CFTypeRef sub_100002980(uint64_t a1)
{
  CFTypeRef result;

  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = qword_100082BF0;
  result = *(CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (result)
    return CFRetain(result);
  return result;
}

uint64_t sub_1000029B4(uint64_t a1, uint64_t a2)
{
  const __CFArray *v4;
  CFTypeRef *v5;
  CFTypeRef *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = (const __CFArray *)sub_10000CFDC(0);
  v5 = (CFTypeRef *)sub_10000CF14(v4);
  v6 = v5;
  if (v5)
    LODWORD(v7) = ((uint64_t (*)(CFTypeRef *, uint64_t))v5[2])(v5, a2);
  else
    LODWORD(v7) = 0;
  if (off_1000827E0((uint64_t)off_1000827D0, a2))
    LODWORD(v7) = v7 | 2;
  if (((BOOL (*)(uint64_t, uint64_t))off_1000827F8[0])((uint64_t)off_1000827E8, a2))
    v7 = v7 | 8;
  else
    v7 = v7;
  v8 = *(_QWORD *)(a1 + 56);
  if (v8)
  {
    if ((*(unsigned int (**)(uint64_t, uint64_t))(v8 + 16))(v8, a2))
      v7 = v7 | 4;
    else
      v7 = v7;
  }
  if (v6)
    sub_1000132E4(v6);
  return v7;
}

BOOL sub_100002A7C(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  CFIndex Count;
  CFIndex v7;
  CFIndex v8;
  BOOL v9;
  unsigned int (**ValueAtIndex)(const void *, _QWORD);
  int v11;
  _QWORD v13[7];
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  char v17;

  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 72));
  if (Count < 1)
  {
    return 0;
  }
  else
  {
    v7 = Count;
    v8 = 0;
    v9 = 1;
    do
    {
      ValueAtIndex = (unsigned int (**)(const void *, _QWORD))CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), v8);
      if (ValueAtIndex[2](ValueAtIndex, a2))
      {
        if (a3)
          *a3 = ValueAtIndex;
        v14 = 0;
        v15 = &v14;
        v16 = 0x2000000000;
        v17 = 0;
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 0x40000000;
        v13[2] = sub_10000DCF0;
        v13[3] = &unk_1000797A8;
        v13[5] = ValueAtIndex;
        v13[6] = a2;
        v13[4] = &v14;
        sub_10000D610(a1, (uint64_t)v13);
        v11 = *((unsigned __int8 *)v15 + 24);
        _Block_object_dispose(&v14, 8);
        if (v11)
          break;
      }
      v9 = ++v8 < v7;
    }
    while (v7 != v8);
  }
  return v9;
}

BOOL sub_100002BA4(uint64_t a1, uint64_t a2)
{
  const __CFData *NormalizedSubjectContent;
  uint64_t v4;
  const void *v5;
  const __CFArray *v6;
  __CFArray *v7;
  const __CFArray *v8;
  int64_t Length;
  const void *BytePtr;
  CFIndex Count;
  CFIndex v12;
  CFIndex v13;
  BOOL v14;
  const __CFData *ValueAtIndex;
  const __CFData *v16;
  CFTypeID v17;
  CFIndex v18;
  const UInt8 *v19;

  NormalizedSubjectContent = (const __CFData *)SecCertificateGetNormalizedSubjectContent(a2);
  v4 = sub_100004464();
  if (v4)
  {
    v5 = (const void *)v4;
    v6 = sub_100002CE4(NormalizedSubjectContent);
    if (v6 && (v7 = sub_100002DF0(v6)) != 0)
    {
      v8 = v7;
      Length = SecCertificateGetLength(a2);
      BytePtr = (const void *)SecCertificateGetBytePtr(a2);
      Count = CFArrayGetCount(v8);
      if (Count < 1)
      {
        v14 = 0;
      }
      else
      {
        v12 = Count;
        v13 = 0;
        v14 = 1;
        do
        {
          ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(v8, v13);
          if (ValueAtIndex)
          {
            v16 = ValueAtIndex;
            v17 = CFGetTypeID(ValueAtIndex);
            if (v17 == CFDataGetTypeID())
            {
              v18 = CFDataGetLength(v16);
              v19 = CFDataGetBytePtr(v16);
              if (Length >= 1 && v18 == Length && !memcmp(BytePtr, v19, Length))
                break;
            }
          }
          v14 = ++v13 < v12;
        }
        while (v12 != v13);
      }
      CFRelease(v8);
    }
    else
    {
      v14 = 0;
    }
    CFRelease(v5);
  }
  else
  {
    return 0;
  }
  return v14;
}

const __CFData *sub_100002CE4(const __CFData *a1)
{
  const __CFData *Value;
  CFTypeRef *v2;
  CFTypeRef *v3;
  const __CFDictionary *v4;
  const UInt8 *BytePtr;
  CC_LONG Length;
  CFDataRef v7;
  _QWORD v9[2];
  int v10;

  Value = a1;
  if (!a1)
    return Value;
  v2 = (CFTypeRef *)sub_100004464();
  if (!v2)
    return 0;
  v3 = v2;
  v4 = (const __CFDictionary *)v2[9];
  if (!v4)
  {
    CFRelease(v2);
    return 0;
  }
  CFRetain(v2[9]);
  CFRelease(v3);
  v9[0] = 0;
  v9[1] = 0;
  v10 = 0;
  BytePtr = CFDataGetBytePtr(Value);
  Length = CFDataGetLength(Value);
  CC_SHA1(BytePtr, Length, (unsigned __int8 *)v9);
  v7 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, (const UInt8 *)v9, 20, kCFAllocatorNull);
  Value = (const __CFData *)CFDictionaryGetValue(v4, v7);
  CFRelease(v4);
  if (v7)
    CFRelease(v7);
  return Value;
}

__CFArray *sub_100002DF0(const __CFArray *a1)
{
  _QWORD *v2;
  const void *v3;
  uint64_t v4;
  CFIndex Count;
  __CFArray *Mutable;
  CFIndex i;
  const __CFNumber *ValueAtIndex;
  CFDataRef v9;
  CFDataRef v10;
  unsigned int valuePtr;

  v2 = (_QWORD *)sub_100004464();
  if (!v2)
    return 0;
  v3 = v2;
  v4 = v2[10];
  if (!v4)
  {
    CFRelease(v2);
    return 0;
  }
  Count = CFArrayGetCount(a1);
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (Count >= 1)
  {
    for (i = 0; i != Count; ++i)
    {
      ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(a1, i);
      valuePtr = 0;
      if (CFNumberGetValue(ValueAtIndex, kCFNumberSInt32Type, &valuePtr))
      {
        v9 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, (const UInt8 *)(v4 + valuePtr + 8), *(int *)(v4 + valuePtr + 4), kCFAllocatorNull);
        if (v9)
        {
          v10 = v9;
          CFArrayAppendValue(Mutable, v9);
          CFRelease(v10);
        }
      }
    }
  }
  CFRelease(v3);
  return Mutable;
}

BOOL sub_100002F10(uint64_t a1, const void *a2)
{
  return CFSetContainsValue(*(CFSetRef *)(a1 + 24), a2) != 0;
}

void sub_100002F30(uint64_t a1)
{
  uint64_t v2;
  unsigned int v3;
  BOOL v4;
  int v5;
  BOOL v6;
  CFIndex Count;
  CFIndex v8;
  CFIndex v9;
  CFDictionaryRef *ValueAtIndex;
  unsigned int v11;
  int v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;
  CFIndex v16;
  const void *v17;
  uint64_t v18;
  uint64_t v19;
  const void *v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const void *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const void *v34;
  const void *v35;
  int v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  const void *v44;
  const void *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  const void *v50;
  const __CFSet *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  const void *v56;
  const void *v57;
  uint64_t v58;
  uint64_t v59;
  const void *v60;
  const __CFSet *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  const void *v66;
  const void *v67;
  uint64_t v68;
  const __CFArray *v69;
  CFIndex v70;
  uint64_t v71;
  uint64_t v72;
  double v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  double v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  const __CFDate *v82;
  double AbsoluteTime;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  const void *v88;
  int v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  BOOL v93;
  uint64_t v94;
  uint64_t v95;
  BOOL v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t *v103;
  double v104;
  char v105;
  uint64_t v106;
  CFIndex v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  _QWORD *v111;
  _QWORD *v112;
  uint64_t CertificatePolicies;
  const __CFArray *CRLDistributionPoints;
  uint64_t BasicConstraints;
  int KeyUsage;
  CFNumberRef v117;
  CFNumberRef v118;
  __CFDictionary *v119;
  __CFDictionary *v120;
  CFNumberRef v121;
  CFNumberRef v122;
  NSObject *v123;
  NSObject *v124;
  const char *v125;
  uint64_t v126;
  uint64_t SHA1Digest;
  const void *v128;
  const __CFArray *v129;
  const __CFArray *v130;
  NSObject *v131;
  NSObject *v132;
  const char *v133;
  uint32_t v134;
  CFNumberRef v135;
  uint64_t v136;
  BOOL v137;
  void **v138;
  _QWORD *v139;
  char v140;
  void **v141;
  uint64_t v142;
  void **v143;
  void **v144;
  uint64_t v145;
  int v146;
  CFNumberRef v147;
  CFNumberRef v148;
  CFNumberRef v149;
  CFNumberRef v150;
  CFDictionaryRef v151;
  char v152;
  NSObject *v153;
  _QWORD *v154;
  NSObject *v155;
  NSObject *v156;
  NSObject *v157;
  const char *v158;
  NSObject *v159;
  NSObject *v160;
  uint32_t v161;
  int v162;
  NSObject *v163;
  __CFDictionary *v164;
  NSObject *v165;
  NSObject *v166;
  NSObject *v167;
  NSObject *v168;
  NSObject *v169;
  NSObject *v170;
  int v171;
  NSObject *v172;
  uint64_t v173;
  void **v174;
  NSObject *v175;
  uint64_t v176;
  uint64_t *v177;
  NSObject *v178;
  _QWORD *v179;
  _QWORD *v180;
  _QWORD *v181;
  unsigned int v182;
  const void *v183;
  _QWORD *i;
  _QWORD *v185;
  _QWORD *v186;
  _QWORD *v187;
  CFMutableArrayRef Mutable;
  int v189;
  CFTypeRef cf1;
  uint64_t v191;
  void *v192;
  _BYTE context[24];
  void *v194;
  CFMutableArrayRef v195;
  void *values[2];
  uint8_t buf[8];
  CFRange v198;
  CFRange v199;
  CFRange v200;

  v2 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  *(_QWORD *)(a1 + 24) = 0;
  sub_100004FE4(a1, kSecPolicyCheckIdLinkage);
  v3 = *(_DWORD *)(a1 + 64);
  v4 = v3 > 7;
  v5 = (1 << v3) & 0xE8;
  v6 = v4 || v5 == 0;
  if (v6 || *(_QWORD *)(a1 + 56))
    sub_100005610((_QWORD *)a1);
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 8));
  v8 = *(_QWORD *)(a1 + 24);
  if (v8 < Count)
  {
    v9 = Count;
    do
    {
      *(_QWORD *)(a1 + 16) = qword_100082DE0;
      ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), v8);
      CFDictionaryApplyFunction(ValueAtIndex[4], (CFDictionaryApplierFunction)sub_1000069C0, (void *)a1);
      v11 = *(_DWORD *)(a1 + 64);
      v4 = v11 > 7;
      v12 = (1 << v11) & 0xE8;
      v13 = v4 || v12 == 0;
      if (!v13 && !*(_QWORD *)(a1 + 56))
        return;
      v8 = *(_QWORD *)(a1 + 24) + 1;
      *(_QWORD *)(a1 + 24) = v8;
    }
    while (v8 < v9);
  }
  v191 = v2;
  *(_QWORD *)(a1 + 24) = 0;
  v14 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v14)
  {
    v15 = *(_QWORD *)(v14 + 16);
    if (v15 >= 1)
    {
      v16 = 0;
      v17 = (const void *)kSecPolicyCheckUsageConstraints;
      do
      {
        v18 = *(_QWORD *)(*(_QWORD *)a1 + 200);
        v19 = *(_QWORD *)(v18 + 8 * v16 + 136);
        if (*(_QWORD *)(v18 + 16) <= v16 || v19 == 0)
          v21 = 0;
        else
          v21 = *(const void **)(v19 + 16);
        v22 = sub_100004760((_QWORD *)a1, v21, *(CFArrayRef *)(v19 + 24));
        if (v22 == 3)
        {
          sub_10000E2C8(a1, v17, v16, kCFBooleanFalse, 1, 0);
        }
        else if (v22 <= 2)
        {
          v23 = *(_DWORD *)(a1 + 64);
          v4 = v23 > 7;
          v24 = (1 << v23) & 0xE8;
          if (v4 || v24 == 0)
          {
            v26 = *(_QWORD *)a1;
            v198.length = CFArrayGetCount(*(CFArrayRef *)(*(_QWORD *)a1 + 72));
            v198.location = 0;
            if (CFArrayContainsValue(*(CFArrayRef *)(v26 + 72), v198, off_1000827E8))
            {
              if (((BOOL (*)(uint64_t, uint64_t))off_1000827F8[0])((uint64_t)off_1000827E8, (uint64_t)v21))
                *(_DWORD *)(a1 + 64) = 1;
            }
          }
        }
        ++v16;
      }
      while (v15 != v16);
    }
  }
  if (qword_100082DF0 != -1)
    dispatch_once(&qword_100082DF0, &stru_100077D78);
  v27 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v27)
  {
    v28 = *(_QWORD *)(v27 + 16);
    if (v28 >= 1)
    {
      v29 = (const void *)kSecPolicyCheckBlackListedKey;
      v30 = v28 + 15;
      do
      {
        v31 = *(_QWORD *)(*(_QWORD *)a1 + 200);
        if (v31 && *(_QWORD *)(v31 + 16) >= v28 && (v32 = *(_QWORD *)(v31 + 8 * (v28 - 1) + 136)) != 0)
          v33 = *(_QWORD *)(v32 + 16);
        else
          v33 = 0;
        v34 = (const void *)SecCertificateCopySHA256Digest(v33);
        if (v34)
        {
          v35 = v34;
          v36 = CFSetContainsValue((CFSetRef)qword_100082DE8, v34);
          v37 = 0;
          if ((unint64_t)v28 >= 2 && v36)
          {
            v38 = v30;
            while (1)
            {
              v39 = v38 - 17;
              v40 = *(_QWORD *)(*(_QWORD *)a1 + 200);
              if (v40)
              {
                if ((v39 & 0x8000000000000000) == 0 && *(_QWORD *)(v40 + 16) > v39)
                {
                  v41 = *(_QWORD *)(v40 + 8 * v38);
                  if (v41)
                  {
                    v42 = *(_QWORD *)(v41 + 16);
                    if (v42)
                    {
                      if (SecCertificateNotValidBefore(v42) >= 502243200.0)
                        break;
                    }
                  }
                }
              }
              --v38;
              if (v39 <= 0)
              {
                v37 = 0;
                goto LABEL_58;
              }
            }
            v37 = 1;
            sub_10000E2C8(a1, v29, v28 - 1, kCFBooleanFalse, 1, 0);
          }
LABEL_58:
          CFRelease(v35);
        }
        else
        {
          v37 = 0;
        }
        if (v28 < 2)
          break;
        --v30;
        --v28;
      }
      while (!v37);
    }
  }
  if (!v191)
    goto LABEL_110;
  v43 = *(_QWORD *)(v191 + 16);
  if (v43 >= 2)
  {
    v44 = (const void *)kSecPolicyCheckGrayListedKey;
    v45 = (const void *)kSecPolicyCheckBlackListedKey;
    v46 = 1 - v43;
    v47 = 18;
    do
    {
      v48 = v47 - 17;
      v49 = sub_100004464();
      if (v49)
      {
        v50 = (const void *)v49;
        v51 = *(const __CFSet **)(v49 + 24);
        if (v51)
        {
          CFRetain(*(CFTypeRef *)(v49 + 24));
          CFRelease(v50);
          v52 = *(_QWORD *)(*(_QWORD *)a1 + 200);
          if (v52)
          {
            if (*(_QWORD *)(v52 + 16) > v48 && (v53 = *(_QWORD *)(v52 + 8 * v47)) != 0)
              v54 = *(_QWORD *)(v53 + 16);
            else
              v54 = 0;
            v55 = *(_QWORD *)(v52 + 16);
          }
          else
          {
            v54 = 0;
            v55 = 0;
          }
          if (v48 != v55 - 1 || !*(_BYTE *)(v52 + 49))
          {
            v56 = (const void *)SecCertificateCopyPublicKeySHA1Digest(v54);
            if (v56)
            {
              v57 = v56;
              if (CFSetContainsValue(v51, v56))
              {
                v58 = *(_QWORD *)(*(_QWORD *)a1 + 200);
                if (!v58 || !*(_BYTE *)(v58 + 67))
                  sub_10000E2C8(a1, v44, v47 - 17, kCFBooleanFalse, 1, 0);
              }
              CFRelease(v57);
            }
          }
        }
        else
        {
          v51 = (const __CFSet *)v49;
        }
        CFRelease(v51);
      }
      v59 = sub_100004464();
      if (v59)
      {
        v60 = (const void *)v59;
        v61 = *(const __CFSet **)(v59 + 16);
        if (v61)
        {
          CFRetain(*(CFTypeRef *)(v59 + 16));
          CFRelease(v60);
          v62 = *(_QWORD *)(*(_QWORD *)a1 + 200);
          if (v62)
          {
            if (*(_QWORD *)(v62 + 16) > v48 && (v63 = *(_QWORD *)(v62 + 8 * v47)) != 0)
              v64 = *(_QWORD *)(v63 + 16);
            else
              v64 = 0;
            v65 = *(_QWORD *)(v62 + 16);
          }
          else
          {
            v64 = 0;
            v65 = 0;
          }
          if (v48 != v65 - 1 || !*(_BYTE *)(v62 + 49))
          {
            v66 = (const void *)SecCertificateCopyPublicKeySHA1Digest(v64);
            if (v66)
            {
              v67 = v66;
              if (CFSetContainsValue(v61, v66))
              {
                v68 = *(_QWORD *)(*(_QWORD *)a1 + 200);
                if (!v68 || !*(_BYTE *)(v68 + 67))
                  sub_10000E2C8(a1, v45, v47 - 17, kCFBooleanFalse, 1, 0);
              }
              CFRelease(v67);
            }
          }
        }
        else
        {
          v61 = (const __CFSet *)v59;
        }
        CFRelease(v61);
      }
      ++v47;
    }
    while (v46 + v47 != 18);
  }
  if (*(_BYTE *)(v191 + 104))
    goto LABEL_111;
  if (!*(_BYTE *)(*(_QWORD *)(v191 + 136) + 40))
  {
LABEL_110:
    sub_1000073F8((uint64_t *)a1);
    goto LABEL_111;
  }
  v189 = *(_DWORD *)(a1 + 64);
  v69 = *(const __CFArray **)(a1 + 56);
  if (v69)
  {
    v70 = CFArrayGetCount(*(CFArrayRef *)(a1 + 56));
    *(_QWORD *)context = _NSConcreteStackBlock;
    *(_QWORD *)&context[8] = 0x40000000;
    *(_QWORD *)&context[16] = sub_100045F80;
    v194 = &unk_100077DD8;
    Mutable = CFArrayCreateMutable(0, v70, &kCFTypeArrayCallBacks);
    v195 = Mutable;
    v199.length = CFArrayGetCount(v69);
    v199.location = 0;
    CFArrayApplyFunction(v69, v199, (CFArrayApplierFunction)sub_100045B9C, context);
  }
  else
  {
    Mutable = 0;
  }
  v97 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (!v97)
    goto LABEL_346;
  v98 = *(_QWORD *)(v97 + 16);
  v192 = 0;
  if (!v98)
    goto LABEL_346;
  cf1 = (CFTypeRef)kSecPolicyCheckExtendedValidation;
  if (v98 >= 1 && (v99 = *(_QWORD *)(v97 + 136)) != 0)
    v100 = *(_QWORD *)(v99 + 16);
  else
    v100 = 0;
  v104 = SecCertificateNotValidBefore(v100);
  if (v98 > 2 || v104 <= 489024000.0)
  {
    if (v98 < 1)
      goto LABEL_346;
  }
  else
  {
    v105 = sub_10000E2C8(a1, cf1, 0, kCFBooleanFalse, 1, 0);
    if (v98 < 1 || (v105 & 1) != 0)
      goto LABEL_346;
  }
  v106 = 0;
  v107 = 0;
  while (1)
  {
    v108 = *(_QWORD *)(*(_QWORD *)a1 + 200);
    if (v108 && *(_QWORD *)(v108 + 16) > v107 && (v109 = *(_QWORD *)(v108 + 8 * v107 + 136)) != 0)
      v110 = *(_QWORD *)(v109 + 16);
    else
      v110 = 0;
    v111 = sub_10001E1FC();
    v112 = v111;
    if (!v107)
    {
      if (!v111)
      {
LABEL_222:
        v192 = v112;
        if (!v112)
          goto LABEL_290;
        goto LABEL_294;
      }
      v126 = (uint64_t)v111;
      while (!DEROidCompare(v126, (uint64_t)&oidAnyPolicy))
      {
        v126 = *(_QWORD *)(v126 + 16);
        if (!v126)
          goto LABEL_222;
      }
      goto LABEL_287;
    }
    if (v107 >= v98 - 1)
      break;
    CertificatePolicies = SecCertificateGetCertificatePolicies(v110);
    if (!CertificatePolicies || !*(_QWORD *)(CertificatePolicies + 8))
    {
      v156 = sub_100011628("ev");
      if (!os_log_type_enabled(v156, OS_LOG_TYPE_DEFAULT))
        goto LABEL_315;
      *(_WORD *)context = 0;
      v157 = v156;
      v158 = "SubCA missing certificate policies";
      goto LABEL_302;
    }
    CRLDistributionPoints = (const __CFArray *)SecCertificateGetCRLDistributionPoints(v110);
    if (!CRLDistributionPoints || CFArrayGetCount(CRLDistributionPoints) <= 0)
    {
      v159 = sub_100011628("ev");
      if (!os_log_type_enabled(v159, OS_LOG_TYPE_DEFAULT))
        goto LABEL_315;
      *(_WORD *)context = 0;
      v157 = v159;
      v158 = "SubCA missing CRLDP";
      goto LABEL_302;
    }
    BasicConstraints = SecCertificateGetBasicConstraints(v110);
    if (!BasicConstraints || !*(_BYTE *)(BasicConstraints + 2))
    {
      v160 = sub_100011628("ev");
      if (!os_log_type_enabled(v160, OS_LOG_TYPE_DEFAULT))
        goto LABEL_315;
      *(_WORD *)context = 0;
      v157 = v160;
      v158 = "SubCA has invalid basic constraints";
LABEL_302:
      v161 = 2;
LABEL_303:
      _os_log_impl((void *)&_mh_execute_header, v157, OS_LOG_TYPE_DEFAULT, v158, context, v161);
      goto LABEL_315;
    }
    KeyUsage = SecCertificateGetKeyUsage(v110);
    if ((~KeyUsage & 0x60) == 0)
    {
      *(_QWORD *)context = 256;
      v117 = CFNumberCreate(0, kCFNumberCFIndexType, context);
      if (!v117)
        goto LABEL_315;
      v118 = v117;
      v119 = CFDictionaryCreateMutable(0, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (!v119)
      {
        v164 = v118;
        goto LABEL_314;
      }
      v120 = v119;
      CFDictionaryAddValue(v119, kSecAttrKeyTypeEC, v118);
      if (SecCertificateNotValidBefore(v110) >= 315532800.0 && SecCertificateNotValidAfter(v110) >= 410227200.0)
      {
        *(_QWORD *)context = 2048;
        v135 = CFNumberCreate(0, kCFNumberCFIndexType, context);
        if (!v135)
          goto LABEL_313;
        v122 = v135;
        CFDictionaryAddValue(v120, kSecAttrKeyTypeRSA, v135);
        if ((SecCertificateIsAtLeastMinKeySize(v110, v120) & 1) != 0)
          goto LABEL_235;
        v166 = sub_100011628("ev");
        if (!os_log_type_enabled(v166, OS_LOG_TYPE_DEFAULT))
          goto LABEL_312;
        *(_WORD *)context = 0;
        v124 = v166;
        v125 = "SubCA's public key is too small for issuance after 2010 or expiration after 2013";
      }
      else
      {
        *(_QWORD *)context = 1024;
        v121 = CFNumberCreate(0, kCFNumberCFIndexType, context);
        if (!v121)
          goto LABEL_313;
        v122 = v121;
        CFDictionaryAddValue(v120, kSecAttrKeyTypeRSA, v121);
        if ((SecCertificateIsAtLeastMinKeySize(v110, v120) & 1) == 0)
        {
          v123 = sub_100011628("ev");
          if (os_log_type_enabled(v123, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)context = 0;
            v124 = v123;
            v125 = "SubCA's public key is too small for issuance before 2011 or expiration before 2014";
            goto LABEL_311;
          }
LABEL_312:
          CFRelease(v122);
LABEL_313:
          CFRelease(v118);
          v164 = v120;
LABEL_314:
          CFRelease(v164);
          goto LABEL_315;
        }
LABEL_235:
        if (SecCertificateNotValidBefore(v110) <= 473299200.0
          || SecCertificateGetSignatureHashAlgorithm(v110) > 4)
        {
          CFRelease(v122);
          CFRelease(v118);
          CFRelease(v120);
          goto LABEL_238;
        }
        v165 = sub_100011628("ev");
        if (!os_log_type_enabled(v165, OS_LOG_TYPE_DEFAULT))
          goto LABEL_312;
        *(_WORD *)context = 0;
        v124 = v165;
        v125 = "SubCA was issued with SHA-1 after 2015";
      }
LABEL_311:
      _os_log_impl((void *)&_mh_execute_header, v124, OS_LOG_TYPE_DEFAULT, v125, context, 2u);
      goto LABEL_312;
    }
    v162 = KeyUsage;
    v163 = sub_100011628("ev");
    if (os_log_type_enabled(v163, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)context = 67109120;
      *(_DWORD *)&context[4] = v162;
      v157 = v163;
      v158 = "SubCA has invalid key usage %u";
      v161 = 8;
      goto LABEL_303;
    }
LABEL_315:
    v167 = sub_100011628("ev");
    if (os_log_type_enabled(v167, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)context = 0;
      _os_log_impl((void *)&_mh_execute_header, v167, OS_LOG_TYPE_DEFAULT, "subordinate certificate is not ev", context, 2u);
    }
    if (sub_10000E2C8(a1, cf1, v107, kCFBooleanFalse, 1, 0))
    {
      v186 = v192;
      if (v192)
      {
        do
        {
          v187 = (_QWORD *)v186[2];
          free(v186);
          v186 = v187;
        }
        while (v187);
      }
      goto LABEL_344;
    }
LABEL_238:
    if (v112)
    {
      v136 = (uint64_t)v112;
      do
      {
        v137 = DEROidCompare(v136, (uint64_t)&oidAnyPolicy);
        if (v137)
          break;
        v136 = *(_QWORD *)(v136 + 16);
      }
      while (v136);
    }
    else
    {
      v137 = 0;
    }
    v138 = (void **)v192;
    if (!v192)
      goto LABEL_287;
    v139 = v192;
    while (!DEROidCompare((uint64_t)v139, (uint64_t)&oidAnyPolicy))
    {
      v139 = (_QWORD *)v139[2];
      if (!v139)
      {
        if (v138)
          v140 = v137;
        else
          v140 = 1;
        if ((v140 & 1) == 0)
        {
          v141 = &v192;
          do
          {
            if (v112)
            {
              v142 = (uint64_t)v112;
              while (!DEROidCompare(v142, (uint64_t)v138))
              {
                v142 = *(_QWORD *)(v142 + 16);
                if (!v142)
                  goto LABEL_257;
              }
              v141 = v138 + 2;
            }
            else
            {
LABEL_257:
              *v141 = v138[2];
              v138[2] = 0;
              do
              {
                v143 = (void **)v138[2];
                free(v138);
                v138 = v143;
              }
              while (v143);
            }
            v138 = (void **)*v141;
          }
          while (*v141);
        }
        goto LABEL_287;
      }
    }
    if (!v137)
    {
      do
      {
        v144 = (void **)v138[2];
        free(v138);
        v138 = v144;
      }
      while (v144);
      v192 = 0;
      if (v112)
      {
        for (i = 0; ; i = v185)
        {
          v185 = malloc_type_malloc(0x18uLL, 0x1030040D5FA72FAuLL);
          v185[2] = i;
          *(_OWORD *)v185 = *(_OWORD *)v112;
        }
      }
      goto LABEL_290;
    }
    if (v112)
    {
      while (1)
      {
        if (v138)
        {
          v173 = (uint64_t)v138;
          while (!DEROidCompare(v173, (uint64_t)v112))
          {
            v173 = *(_QWORD *)(v173 + 16);
            if (!v173)
              goto LABEL_333;
          }
        }
        else
        {
LABEL_333:
          v174 = (void **)malloc_type_malloc(0x18uLL, 0x1030040D5FA72FAuLL);
          v174[2] = v138;
          *(_OWORD *)v174 = *(_OWORD *)v112;
          v138 = v174;
        }
      }
    }
LABEL_289:
    v112 = v192;
    if (!v192)
    {
LABEL_290:
      v155 = sub_100011628("ev");
      if (os_log_type_enabled(v155, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)context = 0;
        _os_log_impl((void *)&_mh_execute_header, v155, OS_LOG_TYPE_DEFAULT, "valid_policies set is empty: chain not ev", context, 2u);
      }
      if ((sub_10000E2C8(a1, cf1, v107, kCFBooleanFalse, 1, 0) & 1) != 0)
        goto LABEL_346;
      v112 = 0;
    }
LABEL_294:
    ++v107;
    v106 = (uint64_t)v112;
    if (v107 == v98)
      goto LABEL_344;
  }
  SHA1Digest = SecCertificateGetSHA1Digest(v110);
  if (!v106)
  {
LABEL_229:
    v131 = sub_100011628("ev");
    if (!os_log_type_enabled(v131, OS_LOG_TYPE_DEFAULT))
      goto LABEL_284;
    *(_WORD *)buf = 0;
    v132 = v131;
    v133 = "anchor not in plist";
    goto LABEL_231;
  }
  v128 = (const void *)SHA1Digest;
  while (1)
  {
    v129 = (const __CFArray *)sub_10001083C(v106);
    if (v129)
    {
      v130 = v129;
      v200.length = CFArrayGetCount(v129);
      v200.location = 0;
      if (CFArrayContainsValue(v130, v200, v128))
        break;
    }
    v106 = *(_QWORD *)(v106 + 16);
    if (!v106)
      goto LABEL_229;
  }
  if (SecCertificateNotValidBefore(v110) >= 178761600.0 && SecCertificateVersion(v110) <= 2)
  {
    v169 = sub_100011628("ev");
    if (!os_log_type_enabled(v169, OS_LOG_TYPE_DEFAULT))
      goto LABEL_284;
    *(_WORD *)buf = 0;
    v132 = v169;
    v133 = "Anchor issued after October 2006 and is not v3";
    goto LABEL_231;
  }
  if (SecCertificateVersion(v110) < 3 || SecCertificateNotValidBefore(v110) < 178761600.0)
  {
LABEL_276:
    *(_QWORD *)buf = 2048;
    v147 = CFNumberCreate(0, kCFNumberCFIndexType, buf);
    if (!v147)
      goto LABEL_284;
    v148 = v147;
    *(_QWORD *)buf = 256;
    v149 = CFNumberCreate(0, kCFNumberCFIndexType, buf);
    if (!v149)
    {
      CFRelease(v148);
      goto LABEL_284;
    }
    v150 = v149;
    *(_QWORD *)context = kSecAttrKeyTypeRSA;
    *(_QWORD *)&context[8] = kSecAttrKeyTypeEC;
    values[0] = v148;
    values[1] = v149;
    v151 = CFDictionaryCreate(0, (const void **)context, (const void **)values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (v151)
    {
      if ((SecCertificateIsAtLeastMinKeySize(v110, v151) & 1) != 0)
      {
        v152 = 1;
        goto LABEL_281;
      }
      v168 = sub_100011628("ev");
      v152 = 0;
      if (!os_log_type_enabled(v168, OS_LOG_TYPE_DEFAULT))
      {
LABEL_281:
        CFRelease(v148);
        CFRelease(v150);
        if (v151)
          CFRelease(v151);
        if ((v152 & 1) == 0)
          goto LABEL_284;
        goto LABEL_287;
      }
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v168, OS_LOG_TYPE_DEFAULT, "Anchor's public key is too weak for EV", buf, 2u);
    }
    v152 = 0;
    goto LABEL_281;
  }
  v145 = SecCertificateGetBasicConstraints(v110);
  if (!v145 || !*(_BYTE *)(v145 + 2))
  {
    v170 = sub_100011628("ev");
    if (!os_log_type_enabled(v170, OS_LOG_TYPE_DEFAULT))
      goto LABEL_284;
    *(_WORD *)buf = 0;
    v132 = v170;
    v133 = "Anchor has invalid basic constraints";
LABEL_231:
    v134 = 2;
    goto LABEL_232;
  }
  v146 = SecCertificateGetKeyUsage(v110);
  if ((~v146 & 0x60) == 0)
    goto LABEL_276;
  v171 = v146;
  v172 = sub_100011628("ev");
  if (os_log_type_enabled(v172, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v171;
    v132 = v172;
    v133 = "Anchor has invalid key usage %u";
    v134 = 8;
LABEL_232:
    _os_log_impl((void *)&_mh_execute_header, v132, OS_LOG_TYPE_DEFAULT, v133, buf, v134);
  }
LABEL_284:
  v153 = sub_100011628("ev");
  if (os_log_type_enabled(v153, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)context = 0;
    _os_log_impl((void *)&_mh_execute_header, v153, OS_LOG_TYPE_DEFAULT, "anchor certificate is not ev", context, 2u);
  }
  if (!sub_10000E2C8(a1, cf1, v107, kCFBooleanFalse, 1, 0))
  {
LABEL_287:
    if (v112)
    {
      do
      {
        v154 = (_QWORD *)v112[2];
        free(v112);
        v112 = v154;
      }
      while (v154);
    }
    goto LABEL_289;
  }
  v179 = v192;
  if (v192)
  {
    do
    {
      v180 = (_QWORD *)v179[2];
      free(v179);
      v179 = v180;
    }
    while (v180);
  }
LABEL_344:
  if (v112)
  {
    do
    {
      v181 = (_QWORD *)v112[2];
      free(v112);
      v112 = v181;
    }
    while (v181);
  }
LABEL_346:
  v182 = (*(_DWORD *)(a1 + 64) > 7u) | (0x17u >> *(_DWORD *)(a1 + 64));
  *(_DWORD *)(a1 + 64) = v189;
  v183 = *(const void **)(a1 + 56);
  if (v183)
    CFRelease(v183);
  *(_QWORD *)(a1 + 56) = Mutable;
  sub_1000073F8((uint64_t *)a1);
  if ((v182 & 1) != 0
    && (*(_BYTE *)(v191 + 66) || sub_100005508((uint64_t)CFSTR("CTKillSwitch")) || !sub_10000C0C0(5184000.0)))
  {
    *(_BYTE *)(v191 + 65) = 1;
  }
LABEL_111:
  v71 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  *(_BYTE *)(v71 + 104) = 1;
  if (sub_100006740(a1))
  {
    v72 = *(_QWORD *)(v71 + 16);
    v73 = *(double *)(v71 + 128);
    if (v73 <= 0.0)
    {
      v74 = *(_QWORD *)(*(_QWORD *)a1 + 200);
      if (v74 && *(uint64_t *)(v74 + 16) >= 1 && (v75 = *(_QWORD *)(v74 + 136)) != 0)
        v76 = *(_QWORD *)(v75 + 16);
      else
        v76 = 0;
      v73 = SecCertificateNotValidBefore(v76);
    }
    if (v72 >= 1)
    {
      v77 = 0;
      v78 = 3.15569088e10;
      v79 = 24;
      while (1)
      {
        if (*(_QWORD *)(v71 + 88) > v77)
        {
          v80 = *(_QWORD *)(v71 + 80);
          if (v80)
          {
            v81 = *(_QWORD *)(v80 + v79);
            if (v81)
            {
              if (*(_BYTE *)(v81 + 56))
              {
                v82 = *(const __CFDate **)(v81 + 72);
                if (v82)
                {
                  AbsoluteTime = CFDateGetAbsoluteTime(v82);
                  if (AbsoluteTime < v78)
                    v78 = AbsoluteTime;
                  if (v73 > v78)
                    break;
                }
              }
            }
          }
        }
        ++v77;
        v79 += 40;
        if (v72 == v77)
          goto LABEL_130;
      }
      v177 = (uint64_t *)(v80 + 40 * v77);
      v178 = sub_100011628("rvc");
      if (os_log_type_enabled(v178, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)context = 134218240;
        *(double *)&context[4] = v73;
        *(_WORD *)&context[12] = 2048;
        *(double *)&context[14] = v78;
        _os_log_impl((void *)&_mh_execute_header, v178, OS_LOG_TYPE_DEFAULT, "certificate issuance time (%f) is later than allowed value (%f)", context, 0x16u);
      }
      sub_100051494(v177);
    }
  }
LABEL_130:
  if (!*(_BYTE *)(v71 + 66))
  {
    v87 = *(_QWORD *)(v71 + 120);
    if (v87 >= 1 && sub_100006740(a1))
    {
      v88 = *(const void **)(*(_QWORD *)a1 + 112);
      if (v88)
        CFRetain(*(CFTypeRef *)(*(_QWORD *)a1 + 112));
      if (sub_100005508((uint64_t)CFSTR("CTKillSwitch")))
      {
LABEL_146:
        if (v88)
          CFRelease(v88);
      }
      else if (sub_10000C0C0(5184000.0) || v88)
      {
        if (v87 == 1)
          v89 = 0;
        else
          v89 = 6;
        sub_10000E2C8(a1, kSecPolicyCheckCTRequired, 0, kCFBooleanFalse, 1, v89);
        goto LABEL_146;
      }
    }
  }
  sub_1000050D0(a1);
  v84 = *(_QWORD *)a1;
  v85 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v85)
  {
    if (*(_BYTE *)(v85 + 105))
    {
      v86 = *(_QWORD *)(v85 + 112);
      if (v86 < 0)
        return;
LABEL_183:
      if (*(_QWORD *)(v85 + 88) <= v86)
        v103 = 0;
      else
        v103 = (uint64_t *)(*(_QWORD *)(v85 + 80) + 40 * v86);
      sub_100051494(v103);
    }
    else
    {
      v90 = *(_QWORD *)(v85 + 16);
      v86 = v90 - 1;
      if (v90 >= 1)
      {
        v91 = *(_QWORD *)(v85 + 88);
        if (v91 >= v90)
          v92 = *(_QWORD *)(v85 + 80) + 40 * v86;
        else
          v92 = 0;
        v93 = 0;
        v94 = 40 * v90 - 80;
        if (v92)
          goto LABEL_153;
LABEL_165:
        while (v86)
        {
          while (1)
          {
            v92 = v91 >= v86 ? *(_QWORD *)(v85 + 80) + v94 : 0;
            v94 -= 40;
            --v86;
            if (!v92)
              break;
LABEL_153:
            v95 = *(_QWORD *)(v92 + 24);
            if (v93)
            {
              if (v95)
              {
LABEL_157:
                v93 = *(_BYTE *)(v95 + 52) != 0;
                if (*(_BYTE *)(v95 + 52))
                  v96 = v86 == 0;
                else
                  v96 = 0;
                if (!v96)
                  goto LABEL_165;
                v101 = *(_QWORD *)(v85 + 136);
                if (!v101)
                  goto LABEL_181;
                v102 = *(_QWORD *)(v101 + 16);
                if (!v102
                  || !SecCertificateIsCA(*(_QWORD *)(v101 + 16))
                  || (sub_100051274(v102) & 1) != 0)
                {
                  goto LABEL_181;
                }
                v86 = 0;
              }
              else
              {
                ++v86;
              }
              v175 = sub_100011628("validupdate");
              if (os_log_type_enabled(v175, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)context = 134217984;
                *(_QWORD *)&context[4] = v86;
                _os_log_impl((void *)&_mh_execute_header, v175, OS_LOG_TYPE_DEFAULT, "CA at index %ld violates known-intermediate constraint", context, 0xCu);
              }
              if (v84)
              {
                v176 = *(_QWORD *)(v84 + 272);
                if (v176)
                  *(_BYTE *)(v176 + 74) = 1;
              }
              goto LABEL_182;
            }
            if (v95)
              goto LABEL_157;
            v93 = 0;
            if (!v86)
              goto LABEL_181;
          }
        }
LABEL_181:
        v86 = -1;
      }
LABEL_182:
      *(_QWORD *)(v85 + 112) = v86;
      *(_BYTE *)(v85 + 105) = 1;
      if ((v86 & 0x8000000000000000) == 0)
        goto LABEL_183;
    }
  }
}

uint64_t sub_100004464()
{
  uint64_t v0;
  _QWORD block[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v6 = 0;
  if (qword_100082BE8 != -1)
    dispatch_once(&qword_100082BE8, &stru_100076500);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100002980;
  block[3] = &unk_100077360;
  block[4] = &v3;
  dispatch_sync((dispatch_queue_t)qword_100082BC8, block);
  v0 = v4[3];
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t sub_100004520(const __CFString *a1, CFTypeRef *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  CFTypeID v7;
  CFIndex Count;
  uint64_t v9;
  unint64_t v10;
  const void *ValueAtIndex;
  CFIndex Length;
  uint64_t v14;
  uint64_t v15;
  double AbsoluteTime;
  uint64_t v17;
  int64_t v18;
  int64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  int v23;
  int v24;

  if (!a1)
  {
    sub_10002A5E8(-5, CFSTR("com.apple.security.cfder.error"), a3, a2, a5, CFSTR("Null CFType"));
    return 0;
  }
  v7 = CFGetTypeID(a1);
  if (CFArrayGetTypeID() != v7)
  {
    if (CFBooleanGetTypeID() == v7)
      return ccder_sizeof(1, 1);
    if (CFDataGetTypeID() == v7)
    {
      Length = CFDataGetLength((CFDataRef)a1);
      return ccder_sizeof_raw_octet_string(Length);
    }
    if (CFDateGetTypeID() == v7)
    {
      AbsoluteTime = CFDateGetAbsoluteTime((CFDateRef)a1);
      v23 = -1431655766;
      v24 = -1431655766;
      v22 = 0xAAAAAAAAAAAAAAAALL;
      v17 = __dtoa(0, 0, &v24, &v23, &v22, AbsoluteTime);
      v18 = v22 - v17;
      __freedtoa();
      v19 = v18 - v24;
      if (v18 < v24)
        v19 = 0;
      if (v19)
        v15 = v19 + 16;
      else
        v15 = 15;
      v14 = 24;
      return ccder_sizeof(v14, v15);
    }
    if (CFDictionaryGetTypeID() == v7)
      return sub_1000055B0((const __CFDictionary *)a1, (uint64_t)a2);
    if (CFSetGetTypeID() == v7)
      return sub_10002B1AC((const __CFSet *)a1, (uint64_t)a2);
    if (CFStringGetTypeID() == v7)
      return sub_10000BC30(a1);
    if (CFNumberGetTypeID() == v7)
      return sub_10002A124((const __CFNumber *)a1, a2);
    if (CFNullGetTypeID() == v7)
      return ccder_sizeof(5, 0);
    sub_10002A5E8(-5, CFSTR("com.apple.security.cfder.error"), v20, a2, v21, CFSTR("Unsupported CFType"));
    return 0;
  }
  Count = CFArrayGetCount((CFArrayRef)a1);
  if (Count < 1)
  {
    v9 = 0;
  }
  else
  {
    v9 = 0;
    v10 = Count + 1;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, v10 - 2);
      v9 += sub_100004520(ValueAtIndex, a2);
      --v10;
    }
    while (v10 > 1);
  }
  v14 = 0x2000000000000010;
  v15 = v9;
  return ccder_sizeof(v14, v15);
}

uint64_t sub_100004760(_QWORD *a1, const void *a2, CFArrayRef theArray)
{
  CFIndex Count;
  CFIndex v7;
  CFIndex v8;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v10;
  CFTypeID v11;
  const __CFNumber *Value;
  const __CFNumber *v13;
  CFTypeID v14;
  unsigned int valuePtr;

  Count = CFArrayGetCount(theArray);
  if (Count < 1)
    return 0;
  v7 = Count;
  v8 = 0;
  while (1)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v8);
    if (ValueAtIndex)
    {
      v10 = ValueAtIndex;
      v11 = CFGetTypeID(ValueAtIndex);
      if (v11 == CFDictionaryGetTypeID())
      {
        Value = (const __CFNumber *)CFDictionaryGetValue(v10, CFSTR("kSecTrustSettingsResult"));
        valuePtr = 0;
        if (!Value
          || (v13 = Value, v14 = CFGetTypeID(Value), v14 != CFNumberGetTypeID())
          || !CFNumberGetValue(v13, kCFNumberSInt32Type, &valuePtr))
        {
          valuePtr = 1;
        }
        if ((sub_1000049C4(a1, a2, v10) & 1) != 0)
          break;
      }
    }
    if (v7 == ++v8)
      return 0;
  }
  return valuePtr;
}

BOOL sub_100004868(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = SecTrustStoreForDomain(2);
  return SecTrustStoreContains(v3, a2) != 0;
}

uint64_t sub_10000489C(CFTypeRef cf2, __CFString **a2)
{
  if (!cf2)
  {
    sub_100012C88(-50, a2, CFSTR("unknown domain: %@"), 0);
    return 0;
  }
  if (CFEqual(CFSTR("user"), cf2))
  {
    if (qword_100082F08 != -1)
      dispatch_once(&qword_100082F08, &stru_100079930);
    return qword_100082F10;
  }
  if (CFEqual(CFSTR("admin"), cf2))
  {
    if (qword_100082F18 != -1)
      dispatch_once(&qword_100082F18, &stru_100079970);
    return qword_100082F20;
  }
  if (!CFEqual(CFSTR("system"), cf2))
  {
    sub_100012C88(-50, a2, CFSTR("unknown domain: %@"), cf2);
    return 0;
  }
  if (qword_100082F28 != -1)
    dispatch_once(&qword_100082F28, &stru_1000799B0);
  return qword_100082F30;
}

uint64_t sub_1000049C4(_QWORD *a1, const void *a2, CFDictionaryRef theDict)
{
  unint64_t Value;
  unint64_t v6;
  const __CFString *v7;
  const void *v8;
  const void *v9;
  int v10;
  CFIndex v11;
  CFTypeID v12;
  CFIndex Length;
  const __CFAllocator *v14;
  int v15;
  CFIndex v16;
  CFIndex v17;
  CFStringRef Copy;
  const __CFString *v19;
  CFDictionaryRef *ValueAtIndex;
  const __CFString *v21;
  const __CFArray *v22;
  const __CFArray *v23;
  CFTypeID v24;
  _BOOL4 v25;
  CFTypeID v26;
  unint64_t v27;
  uint64_t v28;
  NSObject *v29;
  int v30;
  int v31;
  unsigned int v32;
  int v34;
  uint64_t v35;
  const __CFDictionary **v36;
  CFIndex Count;
  CFIndex v38;
  CFIndex i;
  const __CFDictionary **v40;
  unint64_t v41;
  int v43;
  CFIndex v44;
  uint8_t valuePtr[16];
  CFRange v46;
  CFRange v47;

  Value = (unint64_t)CFDictionaryGetValue(theDict, CFSTR("kSecTrustSettingsPolicy"));
  v6 = (unint64_t)CFDictionaryGetValue(theDict, CFSTR("kSecTrustSettingsPolicyName"));
  v7 = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("kSecTrustSettingsPolicyString"));
  v8 = CFDictionaryGetValue(theDict, CFSTR("kSecTrustSettingsKeyUsage"));
  v9 = CFDictionaryGetValue(theDict, CFSTR("kSecTrustSettingsPolicyOptions"));
  v44 = -1;
  v10 = sub_100004E10((uint64_t)a1, (CFTypeRef)Value, (CFTypeRef)v6, &v44);
  v11 = v44;
  v43 = v10;
  if (v7)
  {
    v12 = CFGetTypeID(v7);
    if (v12 != CFStringGetTypeID())
    {
      v15 = 0;
LABEL_22:
      v11 = v44;
      goto LABEL_23;
    }
    Length = CFStringGetLength(v7);
    if (CFStringGetCharacterAtIndex(v7, Length - 1))
    {
      v14 = 0;
    }
    else
    {
      v16 = CFStringGetLength(v7);
      v17 = CFStringGetLength(v7);
      v14 = kCFAllocatorDefault;
      if (v17 >= v16)
      {
        v47.length = v16 - 1;
        v47.location = 0;
        Copy = CFStringCreateWithSubstring(kCFAllocatorDefault, v7, v47);
LABEL_9:
        v19 = Copy;
        if (v11 < 0 || !Copy)
        {
          v15 = 0;
          if (!Copy)
            goto LABEL_22;
          goto LABEL_21;
        }
        if (CFArrayGetCount((CFArrayRef)a1[1]) <= v11)
          goto LABEL_20;
        ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex((CFArrayRef)a1[1], v11);
        v21 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex[4], kSecPolicyCheckSSLHostname);
        if (v21 || (v21 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex[4], kSecPolicyCheckEmail)) != 0)
        {
          v15 = 1;
          if (CFStringCompare(v19, v21, 1uLL) == kCFCompareEqualTo)
            goto LABEL_21;
        }
        v22 = (const __CFArray *)CFDictionaryGetValue(ValueAtIndex[4], kSecPolicyCheckEAPTrustedServerNames);
        if (v22
          && (v23 = v22, v46.length = CFArrayGetCount(v22), v46.location = 0, CFArrayContainsValue(v23, v46, v19)))
        {
          v15 = 1;
        }
        else
        {
LABEL_20:
          v15 = 0;
        }
LABEL_21:
        CFRelease(v19);
        goto LABEL_22;
      }
    }
    Copy = CFStringCreateCopy(v14, v7);
    goto LABEL_9;
  }
  v15 = 0;
LABEL_23:
  *(_QWORD *)valuePtr = 0;
  if (!v8)
    goto LABEL_27;
  v24 = CFGetTypeID(v8);
  if (v24 != CFNumberGetTypeID() || !CFNumberGetValue((CFNumberRef)v8, kCFNumberSInt64Type, valuePtr))
  {
    v25 = 0;
    if (!v9)
      goto LABEL_32;
    goto LABEL_30;
  }
  if (*(_QWORD *)valuePtr == 0xFFFFFFFFLL)
  {
LABEL_27:
    v25 = 1;
    if (!v9)
      goto LABEL_32;
    goto LABEL_30;
  }
  v41 = Value;
  if (sub_100004E10((uint64_t)a1, kSecPolicyAppleOCSPSigner, 0, 0))
    v34 = 16;
  else
    v34 = 0;
  v35 = *(_QWORD *)(*a1 + 200);
  if (v35 && sub_100011848(v35, a2))
    v34 |= 8u;
  if (v11 < 0 || CFArrayGetCount((CFArrayRef)a1[1]) <= v11)
  {
    Count = CFArrayGetCount((CFArrayRef)a1[1]);
    if (Count >= 1)
    {
      v38 = Count;
      for (i = 0; i != v38; ++i)
      {
        v40 = (const __CFDictionary **)CFArrayGetValueAtIndex((CFArrayRef)a1[1], i);
        v34 |= sub_1000458FC(v40[4]);
      }
    }
  }
  else
  {
    v36 = (const __CFDictionary **)CFArrayGetValueAtIndex((CFArrayRef)a1[1], v11);
    v34 |= sub_1000458FC(v36[4]);
  }
  v25 = v34 == *(_DWORD *)valuePtr;
  Value = v41;
  if (v9)
  {
LABEL_30:
    v26 = CFGetTypeID(v9);
    if (v26 == CFDictionaryGetTypeID())
    {
      v27 = Value;
      v28 = a1[2];
      a1[2] = qword_100082DD8;
      CFDictionaryApplyFunction((CFDictionaryRef)v9, (CFDictionaryApplierFunction)sub_1000069C0, a1);
      a1[2] = qword_100082DE0;
      CFDictionaryApplyFunction((CFDictionaryRef)v9, (CFDictionaryApplierFunction)sub_1000069C0, a1);
      a1[2] = v28;
      Value = v27;
    }
  }
LABEL_32:
  if (CFDictionaryContainsKey(theDict, CFSTR("kSecTrustSettingsApplication")))
  {
    v29 = sub_100011628("SecError");
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)valuePtr = 0;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "kSecTrustSettingsApplication is not yet supported on this platform", valuePtr, 2u);
    }
  }
  v30 = v43;
  if (!(Value | v6))
    v30 = 1;
  if (v7)
    v31 = v15;
  else
    v31 = 1;
  v32 = v30 & v31 & v25;
  if (v9)
    return 0;
  else
    return v32;
}

uint64_t sub_100004E10(uint64_t a1, CFTypeRef cf, CFTypeRef a3, CFIndex *a4)
{
  CFTypeID v8;
  CFTypeID v9;
  const __CFArray *v10;
  CFIndex Count;
  CFIndex v12;
  CFIndex v13;
  _BOOL4 v14;
  _BOOL4 v15;
  _BOOL4 v16;
  const void *v17;
  const void *ValueAtIndex;
  const void *Name;
  const void *OidString;
  const void *v21;
  _BOOL4 v22;
  _BOOL4 v24;
  CFTypeRef v25;
  const void *v26;
  int v27;
  _BOOL4 v28;
  CFIndex *v30;
  CFTypeRef cf2;
  _BOOL4 v32;

  if (!a3 || (v8 = CFGetTypeID(a3), v8 != CFStringGetTypeID()))
  {
    if (!cf)
      return 0;
    v9 = CFGetTypeID(cf);
    if (v9 != CFStringGetTypeID())
      return 0;
  }
  v10 = *(const __CFArray **)(a1 + 8);
  Count = CFArrayGetCount(v10);
  if (Count < 1)
    return 0;
  v12 = Count;
  v30 = a4;
  v13 = 0;
  if (a3)
    v14 = cf != 0;
  else
    v14 = 0;
  if (a3)
    v15 = 0;
  else
    v15 = cf != 0;
  if (a3)
    v16 = cf == 0;
  else
    v16 = 0;
  v32 = v16;
  v17 = (const void *)kSecPolicyNameSSLServer;
  cf2 = (CFTypeRef)kSecPolicyNameSSLClient;
  while (1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v10, v13);
    Name = (const void *)SecPolicyGetName();
    OidString = (const void *)SecPolicyGetOidString(ValueAtIndex);
    v21 = OidString;
    v22 = OidString && v14;
    if (v22 && Name != 0)
      break;
    if (OidString)
      v24 = v15;
    else
      v24 = 0;
    if (v24)
    {
      v25 = cf;
      v26 = v21;
    }
    else
    {
      v28 = v32;
      if (!Name)
        v28 = 0;
      if (!v28)
        goto LABEL_40;
      v25 = a3;
      v26 = Name;
    }
    if (CFEqual(v25, v26))
      goto LABEL_42;
LABEL_40:
    if (v12 == ++v13)
      return 0;
  }
  v27 = CFEqual(cf, OidString);
  if ((!v27 || !CFEqual(a3, Name)) && (!CFEqual(cf, v21) || !CFEqual(a3, v17) || CFEqual(Name, cf2)))
    goto LABEL_40;
LABEL_42:
  if (v30)
    *v30 = v13;
  return 1;
}

uint64_t sub_100004FE4(uint64_t result, const void *a2)
{
  uint64_t v2;
  CFIndex v3;
  uint64_t v5;
  const void *v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  const void *AuthorityKeyID;

  v2 = *(_QWORD *)(*(_QWORD *)result + 200);
  if (v2)
  {
    v3 = *(_QWORD *)(v2 + 16);
    if (v3 >= 1)
    {
      v5 = result;
      v6 = 0;
      do
      {
        v7 = *(_QWORD *)(*(_QWORD *)v5 + 200);
        if (v7)
          v8 = v3 < 1;
        else
          v8 = 1;
        if (v8 || *(_QWORD *)(v7 + 16) < v3 || (v9 = *(_QWORD *)(v7 + 8 * v3 + 128)) == 0)
          v10 = 0;
        else
          v10 = *(_QWORD *)(v9 + 16);
        --v3;
        if (v6)
        {
          AuthorityKeyID = (const void *)SecCertificateGetAuthorityKeyID(v10);
          if (AuthorityKeyID)
          {
            if (!CFEqual(v6, AuthorityKeyID))
            {
              result = sub_10000E2C8(v5, a2, v3, kCFBooleanFalse, 0, 0);
              if (!(_DWORD)result)
                break;
            }
          }
        }
        result = SecCertificateGetSubjectKeyID(v10);
        v6 = (const void *)result;
      }
      while ((unint64_t)(v3 + 1) > 1);
    }
  }
  return result;
}

void sub_1000050D0(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  const void *ValueAtIndex;
  const void *Name;
  const __CFDictionary *v6;
  const void *v7;
  const void *Value;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const __CFArray *v16;
  CFTypeRef *v17;
  const __CFDictionary *v18;
  const __CFDictionary *v19;
  const __CFArray *v20;
  const __CFArray *v21;
  CFDictionaryRef *v22;
  const void *v23;
  NSObject *v24;
  const char *v25;
  const __CFArray *v26;
  const __CFArray *v27;
  int v28;
  _QWORD v29[6];
  uint8_t buf[8];
  uint8_t *v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD context[6];
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  char v38;
  CFRange v39;
  CFRange v40;

  v2 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  v3 = *(const void **)(*(_QWORD *)a1 + 112);
  if (v3)
    CFRetain(*(CFTypeRef *)(*(_QWORD *)a1 + 112));
  if (!v2 || !*(_BYTE *)(v2 + 104) || sub_100005508((uint64_t)CFSTR("CTKillSwitch")))
    goto LABEL_51;
  ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  Name = (const void *)SecPolicyGetName();
  if (Name && kSecPolicyNameSSLServer)
  {
    if (!CFEqual(Name, kSecPolicyNameSSLServer))
      goto LABEL_51;
  }
  else if (Name != (const void *)kSecPolicyNameSSLServer)
  {
    goto LABEL_51;
  }
  v6 = (const __CFDictionary *)*((_QWORD *)ValueAtIndex + 4);
  v7 = (const void *)kSecPolicyCheckSystemTrustedCTRequired;
  Value = CFDictionaryGetValue(v6, kSecPolicyCheckSystemTrustedCTRequired);
  if (!Value || CFEqual(Value, kCFBooleanFalse))
    goto LABEL_51;
  if (sub_10000C0C0(5184000.0) || v3)
  {
    v9 = *(_QWORD *)(*(_QWORD *)a1 + 200);
    if (v9 && *(uint64_t *)(v9 + 16) >= 1 && (v10 = *(_QWORD *)(v9 + 136)) != 0)
      v11 = *(_QWORD *)(v10 + 16);
    else
      v11 = 0;
    if (SecCertificateNotValidBefore(v11) >= 561340800.0
      && SecCertificateIsValid(v11, *(double *)(*(_QWORD *)a1 + 120)))
    {
      v12 = *(_QWORD *)(*(_QWORD *)a1 + 200);
      if (v12 && (v13 = *(_QWORD *)(v12 + 16), v13 >= 1) && (v14 = *(_QWORD *)(v12 + 8 * v13 + 128)) != 0)
        v15 = *(_QWORD *)(v14 + 16);
      else
        v15 = 0;
      v16 = (const __CFArray *)sub_10000CFDC(0);
      v17 = (CFTypeRef *)sub_10000CF14(v16);
      if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)a1 + 200) + 49)
        || (!off_1000827E0((uint64_t)off_1000827D0, v15)
         || !v17
         || ((unsigned int (*)(CFTypeRef *, uint64_t))v17[2])(v17, v15))
        && !sub_100045A18(v15, CFSTR("TestCTRequiredSystemRoot"))
        || *(_BYTE *)(v2 + 66))
      {
LABEL_46:
        if (!v3)
          goto LABEL_48;
        goto LABEL_47;
      }
      v18 = (const __CFDictionary *)sub_1000400A8(0, 0);
      if (!v18)
      {
LABEL_45:
        sub_10000E2C8(a1, v7, 0, kCFBooleanFalse, 0, 0);
        goto LABEL_46;
      }
      v19 = v18;
      v35 = 0;
      v36 = &v35;
      v37 = 0x2000000000;
      v38 = 0;
      v20 = (const __CFArray *)CFDictionaryGetValue(v18, kSecCTExceptionsDomainsKey);
      if (v20)
      {
        v21 = v20;
        v22 = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
        v23 = CFDictionaryGetValue(v22[4], kSecPolicyCheckSSLHostname);
        if (v23)
        {
          context[0] = _NSConcreteStackBlock;
          context[1] = 0x40000000;
          context[2] = sub_100045AC8;
          context[3] = &unk_100077CE8;
          context[4] = &v35;
          context[5] = v23;
          v39.length = CFArrayGetCount(v21);
          v39.location = 0;
          CFArrayApplyFunction(v21, v39, (CFArrayApplierFunction)sub_100045B9C, context);
        }
      }
      if (*((_BYTE *)v36 + 24))
      {
        v24 = sub_100011628("policy");
        if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
          goto LABEL_44;
        *(_WORD *)buf = 0;
        v25 = "domain-based CT exception applied";
      }
      else
      {
        v26 = (const __CFArray *)CFDictionaryGetValue(v19, kSecCTExceptionsCAsKey);
        if (v26)
        {
          v27 = v26;
          *(_QWORD *)buf = 0;
          v31 = buf;
          v32 = 0x2000000000;
          v33 = *(_QWORD *)(*(_QWORD *)a1 + 200);
          v29[0] = _NSConcreteStackBlock;
          v29[1] = 0x40000000;
          v29[2] = sub_100045BB0;
          v29[3] = &unk_100077D10;
          v29[4] = &v35;
          v29[5] = buf;
          v40.length = CFArrayGetCount(v26);
          v40.location = 0;
          CFArrayApplyFunction(v27, v40, (CFArrayApplierFunction)sub_100045B9C, v29);
          _Block_object_dispose(buf, 8);
        }
        if (!*((_BYTE *)v36 + 24)
          || (v24 = sub_100011628("policy"), !os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG)))
        {
LABEL_44:
          CFRelease(v19);
          v28 = *((unsigned __int8 *)v36 + 24);
          _Block_object_dispose(&v35, 8);
          if (v28)
            goto LABEL_46;
          goto LABEL_45;
        }
        *(_WORD *)buf = 0;
        v25 = "key-based CT exceptions applied";
      }
      _os_log_debug_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, v25, buf, 2u);
      goto LABEL_44;
    }
LABEL_51:
    v17 = 0;
    if (!v3)
    {
LABEL_48:
      if (v17)
        sub_1000132E4(v17);
      return;
    }
LABEL_47:
    CFRelease(v3);
    goto LABEL_48;
  }
}

BOOL sub_100005508(uint64_t a1)
{
  _BOOL8 v1;
  _QWORD v3[6];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;

  v1 = 0;
  if (a1 && qword_100082BC8)
  {
    v4 = 0;
    v5 = &v4;
    v6 = 0x2020000000;
    v7 = 0;
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_100007068;
    v3[3] = &unk_100076548;
    v3[4] = &v4;
    v3[5] = a1;
    dispatch_sync((dispatch_queue_t)qword_100082BC8, v3);
    v1 = *((_BYTE *)v5 + 24) != 0;
    _Block_object_dispose(&v4, 8);
  }
  return v1;
}

uint64_t sub_1000055B0(const __CFDictionary *a1, uint64_t a2)
{
  __int128 v3;
  uint64_t v4;

  v3 = xmmword_100062960;
  LOBYTE(v3) = 1;
  v4 = a2;
  CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)sub_10000B0D8, &v3);
  if ((_BYTE)v3)
    return ccder_sizeof(0x2000000000000011, *((_QWORD *)&v3 + 1));
  else
    return 0;
}

void sub_100005610(_QWORD *a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  const void **v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const __CFArray *v9;
  BOOL v10;
  const void *v11;
  int v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  double v19;
  const __CFArray *PermittedSubtrees;
  int v21;
  CFMutableArrayRef MutableCopy;
  const __CFArray *v23;
  const __CFArray *ExcludedSubtrees;
  int v25;
  CFMutableArrayRef Mutable;
  const __CFArray *v27;
  uint64_t v28;
  uint64_t *v29;
  _OWORD *v30;
  DERItem *v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t CertificatePolicies;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int v42;
  uint64_t v43;
  __int128 *v44;
  _BOOL4 v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t PolicyMappings;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unsigned int v54;
  unsigned int v55;
  uint64_t v56;
  unint64_t v57;
  unsigned int v58;
  uint64_t InhibitAnyPolicySkipCerts;
  unsigned int v60;
  NSObject *v61;
  const char *v62;
  NSObject *v63;
  uint32_t v64;
  uint64_t v65;
  uint64_t v66;
  unsigned int v67;
  uint64_t PolicyConstraints;
  NSObject *v69;
  uint64_t BasicConstraints;
  int v71;
  unsigned int v72;
  const void *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  CFIndex Count;
  NSObject *v81;
  NSObject *v82;
  CFIndex v83;
  NSObject *v84;
  NSObject *v85;
  const char *v86;
  NSObject *v87;
  uint64_t v88;
  const __CFArray *v89;
  CFIndex v90;
  CFIndex v91;
  _QWORD *v92;
  const void **v93;
  CFIndex v94;
  const __CFArray *v95;
  CFIndex v96;
  CFRange v97;
  NSObject *v98;
  uint64_t v99;
  const __CFArray *v100;
  CFIndex v101;
  uint64_t v102;
  CFRange v103;
  NSObject *v104;
  uint64_t v105;
  unsigned int v106;
  CFTypeRef *v107;
  int v108;
  int v109;
  CFTypeRef v110;
  uint64_t v111;
  const void *v112;
  const __CFArray *v113;
  const __CFArray *v114;
  unsigned int v115;
  CFTypeRef v116;
  unsigned int v117;
  CFTypeRef v118;
  _BOOL4 cf1;
  CFTypeRef cf1a;
  unsigned int v121;
  CFTypeRef v122;
  unint64_t v123;
  unsigned int v124;
  unint64_t v125;
  BOOL v126;
  uint64_t v127;
  __int128 v128;
  uint8_t buf[16];
  _OWORD *v130;
  CFRange v131;
  CFRange v132;

  v1 = a1;
  v2 = *(_QWORD *)(*a1 + 200);
  if (v2)
    v3 = *(_QWORD *)(v2 + 16);
  else
    v3 = 0;
  v4 = v3 - 1;
  v5 = (const void **)&kCFBooleanFalse;
  if (!*(_BYTE *)(v2 + 49)
    || (v6 = v2 + 8 * v4,
        v8 = *(_QWORD *)(v6 + 136),
        v7 = v6 + 136,
        v9 = *(const __CFArray **)(v8 + 24),
        CFArrayGetCount(v9))
    && (v2 ? (v10 = v3 < 1) : (v10 = 1),
        v10 || *(_QWORD *)(v2 + 16) < v3 || !*(_QWORD *)v7
      ? (v11 = 0)
      : (v11 = *(const void **)(*(_QWORD *)v7 + 16)),
        sub_100004760(v1, v11, v9) - 1 >= 2))
  {
    buf[0] = 0;
    if (v2)
      v13 = v3 < 1;
    else
      v13 = 1;
    if (v13 || *(_QWORD *)(v2 + 16) < v3 || (v14 = *(_QWORD *)(v2 + 8 * v4 + 136)) == 0)
      v15 = 0;
    else
      v15 = *(_QWORD *)(v14 + 16);
    SecCertificateIsSelfSigned(v15, buf);
    if (buf[0])
    {
      if ((sub_10000E2C8((uint64_t)v1, kSecPolicyCheckAnchorTrusted, v3 - 1, kCFBooleanFalse, 1, 0) & 1) == 0)
        return;
    }
    else if (!sub_10000E2C8((uint64_t)v1, kSecPolicyCheckMissingIntermediate, v3 - 1, kCFBooleanFalse, 1, 0))
    {
      return;
    }
    v12 = 0;
  }
  else
  {
    v12 = 1;
    --v3;
  }
  v16 = *(_QWORD *)(v2 + 16);
  if (v16 >= 1 && (v17 = *(_QWORD *)(v2 + 8 * v16 + 128)) != 0)
    v18 = *(_QWORD *)(v17 + 16);
  else
    v18 = 0;
  v19 = *(double *)(*v1 + 120);
  PermittedSubtrees = (const __CFArray *)SecCertificateGetPermittedSubtrees(v18);
  if (PermittedSubtrees)
    v21 = v12;
  else
    v21 = 0;
  if (v21 == 1)
    MutableCopy = CFArrayCreateMutableCopy(0, 0, PermittedSubtrees);
  else
    MutableCopy = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  v23 = MutableCopy;
  ExcludedSubtrees = (const __CFArray *)SecCertificateGetExcludedSubtrees(v18);
  if (ExcludedSubtrees)
    v25 = v12;
  else
    v25 = 0;
  if (v25 == 1)
    Mutable = CFArrayCreateMutableCopy(0, 0, ExcludedSubtrees);
  else
    Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  v27 = Mutable;
  if (!v23)
  {
    sub_10000E2C8((uint64_t)v1, kSecPolicyCheckNameConstraints, 0, kCFBooleanFalse, 1, 0);
    if (v27)
      goto LABEL_232;
    return;
  }
  if (!Mutable)
  {
    v107 = (CFTypeRef *)&kSecPolicyCheckNameConstraints;
LABEL_230:
    sub_10000E2C8((uint64_t)v1, *v107, 0, *v5, 1, 0);
    goto LABEL_231;
  }
  if (*(_BYTE *)(v2 + 64) == 2)
    goto LABEL_144;
  if (*(_BYTE *)(v2 + 64))
    goto LABEL_143;
  v29 = (uint64_t *)(v2 + 56);
  v28 = *(_QWORD *)(v2 + 56);
  *(_BYTE *)(v2 + 64) = 1;
  if (v28)
    sub_100006930((_QWORD **)(v2 + 56));
  v30 = malloc_type_malloc(0x38uLL, 0x107004060FBFCD3uLL);
  v30[2] = 0u;
  *((_QWORD *)v30 + 6) = 0;
  *v30 = oidAnyPolicy;
  v30[1] = 0u;
  v31 = (DERItem *)malloc_type_malloc(0x18uLL, 0x1030040D5FA72FAuLL);
  v31[1].data = 0;
  *v31 = oidAnyPolicy;
  *((_QWORD *)v30 + 3) = v31;
  *(_QWORD *)(v2 + 56) = v30;
  v32 = *(_QWORD *)(v2 + 16);
  if ((unint64_t)v32 >> 31)
    goto LABEL_143;
  v33 = v32 - v12 + 1;
  v123 = (v32 - v12);
  v111 = v18;
  if ((int)v32 - v12 < 1)
    goto LABEL_127;
  v34 = 1;
  v121 = v32 - v12 + 1;
  v115 = v121;
  v108 = v12;
  v113 = v27;
  while (1)
  {
    v35 = v123 - v34;
    if ((uint64_t)(v123 - v34) >= 0 && *(_QWORD *)(v2 + 16) > v35 && (v36 = *(_QWORD *)(v2 + 8 * v35 + 136)) != 0)
      v127 = *(_QWORD *)(v36 + 16);
    else
      v127 = 0;
    v125 = v34;
    v109 = v123 - v34;
    cf1 = sub_100006534(v2, v35);
    v37 = *(_QWORD *)(v2 + 56);
    v117 = v33;
    if (!v37)
    {
LABEL_78:
      v5 = (const void **)&kCFBooleanFalse;
      if (v37)
        goto LABEL_83;
      goto LABEL_82;
    }
    CertificatePolicies = SecCertificateGetCertificatePolicies(v127);
    if (CertificatePolicies)
    {
      v39 = CertificatePolicies;
      v40 = *(_QWORD *)(CertificatePolicies + 8);
      if (v40)
      {
        v41 = 0;
        v42 = v125 - 1;
        v43 = *(_QWORD *)(CertificatePolicies + 8);
        do
        {
          v44 = (__int128 *)(*(_QWORD *)(v39 + 16) + v41);
          *(_QWORD *)&v128 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v128 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v128 = *v44;
          *(_OWORD *)buf = v128;
          v130 = v44 + 1;
          if (!DEROidCompare((uint64_t)&v128, (uint64_t)&oidAnyPolicy)
            && (sub_1000065E4(*v29, v42, (uint64_t (*)(void))sub_1000066DC) & 1) == 0)
          {
            sub_1000065E4(*v29, v42, (uint64_t (*)(void))sub_10000C51C);
          }
          v41 += 32;
          --v43;
        }
        while (v43);
        v45 = cf1;
        if (v123 <= v125)
          v45 = 0;
        if (v121 || v45)
        {
          v46 = 0;
          do
          {
            v47 = *(_QWORD *)(v39 + 16);
            memset(buf, 170, sizeof(buf));
            *(_OWORD *)buf = *(_OWORD *)(v47 + v46);
            if (DEROidCompare((uint64_t)buf, (uint64_t)&oidAnyPolicy))
              sub_1000065E4(*v29, v42, (uint64_t (*)(void))sub_10000C498);
            v46 += 32;
            --v40;
          }
          while (v40);
        }
        sub_1000067F8(v2 + 56, v42);
        v5 = (const void **)&kCFBooleanFalse;
        v18 = v111;
        v27 = v113;
        v12 = v108;
        v33 = v117;
      }
      else
      {
        sub_1000067F8(v2 + 56, v125 - 1);
        v5 = (const void **)&kCFBooleanFalse;
        v27 = v113;
      }
    }
    else
    {
      sub_1000067F8(v2 + 56, v34 - 1);
      v37 = *v29;
      if (!*v29)
        goto LABEL_78;
      sub_100006930((_QWORD **)(v2 + 56));
      v5 = (const void **)&kCFBooleanFalse;
    }
    if (*v29)
      goto LABEL_83;
LABEL_82:
    if (!v33)
    {
      v61 = sub_100011628("policy");
      if (!os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
        goto LABEL_143;
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v109;
      v62 = "policy tree failure on cert %u";
LABEL_123:
      v63 = v61;
      v64 = 8;
      goto LABEL_142;
    }
LABEL_83:
    if (v123 == v125)
    {
      v32 = *(_QWORD *)(v2 + 16);
LABEL_127:
      if (v32 >= 1 && (v65 = *(_QWORD *)(v2 + 136)) != 0)
        v66 = *(_QWORD *)(v65 + 16);
      else
        v66 = 0;
      if (v33)
        v67 = v33 - 1;
      else
        v67 = 0;
      PolicyConstraints = SecCertificateGetPolicyConstraints(v66);
      if (PolicyConstraints && *(_BYTE *)(PolicyConstraints + 2) && !*(_DWORD *)(PolicyConstraints + 4))
        v67 = 0;
      if (*v29 || v67)
      {
        *(_BYTE *)(v2 + 64) = 2;
        v18 = v111;
        goto LABEL_144;
      }
      v69 = sub_100011628("policy");
      v18 = v111;
      if (!os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
        goto LABEL_143;
      *(_WORD *)buf = 0;
      v62 = "policy tree failure on leaf";
      v63 = v69;
      v64 = 2;
LABEL_142:
      _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, v62, buf, v64);
      goto LABEL_143;
    }
    PolicyMappings = SecCertificateGetPolicyMappings(v127);
    if (!PolicyMappings)
      goto LABEL_97;
    v49 = PolicyMappings;
    if (!*(_BYTE *)PolicyMappings)
      goto LABEL_97;
    v50 = *(_QWORD *)(PolicyMappings + 8);
    if (v50)
      break;
LABEL_91:
    v53 = *v29;
    if (v115)
    {
      v18 = v111;
      v27 = v113;
      v12 = v108;
      if (v53 && (sub_1000065E4(v53, v125, (uint64_t (*)(void))sub_100038B20) & 1) == 0)
        sub_1000065E4(*v29, v125, (uint64_t (*)(void))sub_100038BE8);
    }
    else
    {
      v18 = v111;
      v27 = v113;
      v12 = v108;
      if (v53)
      {
        sub_1000065E4(v53, v125, (uint64_t (*)(void))sub_100038DCC);
        sub_1000067F8(v2 + 56, v125 - 1);
      }
    }
LABEL_97:
    if (cf1)
    {
      v33 = v117;
    }
    else
    {
      if (v117)
        v33 = v117 - 1;
      else
        v33 = 0;
      v54 = v115 - 1;
      if (!v115)
        v54 = 0;
      v115 = v54;
      v55 = v121 - 1;
      if (!v121)
        v55 = 0;
      v121 = v55;
    }
    v56 = SecCertificateGetPolicyConstraints(v127);
    if (v56)
    {
      v57 = v125;
      if (*(_BYTE *)(v56 + 2) && *(_DWORD *)(v56 + 4) < v33)
        v33 = *(_DWORD *)(v56 + 4);
      if (*(_BYTE *)(v56 + 8))
      {
        v58 = v115;
        if (*(_DWORD *)(v56 + 12) < v115)
          v58 = *(_DWORD *)(v56 + 12);
        v115 = v58;
      }
    }
    else
    {
      v57 = v125;
    }
    InhibitAnyPolicySkipCerts = SecCertificateGetInhibitAnyPolicySkipCerts(v127);
    if (InhibitAnyPolicySkipCerts)
    {
      v60 = v121;
      if (*(_DWORD *)(InhibitAnyPolicySkipCerts + 4) < v121)
        v60 = *(_DWORD *)(InhibitAnyPolicySkipCerts + 4);
      v121 = v60;
    }
    v34 = v57 + 1;
  }
  v51 = 16;
  while (1)
  {
    v52 = *(_QWORD *)(v49 + 16) + v51;
    if (DEROidCompare(v52 - 16, (uint64_t)&oidAnyPolicy) || DEROidCompare(v52, (uint64_t)&oidAnyPolicy))
      break;
    v51 += 32;
    if (!--v50)
      goto LABEL_91;
  }
  v61 = sub_100011628("policy");
  v5 = (const void **)&kCFBooleanFalse;
  v18 = v111;
  v27 = v113;
  v12 = v108;
  if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v109;
    v62 = "policy mapping anyPolicy failure %u";
    goto LABEL_123;
  }
LABEL_143:
  if (sub_10000E2C8((uint64_t)v1, kSecPolicyCheckPolicyConstraints, 0, kCFBooleanFalse, 1, 0))
  {
LABEL_144:
    BasicConstraints = SecCertificateGetBasicConstraints(v18);
    if (BasicConstraints)
      v71 = v12;
    else
      v71 = 0;
    if (v71 == 1 && *(_BYTE *)(BasicConstraints + 3))
    {
      v72 = *(_DWORD *)(BasicConstraints + 4);
      if (v72 >= v3)
        v72 = v3;
    }
    else
    {
      v72 = v3;
    }
    if (v3 >= 1)
    {
      v124 = v72;
      v73 = (const void *)kSecPolicyCheckTemporalValidity;
      cf1a = (CFTypeRef)kSecPolicyCheckWeakKeySize;
      v118 = (CFTypeRef)kSecPolicyCheckWeakSignature;
      v122 = (CFTypeRef)kSecPolicyCheckNameConstraints;
      v110 = (CFTypeRef)kSecPolicyCheckBasicConstraintsPathLen;
      v74 = v3 + 16;
      v114 = v27;
      v116 = (CFTypeRef)kSecPolicyCheckCriticalExtensions;
      v112 = (const void *)kSecPolicyCheckTemporalValidity;
      while (1)
      {
        v75 = 0;
        v76 = v74 - 17;
        v77 = *(_QWORD *)(*v1 + 200);
        if (v77 && (v76 & 0x8000000000000000) == 0)
        {
          if (*(_QWORD *)(v77 + 16) > v76 && (v78 = *(_QWORD *)(v77 + 8 * v74)) != 0)
            v75 = *(_QWORD *)(v78 + 16);
          else
            v75 = 0;
        }
        v126 = sub_100006534(v77, v74 - 17);
        if ((SecCertificateIsValid(v75, v19) & 1) == 0
          && !sub_10000E2C8((uint64_t)v1, v73, v74 - 17, kCFBooleanFalse, 0, 0)
          || SecCertificateIsWeakKey(v75)
          && !sub_10000E2C8((uint64_t)v1, cf1a, v74 - 17, kCFBooleanFalse, 0, 0)
          || (SecPolicyCheckCertWeakSignature(v75, 0) & 1) == 0
          && !sub_10000E2C8((uint64_t)v1, v118, v74 - 17, kCFBooleanFalse, 0, 0))
        {
          goto LABEL_231;
        }
        if (v74 == 17 || !v126)
        {
          LOBYTE(v128) = 0;
          Count = CFArrayGetCount(v27);
          if (Count)
          {
            if (Count < 1024)
            {
              if (sub_10002BBC4(v75, v27, &v128, 0) || (_BYTE)v128)
              {
                v82 = sub_100011628("policy");
                if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "name in excluded subtrees", buf, 2u);
                }
                if (!sub_10000E2C8((uint64_t)v1, v122, v74 - 17, kCFBooleanFalse, 1, 0))
                  goto LABEL_231;
              }
            }
            else
            {
              v81 = sub_100011628("policy");
              if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_DEFAULT, "excluded subtrees too large", buf, 2u);
              }
              if ((sub_10000E2C8((uint64_t)v1, v122, v74 - 17, kCFBooleanFalse, 1, 0) & 1) == 0)
                goto LABEL_231;
            }
          }
          v83 = CFArrayGetCount(v23);
          if (v83)
            break;
        }
LABEL_191:
        if (v74 == 17)
          goto LABEL_228;
        v88 = SecCertificateGetPermittedSubtrees(v75);
        if (v88)
        {
          v89 = (const __CFArray *)v88;
          v90 = CFArrayGetCount(v23);
          v91 = CFArrayGetCount(v89);
          if (v91 <= 1023 && v91 + v90 < 1024)
          {
            v92 = v1;
            v93 = v5;
            v94 = CFArrayGetCount(v89);
            if (CFArrayGetCount(v23))
            {
              v95 = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
              *(_QWORD *)buf = v23;
              *(_QWORD *)&buf[8] = v95;
              v131.location = 0;
              v131.length = v94;
              CFArrayApplyFunction(v89, v131, (CFArrayApplierFunction)sub_10002C70C, buf);
              v96 = CFArrayGetCount(v95);
              if (v95)
              {
                v97.length = v96;
                if (v96)
                {
                  v97.location = 0;
                  CFArrayAppendArray(v23, v95, v97);
                  v5 = v93;
                  goto LABEL_205;
                }
              }
              v5 = v93;
              if (v95)
LABEL_205:
                CFRelease(v95);
              v1 = v92;
              v27 = v114;
            }
            else
            {
              v132.location = 0;
              v132.length = v94;
              CFArrayAppendArray(v23, v89, v132);
              v5 = v93;
              v1 = v92;
            }
            v73 = v112;
            goto LABEL_208;
          }
          v98 = sub_100011628("policy");
          if (os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_DEFAULT, "permitted subtrees too large", buf, 2u);
          }
          if ((sub_10000E2C8((uint64_t)v1, v122, v74 - 17, kCFBooleanFalse, 1, 0) & 1) == 0)
            goto LABEL_231;
        }
LABEL_208:
        v99 = SecCertificateGetExcludedSubtrees(v75);
        if (v99)
        {
          v100 = (const __CFArray *)v99;
          v101 = CFArrayGetCount(v27);
          v102 = CFArrayGetCount(v100);
          if (v102 > 1023 || (v103.length = v102, v102 + v101 >= 1024))
          {
            v104 = sub_100011628("policy");
            if (os_log_type_enabled(v104, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_DEFAULT, "excluded subtrees too large", buf, 2u);
            }
            if ((sub_10000E2C8((uint64_t)v1, v122, v74 - 17, kCFBooleanFalse, 1, 0) & 1) == 0)
              goto LABEL_231;
          }
          else
          {
            v103.location = 0;
            CFArrayAppendArray(v27, v100, v103);
          }
        }
        if (!v126)
        {
          if (v124)
          {
            --v124;
          }
          else
          {
            v124 = 0;
            if (!sub_10000E2C8((uint64_t)v1, v110, v74 - 17, kCFBooleanFalse, 1, 0))
              goto LABEL_231;
          }
        }
        v105 = SecCertificateGetBasicConstraints(v75);
        if (v105 && *(_BYTE *)(v105 + 3))
        {
          v106 = v124;
          if (*(_DWORD *)(v105 + 4) < v124)
            v106 = *(_DWORD *)(v105 + 4);
          v124 = v106;
        }
        if (SecCertificateHasUnknownCriticalExtension(v75)
          && !sub_10000E2C8((uint64_t)v1, v116, v74 - 17, kCFBooleanFalse, 1, 0))
        {
          goto LABEL_231;
        }
        --v74;
      }
      if (v83 < 1024)
      {
        if (!sub_10002BBC4(v75, v23, &v128, 1) && (_BYTE)v128)
          goto LABEL_191;
        v87 = sub_100011628("policy");
        if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          v85 = v87;
          v86 = "name not in permitted subtrees";
LABEL_189:
          _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, v86, buf, 2u);
        }
      }
      else
      {
        v84 = sub_100011628("policy");
        if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          v85 = v84;
          v86 = "permitted subtrees too large";
          goto LABEL_189;
        }
      }
      if ((sub_10000E2C8((uint64_t)v1, v122, v74 - 17, kCFBooleanFalse, 1, 0) & 1) == 0)
        goto LABEL_231;
      goto LABEL_191;
    }
    v75 = 0;
LABEL_228:
    if (SecCertificateHasUnknownCriticalExtension(v75))
    {
      v107 = (CFTypeRef *)&kSecPolicyCheckCriticalExtensions;
      goto LABEL_230;
    }
  }
LABEL_231:
  CFRelease(v23);
  if (v27)
LABEL_232:
    CFRelease(v27);
}

BOOL DEROidCompare(uint64_t a1, uint64_t a2)
{
  _BOOL8 result;
  size_t v4;

  result = 0;
  if (a1 && a2)
  {
    v4 = *(_QWORD *)(a1 + 8);
    return v4 == *(_QWORD *)(a2 + 8) && memcmp(*(const void **)a1, *(const void **)a2, v4) == 0;
  }
  return result;
}

BOOL sub_100006534(uint64_t a1, uint64_t a2)
{
  __SecCertificate *v2;
  uint64_t v3;
  CFDataRef v4;
  CFDataRef v5;
  CFDataRef v6;
  _BOOL8 v7;
  _BOOL8 v8;

  v2 = 0;
  if (a1 && (a2 & 0x8000000000000000) == 0)
  {
    if (*(_QWORD *)(a1 + 16) > a2 && (v3 = *(_QWORD *)(a1 + 8 * a2 + 136)) != 0)
      v2 = *(__SecCertificate **)(v3 + 16);
    else
      v2 = 0;
  }
  v4 = SecCertificateCopyNormalizedIssuerSequence(v2);
  v5 = SecCertificateCopyNormalizedSubjectSequence(v2);
  v6 = v5;
  if (v4 && v5)
  {
    v7 = CFEqual(v4, v5) != 0;
  }
  else
  {
    v7 = 0;
    v8 = 0;
    if (!v4)
      goto LABEL_12;
  }
  CFRelease(v4);
  v8 = v7;
LABEL_12:
  if (v6)
    CFRelease(v6);
  return v8;
}

uint64_t sub_1000065E4(uint64_t a1, unsigned int a2, uint64_t (*a3)(void))
{
  _QWORD *v6;
  _QWORD *v7;
  char v8;
  int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (a2 <= 0xE && (v6 = malloc_type_malloc(8 * (a2 + 1), 0x2004093837F09uLL)) != 0)
  {
    v7 = v6;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    *v6 = a1;
    do
    {
      while (1)
      {
        while (1)
        {
          v11 = v7[v10];
          if ((v8 & 1) != 0)
            break;
          if ((int)v10 >= (int)a2)
            break;
          v13 = *(_QWORD *)(v11 + 32);
          if (!v13)
            break;
          v8 = 0;
          v7[++v10] = v13;
          if ((v10 & 0x80000000) != 0)
            goto LABEL_15;
        }
        v12 = *(_QWORD *)(v11 + 40);
        if (v10 == a2)
          v9 |= a3();
        if (!v12)
          break;
        v8 = 0;
        v7[v10] = v12;
        if ((v10 & 0x80000000) != 0)
          goto LABEL_15;
      }
      --v10;
      v8 = 1;
    }
    while ((v10 & 0x80000000) == 0);
LABEL_15:
    free(v7);
  }
  else
  {
    LOBYTE(v9) = 0;
  }
  return v9 & 1;
}

uint64_t sub_1000066DC(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 24);
  if (!v2)
    return 0;
  while (!DEROidCompare(v2, a2))
  {
    v2 = *(_QWORD *)(v2 + 16);
    if (!v2)
      return 0;
  }
  sub_10000C56C(a1, (_OWORD *)a2, *(_QWORD *)(a2 + 16));
  return 1;
}

BOOL sub_100006740(uint64_t a1)
{
  int v2;
  _BOOL8 v3;
  const __CFArray *v4;
  const void *ValueAtIndex;
  const void *v6;
  const void *Name;
  const __CFDictionary *v8;

  v2 = sub_1000150B0();
  v3 = 0;
  if (a1 && v2)
  {
    v4 = *(const __CFArray **)(a1 + 8);
    if (!v4)
      return 0;
    ValueAtIndex = CFArrayGetValueAtIndex(v4, 0);
    v3 = ValueAtIndex != 0;
    if (ValueAtIndex)
    {
      v6 = ValueAtIndex;
      Name = (const void *)SecPolicyGetName();
      if (Name && kSecPolicyNameSSLServer)
      {
        if (CFEqual(Name, kSecPolicyNameSSLServer))
          return v3;
      }
      else if (Name == (const void *)kSecPolicyNameSSLServer)
      {
        return v3;
      }
      v8 = (const __CFDictionary *)*((_QWORD *)v6 + 4);
      if (!v8
        || !CFDictionaryGetValue(v8, kSecPolicyCheckSSLHostname) && !CFDictionaryGetValue(v8, kSecPolicyCheckCTRequired))
      {
        return 0;
      }
    }
  }
  return v3;
}

void sub_1000067F8(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  char v7;
  int v8;
  int v9;
  _QWORD **v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;

  __chkstk_darwin();
  v6 = (uint64_t *)((char *)&v16 - v5);
  if ((v7 & 1) == 0)
    memset((char *)&v16 - v5, 170, 8 * v4);
  v8 = 0;
  LOBYTE(v9) = 0;
  *v6 = a1;
  do
  {
    while (1)
    {
      while (1)
      {
        v10 = (_QWORD **)v6[v8];
        v11 = (uint64_t)*v10;
        v12 = (*v10)[4];
        if ((v9 & 1) != 0 || v8 >= a2)
          break;
        if (v12)
        {
          LOBYTE(v9) = 0;
          v6[++v8] = *v10 + 4;
          if (v8 < 0)
            return;
        }
        else
        {
LABEL_13:
          v15 = *(_QWORD **)(v11 + 40);
          *(_QWORD *)(v11 + 40) = 0;
          sub_100006988(*v10);
          *v10 = v15;
          v9 = v15 == 0;
          v8 -= v9;
          if (v8 < 0)
            return;
        }
      }
      if (!v12)
        goto LABEL_13;
      v14 = *(_QWORD *)(v11 + 40);
      v13 = v11 + 40;
      if (!v14)
        break;
      LOBYTE(v9) = 0;
      v6[v8] = v13;
      if (v8 < 0)
        return;
    }
    --v8;
    LOBYTE(v9) = 1;
  }
  while ((v8 & 0x80000000) == 0);
}

void sub_100006930(_QWORD **a1)
{
  _QWORD *v2;

  v2 = *a1;
  if (v2[4])
  {
    sub_100006930(v2 + 4);
    v2 = *a1;
  }
  if (v2[5])
  {
    sub_100006930(v2 + 5);
    v2 = *a1;
  }
  sub_100006988(v2);
  *a1 = 0;
}

void sub_100006988(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[3];
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)v2[2];
      free(v2);
      v2 = v3;
    }
    while (v3);
  }
  free(a1);
}

void sub_1000069C0(void *key, uint64_t a2, uint64_t a3)
{
  unsigned int v5;
  BOOL v6;
  int v7;
  BOOL v8;
  void (*Value)(uint64_t, void *);
  uint64_t v10;
  NSObject *v11;
  int v12;
  void *v13;

  v5 = *(_DWORD *)(a3 + 64);
  v6 = v5 > 7;
  v7 = (1 << v5) & 0xE8;
  v8 = v6 || v7 == 0;
  if (v8 || *(_QWORD *)(a3 + 56))
  {
    Value = (void (*)(uint64_t, void *))CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), key);
    if (Value)
    {
      Value(a3, key);
      return;
    }
    v10 = *(_QWORD *)(a3 + 16);
    if (v10 == qword_100082DD8)
    {
      if (!CFDictionaryContainsKey((CFDictionaryRef)qword_100082DE0, key))
      {
        v11 = sub_100011628("SecWarning");
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          v12 = 138412290;
          v13 = key;
LABEL_17:
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "policy: unknown policy key %@, skipping", (uint8_t *)&v12, 0xCu);
        }
      }
    }
    else
    {
      if (v10 != qword_100082DE0)
      {
        *(_DWORD *)(a3 + 64) = 7;
        return;
      }
      if (!CFDictionaryContainsKey((CFDictionaryRef)qword_100082DD8, key))
      {
        v11 = sub_100011628("SecWarning");
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          v12 = 138412290;
          v13 = key;
          goto LABEL_17;
        }
      }
    }
  }
}

uint64_t sub_100006B5C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_100006B70(uint64_t a1, CFDateRef theDate)
{
  double AbsoluteTime;
  uint64_t v4;

  AbsoluteTime = CFDateGetAbsoluteTime(theDate);
  if (AbsoluteTime < *(double *)(a1 + 40))
  {
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    if (AbsoluteTime > *(double *)(v4 + 24))
      *(double *)(v4 + 24) = AbsoluteTime;
  }
}

void sub_100006BB8(uint64_t a1, CFDateRef theDate)
{
  double AbsoluteTime;
  uint64_t v4;

  AbsoluteTime = CFDateGetAbsoluteTime(theDate);
  if (AbsoluteTime > *(double *)(a1 + 40))
  {
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    if (AbsoluteTime < *(double *)(v4 + 24))
      *(double *)(v4 + 24) = AbsoluteTime;
  }
}

uint64_t sub_100006C00(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  if (*(uint64_t *)(a1 + 16) < 1)
    return 0;
  v2 = 0;
  v3 = 0;
  v4 = a1 + 136;
  do
    v3 += CFHash(*(CFTypeRef *)(v4 + 8 * v2++));
  while (v2 < *(_QWORD *)(a1 + 16));
  return v3;
}

CFHashCode sub_100006C64(uint64_t a1)
{
  CFHashCode v2;
  const void *v3;

  v2 = CFHash(*(CFTypeRef *)(a1 + 16));
  v3 = *(const void **)(a1 + 24);
  if (v3)
    v2 += CFHash(v3);
  return v2;
}

void sub_100006CA0(void *value, uint64_t a2)
{
  const void *NormalizedSubjectContent;
  const void *v5;
  const __CFDictionary *v6;
  __CFArray *Mutable;

  if (!CFSetContainsValue(*(CFSetRef *)(a2 + 24), value))
  {
    CFSetAddValue(*(CFMutableSetRef *)(a2 + 24), value);
    NormalizedSubjectContent = (const void *)SecCertificateGetNormalizedSubjectContent(value);
    if (NormalizedSubjectContent)
    {
      v5 = NormalizedSubjectContent;
      v6 = *(const __CFDictionary **)(a2 + 32);
      Mutable = (__CFArray *)CFDictionaryGetValue(v6, NormalizedSubjectContent);
      if (Mutable
        || (Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks),
            CFDictionaryAddValue(v6, v5, Mutable),
            CFRelease(Mutable),
            Mutable))
      {
        CFArrayAppendValue(Mutable, value);
      }
    }
  }
}

void sub_100006D60(uint64_t a1, const void *a2, const void *a3)
{
  CFDictionaryAddValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), a2, a3);
}

uint64_t sub_100006D70(uint64_t a1, uint64_t a2, _BYTE *a3, __CFString **a4)
{
  if (a3)
    *a3 = 0;
  if (!a1 || *(_DWORD *)(a1 + 36) != 1)
    return sub_10000F520(a1, a2, a3, 0, a4);
  if (a3)
    *a3 = off_1000827E0((uint64_t)off_1000827D0, a2);
  return 1;
}

uint64_t sub_100006DD8(const __CFData *a1, const __CFData *a2)
{
  CFIndex Length;
  CFIndex v5;
  unint64_t v6;
  size_t v7;
  const UInt8 *BytePtr;
  const UInt8 *v9;
  int v10;
  uint64_t v12;
  uint64_t v13;

  Length = CFDataGetLength(a1);
  v5 = CFDataGetLength(a2);
  v6 = v5;
  if (Length < 0 || v5 < 0)
  {
    if (Length >= v5)
      v12 = 0;
    else
      v12 = -1;
    if (Length <= v5)
      return v12;
    else
      return 1;
  }
  else
  {
    if (Length >= v5)
      v7 = v5;
    else
      v7 = Length;
    BytePtr = CFDataGetBytePtr(a1);
    v9 = CFDataGetBytePtr(a2);
    v10 = memcmp(BytePtr, v9, v7);
    if (v10 <= 0 && (v10 || Length <= v6))
    {
      LODWORD(v13) = v10 == 0;
      if (Length >= v6)
        LODWORD(v13) = 0;
      if (v10 < 0)
        v13 = 1;
      else
        v13 = v13;
      return v13 << 63 >> 63;
    }
    else
    {
      return 1;
    }
  }
}

void sub_100006E9C(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  const void *v5;

  sub_100006F08(a1);
  if (*(_QWORD *)(a1 + 56))
    sub_100006930((_QWORD **)(a1 + 56));
  v2 = *(_QWORD *)(a1 + 16);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = a1 + 136;
    do
    {
      v5 = *(const void **)(v4 + 8 * v3);
      if (v5)
      {
        *(_QWORD *)(v4 + 8 * v3) = 0;
        CFRelease(v5);
        v2 = *(_QWORD *)(a1 + 16);
      }
      ++v3;
    }
    while (v3 < v2);
  }
}

void sub_100006F08(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *(void **)(a1 + 80);
  if (v2)
  {
    v3 = *(_QWORD *)(a1 + 88);
    if (v3 >= 1)
    {
      v4 = 0;
      do
      {
        sub_100006F68(*(_QWORD *)(a1 + 80) + v4);
        v4 += 40;
        --v3;
      }
      while (v3);
      v2 = *(void **)(a1 + 80);
    }
    free(v2);
    *(_QWORD *)(a1 + 80) = 0;
  }
}

void sub_100006F68(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  const void *v4;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2)
  {
    *(_QWORD *)(v2 + 16) = 0;
    *(_QWORD *)(v2 + 24) = 0;
    v3 = *(const void **)(a1 + 16);
    if (v3)
    {
      *(_QWORD *)(a1 + 16) = 0;
      CFRelease(v3);
    }
  }
  v4 = *(const void **)(a1 + 24);
  if (v4)
  {
    *(_QWORD *)(a1 + 24) = 0;
    CFRelease(v4);
  }
}

void sub_100006FB8(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;

  v2 = (const void *)a1[2];
  if (v2)
  {
    a1[2] = 0;
    CFRelease(v2);
  }
  v3 = (const void *)a1[3];
  if (v3)
  {
    a1[3] = 0;
    CFRelease(v3);
  }
  v4 = (const void *)a1[4];
  if (v4)
  {
    a1[4] = 0;
    CFRelease(v4);
  }
}

void sub_10000700C(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v2)
  {
    if ((SecCertificateAppendToXPCArray(a2, v2, *(_QWORD *)(a1 + 40)) & 1) == 0)
    {
      xpc_release(*(xpc_object_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
    }
  }
}

_QWORD *sub_100007068(_QWORD *result)
{
  _QWORD *v1;
  _BYTE *v2;

  if (qword_100082BF0)
  {
    v1 = result;
    result = (_QWORD *)result[5];
    if (result)
    {
      result = (_QWORD *)CFEqual(result, CFSTR("CTKillSwitch"));
      if ((_DWORD)result)
      {
        v2 = (_BYTE *)(qword_100082BF0 + 200);
LABEL_8:
        *(_BYTE *)(*(_QWORD *)(v1[4] + 8) + 24) = *v2;
        return result;
      }
      result = (_QWORD *)v1[5];
      if (result)
      {
        result = (_QWORD *)CFEqual(result, CFSTR("CTKillSwitch_nonTLS"));
        if ((_DWORD)result)
        {
          v2 = (_BYTE *)(qword_100082BF0 + 201);
          goto LABEL_8;
        }
      }
    }
  }
  return result;
}

uint64_t sub_1000070E4(uint64_t a1, CFCalendarRef calendar)
{
  uint64_t result;

  result = CFCalendarDecomposeAbsoluteTime(calendar, *(CFAbsoluteTime *)(a1 + 40), "yMdHms", *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88));
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (_DWORD)result != 0;
  return result;
}

_QWORD *sub_100007144(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (qword_100082BF0)
  {
    v1 = result;
    v2 = *(_QWORD *)(qword_100082BF0 + 160);
    if (v2)
      result = CFRetain(*(CFTypeRef *)(qword_100082BF0 + 160));
    *(_QWORD *)(*(_QWORD *)(v1[4] + 8) + 24) = v2;
  }
  return result;
}

void sub_100007188(uint64_t a1, CFDictionaryRef theDict, const __CFDate *a3)
{
  double AbsoluteTime;
  uint64_t v6;

  if (!CFDictionaryContainsKey(theDict, CFSTR("expiry")))
  {
    AbsoluteTime = CFDateGetAbsoluteTime(a3);
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    if (AbsoluteTime < *(double *)(v6 + 24))
      *(double *)(v6 + 24) = AbsoluteTime;
  }
}

uint64_t sub_1000071E0(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  if (qword_100082AE0 != -1)
    dispatch_once(&qword_100082AE0, &stru_100075E50);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v1 + 16))(v1, qword_100082AE8);
}

CFTypeRef sub_100007234(uint64_t a1, __SecCertificate *a2)
{
  CFTypeRef result;

  result = (CFTypeRef)sub_100008244(*(_QWORD **)(a1 + 40), a2);
  if ((_DWORD)result)
  {
    if (a2)
      result = CFRetain(a2);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a2;
  }
  return result;
}

void sub_100007278(uint64_t a1, const __CFDictionary *a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const __CFArray *v11;
  const __CFArray *v12;
  const __CFArray *v13;
  CFIndex Count;

  v3 = *(_QWORD *)a1;
  if (!*(_QWORD *)a1)
    return;
  v4 = *(_QWORD *)(v3 + 272);
  if (!v4)
    return;
  v8 = *(_QWORD *)(v3 + 200);
  if (v8 && *(uint64_t *)(v8 + 16) >= 1 && (v9 = *(_QWORD *)(v8 + 136)) != 0)
    v10 = *(_QWORD *)(v9 + 16);
  else
    v10 = 0;
  v11 = (const __CFArray *)SecCertificateCopySignedCertificateTimestamps(v10);
  v12 = *(const __CFArray **)(*(_QWORD *)a1 + 104);
  if (v12)
    CFRetain(*(CFTypeRef *)(*(_QWORD *)a1 + 104));
  v13 = sub_100007C7C(a1);
  if (!v11 || CFArrayGetCount(v11) < 1)
  {
    Count = 0;
    if (!v12)
      goto LABEL_17;
LABEL_15:
    if (CFArrayGetCount(v12) >= 1)
    {
      *(_BYTE *)(v4 + 11) |= 4u;
      Count += CFArrayGetCount(v12);
    }
    goto LABEL_17;
  }
  *(_BYTE *)(v4 + 11) |= 1u;
  Count = CFArrayGetCount(v11);
  if (v12)
    goto LABEL_15;
LABEL_17:
  if (v13 && CFArrayGetCount(v13) >= 1)
  {
    *(_BYTE *)(v4 + 11) |= 2u;
    LODWORD(Count) = CFArrayGetCount(v13) + Count;
  }
  *(_DWORD *)(v4 + 12) = Count;
  *(_DWORD *)(v4 + 16) = a3;
  if (CFDictionaryGetCount(a2) == 1)
    *(_BYTE *)(v4 + 20) = 1;
  if (v11)
    CFRelease(v11);
  if (v12)
    CFRelease(v12);
  if (v13)
    CFRelease(v13);
}

void sub_1000073F8(uint64_t *a1)
{
  const __CFDictionary *v2;
  uint64_t v3;
  int v4;
  const __CFDictionary *v5;
  uint64_t v6;
  __int16 v7;
  CFTypeRef v8;
  CFTypeRef cf;

  v2 = *(const __CFDictionary **)(*a1 + 112);
  if (v2)
    CFRetain(*(CFTypeRef *)(*a1 + 112));
  else
    v2 = (const __CFDictionary *)sub_1000074EC();
  v8 = 0;
  cf = 0;
  v7 = 0;
  v6 = 0;
  v3 = *(_QWORD *)(*a1 + 200);
  *(_BYTE *)(v3 + 66) = 0;
  v4 = sub_100007598((uint64_t)a1, v2, (CFMutableDictionaryRef *)&cf, (CFMutableDictionaryRef *)&v8, (_BYTE *)&v7 + 1, &v7);
  v5 = (const __CFDictionary *)cf;
  if (v4)
  {
    if (sub_100007DBC(a1, (CFDictionaryRef)cf, (const __CFDictionary *)v8, HIBYTE(v7), v7, &v6))
      *(_BYTE *)(v3 + 66) = 1;
    sub_100007278((uint64_t)a1, v5, v6);
  }
  if (v5)
    CFRelease(v5);
  if (v8)
    CFRelease(v8);
  if (v2)
    CFRelease(v2);
}

uint64_t sub_1000074EC()
{
  uint64_t v0;
  _QWORD block[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  if (!qword_100082BC8)
    return 0;
  sub_1000144B0((void *)qword_100082BC0);
  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v6 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10000ACE8;
  block[3] = &unk_100077360;
  block[4] = &v3;
  dispatch_sync((dispatch_queue_t)qword_100082BC8, block);
  v0 = v4[3];
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t sub_100007598(uint64_t a1, const __CFDictionary *a2, CFMutableDictionaryRef *a3, CFMutableDictionaryRef *a4, _BYTE *a5, _BYTE *a6)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const __CFArray *v13;
  const __CFArray *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __CFData *Mutable;
  uint64_t v20;
  const __CFData *v21;
  const __CFData *v22;
  const __CFData *v23;
  BOOL v24;
  CFIndex Length;
  CFIndex v26;
  CFIndex v27;
  CFIndex v28;
  UInt8 *MutableBytePtr;
  const __CFArray *v30;
  const UInt8 *BytePtr;
  size_t v32;
  UInt8 *v33;
  CFIndex v34;
  const UInt8 *v35;
  size_t v36;
  const UInt8 *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  __CFData *v41;
  uint64_t v42;
  __CFData *v43;
  uint64_t v44;
  const __CFArray *v45;
  UInt8 *v46;
  uint64_t v47;
  const void *v48;
  size_t v49;
  void *v50;
  CFMutableDictionaryRef v51;
  CFMutableDictionaryRef v52;
  double v53;
  unint64_t v54;
  uint64_t v55;
  _QWORD *v56;
  _QWORD *v57;
  _QWORD *v58;
  uint64_t v59;
  _BYTE *v62;
  _BYTE *v63;
  const __CFArray *v65;
  _QWORD v67[10];
  _QWORD v68[10];
  _QWORD v69[11];
  uint64_t v70;
  uint64_t *v71;
  uint64_t v72;
  char v73;
  uint64_t v74;
  uint64_t *v75;
  uint64_t v76;
  char v77;
  _QWORD v78[3];
  double v79;
  CFRange v80;
  CFRange v81;
  CFRange v82;

  v9 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v9 && *(uint64_t *)(v9 + 16) >= 1 && (v10 = *(_QWORD *)(v9 + 136)) != 0)
    v11 = *(_QWORD *)(v10 + 16);
  else
    v11 = 0;
  v12 = SecCertificateCopySignedCertificateTimestamps(v11);
  v13 = *(const __CFArray **)(*(_QWORD *)a1 + 104);
  if (v13)
    CFRetain(*(CFTypeRef *)(*(_QWORD *)a1 + 104));
  v14 = sub_100007C7C(a1);
  v15 = *(uint64_t **)(*(_QWORD *)a1 + 200);
  v62 = a6;
  v63 = a5;
  v65 = (const __CFArray *)v12;
  if (!v15 || v15[2] < 2 || ((v16 = v15[17]) == 0 ? (v17 = 0) : (v17 = *(_QWORD *)(v16 + 16)), (v18 = v15[18]) == 0))
  {
    Mutable = 0;
    goto LABEL_27;
  }
  Mutable = 0;
  if (v17)
  {
    v20 = *(_QWORD *)(v18 + 16);
    if (v20)
    {
      v21 = (const __CFData *)SecCertificateCopySubjectPublicKeyInfoSHA256Digest(v20);
      v22 = (const __CFData *)SecCertificateCopyPrecertTBS(v17);
      v23 = v22;
      if (v21)
        v24 = v22 == 0;
      else
        v24 = 1;
      if (v24)
      {
        Mutable = 0;
        if (!v21)
        {
LABEL_23:
          if (v23)
            CFRelease(v23);
          goto LABEL_27;
        }
      }
      else if (CFDataGetLength(v22) < 1)
      {
        Mutable = 0;
      }
      else
      {
        Length = CFDataGetLength(v21);
        v26 = CFDataGetLength(v23);
        Mutable = CFDataCreateMutable(kCFAllocatorDefault, Length + v26 + 3);
        v27 = CFDataGetLength(v21);
        v28 = CFDataGetLength(v23);
        CFDataSetLength(Mutable, v27 + v28 + 3);
        MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
        v30 = v14;
        BytePtr = CFDataGetBytePtr(v21);
        v32 = CFDataGetLength(v21);
        memcpy(MutableBytePtr, BytePtr, v32);
        v33 = &MutableBytePtr[CFDataGetLength(v21)];
        v34 = CFDataGetLength(v23);
        *v33 = BYTE2(v34);
        v33[1] = BYTE1(v34);
        v33[2] = v34;
        v35 = CFDataGetBytePtr(v23);
        v36 = CFDataGetLength(v23);
        v37 = v35;
        v14 = v30;
        memcpy(v33 + 3, v37, v36);
      }
      CFRelease(v21);
      goto LABEL_23;
    }
  }
LABEL_27:
  v38 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v38 && *(uint64_t *)(v38 + 16) >= 1 && (v39 = *(_QWORD *)(v38 + 136)) != 0)
    v40 = *(_QWORD *)(v39 + 16);
  else
    v40 = 0;
  v41 = Mutable;
  if (SecCertificateGetLength(v40) < 0)
  {
    v43 = 0;
  }
  else
  {
    v42 = SecCertificateGetLength(v40);
    v43 = CFDataCreateMutable(kCFAllocatorDefault, v42 + 3);
    v44 = SecCertificateGetLength(v40);
    CFDataSetLength(v43, v44 + 3);
    v45 = v14;
    v46 = CFDataGetMutableBytePtr(v43);
    v47 = SecCertificateGetLength(v40);
    *v46 = BYTE2(v47);
    v46[1] = BYTE1(v47);
    v46[2] = v47;
    v48 = (const void *)SecCertificateGetBytePtr(v40);
    v49 = SecCertificateGetLength(v40);
    v50 = v46 + 3;
    v14 = v45;
    memcpy(v50, v48, v49);
  }
  v78[0] = 0;
  v78[1] = v78;
  v78[2] = 0x2020000000;
  v79 = NAN;
  v79 = SecCertificateNotValidAfter(v11);
  v51 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v52 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v53 = *(double *)(*(_QWORD *)a1 + 120);
  v74 = 0;
  v75 = &v74;
  v76 = 0x2020000000;
  v77 = 0;
  v70 = 0;
  v71 = &v70;
  v72 = 0x2020000000;
  v73 = 0;
  if (v52)
  {
    if (!v51
      || (!v65 || CFArrayGetCount(v65) <= 0)
      && (!v13 || CFArrayGetCount(v13) <= 0)
      && (!v14 || CFArrayGetCount(v14) <= 0))
    {
      goto LABEL_56;
    }
    if (a2 && CFDictionaryGetCount(a2) >= 1)
    {
      v54 = (unint64_t)(v53 + kCFAbsoluteTimeIntervalSince1970);
      v55 = 1000 * v54;
      if (v65 && v41)
      {
        v69[0] = _NSConcreteStackBlock;
        v69[1] = 3221225472;
        v69[2] = sub_10001C570;
        v69[3] = &unk_1000772A0;
        v69[6] = v41;
        v69[7] = 1000 * v54;
        v69[8] = a2;
        v69[9] = v52;
        v69[10] = v51;
        v69[4] = v78;
        v69[5] = &v70;
        v56 = v69;
        v80.length = CFArrayGetCount(v65);
        v80.location = 0;
        CFArrayApplyFunction(v65, v80, (CFArrayApplierFunction)sub_10003A654, v56);

      }
      if (v13 && v43)
      {
        v68[0] = _NSConcreteStackBlock;
        v68[1] = 3221225472;
        v68[2] = sub_10003A704;
        v68[3] = &unk_1000772C8;
        v68[6] = v43;
        v68[7] = v55;
        v68[8] = a2;
        v68[9] = v51;
        v68[4] = v78;
        v68[5] = &v74;
        v57 = v68;
        v81.length = CFArrayGetCount(v13);
        v81.location = 0;
        CFArrayApplyFunction(v13, v81, (CFArrayApplierFunction)sub_10003A654, v57);

      }
      if (v14 && v43)
      {
        v67[0] = _NSConcreteStackBlock;
        v67[1] = 3221225472;
        v67[2] = sub_10003A778;
        v67[3] = &unk_1000772C8;
        v67[6] = v43;
        v67[7] = v55;
        v67[8] = a2;
        v67[9] = v51;
        v67[4] = v78;
        v67[5] = &v74;
        v58 = v67;
        v82.length = CFArrayGetCount(v14);
        v82.location = 0;
        CFArrayApplyFunction(v14, v82, (CFArrayApplierFunction)sub_10003A654, v58);

      }
    }
    if (CFDictionaryGetCount(v51) >= 1)
    {
      CFRetain(v51);
      *a3 = v51;
      CFRetain(v52);
      *a4 = v52;
      *v62 = *((_BYTE *)v71 + 24);
      *v63 = *((_BYTE *)v75 + 24);
      v59 = 1;
    }
    else
    {
LABEL_56:
      v59 = 0;
    }
    CFRelease(v52);
    if (v51)
      goto LABEL_58;
  }
  else
  {
    v59 = 0;
    if (v51)
LABEL_58:
      CFRelease(v51);
  }
  if (v13)
    CFRelease(v13);
  if (v65)
    CFRelease(v65);
  if (v14)
    CFRelease(v14);
  if (v41)
    CFRelease(v41);
  if (v43)
    CFRelease(v43);
  _Block_object_dispose(&v70, 8);
  _Block_object_dispose(&v74, 8);
  _Block_object_dispose(v78, 8);
  return v59;
}

void sub_100007C1C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 200), 8);
  _Block_object_dispose((const void *)(v1 - 168), 8);
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

CFMutableArrayRef sub_100007C7C(uint64_t a1)
{
  const void *v1;
  uint64_t *v3;
  uint64_t v4;
  const void *v5;
  uint64_t v6;
  const void *v7;
  const void **v8;
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v10;
  _QWORD v12[6];
  CFRange v13;

  v1 = *(const void **)(*(_QWORD *)a1 + 96);
  if (!v1)
    return 0;
  CFRetain(*(CFTypeRef *)(*(_QWORD *)a1 + 96));
  v3 = *(uint64_t **)(*(_QWORD *)a1 + 200);
  if (!v3
    || v3[2] < 2
    || ((v4 = v3[17]) == 0 ? (v5 = 0) : (v5 = *(const void **)(v4 + 16)),
        (v6 = v3[18]) == 0 || !v5 || (v7 = *(const void **)(v6 + 16)) == 0))
  {
    CFRelease(v1);
    return 0;
  }
  v8 = (const void **)sub_100015E5C(v5, v7);
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v10 = Mutable;
  if (Mutable)
  {
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472;
    v12[2] = sub_1000083A4;
    v12[3] = &unk_1000772E8;
    v12[4] = v8;
    v12[5] = Mutable;
    v13.length = CFArrayGetCount((CFArrayRef)v1);
    v13.location = 0;
    CFArrayApplyFunction((CFArrayRef)v1, v13, (CFArrayApplierFunction)sub_10003A654, v12);
    if (!CFArrayGetCount(v10))
    {
      CFRelease(v10);
      v10 = 0;
    }
  }
  CFRelease(v1);
  if (v8)
    sub_100008198(v8);
  return v10;
}

BOOL sub_100007DBC(uint64_t *a1, CFDictionaryRef theDict, const __CFDictionary *a3, int a4, int a5, _QWORD *a6)
{
  _BOOL8 v6;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  double v19;
  unsigned int v20;
  int v21;
  unsigned int v22;
  double v23;
  double v24;
  _QWORD v26[8];
  _QWORD v27[3];
  char v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  int v32;
  _QWORD context[5];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  CFIndex Count;
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD v42[6];
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  int v46;

  v6 = 0;
  if (theDict && a3)
  {
    v38 = 0;
    v39 = &v38;
    v13 = *a1;
    v14 = *(_QWORD *)(*a1 + 120);
    v40 = 0x2020000000;
    v41 = v14;
    v15 = *(_QWORD *)(v13 + 200);
    if (v15 && *(uint64_t *)(v15 + 16) >= 1 && (v16 = *(_QWORD *)(v15 + 136)) != 0)
      v17 = *(_QWORD *)(v16 + 16);
    else
      v17 = 0;
    v34 = 0;
    v35 = &v34;
    v36 = 0x2020000000;
    Count = 0xAAAAAAAAAAAAAAAALL;
    Count = CFDictionaryGetCount(theDict);
    if (a4)
    {
      v6 = CFDictionaryGetCount(theDict) > 1;
      if (!a5)
        goto LABEL_28;
    }
    else
    {
      v6 = 0;
      if (!a5)
      {
LABEL_28:
        *a6 = v35[3];
        _Block_object_dispose(&v34, 8);
        _Block_object_dispose(&v38, 8);
        return v6;
      }
    }
    v18 = *(_QWORD *)(*a1 + 200);
    context[0] = _NSConcreteStackBlock;
    context[1] = 3221225472;
    context[2] = sub_100007188;
    context[3] = &unk_100077310;
    context[4] = &v38;
    CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)sub_10003A668, context);
    *(_QWORD *)(v18 + 128) = v39[3];
    if (v6)
    {
      v6 = 1;
    }
    else
    {
      v29 = 0;
      v30 = &v29;
      v31 = 0x2020000000;
      v32 = 0;
      v27[0] = 0;
      v27[1] = v27;
      v27[2] = 0x2020000000;
      v28 = 0;
      v26[0] = _NSConcreteStackBlock;
      v26[1] = 3221225472;
      v26[2] = sub_10000EE04;
      v26[3] = &unk_100077338;
      v26[4] = &v29;
      v26[5] = &v38;
      v26[6] = &v34;
      v26[7] = v27;
      CFDictionaryApplyFunction(a3, (CFDictionaryApplierFunction)sub_10003A668, v26);
      v19 = SecCertificateNotValidBefore(v17);
      v20 = *((_DWORD *)v30 + 6);
      if (v19 >= 640656000.0)
      {
        v23 = SecCertificateNotValidAfter(v17);
        v24 = v23 - SecCertificateNotValidBefore(v17);
        if (v24 <= 15552000.0)
        {
          v22 = 2;
        }
        else if (v24 <= 71280000.0)
        {
          v22 = 3;
        }
        else
        {
          v22 = 4;
        }
      }
      else
      {
        v43 = 0;
        v44 = &v43;
        v45 = 0x2020000000;
        v46 = 60;
        v42[0] = _NSConcreteStackBlock;
        v42[1] = 3221225472;
        v42[2] = sub_10003A680;
        v42[3] = &unk_1000793D0;
        v42[4] = &v43;
        v42[5] = v17;
        sub_10000BF20((uint64_t)v42);
        v21 = *((_DWORD *)v44 + 6);
        if (v21 >= 15)
        {
          if (v21 >= 0x1C)
          {
            if (v21 < 0x28)
              v22 = 4;
            else
              v22 = 5;
          }
          else
          {
            v22 = 3;
          }
        }
        else
        {
          v22 = 2;
        }
        _Block_object_dispose(&v43, 8);
      }
      v6 = v22 <= v20;
      _Block_object_dispose(v27, 8);
      _Block_object_dispose(&v29, 8);
    }
    goto LABEL_28;
  }
  return v6;
}

void sub_1000080AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  _Block_object_dispose(&a18, 8);
  _Block_object_dispose(&a22, 8);
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a35, 8);
  _Unwind_Resume(a1);
}

void sub_100008100(uint64_t a1, const __CFData *a2)
{
  _QWORD *v3;

  v3 = sub_100008550(a2, -1);
  sub_100015F64(*(_QWORD *)(a1 + 32), (uint64_t)v3, 0, 0, 0.0);
}

void sub_10000813C(uint64_t a1)
{
  const void **v2;
  const void **v3;
  _QWORD *v4;

  if (a1)
  {
    v2 = *(const void ***)(a1 + 32);
    if (v2)
    {
      sub_100008198(v2);
      *(_QWORD *)(a1 + 32) = 0;
    }
    v3 = *(const void ***)(a1 + 40);
    if (v3)
    {
      sub_100008218(v3);
      *(_QWORD *)(a1 + 40) = 0;
      v4 = *(_QWORD **)(a1 + 48);
      if (v4)
      {
        sub_10000A22C(v4);
        *(_QWORD *)(a1 + 48) = 0;
      }
    }
    *(_BYTE *)(a1 + 88) = 0;
    *(_QWORD *)(a1 + 80) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 24) = 0;
  }
}

void sub_100008198(const void **a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;

  v2 = a1[5];
  if (v2)
  {
    a1[5] = 0;
    CFRelease(v2);
  }
  v3 = a1[6];
  if (v3)
  {
    a1[6] = 0;
    CFRelease(v3);
  }
  v4 = a1[7];
  if (v4)
  {
    a1[7] = 0;
    CFRelease(v4);
  }
  v5 = *a1;
  if (*a1)
  {
    *a1 = 0;
    CFRelease(v5);
  }
  v6 = a1[1];
  if (v6)
  {
    a1[1] = 0;
    CFRelease(v6);
  }
  v7 = a1[2];
  if (v7)
  {
    a1[2] = 0;
    CFRelease(v7);
  }
  free(a1);
}

void sub_100008218(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  free(a1);
}

BOOL sub_100008244(_QWORD *a1, __SecCertificate *a2)
{
  uint64_t v4;
  const __CFData *v5;
  const __CFData *v6;
  const void *v7;
  const UInt8 *BytePtr;
  SecKeyRef v9;
  SecKeyRef v10;
  __int128 v11;
  _BOOL8 v12;
  _QWORD v14[4];
  unint64_t v15;
  unint64_t v16;
  char v17;
  __int128 v18;
  __int128 v19;

  v4 = a1[23];
  if (v4 == 0xA000000000000002)
  {
    v5 = (const __CFData *)SecCertificateCopyPublicKeySHA1Digest(a2);
  }
  else
  {
    if (v4 != 0xA000000000000001)
      return 0;
    v5 = (const __CFData *)SecCertificateCopySubjectSequence(a2);
    if (!v5)
      return 0;
  }
  v6 = v5;
  if (CFDataGetLength(v5) != a1[25])
  {
    CFRelease(v6);
    return 0;
  }
  v7 = (const void *)a1[24];
  BytePtr = CFDataGetBytePtr(v6);
  LODWORD(v7) = memcmp(v7, BytePtr, a1[25]);
  CFRelease(v6);
  if ((_DWORD)v7)
    return 0;
  v9 = SecCertificateCopyKey(a2);
  if (!v9)
    return 0;
  v10 = v9;
  *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v18 = v11;
  v19 = v11;
  if (DERParseSequenceContent(a1 + 7, (unsigned __int16)DERNumAlgorithmIdItemSpecs, (uint64_t)&DERAlgorithmIdItemSpecs, (unint64_t)&v18, 0x20uLL)|| (v17 = -86, v15 = 0xAAAAAAAAAAAAAAAALL, v16 = 0xAAAAAAAAAAAAAAAALL, DERParseBitString((uint64_t)(a1 + 9), &v15, &v17)))
  {
    v12 = 0;
  }
  else
  {
    v14[0] = *((_QWORD *)&v18 + 1);
    v14[1] = v18;
    v14[2] = *((_QWORD *)&v19 + 1);
    v14[3] = v19;
    v12 = SecKeyDigestAndVerify(v10, v14, a1[5], a1[6], v15, v16) == 0;
  }
  CFRelease(v10);
  return v12;
}

void sub_1000083A4(uint64_t a1, const __CFData *a2)
{
  const void **v3;
  const void **v4;
  uint64_t v5;
  _QWORD *v6;
  const __CFArray *v7;
  __CFArray *v8;
  CFRange v9;

  v3 = (const void **)sub_100008550(a2, -1);
  if (v3)
  {
    v4 = v3;
    if (!*((_BYTE *)v3 + 8))
    {
      v5 = sub_10000844C((uint64_t)v3, *(_QWORD *)(a1 + 32));
      if (v5)
      {
        v6 = (_QWORD *)v5;
        v7 = *(const __CFArray **)(v5 + 40);
        if (v7)
        {
          CFRetain(*(CFTypeRef *)(v5 + 40));
          v8 = *(__CFArray **)(a1 + 40);
          v9.length = CFArrayGetCount(v7);
          v9.location = 0;
          CFArrayAppendArray(v8, v7, v9);
          CFRelease(v7);
        }
        sub_10000A22C(v6);
      }
    }
    sub_100008218(v4);
  }
}

uint64_t sub_10000844C(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  uint64_t v3;
  _QWORD v5[6];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint8_t buf[8];
  uint64_t v11;
  uint64_t (*v12)(uint64_t, _QWORD *);
  void *v13;
  _QWORD *v14;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  if (a2)
  {
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 0x40000000;
    v5[2] = sub_10000A260;
    v5[3] = &unk_100077840;
    v5[4] = &v6;
    v5[5] = a2;
    *(_QWORD *)buf = _NSConcreteStackBlock;
    v11 = 0x40000000;
    v12 = sub_100009F74;
    v13 = &unk_100077890;
    v14 = v5;
    if (DERDecodeSequenceContentWithBlock((unint64_t *)(a1 + 152), (uint64_t)buf))
    {
      v2 = sub_100011628("SecError");
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "failed to parse single responses", buf, 2u);
      }
    }
    v3 = v7[3];
  }
  else
  {
    v3 = 0;
  }
  _Block_object_dispose(&v6, 8);
  return v3;
}

_QWORD *sub_100008550(const __CFData *a1, uint64_t a2)
{
  _QWORD *v4;
  __int128 v5;
  int v6;
  int v7;
  __int128 v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  unint64_t *v14;
  unint64_t *v15;
  NSObject *v16;
  unint64_t v18;
  unint64_t v19;
  __int128 v20;
  unsigned int v21;
  int v22;
  __CFArray *v23;
  NSObject *v24;
  uint64_t v25;
  const char *v26;
  uint8_t *v27;
  int v28;
  NSObject *v29;
  int v30;
  int v31;
  int v32;
  NSObject *v33;
  uint32_t v34;
  int v35;
  int v36;
  unsigned int v37;
  int v38;
  _QWORD v39[2];
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  _BYTE v44[17];
  _OWORD v45[2];
  unint64_t v46;
  _BYTE v47[12];
  uint8_t buf[24];
  void *v49;
  Block_layout *v50;
  unint64_t v51[5];

  if (!a1 || CFDataGetLength(a1) < 1)
    return 0;
  v4 = malloc_type_calloc(1uLL, 0xD8uLL, 0x107004011397726uLL);
  if (!v4)
    return v4;
  CFRetain(a1);
  *v4 = a1;
  v4[26] = a2;
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v40 = v5;
  v41 = v5;
  v39[0] = CFDataGetBytePtr(a1);
  v39[1] = CFDataGetLength(a1);
  v6 = DERParseSequence((uint64_t)v39, 2u, (uint64_t)&unk_100061C80, (unint64_t)&v40, 0x20uLL);
  if (v6)
  {
    v28 = v6;
    v29 = sub_100011628("SecError");
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      goto LABEL_31;
    LODWORD(v51[0]) = 67109120;
    HIDWORD(v51[0]) = v28;
    v26 = "failed to parse OCSPResponse: %d";
LABEL_75:
    v27 = (uint8_t *)v51;
LABEL_94:
    v33 = v29;
    v34 = 8;
    goto LABEL_98;
  }
  if (!(_QWORD)v40 || *((_QWORD *)&v40 + 1) != 1)
  {
    v16 = sub_100011628("SecError");
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      goto LABEL_31;
    LOWORD(v51[0]) = 0;
    v26 = "OCSPResponse has missing/bad responseStatus";
    goto LABEL_77;
  }
  v7 = *(unsigned __int8 *)v40;
  *((_BYTE *)v4 + 8) = v7;
  if (v7)
    return v4;
  if (!(_QWORD)v41 || !*((_QWORD *)&v41 + 1))
  {
    v16 = sub_100011628("SecError");
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      goto LABEL_31;
    LOWORD(v51[0]) = 0;
    v26 = "Successful OCSPResponse has missing/bad responseBytes";
    goto LABEL_77;
  }
  *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v42 = v8;
  v43 = v8;
  v9 = DERParseSequence((uint64_t)&v41, 2u, (uint64_t)&unk_100061CB0, (unint64_t)&v42, 0x20uLL);
  if (v9)
  {
    v30 = v9;
    v29 = sub_100011628("SecError");
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      goto LABEL_31;
    LODWORD(v51[0]) = 67109120;
    HIDWORD(v51[0]) = v30;
    v26 = "failed to parse OCSPResponseBytes: %d";
    goto LABEL_75;
  }
  if (!DEROidCompare((uint64_t)&v42, (uint64_t)&off_1000777E0))
  {
    v16 = sub_100011628("SecError");
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      goto LABEL_31;
    LOWORD(v51[0]) = 0;
    v26 = "unknown responseType";
    goto LABEL_77;
  }
  if (!(_QWORD)v43 || !*((_QWORD *)&v43 + 1))
  {
    v16 = sub_100011628("SecError");
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      goto LABEL_31;
    LOWORD(v51[0]) = 0;
    v26 = "OCSPResponseBytes with missing response";
    goto LABEL_77;
  }
  v10 = DERParseSequence((uint64_t)&v43, 4u, (uint64_t)&unk_100061CF0, (unint64_t)(v4 + 5), 0x40uLL);
  if (v10)
  {
    v31 = v10;
    v29 = sub_100011628("SecError");
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      goto LABEL_31;
    LODWORD(v51[0]) = 67109120;
    HIDWORD(v51[0]) = v31;
    v26 = "failed to parse BasicOCSPResponse: %d";
    goto LABEL_75;
  }
  if (!v4[5] || !v4[6])
  {
    v16 = sub_100011628("SecError");
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      goto LABEL_31;
    LOWORD(v51[0]) = 0;
    v26 = "BasicOCSPResponse missing/bad responseData";
    goto LABEL_77;
  }
  v11 = DERParseSequence((uint64_t)(v4 + 5), 5u, (uint64_t)&unk_100061D50, (unint64_t)(v4 + 13), 0x50uLL);
  if (v11)
  {
    v32 = v11;
    v29 = sub_100011628("SecError");
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      goto LABEL_31;
    LODWORD(v51[0]) = 67109120;
    HIDWORD(v51[0]) = v32;
    v26 = "failed to parse ResponseData: %d";
    goto LABEL_75;
  }
  if (!v4[13] || !v4[14])
    goto LABEL_24;
  *(_QWORD *)v47 = 0;
  memset(v51, 170, 24);
  v12 = DERDecodeItem((uint64_t)(v4 + 13), v51);
  if (v12)
  {
    v35 = v12;
    v29 = sub_100011628("SecError");
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      goto LABEL_31;
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v35;
    v26 = "failed to parse version from ResponseData: %d";
LABEL_93:
    v27 = buf;
    goto LABEL_94;
  }
  if (v51[0] != 2)
  {
    v29 = sub_100011628("SecError");
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      goto LABEL_31;
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = 2;
    v26 = "failed to parse version from ResponseData: %d";
    goto LABEL_93;
  }
  v13 = DERParseInteger64((char **)&v51[1], (unint64_t *)v47);
  if (v13)
  {
    v36 = v13;
    v29 = sub_100011628("SecError");
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      goto LABEL_31;
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v36;
    v26 = "failed to parse version from ResponseData: %d";
    goto LABEL_93;
  }
  if (*(_QWORD *)v47)
  {
    v24 = sub_100011628("SecError");
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      goto LABEL_31;
    *(_DWORD *)buf = 134217984;
    *(_QWORD *)&buf[4] = *(_QWORD *)v47;
    v26 = "ResponseData has unknown version: %llu";
    v27 = buf;
    goto LABEL_97;
  }
LABEL_24:
  if (!v4[15] || !v4[16])
  {
    v16 = sub_100011628("SecError");
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      goto LABEL_31;
    LOWORD(v51[0]) = 0;
    v26 = "ResponseData missing responderId";
LABEL_77:
    v27 = (uint8_t *)v51;
LABEL_78:
    v33 = v16;
    v34 = 2;
LABEL_98:
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, v26, v27, v34);
    goto LABEL_31;
  }
  memset(v51, 170, 24);
  if (DERDecodeItem((uint64_t)(v4 + 15), v51))
  {
    v16 = sub_100011628("SecError");
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      goto LABEL_31;
    *(_WORD *)v47 = 0;
    v26 = "failed to parse ResponderId";
    goto LABEL_111;
  }
  v14 = &v51[1];
  if (v51[0] == 0xA000000000000002)
  {
    v4[23] = 0xA000000000000002;
    memset(buf, 170, sizeof(buf));
    if (DERDecodeItem((uint64_t)&v51[1], (unint64_t *)buf))
    {
      v16 = sub_100011628("SecError");
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        goto LABEL_31;
      *(_WORD *)v47 = 0;
      v26 = "failed to parse ResponderId byKey";
    }
    else if (*(_QWORD *)buf == 4)
    {
      v18 = DERLengthOfItem(4uLL, *(unint64_t *)&buf[16]);
      if (v18 == v51[2])
      {
        v14 = (unint64_t *)&buf[8];
        v15 = (unint64_t *)&buf[16];
        goto LABEL_38;
      }
      v16 = sub_100011628("SecError");
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        goto LABEL_31;
      *(_WORD *)v47 = 0;
      v26 = "failed to parse ResponderId byKey, extra data";
    }
    else
    {
      v16 = sub_100011628("SecError");
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        goto LABEL_31;
      *(_WORD *)v47 = 0;
      v26 = "failed to parse ResponderId byKey, wrong type";
    }
LABEL_111:
    v27 = v47;
    goto LABEL_78;
  }
  if (v51[0] != 0xA000000000000001)
  {
    v24 = sub_100011628("SecError");
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      goto LABEL_31;
    v25 = v4[23];
    *(_DWORD *)v47 = 134217984;
    *(_QWORD *)&v47[4] = v25;
    v26 = "unknown responderId choice: %llu";
    v27 = v47;
LABEL_97:
    v33 = v24;
    v34 = 12;
    goto LABEL_98;
  }
  v15 = &v51[2];
  v4[23] = 0xA000000000000001;
LABEL_38:
  v19 = *v15;
  v4[24] = *v14;
  v4[25] = v19;
  if (!v4[17] || !v4[18])
  {
    v16 = sub_100011628("SecError");
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      goto LABEL_31;
    LOWORD(v51[0]) = 0;
    v26 = "ResponseData with missing producedAt";
    goto LABEL_77;
  }
  v46 = 0;
  *((double *)v4 + 2) = SecAbsoluteTimeFromDateContentWithError(24);
  if (v46)
  {
    v24 = sub_100011628("SecError");
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      goto LABEL_31;
    LODWORD(v51[0]) = 138412290;
    *(unint64_t *)((char *)v51 + 4) = v46;
    v26 = "failed to decode producedAt time: %@";
    v27 = (uint8_t *)v51;
    goto LABEL_97;
  }
  *(_QWORD *)buf = _NSConcreteStackBlock;
  *(_QWORD *)&buf[8] = 0x40000000;
  *(_QWORD *)&buf[16] = sub_10000A05C;
  v49 = &unk_1000777F8;
  v50 = &stru_1000778F0;
  v51[0] = (unint64_t)_NSConcreteStackBlock;
  v51[1] = 0x40000000;
  v51[2] = (unint64_t)sub_100009F74;
  v51[3] = (unint64_t)&unk_100077890;
  v51[4] = (unint64_t)buf;
  if (DERDecodeSequenceContentWithBlock(v4 + 19, (uint64_t)v51)
    || v4[21] && v4[22] && !sub_100040DA8((uint64_t)(v4 + 21), 0))
  {
    goto LABEL_31;
  }
  if (!v4[7] || !v4[8])
  {
    v16 = sub_100011628("SecError");
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      goto LABEL_31;
    LOWORD(v51[0]) = 0;
    v26 = "BasicOCSPResponse missing/bad signatureAlgorithm";
    goto LABEL_77;
  }
  *(_QWORD *)&v20 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v45[0] = v20;
  v45[1] = v20;
  v21 = DERParseSequenceContent(v4 + 7, (unsigned __int16)DERNumAlgorithmIdItemSpecs, (uint64_t)&DERAlgorithmIdItemSpecs, (unint64_t)v45, 0x20uLL);
  if (v21)
  {
    v37 = v21;
    v29 = sub_100011628("SecError");
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      goto LABEL_31;
    LODWORD(v51[0]) = 67109120;
    HIDWORD(v51[0]) = v37;
    v26 = "failed to parse BasicOCSPResponse signatureAlgorithm: %d";
    goto LABEL_75;
  }
  if (!v4[9] || !v4[10])
  {
    v16 = sub_100011628("SecError");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v51[0]) = 0;
      v26 = "BasicOCSPResponse missing/bad signature";
      goto LABEL_77;
    }
LABEL_31:
    sub_100008218((const void **)v4);
    return 0;
  }
  memset(v44, 170, sizeof(v44));
  v22 = DERParseBitString((uint64_t)(v4 + 9), (unint64_t *)&v44[1], v44);
  if (v22)
  {
    v38 = v22;
    v29 = sub_100011628("SecError");
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      goto LABEL_31;
    LODWORD(v51[0]) = 67109120;
    HIDWORD(v51[0]) = v38;
    v26 = "failed to parse BasicOCSPResponse signature: %d";
    goto LABEL_75;
  }
  if (v4[11] && v4[12])
  {
    v23 = sub_100009CCC((uint64_t)v4);
    if (v23)
    {
      CFRelease(v23);
      return v4;
    }
    v16 = sub_100011628("SecError");
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      goto LABEL_31;
    LOWORD(v51[0]) = 0;
    v26 = "failed to parse BasicOCSPResponse certs";
    goto LABEL_77;
  }
  return v4;
}

uint64_t DERParseSequenceToObject(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, unint64_t a5, size_t a6)
{
  uint64_t result;
  unint64_t v12[3];

  memset(v12, 170, sizeof(v12));
  result = DERDecodeItemPartialBufferGetLength(a1, v12, 0);
  if (!(_DWORD)result)
  {
    if (v12[0] == 0x2000000000000010)
      return DERParseSequenceContentToObject(&v12[1], a2, a3, a4, a5, a6);
    else
      return 2;
  }
  return result;
}

uint64_t DERParseSequenceContentToObject(unint64_t *a1, unsigned int a2, uint64_t a3, unint64_t a4, unint64_t a5, size_t a6)
{
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unsigned __int16 v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t result;
  unsigned __int16 v17;
  __int16 v18;
  unint64_t v19;
  char *v21;
  uint64_t v23;
  unint64_t v24;
  __int16 *v25;
  unint64_t v26;
  __int16 v27;
  unint64_t v28;
  char *v29;
  unint64_t v31[3];
  unint64_t v32;
  unint64_t v33;

  v32 = 0;
  if (a6)
  {
    if (a6 > a5)
      goto LABEL_59;
    bzero((void *)a4, a6);
  }
  v10 = *a1;
  v11 = a1[1];
  if (__CFADD__(*a1, v11))
    goto LABEL_58;
  v12 = v10 + v11;
  if (v10 > v12)
LABEL_59:
    __break(0x5519u);
  v32 = *a1;
  v33 = v12;
  if (a2)
  {
    v13 = 0;
    v29 = (char *)(a4 + a5);
    while (1)
    {
      memset(v31, 170, sizeof(v31));
      v15 = v32;
      v14 = v33;
      result = DERDecodeSeqNext(&v32, v31);
      if ((_DWORD)result)
        break;
      if (a2 <= v13)
        return 2;
      while (1)
      {
        if (24 * (__int16)v13 > (unint64_t)~a3)
          goto LABEL_58;
        v17 = v13;
        v18 = *(_WORD *)(a3 + 24 * v13 + 16);
        if ((v18 & 2) != 0 || v31[0] == *(_QWORD *)(a3 + 24 * v13 + 8))
          break;
        result = 2;
        if ((v18 & 1) != 0)
        {
          ++v13;
          if (a2 > (unsigned __int16)(v17 + 1))
            continue;
        }
        return result;
      }
      if ((v18 & 4) == 0)
      {
        v19 = *(_QWORD *)(a3 + 24 * v13);
        if (v19 > 0xFFFFFFFFFFFFFFEFLL || v19 + 16 > a5)
          return 7;
        if (v19 > ~a4)
          goto LABEL_58;
        v21 = (char *)(a4 + v19);
        if (v21 >= v29 || (unint64_t)v21 < a4)
          goto LABEL_59;
        *(_OWORD *)v21 = *(_OWORD *)&v31[1];
        if ((v18 & 8) != 0)
        {
          if (v15 >= v31[1])
          {
            if (v21 + 16 <= v29 && v14 >= v15 && *((_QWORD *)v21 + 1) <= v14 - v15)
            {
              *(_QWORD *)v21 = v15;
              return 3;
            }
            goto LABEL_59;
          }
          if (v21 + 16 > v29)
            goto LABEL_59;
          v23 = *((_QWORD *)v21 + 1);
          v24 = v23 + v31[1] - v15;
          if (__CFADD__(v23, v31[1] - v15))
          {
            __break(0x5500u);
            return result;
          }
          if (v14 < v15 || v24 > v14 - v15)
            goto LABEL_59;
          *(_QWORD *)v21 = v15;
          *((_QWORD *)v21 + 1) = v24;
        }
      }
      ++v13;
      if (a2 == (unsigned __int16)(v17 + 1))
      {
        if (!__CFADD__(v31[1], v31[2]))
        {
          v28 = a1[1];
          if (!__CFADD__(*a1, v28))
          {
            v10 = v31[1] + v31[2];
            v12 = *a1 + v28;
            goto LABEL_47;
          }
        }
LABEL_58:
        __break(0x5513u);
        goto LABEL_59;
      }
      if (a2 <= (unsigned __int16)(v17 + 1))
      {
        v10 = v32;
        v12 = v33;
        goto LABEL_47;
      }
    }
    if ((_DWORD)result == 1)
    {
      if (a2 <= v13)
      {
        return 0;
      }
      else
      {
        v25 = (__int16 *)(a3 + 24 * v13 + 16);
        v26 = a2 - (unint64_t)v13;
        result = 0;
        while (1)
        {
          v27 = *v25;
          v25 += 12;
          if ((v27 & 1) == 0)
            break;
          if (!--v26)
            return result;
        }
        return 5;
      }
    }
  }
  else
  {
LABEL_47:
    if (v10 == v12)
      return 0;
    else
      return 3;
  }
  return result;
}

uint64_t DERDecodeSeqNext(unint64_t *a1, unint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t result;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD v10[2];

  v10[0] = 0;
  v2 = *a1;
  v3 = a1[1];
  if (*a1 >= v3)
    return 1;
  v10[0] = *a1;
  v10[1] = v3 - v2;
  result = DERDecodeItemPartialBufferGetLength((uint64_t)v10, a2, 0);
  if (!(_DWORD)result)
  {
    v8 = a2[1];
    v7 = a2[2];
    if (!__CFADD__(v8, v7))
    {
      v9 = v8 + v7;
      if (v9 <= a1[1] && *a1 <= v9)
      {
        result = 0;
        *a1 = v9;
        return result;
      }
      __break(0x5519u);
    }
    __break(0x5513u);
  }
  return result;
}

uint64_t DERDecodeItemPartialBufferGetLength(uint64_t result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3;
  _BYTE *v4;
  _BYTE *v5;
  unsigned __int8 *v6;
  unint64_t v7;
  unint64_t v8;
  unsigned int v9;
  BOOL v10;
  unint64_t v11;
  char *v12;
  unsigned __int8 v13;
  _BYTE *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unsigned int v24;
  BOOL v25;
  char v26;
  unint64_t v27;
  _BYTE *v28;

  v3 = *(_QWORD *)(result + 8);
  if (v3 < 2)
    return 3;
  v4 = *(_BYTE **)result;
  if (*(_QWORD *)result == -1)
    goto LABEL_68;
  v5 = &v4[v3];
  v6 = v4 + 1;
  v7 = v3 - 1;
  v8 = *v4 & 0x1F;
  if ((*v4 & 0x1F) != 0x1F)
  {
    v12 = v4 + 1;
LABEL_20:
    *a2 = v8 | ((unint64_t)(*v4 & 0xE0) << 56);
    if (v12 != (char *)-1)
    {
      if (v12 >= v5 || v12 < v4)
        goto LABEL_69;
      v14 = v12 + 1;
      v15 = *v12;
      v16 = v7 - 1;
      if ((*v12 & 0x80000000) == 0)
      {
        if (a3 || v16 >= v15)
        {
          if (v16 >= v15)
            v17 = *v12;
          else
            v17 = v7 - 1;
          v10 = v5 >= v14;
          v18 = v5 - v14;
          if (v10 && v4 <= v14 && v17 <= v18)
          {
            a2[1] = (unint64_t)v14;
            a2[2] = v17;
            if (!a3)
              return 0;
LABEL_34:
            result = 0;
            *a3 = v15;
            return result;
          }
LABEL_69:
          __break(0x5519u);
LABEL_70:
          __break(0x5515u);
          return result;
        }
        return 3;
      }
      v19 = v15 & 0x7F;
      if ((v15 & 0x7F) > 8)
        return 3;
      if ((v15 & 0x7F) == 0 || v16 < v19)
        return 3;
      if (v14 >= v5 || v14 < v4)
        goto LABEL_69;
      if (!*v14)
        return 3;
      v15 = 0;
      v21 = (v19 - 1);
      v22 = v7 - v21 - 2;
      v23 = (unint64_t)&v12[v21 + 2];
      while (v14 != (_BYTE *)-1)
      {
        if (v14 >= v5)
          goto LABEL_69;
        v10 = v16-- != 0;
        if (!v10)
          goto LABEL_70;
        v24 = *v14++;
        v15 = (v15 << 8) | v24;
        LODWORD(v19) = v19 - 1;
        if (!(_DWORD)v19)
        {
          if (a3)
            v25 = 0;
          else
            v25 = v15 > v22;
          v26 = v25;
          result = 3;
          if (v15 < 0x80 || (v26 & 1) != 0)
            return result;
          if (v15 >= v22)
            v27 = v22;
          else
            v27 = v15;
          v10 = (unint64_t)v5 >= v23;
          v28 = &v5[-v23];
          if (!v10 || (unint64_t)v4 > v23 || v27 > (unint64_t)v28)
            goto LABEL_69;
          a2[1] = v23;
          a2[2] = v27;
          if (a3)
            goto LABEL_34;
          return 0;
        }
      }
    }
LABEL_68:
    __break(0x5513u);
    goto LABEL_69;
  }
  v9 = *v6;
  v10 = v9 != 128 && v9 >= 0x1F;
  if (!v10)
    return 3;
  v8 = 0;
  result = 3;
  while (v7 >= 2)
  {
    v11 = v8;
    if (v8 >> 57)
      break;
    if (v6 == (unsigned __int8 *)-1)
      goto LABEL_68;
    if (v6 >= v5 || v6 < v4)
      goto LABEL_69;
    v12 = (char *)(v6 + 1);
    --v7;
    v13 = *v6;
    v8 = *v6++ & 0x7F | (v8 << 7);
    if ((v13 & 0x80) == 0)
    {
      if (v11 >> 54)
        return 3;
      goto LABEL_20;
    }
  }
  return result;
}

uint64_t DERParseSequence(uint64_t result, unsigned int a2, uint64_t a3, unint64_t a4, size_t a5)
{
  if ((a4 | 0x7FFFFFFFFFFFFFFFLL) >= a4)
    return DERParseSequenceToObject(result, a2, a3, a4, ~a4 & 0x7FFFFFFFFFFFFFFFLL, a5);
  __break(0x5519u);
  return result;
}

unint64_t *DERParseSequenceContent(unint64_t *result, unsigned int a2, uint64_t a3, unint64_t a4, size_t a5)
{
  if ((a4 | 0x7FFFFFFFFFFFFFFFLL) >= a4)
    return (unint64_t *)DERParseSequenceContentToObject(result, a2, a3, a4, ~a4 & 0x7FFFFFFFFFFFFFFFLL, a5);
  __break(0x5519u);
  return result;
}

uint64_t sub_100009668(_QWORD *a1)
{
  _QWORD *v2;
  uint64_t v3;
  NSObject *v4;
  const char *v5;
  __int128 v6;
  NSObject *v7;
  uint8_t *v9;
  NSObject *v10;
  uint32_t v11;
  unint64_t v12[3];
  __int16 v13;
  unint64_t v14;
  unint64_t v15[4];
  uint8_t buf[40];

  v2 = malloc_type_calloc(1uLL, 0x30uLL, 0x1060040FCA6B05FuLL);
  v3 = (uint64_t)v2;
  if (!v2)
    return v3;
  *(_BYTE *)v2 = -1;
  v2[1] = 0;
  v2[2] = 0;
  v2[3] = 0;
  *((_DWORD *)v2 + 8) = -1;
  v2[5] = 0;
  if (!a1[2] || !a1[3])
  {
    v4 = sub_100011628("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v5 = "missing certStatus in SingleResponse";
      goto LABEL_40;
    }
LABEL_34:
    sub_10000A22C((_QWORD *)v3);
    return 0;
  }
  memset(v12, 170, sizeof(v12));
  if (DERDecodeItem((uint64_t)(a1 + 2), v12))
  {
    v4 = sub_100011628("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v5 = "failed to decode certStatus in SingleResponse";
      goto LABEL_40;
    }
    goto LABEL_34;
  }
  if (v12[0] != 0xA000000000000001)
  {
    if (v12[0] == 0x8000000000000002)
    {
      *(_BYTE *)v3 = 2;
      if (v12[2])
      {
        v4 = sub_100011628("SecError");
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          v5 = "invalid Unknown certStatus content";
          goto LABEL_40;
        }
        goto LABEL_34;
      }
    }
    else
    {
      if (v12[0] != 0x8000000000000000)
      {
        v7 = sub_100011628("SecError");
        if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          goto LABEL_34;
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)&buf[4] = v12[0];
        v5 = "Unknown cert status: %llu";
        v9 = buf;
LABEL_51:
        v10 = v7;
        v11 = 12;
        goto LABEL_52;
      }
      *(_BYTE *)v3 = 0;
      if (v12[2])
      {
        v4 = sub_100011628("SecError");
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          v5 = "invalid Good certStatus content";
LABEL_40:
          v9 = buf;
LABEL_41:
          v10 = v4;
          v11 = 2;
LABEL_52:
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v5, v9, v11);
          goto LABEL_34;
        }
        goto LABEL_34;
      }
    }
    goto LABEL_22;
  }
  *(_BYTE *)v3 = 1;
  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)buf = v6;
  *(_OWORD *)&buf[16] = v6;
  if (DERParseSequenceContentToObject(&v12[1], 2u, (uint64_t)&unk_100061E40, (unint64_t)buf, 0x20uLL, 0x20uLL))
  {
    v4 = sub_100011628("SecError");
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      goto LABEL_34;
    LOWORD(v15[0]) = 0;
    v5 = "failed to parse RevokedInfo";
LABEL_55:
    v9 = (uint8_t *)v15;
    goto LABEL_41;
  }
  if (!*(_QWORD *)buf || !*(_QWORD *)&buf[8])
  {
    v4 = sub_100011628("SecError");
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      goto LABEL_34;
    LOWORD(v15[0]) = 0;
    v5 = "RevokedInfo missing revocationTime";
    goto LABEL_55;
  }
  v14 = 0;
  *(double *)(v3 + 24) = SecAbsoluteTimeFromDateContentWithError(24);
  if (v14)
  {
    v7 = sub_100011628("SecError");
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      goto LABEL_34;
    LODWORD(v15[0]) = 138412290;
    *(unint64_t *)((char *)v15 + 4) = v14;
    v5 = "failed to decode revocationTime: %@";
LABEL_58:
    v9 = (uint8_t *)v15;
    goto LABEL_51;
  }
  if (*(_QWORD *)&buf[16] && *(_QWORD *)&buf[24])
  {
    memset(v15, 170, 24);
    if (DERDecodeItem((uint64_t)&buf[16], v15))
    {
      v4 = sub_100011628("SecError");
      if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        goto LABEL_34;
      v13 = 0;
      v5 = "failed to parse revocation reason";
    }
    else
    {
      if (v15[0] == 10 && v15[2] == 1)
      {
        *(_DWORD *)(v3 + 32) = *(unsigned __int8 *)v15[1];
        goto LABEL_22;
      }
      v4 = sub_100011628("SecError");
      if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        goto LABEL_34;
      v13 = 0;
      v5 = "failed to parse revocation reason";
    }
    v9 = (uint8_t *)&v13;
    goto LABEL_41;
  }
LABEL_22:
  if (!a1[4] || !a1[5])
  {
    v4 = sub_100011628("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v5 = "SingleResponse missing thisUpdate";
      goto LABEL_40;
    }
    goto LABEL_34;
  }
  *(double *)(v3 + 8) = SecAbsoluteTimeFromDateContentWithError(24);
  if (a1[6])
  {
    if (a1[7])
    {
      memset(buf, 170, 24);
      v12[0] = 0;
      if (DERDecodeItem((uint64_t)(a1 + 6), (unint64_t *)buf)
        || *(_QWORD *)buf != 24
        || (*(double *)(v3 + 16) = SecAbsoluteTimeFromDateContentWithError(24), v12[0]))
      {
        v7 = sub_100011628("SecError");
        if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          goto LABEL_34;
        LODWORD(v15[0]) = 138412290;
        *(unint64_t *)((char *)v15 + 4) = v12[0];
        v5 = "failed to decode nextUpdate: %@";
        goto LABEL_58;
      }
    }
  }
  if (a1[8] && a1[9] && !sub_100040DA8((uint64_t)(a1 + 8), v3))
    goto LABEL_34;
  return v3;
}

uint64_t DERDecodeItem(uint64_t a1, unint64_t *a2)
{
  return DERDecodeItemPartialBufferGetLength(a1, a2, 0);
}

uint64_t DERParseBitString(uint64_t result, unint64_t *a2, _BYTE *a3)
{
  unsigned int v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unsigned __int8 *v8;
  unint64_t v10;

  *a3 = 0;
  *a2 = 0;
  a2[1] = 0;
  if (!*(_QWORD *)(result + 8))
    return 3;
  v3 = **(unsigned __int8 **)result;
  *a3 = v3;
  v4 = *(_QWORD *)(result + 8);
  if (v4 != 1)
  {
    if (v3 <= 7)
    {
      v5 = v4 - 1;
      if (!v4)
      {
LABEL_20:
        __break(0x5515u);
        goto LABEL_21;
      }
      v6 = *(_QWORD *)result;
      v7 = *(_QWORD *)result + v4;
      v8 = (unsigned __int8 *)(*(_QWORD *)result + v5);
      if ((unint64_t)v8 >= v7 || (unint64_t)v8 < v6)
      {
LABEL_19:
        __break(0x5519u);
        goto LABEL_20;
      }
      if (((0xFFu >> (8 - v3)) & *v8) == 0)
      {
        if (v6 == -1)
        {
LABEL_21:
          __break(0x5513u);
          return result;
        }
        v10 = v6 + 1;
        if (v6 + 1 <= v7 && v6 <= v10)
        {
          result = 0;
          *a2 = v10;
          a2[1] = v5;
          return result;
        }
        goto LABEL_19;
      }
    }
    return 3;
  }
  if (v3)
    return 3;
  else
    return 0;
}

__CFArray *sub_100009CCC(uint64_t a1)
{
  __CFArray *Mutable;
  unint64_t v3;
  const void *v4;
  const void *v5;
  uint64_t Length;
  uint64_t v7;
  unint64_t v9;
  unint64_t v10[3];
  unint64_t v11[3];

  Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  if (Mutable && *(_QWORD *)(a1 + 88) && *(_QWORD *)(a1 + 96))
  {
    memset(v11, 170, sizeof(v11));
    if (DERDecodeItem(a1 + 88, v11) || v11[0] != 0x2000000000000010)
      goto LABEL_14;
    if (v11[2])
    {
      while ((uint64_t)v11[2] >= 1)
      {
        v9 = 0;
        memset(v10, 170, sizeof(v10));
        if (DERDecodeItemPartialBufferGetLength((uint64_t)&v11[1], v10, &v9))
          goto LABEL_14;
        if (v10[0] != 0x2000000000000010)
          goto LABEL_14;
        v3 = v11[2];
        if (v3 < DERLengthOfItem(0x2000000000000010uLL, v9))
          goto LABEL_14;
        DERLengthOfItem(0x2000000000000010uLL, v9);
        v4 = (const void *)SecCertificateCreateWithBytes(0);
        if (!v4)
          goto LABEL_14;
        v5 = v4;
        CFArrayAppendValue(Mutable, v4);
        Length = SecCertificateGetLength(v5);
        v11[1] += Length;
        v7 = SecCertificateGetLength(v5);
        v11[2] -= v7;
        CFRelease(v5);
      }
      if (!CFArrayGetCount(Mutable))
      {
LABEL_14:
        CFRelease(Mutable);
        return 0;
      }
    }
  }
  return Mutable;
}

unint64_t DERLengthOfItem(unint64_t result, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  BOOL v4;
  uint64_t v5;
  unint64_t v6;
  BOOL v7;
  uint64_t v8;

  v2 = result & 0x1FFFFFFFFFFFFFFFLL;
  v3 = 1;
  if ((result & 0x1FFFFFFFFFFFFFFFLL) >= 0x1F)
  {
    do
    {
      ++v3;
      v4 = v2 > 0x7F;
      v2 >>= 7;
    }
    while (v4);
  }
  v5 = 1;
  if (a2 >= 0x80)
  {
    v6 = a2;
    do
    {
      ++v5;
      v4 = v6 > 0xFF;
      v6 >>= 8;
    }
    while (v4);
  }
  v7 = __CFADD__(v3, v5);
  v8 = v3 + v5;
  if (v7 || (result = v8 + a2, __CFADD__(v8, a2)))
    __break(0x5500u);
  return result;
}

uint64_t DERDecodeSequenceContentWithBlock(unint64_t *a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t result;
  char v7;
  unint64_t v8[3];
  unint64_t v9[2];

  v9[0] = 0;
  v2 = *a1;
  v3 = a1[1];
  if (__CFADD__(*a1, v3))
  {
    __break(0x5513u);
LABEL_13:
    __break(0x5519u);
  }
  v4 = v2 + v3;
  if (v2 > v4)
    goto LABEL_13;
  v9[0] = *a1;
  v9[1] = v4;
  memset(v8, 170, sizeof(v8));
  v7 = 0;
  while (1)
  {
    LODWORD(result) = DERDecodeSeqNext(v9, v8);
    if ((_DWORD)result)
      break;
    LODWORD(result) = (*(uint64_t (**)(uint64_t, unint64_t *, char *))(a2 + 16))(a2, v8, &v7);
    if ((_DWORD)result)
      break;
    if (v7)
      return 0;
  }
  if (result <= 1)
    return 0;
  else
    return result;
}

uint64_t sub_100009F74(uint64_t a1, _QWORD *a2)
{
  __int128 v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  uint8_t v8[16];
  _OWORD v9[5];

  if (*a2 != 0x2000000000000010)
    return 2;
  *(_QWORD *)&v3 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v9[3] = v3;
  v9[4] = v3;
  v9[1] = v3;
  v9[2] = v3;
  v9[0] = v3;
  v4 = DERParseSequenceContentToObject(a2 + 1, 5u, (uint64_t)&unk_100061DC8, (unint64_t)v9, 0x50uLL, 0x50uLL);
  if (!(_DWORD)v4)
    return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  v5 = v4;
  v6 = sub_100011628("SecError");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v8 = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "failed to parse single response", v8, 2u);
  }
  return v5;
}

uint64_t sub_10000A05C(uint64_t a1, unint64_t *a2)
{
  __int128 v4;
  uint64_t v5;
  _QWORD *v6;
  __int128 v7;
  uint64_t v8;
  unint64_t *v9;
  uint64_t v10;
  NSObject *v12;
  const char *v13;
  NSObject *v14;
  uint8_t v15[16];
  _OWORD v16[2];
  _OWORD v17[4];

  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v16[0] = v4;
  v16[1] = v4;
  v5 = sub_100009668(a2);
  if (!v5)
    return 3;
  v6 = (_QWORD *)v5;
  *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v17[2] = v7;
  v17[3] = v7;
  v17[0] = v7;
  v17[1] = v7;
  v8 = DERParseSequenceContentToObject(a2, 4u, (uint64_t)&unk_100061E70, (unint64_t)v17, 0x40uLL, 0x40uLL);
  if ((_DWORD)v8)
  {
    v10 = v8;
    v12 = sub_100011628("SecError");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v15 = 0;
      v13 = "failed to parse certId in single response";
LABEL_15:
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v13, v15, 2u);
    }
  }
  else
  {
    v9 = DERParseSequenceContent((unint64_t *)v17, (unsigned __int16)DERNumAlgorithmIdItemSpecs, (uint64_t)&DERAlgorithmIdItemSpecs, (unint64_t)v16, 0x20uLL);
    if (!(_DWORD)v9)
    {
      if (a2[8] && a2[9] && !sub_100040DA8((uint64_t)(a2 + 8), (uint64_t)v6))
      {
        v14 = sub_100011628("SecError");
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v15 = 0;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "failed to parse single extensions", v15, 2u);
        }
        v10 = 3;
      }
      else
      {
        v10 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
      }
      goto LABEL_8;
    }
    v10 = (uint64_t)v9;
    v12 = sub_100011628("SecError");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v15 = 0;
      v13 = "failed to parse certId hash algorithm";
      goto LABEL_15;
    }
  }
LABEL_8:
  sub_10000A22C(v6);
  return v10;
}

void sub_10000A22C(_QWORD *a1)
{
  const void *v2;

  v2 = (const void *)a1[5];
  if (v2)
    CFRelease(v2);
  free(a1);
}

int sub_10000A258(id a1, __SecOCSPSingleResponse *a2, $3D017E90C94C14BBF0A398495D9CDFD8 *a3, $B6A9763D8B6220BE6062EFE4851A1D27 *a4, BOOL *a5)
{
  return 0;
}

uint64_t sub_10000A260(uint64_t a1, unint64_t *a2, _BYTE *a3)
{
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t PublicKeyData;
  uint64_t v10;
  const __CFData *v11;
  const __CFData *v12;
  uint64_t v13;
  __CFData *v14;
  __CFData *v15;
  uint64_t v16;
  uint64_t v17;
  const UInt8 *BytePtr;
  uint64_t v19;
  unint64_t *v21;
  const UInt8 *v22;
  CFIndex Length;
  uint64_t v24;
  const UInt8 *v25;
  uint64_t v26;
  const UInt8 *v27;
  NSObject *v28;
  NSObject *v29;
  const char *v30;
  uint8_t v31[16];
  _OWORD v32[2];
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;

  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v35 = v6;
  v36 = v6;
  v33 = v6;
  v34 = v6;
  v32[0] = v6;
  v32[1] = v6;
  v7 = *(_QWORD *)(a1 + 40);
  v8 = v7;
  if (*(_QWORD *)v7 && *(_QWORD *)(v7 + 8))
  {
    PublicKeyData = SecCertificateGetPublicKeyData();
    if ((*(_QWORD *)(PublicKeyData + 8) & 0x8000000000000000) != 0)
      return 7;
    v10 = PublicKeyData;
    v11 = (const __CFData *)SecCertificateCopyIssuerSequence(**(_QWORD **)(a1 + 40));
    v12 = SecCertificateCopySerialNumberData(**(SecCertificateRef **)(a1 + 40), 0);
    v13 = 0;
    v14 = 0;
    v15 = 0;
  }
  else
  {
    v15 = *(__CFData **)(v7 + 40);
    if (v15)
    {
      CFRetain(*(CFTypeRef *)(v7 + 40));
      v8 = *(_QWORD *)(a1 + 40);
    }
    v14 = *(__CFData **)(v8 + 48);
    if (v14)
    {
      CFRetain(*(CFTypeRef *)(v8 + 48));
      v8 = *(_QWORD *)(a1 + 40);
    }
    v12 = *(const __CFData **)(v8 + 56);
    if (!v12)
    {
      v19 = DERParseSequenceContentToObject(a2, 4u, (uint64_t)&unk_100061E70, (unint64_t)&v33, 0x40uLL, 0x40uLL);
      v11 = 0;
      v12 = 0;
      if (!(_DWORD)v19)
        goto LABEL_17;
      goto LABEL_48;
    }
    v13 = v7 + 24;
    CFRetain(*(CFTypeRef *)(v8 + 56));
    v10 = 0;
    v11 = 0;
  }
  v16 = DERParseSequenceContentToObject(a2, 4u, (uint64_t)&unk_100061E70, (unint64_t)&v33, 0x40uLL, 0x40uLL);
  if ((_DWORD)v16)
  {
    v19 = v16;
LABEL_48:
    v29 = sub_100011628("SecError");
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      goto LABEL_17;
    *(_WORD *)v31 = 0;
    v30 = "failed to parse certId in single response";
    goto LABEL_50;
  }
  if (!v12
    || (v17 = *((_QWORD *)&v36 + 1), v17 != CFDataGetLength(v12))
    || (BytePtr = CFDataGetBytePtr(v12), memcmp(BytePtr, (const void *)v36, *((size_t *)&v36 + 1))))
  {
LABEL_15:
    v19 = 0;
    goto LABEL_17;
  }
  if (!v10 || !v11)
  {
LABEL_36:
    if (v15 && v14)
    {
      v24 = *((_QWORD *)&v34 + 1);
      if (v24 == CFDataGetLength(v15)
        && (v25 = CFDataGetBytePtr(v15), !memcmp(v25, (const void *)v34, *((size_t *)&v34 + 1)))
        && (v26 = *((_QWORD *)&v35 + 1), v26 == CFDataGetLength(v14))
        && (v27 = CFDataGetBytePtr(v14), !memcmp(v27, (const void *)v35, *((size_t *)&v35 + 1)))
        && (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = sub_100009668(a2)) != 0)
      {
        v19 = 0;
        *a3 = 1;
      }
      else
      {
        v19 = 0;
      }
      goto LABEL_18;
    }
    v28 = sub_100011628("SecError");
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v31 = 0;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Unknown hash algorithm in singleResponse", v31, 2u);
    }
    goto LABEL_15;
  }
  v21 = DERParseSequenceContent((unint64_t *)&v33, (unsigned __int16)DERNumAlgorithmIdItemSpecs, (uint64_t)&DERAlgorithmIdItemSpecs, (unint64_t)v32, 0x20uLL);
  if (!(_DWORD)v21)
  {
    if (!DEROidCompare((uint64_t)v32, v13))
    {
      if (v15)
        CFRelease(v15);
      if (v14)
        CFRelease(v14);
      v22 = CFDataGetBytePtr(v11);
      Length = CFDataGetLength(v11);
      v15 = sub_10000A610(v22, Length, (uint64_t)v32);
      v14 = sub_10000A610(*(const void **)v10, *(_QWORD *)(v10 + 8), (uint64_t)v32);
    }
    goto LABEL_36;
  }
  v19 = (uint64_t)v21;
  v29 = sub_100011628("SecError");
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v31 = 0;
    v30 = "failed to parse certId hash algorithm";
LABEL_50:
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, v30, v31, 2u);
  }
LABEL_17:
  if (v14)
LABEL_18:
    CFRelease(v14);
  if (v15)
    CFRelease(v15);
  if (v12)
    CFRelease(v12);
  if (v11)
    CFRelease(v11);
  return v19;
}

__CFData *sub_10000A610(const void *a1, unint64_t a2, uint64_t a3)
{
  __CFData *Mutable;
  CC_LONG v6;
  unsigned __int8 *(__cdecl **v7)(const void *, CC_LONG, unsigned __int8 *);
  CFIndex v8;
  unsigned __int8 *MutableBytePtr;

  Mutable = 0;
  if (!(a2 >> 31) && a1 && a3)
  {
    v6 = a2;
    if (DEROidCompare(a3, (uint64_t)&oidSha1))
    {
      v7 = &_CC_SHA1;
      v8 = 20;
    }
    else if (DEROidCompare(a3, (uint64_t)&oidSha224))
    {
      v7 = &CC_SHA224;
      v8 = 28;
    }
    else if (DEROidCompare(a3, (uint64_t)&oidSha256))
    {
      v7 = &CC_SHA256;
      v8 = 32;
    }
    else if (DEROidCompare(a3, (uint64_t)&oidSha384))
    {
      v7 = &CC_SHA384;
      v8 = 48;
    }
    else
    {
      if (!DEROidCompare(a3, (uint64_t)&oidSha512))
        return 0;
      v7 = &CC_SHA512;
      v8 = 64;
    }
    Mutable = CFDataCreateMutable(0, v8);
    CFDataSetLength(Mutable, v8);
    MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    ((void (__cdecl *)(const void *, CC_LONG, unsigned __int8 *))v7)(a1, v6, MutableBytePtr);
  }
  return Mutable;
}

uint64_t sub_10000A744(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  _QWORD *v5;
  NSObject *v6;
  uint64_t v7;
  double v8;
  uint64_t v9;
  uint8_t v11[16];

  v4 = sub_100009668(a2);
  if (!v4)
    return 0xFFFFFFFFLL;
  v5 = (_QWORD *)v4;
  if (*(double *)(v4 + 8) <= *(double *)(a1 + 32) + 4500.0)
  {
    if (a2[6] && a2[7] && (v8 = *(double *)(v4 + 16), v9 = *(_QWORD *)(a1 + 40), v8 > *(double *)(v9 + 24)))
    {
      v7 = 0;
      *(double *)(v9 + 24) = v8;
    }
    else
    {
      v7 = 0;
    }
  }
  else
  {
    v6 = sub_100011628("ocsp");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v11 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "OCSPResponse: thisUpdate more than 1:15 from now", v11, 2u);
    }
    v7 = 0xFFFFFFFFLL;
  }
  sub_10000A22C(v5);
  return v7;
}

uint64_t sub_10000A834(uint64_t result, const void *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  CFIndex v6;
  uint64_t v7;

  v2 = *(_QWORD *)(*(_QWORD *)result + 200);
  if (v2)
  {
    v3 = *(_QWORD *)(v2 + 16);
    if (v3 >= 1)
    {
      v5 = result;
      v6 = 0;
LABEL_4:
      if (v6 < 0
        || *(_QWORD *)(v2 + 16) <= v6
        || (v7 = *(_QWORD *)(v2 + 8 * v6 + 136)) == 0
        || (result = *(_QWORD *)(v7 + 16)) == 0
        || (result = SecCertificateIsWeakKey(result), !(_DWORD)result)
        || (result = sub_10000E2C8(v5, a2, v6, kCFBooleanFalse, 0, 0), (_DWORD)result))
      {
        while (++v6 < v3)
        {
          v2 = *(_QWORD *)(*(_QWORD *)v5 + 200);
          if (v2)
            goto LABEL_4;
        }
      }
    }
  }
  return result;
}

void sub_10000A8F8(uint64_t a1)
{
  uint64_t v2;
  sqlite3_stmt *v3;
  const UInt8 *BytePtr;
  unint64_t Length;
  uint64_t v6;
  sqlite3_stmt *v7;
  const UInt8 *v8;
  unint64_t v9;
  uint64_t v10;
  BOOL v11;
  const void *v12;
  const __CFData *v13;
  NSObject *v14;
  uint64_t v15;
  _BYTE *v16;
  const UInt8 *v17;
  int v18;
  CFPropertyListRef v19;
  CFTypeID v20;
  _DWORD v21[2];

  v2 = *(_QWORD *)(a1 + 56);
  if (*(_BYTE *)(v2 + 33))
  {
    v3 = *(sqlite3_stmt **)(v2 + 24);
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
    Length = CFDataGetLength(*(CFDataRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
    if (Length >> 31)
    {
LABEL_5:
      v10 = 18;
LABEL_6:
      v11 = sub_10001A970(v10, *(sqlite3_stmt **)(*(_QWORD *)(a1 + 56) + 24), *(CFTypeRef **)(a1 + 64), CFSTR("sqlite3_bind_blob failed"));
LABEL_7:
      v12 = 0;
      v13 = 0;
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v11;
      goto LABEL_8;
    }
    v6 = sqlite3_bind_blob(v3, 1, BytePtr, Length, 0);
    if ((_DWORD)v6)
      goto LABEL_35;
    v7 = *(sqlite3_stmt **)(*(_QWORD *)(a1 + 56) + 24);
    v8 = CFDataGetBytePtr(*(CFDataRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24));
    v9 = CFDataGetLength(*(CFDataRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24));
    if (v9 >> 31)
      goto LABEL_5;
    v6 = sqlite3_bind_blob(v7, 2, v8, v9, 0);
    if ((_DWORD)v6)
    {
LABEL_35:
      v10 = v6;
      goto LABEL_6;
    }
    v15 = sqlite3_step(*(sqlite3_stmt **)(*(_QWORD *)(a1 + 56) + 24));
    LODWORD(v10) = v15;
    v12 = 0;
    if (!(_DWORD)v15 || (_DWORD)v15 == 101)
    {
      v13 = 0;
      goto LABEL_8;
    }
    if ((_DWORD)v15 != 100)
    {
      v11 = sub_10001A970(v15, *(sqlite3_stmt **)(*(_QWORD *)(a1 + 56) + 24), *(CFTypeRef **)(a1 + 64), CFSTR("sqlite3_step failed"));
      goto LABEL_7;
    }
    v16 = *(_BYTE **)(a1 + 72);
    if (v16)
      *v16 = 1;
    if (*(_QWORD *)(a1 + 80))
    {
      v17 = (const UInt8 *)sqlite3_column_blob(*(sqlite3_stmt **)(*(_QWORD *)(a1 + 56) + 24), 0);
      v18 = sqlite3_column_bytes(*(sqlite3_stmt **)(*(_QWORD *)(a1 + 56) + 24), 0);
      v13 = CFDataCreate(0, v17, v18);
      if (v13)
      {
        v19 = CFPropertyListCreateWithData(0, v13, 0, 0, *(CFErrorRef **)(a1 + 64));
        v12 = v19;
        if (v19)
        {
          v20 = CFGetTypeID(v19);
          if (v20 == CFArrayGetTypeID())
          {
            **(_QWORD **)(a1 + 80) = CFRetain(v12);
LABEL_31:
            LODWORD(v10) = 100;
            goto LABEL_8;
          }
        }
      }
      else
      {
        v12 = 0;
      }
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
      goto LABEL_31;
    }
    v12 = 0;
    v13 = 0;
    goto LABEL_31;
  }
  v12 = 0;
  v13 = 0;
  LODWORD(v10) = 0;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
LABEL_8:
  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    v14 = sub_100011628("SecError");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      v21[0] = 67109120;
      v21[1] = v10;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Failed to query for cert in trust store: %d", (uint8_t *)v21, 8u);
    }
    sub_1000521A8(4, 3, (int)v10);
  }
  sqlite3_reset(*(sqlite3_stmt **)(*(_QWORD *)(a1 + 56) + 24));
  sqlite3_clear_bindings(*(sqlite3_stmt **)(*(_QWORD *)(a1 + 56) + 24));
  if (v13)
    CFRelease(v13);
  if (v12)
    CFRelease(v12);
}

uint64_t sub_10000ABFC(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  CFDictionaryRef *ValueAtIndex;
  uint64_t result;
  uint64_t v8;
  CFIndex i;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v4)
    v5 = *(_QWORD *)(v4 + 16);
  else
    v5 = 0;
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (v5 >= 1)
  {
    v8 = result;
    for (i = 0; i < v5; ++i)
    {
      v10 = 0;
      v11 = *(_QWORD *)(*(_QWORD *)a1 + 200);
      if (v11 && (i & 0x8000000000000000) == 0)
      {
        if (*(_QWORD *)(v11 + 16) > i && (v12 = *(_QWORD *)(v11 + 8 * i + 136)) != 0)
          v10 = *(_QWORD *)(v12 + 16);
        else
          v10 = 0;
      }
      result = SecPolicyCheckCertWeakSignature(v10, v8);
      if ((result & 1) == 0)
      {
        result = sub_10000E2C8(a1, a2, i, kCFBooleanFalse, 0, 0);
        if (!(_DWORD)result)
          break;
      }
    }
  }
  return result;
}

_QWORD *sub_10000ACE8(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (qword_100082BF0)
  {
    v1 = result;
    v2 = *(_QWORD *)(qword_100082BF0 + 40);
    if (v2)
      result = CFRetain(*(CFTypeRef *)(qword_100082BF0 + 40));
    *(_QWORD *)(*(_QWORD *)(v1[4] + 8) + 24) = v2;
  }
  return result;
}

void sub_10000AD2C(uint64_t a1)
{
  const __CFDictionary *v2;
  void *Value;
  void *v4;
  CFTypeID v5;
  CFTypeID v6;

  if (qword_100082BF0)
  {
    v2 = *(const __CFDictionary **)(qword_100082BF0 + 168);
    if (v2)
    {
      Value = (void *)CFDictionaryGetValue(v2, *(const void **)(a1 + 32));
      if (Value)
      {
        if ((v4 = Value, v5 = CFGetTypeID(Value), v5 == CFNumberGetTypeID())
          && CFNumberGetType((CFNumberRef)v4) == kCFNumberSInt64Type
          || (v6 = CFGetTypeID(v4), v6 == CFNumberGetTypeID())
          && CFNumberGetType((CFNumberRef)v4) == kCFNumberSInt32Type)
        {
          objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), v4);
        }
      }
    }
  }
}

void sub_10000ADE0(void (**a1)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  ++qword_100082E80;
  a1[2](a1, a5, a3, a4, a2, 0);
  _Block_release(a1);
}

void sub_10000AE28(uint64_t a1, int64_t value, const __CFString *a3, const __CFString *a4, const __CFArray *a5, void *cf)
{
  __CFError *v7;
  uint64_t v11;
  void *v12;
  xpc_object_t v13;
  void *v14;
  xpc_object_t v15;
  void *v16;
  CFTypeRef v17;
  const void *v18;
  const void *v19;
  CFTypeRef cfa;
  _QWORD context[6];
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  CFRange v26;

  cfa = cf;
  if (cf)
  {
    v7 = (__CFError *)cf;
    CFRetain(cf);
LABEL_14:
    v15 = sub_10002BA74(v7);
    if (v15)
    {
      v16 = v15;
      xpc_dictionary_set_value(*(xpc_object_t *)(a1 + 32), "error", v15);
      xpc_release(v16);
    }
    v17 = cfa;
    if (cfa)
    {
      cfa = 0;
      CFRelease(v17);
    }
    goto LABEL_18;
  }
  xpc_dictionary_set_int64(*(xpc_object_t *)(a1 + 32), "result", value);
  if ((!a3 || sub_10000B024(*(void **)(a1 + 32), "details", a3, &cfa, v11))
    && (!a4 || sub_10000B024(*(void **)(a1 + 32), "info", a4, &cfa, v11))
    && a5)
  {
    v12 = *(void **)(a1 + 32);
    v22 = 0;
    v23 = &v22;
    v24 = 0x2000000000;
    v25 = 0;
    v13 = xpc_array_create(0, 0);
    v23[3] = (uint64_t)v13;
    if (v13)
    {
      context[0] = _NSConcreteStackBlock;
      context[1] = 0x40000000;
      context[2] = sub_10000700C;
      context[3] = &unk_100075D18;
      context[4] = &v22;
      context[5] = &cfa;
      v26.length = CFArrayGetCount(a5);
      v26.location = 0;
      CFArrayApplyFunction(a5, v26, (CFArrayApplierFunction)sub_100006B5C, context);
    }
    else
    {
      sub_100012C88(-50, (__CFString **)&cfa, CFSTR("xpc_array_create failed"));
    }
    v14 = (void *)v23[3];
    if (v14)
    {
      xpc_dictionary_set_value(v12, "chain", v14);
      xpc_release((xpc_object_t)v23[3]);
    }
    _Block_object_dispose(&v22, 8);
  }
  v7 = (__CFError *)cfa;
  if (cfa)
    goto LABEL_14;
LABEL_18:
  xpc_connection_send_message(*(xpc_connection_t *)(a1 + 40), *(xpc_object_t *)(a1 + 32));
  xpc_release(*(xpc_object_t *)(a1 + 32));
  xpc_release(*(xpc_object_t *)(a1 + 40));
  v18 = *(const void **)(a1 + 48);
  if (v18)
    CFRelease(v18);
  v19 = *(const void **)(a1 + 112);
  if (v19)
    CFRelease(v19);
}

uint64_t sub_10000B024(void *a1, const char *a2, const __CFString *a3, CFTypeRef *a4, uint64_t a5)
{
  size_t v9;
  size_t v10;
  UInt8 *v11;
  unint64_t v12;
  const void *v13;
  BOOL v14;
  uint64_t v15;

  v9 = sub_100004520(a3, a4, (uint64_t)a3, (uint64_t)a4, a5);
  if (!v9)
    return 0;
  v10 = v9;
  v11 = (UInt8 *)malloc_type_malloc(v9, 0x91A96E61uLL);
  v12 = (unint64_t)&v11[v10];
  v13 = (const void *)sub_10000B258(a3, a4, 0, v11, v12);
  if (v13)
    v14 = v12 > (unint64_t)v13;
  else
    v14 = 0;
  v15 = v14;
  if ((_DWORD)v15 == 1)
    xpc_dictionary_set_data(a1, a2, v13, v12 - (_QWORD)v13);
  free(v11);
  return v15;
}

uint64_t sub_10000B0D8(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)a3)
  {
    result = sub_10000BBAC(result, a2, *(CFTypeRef **)(a3 + 16));
    if (result)
      *(_QWORD *)(a3 + 8) += result;
    else
      *(_BYTE *)a3 = 0;
  }
  return result;
}

void sub_10000B11C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFIndex v6;
  CFIndex v7;
  __CFData *Mutable;
  UInt8 *MutableBytePtr;
  UInt8 *v10;
  CFTypeRef *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  CFRange v18;

  if (*(_BYTE *)a3)
  {
    v6 = sub_10000BBAC(a1, a2, *(CFTypeRef **)(a3 + 8));
    if (!v6)
    {
      *(_BYTE *)a3 = 0;
      return;
    }
    v7 = v6;
    Mutable = CFDataCreateMutable(*(CFAllocatorRef *)(a3 + 24), v6);
    CFDataSetLength(Mutable, v7);
    MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    v10 = &MutableBytePtr[v7];
    v11 = *(CFTypeRef **)(a3 + 8);
    v12 = *(unsigned __int8 *)(a3 + 1);
    v13 = sub_10000B258(a2, v11, v12, MutableBytePtr, v10);
    v14 = sub_10000B258(a1, v11, v12, MutableBytePtr, v13);
    v15 = ccder_encode_constructed_tl(0x2000000000000010, v10, MutableBytePtr, v14);
    if (v15)
    {
      v18.length = v15 - (_QWORD)MutableBytePtr;
      v18.location = 0;
      CFDataDeleteBytes(Mutable, v18);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 16), Mutable);
      if (!Mutable)
        return;
    }
    else
    {
      sub_10002A5E8(-7, CFSTR("com.apple.security.cfder.error"), v16, v11, v17, CFSTR("ccder failed to encode"));
      *(_BYTE *)a3 = 0;
      if (!Mutable)
        return;
    }
    CFRelease(Mutable);
  }
}

uint64_t sub_10000B258(const __CFString *a1, CFTypeRef *a2, uint64_t a3, UInt8 *a4, unint64_t a5)
{
  CFTypeID v10;
  CFIndex Count;
  uint64_t v12;
  unint64_t v13;
  const void *ValueAtIndex;
  uint64_t v15;
  unint64_t v16;
  UInt8 *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  CFIndex Length;
  const UInt8 *BytePtr;
  double AbsoluteTime;
  uint64_t v30;
  uint64_t v31;
  int v32;
  __CFString *v33;
  NSObject *v34;
  const char *v35;
  CFErrorRef v36;
  unint64_t v37;
  int v38;
  int v39;
  int v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  unint64_t v46;
  _BYTE *v47;
  char v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  size_t v53;
  void *v54;
  int v55;
  NSObject *v56;
  CFTypeRef v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v62;
  unsigned int v63;
  unint64_t v64;
  int v65;
  int v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  CFErrorRef err;
  CFErrorRef *p_err;
  uint64_t v73;
  char v74;
  int v75;
  int v76;
  _BYTE buf[24];
  void *v78;
  CFErrorRef *v79;
  double v80;
  char *v81;
  uint64_t *v82;
  char *v83;
  uint64_t *v84;
  char *v85;
  uint64_t *v86;

  if (!a1)
  {
    sub_10002A5E8(-5, CFSTR("com.apple.security.cfder.error"), a3, a2, a5, CFSTR("Null CFType"));
    return 0;
  }
  v10 = CFGetTypeID(a1);
  if (CFArrayGetTypeID() == v10)
  {
    Count = CFArrayGetCount((CFArrayRef)a1);
    v12 = a5;
    if (Count >= 1)
    {
      v13 = Count + 1;
      v12 = a5;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, v13 - 2);
        v12 = sub_10000B258(ValueAtIndex, a2, a3, a4, v12);
        --v13;
      }
      while (v13 > 1);
    }
    v15 = 0x2000000000000010;
    v16 = a5;
    v17 = a4;
    v18 = v12;
    goto LABEL_7;
  }
  if (CFBooleanGetTypeID() == v10)
  {
    buf[0] = CFBooleanGetValue((CFBooleanRef)a1);
    v23 = ccder_encode_body(1, buf, a4, a5);
    v24 = 1;
    v25 = 1;
LABEL_14:
    v19 = ccder_encode_tl(v24, v25, a4, v23);
LABEL_15:
    v22 = v19;
    if (!v19)
      sub_10002A5E8(-7, CFSTR("com.apple.security.cfder.error"), v20, a2, v21, CFSTR("ccder failed to encode"));
    return v22;
  }
  if (CFDataGetTypeID() == v10)
  {
    Length = CFDataGetLength((CFDataRef)a1);
    BytePtr = CFDataGetBytePtr((CFDataRef)a1);
    v23 = ccder_encode_body(Length, BytePtr, a4, a5);
    v24 = 4;
    v25 = Length;
    goto LABEL_14;
  }
  if (CFDateGetTypeID() == v10)
  {
    AbsoluteTime = CFDateGetAbsoluteTime((CFDateRef)a1);
    v69 = 0;
    v70 = 0;
    v68 = 0;
    err = 0;
    p_err = &err;
    v73 = 0x2000000000;
    v74 = -86;
    *(_QWORD *)buf = _NSConcreteStackBlock;
    *(_QWORD *)&buf[8] = 0x40000000;
    *(_QWORD *)&buf[16] = sub_1000070E4;
    v78 = &unk_100075EA0;
    v79 = &err;
    v80 = AbsoluteTime;
    v81 = (char *)&v70 + 4;
    v82 = &v70;
    v83 = (char *)&v69 + 4;
    v84 = &v69;
    v85 = (char *)&v68 + 4;
    v86 = &v68;
    sub_10000BF20((uint64_t)buf);
    if (*((_BYTE *)p_err + 24))
    {
      _Block_object_dispose(&err, 8);
    }
    else
    {
      sub_10002A5E8(-1, CFSTR("com.apple.security.cfder.error"), v30, a2, v31, CFSTR("Failed to encode date."));
      v32 = *((unsigned __int8 *)p_err + 24);
      _Block_object_dispose(&err, 8);
      if (!v32)
      {
        v56 = sub_100011628("SecError");
        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
        {
          if (a2)
            v57 = *a2;
          else
            v57 = 0;
          *(_DWORD *)buf = 138412290;
          *(_QWORD *)&buf[4] = v57;
          _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "der: unable to encode date: %@", buf, 0xCu);
        }
        goto LABEL_75;
      }
    }
    err = 0;
    if ((sub_10000BFAC(HIDWORD(v70), v70, HIDWORD(v69), v69, HIDWORD(v68), v68, 0, (__CFString **)&err) & 1) == 0)
    {
      v33 = (__CFString *)CFErrorCopyDescription(err);
      sub_10002B644(v33, 1405091842);
      if (v33)
        CFRelease(v33);
      v34 = sub_100011628("SecError");
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        v35 = "continuing";
        if ((_DWORD)a3)
          v35 = "setting default value";
        *(_DWORD *)buf = 138412546;
        *(_QWORD *)&buf[4] = err;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v35;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "der: invalid date: %@; %s", buf, 0x16u);
      }
      v36 = err;
      if (err)
      {
        err = 0;
        CFRelease(v36);
      }
      if ((_DWORD)a3)
      {
        v70 = 0x7D100000001;
        HIDWORD(v69) = 1;
        HIDWORD(v68) = 1;
      }
    }
    if ((unint64_t)(a4 + 1) <= a5)
    {
      *(_BYTE *)(a5 - 1) = 90;
      v37 = a5 - 1;
    }
    else
    {
      v37 = 0;
    }
    v39 = v70;
    v38 = HIDWORD(v70);
    v40 = HIDWORD(v68);
    v66 = HIDWORD(v69);
    v67 = v69;
    v41 = v68;
    v75 = -1431655766;
    v76 = -1431655766;
    *(_QWORD *)buf = 0xAAAAAAAAAAAAAAAALL;
    v42 = __dtoa(0, 0, &v76, &v75, buf, AbsoluteTime);
    v43 = v42;
    v44 = v76;
    v45 = *(_QWORD *)buf;
    if (AbsoluteTime < 0.0)
    {
      v46 = v42 + (v76 & ~(v76 >> 31));
      if (v46 < *(_QWORD *)buf)
      {
        v47 = (_BYTE *)(*(_QWORD *)buf - 1);
        for (*v47 = 106 - *(_BYTE *)(*(_QWORD *)buf - 1); (unint64_t)v47 > v46; *v47 = 105 - v48)
          v48 = *--v47;
      }
      v44 = v76;
      v45 = *(_QWORD *)buf;
    }
    v49 = v45 - v42;
    if (v45 - v43 > v44)
    {
      if ((v44 & 0x80000000) == 0)
      {
        v37 = ccder_encode_body(v49 - v44, v43 + v44, a4, v37);
LABEL_55:
        if ((unint64_t)(a4 + 1) <= v37)
          *(_BYTE *)--v37 = 46;
        else
          v37 = 0;
        goto LABEL_66;
      }
      v65 = v39;
      v51 = v38;
      v52 = ccder_encode_body(v49, v43, a4, v37);
      v53 = -(uint64_t)v76;
      v54 = (void *)ccder_encode_body_nocopy(v53, a4, v52);
      v37 = (unint64_t)v54;
      if (v54)
      {
        if (AbsoluteTime >= 0.0)
          v55 = 48;
        else
          v55 = 57;
        memset(v54, v55, v53);
        v38 = v51;
        v39 = v65;
        goto LABEL_55;
      }
      v38 = v51;
      v39 = v65;
    }
LABEL_66:
    __freedtoa(v43);
    if (v37)
    {
      v62 = (unint64_t)(a4 + 2);
      if ((unint64_t)(a4 + 2) <= v37)
      {
        *(_BYTE *)(v37 - 2) = v41 / 10 + 48;
        *(_BYTE *)(v37 - 1) = v41 % 10 + 48;
        if (v62 <= v37 - 2)
        {
          *(_BYTE *)(v37 - 4) = v40 / 10 + 48;
          *(_BYTE *)(v37 - 3) = v40 % 10 + 48;
          if (v62 <= v37 - 4)
          {
            *(_BYTE *)(v37 - 6) = v67 / 10 + 48;
            *(_BYTE *)(v37 - 5) = v67 % 10 + 48;
            if (v62 <= v37 - 6)
            {
              *(_BYTE *)(v37 - 8) = v66 / 10 + 48;
              *(_BYTE *)(v37 - 7) = v66 % 10 + 48;
              if (v62 <= v37 - 8)
              {
                *(_BYTE *)(v37 - 10) = v39 / 10 + 48;
                *(_BYTE *)(v37 - 9) = v39 % 10 + 48;
                if (v62 <= v37 - 10)
                {
                  v63 = (((103 * (v38 % 100)) >> 15) & 1) + ((103 * (v38 % 100)) >> 10);
                  *(_BYTE *)(v37 - 12) = v63 + 48;
                  *(_BYTE *)(v37 - 11) = v38 % 100 - 10 * v63 + 48;
                  if (v62 <= v37 - 12)
                  {
                    *(_BYTE *)(v37 - 14) = v38 / 1000 + 48;
                    v64 = v37 - 14;
                    *(_BYTE *)(v64 + 1) = v38 / 100 % 10 + 48;
                    goto LABEL_76;
                  }
                }
              }
            }
          }
        }
      }
    }
    sub_10002A5E8(-7, CFSTR("com.apple.security.cfder.error"), v60, a2, v61, CFSTR("ccder failed to encode"));
LABEL_75:
    v64 = 0;
LABEL_76:
    v15 = 24;
    v16 = a5;
    v17 = a4;
    v18 = v64;
LABEL_7:
    v19 = ccder_encode_constructed_tl(v15, v16, v17, v18);
    goto LABEL_15;
  }
  if (CFDictionaryGetTypeID() == v10)
    return sub_10000BDB0((const __CFDictionary *)a1, a2, a3, (uint64_t)a4, a5);
  if (CFSetGetTypeID() == v10)
    return sub_10002B250((const __CFSet *)a1, a2, a3, (uint64_t)a4, a5);
  if (CFStringGetTypeID() == v10)
    return sub_10000BCAC(a1, a2, a4, a5, v50);
  if (CFNumberGetTypeID() == v10)
    return sub_10002A1FC((const __CFNumber *)a1, a2, (uint64_t)a4, a5);
  if (CFNullGetTypeID() != v10)
  {
    sub_10002A5E8(-5, CFSTR("com.apple.security.cfder.error"), v58, a2, v59, CFSTR("Unsupported CFType"));
    return 0;
  }
  return sub_10002B154(a2, (uint64_t)a4, a5);
}

uint64_t sub_10000BBAC(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5 = sub_100004520(a1, a3);
  if (v5)
  {
    v8 = v5;
    v9 = sub_100004520(a2, a3);
    if (v9)
      return ccder_sizeof(0x2000000000000010, v9 + v8);
  }
  sub_10002A5E8(-6, CFSTR("com.apple.security.cfder.error"), v6, a3, v7, CFSTR("null input"));
  return 0;
}

uint64_t sub_10000BC30(const __CFString *a1)
{
  CFIndex Length;
  CFIndex MaximumSizeForEncoding;
  CFIndex v4;
  CFIndex usedBufLen;
  CFRange v7;

  Length = CFStringGetLength(a1);
  MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  usedBufLen = 0;
  v7.location = 0;
  v7.length = Length;
  if (CFStringGetBytes(a1, v7, 0x8000100u, 0, 0, 0, MaximumSizeForEncoding, &usedBufLen) == Length)
    v4 = usedBufLen;
  else
    v4 = 0;
  return ccder_sizeof(12, v4);
}

uint64_t sub_10000BCAC(const __CFString *a1, CFTypeRef *a2, UInt8 *a3, uint64_t a4, uint64_t a5)
{
  CFIndex Length;
  uint64_t v10;
  uint64_t v11;
  CFIndex v12;
  uint64_t v13;
  uint64_t result;
  uint64_t v15;
  uint64_t v16;
  CFIndex usedBufLen;
  CFRange v18;

  if (a4)
  {
    Length = CFStringGetLength(a1);
    usedBufLen = 0;
    v18.location = 0;
    v18.length = Length;
    if (CFStringGetBytes(a1, v18, 0x8000100u, 0, 0, a3, a4 - (_QWORD)a3, &usedBufLen) == Length)
    {
      v12 = usedBufLen;
      v13 = ccder_encode_body(usedBufLen, a3, a3, a4);
      result = ccder_encode_tl(12, v12, a3, v13);
      if (result)
        return result;
      sub_10002A5E8(-7, CFSTR("com.apple.security.cfder.error"), v15, a2, v16, CFSTR("ccder failed to encode"));
    }
    else
    {
      sub_10002A5E8(-5, CFSTR("com.apple.security.cfder.error"), v10, a2, v11, CFSTR("String extraction failed"));
    }
  }
  else
  {
    sub_10002A5E8(-6, CFSTR("com.apple.security.cfder.error"), (uint64_t)a3, a2, a5, CFSTR("null input"));
  }
  return 0;
}

uint64_t sub_10000BDB0(const __CFDictionary *a1, CFTypeRef *a2, char a3, uint64_t a4, uint64_t a5)
{
  CFMutableArrayRef Mutable;
  CFIndex Count;
  uint64_t v12;
  unint64_t v13;
  const __CFData *ValueAtIndex;
  CFIndex Length;
  const UInt8 *BytePtr;
  uint64_t result;
  uint64_t v18;
  uint64_t v19;
  _QWORD v20[4];
  CFRange v21;

  Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  v20[0] = 0xAAAAAAAAAAAAAA01;
  v20[1] = a2;
  BYTE1(v20[0]) = a3;
  v20[2] = Mutable;
  v20[3] = 0;
  CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)sub_10000B11C, v20);
  if (!LOBYTE(v20[0]))
  {
    if (Mutable)
      CFRelease(Mutable);
    return 0;
  }
  v21.length = CFArrayGetCount(Mutable);
  v21.location = 0;
  CFArraySortValues(Mutable, v21, (CFComparatorFunction)sub_100006DD8, 0);
  Count = CFArrayGetCount(Mutable);
  v12 = a5;
  if (Count >= 1)
  {
    v13 = Count + 1;
    v12 = a5;
    do
    {
      ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(Mutable, v13 - 2);
      Length = CFDataGetLength(ValueAtIndex);
      BytePtr = CFDataGetBytePtr(ValueAtIndex);
      v12 = ccder_encode_body(Length, BytePtr, a4, v12);
      --v13;
    }
    while (v13 > 1);
  }
  if (Mutable)
    CFRelease(Mutable);
  result = ccder_encode_constructed_tl(0x2000000000000011, a5, a4, v12);
  if (!result)
  {
    sub_10002A5E8(-7, CFSTR("com.apple.security.cfder.error"), v18, a2, v19, CFSTR("ccder failed to encode"));
    return 0;
  }
  return result;
}

void sub_10000BF20(uint64_t a1)
{
  _QWORD block[5];

  if (qword_100082AD0 != -1)
    dispatch_once(&qword_100082AD0, &stru_100075E10);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_1000071E0;
  block[3] = &unk_100075D80;
  block[4] = a1;
  dispatch_sync((dispatch_queue_t)qword_100082AD8, block);
}

uint64_t sub_10000BFAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, _DWORD *a7, __CFString **a8)
{
  _BOOL8 v8;
  unint64_t v9;
  unint64_t v10;

  if ((a1 & 3) != 0)
  {
    v8 = 0;
  }
  else
  {
    HIDWORD(v9) = -1030792151 * a1 + 85899344;
    LODWORD(v9) = HIDWORD(v9);
    if ((v9 >> 2) <= 0x28F5C28)
    {
      HIDWORD(v10) = -1030792151 * a1 + 85899344;
      LODWORD(v10) = HIDWORD(v10);
      v8 = (v10 >> 4) < 0xA3D70B;
    }
    else
    {
      v8 = 1;
    }
  }
  if (a7)
    *a7 = v8;
  if ((int)a6 <= 61
    && (int)a5 <= 59
    && (int)a4 <= 23
    && (a2 - 13) >= 0xFFFFFFF4
    && (a3 - 32) >= 0xFFFFFFE1
    && ((_DWORD)a2 != 2 || (v8 | 0x1C) >= a3)
    && ((_DWORD)a2 == 2 || dword_100060350[a2] - dword_100060350[(a2 - 1)] >= (int)a3))
  {
    return 1;
  }
  sub_100012C88(-1, a8, CFSTR("Invalid date: %i, %i, %i, %i, %i, %i, %i"), a1, a2, a3, a4, a5, a6, v8);
  return 0;
}

BOOL sub_10000C0C0(double a1)
{
  void *v2;
  void *v3;
  CFTypeID v4;
  double v5;
  _BOOL8 v6;

  v2 = (void *)sub_10000C138();
  if (!v2)
    return 0;
  v3 = v2;
  v4 = CFGetTypeID(v2);
  if (v4 == CFDateGetTypeID())
  {
    objc_msgSend(v3, "timeIntervalSinceNow");
    v6 = fabs(v5) < a1;
  }
  else
  {
    v6 = 0;
  }
  CFRelease(v3);
  return v6;
}

uint64_t sub_10000C138()
{
  uint64_t v0;
  _QWORD block[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  if (!qword_100082BC8)
    return 0;
  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v6 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100007144;
  block[3] = &unk_100077360;
  block[4] = &v3;
  dispatch_sync((dispatch_queue_t)qword_100082BC8, block);
  v0 = v4[3];
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t sub_10000C1D4(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  CFDictionaryRef *ValueAtIndex;
  uint64_t result;
  uint64_t v8;
  CFIndex i;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v4)
    v5 = *(_QWORD *)(v4 + 16);
  else
    v5 = 0;
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (v5 >= 1)
  {
    v8 = result;
    for (i = 0; i < v5; ++i)
    {
      v10 = 0;
      v11 = *(_QWORD *)(*(_QWORD *)a1 + 200);
      if (v11 && (i & 0x8000000000000000) == 0)
      {
        if (*(_QWORD *)(v11 + 16) > i && (v12 = *(_QWORD *)(v11 + 8 * i + 136)) != 0)
          v10 = *(_QWORD *)(v12 + 16);
        else
          v10 = 0;
      }
      result = SecPolicyCheckCertUnparseableExtension(v10, v8);
      if ((result & 1) == 0)
      {
        result = sub_10000E2C8(a1, a2, i, kCFBooleanFalse, 0, 0);
        if (!(_DWORD)result)
          break;
      }
    }
  }
  return result;
}

uint64_t sub_10000C2C0(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  CFDictionaryRef *ValueAtIndex;
  uint64_t result;
  uint64_t v8;
  CFIndex i;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v4)
    v5 = *(_QWORD *)(v4 + 16);
  else
    v5 = 0;
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (v5 >= 1)
  {
    v8 = result;
    for (i = 0; i < v5; ++i)
    {
      v10 = 0;
      v11 = *(_QWORD *)(*(_QWORD *)a1 + 200);
      if (v11 && (i & 0x8000000000000000) == 0)
      {
        if (*(_QWORD *)(v11 + 16) > i && (v12 = *(_QWORD *)(v11 + 8 * i + 136)) != 0)
          v10 = *(_QWORD *)(v12 + 16);
        else
          v10 = 0;
      }
      result = SecPolicyCheckCertNonEmptySubject(v10, v8);
      if ((result & 1) == 0)
      {
        result = sub_10000E2C8(a1, a2, i, kCFBooleanFalse, 0, 0);
        if (!(_DWORD)result)
          break;
      }
    }
  }
  return result;
}

uint64_t sub_10000C3AC(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  CFDictionaryRef *ValueAtIndex;
  uint64_t result;
  uint64_t v8;
  CFIndex i;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v4)
    v5 = *(_QWORD *)(v4 + 16);
  else
    v5 = 0;
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (v5 >= 1)
  {
    v8 = result;
    for (i = 0; i < v5; ++i)
    {
      v10 = 0;
      v11 = *(_QWORD *)(*(_QWORD *)a1 + 200);
      if (v11 && (i & 0x8000000000000000) == 0)
      {
        if (*(_QWORD *)(v11 + 16) > i && (v12 = *(_QWORD *)(v11 + 8 * i + 136)) != 0)
          v10 = *(_QWORD *)(v12 + 16);
        else
          v10 = 0;
      }
      result = SecPolicyCheckCertDuplicateExtension(v10, v8);
      if ((result & 1) == 0)
      {
        result = sub_10000E2C8(a1, a2, i, kCFBooleanFalse, 0, 0);
        if (!(_DWORD)result)
          break;
      }
    }
  }
  return result;
}

uint64_t sub_10000C498(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v5;
  uint64_t v6;

  v2 = *(_QWORD *)(a1 + 24);
  if (v2)
  {
    v5 = 0;
    do
    {
      v6 = *(_QWORD *)(a1 + 32);
      if (v6)
      {
        while (!DEROidCompare(v6, v2))
        {
          v6 = *(_QWORD *)(v6 + 40);
          if (!v6)
            goto LABEL_6;
        }
      }
      else
      {
LABEL_6:
        sub_10000C56C(a1, (_OWORD *)v2, a2);
        v5 = 1;
      }
      v2 = *(_QWORD *)(v2 + 16);
    }
    while (v2);
  }
  else
  {
    v5 = 0;
  }
  return v5 & 1;
}

BOOL sub_10000C51C(uint64_t a1, uint64_t a2)
{
  _BOOL8 v4;

  v4 = DEROidCompare(a1, (uint64_t)&oidAnyPolicy);
  if (v4)
    sub_10000C56C(a1, (_OWORD *)a2, *(_QWORD *)(a2 + 16));
  return v4;
}

__n128 sub_10000C56C(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  _QWORD *v6;
  _QWORD *v7;
  __n128 result;

  v6 = malloc_type_malloc(0x18uLL, 0x1030040D5FA72FAuLL);
  v6[2] = 0;
  *(_OWORD *)v6 = *a2;
  v7 = malloc_type_malloc(0x38uLL, 0x107004060FBFCD3uLL);
  v7[6] = 0;
  *((_OWORD *)v7 + 1) = 0u;
  *((_OWORD *)v7 + 2) = 0u;
  *(_OWORD *)v7 = 0u;
  result = *(__n128 *)a2;
  *(_OWORD *)v7 = *a2;
  v7[2] = a3;
  v7[3] = v6;
  v7[5] = *(_QWORD *)(a1 + 32);
  v7[6] = a1;
  *(_QWORD *)(a1 + 32) = v7;
  return result;
}

uint64_t sub_10000C600(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t, id))
{
  double v7;
  int v8;
  void *v9;
  const __CFArray *CAIssuers;
  const __CFArray *v11;
  uint64_t v12;
  id v13;
  const void *v14;
  NSObject *v15;
  uint64_t v16;
  id v17;
  id v18;
  const void *v19;
  NSObject *v20;
  void *v22;
  void *v23;
  CAIssuerContext *v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  char v28;
  __int128 buf;
  void (*v30)(uint64_t, uint64_t, uint64_t);
  void *v31;
  uint64_t *v32;

  v7 = *(double *)(a3 + 120);
  v25 = 0;
  v26 = &v25;
  v27 = 0x2000000000;
  v28 = 0;
  *(_QWORD *)&buf = _NSConcreteStackBlock;
  *((_QWORD *)&buf + 1) = 0x40000000;
  v30 = sub_10000E060;
  v31 = &unk_100079638;
  v32 = &v25;
  sub_10000D610(a3, (uint64_t)&buf);
  v8 = *((unsigned __int8 *)v26 + 24);
  _Block_object_dispose(&v25, 8);
  if (!v8 || (SecCertificateIsValid(a2, v7) & 1) != 0)
  {
    v9 = objc_autoreleasePoolPush();
    CAIssuers = (const __CFArray *)SecCertificateGetCAIssuers(a2);
    v11 = CAIssuers;
    if (CAIssuers)
    {
      CFRetain(CAIssuers);
      v12 = *(_QWORD *)(a3 + 272);
      v13 = sub_10003855C(a2, v11, 0);
      if (v13)
      {
        v14 = v13;
        if (v12)
          *(_BYTE *)(v12 + 21) = 1;
        a4(a3, v13);
        CFRelease(v14);
        goto LABEL_18;
      }
      if (v12)
        *(_BYTE *)(v12 + 22) = 1;
      v17 = -[__CFArray count](v11, "count");
      if ((unint64_t)v17 < 0xA)
      {
        if (qword_100082D00 != -1)
          dispatch_once(&qword_100082D00, &stru_100076CA0);
        v22 = *(void **)(a3 + 32);
        if (v22)
          CFRetain(*(CFTypeRef *)(a3 + 32));
        v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)qword_100082CF0, "sessionForAuditToken:", v22));
        v24 = -[TrustURLSessionContext initWithContext:uris:]([CAIssuerContext alloc], "initWithContext:uris:", a3, v11);
        -[CAIssuerContext setCallback:](v24, "setCallback:", a4);
        -[TrustURLSessionContext setAttribution:](v24, "setAttribution:", *(_QWORD *)(a3 + 280));
        v16 = (uint64_t)objc_msgSend((id)qword_100082CF8, "fetchNext:context:", v23, v24);

        goto LABEL_19;
      }
      v18 = v17;
      v19 = sub_100011628("caissuer");
      v20 = objc_claimAutoreleasedReturnValue(v19);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 134217984;
        *(_QWORD *)((char *)&buf + 4) = v18;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "too many caIssuer entries (%ld)", (uint8_t *)&buf, 0xCu);
      }

    }
    a4(a3, 0);
LABEL_18:
    v16 = 1;
LABEL_19:

    objc_autoreleasePoolPop(v9);
    return v16;
  }
  v15 = sub_100011628("async");
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(buf) = 138412290;
    *(_QWORD *)((char *)&buf + 4) = a2;
    _os_log_debug_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "skipping CAIssuer fetch for expired %@", (uint8_t *)&buf, 0xCu);
  }
  a4(a3, 0);
  return 1;
}

void sub_10000C900(NSObject *a1, const void *a2, const __CFArray *cf, const __CFArray *a4, int a5, int a6, const void *a7, const void *a8, double a9, const void *a10, void *a11, const void *a12, const void *a13, uint64_t a14, void (**a15)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))
{
  CFTypeID v24;
  void *v25;
  uint64_t v26;
  CFErrorRef v27;

  if (cf && (v24 = CFGetTypeID(cf), v24 == CFArrayGetTypeID()) && CFArrayGetCount(cf) > 0)
  {
    v25 = _Block_copy(a15);
    v26 = sub_10000CAB0(a1, a2, cf, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, (uint64_t)sub_10000ADE0, (uint64_t)v25);
    sub_10000FDEC(v26);
  }
  else
  {
    v27 = CFErrorCreate(0, kCFErrorDomainOSStatus, -26275, 0);
    ((void (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, CFErrorRef))a15)[2](a15, 0, 0, 0, 0, v27);
    if (v27)
      CFRelease(v27);
  }
}

uint64_t sub_10000CAB0(NSObject *a1, const void *a2, const __CFArray *a3, const __CFArray *a4, int a5, int a6, const void *a7, const void *a8, double a9, CFTypeRef cf, void *a11, const void *a12, const void *a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  uint64_t Instance;
  CFTypeRef v26;
  char v27;
  const __CFArray *v28;
  _QWORD *v29;
  const void *v30;
  void *v31;
  id v32;
  uint64_t v33;
  const void *ValueAtIndex;
  const void *v35;
  uint64_t v36;
  const void *v37;
  _QWORD block[5];

  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100054FA4;
  block[3] = &unk_1000795C8;
  block[4] = &qword_100082F00;
  if (qword_100082EF8 != -1)
    dispatch_once(&qword_100082EF8, block);
  Instance = _CFRuntimeCreateInstance(kCFAllocatorDefault, qword_100082F00, 272, 0);
  if (Instance)
  {
    *(_QWORD *)(Instance + 272) = malloc_type_calloc(1uLL, 0x50uLL, 0x100004074E59A96uLL);
    **(_QWORD **)(Instance + 272) = mach_absolute_time();
    if (a2)
      v26 = CFRetain(a2);
    else
      v26 = 0;
    *(_QWORD *)(Instance + 32) = v26;
    if (a1)
      dispatch_retain(a1);
    else
      a1 = dispatch_queue_create("com.apple.trustd.evaluation.builder", 0);
    *(_QWORD *)(Instance + 16) = a1;
    *(_QWORD *)(Instance + 80) = 1;
    *(_BYTE *)(Instance + 178) = 1;
    *(_DWORD *)(Instance + 208) = 0;
    *(_QWORD *)(Instance + 280) = a14;
    *(_QWORD *)(Instance + 72) = CFArrayCreateMutable(kCFAllocatorDefault, 0, 0);
    *(_QWORD *)(Instance + 88) = CFArrayCreateMutable(kCFAllocatorDefault, 0, 0);
    *(_QWORD *)(Instance + 136) = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
    *(_QWORD *)(Instance + 144) = CFArrayCreateMutable(kCFAllocatorDefault, 0, 0);
    *(_QWORD *)(Instance + 152) = CFArrayCreateMutable(kCFAllocatorDefault, 0, 0);
    *(_QWORD *)(Instance + 160) = CFArrayCreateMutable(kCFAllocatorDefault, 0, 0);
    *(_QWORD *)(Instance + 184) = malloc_type_malloc(8uLL, 0x2004093837F09uLL);
    **(_QWORD **)(Instance + 184) = malloc_type_malloc(0x48uLL, 0x10600407F7167BDuLL);
    sub_10000D050(**(_QWORD **)(Instance + 184), Instance, a7);
    *(_QWORD *)(Instance + 192) = 1;
    *(double *)(Instance + 120) = a9;
    if (a13)
      CFRetain(a13);
    *(_QWORD *)(Instance + 128) = a13;
    *(_QWORD *)(Instance + 40) = sub_10000CF14(a3);
    if (a4)
      *(_QWORD *)(Instance + 56) = sub_10000CF14(a4);
    v27 = sub_100035BA4();
    v28 = (const __CFArray *)sub_10000CFDC(v27);
    *(_QWORD *)(Instance + 64) = sub_10000CF14(v28);
    CFArrayAppendValue(*(CFMutableArrayRef *)(Instance + 88), *(const void **)(Instance + 40));
    if (sub_100015138() && a6)
    {
      v29 = malloc_type_malloc(0x20uLL, 0xE0040DD5D8FE3uLL);
      *v29 = sub_100021BF8;
      v29[1] = 0;
      v29[2] = sub_10003902C;
      v29[3] = a12;
      if (a12)
        CFRetain(a12);
      *(_QWORD *)(Instance + 48) = v29;
      CFArrayAppendValue(*(CFMutableArrayRef *)(Instance + 88), v29);
    }
    if (a5)
    {
      CFArrayAppendValue(*(CFMutableArrayRef *)(Instance + 88), *(const void **)(Instance + 64));
      CFArrayAppendValue(*(CFMutableArrayRef *)(Instance + 88), off_1000827D0);
      CFArrayAppendValue(*(CFMutableArrayRef *)(Instance + 88), off_1000827E8);
    }
    if (a6 && *(_BYTE *)(Instance + 178))
      CFArrayAppendValue(*(CFMutableArrayRef *)(Instance + 88), &off_100082800);
    v30 = *(const void **)(Instance + 56);
    if (v30)
      CFArrayAppendValue(*(CFMutableArrayRef *)(Instance + 72), v30);
    if ((a5 & 1) == 0)
    {
      CFArrayAppendValue(*(CFMutableArrayRef *)(Instance + 72), *(const void **)(Instance + 64));
      sub_100015138();
      CFArrayAppendValue(*(CFMutableArrayRef *)(Instance + 72), off_1000827E8);
      CFArrayAppendValue(*(CFMutableArrayRef *)(Instance + 72), off_1000827D0);
    }
    if (a8)
      CFRetain(a8);
    *(_QWORD *)(Instance + 96) = a8;
    if (cf)
      CFRetain(cf);
    *(_QWORD *)(Instance + 104) = cf;
    if (a11)
    {
      v31 = objc_autoreleasePoolPush();
      v32 = sub_10002CD90(a11);
      v33 = objc_claimAutoreleasedReturnValue(v32);
      objc_autoreleasePoolPop(v31);
      *(_QWORD *)(Instance + 112) = v33;
    }
    ValueAtIndex = CFArrayGetValueAtIndex(a3, 0);
    v35 = (const void *)sub_100010264(0, ValueAtIndex, 0);
    CFSetAddValue(*(CFMutableSetRef *)(Instance + 136), v35);
    CFArrayAppendValue(*(CFMutableArrayRef *)(Instance + 144), v35);
    if (v35)
    {
      CFRetain(v35);
      *(_QWORD *)(Instance + 200) = v35;
      v36 = Instance;
      v37 = v35;
    }
    else
    {
      *(_QWORD *)(Instance + 200) = 0;
      v36 = Instance;
      v37 = 0;
    }
    sub_10000D4C4(v36, v37);
    CFRelease(v35);
    *(_QWORD *)(Instance + 248) = sub_10001209C;
    *(_QWORD *)(Instance + 256) = a15;
    *(_QWORD *)(Instance + 264) = a16;
  }
  return Instance;
}

_QWORD *sub_10000CF14(const __CFArray *a1)
{
  _QWORD *v2;
  CFIndex Count;
  CFRange v5;

  v2 = malloc_type_malloc(0x28uLL, 0xA00406C891FDCuLL);
  *v2 = sub_10000FB94;
  v2[1] = 0;
  v2[2] = sub_100002F10;
  Count = CFArrayGetCount(a1);
  v2[3] = CFSetCreateMutable(kCFAllocatorDefault, Count, &kCFTypeSetCallBacks);
  v2[4] = CFDictionaryCreateMutable(kCFAllocatorDefault, Count, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v5.location = 0;
  v5.length = Count;
  CFArrayApplyFunction(a1, v5, (CFArrayApplierFunction)sub_100006CA0, v2);
  return v2;
}

uint64_t sub_10000CFDC(char a1)
{
  _QWORD block[4];
  char v3;

  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100029F10;
  block[3] = &unk_100076348;
  v3 = a1;
  if (qword_100082B40 != -1)
    dispatch_once(&qword_100082B40, block);
  return qword_100082B38;
}

void sub_10000D050(uint64_t a1, uint64_t a2, CFTypeRef cf)
{
  void *values;

  *(_QWORD *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = cf;
  if (cf)
    CFRetain(cf);
  *(_DWORD *)(a1 + 64) = 4;
  values = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  *(_QWORD *)(a1 + 40) = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
  CFRelease(values);
}

uint64_t sub_10000D0EC(uint64_t a1)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int IsWeakHash;
  uint64_t v7;
  _BOOL4 v8;
  _BOOL4 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t (*v17)(uint64_t);
  uint64_t v19;
  const char *v20;
  const char *v21;
  uint64_t v22;
  const char *v23;
  int v24;
  const char *v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  const char *v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  uint64_t v35;

  sub_10000D610(a1, (uint64_t)&stru_1000796C0);
  if (sub_10000D588(a1))
  {
    if (a1)
    {
      v2 = sub_10000DE5C(*(_QWORD *)(a1 + 200));
      v3 = *(_QWORD *)(a1 + 200);
      if (v3 && *(uint64_t *)(v3 + 16) >= 1 && (v4 = *(_QWORD *)(v3 + 136)) != 0)
        v5 = *(_QWORD *)(v4 + 16);
      else
        v5 = 0;
      IsWeakHash = SecCertificateIsWeakHash(v5);
      v7 = *(_QWORD *)(a1 + 200);
      if (v7)
      {
        v8 = *(_BYTE *)(v7 + 65) != 0;
        v9 = *(_BYTE *)(*(_QWORD *)(v7 + 136) + 40) == 0;
      }
      else
      {
        v8 = 0;
        v9 = 1;
      }
      v10 = *(_QWORD *)(a1 + 224);
      if (v10)
        v11 = *(_QWORD *)(v10 + 96);
      else
        v11 = 0;
      v12 = sub_10000DD38(v7, *(double *)(a1 + 120));
      v13 = 11000000;
      if (!v8)
        v13 = 10000000;
      v14 = v12 + v13;
      v15 = *(_QWORD *)(a1 + 200);
      if (*(_QWORD *)(v15 + 96) < v14)
        *(_QWORD *)(v15 + 96) = v14;
      if (v14 > v11)
      {
        v16 = sub_100011628("accept");
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          v19 = *(_QWORD *)(a1 + 224);
          v20 = "non ";
          v21 = "non ";
          if (v19)
          {
            if (*(_BYTE *)(v19 + 65))
              v21 = "";
            else
              v21 = "non ";
          }
          v22 = *(_QWORD *)(a1 + 200);
          v23 = "reject";
          if (v11 > 10000000)
            v23 = "accept";
          v24 = 136316419;
          if (v8)
            v20 = "";
          v25 = v21;
          v26 = 2080;
          v27 = v23;
          v28 = 2048;
          v29 = v11;
          v30 = 2080;
          v31 = v20;
          v32 = 2048;
          v33 = v14;
          v34 = 2113;
          v35 = v22;
          _os_log_debug_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "replacing %sev %s score: %ld with %sev score: %ld %{private}@", (uint8_t *)&v24, 0x3Eu);
        }
        *(_QWORD *)(a1 + 224) = *(_QWORD *)(a1 + 200);
      }
      if (((v8 || v9) & (v2 ^ 1 | IsWeakHash)) != 0)
        v17 = sub_10000D348;
      else
        v17 = (uint64_t (*)(uint64_t))sub_10000FFB8;
      *(_QWORD *)(a1 + 248) = v17;
    }
  }
  else
  {
    sub_100012DF0(a1);
  }
  return 1;
}

uint64_t sub_10000D348(uint64_t a1)
{
  unint64_t v2;
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  uint8_t v7[16];
  _QWORD v8[8];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  char v12;
  _QWORD v13[3];
  unint64_t v14;
  _QWORD v15[4];

  sub_10000D4C4(a1, *(CFTypeRef *)(a1 + 224));
  v15[0] = 0;
  v15[1] = v15;
  v15[2] = 0x2000000000;
  v15[3] = 0xAAAAAAAAAAAAAAAALL;
  v13[0] = 0;
  v13[1] = v13;
  v13[2] = 0x2000000000;
  v14 = 0xAAAAAAAAAAAAAAAALL;
  v2 = *(_QWORD *)(a1 + 224);
  if (v2)
    v2 = *(_QWORD *)(v2 + 16);
  v14 = v2;
  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = 1;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = sub_10000DB74;
  v8[3] = &unk_100079838;
  v8[4] = &v9;
  v8[5] = v15;
  v8[6] = v13;
  v8[7] = a1;
  sub_10000D610(a1, (uint64_t)v8);
  *(_QWORD *)(a1 + 248) = sub_1000136BC;
  sub_10000D610(a1, (uint64_t)&stru_100079878);
  v3 = *(_QWORD *)(a1 + 224);
  if (v3)
  {
    if (*(uint64_t *)(v3 + 96) >= 10000001 && (sub_10000D588(a1) & 1) == 0)
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 224) + 96) = 0;
      v4 = sub_100011628("SecWarning");
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v7 = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "In ComputeDetails, we got a reject after an accept in DidValidatePath.", v7, 2u);
      }
    }
  }
  v5 = *((unsigned __int8 *)v10 + 24);
  _Block_object_dispose(&v9, 8);
  _Block_object_dispose(v13, 8);
  _Block_object_dispose(v15, 8);
  return v5;
}

uint64_t sub_10000D4C4(uint64_t a1, CFTypeRef cf1)
{
  const void *v4;
  CFTypeRef v5;
  const void *v6;
  _QWORD v8[5];

  v4 = *(const void **)(a1 + 200);
  if (cf1)
  {
    if (v4)
    {
      if (CFEqual(cf1, v4))
        goto LABEL_12;
      v5 = *(CFTypeRef *)(a1 + 200);
    }
    else
    {
      v5 = 0;
    }
    if (v5 != cf1)
    {
      CFRetain(cf1);
      v4 = *(const void **)(a1 + 200);
      if (!v4)
      {
LABEL_11:
        *(_QWORD *)(a1 + 200) = cf1;
        goto LABEL_12;
      }
LABEL_10:
      CFRelease(v4);
      goto LABEL_11;
    }
  }
  else if (v4)
  {
    goto LABEL_10;
  }
LABEL_12:
  v6 = *(const void **)(a1 + 232);
  if (v6)
  {
    *(_QWORD *)(a1 + 232) = 0;
    CFRelease(v6);
  }
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = sub_10000D6C4;
  v8[3] = &unk_1000795E8;
  v8[4] = cf1;
  return sub_10000D610(a1, (uint64_t)v8);
}

uint64_t sub_10000D588(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = sub_10000D690;
  v3[3] = &unk_1000798A0;
  v3[4] = &v4;
  sub_10000D610(a1, (uint64_t)v3);
  v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

uint64_t sub_10000D610(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t i;
  uint64_t v6;
  char v7;

  if (*(_QWORD *)(result + 184))
  {
    v2 = result;
    v7 = 0;
    v3 = *(_QWORD *)(result + 192);
    if (v3 >= 1)
    {
      for (i = 0; i < v3; ++i)
      {
        v6 = *(_QWORD *)(*(_QWORD *)(v2 + 184) + 8 * i);
        if (v6)
        {
          result = (*(uint64_t (**)(uint64_t, uint64_t, char *))(a2 + 16))(a2, v6, &v7);
          if (v7)
            return result;
          v3 = *(_QWORD *)(v2 + 192);
        }
      }
    }
  }
  return result;
}

uint64_t sub_10000D690(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) |= (*(_DWORD *)(a2 + 64) > 7u) | (0x17u >> *(_DWORD *)(a2 + 64)) & 1;
  return result;
}

void sub_10000D6C4(uint64_t a1, uint64_t a2)
{
  const void *v2;

  *(_QWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 64) = 4;
  v2 = *(const void **)(a2 + 56);
  if (v2)
  {
    *(_QWORD *)(a2 + 56) = 0;
    CFRelease(v2);
  }
}

uint64_t sub_10000D6E4(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != *(_QWORD *)(a2 + 16))
    return 0;
  if (v2 < 1)
    return 1;
  v4 = 0;
  v5 = a2 + 136;
  v6 = a1 + 136;
  while (1)
  {
    result = CFEqual(*(CFTypeRef *)(v6 + 8 * v4), *(CFTypeRef *)(v5 + 8 * v4));
    if (!(_DWORD)result)
      break;
    if (++v4 >= *(_QWORD *)(a1 + 16))
      return 1;
  }
  return result;
}

uint64_t sub_10000D758(uint64_t result, uint64_t a2, _BYTE *a3)
{
  unsigned int v3;

  v3 = *(_DWORD *)(a2 + 64);
  if (v3 > 7 || ((0x17u >> v3) & 1) != 0)
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2;
    *a3 = 1;
  }
  return result;
}

uint64_t sub_10000D78C(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  CFIndex v5;
  uint64_t result;
  char v7;
  uint64_t v8;

  v4 = *(_QWORD *)(a1 + 40);
  if (v4)
    v5 = *(_QWORD *)(v4 + 16) - 1;
  else
    v5 = -1;
  result = sub_10000D7E8(a2, v5);
  v7 = result ^ 1;
  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (!*(_BYTE *)(v8 + 24))
    v7 = 0;
  *(_BYTE *)(v8 + 24) = v7;
  return result;
}

uint64_t sub_10000D7E8(_DWORD *a1, CFIndex a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t BasicConstraints;
  CFTypeRef *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int KeyUsage;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (!v4 || a2 < 0)
  {
    v6 = 0;
    if (!v4)
    {
      v7 = -1;
      goto LABEL_10;
    }
  }
  else if (*(_QWORD *)(v4 + 16) > a2 && (v5 = *(_QWORD *)(v4 + 8 * a2 + 136)) != 0)
  {
    v6 = *(_QWORD *)(v5 + 16);
  }
  else
  {
    v6 = 0;
  }
  v7 = *(_QWORD *)(v4 + 16) - 1;
LABEL_10:
  if (((SecCertificateIsValid(v6, *(double *)(*(_QWORD *)a1 + 120)) & 1) != 0
     || sub_10000E2C8((uint64_t)a1, kSecPolicyCheckTemporalValidity, a2, kCFBooleanFalse, 0, 0))
    && (!SecCertificateIsWeakKey(v6)
     || sub_10000E2C8((uint64_t)a1, kSecPolicyCheckWeakKeySize, a2, kCFBooleanFalse, 0, 0))
    && ((SecPolicyCheckCertWeakSignature(v6, 0) & 1) != 0
     || sub_10000E2C8((uint64_t)a1, kSecPolicyCheckWeakSignature, a2, kCFBooleanFalse, 0, 0)))
  {
    if (SecCertificateVersion(v6) >= 3)
    {
      BasicConstraints = SecCertificateGetBasicConstraints(v6);
      if (!BasicConstraints)
      {
        v9 = (CFTypeRef *)&kSecPolicyCheckBasicConstraints;
LABEL_31:
        if ((sub_10000E2C8((uint64_t)a1, *v9, a2, kCFBooleanFalse, 1, 0) & 1) == 0)
          return (a1[16] > 7u) | (0x17u >> a1[16]) & 1;
        goto LABEL_32;
      }
      if (!*(_BYTE *)(BasicConstraints + 2))
      {
        v9 = (CFTypeRef *)&kSecPolicyCheckBasicConstraintsCA;
        goto LABEL_31;
      }
LABEL_32:
      KeyUsage = SecCertificateGetKeyUsage(v6);
      if (KeyUsage && (KeyUsage & 0x20) == 0)
        sub_10000E2C8((uint64_t)a1, kSecPolicyCheckKeyUsage, a2, kCFBooleanFalse, 1, 0);
      return (a1[16] > 7u) | (0x17u >> a1[16]) & 1;
    }
    if (a2 < 1 || v7 <= a2)
      goto LABEL_32;
    v10 = *(_QWORD *)(*(_QWORD *)a1 + 200);
    if (v10 && *(_QWORD *)(v10 + 16) > v7 && (v11 = *(_QWORD *)(v10 + 8 * v7 + 136)) != 0)
      v12 = *(_QWORD *)(v11 + 16);
    else
      v12 = 0;
    if (SecCertificateVersion(v12) < 3
      || sub_10000E2C8((uint64_t)a1, kSecPolicyCheckBasicConstraints, a2, kCFBooleanFalse, 1, 0))
    {
      goto LABEL_32;
    }
  }
  return (a1[16] > 7u) | (0x17u >> a1[16]) & 1;
}

void sub_10000DA50(uint64_t a1, uint64_t a2)
{
  const void *v4;
  const void *v5;
  const __CFArray *v6;
  CFIndex Count;
  CFIndex v8;
  CFIndex i;
  CFDictionaryRef *ValueAtIndex;
  unsigned int v11;
  const void *v12;
  const void *v13;
  BOOL v14;
  uint64_t v15;
  char v17;

  v4 = *(const void **)(a2 + 40);
  v5 = *(const void **)(a2 + 56);
  if (v5 != v4)
  {
    if (!v4 || (CFRetain(*(CFTypeRef *)(a2 + 40)), (v5 = *(const void **)(a2 + 56)) != 0))
      CFRelease(v5);
    *(_QWORD *)(a2 + 56) = v4;
  }
  v6 = *(const __CFArray **)(a2 + 8);
  Count = CFArrayGetCount(v6);
  if (Count >= 1)
  {
    v8 = Count;
    for (i = 0; i != v8; ++i)
    {
      ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(v6, i);
      *(_QWORD *)(a2 + 16) = qword_100082DD8;
      *(_QWORD *)(a2 + 24) = i;
      CFDictionaryApplyFunction(ValueAtIndex[4], (CFDictionaryApplierFunction)sub_1000069C0, (void *)a2);
    }
  }
  v11 = *(_DWORD *)(a2 + 64);
  *(_DWORD *)(a2 + 48) = v11;
  v12 = *(const void **)(a2 + 56);
  v13 = *(const void **)(a2 + 40);
  if (v13 != v12)
  {
    if (!v12 || (CFRetain(*(CFTypeRef *)(a2 + 56)), (v13 = *(const void **)(a2 + 40)) != 0))
      CFRelease(v13);
    *(_QWORD *)(a2 + 40) = v12;
    v11 = *(_DWORD *)(a2 + 64);
  }
  v14 = ((0x17u >> v11) & 1) != 0 || v11 >= 8;
  v15 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v17 = !v14 && *(_BYTE *)(v15 + 24) != 0;
  *(_BYTE *)(v15 + 24) = v17;
}

void sub_10000DB6C(id a1, OpaqueSecPVC *a2, BOOL *a3)
{
  sub_100015CC0(a2);
}

void sub_10000DB74(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  CFIndex v5;
  __CFArray *MutableCopy;
  CFIndex v7;
  CFMutableDictionaryRef Mutable;
  __CFArray *v9;
  BOOL v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  uint64_t i;
  CFIndex v15;

  v4 = *(_QWORD *)(a1[7] + 224);
  *(_QWORD *)(a2 + 24) = 0;
  if (v4)
    v5 = *(_QWORD *)(v4 + 16);
  else
    v5 = 0;
  MutableCopy = CFArrayCreateMutableCopy(kCFAllocatorDefault, v5, *(CFArrayRef *)(a2 + 40));
  if (v5 >= 2)
  {
    v7 = v5 - 1;
    do
    {
      Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      CFArrayAppendValue(MutableCopy, Mutable);
      CFRelease(Mutable);
      --v7;
    }
    while (v7);
  }
  v9 = *(__CFArray **)(a2 + 56);
  if (v9 != MutableCopy)
  {
    if (!MutableCopy || (CFRetain(MutableCopy), (v9 = *(__CFArray **)(a2 + 56)) != 0))
      CFRelease(v9);
    *(_QWORD *)(a2 + 56) = MutableCopy;
  }
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(a2 + 48);
  if (MutableCopy)
    CFRelease(MutableCopy);
  v10 = sub_1000145B0(a1[7]);
  v11 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v11 + 24))
    v12 = v10;
  else
    v12 = 0;
  *(_BYTE *)(v11 + 24) = v12;
  v13 = *(_QWORD *)(a1[5] + 8);
  for (i = 1; ; i = *(_QWORD *)(v13 + 24) + 1)
  {
    *(_QWORD *)(v13 + 24) = i;
    v15 = *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
    if (v15 >= *(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24))
      break;
    sub_10000D7E8((_DWORD *)a2, v15);
    v13 = *(_QWORD *)(a1[5] + 8);
  }
  sub_100002F30(a2);
}

void sub_10000DCE0(id a1, OpaqueSecPVC *a2, BOOL *a3)
{
  sub_100002F30((uint64_t)a2);
}

void sub_10000DCE8(id a1, OpaqueSecPVC *a2, BOOL *a3)
{
  sub_100015CC0(a2);
}

BOOL sub_10000DCF0(uint64_t a1, _QWORD *a2, _BYTE *a3)
{
  _BOOL8 result;

  result = sub_10000F2B4(a2, *(_QWORD *)(a1 + 40), *(const void **)(a1 + 48));
  if (result)
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
    *a3 = 1;
  }
  return result;
}

uint64_t sub_10000DD38(uint64_t a1, double a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  _QWORD v8[6];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  char v12;

  v3 = *(_QWORD *)(a1 + 16);
  v4 = -100000;
  if (*(_QWORD *)(a1 + 32) == v3 - 1)
    v4 = 0;
  if (*(_BYTE *)(a1 + 49))
    v4 += 10000;
  if (*(_BYTE *)(a1 + 48) && *(_QWORD *)(a1 + 40) == v3 - 1)
    v5 = v4 - v3 + 1000;
  else
    v5 = v4 + v3;
  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = 1;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = sub_100014200;
  v8[3] = &unk_100076DE8;
  *(double *)&v8[5] = a2;
  v8[4] = &v9;
  sub_10001409C(a1, (uint64_t)v8);
  v6 = *((unsigned __int8 *)v10 + 24);
  _Block_object_dispose(&v9, 8);
  if (v6)
    v5 += 100;
  if (!sub_10000DE5C(a1))
    v5 += 10;
  if (sub_10000DEB8(a1))
    return v5;
  else
    return v5 + 10;
}

uint64_t sub_10000DE5C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  if (*(_BYTE *)(a1 + 68))
    return 0;
  v2 = *(_QWORD *)(a1 + 16) - *(char *)(a1 + 49);
  if (v2 < 1)
  {
LABEL_7:
    v1 = 0;
    *(_BYTE *)(a1 + 68) = 1;
  }
  else
  {
    v3 = a1 + 136;
    while (!*(_BYTE *)(*(_QWORD *)v3 + 41))
    {
      v3 += 8;
      if (!--v2)
        goto LABEL_7;
    }
    return 1;
  }
  return v1;
}

uint64_t sub_10000DEB8(uint64_t a1)
{
  CFNumberRef v2;
  CFNumberRef v3;
  CFNumberRef v4;
  CFDictionaryRef v5;
  const void *v6;
  uint64_t v7;
  _QWORD v9[6];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t valuePtr;
  void *values[2];
  void *keys[2];

  v14 = 0;
  v15 = &v14;
  v16 = 0x2000000000;
  v17 = 0;
  v10 = 0;
  v11 = &v10;
  v12 = 0x2000000000;
  v13 = 0;
  valuePtr = 2048;
  v2 = CFNumberCreate(0, kCFNumberCFIndexType, &valuePtr);
  if (v2)
  {
    valuePtr = 224;
    v3 = CFNumberCreate(0, kCFNumberCFIndexType, &valuePtr);
    v4 = v3;
    if (v3)
    {
      keys[0] = (void *)kSecAttrKeyTypeRSA;
      keys[1] = (void *)kSecAttrKeyTypeEC;
      values[0] = v2;
      values[1] = v3;
      v5 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      v15[3] = (uint64_t)v5;
      if (v5)
      {
        v9[0] = _NSConcreteStackBlock;
        v9[1] = 0x40000000;
        v9[2] = sub_1000141B0;
        v9[3] = &unk_100076E50;
        v9[4] = &v14;
        v9[5] = &v10;
        sub_10001409C(a1, (uint64_t)v9);
      }
    }
  }
  else
  {
    v4 = 0;
  }
  v6 = (const void *)v15[3];
  if (v6)
    CFRelease(v6);
  if (v2)
    CFRelease(v2);
  if (v4)
    CFRelease(v4);
  v7 = *((unsigned __int8 *)v11 + 24);
  _Block_object_dispose(&v10, 8);
  _Block_object_dispose(&v14, 8);
  return v7;
}

void sub_10000E060(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const __CFArray *v3;
  _QWORD v4[6];
  CFRange v5;

  v3 = *(const __CFArray **)(a2 + 8);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_100021498;
  v4[3] = &unk_100079610;
  v4[4] = *(_QWORD *)(a1 + 32);
  v4[5] = a3;
  v5.length = CFArrayGetCount(v3);
  v5.location = 0;
  CFArrayApplyFunction(v3, v5, (CFArrayApplierFunction)sub_100055100, v4);
}

uint64_t sub_10000E0DC(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  const void *v5;
  const void *v6;

  result = CFEqual(*(CFTypeRef *)(a1 + 16), *(CFTypeRef *)(a2 + 16));
  if ((_DWORD)result)
  {
    v5 = *(const void **)(a1 + 24);
    if (!v5)
      return 1;
    v6 = *(const void **)(a2 + 24);
    if (!v6)
      return 1;
    result = CFEqual(v5, v6);
    if ((_DWORD)result)
      return 1;
  }
  return result;
}

uint64_t sub_10000E128(uint64_t result, const void *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  CFIndex v6;
  double v7;
  uint64_t v8;
  uint64_t v9;

  v2 = *(_QWORD *)(*(_QWORD *)result + 200);
  if (v2)
  {
    v3 = *(_QWORD *)(v2 + 16);
    if (v3 >= 1)
    {
      v5 = result;
      v6 = 0;
      v7 = *(double *)(*(_QWORD *)result + 120);
      while (1)
      {
        v8 = 0;
        if (v2 && (v6 & 0x8000000000000000) == 0)
        {
          if (*(_QWORD *)(v2 + 16) > v6 && (v9 = *(_QWORD *)(v2 + 8 * v6 + 136)) != 0)
            v8 = *(_QWORD *)(v9 + 16);
          else
            v8 = 0;
        }
        result = SecCertificateIsValid(v8, v7);
        if ((result & 1) == 0)
        {
          result = sub_10000E2C8(v5, a2, v6, kCFBooleanFalse, 0, 0);
          if (!(_DWORD)result)
            break;
        }
        if (++v6 >= v3)
          break;
        v2 = *(_QWORD *)(*(_QWORD *)v5 + 200);
      }
    }
  }
  return result;
}

void sub_10000E200(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  CFIndex v6;
  uint64_t v7;
  uint64_t v8;
  const void *v9;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v4)
  {
    v5 = *(_QWORD *)(v4 + 16);
    v6 = v5 - 1;
    if (v5 >= 1 && (v7 = *(_QWORD *)(v4 + 8 * v6 + 136)) != 0)
      v8 = *(_QWORD *)(v7 + 16);
    else
      v8 = 0;
  }
  else
  {
    v8 = 0;
    v6 = -1;
  }
  v9 = (const void *)SecCertificateCopySHA256Digest(v8);
  if ((sub_10000ED5C(*(const __CFArray **)(a1 + 8), *(_QWORD *)(a1 + 24), a2, v9) & 1) == 0)
    sub_10000E2C8(a1, kSecPolicyCheckAnchorSHA256, v6, kCFBooleanFalse, 0, 0);
  if (v9)
    CFRelease(v9);
}

uint64_t sub_10000E2C8(uint64_t a1, CFTypeRef cf1, CFIndex a3, const void *a4, int a5, int a6)
{
  int v7;
  CFDictionaryRef *ValueAtIndex;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  const __CFArray *v23;
  CFIndex Count;
  CFIndex v25;
  CFIndex v26;
  BOOL v27;
  const __CFDictionary *v28;
  const __CFDictionary *v29;
  CFTypeID v30;
  const __CFNumber *Value;
  const __CFNumber *v32;
  CFTypeID v33;
  int v34;
  int v35;
  const __CFArray *v36;
  const __CFDictionary *v37;
  const __CFDictionary *v38;
  CFTypeID v39;
  const void *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  const void *SHA1Digest;
  const void *v45;
  const void *v46;
  unsigned int v47;
  NSObject *v48;
  const char *v49;
  NSObject *v50;
  uint64_t v51;
  const char *v52;
  const char *v53;
  const char *v54;
  unsigned int v55;
  uint64_t result;
  __CFDictionary *v57;
  NSObject *v58;
  _BOOL4 v59;
  CFIndex v60;
  CFTypeRef v61;
  CFTypeRef v62;
  CFTypeRef cf2;
  int v64;
  const void *v65;
  CFIndex v66;
  const void *v67;
  int valuePtr;
  _BYTE v69[24];
  __int16 v70;
  const char *v71;
  __int16 v72;
  const void *v73;

  v7 = a5;
  if ((a5 & 1) == 0)
  {
    ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
    if (!sub_10000EC30(a1, cf1) && (!ValueAtIndex || !CFDictionaryContainsKey(ValueAtIndex[4], cf1)))
      return 1;
  }
  v13 = CFEqual(cf1, CFSTR("WeakKeySize"));
  v14 = CFEqual(cf1, CFSTR("WeakSignature"));
  v15 = CFEqual(cf1, CFSTR("BlackListedLeaf"));
  if (CFEqual(cf1, CFSTR("BlackListedKey")) | v15 | v14 | v13)
    v16 = 6;
  else
    v16 = 5;
  if (CFEqual(cf1, CFSTR("UsageConstraints")))
    v16 = 3;
  v17 = CFEqual(cf1, CFSTR("Revocation"));
  v18 = CFEqual(cf1, CFSTR("IssuerPolicyConstraints"));
  if (CFEqual(cf1, CFSTR("IssuerNameConstraints")) | v18 | v17)
    v19 = 6;
  else
    v19 = v16;
  if (a6)
    v20 = a6;
  else
    v20 = v19;
  if (v20 == 5)
  {
    v67 = 0;
    v21 = *(_QWORD *)(*(_QWORD *)a1 + 200);
    v22 = *(_QWORD *)(v21 + 8 * a3 + 136);
    v23 = *(const __CFArray **)(v22 + 24);
    v65 = a4;
    v64 = v7;
    if (v21)
    {
      if ((a3 & 0x8000000000000000) == 0)
      {
        v67 = 0;
        if (*(_QWORD *)(v21 + 16) > a3)
        {
          if (v22)
            v67 = *(const void **)(v22 + 16);
        }
      }
    }
    v66 = a3;
    Count = CFArrayGetCount(v23);
    if (Count >= 1)
    {
      v25 = Count;
      v26 = 0;
      cf2 = (CFTypeRef)kSecPolicyCheckSSLHostname;
      v61 = (CFTypeRef)kSecPolicyCheckTemporalValidity;
      v62 = (CFTypeRef)kSecPolicyCheckEmail;
      v27 = 1;
      while (1)
      {
        v28 = (const __CFDictionary *)CFArrayGetValueAtIndex(v23, v26);
        if (v28)
        {
          v29 = v28;
          v30 = CFGetTypeID(v28);
          if (v30 == CFDictionaryGetTypeID())
          {
            Value = (const __CFNumber *)CFDictionaryGetValue(v29, CFSTR("kSecTrustSettingsAllowedError"));
            valuePtr = 0;
            if (Value)
            {
              v32 = Value;
              v33 = CFGetTypeID(Value);
              if (v33 == CFNumberGetTypeID()
                && CFNumberGetValue(v32, kCFNumberSInt32Type, &valuePtr)
                && sub_1000049C4((_QWORD *)a1, v67, v29))
              {
                v34 = valuePtr;
                if (CFEqual(cf1, cf2))
                {
                  v35 = -2147408896;
                }
                else if (CFEqual(cf1, v62))
                {
                  v35 = -2147408872;
                }
                else
                {
                  v35 = CFEqual(cf1, v61) ? -2147409654 : 0;
                }
                if (v34 == v35)
                  break;
              }
            }
          }
        }
        v27 = ++v26 < v25;
        if (v25 == v26)
          goto LABEL_39;
      }
      if (v27)
      {
        v48 = sub_100011628("policy");
        if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
        {
          valuePtr = 67109378;
          *(_DWORD *)v69 = v66;
          *(_WORD *)&v69[4] = 2112;
          *(_QWORD *)&v69[6] = cf1;
          v49 = "cert[%d]: skipped allowed error %@";
LABEL_85:
          _os_log_debug_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEBUG, v49, (uint8_t *)&valuePtr, 0x12u);
        }
        return 1;
      }
    }
LABEL_39:
    v36 = *(const __CFArray **)(*(_QWORD *)a1 + 128);
    a4 = v65;
    a3 = v66;
    v20 = 5;
    v7 = v64;
    if (v36)
    {
      if (CFArrayGetCount(*(CFArrayRef *)(*(_QWORD *)a1 + 128)) > v66)
      {
        v37 = (const __CFDictionary *)CFArrayGetValueAtIndex(v36, v66);
        if (v37)
        {
          v38 = v37;
          v39 = CFGetTypeID(v37);
          if (v39 == CFDictionaryGetTypeID())
          {
            v40 = (const void *)kSecCertificateDetailSHA1Digest;
            if (CFDictionaryContainsKey(v38, kSecCertificateDetailSHA1Digest))
            {
              v41 = 0;
              v42 = *(_QWORD *)(*(_QWORD *)a1 + 200);
              if (v42 && (v66 & 0x8000000000000000) == 0)
              {
                if (*(_QWORD *)(v42 + 16) > v66 && (v43 = *(_QWORD *)(v42 + 8 * v66 + 136)) != 0)
                  v41 = *(_QWORD *)(v43 + 16);
                else
                  v41 = 0;
              }
              SHA1Digest = (const void *)SecCertificateGetSHA1Digest(v41);
              v45 = CFDictionaryGetValue(v38, v40);
              if (CFEqual(SHA1Digest, v45))
              {
                v46 = CFDictionaryGetValue(v38, cf1);
                if (v46)
                {
                  if (CFEqual(v65, v46))
                  {
                    v47 = *(_DWORD *)(a1 + 64);
                    if (v47 > 7 || ((1 << v47) & 0xE8) == 0)
                      *(_DWORD *)(a1 + 64) = 1;
                    v48 = sub_100011628("policy");
                    if (!os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
                      return 1;
                    valuePtr = 67109378;
                    *(_DWORD *)v69 = v66;
                    *(_WORD *)&v69[4] = 2112;
                    *(_QWORD *)&v69[6] = cf1;
                    v49 = "cert[%d]: skipped exception error %@";
                    goto LABEL_85;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  v50 = sub_100011628("policy");
  if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
  {
    v51 = *(_QWORD *)(a1 + 16);
    if (v51 == qword_100082DE0)
      v52 = "path";
    else
      v52 = "custom";
    valuePtr = 67110146;
    *(_DWORD *)v69 = a3;
    if (v51 == qword_100082DD8)
      v53 = "leaf";
    else
      v53 = v52;
    *(_WORD *)&v69[4] = 2112;
    *(_QWORD *)&v69[6] = cf1;
    *(_WORD *)&v69[14] = 2080;
    *(_QWORD *)&v69[16] = v53;
    if (v7)
      v54 = "force";
    else
      v54 = "";
    v70 = 2080;
    v71 = v54;
    v72 = 2112;
    v73 = a4;
    _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "cert[%d]: %@ =(%s)[%s]> %@", (uint8_t *)&valuePtr, 0x30u);
  }
  v55 = *(_DWORD *)(a1 + 64);
  if (v55 > 7 || ((1 << v55) & 0xE8) == 0 || v20 == 6)
    goto LABEL_74;
  if (v20 == 3 && v55 == 5)
  {
    v20 = 3;
LABEL_74:
    *(_DWORD *)(a1 + 64) = v20;
  }
  result = *(_QWORD *)(a1 + 56);
  if (!result)
    return result;
  v57 = (__CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)result, a3);
  if (v57)
  {
    CFDictionarySetValue(v57, cf1, a4);
    return 1;
  }
  v58 = sub_100011628("SecError");
  v59 = os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT);
  result = 0;
  if (v59)
  {
    v60 = CFArrayGetCount(*(CFArrayRef *)(a1 + 56));
    valuePtr = 134218240;
    *(_QWORD *)v69 = a3;
    *(_WORD *)&v69[8] = 2048;
    *(_QWORD *)&v69[10] = v60;
    _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "SecPVCSetResultForced: failed to get detail at index %ld (array length %ld)", (uint8_t *)&valuePtr, 0x16u);
    return 0;
  }
  return result;
}

uint64_t sub_10000E958(_QWORD *a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  const __CFArray *v6;
  CFIndex Count;
  CFIndex v8;
  CFIndex v9;
  int v10;
  CFDictionaryRef *ValueAtIndex;
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  CFIndex v15;
  uint64_t v16;
  uint64_t v17;

  v4 = *(_QWORD *)(*a1 + 200);
  if (v4)
    v5 = *(_QWORD *)(v4 + 16);
  else
    v5 = 0;
  v6 = (const __CFArray *)a1[1];
  Count = CFArrayGetCount(v6);
  if (Count < 1)
    return sub_10000EC30((uint64_t)a1, a2);
  v8 = Count;
  v9 = 0;
  v10 = 0;
  do
  {
    ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(v6, v9);
    if (ValueAtIndex && CFDictionaryContainsKey(ValueAtIndex[4], a2))
      v10 = 1;
    ++v9;
  }
  while (v8 != v9);
  result = sub_10000EC30((uint64_t)a1, a2);
  if ((_DWORD)result)
  {
    if (v10)
    {
      v13 = *(_QWORD *)(*a1 + 200);
      v14 = v5 - *(char *)(v13 + 49);
      if (v14 >= 1)
      {
        v15 = 0;
        while (1)
        {
          v16 = 0;
          if (v13 && (v15 & 0x8000000000000000) == 0)
          {
            if (*(_QWORD *)(v13 + 16) > v15 && (v17 = *(_QWORD *)(v13 + 8 * v15 + 136)) != 0)
              v16 = *(_QWORD *)(v17 + 16);
            else
              v16 = 0;
          }
          result = SecCertificateIsWeakHash(v16);
          if ((_DWORD)result)
          {
            result = sub_10000E2C8((uint64_t)a1, a2, v15, kCFBooleanFalse, 0, 0);
            if (!(_DWORD)result)
              break;
          }
          if (++v15 >= v14)
            break;
          v13 = *(_QWORD *)(*a1 + 200);
        }
      }
    }
  }
  return result;
}

uint64_t sub_10000EAC4(_QWORD *a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  const __CFArray *v6;
  CFIndex Count;
  CFIndex v8;
  CFIndex v9;
  int v10;
  CFDictionaryRef *ValueAtIndex;
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  CFIndex v15;
  uint64_t v16;
  uint64_t v17;

  v4 = *(_QWORD *)(*a1 + 200);
  if (v4)
    v5 = *(_QWORD *)(v4 + 16);
  else
    v5 = 0;
  v6 = (const __CFArray *)a1[1];
  Count = CFArrayGetCount(v6);
  if (Count < 1)
    return sub_10000EC30((uint64_t)a1, a2);
  v8 = Count;
  v9 = 0;
  v10 = 0;
  do
  {
    ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(v6, v9);
    if (ValueAtIndex && CFDictionaryContainsKey(ValueAtIndex[4], a2))
      v10 = 1;
    ++v9;
  }
  while (v8 != v9);
  result = sub_10000EC30((uint64_t)a1, a2);
  if ((_DWORD)result)
  {
    if (v10)
    {
      v13 = *(_QWORD *)(*a1 + 200);
      v14 = v5 - *(char *)(v13 + 49);
      if (v14 >= 1)
      {
        v15 = 0;
        while (1)
        {
          v16 = 0;
          if (v13 && (v15 & 0x8000000000000000) == 0)
          {
            if (*(_QWORD *)(v13 + 16) > v15 && (v17 = *(_QWORD *)(v13 + 8 * v15 + 136)) != 0)
              v16 = *(_QWORD *)(v17 + 16);
            else
              v16 = 0;
          }
          result = SecCertificateIsStrongKey(v16);
          if ((result & 1) == 0)
          {
            result = sub_10000E2C8((uint64_t)a1, a2, v15, kCFBooleanFalse, 0, 0);
            if (!(_DWORD)result)
              break;
          }
          if (++v15 >= v14)
            break;
          v13 = *(_QWORD *)(*a1 + 200);
        }
      }
    }
  }
  return result;
}

BOOL sub_10000EC30(uint64_t a1, const void *a2)
{
  uint64_t v2;
  uint64_t v5;
  BOOL v6;
  const __CFArray *v7;
  CFIndex Count;
  CFIndex v9;
  CFIndex v10;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v12;
  CFTypeID v13;
  const __CFDictionary *Value;
  const __CFDictionary *v15;
  CFTypeID v16;
  uint64_t v18;

  v2 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v2 && (v18 = *(_QWORD *)(v2 + 16), v18 >= 1))
  {
    v5 = 0;
    v6 = 1;
    while (1)
    {
      v7 = *(const __CFArray **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 200) + 8 * v5 + 136) + 24);
      Count = CFArrayGetCount(v7);
      if (Count >= 1)
        break;
LABEL_12:
      v6 = ++v5 < v18;
      if (v5 == v18)
        return v6;
    }
    v9 = Count;
    v10 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v7, v10);
      if (ValueAtIndex)
      {
        v12 = ValueAtIndex;
        v13 = CFGetTypeID(ValueAtIndex);
        if (v13 == CFDictionaryGetTypeID())
        {
          Value = (const __CFDictionary *)CFDictionaryGetValue(v12, CFSTR("kSecTrustSettingsPolicyOptions"));
          if (Value)
          {
            v15 = Value;
            v16 = CFGetTypeID(Value);
            if (v16 == CFDictionaryGetTypeID())
            {
              if (CFDictionaryContainsKey(v15, a2))
                break;
            }
          }
        }
      }
      if (v9 == ++v10)
        goto LABEL_12;
    }
  }
  else
  {
    return 0;
  }
  return v6;
}

const void *sub_10000ED5C(const __CFArray *a1, CFIndex a2, const void *a3, const void *a4)
{
  CFDictionaryRef *ValueAtIndex;
  const void *result;
  const void *v8;
  CFTypeID v9;
  int v10;
  CFTypeID v11;
  CFRange v12;

  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(a1, a2);
  result = CFDictionaryGetValue(ValueAtIndex[4], a3);
  if (result)
  {
    v8 = result;
    v9 = CFGetTypeID(result);
    if (v9 == CFDataGetTypeID())
    {
      v10 = CFEqual(a4, v8);
      return (const void *)(v10 != 0);
    }
    v11 = CFGetTypeID(v8);
    if (v11 == CFArrayGetTypeID())
    {
      v12.length = CFArrayGetCount((CFArrayRef)v8);
      v12.location = 0;
      v10 = CFArrayContainsValue((CFArrayRef)v8, v12, a4);
      return (const void *)(v10 != 0);
    }
    return 0;
  }
  return result;
}

void sub_10000EE04(_QWORD *a1, CFDictionaryRef theDict, const __CFDate *a3)
{
  const __CFDate *Value;
  const __CFDate *v6;
  double v7;

  Value = (const __CFDate *)CFDictionaryGetValue(theDict, CFSTR("expiry"));
  if (Value)
  {
    v6 = Value;
    if (CFDateCompare(a3, Value, 0) == kCFCompareLessThan
      && (v7 = *(double *)(*(_QWORD *)(a1[5] + 8) + 24), v7 < CFDateGetAbsoluteTime(v6)))
    {
      ++*(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
      ++*(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
    }
    else
    {
      *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
    }
  }
  else
  {
    ++*(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
  }
}

uint64_t sub_10000EED8(_QWORD *a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  CFDictionaryRef *ValueAtIndex;
  const void *Value;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  uint64_t result;
  CFIndex i;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v4 = *(_QWORD *)(*a1 + 200);
  if (v4)
    v5 = *(_QWORD *)(v4 + 16);
  else
    v5 = 0;
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex((CFArrayRef)a1[1], a1[3]);
  Value = CFDictionaryGetValue(ValueAtIndex[4], a2);
  v8 = *(_QWORD *)(*a1 + 200);
  if (v8 && *(uint64_t *)(v8 + 16) >= 1 && (v9 = *(_QWORD *)(v8 + 136)) != 0)
    v10 = *(const void **)(v9 + 16);
  else
    v10 = 0;
  result = sub_10000F2B4(a1, (uint64_t)off_1000827E8, v10);
  if ((result & 1) == 0 && v5 >= 1)
  {
    for (i = 0; i < v5; ++i)
    {
      v13 = 0;
      v14 = *(_QWORD *)(*a1 + 200);
      if (v14 && (i & 0x8000000000000000) == 0)
      {
        if (*(_QWORD *)(v14 + 16) > i && (v15 = *(_QWORD *)(v14 + 8 * i + 136)) != 0)
          v13 = *(_QWORD *)(v15 + 16);
        else
          v13 = 0;
      }
      result = SecCertificateIsAtLeastMinKeySize(v13, Value);
      if ((result & 1) == 0)
      {
        result = sub_10000E2C8((uint64_t)a1, a2, i, kCFBooleanFalse, 0, 0);
        if (!(_DWORD)result)
          break;
      }
    }
  }
  return result;
}

uint64_t sub_10000F004(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t, const void *))
{
  uint64_t v7;
  const __CFData *NormalizedIssuerContent;
  const __CFData *v9;
  NSObject *v10;
  uint64_t v11;
  const __CFArray *v12;
  const __CFArray *Value;
  const __CFArray *v14;
  const void *v15;
  CFIndex Count;
  CFMutableArrayRef MutableCopy;
  const void *v18;
  const void *v19;
  _QWORD v21[8];
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  NSObject *v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;

  v7 = SecTrustStoreForDomain(2);
  v26 = 0;
  v27 = &v26;
  v28 = 0x2000000000;
  v29 = 0;
  v22 = 0;
  v23 = &v22;
  v24 = 0x2000000000;
  v25 = 0xAAAAAAAAAAAAAAAALL;
  v25 = sub_10000F78C(v7);
  NormalizedIssuerContent = (const __CFData *)SecCertificateGetNormalizedIssuerContent(a2);
  v9 = NormalizedIssuerContent;
  if (NormalizedIssuerContent && CFDataGetLength(NormalizedIssuerContent) >= 1)
  {
    if (!v7)
      goto LABEL_17;
    if (*(_QWORD *)(v7 + 8) && *(_DWORD *)(v7 + 36) != 1 && v23[3])
    {
      v10 = *(NSObject **)v7;
      v21[0] = _NSConcreteStackBlock;
      v21[1] = 0x40000000;
      v21[2] = sub_10001D0BC;
      v21[3] = &unk_100079A50;
      v21[6] = v7;
      v21[7] = v9;
      v21[4] = &v22;
      v21[5] = &v26;
      dispatch_sync(v10, v21);
    }
  }
  else if (!v7)
  {
    goto LABEL_17;
  }
  if (v9)
  {
    v11 = *(_QWORD *)(v7 + 40);
    if (v11)
    {
      v12 = (const __CFArray *)v27[3];
      if (v12)
      {
        if (CFArrayGetCount(v12))
          goto LABEL_17;
        v11 = *(_QWORD *)(v7 + 40);
      }
      Value = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(v11 + 16), v9);
      if (Value)
      {
        v14 = Value;
        v15 = (const void *)v27[3];
        if (v15)
        {
          v27[3] = 0;
          CFRelease(v15);
        }
        Count = CFArrayGetCount(v14);
        MutableCopy = CFArrayCreateMutableCopy(0, Count, v14);
        v27[3] = (uint64_t)MutableCopy;
      }
    }
  }
LABEL_17:
  v18 = (const void *)v23[3];
  if (v18)
  {
    v23[3] = 0;
    CFRelease(v18);
  }
  v19 = (const void *)v27[3];
  _Block_object_dispose(&v22, 8);
  _Block_object_dispose(&v26, 8);
  a4(a3, v19);
  if (v19)
    CFRelease(v19);
  return 1;
}

const __CFArray *sub_10000F1C8(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  const void *v6;
  const __CFArray *result;
  CFDictionaryRef *ValueAtIndex;
  const __CFArray *Value;
  double v10;
  double v11;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v4 && *(uint64_t *)(v4 + 16) >= 1 && (v5 = *(_QWORD *)(v4 + 136)) != 0)
    v6 = *(const void **)(v5 + 16);
  else
    v6 = 0;
  result = (const __CFArray *)sub_10000F2B4((_QWORD *)a1, (uint64_t)off_1000827E8, v6);
  if ((result & 1) == 0)
  {
    ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
    Value = (const __CFArray *)CFDictionaryGetValue(ValueAtIndex[4], a2);
    v10 = SecCertificateNotValidBefore(v6);
    v11 = SecCertificateNotValidAfter(v6);
    result = sub_10000F940(Value, v10, v11);
    if ((result & 1) == 0)
      return (const __CFArray *)sub_10000E2C8(a1, a2, 0, kCFBooleanFalse, 0, 0);
  }
  return result;
}

BOOL sub_10000F2B4(_QWORD *a1, uint64_t a2, const void *a3)
{
  uint64_t (*v6)(uint64_t, const void *);
  const __CFArray *v7;
  int IsSelfSigned;
  _BOOL8 v9;
  NSObject *v10;
  int v11;
  NSObject *v12;
  const char *v14;
  const char *v15;
  char v16;
  uint8_t buf[4];
  const char *v18;

  v6 = *(uint64_t (**)(uint64_t, const void *))(a2 + 8);
  if (v6)
    v7 = (const __CFArray *)v6(a2, a3);
  else
    v7 = 0;
  v16 = 0;
  IsSelfSigned = SecCertificateIsSelfSigned(a3, &v16);
  v9 = IsSelfSigned == 0;
  if (IsSelfSigned)
  {
LABEL_10:
    if (!v7)
      return v9;
    goto LABEL_19;
  }
  if (*(_QWORD *)(a2 + 8))
  {
    if (!v7)
      return 0;
    if (CFArrayGetCount(v7) || !v16)
    {
      v11 = sub_100004760(a1, a3, v7);
      if (v16 && v11 == 1 || !v16 && v11 == 2)
      {
        v12 = sub_100011628("trust");
        if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        {
LABEL_18:
          v9 = 1;
          goto LABEL_19;
        }
        *(_WORD *)buf = 0;
        v14 = "complex trust settings anchor";
      }
      else
      {
        if (v11 != 3)
        {
          v9 = 0;
          goto LABEL_19;
        }
        v12 = sub_100011628("trust");
        if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
          goto LABEL_18;
        *(_WORD *)buf = 0;
        v14 = "complex trust settings denied anchor";
      }
      _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, v14, buf, 2u);
      goto LABEL_18;
    }
  }
  v10 = sub_100011628("trust");
  if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    goto LABEL_10;
  if (*(_QWORD *)(a2 + 8))
    v15 = "";
  else
    v15 = " source";
  *(_DWORD *)buf = 136315138;
  v18 = v15;
  _os_log_debug_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "unrestricted anchor%s", buf, 0xCu);
  if (v7)
LABEL_19:
    CFRelease(v7);
  return v9;
}

CFTypeRef sub_10000F4C4(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  char v4;
  CFTypeRef result;
  CFTypeRef cf;

  cf = 0;
  v3 = SecTrustStoreForDomain(2);
  v4 = sub_10000F8D0(v3, a2, (__CFArray **)&cf, 0);
  result = cf;
  if ((v4 & 1) == 0)
  {
    if (cf)
    {
      cf = 0;
      CFRelease(result);
      return 0;
    }
  }
  return result;
}

uint64_t sub_10000F520(NSObject *a1, uint64_t a2, _BYTE *a3, _QWORD *a4, __CFString **a5)
{
  const __CFData *v10;
  NSObject *isa;
  Class v12;
  Class v13;
  uint64_t v14;
  __CFString *v15;
  const void *v16;
  const void *v17;
  uint64_t v18;
  const __CFString *v20;
  _QWORD block[11];
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  NSObject *v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  char v33;

  if (a3)
    *a3 = 0;
  v30 = 0;
  v31 = &v30;
  v32 = 0x2000000000;
  v33 = 1;
  v26 = 0;
  v27 = &v26;
  v28 = 0x2000000000;
  v29 = 0xAAAAAAAAAAAAAAAALL;
  v29 = sub_10000F78C(a1);
  v22 = 0;
  v23 = &v22;
  v24 = 0x2000000000;
  v25 = 0xAAAAAAAAAAAAAAAALL;
  v25 = SecCertificateCopySHA256Digest(a2);
  v10 = (const __CFData *)v23[3];
  if (!v10)
  {
    v20 = CFSTR("failed to get cert sha256 digest");
LABEL_32:
    sub_100012C88(-108, a5, v20);
LABEL_33:
    *((_BYTE *)v31 + 24) = 0;
    if (!a1)
      goto LABEL_24;
    goto LABEL_9;
  }
  if (CFDataGetLength(v10) <= 0)
  {
    v20 = CFSTR("cert digest of bad length");
    goto LABEL_32;
  }
  if (!a1 || !a1[1].isa)
  {
    sub_100012C88(-50, a5, CFSTR("ts is NULL"));
    goto LABEL_33;
  }
  if (v27[3])
  {
    isa = a1->isa;
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = sub_10000A8F8;
    block[3] = &unk_100079B58;
    block[4] = &v30;
    block[5] = &v22;
    block[6] = &v26;
    block[7] = a1;
    block[8] = a5;
    block[9] = a3;
    block[10] = a4;
    dispatch_sync(isa, block);
  }
  else
  {
    sub_100012C88(-26276, a5, CFSTR("failed to get uuid"));
    *((_BYTE *)v31 + 24) = 0;
  }
LABEL_9:
  v12 = a1[5].isa;
  if (v12 && (a3 && !*a3 || a4 && !*a4) && CFSetContainsValue(*((CFSetRef *)v12 + 1), (const void *)v23[3]))
  {
    if (a3)
      *a3 = 1;
    if (a4)
    {
      v13 = a1[5].isa;
      v14 = *((_QWORD *)v13 + 3);
      if (v14)
        CFRetain(*((CFTypeRef *)v13 + 3));
      *a4 = v14;
    }
    *((_BYTE *)v31 + 24) = 1;
    if (a5)
    {
      v15 = *a5;
      if (*a5)
      {
        *a5 = 0;
        CFRelease(v15);
      }
    }
  }
LABEL_24:
  v16 = (const void *)v27[3];
  if (v16)
  {
    v27[3] = 0;
    CFRelease(v16);
  }
  v17 = (const void *)v23[3];
  if (v17)
  {
    v23[3] = 0;
    CFRelease(v17);
  }
  v18 = *((unsigned __int8 *)v31 + 24);
  _Block_object_dispose(&v22, 8);
  _Block_object_dispose(&v26, 8);
  _Block_object_dispose(&v30, 8);
  return v18;
}

NSObject *sub_10000F78C(NSObject *result)
{
  uid_t v1;

  if (result)
  {
    if (HIDWORD(result[4].isa) == 2)
      v1 = geteuid();
    else
      v1 = 282;
    return sub_10000F7BC(v1);
  }
  return result;
}

NSObject *sub_10000F7BC(uid_t a1)
{
  int v2;
  int v3;
  const void *v4;
  NSObject *v5;
  NSObject *v6;
  NSObject *v7;
  _QWORD v9[2];
  uint8_t buf[4];
  uid_t v11;
  __int16 v12;
  int v13;

  v9[0] = 0xAAAAAAAAAAAAAAAALL;
  v9[1] = 0xAAAAAAAAAAAAAAAALL;
  v2 = mbr_uid_to_uuid(a1, (unsigned __int8 *)v9);
  if (v2)
  {
    v3 = v2;
    v4 = sub_100011628("SecError");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109376;
      v11 = a1;
      v12 = 1024;
      v13 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "failed to get UUID for user(%d) - %d", buf, 0xEu);
    }
    v6 = 0;
  }
  else
  {
    v7 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", v9, 16);
    v5 = v7;
    if (v7)
    {
      v5 = v7;
      v6 = v5;
    }
    else
    {
      v6 = 0;
    }
  }

  return v6;
}

uint64_t sub_10000F8D0(uint64_t a1, uint64_t a2, __CFArray **a3, __CFString **a4)
{
  __CFArray *v5;

  if (!a1 || *(_DWORD *)(a1 + 36) != 1)
    return sub_10000F520(a1, a2, 0, a3, a4);
  if (a3)
  {
    if (off_1000827D8)
      v5 = off_1000827D8();
    else
      v5 = 0;
    *a3 = v5;
  }
  return 1;
}

const __CFArray *sub_10000F940(const __CFArray *result, double a2, double a3)
{
  const __CFArray *v5;
  CFTypeID v6;
  CFIndex v7;
  double v8;
  CFIndex Count;
  BOOL v10;
  const __CFArray *v11;
  CFTypeID v12;
  const void *ValueAtIndex;
  const void *v14;
  const void *v15;
  CFTypeID v16;
  CFTypeID TypeID;
  CFTypeID v18;
  double AbsoluteTime;
  double valuePtr;

  if (result)
  {
    v5 = result;
    v6 = CFGetTypeID(result);
    if (v6 == CFArrayGetTypeID())
    {
      v7 = 0;
      v8 = a3 - a2;
      while (1)
      {
        Count = CFArrayGetCount(v5);
        v10 = v7 < Count;
        result = (const __CFArray *)(v7 >= Count);
        if (!v10)
          break;
        result = (const __CFArray *)CFArrayGetValueAtIndex(v5, v7);
        if (!result)
          break;
        v11 = result;
        v12 = CFGetTypeID(result);
        if (v12 != CFArrayGetTypeID())
          return 0;
        ValueAtIndex = CFArrayGetValueAtIndex(v11, 0);
        v14 = CFArrayGetValueAtIndex(v11, 1);
        if (!ValueAtIndex)
          return 0;
        v15 = v14;
        v16 = CFGetTypeID(ValueAtIndex);
        TypeID = CFDateGetTypeID();
        result = 0;
        if (v16 != TypeID || !v15)
          return result;
        v18 = CFGetTypeID(v15);
        if (v18 != CFNumberGetTypeID())
          return 0;
        AbsoluteTime = CFDateGetAbsoluteTime((CFDateRef)ValueAtIndex);
        valuePtr = 0.0;
        if (!CFNumberGetValue((CFNumberRef)v15, kCFNumberDoubleType, &valuePtr) || AbsoluteTime <= a2 && v8 > valuePtr)
          return 0;
        ++v7;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_10000FA8C(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t, __CFArray *))
{
  const __CFData *NormalizedIssuerContent;
  const __CFArray *v7;
  __CFArray *v8;
  const __CFArray *v9;
  __CFArray *Mutable;
  CFIndex Count;
  CFIndex v12;
  CFIndex i;
  const __CFData *ValueAtIndex;
  SecCertificateRef v15;
  SecCertificateRef v16;

  NormalizedIssuerContent = (const __CFData *)SecCertificateGetNormalizedIssuerContent(a2);
  v7 = sub_100002CE4(NormalizedIssuerContent);
  if (v7 && (v8 = sub_100002DF0(v7)) != 0)
  {
    v9 = v8;
    Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    Count = CFArrayGetCount(v9);
    if (Count >= 1)
    {
      v12 = Count;
      for (i = 0; i != v12; ++i)
      {
        ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(v9, i);
        if (ValueAtIndex)
        {
          v15 = SecCertificateCreateWithData(kCFAllocatorDefault, ValueAtIndex);
          if (v15)
          {
            v16 = v15;
            CFArrayAppendValue(Mutable, v15);
            CFRelease(v16);
          }
        }
      }
    }
    CFRelease(v9);
    a4(a3, Mutable);
    if (Mutable)
      CFRelease(Mutable);
  }
  else
  {
    a4(a3, 0);
  }
  return 1;
}

uint64_t sub_10000FB94(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t, const void *))
{
  const void *NormalizedIssuerContent;

  NormalizedIssuerContent = (const void *)SecCertificateGetNormalizedIssuerContent(a2);
  if (NormalizedIssuerContent)
    NormalizedIssuerContent = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), NormalizedIssuerContent);
  a4(a3, NormalizedIssuerContent);
  return 1;
}

void sub_10000FBE8(uint64_t a1, const __CFArray *a2)
{
  _QWORD *ValueAtIndex;
  uint64_t v5;
  uint64_t v6;
  CFIndex Count;
  CFIndex v8;
  CFIndex i;
  const void *v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  _BOOL4 v17;
  uint64_t (*v18)(void);
  const void *v19;
  const void *v20;
  __CFArray *v21;
  CFIndex v22;
  uint64_t v23;
  char v24;

  ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 144), *(_QWORD *)(a1 + 168));
  v5 = (uint64_t)ValueAtIndex;
  if (ValueAtIndex)
  {
    v6 = ValueAtIndex[2] - 1;
    if (!a2)
      goto LABEL_31;
  }
  else
  {
    v6 = -1;
    if (!a2)
      goto LABEL_31;
  }
  Count = CFArrayGetCount(a2);
  if (Count >= 1)
  {
    v8 = Count;
    for (i = 0; i != v8; ++i)
    {
      v10 = CFArrayGetValueAtIndex(a2, i);
      v11 = sub_100011848(v5, v10);
      if (v11 == -1)
      {
        v23 = 0;
        v17 = sub_100002A7C(a1, (uint64_t)v10, &v23);
        if (v23 && (v18 = *(uint64_t (**)(void))(v23 + 8)) != 0)
        {
          v19 = (const void *)v18();
          v20 = (const void *)sub_100010264(v5, v10, v19);
          if (v19)
            CFRelease(v19);
        }
        else
        {
          v20 = (const void *)sub_100010264(v5, v10, 0);
        }
        if (v20)
        {
          if (!CFSetContainsValue(*(CFSetRef *)(a1 + 136), v20))
          {
            CFSetAddValue(*(CFMutableSetRef *)(a1 + 136), v20);
            if (v17)
              sub_100012918((uint64_t)v20);
            if (sub_1000118A8(a1, (uint64_t)v20))
            {
              v21 = *(__CFArray **)(a1 + 144);
              v22 = *(_QWORD *)(a1 + 168) + 1;
              *(_QWORD *)(a1 + 168) = v22;
              CFArrayInsertValueAtIndex(v21, v22, v20);
            }
          }
          CFRelease(v20);
        }
      }
      else if (v11 == v6 && (*(_QWORD *)(v5 + 40) & 0x8000000000000000) != 0)
      {
        v12 = *(_QWORD *)(v5 + 16);
        v13 = v12 < 1;
        v14 = v12 - 1;
        *(_QWORD *)(v5 + 40) = v14;
        if (!v13 && !*(_BYTE *)(v5 + 48))
        {
          v15 = *(_QWORD *)(v5 + 8 * v14 + 136);
          v24 = 0;
          if (SecCertificateIsSelfSigned(*(_QWORD *)(v15 + 16), &v24))
            v16 = 1;
          else
            v16 = v24 == 0;
          if (v16)
            *(_QWORD *)(v5 + 40) = -1;
          else
            *(_BYTE *)(v5 + 48) = 1;
        }
      }
    }
  }
LABEL_31:
  *(_QWORD *)(a1 + 248) = sub_10000FFB8;
  sub_10000FDEC(a1);
}

void sub_10000FDEC(uint64_t a1)
{
  uint64_t (*v2)(uint64_t);
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v9;
  NSObject *v10;
  CFMutableArrayRef v11;
  const void *v12;
  const void *v13;
  uint64_t v14;
  void (*v15)(uint64_t, CFMutableArrayRef, const void *, const void *, uint64_t);
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  int v23;

  if (*(_QWORD *)(a1 + 240))
    return;
  *(_QWORD *)(a1 + 240) = 1;
  do
  {
    v2 = *(uint64_t (**)(uint64_t))(a1 + 248);
    if (!v2)
    {
      v5 = *(_QWORD *)(a1 + 240) - 1;
      *(_QWORD *)(a1 + 240) = v5;
      if (v5)
        return;
LABEL_9:
      v6 = sub_100015ECC(a1);
      v7 = *(_DWORD *)(v6 + 64);
      if (v7 != 4 || *(_QWORD *)(a1 + 128) == 0)
        v9 = v7;
      else
        v9 = 1;
      v10 = sub_100011628("trust");
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        v16 = *(_QWORD *)(a1 + 224);
        v17 = *(_QWORD *)(v6 + 56);
        v18 = 138478339;
        v19 = v16;
        v20 = 2114;
        v21 = v17;
        v22 = 1024;
        v23 = v9;
        _os_log_debug_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "completed: %{private}@ details: %{public}@ result: %d", (uint8_t *)&v18, 0x1Cu);
      }
      if (*(_QWORD *)(a1 + 256))
      {
        v11 = sub_100011E18(*(_QWORD *)(a1 + 224));
        v12 = *(const void **)(a1 + 232);
        if (v12)
          CFRetain(*(CFTypeRef *)(a1 + 232));
        v13 = *(const void **)(v6 + 56);
        if (v13)
          CFRetain(v13);
        v15 = *(void (**)(uint64_t, CFMutableArrayRef, const void *, const void *, uint64_t))(a1 + 256);
        v14 = *(_QWORD *)(a1 + 264);
        CFRelease((CFTypeRef)a1);
        v15(v14, v11, v13, v12, v9);
        if (v11)
          CFRelease(v11);
        if (v12)
          CFRelease(v12);
        if (!v13)
          return;
      }
      else
      {
        v13 = (const void *)a1;
      }
      CFRelease(v13);
      return;
    }
  }
  while ((v2(a1) & 1) != 0);
  v3 = *(_QWORD *)(a1 + 248);
  v4 = *(_QWORD *)(a1 + 240) - 1;
  *(_QWORD *)(a1 + 240) = v4;
  if (!v3 && !v4)
    goto LABEL_9;
}

uint64_t sub_10000FFB8(uint64_t a1)
{
  _QWORD *ValueAtIndex;
  uint64_t (*v3)(uint64_t);
  CFIndex Count;
  CFIndex v6;
  const void *v7;
  __CFArray *v8;
  CFIndex v9;
  CFIndex v10;
  CFIndex v11;
  CFIndex v12;
  NSObject *v13;
  CFIndex v14;
  uint64_t v15;
  CFIndex v16;
  CFIndex v17;
  uint64_t v18;
  CFIndex v19;
  uint64_t (**v20)(const void *, uint64_t, uint64_t, void (*)(uint64_t, const __CFArray *));
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  CFIndex v25;

  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 160)))
  {
    ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 160), 0);
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 160), 0);
LABEL_3:
    sub_10000D4C4(a1, ValueAtIndex);
    v3 = sub_10001203C;
LABEL_4:
    *(_QWORD *)(a1 + 248) = v3;
    return 1;
  }
  if (*(_BYTE *)(a1 + 176))
  {
    Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 152));
    if (Count)
    {
      v6 = Count - 1;
      v7 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 152), Count - 1);
      if (sub_1000118A8(a1, (uint64_t)v7))
      {
        v8 = *(__CFArray **)(a1 + 144);
        v9 = *(_QWORD *)(a1 + 168) + 1;
        *(_QWORD *)(a1 + 168) = v9;
        CFArrayInsertValueAtIndex(v8, v9, v7);
      }
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 152), v6);
      return 1;
    }
  }
  v10 = *(_QWORD *)(a1 + 168);
  if (v10 < 0)
  {
    v11 = CFArrayGetCount(*(CFArrayRef *)(a1 + 88));
    v12 = *(_QWORD *)(a1 + 80);
    if (v12 >= v11)
    {
      if (*(_BYTE *)(a1 + 176))
      {
        if (*(_BYTE *)(a1 + 177))
        {
          v3 = sub_10000D348;
          goto LABEL_4;
        }
        *(_BYTE *)(a1 + 177) = 1;
      }
      else
      {
        *(_BYTE *)(a1 + 176) = 1;
      }
    }
    else
    {
      *(_QWORD *)(a1 + 80) = v12 + 1;
    }
    v15 = CFArrayGetCount(*(CFArrayRef *)(a1 + 144)) - 1;
LABEL_34:
    *(_QWORD *)(a1 + 168) = v15;
    return 1;
  }
  ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 144), v10);
  if (*(_BYTE *)(a1 + 177))
  {
    --*(_QWORD *)(a1 + 168);
    goto LABEL_3;
  }
  if (CFSetGetCount(*(CFSetRef *)(a1 + 136)) >= 101)
  {
    v13 = sub_100011628("trust");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      v14 = CFSetGetCount(*(CFSetRef *)(a1 + 136));
      v24 = 134217984;
      v25 = v14;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "not building any more paths, already have %ld", (uint8_t *)&v24, 0xCu);
    }
    v15 = -1;
    goto LABEL_34;
  }
  v16 = ValueAtIndex[3];
  v17 = CFArrayGetCount(*(CFArrayRef *)(a1 + 72));
  if (v16 >= *(_QWORD *)(a1 + 80) + v17)
  {
    v15 = *(_QWORD *)(a1 + 168) - 1;
    goto LABEL_34;
  }
  v18 = 88;
  if (v16 >= v17)
  {
    v19 = v17;
  }
  else
  {
    v18 = 72;
    v19 = 0;
  }
  v20 = (uint64_t (**)(const void *, uint64_t, uint64_t, void (*)(uint64_t, const __CFArray *)))CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + v18), v16 - v19);
  ValueAtIndex[3] = v16 + 1;
  v21 = ValueAtIndex[2];
  if (v21 >= 1 && (v22 = ValueAtIndex[v21 + 16]) != 0)
    v23 = *(_QWORD *)(v22 + 16);
  else
    v23 = 0;
  return (*v20)(v20, v23, a1, sub_10000FBE8);
}

uint64_t sub_100010264(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  uint64_t v10;
  uint64_t Instance;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  const void **v15;
  uint64_t v16;
  const void *v17;
  uint64_t v18;
  uint64_t CertificatePolicies;
  uint64_t v20;
  uint64_t v21;
  char v22;
  unsigned int v23;
  uint64_t BasicConstraints;
  int KeyUsage;
  CFNumberRef v27;
  CFNumberRef v28;
  __CFDictionary *Mutable;
  __CFDictionary *v30;
  CFNumberRef v31;
  CFNumberRef v32;
  NSObject *v33;
  const char *v34;
  CFNumberRef v35;
  char v36;
  CFArrayRef v37;
  CFArrayRef v38;
  NSObject *v39;
  const char *v40;
  NSObject *v41;
  uint32_t v42;
  int v43;
  NSObject *v44;
  _QWORD v46[5];

  if (a1)
  {
    v6 = *(_QWORD *)(a1 + 16) + 1;
    v7 = *(_QWORD *)(a1 + 32);
    v8 = *(_QWORD *)(a1 + 40);
    v9 = *(_BYTE *)(a1 + 48) != 0;
  }
  else
  {
    v7 = 0;
    v9 = 0;
    v8 = -1;
    v6 = 1;
  }
  v10 = sub_1000107C0();
  Instance = _CFRuntimeCreateInstance(kCFAllocatorDefault, v10, 8 * v6 + 120, 0);
  v12 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 24) = 0u;
    *(_OWORD *)(Instance + 40) = 0u;
    *(_OWORD *)(Instance + 120) = 0u;
    *(_OWORD *)(Instance + 104) = 0u;
    *(_OWORD *)(Instance + 88) = 0u;
    *(_OWORD *)(Instance + 72) = 0u;
    *(_OWORD *)(Instance + 56) = 0u;
    *(_QWORD *)(Instance + 16) = v6;
    *(_QWORD *)(Instance + 32) = v7;
    *(_QWORD *)(Instance + 40) = v8;
    v13 = v6 - 1;
    *(_BYTE *)(Instance + 48) = v9;
    if (v6 >= 2)
    {
      v14 = (_QWORD *)(Instance + 136);
      v15 = (const void **)(a1 + 136);
      v16 = v6 - 1;
      do
      {
        v17 = *v15++;
        *v14++ = v17;
        CFRetain(v17);
        --v16;
      }
      while (v16);
    }
    if (!a2)
      goto LABEL_53;
    v46[0] = _NSConcreteStackBlock;
    v46[1] = 0x40000000;
    v46[2] = sub_100038868;
    v46[3] = &unk_100076D20;
    v46[4] = &qword_100082D10;
    if (qword_100082D08 != -1)
      dispatch_once(&qword_100082D08, v46);
    v18 = _CFRuntimeCreateInstance(kCFAllocatorDefault, qword_100082D10, 32, 0);
    if (!v18)
      goto LABEL_54;
    CFRetain(a2);
    *(_QWORD *)(v18 + 16) = a2;
    *(_BYTE *)(v18 + 41) = SecCertificateIsWeakHash(a2);
    CertificatePolicies = SecCertificateGetCertificatePolicies(a2);
    if (!CertificatePolicies)
      goto LABEL_45;
    v20 = CertificatePolicies;
    if (!*(_QWORD *)(CertificatePolicies + 8))
      goto LABEL_45;
    v21 = 0;
    v22 = 0;
    v23 = 1;
    do
    {
      v22 |= sub_10001083C(*(_QWORD *)(v20 + 16) + 32 * v21) != 0;
      v21 = v23;
    }
    while (*(_QWORD *)(v20 + 8) > (unint64_t)v23++);
    if ((v22 & 1) == 0)
      goto LABEL_45;
    BasicConstraints = SecCertificateGetBasicConstraints(a2);
    if (BasicConstraints && *(_BYTE *)(BasicConstraints + 2))
    {
      v39 = sub_100011628("ev");
      v36 = 0;
      if (!os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
        goto LABEL_34;
      LOWORD(v46[0]) = 0;
      v40 = "Leaf has invalid basic constraints";
      v41 = v39;
      v42 = 2;
    }
    else
    {
      KeyUsage = SecCertificateGetKeyUsage(a2);
      if ((KeyUsage & 0x60) == 0)
      {
        v46[0] = 256;
        v27 = CFNumberCreate(0, kCFNumberCFIndexType, v46);
        if (v27)
        {
          v28 = v27;
          Mutable = CFDictionaryCreateMutable(0, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (Mutable)
          {
            v30 = Mutable;
            CFDictionaryAddValue(Mutable, kSecAttrKeyTypeEC, v28);
            if (SecCertificateNotValidBefore(a2) >= 410227200.0)
            {
              v46[0] = 2048;
              v35 = CFNumberCreate(0, kCFNumberCFIndexType, v46);
              if (v35)
              {
                v32 = v35;
                CFDictionaryAddValue(v30, kSecAttrKeyTypeRSA, v35);
                if ((SecCertificateIsAtLeastMinKeySize(a2, v30) & 1) == 0)
                {
                  v33 = sub_100011628("ev");
                  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
                  {
                    LOWORD(v46[0]) = 0;
                    v34 = "Leaf's public key is too small for issuance after 2013";
                    goto LABEL_50;
                  }
LABEL_51:
                  v36 = 0;
                  goto LABEL_32;
                }
LABEL_29:
                if (SecCertificateNotValidBefore(a2) <= 473299200.0
                  || SecCertificateGetSignatureHashAlgorithm(a2) > 4)
                {
                  v36 = 1;
LABEL_32:
                  CFRelease(v32);
LABEL_33:
                  CFRelease(v28);
                  CFRelease(v30);
LABEL_34:
                  *(_BYTE *)(v18 + 40) = v36;
                  if (a3)
                  {
                    CFRetain(a3);
                    *(_QWORD *)(v18 + 24) = a3;
LABEL_54:
                    *(_QWORD *)(v12 + 8 * v13 + 136) = v18;
                    return v12;
                  }
                  v37 = CFArrayCreate(kCFAllocatorDefault, 0, 0, &kCFTypeArrayCallBacks);
                  if (v37)
                  {
                    v38 = v37;
                    CFRetain(v37);
                    *(_QWORD *)(v18 + 24) = v38;
                    CFRelease(v38);
                    goto LABEL_54;
                  }
                  CFRelease((CFTypeRef)v18);
LABEL_53:
                  v18 = 0;
                  goto LABEL_54;
                }
                v33 = sub_100011628("ev");
                if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(v46[0]) = 0;
                  v34 = "Leaf was issued with SHA-1 after 2015";
                  goto LABEL_50;
                }
                goto LABEL_51;
              }
            }
            else
            {
              v46[0] = 1024;
              v31 = CFNumberCreate(0, kCFNumberCFIndexType, v46);
              if (v31)
              {
                v32 = v31;
                CFDictionaryAddValue(v30, kSecAttrKeyTypeRSA, v31);
                if ((SecCertificateIsAtLeastMinKeySize(a2, v30) & 1) == 0)
                {
                  v33 = sub_100011628("ev");
                  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
                  {
                    LOWORD(v46[0]) = 0;
                    v34 = "Leaf's public key is too small for issuance before 2014";
LABEL_50:
                    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, v34, (uint8_t *)v46, 2u);
                    goto LABEL_51;
                  }
                  goto LABEL_51;
                }
                goto LABEL_29;
              }
            }
            v36 = 0;
            goto LABEL_33;
          }
          CFRelease(v28);
        }
LABEL_45:
        v36 = 0;
        goto LABEL_34;
      }
      v43 = KeyUsage;
      v44 = sub_100011628("ev");
      v36 = 0;
      if (!os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
        goto LABEL_34;
      LODWORD(v46[0]) = 67109120;
      HIDWORD(v46[0]) = v43;
      v40 = "Leaf has invalid key usage %u";
      v41 = v44;
      v42 = 8;
    }
    _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, v40, (uint8_t *)v46, v42);
    goto LABEL_45;
  }
  return v12;
}

uint64_t sub_1000107C0()
{
  _QWORD block[5];

  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_1000388C4;
  block[3] = &unk_100076DA0;
  block[4] = &qword_100082D20;
  if (qword_100082D18 != -1)
    dispatch_once(&qword_100082D18, block);
  return qword_100082D20;
}

const void *sub_10001083C(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  const __CFDictionary *v4;
  const void *v5;
  const void *v6;
  const void *Value;

  v2 = sub_100004464();
  if (!v2)
    return 0;
  v3 = (const void *)v2;
  v4 = *(const __CFDictionary **)(v2 + 64);
  if (v4)
  {
    CFRetain(*(CFTypeRef *)(v2 + 64));
    CFRelease(v3);
    v5 = (const void *)SecDERItemCopyOIDDecimalRepresentation(kCFAllocatorDefault, a1);
    if (v5)
    {
      v6 = v5;
      Value = CFDictionaryGetValue(v4, v5);
      CFRelease(v6);
    }
    else
    {
      Value = 0;
    }
    v3 = v4;
  }
  else
  {
    Value = 0;
  }
  CFRelease(v3);
  return Value;
}

void sub_1000108E0(uint64_t a1, xpc_object_t object)
{
  _xpc_connection_s *v4;
  xpc_type_t type;
  uid_t euid;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  xpc_object_t v10;
  void *reply_with_format;
  CFDataRef v12;
  int v13;
  SecTaskRef v14;
  _BOOL4 v15;
  const __CFArray *v16;
  const __CFArray *v17;
  const void *v18;
  const __CFArray *v19;
  __CFArray *Mutable;
  NSObject *v21;
  CFIndex FirstIndexOfValue;
  CFIndex v23;
  NSObject *v24;
  NSObject *v25;
  unsigned int v26;
  uint64_t *v27;
  const __CFString *v28;
  CFTypeRef v29;
  CFTypeRef v30;
  void (*v31)(int, xpc_object_t, void *, __CFString **);
  NSObject *v32;
  const __CFString *v33;
  const __CFString *v34;
  const char *v35;
  _BOOL4 v36;
  uint64_t v37;
  xpc_object_t value;
  int v39;
  uint64_t v40;
  const __CFArray *v41;
  xpc_object_t v42;
  const __CFArray *v43;
  xpc_object_t v44;
  const void *v45;
  CFTypeRef v46;
  CFTypeRef v47;
  double v48;
  CFTypeRef v49;
  NSObject *v50;
  _BOOL4 v51;
  CFDataRef v52;
  _xpc_connection_s *objecta;
  xpc_object_t reply;
  uint64_t uint64;
  CFTypeRef v56;
  CFTypeRef v57;
  CFTypeRef v58;
  CFTypeRef v59;
  audit_token_t bytes;
  CFTypeRef v61[2];
  CFTypeRef v62[2];
  __int128 v63;
  __int128 v64;
  CFTypeRef cf;
  _BYTE v66[12];
  __int16 v67;
  const __CFString *v68;
  __int16 v69;
  CFTypeRef v70;
  audit_token_t buf;
  xpc_object_t v72;
  _xpc_connection_s *v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  CFDataRef v78;
  CFRange v79;
  CFRange v80;
  CFRange v81;
  CFRange v82;

  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    v4 = *(_xpc_connection_s **)(a1 + 32);
    type = xpc_get_type(object);
    cf = 0;
    v63 = 0u;
    v64 = 0u;
    *(_OWORD *)v61 = 0u;
    *(_OWORD *)v62 = 0u;
    LOBYTE(v62[0]) = 1;
    euid = xpc_connection_get_euid(v4);
    HIDWORD(v62[0]) = euid;
    BYTE4(v63) = 0;
    BYTE9(v64) = 0;
    if (type == (xpc_type_t)&_xpc_type_dictionary)
    {
      v13 = euid;
      reply = xpc_dictionary_create_reply(object);
      uint64 = xpc_dictionary_get_uint64(object, "operation");
      memset(&bytes, 0, sizeof(bytes));
      objecta = v4;
      xpc_connection_get_audit_token(v4, &bytes);
      buf = bytes;
      v14 = SecTaskCreateWithAuditToken(kCFAllocatorDefault, &buf);
      v61[0] = v14;
      v52 = CFDataCreate(kCFAllocatorDefault, (const UInt8 *)&bytes, 32);
      v15 = sub_100011D18(v14, CFSTR("com.apple.developer.on-demand-install-capable"));
      v16 = (const __CFArray *)sub_1000117A8(v14, CFSTR("keychain-access-groups"));
      v17 = (const __CFArray *)sub_1000117A8(v14, CFSTR("com.apple.security.application-groups"));
      v18 = sub_100011D84(v14);
      v19 = (const __CFArray *)sub_1000117A8(v14, CFSTR("com.apple.developer.associated-application-identifier"));
      Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
      if (v16)
      {
        v80.length = CFArrayGetCount(v16);
        v80.location = 0;
        CFArrayAppendArray(Mutable, v16, v80);
      }
      if (v19)
      {
        v81.length = CFArrayGetCount(v19);
        v81.location = 0;
        CFArrayAppendArray(Mutable, v19, v81);
      }
      if (v18)
        CFArrayAppendValue(Mutable, v18);
      if (v17)
      {
        if (v15)
        {
          v21 = sub_100011628("entitlements");
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            buf.val[0] = 138412290;
            *(_QWORD *)&buf.val[1] = CFSTR("com.apple.security.application-groups");
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Ignoring \"%@\" because client is API-restricted", (uint8_t *)&buf, 0xCu);
          }
        }
        else
        {
          v82.length = CFArrayGetCount(v17);
          v82.location = 0;
          CFArrayAppendArray(Mutable, v17, v82);
        }
      }
      v79.length = CFArrayGetCount(Mutable);
      v79.location = 0;
      FirstIndexOfValue = CFArrayGetFirstIndexOfValue(Mutable, v79, kSecAttrAccessGroupToken);
      if (FirstIndexOfValue != -1)
      {
        v23 = FirstIndexOfValue;
        if (_os_feature_enabled_impl("CryptoTokenKit", "UseTokens"))
        {
          CFArrayRemoveValueAtIndex(Mutable, v23);
          CFArrayAppendValue(Mutable, kSecAttrAccessGroupToken);
        }
        else
        {
          v24 = sub_100011628("SecWarning");
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf.val[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Keychain access group com.apple.token ignored, feature not available", (uint8_t *)&buf, 2u);
          }
          CFArrayRemoveValueAtIndex(Mutable, v23);
        }
      }
      if (v19)
        CFRelease(v19);
      v4 = objecta;
      if (v18)
        CFRelease(v18);
      reply_with_format = reply;
      if (v16)
        CFRelease(v16);
      v12 = v52;
      if (v17)
        CFRelease(v17);
      v61[1] = Mutable;
      v25 = sub_100011628("serverxpc");
      v26 = uint64;
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
      {
        if (uint64 > 0x87)
          v28 = CFSTR("Unknown xpc operation");
        else
          v28 = *(&off_100079D38 + uint64);
        buf.val[0] = 138412802;
        *(_QWORD *)&buf.val[1] = v14;
        LOWORD(buf.val[3]) = 2112;
        *(_QWORD *)((char *)&buf.val[3] + 2) = v28;
        HIWORD(buf.val[5]) = 2048;
        *(_QWORD *)&buf.val[6] = uint64;
        _os_log_debug_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEBUG, "XPC [%@] operation: %@ (%llu)", (uint8_t *)&buf, 0x20u);
      }
      switch(uint64)
      {
        case 0x64uLL:
          v27 = (uint64_t *)&off_100075B50;
          goto LABEL_93;
        case 0x65uLL:
          v27 = (uint64_t *)&off_100075B60;
          goto LABEL_93;
        case 0x66uLL:
          v27 = &qword_100075B80;
          goto LABEL_93;
        case 0x67uLL:
        case 0x68uLL:
        case 0x69uLL:
        case 0x6AuLL:
        case 0x6BuLL:
        case 0x6CuLL:
        case 0x6DuLL:
        case 0x6EuLL:
        case 0x6FuLL:
        case 0x70uLL:
        case 0x71uLL:
        case 0x72uLL:
        case 0x83uLL:
        case 0x84uLL:
          goto LABEL_98;
        case 0x73uLL:
          v27 = &qword_100075C00;
          goto LABEL_93;
        case 0x74uLL:
          v27 = (uint64_t *)&off_100075C10;
          goto LABEL_93;
        case 0x75uLL:
          v27 = (uint64_t *)&off_100075C20;
          goto LABEL_93;
        case 0x76uLL:
          v27 = &qword_100075C30;
          goto LABEL_93;
        case 0x77uLL:
          v27 = &qword_100075C40;
          goto LABEL_93;
        case 0x78uLL:
          v27 = &qword_100075C50;
          goto LABEL_93;
        case 0x79uLL:
          v27 = (uint64_t *)&off_100075C60;
          goto LABEL_93;
        case 0x7AuLL:
          v27 = (uint64_t *)&off_100075C70;
          goto LABEL_93;
        case 0x7BuLL:
          v27 = (uint64_t *)&off_100075C80;
          goto LABEL_93;
        case 0x7CuLL:
          v27 = &qword_100075C90;
          goto LABEL_93;
        case 0x7DuLL:
          v27 = (uint64_t *)&off_100075CA0;
          goto LABEL_93;
        case 0x7EuLL:
          v27 = (uint64_t *)&off_100075CB0;
          goto LABEL_93;
        case 0x7FuLL:
          *(_QWORD *)v66 = 0;
          v58 = 0;
          v59 = 0;
          if (!sub_100059DF4(object, "domain", v66, (__CFString **)&cf))
            goto LABEL_136;
          if (sub_100012A74(object, "auth", &v59, (__CFString **)&cf))
          {
            if (sub_100012A74(object, "settings", &v58, (__CFString **)&cf))
            {
              xpc_retain(objecta);
              if (v14)
                CFRetain(v14);
              if (v52)
                CFRetain(v52);
              v29 = v58;
              *(_QWORD *)buf.val = _NSConcreteStackBlock;
              *(_QWORD *)&buf.val[2] = 0x40000000;
              *(_QWORD *)&buf.val[4] = sub_100025968;
              *(_QWORD *)&buf.val[6] = &unk_100075AF0;
              v72 = reply;
              v73 = objecta;
              v74 = *(_OWORD *)v61;
              v75 = *(_OWORD *)v62;
              v76 = v63;
              v77 = v64;
              v78 = v52;
              sub_100054574(v13, v52, *(const void **)v66, v59, v58, &buf);
              reply_with_format = 0;
            }
            else
            {
              v29 = v58;
            }
            if (v29)
              CFRelease(v29);
          }
          v46 = v59;
          if (!v59)
            goto LABEL_136;
          goto LABEL_135;
        case 0x80uLL:
          v27 = &qword_100075CD0;
          goto LABEL_93;
        case 0x81uLL:
          v27 = (uint64_t *)&off_100075CE0;
          goto LABEL_93;
        case 0x82uLL:
          v27 = &qword_100075CF0;
          goto LABEL_93;
        case 0x85uLL:
          *(_QWORD *)v66 = 0;
          v59 = 0;
          if (!sub_100012D5C(0x85u, v14, CFSTR("com.apple.private.security.storage.trustd-private"), (__CFString **)&cf))goto LABEL_98;
          if (sub_100059D7C(object, v66, (__CFString **)&cf))
          {
            if (sub_100059CB0(object, "cfdict", &v59, (__CFString **)&cf))
            {
              xpc_retain(objecta);
              if (v14)
                CFRetain(v14);
              v30 = v59;
              *(_QWORD *)buf.val = _NSConcreteStackBlock;
              *(_QWORD *)&buf.val[2] = 0x40000000;
              *(_QWORD *)&buf.val[4] = sub_100025A24;
              *(_QWORD *)&buf.val[6] = &unk_100075B10;
              v72 = reply;
              v73 = objecta;
              v74 = *(_OWORD *)v61;
              v75 = *(_OWORD *)v62;
              v76 = v63;
              v77 = v64;
              sub_1000409EC(v13, *(const void **)v66, v59, &buf);
              reply_with_format = 0;
            }
            else
            {
              v30 = v59;
            }
            if (v30)
            {
              v46 = v30;
LABEL_135:
              CFRelease(v46);
            }
          }
LABEL_136:
          v47 = *(CFTypeRef *)v66;
          if (*(_QWORD *)v66)
LABEL_167:
            CFRelease(v47);
          goto LABEL_98;
        case 0x86uLL:
          v27 = &qword_100075BA0;
          goto LABEL_93;
        case 0x87uLL:
          v27 = &qword_100075B90;
LABEL_93:
          v31 = (void (*)(int, xpc_object_t, void *, __CFString **))v27[1];
          if (!v31)
            goto LABEL_98;
          if (!*v27)
            goto LABEL_97;
          if (sub_100012D5C(uint64, v14, (const __CFString *)*v27, (__CFString **)&cf))
          {
            v31 = (void (*)(int, xpc_object_t, void *, __CFString **))v27[1];
LABEL_97:
            v31((int)v61, object, reply, (__CFString **)&cf);
          }
LABEL_98:
          if (!cf)
          {
            v10 = 0;
            break;
          }
          if (((uint64_t (*)(void))SecErrorGetOSStatus)() == -25300)
            goto LABEL_113;
          if (SecErrorGetOSStatus(cf) == -25330)
          {
            v32 = sub_100011628("SecWarning");
            if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
              goto LABEL_113;
            if (v26 > 0x87)
              v33 = CFSTR("Unknown xpc operation");
            else
              v33 = *(&off_100079D38 + v26);
            *(_DWORD *)v66 = 138412802;
            *(CFTypeRef *)&v66[4] = v61[0];
            v67 = 2112;
            v68 = v33;
            v69 = 2112;
            v70 = cf;
            v35 = "Authentication is needed %@ %@ %@";
          }
          else
          {
            v32 = sub_100011628("SecError");
            if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
              goto LABEL_113;
            if (v26 > 0x87)
              v34 = CFSTR("Unknown xpc operation");
            else
              v34 = *(&off_100079D38 + v26);
            *(_DWORD *)v66 = 138412802;
            *(CFTypeRef *)&v66[4] = v61[0];
            v67 = 2112;
            v68 = v34;
            v69 = 2112;
            v70 = cf;
            v35 = "%@ %@ %@";
          }
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, v35, v66, 0x20u);
LABEL_113:
          v10 = sub_10002BA74((__CFError *)cf);
          if (reply_with_format)
            xpc_dictionary_set_value(reply_with_format, "error", v10);
          break;
        default:
          switch(uint64)
          {
            case 0x13uLL:
              v27 = &qword_100075BB0;
              goto LABEL_93;
            case 0x14uLL:
              v27 = &qword_100075BC0;
              goto LABEL_93;
            case 0x15uLL:
            case 0x16uLL:
            case 0x18uLL:
              goto LABEL_98;
            case 0x17uLL:
              v27 = &qword_100075BD0;
              goto LABEL_93;
            case 0x19uLL:
              v27 = &qword_100075BE0;
              goto LABEL_93;
            case 0x1AuLL:
              v27 = &qword_100075BF0;
              goto LABEL_93;
            default:
              v27 = &qword_100075B30;
              switch(uint64)
              {
                case 4uLL:
                  goto LABEL_93;
                case 5uLL:
                  v27 = (uint64_t *)&off_100075B40;
                  goto LABEL_93;
                case 6uLL:
                  v27 = (uint64_t *)&off_100075B70;
                  goto LABEL_93;
                case 8uLL:
                  *(_QWORD *)v66 = 0;
                  v58 = 0;
                  v59 = 0;
                  v56 = 0;
                  v57 = 0;
                  v36 = xpc_dictionary_get_BOOL(object, "anchorsOnly");
                  v51 = xpc_dictionary_get_BOOL(object, "keychainsAllowed");
                  v37 = xpc_dictionary_get_uint64(object, "attribution");
                  value = xpc_dictionary_get_value(object, "certificates");
                  if (!value)
                  {
                    sub_100012C88(-108, (__CFString **)&cf, CFSTR("no certs for key %s"), "certificates");
                    goto LABEL_158;
                  }
                  v39 = v36;
                  v40 = SecCertificateXPCArrayCopyArray(value, &cf);
                  if (!v40)
                    goto LABEL_158;
                  v41 = (const __CFArray *)v40;
                  v42 = xpc_dictionary_get_value(object, "anchors");
                  if (v42)
                  {
                    v43 = (const __CFArray *)SecCertificateXPCArrayCopyArray(v42, &cf);
                    if (!v43)
                      goto LABEL_157;
                  }
                  else
                  {
                    v43 = 0;
                  }
                  v44 = xpc_dictionary_get_value(object, "policies");
                  if (v44)
                  {
                    v45 = (const void *)SecPolicyXPCArrayCopyArray(v44, &cf);
                    if (!v45)
                      goto LABEL_155;
                  }
                  else
                  {
                    v45 = 0;
                  }
                  if (sub_100011AB0(object, "responses", (__CFArray **)v66, (__CFString **)&cf)
                    && sub_100011AB0(object, "scts", (__CFArray **)&v59, (__CFString **)&cf)
                    && sub_100011C4C(object, "trustedLogs", &v58, (__CFString **)&cf))
                  {
                    v48 = xpc_dictionary_get_double(object, "verifyDate");
                    if (sub_100011C4C(object, "exceptions", &v57, (__CFString **)&cf))
                    {
                      if (sub_100012A74(object, "auditToken", &v56, (__CFString **)&cf))
                      {
                        xpc_retain(objecta);
                        if (v14)
                          CFRetain(v14);
                        v49 = v56;
                        if (v56
                          && sub_100012D5C(8u, v14, CFSTR("com.apple.private.network.socket-delegate"), (__CFString **)&cf)|| (v49 = v52) != 0)
                        {
                          CFRetain(v49);
                        }
                        v50 = sub_100012A34();
                        *(_QWORD *)buf.val = _NSConcreteStackBlock;
                        *(_QWORD *)&buf.val[2] = 0x40000000;
                        *(_QWORD *)&buf.val[4] = sub_10000AE28;
                        *(_QWORD *)&buf.val[6] = &unk_100075AD0;
                        v4 = objecta;
                        v72 = reply;
                        v73 = objecta;
                        v74 = *(_OWORD *)v61;
                        v75 = *(_OWORD *)v62;
                        v76 = v63;
                        v77 = v64;
                        v78 = (CFDataRef)v49;
                        sub_10000C900(v50, v49, v41, v43, v39, v51, v45, *(const void **)v66, v48, v59, (void *)v58, Mutable, v57, v37, &buf);
                        reply = 0;
                      }
                      else
                      {
                        v4 = objecta;
                      }
                      v12 = v52;
                    }
                  }
                  if (v45)
                    CFRelease(v45);
LABEL_155:
                  reply_with_format = reply;
                  if (v43)
                    CFRelease(v43);
LABEL_157:
                  v26 = uint64;
                  CFRelease(v41);
LABEL_158:
                  if (*(_QWORD *)v66)
                    CFRelease(*(CFTypeRef *)v66);
                  if (v59)
                    CFRelease(v59);
                  if (v58)
                    CFRelease(v58);
                  if (v57)
                    CFRelease(v57);
                  v47 = v56;
                  if (v56)
                    goto LABEL_167;
                  goto LABEL_98;
                default:
                  goto LABEL_98;
              }
          }
      }
    }
    else
    {
      sub_10002A5E8(1, CFSTR("com.apple.security.xpc"), v7, &cf, v8, CFSTR("Messages expect to be xpc dictionary, got: %@"), object);
      v9 = sub_100011628("SecError");
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        buf.val[0] = 138412546;
        *(_QWORD *)&buf.val[1] = 0;
        LOWORD(buf.val[3]) = 2112;
        *(_QWORD *)((char *)&buf.val[3] + 2) = cf;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%@: returning error: %@", (uint8_t *)&buf, 0x16u);
      }
      v10 = sub_10002BA74((__CFError *)cf);
      reply_with_format = (void *)xpc_create_reply_with_format(object, "{%string: %value}", "error", v10);
      v12 = 0;
    }
    if (reply_with_format)
    {
      xpc_connection_send_message(v4, reply_with_format);
      xpc_release(reply_with_format);
    }
    if (v10)
      xpc_release(v10);
    if (cf)
      CFRelease(cf);
    if (v61[1])
      CFRelease(v61[1]);
    if (v62[1])
      CFRelease(v62[1]);
    if (v61[0])
      CFRelease(v61[0]);
    if (v12)
      CFRelease(v12);
  }
}

const void *sub_100011628(const char *a1)
{
  const __CFString *v2;
  const void *v3;

  pthread_mutex_lock(&stru_100082720);
  pthread_mutex_unlock(&stru_100082720);
  if (!a1)
    return sub_1000116A4(0);
  v2 = CFStringCreateWithCString(kCFAllocatorDefault, a1, 0x600u);
  v3 = sub_1000116A4(v2);
  if (v2)
    CFRelease(v2);
  return v3;
}

const void *sub_1000116A4(const __CFString *a1)
{
  const __CFString *v1;
  const __CFDictionary *Mutable;
  const void *Value;
  _QWORD v5[5];
  _QWORD v6[5];

  if (a1)
    v1 = a1;
  else
    v1 = CFSTR("logging");
  os_unfair_lock_lock_with_options(&unk_100082AB0, 0x10000);
  Mutable = (const __CFDictionary *)qword_100082AB8;
  if (!qword_100082AB8)
  {
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, 0);
    qword_100082AB8 = (uint64_t)Mutable;
  }
  Value = CFDictionaryGetValue(Mutable, v1);
  if (!Value)
  {
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 0x40000000;
    v5[2] = sub_1000269D4;
    v5[3] = &unk_100075D38;
    v5[4] = v1;
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000;
    v6[2] = sub_100026C34;
    v6[3] = &unk_100075DD0;
    v6[4] = v5;
    sub_100019A20(v1, (uint64_t)v6);
    Value = CFDictionaryGetValue((CFDictionaryRef)qword_100082AB8, v1);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_100082AB0);
  return Value;
}

const void *sub_1000117A8(__SecTask *a1, const __CFString *a2)
{
  CFTypeRef v2;
  const void *v3;
  CFTypeID v4;
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;
  const void *ValueAtIndex;
  CFTypeID v9;

  v2 = SecTaskCopyValueForEntitlement(a1, a2, 0);
  v3 = v2;
  if (v2)
  {
    v4 = CFGetTypeID(v2);
    if (v4 != CFArrayGetTypeID())
    {
LABEL_8:
      CFRelease(v3);
      return 0;
    }
    Count = CFArrayGetCount((CFArrayRef)v3);
    if (Count >= 1)
    {
      v6 = Count;
      v7 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v3, v7);
        v9 = CFGetTypeID(ValueAtIndex);
        if (v9 != CFStringGetTypeID())
          break;
        if (v6 == ++v7)
          return v3;
      }
      goto LABEL_8;
    }
  }
  return v3;
}

uint64_t sub_100011848(uint64_t a1, CFTypeRef cf2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2 < 1)
    return -1;
  v4 = 0;
  v5 = a1 + 136;
  while (!CFEqual(*(CFTypeRef *)(*(_QWORD *)(v5 + 8 * v4) + 16), cf2))
  {
    if (v2 == ++v4)
      return -1;
  }
  return v4;
}

BOOL sub_1000118A8(uint64_t a1, uint64_t a2)
{
  uint64_t i;
  uint64_t v5;
  __SecCertificate *v6;
  SecKeyRef v7;
  _BOOL8 v8;
  SecKeyRef v9;
  int IsSignedBy;
  __CFArray *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t NormalizedIssuerContent;
  uint64_t v17;
  const void *v18;
  const void *NormalizedSubjectContent;
  uint64_t v20;
  _QWORD v22[6];
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  char v26;

  sub_10000D4C4(a1, (CFTypeRef)a2);
  v23 = 0;
  v24 = &v23;
  v25 = 0x2000000000;
  v26 = 1;
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 0x40000000;
  v22[2] = sub_10000D78C;
  v22[3] = &unk_100079810;
  v22[4] = &v23;
  v22[5] = a2;
  sub_10000D610(a1, (uint64_t)v22);
  if (!*(_BYTE *)(a1 + 176) && *((_BYTE *)v24 + 24))
    goto LABEL_13;
  if (a2)
  {
    for (i = *(_QWORD *)(a2 + 32); i < *(_QWORD *)(a2 + 16) - 1; *(_QWORD *)(a2 + 32) = i)
    {
      if (i >= -1 && (v5 = *(_QWORD *)(a2 + 8 * i + 144)) != 0)
        v6 = *(__SecCertificate **)(v5 + 16);
      else
        v6 = 0;
      v7 = SecCertificateCopyKey(v6);
      v8 = v7 == 0;
      if (!v7)
        goto LABEL_35;
      v9 = v7;
      IsSignedBy = SecCertificateIsSignedBy(*(_QWORD *)(*(_QWORD *)(a2 + 8 * *(_QWORD *)(a2 + 32) + 136) + 16), v7);
      CFRelease(v9);
      if (IsSignedBy)
        goto LABEL_15;
      i = *(_QWORD *)(a2 + 32) + 1;
    }
    if (*(_BYTE *)(a2 + 49))
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 160), (const void *)a2);
    if (!*(_BYTE *)(a2 + 48) || (v12 = *(_QWORD *)(a2 + 40), v12 < 0))
    {
      v13 = *(_QWORD *)(a2 + 16);
    }
    else
    {
      v13 = *(_QWORD *)(a2 + 16);
      if (v12 == v13 - 1)
        goto LABEL_21;
    }
    if (v13 >= 1 && (v14 = *(_QWORD *)(a2 + 8 * v13 + 128)) != 0)
      v15 = *(_QWORD *)(v14 + 16);
    else
      v15 = 0;
    NormalizedIssuerContent = SecCertificateGetNormalizedIssuerContent(v15);
    if (!NormalizedIssuerContent || (v17 = *(_QWORD *)(a2 + 16), v17 < 2))
    {
LABEL_34:
      v8 = 1;
      goto LABEL_35;
    }
    v18 = (const void *)NormalizedIssuerContent;
    while (1)
    {
      NormalizedSubjectContent = (const void *)SecCertificateGetNormalizedSubjectContent(*(_QWORD *)(*(_QWORD *)(a2 + 120 + 8 * v17) + 16));
      if (NormalizedSubjectContent)
      {
        if (CFEqual(v18, NormalizedSubjectContent))
          break;
      }
      v20 = v17 - 2;
      --v17;
      if (v20 <= 0)
        goto LABEL_34;
    }
LABEL_21:
    if (*(_BYTE *)(a1 + 176))
    {
      v11 = *(__CFArray **)(a1 + 160);
      goto LABEL_14;
    }
LABEL_13:
    v11 = *(__CFArray **)(a1 + 152);
LABEL_14:
    CFArrayAppendValue(v11, (const void *)a2);
  }
LABEL_15:
  v8 = 0;
LABEL_35:
  _Block_object_dispose(&v23, 8);
  return v8;
}

BOOL sub_100011AB0(void *a1, const char *a2, __CFArray **a3, __CFString **a4)
{
  xpc_object_t value;
  void *v7;
  size_t count;
  size_t v9;
  __CFArray *Mutable;
  size_t v11;
  const UInt8 *data;
  CFDataRef v13;
  CFDataRef v14;
  size_t length;

  value = xpc_dictionary_get_value(a1, a2);
  if (value)
  {
    v7 = value;
    if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_array)
    {
      count = xpc_array_get_count(v7);
      v9 = count;
      if (count >= 0x7FFFFFFFFFFFFFFFLL)
      {
        sub_100012C88(-108, a4, CFSTR("failed to create CFArray of capacity %zu"), count);
      }
      else
      {
        Mutable = CFArrayCreateMutable(kCFAllocatorDefault, count, &kCFTypeArrayCallBacks);
        if (!Mutable)
        {
          sub_100012C88(-108, a4, CFSTR("failed to create CFArray of capacity %zu"), v9);
          goto LABEL_17;
        }
        if (!v9)
        {
LABEL_17:
          *a3 = Mutable;
          return Mutable != 0;
        }
        v11 = 0;
        while (1)
        {
          length = 0;
          data = (const UInt8 *)xpc_array_get_data(v7, v11, &length);
          if (!data)
            break;
          if (length > 0x7FFFFFFFFFFFFFFELL)
            break;
          v13 = CFDataCreate(kCFAllocatorDefault, data, length);
          if (!v13)
            break;
          v14 = v13;
          CFArraySetValueAtIndex(Mutable, v11, v13);
          CFRelease(v14);
          if (v9 == ++v11)
            goto LABEL_17;
        }
        sub_100012C88(-50, a4, CFSTR("data_array[%zu] failed to decode"), v11);
        CFRelease(Mutable);
      }
    }
    else
    {
      sub_100012C88(-50, a4, CFSTR("data_array xpc value is not an array"));
    }
    Mutable = 0;
    goto LABEL_17;
  }
  if (a3)
    *a3 = 0;
  return 1;
}

BOOL sub_100011C4C(void *a1, const char *a2, _QWORD *a3, __CFString **a4)
{
  CFTypeRef v8;
  const void *v9;
  CFTypeID v10;
  CFStringRef v11;
  _BOOL8 result;

  if (xpc_dictionary_get_value(a1, a2))
  {
    v8 = sub_100059B20(a1, a2, a4);
    v9 = v8;
    if (v8)
    {
      v10 = CFGetTypeID(v8);
      if (v10 != CFArrayGetTypeID())
      {
        v11 = CFCopyTypeIDDescription(v10);
        sub_100012C88(-50, a4, CFSTR("object for key %s not array but %@"), a2, v11);
        if (v11)
          CFRelease(v11);
        CFRelease(v9);
        v9 = 0;
      }
    }
    result = v9 != 0;
  }
  else
  {
    v9 = 0;
    result = 1;
  }
  *a3 = v9;
  return result;
}

BOOL sub_100011D18(__SecTask *a1, const __CFString *a2)
{
  CFTypeRef v2;
  const void *v3;
  CFTypeID TypeID;
  _BOOL8 v5;

  v2 = SecTaskCopyValueForEntitlement(a1, a2, 0);
  if (!v2)
    return 0;
  v3 = v2;
  TypeID = CFBooleanGetTypeID();
  v5 = TypeID == CFGetTypeID(v3) && CFBooleanGetValue((CFBooleanRef)v3) != 0;
  CFRelease(v3);
  return v5;
}

const void *sub_100011D84(__SecTask *a1)
{
  const void *result;

  result = sub_100011DC8(a1, CFSTR("application-identifier"));
  if (!result)
    return sub_100011DC8(a1, CFSTR("com.apple.application-identifier"));
  return result;
}

const void *sub_100011DC8(__SecTask *a1, const __CFString *a2)
{
  CFTypeRef v2;
  const void *v3;
  CFTypeID v4;

  v2 = SecTaskCopyValueForEntitlement(a1, a2, 0);
  v3 = v2;
  if (v2)
  {
    v4 = CFGetTypeID(v2);
    if (v4 != CFStringGetTypeID())
    {
      CFRelease(v3);
      return 0;
    }
  }
  return v3;
}

CFMutableArrayRef sub_100011E18(uint64_t a1)
{
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v3;
  _QWORD v5[5];

  Mutable = CFArrayCreateMutable(0, *(_QWORD *)(a1 + 16), &kCFTypeArrayCallBacks);
  v3 = Mutable;
  if (Mutable)
  {
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 0x40000000;
    v5[2] = sub_100014108;
    v5[3] = &unk_100076DC0;
    v5[4] = Mutable;
    sub_10001409C(a1, (uint64_t)v5);
  }
  return v3;
}

__CFArray *sub_100011E98()
{
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v1;
  CFMutableDictionaryRef v2;
  __CFDictionary *v3;
  CFMutableDictionaryRef v4;
  __CFDictionary *v5;
  CFNumberRef v6;
  CFNumberRef v7;
  __CFArray *v8;
  __CFArray *v9;
  int valuePtr;

  Mutable = CFDictionaryCreateMutable(0, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  v2 = CFDictionaryCreateMutable(0, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v2)
  {
    CFRelease(v1);
    return 0;
  }
  v3 = v2;
  v4 = CFDictionaryCreateMutable(0, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v4)
  {
    v5 = v4;
    valuePtr = 1;
    v6 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    if (v6)
    {
      v7 = v6;
      CFDictionaryAddValue(v5, CFSTR("kSecTrustSettingsResult"), v6);
      CFDictionaryAddValue(v1, kSecPolicyCheckSystemTrustedWeakHash, kCFBooleanTrue);
      CFDictionaryAddValue(v1, kSecPolicyCheckSystemTrustedWeakKey, kCFBooleanTrue);
      CFDictionaryAddValue(v3, CFSTR("kSecTrustSettingsPolicyOptions"), v1);
      v8 = CFArrayCreateMutable(0, 2, &kCFTypeArrayCallBacks);
      v9 = v8;
      if (v8)
      {
        CFArrayAppendValue(v8, v3);
        CFArrayAppendValue(v9, v5);
      }
      CFRelease(v1);
    }
    else
    {
      v9 = 0;
      v7 = v1;
    }
    CFRelease(v7);
    CFRelease(v5);
  }
  else
  {
    CFRelease(v1);
    v9 = 0;
  }
  CFRelease(v3);
  return v9;
}

uint64_t sub_10001203C(uint64_t a1)
{
  _BOOL8 v3;

  if (*(_BYTE *)(a1 + 176))
  {
    sub_100012DF0(a1);
    return 1;
  }
  else
  {
    *(_QWORD *)(a1 + 248) = sub_10000D0EC;
    v3 = sub_1000145B0(a1);
    sub_10000D610(a1, (uint64_t)&stru_1000797E8);
    return v3;
  }
}

uint64_t sub_10001209C(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  const __CFArray *v4;
  CFIndex i;
  CFDictionaryRef *ValueAtIndex;
  const void *Name;
  const __CFString *Value;
  const __CFString *v9;
  __CFDictionary *Mutable;
  void *v11;
  __CFDictionary *v12;
  void *v13;
  void *v14;
  id v15;
  void *v16;
  const __CFArray *MutableCopy;
  const __CFNumber *v18;
  NSObject *v19;
  const __CFArray *v20;
  const __CFArray *v21;
  __CFDictionary *v22;
  CFIndex v23;
  const __CFArray *v24;
  NSObject *v25;
  CFIndex v26;
  CFIndex v27;
  CFIndex Count;
  CFIndex v29;
  const void *v30;
  CFTypeID v31;
  const __CFDictionary *v32;
  CFDictionaryRef *SSL;
  CFDictionaryRef *v34;
  const __CFDictionary *v35;
  CFDictionaryRef v36;
  __CFArray *v37;
  const void *v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  const void *v42;
  const void *v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t v46;
  _BOOL4 v47;
  uint64_t (*v48)(void);
  const __CFArray *v49;
  void *v51;
  uint64_t v52;
  uint64_t v53;
  void *key;
  const void *v55;
  _QWORD v56[5];
  unint64_t valuePtr;
  _BYTE context[24];
  const __CFString *v59;
  _QWORD v60[2];
  __int128 buf;
  uint64_t v62;
  CFMutableDictionaryRef v63;
  CFRange v64;
  CFRange v65;

  v52 = *(_QWORD *)(a1 + 192);
  if (v52 >= 1)
  {
    v2 = 0;
    key = (void *)kSecPolicyCheckSSLHostname;
    v51 = (void *)kSecPolicyCheckCAspkiSHA256;
    do
    {
      v53 = v2;
      v3 = *(_QWORD *)(*(_QWORD *)(a1 + 184) + 8 * v2);
      v4 = *(const __CFArray **)(v3 + 8);
      if (v4)
        CFRetain(*(CFTypeRef *)(v3 + 8));
      for (i = 0; i < CFArrayGetCount(v4); ++i)
      {
        ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(v4, i);
        Name = (const void *)SecPolicyGetName();
        Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex[4], key);
        if (Value)
        {
          v9 = Value;
          Mutable = CFDictionaryCreateMutable(0, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          CFDictionaryAddValue(Mutable, CFSTR("PinningPolicyName"), Name);
          CFDictionaryAddValue(Mutable, CFSTR("PinningHostname"), v9);
          v11 = objc_autoreleasePoolPush();
          if (qword_100082DD0 != -1)
            dispatch_once(&qword_100082DD0, &stru_100077C70);
          v12 = Mutable;
          v13 = (void *)objc_claimAutoreleasedReturnValue(-[__CFDictionary objectForKey:](v12, "objectForKey:", CFSTR("PinningPolicyName")));
          v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)qword_100082DC8, "queryForPolicyName:", v13));
          if (v14)
          {
            v15 = v14;
          }
          else
          {
            v16 = (void *)objc_claimAutoreleasedReturnValue(-[__CFDictionary objectForKey:](v12, "objectForKey:", CFSTR("PinningHostname")));
            v15 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend((id)qword_100082DC8, "queryForDomain:", v16));

          }
          objc_autoreleasePoolPop(v11);
          if (v12)
            CFRelease(v12);
          if (v15)
          {
            MutableCopy = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v15, CFSTR("PinningRules"));
            v55 = CFDictionaryGetValue((CFDictionaryRef)v15, CFSTR("PinningPolicyName"));
            v18 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v15, CFSTR("PinningTransparentConnection"));
            v19 = sub_100011628("SecPinningDb");
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
            {
              Count = CFArrayGetCount(MutableCopy);
              *(_DWORD *)context = 134218755;
              *(_QWORD *)&context[4] = Count;
              *(_WORD *)&context[12] = 2112;
              *(_QWORD *)&context[14] = v55;
              *(_WORD *)&context[22] = 2113;
              v59 = v9;
              LOWORD(v60[0]) = 2114;
              *(_QWORD *)((char *)v60 + 2) = Name;
              _os_log_debug_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "found pinning %lu %@ policies for hostname %{private}@, policyName %{public}@", context, 0x2Au);
            }
            LODWORD(valuePtr) = 0;
            if (v18)
            {
              if (CFNumberGetValue(v18, kCFNumberIntType, &valuePtr))
              {
                if ((_DWORD)valuePtr == 1)
                {
                  v20 = (const __CFArray *)sub_1000405C0(0, 0);
                  if (v20)
                  {
                    v21 = v20;
                    if (CFArrayGetCount(v20))
                    {
                      v22 = CFDictionaryCreateMutable(0, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                      v23 = CFArrayGetCount(v21);
                      v24 = CFArrayCreateMutable(0, v23, &kCFTypeArrayCallBacks);
                      *(_QWORD *)context = _NSConcreteStackBlock;
                      *(_QWORD *)&context[8] = 0x40000000;
                      *(_QWORD *)&context[16] = sub_100055048;
                      v59 = (const __CFString *)&unk_100079758;
                      v60[0] = v24;
                      v64.length = CFArrayGetCount(v21);
                      v64.location = 0;
                      CFArrayApplyFunction(v21, v64, (CFArrayApplierFunction)sub_100055100, context);
                      if (CFArrayGetCount(v24))
                      {
                        v25 = sub_100011628("SecPinningDb");
                        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
                        {
                          v26 = CFArrayGetCount(v24);
                          LODWORD(buf) = 134217984;
                          *(_QWORD *)((char *)&buf + 4) = v26;
                          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Adding %lu CA pins for Transparent Connection", (uint8_t *)&buf, 0xCu);
                        }
                        CFDictionaryAddValue(v22, v51, v24);
                        if (v24)
                          CFRelease(v24);
                        v27 = CFArrayGetCount(MutableCopy);
                        MutableCopy = CFArrayCreateMutableCopy(0, v27 + 1, MutableCopy);
                        CFArrayAppendValue(MutableCopy, v22);
                        if (v22)
                          CFRelease(v22);
                        CFRelease(v21);
                        goto LABEL_38;
                      }
                      if (v24)
                        CFRelease(v24);
                      if (v22)
                        CFRelease(v22);
                    }
                    CFRelease(v21);
                  }
                }
              }
            }
            if (MutableCopy)
              CFRetain(MutableCopy);
LABEL_38:
            v29 = 0;
LABEL_39:
            if (v29 >= CFArrayGetCount(MutableCopy))
            {
              CFRelease(v15);
              if (MutableCopy)
                CFRelease(MutableCopy);
              continue;
            }
            v30 = CFArrayGetValueAtIndex(MutableCopy, v29);
            if (v30)
            {
              v31 = CFGetTypeID(v30);
              if (v31 == CFDictionaryGetTypeID())
              {
                v32 = (const __CFDictionary *)CFArrayGetValueAtIndex(MutableCopy, v29);
                valuePtr = 0xAAAAAAAAAAAAAAAALL;
                SSL = (CFDictionaryRef *)SecPolicyCreateSSL(1u, v9);
                valuePtr = (unint64_t)SSL;
                if (SSL)
                {
                  v34 = SSL;
                  *(_QWORD *)&buf = 0;
                  *((_QWORD *)&buf + 1) = &buf;
                  v62 = 0x2000000000;
                  v63 = (CFMutableDictionaryRef)0xAAAAAAAAAAAAAAAALL;
                  v63 = CFDictionaryCreateMutableCopy(0, 0, SSL[4]);
                  *(_QWORD *)context = _NSConcreteStackBlock;
                  *(_QWORD *)&context[8] = 0x40000000;
                  *(_QWORD *)&context[16] = sub_100006D60;
                  v59 = (const __CFString *)&unk_100079780;
                  v60[0] = &buf;
                  CFDictionaryApplyFunction(v32, (CFDictionaryApplierFunction)sub_100055114, context);
                  v35 = *(const __CFDictionary **)(*((_QWORD *)&buf + 1) + 24);
                  v36 = v34[4];
                  if (v36)
                    CFRelease(v36);
                  v34[4] = v35;
                  _Block_object_dispose(&buf, 8);
                  SecPolicySetName(valuePtr, v55);
                  v37 = CFArrayCreateMutableCopy(0, 0, v4);
                  if (v37)
                  {
                    v38 = v37;
                    v65.location = i;
                    v65.length = 1;
                    CFArrayReplaceValues(v37, v65, (const void **)&valuePtr, 1);
                    if (v29)
                    {
                      *(_QWORD *)(a1 + 184) = malloc_type_realloc(*(void **)(a1 + 184), 8 * *(_QWORD *)(a1 + 192) + 8, 0x2004093837F09uLL);
                      v39 = malloc_type_malloc(0x48uLL, 0x10600407F7167BDuLL);
                      v40 = *(_QWORD *)(a1 + 192);
                      *(_QWORD *)(*(_QWORD *)(a1 + 184) + 8 * v40) = v39;
                      sub_10000D050(*(_QWORD *)(*(_QWORD *)(a1 + 184) + 8 * v40), a1, v38);
                      ++*(_QWORD *)(a1 + 192);
                    }
                    else
                    {
                      v41 = *(_QWORD *)(*(_QWORD *)(a1 + 184) + 8 * v53);
                      if (*(const void **)(v41 + 8) != v38)
                      {
                        CFRetain(v38);
                        v42 = *(const void **)(v41 + 8);
                        if (v42)
                          CFRelease(v42);
                        *(_QWORD *)(v41 + 8) = v38;
                      }
                    }
                    v43 = (const void *)valuePtr;
                    if (valuePtr)
                    {
                      valuePtr = 0;
                      CFRelease(v43);
                    }
LABEL_56:
                    CFRelease(v38);
                  }
                  else
                  {
                    v38 = (const void *)valuePtr;
                    if (valuePtr)
                    {
                      valuePtr = 0;
                      goto LABEL_56;
                    }
                  }
                }
              }
            }
            ++v29;
            goto LABEL_39;
          }
        }
      }
      if (v4)
        CFRelease(v4);
      v2 = v53 + 1;
    }
    while (v53 + 1 != v52);
  }
  v44 = *(uint64_t **)(a1 + 200);
  if (v44 && v44[2] >= 1 && (v45 = v44[17]) != 0)
    v46 = *(_QWORD *)(v45 + 16);
  else
    v46 = 0;
  *(_QWORD *)&buf = 0;
  v47 = sub_100002A7C(a1, v46, &buf);
  if (!(_QWORD)buf || (v48 = *(uint64_t (**)(void))(buf + 8)) == 0)
  {
    sub_100012894((uint64_t)v44, 0);
    if (!v47)
      goto LABEL_75;
    goto LABEL_74;
  }
  v49 = (const __CFArray *)v48();
  sub_100012894((uint64_t)v44, v49);
  if (v49)
    CFRelease(v49);
  if (v47)
  {
LABEL_74:
    sub_100012918((uint64_t)v44);
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 160), v44);
  }
LABEL_75:
  *(_QWORD *)context = 0;
  *(_QWORD *)&context[8] = context;
  *(_QWORD *)&context[16] = 0x2000000000;
  LOBYTE(v59) = 1;
  v56[0] = _NSConcreteStackBlock;
  v56[1] = 0x40000000;
  v56[2] = sub_10000DA50;
  v56[3] = &unk_100079738;
  v56[4] = context;
  sub_10000D610(a1, (uint64_t)v56);
  *(_BYTE *)(a1 + 176) = *(_BYTE *)(*(_QWORD *)&context[8] + 24);
  *(_QWORD *)(a1 + 248) = sub_10000FFB8;
  _Block_object_dispose(context, 8);
  return 1;
}

void sub_100012894(uint64_t a1, const __CFArray *cf)
{
  CFArrayRef v3;
  CFArrayRef v4;
  uint64_t v5;

  if (cf)
  {
    v3 = cf;
    v4 = 0;
  }
  else
  {
    v4 = CFArrayCreate(kCFAllocatorDefault, 0, 0, &kCFTypeArrayCallBacks);
    v3 = v4;
    if (!v4)
      return;
  }
  v5 = *(_QWORD *)(a1 + 136);
  CFRetain(v3);
  *(_QWORD *)(v5 + 24) = v3;
  if (v4)
    CFRelease(v4);
}

uint64_t sub_100012918(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  char v5;

  *(_BYTE *)(result + 49) = 1;
  if (!*(_BYTE *)(result + 48))
  {
    v1 = result;
    v2 = *(_QWORD *)(result + 16);
    if (v2 >= 1)
    {
      v3 = *(_QWORD *)(result + 8 * v2 + 128);
      v5 = 0;
      result = SecCertificateIsSelfSigned(*(_QWORD *)(v3 + 16), &v5);
      if ((_DWORD)result)
        v4 = 1;
      else
        v4 = v5 == 0;
      if (!v4)
      {
        *(_BYTE *)(v1 + 48) = 1;
        if (*(_QWORD *)(v1 + 40) == -1)
          *(_QWORD *)(v1 + 40) = *(_QWORD *)(v1 + 16) - 1;
      }
    }
  }
  return result;
}

void sub_1000129A4(id a1, void *a2)
{
  NSObject *v3;
  _QWORD handler[5];

  if (xpc_get_type(a2) == (xpc_type_t)&_xpc_type_connection)
  {
    v3 = sub_100012A34();
    xpc_connection_set_target_queue((xpc_connection_t)a2, v3);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 0x40000000;
    handler[2] = sub_1000108E0;
    handler[3] = &unk_100075AB0;
    handler[4] = a2;
    xpc_connection_set_event_handler((xpc_connection_t)a2, handler);
    xpc_connection_activate((xpc_connection_t)a2);
  }
}

id sub_100012A34()
{
  if (qword_100082BA8 != -1)
    dispatch_once(&qword_100082BA8, &stru_100076480);
  return (id)qword_100082BA0;
}

BOOL sub_100012A74(void *a1, const char *a2, _QWORD *a3, __CFString **a4)
{
  void *data;
  const UInt8 *v9;
  _BOOL8 v10;
  size_t length;
  size_t v13;

  length = 0;
  data = (void *)xpc_dictionary_get_data(a1, a2, &length);
  if (data)
  {
    v13 = 0;
    v9 = (const UInt8 *)xpc_dictionary_get_data(a1, a2, &v13);
    if (v9)
    {
      if ((v13 & 0x8000000000000000) != 0)
      {
        sub_100012C88(-50, a4, CFSTR("too large data for key %s"), a2);
      }
      else
      {
        data = CFDataCreate(kCFAllocatorDefault, v9, v13);
        if (data)
        {
LABEL_10:
          v10 = data != 0;
          goto LABEL_11;
        }
        sub_100012C88(-50, a4, CFSTR("failed to create data for key %s"), a2);
      }
    }
    else
    {
      sub_100012C88(-50, a4, CFSTR("no data for key %s"), a2);
    }
    data = 0;
    goto LABEL_10;
  }
  v10 = 1;
LABEL_11:
  *a3 = data;
  return v10;
}

BOOL sub_100012B40(int a1, xpc_object_t xdict, void *a3, __CFString **a4)
{
  xpc_object_t dictionary;
  __CFString *v8;
  __CFString *v9;
  BOOL v10;
  _BOOL8 result;
  _BOOL8 v12;

  dictionary = xpc_dictionary_get_dictionary(xdict, "eventAttributes");
  v8 = (__CFString *)sub_100012BFC(xdict, "eventName", a4);
  v9 = v8;
  if (dictionary)
    v10 = v8 == 0;
  else
    v10 = 1;
  if (v10)
  {
    xpc_dictionary_set_BOOL(a3, "status", 0);
    v12 = 0;
    result = 0;
    if (!v9)
      return result;
  }
  else
  {
    v12 = sub_100013464(v8, dictionary, a4);
    xpc_dictionary_set_BOOL(a3, "status", v12);
  }
  CFRelease(v9);
  return v12;
}

CFStringRef sub_100012BFC(void *a1, const char *a2, __CFString **a3)
{
  const char *string;
  const char *v6;
  CFStringRef result;

  string = xpc_dictionary_get_string(a1, a2);
  if (string)
  {
    v6 = string;
    result = CFStringCreateWithCString(kCFAllocatorDefault, string, 0x8000100u);
    if (result)
      return result;
    sub_100012C88(-108, a3, CFSTR("object for key %s failed to convert %s to CFString"), a2, v6);
  }
  else
  {
    sub_100012C88(-50, a3, CFSTR("object for key %s not string"), a2);
  }
  return 0;
}

void sub_100012C88(int a1, __CFString **a2, CFStringRef format, ...)
{
  CFTypeRef v4;
  CFTypeRef cf;
  va_list va;

  va_start(va, format);
  cf = 0;
  if (a2)
  {
    sub_10002A34C(a1, kCFErrorDomainOSStatus, *a2, &cf, format, va);
    *a2 = (__CFString *)cf;
  }
  else
  {
    sub_10002A34C(a1, kCFErrorDomainOSStatus, 0, &cf, format, va);
    v4 = cf;
    if (cf)
    {
      cf = 0;
      CFRelease(v4);
    }
  }
}

uint64_t sub_100012D08(uint64_t a1, uint64_t a2, void *a3, CFTypeRef *a4)
{
  uint64_t v6;

  v6 = sub_10001D4EC(a4);
  if (a4 && *a4)
    return 0;
  xpc_dictionary_set_uint64(a3, "status", v6);
  return 1;
}

BOOL sub_100012D5C(unsigned int a1, __SecTask *a2, const __CFString *a3, __CFString **a4)
{
  _BOOL8 v8;
  const __CFString *v9;

  v8 = sub_100011D18(a2, a3);
  if (!v8)
  {
    if (a1 > 0x87)
      v9 = CFSTR("Unknown xpc operation");
    else
      v9 = *(&off_100079D38 + a1);
    sub_100012C88(-34018, a4, CFSTR("%@: %@ lacks entitlement %@"), v9, a2, a3);
  }
  return v8;
}

void sub_100012DF0(uint64_t a1)
{
  uint64_t v2;
  _BOOL4 v3;
  uint64_t v4;
  _BOOL4 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  _BOOL4 v14;
  const char *v15;
  const char *v16;
  uint64_t v17;
  const char *v18;
  const char *v19;
  const char *v20;
  const char *v21;
  NSObject *v22;
  uint32_t v23;
  const char *v24;
  uint64_t v25;
  int v26;
  const char *v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  uint64_t v37;

  *(_QWORD *)(a1 + 248) = sub_10000FFB8;
  v2 = *(_QWORD *)(a1 + 224);
  if (v2)
    v3 = *(_BYTE *)(v2 + 65) != 0;
  else
    v3 = 0;
  v4 = *(_QWORD *)(a1 + 200);
  if (v4)
  {
    v5 = *(_BYTE *)(v4 + 65) != 0;
    if (*(_BYTE *)(v4 + 65))
      goto LABEL_9;
  }
  else
  {
    v5 = 0;
  }
  if (v3)
    return;
LABEL_9:
  if (v2)
    v6 = *(_QWORD *)(v2 + 96);
  else
    v6 = 0;
  v7 = sub_10000DD38(v4, *(double *)(a1 + 120));
  v8 = v7;
  v9 = *(_QWORD *)(a1 + 200);
  if (*(_QWORD *)(v9 + 96) < v7)
    *(_QWORD *)(v9 + 96) = v7;
  if (v3)
    v10 = v6;
  else
    v10 = 0;
  if (v5)
    v11 = v10;
  else
    v11 = v6;
  v12 = *(_QWORD *)(a1 + 224);
  v13 = sub_100011628("reject");
  v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG);
  if (!v12 || v8 > v11)
  {
    if (v12)
    {
      if (v14)
      {
        v17 = *(_QWORD *)(a1 + 200);
        v18 = "non ";
        v26 = 136316419;
        if (v3)
          v19 = "";
        else
          v19 = "non ";
        v27 = v19;
        v28 = 2080;
        v20 = "accept";
        if (v11 <= 10000000)
          v20 = "reject";
        v29 = v20;
        v30 = 2048;
        v31 = v11;
        if (v5)
          v18 = "";
        v32 = 2080;
        v33 = v18;
        v34 = 2048;
        v35 = v8;
        v36 = 2113;
        v37 = v17;
        v21 = "replacing %sev %s score: %ld with %sev score: %ld %{private}@";
        v22 = v13;
        v23 = 62;
LABEL_42:
        _os_log_debug_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEBUG, v21, (uint8_t *)&v26, v23);
      }
    }
    else if (v14)
    {
      v24 = "non ";
      v25 = *(_QWORD *)(a1 + 200);
      v26 = 136315651;
      if (v5)
        v24 = "";
      v27 = v24;
      v28 = 2048;
      v29 = (const char *)v8;
      v30 = 2113;
      v31 = v25;
      v21 = "%sev score: %ld %{private}@";
      v22 = v13;
      v23 = 32;
      goto LABEL_42;
    }
    *(_QWORD *)(a1 + 224) = *(_QWORD *)(a1 + 200);
    return;
  }
  if (v14)
  {
    v15 = "non ";
    v16 = *(const char **)(a1 + 200);
    v26 = 136315907;
    if (v5)
      v15 = "";
    v27 = v15;
    v28 = 2048;
    v29 = (const char *)v8;
    v30 = 2048;
    v31 = v11;
    v32 = 2113;
    v33 = v16;
    _os_log_debug_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "%sev score: %ld lower than %ld %{private}@", (uint8_t *)&v26, 0x2Au);
  }
}

_QWORD *sub_1000130B4(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (qword_100082BF0)
  {
    v1 = result;
    v2 = *(_QWORD *)(qword_100082BF0 + 176);
    if (v2)
      result = CFRetain(*(CFTypeRef *)(qword_100082BF0 + 176));
    *(_QWORD *)(*(_QWORD *)(v1[4] + 8) + 24) = v2;
  }
  return result;
}

void sub_1000130F8(uint64_t a1)
{
  NSObject *v2;
  CFTypeRef *v3;
  CFTypeRef *v4;
  _QWORD *v5;
  const void *v6;
  CFTypeRef *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  void *v22;
  uint64_t v23;
  uint64_t i;
  _QWORD *v25;
  const void *v26;
  const void *v27;
  const void *v28;

  v2 = *(NSObject **)(a1 + 16);
  if (v2)
  {
    *(_QWORD *)(a1 + 16) = 0;
    dispatch_release(v2);
  }
  v3 = *(CFTypeRef **)(a1 + 56);
  if (v3)
  {
    sub_1000132E4(v3);
    *(_QWORD *)(a1 + 56) = 0;
  }
  v4 = *(CFTypeRef **)(a1 + 40);
  if (v4)
  {
    sub_1000132E4(v4);
    *(_QWORD *)(a1 + 40) = 0;
  }
  v5 = *(_QWORD **)(a1 + 48);
  if (v5)
  {
    v6 = (const void *)v5[3];
    if (v6)
      CFRelease(v6);
    free(v5);
    *(_QWORD *)(a1 + 48) = 0;
  }
  v7 = *(CFTypeRef **)(a1 + 64);
  if (v7)
  {
    sub_1000132E4(v7);
    *(_QWORD *)(a1 + 64) = 0;
  }
  v8 = *(const void **)(a1 + 32);
  if (v8)
  {
    *(_QWORD *)(a1 + 32) = 0;
    CFRelease(v8);
  }
  v9 = *(const void **)(a1 + 72);
  if (v9)
  {
    *(_QWORD *)(a1 + 72) = 0;
    CFRelease(v9);
  }
  v10 = *(const void **)(a1 + 88);
  if (v10)
  {
    *(_QWORD *)(a1 + 88) = 0;
    CFRelease(v10);
  }
  v11 = *(const void **)(a1 + 136);
  if (v11)
  {
    *(_QWORD *)(a1 + 136) = 0;
    CFRelease(v11);
  }
  v12 = *(const void **)(a1 + 144);
  if (v12)
  {
    *(_QWORD *)(a1 + 144) = 0;
    CFRelease(v12);
  }
  v13 = *(const void **)(a1 + 152);
  if (v13)
  {
    *(_QWORD *)(a1 + 152) = 0;
    CFRelease(v13);
  }
  v14 = *(const void **)(a1 + 160);
  if (v14)
  {
    *(_QWORD *)(a1 + 160) = 0;
    CFRelease(v14);
  }
  v15 = *(const void **)(a1 + 96);
  if (v15)
  {
    *(_QWORD *)(a1 + 96) = 0;
    CFRelease(v15);
  }
  v16 = *(const void **)(a1 + 104);
  if (v16)
  {
    *(_QWORD *)(a1 + 104) = 0;
    CFRelease(v16);
  }
  v17 = *(const void **)(a1 + 112);
  if (v17)
  {
    *(_QWORD *)(a1 + 112) = 0;
    CFRelease(v17);
  }
  v18 = *(const void **)(a1 + 200);
  if (v18)
  {
    *(_QWORD *)(a1 + 200) = 0;
    CFRelease(v18);
  }
  v19 = *(const void **)(a1 + 216);
  if (v19)
  {
    *(_QWORD *)(a1 + 216) = 0;
    CFRelease(v19);
  }
  v20 = *(const void **)(a1 + 232);
  if (v20)
  {
    *(_QWORD *)(a1 + 232) = 0;
    CFRelease(v20);
  }
  v21 = *(const void **)(a1 + 128);
  if (v21)
  {
    *(_QWORD *)(a1 + 128) = 0;
    CFRelease(v21);
  }
  free(*(void **)(a1 + 272));
  *(_QWORD *)(a1 + 272) = 0;
  v22 = *(void **)(a1 + 184);
  if (v22)
  {
    v23 = *(_QWORD *)(a1 + 192);
    if (v23 >= 1)
    {
      for (i = 0; i < v23; ++i)
      {
        v25 = *(_QWORD **)(*(_QWORD *)(a1 + 184) + 8 * i);
        if (v25)
        {
          v26 = (const void *)v25[1];
          if (v26)
          {
            v25[1] = 0;
            CFRelease(v26);
          }
          v27 = (const void *)v25[7];
          if (v27)
          {
            v25[7] = 0;
            CFRelease(v27);
          }
          v28 = (const void *)v25[5];
          if (v28)
          {
            v25[5] = 0;
            CFRelease(v28);
          }
          free(*(void **)(*(_QWORD *)(a1 + 184) + 8 * i));
          v23 = *(_QWORD *)(a1 + 192);
        }
      }
      v22 = *(void **)(a1 + 184);
    }
    free(v22);
    *(_QWORD *)(a1 + 184) = 0;
  }
}

void sub_1000132E4(CFTypeRef *a1)
{
  CFRelease(a1[3]);
  CFRelease(a1[4]);
  free(a1);
}

BOOL sub_100013314(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;
  void *v6;
  id v7;
  void *v8;
  uint64_t v9;
  void *v10;

  v5 = a3;
  v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithCString:encoding:](NSString, "stringWithCString:encoding:", a2, 4));
  v7 = sub_100016F80(v5, *(__CFString ***)(a1 + 40));
  v8 = (void *)objc_claimAutoreleasedReturnValue(v7);

  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v10 = *(void **)(v9 + 40);
  if (v8)
  {
    objc_msgSend(v10, "setObject:forKeyedSubscript:", v8, v6);
  }
  else
  {
    *(_QWORD *)(v9 + 40) = 0;

  }
  return v8 != 0;
}

uint64_t sub_1000133B8(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char v6;
  uint64_t result;

  v2 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v2 && (v3 = *(_QWORD *)(v2 + 16), v3 >= 1) && (v4 = *(_QWORD *)(v2 + 8 * v3 + 128)) != 0)
    v5 = *(_QWORD *)(v4 + 16);
  else
    v5 = 0;
  if ((SecIsInternalRelease(a1) & 1) != 0)
  {
    v6 = 1;
  }
  else if (sub_100035BA4())
  {
    v6 = 3;
  }
  else
  {
    v6 = 1;
  }
  result = sub_100016B34(v5, v6);
  if ((result & 1) == 0)
    return sub_10000E2C8(a1, kSecPolicyCheckAnchorApple, 0, kCFBooleanFalse, 0, 0);
  return result;
}

BOOL sub_100013464(void *a1, void *a2, __CFString **a3)
{
  id v5;
  void *v6;
  _BOOL8 v7;
  id v8;
  uint64_t v9;
  void *v10;
  id v11;
  void *v12;
  void *v13;
  void *v14;
  _QWORD v16[4];
  id v17;
  uint64_t *v18;
  __CFString **v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  char v23;

  v5 = a2;
  if ((sub_100015138() & 1) != 0)
  {
    v6 = objc_autoreleasePoolPush();
    if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
    {
      v20 = 0;
      v21 = &v20;
      v22 = 0x2020000000;
      v23 = 1;
      if (objc_msgSend(a1, "hasPrefix:", CFSTR("com.apple.network")))
      {
        v8 = (id)qword_100082E70;
        v9 = objc_claimAutoreleasedReturnValue(+[NetworkingAnalytics logger](NetworkingAnalytics, "logger"));
      }
      else
      {
        v8 = (id)qword_100082E68;
        v9 = objc_claimAutoreleasedReturnValue(+[TrustAnalytics logger](TrustAnalytics, "logger"));
      }
      v10 = (void *)v9;
      v11 = v8;
      objc_sync_enter(v11);
      v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "objectForKeyedSubscript:", a1));
      v13 = v12;
      if (v12)
      {
        v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", (char *)objc_msgSend(v12, "unsignedLongValue") + 1));
        objc_msgSend(v11, "setObject:forKeyedSubscript:", v14, a1);

      }
      else
      {
        objc_msgSend(v11, "setObject:forKeyedSubscript:", &off_10007FE48, a1);
      }

      objc_sync_exit(v11);
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 3221225472;
      v16[2] = sub_100017340;
      v16[3] = &unk_1000792D8;
      v17 = v5;
      v18 = &v20;
      v19 = a3;
      objc_msgSend(v10, "trustd_logDetailedEventforEventNamed:attributesCallback:timestampBucket:", a1, v16, 2);
      v7 = *((_BYTE *)v21 + 24) != 0;

      _Block_object_dispose(&v20, 8);
    }
    else
    {
      sub_100012C88(-50, a3, CFSTR("Networking Analytics attributes received were not a dictionary type"));
      v7 = 0;
    }
    objc_autoreleasePoolPop(v6);
  }
  else
  {
    sub_100012C88(-4, a3, CFSTR("Networking analytics not supported in this environment"));
    v7 = 0;
  }

  return v7;
}

void sub_100013694(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000136BC(uint64_t a1)
{
  CFMutableDictionaryRef Mutable;
  __CFArray *v3;
  CFAbsoluteTime Current;
  CFDateRef v5;
  uint64_t v6;
  CFMutableArrayRef v7;
  uint64_t v8;
  __CFArray *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  CFAbsoluteTime v14;
  CFDateRef v15;
  CFDateRef v16;
  CFAbsoluteTime v17;
  CFAbsoluteTime v18;
  __CFArray *v19;
  CFAbsoluteTime v20;
  CFDateRef v21;
  uint64_t v22;
  CFMutableArrayRef v23;
  uint64_t v24;
  __CFArray *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  CFAbsoluteTime v29;
  uint64_t v30;
  CFDateRef v31;
  CFDateRef v32;
  CFAbsoluteTime v33;
  CFAbsoluteTime v34;
  CFDateRef v35;
  CFDateRef v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  const void *v42;
  const void *v43;
  _QWORD *v44;
  double v45;
  CFDateRef v46;
  __CFDictionary *v47;
  const void *v48;
  const void **v49;
  const void *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  const void *v57;
  uint64_t v58;
  void *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  void *v64;
  void *v65;
  unsigned __int8 v66;
  void *v67;
  void *v68;
  void *v69;
  void **v71;
  uint64_t v72;
  void *v73;
  void *v74;
  uint64_t *v75;
  CFAbsoluteTime v76;
  uint64_t v77;
  double *v78;
  uint64_t v79;
  unint64_t v80;
  CFRange v81;
  CFRange v82;
  CFRange v83;
  CFRange v84;
  CFRange v85;
  CFRange v86;

  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  *(_QWORD *)(a1 + 232) = Mutable;
  if (!Mutable)
    goto LABEL_82;
  v3 = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  Current = CFAbsoluteTimeGetCurrent();
  v5 = CFDateCreate(0, Current + -4500.0);
  CFArrayAppendValue(v3, v5);
  v6 = *(_QWORD *)(a1 + 224);
  v7 = CFArrayCreateMutable(0, *(_QWORD *)(v6 + 16), &kCFTypeArrayCallBacks);
  v71 = _NSConcreteStackBlock;
  v72 = 0x40000000;
  v73 = sub_100014110;
  v74 = &unk_100076E08;
  v75 = (uint64_t *)v7;
  sub_10001409C(v6, (uint64_t)&v71);
  v83.length = CFArrayGetCount(v7);
  v83.location = 0;
  CFArrayAppendArray(v3, v7, v83);
  v8 = *(_QWORD *)(a1 + 224);
  v9 = CFArrayCreateMutable(0, *(_QWORD *)(v8 + 88), &kCFTypeArrayCallBacks);
  if (*(uint64_t *)(v8 + 88) >= 1)
  {
    v10 = 0;
    v11 = 16;
    do
    {
      v12 = *(_QWORD *)(v8 + 80);
      if (v12 && (v13 = *(_QWORD *)(v12 + v11)) != 0)
        v14 = *(double *)(v13 + 64);
      else
        v14 = -1.79769313e308;
      v15 = CFDateCreate(0, v14);
      if (v15)
      {
        v16 = v15;
        CFArrayAppendValue(v9, v15);
        CFRelease(v16);
      }
      ++v10;
      v11 += 40;
    }
    while (v10 < *(_QWORD *)(v8 + 88));
  }
  v84.length = CFArrayGetCount(v9);
  v84.location = 0;
  CFArrayAppendArray(v3, v9, v84);
  if (v9)
    CFRelease(v9);
  if (v5)
    CFRelease(v5);
  if (v7)
    CFRelease(v7);
  v77 = 0;
  v78 = (double *)&v77;
  v79 = 0x2000000000;
  v80 = 0xFFEFFFFFFFFFFFFFLL;
  v17 = CFAbsoluteTimeGetCurrent();
  v71 = _NSConcreteStackBlock;
  v72 = 0x40000000;
  v73 = sub_100006B70;
  v74 = &unk_1000798C8;
  v76 = v17;
  v75 = &v77;
  v81.length = CFArrayGetCount(v3);
  v81.location = 0;
  CFArrayApplyFunction(v3, v81, (CFArrayApplierFunction)sub_100055100, &v71);
  if (v3)
    CFRelease(v3);
  v18 = v78[3];
  _Block_object_dispose(&v77, 8);
  v19 = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  v20 = CFAbsoluteTimeGetCurrent();
  v21 = CFDateCreate(0, v20 + 4500.0);
  CFArrayAppendValue(v19, v21);
  v22 = *(_QWORD *)(a1 + 224);
  v23 = CFArrayCreateMutable(0, *(_QWORD *)(v22 + 16), &kCFTypeArrayCallBacks);
  v71 = _NSConcreteStackBlock;
  v72 = 0x40000000;
  v73 = sub_100014160;
  v74 = &unk_100076E28;
  v75 = (uint64_t *)v23;
  sub_10001409C(v22, (uint64_t)&v71);
  v85.length = CFArrayGetCount(v23);
  v85.location = 0;
  CFArrayAppendArray(v19, v23, v85);
  v24 = *(_QWORD *)(a1 + 224);
  v25 = CFArrayCreateMutable(0, *(_QWORD *)(v24 + 88), &kCFTypeArrayCallBacks);
  if (*(uint64_t *)(v24 + 88) >= 1)
  {
    v26 = 0;
    v27 = 16;
    do
    {
      v28 = *(_QWORD *)(v24 + 80);
      v29 = 0.0;
      if (v28)
      {
        v30 = *(_QWORD *)(v28 + v27);
        if (v30)
          v29 = *(double *)(v30 + 72);
      }
      v31 = CFDateCreate(0, v29);
      if (v31)
      {
        v32 = v31;
        CFArrayAppendValue(v25, v31);
        CFRelease(v32);
      }
      ++v26;
      v27 += 40;
    }
    while (v26 < *(_QWORD *)(v24 + 88));
  }
  v86.length = CFArrayGetCount(v25);
  v86.location = 0;
  CFArrayAppendArray(v19, v25, v86);
  if (v25)
    CFRelease(v25);
  if (v21)
    CFRelease(v21);
  if (v23)
    CFRelease(v23);
  v77 = 0;
  v78 = (double *)&v77;
  v79 = 0x2000000000;
  v80 = 0x7FEFFFFFFFFFFFFFLL;
  v33 = CFAbsoluteTimeGetCurrent();
  v71 = _NSConcreteStackBlock;
  v72 = 0x40000000;
  v73 = sub_100006BB8;
  v74 = &unk_1000798F0;
  v76 = v33;
  v75 = &v77;
  v82.length = CFArrayGetCount(v19);
  v82.location = 0;
  CFArrayApplyFunction(v19, v82, (CFArrayApplierFunction)sub_100055100, &v71);
  if (v19)
    CFRelease(v19);
  v34 = v78[3];
  _Block_object_dispose(&v77, 8);
  v35 = CFDateCreate(0, v18);
  v36 = CFDateCreate(0, v34);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 232), kSecTrustInfoResultNotBefore, v35);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 232), kSecTrustInfoResultNotAfter, v36);
  if (v35)
    CFRelease(v35);
  if (v36)
    CFRelease(v36);
  if (!*(_QWORD *)(a1 + 232))
    goto LABEL_82;
  v37 = *(_QWORD *)(a1 + 224);
  if (v37)
  {
    if (*(_BYTE *)(v37 + 65))
    {
      if (sub_10000D588(a1))
      {
        v38 = *(_QWORD **)(a1 + 224);
        if (v38[10])
        {
          if (sub_100016CDC(v38) != 0.0)
          {
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 232), kSecTrustInfoExtendedValidationKey, kCFBooleanTrue);
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 232), kSecTrustExtendedValidation, kCFBooleanTrue);
            v39 = *(_QWORD *)(a1 + 200);
            if (v39 && *(uint64_t *)(v39 + 16) >= 1 && (v40 = *(_QWORD *)(v39 + 136)) != 0)
              v41 = *(_QWORD *)(v40 + 16);
            else
              v41 = 0;
            v42 = (const void *)SecCertificateCopyCompanyName(v41);
            if (v42)
            {
              v43 = v42;
              CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 232), kSecTrustInfoCompanyNameKey, v42);
              CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 232), kSecTrustOrganizationName, v43);
              CFRelease(v43);
            }
          }
        }
      }
    }
    if (!*(_QWORD *)(a1 + 232))
      goto LABEL_82;
  }
  if (sub_10000D588(a1))
  {
    v44 = *(_QWORD **)(a1 + 224);
    if (v44[10])
    {
      v45 = sub_100016CDC(v44);
      if (v45 != 0.0)
      {
        v46 = CFDateCreate(kCFAllocatorDefault, v45);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 232), kSecTrustInfoRevocationValidUntilKey, v46);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 232), kSecTrustRevocationValidUntilDate, v46);
        CFRelease(v46);
        goto LABEL_57;
      }
      v55 = *(_QWORD *)(a1 + 224);
      if (v55 && *(_BYTE *)(v55 + 65))
      {
        v47 = *(__CFDictionary **)(a1 + 232);
        v48 = (const void *)kSecTrustInfoRevocationKey;
        v49 = (const void **)&kCFBooleanFalse;
        goto LABEL_58;
      }
      if (sub_100016DE4((uint64_t *)v55))
      {
LABEL_57:
        v47 = *(__CFDictionary **)(a1 + 232);
        v48 = (const void *)kSecTrustInfoRevocationKey;
        v49 = (const void **)&kCFBooleanTrue;
LABEL_58:
        v50 = *v49;
        CFDictionarySetValue(v47, v48, *v49);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 232), kSecTrustRevocationChecked, v50);
      }
    }
  }
  if (*(_QWORD *)(a1 + 232))
  {
    if ((sub_10000D588(a1) & 1) == 0)
    {
      v51 = *(_QWORD *)(a1 + 224);
      if (*(_QWORD *)(v51 + 80))
      {
        v52 = *(_QWORD *)(v51 + 16);
        if (v52 >= 1)
        {
          v53 = v51 + 136;
          v54 = *(_QWORD *)(v51 + 16);
          while (!*(_QWORD *)(*(_QWORD *)v53 + 32))
          {
            v53 += 8;
            if (!--v54)
              goto LABEL_77;
          }
          v56 = v51 + 136;
          while (1)
          {
            v57 = *(const void **)(*(_QWORD *)v56 + 32);
            if (v57)
              break;
            v56 += 8;
            if (!--v52)
            {
              v57 = 0;
              break;
            }
          }
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 232), kSecTrustRevocationReason, v57);
        }
      }
    }
LABEL_77:
    if (*(_QWORD *)(a1 + 232))
    {
      v58 = *(_QWORD *)(a1 + 224);
      if (v58)
      {
        if (*(_BYTE *)(v58 + 66) && sub_10000D588(a1))
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 232), kSecTrustInfoCertificateTransparencyKey, kCFBooleanTrue);
      }
    }
  }
LABEL_82:
  if (sub_10000D588(a1))
  {
    if (!sub_100015138())
      goto LABEL_102;
    v59 = objc_autoreleasePoolPush();
    v60 = *(_QWORD *)(a1 + 224);
    if (!*(_BYTE *)(v60 + 49))
      goto LABEL_101;
    v61 = *(_QWORD *)(v60 + 16);
    if (v61 >= 1 && (v62 = *(_QWORD *)(v60 + 8 * v61 + 128)) != 0)
      v63 = *(_QWORD *)(v62 + 16);
    else
      v63 = 0;
    if ((sub_1000029B4(a1, v63) & 3) != 2)
      goto LABEL_101;
    if (qword_100082BC8)
    {
      sub_1000144B0((void *)qword_100082BC0);
      v77 = 0;
      v78 = (double *)&v77;
      v79 = 0x2020000000;
      v80 = 0;
      v71 = _NSConcreteStackBlock;
      v72 = 3221225472;
      v73 = sub_1000130B4;
      v74 = &unk_100077360;
      v75 = &v77;
      dispatch_sync((dispatch_queue_t)qword_100082BC8, &v71);
      v64 = (void *)*((_QWORD *)v78 + 3);
      _Block_object_dispose(&v77, 8);
    }
    else
    {
      v64 = 0;
    }
    v65 = (void *)SecCertificateCopySHA256Digest(v63);
    v66 = objc_msgSend(v64, "containsObject:", v65);
    if (v65 && (v66 & 1) == 0 && objc_msgSend(v65, "length") == (id)32)
    {
      ++qword_100082E88;
      v67 = (void *)objc_claimAutoreleasedReturnValue(+[TrustAnalytics logger](TrustAnalytics, "logger"));
      v71 = _NSConcreteStackBlock;
      v72 = 3221225472;
      v73 = sub_100052374;
      v74 = &unk_100079270;
      v75 = v65;
      v76 = *(double *)&a1;
      objc_msgSend(v67, "trustd_logDetailedEventforEventNamed:attributesCallback:", CFSTR("SystemRootUsageEvent"), &v71);

    }
  }
  else
  {
    if (!sub_100015138())
      goto LABEL_102;
    v59 = objc_autoreleasePoolPush();
    v64 = (void *)objc_claimAutoreleasedReturnValue(+[TrustAnalytics logger](TrustAnalytics, "logger"));
    v71 = _NSConcreteStackBlock;
    v72 = 3221225472;
    v73 = sub_100052498;
    v74 = &unk_100079290;
    v75 = (uint64_t *)a1;
    objc_msgSend(v64, "trustd_logDetailedEventforEventNamed:attributesCallback:", CFSTR("TrustFailureEvent"), &v71);
  }

LABEL_101:
  objc_autoreleasePoolPop(v59);
LABEL_102:
  if (sub_100015138())
  {
    v68 = objc_autoreleasePoolPush();
    ++qword_100082EA0;
    v69 = (void *)objc_claimAutoreleasedReturnValue(+[TrustAnalytics logger](TrustAnalytics, "logger"));
    v71 = _NSConcreteStackBlock;
    v72 = 3221225472;
    v73 = sub_10001F08C;
    v74 = &unk_100079290;
    v75 = (uint64_t *)a1;
    objc_msgSend(v69, "trustd_logDetailedEventforEventNamed:attributesCallback:", CFSTR("TrustEvaluationEvent"), &v71);

    objc_autoreleasePoolPop(v68);
  }
  *(_QWORD *)(a1 + 248) = 0;
  return 0;
}

uint64_t sub_10001409C(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v5;
  uint64_t v6;
  BOOL v7;
  char v8;

  v8 = 0;
  v2 = *(_QWORD *)(result + 16);
  v3 = v2 - 1;
  if (v2 >= 1)
  {
    v5 = (uint64_t *)(result + 136);
    do
    {
      v6 = *v5++;
      result = (*(uint64_t (**)(uint64_t, _QWORD, char *))(a2 + 16))(a2, *(_QWORD *)(v6 + 16), &v8);
      if (v8)
        v7 = 1;
      else
        v7 = v3 == 0;
      --v3;
    }
    while (!v7);
  }
  return result;
}

void sub_100014108(uint64_t a1, const void *a2)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), a2);
}

void sub_100014110(uint64_t a1, uint64_t a2)
{
  CFAbsoluteTime v3;
  CFDateRef v4;
  CFDateRef v5;

  v3 = SecCertificateNotValidBefore(a2);
  v4 = CFDateCreate(0, v3);
  if (v4)
  {
    v5 = v4;
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), v4);
    CFRelease(v5);
  }
}

void sub_100014160(uint64_t a1, uint64_t a2)
{
  CFAbsoluteTime v3;
  CFDateRef v4;
  CFDateRef v5;

  v3 = SecCertificateNotValidAfter(a2);
  v4 = CFDateCreate(0, v3);
  if (v4)
  {
    v5 = v4;
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), v4);
    CFRelease(v5);
  }
}

uint64_t sub_1000141B0(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  uint64_t result;

  result = SecCertificateIsAtLeastMinKeySize(a2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  if ((result & 1) == 0)
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
    *a3 = 1;
  }
  return result;
}

uint64_t sub_100014200(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = SecCertificateIsValid(a2, *(double *)(a1 + 40));
  if ((result & 1) == 0)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  return result;
}

void sub_1000144B0(void *a1)
{
  int v1;
  void *v2;
  id v3;
  void *v4;
  id v5;
  _QWORD block[4];
  id v7;

  v5 = a1;
  v1 = sub_1000150B0();
  v2 = v5;
  if (v1)
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000340A8;
    block[3] = &unk_100077B20;
    v3 = v5;
    v7 = v3;
    if (qword_100082C18 == -1)
    {
      v4 = v3;
    }
    else
    {
      dispatch_once(&qword_100082C18, block);
      v4 = v7;
    }
    dispatch_source_merge_data((dispatch_source_t)qword_100082C08, 1uLL);

    v2 = v5;
  }

}

BOOL sub_1000145B0(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t i;
  uint64_t v12;
  uint64_t v13;
  unsigned int *v14;
  uint64_t v15;
  uint64_t *v16;
  _QWORD *Instance;
  __n128 v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  const void *v22;
  uint64_t v23;
  uint64_t *v24;
  unsigned int *v25;
  unsigned int v26;
  uint64_t v27;
  const void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int *v33;
  unsigned int v34;
  uint64_t v35;
  _BYTE *v36;
  int v37;
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  const __CFArray *v41;
  uint64_t v42;
  CFAbsoluteTime Current;
  uint64_t v44;
  uint64_t v45;
  const void *Name;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unsigned int *v55;
  unsigned int v56;
  uint64_t v57;
  uint64_t v58;
  const __CFDictionary *v59;
  const __CFArray *Value;
  const __CFArray *v61;
  NSObject *v62;
  uint64_t v63;
  char v64;
  uint64_t v65;
  _BYTE *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  void *OCSPResponders;
  void *v73;
  id v74;
  id v75;
  const void *v76;
  NSObject *v77;
  uint64_t v78;
  uint64_t v79;
  void *v80;
  BOOL v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  const void *v87;
  uint64_t v88;
  const void *v89;
  TrustURLSessionContext *v90;
  TrustURLSessionContext *v91;
  uint64_t v92;
  uint64_t v93;
  unsigned int v94;
  uint64_t v95;
  unsigned int v96;
  unsigned int v97;
  uint64_t v98;
  void *v99;
  uint64_t v100;
  CFTypeRef cf;
  const __CFDictionary *cfa;
  _BYTE *cfb;
  CFTypeRef cfc;
  uint64_t v105;
  void *v106;
  uint64_t v107;
  void *key;
  uint64_t v109;
  uint64_t *v110;
  void *v111;
  uint64_t v112;
  uint64_t *v113;
  uint64_t v114;
  uint64_t v115;
  __int128 context;
  void *v117;
  void *v118;
  uint64_t *v119;
  uint64_t v120;
  uint64_t v121;
  double v122;
  uint8_t buf[4];
  uint64_t v124;
  CFRange v125;
  CFRange v126;

  v1 = *(_QWORD *)(a1 + 200);
  if (!v1)
    return 1;
  v2 = *(_QWORD *)(v1 + 16);
  if (v2 < 2)
    return 1;
  v5 = *(_QWORD *)(v1 + 80);
  if (v5)
  {
    v6 = sub_100015ECC(a1);
    if (!*(_BYTE *)(a1 + 213) || (v7 = *(_DWORD *)(v6 + 64), v7 <= 7) && ((0x17u >> v7) & 1) == 0)
    {
      v8 = *(_QWORD *)(a1 + 200);
      if (v8)
      {
        v9 = *(_QWORD *)(v8 + 16);
        if (v9 >= 1)
        {
          v10 = 0;
          for (i = 0; i != v9; ++i)
          {
            if (*(_QWORD *)(v1 + 88) > i)
            {
              v12 = *(_QWORD *)(v1 + 80);
              if (v12)
                sub_100015190(v12 + v10);
            }
            v10 += 40;
          }
        }
      }
      return 1;
    }
    sub_100006F08(v1);
  }
  v109 = v5;
  v13 = 0;
  v14 = (unsigned int *)(a1 + 208);
  *(_QWORD *)(v1 + 80) = malloc_type_calloc(0x28uLL, v2, 0x1E0C439AuLL);
  *(_QWORD *)(v1 + 88) = v2;
  atomic_store(v2, (unsigned int *)(a1 + 208));
  key = (void *)kSecCARevocationAdditionsKey;
  do
  {
    if (*(_QWORD *)(v1 + 88) <= v13)
      goto LABEL_80;
    v15 = *(_QWORD *)(v1 + 80);
    if (!v15)
      goto LABEL_80;
    v16 = (uint64_t *)(v15 + 40 * v13);
    *v16 = a1;
    v16[1] = v13;
    v110 = v16 + 1;
    *(_QWORD *)&context = _NSConcreteStackBlock;
    *((_QWORD *)&context + 1) = 0x40000000;
    v117 = sub_1000513D0;
    v118 = &unk_100079108;
    v119 = &qword_100082E58;
    if (qword_100082E50 != -1)
      dispatch_once(&qword_100082E50, &context);
    Instance = (_QWORD *)_CFRuntimeCreateInstance(kCFAllocatorDefault, qword_100082E58, 80, 0);
    if (Instance)
    {
      v19 = Instance;
      Instance[2] = a1;
      Instance[3] = v16;
      Instance[7] = v13;
      if (a1)
      {
        v20 = *(_QWORD *)(a1 + 200);
        if (v20)
        {
          if (*(_QWORD *)(v20 + 16) > v13 + 1)
          {
            v21 = *(_QWORD *)(v20 + 8 * v13 + 136);
            if (v21)
              v22 = *(const void **)(v21 + 16);
            else
              v22 = 0;
            v27 = *(_QWORD *)(v20 + 8 * (v13 + 1) + 136);
            if (v27)
              v28 = *(const void **)(v27 + 16);
            else
              v28 = 0;
            v19[4] = sub_100015E5C(v22, v28);
          }
        }
      }
      v29 = v15 + 40 * v13;
      *(_QWORD *)(v29 + 16) = v19;
      v24 = (uint64_t *)(v29 + 16);
      *((_BYTE *)v24 + 16) = 0;
    }
    else
    {
      v23 = v15 + 40 * v13;
      *(_QWORD *)(v23 + 16) = 0;
      v24 = (uint64_t *)(v23 + 16);
      sub_100006F68(v15 + 40 * v13);
      *((_BYTE *)v24 + 16) = 1;
      v18.n128_f64[0] = sub_100015190(v15 + 40 * v13);
      v25 = (unsigned int *)(*v16 + 208);
      do
        v26 = __ldaxr(v25);
      while (__stlxr(v26 - 1, v25));
    }
    if (*(_QWORD *)(v1 + 16) > v13 && (v30 = *(_QWORD *)(v1 + 8 * v13 + 136)) != 0)
      v31 = *(_QWORD *)(v30 + 16);
    else
      v31 = 0;
    if (SecCertificateHasOCSPNoCheckMarkerExtension(v31, v18))
    {
      if (a1)
      {
        v32 = *(_QWORD *)(a1 + 272);
        if (v32)
          *(_BYTE *)(v32 + 46) = 1;
      }
      *(_BYTE *)(v15 + 40 * v13 + 32) = 1;
      sub_100015190(v15 + 40 * v13);
      v33 = (unsigned int *)(*v16 + 208);
      do
        v34 = __ldaxr(v33);
      while (__stlxr(v34 - 1, v33));
    }
    v35 = v15 + 40 * v13;
    v37 = *(unsigned __int8 *)(v35 + 32);
    v36 = (_BYTE *)(v35 + 32);
    if (v37)
      goto LABEL_80;
    if (sub_100015138())
    {
      v38 = *v16;
      if (!*(_BYTE *)(*v16 + 179)
        && (*(_QWORD *)(v38 + 192) != 1
         || (v45 = **(_QWORD **)(v38 + 184)) != 0
         && (!CFArrayGetValueAtIndex(*(CFArrayRef *)(v45 + 8), 0)
          || (Name = (const void *)SecPolicyGetName()) == 0
          || !CFEqual(Name, CFSTR("OCSPSigner")))))
      {
        if (qword_100082E18 != -1)
          dispatch_once(&qword_100082E18, &stru_100077FA0);
        dispatch_source_merge_data((dispatch_source_t)qword_100082E20, 1uLL);
        v47 = *(_QWORD *)(*v16 + 200);
        if (v47)
        {
          v48 = *(_QWORD *)(v47 + 16);
          if (v48)
          {
            v49 = *v110;
            v50 = *v110 + 1;
            if (v48 <= v50)
            {
              if (v48 == v50)
              {
                if (*(_BYTE *)(v47 + 48))
                  v63 = *(_QWORD *)(v47 + 40);
                else
                  v63 = -1;
                v51 = 0;
                v107 = 0;
                if (v63 == v49)
                  goto LABEL_140;
              }
              else
              {
                v51 = 0;
              }
            }
            else
            {
              if (v49 < -1)
              {
                cf = *(CFTypeRef *)(v47 + 16);
                v51 = 0;
                goto LABEL_138;
              }
              v51 = *(_QWORD *)(v47 + 8 * v50 + 136);
              if (v51)
                v51 = *(_QWORD *)(v51 + 16);
            }
            v82 = 0;
            cf = *(CFTypeRef *)(v47 + 16);
            if (v49 < 0 || v48 <= v49)
              goto LABEL_139;
            v83 = *(_QWORD *)(v47 + 8 * v49 + 136);
            if (v83)
            {
              v82 = *(_QWORD *)(v83 + 16);
LABEL_139:
              v112 = 0;
              v113 = &v112;
              v114 = 0x2000000000;
              v115 = 0;
              *(_QWORD *)&context = _NSConcreteStackBlock;
              *((_QWORD *)&context + 1) = 0x40000000;
              v117 = sub_100016C08;
              v118 = &unk_100078230;
              v119 = &v112;
              v120 = v82;
              v121 = v51;
              sub_100016C6C((uint64_t)&context);
              v107 = v113[3];
              _Block_object_dispose(&v112, 8);
              v47 = *(_QWORD *)(*v16 + 200);
              v48 = (uint64_t)cf;
LABEL_140:
              v84 = 0;
              if (v47)
              {
                v85 = v107;
                if (v48 >= 1)
                {
                  if (*(_QWORD *)(v47 + 16) >= v48 && (v86 = *(_QWORD *)(v47 + 8 * (v48 - 1) + 136)) != 0)
                    v84 = *(_QWORD *)(v86 + 16);
                  else
                    v84 = 0;
                }
              }
              else
              {
                v85 = v107;
              }
              if (v85)
              {
                if (v84)
                {
                  v100 = v84;
                  cfc = (CFTypeRef)SecCertificateCopySHA256Digest(v84);
                  if (sub_100016B34(v100, 0))
                  {
                    v85 = v107;
                    *(_BYTE *)(v107 + 54) = 0;
                  }
                  else
                  {
                    v85 = v107;
                  }
                }
                else
                {
                  cfc = 0;
                }
                v87 = *(const void **)(v85 + 40);
                if (v87)
                {
                  *(_QWORD *)(v85 + 40) = 0;
                  CFRelease(v87);
                  v85 = v107;
                }
                *(_QWORD *)(v85 + 40) = cfc;
                v88 = v15 + 40 * v13;
                v89 = *(const void **)(v88 + 24);
                *(_QWORD *)(v88 + 24) = v85;
                if (v89)
                  CFRelease(v89);
                sub_1000151C4(v15 + 40 * v13);
              }
              goto LABEL_50;
            }
LABEL_138:
            v82 = 0;
            goto LABEL_139;
          }
        }
      }
    }
LABEL_50:
    if (v13 + 1 >= v2)
      goto LABEL_80;
    v39 = (uint64_t *)*v24;
    v40 = *(_QWORD *)(*v24 + 16);
    v41 = *(const __CFArray **)(v40 + 96);
    if (v41)
    {
      CFRetain(*(CFTypeRef *)(v40 + 96));
      *(_QWORD *)&context = _NSConcreteStackBlock;
      *((_QWORD *)&context + 1) = 0x40000000;
      v117 = sub_100008100;
      v118 = &unk_100079150;
      v119 = v39;
      v125.length = CFArrayGetCount(v41);
      v125.location = 0;
      CFArrayApplyFunction(v41, v125, (CFArrayApplierFunction)sub_100051618, &context);
      CFRelease(v41);
    }
    if (sub_100015138())
    {
      v42 = *(_QWORD *)(*v24 + 32);
      if (v42)
      {
        if (*(_BYTE *)(*v16 + 212))
        {
          Current = CFAbsoluteTimeGetCurrent();
          v44 = *(_QWORD *)(*v24 + 32);
          v112 = 0;
          v113 = &v112;
          v114 = 0x2000000000;
          v115 = 0;
          *(_QWORD *)&context = _NSConcreteStackBlock;
          *((_QWORD *)&context + 1) = 0x40000000;
          v117 = sub_10003A408;
          v118 = &unk_100076F70;
          v119 = &v112;
          v120 = v44;
          v121 = 0;
          v122 = Current + -300.0;
        }
        else
        {
          v112 = 0;
          v113 = &v112;
          v114 = 0x2000000000;
          v115 = 0;
          *(_QWORD *)&context = _NSConcreteStackBlock;
          *((_QWORD *)&context + 1) = 0x40000000;
          v117 = sub_10001910C;
          v118 = &unk_100076F48;
          v119 = &v112;
          v120 = v42;
          v121 = 0;
        }
        sub_100018E98((uint64_t)&context);
        v52 = v113[3];
        _Block_object_dispose(&v112, 8);
        sub_100015F64(*v24, v52, 0, 1, 0.0);
        if (*v16)
        {
          if (*(_BYTE *)(*v24 + 88))
          {
            v53 = *(_QWORD *)(*v16 + 272);
            if (v53)
              *(_BYTE *)(v53 + 47) = 1;
          }
        }
      }
    }
    if (*v36 || *(_BYTE *)(*v24 + 88))
    {
      *v36 = 1;
      sub_100015190((uint64_t)v16);
LABEL_77:
      v54 = *v16;
      goto LABEL_78;
    }
    v57 = *(_QWORD *)(*v24 + 40);
    v58 = *(_QWORD *)(v1 + 72);
    if (!v58)
    {
      v59 = (const __CFDictionary *)sub_10001D958(0, 0);
      v58 = -1;
      *(_QWORD *)(v1 + 72) = -1;
      if (v59)
      {
        cfa = v59;
        v105 = v57;
        v112 = 0;
        v113 = &v112;
        v114 = 0x2000000000;
        LOBYTE(v115) = 0;
        Value = (const __CFArray *)CFDictionaryGetValue(v59, key);
        if (Value)
        {
          v61 = Value;
          *(_QWORD *)&context = _NSConcreteStackBlock;
          *((_QWORD *)&context + 1) = 0x40000000;
          v117 = sub_100038A04;
          v118 = &unk_100076E78;
          v119 = &v112;
          v120 = v1;
          v126.length = CFArrayGetCount(Value);
          v126.location = 0;
          CFArrayApplyFunction(v61, v126, (CFArrayApplierFunction)sub_100038B0C, &context);
        }
        if (*((_BYTE *)v113 + 24))
        {
          v62 = sub_100011628("ocsp");
          if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
          {
            v95 = *(_QWORD *)(v1 + 72);
            *(_DWORD *)buf = 134217984;
            v124 = v95;
            _os_log_debug_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEBUG, "key-based CA revocation applies at index %lld", buf, 0xCu);
          }
        }
        CFRelease(cfa);
        _Block_object_dispose(&v112, 8);
        v58 = *(_QWORD *)(v1 + 72);
        v57 = v105;
      }
    }
    if (*(_BYTE *)(a1 + 213))
    {
      if (!v109)
        goto LABEL_105;
    }
    else if (!*(_BYTE *)(a1 + 178))
    {
      goto LABEL_105;
    }
    if (*(_BYTE *)(v1 + 65) || *(_BYTE *)(*(_QWORD *)(v1 + 136) + 40))
    {
      v64 = 1;
    }
    else
    {
      if (*(_QWORD *)(a1 + 216) | v57)
        v81 = 1;
      else
        v81 = v13 < v58;
      v64 = v81;
    }
    if (*v36 || (v64 & 1) == 0)
    {
LABEL_105:
      sub_100015190((uint64_t)v16);
      v54 = a1;
LABEL_78:
      v55 = (unsigned int *)(v54 + 208);
      do
        v56 = __ldaxr(v55);
      while (__stlxr(v56 - 1, v55));
      goto LABEL_80;
    }
    v65 = *v16;
    if (*v16)
      v66 = *(_BYTE **)(v65 + 272);
    else
      v66 = 0;
    v67 = 0;
    v68 = *(_QWORD *)(v65 + 200);
    if (v68)
    {
      v69 = *v110;
      if ((*v110 & 0x8000000000000000) == 0)
      {
        if (*(_QWORD *)(v68 + 16) > v69 && (v70 = *(_QWORD *)(v68 + 8 * v69 + 136)) != 0)
          v67 = *(_QWORD *)(v70 + 16);
        else
          v67 = 0;
      }
    }
    cfb = v66;
    v71 = *v24;
    v111 = objc_autoreleasePoolPush();
    OCSPResponders = (void *)SecCertificateGetOCSPResponders(v67);
    v73 = OCSPResponders;
    if (OCSPResponders)
      CFRetain(OCSPResponders);
    v74 = objc_msgSend(v73, "count");
    v106 = v73;
    if ((unint64_t)v74 >= 0xB)
    {
      v75 = v74;
      v76 = sub_100011628("rvc");
      v77 = objc_claimAutoreleasedReturnValue(v76);
      if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(context) = 134217984;
        *(_QWORD *)((char *)&context + 4) = v75;
        _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "too may OCSP responder entries (%ld)", (uint8_t *)&context, 0xCu);
      }

      *(_BYTE *)(v71 + 88) = 1;
      objc_autoreleasePoolPop(v111);
      goto LABEL_77;
    }
    if (qword_100082D68 != -1)
      dispatch_once(&qword_100082D68, &stru_100077450);
    v78 = v71;
    v79 = *(_QWORD *)(v71 + 16);
    if (v79)
    {
      v80 = *(void **)(v79 + 32);
      if (v80)
        CFRetain(*(CFTypeRef *)(v79 + 32));
    }
    else
    {
      v80 = 0;
    }
    v98 = objc_claimAutoreleasedReturnValue(objc_msgSend((id)qword_100082D58, "sessionForAuditToken:", v80));
    v90 = -[TrustURLSessionContext initWithContext:uris:]([TrustURLSessionContext alloc], "initWithContext:uris:", v78, v73);
    v91 = v90;
    v92 = *(_QWORD *)(v78 + 16);
    if (v92)
      v93 = *(_QWORD *)(v92 + 280);
    else
      v93 = 0;
    -[TrustURLSessionContext setAttribution:](v90, "setAttribution:", v93, v98);
    v94 = objc_msgSend((id)qword_100082D60, "fetchNext:context:", v99, v91);

    objc_autoreleasePoolPop(v111);
    if (cfb && (v94 & 1) == 0)
    {
      cfb[48] = 1;
      goto LABEL_80;
    }
    if (v94)
      goto LABEL_77;
LABEL_80:
    ++v13;
  }
  while (v13 != v2);
  do
  {
    v96 = __ldaxr(v14);
    v97 = v96 - 1;
  }
  while (__stlxr(v97, v14));
  return v97 == 0;
}

uint64_t sub_1000150B0()
{
  if (sub_100015138())
  {
    if (qword_100082B70 != -1)
      dispatch_once(&qword_100082B70, &stru_100076400);
    if (byte_100082B78 != 1)
      return 1;
  }
  if (qword_100082B80 != -1)
    dispatch_once(&qword_100082B80, &stru_100076420);
  return 0;
}

uint64_t sub_100015138()
{
  int v0;

  v0 = os_variant_uses_ephemeral_storage("com.apple.security");
  if (v0 && qword_100082B68 != -1)
    dispatch_once(&qword_100082B68, &stru_1000763E0);
  return v0 ^ 1u;
}

double sub_100015190(uint64_t a1)
{
  double result;
  uint64_t v3;

  sub_1000151C4(a1);
  v3 = *(_QWORD *)(a1 + 16);
  if (v3)
    return sub_100015AEC(v3, result);
  return result;
}

void sub_1000151C4(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  _BOOL4 v7;
  _BYTE *v8;
  char v9;
  char v10;
  _BYTE *v11;
  int v12;
  const __CFData *v13;
  CFIndex Length;
  uint64_t v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  const void *v19;
  int v20;
  uint64_t v21;
  const __CFArray *v22;
  CFIndex Count;
  CFIndex v24;
  CFIndex i;
  const void *Name;
  CFTypeRef v27;
  int v28;
  const UInt8 *v29;
  uint64_t v30;
  int v31;
  int v32;
  BOOL v33;
  char v34;
  NSObject *v36;
  int v37;
  NSObject *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  double v44;
  uint64_t v45;
  const __CFDate *v46;
  double AbsoluteTime;
  uint64_t v48;
  char v49;
  const __CFDate *v50;
  double v51;
  uint64_t v52;
  NSObject *v55;
  const char *v56;
  uint64_t v57;
  uint64_t v58;
  CFNumberRef v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  _BYTE *v68;
  _BOOL4 v69;
  uint64_t v70;
  _BYTE *v71;
  uint64_t v72;
  CFTypeRef v73;
  CFTypeRef v74;
  CFTypeRef v75;
  CFTypeRef v76;
  CFTypeRef v77;
  uint64_t v78;
  CFTypeRef v79;
  CFTypeRef v80;
  uint64_t v81;
  const UInt8 *BytePtr;
  const UInt8 *v83;
  const void *v84;
  CFTypeRef cf2;
  int valuePtr;
  __int128 buf;
  uint64_t (*v88)(uint64_t, uint64_t);
  void *v89;
  uint64_t v90;
  uint64_t v91;
  CFBooleanRef v92;
  char v93;

  v1 = *(_QWORD *)(a1 + 24);
  if (!v1)
    return;
  v3 = *(_QWORD *)a1;
  if (!*(_QWORD *)a1)
    return;
  v4 = *(_QWORD *)(v3 + 200);
  v5 = sub_100015E00(a1);
  v6 = v5;
  if (*(_BYTE *)(v1 + 48))
    v7 = *(_BYTE *)(v1 + 49) == 0;
  else
    v7 = *(_BYTE *)(v1 + 49) != 0;
  v8 = *(_BYTE **)(v3 + 272);
  if (v8)
  {
    if (v5)
      v9 = 1;
    else
      v9 = 2;
    if (v5)
      v10 = 8;
    else
      v10 = 4;
    if (v7)
      v9 = v10;
    v8[70] |= v9;
    v8[72] |= *(_BYTE *)(v1 + 53);
    v8[73] |= *(_BYTE *)(v1 + 52);
    v11 = v8;
  }
  else
  {
    v11 = 0;
  }
  if (*(_BYTE *)(v1 + 54))
  {
    v12 = *(unsigned __int8 *)(v1 + 49);
    if (*(_BYTE *)(v1 + 49))
    {
      v12 = *(unsigned __int8 *)(v1 + 50);
      if (*(_BYTE *)(v1 + 50))
        v12 = *(_BYTE *)(v1 + 48) != 0;
    }
    if (v7)
    {
      sub_100051494((uint64_t *)a1);
    }
    else if (v12)
    {
      *(_BYTE *)(v4 + 67) = 1;
      *(_BYTE *)(a1 + 33) = 1;
    }
    *(_BYTE *)(a1 + 32) = 1;
    return;
  }
  if (!*(_BYTE *)(v1 + 58))
    goto LABEL_112;
  v13 = *(const __CFData **)(v1 + 88);
  if (!v13
    || (Length = CFDataGetLength(*(CFDataRef *)(v1 + 88)), BytePtr = CFDataGetBytePtr(v13), Length < 1)
    || (v15 = *(char *)BytePtr, v83 = BytePtr + 1, v15 < 0)
    || Length - 1 != v15)
  {
    v38 = sub_100011628("SecError");
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "invalid policy constraints array", (uint8_t *)&buf, 2u);
    }
    goto LABEL_112;
  }
  v16 = *(_QWORD *)a1;
  v78 = *(_QWORD *)(*(_QWORD *)a1 + 192);
  if (v78 < 1)
  {
    v17 = 0;
    goto LABEL_123;
  }
  v67 = v6;
  v68 = v11;
  v69 = v7;
  v70 = v1;
  v71 = v8;
  v72 = v4;
  v17 = 0;
  v18 = 0;
  v19 = (const void *)kSecPolicyNameSSLServer;
  cf2 = (CFTypeRef)kSecPolicyNameEAPServer;
  v80 = (CFTypeRef)kSecPolicyNameIPSecServer;
  v79 = (CFTypeRef)kSecPolicyNameSSLClient;
  v77 = (CFTypeRef)kSecPolicyNameEAPClient;
  v76 = (CFTypeRef)kSecPolicyNameIPSecClient;
  v75 = (CFTypeRef)kSecPolicyNameSMIME;
  v74 = (CFTypeRef)kSecPolicyNameCodeSigning;
  v73 = (CFTypeRef)kSecPolicyNameTimeStamping;
  v84 = (const void *)kSecPolicyCheckIssuerPolicyConstraints;
  v20 = v15;
  v81 = v15 - 1;
  do
  {
    if (*(_QWORD *)(*(_QWORD *)a1 + 192) <= v18)
      v21 = 0;
    else
      v21 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 184) + 8 * v18);
    v22 = *(const __CFArray **)(v21 + 8);
    if (v22)
    {
      CFRetain(*(CFTypeRef *)(v21 + 8));
      Count = CFArrayGetCount(v22);
      if (Count >= 1)
      {
        v24 = Count;
        for (i = 0; i != v24; ++i)
        {
          if (CFArrayGetValueAtIndex(v22, i))
          {
            Name = (const void *)SecPolicyGetName();
            v27 = Name;
            if (v19 && Name)
            {
              if (CFEqual(Name, v19))
                goto LABEL_50;
            }
            else if (Name == v19)
            {
              goto LABEL_50;
            }
            if (cf2 && v27)
            {
              if (CFEqual(v27, cf2))
                goto LABEL_50;
            }
            else if (v27 == cf2)
            {
              goto LABEL_50;
            }
            if (v80 && v27)
            {
              if (CFEqual(v27, v80))
                goto LABEL_50;
            }
            else if (v27 == v80)
            {
LABEL_50:
              v28 = 1;
LABEL_51:
              if (!v20)
                goto LABEL_62;
              v30 = v81;
              v29 = v83;
              do
              {
                v32 = *(char *)v29++;
                v31 = v32;
                if (v32)
                  v33 = v28 == v31;
                else
                  v33 = 1;
                v34 = v33;
                if (v33)
                  break;
              }
              while (v30--);
              if ((v34 & 1) == 0)
              {
LABEL_62:
                v36 = sub_100011628("rvc");
                if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
                {
                  LODWORD(buf) = 138412290;
                  *(_QWORD *)((char *)&buf + 4) = v27;
                  _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%@ not allowed by policy constraints on issuing CA", (uint8_t *)&buf, 0xCu);
                }
                v17 = 1;
                if (*(_BYTE *)(*(_QWORD *)(a1 + 24) + 55))
                  v37 = 5;
                else
                  v37 = 0;
                sub_10000E2C8(v21, v84, *(_QWORD *)(a1 + 8), kCFBooleanFalse, 1, v37);
              }
              continue;
            }
            if (v79 && v27)
            {
              if (CFEqual(v27, v79))
                goto LABEL_84;
            }
            else if (v27 == v79)
            {
              goto LABEL_84;
            }
            if (v77 && v27)
            {
              if (CFEqual(v27, v77))
                goto LABEL_84;
            }
            else if (v27 == v77)
            {
              goto LABEL_84;
            }
            if (v76 && v27)
            {
              if (CFEqual(v27, v76))
                goto LABEL_84;
            }
            else if (v27 == v76)
            {
LABEL_84:
              v28 = 2;
              goto LABEL_51;
            }
            if (v75 && v27)
            {
              if (CFEqual(v27, v75))
                goto LABEL_89;
            }
            else if (v27 == v75)
            {
LABEL_89:
              v28 = 3;
              goto LABEL_51;
            }
            if (v74 && v27)
            {
              if (CFEqual(v27, v74))
                goto LABEL_94;
            }
            else if (v27 == v74)
            {
LABEL_94:
              v28 = 4;
              goto LABEL_51;
            }
            if (v73 && v27)
            {
              if (CFEqual(v27, v73))
                goto LABEL_101;
            }
            else if (v27 == v73)
            {
LABEL_101:
              v28 = 5;
              goto LABEL_51;
            }
          }
        }
      }
      CFRelease(v22);
    }
    ++v18;
  }
  while (v18 != v78);
  v16 = *(_QWORD *)a1;
  v8 = v71;
  v4 = v72;
  v1 = v70;
  v7 = v69;
  v11 = v68;
  v6 = v67;
  if (!*(_QWORD *)a1)
    goto LABEL_112;
LABEL_123:
  v48 = *(_QWORD *)(v16 + 272);
  if (v48)
  {
    if ((v17 & 1) != 0)
      v49 = 0x80;
    else
      v49 = 64;
    *(_BYTE *)(v48 + 70) |= v49;
  }
LABEL_112:
  v39 = *(_QWORD *)(a1 + 24);
  if (v39)
  {
    if (*(_QWORD *)a1)
    {
      if (*(_BYTE *)(v39 + 56))
      {
        v40 = *(_QWORD *)(*(_QWORD *)a1 + 200);
        if (v40)
        {
          v41 = *(_QWORD *)(a1 + 8);
          if ((v41 & 0x8000000000000000) == 0 && *(_QWORD *)(v40 + 16) > v41)
          {
            v42 = *(_QWORD *)(v40 + 8 * v41 + 136);
            if (v42)
            {
              v43 = *(_QWORD *)(v42 + 16);
              if (v43)
              {
                v44 = SecCertificateNotValidBefore(v43);
                v45 = *(_QWORD *)(a1 + 24);
                v46 = *(const __CFDate **)(v45 + 64);
                if (v46)
                {
                  AbsoluteTime = CFDateGetAbsoluteTime(v46);
                  v45 = *(_QWORD *)(a1 + 24);
                }
                else
                {
                  AbsoluteTime = -3155760000.0;
                }
                v50 = *(const __CFDate **)(v45 + 72);
                if (v50)
                {
                  v51 = CFDateGetAbsoluteTime(v50);
                  if (v51 < CFAbsoluteTimeGetCurrent())
                    *(_BYTE *)(*(_QWORD *)(a1 + 24) + 53) = 1;
                }
                else
                {
                  v51 = 3.15569088e10;
                }
                if (v44 >= AbsoluteTime || *(uint64_t *)(a1 + 8) <= 0)
                {
                  if (*(_QWORD *)a1)
                  {
                    v52 = *(_QWORD *)(*(_QWORD *)a1 + 272);
                    if (v44 >= AbsoluteTime && v44 <= v51)
                    {
                      if (v52)
                        *(_BYTE *)(v52 + 70) |= 0x10u;
                    }
                    else
                    {
LABEL_148:
                      v55 = sub_100011628("rvc");
                      if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
                      {
                        if (*(_BYTE *)(*(_QWORD *)(a1 + 24) + 55))
                          v56 = "";
                        else
                          v56 = " (non-recoverable error)";
                        LODWORD(buf) = 136315138;
                        *(_QWORD *)((char *)&buf + 4) = v56;
                        _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "certificate issuance date not within the allowed range for this CA%s", (uint8_t *)&buf, 0xCu);
                      }
                      if (v52)
                        *(_BYTE *)(v52 + 70) |= 0x20u;
                      if (*(_BYTE *)(*(_QWORD *)(a1 + 24) + 55))
                      {
                        v57 = *(_QWORD *)a1;
                        v58 = *(_QWORD *)(a1 + 8);
                        *(_QWORD *)&buf = _NSConcreteStackBlock;
                        *((_QWORD *)&buf + 1) = 0x40000000;
                        v88 = sub_10005512C;
                        v89 = &unk_100079658;
                        v90 = kSecPolicyCheckGrayListedKey;
                        v91 = v58;
                        v92 = kCFBooleanFalse;
                        v93 = 1;
                        sub_10000D610(v57, (uint64_t)&buf);
                      }
                      else
                      {
                        valuePtr = 0;
                        v59 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
                        v60 = *(_QWORD *)a1;
                        v61 = *(_QWORD *)(a1 + 8);
                        *(_QWORD *)&buf = _NSConcreteStackBlock;
                        *((_QWORD *)&buf + 1) = 0x40000000;
                        v88 = sub_10005512C;
                        v89 = &unk_100079658;
                        v90 = kSecPolicyCheckRevocation;
                        v91 = v61;
                        v92 = v59;
                        v93 = 1;
                        sub_10000D610(v60, (uint64_t)&buf);
                        v62 = *(_QWORD *)(*(_QWORD *)a1 + 200);
                        if (v62)
                        {
                          v63 = *(_QWORD *)(a1 + 8);
                          if (*(_QWORD *)(v62 + 16) > v63)
                          {
                            v64 = *(_QWORD *)(v62 + 8 * v63 + 136);
                            if (v59)
                              CFRetain(v59);
                            *(_QWORD *)(v64 + 32) = v59;
                          }
                        }
                        if (v59)
                          CFRelease(v59);
                      }
                    }
                  }
                  else if (v44 < AbsoluteTime || v44 > v51)
                  {
                    v52 = 0;
                    goto LABEL_148;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (*(_BYTE *)(v1 + 53))
  {
    v65 = 1;
    if (!*(_BYTE *)(v1 + 55))
      v65 = 2;
    if (*(_QWORD *)(v4 + 120) <= v65)
      *(_QWORD *)(v4 + 120) = v65;
  }
  if ((v7 | v6 ^ 1) == 1)
  {
    *(_BYTE *)(v1 + 51) = 1;
    goto LABEL_172;
  }
  if (*(_BYTE *)(v1 + 51))
  {
LABEL_172:
    v66 = *(_QWORD *)(*(_QWORD *)a1 + 200);
    if (v66)
      v66 = *(_QWORD *)(v66 + 16);
    if (*(_QWORD *)(a1 + 8) + 1 < v66)
    {
      sub_100016F38(*(_QWORD *)a1, kSecPolicyCheckRevocationAny);
      if (v8)
        v11[71] = 1;
    }
  }
}

double sub_100015AEC(uint64_t a1, double result)
{
  unsigned __int8 *v3;
  int v4;
  double v5;
  CFNumberRef v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int valuePtr;
  uint8_t buf[8];
  __int128 v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  CFNumberRef v22;
  char v23;

  v3 = *(unsigned __int8 **)(a1 + 48);
  if (v3)
  {
    v4 = *v3;
    if (v4 != 2)
    {
      if (v4 == 1)
      {
        valuePtr = *((_DWORD *)v3 + 8);
        v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
        v7 = *(_QWORD *)(a1 + 16);
        v8 = *(_QWORD *)(a1 + 56);
        *(_QWORD *)buf = _NSConcreteStackBlock;
        *(_QWORD *)&v18 = 0x40000000;
        *((_QWORD *)&v18 + 1) = sub_10005512C;
        v19 = &unk_100079658;
        v20 = kSecPolicyCheckRevocation;
        v21 = v8;
        v22 = v6;
        v23 = 1;
        sub_10000D610(v7, (uint64_t)buf);
        v9 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 200);
        if (v9)
        {
          v10 = *(_QWORD *)(a1 + 56);
          if (*(_QWORD *)(v9 + 16) > v10)
          {
            v11 = *(_QWORD *)(v9 + 8 * v10 + 136);
            if (v6)
              CFRetain(v6);
            *(_QWORD *)(v11 + 32) = v6;
          }
        }
        CFRelease(v6);
      }
      else if (*v3)
      {
        v12 = sub_100011628("ocsp");
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          v13 = *v3;
          v14 = *(_QWORD *)(a1 + 56);
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&buf[4] = v13;
          LOWORD(v18) = 2048;
          *(_QWORD *)((char *)&v18 + 2) = v14;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "BAD certStatus (%d) for cert %ld", buf, 0x12u);
        }
      }
      else
      {
        v5 = *((double *)v3 + 2);
        if (v5 == 0.0)
          v5 = *((double *)v3 + 1) + 86400.0;
        *(double *)(a1 + 72) = v5;
      }
    }
    result = *(double *)(*(_QWORD *)(a1 + 48) + 8);
    *(double *)(a1 + 64) = result;
  }
  v15 = *(_QWORD *)(a1 + 40);
  if (v15)
  {
    result = *(double *)(v15 + 32);
    *(double *)(a1 + 72) = result;
  }
  return result;
}

void sub_100015CC0(_BYTE *a1)
{
  _QWORD *v1;
  uint64_t v2;
  CFIndex v4;
  const void *v5;
  uint64_t i;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  CFIndex v10;
  uint64_t v11;
  int v12;
  int v13;

  v1 = *(_QWORD **)(*(_QWORD *)a1 + 200);
  if (v1)
  {
    v2 = v1[2];
    if (v2 >= 1)
    {
      v4 = 0;
      v5 = (const void *)kSecPolicyCheckRevocationResponseRequired;
      for (i = 16; ; i += 40)
      {
        if (v1[11] > v4 && (v7 = v1[10]) != 0)
        {
          v8 = (uint64_t *)(v7 + i - 16);
          v9 = *(_QWORD *)(v7 + i);
          if (v9 && *(double *)(v9 + 72) != 0.0)
            goto LABEL_22;
        }
        else
        {
          v8 = 0;
        }
        if (v1[2] > v4)
        {
          v10 = v4;
          if (*(_BYTE *)(v1[v4 + 17] + 42))
            goto LABEL_15;
        }
        if (!v4 && a1[32])
          break;
LABEL_16:
        if (!sub_100015E00((uint64_t)v8))
          goto LABEL_22;
        if (!v8)
          goto LABEL_22;
        v11 = v8[3];
        if (!v11)
          goto LABEL_22;
        v12 = *(unsigned __int8 *)(v11 + 48);
        v13 = *(unsigned __int8 *)(v11 + 49);
        if (!v12)
        {
          if (!v13)
            goto LABEL_22;
LABEL_21:
          sub_100051494(v8);
          goto LABEL_22;
        }
        if (!v13)
          goto LABEL_21;
LABEL_22:
        if (v2 == ++v4)
          return;
      }
      v10 = 0;
LABEL_15:
      sub_10000E2C8((uint64_t)a1, v5, v10, kCFBooleanFalse, 1, 0);
      goto LABEL_16;
    }
  }
}

uint64_t sub_100015E00(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = *(_QWORD *)(result + 24);
    if (!v1)
      return 0;
    if ((*(_DWORD *)(v1 + 16) - 1) > 1)
    {
      if (!*(_BYTE *)(v1 + 54) && (!*(_BYTE *)(v1 + 50) || *(_BYTE *)(v1 + 48)))
        return 0;
    }
    else if (!*(_BYTE *)(v1 + 54) && !*(_BYTE *)(v1 + 50) && !*(_BYTE *)(v1 + 48))
    {
      return 0;
    }
    return 1;
  }
  return result;
}

_QWORD *sub_100015E5C(const void *a1, const void *a2)
{
  _QWORD *v4;

  v4 = malloc_type_calloc(1uLL, 0x40uLL, 0x107004033994813uLL);
  if (v4)
  {
    if (a1)
      CFRetain(a1);
    *v4 = a1;
    if (a2)
      CFRetain(a2);
    v4[1] = a2;
  }
  return v4;
}

uint64_t sub_100015ECC(uint64_t a1)
{
  uint64_t v2;
  _QWORD v4[5];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10000D758;
  v4[3] = &unk_100079680;
  v4[4] = &v5;
  sub_10000D610(a1, (uint64_t)v4);
  v2 = v6[3];
  if (!v2)
    v2 = **(_QWORD **)(a1 + 184);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_100015F64(uint64_t a1, uint64_t a2, int a3, char a4, double a5)
{
  int v7;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  double Current;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  BOOL v25;
  uint64_t *v26;
  void *v27;
  char v28;
  __CFArray *v29;
  __CFArray *v30;
  const __CFArray *v31;
  const void *v32;
  BOOL v33;
  NSObject *v34;
  int v35;
  uint64_t v36;
  NSObject *v37;
  NSObject *v38;
  __CFArray *Mutable;
  CFMutableArrayRef v40;
  void *v41;
  uint64_t v42;
  const void *v43;
  uint64_t v44;
  uint64_t Instance;
  uint64_t v46;
  uint64_t v47;
  const void *v48;
  uint64_t v49;
  uint64_t v50;
  __SecCertificate *ValueAtIndex;
  const void *v52;
  const void *v53;
  SecKeyRef v54;
  BOOL v55;
  NSObject *v56;
  NSObject *v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  __int128 v61;
  double v62;
  NSObject *v63;
  const char *v64;
  NSObject *v65;
  uint32_t v66;
  double v67;
  double v68;
  int v69;
  NSObject *v70;
  const char *v71;
  NSObject *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  double v77;
  uint8_t *v78;
  uint64_t v79;
  const void **v80;
  _QWORD *v81;
  const char *v82;
  BOOL v83;
  uint64_t v84;
  uint64_t v85;
  NSObject *v86;
  uint64_t v87;
  const char *v88;
  NSObject *v89;
  uint32_t v90;
  NSObject *v91;
  uint64_t v92;
  const __CFArray *theArray;
  int v94;
  int v95;
  CFAllocatorRef allocator;
  BOOL allocatora;
  uint64_t v98;
  char v99;
  uint8_t buf[8];
  void *values;
  uint8_t v102[8];
  uint64_t v103;
  uint64_t v104;
  void *v105;
  _BYTE *v106;
  _BYTE context[32];
  uint8_t *v108;
  uint64_t v109;
  uint64_t v110;
  double v111;
  CFRange v112;
  CFRange v113;

  if (!a2)
    return;
  v7 = *(unsigned __int8 *)(a2 + 8);
  if (*(_BYTE *)(a2 + 8))
  {
    v86 = sub_100011628("ocsp");
    if (!os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT))
      goto LABEL_118;
    v87 = *(_QWORD *)(a1 + 80);
    *(_DWORD *)context = 138412546;
    *(_QWORD *)&context[4] = v87;
    *(_WORD *)&context[12] = 1024;
    *(_DWORD *)&context[14] = v7;
    v88 = "responder: %@ returned status: %d";
    v89 = v86;
    v90 = 18;
LABEL_152:
    _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEFAULT, v88, context, v90);
    goto LABEL_118;
  }
  v11 = sub_10000844C(a2, *(_QWORD *)(a1 + 32));
  if (!v11)
  {
    v91 = sub_100011628("ocsp");
    if (!os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT))
      goto LABEL_118;
    v92 = *(_QWORD *)(a1 + 80);
    *(_DWORD *)context = 138412290;
    *(_QWORD *)&context[4] = v92;
    v88 = "ocsp responder: %@ did not include status of requested cert";
    v89 = v91;
    v90 = 12;
    goto LABEL_152;
  }
  v12 = v11;
  v13 = *(_QWORD *)(a1 + 48);
  if (v13 && *(double *)(v13 + 8) >= *(double *)(v11 + 8))
    goto LABEL_117;
  Current = CFAbsoluteTimeGetCurrent();
  if ((a4 & 1) == 0)
  {
    v15 = *(_QWORD *)(a1 + 56);
    if (v15 < -1
      || (v16 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 200),
          v17 = v15 + 1,
          v18 = *(_QWORD *)(v16 + 16),
          v19 = v18 - (v15 + 1),
          v18 <= v15 + 1))
    {
      v26 = 0;
      v27 = 0;
      v28 = 1;
      goto LABEL_18;
    }
    v94 = a3;
    v20 = *(_QWORD *)(v16 + 32);
    v21 = *(_QWORD *)(v16 + 40);
    v83 = v20 <= v17;
    v22 = v20 - v17;
    if (v83)
      v22 = 0;
    v98 = v22;
    v23 = v21 - v17;
    if (v21 <= v15)
      v24 = -1;
    else
      v24 = v23;
    v25 = (v21 & 0x8000000000000000) == 0 && *(_BYTE *)(v16 + 48) != 0;
    v44 = sub_1000107C0();
    Instance = _CFRuntimeCreateInstance(kCFAllocatorDefault, v44, 8 * v19 + 120, 0);
    v26 = (uint64_t *)Instance;
    if (Instance)
    {
      *(_OWORD *)(Instance + 24) = 0u;
      *(_OWORD *)(Instance + 40) = 0u;
      *(_OWORD *)(Instance + 120) = 0u;
      *(_OWORD *)(Instance + 104) = 0u;
      *(_OWORD *)(Instance + 88) = 0u;
      *(_OWORD *)(Instance + 72) = 0u;
      *(_OWORD *)(Instance + 56) = 0u;
      *(_QWORD *)(Instance + 16) = v19;
      *(_QWORD *)(Instance + 32) = v98;
      *(_QWORD *)(Instance + 40) = v24;
      *(_BYTE *)(Instance + 48) = v25;
      *(_BYTE *)(Instance + 49) = *(_BYTE *)(v16 + 49);
      if (v19 >= 1)
      {
        v46 = 0;
        v47 = v16 + 8 * v15 + 144;
        do
        {
          v48 = *(const void **)(v47 + 8 * v46);
          v26[v46 + 17] = (uint64_t)v48;
          CFRetain(v48);
          ++v46;
        }
        while (v19 != v46);
        a3 = v94;
        if (v26[2] >= 1 && (v49 = v26[17]) != 0)
        {
          v27 = *(void **)(v49 + 16);
          if (v27)
            CFRetain(*(CFTypeRef *)(v49 + 16));
          v28 = 0;
        }
        else
        {
          v28 = 0;
          v27 = 0;
        }
LABEL_18:
        v29 = sub_100009CCC(a2);
        *(_QWORD *)v102 = 0;
        v103 = (uint64_t)v102;
        v104 = 0x2000000000;
        v105 = 0;
        v30 = sub_100009CCC(a2);
        if (v30)
        {
          v31 = v30;
          *(_QWORD *)context = _NSConcreteStackBlock;
          *(_QWORD *)&context[8] = 0x40000000;
          *(_QWORD *)&context[16] = sub_100007234;
          *(_QWORD *)&context[24] = &unk_100077868;
          v108 = v102;
          v109 = a2;
          v112.length = CFArrayGetCount(v30);
          v112.location = 0;
          CFArrayApplyFunction(v31, v112, (CFArrayApplierFunction)sub_100040F24, context);
          CFRelease(v31);
        }
        v32 = *(const void **)(v103 + 24);
        if (v27 && !v32)
        {
          if (sub_100008244((_QWORD *)a2, (__SecCertificate *)v27))
          {
            CFRetain(v27);
            *(_QWORD *)(v103 + 24) = v27;
            v32 = v27;
          }
          else
          {
            v32 = *(const void **)(v103 + 24);
          }
        }
        _Block_object_dispose(v102, 8);
        if (v32)
          v33 = v29 == 0;
        else
          v33 = 1;
        v99 = v28;
        if (v33)
        {
          v34 = sub_100011628("ocsp");
          v35 = 0;
          if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
          {
            v36 = *(_QWORD *)(a1 + 80);
            *(_DWORD *)context = 138412290;
            *(_QWORD *)&context[4] = v36;
            _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "ocsp responder: %@ no signer found for response", context, 0xCu);
            v35 = 0;
          }
LABEL_84:
          if ((v99 & 1) == 0)
            CFRelease(v26);
          if (v27)
            CFRelease(v27);
          if (v29)
            CFRelease(v29);
          if (v32)
            CFRelease(v32);
          if (!v35)
            goto LABEL_117;
          goto LABEL_93;
        }
        if (v27 && CFEqual(v32, v27))
        {
          v37 = sub_100011628("ocsp");
          if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
          {
            v85 = *(_QWORD *)(a1 + 80);
            *(_DWORD *)context = 138412290;
            *(_QWORD *)&context[4] = v85;
            _os_log_debug_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEBUG, "ocsp responder: %@ response signed by issuer", context, 0xCu);
          }
          v35 = 1;
          goto LABEL_84;
        }
        v95 = a3;
        v38 = sub_100011628("ocsp");
        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
        {
          v84 = *(_QWORD *)(a1 + 80);
          *(_DWORD *)context = 138412290;
          *(_QWORD *)&context[4] = v84;
          _os_log_debug_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEBUG, "ocsp responder: %@ response signed by cert issued by issuer", context, 0xCu);
        }
        Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
        CFArrayAppendValue(Mutable, v32);
        v113.length = CFArrayGetCount(v29);
        v113.location = 0;
        CFArrayAppendArray(Mutable, v29, v113);
        v40 = 0;
        if ((v28 & 1) == 0)
          v40 = sub_100011E18((uint64_t)v26);
        *(_QWORD *)v102 = 0;
        v103 = (uint64_t)v102;
        v104 = 0x2000000000;
        LOBYTE(v105) = 0;
        theArray = v40;
        if (Mutable && v40)
        {
          values = (void *)SecPolicyCreateOCSPSigner();
          allocator = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
          CFRelease(values);
          *(_QWORD *)context = _NSConcreteStackBlock;
          *(_QWORD *)&context[8] = 0x40000000;
          *(_QWORD *)&context[16] = sub_10001CD74;
          *(_QWORD *)&context[24] = &unk_100079130;
          v108 = v102;
          v41 = _Block_copy(context);
          v42 = *(_QWORD *)(a1 + 16);
          if (v42)
          {
            v43 = *(const void **)(v42 + 32);
            if (v43)
              CFRetain(*(CFTypeRef *)(v42 + 32));
          }
          else
          {
            v43 = 0;
          }
          v50 = sub_10000CAB0(0, (int)v43, (int)Mutable, (int)theArray, 1, 0, (int)allocator, 0, 0, 0, 0, 0, 0, (uint64_t)sub_10001CD48, (uint64_t)v41);
          sub_100016E34(v50, 0);
          sub_10000FDEC(v50);
          if (v43)
            CFRelease(v43);
          if (allocator)
            CFRelease(allocator);
          if (*(_BYTE *)(v103 + 24))
          {
            ValueAtIndex = (__SecCertificate *)CFArrayGetValueAtIndex(theArray, 0);
            v52 = CFArrayGetValueAtIndex(Mutable, 0);
            if (ValueAtIndex)
            {
              v53 = v52;
              v54 = SecCertificateCopyKey(ValueAtIndex);
              ValueAtIndex = v54;
              v55 = v54 != 0;
              if (v53 && v54)
              {
                if (!SecCertificateIsSignedBy(v53, v54))
                {
                  CFRelease(ValueAtIndex);
                  _Block_object_dispose(v102, 8);
                  v58 = 1;
LABEL_80:
                  CFRelease(Mutable);
                  v35 = v58;
LABEL_81:
                  if (theArray)
                    CFRelease(theArray);
                  a3 = v95;
                  goto LABEL_84;
                }
                v55 = 1;
              }
              allocatora = v55;
            }
            else
            {
              allocatora = 0;
            }
            v56 = sub_100011628("ocsp");
            if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "ocsp signer cert not signed by issuer", buf, 2u);
            }
            if (allocatora)
              CFRelease(ValueAtIndex);
          }
        }
        _Block_object_dispose(v102, 8);
        v57 = sub_100011628("ocsp");
        if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)context = 0;
          _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "ocsp response signed by certificate which does not satisfy ocspSigner policy", context, 2u);
        }
        v58 = 0;
        v35 = 0;
        if (!Mutable)
          goto LABEL_81;
        goto LABEL_80;
      }
      v28 = 0;
      v27 = 0;
    }
    else
    {
      v27 = 0;
      v28 = 1;
    }
    a3 = v94;
    goto LABEL_18;
  }
LABEL_93:
  v59 = *(_QWORD *)(a1 + 16);
  if (v59)
  {
    v60 = *(_QWORD *)(v59 + 272);
    if (v60)
    {
      *(_QWORD *)&v61 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v61 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)context = v61;
      *(_OWORD *)&context[16] = v61;
      if (DERParseSequenceContent((unint64_t *)(a2 + 56), (unsigned __int16)DERNumAlgorithmIdItemSpecs, (uint64_t)&DERAlgorithmIdItemSpecs, (unint64_t)context, 0x20uLL)|| SecSignatureHashAlgorithmForAlgorithmOid(context) <= 4)
      {
        *(_BYTE *)(v60 + 69) = 1;
      }
    }
  }
  v62 = *(double *)(v12 + 8);
  if (v62 <= Current + 4500.0)
  {
    v67 = v62 + 86400.0;
    if (*(double *)(v12 + 16) == 0.0)
      v68 = v67;
    else
      v68 = *(double *)(v12 + 16);
    if (Current + -4500.0 <= v68)
    {
      v69 = 1;
      *(_BYTE *)(*(_QWORD *)(a1 + 24) + 33) = 1;
      goto LABEL_112;
    }
    v70 = sub_100011628("SecError");
    if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
    {
      v71 = "thisUpdate + defaultTTL";
      if (*(double *)(v12 + 16) != 0.0)
        v71 = "nextUpdate";
      *(_DWORD *)context = 136315394;
      *(_QWORD *)&context[4] = v71;
      *(_WORD *)&context[12] = 2048;
      *(double *)&context[14] = (Current - v68) / 86400.0;
      v64 = "OCSPSingleResponse: %s %.2f days ago";
      v65 = v70;
      v66 = 22;
      goto LABEL_110;
    }
  }
  else
  {
    v63 = sub_100011628("SecError");
    if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)context = 0;
      v64 = "OCSPSingleResponse: thisUpdate more than 1:15 from now";
      v65 = v63;
      v66 = 2;
LABEL_110:
      _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, v64, context, v66);
    }
  }
  v69 = 0;
LABEL_112:
  if (*(_BYTE *)v12 == 1)
  {
    v73 = 0;
    v74 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 200);
    if (v74)
    {
      v75 = *(_QWORD *)(a1 + 56);
      if ((v75 & 0x8000000000000000) == 0)
      {
        if (*(_QWORD *)(v74 + 16) > v75 && (v76 = *(_QWORD *)(v74 + 8 * v75 + 136)) != 0)
          v73 = *(_QWORD *)(v76 + 16);
        else
          v73 = 0;
      }
    }
    v77 = SecCertificateNotValidAfter(v73);
LABEL_129:
    *(double *)(a2 + 32) = v77;
    goto LABEL_130;
  }
  if (!*(_BYTE *)v12)
  {
    if (!v69)
    {
LABEL_117:
      sub_10000A22C((_QWORD *)v12);
LABEL_118:
      sub_100008218((const void **)a2);
      return;
    }
    *(_QWORD *)(a2 + 24) = 0;
    if (*(double *)(a2 + 16) > Current + 4500.0)
    {
      v72 = sub_100011628("ocsp");
      if (!os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
        goto LABEL_117;
      *(_WORD *)v102 = 0;
      v82 = "OCSPResponse: producedAt more than 1:15 from now";
LABEL_154:
      _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, v82, v102, 2u);
      goto LABEL_117;
    }
    *(_QWORD *)context = _NSConcreteStackBlock;
    *(_QWORD *)&context[8] = 0x40000000;
    *(_QWORD *)&context[16] = sub_10000A744;
    *(_QWORD *)&context[24] = &unk_100077818;
    v108 = *(uint8_t **)&Current;
    v109 = a2;
    *(_QWORD *)v102 = _NSConcreteStackBlock;
    v103 = 0x40000000;
    v104 = (uint64_t)sub_100009F74;
    v105 = &unk_100077890;
    v106 = context;
    if (DERDecodeSequenceContentWithBlock((unint64_t *)(a2 + 152), (uint64_t)v102))
    {
      v72 = sub_100011628("SecError");
      if (!os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
        goto LABEL_117;
      *(_WORD *)v102 = 0;
      v82 = "failed to parse single responses";
      goto LABEL_154;
    }
    v77 = *(double *)(a2 + 24);
    if (v77 == 0.0)
    {
      v77 = Current + 86400.0;
    }
    else
    {
      if (v77 < Current + -4500.0)
      {
        v72 = sub_100011628("ocsp");
        if (!os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
          goto LABEL_117;
        *(_WORD *)v102 = 0;
        v82 = "OCSPResponse: latestNextUpdate more than 1:15 ago";
        goto LABEL_154;
      }
      v83 = v77 - Current <= a5 || a5 <= 0.0;
      if (!v83)
        v77 = Current + a5;
    }
    goto LABEL_129;
  }
LABEL_130:
  if (a3)
  {
    v78 = *(uint8_t **)(a1 + 40);
    v79 = *(_QWORD *)(a1 + 80);
    *(_QWORD *)context = _NSConcreteStackBlock;
    *(_QWORD *)&context[8] = 0x40000000;
    *(_QWORD *)&context[16] = sub_1000394C4;
    *(_QWORD *)&context[24] = &unk_100076F20;
    v108 = v78;
    v109 = a2;
    v110 = v79;
    v111 = Current;
    sub_100018E98((uint64_t)context);
  }
  v80 = *(const void ***)(a1 + 40);
  if (v80)
    sub_100008218(v80);
  *(_QWORD *)(a1 + 40) = a2;
  v81 = *(_QWORD **)(a1 + 48);
  if (v81)
    sub_10000A22C(v81);
  *(_QWORD *)(a1 + 48) = v12;
  *(_BYTE *)(a1 + 88) = v69;
}

uint64_t sub_100016B34(uint64_t a1, char a2)
{
  uint64_t v3;
  const void *v4;
  const void *Value;
  uint64_t v6;
  CFTypeID v7;
  int v8;
  int v9;
  unsigned int v10;

  v3 = SecCertificateCopySHA256Digest();
  if (!v3)
    return 0;
  v4 = (const void *)v3;
  if (qword_100082B48 != -1)
    dispatch_once(&qword_100082B48, &stru_100076388);
  if (!qword_100082B50)
  {
LABEL_13:
    v6 = 0;
    goto LABEL_11;
  }
  Value = CFDictionaryGetValue((CFDictionaryRef)qword_100082B50, v4);
  v6 = (uint64_t)Value;
  if (Value)
  {
    v7 = CFGetTypeID(Value);
    if (v7 == CFBooleanGetTypeID())
    {
      v8 = CFBooleanGetValue((CFBooleanRef)v6);
      v6 = v8 != 0;
      if ((a2 & 1) != 0)
      {
        v9 = v8;
        v10 = SecIsInternalRelease() | ((a2 & 2) >> 1);
        if (v9)
          v6 = 1;
        else
          v6 = v10;
      }
      goto LABEL_11;
    }
    goto LABEL_13;
  }
LABEL_11:
  CFRelease(v4);
  return v6;
}

BOOL sub_100016C08(uint64_t a1, uint64_t *a2)
{
  _QWORD v3[4];
  __int128 v4;
  uint64_t v5;

  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = sub_100017DA8;
  v3[3] = &unk_100078208;
  v4 = *(_OWORD *)(a1 + 32);
  v5 = *(_QWORD *)(a1 + 48);
  return sub_100018D8C(a2, 0, (uint64_t)v3);
}

void sub_100016C6C(uint64_t a1)
{
  if (qword_100082E40 != -1)
    dispatch_once(&qword_100082E40, &stru_1000784B0);
  if (!*(_BYTE *)(qword_100082E48 + 16))
    (*(void (**)(uint64_t))(a1 + 16))(a1);
}

double sub_100016CDC(_QWORD *a1)
{
  uint64_t v1;
  double v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  double v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const __CFArray *OCSPResponders;

  v1 = a1[2];
  v2 = 0.0;
  if (v1 >= 2 && a1[10] && (uint64_t)a1[11] >= 1)
  {
    v4 = 0;
    v5 = 0;
    v6 = v1 - 1;
    v7 = 0.0;
    do
    {
      v8 = a1[10];
      v2 = 0.0;
      if (v8 && (v9 = *(_QWORD *)(v8 + v4 + 16)) != 0 && (v2 = *(double *)(v9 + 72), v2 != 0.0))
      {
        if (v2 < v7 || v7 == 0.0)
          v7 = *(double *)(v9 + 72);
      }
      else
      {
        if (!v5)
          return v2;
        v10 = *(_QWORD *)(v8 + v4 + 8);
        if (v10 < 0 || a1[2] <= v10 || (v11 = a1[v10 + 17]) == 0)
          v12 = 0;
        else
          v12 = *(_QWORD *)(v11 + 16);
        OCSPResponders = (const __CFArray *)SecCertificateGetOCSPResponders(v12);
        if (OCSPResponders)
        {
          if (CFArrayGetCount(OCSPResponders) && v6 != v5)
            return v2;
        }
      }
      ++v5;
      v4 += 40;
      v2 = v7;
    }
    while (v5 < a1[11]);
  }
  return v2;
}

BOOL sub_100016DE4(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  unsigned __int8 *v4;
  int v5;
  _BOOL8 result;

  if (a1[2] < 2)
    return 0;
  v1 = a1[10];
  if (!v1)
    return 0;
  v2 = a1[11];
  if (v2 < 2)
    return 1;
  v3 = v2 - 1;
  v4 = (unsigned __int8 *)(v1 + 33);
  while (1)
  {
    v5 = *v4;
    v4 += 40;
    result = v5 != 0;
    if (!v5)
      break;
    if (!--v3)
      return 1;
  }
  return result;
}

void sub_100016E34(uint64_t a1, int a2)
{
  NSObject *v4;
  _BOOL4 v5;
  const __CFArray *v6;
  CFIndex FirstIndexOfValue;
  uint8_t v8[16];
  uint8_t buf[16];
  CFRange v10;

  if (*(unsigned __int8 *)(a1 + 178) != a2)
  {
    *(_BYTE *)(a1 + 178) = a2;
    v4 = sub_100011628("http");
    v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG);
    if (a2)
    {
      if (v5)
      {
        *(_WORD *)buf = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "network access re-enabled by policy", buf, 2u);
      }
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 88), &off_100082800);
    }
    else
    {
      if (v5)
      {
        *(_WORD *)v8 = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "network access disabled by policy", v8, 2u);
      }
      v6 = *(const __CFArray **)(a1 + 88);
      v10.length = CFArrayGetCount(v6);
      v10.location = 0;
      FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v6, v10, &off_100082800);
      if ((FirstIndexOfValue & 0x8000000000000000) == 0)
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 88), FirstIndexOfValue);
    }
  }
}

void sub_100016F38(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3;

  v3 = *(CFTypeRef *)(a1 + 216);
  if (v3 != cf)
  {
    if (!cf || (CFRetain(cf), (v3 = *(CFTypeRef *)(a1 + 216)) != 0))
      CFRelease(v3);
    *(_QWORD *)(a1 + 216) = cf;
  }
}

id sub_100016F80(void *a1, __CFString **a2)
{
  id v3;
  void *v4;
  NSNumber *v5;
  id v6;
  NSNumber *v7;
  NSNumber *v8;
  double value;
  const void *bytes_ptr;
  NSData *v12;
  id v13;
  const char *string_ptr;
  uint64_t v15;
  id v16;
  id v17;

  v3 = a1;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_BOOL)
  {
    v5 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", xpc_BOOL_get_value(v3));
    v6 = (id)objc_claimAutoreleasedReturnValue(v5);
LABEL_18:
    v4 = v6;
    goto LABEL_19;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_int64)
  {
    v7 = +[NSNumber numberWithLongLong:](NSNumber, "numberWithLongLong:", xpc_int64_get_value(v3));
    v6 = (id)objc_claimAutoreleasedReturnValue(v7);
    goto LABEL_18;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_uint64)
  {
    v8 = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", xpc_uint64_get_value(v3));
    v6 = (id)objc_claimAutoreleasedReturnValue(v8);
    goto LABEL_18;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_double)
  {
    value = xpc_double_get_value(v3);
LABEL_17:
    v6 = (id)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", value));
    goto LABEL_18;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_date)
  {
    value = (double)xpc_date_get_value(v3) / 1000000.0;
    goto LABEL_17;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_data)
  {
    bytes_ptr = xpc_data_get_bytes_ptr(v3);
    v12 = +[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", bytes_ptr, xpc_data_get_length(v3));
    v6 = (id)objc_claimAutoreleasedReturnValue(v12);
    goto LABEL_18;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_string)
  {
    v13 = objc_alloc((Class)NSString);
    string_ptr = xpc_string_get_string_ptr(v3);
    v6 = objc_msgSend(v13, "initWithBytes:length:encoding:", string_ptr, xpc_string_get_length(v3), 4);
    goto LABEL_18;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    v15 = sub_100017378(v3, a2);
    v6 = (id)objc_claimAutoreleasedReturnValue(v15);
    goto LABEL_18;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    v16 = sub_100053320(v3, (uint64_t)a2);
    v6 = (id)objc_claimAutoreleasedReturnValue(v16);
    goto LABEL_18;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_uuid)
  {
    v17 = objc_msgSend(objc_alloc((Class)NSUUID), "initWithUUIDBytes:", xpc_uuid_get_bytes(v3));
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "UUIDString"));

  }
  else
  {
    sub_100012C88(-50, a2, CFSTR("Unsupported xpc type"));
    v4 = 0;
  }
LABEL_19:

  return v4;
}

void sub_100017240(void *a1)
{
  id v1;
  NSObject *v2;
  NSObject *v3;
  BOOL v4;
  unsigned __int8 v5;
  _QWORD block[4];
  id v7;

  v1 = a1;
  if (qword_100082EB8 != -1)
    dispatch_once(&qword_100082EB8, &stru_100079318);
  v2 = qword_100082E60;
  v3 = qword_100082EA8;
  if (qword_100082E60)
    v4 = qword_100082EA8 == 0;
  else
    v4 = 1;
  if (!v4)
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100021478;
    block[3] = &unk_100079340;
    v7 = v1;
    dispatch_group_async(v3, v2, block);
    do
      v5 = __ldaxr(byte_100082EB0);
    while (__stlxr(1u, byte_100082EB0));
    if ((v5 & 1) == 0)
    {
      xpc_transaction_begin();
      dispatch_group_notify((dispatch_group_t)qword_100082EA8, (dispatch_queue_t)qword_100082E60, &stru_100079360);
    }

  }
}

id sub_100017340(uint64_t a1)
{
  id result;

  result = sub_100017378(*(void **)(a1 + 32), *(_QWORD *)(a1 + 48));
  if (!result)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
  return result;
}

id sub_100017378(void *a1, uint64_t a2)
{
  id v3;
  id v4;
  _QWORD v6[6];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t (*v10)(uint64_t, uint64_t);
  void (*v11)(uint64_t);
  id v12;

  v3 = a1;
  v7 = 0;
  v8 = &v7;
  v9 = 0x3032000000;
  v10 = sub_100053308;
  v11 = sub_100053318;
  v12 = (id)0xAAAAAAAAAAAAAAAALL;
  v12 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_100013314;
  v6[3] = &unk_100079418;
  v6[4] = &v7;
  v6[5] = a2;
  xpc_dictionary_apply(v3, v6);
  v4 = (id)v8[5];
  _Block_object_dispose(&v7, 8);

  return v4;
}

void sub_100017458(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100017470(uint64_t a1)
{
  NSObject *v2;
  CFIndex Count;
  CFIndex v4;
  uint64_t v5;
  const __CFArray *v6;
  unint64_t v7;
  unint64_t v8;
  CFIndex v9;
  NSObject *v11;
  const char *v12;
  const char *v13;
  NSObject *v14;
  uint32_t v15;
  NSObject *v16;
  const char *v17;
  int v18;
  int v19;
  const char *v20;
  __int16 v21;
  int v22;

  if (!*(_BYTE *)(*(_QWORD *)(a1 + 32) + 48))
  {
    Count = CFArrayGetCount(*(CFArrayRef *)(*(_QWORD *)(a1 + 40) + 48));
    v4 = CFArrayGetCount(*(CFArrayRef *)(*(_QWORD *)(a1 + 40) + 40)) + Count;
    v5 = 48;
    if (!*(_BYTE *)(a1 + 48))
      v5 = 40;
    v6 = *(const __CFArray **)(*(_QWORD *)(a1 + 40) + v5);
    v7 = CFArrayGetCount(v6);
    if (*(_BYTE *)(a1 + 48))
      v8 = 5;
    else
      v8 = 1;
    v9 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 40) + 166);
    if (v7 < v8 && v4 < v9)
    {
      CFArrayAppendValue(v6, *(const void **)(a1 + 32));
      return;
    }
    if (v9 < 6)
    {
      v16 = sub_100011628("dbconn");
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        return;
      v17 = "ro";
      if (!*(_BYTE *)(a1 + 48))
        v17 = "rw";
      v18 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 40) + 166);
      v19 = 136315394;
      v20 = v17;
      v21 = 1024;
      v22 = v18;
      v13 = "releasing %s connection rather than storing in size %d cache";
      v14 = v16;
      v15 = 18;
    }
    else
    {
      v11 = sub_100011628("SecError");
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        return;
      if (*(_BYTE *)(a1 + 48))
        v12 = "ro";
      else
        v12 = "rw";
      v19 = 136315138;
      v20 = v12;
      v13 = "dbconn: did not expect to run out of room in the %s cache when releasing connection";
      v14 = v11;
      v15 = 12;
    }
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v13, (uint8_t *)&v19, v15);
    return;
  }
  v2 = sub_100011628("SecWarning");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v19) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SecDbConnectionRelease: IO failure reported in connection, throwing away currently idle caches", (uint8_t *)&v19, 2u);
  }
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(*(_QWORD *)(a1 + 40) + 40));
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(*(_QWORD *)(a1 + 40) + 48));
}

void sub_1000176C4(uint64_t *a1, const void *a2)
{
  CFDictionaryRef *ValueAtIndex;
  const void *Value;
  const void *v6;
  CFTypeID v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void *v12;
  _QWORD v13[6];

  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex((CFArrayRef)a1[1], a1[3]);
  Value = CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (Value)
  {
    v6 = Value;
    v7 = CFGetTypeID(Value);
    if (v7 == CFStringGetTypeID())
    {
      v8 = *(_QWORD *)(*a1 + 200);
      if (v8 && *(uint64_t *)(v8 + 16) >= 1 && (v9 = *(_QWORD *)(v8 + 136)) != 0)
        v10 = *(_QWORD *)(v9 + 16);
      else
        v10 = 0;
      if ((SecPolicyCheckCertSSLHostname(v10, v6) & 1) == 0)
        sub_10000E2C8((uint64_t)a1, a2, 0, kCFBooleanFalse, 0, 0);
      if (sub_100015138())
      {
        v11 = objc_autoreleasePoolPush();
        if ((sub_100017818(*a1) & 3) != 1)
        {
          ++qword_100082E98;
          v12 = (void *)objc_claimAutoreleasedReturnValue(+[TrustAnalytics logger](TrustAnalytics, "logger"));
          v13[0] = _NSConcreteStackBlock;
          v13[1] = 3221225472;
          v13[2] = sub_100021754;
          v13[3] = &unk_1000792B0;
          v13[4] = a1;
          v13[5] = v6;
          objc_msgSend(v12, "trustd_logDetailedEventforEventNamed:attributesCallback:", CFSTR("PinningEvent"), v13);

        }
        objc_autoreleasePoolPop(v11);
      }
    }
  }
}

uint64_t sub_100017818(uint64_t a1)
{
  _QWORD *v1;
  __CFString *v2;
  void *v3;
  SecTaskRef v4;
  __SecTask *v5;
  unsigned __int8 v6;
  uint32_t v8;
  audit_token_t v9;
  audit_token_t v10;

  v1 = (_QWORD *)a1;
  v2 = sub_10001799C(a1);
  v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  memset(&v10, 0, sizeof(v10));
  if (v1
    && (v1 = (_QWORD *)v1[4]) != 0
    && (CFRetain(v1), objc_msgSend(v1, "length") == (id)32)
    && (objc_msgSend(v1, "getBytes:range:", &v10, 0, 32),
        v9 = v10,
        (v4 = SecTaskCreateWithAuditToken(0, &v9)) != 0))
  {
    v5 = v4;
    if ((objc_msgSend(v3, "hasPrefix:", CFSTR("com.apple.Safari")) & 1) != 0
      || (objc_msgSend(v3, "hasPrefix:", CFSTR("com.apple.mobilesafari")) & 1) != 0
      || (objc_msgSend(v3, "hasPrefix:", CFSTR("com.apple.WebKit.Networking")) & 1) != 0)
    {
      v6 = 1;
    }
    else if ((objc_msgSend(v3, "hasPrefix:", CFSTR("com.apple.mail")) & 1) != 0
           || (objc_msgSend(v3, "hasPrefix:", CFSTR("com.apple.mobilemail")) & 1) != 0)
    {
      v6 = 2;
    }
    else if ((objc_msgSend(v3, "hasPrefix:", CFSTR("com.apple.CaptiveNetworkAssistant")) & 1) != 0)
    {
      v6 = 3;
    }
    else
    {
      v8 = SecTaskGetCodeSignStatus(v5) & 0x1C000001;
      v6 = 4;
      if (v8 != 67108865)
      {
        if (((v8 == 335544320) & SecIsInternalRelease()) != 0)
          v6 = 4;
        else
          v6 = 5;
      }
    }
    CFRelease(v5);
  }
  else
  {
    v6 = 0;
  }

  return v6;
}

__CFString *sub_10001799C(uint64_t a1)
{
  void *v1;
  __SecTask *v2;
  __SecTask *v3;
  __CFString *v4;
  audit_token_t v6;
  audit_token_t v7;

  memset(&v7, 0, sizeof(v7));
  if (!a1)
  {
    v1 = 0;
LABEL_7:
    v4 = 0;
    goto LABEL_8;
  }
  v1 = *(void **)(a1 + 32);
  if (!v1)
    goto LABEL_7;
  CFRetain(*(CFTypeRef *)(a1 + 32));
  if (objc_msgSend(v1, "length") != (id)32)
    goto LABEL_7;
  objc_msgSend(v1, "getBytes:range:", &v7, 0, 32);
  v6 = v7;
  v2 = SecTaskCreateWithAuditToken(0, &v6);
  if (!v2)
    goto LABEL_7;
  v3 = v2;
  v4 = (__CFString *)SecTaskCopySigningIdentifier(v2, 0);
  CFRelease(v3);
LABEL_8:

  return v4;
}

void sub_100017D34(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  char v5;

  v3 = sub_100018B0C(a1[7], a2, (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24));
  v4 = *(_QWORD *)(a1[6] + 8);
  if (*(_BYTE *)(v4 + 24))
  {
    v5 = (*(uint64_t (**)(void))(a1[4] + 16))();
    v4 = *(_QWORD *)(a1[6] + 8);
  }
  else
  {
    v5 = 0;
  }
  *(_BYTE *)(v4 + 24) = v5;
  free(v3);
}

BOOL sub_100017DA8(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  const void *Value;
  uint64_t v4;
  __SecCertificate *v5;
  _QWORD *v7;
  uint64_t v8;
  const __CFData *v9;
  uint64_t v10;
  uint64_t v11;
  const __CFData *v12;
  const void *v13;
  const __CFArray *v14;
  CFIndex FirstIndexOfValue;
  CFIndex v16;
  const __CFData *v17;
  const void *v18;
  NSObject *v19;
  const void *v20;
  const __CFData *v21;
  const __CFData *v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  char v27;
  char v28;
  uint64_t v29;
  char v30;
  char v31;
  NSObject *v32;
  uint64_t v33;
  __CFError *v34;
  CFIndex Code;
  uint64_t v36;
  uint64_t v37;
  int v38;
  int v39;
  NSObject *v40;
  uint64_t v41;
  __CFError *v42;
  CFIndex v43;
  const __CFData *v44;
  const __CFData *v45;
  const __CFData *v46;
  const __CFData *v47;
  const __CFDictionary *v48;
  const __CFDictionary *v49;
  uint64_t v50;
  const __CFArray *v51;
  const void *v52;
  const void *v53;
  void ***v54;
  const UInt8 *v55;
  const UInt8 *v56;
  CFIndex v57;
  char v58;
  int v59;
  CFIndex Count;
  CFIndex v61;
  CFIndex v62;
  const UInt8 *v63;
  const __CFNumber *ValueAtIndex;
  const __CFNumber *v65;
  CFTypeID v66;
  unsigned int v67;
  unint64_t v68;
  NSObject *v70;
  const __CFData *v71;
  __int16 v72;
  CFTypeRef v73;
  CFTypeRef v74;
  CFTypeRef v75;
  uint64_t v76;
  void *v77;
  unsigned __int8 v78;
  uint64_t v79;
  const void *v80;
  const __CFArray *v81;
  __CFDictionary *v82;
  const void *v83;
  const __CFData *v85;
  const __CFData *v86;
  const __CFDictionary *v87;
  uint64_t v88;
  BOOL v89;
  const UInt8 *v90;
  int v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  CFTypeRef cf2;
  CFTypeRef v96;
  CFTypeRef v97;
  CFTypeRef v98;
  CFTypeRef cf;
  uint64_t v100;
  const void *v101;
  void **valuePtr;
  uint64_t p_valuePtr;
  uint64_t v104;
  void *v105;
  uint64_t *v106;
  __int128 *v107;
  uint64_t *v108;
  uint64_t *v109;
  uint64_t *v110;
  uint64_t v111;
  _QWORD *v112;
  uint64_t v113;
  uint64_t *v114;
  uint64_t v115;
  CFIndex Length;
  uint64_t v117;
  uint64_t *v118;
  uint64_t v119;
  const UInt8 *BytePtr;
  uint64_t v121;
  uint64_t *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t *v126;
  uint64_t v127;
  char v128;
  uint8_t v129[4];
  uint64_t v130;
  __int128 buf;
  void *v132;
  void *v133;
  uint64_t *v134;
  uint64_t *v135;
  void ***v136;
  uint64_t *v137;
  const __CFData *v138;
  _QWORD *v139;
  _QWORD *v140;
  __int128 v141;
  uint64_t v142;
  uint64_t v143;
  CFRange v144;
  CFRange v145;

  v2 = a1;
  Value = 0;
  if (!a2)
    goto LABEL_162;
  v5 = *(__SecCertificate **)(a1 + 40);
  v4 = *(_QWORD *)(a1 + 48);
  if (!v5 || v4 == 0)
    goto LABEL_162;
  v7 = a2;
  v8 = SecCertificateCopySHA256Digest(v4);
  if (!v8)
  {
    Value = 0;
    goto LABEL_162;
  }
  v9 = (const __CFData *)v8;
  v10 = *v7;
  cf2 = (CFTypeRef)v8;
  if (!*v7 || !*(_QWORD *)(v10 + 32) || !*(_QWORD *)(v10 + 24))
    goto LABEL_29;
  v11 = v2;
  v12 = (const __CFData *)SecCertificateCopySHA256Digest(v5);
  v13 = (const void *)sub_100018A90(v12, v9);
  os_unfair_lock_lock((os_unfair_lock_t)(v10 + 40));
  v14 = *(const __CFArray **)(v10 + 24);
  v144.length = CFArrayGetCount(v14);
  v144.location = 0;
  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v14, v144, v13);
  if (FirstIndexOfValue < 0)
  {
    Value = 0;
    goto LABEL_23;
  }
  v16 = FirstIndexOfValue;
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v10 + 32), v13);
  v17 = (const __CFData *)*((_QWORD *)Value + 3);
  if (v12 && v17)
  {
    if (!CFEqual(v17, v12))
      goto LABEL_20;
  }
  else if (v17 != v12)
  {
    goto LABEL_20;
  }
  v18 = (const void *)*((_QWORD *)Value + 4);
  if (!v18 || !CFEqual(v18, cf2))
  {
LABEL_20:
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v10 + 24), v16);
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v10 + 32), v13);
    v19 = sub_100011628("validcache");
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 134217984;
      *(_QWORD *)((char *)&buf + 4) = v16;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "found a bad valid info cache entry at %ld", (uint8_t *)&buf, 0xCu);
    }
    goto LABEL_22;
  }
  CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v10 + 24), v16);
  CFArrayAppendValue(*(CFMutableArrayRef *)(v10 + 24), v13);
LABEL_22:
  CFRetain(Value);
LABEL_23:
  os_unfair_lock_unlock((os_unfair_lock_t)(v10 + 40));
  if (v12)
    CFRelease(v12);
  if (v13)
    CFRelease(v13);
  v2 = v11;
  v9 = (const __CFData *)cf2;
  if (Value)
  {
    v20 = cf2;
LABEL_161:
    CFRelease(v20);
    goto LABEL_162;
  }
LABEL_29:
  v100 = 0;
  v101 = 0;
  v98 = 0;
  cf = 0;
  v96 = 0;
  v97 = 0;
  v21 = SecCertificateCopySerialNumberData(v5, 0);
  if (!v21)
  {
    Value = 0;
    v22 = 0;
    goto LABEL_138;
  }
  v22 = (const __CFData *)SecCertificateCopySHA256Digest(v5);
  if (!v22)
    goto LABEL_136;
  v23 = sub_10001ABF0(v7, v9, &v101);
  if (v23 < 1)
    goto LABEL_136;
  v24 = v23;
  v25 = sub_10001B964((uint64_t)v7, v23, (uint64_t)&v100, (uint64_t)&cf, (uint64_t)&v96, &v101);
  v93 = v24;
  Value = 0;
  switch(v25)
  {
    case 0:
      goto LABEL_138;
    case 1:
      v91 = v25;
      v125 = 0;
      v126 = &v125;
      v127 = 0x2000000000;
      v128 = 0;
      v121 = 0;
      v122 = &v121;
      v123 = 0x2000000000;
      LOBYTE(v124) = 1;
      *(_QWORD *)&v141 = 0;
      *((_QWORD *)&v141 + 1) = &v141;
      v142 = 0x2000000000;
      v143 = 0;
      v117 = 0;
      v118 = &v117;
      v119 = 0x2000000000;
      BytePtr = (const UInt8 *)0xAAAAAAAAAAAAAAAALL;
      BytePtr = CFDataGetBytePtr(v21);
      v113 = 0;
      v114 = &v113;
      v115 = 0x2000000000;
      Length = 0xAAAAAAAAAAAAAAAALL;
      Length = CFDataGetLength(v21);
      if (v118[3] && v114[3])
      {
        v26 = v7[1];
        *(_QWORD *)&buf = _NSConcreteStackBlock;
        *((_QWORD *)&buf + 1) = 0x40000000;
        v132 = sub_10001B5E4;
        v133 = &unk_100078C28;
        v134 = &v121;
        v135 = (uint64_t *)&v141;
        v136 = (void ***)&v117;
        v137 = &v113;
        v139 = (_QWORD *)v24;
        v140 = v7;
        v138 = (const __CFData *)&v125;
        v27 = sub_10001979C(v26, CFSTR("SELECT rowid FROM serials WHERE groupid=? AND serial=?"), (CFTypeRef *)(*((_QWORD *)&v141 + 1) + 24), (uint64_t)&buf);
        v28 = *((_BYTE *)v122 + 24) ? v27 : 0;
        *((_BYTE *)v122 + 24) = v28;
        if (!*((_BYTE *)v126 + 24) && (unint64_t)v114[3] >= 2 && !*(_BYTE *)v118[3])
        {
          v29 = v7[1];
          valuePtr = _NSConcreteStackBlock;
          p_valuePtr = 0x40000000;
          v104 = (uint64_t)sub_100050F48;
          v105 = &unk_100078C78;
          v106 = &v121;
          v107 = &v141;
          v108 = &v117;
          v109 = &v113;
          v111 = v24;
          v112 = v7;
          v110 = &v125;
          v30 = sub_10001979C(v29, CFSTR("SELECT rowid FROM serials WHERE groupid=? AND serial=?"), (CFTypeRef *)(*((_QWORD *)&v141 + 1) + 24), (uint64_t)&valuePtr);
          if (*((_BYTE *)v122 + 24))
            v31 = v30;
          else
            v31 = 0;
          *((_BYTE *)v122 + 24) = v31;
        }
      }
      if (!*((_BYTE *)v122 + 24) || *(_QWORD *)(*((_QWORD *)&v141 + 1) + 24))
      {
        v32 = sub_100011628("SecError");
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
        {
          v33 = *(_QWORD *)(*((_QWORD *)&v141 + 1) + 24);
          *(_DWORD *)v129 = 138412290;
          v130 = v33;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbSerialInGroup failed: %@", v129, 0xCu);
        }
        v34 = *(__CFError **)(*((_QWORD *)&v141 + 1) + 24);
        if (v34)
          Code = CFErrorGetCode(v34);
        else
          Code = -2070;
        sub_1000521A8(1, 3, Code);
        v52 = *(const void **)(*((_QWORD *)&v141 + 1) + 24);
        if (v52)
        {
          if (v101)
            CFRelease(v52);
          else
            v101 = *(const void **)(*((_QWORD *)&v141 + 1) + 24);
        }
      }
      v94 = v2;
      v36 = (uint64_t)v7;
      v92 = (uint64_t)v5;
      v89 = *((_BYTE *)v126 + 24) != 0;
      _Block_object_dispose(&v113, 8);
      _Block_object_dispose(&v117, 8);
      _Block_object_dispose(&v141, 8);
      _Block_object_dispose(&v121, 8);
      v54 = (void ***)&v125;
      goto LABEL_89;
    case 2:
      v91 = v25;
      valuePtr = 0;
      p_valuePtr = (uint64_t)&valuePtr;
      v104 = 0x2000000000;
      LOBYTE(v105) = 0;
      v125 = 0;
      v126 = &v125;
      v127 = 0x2000000000;
      v128 = 1;
      v121 = 0;
      v122 = &v121;
      v123 = 0x2000000000;
      v124 = 0;
      if (CFDataGetLength(v22) <= 0)
      {
        v39 = *((unsigned __int8 *)v126 + 24);
      }
      else
      {
        v37 = v7[1];
        *(_QWORD *)&buf = _NSConcreteStackBlock;
        *((_QWORD *)&buf + 1) = 0x40000000;
        v132 = sub_10005108C;
        v133 = &unk_100078CC8;
        v134 = &v125;
        v135 = &v121;
        v138 = v22;
        v139 = v7;
        v136 = &valuePtr;
        v137 = (uint64_t *)v24;
        v38 = sub_10001979C(v37, CFSTR("SELECT rowid FROM hashes WHERE groupid=? AND sha256=?"), (CFTypeRef *)v122 + 3, (uint64_t)&buf);
        if (*((_BYTE *)v126 + 24))
          v39 = v38;
        else
          v39 = 0;
        *((_BYTE *)v126 + 24) = v39;
      }
      if (!v39 || v122[3])
      {
        v40 = sub_100011628("SecError");
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
        {
          v41 = v122[3];
          LODWORD(v141) = 138412290;
          *(_QWORD *)((char *)&v141 + 4) = v41;
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbCertHashInGroup failed: %@", (uint8_t *)&v141, 0xCu);
        }
        v42 = (__CFError *)v122[3];
        if (v42)
          v43 = CFErrorGetCode(v42);
        else
          v43 = -2070;
        sub_1000521A8(1, 3, v43);
        v53 = (const void *)v122[3];
        if (v53)
        {
          if (v101)
            CFRelease(v53);
          else
            v101 = (const void *)v122[3];
        }
      }
      v94 = v2;
      v36 = (uint64_t)v7;
      v92 = (uint64_t)v5;
      v89 = *(_BYTE *)(p_valuePtr + 24) != 0;
      _Block_object_dispose(&v121, 8);
      _Block_object_dispose(&v125, 8);
      v54 = &valuePtr;
LABEL_89:
      _Block_object_dispose(v54, 8);
      goto LABEL_121;
    case 3:
      v91 = v25;
      v44 = (const __CFData *)cf;
      if (cf)
      {
        CFRetain(cf);
        v45 = sub_10004B678(v44);
        if (v45)
          v46 = v45;
        else
          v46 = v44;
        if (v45)
        {
          v47 = v45;
          CFRelease(v44);
          v46 = v47;
        }
      }
      else
      {
        v46 = 0;
      }
      v48 = (const __CFDictionary *)CFPropertyListCreateWithData(kCFAllocatorDefault, v46, 0, 0, 0);
      v49 = v48;
      v87 = v48;
      if (!v48)
      {
        v90 = 0;
        v51 = 0;
LABEL_91:
        v50 = 0;
        goto LABEL_94;
      }
      v50 = (uint64_t)CFDictionaryGetValue(v48, CFSTR("xor"));
      v51 = (const __CFArray *)CFDictionaryGetValue(v49, CFSTR("params"));
      if (!v50)
      {
        LODWORD(v49) = 0;
        v90 = 0;
        goto LABEL_94;
      }
      v90 = CFDataGetBytePtr((CFDataRef)v50);
      if (!v90)
      {
        LODWORD(v49) = 0;
        v90 = 0;
        goto LABEL_91;
      }
      if (CFDataGetLength((CFDataRef)v50) < 1)
        v50 = 0;
      else
        v50 = CFDataGetLength((CFDataRef)v50);
      LODWORD(v49) = 1;
LABEL_94:
      v92 = (uint64_t)v5;
      v55 = CFDataGetBytePtr(v21);
      v94 = v2;
      if (v55)
      {
        v56 = v55;
        v57 = CFDataGetLength(v21);
        v58 = 0;
        if (v50 > 0)
          v59 = (int)v49;
        else
          v59 = 0;
        if (v59 == 1)
        {
          v88 = v57;
          if (v51)
          {
            Count = CFArrayGetCount(v51);
            if (Count < 1)
            {
              v58 = 1;
            }
            else
            {
              v61 = Count;
              v85 = v46;
              v86 = v22;
              v62 = 0;
              v63 = v56 - 1;
              do
              {
                LODWORD(valuePtr) = -1431655766;
                ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v51, v62);
                if (ValueAtIndex
                  && (v65 = ValueAtIndex, v66 = CFGetTypeID(ValueAtIndex), v66 == CFNumberGetTypeID())
                  && CFNumberGetValue(v65, kCFNumberSInt32Type, &valuePtr)
                  && (valuePtr & 0x80000000) == 0)
                {
                  v67 = valuePtr ^ 0x811C9DC5;
                  v68 = v88;
                  if (v88 >= 1)
                  {
                    do
                      v67 = 16777619 * (v67 ^ v63[v68]);
                    while (v68-- > 1);
                  }
                  if (((v90[(v67 % (unint64_t)(8 * v50)) >> 3] >> ((v67 % (unint64_t)(8 * v50)) & 7)) & 1) == 0)
                  {
                    v58 = 0;
                    goto LABEL_115;
                  }
                }
                else
                {
                  v70 = sub_100011628("validupdate");
                  if (os_log_type_enabled(v70, OS_LOG_TYPE_DEBUG))
                  {
                    LODWORD(buf) = 134217984;
                    *(_QWORD *)((char *)&buf + 4) = v62;
                    _os_log_debug_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEBUG, "error processing filter params at index %ld", (uint8_t *)&buf, 0xCu);
                  }
                }
                ++v62;
              }
              while (v62 != v61);
              v58 = 1;
LABEL_115:
              v22 = v86;
              v46 = v85;
            }
          }
        }
      }
      else
      {
        v58 = 0;
      }
      v89 = v58;
      if (v87)
        CFRelease(v87);
      v9 = (const __CFData *)cf2;
      v24 = v93;
      v36 = (uint64_t)v7;
      if (v46)
        CFRelease(v46);
LABEL_121:
      v71 = v21;
      v72 = v100;
      if ((v100 & 0x80) != 0)
      {
        sub_10004B940(v36, v24, &v98, &v97, &v101);
        v72 = v100;
      }
      v74 = v97;
      v73 = v98;
      v75 = v96;
      v76 = sub_10001BABC();
      Value = (const void *)_CFRuntimeCreateInstance(kCFAllocatorDefault, v76, 80, 0);
      if (Value)
      {
        CFRetain(v22);
        CFRetain(v9);
        if (v73)
          CFRetain(v73);
        if (v74)
          CFRetain(v74);
        if (v75)
          CFRetain(v75);
        *((_DWORD *)Value + 4) = v91;
        *((_QWORD *)Value + 3) = v22;
        *((_QWORD *)Value + 4) = v9;
        *((_QWORD *)Value + 5) = 0;
        *((_BYTE *)Value + 48) = v89;
        *((_BYTE *)Value + 49) = (v72 & 0x10) != 0;
        *((_BYTE *)Value + 50) = v72 & 1;
        *((_BYTE *)Value + 51) = (v72 & 2) != 0;
        *((_BYTE *)Value + 52) = (v72 & 4) != 0;
        *((_BYTE *)Value + 53) = (v72 & 8) != 0;
        *((_BYTE *)Value + 54) = (v72 & 0x400) != 0;
        *((_BYTE *)Value + 55) = (v72 & 0x40) != 0;
        *((_BYTE *)Value + 56) = (v72 & 0x80) != 0;
        *((_BYTE *)Value + 57) = HIBYTE(v72) & 1;
        *((_BYTE *)Value + 58) = (v72 & 0x200) != 0;
        *((_QWORD *)Value + 8) = v73;
        *((_QWORD *)Value + 9) = v74;
        *((_QWORD *)Value + 10) = 0;
        *((_QWORD *)Value + 11) = v75;
        v21 = v71;
        v7 = (_QWORD *)v36;
        v2 = v94;
        if ((sub_100016B34(v92, 0) & 1) != 0)
          goto LABEL_135;
        v77 = (void *)SecCertificateCopySHA256Digest(v92);
        v78 = sub_10001B464(v77);
        if (v77)
          CFRelease(v77);
        if ((v78 & 1) != 0 || sub_10001B464(v9))
        {
LABEL_135:
          CFRelease(Value);
LABEL_136:
          Value = 0;
        }
      }
      else
      {
        v21 = v71;
        v7 = (_QWORD *)v36;
        v2 = v94;
      }
LABEL_138:
      v20 = v101;
      if (cf)
        CFRelease(cf);
      if (v22)
        CFRelease(v22);
      if (v21)
        CFRelease(v21);
      if (v98)
        CFRelease(v98);
      if (v97)
        CFRelease(v97);
      if (v96)
        CFRelease(v96);
      if (Value)
      {
        v79 = *v7;
        if (*v7)
        {
          if (*(_QWORD *)(v79 + 32) && *(_QWORD *)(v79 + 24))
          {
            v80 = (const void *)sub_100018A90(*((CFDataRef *)Value + 3), *((const __CFData **)Value + 4));
            os_unfair_lock_lock((os_unfair_lock_t)(v79 + 40));
            v81 = *(const __CFArray **)(v79 + 24);
            v145.length = CFArrayGetCount(v81);
            v145.location = 0;
            if (CFArrayGetFirstIndexOfValue(v81, v145, v80) < 0)
            {
              CFDictionaryAddValue(*(CFMutableDictionaryRef *)(v79 + 32), v80, Value);
              if (CFArrayGetCount(*(CFArrayRef *)(v79 + 24)) >= 100)
              {
                v82 = *(__CFDictionary **)(v79 + 32);
                v83 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v79 + 24), 0);
                CFDictionaryRemoveValue(v82, v83);
                CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v79 + 24), 0);
              }
              CFArrayAppendValue(*(CFMutableArrayRef *)(v79 + 24), v80);
            }
            os_unfair_lock_unlock((os_unfair_lock_t)(v79 + 40));
            if (v80)
              CFRelease(v80);
          }
        }
      }
      CFRelease(cf2);
      if (v20)
        goto LABEL_161;
LABEL_162:
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 32) + 8) + 24) = Value;
      return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 32) + 8) + 24) != 0;
    default:
      v91 = v25;
      v94 = v2;
      v36 = (uint64_t)v7;
      v92 = (uint64_t)v5;
      v89 = 0;
      goto LABEL_121;
  }
}

uint64_t sub_100018A90(CFDataRef theData, const __CFData *a2)
{
  __CFData *MutableCopy;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v6;

  MutableCopy = CFDataCreateMutableCopy(0, 0, theData);
  BytePtr = CFDataGetBytePtr(a2);
  Length = CFDataGetLength(a2);
  CFDataAppendBytes(MutableCopy, BytePtr, Length);
  v6 = SecSHA256DigestCreateFromData(0, MutableCopy);
  if (MutableCopy)
    CFRelease(MutableCopy);
  return v6;
}

_QWORD *sub_100018B0C(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  CFTypeRef cf;

  cf = 0;
  v6 = malloc_type_malloc(0x30uLL, 0x1020040E3B5EC00uLL);
  v7 = v6;
  if (v6)
  {
    *v6 = a1;
    v6[1] = a2;
    v8 = sub_100018BB0((uint64_t)v6, &cf);
    v9 = atomic_load(&qword_100082920);
    v7[2] = v8;
    v7[3] = v9;
    v7[4] = 0;
    *((_BYTE *)v7 + 40) = 0;
    if (cf)
    {
      if (a3 && !*a3)
        *a3 = cf;
      else
        CFRelease(cf);
    }
  }
  return v7;
}

uint64_t sub_100018BB0(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  int v4;
  NSObject *v5;
  uint64_t v6;
  __CFError *v7;
  CFIndex Code;
  const void *v9;
  uint64_t v10;
  _QWORD v12[8];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  CFTypeRef v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  BOOL v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint8_t buf[4];
  uint64_t v26;

  v21 = 0;
  v22 = &v21;
  v23 = 0x2000000000;
  v24 = -1;
  v17 = 0;
  v18 = &v17;
  v19 = 0x2000000000;
  v20 = a1 != 0;
  v13 = 0;
  v14 = &v13;
  v15 = 0x2000000000;
  v16 = 0;
  if (a1)
  {
    v3 = *(_QWORD *)(a1 + 8);
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 0x40000000;
    v12[2] = sub_10001A328;
    v12[3] = &unk_100078D68;
    v12[4] = &v17;
    v12[5] = &v13;
    v12[6] = &v21;
    v12[7] = a1;
    v4 = sub_10001979C(v3, CFSTR("SELECT ival FROM admin WHERE key='version'"), &v16, (uint64_t)v12);
    *((_BYTE *)v18 + 24) = v4;
    if (v4 && !v14[3])
      goto LABEL_16;
  }
  else
  {
    v20 = 0;
  }
  v5 = sub_100011628("SecError");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = v14[3];
    *(_DWORD *)buf = 138412290;
    v26 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbGetVersion failed: %@", buf, 0xCu);
  }
  v7 = (__CFError *)v14[3];
  if (v7)
    Code = CFErrorGetCode(v7);
  else
    Code = -2070;
  sub_1000521A8(1, 3, Code);
  v9 = (const void *)v14[3];
  if (v9)
  {
    if (a2 && !*a2)
      *a2 = v9;
    else
      CFRelease(v9);
  }
LABEL_16:
  v10 = v22[3];
  _Block_object_dispose(&v13, 8);
  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(&v21, 8);
  return v10;
}

BOOL sub_100018D8C(uint64_t *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v4;
  _BOOL4 v5;
  uint64_t *v6;
  _BOOL4 v7;
  const void *v8;
  _BOOL8 v9;
  _QWORD v11[8];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;

  v16 = 0;
  v17 = &v16;
  v18 = 0x2000000000;
  v19 = 0;
  v12 = 0;
  v13 = &v12;
  v14 = 0x2000000000;
  v15 = 1;
  v4 = *a1;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  v11[2] = sub_100017D34;
  v11[3] = &unk_100078668;
  v11[6] = &v12;
  v11[7] = a1;
  v11[4] = a3;
  v11[5] = &v16;
  v5 = sub_1000193B4(v4, (uint64_t)&v19, (uint64_t)v11);
  v6 = v13;
  if (*((_BYTE *)v13 + 24))
    v7 = v5;
  else
    v7 = 0;
  *((_BYTE *)v13 + 24) = v7;
  v8 = (const void *)v17[3];
  if (v8)
  {
    if (a2 && !*a2)
    {
      *a2 = v8;
    }
    else
    {
      CFRelease(v8);
      v6 = v13;
      v7 = *((_BYTE *)v13 + 24) != 0;
    }
  }
  if (v8)
    v9 = 0;
  else
    v9 = v7;
  *((_BYTE *)v6 + 24) = v9;
  _Block_object_dispose(&v12, 8);
  _Block_object_dispose(&v16, 8);
  return v9;
}

void sub_100018E98(uint64_t a1)
{
  const __CFURL *v2;
  const __CFURL *v3;
  const __CFString *v4;
  CFTypeRef *v5;
  uint64_t v6;
  char v7;
  char v8;
  NSObject *v9;
  uint64_t v10;
  __CFError *v11;
  CFIndex Code;
  const void *v13;
  int v14;
  _QWORD v15[6];
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  char v23;
  uint8_t buf[4];
  uint64_t v25;

  if (sub_100015138())
  {
    os_unfair_lock_lock((os_unfair_lock_t)&unk_100082D28);
    if (qword_100082D30)
      goto LABEL_22;
    v2 = sub_10001DC28((uint64_t)CFSTR("ocspcache.sqlite3"));
    if (!v2 || (v3 = v2, v4 = CFURLCopyFileSystemPath(v2, kCFURLPOSIXPathStyle), CFRelease(v3), !v4))
    {
LABEL_21:
      if (!qword_100082D30)
      {
LABEL_23:
        os_unfair_lock_unlock((os_unfair_lock_t)&unk_100082D28);
        return;
      }
LABEL_22:
      (*(void (**)(uint64_t))(a1 + 16))(a1);
      goto LABEL_23;
    }
    v5 = (CFTypeRef *)malloc_type_malloc(8uLL, 0x2004093837F09uLL);
    if (v5)
    {
      v6 = sub_1000275D0(v4, 384, 1, 1, 1, 1, &stru_100076FD8);
      *v5 = (CFTypeRef)v6;
      if (v6)
      {
        v20 = 0;
        v21 = &v20;
        v22 = 0x2000000000;
        v23 = 1;
        v16 = 0;
        v17 = &v16;
        v18 = 0x2000000000;
        v19 = 0;
        v15[0] = _NSConcreteStackBlock;
        v15[1] = 0x40000000;
        v15[2] = sub_10003969C;
        v15[3] = &unk_100077078;
        v15[4] = &v20;
        v15[5] = &v16;
        v7 = sub_100029AF0(v6, &v19, (uint64_t)v15);
        if (*((_BYTE *)v21 + 24))
          v8 = v7;
        else
          v8 = 0;
        *((_BYTE *)v21 + 24) = v8;
        if ((v8 & 1) == 0)
        {
          v9 = sub_100011628("SecError");
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            v10 = v17[3];
            *(_DWORD *)buf = 138412290;
            v25 = v10;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "OCSP table update failed: %@", buf, 0xCu);
          }
          v11 = (__CFError *)v17[3];
          if (v11)
            Code = CFErrorGetCode(v11);
          else
            Code = -2070;
          sub_1000521A8(2, 2, Code);
        }
        v13 = (const void *)v17[3];
        if (v13)
          CFRelease(v13);
        v14 = *((unsigned __int8 *)v21 + 24);
        _Block_object_dispose(&v16, 8);
        _Block_object_dispose(&v20, 8);
        if (v14)
          goto LABEL_20;
        if (*v5)
          CFRelease(*v5);
      }
      free(v5);
      v5 = 0;
    }
LABEL_20:
    qword_100082D30 = (uint64_t)v5;
    CFRelease(v4);
    goto LABEL_21;
  }
}

uint64_t sub_10001910C(uint64_t a1, uint64_t *a2)
{
  uint64_t result;

  result = sub_100019148(a2, *(SecCertificateRef **)(a1 + 40), 0.0);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t sub_100019148(uint64_t *a1, SecCertificateRef *a2, double a3)
{
  uint64_t PublicKeyData;
  uint64_t v7;
  uint64_t v8;
  const void *v9;
  const __CFData *v10;
  const __CFData *v11;
  uint64_t v12;
  BOOL v13;
  BOOL v14;
  NSObject *v15;
  uint64_t v16;
  const void **v17;
  __CFError *v18;
  CFIndex Code;
  const void *v20;
  uint64_t v21;
  _QWORD v23[11];
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  char v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint8_t buf[4];
  uint64_t v37;

  v32 = 0;
  v33 = &v32;
  v34 = 0x2000000000;
  v35 = 0;
  v28 = 0;
  v29 = &v28;
  v30 = 0x2000000000;
  v31 = 0;
  v24 = 0;
  v25 = &v24;
  v26 = 0x2000000000;
  v27 = 1;
  PublicKeyData = SecCertificateGetPublicKeyData(a2[1]);
  if (PublicKeyData)
  {
    v7 = PublicKeyData;
    v8 = SecCertificateCopyIssuerSequence(*a2);
    if (v8)
    {
      v9 = (const void *)v8;
      v10 = SecCertificateCopySerialNumberData(*a2, 0);
      if (v10)
      {
        v11 = v10;
        if (CFDataGetLength(v10) >= 1 && *(_QWORD *)(v7 + 8) <= 0x7FFFFFFFFFFFFFFEuLL)
        {
          v12 = *a1;
          v23[0] = _NSConcreteStackBlock;
          v23[1] = 0x40000000;
          v23[2] = sub_1000196E8;
          v23[3] = &unk_100077250;
          v23[4] = &v24;
          v23[5] = &v28;
          v23[8] = v9;
          v23[9] = v7;
          *(double *)&v23[10] = a3;
          v23[6] = &v32;
          v23[7] = v11;
          v13 = sub_1000193B4(v12, (uint64_t)(v29 + 3), (uint64_t)v23);
          if (*((_BYTE *)v25 + 24))
            v14 = v13;
          else
            v14 = 0;
          *((_BYTE *)v25 + 24) = v14;
        }
        CFRelease(v11);
      }
      CFRelease(v9);
    }
  }
  if (!*((_BYTE *)v25 + 24) || v29[3])
  {
    v15 = sub_100011628("SecError");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v16 = v29[3];
      *(_DWORD *)buf = 138412290;
      v37 = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "ocsp cache lookup failed: %@", buf, 0xCu);
    }
    v17 = (const void **)v33[3];
    if (v17)
    {
      sub_100008218(v17);
      v33[3] = 0;
    }
    v18 = (__CFError *)v29[3];
    if (v18)
      Code = CFErrorGetCode(v18);
    else
      Code = -2070;
    sub_1000521A8(2, 3, Code);
    v20 = (const void *)v29[3];
    if (v20)
      CFRelease(v20);
  }
  v21 = v33[3];
  _Block_object_dispose(&v24, 8);
  _Block_object_dispose(&v28, 8);
  _Block_object_dispose(&v32, 8);
  return v21;
}

BOOL sub_1000193B4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v6;

  v6 = 0;
  sub_1000194AC(a1, 1, &v6, a2);
  v4 = v6;
  if (v6)
  {
    (*(void (**)(uint64_t, uint64_t))(a3 + 16))(a3, v6);
    sub_100019414(v4);
  }
  return v4 != 0;
}

void sub_100019414(uint64_t a1)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  _QWORD block[6];
  char v6;

  v2 = *(_QWORD *)(a1 + 16);
  v3 = *(unsigned __int8 *)(a1 + 24);
  v4 = *(NSObject **)(v2 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100017470;
  block[3] = &unk_1000760B0;
  block[4] = a1;
  block[5] = v2;
  v6 = v3;
  dispatch_sync(v4, block);
  if (v3)
    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v2 + 120));
  else
    pthread_mutex_unlock((pthread_mutex_t *)(v2 + 56));
  CFRelease((CFTypeRef)a1);
  CFRelease((CFTypeRef)v2);
}

void sub_1000194AC(uint64_t a1, int a2, _QWORD *a3, uint64_t a4)
{
  NSObject *v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;
  char v12;
  const void *v13;
  uint64_t v14;
  NSObject *v15;
  _QWORD v16[7];
  char v17;
  _QWORD block[11];
  char v19;
  _QWORD v20[2];
  BOOL (*v21)(uint64_t, uint64_t);
  void *v22;
  uint64_t *v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  char v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  char v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;

  CFRetain((CFTypeRef)a1);
  if (a2)
    dispatch_semaphore_wait(*(dispatch_semaphore_t *)(a1 + 120), 0xFFFFFFFFFFFFFFFFLL);
  else
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
  v33 = 0;
  v34 = &v33;
  v35 = 0x2000000000;
  v36 = 0;
  v29 = 0;
  v30 = &v29;
  v31 = 0x2000000000;
  v32 = 1;
  v25 = 0;
  v26 = &v25;
  v27 = 0x2000000000;
  v28 = 0;
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 0x40000000;
  v21 = sub_10001C060;
  v22 = &unk_100076040;
  v23 = &v33;
  v24 = a3;
  v8 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_10001BB80;
  block[3] = &unk_100076068;
  block[8] = a1;
  block[9] = a3;
  block[10] = a4;
  v19 = a2;
  block[6] = &v25;
  block[7] = &v33;
  block[4] = v20;
  block[5] = &v29;
  dispatch_sync(v8, block);
  v9 = v34;
  if (*((_BYTE *)v30 + 24))
  {
    if (!v34[3])
    {
      v17 = 0;
      v10 = sub_100028E0C(a1, a2);
      v11 = ((uint64_t (*)(_QWORD *, uint64_t))v21)(v20, v10);
      v9 = v34;
      if (v11)
      {
        v12 = sub_100028F04(v34[3], (uint64_t)&v17, a4);
        v9 = v34;
        if ((v12 & 1) == 0)
        {
          v13 = (const void *)v34[3];
          if (v13)
          {
            v34[3] = 0;
            CFRelease(v13);
            v9 = v34;
          }
        }
      }
    }
  }
  v14 = v9[3];
  if (v14 && !*((_BYTE *)v26 + 24) && *(_QWORD *)(*(_QWORD *)(v14 + 16) + 136) && !*(_BYTE *)(v14 + 24))
  {
    v15 = *(NSObject **)(a1 + 24);
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 0x40000000;
    v16[2] = sub_100028FC4;
    v16[3] = &unk_100076090;
    v16[4] = &v33;
    v16[5] = a1;
    v16[6] = a4;
    dispatch_sync(v15, v16);
    v9 = v34;
  }
  if (a3)
    *a3 = v9[3];
  if (!v9[3])
  {
    if (a2)
      dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 120));
    else
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
    CFRelease((CFTypeRef)a1);
  }
  _Block_object_dispose(&v25, 8);
  _Block_object_dispose(&v29, 8);
  _Block_object_dispose(&v33, 8);
}

unint64_t sub_1000196E8(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  CFTypeRef *v7;
  unint64_t result;
  uint64_t v9;
  char v10;
  _QWORD v11[5];
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;

  v11[0] = _NSConcreteStackBlock;
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(_QWORD *)(a1 + 56);
  v5 = *(_QWORD *)(a1 + 80);
  v6 = *(_OWORD *)(a1 + 40);
  v7 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  v11[1] = 0x40000000;
  v11[2] = sub_100019C10;
  v11[3] = &unk_100077228;
  v11[4] = v3;
  v13 = v4;
  v14 = a2;
  v15 = *(_OWORD *)(a1 + 64);
  v16 = v5;
  v12 = v6;
  result = sub_10001979C(a2, CFSTR("SELECT DISTINCT hashAlgorithm FROM ocsp WHERE serialNum=?"), v7, (uint64_t)v11);
  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v9 + 24))
    v10 = result;
  else
    v10 = 0;
  *(_BYTE *)(v9 + 24) = v10;
  return result;
}

unint64_t sub_10001979C(uint64_t a1, const __CFString *cf, CFTypeRef *a3, uint64_t a4)
{
  const __CFString *v6;
  unint64_t v8;
  int v9;
  CFStringRef v11;

  v6 = cf;
  CFRetain(cf);
  v8 = 1;
  if (v6)
  {
    do
    {
      v11 = 0;
      if ((v8 & 1) != 0)
      {
        v8 = (unint64_t)sub_1000198FC(a1, v6, &v11, a3);
        if (v8)
        {
          if (a4)
          {
            v9 = (*(uint64_t (**)(uint64_t, unint64_t))(a4 + 16))(a4, v8);
          }
          else
          {
            sub_100012C88(-50, (__CFString **)a3, CFSTR("SecDbWithSQL perform block missing"));
            v9 = 0;
          }
          v8 = v9 & sub_100019898((sqlite3_stmt *)v8, a3);
        }
      }
      else
      {
        sub_10001BB38(1, a3, CFSTR("Error with unexecuted sql remaining %@"), v6);
        v8 = 0;
      }
      CFRelease(v6);
      v6 = v11;
    }
    while (v11);
  }
  return v8;
}

BOOL sub_100019898(sqlite3_stmt *a1, CFTypeRef *a2)
{
  sqlite3 *v4;
  uint64_t v5;

  v4 = sqlite3_db_handle(a1);
  v5 = sqlite3_finalize(a1);
  return !(_DWORD)v5 || sub_1000271E8(v5, v4, a2, CFSTR("finalize: %p"), a1);
}

sqlite3_stmt *sub_1000198FC(uint64_t a1, const __CFString *a2, CFStringRef *a3, CFTypeRef *a4)
{
  sqlite3_stmt *v7;
  const __CFAllocator *v8;
  CFStringRef v9;
  CFStringRef v10;
  CFRange v12;
  _QWORD v13[8];
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;

  v12.location = 0;
  v12.length = 0;
  v14 = 0;
  v15 = &v14;
  v16 = 0x2000000000;
  v17 = 0;
  if (a2)
  {
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000;
    v13[2] = sub_100019B14;
    v13[3] = &unk_1000762C8;
    v13[4] = &v14;
    v13[5] = a1;
    v13[6] = a4;
    v13[7] = &v12;
    sub_100019A20(a2, (uint64_t)v13);
    v7 = (sqlite3_stmt *)v15[3];
  }
  else
  {
    v7 = 0;
  }
  _Block_object_dispose(&v14, 8);
  if (v12.length >= 1)
  {
    v8 = CFGetAllocator(a2);
    v9 = CFStringCreateWithSubstring(v8, a2, v12);
    v10 = v9;
    if (a3)
    {
      *a3 = v9;
    }
    else
    {
      sub_10001BB38(2, a4, CFSTR("prepare_v2: %@ unused sql: %@"), a2, v9);
      if (v10)
        CFRelease(v10);
      sub_100019898(v7, a4);
      return 0;
    }
  }
  return v7;
}

void sub_100019A20(const __CFString *a1, uint64_t a2)
{
  const char *CStringPtr;
  const char *v5;
  size_t v6;
  CFIndex Length;
  _QWORD v8[9];
  CFIndex usedBufLen;
  CFRange v10;

  CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
  if (CStringPtr)
  {
    v5 = CStringPtr;
    v6 = strlen(CStringPtr);
    (*(void (**)(uint64_t, const char *, size_t))(a2 + 16))(a2, v5, v6);
  }
  else
  {
    usedBufLen = 0;
    Length = CFStringGetLength(a1);
    v10.location = 0;
    v10.length = Length;
    CFStringGetBytes(a1, v10, 0x8000100u, 0, 0, 0, 0, &usedBufLen);
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 0x40000000;
    v8[2] = sub_100026BC0;
    v8[3] = &unk_100075DA8;
    v8[6] = 0;
    v8[7] = Length;
    v8[8] = usedBufLen;
    v8[4] = a2;
    v8[5] = a1;
    sub_10002B920(usedBufLen + 1, (uint64_t)v8);
  }
}

uint64_t sub_100019B14(_QWORD *a1, char *zSql, unint64_t nByte)
{
  CFTypeRef *v6;
  uint64_t v7;
  sqlite3 *v8;
  uint64_t result;
  sqlite3_stmt *v10;
  int i;
  _QWORD *v12;
  uint64_t v13;
  char *v15;
  sqlite3_stmt *ppStmt;

  v15 = 0;
  v7 = a1[5];
  v6 = (CFTypeRef *)a1[6];
  v8 = *(sqlite3 **)(v7 + 64);
  if (nByte >> 31)
  {
    result = sub_1000271E8(18, *(sqlite3 **)(v7 + 64), v6, CFSTR("prepare_v2: sql bigger than INT_MAX"));
LABEL_3:
    v10 = 0;
  }
  else
  {
    for (i = 0; ; ++i)
    {
      ppStmt = 0;
      result = sqlite3_prepare_v2(v8, zSql, nByte, &ppStmt, (const char **)&v15);
      if (!(_DWORD)result)
        break;
      result = sub_100027ACC(v7, result, (uint64_t)CFSTR("preparev2"), i, v6);
      if ((result & 1) == 0)
        goto LABEL_3;
    }
    v10 = ppStmt;
  }
  *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = v10;
  v12 = (_QWORD *)a1[7];
  if (v12)
  {
    v13 = v15 - zSql;
    if (v15 > zSql && v15 < &zSql[nByte])
    {
      *v12 = v13;
      v12[1] = nByte - v13;
    }
  }
  return result;
}

uint64_t sub_100019C10(uint64_t a1, sqlite3_stmt *a2)
{
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  CFTypeRef *v11;
  char v12;
  uint64_t v13;
  char v14;
  _QWORD v16[5];
  __int128 v17;
  sqlite3_stmt *v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 56));
  Length = CFDataGetLength(*(CFDataRef *)(a1 + 56));
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = sub_10001A8F8(a2, 1, BytePtr, Length, (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8)+ 24));
  v16[0] = _NSConcreteStackBlock;
  v6 = *(_QWORD *)(a1 + 32);
  v7 = *(_QWORD *)(a1 + 88);
  v9 = *(_QWORD *)(a1 + 56);
  v8 = *(_QWORD *)(a1 + 64);
  v10 = *(_OWORD *)(a1 + 40);
  v11 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  v16[1] = 0x40000000;
  v16[2] = sub_10001AA60;
  v16[3] = &unk_100077200;
  v18 = a2;
  v19 = *(_OWORD *)(a1 + 72);
  v16[4] = v6;
  v20 = v8;
  v21 = v7;
  v22 = v9;
  v17 = v10;
  v12 = sub_100019D18(v8, a2, v11, (uint64_t)v16);
  v13 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v13 + 24))
    v14 = v12;
  else
    v14 = 0;
  *(_BYTE *)(v13 + 24) = v14;
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

uint64_t sub_100019D18(uint64_t a1, sqlite3_stmt *a2, CFTypeRef *a3, uint64_t a4)
{
  uint64_t result;
  _QWORD *v9;
  void *v10;
  _QWORD v11[2];
  uint64_t (*v12)(uint64_t);
  void *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  char v19;

  while (1)
  {
    while (1)
    {
      result = sub_100019E48(a1, a2, (uint64_t)a3);
      if ((_DWORD)result == 1)
        break;
      if (!(_DWORD)result)
        return result;
      if ((_DWORD)result == 2)
        return 1;
    }
    if (!a4)
      break;
    v16 = 0;
    v17 = &v16;
    v18 = 0x2000000000;
    v19 = 0;
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000;
    v12 = sub_100019FA0;
    v13 = &unk_100076018;
    v14 = a4;
    v15 = &v16;
    v9 = v11;
    v10 = objc_autoreleasePoolPush();
    v12((uint64_t)v9);
    objc_autoreleasePoolPop(v10);

    LODWORD(v9) = *((unsigned __int8 *)v17 + 24);
    _Block_object_dispose(&v16, 8);
    if ((_DWORD)v9)
      return 1;
  }
  sub_10001BB38(1, a3, CFSTR("SecDbStep SQLITE_ROW returned without a row handler"));
  return 0;
}

uint64_t sub_100019E48(uint64_t a1, sqlite3_stmt *pStmt, uint64_t a3)
{
  uint64_t v6;
  NSObject *v7;
  const char *v8;
  uint64_t v9;
  char v10;
  uint8_t buf[4];
  const char *v13;

  v6 = 0;
  while (1)
  {
    if (*(_BYTE *)(a1 + 24) && !sqlite3_stmt_readonly(pStmt))
    {
      v7 = sub_100011628("SecError");
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        v8 = sqlite3_sql(pStmt);
        *(_DWORD *)buf = 136315138;
        v13 = v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "_SecDbStep: SecDbConnection is readonly but we're about to write: %s", buf, 0xCu);
      }
    }
    v9 = sqlite3_step(pStmt);
    if ((_DWORD)v9 == 100)
      return 1;
    if ((_DWORD)v9 == 101)
      break;
    v10 = sub_100027ACC(a1, v9, CFSTR("step"), v6, a3);
    v6 = (v6 + 1);
    if ((v10 & 1) == 0)
      return 0;
  }
  sqlite3_reset(pStmt);
  return 2;
}

uint64_t sub_100019FA0(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
}

void sub_100019FB8(uint64_t a1)
{
  void *v2;
  const unsigned __int8 *v3;
  void *v4;
  void *v5;
  NSString *v6;
  void *v7;
  const void *v8;
  NSData *v9;
  void *v10;
  void *v11;
  uint64_t v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  const void *v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint8_t buf[4];
  uint64_t v28;
  __int16 v29;
  uint64_t v30;
  _QWORD v31[3];
  _QWORD v32[3];

  v2 = objc_autoreleasePoolPush();
  v3 = sqlite3_column_text(*(sqlite3_stmt **)(a1 + 80), 0);
  if (v3)
  {
    v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v3));
    if (v4)
    {
      v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSRegularExpression regularExpressionWithPattern:options:error:](NSRegularExpression, "regularExpressionWithPattern:options:error:", v4, 1, 0));
      if (v5)
      {
        v6 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", sqlite3_column_text(*(sqlite3_stmt **)(a1 + 80), 1));
        v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
        if (sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 80), 2) >= 1)
        {
          v8 = sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 80), 2);
          v9 = +[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", v8, sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 80), 2));
          v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
          if (v10)
          {
            v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSPropertyListSerialization propertyListWithData:options:format:error:](NSPropertyListSerialization, "propertyListWithData:options:format:error:", v10, 0, 0, 0));
            if (v11)
            {
              v12 = objc_opt_class(NSArray);
              if ((objc_opt_isKindOfClass(v11, v12) & 1) != 0)
              {
                v26 = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 80), 3);
                if (+[SecPinningDb enableInMemoryCache](SecPinningDb, "enableInMemoryCache"))
                {
                  v13 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
                  v31[0] = CFSTR("PinningPolicyName");
                  v31[1] = CFSTR("PinningRules");
                  v32[0] = v7;
                  v32[1] = v11;
                  v31[2] = CFSTR("PinningTransparentConnection");
                  v14 = v4;
                  v15 = v7;
                  v16 = v2;
                  v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v26 > 0));
                  v32[2] = v17;
                  v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v32, v31, 3));
                  objc_msgSend(v13, "setObject:forKey:", v18, v5);

                  v2 = v16;
                  v7 = v15;
                  v4 = v14;
                }
                if (objc_msgSend(v5, "numberOfMatchesInString:options:range:", *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), 0, 0, objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), "length")))
                {
                  v19 = sub_100011628("SecPinningDb");
                  v20 = objc_claimAutoreleasedReturnValue(v19);
                  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
                  {
                    v24 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
                    v25 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40);
                    *(_DWORD *)buf = 138412546;
                    v28 = v24;
                    v29 = 2112;
                    v30 = v25;
                    _os_log_debug_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "found matching rule in DB for %@.%@", buf, 0x16u);
                  }

                  objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 40), "addObjectsFromArray:", v11);
                  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 40), v7);
                  v21 = objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v26 > 0));
                  v22 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8);
                  v23 = *(void **)(v22 + 40);
                  *(_QWORD *)(v22 + 40) = v21;

                }
              }
            }

          }
        }

      }
    }

  }
  objc_autoreleasePoolPop(v2);
}

uint64_t sub_10001A328(_QWORD *a1, sqlite3_stmt *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  _QWORD v9[6];

  v3 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v3 + 24))
  {
    v4 = a1[6];
    v5 = *(_QWORD *)(a1[7] + 8);
    v6 = *(_QWORD *)(a1[5] + 8);
    v9[0] = _NSConcreteStackBlock;
    v9[2] = sub_10001A3C8;
    v9[3] = &unk_100078D40;
    v9[1] = 0x40000000;
    v9[4] = v4;
    v9[5] = a2;
    v7 = sub_100019D18(v5, a2, (CFTypeRef *)(v6 + 24), (uint64_t)v9);
    v3 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v7 = 0;
  }
  *(_BYTE *)(v3 + 24) = v7;
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

sqlite3_int64 sub_10001A3C8(uint64_t a1, _BYTE *a2)
{
  sqlite3_int64 result;

  result = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  *a2 = 1;
  return result;
}

unint64_t sub_10001A408(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  int8x16_t v4;
  CFTypeRef *v5;
  __int128 v6;
  unint64_t result;
  uint64_t v8;
  char v9;
  _QWORD v10[5];
  int8x16_t v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;

  v10[0] = _NSConcreteStackBlock;
  v3 = *(_QWORD *)(a1 + 32);
  v4 = vextq_s8(*(int8x16_t *)(a1 + 40), *(int8x16_t *)(a1 + 40), 8uLL);
  v5 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  v10[1] = 3221225472;
  v10[2] = sub_10001A4C8;
  v10[3] = &unk_100077BB0;
  v10[4] = v3;
  v6 = *(_OWORD *)(a1 + 56);
  v11 = v4;
  v12 = v6;
  v13 = *(_OWORD *)(a1 + 72);
  v14 = *(_QWORD *)(a1 + 88);
  v15 = a2;
  result = sub_10001979C(a2, CFSTR("SELECT DISTINCT labelRegex,policyName,policies,transparentConnection FROM rules WHERE domainSuffix=?"), v5, (uint64_t)v10);
  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v8 + 24))
    v9 = result;
  else
    v9 = 0;
  *(_BYTE *)(v8 + 24) = v9;
  return result;
}

uint64_t sub_10001A4C8(uint64_t a1, sqlite3_stmt *a2)
{
  BOOL v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  CFTypeRef *v8;
  uint64_t v9;
  char v10;
  uint64_t v11;
  char v12;
  _QWORD v14[4];
  __int128 v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;
  sqlite3_stmt *v19;

  v4 = sub_10001A5DC(a2, 1, (const char *)objc_msgSend(objc_retainAutorelease(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40)), "UTF8String"), (unint64_t)objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), "length"), (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24));
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v5 + 24))
    v6 = v4;
  else
    v6 = 0;
  *(_BYTE *)(v5 + 24) = v6;
  v7 = *(_QWORD *)(a1 + 40);
  v8 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  v14[2] = sub_100019FB8;
  v14[3] = &unk_100077B88;
  v15 = *(_OWORD *)(a1 + 56);
  v16 = v7;
  v17 = *(_OWORD *)(a1 + 72);
  v9 = *(_QWORD *)(a1 + 96);
  v18 = *(_QWORD *)(a1 + 88);
  v19 = a2;
  v10 = sub_100019D18(v9, a2, v8, (uint64_t)v14);
  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v11 + 24))
    v12 = v10;
  else
    v12 = 0;
  *(_BYTE *)(v11 + 24) = v12;
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

BOOL sub_10001A5DC(sqlite3_stmt *a1, uint64_t a2, const char *a3, unint64_t a4, CFTypeRef *a5)
{
  uint64_t v9;

  if (a4 >> 31)
    return sub_10001A970(18, a1, a5, CFSTR("bind_text[%d]: text bigger than INT_MAX"), a2);
  v9 = sqlite3_bind_text(a1, a2, a3, a4, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
  return sub_10001A970(v9, a1, a5, CFSTR("bind_text[%d]"), a2);
}

void sub_10001A654(uint64_t a1)
{
  const UInt8 *v2;
  int v3;
  const __CFData *v4;
  sqlite3_int64 v5;

  v2 = (const UInt8 *)sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 40), 0);
  v3 = sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 40), 0);
  v4 = CFDataCreate(kCFAllocatorDefault, v2, v3);
  v5 = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 1);
  if (v4)
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = sub_100008550(v4, v5);
    CFRelease(v4);
  }
}

uint64_t sub_10001A6F0(uint64_t a1, sqlite3_stmt *a2)
{
  CFTypeRef *v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  BOOL v8;
  const UInt8 *BytePtr;
  CFIndex Length;
  BOOL v11;
  uint64_t v12;
  BOOL v13;
  const UInt8 *v14;
  CFIndex v15;
  BOOL v16;
  uint64_t v17;
  BOOL v18;
  const UInt8 *v19;
  CFIndex v20;
  BOOL v21;
  uint64_t v22;
  BOOL v23;
  BOOL v24;
  uint64_t v25;
  BOOL v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  char v32;
  _QWORD v34[6];

  v4 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  v5 = sqlite3_bind_double(a2, 1, *(double *)(a1 + 56));
  v6 = sub_10001A970(v5, a2, v4, CFSTR("bind_double[%d]"), 1);
  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v7 + 24))
    v8 = v6;
  else
    v8 = 0;
  *(_BYTE *)(v7 + 24) = v8;
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 64));
  Length = CFDataGetLength(*(CFDataRef *)(a1 + 64));
  v11 = sub_10001A8F8(a2, 2, BytePtr, Length, (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
  v12 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v12 + 24))
    v13 = v11;
  else
    v13 = 0;
  *(_BYTE *)(v12 + 24) = v13;
  v14 = CFDataGetBytePtr(*(CFDataRef *)(a1 + 72));
  v15 = CFDataGetLength(*(CFDataRef *)(a1 + 72));
  v16 = sub_10001A8F8(a2, 3, v14, v15, (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
  v17 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v17 + 24))
    v18 = v16;
  else
    v18 = 0;
  *(_BYTE *)(v17 + 24) = v18;
  v19 = CFDataGetBytePtr(*(CFDataRef *)(a1 + 80));
  v20 = CFDataGetLength(*(CFDataRef *)(a1 + 80));
  v21 = sub_10001A8F8(a2, 4, v19, v20, (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
  v22 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v22 + 24))
    v23 = v21;
  else
    v23 = 0;
  *(_BYTE *)(v22 + 24) = v23;
  v24 = sub_10001A8F8(a2, 5, *(const void **)(a1 + 96), *(_QWORD *)(a1 + 88), (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
  v25 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v25 + 24))
    v26 = v24;
  else
    v26 = 0;
  *(_BYTE *)(v25 + 24) = v26;
  v27 = *(_QWORD *)(a1 + 48);
  v28 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  v34[0] = _NSConcreteStackBlock;
  v34[2] = sub_10001A654;
  v34[3] = &unk_1000771B0;
  v29 = *(_QWORD *)(a1 + 104);
  v34[1] = 0x40000000;
  v34[4] = v27;
  v34[5] = a2;
  v30 = sub_100019D18(v29, a2, (CFTypeRef *)(v28 + 24), (uint64_t)v34);
  v31 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v31 + 24))
    v32 = v30;
  else
    v32 = 0;
  *(_BYTE *)(v31 + 24) = v32;
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

BOOL sub_10001A8F8(sqlite3_stmt *a1, uint64_t a2, const void *a3, unint64_t a4, CFTypeRef *a5)
{
  uint64_t v9;

  if (a4 >> 31)
    return sub_10001A970(18, a1, a5, CFSTR("bind_blob[%d]: blob bigger than INT_MAX"), a2);
  v9 = sqlite3_bind_blob(a1, a2, a3, a4, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
  return sub_10001A970(v9, a1, a5, CFSTR("bind_blob[%d]"), a2);
}

BOOL sub_10001A970(uint64_t a1, sqlite3_stmt *a2, CFTypeRef *a3, CFStringRef format, ...)
{
  CFStringRef v7;
  sqlite3 *v8;
  const char *v9;
  uint64_t v10;
  const char *v11;
  uint64_t v13;
  va_list va;

  va_start(va, format);
  if ((_DWORD)a1 && a3)
  {
    v7 = CFStringCreateWithFormatAndArguments(kCFAllocatorDefault, 0, format, va);
    v8 = sqlite3_db_handle(a2);
    v9 = sqlite3_sql(a2);
    v10 = sqlite3_extended_errcode(v8);
    v11 = sqlite3_errmsg(v8);
    if ((_DWORD)v10 == (_DWORD)a1)
      sub_10001BB38(a1, a3, CFSTR("%@: [%d] %s sql: %s"), v7, a1, v11, v9, v13, va);
    else
      sub_10001BB38(a1, a3, CFSTR("%@: [%d->%d] %s sql: %s"), v7, a1, v10, v11, v9, va);
    if (v7)
      CFRelease(v7);
  }
  return (_DWORD)a1 == 0;
}

void sub_10001AA60(uint64_t a1)
{
  const UInt8 *BytePtr;
  CFIndex Length;
  const __CFData *v4;
  const __CFData *v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  char v14;
  _QWORD v15[11];
  __int128 v16;
  uint64_t v17;
  __int128 v18;

  if ((sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 56), 0) & 0x80000000) == 0)
  {
    *((_QWORD *)&v18 + 1) = sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 56), 0);
    *(_QWORD *)&v18 = sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 56), 0);
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 64));
    Length = CFDataGetLength(*(CFDataRef *)(a1 + 64));
    v4 = (const __CFData *)SecDigestCreate(kCFAllocatorDefault, &v18, 0, BytePtr, Length);
    v5 = (const __CFData *)SecDigestCreate(kCFAllocatorDefault, &v18, 0, **(_QWORD **)(a1 + 72), *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8));
    if (v4)
    {
      if (CFDataGetLength(v4) >= 1 && v5 != 0 && CFDataGetLength(v5) >= 1)
      {
        v7 = *(_QWORD *)(a1 + 32);
        if (*(_BYTE *)(*(_QWORD *)(v7 + 8) + 24))
        {
          v15[0] = _NSConcreteStackBlock;
          v8 = *(_QWORD *)(a1 + 40);
          v9 = *(_QWORD *)(a1 + 48);
          v10 = *(_QWORD *)(v8 + 8);
          v15[2] = sub_10001A6F0;
          v15[3] = &unk_1000771D8;
          v11 = *(_QWORD *)(a1 + 80);
          v15[1] = 0x40000000;
          v15[7] = *(_QWORD *)(a1 + 88);
          v15[4] = v7;
          v15[5] = v8;
          v15[8] = v4;
          v15[9] = v5;
          v15[10] = *(_QWORD *)(a1 + 96);
          v16 = v18;
          v17 = v11;
          v15[6] = v9;
          v12 = sub_10001979C(v11, CFSTR("SELECT ocspResponse,responseId FROM responses WHERE lastUsed>? AND responseId=(SELECT responseId FROM ocsp WHERE issuerNameHash=? AND issuerPubKeyHash=? AND serialNum=? AND hashAlgorithm=?) ORDER BY expires DESC"), (CFTypeRef *)(v10 + 24), (uint64_t)v15);
          v13 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
          if (*(_BYTE *)(v13 + 24))
            v14 = v12;
          else
            v14 = 0;
          *(_BYTE *)(v13 + 24) = v14;
        }
      }
      CFRelease(v4);
    }
    if (v5)
      CFRelease(v5);
  }
}

uint64_t sub_10001ABF0(_QWORD *a1, CFDataRef theData, _QWORD *a3)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  char v10;
  NSObject *v11;
  CFTypeRef v12;
  __CFError *v13;
  CFIndex Code;
  CFTypeRef v15;
  uint64_t v16;
  _QWORD v18[9];
  uint64_t v19;
  CFTypeRef *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  BOOL v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  uint8_t buf[4];
  CFTypeRef v32;

  v27 = 0;
  v28 = &v27;
  v29 = 0x2000000000;
  v30 = -1;
  v23 = 0;
  v24 = &v23;
  v25 = 0x2000000000;
  v26 = a1 != 0;
  v19 = 0;
  v20 = (CFTypeRef *)&v19;
  v21 = 0x2000000000;
  v22 = 0;
  if (a1 && theData && CFDataGetLength(theData) >= 1)
  {
    v6 = atomic_load(&qword_100082920);
    if (v6 == -1)
      atomic_store(sub_10001AEFC((uint64_t)a1, 0), &qword_100082920);
    v7 = atomic_load(&qword_100082920);
    if (v7 > 6)
    {
      v8 = v24;
      if (*((_BYTE *)v24 + 24))
      {
        v9 = a1[1];
        v18[0] = _NSConcreteStackBlock;
        v18[1] = 0x40000000;
        v18[2] = sub_10001B4F4;
        v18[3] = &unk_100078D18;
        v18[4] = &v23;
        v18[5] = &v19;
        v18[7] = theData;
        v18[8] = a1;
        v18[6] = &v27;
        v10 = sub_10001979C(v9, CFSTR("SELECT DISTINCT groupid FROM issuers WHERE issuer_hash=?"), v20 + 3, (uint64_t)v18);
        v8 = v24;
      }
      else
      {
        v10 = 0;
      }
      *((_BYTE *)v8 + 24) = v10;
    }
    else if (!*(_BYTE *)(*a1 + 17))
    {
      *(_BYTE *)(*a1 + 17) = 1;
    }
  }
  if (!*((_BYTE *)v24 + 24) || v20[3])
  {
    v11 = sub_100011628("SecError");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v12 = v20[3];
      *(_DWORD *)buf = 138412290;
      v32 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbGroupIdForIssuerHash failed: %@", buf, 0xCu);
    }
    v13 = (__CFError *)v20[3];
    if (v13)
      Code = CFErrorGetCode(v13);
    else
      Code = -2070;
    sub_1000521A8(1, 3, Code);
    v15 = v20[3];
    if (v15)
    {
      if (a3 && !*a3)
        *a3 = v15;
      else
        CFRelease(v15);
    }
  }
  v16 = v28[3];
  _Block_object_dispose(&v19, 8);
  _Block_object_dispose(&v23, 8);
  _Block_object_dispose(&v27, 8);
  return v16;
}

uint64_t sub_10001AE5C(_QWORD *a1, sqlite3_stmt *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  _QWORD v9[6];

  v3 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v3 + 24))
  {
    v4 = a1[6];
    v5 = *(_QWORD *)(a1[7] + 8);
    v6 = *(_QWORD *)(a1[5] + 8);
    v9[0] = _NSConcreteStackBlock;
    v9[2] = sub_100047908;
    v9[3] = &unk_1000785C8;
    v9[1] = 0x40000000;
    v9[4] = v4;
    v9[5] = a2;
    v7 = sub_100019D18(v5, a2, (CFTypeRef *)(v6 + 24), (uint64_t)v9);
    v3 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v7 = 0;
  }
  *(_BYTE *)(v3 + 24) = v7;
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

uint64_t sub_10001AEFC(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  int v4;
  NSObject *v5;
  uint64_t v6;
  __CFError *v7;
  CFIndex Code;
  const void *v9;
  uint64_t v10;
  _QWORD v12[8];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  CFTypeRef v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  BOOL v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint8_t buf[4];
  uint64_t v26;

  v21 = 0;
  v22 = &v21;
  v23 = 0x2000000000;
  v24 = -1;
  v17 = 0;
  v18 = &v17;
  v19 = 0x2000000000;
  v20 = a1 != 0;
  v13 = 0;
  v14 = &v13;
  v15 = 0x2000000000;
  v16 = 0;
  if (a1)
  {
    v3 = *(_QWORD *)(a1 + 8);
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 0x40000000;
    v12[2] = sub_10001AE5C;
    v12[3] = &unk_1000785F0;
    v12[4] = &v17;
    v12[5] = &v13;
    v12[6] = &v21;
    v12[7] = a1;
    v4 = sub_10001979C(v3, CFSTR("SELECT ival FROM admin WHERE key='db_version'"), &v16, (uint64_t)v12);
    *((_BYTE *)v18 + 24) = v4;
    if (v4 && !v14[3])
      goto LABEL_16;
  }
  else
  {
    v20 = 0;
  }
  v5 = sub_100011628("SecError");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = v14[3];
    *(_DWORD *)buf = 138412290;
    v26 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbReadSchemaVersionFromDb failed: %@", buf, 0xCu);
  }
  v7 = (__CFError *)v14[3];
  if (v7)
    Code = CFErrorGetCode(v7);
  else
    Code = -2070;
  sub_1000521A8(1, 3, Code);
  v9 = (const void *)v14[3];
  if (v9)
  {
    if (a2 && !*a2)
      *a2 = v9;
    else
      CFRelease(v9);
  }
LABEL_16:
  v10 = v22[3];
  _Block_object_dispose(&v13, 8);
  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(&v21, 8);
  return v10;
}

uint64_t sub_10001B0D8(uint64_t a1, sqlite3_stmt *a2)
{
  BOOL v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  CFTypeRef *v8;
  char v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  _QWORD v14[4];
  id v15;
  __int128 v16;
  sqlite3_stmt *v17;

  v4 = sub_10001A5DC(a2, 1, (const char *)objc_msgSend(objc_retainAutorelease(*(id *)(a1 + 32)), "UTF8String"), (unint64_t)objc_msgSend(*(id *)(a1 + 32), "length"), (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24));
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  if (*(_BYTE *)(v5 + 24))
    v6 = v4;
  else
    v6 = 0;
  *(_BYTE *)(v5 + 24) = v6;
  v7 = *(_QWORD *)(a1 + 72);
  v8 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  v14[2] = sub_10001B2B4;
  v14[3] = &unk_100077C00;
  v15 = *(id *)(a1 + 32);
  v17 = a2;
  v16 = *(_OWORD *)(a1 + 56);
  v9 = sub_100019D18(v7, a2, v8, (uint64_t)v14);
  v10 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  if (*(_BYTE *)(v10 + 24))
    v11 = v9;
  else
    v11 = 0;
  *(_BYTE *)(v10 + 24) = v11;
  v12 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);

  return v12;
}

void sub_10001B1F0(uint64_t a1, uint64_t a2)
{
  CFTypeRef *v4;
  id v5;
  __int128 v6;
  char v7;
  uint64_t v8;
  char v9;
  __int128 v10;
  _QWORD v11[4];
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;

  v4 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  v11[2] = sub_10001B0D8;
  v11[3] = &unk_100077C28;
  v10 = *(_OWORD *)(a1 + 32);
  v5 = (id)v10;
  v6 = *(_OWORD *)(a1 + 48);
  v12 = v10;
  v13 = v6;
  v14 = *(_QWORD *)(a1 + 64);
  v15 = a2;
  v7 = sub_10001979C(a2, CFSTR("SELECT DISTINCT policies,transparentConnection FROM rules WHERE policyName=?"), v4, (uint64_t)v11);
  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  if (*(_BYTE *)(v8 + 24))
    v9 = v7;
  else
    v9 = 0;
  *(_BYTE *)(v8 + 24) = v9;

}

void sub_10001B2B4(uint64_t a1)
{
  void *v2;
  const void *v3;
  NSObject *v4;
  const void *v5;
  NSData *v6;
  void *v7;
  void *v8;
  uint64_t v9;
  NSNumber *v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;

  v2 = objc_autoreleasePoolPush();
  v3 = sub_100011628("SecPinningDb");
  v4 = objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    v14 = *(_QWORD *)(a1 + 32);
    v15 = 138412290;
    v16 = v14;
    _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "found matching rule for %@ policy", (uint8_t *)&v15, 0xCu);
  }

  if ((sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 56), 0) & 0x80000000) == 0)
  {
    v5 = sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 56), 0);
    v6 = +[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", v5, sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 56), 0));
    v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
    if (v7)
    {
      v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSPropertyListSerialization propertyListWithData:options:format:error:](NSPropertyListSerialization, "propertyListWithData:options:format:error:", v7, 0, 0, 0));
      if (v8)
      {
        v9 = objc_opt_class(NSArray);
        if ((objc_opt_isKindOfClass(v8, v9) & 1) != 0)
        {
          objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), "addObjectsFromArray:", v8);
          v10 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", sqlite3_column_int(*(sqlite3_stmt **)(a1 + 56), 1) > 0);
          v11 = objc_claimAutoreleasedReturnValue(v10);
          v12 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
          v13 = *(void **)(v12 + 40);
          *(_QWORD *)(v12 + 40) = v11;

        }
      }

    }
  }
  objc_autoreleasePoolPop(v2);
}

const __CFBoolean *sub_10001B464(void *key)
{
  const __CFBoolean *result;
  const __CFBoolean *v3;
  CFTypeID v4;

  if (qword_100082B28 == -1)
  {
    if (!key)
      return 0;
  }
  else
  {
    dispatch_once(&qword_100082B28, &stru_100076328);
    if (!key)
      return 0;
  }
  result = (const __CFBoolean *)qword_100082B30;
  if (qword_100082B30)
  {
    result = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)qword_100082B30, key);
    if (result)
    {
      v3 = result;
      v4 = CFGetTypeID(result);
      if (v4 == CFBooleanGetTypeID())
        return (const __CFBoolean *)(CFBooleanGetValue(v3) != 0);
      return 0;
    }
  }
  return result;
}

uint64_t sub_10001B4F4(uint64_t a1, sqlite3_stmt *a2)
{
  const UInt8 *BytePtr;
  CFIndex Length;
  BOOL v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  char v14;
  _QWORD v16[6];

  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 56));
  Length = CFDataGetLength(*(CFDataRef *)(a1 + 56));
  v6 = sub_10001A8F8(a2, 1, BytePtr, Length, (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v7 + 24))
    v8 = v6;
  else
    v8 = 0;
  *(_BYTE *)(v7 + 24) = v8;
  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8);
  v10 = *(_QWORD *)(a1 + 48);
  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  v16[0] = _NSConcreteStackBlock;
  v16[2] = sub_10001B720;
  v16[3] = &unk_100078CF0;
  v16[1] = 0x40000000;
  v16[4] = v10;
  v16[5] = a2;
  v12 = sub_100019D18(v9, a2, (CFTypeRef *)(v11 + 24), (uint64_t)v16);
  v13 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v13 + 24))
    v14 = v12;
  else
    v14 = 0;
  *(_BYTE *)(v13 + 24) = v14;
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

uint64_t sub_10001B5E4(_QWORD *a1, sqlite3_stmt *a2)
{
  CFTypeRef *v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  BOOL v8;
  BOOL v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  CFTypeRef *v13;
  char v14;
  uint64_t v15;
  char v16;
  _QWORD v18[6];

  v4 = (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24);
  v5 = sqlite3_bind_int64(a2, 1, a1[9]);
  v6 = sub_10001A970(v5, a2, v4, CFSTR("bind_int64[%d]"), 1);
  v7 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v7 + 24))
    v8 = v6;
  else
    v8 = 0;
  *(_BYTE *)(v7 + 24) = v8;
  v9 = sub_10001A8F8(a2, 2, *(const void **)(*(_QWORD *)(a1[6] + 8) + 24), *(_QWORD *)(*(_QWORD *)(a1[7] + 8) + 24), (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24));
  v10 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v10 + 24))
    v11 = v9;
  else
    v11 = 0;
  *(_BYTE *)(v10 + 24) = v11;
  v12 = *(_QWORD *)(a1[10] + 8);
  v13 = (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24);
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 0x40000000;
  v18[2] = sub_100051238;
  v18[3] = &unk_100078C00;
  v18[4] = a1[8];
  v18[5] = a2;
  v14 = sub_100019D18(v12, a2, v13, (uint64_t)v18);
  v15 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v15 + 24))
    v16 = v14;
  else
    v16 = 0;
  *(_BYTE *)(v15 + 24) = v16;
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

sqlite3_int64 sub_10001B720(uint64_t a1)
{
  sqlite3_int64 result;

  result = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

const UInt8 *sub_10001B754(uint64_t a1)
{
  const UInt8 *result;
  const UInt8 *v3;
  int v4;
  const UInt8 *v5;
  int v6;

  if (*(_QWORD *)(a1 + 40))
    **(_QWORD **)(a1 + 40) = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 48), 0);
  result = (const UInt8 *)sqlite3_column_int(*(sqlite3_stmt **)(a1 + 48), 1);
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (_DWORD)result;
  if (*(_QWORD *)(a1 + 56))
  {
    result = (const UInt8 *)sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 48), 2);
    if (result)
    {
      if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) == 3)
      {
        v3 = result;
        v4 = sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 48), 2);
        result = (const UInt8 *)CFDataCreate(kCFAllocatorDefault, v3, v4);
        **(_QWORD **)(a1 + 56) = result;
      }
    }
  }
  if (*(_QWORD *)(a1 + 64))
  {
    result = (const UInt8 *)sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 48), 3);
    if (result)
    {
      v5 = result;
      v6 = sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 48), 3);
      result = (const UInt8 *)CFDataCreate(kCFAllocatorDefault, v5, v6);
      **(_QWORD **)(a1 + 64) = result;
    }
  }
  return result;
}

uint64_t sub_10001B84C(uint64_t a1, sqlite3_stmt *a2)
{
  uint64_t v4;
  CFTypeRef *v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  _QWORD v15[7];
  __int128 v16;

  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v4 + 24))
  {
    v5 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
    v6 = sqlite3_bind_int64(a2, 1, *(_QWORD *)(a1 + 56));
    v7 = sub_10001A970(v6, a2, v5, CFSTR("bind_int64[%d]"), 1);
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  else
  {
    v7 = 0;
  }
  *(_BYTE *)(v4 + 24) = v7;
  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v8 + 24))
  {
    v9 = *(_QWORD *)(a1 + 72);
    v10 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8);
    v11 = *(_QWORD *)(a1 + 48);
    v12 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v15[0] = _NSConcreteStackBlock;
    v15[2] = sub_10001B754;
    v15[3] = &unk_1000787F8;
    v15[1] = 0x40000000;
    v15[5] = v9;
    v15[6] = a2;
    v15[4] = v11;
    v16 = *(_OWORD *)(a1 + 80);
    v13 = sub_100019D18(v10, a2, (CFTypeRef *)(v12 + 24), (uint64_t)v15);
    v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  else
  {
    v13 = 0;
  }
  *(_BYTE *)(v8 + 24) = v13;
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

uint64_t sub_10001B964(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6)
{
  uint64_t v7;
  int v8;
  __CFError *v9;
  CFIndex Code;
  const void *v11;
  uint64_t v12;
  _QWORD v14[12];
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  CFTypeRef v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  char v26;

  v23 = 0;
  v24 = &v23;
  v25 = 0x2000000000;
  v26 = 1;
  v19 = 0;
  v20 = &v19;
  v21 = 0x2000000000;
  v22 = 0;
  v15 = 0;
  v16 = &v15;
  v17 = 0x2000000000;
  v18 = 0;
  v7 = *(_QWORD *)(a1 + 8);
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000;
  v14[2] = sub_10001B84C;
  v14[3] = &unk_100078820;
  v14[4] = &v23;
  v14[5] = &v15;
  v14[8] = a1;
  v14[9] = a3;
  v14[6] = &v19;
  v14[7] = a2;
  v14[10] = a4;
  v14[11] = a5;
  v8 = sub_10001979C(v7, CFSTR("SELECT flags,format,data,policies FROM groups WHERE groupid=?"), &v18, (uint64_t)v14);
  *((_BYTE *)v24 + 24) = v8;
  v9 = (__CFError *)v16[3];
  if (v8)
  {
    if (!v9)
      goto LABEL_12;
    goto LABEL_5;
  }
  if (v9)
  {
LABEL_5:
    Code = CFErrorGetCode(v9);
    goto LABEL_7;
  }
  Code = -2070;
LABEL_7:
  sub_1000521A8(1, 3, Code);
  *((_DWORD *)v20 + 6) = 0;
  v11 = (const void *)v16[3];
  if (v11)
  {
    if (a6 && !*a6)
      *a6 = v11;
    else
      CFRelease(v11);
  }
LABEL_12:
  v12 = *((unsigned int *)v20 + 6);
  _Block_object_dispose(&v15, 8);
  _Block_object_dispose(&v19, 8);
  _Block_object_dispose(&v23, 8);
  return v12;
}

uint64_t sub_10001BABC()
{
  _QWORD block[5];

  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100050144;
  block[3] = &unk_100077F60;
  block[4] = &qword_100082E10;
  if (qword_100082E08 != -1)
    dispatch_once(&qword_100082E08, block);
  return qword_100082E10;
}

void sub_10001BB38(int a1, CFTypeRef *a2, CFStringRef format, ...)
{
  __CFString *v4;
  va_list va;

  va_start(va, format);
  if (a2)
  {
    v4 = (__CFString *)*a2;
    *a2 = 0;
    sub_10002A34C(a1, CFSTR("com.apple.utilities.sqlite3"), v4, a2, format, va);
  }
}

void sub_10001BB80(uint64_t a1)
{
  uint64_t v2;
  CFTypeRef *v3;
  uint64_t *v4;
  const __CFString *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  CFTypeRef v9;
  NSObject *v10;
  int v11;
  NSObject *v12;
  CFIndex v13;
  int *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const __CFArray *v18;
  uint64_t v19;
  const void *ValueAtIndex;
  const void *v21;
  NSObject *v22;
  CFErrorDomain Domain;
  int Code;
  BOOL v26;
  uint64_t v27;
  uint64_t v28;
  NSObject *v29;
  NSObject *v30;
  CFTypeRef v31;
  unsigned __int8 v32;
  CFTypeRef cf[5];
  CFTypeRef v34;
  CFTypeRef *v35;
  uint64_t v36;
  char v37;
  __int128 buf;
  uint64_t (*v39)(uint64_t);
  void *v40;
  CFTypeRef *v41;

  v2 = *(_QWORD *)(a1 + 64);
  if (*(_BYTE *)(v2 + 128))
    goto LABEL_22;
  v4 = *(uint64_t **)(a1 + 72);
  v3 = *(CFTypeRef **)(a1 + 80);
  v5 = *(const __CFString **)(v2 + 16);
  v34 = 0;
  v35 = &v34;
  v36 = 0x2000000000;
  v37 = 1;
  cf[0] = _NSConcreteStackBlock;
  cf[1] = (CFTypeRef)0x40000000;
  cf[2] = sub_100029838;
  cf[3] = &unk_100076218;
  cf[4] = &v34;
  *(_QWORD *)&buf = _NSConcreteStackBlock;
  *((_QWORD *)&buf + 1) = 0x40000000;
  v39 = sub_100026C34;
  v40 = &unk_100075DD0;
  v41 = cf;
  sub_100019A20(v5, (uint64_t)&buf);
  v6 = *((unsigned __int8 *)v35 + 24);
  _Block_object_dispose(&v34, 8);
  if (v6)
  {
    v32 = 0;
    v7 = sub_100028E0C(v2, 0);
    if (v7)
    {
      v8 = v7;
      cf[0] = 0;
      if ((sub_100028F04(v7, (uint64_t)&v32, (uint64_t)cf) & 1) != 0)
      {
        v9 = cf[0];
        if (cf[0])
        {
          cf[0] = 0;
          CFRelease(v9);
        }
        if (v4)
          *v4 = v8;
        v10 = sub_100011628("#SecDB");
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          LOWORD(buf) = 0;
          _os_log_debug_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "#SecDB starting maintenance", (uint8_t *)&buf, 2u);
        }
        if (*(_BYTE *)(v8 + 40))
          goto LABEL_12;
        v27 = *(_QWORD *)(v8 + 16);
        v28 = *(_QWORD *)(v27 + 136);
        if (v28)
        {
          v34 = 0;
          *(_BYTE *)(v27 + 144) = 0;
          v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, CFTypeRef *))(v28 + 16))(v28, v27, v8, v32, v27 + 144, &v34);
          *(_BYTE *)(v2 + 128) = v11;
          if ((v11 & 1) == 0)
          {
            v29 = sub_100011628("SecError");
            if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(buf) = 138412290;
              *(_QWORD *)((char *)&buf + 4) = v34;
              _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "opened block failed: %@", (uint8_t *)&buf, 0xCu);
            }
          }
          if (!v3 || *(_BYTE *)(v8 + 40) || *v3)
          {
            if (v34)
            {
              v30 = sub_100011628("SecError");
              if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(buf) = 138412290;
                *(_QWORD *)((char *)&buf + 4) = v34;
                _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "opened block failed: error (%@) is being released and lost", (uint8_t *)&buf, 0xCu);
              }
              v31 = v34;
              if (v34)
              {
                v34 = 0;
                CFRelease(v31);
              }
            }
          }
          else
          {
            *v3 = v34;
          }
          if (*(_BYTE *)(v8 + 40))
LABEL_12:
            v11 = sub_1000281EC(v8, 0, v3);
        }
        else
        {
          v11 = 0;
        }
        v12 = sub_100011628("#SecDB");
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        {
          LOWORD(buf) = 0;
          _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "#SecDB ending maintenance", (uint8_t *)&buf, 2u);
          if (!v11)
          {
LABEL_16:
            CFRelease((CFTypeRef)v8);
            if (v4)
              *v4 = 0;
            goto LABEL_20;
          }
        }
        else if (!v11)
        {
          goto LABEL_16;
        }
        CFArrayAppendValue(*(CFMutableArrayRef *)(v2 + 40), (const void *)v8);
        goto LABEL_16;
      }
      v22 = sub_100011628("SecError");
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138412290;
        *(CFTypeRef *)((char *)&buf + 4) = cf[0];
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Unable to create database: %@", (uint8_t *)&buf, 0xCu);
      }
      if (cf[0])
      {
        Domain = CFErrorGetDomain((CFErrorRef)cf[0]);
        if (CFEqual(Domain, CFSTR("com.apple.utilities.sqlite3")))
        {
          Code = CFErrorGetCode((CFErrorRef)cf[0]);
          v26 = Code == 11 || Code == 26;
          *(_BYTE *)(v8 + 40) = v26;
        }
      }
      LOBYTE(v11) = 0;
      if (!v3 || *(_BYTE *)(v8 + 40))
        goto LABEL_20;
      if (!*v3)
      {
        LOBYTE(v11) = 0;
        *v3 = cf[0];
        goto LABEL_20;
      }
    }
  }
  else
  {
    v13 = *__error();
    v14 = __error();
    sub_10002A5E8(v13, kCFErrorDomainPOSIX, v15, v3, v16, CFSTR("Unable to process corruption marker: %{darwin.errno}d"), *v14);
  }
  LOBYTE(v11) = 0;
LABEL_20:
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = v11;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v11;
  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24))
    return;
  v2 = *(_QWORD *)(a1 + 64);
LABEL_22:
  v17 = 48;
  if (!*(_BYTE *)(a1 + 88))
    v17 = 40;
  v18 = *(const __CFArray **)(v2 + v17);
  if (CFArrayGetCount(v18) && !*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24))
  {
    v19 = *(_QWORD *)(a1 + 32);
    ValueAtIndex = CFArrayGetValueAtIndex(v18, 0);
    if ((*(unsigned int (**)(uint64_t, const void *))(v19 + 16))(v19, ValueAtIndex))
    {
      v21 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24);
      if (v21)
        CFRetain(v21);
    }
    CFArrayRemoveValueAtIndex(v18, 0);
  }
}

BOOL sub_10001C060(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;

  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a2;
  v2 = *(_QWORD **)(a1 + 40);
  if (v2)
    *v2 = a2;
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) != 0;
}

void sub_10001C090(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  CFDictionaryRef *ValueAtIndex;
  const __CFData *Value;
  int v9;
  uint64_t v10;
  char v11;
  int v12;
  const __CFArray *v13;
  const __CFArray *v14;
  CFTypeID v15;
  const UInt8 *BytePtr;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const __CFArray *v25;
  const __CFArray *v26;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v4 && *(uint64_t *)(v4 + 16) >= 1 && (v5 = *(_QWORD *)(v4 + 136)) != 0)
    v6 = *(_QWORD *)(v5 + 16);
  else
    v6 = 0;
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  Value = (const __CFData *)CFDictionaryGetValue(ValueAtIndex[4], a2);
  v9 = SecPolicyCheckCertExtendedKeyUsageFiltered(v6, Value, 1);
  if ((v9 & 1) == 0)
    sub_10000E2C8(a1, a2, 0, kCFBooleanFalse, 0, 0);
  if (*(_QWORD *)a1)
    v10 = *(_QWORD *)(*(_QWORD *)a1 + 272);
  else
    v10 = 0;
  v11 = SecPolicyCheckCertExtendedKeyUsageFiltered(v6, Value, 0);
  if (v10)
    v12 = v9;
  else
    v12 = 0;
  if (v12 == 1 && (v11 & 1) == 0)
    *(_BYTE *)(v10 + 9) = 1;
  v13 = (const __CFArray *)SecCertificateCopyExtendedKeyUsage(v6);
  v14 = v13;
  if (v10 && v13)
  {
    if (CFArrayGetCount(v13) >= 2)
      *(_BYTE *)(v10 + 10) = 1;
    goto LABEL_22;
  }
  if (v13)
LABEL_22:
    CFRelease(v14);
  if (Value && (v15 = CFGetTypeID(Value), v15 == CFDataGetTypeID()) && CFDataGetLength(Value) == 8)
  {
    BytePtr = CFDataGetBytePtr(Value);
    v17 = memcmp(BytePtr, &unk_10006006A, 8uLL) != 0;
  }
  else
  {
    v17 = 0;
  }
  v18 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v18)
  {
    v19 = *(_QWORD *)(v18 + 16);
    if (v19 < 3)
      v17 = 1;
    if (!v17)
    {
      v20 = 0;
      v21 = v19 - 2;
      do
      {
        v22 = *(_QWORD *)(*(_QWORD *)a1 + 200);
        if (v22 && *(_QWORD *)(v22 + 16) > v20 + 1 && (v23 = *(_QWORD *)(v22 + 8 * v20 + 144)) != 0)
          v24 = *(_QWORD *)(v23 + 16);
        else
          v24 = 0;
        v25 = (const __CFArray *)SecCertificateCopyExtendedKeyUsage(v24);
        if (v25)
        {
          v26 = v25;
          if (CFArrayGetCount(v25)
            && (SecPolicyCheckCertExtendedKeyUsage(v24, CFSTR("2.5.29.37.0")) & 1) == 0
            && (SecPolicyCheckCertExtendedKeyUsage(v24, Value) & 1) == 0)
          {
            sub_10000E2C8(a1, a2, v20 + 1, kCFBooleanFalse, 0, 0);
          }
          CFRelease(v26);
        }
        ++v20;
      }
      while (v21 != v20);
    }
  }
}

const __CFArray *sub_10001C304(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const __CFArray *result;
  CFDictionaryRef *ValueAtIndex;
  const __CFArray *Value;
  double v13;
  double v14;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (!v4)
  {
    v6 = 0;
LABEL_10:
    v9 = 0;
    goto LABEL_11;
  }
  if (*(uint64_t *)(v4 + 16) >= 1 && (v5 = *(_QWORD *)(v4 + 136)) != 0)
    v6 = *(_QWORD *)(v5 + 16);
  else
    v6 = 0;
  v7 = *(_QWORD *)(v4 + 16);
  if (v7 < 1)
    goto LABEL_10;
  v8 = *(_QWORD *)(v4 + 8 * v7 + 128);
  if (!v8)
    goto LABEL_10;
  v9 = *(_QWORD *)(v8 + 16);
LABEL_11:
  if (off_1000827E0((uint64_t)off_1000827D0, v9)
    || (result = (const __CFArray *)sub_100045A18(v9, CFSTR("TestSystemRoot")), (_DWORD)result))
  {
    ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
    Value = (const __CFArray *)CFDictionaryGetValue(ValueAtIndex[4], a2);
    v13 = SecCertificateNotValidBefore(v6);
    v14 = SecCertificateNotValidAfter(v6);
    result = sub_10000F940(Value, v13, v14);
    if ((result & 1) == 0)
      return (const __CFArray *)sub_10000E2C8(a1, a2, 0, kCFBooleanFalse, 0, 0);
  }
  return result;
}

uint64_t sub_10001C430(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const void *v8;
  uint64_t v9;
  CFDictionaryRef *ValueAtIndex;
  uint64_t result;
  uint64_t v12;
  CFIndex i;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v4)
  {
    v5 = *(_QWORD *)(v4 + 16);
    v6 = v5 - 1;
    if (v5 >= 1 && (v7 = *(_QWORD *)(v4 + 8 * v6 + 136)) != 0)
      v8 = *(const void **)(v7 + 16);
    else
      v8 = 0;
  }
  else
  {
    v5 = 0;
    v8 = 0;
    v6 = -1;
  }
  if (((*(_BYTE *)(*(_QWORD *)(*(_QWORD *)a1 + 200) + 49) != 0) & sub_10000F2B4((_QWORD *)a1, (uint64_t)off_1000827E8, v8)) != 0)v9 = v6;
  else
    v9 = v5;
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (v9 >= 1)
  {
    v12 = result;
    for (i = 0; i < v9; ++i)
    {
      v14 = 0;
      v15 = *(_QWORD *)(*(_QWORD *)a1 + 200);
      if (v15 && (i & 0x8000000000000000) == 0)
      {
        if (*(_QWORD *)(v15 + 16) > i && (v16 = *(_QWORD *)(v15 + 8 * i + 136)) != 0)
          v14 = *(_QWORD *)(v16 + 16);
        else
          v14 = 0;
      }
      result = SecPolicyCheckCertSignatureHashAlgorithms(v14, v12);
      if ((result & 1) == 0)
      {
        result = sub_10000E2C8(a1, a2, i, kCFBooleanFalse, 0, 0);
        if (!(_DWORD)result)
          break;
      }
    }
  }
  return result;
}

void sub_10001C570(uint64_t a1, const __CFData *a2)
{
  const __CFDictionary *v3;
  const __CFDictionary *v4;
  CFAbsoluteTime v5;
  CFAbsoluteTime v6;

  v6 = NAN;
  v3 = sub_10001C6A4(a2, 1, *(const __CFData **)(a1 + 48), *(_QWORD *)(a1 + 56), *(const __CFDictionary **)(a1 + 64), &v6, *(CFAbsoluteTime *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  if (v3)
  {
    v4 = v3;
    v5 = v6;
    sub_10001C618(*(const __CFDictionary **)(a1 + 72), v3, v6);
    if (!CFDictionaryContainsKey(v4, CFSTR("expiry")))
    {
      sub_10001C618(*(const __CFDictionary **)(a1 + 80), v4, v5);
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
    }
  }
}

void sub_10001C618(const __CFDictionary *a1, const void *a2, CFAbsoluteTime a3)
{
  const __CFDate *Value;
  CFDateRef v7;

  Value = (const __CFDate *)CFDictionaryGetValue(a1, a2);
  if (!Value || CFDateGetAbsoluteTime(Value) > a3)
  {
    v7 = CFDateCreate(kCFAllocatorDefault, a3);
    CFDictionarySetValue(a1, a2, v7);
    if (v7)
      CFRelease(v7);
  }
}

const __CFDictionary *sub_10001C6A4(const __CFData *a1, uint64_t a2, const __CFData *a3, unint64_t a4, const __CFDictionary *a5, double *a6, CFAbsoluteTime a7)
{
  SecAsn1Oid v13;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  BOOL v20;
  unint64_t v21;
  const void *v22;
  const UInt8 *v23;
  uint64_t v24;
  int v25;
  const void *v26;
  NSObject *v27;
  uint64_t v28;
  const __CFDictionary *v29;
  UInt8 *v30;
  _QWORD *v31;
  int v32;
  const void *v33;
  NSObject *v34;
  char *v35;
  const __CFDictionary *v36;
  char *v38;
  char *v39;
  const UInt8 *v40;
  size_t v41;
  char *v42;
  CFDataRef v43;
  const __CFDictionary *Value;
  double v45;
  const __CFDate *v46;
  const void *v47;
  NSObject *v48;
  const __CFDate *v49;
  const __CFDate *v50;
  const void *v51;
  uint64_t v52;
  const void *v53;
  const SecAsn1Oid *v54;
  const void *v55;
  NSObject *v56;
  size_t v57;
  unsigned __int8 *v58;
  uint64_t v59;
  int v60;
  int v61;
  char *v62;
  double *v63;
  UInt8 *bytesa;
  SecAsn1Oid v66;
  SecAsn1Oid v67;
  uint8_t buf[4];
  const __CFDictionary *v69;
  __int16 v70;
  unint64_t v71;

  v13.Length = 0xAAAAAAAAAAAAAAAALL;
  v13.Data = (uint8_t *)0xAAAAAAAAAAAAAAAALL;
  v66 = v13;
  v67 = v13;
  BytePtr = CFDataGetBytePtr(a1);
  Length = CFDataGetLength(a1);
  if ((unint64_t)(Length - 0x7FFFFFFFFFFFFFFFLL) < 0x800000000000002CLL)
    goto LABEL_16;
  v16 = BytePtr[41];
  v17 = BytePtr[42];
  v18 = v17 | (v16 << 8);
  v19 = Length - 43 - v18;
  if (Length - 43 < v18)
    goto LABEL_16;
  v20 = v19 >= 4;
  v21 = v19 - 4;
  if (!v20)
    goto LABEL_16;
  v22 = BytePtr + 43;
  v23 = &BytePtr[v18 + 43];
  v24 = __rev16(*((unsigned __int16 *)v23 + 1));
  if (v21 != v24)
    goto LABEL_16;
  v25 = *BytePtr;
  if (*BytePtr)
  {
    v26 = sub_100011628("SecError");
    v27 = objc_claimAutoreleasedReturnValue(v26);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      LODWORD(v69) = v25;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "SCT version unsupported: %d\n", buf, 8u);
    }

    goto LABEL_16;
  }
  v63 = a6;
  v28 = 0;
  v29 = 0;
  v30 = (UInt8 *)(BytePtr + 1);
  v31 = BytePtr + 33;
  v32 = *v23;
  do
    v29 = (const __CFDictionary *)(*((unsigned __int8 *)v31 + v28++) | ((_QWORD)v29 << 8));
  while ((_DWORD)v28 != 8);
  if ((unint64_t)v29 > a4)
  {
    v33 = sub_100011628("SecError");
    v34 = objc_claimAutoreleasedReturnValue(v33);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134218240;
      v69 = v29;
      v70 = 2048;
      v71 = a4;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "SCT is in the future: %llu > %llu\n", buf, 0x16u);
    }

    goto LABEL_16;
  }
  bytesa = v30;
  v61 = v23[1];
  v58 = (unsigned __int8 *)(v23 + 4);
  v59 = v24;
  if (CFDataGetLength(a3) < 1
    || CFDataGetLength(a3) > 1048574
    || (v60 = v32, v57 = v18 + CFDataGetLength(a3) + 14, (v38 = (char *)malloc_type_malloc(v57, 0xF029A3ACuLL)) == 0))
  {
LABEL_16:
    v35 = 0;
    v36 = 0;
    goto LABEL_17;
  }
  *(_WORD *)v38 = 0;
  *(_QWORD *)(v38 + 2) = *v31;
  v38[10] = 0;
  v38[11] = a2;
  v62 = v38;
  v39 = v38 + 12;
  v40 = CFDataGetBytePtr(a3);
  v41 = CFDataGetLength(a3);
  memcpy(v39, v40, v41);
  v42 = &v39[CFDataGetLength(a3)];
  *v42 = v16;
  v42[1] = v17;
  memcpy(v42 + 2, v22, v17 | (v16 << 8));
  v43 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, bytesa, 32, kCFAllocatorNull);
  Value = (const __CFDictionary *)CFDictionaryGetValue(a5, v43);
  v36 = Value;
  if (!Value)
  {
    v53 = 0;
LABEL_45:
    v35 = v62;
    if (!v43)
      goto LABEL_47;
    goto LABEL_46;
  }
  if (!a2 && CFDictionaryContainsKey(Value, CFSTR("expiry")))
  {
    v53 = 0;
    v36 = 0;
    goto LABEL_45;
  }
  v45 = (double)((unint64_t)v29 / 0x3E8) - kCFAbsoluteTimeIntervalSince1970;
  v46 = (const __CFDate *)CFDictionaryGetValue(v36, CFSTR("frozen"));
  if (v46 && CFDateGetAbsoluteTime(v46) < v45)
  {
    v47 = sub_100011628("SecError");
    v48 = objc_claimAutoreleasedReturnValue(v47);
    v35 = v62;
    if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v69 = v36;
      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "Frozen CT log issued SCT after freezing (log=%@)\n", buf, 0xCu);
    }

    goto LABEL_40;
  }
  v49 = (const __CFDate *)CFDictionaryGetValue(v36, CFSTR("start_inclusive"));
  v50 = (const __CFDate *)CFDictionaryGetValue(v36, CFSTR("end_exclusive"));
  v35 = v62;
  if (v49 && CFDateGetAbsoluteTime(v49) > a7
    || v50 && CFDateGetAbsoluteTime(v50) <= a7
    || (v51 = CFDictionaryGetValue(v36, CFSTR("key"))) == 0)
  {
LABEL_40:
    v53 = 0;
    goto LABEL_41;
  }
  v52 = SecKeyCreateFromSubjectPublicKeyInfoData(kCFAllocatorDefault, v51);
  v53 = (const void *)v52;
  if (!v52)
    goto LABEL_41;
  if (v61 == 3)
  {
    switch(v60)
    {
      case 2:
        v54 = &CSSMOID_ECDSA_WithSHA1;
        break;
      case 5:
        v54 = &CSSMOID_ECDSA_WithSHA384;
        break;
      case 4:
        v54 = &CSSMOID_ECDSA_WithSHA256;
        break;
      default:
        goto LABEL_41;
    }
  }
  else
  {
    if (v61 != 1)
      goto LABEL_41;
    switch(v60)
    {
      case 2:
        v54 = &CSSMOID_SHA1WithRSA;
        break;
      case 5:
        v54 = &CSSMOID_SHA384WithRSA;
        break;
      case 4:
        v54 = &CSSMOID_SHA256WithRSA;
        break;
      default:
        goto LABEL_41;
    }
  }
  v66 = *v54;
  v67 = (SecAsn1Oid)0;
  if (SecKeyDigestAndVerify(v52, &v66, v62, v57, v58, v59))
  {
    v55 = sub_100011628("SecError");
    v56 = objc_claimAutoreleasedReturnValue(v55);
    if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v69 = v36;
      _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "SCT signature failed (log=%@)\n", buf, 0xCu);
    }

LABEL_41:
    v36 = 0;
    if (!v43)
      goto LABEL_47;
LABEL_46:
    CFRelease(v43);
    goto LABEL_47;
  }
  *v63 = v45;
  if (v43)
    goto LABEL_46;
LABEL_47:
  if (v53)
    CFRelease(v53);
LABEL_17:
  free(v35);
  return v36;
}

void sub_10001CC6C(uint64_t a1, const void *a2)
{
  uint64_t v4;
  const void *v5;
  const __CFSet *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  const void *v11;

  v4 = sub_100004464();
  if (v4)
  {
    v5 = (const void *)v4;
    v6 = *(const __CFSet **)(v4 + 24);
    if (v6)
    {
      CFRetain(*(CFTypeRef *)(v4 + 24));
      CFRelease(v5);
      v7 = *(_QWORD *)(*(_QWORD *)a1 + 200);
      if (v7 && *(uint64_t *)(v7 + 16) >= 1 && (v8 = *(_QWORD *)(v7 + 136)) != 0)
        v9 = *(_QWORD *)(v8 + 16);
      else
        v9 = 0;
      v10 = (const void *)SecCertificateCopyPublicKeySHA1Digest(v9);
      if (v10)
      {
        v11 = v10;
        if (CFSetContainsValue(v6, v10))
          sub_10000E2C8(a1, a2, 0, kCFBooleanFalse, 0, 0);
        CFRelease(v11);
      }
    }
    else
    {
      v6 = (const __CFSet *)v4;
    }
    CFRelease(v6);
  }
}

void sub_10001CD48(void (**a1)(_QWORD, _QWORD), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  a1[2](a1, a5);
  _Block_release(a1);
}

uint64_t sub_10001CD74(uint64_t result, int a2)
{
  if (a2 == 4 || a2 == 1)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = 1;
  return result;
}

uint64_t sub_10001CD98(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  CFDictionaryRef *ValueAtIndex;
  uint64_t result;
  const __CFNumber *v8;
  CFTypeID v9;
  BOOL v10;
  unint64_t valuePtr;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v4)
    v5 = *(_QWORD *)(v4 + 16);
  else
    v5 = 0;
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (result)
  {
    v8 = (const __CFNumber *)result;
    v9 = CFGetTypeID((CFTypeRef)result);
    result = CFNumberGetTypeID();
    if (v9 == result)
    {
      valuePtr = 0xAAAAAAAAAAAAAAAALL;
      result = CFNumberGetValue(v8, kCFNumberCFIndexType, &valuePtr);
      if ((_DWORD)result)
        v10 = valuePtr == v5;
      else
        v10 = 1;
      if (!v10)
        return sub_10000E2C8(a1, a2, 0, kCFBooleanFalse, 0, 0);
    }
  }
  return result;
}

void sub_10001CE68(_QWORD *a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const __CFArray *v15;
  const __CFArray *v16;

  v4 = *(_QWORD *)(*a1 + 200);
  if (v4)
  {
    if (*(uint64_t *)(v4 + 16) >= 1 && (v5 = *(_QWORD *)(v4 + 136)) != 0)
      v6 = *(_QWORD *)(v5 + 16);
    else
      v6 = 0;
    v7 = *(_QWORD *)(v4 + 16);
    v8 = v7 - 1;
    if (v7 >= 1 && (v9 = *(_QWORD *)(v4 + 8 * v8 + 136)) != 0)
      v10 = *(const void **)(v9 + 16);
    else
      v10 = 0;
  }
  else
  {
    v6 = 0;
    v7 = 0;
    v10 = 0;
    v8 = -1;
  }
  if (off_1000827E0((uint64_t)off_1000827D0, (uint64_t)v10) || sub_100045A18((uint64_t)v10, CFSTR("TestSystemRoot")))
  {
    if ((SecPolicyCheckCertExtendedKeyUsage(v6, CFSTR("1.3.6.1.5.5.7.3.1")) & 1) == 0)
      sub_10000E2C8((uint64_t)a1, a2, 0, kCFBooleanFalse, 0, 0);
    if (v7 >= 3)
    {
      v11 = 0;
      do
      {
        v12 = *(_QWORD *)(*a1 + 200);
        if (v12 && *(_QWORD *)(v12 + 16) > v11 + 1 && (v13 = *(_QWORD *)(v12 + 8 * v11 + 144)) != 0)
          v14 = *(_QWORD *)(v13 + 16);
        else
          v14 = 0;
        v15 = (const __CFArray *)SecCertificateCopyExtendedKeyUsage(v14);
        if (v15)
        {
          v16 = v15;
          if (CFArrayGetCount(v15)
            && (SecPolicyCheckCertExtendedKeyUsage(v14, CFSTR("1.3.6.1.5.5.7.3.1")) & 1) == 0
            && (SecPolicyCheckCertExtendedKeyUsage(v14, CFSTR("2.5.29.37.0")) & 1) == 0)
          {
            sub_10000E2C8((uint64_t)a1, a2, 0, kCFBooleanFalse, 0, 0);
          }
          CFRelease(v16);
        }
        ++v11;
      }
      while (v8 - 1 != v11);
    }
  }
  else if (!sub_10000F2B4(a1, (uint64_t)off_1000827E8, v10)
         && SecCertificateNotValidBefore(v6) > 583628400.0
         && (SecPolicyCheckCertExtendedKeyUsage(v6, CFSTR("1.3.6.1.5.5.7.3.1")) & 1) == 0)
  {
    sub_10000E2C8((uint64_t)a1, a2, 0, kCFBooleanFalse, 0, 0);
  }
}

uint64_t sub_10001D0BC(uint64_t a1)
{
  uint64_t v2;
  sqlite3_stmt *v3;
  const UInt8 *BytePtr;
  unint64_t Length;
  int v6;
  sqlite3_stmt *v7;
  const UInt8 *v8;
  unint64_t v9;
  int v10;
  NSObject *v11;
  const void *v12;
  CFMutableArrayRef Mutable;
  int v15;
  const void *v16;
  const void *v17;
  _DWORD v18[2];

  v2 = *(_QWORD *)(a1 + 48);
  if (!*(_BYTE *)(v2 + 33))
    goto LABEL_10;
  v3 = *(sqlite3_stmt **)(v2 + 16);
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 56));
  Length = CFDataGetLength(*(CFDataRef *)(a1 + 56));
  if (Length >> 31)
    goto LABEL_5;
  v6 = sqlite3_bind_blob(v3, 1, BytePtr, Length, 0);
  if (v6)
    goto LABEL_21;
  v7 = *(sqlite3_stmt **)(*(_QWORD *)(a1 + 48) + 16);
  v8 = CFDataGetBytePtr(*(CFDataRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  v9 = CFDataGetLength(*(CFDataRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  if (v9 >> 31)
  {
LABEL_5:
    v10 = 18;
LABEL_6:
    v11 = sub_100011628("SecError");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v18[0] = 67109120;
      v18[1] = v10;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Failed to read parents from trust store: %d", (uint8_t *)v18, 8u);
    }
    sub_1000521A8(4, 3, v10);
    v12 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
    if (v12)
    {
      CFRelease(v12);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
    }
    goto LABEL_10;
  }
  v6 = sqlite3_bind_blob(v7, 2, v8, v9, 0);
  if (v6)
  {
LABEL_21:
    v10 = v6;
    goto LABEL_6;
  }
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = Mutable;
  if (!Mutable)
  {
    v10 = 0;
    goto LABEL_6;
  }
  while (1)
  {
    v15 = sqlite3_step(*(sqlite3_stmt **)(*(_QWORD *)(a1 + 48) + 16));
    if (v15 != 100)
      break;
    sqlite3_column_blob(*(sqlite3_stmt **)(*(_QWORD *)(a1 + 48) + 16), 0);
    sqlite3_column_bytes(*(sqlite3_stmt **)(*(_QWORD *)(a1 + 48) + 16), 0);
    v16 = (const void *)SecCertificateCreateWithBytes(kCFAllocatorDefault);
    if (!v16)
    {
      v10 = 100;
      goto LABEL_6;
    }
    v17 = v16;
    CFArrayAppendValue(*(CFMutableArrayRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), v16);
    CFRelease(v17);
  }
  v10 = v15;
  if (v15 && v15 != 101)
    goto LABEL_6;
LABEL_10:
  sqlite3_reset(*(sqlite3_stmt **)(*(_QWORD *)(a1 + 48) + 16));
  return sqlite3_clear_bindings(*(sqlite3_stmt **)(*(_QWORD *)(a1 + 48) + 16));
}

void sub_10001D314(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  __SecCertificate *v6;
  const __CFData *NormalizedIssuerContent;
  const __CFData *v8;
  const UInt8 *BytePtr;
  const __CFData *v10;
  const __CFData *v11;
  CFIndex Length;
  const UInt8 *v13;
  uint64_t v15;
  const void *v16;
  const void *v17;
  const void *v18;
  uint64_t v19;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v4 && *(uint64_t *)(v4 + 16) >= 1 && (v5 = *(_QWORD *)(v4 + 136)) != 0)
  {
    v6 = *(__SecCertificate **)(v5 + 16);
    if (v6)
    {
      NormalizedIssuerContent = (const __CFData *)SecCertificateGetNormalizedIssuerContent(*(_QWORD *)(v5 + 16));
      if (NormalizedIssuerContent)
      {
        v8 = NormalizedIssuerContent;
        if (CFDataGetLength(NormalizedIssuerContent) == 151)
        {
          BytePtr = CFDataGetBytePtr(v8);
          if (!memcmp(&unk_100061ED0, BytePtr, 0x97uLL))
          {
            v10 = SecCertificateCopySerialNumberData(v6, 0);
            if (v10)
            {
              v11 = v10;
              Length = CFDataGetLength(v10);
              v13 = CFDataGetBytePtr(v11);
              if (Length >= 1)
              {
                while (!*v13)
                {
                  ++v13;
                  if (Length-- <= 1)
                    goto LABEL_31;
                }
                if (Length == 16)
                {
                  v19 = 0;
                  while (*(_QWORD *)((char *)&unk_100061F67 + v19) != *(_QWORD *)v13
                       || *(_QWORD *)((char *)&unk_100061F67 + v19 + 8) != *((_QWORD *)v13 + 1))
                  {
                    v19 += 16;
                    if (v19 == 144)
                      goto LABEL_31;
                  }
                  sub_10000E2C8(a1, a2, 0, kCFBooleanFalse, 0, 0);
                  goto LABEL_23;
                }
              }
LABEL_31:
              CFRelease(v11);
            }
          }
        }
      }
    }
  }
  else
  {
    v6 = 0;
  }
  v15 = sub_100004464();
  if (v15)
  {
    v16 = (const void *)v15;
    v11 = *(const __CFData **)(v15 + 16);
    if (v11)
    {
      CFRetain(*(CFTypeRef *)(v15 + 16));
      CFRelease(v16);
      v17 = (const void *)SecCertificateCopyPublicKeySHA1Digest(v6);
      if (v17)
      {
        v18 = v17;
        if (CFSetContainsValue(v11, v17))
          sub_10000E2C8(a1, a2, 0, kCFBooleanFalse, 0, 0);
        CFRelease(v18);
      }
    }
    else
    {
      v11 = (const __CFData *)v15;
    }
LABEL_23:
    CFRelease(v11);
  }
}

uint64_t sub_10001D4EC(CFTypeRef *a1)
{
  CFURLRef v2;
  void *v3;
  uint64_t v4;
  CFTypeRef v5;
  const void *v6;
  NSObject *v7;
  const char *v9;
  CFTypeRef cf;
  uint8_t buf[4];
  uint64_t v12;
  __int16 v13;
  const char *v14;

  if (!sub_100015138())
    return 0;
  cf = 0;
  v2 = sub_10001D628();
  v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  v4 = sub_10001D644(v3, (CFErrorRef *)&cf);

  v5 = cf;
  if (cf)
  {
    if (a1)
    {
      *a1 = cf;
    }
    else
    {
      cf = 0;
      CFRelease(v5);
    }
  }
  v6 = sub_100011628("trust");
  v7 = objc_claimAutoreleasedReturnValue(v6);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    if (a1)
    {
      if (*a1)
        v9 = "Error";
      else
        v9 = "OK";
    }
    else
    {
      v9 = "N/A";
    }
    *(_DWORD *)buf = 134218242;
    v12 = v4;
    v13 = 2080;
    v14 = v9;
    _os_log_debug_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "exceptionResetCount: %llu (%s)", buf, 0x16u);
  }

  return v4;
}

CFURLRef sub_10001D628()
{
  return sub_10001DC28((uint64_t)CFSTR("com.apple.security.exception_reset_counter.plist"));
}

uint64_t sub_10001D644(void *a1, CFErrorRef *a2)
{
  __CFString *v3;
  void *v4;
  void *v5;
  id v6;
  id v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  const void *v11;
  NSObject *v12;
  const void *v13;
  NSObject *v14;
  const void *v15;
  NSObject *v16;
  const __CFString *v17;
  CFIndex v18;
  const void *v19;
  NSObject *v20;
  id v22;
  uint8_t buf[4];
  const __CFString *v24;
  __int16 v25;
  uint64_t v26;

  v3 = a1;
  v4 = objc_autoreleasePoolPush();
  v22 = 0;
  v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithContentsOfURL:error:](NSDictionary, "dictionaryWithContentsOfURL:error:", v3, &v22));
  v6 = v22;
  v7 = objc_msgSend(v5, "mutableCopy");

  if (v7)
  {
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKey:", CFSTR("ExceptionResetCount")));
    if (v8)
    {
      v9 = objc_opt_class(NSNumber);
      if ((objc_opt_isKindOfClass(v8, v9) & 1) != 0)
      {
        v10 = objc_msgSend(v8, "unsignedIntValue");
        v11 = sub_100011628("trust");
        v12 = objc_claimAutoreleasedReturnValue(v11);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 138543618;
          v24 = CFSTR("ExceptionResetCount");
          v25 = 2048;
          v26 = v10;
          _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "'%{public}@' is %llu.", buf, 0x16u);
        }

        goto LABEL_21;
      }
      v19 = sub_100011628("SecError");
      v20 = objc_claimAutoreleasedReturnValue(v19);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138543362;
        v24 = CFSTR("ExceptionResetCount");
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "The value for key '%{public}@' is not a number.", buf, 0xCu);
      }

      if (a2)
      {
        v17 = kCFErrorDomainPOSIX;
        v18 = 33;
        goto LABEL_19;
      }
    }
    else
    {
      v15 = sub_100011628("trust");
      v16 = objc_claimAutoreleasedReturnValue(v15);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 138543618;
        v24 = CFSTR("ExceptionResetCount");
        v25 = 2048;
        v26 = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "Could not find key '%{public}@'. Defaulting to value %llu.", buf, 0x16u);
      }

      if (a2)
      {
        v17 = kCFErrorDomainPOSIX;
        v18 = 6;
LABEL_19:
        v10 = 0;
        *a2 = CFErrorCreate(0, v17, v18, 0);
LABEL_21:

        goto LABEL_22;
      }
    }
    v10 = 0;
    goto LABEL_21;
  }
  v13 = sub_100011628("SecError");
  v14 = objc_claimAutoreleasedReturnValue(v13);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138543618;
    v24 = v3;
    v25 = 2048;
    v26 = 0;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Failed to read from permanent storage at '%{public}@' or the data is bad. Defaulting to value %llu.", buf, 0x16u);
  }

  v10 = 0;
  if (a2)
    *a2 = (CFErrorRef)v6;
LABEL_22:

  objc_autoreleasePoolPop(v4);
  return v10;
}

uint64_t sub_10001D958(uint64_t a1, uint64_t a2)
{
  CFURLRef v4;
  void *v5;
  uint64_t v6;

  if (qword_100082D90 != -1)
    dispatch_once(&qword_100082D90, &stru_100077648);
  v4 = sub_10001DC0C();
  v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  v6 = sub_10001D9F8(a1, a2, (uint64_t)"CA Revocation Additions", byte_100082D88, &dword_100082D8C, v5, &stru_1000775E0, &stru_100077600);

  return v6;
}

uint64_t sub_10001D9F8(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4, int *a5, void *a6, void *a7, void *a8)
{
  id v15;
  uint64_t (**v16)(id, id, id *);
  uint64_t (**v17)(id, void *, _QWORD);
  void *v18;
  uint32_t v19;
  unsigned __int8 v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  id v24;
  uint64_t v25;
  const void *v26;
  NSObject *v27;
  id v29;
  int check;
  uint64_t v31;
  __int16 v32;
  id v33;

  v15 = a6;
  v16 = a7;
  v17 = a8;
  if (sub_100015138())
  {
    v18 = objc_autoreleasePoolPush();
    if (qword_100082C28 != -1)
      dispatch_once(&qword_100082C28, &stru_1000767D0);
    if ((byte_100082C20 & 1) == 0 && (check = 0, v19 = notify_check(*a5, &check), v19 | check)
      || (v20 = atomic_load(a4), (v20 & 1) != 0))
    {
      v29 = 0;
      v22 = v16[2](v16, v15, &v29);
      v23 = (void *)objc_claimAutoreleasedReturnValue(v22);
      v24 = v29;
      if (v23 && objc_msgSend(v23, "count"))
      {
        if (a1)
          v25 = objc_claimAutoreleasedReturnValue(objc_msgSend(v23, "objectForKeyedSubscript:", a1));
        else
          v25 = v17[2](v17, v23, a2);
        v21 = v25;
      }
      else
      {
        v26 = sub_100011628("config");
        v27 = objc_claimAutoreleasedReturnValue(v26);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          check = 136446466;
          v31 = a3;
          v32 = 2112;
          v33 = v24;
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "skipping further reads. no %{public}s found: %@", (uint8_t *)&check, 0x16u);
        }

        v21 = 0;
        atomic_store(0, a4);
      }

    }
    else
    {
      v21 = 0;
    }
    objc_autoreleasePoolPop(v18);
  }
  else
  {
    v21 = 0;
  }

  return v21;
}

CFURLRef sub_10001DC0C()
{
  return sub_10001DC28((uint64_t)CFSTR("CARevocation.plist"));
}

CFURLRef sub_10001DC28(uint64_t a1)
{
  __CFString *v2;
  CFURLRef v3;

  if (qword_100082C38 != -1)
  {
    dispatch_once(&qword_100082C38, &stru_100076830);
    if (a1)
      goto LABEL_3;
LABEL_5:
    v2 = CFSTR("private/");
    goto LABEL_6;
  }
  if (!a1)
    goto LABEL_5;
LABEL_3:
  v2 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("private/%@"), a1));
LABEL_6:
  v3 = sub_10001DCB8((uint64_t)v2);

  return v3;
}

CFURLRef sub_10001DCB8(uint64_t a1)
{
  __CFString *v2;
  CFURLRef v3;

  if (qword_100082C30 != -1)
  {
    dispatch_once(&qword_100082C30, &stru_1000767F0);
    if (a1)
      goto LABEL_3;
LABEL_5:
    v2 = CFSTR("trustd/");
    goto LABEL_6;
  }
  if (!a1)
    goto LABEL_5;
LABEL_3:
  v2 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("trustd/%@"), a1));
LABEL_6:
  v3 = sub_10001DD50(CFSTR("private/var/protected/"), (uint64_t)v2);

  return v3;
}

CFURLRef sub_10001DD50(const __CFString *a1, uint64_t a2)
{
  const __CFURL *v4;
  const __CFAllocator *v5;
  const __CFString *Copy;
  const __CFString *v7;
  CFURLRef v8;

  v4 = CFURLCreateWithFileSystemPath(0, CFSTR("/"), kCFURLPOSIXPathStyle, 1u);
  if (a2)
  {
    v5 = kCFAllocatorDefault;
    Copy = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@/%@"), a1, a2);
  }
  else
  {
    if (!a1)
      goto LABEL_10;
    v5 = kCFAllocatorDefault;
    Copy = CFStringCreateCopy(kCFAllocatorDefault, a1);
  }
  v7 = Copy;
  if (v4 && Copy)
  {
    v8 = CFURLCreateCopyAppendingPathComponent(v5, v4, Copy, a2 == 0);
    CFRelease(v7);
LABEL_11:
    CFRelease(v4);
    return v8;
  }
  if (Copy)
    CFRelease(Copy);
LABEL_10:
  v8 = 0;
  if (v4)
    goto LABEL_11;
  return v8;
}

void sub_10001DE38(uint64_t a1, const void *a2)
{
  CFDictionaryRef *ValueAtIndex;
  _BOOL4 v5;

  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  v5 = CFDictionaryGetValue(ValueAtIndex[4], a2) != kCFBooleanTrue;
  sub_100016E34(*(_QWORD *)a1, v5);
}

uint64_t sub_10001DE88(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  CFDictionaryRef *ValueAtIndex;
  const void *Value;
  uint64_t result;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v4 && *(uint64_t *)(v4 + 16) >= 1 && (v5 = *(_QWORD *)(v4 + 136)) != 0)
    v6 = *(_QWORD *)(v5 + 16);
  else
    v6 = 0;
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  Value = CFDictionaryGetValue(ValueAtIndex[4], a2);
  result = SecPolicyCheckCertKeyUsage(v6, Value);
  if ((result & 1) == 0)
    return sub_10000E2C8(a1, a2, 0, kCFBooleanFalse, 0, 0);
  return result;
}

uint64_t sub_10001DF34(uint64_t a1, CFTypeRef cf1)
{
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  CFDictionaryRef *ValueAtIndex;
  uint64_t v9;
  CFTypeID v10;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (!v4 || *(uint64_t *)(v4 + 16) < 2)
    return sub_10000E2C8(a1, cf1, 0, kCFBooleanFalse, 0, 0);
  v6 = *(_QWORD *)(v4 + 144);
  v7 = v6 ? *(_QWORD *)(v6 + 16) : 0;
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], cf1);
  if (result)
  {
    v9 = result;
    v10 = CFGetTypeID((CFTypeRef)result);
    result = CFStringGetTypeID();
    if (v10 == result)
    {
      result = SecPolicyCheckCertSubjectCommonName(v7, v9);
      if ((result & 1) == 0)
        return sub_10000E2C8(a1, cf1, 0, kCFBooleanFalse, 0, 0);
    }
  }
  return result;
}

void sub_10001E008(uint64_t a1, const void *a2)
{
  CFDictionaryRef *ValueAtIndex;
  const void *Value;
  CFTypeID v6;
  CFTypeID v7;
  const __CFData *OidDataFromString;
  const __CFData *v9;
  BOOL v10;

  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  Value = CFDictionaryGetValue(ValueAtIndex[4], a2);
  v6 = CFGetTypeID(Value);
  if (v6 == CFDataGetTypeID())
  {
    if (!sub_10001E0EC(a1, (CFDataRef)Value))
LABEL_8:
      sub_10000E2C8(a1, a2, 0, kCFBooleanFalse, 0, 0);
  }
  else
  {
    v7 = CFGetTypeID(Value);
    if (v7 != CFStringGetTypeID())
      goto LABEL_8;
    OidDataFromString = (const __CFData *)SecCertificateCreateOidDataFromString(0, Value);
    if (!OidDataFromString)
      goto LABEL_8;
    v9 = OidDataFromString;
    v10 = sub_10001E0EC(a1, OidDataFromString);
    CFRelease(v9);
    if (!v10)
      goto LABEL_8;
  }
}

BOOL sub_10001E0EC(uint64_t a1, CFDataRef theData)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  BOOL v10;
  _QWORD *v11;
  _QWORD v13[2];

  v3 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v3)
    v4 = *(_QWORD *)(v3 + 16);
  else
    v4 = 0;
  v13[0] = CFDataGetBytePtr(theData);
  v13[1] = CFDataGetLength(theData);
  if (v4 < 1)
  {
    return 0;
  }
  else
  {
    v5 = 0;
    v6 = 1;
    do
    {
      v7 = sub_10001E1FC();
      if (v7)
      {
        v8 = v7;
        v9 = (uint64_t)v7;
        do
        {
          v10 = DEROidCompare(v9, (uint64_t)v13);
          if (v10)
            break;
          v9 = *(_QWORD *)(v9 + 16);
        }
        while (v9);
        do
        {
          v11 = (_QWORD *)v8[2];
          free(v8);
          v8 = v11;
        }
        while (v11);
        if (v10)
          break;
      }
      v6 = ++v5 < v4;
    }
    while (v5 != v4);
  }
  return v6;
}

_QWORD *sub_10001E1FC()
{
  _QWORD *result;
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;

  result = (_QWORD *)SecCertificateGetCertificatePolicies();
  if (result)
  {
    v1 = result;
    v2 = result[1];
    if (v2)
    {
      v3 = 0;
      v4 = 0;
      do
      {
        v5 = v1[2];
        result = malloc_type_malloc(0x18uLL, 0x1030040D5FA72FAuLL);
        result[2] = v4;
        *(_OWORD *)result = *(_OWORD *)(v5 + v3);
        v3 += 32;
        v4 = result;
        --v2;
      }
      while (v2);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_10001E280(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v4 && *(uint64_t *)(v4 + 16) >= 1 && (v5 = *(_QWORD *)(v4 + 136)) != 0)
    v6 = *(_QWORD *)(v5 + 16);
  else
    v6 = 0;
  result = SecCertificateIsCA(v6);
  if ((_DWORD)result)
    return sub_10000E2C8(a1, a2, 0, kCFBooleanFalse, 0, 0);
  return result;
}

void sub_10001E300(uint64_t a1, const void *a2)
{
  CFDictionaryRef *ValueAtIndex;
  const void *Value;
  const void *v6;
  CFTypeID v7;

  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  Value = CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (Value)
  {
    v6 = Value;
    v7 = CFGetTypeID(Value);
    if (v7 == CFStringGetTypeID())
      sub_100016F38(*(_QWORD *)a1, v6);
  }
}

uint64_t sub_10001E374(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  CFDictionaryRef *ValueAtIndex;
  const void *Value;
  uint64_t result;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v4 && *(uint64_t *)(v4 + 16) >= 1 && (v5 = *(_QWORD *)(v4 + 136)) != 0)
    v6 = *(_QWORD *)(v5 + 16);
  else
    v6 = 0;
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  Value = CFDictionaryGetValue(ValueAtIndex[4], a2);
  result = SecPolicyCheckCertLeafMarkerOid(v6, Value);
  if ((result & 1) == 0)
    return sub_10000E2C8(a1, kSecPolicyCheckLeafMarkerOid, 0, kCFBooleanFalse, 1, 0);
  return result;
}

void sub_10001E428(uint64_t a1)
{
  uint64_t v2;
  dispatch_time_t v3;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2)
    (*(void (**)(void))(v2 + 16))();
  dispatch_suspend(*(dispatch_object_t *)(a1 + 8));
  v3 = dispatch_time(0, 1000000000 * *(_QWORD *)(a1 + 24));
  dispatch_after_f(v3, *(dispatch_queue_t *)a1, *(void **)(a1 + 8), (dispatch_function_t)&_dispatch_resume);
}

void sub_10001E480(id a1)
{
  NSObject *v1;
  const void *v2;
  NSObject *v3;
  const void *v4;
  _DWORD v5[2];

  if ((SecIsInternalRelease(a1) & 1) != 0)
  {
    v1 = objc_msgSend(objc_alloc((Class)NSUserDefaults), "initWithSuiteName:", CFSTR("com.apple.security"));
    v2 = sub_100011628("pinningQA");
    v3 = objc_claimAutoreleasedReturnValue(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v5[0] = 67109120;
      v5[1] = -[NSObject BOOLForKey:](v1, "BOOLForKey:", CFSTR("AppleServerAuthenticationNoPinning"));
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "generic pinning disable = %{BOOL}d", (uint8_t *)v5, 8u);
    }

  }
  else
  {
    v4 = sub_100011628("pinningQA");
    v1 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v5[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "could not disable pinning: not an internal release", (uint8_t *)v5, 2u);
    }
  }

}

void sub_10001EE94(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_10001F08C(uint64_t a1)
{
  void *v1;
  uint64_t v2;
  id v3;
  float v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSNumber *v15;
  void *v16;
  NSNumber *v17;
  void *v18;
  NSNumber *v19;
  void *v20;
  uint64_t v21;
  id v22;
  void *v23;
  void *v24;
  NSDate *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  double v31;
  void *v32;
  NSNumber *v33;
  void *v34;
  double v35;
  void *v36;
  const __CFArray *v37;
  const __CFArray *v38;
  CFIndex Count;
  uint64_t v40;
  const __CFArray *v41;
  const __CFArray *v42;
  CFIndex v43;
  const __CFArray *v44;
  const __CFArray *v45;
  CFIndex v46;
  const __CFArray *v47;
  const __CFArray *v48;
  CFIndex v49;
  id v50;
  void *v51;
  const __CFArray *PermittedSubtrees;
  uint64_t ExcludedSubtrees;
  const __CFArray *v54;
  CFIndex v55;
  uint64_t v56;
  id v57;
  void *v58;
  uint64_t Length;
  id v60;
  void *v61;
  unsigned int v62;
  NSNumber *v63;
  void *v64;
  CFDictionaryRef *ValueAtIndex;
  void *Value;
  void *v67;
  id v68;
  uint64_t v69;
  void *i;
  id v71;
  void *v72;
  uint64_t v73;
  uint64_t v74;
  id v75;
  uint64_t *v76;
  uint64_t v77;
  __SecCertificate *v78;
  uint64_t v79;
  int v80;
  uint64_t v81;
  CFDataRef v82;
  CFDataRef v83;
  uint64_t v84;
  uint64_t v85;
  void *v86;
  id v87;
  void *v88;
  id v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  void *v93;
  uint64_t v94;
  uint64_t v95;
  void *v96;
  id v97;
  void *v98;
  uint64_t v99;
  id v100;
  void *v101;
  uint64_t v102;
  id v103;
  void *v104;
  void *v105;
  id v106;
  void *v107;
  id v108;
  void *v109;
  uint64_t v110;
  id v111;
  void *v112;
  id v113;
  void *v114;
  void *v115;
  id v116;
  void *v117;
  id v118;
  void *v119;
  void *v120;
  id v121;
  void *v122;
  id v123;
  void *v124;
  void *v125;
  id v126;
  uint64_t v128;
  uint64_t v129;
  uint64_t v131;
  mach_timebase_info info;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  _QWORD v137[16];

  v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
    v131 = *(_QWORD *)(v2 + 272);
  else
    v131 = 0;
  v128 = *(_QWORD *)(v2 + 200);
  v3 = v1;
  v129 = *(_QWORD *)(v2 + 272);
  info = (mach_timebase_info)0xAAAAAAAAAAAAAAAALL;
  mach_timebase_info(&info);
  if (v129)
    v4 = (float)(mach_absolute_time() - *(_QWORD *)v129);
  else
    v4 = 0.0;
  v5 = sub_100015ECC(v2);
  v6 = v5;
  v7 = *(_QWORD **)(v2 + 200);
  if (!v7 || (v8 = v7[2], v8 < 1))
  {
    v11 = 0;
    v10 = 0;
LABEL_12:
    v12 = 0;
    goto LABEL_20;
  }
  v9 = v7[17];
  if (v9)
    v10 = *(_QWORD *)(v9 + 16);
  else
    v10 = 0;
  if (v8 >= 2 && (v13 = v7[18]) != 0)
    v11 = *(_QWORD *)(v13 + 16);
  else
    v11 = 0;
  v14 = v7[v8 + 16];
  if (!v14)
    goto LABEL_12;
  v12 = *(_QWORD *)(v14 + 16);
LABEL_20:
  v15 = +[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", sub_1000200E0(*(const __CFArray **)(v5 + 8)));
  v16 = (void *)objc_claimAutoreleasedReturnValue(v15);
  objc_msgSend(v3, "setObject:forKeyedSubscript:", v16, CFSTR("Policy"));

  v17 = +[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", sub_100017818(v2));
  v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
  objc_msgSend(v3, "setObject:forKeyedSubscript:", v18, CFSTR("Caller"));

  v19 = +[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", sub_1000029B4(v2, v12));
  v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
  objc_msgSend(v3, "setObject:forKeyedSubscript:", v20, CFSTR("AnchorSource"));

  if (v7)
    v21 = v7[2];
  else
    v21 = 0;
  v22 = sub_100020080(v21, 1);
  v23 = (void *)objc_claimAutoreleasedReturnValue(v22);
  objc_msgSend(v3, "setObject:forKeyedSubscript:", v23, CFSTR("NumberCertsInChain"));

  v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(v6 + 64)));
  objc_msgSend(v3, "setObject:forKeyedSubscript:", v24, CFSTR("TrustResult"));

  v25 = +[NSDate dateWithTimeIntervalSinceReferenceDate:](NSDate, "dateWithTimeIntervalSinceReferenceDate:", SecCertificateNotValidBefore(v10));
  v26 = (void *)objc_claimAutoreleasedReturnValue(v25);
  v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSCalendar calendarWithIdentifier:](NSCalendar, "calendarWithIdentifier:", NSCalendarIdentifierGregorian));
  v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSTimeZone timeZoneForSecondsFromGMT:](NSTimeZone, "timeZoneForSecondsFromGMT:", 0));
  objc_msgSend(v27, "setTimeZone:", v28);

  v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v27, "components:fromDate:", 12, v26));
  v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v27, "dateFromComponents:", v29));
  objc_msgSend(v30, "timeIntervalSince1970");
  v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v31 * 1000.0));

  objc_msgSend(v3, "setObject:forKeyedSubscript:", v32, CFSTR("LeafIssuanceDate"));
  v33 = +[NSNumber numberWithLong:](NSNumber, "numberWithLong:", CFSetGetCount(*(CFSetRef *)(v2 + 136)));
  v34 = (void *)objc_claimAutoreleasedReturnValue(v33);
  objc_msgSend(v3, "setObject:forKeyedSubscript:", v34, CFSTR("NumberChainsBuilt"));

  *(float *)&v35 = v4 * (float)((float)info.numer / (float)info.denom);
  v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v35));
  objc_msgSend(v3, "setObject:forKeyedSubscript:", v36, CFSTR("EvaluationTime"));

  if (v10)
  {
    v37 = (const __CFArray *)SecCertificateCopyDNSNames(v10);
    v38 = v37;
    if (v37)
    {
      Count = CFArrayGetCount(v37);
      if (Count >= 0)
        v40 = Count;
      else
        v40 = 0x7FFFFFFFLL;
      CFRelease(v38);
    }
    else
    {
      v40 = 0;
    }
    v41 = (const __CFArray *)SecCertificateCopyIPAddresses(v10);
    v42 = v41;
    if (v41)
    {
      v43 = CFArrayGetCount(v41);
      if (v43 + v40 < 0 != __OFADD__(v43, v40))
        v40 = 0x7FFFFFFFLL;
      else
        v40 += v43;
      CFRelease(v42);
    }
    v44 = (const __CFArray *)SecCertificateCopyRFC822Names(v10);
    v45 = v44;
    if (v44)
    {
      v46 = CFArrayGetCount(v44);
      if (v46 + v40 < 0 != __OFADD__(v46, v40))
        v40 = 0x7FFFFFFFLL;
      else
        v40 += v46;
      CFRelease(v45);
    }
    v47 = (const __CFArray *)SecCertificateCopyURIs(v10);
    v48 = v47;
    if (v47 && (v49 = CFArrayGetCount(v47), CFRelease(v48), v40 += v49, v40 < 0))
    {
      v40 = 0x7FFFFFFFLL;
    }
    else if ((unint64_t)v40 < 0x64)
    {
      goto LABEL_46;
    }
    v50 = sub_100020080(v40, 1);
    v51 = (void *)objc_claimAutoreleasedReturnValue(v50);
    objc_msgSend(v3, "setObject:forKeyedSubscript:", v51, CFSTR("NumberSANs"));

  }
LABEL_46:
  if (v11)
  {
    PermittedSubtrees = (const __CFArray *)SecCertificateGetPermittedSubtrees(v11);
    ExcludedSubtrees = SecCertificateGetExcludedSubtrees(v11);
    v54 = (const __CFArray *)ExcludedSubtrees;
    if (PermittedSubtrees)
    {
      v55 = CFArrayGetCount(PermittedSubtrees);
      if (v55 >= 0)
        v56 = v55;
      else
        v56 = 0x7FFFFFFFLL;
      if (!v54)
        goto LABEL_55;
    }
    else
    {
      v56 = 0;
      if (!ExcludedSubtrees)
        goto LABEL_55;
    }
    v56 += CFArrayGetCount(v54);
    if (v56 < 0)
    {
      v56 = 0x7FFFFFFFLL;
LABEL_58:
      v57 = sub_100020080(v56, 1);
      v58 = (void *)objc_claimAutoreleasedReturnValue(v57);
      objc_msgSend(v3, "setObject:forKeyedSubscript:", v58, CFSTR("NumberNCs"));

      goto LABEL_59;
    }
LABEL_55:
    if ((unint64_t)v56 < 0xA)
      goto LABEL_59;
    goto LABEL_58;
  }
LABEL_59:
  if (v10)
  {
    Length = SecCertificateGetLength(v10);
    if (Length >= 0x2000)
    {
      v60 = sub_100020080(Length, 1);
      v61 = (void *)objc_claimAutoreleasedReturnValue(v60);
      objc_msgSend(v3, "setObject:forKeyedSubscript:", v61, CFSTR("CertSize"));

    }
  }
  v62 = *(_DWORD *)(v6 + 64);
  if (v62 <= 7 && ((0x17u >> v62) & 1) == 0)
  {
    v63 = +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", sub_10005267C(v2, 0));
    v64 = (void *)objc_claimAutoreleasedReturnValue(v63);
    objc_msgSend(v3, "setObject:forKeyedSubscript:", v64, CFSTR("Error"));

  }
  if (!*(_BYTE *)(v2 + 178))
    objc_msgSend(v3, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("NoNetwork"));
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v6 + 8), *(_QWORD *)(v6 + 24));
  Value = (void *)CFDictionaryGetValue(ValueAtIndex[4], kSecPolicyCheckSSLHostname);
  if (Value)
  {
    v67 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(Value, "lowercaseString"));
    v135 = 0u;
    v136 = 0u;
    v133 = 0u;
    v134 = 0u;
    v68 = objc_msgSend(&off_10007FEE8, "countByEnumeratingWithState:objects:count:", &v133, v137, 16);
    if (v68)
    {
      v69 = *(_QWORD *)v134;
      while (2)
      {
        for (i = 0; i != v68; i = (char *)i + 1)
        {
          if (*(_QWORD *)v134 != v69)
            objc_enumerationMutation(&off_10007FEE8);
          if ((objc_msgSend(v67, "hasSuffix:", *(_QWORD *)(*((_QWORD *)&v133 + 1) + 8 * (_QWORD)i)) & 1) != 0)
          {

            objc_msgSend(v3, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("AppleDomain"));
            goto LABEL_78;
          }
        }
        v68 = objc_msgSend(&off_10007FEE8, "countByEnumeratingWithState:objects:count:", &v133, v137, 16);
        if (v68)
          continue;
        break;
      }
    }

  }
LABEL_78:
  if (v129 && *(_BYTE *)(v129 + 8))
    objc_msgSend(v3, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("SuspectedMitM"));

  v71 = v3;
  v72 = v71;
  v73 = v128;
  if (v128)
  {
    if (*(_BYTE *)(*(_QWORD *)(v128 + 136) + 40))
    {
      objc_msgSend(v71, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("OptionallyEV"));
      v73 = v128;
    }
    if (*(_BYTE *)(v73 + 65))
      objc_msgSend(v72, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("IsEV"));
  }

  v74 = *(_QWORD *)(a1 + 32);
  v75 = v72;
  v76 = *(uint64_t **)(v74 + 200);
  if (v76 && v76[2] >= 1 && (v77 = v76[17]) != 0)
    v78 = *(__SecCertificate **)(v77 + 16);
  else
    v78 = 0;
  v79 = sub_100015ECC(v74);
  v80 = sub_1000200E0(*(const __CFArray **)(v79 + 8));
  v81 = *(_QWORD *)(v74 + 272);
  if (sub_10000DE5C((uint64_t)v76))
    objc_msgSend(v75, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("WeakHash"));
  if (sub_10000DEB8((uint64_t)v76))
    objc_msgSend(v75, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("WeakKey"));
  v82 = SecCertificateCopySerialNumberData(v78, 0);
  v83 = v82;
  if (v82 && (unint64_t)-[__CFData length](v82, "length") >= 0x15)
    objc_msgSend(v75, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("LargeSerialNumber"));
  if (v81)
  {
    if (*(_BYTE *)(v81 + 9))
      objc_msgSend(v75, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("MissingEKU"));
    if (*(_BYTE *)(v81 + 10))
      objc_msgSend(v75, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("MultipurposeEKU"));
  }
  if ((v80 & 7) == 1)
  {
    v84 = SecCertificateCopyDNSNamesFromSAN(v78);
    v85 = SecCertificateCopyIPAddresses(v78);
    if (!(v84 | v85))
      objc_msgSend(v75, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("NoName"));

  }
  if (v80 == 3)
  {
    v86 = (void *)SecCertificateCopyRFC822NamesFromSAN(v78);
    if (!v86)
      objc_msgSend(v75, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("NoName"));

  }
  if (!SecCertificateGetOCSPResponders(v78))
    objc_msgSend(v75, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("MissingOCSPResponder"));
  *(_QWORD *)&v133 = 0;
  *((_QWORD *)&v133 + 1) = &v133;
  *(_QWORD *)&v134 = 0x2020000000;
  DWORD2(v134) = -1431655766;
  v137[0] = _NSConcreteStackBlock;
  v137[1] = 3221225472;
  v137[2] = sub_100021590;
  v137[3] = &unk_1000793D0;
  v137[4] = &v133;
  v137[5] = v78;
  sub_10000BF20((uint64_t)v137);
  v87 = sub_100020080(*(int *)(*((_QWORD *)&v133 + 1) + 24), 1);
  v88 = (void *)objc_claimAutoreleasedReturnValue(v87);
  objc_msgSend(v75, "setObject:forKeyedSubscript:", v88, CFSTR("LeafLifetime"));

  v89 = v75;
  if (v76 && (v90 = v76[2], v90 >= 1) && (v91 = v76[v90 + 16]) != 0)
    v92 = *(_QWORD *)(v91 + 16);
  else
    v92 = 0;
  if (qword_100082ED8 != -1)
    dispatch_once(&qword_100082ED8, &stru_1000793F0);
  v93 = (void *)SecCertificateCopySHA256Digest(v92);
  if (v76 && v76[2] >= 2 && qword_100082ED0 && objc_msgSend((id)qword_100082ED0, "containsObject:", v93))
  {
    if (v76[2] >= 2 && (v94 = v76[18]) != 0)
      v95 = *(_QWORD *)(v94 + 16);
    else
      v95 = 0;
    v96 = (void *)SecCertificateCopySHA256Digest(v95);
    v97 = v96;
    if (v96 && objc_msgSend(v96, "length") == (id)32)
    {
      v97 = objc_retainAutorelease(v97);
      v98 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)objc_msgSend(v97, "bytes")));
      objc_msgSend(v89, "setObject:forKeyedSubscript:", v98, CFSTR("SymantecCA"));

    }
  }

  if (SecCertificateNotValidBefore(v78) >= 561340800.0)
    objc_msgSend(v89, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("AfterCTFlagDay"));
  _Block_object_dispose(&v133, 8);

  v99 = *(_QWORD *)(a1 + 32);
  v100 = v89;
  v101 = *(void **)(v99 + 96);
  if (v101)
  {
    CFRetain(*(CFTypeRef *)(v99 + 96));
    if (objc_msgSend(v101, "count"))
      objc_msgSend(v100, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("OCSPStapled"));
  }
  v102 = *(_QWORD *)(v99 + 272);
  if (v102)
  {
    if (*(_BYTE *)(v102 + 47))
      objc_msgSend(v100, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("OCSPCached"));
    if (*(_BYTE *)(v102 + 46))
      objc_msgSend(v100, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("OCSPNoCheck"));
    if (*(_BYTE *)(v102 + 69))
      objc_msgSend(v100, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("OCSPWeakHash"));
    if (*(_BYTE *)(v102 + 48))
    {
      objc_msgSend(v100, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("OCSPNetwork"));
      objc_msgSend(v100, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("OCSPlibDER"));
      v103 = sub_100020080(*(unsigned int *)(v102 + 52), 1);
      v104 = (void *)objc_claimAutoreleasedReturnValue(v103);
      objc_msgSend(v100, "setObject:forKeyedSubscript:", v104, CFSTR("OCSPFetches"));

      v105 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(v102 + 56)));
      objc_msgSend(v100, "setObject:forKeyedSubscript:", v105, CFSTR("OCSPFetchTime"));

      v106 = sub_100020080(*(unsigned int *)(v102 + 64), 1);
      v107 = (void *)objc_claimAutoreleasedReturnValue(v106);
      objc_msgSend(v100, "setObject:forKeyedSubscript:", v107, CFSTR("OCSPFailed"));

      if (*(_BYTE *)(v102 + 68))
        objc_msgSend(v100, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("OCSPInvalidResponse"));
    }
  }

  if (v131)
  {
    v108 = v100;
    v109 = v108;
    if (v128 && *(_BYTE *)(v128 + 66))
      objc_msgSend(v108, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("IsCTValidated"));
    v110 = *(unsigned int *)(v131 + 12);
    if ((_DWORD)v110)
    {
      v111 = sub_100020080(v110, 1);
      v112 = (void *)objc_claimAutoreleasedReturnValue(v111);
      objc_msgSend(v109, "setObject:forKeyedSubscript:", v112, CFSTR("NumberSCTs"));

      v113 = sub_100020080(*(unsigned int *)(v131 + 16), 1);
      v114 = (void *)objc_claimAutoreleasedReturnValue(v113);
      objc_msgSend(v109, "setObject:forKeyedSubscript:", v114, CFSTR("NumberTrustedSCTs"));

      v115 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", *(unsigned __int8 *)(v131 + 11)));
      objc_msgSend(v109, "setObject:forKeyedSubscript:", v115, CFSTR("SCTSources"));

    }
    if (*(_BYTE *)(v131 + 20))
      objc_msgSend(v109, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("CTOneLeft"));

    v116 = v109;
    v117 = v116;
    if (*(_BYTE *)(v131 + 21))
      objc_msgSend(v116, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("CAIssuerCache"));
    if (*(_BYTE *)(v131 + 22))
    {
      objc_msgSend(v117, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("CAIssuerNetwork"));
      v118 = sub_100020080(*(unsigned int *)(v131 + 24), 1);
      v119 = (void *)objc_claimAutoreleasedReturnValue(v118);
      objc_msgSend(v117, "setObject:forKeyedSubscript:", v119, CFSTR("CAIssuerFetches"));

      v120 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(v131 + 32)));
      objc_msgSend(v117, "setObject:forKeyedSubscript:", v120, CFSTR("CAIssuerFetchTime"));

      v121 = sub_100020080(*(unsigned int *)(v131 + 40), 1);
      v122 = (void *)objc_claimAutoreleasedReturnValue(v121);
      objc_msgSend(v117, "setObject:forKeyedSubscript:", v122, CFSTR("CAIssuerFailed"));

      if (*(_BYTE *)(v131 + 44))
        objc_msgSend(v117, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("CAIssuerUnsupportedData"));
      if (*(_BYTE *)(v131 + 45))
        objc_msgSend(v117, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("CAIssuerMultipleCerts"));
    }

    v123 = v117;
    v124 = v123;
    if (*(_BYTE *)(v131 + 71))
      objc_msgSend(v123, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("ValidOCSPTriggered"));
    if (*(_BYTE *)(v131 + 70))
    {
      v125 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:"));
      objc_msgSend(v124, "setObject:forKeyedSubscript:", v125, CFSTR("ValidStatus"));

    }
    if (*(_BYTE *)(v131 + 72))
      objc_msgSend(v124, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("ValidRequireCT"));
    if (*(_BYTE *)(v131 + 73))
      objc_msgSend(v124, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("ValidKnownIntermediatesOnly"));
    if (*(_BYTE *)(v131 + 74))
      objc_msgSend(v124, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("ValidUnknownIntermediate"));

  }
  v126 = v100;

  return v126;
}

void sub_100020060(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_100020080(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = 0;
  while (1)
  {
    v3 = qword_100062130[v2];
    v4 = a1 / v3;
    v5 = a1 / v3 >= 0 ? a1 / v3 : -v4;
    if (v5 < qword_100062130[a2])
      break;
    if (++v2 == 19)
      return 0;
  }
  return (id)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithLongLong:](NSNumber, "numberWithLongLong:", v4 * v3));
}

uint64_t sub_1000200E0(const __CFArray *a1)
{
  CFDictionaryRef *ValueAtIndex;
  uint64_t Name;
  void *v3;
  unsigned __int8 v4;

  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(a1, 0);
  Name = SecPolicyGetName();
  v3 = (void *)objc_claimAutoreleasedReturnValue(Name);
  if ((objc_msgSend(v3, "isEqualToString:", kSecPolicyNameX509Basic) & 1) != 0)
  {
    v4 = 0;
  }
  else if ((objc_msgSend(v3, "isEqualToString:", kSecPolicyNameSSLServer) & 1) != 0)
  {
    v4 = 1;
  }
  else if ((objc_msgSend(v3, "isEqualToString:", kSecPolicyNameSSLClient) & 1) != 0)
  {
    v4 = 2;
  }
  else if ((objc_msgSend(v3, "isEqualToString:", kSecPolicyNameSMIME) & 1) != 0)
  {
    v4 = 3;
  }
  else if ((objc_msgSend(v3, "isEqualToString:", kSecPolicyNameEAPServer) & 1) != 0
         || (objc_msgSend(v3, "isEqualToString:", kSecPolicyNameEAPClient) & 1) != 0)
  {
    v4 = 4;
  }
  else if ((objc_msgSend(v3, "isEqualToString:", kSecPolicyNameIPSecServer) & 1) != 0
         || (objc_msgSend(v3, "isEqualToString:", kSecPolicyNameIPSecClient) & 1) != 0)
  {
    v4 = 5;
  }
  else if ((objc_msgSend(v3, "isEqualToString:", kSecPolicyNameCodeSigning) & 1) != 0)
  {
    v4 = 6;
  }
  else if ((objc_msgSend(v3, "isEqualToString:", kSecPolicyNameTimeStamping) & 1) != 0)
  {
    v4 = 7;
  }
  else if ((objc_msgSend(v3, "isEqualToString:", kSecPolicyNameOCSPSigner) & 1) != 0)
  {
    v4 = 8;
  }
  else if (CFDictionaryGetValue(ValueAtIndex[4], kSecPolicyCheckSSLHostname))
  {
    v4 = 9;
  }
  else
  {
    v4 = 10;
  }

  return v4;
}

void sub_100020864(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  uint64_t v29;

  _Block_object_dispose(&a19, 8);
  _Block_object_dispose((const void *)(v29 - 160), 8);
  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a29, 8);
  _Unwind_Resume(a1);
}

void sub_100020E34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61)
{
  _Block_object_dispose(&a22, 8);
  _Block_object_dispose(&a28, 8);
  _Block_object_dispose(&a34, 8);
  _Block_object_dispose(&a40, 8);
  _Block_object_dispose(&a46, 8);
  _Block_object_dispose(&a50, 8);
  _Block_object_dispose(&a55, 8);
  _Block_object_dispose(&a61, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100020ED0(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  CFDictionaryRef *ValueAtIndex;
  uint64_t result;
  uint64_t v9;
  CFTypeID v10;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v4 && *(uint64_t *)(v4 + 16) >= 1 && (v5 = *(_QWORD *)(v4 + 136)) != 0)
    v6 = *(_QWORD *)(v5 + 16);
  else
    v6 = 0;
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (result)
  {
    v9 = result;
    v10 = CFGetTypeID((CFTypeRef)result);
    result = CFStringGetTypeID();
    if (v10 == result)
    {
      result = SecPolicyCheckCertSubjectCommonNameTEST(v6, v9);
      if ((result & 1) == 0)
        return sub_10000E2C8(a1, a2, 0, kCFBooleanFalse, 0, 0);
    }
  }
  return result;
}

uint64_t sub_100020FA4(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  CFDictionaryRef *ValueAtIndex;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v4)
    v5 = *(_QWORD *)(v4 + 16);
  else
    v5 = 0;
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (v5 >= 3)
  {
    v8 = result;
    v9 = 0;
    v10 = (const void *)kSecPolicyCheckIntermediateOrganization;
    do
    {
      v11 = *(_QWORD *)(*(_QWORD *)a1 + 200);
      if (v11 && *(_QWORD *)(v11 + 16) > v9 + 1 && (v12 = *(_QWORD *)(v11 + 8 * v9 + 144)) != 0)
        v13 = *(_QWORD *)(v12 + 16);
      else
        v13 = 0;
      result = SecPolicyCheckCertSubjectOrganization(v13, v8);
      if ((result & 1) == 0)
        result = sub_10000E2C8(a1, v10, v9 + 1, kCFBooleanFalse, 1, 0);
      ++v9;
    }
    while (v5 - 2 != v9);
  }
  return result;
}

uint64_t sub_1000210A0(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  CFDictionaryRef *ValueAtIndex;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v4)
    v5 = *(_QWORD *)(v4 + 16);
  else
    v5 = 0;
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (v5 >= 3)
  {
    v8 = result;
    v9 = 0;
    v10 = (const void *)kSecPolicyCheckIntermediateCountry;
    do
    {
      v11 = *(_QWORD *)(*(_QWORD *)a1 + 200);
      if (v11 && *(_QWORD *)(v11 + 16) > v9 + 1 && (v12 = *(_QWORD *)(v11 + 8 * v9 + 144)) != 0)
        v13 = *(_QWORD *)(v12 + 16);
      else
        v13 = 0;
      result = SecPolicyCheckCertSubjectCountry(v13, v8);
      if ((result & 1) == 0)
        result = sub_10000E2C8(a1, v10, v9 + 1, kCFBooleanFalse, 1, 0);
      ++v9;
    }
    while (v5 - 2 != v9);
  }
  return result;
}

uint64_t sub_10002119C(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  CFDictionaryRef *ValueAtIndex;
  const __CFDictionary *Value;
  const void *v9;
  uint64_t result;
  const void *v11;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v4 && *(uint64_t *)(v4 + 16) >= 1 && (v5 = *(_QWORD *)(v4 + 136)) != 0)
    v6 = *(_QWORD *)(v5 + 16);
  else
    v6 = 0;
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  Value = (const __CFDictionary *)CFDictionaryGetValue(ValueAtIndex[4], a2);
  v9 = CFDictionaryGetValue(Value, kSecPolicyLeafMarkerProd);
  result = SecPolicyCheckCertLeafMarkerOid(v6, v9);
  if ((result & 1) == 0)
  {
    if ((SecIsInternalRelease(result) & 1) == 0
      && !sub_100035BA4()
      && !CFPreferencesGetAppBooleanValue(CFSTR("AppleServerAuthenticationAllowUATIdMS"), CFSTR("com.apple.security"), 0))
    {
      return sub_10000E2C8(a1, kSecPolicyCheckLeafMarkersProdAndQA, 0, kCFBooleanFalse, 1, 0);
    }
    v11 = CFDictionaryGetValue(Value, kSecPolicyLeafMarkerQA);
    result = SecPolicyCheckCertLeafMarkerOid(v6, v11);
    if ((result & 1) == 0)
      return sub_10000E2C8(a1, kSecPolicyCheckLeafMarkersProdAndQA, 0, kCFBooleanFalse, 1, 0);
  }
  return result;
}

uint64_t sub_1000212B4(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  CFDictionaryRef *ValueAtIndex;
  const void *Value;
  const void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t result;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v4)
    v5 = *(_QWORD *)(v4 + 16);
  else
    v5 = 0;
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  Value = CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (v5 < 3)
    return sub_10000E2C8(a1, kSecPolicyCheckIntermediateMarkerOid, 0, kCFBooleanFalse, 1, 0);
  v8 = Value;
  v9 = 0;
  v10 = v5 - 2;
  while (1)
  {
    v11 = *(_QWORD *)(*(_QWORD *)a1 + 200);
    if (v11 && *(_QWORD *)(v11 + 16) > v9 + 1 && (v12 = *(_QWORD *)(v11 + 8 * v9 + 144)) != 0)
      v13 = *(_QWORD *)(v12 + 16);
    else
      v13 = 0;
    result = SecCertificateHasMarkerExtension(v13, v8);
    if ((result & 1) != 0)
      break;
    if (v10 == ++v9)
      return sub_10000E2C8(a1, kSecPolicyCheckIntermediateMarkerOid, 0, kCFBooleanFalse, 1, 0);
  }
  return result;
}

uint64_t sub_1000213A4(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  CFDictionaryRef *ValueAtIndex;
  uint64_t result;
  uint64_t v9;
  CFTypeID v10;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v4 && *(uint64_t *)(v4 + 16) >= 1 && (v5 = *(_QWORD *)(v4 + 136)) != 0)
    v6 = *(_QWORD *)(v5 + 16);
  else
    v6 = 0;
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (result)
  {
    v9 = result;
    v10 = CFGetTypeID((CFTypeRef)result);
    result = CFStringGetTypeID();
    if (v10 == result)
    {
      result = SecPolicyCheckCertSubjectOrganization(v6, v9);
      if ((result & 1) == 0)
        return sub_10000E2C8(a1, a2, 0, kCFBooleanFalse, 0, 0);
    }
  }
  return result;
}

uint64_t sub_100021478(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

id sub_100021484(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "logHardFailureForEventNamed:withAttributes:timestampBucket:", *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(unsigned int *)(a1 + 56));
}

uint64_t sub_100021498(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _BYTE *v4;

  result = CFDictionaryContainsKey(*(CFDictionaryRef *)(a2 + 32), kSecPolicyCheckTemporalValidity);
  if ((_DWORD)result)
  {
    v4 = *(_BYTE **)(a1 + 40);
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
    *v4 = 1;
  }
  return result;
}

void sub_1000214E0(id a1)
{
  unsigned __int8 v1;

  do
    v1 = __ldaxr(byte_100082EB0);
  while (__stlxr(0, byte_100082EB0));
  if ((v1 & 1) != 0)
    xpc_transaction_end();
}

CFBooleanRef sub_100021500(uint64_t a1, const void *a2)
{
  CFDictionaryRef *ValueAtIndex;
  CFBooleanRef result;
  int v6;

  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  result = (CFBooleanRef)CFDictionaryGetValue(ValueAtIndex[4], a2);
  v6 = result == kCFBooleanTrue;
  if (*(unsigned __int8 *)(*(_QWORD *)a1 + 179) != v6)
    *(_BYTE *)(*(_QWORD *)a1 + 179) = v6;
  return result;
}

uint64_t sub_100021590(uint64_t a1, __CFCalendar *a2)
{
  CFAbsoluteTime v4;
  CFAbsoluteTime v5;
  uint64_t result;
  int v7;

  v7 = -1431655766;
  v4 = SecCertificateNotValidBefore(*(_QWORD *)(a1 + 40));
  v5 = SecCertificateNotValidAfter(*(_QWORD *)(a1 + 40));
  result = CFCalendarGetComponentDifference(a2, v4, v5, 0, "M", &v7);
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v7;
  return result;
}

intptr_t sub_100021610(uint64_t a1, int a2, CFTypeRef cf, CFTypeRef a4, CFTypeRef a5, CFTypeRef a6)
{
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;

  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a2;
  if (!a2)
  {
    v12 = *(_QWORD **)(a1 + 40);
    if (!v12)
      return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 72));
    *v12 = a6;
    if (!a6)
      return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 72));
LABEL_13:
    CFRetain(a6);
    return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 72));
  }
  v9 = *(_QWORD **)(a1 + 48);
  if (v9)
  {
    *v9 = cf;
    if (cf)
      CFRetain(cf);
  }
  v10 = *(_QWORD **)(a1 + 56);
  if (v10)
  {
    *v10 = a4;
    if (a4)
      CFRetain(a4);
  }
  v11 = *(_QWORD **)(a1 + 64);
  if (v11)
  {
    *v11 = a5;
    a6 = a5;
    if (a5)
      goto LABEL_13;
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 72));
}

void sub_1000216B0(uint64_t a1)
{
  void (*v1)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  NSObject *v2;
  const void *v3;
  const __CFArray *v4;
  int v5;
  int v6;
  const __CFArray *v7;
  const void *v8;
  const void *v9;
  __int128 v10;
  double v11;
  __int128 v12;
  uint64_t v13;
  void (*v14[5])(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  __int128 v15;
  __int128 v16;
  uint64_t v17;

  v1 = *(void (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(a1 + 40);
  v2 = *(NSObject **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  v3 = *(const void **)(a1 + 48);
  v4 = *(const __CFArray **)(a1 + 56);
  v5 = *(unsigned __int8 *)(a1 + 176);
  v6 = *(unsigned __int8 *)(a1 + 177);
  v7 = *(const __CFArray **)(a1 + 64);
  v8 = *(const void **)(a1 + 72);
  v9 = *(const void **)(a1 + 80);
  v10 = *(_OWORD *)(a1 + 88);
  v11 = *(double *)(a1 + 104);
  v14[0] = (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))_NSConcreteStackBlock;
  v12 = *(_OWORD *)(a1 + 112);
  v14[2] = (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))sub_100021610;
  v14[3] = (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))&unk_1000796E8;
  v13 = *(_QWORD *)(a1 + 128);
  v14[1] = (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))0x40000000;
  v14[4] = v1;
  v15 = *(_OWORD *)(a1 + 136);
  v16 = *(_OWORD *)(a1 + 152);
  v17 = *(_QWORD *)(a1 + 168);
  sub_10000C900(v2, v3, v4, v7, v5, v6, v8, v9, v11, (const void *)v10, *((void **)&v10 + 1), (const void *)v12, *((const void **)&v12 + 1), v13, v14);
}

id sub_100021754(uint64_t a1)
{
  __CFString *v2;
  void *v3;
  const void *ValueAtIndex;
  uint64_t Name;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  __SecCertificate *v9;
  void *v10;
  void *v11;
  const __CFData *v12;
  CFIndex Length;
  __CFString *Mutable;
  const UInt8 *BytePtr;
  CFIndex v16;
  CFIndex v17;
  unsigned int v18;
  uint64_t v19;
  _QWORD v21[5];
  _QWORD v22[5];

  v2 = sub_10001799C(**(_QWORD **)(a1 + 32));
  v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(*(_QWORD *)(a1 + 32) + 8), 0);
  Name = SecPolicyGetName(ValueAtIndex);
  v6 = (void *)objc_claimAutoreleasedReturnValue(Name);
  v7 = *(_QWORD *)(**(_QWORD **)(a1 + 32) + 200);
  if (v7 && *(uint64_t *)(v7 + 16) >= 1 && (v8 = *(_QWORD *)(v7 + 136)) != 0)
    v9 = *(__SecCertificate **)(v8 + 16);
  else
    v9 = 0;
  v10 = (void *)SecCertificateCopyIssuerSummary(v9);
  if ((objc_msgSend(v10, "hasPrefix:", CFSTR("Charles Proxy")) & 1) != 0)
  {
    v11 = 0;
  }
  else
  {
    v12 = SecCertificateCopySerialNumberData(v9, 0);
    Length = CFDataGetLength(v12);
    Mutable = CFStringCreateMutable(kCFAllocatorDefault, 2 * Length);
    BytePtr = CFDataGetBytePtr(v12);
    v16 = CFDataGetLength(v12);
    if (v16 >= 1)
    {
      v17 = v16;
      do
      {
        v18 = *BytePtr++;
        CFStringAppendFormat(Mutable, 0, CFSTR("%02X"), v18);
        --v17;
      }
      while (v17);
    }
    v11 = 0;
    if (v10)
    {
      v19 = *(_QWORD *)(a1 + 40);
      if (v19)
      {
        if (v3 && v6 && Mutable)
        {
          v21[0] = CFSTR("Hostname");
          v21[1] = CFSTR("Caller");
          v22[0] = v19;
          v22[1] = v3;
          v21[2] = CFSTR("Policy");
          v21[3] = CFSTR("SerialNumber");
          v22[2] = v6;
          v22[3] = Mutable;
          v21[4] = CFSTR("IssuerName");
          v22[4] = v10;
          v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v22, v21, 5));
        }
      }
    }

  }
  return v11;
}

void sub_100021954(id a1)
{
  void *v1;
  id v2;
  void *v3;

  v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSCharacterSet URLPathAllowedCharacterSet](NSCharacterSet, "URLPathAllowedCharacterSet"));
  v2 = objc_msgSend(v1, "mutableCopy");
  v3 = (void *)qword_100082D48;
  qword_100082D48 = (uint64_t)v2;

  objc_msgSend((id)qword_100082D48, "removeCharactersInString:", CFSTR(":/?#[]@!$&'()*+,;="));
}

uint64_t sub_1000219A4(uint64_t a1, uint64_t a2, char a3, char a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, uint64_t a10, uint64_t a11, const __CFData *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  CFDataRef v22;
  NSObject *v23;
  __int128 v24;
  NSObject *v25;
  NSObject *v26;
  NSObject *v27;
  uint64_t v28;
  _QWORD block[22];
  char v35;
  char v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  dispatch_queue_t v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  int v44;
  uint8_t buf[12];
  mach_msg_type_number_t task_info_outCnt;
  _OWORD task_info_out[3];

  v22 = a12;
  v23 = dispatch_semaphore_create(0);
  v41 = 0;
  v42 = &v41;
  v43 = 0x2000000000;
  v44 = 0;
  v37 = 0;
  v38 = &v37;
  v39 = 0x2000000000;
  v40 = (dispatch_queue_t)0xAAAAAAAAAAAAAAAALL;
  v40 = dispatch_queue_create("com.apple.trustd.evaluation.recursive", 0);
  if (a12)
  {
    CFRetain(a12);
  }
  else
  {
    *(_QWORD *)&v24 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
    task_info_out[0] = v24;
    task_info_out[1] = v24;
    task_info_outCnt = 8;
    if (task_info(mach_task_self_, 0xFu, (task_info_t)task_info_out, &task_info_outCnt))
    {
      v25 = sub_100011628("SecWarning");
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "failed to get audit token for ourselves", buf, 2u);
      }
      v22 = 0;
    }
    else
    {
      v22 = CFDataCreate(0, (const UInt8 *)task_info_out, 32);
    }
  }
  v26 = v38[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_1000216B0;
  block[3] = &unk_100079710;
  block[6] = v22;
  block[7] = a1;
  v35 = a3;
  v36 = a4;
  block[8] = a2;
  block[9] = a5;
  block[10] = a6;
  block[11] = a7;
  block[12] = a8;
  *(double *)&block[13] = a9;
  block[14] = a10;
  block[15] = a11;
  block[4] = &v37;
  block[5] = &v41;
  block[16] = a13;
  block[17] = a17;
  block[18] = a14;
  block[19] = a15;
  block[20] = a16;
  block[21] = v23;
  dispatch_async(v26, block);
  dispatch_semaphore_wait(v23, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(v23);
  v27 = v38[3];
  if (v27)
  {
    v38[3] = 0;
    dispatch_release(v27);
  }
  if (v22)
    CFRelease(v22);
  v28 = *((unsigned int *)v42 + 6);
  _Block_object_dispose(&v37, 8);
  _Block_object_dispose(&v41, 8);
  return v28;
}

uint64_t sub_100021BF8(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t, __CFArray *))
{
  uint64_t NormalizedIssuerContent;
  const __CFArray *v8;
  const __CFArray *v9;
  CFTypeID v10;
  CFIndex Count;
  __CFArray *Mutable;
  CFTypeID v13;
  CFIndex v14;
  SecCertificateRef v15;
  SecCertificateRef v16;
  CFErrorRef err;
  _QWORD context[5];
  CFRange v20;

  NormalizedIssuerContent = SecCertificateGetNormalizedIssuerContent(a2);
  err = 0;
  v8 = (const __CFArray *)SecItemCopyParentCertificates_ios(NormalizedIssuerContent, *(_QWORD *)(a1 + 24), &err);
  if (v8)
  {
    v9 = v8;
    v10 = CFGetTypeID(v8);
    if (v10 == CFArrayGetTypeID())
    {
      Count = CFArrayGetCount(v9);
      Mutable = CFArrayCreateMutable(kCFAllocatorDefault, Count, &kCFTypeArrayCallBacks);
      context[0] = _NSConcreteStackBlock;
      context[1] = 0x40000000;
      context[2] = sub_1000390D4;
      context[3] = &unk_100076EE0;
      context[4] = Mutable;
      v20.length = CFArrayGetCount(v9);
      v20.location = 0;
      CFArrayApplyFunction(v9, v20, (CFArrayApplierFunction)sub_100039124, context);
    }
    else
    {
      v13 = CFGetTypeID(v9);
      if (v13 == CFDataGetTypeID())
      {
        v14 = CFArrayGetCount(v9);
        Mutable = CFArrayCreateMutable(kCFAllocatorDefault, v14, &kCFTypeArrayCallBacks);
        v15 = SecCertificateCreateWithData(kCFAllocatorDefault, v9);
        if (v15)
        {
          v16 = v15;
          CFArrayAppendValue(Mutable, v15);
          CFRelease(v16);
        }
      }
      else
      {
        Mutable = 0;
      }
    }
    CFRelease(v9);
    a4(a3, Mutable);
    if (Mutable)
      CFRelease(Mutable);
  }
  else
  {
    if (err)
    {
      CFErrorGetCode(err);
      if (err)
        CFRelease(err);
    }
    a4(a3, 0);
  }
  return 1;
}

unint64_t DERLengthOfEncodedSequenceFromObject(uint64_t a1, unint64_t a2, unint64_t a3, int a4, uint64_t a5, unint64_t *a6)
{
  unint64_t result;
  unint64_t v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  unint64_t v13;
  BOOL v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;

  v17 = 0;
  result = sub_100022444(a2, a3, a4, a5, &v17);
  if (!(_DWORD)result)
  {
    v9 = a1 & 0x1FFFFFFFFFFFFFFFLL;
    v10 = 1;
    if ((a1 & 0x1FFFFFFFFFFFFFFFuLL) >= 0x1F)
    {
      do
      {
        ++v10;
        v11 = v9 > 0x7F;
        v9 >>= 7;
      }
      while (v11);
    }
    v12 = 1;
    if (v17 >= 0x80)
    {
      v13 = v17;
      do
      {
        ++v12;
        v11 = v13 > 0xFF;
        v13 >>= 8;
      }
      while (v11);
    }
    v14 = __CFADD__(v10, v12);
    v15 = v10 + v12;
    if (v14 || (v14 = __CFADD__(v15, v17), v16 = v15 + v17, v14))
    {
      __break(0x5500u);
    }
    else
    {
      result = 0;
      *a6 = v16;
    }
  }
  return result;
}

uint64_t sub_100021E8C(uint64_t result, unint64_t a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  unint64_t v7;
  unint64_t v8;
  _BYTE *v9;
  _BYTE *v10;
  unint64_t v11;

  v3 = result & 0x1FFFFFFFFFFFFFFFLL;
  if ((result & 0x1FFFFFFFFFFFFFFFuLL) < 0x1F)
  {
    if (*a3)
    {
      *(_BYTE *)a2 = HIBYTE(result) & 0xE0 | result;
      v8 = 1;
      goto LABEL_17;
    }
    return 7;
  }
  v4 = 0;
  v5 = result & 0x1FFFFFFFFFFFFFFFLL;
  do
  {
    ++v4;
    v6 = v5 > 0x7F;
    v5 >>= 7;
  }
  while (v6);
  v7 = *a3;
  if (v4 >= *a3)
    return 7;
  if (v4 >= ~a2 || (*(_BYTE *)a2 = HIBYTE(result) | 0x1F, a2 + v4 == -2))
  {
LABEL_20:
    __break(0x5513u);
    goto LABEL_21;
  }
  if (a2 + v4 >= a2)
  {
    v8 = v4 + 1;
    *(_BYTE *)(a2 + v4) = result & 0x7F;
    if (v3 >= 0x80)
    {
      v9 = (_BYTE *)(a2 + v4 - 1);
      v10 = (_BYTE *)(a2 + v7);
      while (v9 != (_BYTE *)-2)
      {
        if (v9 >= v10 || (unint64_t)v9 < a2)
          goto LABEL_21;
        v11 = v3 >> 14;
        v3 >>= 7;
        *v9-- = v3 | 0x80;
        if (!v11)
          goto LABEL_17;
      }
      goto LABEL_20;
    }
LABEL_17:
    if (v8 <= *a3)
    {
      result = 0;
      *a3 = v8;
      return result;
    }
  }
LABEL_21:
  __break(0x5519u);
  return result;
}

uint64_t DEREncodeSequenceFromObject(uint64_t a1, unint64_t a2, unint64_t a3, unsigned int a4, uint64_t a5, unint64_t a6, unint64_t a7, unint64_t *a8)
{
  unint64_t v8;
  unint64_t v11;
  uint64_t result;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  _BYTE *v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  const void **v27;
  __int16 v28;
  unint64_t v30;
  unint64_t v31;
  char v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  size_t v36;
  unint64_t v37;
  size_t v39;
  BOOL v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v44;
  unint64_t v45;

  v8 = ~a6;
  if (~a6 < a7)
    goto LABEL_73;
  v11 = *a8;
  v44 = a7;
  v45 = 0;
  if (v11 < a7)
    goto LABEL_74;
  result = sub_100021E8C(a1, a6, &v44);
  if ((_DWORD)result)
    return result;
  if (v44 > v8)
    goto LABEL_73;
  v17 = a7 - v44;
  if (a7 < v44)
    goto LABEL_75;
  v18 = a6 + a7;
  v19 = a6 + v44;
  if (a6 + v44 < v18)
  {
    result = sub_100022444(a2, a3, a4, a5, &v45);
    if ((_DWORD)result)
      return result;
    v44 = v17;
    if (v19 > a6 + v11 || v19 < a6 || v17 > a6 + v11 - v19)
      goto LABEL_74;
    v42 = a6 + v11;
    v20 = v45;
    result = DEREncodeLengthSized(v45, v19, v17, (uint64_t *)&v44);
    if ((_DWORD)result)
      return result;
    v21 = v42;
    if (__CFADD__(v19, v44))
    {
LABEL_73:
      __break(0x5513u);
      goto LABEL_74;
    }
    v22 = v17 - v44;
    if (v17 >= v44)
    {
      v23 = (_BYTE *)(v19 + v44);
      if (!__CFADD__(v19 + v44, v20))
      {
        if ((unint64_t)&v23[v20] > v18)
          return 7;
        if (a4)
        {
          v24 = 0;
          v25 = a2 + a3;
          v41 = 24 * a4;
          while (1)
          {
            if (v24 > ~a5)
              goto LABEL_73;
            v26 = *(_QWORD *)(a5 + v24);
            if (v26 > ~a2)
              goto LABEL_73;
            v27 = (const void **)(a2 + v26);
            v28 = *(_WORD *)(a5 + v24 + 16);
            if ((v28 & 0x200) != 0)
              break;
            if ((v28 & 1) == 0)
              goto LABEL_29;
            if ((unint64_t)v27 < a2 || (unint64_t)(v27 + 2) > v25)
              goto LABEL_74;
            if (v27[1])
            {
LABEL_29:
              v44 = v22;
              if ((unint64_t)v23 > v21 || (unint64_t)v23 < a6 || v22 > v21 - (unint64_t)v23)
                goto LABEL_74;
              result = sub_100021E8C(*(_QWORD *)(a5 + v24 + 8), (unint64_t)v23, &v44);
              if ((_DWORD)result)
                return result;
              if (__CFADD__(v23, v44))
                goto LABEL_73;
              v30 = v22 - v44;
              if (v22 < v44)
                goto LABEL_75;
              if ((unint64_t)v27 < a2 || (unint64_t)(v27 + 2) > v25)
                goto LABEL_74;
              v31 = (unint64_t)v27[1];
              v45 = v31;
              v32 = 1;
              if ((v28 & 0x100) != 0 && v31 && *(char *)*v27 < 0)
              {
                v32 = 0;
                v45 = ++v31;
              }
              v33 = (unint64_t)&v23[v44];
              v44 = v30;
              if (v33 > v42 || v33 < a6 || v30 > v42 - v33)
                goto LABEL_74;
              result = DEREncodeLengthSized(v31, v33, v30, (uint64_t *)&v44);
              if ((_DWORD)result)
                return result;
              v34 = v44;
              if (__CFADD__(v33, v44))
                goto LABEL_73;
              v35 = v30 - v44;
              if (v30 < v44)
                goto LABEL_75;
              v23 = (_BYTE *)(v33 + v44);
              if ((v32 & 1) == 0)
              {
                if (v23 == (_BYTE *)-1)
                  goto LABEL_73;
                if ((unint64_t)v23 >= v42 || (unint64_t)v23 < a6)
                  goto LABEL_74;
                *v23 = 0;
                --v35;
                if (v30 == v34)
                  goto LABEL_75;
                ++v23;
              }
              if ((unint64_t)v23 > v42)
                goto LABEL_74;
              if ((unint64_t)v23 < a6)
                goto LABEL_74;
              v36 = (size_t)v27[1];
              if (v36 > v42 - (unint64_t)v23)
                goto LABEL_74;
              result = (uint64_t)memmove(v23, *v27, v36);
              v21 = v42;
              v37 = (unint64_t)v27[1];
              if (__CFADD__(v23, v37))
                goto LABEL_73;
              v22 = v35 - v37;
              if (v35 < v37)
                goto LABEL_75;
              goto LABEL_69;
            }
LABEL_70:
            v24 += 24;
            if (v41 == v24)
              goto LABEL_71;
          }
          if ((unint64_t)v27 < a2 || (unint64_t)(v27 + 2) > v25)
            goto LABEL_74;
          if ((unint64_t)v23 > v21)
            goto LABEL_74;
          if ((unint64_t)v23 < a6)
            goto LABEL_74;
          v39 = (size_t)v27[1];
          if (v39 > v21 - (unint64_t)v23)
            goto LABEL_74;
          result = (uint64_t)memmove(v23, *v27, v39);
          v21 = v42;
          v37 = (unint64_t)v27[1];
          if (__CFADD__(v23, v37))
            goto LABEL_73;
          v40 = v22 >= v37;
          v22 -= v37;
          if (!v40)
            goto LABEL_75;
LABEL_69:
          v23 += v37;
          goto LABEL_70;
        }
LABEL_71:
        if ((unint64_t)&v23[-a6] <= *a8)
        {
          result = 0;
          *a8 = (unint64_t)&v23[-a6];
          return result;
        }
LABEL_74:
        __break(0x5519u);
      }
      goto LABEL_73;
    }
LABEL_75:
    __break(0x5515u);
    return result;
  }
  return 7;
}

unint64_t DEREncodeLengthSized(unint64_t result, unint64_t a2, unint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  BOOL v7;
  unint64_t v8;
  uint64_t v9;
  _BYTE *v10;
  _BYTE *v11;

  if (result >= 0x80)
  {
    v5 = 0;
    v6 = result;
    do
    {
      --v5;
      v7 = v6 > 0xFF;
      v6 >>= 8;
    }
    while (v7);
    v8 = -v5;
    v9 = 7;
    if (-v5 < a3 && v8 <= 0x7E)
    {
      if (*a4)
      {
        v4 = 1 - v5;
        *(_BYTE *)a2 = -(char)v5 | 0x80;
        if (v8 < ~a2)
        {
          v10 = (_BYTE *)(a2 - v5);
          if (a2 - v5 != -2)
          {
            v11 = (_BYTE *)(a2 + *a4);
            while (v10 != (_BYTE *)-1)
            {
              if (v10 >= v11 || (unint64_t)v10 < a2)
                goto LABEL_23;
              *v10-- = result;
              v7 = result > 0xFF;
              result >>= 8;
              if (!v7)
              {
                if (v8 >= *a4)
                  goto LABEL_23;
                goto LABEL_19;
              }
            }
          }
        }
        __break(0x5513u);
      }
      goto LABEL_23;
    }
    return v9;
  }
  if (!a3)
    return 7;
  if (*a4)
  {
    *(_BYTE *)a2 = result;
    if (*a4)
    {
      v4 = 1;
LABEL_19:
      v9 = 0;
      *a4 = v4;
      return v9;
    }
  }
LABEL_23:
  __break(0x5519u);
  return result;
}

unint64_t sub_100022444(unint64_t result, unint64_t a2, int a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v5;
  unsigned int v6;
  unint64_t v7;
  unint64_t v8;
  BOOL v9;
  unsigned __int8 **v10;
  __int16 v11;
  unint64_t v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unsigned __int8 *v20;
  unint64_t v21;
  uint64_t v22;

  v5 = 0;
  if (!a3)
  {
LABEL_38:
    result = 0;
LABEL_40:
    *a5 = v5;
    return result;
  }
  v6 = 0;
  v7 = result + a2;
  while (24 * (unint64_t)v6 <= ~a4)
  {
    v8 = *(_QWORD *)(a4 + 24 * v6);
    v9 = v8 > 0xFFFFFFFFFFFFFFEFLL || v8 + 16 > a2;
    if (v9)
    {
      v5 = 0;
      result = 7;
      goto LABEL_40;
    }
    if (v8 > ~result)
      break;
    v10 = (unsigned __int8 **)(result + v8);
    v11 = *(_WORD *)(a4 + 24 * v6 + 16);
    if ((v11 & 0x200) == 0)
    {
      if ((v11 & 1) != 0)
      {
        if ((unint64_t)v10 < result || (unint64_t)(v10 + 2) > v7)
          goto LABEL_43;
        if (!v10[1])
          goto LABEL_37;
      }
      v13 = *(_QWORD *)(a4 + 24 * v6 + 8) & 0x1FFFFFFFFFFFFFFFLL;
      v14 = 1;
      if (v13 >= 0x1F)
      {
        do
        {
          ++v14;
          v9 = v13 > 0x7F;
          v13 >>= 7;
        }
        while (v9);
      }
      v15 = __CFADD__(v5, v14);
      v16 = v5 + v14;
      if (v15)
        goto LABEL_42;
      if ((unint64_t)v10 < result || (unint64_t)(v10 + 2) > v7)
        goto LABEL_43;
      v17 = (unint64_t)v10[1];
      if ((*(_WORD *)(a4 + 24 * v6 + 16) & 0x100) != 0)
      {
        if (v17)
        {
          v17 += (unint64_t)**v10 >> 7;
          goto LABEL_24;
        }
LABEL_25:
        v18 = 1;
      }
      else
      {
LABEL_24:
        if (v17 < 0x80)
          goto LABEL_25;
        v18 = 1;
        v21 = v17;
        do
        {
          ++v18;
          v9 = v21 > 0xFF;
          v21 >>= 8;
        }
        while (v9);
      }
      v15 = __CFADD__(v16, v18);
      v22 = v16 + v18;
      if (v15)
        goto LABEL_42;
      v15 = __CFADD__(v22, v17);
      v5 = v22 + v17;
      if (v15)
        goto LABEL_42;
      goto LABEL_37;
    }
    if ((unint64_t)v10 < result || (unint64_t)(v10 + 2) > v7)
      goto LABEL_43;
    v20 = v10[1];
    v15 = __CFADD__(v5, v20);
    v5 += (uint64_t)v20;
    if (v15)
      goto LABEL_42;
LABEL_37:
    if (++v6 == a3)
      goto LABEL_38;
  }
  __break(0x5513u);
LABEL_42:
  __break(0x5500u);
LABEL_43:
  __break(0x5519u);
  return result;
}

void sub_100022628(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000227EC(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_100022A18(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100022AB4(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

double DERImg4DecodeFindInSequence(unint64_t *a1, uint64_t a2, _OWORD *a3)
{
  double result;
  unint64_t v7;
  __int128 v8;

  v7 = 0;
  v8 = 0uLL;
  while (!DERDecodeSeqNext(a1, &v7))
  {
    if (v7 == a2)
    {
      result = *(double *)&v8;
      *a3 = v8;
      return result;
    }
  }
  return result;
}

double DERImg4DecodeContentFindItemWithTag(unint64_t *a1, uint64_t a2, _OWORD *a3)
{
  double result;
  unint64_t v6[2];

  v6[0] = 0;
  v6[1] = 0;
  if (!DERDecodeSeqContentInit(a1, v6))
    return DERImg4DecodeFindInSequence(v6, a2, a3);
  return result;
}

uint64_t DERImg4DecodeTagCompare(uint64_t a1, unsigned int a2)
{
  unint64_t v2;
  unsigned int v5;

  v2 = *(_QWORD *)(a1 + 8);
  if (v2 < 4)
    return 0xFFFFFFFFLL;
  if (v2 != 4)
    return 1;
  v5 = 0;
  if (DERParseInteger((char **)a1, &v5))
    return 4294967294;
  if (v5 < a2)
    return 0xFFFFFFFFLL;
  return v5 > a2;
}

uint64_t DERImg4DecodeManifest(_QWORD *a1, unint64_t a2)
{
  return sub_100023584(a1, 5uLL, (uint64_t)&DERImg4ManifestItemSpecs, a2, 0x494D344Du);
}

uint64_t sub_100023584(_QWORD *a1, unint64_t a2, uint64_t a3, unint64_t a4, unsigned int a5)
{
  uint64_t result;
  unsigned int v9;

  result = 6;
  if (a1 && a4)
  {
    if (!*a1 || !a1[1])
      return 0;
    if (a2 >= 0x10000)
    {
      __break(0x5507u);
      return result;
    }
    result = DERParseSequenceToObject((uint64_t)a1, (unsigned __int16)a2, a3, a4, 0xC0uLL, 0);
    if (!(_DWORD)result)
    {
      if (DERImg4DecodeTagCompare(a4, a5))
        return 2;
      v9 = 0;
      result = DERParseInteger((char **)(a4 + 16), &v9);
      if ((_DWORD)result)
        return result;
      if (v9 > 2)
        return 2;
      return 0;
    }
  }
  return result;
}

uint64_t DERImg4DecodeUnsignedManifest(_QWORD *a1, unint64_t a2)
{
  return sub_100023584(a1, 3uLL, (uint64_t)&DERImg4UnsignedManifestItemSpecs, a2, 0x494D344Du);
}

uint64_t DERImg4DecodeCertificate(_QWORD *a1, unint64_t a2)
{
  return sub_100023584(a1, 4uLL, (uint64_t)&DERImg4CertificateItemSpecs, a2, 0x494D3443u);
}

uint64_t DERImg4DecodeUnsignedCertificate(_QWORD *a1, unint64_t a2)
{
  return sub_100023584(a1, 3uLL, (uint64_t)&DERImg4UnsignedManifestItemSpecs, a2, 0x494D3443u);
}

uint64_t DERImg4DecodeProperty(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  __int128 v13;
  unint64_t v14;
  __int128 v15;

  result = 6;
  if (a1)
  {
    if (a3)
    {
      v14 = 0;
      v15 = 0uLL;
      v13 = 0uLL;
      v11 = 0;
      v12 = 0;
      v9 = 0;
      v10 = 0;
      v8 = 0;
      result = DERDecodeSeqInit((uint64_t)a1, &v9, &v10);
      if (!(_DWORD)result)
      {
        if (v9 != 0x2000000000000010)
          return 2;
        result = DERDecodeSeqNext(&v10, &v14);
        if ((_DWORD)result)
          return result;
        if (v14 != 22)
          return 2;
        result = DERParseInteger((char **)&v15, &v8);
        if ((_DWORD)result)
          return result;
        if ((v8 | 0xE000000000000000) != a2)
          return 2;
        *(_OWORD *)a3 = v15;
        result = DERDecodeSeqNext(&v10, &v12);
        if ((_DWORD)result)
          return result;
        *(_QWORD *)(a3 + 40) = v12;
        *(_OWORD *)(a3 + 24) = v13;
        result = DERDecodeSeqNext(&v10, &v12);
        if ((_DWORD)result != 1)
          return 2;
        v7 = a1[1];
        if (__CFADD__(*a1, v7))
        {
          __break(0x5513u);
        }
        else if (v11 == *a1 + v7)
        {
          return 0;
        }
        else
        {
          return 7;
        }
      }
    }
  }
  return result;
}

uint64_t DERImg4DecodePropertyWithItem(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t result;
  unsigned int v8;
  _QWORD v9[4];
  __int128 v10;

  v8 = 0;
  v9[0] = 0;
  v9[2] = 0;
  v9[1] = 22;
  v9[3] = 24;
  v10 = a3;
  result = DERParseSequenceToObject(a1, 2u, (uint64_t)v9, a4, 0x30uLL, 0);
  if (!(_DWORD)result)
  {
    result = DERParseInteger((char **)a4, &v8);
    if (!(_DWORD)result)
    {
      if ((v8 | 0xE000000000000000) == a2)
      {
        result = 0;
        *(_QWORD *)(a4 + 16) = a2 | 0xE000000000000000;
        *(_QWORD *)(a4 + 40) = a3;
      }
      else
      {
        return 2;
      }
    }
  }
  return result;
}

void DERImg4DecodeFindPropertyInSequence(unint64_t *a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  int v7;
  __int128 v8;

  v8 = 0uLL;
  DERImg4DecodeFindInSequence(a1, a2, &v8);
  if (!v7)
    DERImg4DecodePropertyWithItem((uint64_t)&v8, a2, a3, a4);
}

void DERImg4DecodeFindProperty(unint64_t *a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v7[2];

  v7[0] = 0;
  v7[1] = 0;
  if (!DERDecodeSeqContentInit(a1, v7))
    DERImg4DecodeFindPropertyInSequence(v7, a2, a3, a4);
}

void DERImg4DecodeParseManifestProperties(uint64_t a1, unint64_t a2, unint64_t a3)
{
  sub_10002393C(a1, a2, a3, 0x4D414E42u);
}

void sub_10002393C(uint64_t a1, unint64_t a2, unint64_t a3, unsigned int a4)
{
  unint64_t v8;
  int v9;
  int v10;
  int v11;
  _OWORD v12[3];
  _OWORD v13[3];
  unint64_t v14;
  unint64_t v15[2];

  v11 = 0;
  if (a1)
  {
    if (a2 | a3)
    {
      v14 = 0;
      v15[0] = 0;
      v15[1] = 0;
      memset(v13, 0, sizeof(v13));
      memset(v12, 0, sizeof(v12));
      if (!DERDecodeItem(a1 + 264, &v14)
        && v14 == 0x2000000000000011
        && !DERParseInteger((char **)(a1 + 248), &v11))
      {
        v8 = v11 == 2 ? 0x2000000000000010 : 0x2000000000000011;
        DERImg4DecodeFindProperty(v15, a4 | 0xE000000000000000, v8, (unint64_t)v13);
        if (!v9)
        {
          if (a2)
            *(_OWORD *)a2 = *(_OWORD *)((char *)&v13[1] + 8);
          DERImg4DecodeFindProperty((unint64_t *)&v13[1] + 1, 0xE00000004D414E50, 0x2000000000000011uLL, (unint64_t)v12);
          if (a3)
          {
            if (!v10)
              *(_OWORD *)a3 = *(_OWORD *)((char *)&v12[1] + 8);
          }
        }
      }
    }
  }
}

uint64_t Img4DecodeParseLengthFromBufferWithTag(uint64_t a1, uint64_t a2, unsigned int a3, _QWORD *a4)
{
  uint64_t result;
  uint64_t v8;
  BOOL v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD v14[2];
  unint64_t v15;
  _QWORD v16[2];
  _QWORD v17[2];

  v11 = 0;
  v12 = 0;
  v16[0] = 0;
  v16[1] = 0;
  v14[1] = 0;
  v15 = 0;
  result = 0xFFFFFFFFLL;
  v13 = 0;
  v14[0] = 0;
  if (a1)
  {
    if (a4)
    {
      v17[0] = a1;
      v17[1] = a2;
      result = DERDecodeItemPartialBufferGetLength((uint64_t)v17, &v15, &v12);
      if (!(_DWORD)result)
      {
        if (v12)
        {
          if (v15 != 0x2000000000000010)
            return 2;
          result = DERDecodeItemPartialBufferGetLength((uint64_t)v16, &v13, &v11);
          if ((_DWORD)result)
            return result;
          if (v11)
          {
            result = DERImg4DecodeTagCompare((uint64_t)v14, a3);
            if (!(_DWORD)result)
            {
              v8 = v16[0] - a1;
              if (v12 >= ~(v16[0] - a1))
                return 7;
              v9 = __CFADD__(v12, v8);
              v10 = v12 + v8;
              if (v9)
              {
                __break(0x5500u);
              }
              else
              {
                result = 0;
                *a4 = v10;
              }
              return result;
            }
            return 2;
          }
        }
        return 3;
      }
    }
  }
  return result;
}

uint64_t Img4DecodePayloadExists(uint64_t a1, BOOL *a2)
{
  uint64_t result;
  BOOL v4;

  result = 6;
  if (a1 && a2)
  {
    if (*(_QWORD *)(a1 + 136))
      v4 = *(_QWORD *)(a1 + 144) != 0;
    else
      v4 = 0;
    result = 0;
    *a2 = v4;
  }
  return result;
}

uint64_t Img4DecodeCopyManifestDigest(uint64_t a1, void *__dst, size_t __n, uint64_t (**a4)(uint64_t, _QWORD, _OWORD *, size_t, _QWORD))
{
  uint64_t v4;
  uint64_t (*v7)(uint64_t, _QWORD, _OWORD *, size_t, _QWORD);
  uint64_t v8;
  _OWORD v10[3];

  v4 = 6;
  if (a1)
  {
    if (__dst)
    {
      if (__n)
      {
        if (a4)
        {
          v7 = *a4;
          if (*a4)
          {
            v8 = *(_QWORD *)(a1 + 24);
            if (v8)
            {
              if (__n > 0x30)
              {
                return 7;
              }
              else if (*(_BYTE *)(a1 + 1))
              {
                memcpy(__dst, (const void *)(a1 + 328), __n);
                return 0;
              }
              else
              {
                memset(v10, 0, sizeof(v10));
                v4 = v7(v8, *(_QWORD *)(a1 + 32), v10, __n, a4);
                if (!(_DWORD)v4)
                  memcpy(__dst, v10, __n);
              }
            }
            else
            {
              return 1;
            }
          }
        }
      }
    }
  }
  return v4;
}

uint64_t Img4DecodeSectionExists(_QWORD *a1, unsigned int a2, char *a3)
{
  uint64_t v3;
  char v4;

  v3 = 6;
  if (a2 <= 1 && a1 && a3)
  {
    if (a2 == 1)
    {
      if (!a1[55] || !a1[56])
        goto LABEL_11;
    }
    else if (!a1[33] || !a1[34])
    {
LABEL_11:
      v4 = 0;
      goto LABEL_12;
    }
    v4 = 1;
LABEL_12:
    v3 = 0;
    *a3 = v4;
  }
  return v3;
}

uint64_t Img4DecodeGetBooleanFromSection(uint64_t a1, unsigned int a2, uint64_t a3, BOOL *a4)
{
  uint64_t v4;
  uint64_t v6;
  _OWORD v8[3];

  memset(v8, 0, sizeof(v8));
  v4 = 6;
  if (a1)
  {
    if (a4)
    {
      Img4DecodeGetPropertyFromSection(a1, a2, a3 | 0xE000000000000000, 1uLL, v8);
      v4 = v6;
      if (!(_DWORD)v6)
        return DERParseBoolean((unsigned __int8 **)&v8[1] + 1, a4);
    }
  }
  return v4;
}

double Img4DecodeGetPropertyFromSection(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, _OWORD *a5)
{
  int v10;
  double result;
  int v12;
  unint64_t v13[3];
  char v14;

  *(_OWORD *)v13 = 0uLL;
  if (a2 <= 1 && a1 && a5)
  {
    v14 = 0;
    if (!Img4DecodeSectionExists((_QWORD *)a1, a2, &v14) && v14)
    {
      if (a2)
      {
        *(_OWORD *)v13 = *(_OWORD *)(a1 + 440);
        goto LABEL_9;
      }
      DERImg4DecodeParseManifestProperties(a1, 0, (unint64_t)v13);
      if (!v10)
      {
LABEL_9:
        DERImg4DecodeFindProperty(v13, a3, a4, (unint64_t)a5);
        if (!v12)
          return result;
      }
    }
    result = 0.0;
    a5[1] = 0u;
    a5[2] = 0u;
    *a5 = 0u;
  }
  return result;
}

void Img4DecodeEvaluateCertificateProperties(_QWORD *a1)
{
  sub_100023E34(a1, 0);
}

void sub_100023E34(_QWORD *a1, _OWORD *a2)
{
  __int128 *v4;
  int v5;
  int v6;
  __int128 v7;
  __int128 __s2;
  _OWORD v9[2];
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  void *__s1;
  size_t __n;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;
  unint64_t v20[2];
  unint64_t v21[3];

  v21[0] = 0;
  v21[1] = 0;
  v20[0] = 0;
  v20[1] = 0;
  v19 = 0;
  v18 = 0uLL;
  __n = 0;
  v17 = 0;
  v14 = 0;
  __s1 = 0;
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v10 = 0u;
  memset(v9, 0, sizeof(v9));
  __s2 = 0uLL;
  v7 = 0uLL;
  if (a1 && a1[40] && !DERDecodeSeqInit((uint64_t)(a1 + 39), &v19, v21) && v19 == 0x2000000000000011)
  {
    while (1)
    {
      if (DERDecodeSeqNext(v21, (unint64_t *)&v17))
        return;
      v4 = (__int128 *)(a1 + 7);
      switch(v17)
      {
        case 0xE00000004D414E50:
LABEL_11:
          v7 = *v4;
          if (DERImg4DecodeProperty(&v18, v17, (uint64_t)&v11)
            || *((_QWORD *)&v13 + 1) != 0x2000000000000011
            || DERDecodeSeqContentInit((unint64_t *)&v12 + 1, v20))
          {
            return;
          }
          while (1)
          {
            v5 = DERDecodeSeqNext(v20, (unint64_t *)&v14);
            if (v5)
              break;
            if (DERImg4DecodeProperty(&__s1, v14, (uint64_t)v9))
              return;
            DERImg4DecodeContentFindItemWithTag((unint64_t *)&v7, v14, &__s2);
            if (*((_QWORD *)&v10 + 1) <= 4uLL && ((1 << SBYTE8(v10)) & 0x16) != 0)
            {
              if (v6)
                return;
              if (__n != *((_QWORD *)&__s2 + 1))
                return;
              v6 = memcmp(__s1, (const void *)__s2, __n);
              if (v6)
                return;
            }
            else if (*((_QWORD *)&v10 + 1) != 0xA000000000000000)
            {
              if (*((_QWORD *)&v10 + 1) != 0xA000000000000001 || v6 != 1)
                return;
              v6 = 0;
            }
            if (v6)
              return;
          }
          if (v5 != 1)
            return;
          break;
        case 0xE00000006D616E78:
          if (a2)
            *a2 = v18;
          break;
        case 0xE00000004F424A50:
          v4 = (__int128 *)(a1 + 9);
          if (a1[9])
            goto LABEL_11;
          v4 = (__int128 *)(a1 + 9);
          if (a1[10])
            goto LABEL_11;
          break;
        default:
          return;
      }
    }
  }
}

uint64_t Img4DecodeEvaluateDictionaryProperties(unint64_t *a1, uint64_t a2, uint64_t (*a3)(unint64_t, uint64_t *, uint64_t, uint64_t), uint64_t a4)
{
  uint64_t result;
  _OWORD v8[2];
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13[2];
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;

  v15 = 0;
  v16 = 0;
  v14 = 0;
  v13[0] = 0;
  v13[1] = 0;
  v11 = 0;
  v12 = 0;
  v10 = 0;
  memset(v8, 0, sizeof(v8));
  v9 = 0u;
  if (!a3)
    return 6;
  result = (uint64_t)DERDecodeSeqContentInit(a1, v13);
  if (!(_DWORD)result)
  {
    while (1)
    {
      result = DERDecodeSeqNext(v13, &v14);
      if ((_DWORD)result == 1)
        return 0;
      if ((_DWORD)result)
        return result;
      result = DERImg4DecodeProperty(&v15, v14, (uint64_t)v8);
      if ((_DWORD)result)
        return result;
      result = 2;
      if (*((_QWORD *)&v9 + 1) > 0x16uLL
        || ((1 << SBYTE8(v9)) & 0x400016) == 0
        || !(v14 >> 62)
        || (v14 & 0x2000000000000000) == 0)
      {
        return result;
      }
      if (HIDWORD(v16))
        break;
      v10 = v15;
      LODWORD(v11) = v16;
      v12 = *((_QWORD *)&v9 + 1);
      result = a3(v14, &v10, a2, a4);
      if ((_DWORD)result)
        return result;
    }
    return 7;
  }
  return result;
}

uint64_t Img4DecodeInitManifest(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000241D0(a1, a2, 1, a3, 1229796429);
}

uint64_t sub_1000241D0(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t result;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  result = 6;
  if (a1 && a4)
  {
    v15 = a1;
    v16 = a2;
    *(_OWORD *)a4 = 0u;
    *(_OWORD *)(a4 + 16) = 0u;
    *(_OWORD *)(a4 + 32) = 0u;
    *(_OWORD *)(a4 + 48) = 0u;
    *(_OWORD *)(a4 + 64) = 0u;
    *(_OWORD *)(a4 + 80) = 0u;
    *(_OWORD *)(a4 + 96) = 0u;
    *(_OWORD *)(a4 + 112) = 0u;
    *(_OWORD *)(a4 + 128) = 0u;
    *(_OWORD *)(a4 + 144) = 0u;
    *(_OWORD *)(a4 + 160) = 0u;
    *(_OWORD *)(a4 + 176) = 0u;
    *(_OWORD *)(a4 + 192) = 0u;
    *(_OWORD *)(a4 + 208) = 0u;
    *(_OWORD *)(a4 + 224) = 0u;
    *(_OWORD *)(a4 + 240) = 0u;
    *(_OWORD *)(a4 + 256) = 0u;
    *(_OWORD *)(a4 + 272) = 0u;
    *(_OWORD *)(a4 + 288) = 0u;
    *(_OWORD *)(a4 + 304) = 0u;
    *(_OWORD *)(a4 + 320) = 0u;
    *(_OWORD *)(a4 + 336) = 0u;
    *(_OWORD *)(a4 + 352) = 0u;
    *(_OWORD *)(a4 + 368) = 0u;
    *(_OWORD *)(a4 + 384) = 0u;
    *(_OWORD *)(a4 + 400) = 0u;
    *(_OWORD *)(a4 + 416) = 0u;
    *(_OWORD *)(a4 + 432) = 0u;
    *(_QWORD *)(a4 + 448) = 0;
    if (a5 == 1229796419)
    {
      v10 = a4 + 232;
      if (a3)
        result = DERImg4DecodeCertificate(&v15, v10);
      else
        result = DERImg4DecodeUnsignedCertificate(&v15, v10);
    }
    else
    {
      if (a5 != 1229796429)
        return 2;
      v9 = a4 + 232;
      if (a3)
        result = DERImg4DecodeManifest(&v15, v9);
      else
        result = DERImg4DecodeUnsignedManifest(&v15, v9);
    }
    if (!(_DWORD)result)
    {
      if (*(_QWORD *)(a4 + 264))
      {
        v12 = 0;
        v13 = 0;
        v14 = 0;
        v15 = a1;
        v16 = a2;
        result = DERDecodeItemPartialBufferGetLength((uint64_t)&v15, &v12, 0);
        if (!(_DWORD)result)
        {
          *(_QWORD *)(a4 + 24) = a1;
          v11 = v14 + v13 - a1;
          if (__CFADD__(v14, v13 - a1))
          {
            __break(0x5500u);
          }
          else
          {
            *(_QWORD *)(a4 + 32) = v11;
            if (v11 == a2)
              return 0;
            else
              return 7;
          }
        }
      }
      else
      {
        return 3;
      }
    }
  }
  return result;
}

void Img4DecodePerformTrustEvaluation(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _QWORD v5[3];

  v5[1] = 0;
  v5[2] = 0;
  v5[0] = a3;
  sub_10002433C(a1, a2, (uint64_t)v5, a4, 0, a5);
}

void sub_10002433C(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6)
{
  _QWORD *v9;
  uint64_t (*v13)(uint64_t, uint64_t);
  const void *v14;
  int v15;
  int v16;
  unsigned int (*v17)(unint64_t *, unint64_t, uint64_t, _OWORD *, uint64_t);
  unint64_t v18;
  unint64_t *v19;
  int v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  _OWORD v24[3];

  v22 = 0;
  v23 = 0;
  memset(v24, 0, sizeof(v24));
  if (a2)
  {
    if (a3)
    {
      v21 = 0;
      if (a4)
      {
        if (*(_QWORD *)a3)
        {
          if (*(_QWORD *)a4)
          {
            if (*(_QWORD *)(a4 + 24))
            {
              if (*(_QWORD *)(a4 + 8))
              {
                if (*(_QWORD *)(a4 + 16))
                {
                  v9 = *(_QWORD **)(a4 + 32);
                  if (v9)
                  {
                    if (*(_QWORD *)(a2 + 24) && *v9 <= 0x30uLL && !(*(unsigned int (**)(void))a4)())
                    {
                      *(_BYTE *)(a2 + 1) = 1;
                      v13 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 8);
                      if (v13
                        && (v14 = (const void *)v13(a2, a6)) != 0
                        && !memcmp((const void *)(a2 + 328), v14, **(_QWORD **)(a4 + 32)))
                      {
                        v15 = 0;
                      }
                      else
                      {
                        if ((*(unsigned int (**)(_QWORD, _QWORD, uint64_t *, uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 8))(*(_QWORD *)(a2 + 296), *(_QWORD *)(a2 + 304), &v22, &v23, a2 + 312, a2 + 320, a4, a6)|| **(_QWORD **)(a4 + 32) > 0x30uLL|| (*(unsigned int (**)(_QWORD, _QWORD, uint64_t))a4)(*(_QWORD *)(a2 + 264), *(_QWORD *)(a2 + 272), a2 + 376)|| (*(unsigned int (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD, uint64_t, uint64_t))(a4 + 16))(v22, v23, *(_QWORD *)(a2 + 280), *(_QWORD *)(a2 + 288), a2 + 376,
                               **(_QWORD **)(a4 + 32),
                               a4,
                               a6))
                        {
                          return;
                        }
                        v15 = 1;
                      }
                      DERImg4DecodeParseManifestProperties(a2, a2 + 40, a2 + 56);
                      if (v16)
                        return;
                      if ((a5 & 1) == 0)
                      {
                        v17 = *(unsigned int (**)(unint64_t *, unint64_t, uint64_t, _OWORD *, uint64_t))(a3 + 16);
                        v18 = a1 | 0xE000000000000000;
                        v19 = (unint64_t *)(a2 + 40);
                        if (v17)
                        {
                          if (v17(v19, v18, 0x2000000000000011, v24, a6))
                            return;
                        }
                        else
                        {
                          DERImg4DecodeFindProperty(v19, v18, 0x2000000000000011uLL, (unint64_t)v24);
                          if (v20)
                            return;
                        }
                        *(_OWORD *)(a2 + 72) = *(_OWORD *)((char *)&v24[1] + 8);
                      }
                      if ((!v15 || !(*(unsigned int (**)(uint64_t, uint64_t))(a4 + 24))(a2, a6))
                        && **(_QWORD **)(a4 + 32) <= 0x30uLL
                        && !Img4DecodePayloadExists(a2, &v21))
                      {
                        if (v21)
                        {
                          if ((*(unsigned int (**)(_QWORD, _QWORD, uint64_t, _QWORD, uint64_t))a4)(*(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 16), a2 + 184, **(_QWORD **)(a4 + 32), a4))
                          {
                            return;
                          }
                          *(_BYTE *)a2 = 1;
                        }
                        if (!Img4DecodeEvaluateDictionaryProperties((unint64_t *)(a2 + 56), 0, *(uint64_t (**)(unint64_t, uint64_t *, uint64_t, uint64_t))a3, a6)&& (a5 & 1) == 0)
                        {
                          Img4DecodeEvaluateDictionaryProperties((unint64_t *)(a2 + 72), 1, *(uint64_t (**)(unint64_t, uint64_t *, uint64_t, uint64_t))a3, a6);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

uint64_t sub_1000245E4(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4, uint64_t a5)
{
  unint64_t v9;
  size_t v10;
  unint64_t *v11;
  uint64_t v12;
  uint64_t result;
  unint64_t v14;
  _BYTE *v15;
  __int128 i;
  unint64_t v17;
  BOOL v18;
  int v19;
  int v20;
  __int128 v21;
  __int128 v22;
  _QWORD v23[2];
  _QWORD v24[2];

  if (a5 != 4096 && a5 != 3072)
    return 0xFFFFFFFFLL;
  v24[0] = 0;
  v24[1] = 0;
  v9 = (unint64_t)(a5 + 63) >> 6;
  __chkstk_darwin();
  v11 = (unint64_t *)((char *)&v21 - v10);
  bzero((char *)&v21 - v10, v10);
  *v11 = v9;
  v12 = *(unsigned int *)(a1 + 8);
  v23[0] = *(_QWORD *)a1;
  v23[1] = v12;
  v21 = 0u;
  v22 = 0u;
  result = DERParseSequenceToObject((uint64_t)v23, (unsigned __int16)DERNumRSAPubKeyPKCS1ItemSpecs, (uint64_t)&DERRSAPubKeyPKCS1ItemSpecs, (unint64_t)&v21, 0x20uLL, 0x20uLL);
  if ((_DWORD)result)
    return 0xFFFFFFFFLL;
  v14 = *((_QWORD *)&v21 + 1);
  v15 = (_BYTE *)v21;
  for (i = v22; v14; --v14)
  {
    if (*v15)
      break;
    if (v15 == (_BYTE *)-1)
      __break(0x5513u);
    ++v15;
  }
  if (v14 >= 0xFFFFFFFFFFFFFFF8)
  {
    __break(0x5500u);
    return result;
  }
  v17 = (v14 + 7) >> 3;
  if (v17 > *v11)
    return 0xFFFFFFFFLL;
  *v11 = v17;
  if (ccrsa_make_pub(v11, *((_QWORD *)&i + 1), i))
    return 0xFFFFFFFFLL;
  if (&_ccrsa_verify_pkcs1v15_digest)
    v18 = &CCRSA_PKCS1_FAULT_CANARY == 0;
  else
    v18 = 1;
  if (!v18)
  {
    v20 = ccrsa_verify_pkcs1v15_digest(v11, a2, a3[1], *a3, a4[1], *a4, v24);
    if (!v20 && !cc_cmp_safe(16, &CCRSA_PKCS1_FAULT_CANARY, v24))
      return 0;
    return 0xFFFFFFFFLL;
  }
  LOBYTE(v21) = 0;
  v19 = ccrsa_verify_pkcs1v15(v11, a2, a3[1], *a3, a4[1], *a4, &v21);
  result = 0xFFFFFFFFLL;
  if (!v19 && (_BYTE)v21)
    return 0;
  return result;
}

uint64_t verify_signature_rsa(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  _QWORD **v8;
  _QWORD *v9;
  uint64_t result;
  _QWORD v11[2];
  _QWORD v12[2];
  _QWORD v13[2];

  v13[0] = a1;
  v13[1] = a2;
  v12[0] = a3;
  v12[1] = a4;
  v11[0] = a5;
  v11[1] = a6;
  if (!a1)
    return 0xFFFFFFFFLL;
  if (!a2)
    return 0xFFFFFFFFLL;
  if (!a3)
    return 0xFFFFFFFFLL;
  if (!a4)
    return 0xFFFFFFFFLL;
  if (!a5)
    return 0xFFFFFFFFLL;
  if (!a6)
    return 0xFFFFFFFFLL;
  if (!a7)
    return 0xFFFFFFFFLL;
  v7 = *(_QWORD *)(a7 + 32);
  if (!v7)
    return 0xFFFFFFFFLL;
  v8 = *(_QWORD ***)(v7 + 16);
  if (!v8)
    return 0xFFFFFFFFLL;
  v9 = *v8;
  if (!v9)
    return 0xFFFFFFFFLL;
  if (*v9 != a6)
    return 0xFFFFFFFFLL;
  result = sub_1000245E4((uint64_t)v13, v9[4], v11, v12, 4096);
  if ((_DWORD)result)
    return 0xFFFFFFFFLL;
  return result;
}

uint64_t verify_chain_img4_v1(unint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, uint64_t a7)
{
  uint64_t result;
  unsigned int v9;
  uint64_t v15;
  const void **v16;
  uint64_t *v17;
  const void **v18;
  unint64_t *v19;
  size_t v20;
  const void *v21;
  int v22;
  uint64_t v23;
  _QWORD *v24;
  __int128 v25;
  unint64_t v26[2];
  _QWORD v27[2];
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _BYTE v31[216];
  _BYTE v32[24];
  unint64_t v33[30];
  _OWORD v34[2];
  uint64_t v35;
  uint64_t v36;
  _BYTE v37[32];
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41[2];
  unint64_t v42[2];
  __int128 v43;
  __int128 v44;
  unint64_t v45;
  unint64_t v46[2];
  unint64_t v47[3];

  result = 0xFFFFFFFFLL;
  if (a1)
  {
    v9 = a2;
    if (a2)
    {
      if (a3 && a4)
      {
        bzero(&v28, 0x2F0uLL);
        v26[0] = a1;
        v26[1] = v9;
        v27[0] = &ROOT_CA_CERTIFICATE;
        v27[1] = 1215;
        if (!sub_1000251F0(v26, (uint64_t)v27, 3u)
          && !sub_100024B68((uint64_t)v27, 3u, (uint64_t)&v29, (uint64_t)v31, (uint64_t)v34, (uint64_t)v37))
        {
          v24 = a6;
          v15 = 0;
          v16 = (const void **)v32;
          v17 = &v30;
          v18 = (const void **)v32;
          while (1)
          {
            v19 = &v26[20 * v15];
            v20 = v19[37];
            v21 = *v18;
            v18 += 20;
            if ((const void *)v20 != v21)
              break;
            if (memcmp((const void *)v19[36], *(v16 - 1), v20))
              break;
            result = sub_100024DCC(&v34[v15], v17, a7);
            if ((_DWORD)result)
              break;
            v17 += 6;
            ++v15;
            v16 = v18;
            if (v15 == 2)
            {
              v25 = 0uLL;
              if ((unint64_t)v31 > 0xFFFFFFFFFFFFFF5FLL)
              {
LABEL_34:
                __break(0x5513u);
                return result;
              }
              v42[0] = 0;
              v42[1] = 0;
              v40 = 0;
              v41[0] = 0;
              v41[1] = 0;
              if (DERDecodeSeqContentInit(v33, v42))
                return 0xFFFFFFFFLL;
LABEL_14:
              if (!DERDecodeSeqNext(v42, &v40) && v40 == 0x2000000000000011)
              {
                v47[0] = 0;
                v47[1] = 0;
                v45 = 0;
                v46[0] = 0;
                v46[1] = 0;
                v43 = 0u;
                v44 = 0u;
                if (!DERDecodeSeqContentInit(v41, v47))
                {
                  do
                  {
                    v22 = DERDecodeSeqNext(v47, &v45);
                    if (v22)
                    {
                      if (v22 == 1)
                        goto LABEL_14;
                      return 0xFFFFFFFFLL;
                    }
                    if (v45 != 0x2000000000000010
                      || DERParseSequenceContentToObject(v46, (unsigned __int16)DERNumAttributeTypeAndValueItemSpecs, (uint64_t)&DERAttributeTypeAndValueItemSpecs, (unint64_t)&v43, 0x20uLL, 0x20uLL))
                    {
                      return 0xFFFFFFFFLL;
                    }
                  }
                  while (!DEROidCompare((uint64_t)&oidCommonName, (uint64_t)&v43));
                  v25 = v44;
                  result = DEROidCompare((uint64_t)&off_100075960, (uint64_t)&v25);
                  if (!(_DWORD)result)
                    return 0xFFFFFFFFLL;
                  if ((unint64_t)v34 > 0xFFFFFFFFFFFFFFDFLL)
                    goto LABEL_34;
                  *a3 = v35;
                  *a4 = v36;
                  if ((unint64_t)v37 > 0xFFFFFFFFFFFFFFDFLL)
                    goto LABEL_34;
                  if (!v38)
                    return 0;
                  v23 = v39;
                  if (!v39)
                    return 0;
                  result = 0;
                  if (a5)
                  {
                    if (v24)
                    {
                      result = 0;
                      *a5 = v38;
                      *v24 = v23;
                    }
                  }
                  return result;
                }
              }
              return 0xFFFFFFFFLL;
            }
          }
        }
        return 0xFFFFFFFFLL;
      }
    }
  }
  return result;
}

uint64_t sub_100024B68(uint64_t result, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v17;
  unint64_t v18;
  __int128 v19;
  __int128 v20;
  char v21;
  __int128 v22;
  __int128 v23;

  if (!a2)
    return 0;
  v8 = 0;
  v15 = result;
  v18 = ~result;
  v17 = ~a3;
  v14 = ~a4;
  v13 = ~a5;
  v11 = ~a6;
  v10 = a2;
  while (1)
  {
    v9 = 16 * v8;
    if (16 * v8 > v18 || 48 * v8 > v17)
      break;
    result = DERParseSequenceToObject(v15 + 16 * v8, (unsigned __int16)DERNumSignedCertCrlItemSpecs, (uint64_t)&DERSignedCertCrlItemSpecs, a3 + 48 * v8, 0x30uLL, 0x30uLL);
    if ((_DWORD)result)
      return 0xFFFFFFFFLL;
    if (160 * v8 > v14)
      break;
    result = DERParseSequenceToObject(a3 + 48 * v8, (unsigned __int16)DERNumTBSCertItemSpecs, (uint64_t)&DERTBSCertItemSpecs, a4 + 160 * v8, 0xA0uLL, 0xA0uLL);
    if ((_DWORD)result)
      return 0xFFFFFFFFLL;
    if (v9 > v13)
      break;
    v22 = 0u;
    v23 = 0u;
    v21 = 0;
    v19 = 0u;
    v20 = 0u;
    if (DERParseSequenceContentToObject((unint64_t *)(a4 + 160 * v8 + 96), (unsigned __int16)DERNumSubjPubKeyInfoItemSpecs, (uint64_t)&DERSubjPubKeyInfoItemSpecs, (unint64_t)&v22, 0x20uLL, 0x20uLL))return 0xFFFFFFFFLL;
    if (DERParseSequenceContentToObject((unint64_t *)&v22, (unsigned __int16)DERNumAlgorithmIdItemSpecs, (uint64_t)&DERAlgorithmIdItemSpecs, (unint64_t)&v19, 0x20uLL, 0x20uLL))return 0xFFFFFFFFLL;
    result = DEROidCompare((uint64_t)&v19, (uint64_t)&oidRsa);
    if (!(_DWORD)result)
      return 0xFFFFFFFFLL;
    if (*((_QWORD *)&v20 + 1))
    {
      if (*((_QWORD *)&v20 + 1) != 2 || *(_BYTE *)v20 != 5)
        return 0xFFFFFFFFLL;
      if ((_QWORD)v20 == -1)
        break;
      if (*(_BYTE *)(v20 + 1))
        return 0xFFFFFFFFLL;
    }
    result = DERParseBitString((uint64_t)&v23, (unint64_t *)(a5 + 16 * v8), &v21);
    if ((_DWORD)result || v21)
      return 0xFFFFFFFFLL;
    if (v9 > v11)
      break;
    result = sub_1000252C8(a4 + 160 * v8, (_QWORD *)(a6 + 16 * v8));
    if ((_DWORD)result)
      return 0xFFFFFFFFLL;
    if (++v8 == v10)
      return 0;
  }
  __break(0x5513u);
  return result;
}

uint64_t sub_100024DCC(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *v5;
  uint64_t result;
  unint64_t v8;
  uint64_t v9;
  char v10;
  __int128 v11;
  __int128 v12;
  _OWORD v13[3];

  if (!a1)
    return 0xFFFFFFFFLL;
  if (!a2)
    return 0xFFFFFFFFLL;
  if (!a3)
    return 0xFFFFFFFFLL;
  v11 = 0u;
  v12 = 0u;
  v10 = 0;
  memset(v13, 0, sizeof(v13));
  v8 = 0;
  v9 = 0;
  v5 = *(_QWORD **)(a3 + 32);
  if (!v5
    || !v5[2]
    || !*(_QWORD *)a3
    || !*(_QWORD *)(a3 + 40)
    || *v5 > 0x30uLL
    || DERParseSequenceContentToObject(a2 + 2, (unsigned __int16)DERNumAlgorithmIdItemSpecs, (uint64_t)&DERAlgorithmIdItemSpecs, (unint64_t)&v11, 0x20uLL, 0x20uLL))
  {
    return 0xFFFFFFFFLL;
  }
  if (*((_QWORD *)&v12 + 1))
  {
    result = DEROidCompare((uint64_t)&v11, (uint64_t)&oidEcPubKey);
    if ((result & 1) == 0)
    {
      if (*((_QWORD *)&v12 + 1) != 2 || *(_BYTE *)v12 != 5)
        return 0xFFFFFFFFLL;
      if ((_QWORD)v12 == -1)
      {
        __break(0x5513u);
        return result;
      }
      if (*(_BYTE *)(v12 + 1))
        return 0xFFFFFFFFLL;
    }
  }
  if (!DEROidCompare((uint64_t)&v11, *(_QWORD *)(a3 + 40)))
    return 0xFFFFFFFFLL;
  if ((*(unsigned int (**)(_QWORD, _QWORD, _OWORD *, _QWORD, uint64_t))a3)(*a2, a2[1], v13, **(_QWORD **)(a3 + 32), a3))
  {
    return 0xFFFFFFFFLL;
  }
  if (DERParseBitString((uint64_t)(a2 + 4), &v8, &v10))
    return 0xFFFFFFFFLL;
  if (v10)
    return 0xFFFFFFFFLL;
  result = (*(uint64_t (**)(_QWORD, _QWORD, unint64_t, uint64_t, _OWORD *, _QWORD, uint64_t, _QWORD))(a3 + 16))(*a1, a1[1], v8, v9, v13, **(_QWORD **)(a3 + 32), a3, 0);
  if ((_DWORD)result)
    return 0xFFFFFFFFLL;
  return result;
}

uint64_t sub_100024F70(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, uint64_t a7, unsigned int (*a8)(_QWORD *, _BYTE *, uint64_t))
{
  uint64_t result;
  unsigned int v10;
  char v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  _QWORD v21[2];
  _BYTE v22[48];
  _OWORD v23[9];
  uint64_t v24;
  void *__s1;
  size_t __n;
  _QWORD v27[6];
  _BYTE v28[16];
  uint64_t v29;
  uint64_t v30;

  result = 0xFFFFFFFFLL;
  if (a1)
  {
    v10 = a2;
    if (a2)
    {
      if (a3 && a4)
      {
        bzero(v22, 0x300uLL);
        v21[0] = a1;
        v21[1] = v10;
        if (a8(v21, v22, 2))
          return 0xFFFFFFFFLL;
        result = sub_100024B68((uint64_t)v22, 2u, (uint64_t)v23, (uint64_t)&v24, (uint64_t)v27, (uint64_t)v28);
        if ((_DWORD)result)
        {
          return 0xFFFFFFFFLL;
        }
        else
        {
          v16 = 1;
          v17 = 1;
          while ((v16 & 1) != 0)
          {
            v18 = &v21[20 * v17];
            if (__n == v18[33] && !memcmp(__s1, (const void *)v18[32], __n))
            {
              result = sub_100024DCC(v27, &v23[3 * v17], a7);
              v16 = 0;
              v17 = 2;
              if (!(_DWORD)result)
                continue;
            }
            return 0xFFFFFFFFLL;
          }
          if ((unint64_t)v27 > 0xFFFFFFFFFFFFFFEFLL
            || (*a3 = v27[2], *a4 = v27[3], (unint64_t)v28 > 0xFFFFFFFFFFFFFFEFLL))
          {
            __break(0x5513u);
          }
          else if (v29 && (v19 = v30) != 0)
          {
            result = 0;
            if (a5 && a6)
            {
              result = 0;
              *a5 = v29;
              *a6 = v19;
            }
          }
          else
          {
            return 0;
          }
        }
      }
    }
  }
  return result;
}

uint64_t verify_chain_img4_ddi(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, uint64_t a7)
{
  return sub_100024F70(a1, a2, a3, a4, a5, a6, a7, (unsigned int (*)(_QWORD *, _BYTE *, uint64_t))sub_10002510C);
}

uint64_t sub_10002510C(unint64_t *a1, _QWORD *a2, unsigned int a3)
{
  *a2 = &RSA4K_SHA384_DDI_ROOT_CA_CERTIFICATE;
  a2[1] = 1394;
  if (sub_1000251F0(a1, (uint64_t)a2, a3))
    return 0xFFFFFFFFLL;
  else
    return 0;
}

uint64_t verify_chain_img4_v2(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, uint64_t a7)
{
  return sub_100024F70(a1, a2, a3, a4, a5, a6, a7, (unsigned int (*)(_QWORD *, _BYTE *, uint64_t))sub_10002514C);
}

uint64_t sub_10002514C(unint64_t *a1, _QWORD *a2, unsigned int a3)
{
  *a2 = &RSA4K_SHA384_ROOT_CA_CERTIFICATE;
  a2[1] = 1374;
  if (sub_1000251F0(a1, (uint64_t)a2, a3))
    return 0xFFFFFFFFLL;
  else
    return 0;
}

uint64_t Img4DecodeComputeDigest(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  _QWORD *v8;
  _QWORD *v9;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 && a3 && a5)
  {
    v8 = *(_QWORD **)(a5 + 32);
    if (v8 && (v9 = (_QWORD *)v8[2]) != 0 && *v8 == a4 && *v9 && *(_QWORD *)*v9 == a4)
    {
      ccdigest();
      return 0;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t sub_1000251F0(unint64_t *a1, uint64_t a2, unsigned int a3)
{
  unint64_t v5;
  unsigned int v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t result;
  unint64_t v10;
  unint64_t v11;
  BOOL v12;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;

  v18 = 0;
  v19 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v5 = ~a2;
  v6 = 1;
  v7 = *a1;
  v8 = a1[1];
  while (1)
  {
    v18 = v7;
    v19 = v8;
    result = DERDecodeItem((uint64_t)&v18, &v15);
    if ((_DWORD)result)
      return 0xFFFFFFFFLL;
    if (__CFADD__(v16, v17))
      break;
    v10 = v16 + v17;
    v11 = v16 + v17 - v7;
    v12 = !(v11 >> 17) && v8 >= v11;
    if (!v12 || v6 >= a3)
      return 0xFFFFFFFFLL;
    if (v5 < 16 * (unint64_t)v6)
      break;
    v14 = (unint64_t *)(a2 + 16 * v6);
    *v14 = v7;
    v14[1] = v11;
    if (v10 < v7)
      break;
    v12 = v8 >= v11;
    v8 -= v11;
    if (!v12)
      goto LABEL_21;
    ++v6;
    v7 = v10;
    if (!v8)
    {
      if (v6 == a3)
        return 0;
      return 0xFFFFFFFFLL;
    }
  }
  __break(0x5513u);
LABEL_21:
  __break(0x5515u);
  return result;
}

uint64_t sub_1000252C8(uint64_t a1, _QWORD *a2)
{
  char v3;
  int v4;
  _OWORD v6[2];
  __int128 v7;
  unint64_t v8;
  unint64_t v9[2];
  uint64_t v10;
  unint64_t v11[2];
  unint64_t v12[3];

  v11[0] = 0;
  v11[1] = 0;
  v9[1] = 0;
  v10 = 0;
  v8 = 0;
  v9[0] = 0;
  v7 = 0u;
  memset(v6, 0, sizeof(v6));
  *a2 = 0;
  a2[1] = 0;
  if (!*(_QWORD *)(a1 + 152))
    return 0;
  if (DERDecodeSeqInit(a1 + 144, &v10, v11) || v10 != 0x2000000000000010)
    return 0xFFFFFFFFLL;
  v3 = 1;
  while (1)
  {
    v4 = DERDecodeSeqNext(v11, &v8);
    if (v4)
      break;
    if (v8 != 0x2000000000000010
      || DERParseSequenceContentToObject(v9, (unsigned __int16)DERNumExtensionItemSpecs, (uint64_t)&DERExtensionItemSpecs, (unint64_t)v6, 0x30uLL, 0x30uLL))
    {
      return 0xFFFFFFFFLL;
    }
    v3 = 0;
    if (DEROidCompare((uint64_t)&oidAppleImg4ManifestCertSpec, (uint64_t)v6))
    {
      memset(v12, 0, sizeof(v12));
      if (DERDecodeItem((uint64_t)&v7, v12) || v12[0] != 0x2000000000000011)
        return 0xFFFFFFFFLL;
      v3 = 0;
      *(_OWORD *)a2 = v7;
    }
  }
  if (v4 != 1 || (v3 & 1) != 0)
    return 0xFFFFFFFFLL;
  else
    return 0;
}

uint64_t DERParseBoolean(unsigned __int8 **a1, BOOL *a2)
{
  int v2;
  uint64_t result;

  if (a1[1] != (unsigned __int8 *)1)
    return 3;
  v2 = **a1;
  if (v2 != 255 && v2 != 0)
    return 3;
  result = 0;
  *a2 = v2 != 0;
  return result;
}

uint64_t DERParseInteger(char **a1, _DWORD *a2)
{
  uint64_t result;
  unint64_t v4;

  v4 = 0xAAAAAAAAAAAAAAAALL;
  result = DERParseInteger64(a1, &v4);
  if (!(_DWORD)result)
  {
    if (HIDWORD(v4))
    {
      return 7;
    }
    else
    {
      result = 0;
      *a2 = v4;
    }
  }
  return result;
}

uint64_t DERParseInteger64(char **a1, unint64_t *a2)
{
  unint64_t v2;
  unsigned __int8 *v3;
  uint64_t result;
  unint64_t v5;
  unsigned int v6;

  v2 = (unint64_t)a1[1];
  if (!v2)
    return 3;
  v3 = (unsigned __int8 *)*a1;
  if (**a1 < 0)
    return 3;
  if (**a1)
  {
    if (v2 > 8)
      return 7;
    goto LABEL_10;
  }
  if (v2 >= 2)
  {
    if (((char)v3[1] & 0x80000000) == 0)
      return 3;
    if (v2 > 9)
      return 7;
  }
LABEL_10:
  v5 = 0;
  do
  {
    v6 = *v3++;
    v5 = v6 | (v5 << 8);
    --v2;
  }
  while (v2);
  result = 0;
  *a2 = v5;
  return result;
}

uint64_t DERDecodeSeqInit(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t result;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8[3];

  memset(v8, 170, sizeof(v8));
  result = DERDecodeItemPartialBufferGetLength(a1, v8, 0);
  if (!(_DWORD)result)
  {
    v6 = v8[0];
    *a2 = v8[0];
    if (v6 >> 1 == 0x1000000000000008)
    {
      if (__CFADD__(v8[1], v8[2]))
      {
        __break(0x5513u);
      }
      else
      {
        v7 = v8[1] + v8[2];
        if (v8[1] <= v8[1] + v8[2])
        {
          result = 0;
          *a3 = v8[1];
          a3[1] = v7;
          return result;
        }
      }
      __break(0x5519u);
    }
    else
    {
      return 2;
    }
  }
  return result;
}

unint64_t *DERDecodeSeqContentInit(unint64_t *result, unint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;

  v2 = *result;
  v3 = result[1];
  if (__CFADD__(*result, v3))
  {
    __break(0x5513u);
  }
  else
  {
    v4 = v2 + v3;
    if (v2 <= v4)
    {
      *a2 = v2;
      a2[1] = v4;
      return 0;
    }
  }
  __break(0x5519u);
  return result;
}

uint64_t DERDecodeSequenceWithBlock(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  unint64_t v4[3];

  memset(v4, 170, sizeof(v4));
  result = DERDecodeItemPartialBufferGetLength(a1, v4, 0);
  if (!(_DWORD)result)
  {
    if (v4[0] - 0x2000000000000012 >= 0xFFFFFFFFFFFFFFFELL)
      return DERDecodeSequenceContentWithBlock(&v4[1], a2);
    else
      return 2;
  }
  return result;
}

void start()
{
  char *v0;
  NSObject *v1;
  pid_t v2;
  NSObject *v3;
  pid_t v4;
  NSObject *v5;
  uint8_t v6[16];
  uint8_t buf[16];

  +[NSError _setFileNameLocalizationEnabled:](NSError, "_setFileNameLocalizationEnabled:", 0);
  v0 = getenv("WAIT4DEBUGGER");
  if (v0 && !strcasecmp("YES", v0))
  {
    v1 = sub_100011628("SecCritical");
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "SIGSTOPing self, awaiting debugger", buf, 2u);
    }
    v2 = getpid();
    kill(v2, 17);
    v3 = sub_100011628("SecCritical");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Again, for good luck (or bad debuggers)", v6, 2u);
    }
    v4 = getpid();
    kill(v4, 17);
  }
  sub_1000257CC();
  sub_100035414();
  sub_100027308();
  sub_10003A7EC();
  v5 = sub_100012A34();
  sub_100025840(v5);
  sub_100025898();
  dispatch_main();
}

size_t sub_1000257CC()
{
  char v1[1024];

  bzero(v1, 0x400uLL);
  _set_user_dir_suffix("com.apple.trustd");
  return confstr(65537, v1, 0x400uLL);
}

void sub_100025840(NSObject *a1)
{
  signal(15, (void (__cdecl *)(int))1);
  qword_100082AA8 = (uint64_t)dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_signal, 0xFuLL, 0, a1);
  dispatch_source_set_event_handler((dispatch_source_t)qword_100082AA8, &stru_100075A50);
  dispatch_activate((dispatch_object_t)qword_100082AA8);
}

void sub_100025898()
{
  _xpc_connection_s *mach_service;
  _xpc_connection_s *v1;
  NSObject *v2;
  int v3;
  const char *v4;

  mach_service = xpc_connection_create_mach_service("com.apple.trustd", 0, 1uLL);
  if (!mach_service)
  {
    v2 = sub_100011628("SecCritical");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      v3 = 136315138;
      v4 = "com.apple.trustd";
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "security failed to register xpc listener for %s, exiting", (uint8_t *)&v3, 0xCu);
    }
    abort();
  }
  v1 = mach_service;
  xpc_connection_set_event_handler(mach_service, &stru_100075A90);
  xpc_connection_activate(v1);
}

void sub_100025968(uint64_t a1, BOOL value, void *cf)
{
  xpc_object_t v5;
  void *v6;
  const void *v7;
  const void *v8;

  if (cf)
  {
    CFRetain(cf);
    v5 = sub_10002BA74((__CFError *)cf);
    if (v5)
    {
      v6 = v5;
      xpc_dictionary_set_value(*(xpc_object_t *)(a1 + 32), "error", v5);
      xpc_release(v6);
    }
    CFRelease(cf);
  }
  else
  {
    xpc_dictionary_set_BOOL(*(xpc_object_t *)(a1 + 32), "status", value);
  }
  xpc_connection_send_message(*(xpc_connection_t *)(a1 + 40), *(xpc_object_t *)(a1 + 32));
  xpc_release(*(xpc_object_t *)(a1 + 32));
  xpc_release(*(xpc_object_t *)(a1 + 40));
  v7 = *(const void **)(a1 + 48);
  if (v7)
    CFRelease(v7);
  v8 = *(const void **)(a1 + 112);
  if (v8)
    CFRelease(v8);
}

void sub_100025A24(uint64_t a1, BOOL value, void *cf)
{
  xpc_object_t v5;
  void *v6;
  const void *v7;

  if (cf)
  {
    CFRetain(cf);
    v5 = sub_10002BA74((__CFError *)cf);
    if (v5)
    {
      v6 = v5;
      xpc_dictionary_set_value(*(xpc_object_t *)(a1 + 32), "error", v5);
      xpc_release(v6);
    }
    CFRelease(cf);
  }
  else
  {
    xpc_dictionary_set_BOOL(*(xpc_object_t *)(a1 + 32), "status", value);
  }
  xpc_connection_send_message(*(xpc_connection_t *)(a1 + 40), *(xpc_object_t *)(a1 + 32));
  xpc_release(*(xpc_object_t *)(a1 + 32));
  xpc_release(*(xpc_object_t *)(a1 + 40));
  v7 = *(const void **)(a1 + 48);
  if (v7)
    CFRelease(v7);
}

uint64_t sub_100025AD4(uint64_t a1, void *a2, void *a3, __CFString **a4)
{
  CFStringRef v7;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  uint64_t v11;
  BOOL value;

  v7 = sub_100026880(a2, a4);
  if (!v7)
    return 0;
  v8 = (uint64_t)v7;
  v9 = sub_1000268CC(a2, a4);
  if (!v9)
    return 0;
  v10 = (const void *)v9;
  value = -86;
  v11 = sub_100006D70(v8, v9, &value, a4);
  if ((_DWORD)v11)
    xpc_dictionary_set_BOOL(a3, "status", value);
  CFRelease(v10);
  return v11;
}

BOOL sub_100025B7C(uint64_t a1, void *a2, void *a3, __CFString **a4)
{
  CFStringRef v7;
  uint64_t v8;
  const void *v9;
  _BOOL8 v10;
  const void *v11;
  BOOL v12;
  size_t length;

  v7 = sub_100026880(a2, a4);
  if (!v7)
    return 0;
  v8 = (uint64_t)v7;
  length = 0;
  v9 = 0;
  if (xpc_dictionary_get_data(a2, "cert", &length) && length && length <= 0x7FFFFFFFFFFFFFFELL)
    v9 = (const void *)SecCertificateCreateWithBytes(kCFAllocatorDefault);
  length = 0;
  v10 = sub_100059D7C(a2, &length, a4);
  if (v10)
  {
    v11 = (const void *)length;
    v12 = sub_100055FA0(v8, (uint64_t)v9, length, a4);
    xpc_dictionary_set_BOOL(a3, "status", v12);
    if (v11)
      CFRelease(v11);
  }
  if (v9)
    CFRelease(v9);
  return v10;
}

uint64_t sub_100025C84(uint64_t a1, void *a2, void *a3, __CFString **a4)
{
  CFStringRef v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  CFTypeRef v10;
  CFTypeRef cf;

  v6 = sub_100026880(a2, a4);
  if (!v6)
    return 0;
  cf = 0;
  v7 = sub_100056D80((uint64_t)v6, (__CFArray **)&cf, a4);
  if (cf)
    v9 = v7;
  else
    v9 = 0;
  if ((_DWORD)v9 == 1)
  {
    sub_10000B024(a3, "status", (const __CFString *)cf, (CFTypeRef *)a4, v8);
    v10 = cf;
    if (cf)
    {
      cf = 0;
      CFRelease(v10);
    }
  }
  return v9;
}

uint64_t sub_100025D18(uint64_t a1, void *a2, void *a3, __CFString **a4)
{
  uint64_t v7;
  uint64_t v8;
  const void *v9;
  unsigned int v10;
  uint64_t v11;
  CFTypeRef v12;
  CFTypeRef cf;

  v7 = (uint64_t)sub_100026880(a2, a4);
  if (v7)
  {
    v8 = sub_1000268CC(a2, a4);
    if (v8)
    {
      v9 = (const void *)v8;
      cf = 0;
      v10 = sub_10000F8D0(v7, v8, (__CFArray **)&cf, a4);
      if (cf)
        v7 = v10;
      else
        v7 = 0;
      if ((_DWORD)v7 == 1)
      {
        sub_10000B024(a3, "status", (const __CFString *)cf, (CFTypeRef *)a4, v11);
        v12 = cf;
        if (cf)
        {
          cf = 0;
          CFRelease(v12);
        }
      }
      CFRelease(v9);
    }
    else
    {
      return 0;
    }
  }
  return v7;
}

uint64_t sub_100025DD8(uint64_t a1, void *a2, void *a3, __CFString **a4)
{
  uint64_t result;
  uint64_t v8;
  const void *v9;
  char v10;

  result = (uint64_t)sub_100026880(a2, a4);
  if (result)
  {
    v8 = result;
    result = sub_1000268CC(a2, a4);
    if (result)
    {
      v9 = (const void *)result;
      v10 = sub_100056734(v8, result, a4);
      xpc_dictionary_set_BOOL(a3, "status", v10);
      CFRelease(v9);
      return 1;
    }
  }
  return result;
}

uint64_t sub_100025E5C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_10003A444(a4);
}

BOOL sub_100025E64(uint64_t a1, uint64_t a2, void *a3, __CFString **a4)
{
  uint64_t v5;
  const void *v6;
  void *v7;
  _BOOL8 v8;
  void *v9;

  v5 = sub_1000346DC(a4);
  if (!v5)
    return 0;
  v6 = (const void *)v5;
  v7 = (void *)_CFXPCCreateXPCObjectFromCFObject();
  v8 = v7 != 0;
  if (v7)
  {
    v9 = v7;
    xpc_dictionary_set_value(a3, "status", v7);
    xpc_release(v9);
  }
  CFRelease(v6);
  return v8;
}

BOOL sub_100025EDC(uint64_t a1, uint64_t a2, void *a3, __CFString **a4)
{
  uint64_t v5;
  const void *v6;
  void *v7;
  _BOOL8 v8;
  void *v9;

  v5 = sub_10003473C(a4);
  if (!v5)
    return 0;
  v6 = (const void *)v5;
  v7 = (void *)_CFXPCCreateXPCObjectFromCFObject();
  v8 = v7 != 0;
  if (v7)
  {
    v9 = v7;
    xpc_dictionary_set_value(a3, "status", v7);
    xpc_release(v9);
  }
  CFRelease(v6);
  return v8;
}

uint64_t sub_100025F54(uint64_t a1, uint64_t a2, void *a3, __CFString **a4)
{
  uint64_t v5;

  v5 = sub_100034930(a4);
  xpc_dictionary_set_uint64(a3, "status", v5);
  return 1;
}

uint64_t sub_100025F90(uint64_t a1, uint64_t a2, void *a3, __CFString **a4)
{
  uint64_t v5;

  v5 = sub_10003224C(a4);
  xpc_dictionary_set_uint64(a3, "status", v5);
  return 1;
}

uint64_t sub_100025FCC(int a1, int a2, void *a3, __CFString **a4)
{
  uint64_t v5;

  v5 = sub_10003497C(a4);
  xpc_dictionary_set_uint64(a3, "status", v5);
  return 1;
}

BOOL sub_100026008(uint64_t a1, uint64_t a2, void *a3, __CFString **a4)
{
  void *v5;
  const void *v6;
  void *v7;
  _BOOL8 v8;
  void *v9;

  v5 = sub_1000344B0(a4);
  if (!v5)
    return 0;
  v6 = v5;
  v7 = (void *)_CFXPCCreateXPCObjectFromCFObject();
  v8 = v7 != 0;
  if (v7)
  {
    v9 = v7;
    xpc_dictionary_set_value(a3, "status", v7);
    xpc_release(v9);
  }
  CFRelease(v6);
  return v8;
}

BOOL sub_100026080(int a1, xpc_object_t xdict, void *a3)
{
  const UInt8 *data;
  BOOL v5;
  CFDataRef v7;
  CFDataRef v8;
  const void *v9;
  _BOOL8 v10;
  const void *v11;
  void *v12;
  size_t length;

  length = 0;
  data = (const UInt8 *)xpc_dictionary_get_data(xdict, "data", &length);
  if (data)
    v5 = length == 0;
  else
    v5 = 1;
  if (v5 || length > 0x7FFFFFFFFFFFFFFELL)
    return 0;
  v7 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, data, length, kCFAllocatorNull);
  if (!v7)
    return 0;
  v8 = v7;
  v9 = sub_100034640(v7);
  v10 = v9 != 0;
  if (v9)
  {
    v11 = v9;
    v12 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    xpc_dictionary_set_value(a3, "status", v12);
    xpc_release(v12);
    CFRelease(v11);
  }
  CFRelease(v8);
  return v10;
}

uint64_t sub_100026160(__SecTask **a1, void *a2, void *a3, __CFString **a4)
{
  _BOOL4 v8;
  const void *v9;
  const void *v11;
  char v12;
  const void *v14;
  const void *v15;

  v14 = 0;
  v15 = 0;
  v8 = sub_100059DF4(a2, "appID", &v15, a4);
  v9 = v15;
  if (!v8 || v15 == 0)
    v9 = sub_100011D84(*a1);
  sub_100059CB0(a2, "exceptions", &v14, a4);
  v11 = v14;
  v12 = sub_10003FAC0((uint64_t)v9, (uint64_t)v14, a4);
  xpc_dictionary_set_BOOL(a3, "status", v12);
  if (v11)
    CFRelease(v11);
  if (v9)
    CFRelease(v9);
  return 0;
}

uint64_t sub_100026230(uint64_t a1, void *a2, void *a3, __CFString **a4)
{
  const void *v6;
  const __CFString *v7;
  uint64_t v8;
  const __CFString *v9;
  const void *v11;

  v11 = 0;
  sub_100059DF4(a2, "appID", &v11, a4);
  v6 = v11;
  v7 = (const __CFString *)sub_1000400A8((uint64_t)v11, (uint64_t)a4);
  if (v7)
  {
    v9 = v7;
    sub_10000B024(a3, "exceptions", v7, (CFTypeRef *)a4, v8);
    CFRelease(v9);
  }
  if (v6)
    CFRelease(v6);
  return 0;
}

BOOL sub_1000262C0(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4;
  const void *v5;
  void *v6;
  _BOOL8 v7;
  void *v8;

  v4 = sub_100034B2C();
  if (!v4)
    return 0;
  v5 = (const void *)v4;
  v6 = (void *)_CFXPCCreateXPCObjectFromCFObject();
  v7 = v6 != 0;
  if (v6)
  {
    v8 = v6;
    xpc_dictionary_set_value(a3, "status", v6);
    xpc_release(v8);
  }
  CFRelease(v5);
  return v7;
}

uint64_t sub_100026334(int a1, int a2, void *a3, __CFString **a4)
{
  uint64_t v5;

  v5 = sub_100034A54(a4);
  xpc_dictionary_set_uint64(a3, "status", v5);
  return 1;
}

id sub_100026370(uint64_t a1, uint64_t a2, void *a3, CFTypeRef *a4)
{
  id v6;
  BOOL v7;

  v6 = sub_100039138(a4);
  v7 = !(_DWORD)v6 || a4 && *a4;
  xpc_dictionary_set_BOOL(a3, "status", v7);
  return v6;
}

uint64_t sub_1000263D4(__SecTask **a1, void *a2, void *a3, __CFString **a4)
{
  _BOOL4 v8;
  const void *v9;
  const void *v11;
  char v12;
  const void *v14;
  const void *v15;

  v14 = 0;
  v15 = 0;
  v8 = sub_100059DF4(a2, "appID", &v15, a4);
  v9 = v15;
  if (!v8 || v15 == 0)
    v9 = sub_100011D84(*a1);
  sub_100059CB0(a2, "revocationCheck", &v14, a4);
  v11 = v14;
  v12 = sub_100040434((uint64_t)v9, (uint64_t)v14, a4);
  xpc_dictionary_set_BOOL(a3, "status", v12);
  if (v11)
    CFRelease(v11);
  if (v9)
    CFRelease(v9);
  return 0;
}

uint64_t sub_1000264A4(uint64_t a1, void *a2, void *a3, __CFString **a4)
{
  const void *v6;
  const __CFString *v7;
  uint64_t v8;
  const __CFString *v9;
  const void *v11;

  v11 = 0;
  sub_100059DF4(a2, "appID", &v11, a4);
  v6 = v11;
  v7 = (const __CFString *)sub_10001D958((uint64_t)v11, (uint64_t)a4);
  if (v7)
  {
    v9 = v7;
    sub_10000B024(a3, "revocationCheck", v7, (CFTypeRef *)a4, v8);
    CFRelease(v9);
  }
  if (v6)
    CFRelease(v6);
  return 0;
}

uint64_t sub_100026534(int a1, int a2, void *a3, __CFString **a4)
{
  unsigned int v5;

  v5 = sub_100050DD8(a4);
  xpc_dictionary_set_uint64(a3, "status", v5);
  return 1;
}

uint64_t sub_100026570(__SecTask **a1, void *a2, void *a3, __CFString **a4)
{
  _BOOL4 v8;
  const void *v9;
  const void *v11;
  char v12;
  const void *v14;
  const void *v15;

  v14 = 0;
  v15 = 0;
  v8 = sub_100059DF4(a2, "appID", &v15, a4);
  v9 = v15;
  if (!v8 || v15 == 0)
    v9 = sub_100011D84(*a1);
  sub_100011C4C(a2, "anchors", &v14, a4);
  v11 = v14;
  v12 = sub_100040518((uint64_t)v9, (uint64_t)v14, a4);
  xpc_dictionary_set_BOOL(a3, "status", v12);
  if (v11)
    CFRelease(v11);
  if (v9)
    CFRelease(v9);
  return 0;
}

uint64_t sub_100026640(uint64_t a1, void *a2, void *a3, __CFString **a4)
{
  const void *v6;
  const __CFString *v7;
  uint64_t v8;
  const __CFString *v9;
  const void *v11;

  v11 = 0;
  sub_100059DF4(a2, "appID", &v11, a4);
  v6 = v11;
  v7 = (const __CFString *)sub_1000405C0((uint64_t)v11, (uint64_t)a4);
  if (v7)
  {
    v9 = v7;
    sub_10000B024(a3, "anchors", v7, (CFTypeRef *)a4, v8);
    CFRelease(v9);
  }
  if (v6)
    CFRelease(v6);
  return 0;
}

BOOL sub_1000266D0(uint64_t a1, void *a2, void *a3, __CFString **a4)
{
  CFStringRef v7;
  CFStringRef v8;
  _BOOL4 v9;
  const __CFData *v10;
  _BOOL8 v11;
  const UInt8 *BytePtr;
  size_t Length;
  CFDataRef theData;

  v7 = sub_100012BFC(a2, "domain", a4);
  if (!v7)
    return 0;
  v8 = v7;
  theData = 0;
  v9 = sub_1000549DC(*(_DWORD *)(a1 + 20), (uint64_t)v7, (uint64_t)&theData, a4);
  v10 = theData;
  if (theData)
    v11 = v9;
  else
    v11 = 0;
  if (v11)
  {
    if (CFDataGetLength(theData) < 0)
    {
      sub_100012C88(-50, a4, CFSTR("no data for key %s"), "status");
    }
    else
    {
      BytePtr = CFDataGetBytePtr(v10);
      Length = CFDataGetLength(v10);
      xpc_dictionary_set_data(a3, "status", BytePtr, Length);
    }
    v10 = theData;
  }
  if (v10)
  {
    theData = 0;
    CFRelease(v10);
  }
  CFRelease(v8);
  return v11;
}

BOOL sub_1000267DC(uint64_t a1, void *a2, void *a3, __CFString **a4)
{
  CFStringRef v6;
  CFStringRef v7;
  char v8;

  v6 = sub_100026880(a2, a4);
  v7 = v6;
  if (v6)
  {
    v8 = sub_100056A34((uint64_t)v6, a4);
    xpc_dictionary_set_BOOL(a3, "status", v8);
  }
  return v7 != 0;
}

uint64_t sub_100026840(int a1, xpc_object_t xdict, uint64_t a3, _QWORD *a4)
{
  uint64_t result;

  result = xpc_dictionary_get_uint64(xdict, "flags");
  if ((_DWORD)result)
    return sub_100054D94(result, a4);
  return result;
}

CFStringRef sub_100026880(void *a1, __CFString **a2)
{
  CFStringRef result;
  CFStringRef v4;
  uint64_t v5;

  result = sub_100012BFC(a1, "domain", a2);
  if (result)
  {
    v4 = result;
    v5 = sub_10000489C(result, a2);
    CFRelease(v4);
    return (CFStringRef)v5;
  }
  return result;
}

uint64_t sub_1000268CC(void *a1, __CFString **a2)
{
  BOOL v3;
  uint64_t result;
  size_t length;

  length = 0;
  if (xpc_dictionary_get_data(a1, "cert", &length))
    v3 = length == 0;
  else
    v3 = 1;
  if (v3 || length > 0x7FFFFFFFFFFFFFFELL)
  {
    sub_100012C88(-50, a2, CFSTR("object for key %s missing"), "cert");
    return 0;
  }
  result = SecCertificateCreateWithBytes(kCFAllocatorDefault);
  if (!result)
  {
    sub_100012C88(-26275, a2, CFSTR("object for key %s failed to create certificate from data"), "cert");
    return 0;
  }
  return result;
}

void sub_100026968(id a1)
{
  NSObject *v1;
  uint8_t v2[16];

  v1 = sub_100011628("serverxpc");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)v2 = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "Received signal SIGTERM. Will terminate when clean.", v2, 2u);
  }
  xpc_transaction_exit_clean();
}

void sub_1000269D4(uint64_t a1, const char *a2)
{
  __CFDictionary *v2;
  const void *v3;
  os_log_t v4;

  v2 = (__CFDictionary *)qword_100082AB8;
  v3 = *(const void **)(a1 + 32);
  v4 = os_log_create("com.apple.securityd", a2);
  CFDictionaryAddValue(v2, v3, v4);
}

uint64_t sub_100026A10()
{
  _QWORD block[5];

  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100026A8C;
  block[3] = &unk_100075D58;
  block[4] = &qword_100082AC8;
  if (qword_100082AC0 != -1)
    dispatch_once(&qword_100082AC0, block);
  return qword_100082AC8;
}

CFDictionaryRef sub_100026A8C(uint64_t a1)
{
  CFDictionaryRef result;
  void *values;
  void *keys;

  values = kCFBooleanTrue;
  keys = CFSTR("debug");
  result = CFDictionaryCreate(kCFAllocatorDefault, (const void **)&keys, (const void **)&values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  **(_QWORD **)(a1 + 32) = result;
  return result;
}

void sub_100026B28(id a1)
{
  const __CFTimeZone *v1;

  qword_100082AE8 = (uint64_t)CFCalendarCreateWithIdentifier(kCFAllocatorDefault, kCFGregorianCalendar);
  v1 = CFTimeZoneCreateWithTimeIntervalFromGMT(kCFAllocatorDefault, 0.0);
  CFCalendarSetTimeZone((CFCalendarRef)qword_100082AE8, v1);
  if (v1)
    CFRelease(v1);
}

void sub_100026B98(id a1)
{
  qword_100082AD8 = (uint64_t)dispatch_queue_create("ZuluCalendar", 0);
}

uint64_t sub_100026BC0(uint64_t result, int a2, UInt8 *buffer)
{
  uint64_t v4;
  const __CFString *v5;
  CFIndex v6;
  CFIndex usedBufLen;
  CFRange v8;

  if (buffer)
  {
    v4 = result;
    v5 = *(const __CFString **)(result + 40);
    v8 = *(CFRange *)(v4 + 48);
    v6 = *(_QWORD *)(v4 + 64);
    usedBufLen = 0xAAAAAAAAAAAAAAAALL;
    CFStringGetBytes(v5, v8, 0x8000100u, 0, 0, buffer, v6, &usedBufLen);
    buffer[usedBufLen] = 0;
    return (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 32) + 16))();
  }
  return result;
}

uint64_t sub_100026C34(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t sub_100026C40(unsigned __int8 **a1, unint64_t a2, CFTypeRef *a3, uint64_t a4, uint64_t a5)
{
  unsigned __int8 *v7;
  int v8;
  int v9;

  v7 = *a1;
  if (*a1)
  {
    if ((unint64_t)v7 >= a2)
    {
      sub_10002A5E8(-1, CFSTR("com.apple.security.cfder.error"), (uint64_t)a3, a3, a5, CFSTR("Unexpected end of datetime"));
      *a1 = 0;
    }
    else
    {
      v9 = *v7;
      v8 = v9;
      *a1 = v7 + 1;
      if (((v9 << 24) - 956301313) > 0xF6FFFFFE)
        return (v8 - 48);
    }
  }
  sub_10002A5E8(-1, CFSTR("com.apple.security.cfder.error"), (uint64_t)a3, a3, a5, CFSTR("Not a decimal digit"));
  *a1 = 0;
  return 0xFFFFFFFFLL;
}

unint64_t sub_100026CDC(double *a1, CFTypeRef *a2, unsigned int a3, unsigned __int8 *a4, unint64_t a5)
{
  unint64_t v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  unsigned __int8 *v35;
  unsigned __int8 *v36;
  double v37;
  int v38;
  unsigned __int8 *v39;
  const __CFString *v40;
  int v41;
  CFIndex v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  int v46;
  int v47;
  double v48;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  double v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  unsigned __int8 *v71;
  _QWORD v72[6];
  unsigned int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  uint64_t v78;
  int v79;
  double *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t *v84;
  uint64_t v85;
  char v86;
  _DWORD v87[3];

  v5 = a5;
  v71 = a4;
  v68 = sub_100026C40(&v71, a5, a2, (uint64_t)a4, a5);
  v67 = sub_100026C40(&v71, v5, a2, v7, v8);
  v66 = sub_100026C40(&v71, v5, a2, v9, v10);
  v13 = sub_100026C40(&v71, v5, a2, v11, v12);
  v16 = sub_100026C40(&v71, v5, a2, v14, v15);
  v19 = sub_100026C40(&v71, v5, a2, v17, v18);
  v22 = sub_100026C40(&v71, v5, a2, v20, v21);
  v25 = sub_100026C40(&v71, v5, a2, v23, v24);
  v28 = sub_100026C40(&v71, v5, a2, v26, v27);
  v34 = sub_100026C40(&v71, v5, a2, v29, v30);
  v35 = 0;
  v36 = v71;
  v37 = NAN;
  if (v71 && (unint64_t)v71 < v5)
  {
    v38 = *v71;
    if (v38 == 46)
    {
      v39 = v71 + 1;
      if ((unint64_t)(v71 + 1) < v5)
      {
        v38 = *v39;
        if ((v38 - 58) < 0xFFFFFFF6)
        {
          v40 = CFSTR("fraction without digits");
LABEL_14:
          v42 = -1;
LABEL_23:
          sub_10002A5E8(v42, CFSTR("com.apple.security.cfder.error"), v31, a2, v33, v40);
          v35 = 0;
          goto LABEL_24;
        }
        v43 = 0;
        v44 = v5 - (_QWORD)v71 - 2;
        v45 = 1;
        while (v44)
        {
          v46 = v38;
          if (v45 < 0x1999999999999999)
          {
            v45 *= 10;
            v43 = (v38 - 48) + 10 * v43;
          }
          v47 = *++v39;
          v38 = v47;
          --v44;
          if ((v47 - 58) < 0xFFFFFFF6)
          {
            if (v46 == 48)
            {
              v40 = CFSTR("fraction ends in 0");
              goto LABEL_14;
            }
            v37 = (double)(unint64_t)v43 / (double)v45;
            v36 = v39;
            goto LABEL_8;
          }
        }
      }
      v40 = CFSTR("overflow");
      v42 = -8;
      goto LABEL_23;
    }
    v37 = 0.0;
LABEL_8:
    if ((unint64_t)v36 < v5)
    {
      v35 = v36 + 1;
      v71 = v36 + 1;
      switch(v38)
      {
        case 'Z':
          v48 = 0.0;
          goto LABEL_25;
        case '-':
          v41 = -60;
          break;
        case '+':
          v41 = 60;
          break;
        default:
          goto LABEL_24;
      }
      v65 = v41;
      v56 = sub_100026C40(&v71, v5, a2, v32, v33);
      v64 = sub_100026C40(&v71, v5, a2, v57, v58) + 10 * v56;
      v61 = sub_100026C40(&v71, v5, a2, v59, v60);
      v48 = (double)(int)((sub_100026C40(&v71, v5, a2, v62, v63) + 10 * v61 + 60 * v64) * v65);
      v35 = v71;
      if (!v71)
        return 0;
      goto LABEL_25;
    }
    v40 = CFSTR("Unexpected end of datetime");
    goto LABEL_14;
  }
LABEL_24:
  sub_10002A5E8(-1, CFSTR("com.apple.security.cfder.error"), v31, a2, v33, CFSTR("Invalid datetime character"));
  v48 = NAN;
  if (!v35)
    return 0;
LABEL_25:
  if (v35 != (unsigned __int8 *)v5)
  {
    sub_10002A5E8(-1, CFSTR("com.apple.security.cfder.error"), v31, a2, v33, CFSTR("trailing garbage at end of datetime"));
    return 0;
  }
  v50 = (v13 + 10 * v66);
  v51 = (v19 + 10 * v16);
  v52 = (v25 + 10 * v22);
  v87[0] = 0;
  if ((sub_10000BFAC(a3, (v67 + 10 * v68), v50, v51, v52, (v34 + 10 * v28), v87, (__CFString **)a2) & 1) != 0)
  {
    v83 = 0;
    v84 = &v83;
    v85 = 0x2000000000;
    v86 = 0;
    v79 = 0;
    v80 = (double *)((char *)&v78 + 4);
    v81 = 0x2000000000;
    v82 = 0;
    v72[0] = _NSConcreteStackBlock;
    v72[1] = 0x40000000;
    v72[2] = sub_100027168;
    v72[3] = &unk_100075E78;
    v72[4] = &v83;
    v72[5] = (char *)&v78 + 4;
    v73 = a3;
    v74 = v67 + 10 * v68;
    v75 = v50;
    v76 = v51;
    v77 = v52;
    v78 = (v34 + 10 * v28);
    sub_10000BF20((uint64_t)v72);
    if (*((_BYTE *)v84 + 24))
    {
      v55 = v80[3] - v48;
    }
    else
    {
      sub_10002A5E8(-1, CFSTR("com.apple.security.cfder.error"), v53, a2, v54, CFSTR("Failed to encode date from components"));
      v55 = NAN;
    }
    _Block_object_dispose((char *)&v78 + 4, 8);
    _Block_object_dispose(&v83, 8);
    *a1 = v55;
    *a1 = v37 + v55;
  }
  else
  {
    v5 = 0;
    *a1 = NAN;
  }
  return v5;
}

uint64_t sub_100027168(uint64_t a1, CFCalendarRef calendar)
{
  uint64_t result;

  result = CFCalendarComposeAbsoluteTime(calendar, (CFAbsoluteTime *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), "yMdHms", *(unsigned int *)(a1 + 48), *(unsigned int *)(a1 + 52), *(unsigned int *)(a1 + 56), *(unsigned int *)(a1 + 60), *(unsigned int *)(a1 + 64), *(unsigned int *)(a1 + 68));
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (_DWORD)result != 0;
  return result;
}

void sub_1000271D8()
{
  exit(1);
}

BOOL sub_1000271E8(uint64_t a1, sqlite3 *a2, CFTypeRef *a3, CFStringRef format, ...)
{
  CFStringRef v7;
  uint64_t v8;
  void *v9;
  const void *v10;
  uint64_t v11;
  const char *v12;
  uint64_t v14;
  va_list va;

  va_start(va, format);
  if ((_DWORD)a1 && a3)
  {
    v7 = CFStringCreateWithFormatAndArguments(kCFAllocatorDefault, 0, format, va);
    if ((_DWORD)a1 == 14)
    {
      v8 = sqlite3_system_errno(a2);
      v9 = (void *)CFStringCreateWithFormat(0, 0, CFSTR("%d"), v8);
    }
    else
    {
      v9 = (void *)CFRetain(&stru_10007A618);
    }
    v10 = v9;
    v11 = sqlite3_extended_errcode(a2);
    v12 = sqlite3_errmsg(a2);
    if ((_DWORD)v11 == (_DWORD)a1)
      sub_10001BB38(a1, a3, CFSTR("%@: [%d]%@ %s"), v7, a1, v10, v12, v14, va);
    else
      sub_10001BB38(a1, a3, CFSTR("%@: [%d->%d]%@ %s"), v7, a1, v11, v10, v12, va);
    if (v7)
      CFRelease(v7);
    if (v10)
      CFRelease(v10);
  }
  return (_DWORD)a1 == 0;
}

void sub_100027308()
{
  if (qword_100082AF0 != -1)
    dispatch_once(&qword_100082AF0, &stru_100075EE0);
}

void sub_100027330(id a1)
{
  int v1;
  int v2;
  NSObject *v3;
  uint8_t buf[4];
  int v5;

  v1 = sqlite3_config(16, nullsub_3, 0);
  if (v1)
  {
    v2 = v1;
    v3 = sub_100011628("SecWarning");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      v5 = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Could not set up sqlite global error logging to syslog: %d", buf, 8u);
    }
  }
}

uint64_t sub_1000273EC(uint64_t a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass(&unk_100075F00);
  **(_QWORD **)(a1 + 32) = result;
  return result;
}

void sub_10002741C(uint64_t a1)
{
  const void *v2;
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;
  const void *v7;
  const void *v8;
  _QWORD block[5];

  v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    *(_QWORD *)(a1 + 16) = 0;
    CFRelease(v2);
  }
  v3 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100027584;
  block[3] = &unk_100076150;
  block[4] = a1;
  dispatch_sync(v3, block);
  v4 = *(NSObject **)(a1 + 24);
  if (v4)
  {
    dispatch_release(v4);
    *(_QWORD *)(a1 + 24) = 0;
  }
  v5 = *(NSObject **)(a1 + 32);
  if (v5)
  {
    dispatch_release(v5);
    *(_QWORD *)(a1 + 32) = 0;
  }
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 56));
  v6 = *(NSObject **)(a1 + 120);
  if (v6)
  {
    dispatch_release(v6);
    *(_QWORD *)(a1 + 120) = 0;
  }
  v7 = *(const void **)(a1 + 136);
  if (v7)
  {
    _Block_release(v7);
    *(_QWORD *)(a1 + 136) = 0;
  }
  v8 = *(const void **)(a1 + 152);
  if (v8)
  {
    *(_QWORD *)(a1 + 152) = 0;
    CFRelease(v8);
  }
}

CFStringRef sub_1000274F0(uint64_t a1)
{
  return CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("<SecDb path:%@ connections: %@>"), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 48));
}

CFStringRef sub_100027534(uint64_t a1)
{
  sub_100026A10();
  return CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("<SecDb path:%@ connections: %@>"), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 48));
}

void sub_100027584(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  const void *v4;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(const void **)(v2 + 40);
  if (v3)
  {
    *(_QWORD *)(v2 + 40) = 0;
    CFRelease(v3);
    v2 = *(_QWORD *)(a1 + 32);
  }
  v4 = *(const void **)(v2 + 48);
  if (v4)
  {
    *(_QWORD *)(v2 + 48) = 0;
    CFRelease(v4);
  }
}

uint64_t sub_1000275D0(const __CFString *a1, __int16 a2, char a3, char a4, char a5, char a6, void *a7)
{
  uint64_t Instance;
  __int16 v15;
  char v16;
  NSObject *v17;
  char v18;
  CFStringRef Copy;
  const __CFString *v20;
  pthread_mutexattr_t *v21;
  NSObject *v22;
  NSObject *v23;
  char v25;
  void *aBlock;
  _QWORD v27[5];
  _QWORD v28[5];
  uint8_t buf[8];
  uint64_t v30;
  uint64_t (*v31)(uint64_t);
  void *v32;
  uint64_t *v33;
  pthread_mutexattr_t v34;

  *(_QWORD *)buf = _NSConcreteStackBlock;
  v30 = 0x40000000;
  v31 = sub_1000273EC;
  v32 = &unk_100075F60;
  v33 = &qword_100082B00;
  if (qword_100082AF8 != -1)
    dispatch_once(&qword_100082AF8, buf);
  Instance = _CFRuntimeCreateInstance(kCFAllocatorDefault, qword_100082B00, 160, 0);
  if (Instance)
  {
    aBlock = a7;
    v25 = a3;
    v15 = a2;
    v16 = a5;
    if (getenv("__OSINSTALL_ENVIRONMENT"))
    {
      v17 = sub_100011628("#SecDB");
      v18 = a6;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)buf = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "SecDB: running from installer", buf, 2u);
      }
      Copy = CFSTR("file::memory:?cache=shared");
    }
    else
    {
      v18 = a6;
      Copy = CFStringCreateCopy(kCFAllocatorDefault, a1);
    }
    *(_QWORD *)(Instance + 16) = Copy;
    v28[0] = _NSConcreteStackBlock;
    v28[1] = 0x40000000;
    v28[2] = sub_100027978;
    v28[3] = &unk_100075F80;
    v28[4] = Instance;
    *(_QWORD *)buf = _NSConcreteStackBlock;
    v30 = 0x40000000;
    v31 = sub_100026C34;
    v32 = &unk_100075DD0;
    v33 = v28;
    sub_100019A20(a1, (uint64_t)buf);
    v20 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@-commit"), a1);
    v27[0] = _NSConcreteStackBlock;
    v27[1] = 0x40000000;
    v27[2] = sub_1000279A8;
    v27[3] = &unk_100075FA0;
    v27[4] = Instance;
    *(_QWORD *)buf = _NSConcreteStackBlock;
    v30 = 0x40000000;
    v31 = sub_100026C34;
    v32 = &unk_100075DD0;
    v33 = v27;
    sub_100019A20(v20, (uint64_t)buf);
    if (v20)
      CFRelease(v20);
    *(_QWORD *)(Instance + 40) = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    *(_QWORD *)(Instance + 48) = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    v34.__sig = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)v34.__opaque = 0xAAAAAAAAAAAAAAAALL;
    if (pthread_mutexattr_init(&v34) || (v21 = &v34, pthread_mutexattr_setpolicy_np(&v34, 1)))
    {
      v22 = sub_100011628("SecCritical");
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "SecDb: SecDbCreate failed to create attributes for the write mutex; fairness properties are no longer present",
          buf,
          2u);
      }
      v21 = 0;
    }
    if (pthread_mutex_init((pthread_mutex_t *)(Instance + 56), v21))
    {
      v23 = sub_100011628("SecCritical");
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "SecDb: SecDbCreate failed to init the write mutex, this will end badly", buf, 2u);
      }
    }
    pthread_mutexattr_destroy(&v34);
    *(_QWORD *)(Instance + 120) = dispatch_semaphore_create(5);
    *(_BYTE *)(Instance + 128) = 0;
    *(_QWORD *)(Instance + 136) = _Block_copy(aBlock);
    *(_BYTE *)(Instance + 144) = 0;
    *(_DWORD *)(Instance + 148) = 0;
    *(_QWORD *)(Instance + 152) = 0;
    *(_WORD *)(Instance + 160) = v15;
    *(_BYTE *)(Instance + 162) = v25;
    *(_BYTE *)(Instance + 163) = a4;
    *(_BYTE *)(Instance + 164) = v16;
    *(_BYTE *)(Instance + 165) = v18;
    *(_BYTE *)(Instance + 166) = 2;
    *(_QWORD *)(Instance + 168) = 0;
  }
  return Instance;
}

dispatch_queue_t sub_100027978(uint64_t a1, char *label)
{
  dispatch_queue_t result;

  result = dispatch_queue_create(label, 0);
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24) = result;
  return result;
}

dispatch_queue_t sub_1000279A8(uint64_t a1, char *label)
{
  dispatch_queue_t result;

  result = dispatch_queue_create(label, (dispatch_queue_attr_t)&_dispatch_queue_attr_concurrent);
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 32) = result;
  return result;
}

uint64_t sub_1000279E0(uint64_t a1, const __CFString *cf, CFTypeRef *a3)
{
  const __CFString *v4;
  sqlite3_stmt *v6;
  int v7;
  CFStringRef v9;

  v4 = cf;
  CFRetain(cf);
  if (!v4)
    return 1;
  LOBYTE(v6) = 1;
  do
  {
    v9 = 0;
    if ((v6 & 1) != 0)
    {
      v6 = sub_1000198FC(a1, v4, &v9, a3);
      if (v6)
      {
        do
          v7 = sub_100019E48(a1, v6, (uint64_t)a3);
        while (v7 == 1);
        v6 = (sqlite3_stmt *)((v7 != 0) & sub_100019898(v6, a3));
      }
    }
    else
    {
      sub_10001BB38(1, a3, CFSTR("Error with unexecuted sql remaining %@"), v4);
      v6 = 0;
    }
    CFRelease(v4);
    v4 = v9;
  }
  while (v9);
  return (uint64_t)v6;
}

uint64_t sub_100027ACC(uint64_t a1, uint64_t a2, uint64_t a3, int a4, CFTypeRef *a5)
{
  int v10;
  int v11;
  NSObject *v12;
  _BOOL4 v13;
  uint8_t buf[4];
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;

  if (a2 - 5 > 1)
    return sub_100027C80(a1, a2, a5, CFSTR("%@"), a3);
  if (a4 > 4)
  {
    v10 = 250;
    v11 = 250 * a4 - 820;
  }
  else
  {
    v10 = dword_100060384[a4];
    v11 = dword_100060398[a4];
  }
  v12 = sub_100011628("#SecDB");
  v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG);
  if (v11 > 299999)
  {
    if (v13)
    {
      *(_DWORD *)buf = 67109120;
      v16 = v11;
      _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "sqlite busy/locked: too long: %d ms, giving up", buf, 8u);
    }
    return sub_100027C80(a1, a2, a5, CFSTR("%@"), a3);
  }
  if (v13)
  {
    *(_DWORD *)buf = 67109632;
    v16 = a2;
    v17 = 1024;
    v18 = a4;
    v19 = 1024;
    v20 = v11;
    _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "sqlite busy/locked: %d ntries: %d totaltimeout: %d", buf, 0x14u);
  }
  j__sqlite3_sleep(v10);
  return 1;
}

BOOL sub_100027C80(uint64_t a1, uint64_t a2, CFTypeRef *a3, CFStringRef format, ...)
{
  CFStringRef v7;
  __CFString *v8;
  NSObject *v9;
  int v10;
  BOOL v11;
  sqlite3_stmt *v12;
  sqlite3_stmt *v13;
  __CFError *v14;
  CFIndex Code;
  NSObject *v16;
  uint64_t v17;
  const char *v18;
  NSObject *v19;
  uint32_t v20;
  NSObject *v21;
  int v22;
  NSObject *v23;
  _BOOL4 v24;
  const char *v25;
  const void *v26;
  int v27;
  NSObject *v28;
  _BOOL4 v29;
  const char *v30;
  NSObject *v31;
  uint32_t v32;
  NSObject *v33;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  CFTypeRef v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  char v43;
  uint64_t v44;
  uint64_t *v45;
  uint64_t v46;
  char v47;
  uint8_t v48[4];
  uint64_t v49;
  __int128 buf;
  uint64_t (*v51)(uint64_t, sqlite3_stmt *);
  void *v52;
  uint64_t *v53;
  uint64_t *v54;
  uint64_t *v55;
  uint64_t v56;
  va_list va;

  va_start(va, format);
  if (!(_DWORD)a2 || (_DWORD)a2 == 101)
    return !(_DWORD)a2 || (_DWORD)a2 == 101;
  if (a3)
  {
    va_copy((va_list)buf, va);
    v7 = CFStringCreateWithFormatAndArguments(kCFAllocatorDefault, 0, format, va);
    sub_1000271E8(a2, *(sqlite3 **)(a1 + 64), a3, CFSTR("%@"), v7);
    CFRelease(v7);
  }
  *(_BYTE *)(a1 + 48) |= (_DWORD)a2 == 10;
  if (*(_BYTE *)(a1 + 40))
  {
    v8 = (__CFString *)CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("SQL DB %@ is corrupted already. Corruption error was: %d (previously %d)"), format, *(_QWORD *)(*(_QWORD *)(a1 + 16) + 16), a2, *(unsigned int *)(a1 + 44));
    v9 = sub_100011628("SecError");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(_QWORD *)((char *)&buf + 4) = v8;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%@", (uint8_t *)&buf, 0xCu);
    }
    if (CFEqual(*(CFTypeRef *)(*(_QWORD *)(a1 + 16) + 16), CFSTR("/Library/Keychains/keychain-2.db")))
    {
      v10 = 1405092101;
    }
    else if (CFEqual(*(CFTypeRef *)(*(_QWORD *)(a1 + 16) + 16), CFSTR("/Library/Keychains/ocspcache.sqlite3")))
    {
      v10 = 1405092357;
    }
    else if (CFEqual(*(CFTypeRef *)(*(_QWORD *)(a1 + 16) + 16), CFSTR("/Library/Keychains/TrustStore.sqlite3")))
    {
      v10 = 1405092613;
    }
    else if (CFEqual(*(CFTypeRef *)(*(_QWORD *)(a1 + 16) + 16), CFSTR("/Library/Keychains/caissuercache.sqlite3")))
    {
      v10 = 1405092869;
    }
    else
    {
      v10 = 1405091845;
    }
    sub_10002B644(v8, v10);
    if (v8)
      CFRelease(v8);
    if ((_DWORD)a2 == 26 || (_DWORD)a2 == 11)
    {
      v33 = sub_100011628("SecError");
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        v30 = "SecDbConnectionCheckCode detected corruption twice: going to handle corrupt DB";
        v31 = v33;
        v32 = 2;
        goto LABEL_51;
      }
      goto LABEL_52;
    }
    return !(_DWORD)a2 || (_DWORD)a2 == 101;
  }
  v11 = (_DWORD)a2 == 11;
  if ((_DWORD)a2 == 26)
    v11 = 1;
  *(_BYTE *)(a1 + 40) = v11;
  if ((_DWORD)a2 != 26 && (_DWORD)a2 != 11)
    return !(_DWORD)a2 || (_DWORD)a2 == 101;
  *(_DWORD *)(a1 + 44) = a2;
  v44 = 0;
  v45 = &v44;
  v46 = 0x2000000000;
  v47 = 0;
  v40 = 0;
  v41 = &v40;
  v42 = 0x2000000000;
  v43 = 0;
  v36 = 0;
  v37 = &v36;
  v38 = 0x2000000000;
  v39 = 0;
  *(_QWORD *)&buf = _NSConcreteStackBlock;
  *((_QWORD *)&buf + 1) = 0x40000000;
  v51 = sub_1000282FC;
  v52 = &unk_1000761F0;
  v53 = &v36;
  v54 = &v40;
  v55 = &v44;
  v56 = a1;
  v12 = (sqlite3_stmt *)sub_1000198FC(a1, CFSTR("PRAGMA integrity_check"), 0, &v39);
  if (v12)
  {
    v13 = v12;
    sub_1000282FC((uint64_t)&buf, v12);
    sub_100019898(v13, &v39);
  }
  if (!*((_BYTE *)v45 + 24))
  {
    v14 = (__CFError *)v37[3];
    if (!v14)
    {
      *((_BYTE *)v41 + 24) = 1;
      v21 = sub_100011628("#SecDB");
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
        goto LABEL_28;
      *(_WORD *)v48 = 0;
      v18 = "#SecDB warning: failed to run integrity check due to corruption";
      v19 = v21;
      v20 = 2;
      goto LABEL_60;
    }
    Code = CFErrorGetCode(v14);
    if (Code == 26 || Code == 11)
      *((_BYTE *)v41 + 24) = 1;
    v16 = sub_100011628("#SecDB");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      v17 = v37[3];
      *(_DWORD *)v48 = 138543362;
      v49 = v17;
      v18 = "#SecDB warning error %{public}@ when running integrity check";
      v19 = v16;
      v20 = 12;
LABEL_60:
      _os_log_debug_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, v18, v48, v20);
    }
  }
LABEL_28:
  if (*((_BYTE *)v41 + 24))
  {
    v22 = *((unsigned __int8 *)v45 + 24);
    v23 = sub_100011628("SecError");
    v24 = os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT);
    if (v22)
    {
      if (v24)
      {
        *(_WORD *)v48 = 0;
        v25 = "SecDBCheckCorrupted ran integrity_check, and that didn't return ok";
LABEL_34:
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, v25, v48, 2u);
      }
    }
    else if (v24)
    {
      *(_WORD *)v48 = 0;
      v25 = "SecDBCheckCorrupted failed to run integrity check";
      goto LABEL_34;
    }
  }
  v26 = (const void *)v37[3];
  if (v26)
  {
    v37[3] = 0;
    CFRelease(v26);
  }
  v27 = *((unsigned __int8 *)v41 + 24);
  _Block_object_dispose(&v36, 8);
  _Block_object_dispose(&v40, 8);
  _Block_object_dispose(&v44, 8);
  *(_BYTE *)(a1 + 40) = v27;
  v28 = sub_100011628("SecError");
  v29 = os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT);
  if (v27)
  {
    if (v29)
    {
      LODWORD(buf) = 67109120;
      DWORD1(buf) = a2;
      v30 = "operation returned code: %d integrity check=fail";
      v31 = v28;
      v32 = 8;
LABEL_51:
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, v30, (uint8_t *)&buf, v32);
    }
LABEL_52:
    sub_1000281EC(a1, a2, a3);
    return !(_DWORD)a2 || (_DWORD)a2 == 101;
  }
  if (v29)
  {
    LODWORD(buf) = 67109120;
    DWORD1(buf) = a2;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "operation returned code: %d: integrity check=pass", (uint8_t *)&buf, 8u);
  }
  return !(_DWORD)a2 || (_DWORD)a2 == 101;
}

uint64_t sub_1000281EC(uint64_t a1, uint64_t __errnum, CFTypeRef *a3)
{
  uint64_t v3;
  CFIndex v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  const __CFString *v12;
  NSObject *v13;
  uint8_t buf[8];
  uint64_t v15;
  uint64_t (*v16)(uint64_t);
  void *v17;
  Block_layout *v18;

  v3 = *(_QWORD *)(a1 + 16);
  if (*(_BYTE *)(v3 + 163))
  {
    v12 = *(const __CFString **)(v3 + 16);
    *(_QWORD *)buf = _NSConcreteStackBlock;
    v15 = 0x40000000;
    v16 = sub_100026C34;
    v17 = &unk_100075DD0;
    v18 = &stru_1000762A0;
    sub_100019A20(v12, (uint64_t)buf);
    v13 = sub_100011628("SecWarning");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "SecDbHandleCorrupt: killing self so that successor might cleanly delete corrupt db", buf, 2u);
    }
    sub_1000271D8();
  }
  v7 = (int)__errnum;
  v8 = strerror(__errnum);
  sub_10002A5E8(v7, kCFErrorDomainPOSIX, v9, a3, v10, CFSTR("SecDbHandleCorrupt not allowed to repair, handled error: [%d] %s"), __errnum, v8);
  *(_BYTE *)(a1 + 40) = 0;
  return 0;
}

uint64_t sub_1000282FC(uint64_t a1, sqlite3_stmt *a2)
{
  uint64_t v2;
  CFTypeRef *v3;
  _QWORD v5[4];
  __int128 v6;
  sqlite3_stmt *v7;

  v2 = *(_QWORD *)(a1 + 56);
  v3 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_100028368;
  v5[3] = &unk_1000761C8;
  v7 = a2;
  v6 = *(_OWORD *)(a1 + 40);
  return sub_100019D18(v2, a2, v3, (uint64_t)v5);
}

void sub_100028368(uint64_t a1)
{
  const unsigned __int8 *v2;
  const unsigned __int8 *v3;
  NSObject *v4;
  const char *v5;
  int v6;
  const char *v7;

  v2 = sqlite3_column_text(*(sqlite3_stmt **)(a1 + 48), 0);
  v3 = v2;
  if (!v2 || strncasecmp((const char *)v2, "ok", 3uLL))
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
    v4 = sub_100011628("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5 = "NULL";
      if (v3)
        v5 = (const char *)v3;
      v6 = 136315138;
      v7 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "SecDBCheckCorrupted integrity_check returned %s", (uint8_t *)&v6, 0xCu);
    }
  }
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
}

void sub_10002846C(id a1, const char *a2)
{
  NSObject *v3;
  FILE *v4;
  NSObject *v5;
  int v6;
  stat v7;
  uint8_t buf[4];
  _BYTE v9[14];
  char __b[1025];

  memset(__b, 170, sizeof(__b));
  snprintf(__b, 0x401uLL, "%s-iscorrupt", a2);
  memset(&v7, 0, sizeof(v7));
  if (!stat(__b, &v7))
  {
    v3 = sub_100011628("SecError");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)v9 = __b;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "SecDbHandleCorrupt: Tried to write corruption marker %s but one already exists", buf, 0xCu);
    }
  }
  v4 = fopen(__b, "w");
  if (v4)
  {
    fclose(v4);
  }
  else
  {
    v5 = sub_100011628("SecError");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *__error();
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)v9 = v6;
      *(_WORD *)&v9[4] = 2082;
      *(_QWORD *)&v9[6] = __b;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "SecDbHandleCorrupt: Unable (%{darwin.errno}d) to create corruption marker %{public}s", buf, 0x12u);
    }
  }
}

uint64_t sub_1000285F0(uint64_t a1, const __CFString *a2)
{
  char v3;
  char v4;
  NSObject *v5;
  uint64_t v6;
  const void *v7;
  uint64_t v8;
  _QWORD v10[8];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  CFTypeRef v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  char v22;
  uint8_t buf[4];
  const __CFString *v24;
  __int16 v25;
  uint64_t v26;

  v19 = 0;
  v20 = &v19;
  v21 = 0x2000000000;
  v22 = 1;
  v15 = 0;
  v16 = &v15;
  v17 = 0x2000000000;
  v18 = -1;
  v11 = 0;
  v12 = &v11;
  v13 = 0x2000000000;
  v14 = 0;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = sub_100028784;
  v10[3] = &unk_100075FF0;
  v10[4] = &v19;
  v10[5] = &v11;
  v10[6] = &v15;
  v10[7] = a1;
  v3 = sub_10001979C(a1, a2, &v14, (uint64_t)v10);
  if (*((_BYTE *)v20 + 24))
    v4 = v3;
  else
    v4 = 0;
  *((_BYTE *)v20 + 24) = v4;
  if ((v4 & 1) == 0)
  {
    v5 = sub_100011628("SecError");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = v12[3];
      *(_DWORD *)buf = 138412546;
      v24 = a2;
      v25 = 2112;
      v26 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "SecDBGetInteger [%@] failed: %@", buf, 0x16u);
    }
  }
  v7 = (const void *)v12[3];
  if (v7)
  {
    v12[3] = 0;
    CFRelease(v7);
  }
  v8 = *((unsigned int *)v16 + 6);
  _Block_object_dispose(&v11, 8);
  _Block_object_dispose(&v15, 8);
  _Block_object_dispose(&v19, 8);
  return v8;
}

uint64_t sub_100028784(_QWORD *a1, sqlite3_stmt *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  char v8;
  _QWORD v10[6];

  v3 = a1[6];
  v4 = *(_QWORD *)(a1[5] + 8);
  v10[0] = _NSConcreteStackBlock;
  v10[2] = sub_10002880C;
  v10[3] = &unk_100075FC8;
  v5 = a1[7];
  v10[1] = 0x40000000;
  v10[4] = v3;
  v10[5] = a2;
  v6 = sub_100019D18(v5, a2, (CFTypeRef *)(v4 + 24), (uint64_t)v10);
  v7 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v7 + 24))
    v8 = v6;
  else
    v8 = 0;
  *(_BYTE *)(v7 + 24) = v8;
  return 1;
}

uint64_t sub_10002880C(uint64_t a1, _BYTE *a2)
{
  uint64_t result;

  result = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 40), 0);
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  *a2 = 1;
  return result;
}

BOOL sub_10002884C(uint64_t a1, uint64_t a2, CFTypeRef *a3, uint64_t a4)
{
  NSObject *v5;
  _BOOL4 v6;
  const __CFString *v9;
  NSObject *v10;
  char v12;
  _QWORD block[5];
  uint8_t buf[8];
  uint64_t v15;
  void (*v16)(uint64_t);
  void *v17;
  _QWORD *v18;
  uint64_t *v19;
  uint64_t v20;
  CFTypeRef *v21;
  char v22;
  _QWORD v23[3];
  char v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  char v28;

  v12 = 1;
  if (!*(_BYTE *)(a1 + 25))
  {
    if (a2 == 1)
    {
      v9 = CFSTR("BEGIN IMMEDIATE");
    }
    else
    {
      if (a2 != 2)
      {
        sub_10001BB38(1, a3, CFSTR("invalid transaction type %d"), a2);
        goto LABEL_15;
      }
      v9 = CFSTR("BEGIN EXCLUSIVE");
    }
    if (!sqlite3_get_autocommit(*(sqlite3 **)(a1 + 64)) || (sub_1000279E0(a1, v9, a3) & 1) != 0)
    {
      *(_BYTE *)(a1 + 25) = 1;
      (*(void (**)(uint64_t, char *))(a4 + 16))(a4, &v12);
      v25 = 0;
      v26 = &v25;
      v27 = 0x2000000000;
      v28 = 1;
      v23[0] = 0;
      v23[1] = v23;
      v23[2] = 0x2000000000;
      v24 = 0;
      *(_QWORD *)buf = _NSConcreteStackBlock;
      v15 = 0x40000000;
      v16 = sub_100028A64;
      v17 = &unk_100076178;
      v22 = v12;
      v18 = v23;
      v19 = &v25;
      v20 = a1;
      v21 = a3;
      if (*(_BYTE *)(a1 + 24))
      {
        sub_100028A64((uint64_t)buf);
      }
      else
      {
        v10 = *(NSObject **)(*(_QWORD *)(a1 + 16) + 32);
        block[0] = _NSConcreteStackBlock;
        block[1] = 0x40000000;
        block[2] = sub_100028CAC;
        block[3] = &unk_1000761A0;
        block[4] = buf;
        dispatch_barrier_sync(v10, block);
      }
      v6 = *((_BYTE *)v26 + 24) != 0;
      _Block_object_dispose(v23, 8);
      _Block_object_dispose(&v25, 8);
      return v12 && v6;
    }
LABEL_15:
    v6 = 0;
    return v12 && v6;
  }
  (*(void (**)(uint64_t, char *))(a4 + 16))(a4, &v12);
  if (!v12)
  {
    v5 = sub_100011628("#SecDB");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "#SecDB nested transaction asked to not be committed", buf, 2u);
    }
  }
  v6 = 1;
  return v12 && v6;
}

void sub_100028A64(uint64_t a1)
{
  int v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  double v11;
  int v12;
  int v13;
  NSObject *v14;
  char *errmsg;
  char *sql;
  uint8_t buf[4];
  int v18;
  __int16 v19;
  char *v20;

  v2 = *(unsigned __int8 *)(a1 + 64);
  v3 = *(_QWORD *)(a1 + 48);
  if (v2)
  {
    if (!*(_BYTE *)(v3 + 24))
    {
      sub_100028CB8(v3, 1);
      v3 = *(_QWORD *)(a1 + 48);
    }
    v4 = sub_1000279E0(v3, CFSTR("END"), *(CFTypeRef **)(a1 + 56));
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v4;
  }
  else
  {
    v5 = sub_1000279E0(v3, CFSTR("ROLLBACK"), *(CFTypeRef **)(a1 + 56));
    v4 = 0;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v5;
  }
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v4;
  v6 = *(_QWORD *)(a1 + 48);
  *(_BYTE *)(v6 + 25) = 0;
  if (!*(_BYTE *)(v6 + 24))
  {
    sub_100028CB8(v6, 2 * *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
    v6 = *(_QWORD *)(a1 + 48);
  }
  *(_QWORD *)(v6 + 32) = 1;
  if (*(_BYTE *)(a1 + 64))
  {
    if (*(_BYTE *)(*(_QWORD *)(v6 + 16) + 165))
    {
      if (!*(_BYTE *)(v6 + 24))
      {
        v7 = sub_1000285F0(v6, CFSTR("pragma page_count"));
        if (v7 >= 1)
        {
          v8 = v7;
          v9 = sub_1000285F0(v6, CFSTR("pragma freelist_count"));
          if ((v9 & 0x80000000) == 0)
          {
            LODWORD(v10) = v9;
            v11 = (double)(v8 - (uint64_t)v9) / (double)v8;
            if (v9 >> 13 || v11 <= 0.85)
            {
              if (v11 >= 0.4)
                v10 = (uint64_t)((double)v9 * 0.2);
              sql = 0;
              asprintf(&sql, "pragma incremental_vacuum(%d)", v10);
              if (sql)
              {
                errmsg = 0;
                v12 = sqlite3_exec(*(sqlite3 **)(v6 + 64), sql, 0, 0, &errmsg);
                if (v12)
                {
                  v13 = v12;
                  v14 = sub_100011628("SecError");
                  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 67109378;
                    v18 = v13;
                    v19 = 2082;
                    v20 = errmsg;
                    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "incremental_vacuum failed with: (%d) %{public}s", buf, 0x12u);
                  }
                }
                sqlite3_free(errmsg);
                free(sql);
              }
            }
          }
        }
      }
    }
  }
}

uint64_t sub_100028CAC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_100028CB8(uint64_t a1, uint64_t a2)
{
  const void *v4;
  uint64_t v5;
  os_unfair_lock_s *v6;
  const __CFArray *v7;
  const __CFArray *Copy;
  _QWORD context[7];
  CFRange v10;

  v4 = *(const void **)(a1 + 72);
  if (CFArrayGetCount((CFArrayRef)v4))
  {
    v5 = *(_QWORD *)(a1 + 16);
    v6 = (os_unfair_lock_s *)(v5 + 148);
    os_unfair_lock_lock((os_unfair_lock_t)(v5 + 148));
    v7 = *(const __CFArray **)(v5 + 152);
    if (v7)
    {
      Copy = CFArrayCreateCopy(kCFAllocatorDefault, v7);
      os_unfair_lock_unlock(v6);
      if (Copy)
      {
        *(_QWORD *)(a1 + 72) = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        context[0] = _NSConcreteStackBlock;
        context[1] = 0x40000000;
        context[2] = sub_100028DDC;
        context[3] = &unk_1000762E8;
        context[4] = a1;
        context[5] = a2;
        context[6] = v4;
        v10.length = CFArrayGetCount(Copy);
        v10.location = 0;
        CFArrayApplyFunction(Copy, v10, (CFArrayApplierFunction)sub_100028DF8, context);
        if (v4)
          CFRelease(v4);
        CFRelease(Copy);
      }
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 148));
    }
  }
}

uint64_t sub_100028DDC(_QWORD *a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))(a2 + 16))(a2, a1[4], a1[5], *(_QWORD *)(a1[4] + 32), a1[6]);
}

uint64_t sub_100028DF8(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_100028E0C(uint64_t a1, char a2)
{
  uint64_t Instance;
  uint64_t v5;
  _QWORD block[5];

  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_1000295D0;
  block[3] = &unk_100076130;
  block[4] = &qword_100082B10;
  if (qword_100082B08 != -1)
    dispatch_once(&qword_100082B08, block);
  Instance = _CFRuntimeCreateInstance(kCFAllocatorDefault, qword_100082B10, 64, 0);
  v5 = Instance;
  if (Instance)
  {
    *(_QWORD *)(Instance + 16) = a1;
    *(_BYTE *)(Instance + 24) = a2;
    *(_BYTE *)(Instance + 25) = 0;
    *(_QWORD *)(Instance + 32) = 2;
    *(_BYTE *)(Instance + 40) = 0;
    *(_DWORD *)(Instance + 44) = 0;
    *(_BYTE *)(Instance + 48) = 0;
    *(_QWORD *)(Instance + 56) = 0;
    *(_QWORD *)(Instance + 64) = 0;
    *(_QWORD *)(Instance + 72) = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  }
  return v5;
}

uint64_t sub_100028F04(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const __CFString *v3;
  uint64_t v4;
  _QWORD v6[8];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  char v10;
  _QWORD v11[5];

  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 1;
  v3 = *(const __CFString **)(*(_QWORD *)(a1 + 16) + 16);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = sub_10002906C;
  v6[3] = &unk_100076240;
  v6[4] = &v7;
  v6[5] = a1;
  v6[6] = a2;
  v6[7] = a3;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  v11[2] = sub_100026C34;
  v11[3] = &unk_100075DD0;
  v11[4] = v6;
  sub_100019A20(v3, (uint64_t)v11);
  v4 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_100028FC4(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  _BYTE *v4;

  v1 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 16);
  if (*(_BYTE *)(v1 + 144))
  {
    *(_BYTE *)(v1 + 144) = 0;
    if (((*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24)
                                                       + 16)
                                           + 136)
                               + 16))() & 1) == 0)
    {
      v3 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v4 = *(_BYTE **)(v3 + 24);
      if (!v4[40]
        || (sub_1000281EC((uint64_t)v4, 0, *(CFTypeRef **)(a1 + 48)) & 1) == 0
        && (v3 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), (v4 = *(_BYTE **)(v3 + 24)) != 0))
      {
        *(_QWORD *)(v3 + 24) = 0;
        CFRelease(v4);
      }
    }
  }
}

void sub_10002906C(uint64_t a1, char *filename)
{
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  char *v8;
  char *v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v13;
  CFIndex v14;
  CFTypeRef *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  BOOL v20;
  _BYTE *v21;

  v4 = *(_QWORD *)(a1 + 40);
  if (*(_BYTE *)(*(_QWORD *)(v4 + 16) + 162))
  {
    if (*(_BYTE *)(v4 + 24))
      v5 = 4194305;
    else
      v5 = 4194306;
  }
  else
  {
    v5 = 4194305;
  }
  if (*(_QWORD *)(a1 + 48))
    v6 = sub_100029288(v4, filename, v5, 0);
  else
    v6 = 0;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v6;
  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (!*(_BYTE *)(v7 + 24))
  {
    *(_BYTE *)(v7 + 24) = 1;
    if (*(_QWORD *)(a1 + 48))
    {
      v8 = dirname(filename);
      if (v8)
      {
        v9 = v8;
        v10 = *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 16) + 160);
        v11 = mkpath_np(v8, (v10 >> 2) & 0x49 | v10);
        if ((_DWORD)v11 && (_DWORD)v11 != 17)
        {
          v13 = v11;
          v14 = (int)v11;
          v15 = *(CFTypeRef **)(a1 + 56);
          v16 = strerror(v11);
          sub_10002A5E8(v14, kCFErrorDomainPOSIX, v17, v15, v18, CFSTR("mkpath_np %s: [%d] %s"), v9, v13, v16);
          *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
        }
      }
    }
    v19 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    if (*(_BYTE *)(v19 + 24))
    {
      v20 = sub_100029288(*(_QWORD *)(a1 + 40), filename, 4194310, *(CFTypeRef **)(a1 + 56));
      v19 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    }
    else
    {
      v20 = 0;
    }
    *(_BYTE *)(v19 + 24) = v20;
    if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    {
      chmod(filename, *(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 16) + 160));
      v21 = *(_BYTE **)(a1 + 48);
      if (v21)
        *v21 = 1;
    }
  }
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    if (qword_100082B18 != -1)
      dispatch_once(&qword_100082B18, &stru_100076280);
    if (dword_100082B20)
      sqlite3_trace_v2(*(sqlite3 **)(*(_QWORD *)(a1 + 40) + 64), dword_100082B20, (int (__cdecl *)(unsigned int, void *, void *, void *))sub_10002940C, *(void **)(a1 + 40));
  }
}

BOOL sub_100029288(uint64_t a1, char *filename, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  sqlite3 *v13;
  sqlite3_stmt *ppStmt;
  sqlite3 *ppDb;

  v8 = *(_QWORD *)(a1 + 16);
  v9 = *(unsigned __int8 *)(v8 + 164);
  v10 = *(unsigned __int8 *)(v8 + 165);
  ppDb = 0;
  v11 = sqlite3_open_v2(filename, &ppDb, a3, 0);
  if ((_DWORD)v11)
  {
    if (ppDb)
    {
      sub_1000271E8(v11, ppDb, a4, CFSTR("open_v2 \"%s\" 0x%X"), filename, a3);
      sqlite3_close(ppDb);
      ppDb = 0;
    }
    else
    {
      sub_10001BB38(v11, a4, CFSTR("open_v2 \"%s\" 0x%X"), filename, a3);
    }
    goto LABEL_16;
  }
  if ((a3 & 2) == 0)
    goto LABEL_16;
  if (v10)
  {
    ppStmt = 0;
    if (!sqlite3_prepare_v2(ppDb, "PRAGMA auto_vacuum", -1, &ppStmt, 0))
    {
      if (sqlite3_step(ppStmt) == 100)
      {
        v12 = sqlite3_column_int(ppStmt, 0);
        sqlite3_finalize(ppStmt);
        if (v12 == 2)
          goto LABEL_13;
      }
      else
      {
        sqlite3_finalize(ppStmt);
      }
    }
    sqlite3_exec(ppDb, "PRAGMA auto_vacuum = incremental", 0, 0, 0);
    sqlite3_exec(ppDb, "VACUUM", 0, 0, 0);
  }
LABEL_13:
  if (v9)
    sqlite3_exec(ppDb, "PRAGMA journal_mode = WAL", 0, 0, 0);
  sqlite3_busy_timeout(ppDb, 5000);
LABEL_16:
  v13 = ppDb;
  *(_QWORD *)(a1 + 64) = ppDb;
  return v13 != 0;
}

uint64_t sub_10002940C()
{
  return 0;
}

void sub_100029414(id a1)
{
  NSObject *v1;
  _DWORD v2[2];

  if (sub_1000294F8())
    dword_100082B20 = 2;
  if (sub_1000294F8())
    dword_100082B20 = 1;
  if (sub_1000294F8())
    dword_100082B20 = 4;
  v1 = sub_100011628("#SecDB");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
  {
    v2[0] = 67109120;
    v2[1] = dword_100082B20;
    _os_log_debug_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "sqlDb: sql trace mask: 0x%08x", (uint8_t *)v2, 8u);
  }
}

uint64_t sub_1000294F8()
{
  uint64_t v0;
  const __CFBoolean *v1;
  const __CFBoolean *v2;
  CFTypeID v3;
  BOOL v4;
  CFTypeID v5;
  int valuePtr;

  if (!csr_check(16))
  {
    v1 = (const __CFBoolean *)CFPreferencesCopyValue(CFSTR("SQLProfile"), CFSTR("com.apple.security"), kCFPreferencesAnyUser, kCFPreferencesAnyHost);
    if (v1)
    {
      v2 = v1;
      v3 = CFGetTypeID(v1);
      if (v3 == CFBooleanGetTypeID())
      {
        v4 = CFBooleanGetValue(v2) == 0;
      }
      else
      {
        v5 = CFGetTypeID(v2);
        if (v5 != CFNumberGetTypeID())
        {
          v0 = 0;
LABEL_12:
          CFRelease(v2);
          return v0;
        }
        valuePtr = 0;
        CFNumberGetValue(v2, kCFNumberSInt32Type, &valuePtr);
        v4 = valuePtr == 0;
      }
      v0 = !v4;
      goto LABEL_12;
    }
  }
  return 0;
}

uint64_t sub_1000295D0(uint64_t a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass(&unk_1000760D0);
  **(_QWORD **)(a1 + 32) = result;
  return result;
}

void sub_100029600(uint64_t a1)
{
  sqlite3 *v2;
  int v3;
  const void *v4;
  const void *v5;
  NSObject *v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  int v10;
  uint8_t buf[4];
  int v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  const char *v16;

  v2 = *(sqlite3 **)(a1 + 64);
  if (v2 && (v3 = sqlite3_close(v2)) != 0)
  {
    v10 = v3;
    v6 = sub_100011628("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v7 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 16);
      v8 = sqlite3_errmsg(*(sqlite3 **)(a1 + 64));
      *(_DWORD *)buf = 67109634;
      v12 = v10;
      v13 = 2112;
      v14 = v7;
      v15 = 2080;
      v16 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "failed to close database connection (%d) for %@: %s", buf, 0x1Cu);
    }
    v9 = _os_assert_log(0);
    _os_crash(v9);
    __break(1u);
  }
  else
  {
    *(_QWORD *)(a1 + 16) = 0;
    v4 = *(const void **)(a1 + 72);
    if (v4)
    {
      *(_QWORD *)(a1 + 72) = 0;
      CFRelease(v4);
    }
    v5 = *(const void **)(a1 + 56);
    if (v5)
    {
      *(_QWORD *)(a1 + 56) = 0;
      CFRelease(v5);
    }
  }
}

CFStringRef sub_100029744(uint64_t a1)
{
  const char *v1;
  const char *v2;

  v1 = "ro";
  if (!*(_BYTE *)(a1 + 24))
    v1 = "rw";
  if (*(_QWORD *)(a1 + 64))
    v2 = "open";
  else
    v2 = "closed";
  return CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("<SecDbConnection %s %s>"), v1, v2);
}

CFStringRef sub_1000297B8(uint64_t a1)
{
  const char *v2;
  const char *v3;

  sub_100026A10();
  v2 = "ro";
  if (!*(_BYTE *)(a1 + 24))
    v2 = "rw";
  if (*(_QWORD *)(a1 + 64))
    v3 = "open";
  else
    v3 = "closed";
  return CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("<SecDbConnection %s %s>"), v2, v3);
}

void sub_100029838(uint64_t a1, const std::__fs::filesystem::path *a2)
{
  NSObject *v4;
  int v5;
  const char *v6;
  NSObject *v7;
  uint32_t v8;
  NSObject *v9;
  std::error_code *v10;
  std::error_code *v11;
  NSObject *v12;
  int v13;
  const char *v14;
  NSObject *v15;
  uint32_t v16;
  NSObject *v17;
  NSObject *v18;
  int v19;
  stat v20;
  uint8_t buf[4];
  _BYTE v22[14];
  _BYTE __b[1025];

  memset(__b, 170, sizeof(__b));
  snprintf(__b, 0x401uLL, "%s-iscorrupt", (const char *)a2);
  memset(&v20, 0, sizeof(v20));
  if (!stat(__b, &v20))
  {
    v9 = sub_100011628("SecWarning");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)v22 = __b;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "SecDbSecDbProcessCorruptionMarker: found corruption marker %s", buf, 0xCu);
    }
    if (remove((const std::__fs::filesystem::path *)__b, v10))
    {
      v12 = sub_100011628("SecError");
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        v13 = *__error();
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)v22 = v13;
        v14 = "SecDbSecDbProcessCorruptionMarker: Unable (%{darwin.errno}d) to delete corruption marker";
        v15 = v12;
        v16 = 8;
LABEL_10:
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, v14, buf, v16);
      }
    }
    else
    {
      if (!remove(a2, v11) || *__error() == 2)
      {
        v17 = sub_100011628("SecWarning");
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          return;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)v22 = a2;
        v6 = "SecDbSecDbProcessCorruptionMarker: deleted corrupt db %{public}s";
        v7 = v17;
        v8 = 12;
        goto LABEL_16;
      }
      v18 = sub_100011628("SecError");
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        v19 = *__error();
        *(_DWORD *)buf = 67109378;
        *(_DWORD *)v22 = v19;
        *(_WORD *)&v22[4] = 2082;
        *(_QWORD *)&v22[6] = a2;
        v14 = "SecDbSecDbProcessCorruptionMarker: Unable (%{darwin.errno}d) to delete db %{public}s";
        v15 = v18;
        v16 = 18;
        goto LABEL_10;
      }
    }
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
    return;
  }
  if (*__error() != 2)
  {
    v4 = sub_100011628("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5 = *__error();
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)v22 = v5;
      v6 = "SecDbSecDbProcessCorruptionMarker: Unable to check for corruption marker: %{darwin.errno}d";
      v7 = v4;
      v8 = 8;
LABEL_16:
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v6, buf, v8);
    }
  }
}

uint64_t sub_100029AF0(uint64_t a1, __CFString **a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v6;

  if (a1)
  {
    v6 = 0;
    sub_1000194AC(a1, 0, &v6, (uint64_t)a2);
    v4 = v6;
    if (v6)
    {
      (*(void (**)(uint64_t, uint64_t))(a3 + 16))(a3, v6);
      sub_100019414(v4);
      return 1;
    }
  }
  else
  {
    sub_100012C88(-25291, a2, CFSTR("failed to get a db handle"));
  }
  return 0;
}

uint64_t sub_100029B6C(uint64_t a1, sqlite3_stmt *pStmt, CFTypeRef *a3, uint64_t a4)
{
  uint64_t i;
  NSObject *v9;
  const char *v10;
  uint64_t v11;
  const char *v12;
  uint8_t buf[4];
  const char *v15;

  for (i = 0; ; i = (i + 1))
  {
    if (*(_BYTE *)(a1 + 24) && !sqlite3_stmt_readonly(pStmt))
    {
      v9 = sub_100011628("SecError");
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        v10 = sqlite3_sql(pStmt);
        *(_DWORD *)buf = 136315138;
        v15 = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "SecDbForEach: SecDbConnection is readonly but we're about to write: %s", buf, 0xCu);
      }
    }
    v11 = sqlite3_step(pStmt);
    if ((_DWORD)v11 != 100)
      break;
    if (a4)
    {
      if (((*(uint64_t (**)(uint64_t, uint64_t))(a4 + 16))(a4, i) & 1) == 0)
        return 0;
    }
    else
    {
      v12 = sqlite3_sql(pStmt);
      sub_10001BB38(100, a3, CFSTR("step[%d]: %s returned SQLITE_ROW with NULL row block"), i, v12);
    }
  }
  if ((_DWORD)v11 == 101)
    return 1;
  sub_100027C80(a1, v11, a3, CFSTR("SecDbForEach step[%d]"), i);
  return 0;
}

void sub_100029CF4(id a1)
{
  const __CFDictionary *Mutable;

  Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  sub_100029DA8(Mutable, byte_100061A1E, 1);
  sub_100029DA8(Mutable, byte_100061A3E, 1);
  sub_100029DA8(Mutable, byte_100061A5E, 1);
  sub_100029DA8(Mutable, byte_100061A7E, 0);
  sub_100029DA8(Mutable, byte_100061A9E, 0);
  sub_100029DA8(Mutable, byte_100061ABE, 0);
  qword_100082B50 = (uint64_t)Mutable;
}

void sub_100029DA8(const __CFDictionary *a1, const UInt8 *a2, int a3)
{
  CFDataRef v5;
  const void **v6;

  v5 = CFDataCreateWithBytesNoCopy(0, a2, 32, kCFAllocatorNull);
  if (CFDictionaryGetValue(a1, v5))
    abort();
  v6 = (const void **)&kCFBooleanTrue;
  if (!a3)
    v6 = (const void **)&kCFBooleanFalse;
  CFDictionarySetValue(a1, v5, *v6);
  if (v5)
    CFRelease(v5);
}

void sub_100029E40(id a1)
{
  __CFDictionary *Mutable;
  CFDataRef v2;
  CFDataRef v3;

  Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v2 = CFDataCreateWithBytesNoCopy(0, byte_1000603AC, 32, kCFAllocatorNull);
  CFDictionarySetValue(Mutable, v2, kCFBooleanTrue);
  if (v2)
    CFRelease(v2);
  v3 = CFDataCreateWithBytesNoCopy(0, byte_1000603CC, 32, kCFAllocatorNull);
  CFDictionarySetValue(Mutable, v3, kCFBooleanTrue);
  if (v3)
    CFRelease(v3);
  qword_100082B30 = (uint64_t)Mutable;
}

void sub_100029F10(uint64_t a1)
{
  const __CFArray *Mutable;

  Mutable = CFArrayCreateMutable(0, 3, &kCFTypeArrayCallBacks);
  sub_100029FD0(Mutable);
  sub_100029FD0(Mutable);
  sub_100029FD0(Mutable);
  if ((SecIsInternalRelease() & 1) != 0 || *(_BYTE *)(a1 + 32))
  {
    sub_100029FD0(Mutable);
    sub_100029FD0(Mutable);
    sub_100029FD0(Mutable);
  }
  qword_100082B38 = (uint64_t)Mutable;
}

void sub_100029FD0(const __CFArray *a1)
{
  const void *v2;
  CFRange v3;

  v2 = (const void *)SecCertificateCreateWithBytes(0);
  v3.length = CFArrayGetCount(a1);
  v3.location = 0;
  if (CFArrayContainsValue(a1, v3, v2))
    abort();
  CFArrayAppendValue(a1, v2);
  if (v2)
    CFRelease(v2);
}

CFMutableArrayRef sub_10002A03C(unsigned __int16 *a1, unint64_t a2)
{
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v5;
  unint64_t v6;
  const UInt8 *v7;
  unint64_t v8;
  BOOL v9;
  const UInt8 *v10;
  CFDataRef v11;
  CFDataRef v12;

  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v5 = Mutable;
  if (a2 < 3 || !Mutable)
    goto LABEL_11;
  v6 = __rev16(*a1);
  if (v6 != a2 - 2)
  {
LABEL_12:
    CFRelease(v5);
    return 0;
  }
  v7 = (const UInt8 *)(a1 + 1);
  if (v6)
  {
    while (v6 != 1)
    {
      v8 = __rev16(*(unsigned __int16 *)v7);
      v9 = v6 - 2 >= v8;
      v6 = v6 - 2 - v8;
      if (!v9)
        break;
      v10 = v7 + 2;
      v11 = CFDataCreate(kCFAllocatorDefault, v10, v8);
      if (!v11)
        break;
      v12 = v11;
      v7 = &v10[v8];
      CFArrayAppendValue(v5, v11);
      CFRelease(v12);
      if (!v6)
        return v5;
    }
LABEL_11:
    if (v5)
      goto LABEL_12;
  }
  return v5;
}

uint64_t sub_10002A124(const __CFNumber *a1, CFTypeRef *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t valuePtr;

  valuePtr = 0xAAAAAAAAAAAAAAAALL;
  if (CFNumberGetValue(a1, kCFNumberLongLongType, &valuePtr))
  {
    v5 = HIBYTE(valuePtr);
    if ((HIBYTE(valuePtr) + 1) > 1u)
    {
      v11 = 8;
    }
    else
    {
      v6 = 9;
      v7 = 48;
      v8 = 1;
      while ((unint64_t)(v6 - 2) >= 2)
      {
        v9 = valuePtr >> v7;
        --v6;
        v7 -= 8;
        if ((_DWORD)v5 != v9)
        {
          v8 = v6 - 1;
          goto LABEL_10;
        }
      }
      v6 = 2;
LABEL_10:
      if ((((valuePtr >> (8 * v8 - 8)) ^ v5) & 0x80) != 0)
        v11 = v6;
      else
        v11 = v8;
    }
    return ccder_sizeof(2, v11);
  }
  else
  {
    sub_10002A5E8(-4, CFSTR("com.apple.security.cfder.error"), v3, a2, v4, CFSTR("Unable to get number from data"));
    return 0;
  }
}

uint64_t sub_10002A1FC(const __CFNumber *a1, CFTypeRef *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t result;
  uint64_t v18;
  uint64_t v19;
  uint64_t valuePtr;

  valuePtr = 0xAAAAAAAAAAAAAAAALL;
  if (!CFNumberGetValue(a1, kCFNumberLongLongType, &valuePtr))
  {
    sub_10002A5E8(-4, CFSTR("com.apple.security.cfder.error"), v7, a2, v8, CFSTR("Unable to get number from data"));
    return 0;
  }
  v9 = valuePtr;
  v10 = HIBYTE(valuePtr);
  if ((HIBYTE(valuePtr) + 1) > 1u)
  {
    v15 = 8;
    if (!a4)
      goto LABEL_22;
  }
  else
  {
    v11 = 9;
    v12 = 48;
    v13 = 1;
    while ((unint64_t)(v11 - 2) >= 2)
    {
      v14 = valuePtr >> v12;
      --v11;
      v12 -= 8;
      if ((_DWORD)v10 != v14)
      {
        v13 = v11 - 1;
        goto LABEL_11;
      }
    }
    v11 = 2;
LABEL_11:
    if ((((valuePtr >> (8 * v13 - 8)) ^ v10) & 0x80) != 0)
      v15 = v11;
    else
      v15 = v13;
    if (!a4)
      goto LABEL_22;
  }
  if (a4 - a3 < (uint64_t)v15)
  {
LABEL_22:
    sub_10002A5E8(-3, CFSTR("com.apple.security.cfder.error"), v7, a2, v8, CFSTR("Unknown size"));
    return 0;
  }
  if (v15 <= 1)
    v16 = 1;
  else
    v16 = v15;
  do
  {
    *(_BYTE *)--a4 = v9;
    v9 >>= 8;
    --v16;
  }
  while (v16);
  valuePtr = v9;
  result = ccder_encode_tl(2, v15, a3, a4);
  if (!result)
  {
    sub_10002A5E8(-7, CFSTR("com.apple.security.cfder.error"), v18, a2, v19, CFSTR("ccder failed to encode"));
    return 0;
  }
  return result;
}

void sub_10002A34C(CFIndex a1, const __CFString *a2, __CFString *cf, CFTypeRef *a4, CFStringRef format, va_list arguments)
{
  const __CFString *v10;
  const __CFDictionary *v11;
  const __CFString *Value;
  _BOOL4 v13;
  CFIndex Code;
  const __CFString *Domain;
  CFComparisonResult v16;
  _BOOL4 v18;
  __CFString *v19;
  const __CFString *v20;
  const __CFDictionary *v21;
  const __CFDictionary *v22;
  const void *v23;
  const __CFNumber *v24;
  CFNumberRef v25;
  __CFDictionary *Mutable;
  __CFDictionary *v27;
  uint64_t v28;
  uint64_t valuePtr;

  if (!a4)
    return;
  if (*a4)
  {
    if (cf)
    {
      if (*a4 != cf)
        CFRelease(cf);
    }
    return;
  }
  v10 = CFStringCreateWithFormatAndArguments(0, 0, format, arguments);
  v28 = 0;
  if (!cf)
    goto LABEL_28;
  v11 = CFErrorCopyUserInfo((CFErrorRef)cf);
  Value = (const __CFString *)CFDictionaryGetValue(v11, kCFErrorDescriptionKey);
  if (Value)
  {
    v13 = CFStringCompare(v10, Value, 0) == kCFCompareEqualTo;
    if (!v11)
      goto LABEL_10;
    goto LABEL_9;
  }
  v13 = 0;
  if (v11)
LABEL_9:
    CFRelease(v11);
LABEL_10:
  Code = CFErrorGetCode((CFErrorRef)cf);
  Domain = CFErrorGetDomain((CFErrorRef)cf);
  v16 = CFStringCompare(a2, Domain, 0);
  v18 = Code == a1 && v16 == kCFCompareEqualTo && v13;
  v19 = cf;
  if (v18)
    goto LABEL_17;
  v21 = CFErrorCopyUserInfo((CFErrorRef)cf);
  if (v21)
  {
    v22 = v21;
    v23 = (const void *)kSOSCountKey;
    if (CFDictionaryContainsKey(v21, kSOSCountKey) == 1)
    {
      v24 = (const __CFNumber *)CFDictionaryGetValue(v22, v23);
      if (v24)
      {
        valuePtr = 0;
        CFNumberGetValue(v24, kCFNumberLongType, &valuePtr);
        if (valuePtr > 199)
        {
          CFRelease(v22);
          v19 = cf;
LABEL_17:
          CFRetain(v19);
          *a4 = cf;
          CFRelease(cf);
          if (!v10)
            return;
          v20 = v10;
          goto LABEL_42;
        }
        v28 = valuePtr + 1;
      }
    }
    CFRelease(v22);
  }
LABEL_28:
  v25 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongType, &v28);
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v27 = Mutable;
  if (cf)
    CFDictionaryAddValue(Mutable, kCFErrorUnderlyingErrorKey, cf);
  if (v25)
    CFDictionaryAddValue(v27, kSOSCountKey, v25);
  if (v10)
    CFDictionaryAddValue(v27, kCFErrorDescriptionKey, v10);
  *a4 = CFErrorCreate(kCFAllocatorDefault, a2, a1, v27);
  if (v25)
    CFRelease(v25);
  if (v10)
    CFRelease(v10);
  if (v27)
    CFRelease(v27);
  if (cf)
  {
    v20 = cf;
LABEL_42:
    CFRelease(v20);
  }
}

void sub_10002A5E8(CFIndex a1, const __CFString *a2, uint64_t a3, CFTypeRef *a4, uint64_t a5, CFStringRef format, ...)
{
  va_list va;

  va_start(va, format);
  sub_10002A34C(a1, a2, 0, a4, format, va);
}

const UInt8 *sub_10002A618(const __CFAllocator *a1, CFTypeRef *a2, CFTypeRef *a3, const UInt8 *a4, _BYTE *a5)
{
  const UInt8 *v5;
  CFIndex v10;
  uint64_t v11;
  _BYTE *v12;
  const CFBooleanRef *v13;
  const __CFString *v14;
  CFIndex v15;
  const __CFString *v16;
  CFIndex v17;
  CFIndex v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  CFDateRef v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  __CFSet *Mutable;
  BOOL v39;
  void *v40;
  UInt8 *v41;
  const UInt8 *v42;
  const UInt8 *v43;
  uint64_t v44;
  const UInt8 *v45;
  const UInt8 *v46;
  CFIndex v47;
  void *v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  signed int v56;
  CFMutableArrayRef v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  void *v62;
  uint64_t v63;
  uint64_t v64;
  const UInt8 *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  void *v71;
  CFAbsoluteTime v72;
  CFDataRef v73;
  CFStringRef v74;
  CFDataRef v75;
  CFStringRef v76;
  CFDateRef v77;
  const UInt8 *v78;
  int8x8_t v79;
  unsigned __int8 *v80;
  unsigned int v81;
  CFIndex v82;
  unint64_t v83;
  uint64_t v84;
  unint64_t v85;
  int8x16_t v86;
  int64x2_t v87;
  int64x2_t v88;
  uint64x2_t v89;
  int64x2_t v90;
  int8x16_t v91;
  int8x16_t v92;
  CFNumberRef v93;
  uint64_t v94;
  const UInt8 *v95;
  CFAbsoluteTime at;
  void *value;
  CFIndex length;

  v5 = a4;
  if (!a4)
  {
    v14 = CFSTR("null input");
    v15 = -6;
    goto LABEL_12;
  }
  v94 = 0xAAAAAAAAAAAAAAAALL;
  if (!ccder_decode_tag(&v94, a4, a5))
  {
    v16 = CFSTR("invalid tag");
    goto LABEL_14;
  }
  if (v94 <= 17)
  {
    switch(v94)
    {
      case 1:
        length = 0;
        v12 = (_BYTE *)ccder_decode_tl(1, &length, v5, a5);
        if (!v12 || a5 - v12 < 1 || length != 1)
        {
          v16 = CFSTR("Unknown BOOLean encoding");
          goto LABEL_14;
        }
        v5 = v12 + 1;
        if (*v12)
          v13 = &kCFBooleanTrue;
        else
          v13 = &kCFBooleanFalse;
        goto LABEL_54;
      case 2:
        length = 0;
        v41 = (UInt8 *)ccder_decode_tl(2, &length, v5, a5);
        if (!v41 || (v42 = v41, a5 - v41 < length))
        {
          v16 = CFSTR("Unknown number encoding");
          goto LABEL_14;
        }
        if ((unint64_t)length >= 9)
        {
          sub_10002A5E8(-4, CFSTR("com.apple.security.cfder.error"), v10, a3, v11, CFSTR("Number too large"));
          return 0;
        }
        value = 0;
        if (length)
        {
          v79 = 0;
          v80 = v41;
          do
          {
            v81 = *v80++;
            v79 = (int8x8_t)(v81 | (*(_QWORD *)&v79 << 8));
            value = (void *)v79;
          }
          while (v80 < &v41[length]);
          if ((char)*v41 < 0)
          {
            if (length != 8)
            {
              if ((unint64_t)(8 - length) <= 1)
                v82 = 1;
              else
                v82 = 8 - length;
              v83 = (v82 - 1) & 0xFFFFFFFFFFFFFFFELL;
              v84 = v82 - 1;
              v85 = (v82 + 1) & 0xFFFFFFFFFFFFFFFELL;
              v86 = (int8x16_t)(unint64_t)v79;
              v87 = (int64x2_t)xmmword_100062970;
              v88 = vdupq_n_s64(0x40uLL);
              v89.i64[0] = 255;
              v89.i64[1] = 255;
              v90 = vdupq_n_s64(2uLL);
              do
              {
                v91 = v86;
                v86 = vorrq_s8(v86, (int8x16_t)vshlq_u64(v89, (uint64x2_t)vsubq_s64(v88, vshlq_n_s64(v87, 3uLL))));
                v87 = vaddq_s64(v87, v90);
                v85 -= 2;
              }
              while (v85);
              v92 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v83), (int8x16_t)xmmword_100062980), (uint64x2_t)vdupq_lane_s64(v84, 0)), v91, v86);
              v79 = vorr_s8(*(int8x8_t *)v92.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v92, v92, 8uLL));
            }
            value = (void *)v79;
          }
        }
        v93 = CFNumberCreate(a1, kCFNumberLongLongType, &value);
        *a2 = v93;
        if (v93)
          return &v42[length];
        v16 = CFSTR("Number allocation failed");
        goto LABEL_136;
      case 3:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
        goto LABEL_44;
      case 4:
        length = 0;
        v43 = (const UInt8 *)ccder_decode_tl(4, &length, v5, a5);
        if (!v43 || (v42 = v43, v10 = length, a5 - v43 < length))
        {
          v16 = CFSTR("Unknown data encoding");
          goto LABEL_14;
        }
        v73 = CFDataCreate(a1, v43, length);
        *a2 = v73;
        if (v73)
          return &v42[length];
        v16 = CFSTR("Failed to create data");
        goto LABEL_136;
      case 5:
        length = 0;
        v44 = ccder_decode_tl(5, &length, v5, a5);
        if (!v44 || length)
        {
          v16 = CFSTR("Unknown null encoding");
          goto LABEL_14;
        }
        v5 = (const UInt8 *)v44;
        v13 = &kCFNull;
LABEL_54:
        *a2 = *v13;
        return v5;
      case 12:
        length = 0;
        v45 = (const UInt8 *)ccder_decode_tl(12, &length, v5, a5);
        if (!v45 || (v42 = v45, v10 = length, a5 - v45 < length))
        {
          v16 = CFSTR("Unknown string encoding");
          goto LABEL_14;
        }
        v74 = CFStringCreateWithBytes(a1, v45, length, 0x8000100u, 0);
        *a2 = v74;
        if (v74)
          return &v42[length];
        v16 = CFSTR("String allocation failed");
        goto LABEL_136;
      default:
        if (v94 != 0xC000000000000011)
          goto LABEL_44;
        length = 0;
        v5 = (const UInt8 *)ccder_decode_constructed_tl(0xC000000000000011, &length, v5, a5);
        if (!v5)
        {
          v14 = CFSTR("Unknown data encoding, expected CCDER_CONSTRUCTED_CFSET");
          goto LABEL_98;
        }
        Mutable = CFSetCreateMutable(a1, 0, &kCFTypeSetCallBacks);
        if (Mutable)
        {
          v39 = v5 == (const UInt8 *)length;
          if ((unint64_t)v5 < length)
          {
            do
            {
              value = 0;
              v5 = (const UInt8 *)sub_10002A618(a1, &value, a3, v5);
              v40 = value;
              if (v5)
                CFSetAddValue(Mutable, value);
              if (v40)
                CFRelease(v40);
            }
            while (v5 && (unint64_t)v5 < length);
            v39 = v5 == (const UInt8 *)length;
          }
          if (!v39)
          {
            CFRelease(Mutable);
            return v5;
          }
        }
        else
        {
          sub_10002A5E8(-3, CFSTR("com.apple.security.cfder.error"), v36, a3, v37, CFSTR("Failed to create set"));
          v5 = 0;
          if (length)
            return v5;
        }
        if (*a2)
          CFRelease(*a2);
        break;
    }
    goto LABEL_111;
  }
  if (v94 > 0x200000000000000FLL)
  {
    if (v94 == 0x2000000000000010)
    {
      v57 = CFArrayCreateMutable(a1, 0, &kCFTypeArrayCallBacks);
      length = 0xAAAAAAAAAAAAAAAALL;
      v58 = ccder_decode_sequence_tl(&length, v5, a5);
      if (!v58)
      {
        sub_10002A5E8(-1, CFSTR("com.apple.security.cfder.error"), v59, a3, v60, CFSTR("tag/length decode failed"));
LABEL_86:
        if (v57)
          CFRelease(v57);
        return 0;
      }
      v5 = (const UInt8 *)v58;
      while ((unint64_t)v5 < length)
      {
        value = 0;
        v61 = sub_10002A618(a1, &value, a3, v5);
        if (!v61)
          goto LABEL_86;
        v5 = (const UInt8 *)v61;
        v62 = value;
        CFArrayAppendValue(v57, value);
        if (v62)
          CFRelease(v62);
      }
      *a2 = v57;
      return v5;
    }
    if (v94 != 0x2000000000000011)
    {
      if (v94 != 0x6000000000000010)
        goto LABEL_44;
      length = 0;
      v34 = ccder_decode_tl(0x6000000000000010, &length, v5, a5);
      if (v34)
      {
        v35 = v34;
        if ((uint64_t)&a5[-v34] >= length)
        {
          v75 = CFDataCreate(a1, v5, v34 + length - (_QWORD)v5);
          *a2 = v75;
          if (v75)
            return (const UInt8 *)(v35 + length);
          v16 = CFSTR("Failed to create CoreEntitlements data");
          goto LABEL_136;
        }
      }
      v16 = CFSTR("Unknown CoreEntitlements encoding");
LABEL_14:
      v17 = -1;
LABEL_15:
      sub_10002A5E8(v17, CFSTR("com.apple.security.cfder.error"), v10, a3, v11, v16);
      return 0;
    }
    v95 = 0;
    v5 = (const UInt8 *)ccder_decode_constructed_tl(0x2000000000000011, &v95, v5, a5);
    if (v5)
    {
      Mutable = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        v65 = v95;
        if (v5 < v95)
        {
          while (1)
          {
            length = 0;
            v66 = ccder_decode_constructed_tl(0x2000000000000010, &length, v5, v65);
            if (!v66)
            {
              sub_10002A5E8(-1, CFSTR("com.apple.security.cfder.error"), v67, a3, v68, CFSTR("Unknown data encoding, expected CCDER_CONSTRUCTED_SEQUENCE"));
              goto LABEL_132;
            }
            at = 0.0;
            value = 0;
            v69 = sub_10002A618(a1, &value, a3, v66);
            v70 = sub_10002A618(a1, &at, a3, v69);
            v71 = value;
            if (!v70)
              break;
            v5 = (const UInt8 *)v70;
            v72 = at;
            CFDictionaryAddValue(Mutable, value, *(const void **)&at);
            if (v71)
              CFRelease(v71);
            if (v72 != 0.0)
              CFRelease(*(CFTypeRef *)&v72);
            v65 = v95;
            if (v5 >= v95)
              goto LABEL_133;
          }
          if (value)
            CFRelease(value);
          if (*(_QWORD *)&at)
            CFRelease(*(CFTypeRef *)&at);
LABEL_132:
          v5 = 0;
          v65 = v95;
LABEL_133:
          v78 = v5;
          v5 = v65;
          if (v78 == v65)
            goto LABEL_111;
LABEL_134:
          CFRelease(Mutable);
          return v78;
        }
        v78 = v5;
        if (v5 != v95)
          goto LABEL_134;
      }
      else
      {
        sub_10002A5E8(-3, CFSTR("com.apple.security.cfder.error"), v63, a3, v64, CFSTR("Failed to create dictionary"));
        v5 = 0;
        if (v95)
          return v5;
      }
LABEL_111:
      *a2 = Mutable;
      return v5;
    }
    v14 = CFSTR("Unknown data encoding, expected CCDER_CONSTRUCTED_SET");
LABEL_98:
    v15 = -1;
LABEL_12:
    sub_10002A5E8(v15, CFSTR("com.apple.security.cfder.error"), (uint64_t)a3, a3, (uint64_t)a5, v14);
    return v5;
  }
  if (v94 == 18)
  {
    length = 0;
    v46 = (const UInt8 *)ccder_decode_tl(18, &length, v5, a5);
    if (v46)
    {
      v42 = v46;
      v10 = length;
      if (a5 - v46 >= length)
      {
        v76 = CFStringCreateWithBytes(a1, v46, length, 0x8000100u, 0);
        *a2 = v76;
        if (v76)
          return &v42[length];
        v16 = CFSTR("Numeric string allocation failed");
        goto LABEL_136;
      }
    }
    v16 = CFSTR("Unknown numeric string encoding");
    goto LABEL_14;
  }
  if (v94 != 23)
  {
    if (v94 == 24)
    {
      value = a5;
      v19 = ccder_decode_constructed_tl(24, &value, v5, a5);
      at = 0.0;
      v20 = value;
      length = v19;
      v23 = sub_100026C40((unsigned __int8 **)&length, (unint64_t)value, a3, v21, v22);
      v26 = sub_100026C40((unsigned __int8 **)&length, (unint64_t)v20, a3, v24, v25) + 10 * v23;
      v29 = sub_100026C40((unsigned __int8 **)&length, (unint64_t)v20, a3, v27, v28);
      v32 = sub_100026C40((unsigned __int8 **)&length, (unint64_t)v20, a3, v30, v31);
      v5 = (const UInt8 *)sub_100026CDC(&at, a3, v32 + 10 * v29 + 100 * v26, (unsigned __int8 *)length, (unint64_t)v20);
      if (v5)
      {
        v33 = CFDateCreate(a1, at);
        *a2 = v33;
        if (!v33)
        {
          v16 = CFSTR("Failed to create date");
LABEL_136:
          v17 = -3;
          goto LABEL_15;
        }
      }
      return v5;
    }
LABEL_44:
    sub_10002A5E8(-2, CFSTR("com.apple.security.cfder.error"), v10, a3, v11, CFSTR("Unsupported DER Type"));
    return 0;
  }
  value = a5;
  v47 = ccder_decode_constructed_tl(23, &value, v5, a5);
  at = 0.0;
  v48 = value;
  length = v47;
  v51 = sub_100026C40((unsigned __int8 **)&length, (unint64_t)value, a3, v49, v50);
  v56 = sub_100026C40((unsigned __int8 **)&length, (unint64_t)v48, a3, v52, v53) + 10 * v51;
  if (v56 > 49)
  {
    if (v56 > 0x45)
    {
      v56 += 1900;
    }
    else
    {
      sub_10002A5E8(-1, CFSTR("com.apple.security.cfder.error"), v54, a3, v55, CFSTR("Invalid universal time year between 50 and 70"));
      length = 0;
    }
  }
  else
  {
    v56 += 2000;
  }
  v5 = (const UInt8 *)sub_100026CDC(&at, a3, v56, (unsigned __int8 *)length, (unint64_t)v48);
  if (v5)
  {
    v77 = CFDateCreate(a1, at);
    *a2 = v77;
    if (!v77)
    {
      v16 = CFSTR("Failed to create utc date");
      goto LABEL_136;
    }
  }
  return v5;
}

NSObject *sub_10002B070(NSObject *a1, char *label, uint64_t a3)
{
  NSObject *v4;
  NSObject *v5;
  _QWORD *v6;

  if (a1)
  {
    v4 = a1;
    dispatch_retain(a1);
  }
  else
  {
    v4 = dispatch_queue_create(label, 0);
  }
  v5 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_data_add, 0, 0, v4);
  v6 = malloc_type_malloc(0x20uLL, 0x10A0040A7A12BA5uLL);
  *v6 = v4;
  v6[1] = v5;
  v6[2] = 0;
  v6[3] = a3;
  dispatch_set_context(v5, v6);
  dispatch_source_set_event_handler_f(v5, (dispatch_function_t)sub_10001E428);
  dispatch_set_finalizer_f(v5, (dispatch_function_t)sub_10002B120);
  return v5;
}

void sub_10002B120(uint64_t a1)
{
  const void *v2;

  dispatch_release(*(dispatch_object_t *)a1);
  v2 = *(const void **)(a1 + 16);
  if (v2)
    _Block_release(v2);
  free((void *)a1);
}

uint64_t sub_10002B154(CFTypeRef *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v6 = ccder_encode_tl(5, 0, a2, a3);
  if (!v6)
    sub_10002A5E8(-7, CFSTR("com.apple.security.cfder.error"), v4, a1, v5, CFSTR("ccder failed to encode"));
  return v6;
}

uint64_t sub_10002B1AC(const __CFSet *a1, uint64_t a2)
{
  __int128 v3;
  uint64_t v4;

  v3 = xmmword_100062960;
  LOBYTE(v3) = 1;
  v4 = a2;
  CFSetApplyFunction(a1, (CFSetApplierFunction)sub_10002B20C, &v3);
  if ((_BYTE)v3)
    return ccder_sizeof(0xC000000000000011, *((_QWORD *)&v3 + 1));
  else
    return 0;
}

uint64_t sub_10002B20C(uint64_t result, uint64_t a2)
{
  if (*(_BYTE *)a2)
  {
    result = sub_100004520(result, *(_QWORD *)(a2 + 16));
    if (result)
      *(_QWORD *)(a2 + 8) += result;
    else
      *(_BYTE *)a2 = 0;
  }
  return result;
}

uint64_t sub_10002B250(const __CFSet *a1, CFTypeRef *a2, char a3, uint64_t a4, uint64_t a5)
{
  CFMutableArrayRef Mutable;
  CFIndex Count;
  uint64_t v12;
  unint64_t v13;
  const __CFData *ValueAtIndex;
  CFIndex Length;
  const UInt8 *BytePtr;
  uint64_t result;
  uint64_t v18;
  uint64_t v19;
  _QWORD v20[4];
  CFRange v21;

  Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  v20[0] = 0xAAAAAAAAAAAAAA01;
  v20[1] = a2;
  BYTE1(v20[0]) = a3;
  v20[2] = Mutable;
  v20[3] = 0;
  CFSetApplyFunction(a1, (CFSetApplierFunction)sub_10002B3C0, v20);
  if (!LOBYTE(v20[0]))
  {
    if (Mutable)
      CFRelease(Mutable);
    return 0;
  }
  v21.length = CFArrayGetCount(Mutable);
  v21.location = 0;
  CFArraySortValues(Mutable, v21, (CFComparatorFunction)sub_10002B494, 0);
  Count = CFArrayGetCount(Mutable);
  v12 = a5;
  if (Count >= 1)
  {
    v13 = Count + 1;
    v12 = a5;
    do
    {
      ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(Mutable, v13 - 2);
      Length = CFDataGetLength(ValueAtIndex);
      BytePtr = CFDataGetBytePtr(ValueAtIndex);
      v12 = ccder_encode_body(Length, BytePtr, a4, v12);
      --v13;
    }
    while (v13 > 1);
  }
  if (Mutable)
    CFRelease(Mutable);
  result = ccder_encode_constructed_tl(0xC000000000000011, a5, a4, v12);
  if (!result)
  {
    sub_10002A5E8(-7, CFSTR("com.apple.security.cfder.error"), v18, a2, v19, CFSTR("ccder failed to encode"));
    return 0;
  }
  return result;
}

void sub_10002B3C0(const __CFString *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  CFIndex v7;
  CFIndex v8;
  __CFData *Mutable;
  UInt8 *MutableBytePtr;
  uint64_t v11;
  CFRange v12;

  if (*(_BYTE *)a2)
  {
    v7 = sub_100004520(a1, *(CFTypeRef **)(a2 + 8), a3, a4, a5);
    if (!v7)
    {
      *(_BYTE *)a2 = 0;
      return;
    }
    v8 = v7;
    Mutable = CFDataCreateMutable(*(CFAllocatorRef *)(a2 + 24), v7);
    CFDataSetLength(Mutable, v8);
    MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    v11 = sub_10000B258(a1, *(_QWORD *)(a2 + 8), *(unsigned __int8 *)(a2 + 1), MutableBytePtr, &MutableBytePtr[v8]);
    if (v11)
    {
      v12.length = v11 - (_QWORD)MutableBytePtr;
      v12.location = 0;
      CFDataDeleteBytes(Mutable, v12);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a2 + 16), Mutable);
      if (!Mutable)
        return;
    }
    else
    {
      *(_BYTE *)a2 = 0;
      if (!Mutable)
        return;
    }
    CFRelease(Mutable);
  }
}

uint64_t sub_10002B494(const __CFData *a1, const __CFData *a2)
{
  CFIndex Length;
  CFIndex v5;
  unint64_t v6;
  size_t v7;
  const UInt8 *BytePtr;
  const UInt8 *v9;
  int v10;
  uint64_t v12;
  uint64_t v13;

  Length = CFDataGetLength(a1);
  v5 = CFDataGetLength(a2);
  v6 = v5;
  if (Length < 0 || v5 < 0)
  {
    if (Length >= v5)
      v12 = 0;
    else
      v12 = -1;
    if (Length <= v5)
      return v12;
    else
      return 1;
  }
  else
  {
    if (Length >= v5)
      v7 = v5;
    else
      v7 = Length;
    BytePtr = CFDataGetBytePtr(a1);
    v9 = CFDataGetBytePtr(a2);
    v10 = memcmp(BytePtr, v9, v7);
    if (v10 <= 0 && (v10 || Length <= v6))
    {
      LODWORD(v13) = v10 == 0;
      if (Length >= v6)
        LODWORD(v13) = 0;
      if (v10 < 0)
        v13 = 1;
      else
        v13 = v13;
      return v13 << 63 >> 63;
    }
    else
    {
      return 1;
    }
  }
}

void sub_10002B558(const __CFURL *a1, uint64_t a2)
{
  UInt8 __b[1024];

  if (a1)
  {
    memset(__b, 170, sizeof(__b));
    CFURLGetFileSystemRepresentation(a1, 0, __b, 1024);
    (*(void (**)(uint64_t, UInt8 *))(a2 + 16))(a2, __b);
    CFRelease(a1);
  }
}

void sub_10002B5F4(uint64_t a1, uint64_t a2)
{
  const __CFURL *v4;

  syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0);
  v4 = sub_10001DD50(CFSTR("Library/Keychains"), a1);
  sub_10002B558(v4, a2);
}

void sub_10002B644(void *a1, int a2)
{
  void *v2;
  const void *v4;
  NSObject *v5;
  int v6;
  uint64_t v7;
  id v8;
  void *v9;
  void *v10;
  void *v11;
  _BYTE buf[24];
  void *v13;
  __int128 v14;
  uint64_t v15;

  LODWORD(v2) = a2;
  v4 = sub_100011628("SecError");
  v5 = objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412546;
    *(_QWORD *)&buf[4] = a1;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = (_DWORD)v2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Simulating crash, reason: %@, code=%08x", buf, 0x12u);
  }

  v6 = dword_100082760;
  if (dword_100082760 != -1)
    goto LABEL_4;
  if (!qword_100082B58)
  {
    *(_OWORD *)buf = off_1000763A8;
    *(_QWORD *)&buf[16] = 0;
    qword_100082B58 = _sl_dlopen(buf, 0);
  }
  if (!qword_100082B58)
  {
    v6 = dword_100082760;
LABEL_4:
    dword_100082760 = v6 + 1;
    return;
  }
  v7 = getpid();
  v8 = a1;
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  *(_QWORD *)&buf[16] = 0x2020000000;
  v9 = off_100082B60;
  v13 = off_100082B60;
  if (off_100082B60)
    goto LABEL_14;
  v11 = 0;
  if (!qword_100082B58)
  {
    v14 = off_1000763A8;
    v15 = 0;
    qword_100082B58 = _sl_dlopen(&v14, &v11);
  }
  v9 = (void *)qword_100082B58;
  if (!qword_100082B58)
  {
    v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    v8 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "void *CrashReporterSupportLibrary(void)"));
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v8, CFSTR("simulate_crash.m"), 18, CFSTR("%s"), v11);

    goto LABEL_20;
  }
  v10 = v11;
  if (v11)
    goto LABEL_21;
  while (1)
  {
    v9 = dlsym(v9, "SimulateCrash");
    *(_QWORD *)(*(_QWORD *)&buf[8] + 24) = v9;
    off_100082B60 = v9;
LABEL_14:
    _Block_object_dispose(buf, 8);
    if (v9)
      break;
    v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    v8 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "BOOL soft_SimulateCrash(pid_t, mach_exception_data_type_t, NSString *__strong)"));
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v8, CFSTR("simulate_crash.m"), 22, CFSTR("%s"), dlerror());

LABEL_20:
    __break(1u);
LABEL_21:
    free(v10);
  }
  ((void (*)(uint64_t, _QWORD, id))v9)(v7, v2, v8);

}

void sub_10002B900(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10002B920(size_t size, uint64_t a2)
{
  void *v4;
  uint64_t v5;

  if (size)
  {
    if (size > 0x800)
    {
      v4 = malloc_type_malloc(size, 0x9C1A2F70uLL);
      (*(void (**)(uint64_t, size_t, void *))(a2 + 16))(a2, size, v4);
      if (v4)
        free(v4);
    }
    else
    {
      __chkstk_darwin();
      memset((char *)&v5 - ((size + 15) & 0xFFFFFFFFFFFFFFF0), 170, size);
      (*(void (**)(uint64_t, size_t, char *))(a2 + 16))(a2, size, (char *)&v5 - ((size + 15) & 0xFFFFFFFFFFFFFFF0));
    }
  }
  else
  {
    (*(void (**)(uint64_t, _QWORD, _QWORD))(a2 + 16))(a2, 0, 0);
  }
}

xpc_object_t sub_10002BA74(__CFError *a1)
{
  xpc_object_t v2;
  const __CFString *Domain;
  int64_t Code;
  const __CFString *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;
  size_t v10;
  UInt8 *v11;
  unint64_t v12;
  const void *v13;
  _QWORD v15[6];
  _QWORD v16[5];

  v2 = xpc_dictionary_create(0, 0, 0);
  Domain = CFErrorGetDomain(a1);
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 0x40000000;
  v15[2] = sub_10002BBB4;
  v15[3] = &unk_1000763C0;
  v15[4] = v2;
  v15[5] = "domain";
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 0x40000000;
  v16[2] = sub_100026C34;
  v16[3] = &unk_100075DD0;
  v16[4] = v15;
  sub_100019A20(Domain, (uint64_t)v16);
  Code = CFErrorGetCode(a1);
  xpc_dictionary_set_int64(v2, "code", Code);
  v5 = (const __CFString *)CFErrorCopyUserInfo(a1);
  v9 = sub_100004520(v5, 0, v6, v7, v8);
  if (v9)
  {
    v10 = v9;
    v11 = (UInt8 *)malloc_type_malloc(v9, 0x4ABABCFuLL);
    v12 = (unint64_t)&v11[v10];
    v13 = (const void *)sub_10000B258(v5, 0, 0, v11, v12);
    if (v13)
      xpc_dictionary_set_data(v2, "userinfo", v13, v12 - (_QWORD)v13);
    free(v11);
  }
  CFRelease(v5);
  return v2;
}

void sub_10002BBB4(uint64_t a1, char *string)
{
  xpc_dictionary_set_string(*(xpc_object_t *)(a1 + 32), *(const char **)(a1 + 40), string);
}

uint64_t sub_10002BBC4(uint64_t a1, const __CFArray *a2, _BYTE *a3, int a4)
{
  uint64_t v8;
  const __CFData *v9;
  uint64_t SubjectAltName;
  const __CFData *v11;
  const __CFData *v12;
  int v13;
  char v14;
  uint64_t v15;
  uint64_t v16;
  CFIndex Count;
  const __CFArray *v19;
  const __CFArray *v20;
  _QWORD v21[2];
  unint64_t v22;
  char v23;
  char v24;
  _QWORD v25[2];
  unint64_t v26;
  char v27;
  char v28;
  _QWORD context[3];
  _QWORD v30[2];
  __int16 v31;
  CFRange v32;
  CFRange v33;

  v8 = ((uint64_t (*)(void))SecCertificateCopySubjectSequence)();
  if (!v8)
    return 4294941021;
  v9 = (const __CFData *)v8;
  SubjectAltName = SecCertificateGetSubjectAltName(a1);
  if (sub_10002BE18(v9) && !SubjectAltName)
  {
    v16 = 4294941021;
    goto LABEL_21;
  }
  v11 = (const __CFData *)SecCertificateCopySubjectSequence(a1);
  if (!v11)
    goto LABEL_8;
  v12 = v11;
  if (CFDataGetLength(v11) < 0 || sub_10002BE18(v12))
  {
    CFRelease(v12);
LABEL_8:
    v13 = 0;
    v14 = a4;
    goto LABEL_9;
  }
  Count = CFArrayGetCount(a2);
  v31 = 0;
  v30[0] = CFDataGetBytePtr(v12);
  v30[1] = CFDataGetLength(v12);
  context[0] = 0xAAAAAAAA00000004;
  context[1] = v30;
  context[2] = &v31;
  v32.location = 0;
  v32.length = Count;
  CFArrayApplyFunction(a2, v32, (CFArrayApplierFunction)sub_10002BE90, context);
  CFRelease(v12);
  v13 = v31;
  if ((_BYTE)v31)
    v14 = HIBYTE(v31);
  else
    v14 = a4;
  v27 = 0;
  v28 = a4;
  v19 = (const __CFArray *)SecCertificateCopyRFC822NamesFromSubject(a1);
  if (v19)
  {
    v20 = v19;
    v33.length = CFArrayGetCount(v19);
    v25[0] = a2;
    v25[1] = &v27;
    v26 = 0xAAAAAAAAAAAAAAAALL;
    LOBYTE(v26) = a4;
    v33.location = 0;
    CFArrayApplyFunction(v20, v33, (CFArrayApplierFunction)sub_10002BF68, v25);
    CFRelease(v20);
    if (v27)
    {
      if (a4)
        v14 &= v28;
      else
        v14 |= v28;
      v13 = 1;
    }
  }
LABEL_9:
  v23 = 0;
  v24 = a4;
  v21[0] = a2;
  v21[1] = &v23;
  v22 = 0xAAAAAAAAAAAAAAAALL;
  LOBYTE(v22) = a4;
  if (!SubjectAltName)
  {
    if (v13)
    {
LABEL_16:
      v16 = 0;
      LOBYTE(a4) = v14;
      goto LABEL_20;
    }
LABEL_19:
    v16 = 0;
    goto LABEL_20;
  }
  v15 = SecCertificateParseGeneralNames(SubjectAltName, v21, sub_10002C0C0);
  if ((_DWORD)v15)
  {
    v16 = v15;
    LOBYTE(a4) = 0;
    goto LABEL_20;
  }
  if (!v13)
  {
    if (v23)
    {
      v16 = 0;
      LOBYTE(a4) = v24;
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  if (!v23 || (v14 != 0) != (v24 == 0))
    goto LABEL_16;
  v16 = 0;
  LOBYTE(a4) = a4 ^ 1;
LABEL_20:
  *a3 = a4;
LABEL_21:
  CFRelease(v9);
  return v16;
}

BOOL sub_10002BE18(const __CFData *a1)
{
  _BOOL8 result;
  unint64_t v3[3];
  _QWORD v4[2];

  result = 1;
  if (CFDataGetLength(a1) >= 1)
  {
    v4[0] = CFDataGetBytePtr(a1);
    v4[1] = CFDataGetLength(a1);
    memset(v3, 170, sizeof(v3));
    if (!DERDecodeItem((uint64_t)v4, v3))
    {
      if (v3[2])
        return 0;
    }
  }
  return result;
}

void sub_10002BE90(const __CFData *a1, uint64_t a2)
{
  NSObject *v4;
  uint8_t v5[8];
  unint64_t v6[3];
  _QWORD v7[2];

  if (a1)
  {
    if (CFDataGetLength(a1) >= 1)
    {
      v7[0] = CFDataGetBytePtr(a1);
      v7[1] = CFDataGetLength(a1);
      memset(v6, 170, sizeof(v6));
      if (!DERDecodeItem((uint64_t)v7, v6)
        && SecCertificateParseGeneralNameContentProperty(v6[0], &v6[1], a2, sub_10002C188) == -26275)
      {
        v4 = sub_100011628("policy");
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v5 = 0;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "can't parse general name or not a type we support", v5, 2u);
        }
      }
    }
  }
}

void sub_10002BF68(const __CFString *a1, uint64_t a2)
{
  const __CFArray *v3;
  CFIndex Count;
  CFIndex Length;
  CFIndex v7;
  char *v8;
  _BYTE *v9;
  int v10;
  char v11;
  char v12;
  _QWORD v13[3];
  _QWORD v14[2];
  __int16 v15;
  CFRange v16;

  if (!a2)
    return;
  v3 = *(const __CFArray **)a2;
  if (!*(_QWORD *)a2)
    return;
  Count = CFArrayGetCount(*(CFArrayRef *)a2);
  v15 = 0;
  if (!a1)
  {
    v8 = strdup("");
    if (!v8)
      return;
    goto LABEL_9;
  }
  CFRetain(a1);
  Length = CFStringGetLength(a1);
  v7 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
  v8 = (char *)malloc_type_malloc(v7, 0x5ECC0363uLL);
  if (!CFStringGetCString(a1, v8, v7, 0x8000100u))
    *v8 = 0;
  CFRelease(a1);
  if (v8)
  {
LABEL_9:
    v14[0] = v8;
    v14[1] = strlen(v8);
    v13[0] = 0xAAAAAAAA00000001;
    v13[1] = v14;
    v13[2] = &v15;
    v16.location = 0;
    v16.length = Count;
    CFArrayApplyFunction(v3, v16, (CFArrayApplierFunction)sub_10002BE90, v13);
    free(v8);
    v9 = *(_BYTE **)(a2 + 8);
    if (v9 && (_BYTE)v15)
    {
      v10 = *(unsigned __int8 *)(a2 + 16);
      *v9 = 1;
      v11 = v9[1];
      if (v10)
        v12 = v11 & HIBYTE(v15);
      else
        v12 = v11 | HIBYTE(v15);
      v9[1] = v12;
    }
  }
}

uint64_t sub_10002C0C0(uint64_t a1, int a2, uint64_t a3)
{
  const __CFArray *v4;
  _BYTE *v7;
  int v8;
  char v9;
  char v10;
  _DWORD v12[2];
  uint64_t v13;
  __int16 *v14;
  __int16 v15;
  CFRange v16;

  if (!a1)
    return 4294941021;
  v4 = *(const __CFArray **)a1;
  if (!*(_QWORD *)a1)
    return 4294941021;
  v16.length = CFArrayGetCount(*(CFArrayRef *)a1);
  v15 = 0;
  v12[1] = -1431655766;
  v13 = a3;
  v12[0] = a2;
  v14 = &v15;
  v16.location = 0;
  CFArrayApplyFunction(v4, v16, (CFArrayApplierFunction)sub_10002BE90, v12);
  v7 = *(_BYTE **)(a1 + 8);
  if (v7 && (_BYTE)v15)
  {
    v8 = *(unsigned __int8 *)(a1 + 16);
    *v7 = 1;
    v9 = v7[1];
    if (v8)
      v10 = v9 & HIBYTE(v15);
    else
      v10 = v9 | HIBYTE(v15);
    v7[1] = v10;
  }
  return 0;
}

uint64_t sub_10002C188(uint64_t a1, int a2, const UInt8 **a3)
{
  _BYTE *v4;
  const UInt8 **v5;
  uint64_t result;
  unint64_t v8;
  const __CFString *v9;
  const __CFString *v10;
  const __CFString *v11;
  BOOL v12;
  CFComparisonResult v13;
  unint64_t v14;
  const __CFString *v15;
  BOOL v16;
  CFIndex v17;
  CFIndex v18;
  CFIndex v19;
  BOOL v20;
  unint64_t v21;
  const __CFString *v22;
  CFStringRef v23;
  BOOL v24;
  CFRange v25;
  CFIndex v26;
  const __CFCharacterSet *v27;
  CFIndex v28;
  const __CFString *v29;
  CFIndex v30;
  CFIndex v31;
  BOOL v32;
  CFIndex v33;
  CFIndex v34;
  CFRange v35;
  BOOL v36;
  unsigned __int8 *v37;
  unsigned __int8 *v38;
  BOOL v39;
  BOOL v40;
  unsigned __int8 *v41;
  CFIndex v42;
  const __CFString *v43;
  const __CFString *v44;
  CFRange v45;
  CFIndex location;
  CFIndex v47;
  CFIndex v48;
  CFIndex Length;
  uint64_t v50;
  int v51;
  int v52;
  unsigned __int8 *v53;
  unint64_t v54[3];
  CFRange __s1;
  CFRange v56;
  CFRange v57;

  if (!a1)
    return 4294941021;
  if (*(_DWORD *)a1 != a2)
    return 4294941021;
  v4 = *(_BYTE **)(a1 + 16);
  if (!v4)
    return 4294941021;
  v5 = *(const UInt8 ***)(a1 + 8);
  if (!v5)
    return 4294941021;
  *v4 = 1;
  result = 4294941021;
  switch(a2)
  {
    case 1:
      v8 = (unint64_t)v5[1];
      if (v8 > 0x7FFFFFFFFFFFFFFELL || (unint64_t)a3[1] > 0x7FFFFFFFFFFFFFFELL)
        goto LABEL_27;
      v9 = CFStringCreateWithBytes(kCFAllocatorDefault, *v5, v8, 0x8000100u, 0);
      v10 = CFStringCreateWithBytes(kCFAllocatorDefault, *a3, (CFIndex)a3[1], 0x8000100u, 0);
      v11 = v10;
      if (v9)
        v12 = v10 == 0;
      else
        v12 = 1;
      if (v12)
        goto LABEL_83;
      if (CFStringFind(v10, CFSTR("@"), 0).location != -1)
      {
        v13 = CFStringCompare(v9, v11, 1uLL);
        goto LABEL_75;
      }
      location = CFStringFind(v9, CFSTR("@"), 0).location;
      if (location == -1)
        goto LABEL_22;
      v47 = location;
      v48 = location + 1;
      Length = CFStringGetLength(v9);
      if (CFStringGetCharacterAtIndex(v11, 0) != 46)
      {
        v45.length = Length + ~v47;
        v43 = v9;
        v44 = v11;
        v45.location = v48;
        goto LABEL_74;
      }
      if (CFStringGetCharacterAtIndex(v9, v48) != 46 && CFStringHasSuffix(v9, v11))
      {
        v20 = 1;
        goto LABEL_76;
      }
      goto LABEL_22;
    case 2:
      v14 = (unint64_t)v5[1];
      if (v14 > 0x7FFFFFFFFFFFFFFELL || (unint64_t)a3[1] > 0x7FFFFFFFFFFFFFFELL)
        goto LABEL_27;
      v9 = CFStringCreateWithBytes(kCFAllocatorDefault, *v5, v14, 0x8000100u, 0);
      v15 = CFStringCreateWithBytes(kCFAllocatorDefault, *a3, (CFIndex)a3[1], 0x8000100u, 0);
      v11 = v15;
      if (v9)
        v16 = v15 == 0;
      else
        v16 = 1;
      if (!v16)
      {
        v17 = CFStringGetLength(v15);
        v18 = CFStringGetLength(v9);
        v19 = v18 - v17;
        if (v18 >= v17
          && (v18 == v17
           || (v42 = v18, CFStringGetCharacterAtIndex(v11, 0) == 46)
           || CFStringGetCharacterAtIndex(v9, v42 + ~v17) == 46))
        {
          v43 = v9;
          v44 = v11;
          v45.location = v19;
          v45.length = v17;
LABEL_74:
          v13 = CFStringCompareWithOptions(v43, v44, v45, 1uLL);
LABEL_75:
          v20 = v13 == kCFCompareEqualTo;
        }
        else
        {
LABEL_22:
          v20 = 0;
        }
        goto LABEL_76;
      }
LABEL_83:
      v20 = 0;
      if (v9)
      {
LABEL_76:
        CFRelease(v9);
        goto LABEL_77;
      }
      goto LABEL_77;
    case 4:
      memset(&__s1, 170, 24);
      if (DERDecodeItem((uint64_t)v5, (unint64_t *)&__s1))
        goto LABEL_27;
      memset(v54, 170, sizeof(v54));
      if (DERDecodeItem((uint64_t)a3, v54)
        || v5[1] <= a3[1]
        || memcmp((const void *)__s1.length, (const void *)v54[1], v54[2]))
      {
        goto LABEL_27;
      }
      v20 = 1;
      goto LABEL_79;
    case 6:
      v21 = (unint64_t)v5[1];
      if (v21 > 0x7FFFFFFFFFFFFFFELL || (unint64_t)a3[1] > 0x7FFFFFFFFFFFFFFELL)
      {
LABEL_27:
        v20 = 0;
        goto LABEL_79;
      }
      v22 = CFStringCreateWithBytes(kCFAllocatorDefault, *v5, v21, 0x8000100u, 0);
      v23 = CFStringCreateWithBytes(kCFAllocatorDefault, *a3, (CFIndex)a3[1], 0x8000100u, 0);
      v11 = v23;
      if (v22)
        v24 = v23 == 0;
      else
        v24 = 1;
      if (!v24)
      {
        v25 = CFStringFind(v22, CFSTR("://"), 0);
        if (v25.location != -1)
        {
          v26 = CFStringGetLength(v22) - (v25.location + v25.length);
          v27 = CFCharacterSetCreateWithCharactersInString(kCFAllocatorDefault, CFSTR(":/"));
          __s1 = (CFRange)xmmword_100062990;
          v56.location = v25.location + v25.length;
          v56.length = v26;
          if (CFStringFindCharacterFromSet(v22, v27, v56, 0, &__s1))
          {
            v28 = CFStringGetLength(v22);
            v26 = v26 - v28 + __s1.location;
          }
          v57.location = v25.location + v25.length;
          v57.length = v26;
          v29 = CFStringCreateWithSubstring(kCFAllocatorDefault, v22, v57);
          if (CFStringGetCharacterAtIndex(v29, 0) == 46
            || (v30 = CFStringGetLength(v29), v31 = CFStringGetLength(v11), v32 = v30 < v31, v33 = v30 - v31, v32))
          {
            v36 = 0;
            if (v27)
LABEL_43:
              CFRelease(v27);
          }
          else
          {
            v34 = v31;
            if (CFStringGetCharacterAtIndex(v11, 0) == 46)
              v35.location = v33;
            else
              v35.location = 0;
            v35.length = v34;
            v36 = CFStringCompareWithOptions(v29, v11, v35, 1uLL) == kCFCompareEqualTo;
            if (v27)
              goto LABEL_43;
          }
          if (v29)
            CFRelease(v29);
          goto LABEL_46;
        }
        v36 = 0;
LABEL_46:
        CFRelease(v22);
        v20 = v36;
        goto LABEL_77;
      }
      v36 = 0;
      v20 = 0;
      if (v22)
        goto LABEL_46;
LABEL_77:
      if (v11)
        CFRelease(v11);
LABEL_79:
      v4 = *(_BYTE **)(a1 + 16);
LABEL_80:
      result = 0;
      v4[1] |= v20;
      break;
    case 7:
      v37 = (unsigned __int8 *)a3[1];
      if (v37 != (unsigned __int8 *)32 && v37 != (unsigned __int8 *)8
        || ((v38 = (unsigned __int8 *)v5[1], v38 != (unsigned __int8 *)16)
          ? (v39 = v38 == (unsigned __int8 *)4)
          : (v39 = 1),
            v39 ? (v40 = v37 == (unsigned __int8 *)(2 * (_QWORD)v38)) : (v40 = 0),
            !v40 || (v41 = &v38[(_QWORD)*a3], ((**v5 ^ **a3) & *v41) != 0)))
      {
        v20 = 0;
        goto LABEL_80;
      }
      v50 = 1;
      while (v38 != (unsigned __int8 *)v50)
      {
        v51 = v41[v50];
        v52 = (*v5)[v50] ^ (*a3)[v50];
        ++v50;
        if ((v52 & v51) != 0)
        {
          v53 = (unsigned __int8 *)(v50 - 1);
          goto LABEL_82;
        }
      }
      v53 = (unsigned __int8 *)v5[1];
LABEL_82:
      v20 = v53 >= v38;
      goto LABEL_80;
    default:
      return result;
  }
  return result;
}

void sub_10002C70C(const __CFData *a1, const __CFArray **a2)
{
  const __CFArray *v3;
  __CFArray *v4;
  int v5;
  int v6;
  CFIndex Count;
  CFIndex v8;
  const __CFData *ValueAtIndex;
  int v10;
  _QWORD v11[3];
  __int16 v12;
  unint64_t v13[3];
  const UInt8 *BytePtr;
  CFIndex Length;
  _DWORD v16[2];
  unint64_t *v17;
  __int16 *v18;
  __int16 v19;
  unint64_t v20[3];
  _QWORD v21[2];

  if (a1)
  {
    v3 = *a2;
    v4 = a2[1];
    if ((CFDataGetLength(a1) & 0x8000000000000000) == 0)
    {
      if (v3)
      {
        v21[0] = CFDataGetBytePtr(a1);
        v21[1] = CFDataGetLength(a1);
        memset(v20, 170, sizeof(v20));
        if (!DERDecodeItem((uint64_t)v21, v20))
        {
          v5 = 0;
          v6 = 2;
          switch(v20[0])
          {
            case 0x8000000000000001:
              v5 = 1;
              goto LABEL_14;
            case 0x8000000000000002:
              break;
            case 0x8000000000000003:
            case 0x8000000000000004:
            case 0x8000000000000005:
              goto LABEL_14;
            case 0x8000000000000006:
LABEL_9:
              v5 = 6;
              goto LABEL_14;
            case 0x8000000000000007:
              v5 = 7;
              goto LABEL_14;
            case 0x8000000000000008:
              v5 = 8;
LABEL_14:
              CFArrayAppendValue(v4, a1);
              v6 = v5;
              break;
            default:
              switch(v20[0])
              {
                case 0xA000000000000003:
                  v5 = 3;
                  goto LABEL_14;
                case 0xA000000000000004:
                  v6 = 4;
                  break;
                case 0xA000000000000005:
                  v5 = 5;
                  goto LABEL_14;
                case 0xA000000000000006:
                  goto LABEL_9;
                default:
                  goto LABEL_14;
              }
              break;
          }
          Count = CFArrayGetCount(v3);
          v19 = 0;
          v16[1] = -1431655766;
          v17 = &v20[1];
          v16[0] = v6;
          v18 = &v19;
          if (Count < 1)
          {
            v8 = 0;
          }
          else
          {
            v8 = 0;
            while (1)
            {
              ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(v3, v8);
              if ((CFDataGetLength(ValueAtIndex) & 0x8000000000000000) == 0)
              {
                BytePtr = (const UInt8 *)0xAAAAAAAAAAAAAAAALL;
                Length = 0xAAAAAAAAAAAAAAAALL;
                BytePtr = CFDataGetBytePtr(ValueAtIndex);
                Length = CFDataGetLength(ValueAtIndex);
                memset(v13, 170, sizeof(v13));
                if (!DERDecodeItem((uint64_t)&BytePtr, v13))
                {
                  if (!SecCertificateParseGeneralNameContentProperty(v13[0], &v13[1], v16, sub_10002C188)
                    && (_BYTE)v19
                    && HIBYTE(v19))
                  {
                    break;
                  }
                  v10 = 0;
                  v12 = 0;
                  v11[0] = 0xAAAAAAAAAAAAAAAALL;
                  switch(v13[0])
                  {
                    case 0x8000000000000001:
                      v10 = 1;
                      break;
                    case 0x8000000000000002:
                      v10 = 2;
                      break;
                    case 0x8000000000000003:
                    case 0x8000000000000004:
                    case 0x8000000000000005:
                      break;
                    case 0x8000000000000006:
LABEL_26:
                      v10 = 6;
                      break;
                    case 0x8000000000000007:
                      v10 = 7;
                      break;
                    case 0x8000000000000008:
                      v10 = 8;
                      break;
                    default:
                      switch(v13[0])
                      {
                        case 0xA000000000000003:
                          v10 = 3;
                          break;
                        case 0xA000000000000004:
                          v10 = 4;
                          break;
                        case 0xA000000000000005:
                          v10 = 5;
                          break;
                        case 0xA000000000000006:
                          goto LABEL_26;
                        default:
                          goto LABEL_32;
                      }
                      break;
                  }
LABEL_32:
                  LODWORD(v11[0]) = v10;
                  v11[1] = &v13[1];
                  v11[2] = &v12;
                  if (!SecCertificateParseGeneralNameContentProperty(v20[0], &v20[1], v11, sub_10002C188)
                    && (_BYTE)v12
                    && HIBYTE(v12))
                  {
                    break;
                  }
                }
              }
              if (Count == ++v8)
                goto LABEL_39;
            }
          }
          if (v8 == Count)
          {
LABEL_39:
            CFArrayAppendValue(v4, a1);
          }
          else if ((_BYTE)v19)
          {
            if (HIBYTE(v19))
              CFArraySetValueAtIndex(v3, v8, a1);
          }
        }
      }
    }
  }
}

void sub_10002CA18(id a1)
{
  const void *v1;
  NSObject *v2;
  uint8_t v3[16];

  v1 = sub_100011628("trustd");
  v2 = objc_claimAutoreleasedReturnValue(v1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "variant does not allow file writes", v3, 2u);
  }

}

void sub_10002CA84(id a1)
{
  const void *v1;
  NSObject *v2;
  uint8_t v3[16];

  v1 = sub_100011628("trustd");
  v2 = objc_claimAutoreleasedReturnValue(v1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "variant does not allow MobileAsset", v3, 2u);
  }

}

void sub_10002CAF0(id a1)
{
  const void *v1;
  NSObject *v2;
  uint8_t v3[16];

  if (!objc_opt_class(ASAssetQuery)
    || !objc_opt_class(ASAsset)
    || !objc_opt_class(MAAssetQuery)
    || !objc_opt_class(MAAsset))
  {
    v1 = sub_100011628("OTATrust");
    v2 = objc_claimAutoreleasedReturnValue(v1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v3 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Weak-linked MobileAsset framework missing.", v3, 2u);
    }

    byte_100082B78 = 1;
  }
}

void sub_10002CBA8(id a1)
{
  const void *v1;
  NSObject *v2;
  uint8_t v3[16];

  v1 = sub_100011628("trustd");
  v2 = objc_claimAutoreleasedReturnValue(v1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "trustd running in CloudOS variant", v3, 2u);
  }

}

void sub_10002CC14(id a1)
{
  id v1;

  v1 = (id)MGCopyAnswer(CFSTR("ReleaseType"), 0);
  if (objc_msgSend(v1, "containsString:", CFSTR("Darwin Cloud")))
    byte_100082B88 = 1;

}

void sub_10002CC60(id a1)
{
  dispatch_workloop_t v1;
  void *v2;

  v1 = dispatch_workloop_create("com.apple.trustd.evaluation");
  v2 = (void *)qword_100082BA0;
  qword_100082BA0 = (uint64_t)v1;

}

uint64_t sub_10002CC88()
{
  _QWORD block[5];

  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10002CD04;
  block[3] = &unk_1000791F8;
  block[4] = &qword_100082BB8;
  if (qword_100082BB0 != -1)
    dispatch_once(&qword_100082BB0, block);
  return qword_100082BB8;
}

void sub_10002CD04(uint64_t a1)
{
  const __CFURL *v2;
  const __CFURL *v3;

  CFRetain(CFSTR("/System/Library/Security/Certificates.bundle"));
  v2 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, CFSTR("/System/Library/Security/Certificates.bundle"), kCFURLPOSIXPathStyle, 1u);
  if (v2)
  {
    v3 = v2;
    **(_QWORD **)(a1 + 32) = CFBundleCreate(kCFAllocatorDefault, v2);
    CFRelease(v3);
  }
  else
  {
    **(_QWORD **)(a1 + 32) = 0;
  }
  CFRelease(CFSTR("/System/Library/Security/Certificates.bundle"));
}

id sub_10002CD90(void *a1)
{
  id v1;
  id v2;
  _QWORD v4[4];
  id v5;

  v1 = a1;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_10002CE28;
  v4[3] = &unk_100076570;
  v2 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionaryWithCapacity:](NSMutableDictionary, "dictionaryWithCapacity:", objc_msgSend(v1, "count")));
  v5 = v2;
  objc_msgSend(v1, "enumerateObjectsUsingBlock:", v4);

  return v2;
}

void sub_10002CE28(uint64_t a1, void *a2, uint64_t a3)
{
  id v5;
  uint64_t v6;
  NSObject *v7;
  void *v8;
  void *v9;
  id v10;
  uint64_t v11;
  char isKindOfClass;
  const void *v13;
  NSObject *v14;
  void *v15;
  uint64_t v16;
  const void *v17;
  const void *v18;
  NSObject *v19;
  int v20;
  uint64_t v21;

  v5 = a2;
  if (v5)
  {
    v6 = objc_opt_class(NSDictionary);
    if ((objc_opt_isKindOfClass(v5, v6) & 1) != 0)
    {
      v7 = v5;
      v8 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject objectForKeyedSubscript:](v7, "objectForKeyedSubscript:", CFSTR("log_id")));
      v9 = v8;
      if (!v8
        || (v10 = v8,
            v11 = objc_opt_class(NSData),
            isKindOfClass = objc_opt_isKindOfClass(v10, v11),
            v10,
            (isKindOfClass & 1) == 0))
      {
        v13 = sub_100011628("OTATrust");
        v14 = objc_claimAutoreleasedReturnValue(v13);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        {
          v20 = 134217984;
          v21 = a3;
          _os_log_debug_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "failed to read log_id from trusted CT log array entry at index %lu, computing log_id", (uint8_t *)&v20, 0xCu);
        }

        v15 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject objectForKeyedSubscript:](v7, "objectForKeyedSubscript:", CFSTR("key")));
        if (!v15 || (v16 = objc_opt_class(NSData), (objc_opt_isKindOfClass(v15, v16) & 1) == 0))
        {
          v18 = sub_100011628("SecError");
          v19 = objc_claimAutoreleasedReturnValue(v18);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            v20 = 134217984;
            v21 = a3;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "failed to read key from trusted CT log array entry at index %lu", (uint8_t *)&v20, 0xCu);
          }

          goto LABEL_16;
        }
        v10 = (id)SecSHA256DigestCreateFromData(0, v15);

      }
      objc_msgSend(*(id *)(a1 + 32), "setObject:forKey:", v7, v10);
      v9 = v10;
LABEL_16:

      goto LABEL_17;
    }
  }
  v17 = sub_100011628("SecError");
  v7 = objc_claimAutoreleasedReturnValue(v17);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    v20 = 134217984;
    v21 = a3;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "OTATrust: failed to read entry from trusted CT logs array at index %lu", (uint8_t *)&v20, 0xCu);
  }
LABEL_17:

}

uint64_t sub_10002D08C(uint64_t a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass(&unk_1000764A0);
  **(_QWORD **)(a1 + 32) = result;
  return result;
}

void sub_10002D0BC(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  const void *v15;
  void *v16;
  void *v17;
  void *v18;
  const void *v19;

  v2 = (const void *)a1[2];
  if (v2)
  {
    a1[2] = 0;
    CFRelease(v2);
  }
  v3 = (const void *)a1[3];
  if (v3)
  {
    a1[3] = 0;
    CFRelease(v3);
  }
  v4 = (const void *)a1[4];
  if (v4)
  {
    a1[4] = 0;
    CFRelease(v4);
  }
  v5 = (const void *)a1[8];
  if (v5)
  {
    a1[8] = 0;
    CFRelease(v5);
  }
  v6 = (const void *)a1[9];
  if (v6)
  {
    a1[9] = 0;
    CFRelease(v6);
  }
  v7 = (const void *)a1[12];
  if (v7)
  {
    a1[12] = 0;
    CFRelease(v7);
  }
  v8 = (const void *)a1[13];
  if (v8)
  {
    a1[13] = 0;
    CFRelease(v8);
  }
  v9 = (const void *)a1[5];
  if (v9)
  {
    a1[5] = 0;
    CFRelease(v9);
  }
  v10 = (const void *)a1[6];
  if (v10)
  {
    a1[6] = 0;
    CFRelease(v10);
  }
  v11 = (const void *)a1[7];
  if (v11)
  {
    a1[7] = 0;
    CFRelease(v11);
  }
  v12 = (const void *)a1[21];
  if (v12)
  {
    a1[21] = 0;
    CFRelease(v12);
  }
  v13 = (const void *)a1[22];
  if (v13)
  {
    a1[22] = 0;
    CFRelease(v13);
  }
  v14 = (const void *)a1[20];
  if (v14)
  {
    a1[20] = 0;
    CFRelease(v14);
  }
  v15 = (const void *)a1[23];
  if (v15)
  {
    a1[23] = 0;
    CFRelease(v15);
  }
  v16 = (void *)a1[10];
  if (v16)
  {
    free(v16);
    a1[10] = 0;
  }
  v17 = (void *)a1[15];
  if (v17)
  {
    free(v17);
    a1[15] = 0;
  }
  v18 = (void *)a1[26];
  a1[26] = 0;

  v19 = (const void *)a1[27];
  if (v19)
  {
    a1[27] = 0;
    CFRelease(v19);
  }
}

CFStringRef sub_10002D1FC(uint64_t a1)
{
  return CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("<SecOTAPKIRef: version %llu/%llu>"), *(_QWORD *)(a1 + 112), *(_QWORD *)(a1 + 152));
}

CFStringRef sub_10002D240(uint64_t a1)
{
  sub_100026A10();
  return CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("<SecOTAPKIRef: version %llu/%llu>"), *(_QWORD *)(a1 + 112), *(_QWORD *)(a1 + 152));
}

void sub_10002D290(id a1)
{
  void *v1;
  dispatch_queue_t v2;
  void *v3;
  dispatch_queue_attr_t v4;
  NSObject *v5;
  dispatch_queue_attr_t v6;
  NSObject *v7;
  dispatch_queue_t v8;
  void *v9;
  dispatch_queue_t v10;
  void *v11;
  NSObject *v12;
  const void *v13;
  NSObject *v14;
  uint8_t v15[16];

  v1 = objc_autoreleasePoolPush();
  v2 = dispatch_queue_create("com.apple.security.OTAPKIQueue", 0);
  v3 = (void *)qword_100082BC8;
  qword_100082BC8 = (uint64_t)v2;

  v4 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_BACKGROUND, 0);
  v5 = objc_claimAutoreleasedReturnValue(v4);
  v6 = dispatch_queue_attr_make_with_autorelease_frequency(v5, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v7 = objc_claimAutoreleasedReturnValue(v6);

  v8 = dispatch_queue_create("com.apple.security.OTAPKIBackgroundQueue", v7);
  v9 = (void *)qword_100082BC0;
  qword_100082BC0 = (uint64_t)v8;

  v10 = dispatch_queue_create("com.apple.security.OTAPKIReloadAssetQueue", 0);
  v11 = (void *)qword_100082BD0;
  qword_100082BD0 = (uint64_t)v10;

  v12 = qword_100082BC8;
  if (!qword_100082BC8 || !qword_100082BC0 || !qword_100082BD0)
  {
    v13 = sub_100011628("SecError");
    v14 = objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v15 = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Failed to create OTAPKI Queues. May crash later.", v15, 2u);
    }

    v12 = qword_100082BC8;
  }
  dispatch_sync(v12, &stru_100076520);

  objc_autoreleasePoolPop(v1);
}

void sub_10002D3D4(id a1)
{
  uint64_t Instance;
  uint64_t v2;
  __CFSet **v3;
  void *v4;
  OTAAutoAssetClient *v5;
  __CFError *v6;
  void *v7;
  void *v8;
  const void *v9;
  NSObject *v10;
  CFIndex Code;
  const __CFData *v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  const void *v16;
  NSObject *v17;
  const __CFData *v18;
  __CFSet *v19;
  const __CFData *v20;
  __CFSet *v21;
  void *v22;
  id v23;
  id v24;
  id v25;
  void *v26;
  id v27;
  id v28;
  uint64_t v29;
  char isKindOfClass;
  const void *v31;
  NSObject *v32;
  void *v33;
  uint64_t v34;
  char v35;
  id v36;
  void *v37;
  uint64_t v38;
  id v39;
  uint64_t v40;
  char v41;
  id v42;
  uint64_t v43;
  char v44;
  id v45;
  void *v46;
  id v47;
  id v48;
  id v49;
  uint64_t v50;
  char v51;
  id v52;
  const void *v53;
  NSObject *v54;
  uint64_t v55;
  char v56;
  void *v57;
  id v58;
  void *v59;
  id v60;
  uint64_t v61;
  char v62;
  const void *v63;
  const __CFData *v64;
  const __CFData *v65;
  const __CFDictionary *v66;
  const __CFDictionary *v67;
  CFTypeID TypeID;
  const __CFNumber *Value;
  const __CFNumber *v70;
  const __CFNumber *v71;
  uint64_t v72;
  char *v73;
  const __CFURL *v74;
  const __CFURL *v75;
  const __CFString *v76;
  const char *CStringPtr;
  const void *v78;
  NSObject *v79;
  const void *v80;
  NSObject *v81;
  char *v82;
  timespec v83;
  int v84;
  const __CFData *v85;
  const __CFData *v86;
  CFTypeID v87;
  const void *v88;
  NSObject *v89;
  char *v90;
  const void *v91;
  const void *v92;
  void *v93;
  void *v94;
  void *v95;
  void *v96;
  NSObject *v97;
  const __CFData *v98;
  const void *v99;
  NSObject *v100;
  const void *v101;
  NSObject *v102;
  const void *v103;
  const char *v104;
  const void *v105;
  NSObject *v106;
  const char *v107;
  const __CFDictionary *v108;
  const __CFDictionary *v109;
  CFTypeID v110;
  const __CFDictionary *v111;
  const __CFDictionary *v112;
  CFTypeID v113;
  const __CFDictionary *v114;
  const __CFData *v115;
  const __CFData *v116;
  CFIndex Length;
  __CFString *Mutable;
  const UInt8 *BytePtr;
  CFIndex v120;
  CFIndex v121;
  unsigned int v122;
  NSObject *v123;
  const void *v124;
  NSObject *v125;
  NSObject *v126;
  const void *v127;
  NSObject *v128;
  id v129;
  CFPropertyListFormat format;
  char *v131;
  int v132;
  int out_token;
  _BYTE valuePtr[12];
  stat buf[7];

  *(_QWORD *)&buf[0].st_dev = _NSConcreteStackBlock;
  buf[0].st_ino = 3221225472;
  *(_QWORD *)&buf[0].st_uid = sub_10002D08C;
  *(_QWORD *)&buf[0].st_rdev = &unk_1000791F8;
  buf[0].st_atimespec.tv_sec = (__darwin_time_t)&qword_100082BE0;
  if (qword_100082BD8 != -1)
    dispatch_once(&qword_100082BD8, buf);
  Instance = _CFRuntimeCreateInstance(kCFAllocatorDefault, qword_100082BE0, 208, 0);
  v2 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    v3 = (__CFSet **)(Instance + 16);
    *(_QWORD *)(Instance + 120) = 0;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_QWORD *)(Instance + 80) = 0;
    *(_QWORD *)(Instance + 96) = 0;
    *(_QWORD *)(Instance + 104) = 0;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    v4 = *(void **)(Instance + 208);
    *(_QWORD *)(Instance + 208) = 0;

    *(_QWORD *)(v2 + 216) = 0;
    if (sub_1000150B0())
    {
      v129 = 0;
      v5 = -[OTAAutoAssetClient initWithError:]([OTAAutoAssetClient alloc], "initWithError:", &v129);
      v6 = (__CFError *)v129;
      v7 = *(void **)(v2 + 208);
      *(_QWORD *)(v2 + 208) = v5;

      v8 = *(void **)(v2 + 208);
      if (v8)
      {
        objc_msgSend(v8, "registerForAssetChangedNotificationsWithBlock:", &stru_100076590);
      }
      else
      {
        v9 = sub_100011628("SecError");
        v10 = objc_claimAutoreleasedReturnValue(v9);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          buf[0].st_dev = 138412290;
          *(_QWORD *)&buf[0].st_mode = v6;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Error initializing OTAAutoAssetClient: %@", (uint8_t *)buf, 0xCu);
        }

        if (v6)
          Code = CFErrorGetCode(v6);
        else
          Code = 0xFFFFFFFFLL;
        sub_100052038((uint64_t)CFSTR("AssetBuiltInEvent"), 0, Code);
      }

    }
    v12 = (const __CFData *)sub_10002E500(v2, (uint64_t)CFSTR("AssetVersion"), (uint64_t)CFSTR("plist"));
    v13 = sub_10002E614(v12);
    if (v13)
    {
      v14 = v13;
      v15 = "asset";
      if (!v12)
        goto LABEL_17;
    }
    else
    {
      if (v12)
        CFRelease(v12);
      v12 = sub_10002E6C8(CFSTR("AssetVersion"), CFSTR("plist"));
      v14 = sub_10002E614(v12);
      v15 = "system";
      if (!v12)
      {
LABEL_17:
        v16 = sub_100011628("OTATrust");
        v17 = objc_claimAutoreleasedReturnValue(v16);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          buf[0].st_dev = 134218242;
          *(_QWORD *)&buf[0].st_mode = v14;
          WORD2(buf[0].st_ino) = 2080;
          *(__darwin_ino64_t *)((char *)&buf[0].st_ino + 6) = (__darwin_ino64_t)v15;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Using trust store version %llu from %s", (uint8_t *)buf, 0x16u);
        }

        *(_QWORD *)(v2 + 112) = v14;
        v18 = sub_10002E7F0(CFSTR("Blocked"));
        v19 = sub_10002E84C(v18);
        if (v18)
          CFRelease(v18);
        *v3 = v19;
        v20 = sub_10002E7F0(CFSTR("GrayListedKeys"));
        v21 = sub_10002E84C(v20);
        if (v20)
          CFRelease(v20);
        *(_QWORD *)(v2 + 24) = v21;
        *(_QWORD *)(v2 + 40) = sub_10002E8F4(CFSTR("TrustedCTLogs.plist"));
        *(_QWORD *)(v2 + 48) = 0;
        *(_QWORD *)(v2 + 56) = sub_10002EB5C(CFSTR("CertificatePinning"), CFSTR("plist"));
        v22 = 0;
        v23 = 0;
        v24 = 0;
        if (sub_10002EC44())
        {
          v25 = sub_10002ED40(CFSTR("AnalyticsSamplingRates.plist"));
          v26 = (void *)objc_claimAutoreleasedReturnValue(v25);
          *(_QWORD *)valuePtr = 0;
          v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithContentsOfURL:error:](NSDictionary, "dictionaryWithContentsOfURL:error:", v26, valuePtr));
          v27 = *(id *)valuePtr;

          if (v22
            && (v28 = v22,
                v29 = objc_opt_class(NSDictionary),
                isKindOfClass = objc_opt_isKindOfClass(v28, v29),
                v28,
                (isKindOfClass & 1) != 0))
          {
            v24 = v27;
          }
          else
          {
            v31 = sub_100011628("SecError");
            v32 = objc_claimAutoreleasedReturnValue(v31);
            if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
            {
              buf[0].st_dev = 138412290;
              *(_QWORD *)&buf[0].st_mode = v27;
              _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "OTATrust: failed to read sampling rates from asset data: %@", (uint8_t *)buf, 0xCu);
            }

            *(_QWORD *)&buf[0].st_dev = v27;
            sub_10002EF6C(4, (uint64_t *)&buf[0].st_dev, 0);
            v24 = *(id *)&buf[0].st_dev;

            if ((sub_10002F010() & 1) == 0)
              byte_100082BF8 = 1;
          }
          v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "objectForKeyedSubscript:", CFSTR("Events")));
          if (v33)
          {
            v23 = v33;
            v34 = objc_opt_class(NSDictionary);
            v35 = objc_opt_isKindOfClass(v23, v34);

            if ((v35 & 1) != 0)
            {
              if (!v22)
                goto LABEL_45;
LABEL_41:
              v39 = v22;
              v40 = objc_opt_class(NSDictionary);
              v41 = objc_opt_isKindOfClass(v39, v40);

              if ((v41 & 1) != 0)
              {
                v42 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v39, "objectForKeyedSubscript:", CFSTR("Events")));

                if (!v42)
                {
                  v23 = 0;
LABEL_46:

                  *(_QWORD *)(v2 + 168) = v42;
                  if (sub_10002EC44())
                  {
                    v45 = sub_10002ED40(CFSTR("AppleCertificateAuthorities.plist"));
                    v46 = (void *)objc_claimAutoreleasedReturnValue(v45);
                    *(_QWORD *)valuePtr = 0;
                    v47 = (id)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithContentsOfURL:error:](NSArray, "arrayWithContentsOfURL:error:", v46, valuePtr));
                    v48 = *(id *)valuePtr;

                    if (v47)
                    {
                      v49 = v47;
                      v50 = objc_opt_class(NSArray);
                      v51 = objc_opt_isKindOfClass(v49, v50);

                      if ((v51 & 1) != 0)
                      {
                        v52 = v48;
                        goto LABEL_56;
                      }
                    }
                    v53 = sub_100011628("SecError");
                    v54 = objc_claimAutoreleasedReturnValue(v53);
                    if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
                    {
                      buf[0].st_dev = 138412290;
                      *(_QWORD *)&buf[0].st_mode = v48;
                      _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "OTATrust: failed to read Apple CAs list from asset data: %@", (uint8_t *)buf, 0xCu);
                    }

                    *(_QWORD *)&buf[0].st_dev = v48;
                    sub_10002EF6C(4, (uint64_t *)&buf[0].st_dev, 0);
                    v52 = *(id *)&buf[0].st_dev;

                    if ((sub_10002F010() & 1) == 0)
                      byte_100082BF8 = 1;
                    if (v47)
                    {
LABEL_56:
                      v47 = v47;
                      v55 = objc_opt_class(NSArray);
                      v56 = objc_opt_isKindOfClass(v47, v55);

                      v57 = v47;
                      if ((v56 & 1) != 0)
                        goto LABEL_58;
                    }
                  }
                  else
                  {
                    v47 = 0;
                    v52 = 0;
                  }
                  v58 = sub_10002F074(CFSTR("AppleCertificateAuthorities.plist"));
                  v59 = (void *)objc_claimAutoreleasedReturnValue(v58);
                  v57 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithContentsOfURL:](NSArray, "arrayWithContentsOfURL:", v59));

                  if (!v57)
                  {
                    v60 = 0;
                    goto LABEL_62;
                  }
LABEL_58:
                  v60 = v57;
                  v61 = objc_opt_class(NSArray);
                  v62 = objc_opt_isKindOfClass(v60, v61);

                  if ((v62 & 1) != 0)
                  {
                    v60 = v60;
                    v57 = v60;
                  }
                  else
                  {
                    v57 = 0;
                  }
LABEL_62:

                  *(_QWORD *)(v2 + 176) = v57;
                  if ((byte_100082BF8 & 1) != 0)
                  {
                    *(_QWORD *)(v2 + 152) = sub_10002F5DC(CFSTR("MobileAssetContentVersion"));
                  }
                  else
                  {
                    *(_QWORD *)&buf[0].st_dev = 0;
                    *(_QWORD *)(v2 + 152) = sub_10002F174(buf);
                    *(_QWORD *)(v2 + 160) = sub_10002F438();
                    v63 = *(const void **)&buf[0].st_dev;
                    if (*(_QWORD *)&buf[0].st_dev)
                    {
                      *(_QWORD *)&buf[0].st_dev = 0;
                      CFRelease(v63);
                    }
                  }
                  *(_QWORD *)(v2 + 192) = 0;
                  *(_QWORD *)&buf[0].st_dev = 0;
                  *(_QWORD *)valuePtr = 0;
                  v131 = 0;
                  v64 = sub_10002E6C8(CFSTR("ValidUpdate"), CFSTR("plist"));
                  if (v64)
                  {
                    v65 = v64;
                    format = 0xAAAAAAAAAAAAAAAALL;
                    v66 = (const __CFDictionary *)CFPropertyListCreateWithData(kCFAllocatorDefault, v64, 0, &format, 0);
                    if (v66)
                    {
                      v67 = v66;
                      TypeID = CFDictionaryGetTypeID();
                      if (TypeID == CFGetTypeID(v67))
                      {
                        Value = (const __CFNumber *)CFDictionaryGetValue(v67, CFSTR("Version"));
                        if (Value)
                          CFNumberGetValue(Value, kCFNumberCFIndexType, buf);
                        v70 = (const __CFNumber *)CFDictionaryGetValue(v67, CFSTR("Format"));
                        if (v70)
                          CFNumberGetValue(v70, kCFNumberCFIndexType, valuePtr);
                        v71 = (const __CFNumber *)CFDictionaryGetValue(v67, CFSTR("Generation"));
                        if (v71)
                          CFNumberGetValue(v71, kCFNumberCFIndexType, &v131);
                      }
                      CFRelease(v67);
                    }
                    CFRelease(v65);
                  }
                  v72 = *(_QWORD *)valuePtr;
                  v73 = v131;
                  *(_QWORD *)(v2 + 128) = *(_QWORD *)&buf[0].st_dev;
                  *(_QWORD *)(v2 + 136) = v72;
                  *(_QWORD *)(v2 + 144) = v73;
                  v131 = 0;
                  v74 = sub_10002EB5C(CFSTR("valid"), CFSTR("sqlite3"));
                  if (v74)
                  {
                    v75 = v74;
                    v76 = CFURLCopyFileSystemPath(v74, kCFURLPOSIXPathStyle);
                    bzero(buf, 0x400uLL);
                    if (v76)
                    {
                      CStringPtr = CFStringGetCStringPtr(v76, 0x8000100u);
                      if (CStringPtr
                        || (CStringPtr = (const char *)buf, CFStringGetCString(v76, (char *)buf, 1024, 0x8000100u)))
                      {
                        asprintf(&v131, "%s", CStringPtr);
                      }
                      else
                      {
                        v101 = sub_100011628("SecError");
                        v102 = objc_claimAutoreleasedReturnValue(v101);
                        if (os_log_type_enabled(v102, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_DWORD *)valuePtr = 136315138;
                          *(_QWORD *)&valuePtr[4] = "could not get valid snapshot";
                          _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_DEFAULT, "%s path as UTF8 string", valuePtr, 0xCu);
                        }

                      }
                      CFRelease(v76);
                    }
                    else
                    {
                      v80 = sub_100011628("SecError");
                      v81 = objc_claimAutoreleasedReturnValue(v80);
                      if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)valuePtr = 136315138;
                        *(_QWORD *)&valuePtr[4] = "could not get valid snapshot";
                        _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_DEFAULT, "%s path", valuePtr, 0xCu);
                      }

                    }
                    CFRelease(v75);
                    v82 = v131;
                    if (!v131)
                      goto LABEL_93;
                    v83.tv_sec = 0xAAAAAAAAAAAAAAAALL;
                    v83.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
                    *(timespec *)&buf[0].st_blksize = v83;
                    *(timespec *)buf[0].st_qspare = v83;
                    buf[0].st_birthtimespec = v83;
                    *(timespec *)&buf[0].st_size = v83;
                    buf[0].st_mtimespec = v83;
                    buf[0].st_ctimespec = v83;
                    *(timespec *)&buf[0].st_uid = v83;
                    buf[0].st_atimespec = v83;
                    *(timespec *)&buf[0].st_dev = v83;
                    v84 = stat(v131, buf);
                    v82 = v131;
                    if (!v84)
                    {
LABEL_93:
                      *(_QWORD *)(v2 + 120) = v82;
                      v85 = sub_10002E7F0(CFSTR("EVRoots"));
                      if (v85)
                      {
                        v86 = v85;
                        v87 = CFGetTypeID(v85);
                        if (v87 == CFDictionaryGetTypeID())
                        {
                          *(_QWORD *)(v2 + 64) = v86;
                          *(_QWORD *)valuePtr = 0;
                          format = 0;
                          v131 = 0;
                          if ((sub_10002F6C8(v2, (const __CFDictionary **)valuePtr, &v131, (size_t *)&format, 1) & 1) != 0)
                            goto LABEL_99;
                          v88 = sub_100011628("OTATrust");
                          v89 = objc_claimAutoreleasedReturnValue(v88);
                          if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
                          {
                            LOWORD(buf[0].st_dev) = 0;
                            _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEFAULT, "Using built-in system anchors", (uint8_t *)buf, 2u);
                          }

                          if ((sub_10002F6C8(v2, (const __CFDictionary **)valuePtr, &v131, (size_t *)&format, 0) & 1) != 0)
                          {
LABEL_99:
                            v90 = v131;
                            *(_QWORD *)(v2 + 72) = *(_QWORD *)valuePtr;
                            *(_QWORD *)(v2 + 80) = v90;
                            *(_QWORD *)(v2 + 88) = format;
                            v91 = sub_10002FD68(v2);
                            if (!v91)
                              goto LABEL_131;
                            v92 = v91;
                            v93 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@/../%@"), v91, CFSTR("Info")));
                            CFRelease(v92);
                            v94 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@.%@"), v93, CFSTR("plist")));

                            v95 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:isDirectory:](NSURL, "fileURLWithPath:isDirectory:", v94, 0));
                            if (v95)
                            {
                              v96 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithContentsOfURL:](NSData, "dataWithContentsOfURL:", v95));
                              if (v96)
                              {
                                v97 = v96;
                                v98 = (const __CFData *)v97;
                                goto LABEL_124;
                              }
                              v104 = (const char *)objc_msgSend(objc_retainAutorelease(v95), "fileSystemRepresentation");
                              v105 = sub_100011628("SecWarning");
                              v106 = objc_claimAutoreleasedReturnValue(v105);
                              if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
                              {
                                v107 = "";
                                if (v104)
                                  v107 = v104;
                                buf[0].st_dev = 136315138;
                                *(_QWORD *)&buf[0].st_mode = v107;
                                _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_DEFAULT, "Unable to get data from \"%s\"", (uint8_t *)buf, 0xCu);
                              }

                              v97 = 0;
                            }
                            else
                            {
                              v103 = sub_100011628("SecWarning");
                              v97 = objc_claimAutoreleasedReturnValue(v103);
                              if (os_log_type_enabled(v97, OS_LOG_TYPE_DEFAULT))
                              {
                                buf[0].st_dev = 138412802;
                                *(_QWORD *)&buf[0].st_mode = CFSTR("Info");
                                WORD2(buf[0].st_ino) = 2112;
                                *(__darwin_ino64_t *)((char *)&buf[0].st_ino + 6) = (__darwin_ino64_t)CFSTR("plist");
                                HIWORD(buf[0].st_gid) = 2112;
                                *(_QWORD *)&buf[0].st_rdev = 0;
                                _os_log_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_DEFAULT, "resource: %@.%@ in %@ not found", (uint8_t *)buf, 0x20u);
                              }
                            }
                            v98 = 0;
LABEL_124:

                            if (v98)
                            {
                              *(_QWORD *)&buf[0].st_dev = 0xAAAAAAAAAAAAAAAALL;
                              v108 = (const __CFDictionary *)CFPropertyListCreateWithData(kCFAllocatorDefault, v98, 0, (CFPropertyListFormat *)buf, 0);
                              if (!v108)
                              {
                                v112 = 0;
                                goto LABEL_135;
                              }
                              v109 = v108;
                              v110 = CFGetTypeID(v108);
                              if (v110 == CFDictionaryGetTypeID())
                              {
                                v111 = (const __CFDictionary *)CFDictionaryGetValue(v109, CFSTR("MobileAssetProperties"));
                                v112 = v111;
                                if (!v111)
                                {
LABEL_133:
                                  CFRelease(v109);
LABEL_135:
                                  CFRelease(v98);
                                  goto LABEL_136;
                                }
                                v113 = CFGetTypeID(v111);
                                if (v113 == CFDictionaryGetTypeID())
                                {
                                  v114 = (const __CFDictionary *)CFDictionaryGetValue(v112, CFSTR("AssetVersion"));
                                  v112 = v114;
                                  if (v114)
                                    CFRetain(v114);
                                  goto LABEL_133;
                                }
                              }
                              v112 = 0;
                              goto LABEL_133;
                            }
LABEL_131:
                            v112 = 0;
LABEL_136:
                            *(_QWORD *)(v2 + 96) = v112;
                            v115 = (const __CFData *)SecSHA256DigestCreate(0, *(_QWORD *)(v2 + 80), *(_QWORD *)(v2 + 88));
                            if (v115)
                            {
                              v116 = v115;
                              Length = CFDataGetLength(v115);
                              Mutable = CFStringCreateMutable(kCFAllocatorDefault, 2 * Length);
                              BytePtr = CFDataGetBytePtr(v116);
                              v120 = CFDataGetLength(v116);
                              if (v120 >= 1)
                              {
                                v121 = v120;
                                do
                                {
                                  v122 = *BytePtr++;
                                  CFStringAppendFormat(Mutable, 0, CFSTR("%02X"), v122);
                                  --v121;
                                }
                                while (v121);
                              }
                              CFRelease(v116);
                            }
                            else
                            {
                              Mutable = 0;
                            }
                            *(_QWORD *)(v2 + 104) = Mutable;
                            if (sub_1000150B0())
                            {
                              v123 = (id)qword_100082BC0;
                              if (sub_1000150B0())
                              {
                                if (qword_100082C28 != -1)
                                  dispatch_once(&qword_100082C28, &stru_1000767D0);
                                if (byte_100082C20 == 1)
                                {
                                  if (sub_1000150B0())
                                  {
                                    buf[0].st_dev = 0;
                                    notify_register_dispatch("com.apple.MobileAsset.PKITrustSupplementals.ma.cached-metadata-updated", &buf[0].st_dev, v123, &stru_1000765F0);
                                  }
                                  dispatch_async(v123, &stru_100076610);
                                }
                                else
                                {
                                  v124 = sub_100011628("OTATrust");
                                  v125 = objc_claimAutoreleasedReturnValue(v124);
                                  if (os_log_type_enabled(v125, OS_LOG_TYPE_DEFAULT))
                                  {
                                    LOWORD(buf[0].st_dev) = 0;
                                    _os_log_impl((void *)&_mh_execute_header, v125, OS_LOG_TYPE_DEFAULT, "Initializing listener for PKI Asset changes from system trustd.", (uint8_t *)buf, 2u);
                                  }

                                  buf[0].st_dev = 0;
                                  notify_register_dispatch("com.apple.trustd.asset-updated", &buf[0].st_dev, v123, &stru_100076630);
                                  out_token = 0;
                                  notify_register_dispatch("com.apple.trustd.asset-check-in", &out_token, v123, &stru_100076650);
                                  v132 = 0;
                                  notify_register_dispatch("com.apple.trustd.kill-switch", &v132, v123, &stru_100076670);
                                }
                              }

                              *(_BYTE *)(v2 + 200) = sub_10002FE58(CFSTR("CTKillSwitch"));
                              *(_BYTE *)(v2 + 201) = sub_10002FE58(CFSTR("CTKillSwitch_nonTLS"));
                              v126 = (id)qword_100082BC0;
                              if (qword_100082C28 != -1)
                                dispatch_once(&qword_100082C28, &stru_1000767D0);
                              if (byte_100082C20 == 1)
                              {
                                dispatch_async(v126, &stru_100076748);
                              }
                              else
                              {
                                v127 = sub_100011628("OTATrust");
                                v128 = objc_claimAutoreleasedReturnValue(v127);
                                if (os_log_type_enabled(v128, OS_LOG_TYPE_DEFAULT))
                                {
                                  LOWORD(buf[0].st_dev) = 0;
                                  _os_log_impl((void *)&_mh_execute_header, v128, OS_LOG_TYPE_DEFAULT, "Initializing listener for SecExperiment Asset changes from system trustd.", (uint8_t *)buf, 2u);
                                }

                                buf[0].st_dev = 0;
                                notify_register_dispatch("com.apple.trustd.secexperiment.asset-updated", &buf[0].st_dev, v126, &stru_100076768);
                              }

                            }
                            else
                            {
                              *(_WORD *)(v2 + 200) = 257;
                            }
                            goto LABEL_107;
                          }
                          if (*(_QWORD *)valuePtr)
                            CFRelease(*(CFTypeRef *)valuePtr);
                          if (v131)
                            free(v131);
                        }
                        else
                        {
                          v99 = sub_100011628("SecWarning");
                          v100 = objc_claimAutoreleasedReturnValue(v99);
                          if (os_log_type_enabled(v100, OS_LOG_TYPE_DEFAULT))
                          {
                            LOWORD(buf[0].st_dev) = 0;
                            _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_DEFAULT, "EVRoot.plist is wrong type.", (uint8_t *)buf, 2u);
                          }

                          CFRelease(v86);
                        }
                      }
                      CFRelease((CFTypeRef)v2);
                      v2 = 0;
                      goto LABEL_107;
                    }
                    free(v131);
                  }
                  else
                  {
                    v78 = sub_100011628("SecError");
                    v79 = objc_claimAutoreleasedReturnValue(v78);
                    if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
                    {
                      buf[0].st_dev = 136315138;
                      *(_QWORD *)&buf[0].st_mode = "could not get valid snapshot";
                      _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "%s", (uint8_t *)buf, 0xCu);
                    }

                  }
                  v82 = 0;
                  goto LABEL_93;
                }
                v23 = v42;
                v43 = objc_opt_class(NSDictionary);
                v44 = objc_opt_isKindOfClass(v23, v43);

                if ((v44 & 1) != 0)
                {
                  v42 = v23;
                  v23 = v42;
                  goto LABEL_46;
                }
              }
LABEL_45:
              v42 = 0;
              goto LABEL_46;
            }
          }
          else
          {
            v23 = 0;
          }
        }
        v36 = sub_10002F074(CFSTR("AnalyticsSamplingRates.plist"));
        v37 = (void *)objc_claimAutoreleasedReturnValue(v36);
        v38 = objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithContentsOfURL:](NSDictionary, "dictionaryWithContentsOfURL:", v37));

        v22 = (void *)v38;
        if (!v38)
          goto LABEL_45;
        goto LABEL_41;
      }
    }
    CFRelease(v12);
    goto LABEL_17;
  }
LABEL_107:
  qword_100082BF0 = v2;
}

void *sub_10002E500(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  id v7;
  const char *v8;
  const void *v9;
  NSObject *v10;
  const char *v11;
  int v13;
  const char *v14;

  v3 = sub_100033D28(a1, a2, a3);
  if (!v3)
    return 0;
  v4 = v3;
  v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithContentsOfURL:](NSData, "dataWithContentsOfURL:", v3));
  v6 = v5;
  if (v5)
  {
    v7 = v5;
  }
  else
  {
    v8 = (const char *)objc_msgSend(objc_retainAutorelease(v4), "fileSystemRepresentation");
    v9 = sub_100011628("SecWarning");
    v10 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      v11 = "";
      if (v8)
        v11 = v8;
      v13 = 136315138;
      v14 = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Unable to get data from \"%s\"", (uint8_t *)&v13, 0xCu);
    }

  }
  CFRelease(v4);

  return v6;
}

uint64_t sub_10002E614(CFDataRef data)
{
  CFPropertyListRef v1;
  const void *v2;
  CFTypeID TypeID;
  const __CFNumber *Value;
  uint64_t v5;
  uint64_t v7;
  CFPropertyListFormat format;

  if (!data)
    return 0;
  format = 0xAAAAAAAAAAAAAAAALL;
  v1 = CFPropertyListCreateWithData(kCFAllocatorDefault, data, 0, &format, 0);
  if (!v1)
    return 0;
  v2 = v1;
  TypeID = CFDictionaryGetTypeID();
  if (TypeID == CFGetTypeID(v2)
    && (Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v2, CFSTR("VersionNumber"))) != 0)
  {
    v7 = 0;
    CFNumberGetValue(Value, kCFNumberSInt64Type, &v7);
    v5 = v7 & ~(v7 >> 63);
  }
  else
  {
    v5 = 0;
  }
  CFRelease(v2);
  return v5;
}

const __CFURL *sub_10002E6C8(const __CFString *a1, const __CFString *a2)
{
  const __CFURL *result;
  const __CFURL *v3;
  const char *v4;
  const void *v5;
  NSObject *v6;
  const char *v7;
  SInt32 errorCode;
  CFDataRef resourceData;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  uint64_t v13;

  result = sub_10002EB5C(a1, a2);
  resourceData = 0;
  if (result)
  {
    v3 = result;
    errorCode = -1431655766;
    if (!CFURLCreateDataAndPropertiesFromResource(kCFAllocatorDefault, result, &resourceData, 0, 0, &errorCode))
    {
      v4 = (const char *)-[__CFURL fileSystemRepresentation](objc_retainAutorelease(v3), "fileSystemRepresentation");
      v5 = sub_100011628("SecWarning");
      v6 = objc_claimAutoreleasedReturnValue(v5);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        v7 = "";
        if (v4)
          v7 = v4;
        *(_DWORD *)buf = 136315394;
        v11 = v7;
        v12 = 2048;
        v13 = errorCode;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Unable to get data from \"%s\": error %ld", buf, 0x16u);
      }

    }
    CFRelease(v3);
    return resourceData;
  }
  return result;
}

const __CFData *sub_10002E7F0(const __CFString *a1)
{
  const __CFData *result;
  const __CFData *v2;
  CFPropertyListRef v3;

  result = sub_10002E6C8(a1, CFSTR("plist"));
  if (result)
  {
    v2 = result;
    v3 = CFPropertyListCreateWithData(kCFAllocatorDefault, result, 0, 0, 0);
    CFRelease(v2);
    return (const __CFData *)v3;
  }
  return result;
}

__CFSet *sub_10002E84C(const void *a1)
{
  CFTypeID v2;
  __CFSet *Mutable;
  CFIndex Count;
  CFIndex v5;
  CFIndex i;
  const void *ValueAtIndex;

  if (!a1)
    return 0;
  v2 = CFGetTypeID(a1);
  if (v2 != CFArrayGetTypeID())
    return 0;
  Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  if (Mutable)
  {
    Count = CFArrayGetCount((CFArrayRef)a1);
    if (Count >= 1)
    {
      v5 = Count;
      for (i = 0; i != v5; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, i);
        CFSetAddValue(Mutable, ValueAtIndex);
      }
    }
  }
  return Mutable;
}

id sub_10002E8F4(void *a1)
{
  id v1;
  void *v2;
  id v3;
  void *v4;
  id v5;
  id v6;
  id v7;
  uint64_t v8;
  char isKindOfClass;
  id v10;
  const void *v11;
  NSObject *v12;
  uint64_t v13;
  char v14;
  id v15;
  id v16;
  void *v17;
  id v18;
  uint64_t v19;
  char v20;
  id v21;
  id v23;
  id v24;
  uint8_t buf[4];
  id v26;

  v1 = a1;
  v2 = objc_autoreleasePoolPush();
  if (sub_10002EC44())
  {
    v3 = sub_10002ED40(v1);
    v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
    v24 = 0;
    v5 = (id)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithContentsOfURL:error:](NSArray, "arrayWithContentsOfURL:error:", v4, &v24));
    v6 = v24;

    if (v5)
    {
      v7 = v5;
      v8 = objc_opt_class(NSArray);
      isKindOfClass = objc_opt_isKindOfClass(v7, v8);

      if ((isKindOfClass & 1) != 0)
      {
        v10 = v6;
        goto LABEL_11;
      }
    }
    v11 = sub_100011628("SecError");
    v12 = objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v26 = v6;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "OTATrust: failed to read CT list from asset data: %@", buf, 0xCu);
    }

    v23 = v6;
    sub_10002EF6C(4, (uint64_t *)&v23, 0);
    v10 = v23;

    if ((sub_10002F010() & 1) == 0)
      byte_100082BF8 = 1;
    if (v5)
    {
LABEL_11:
      v5 = v5;
      v13 = objc_opt_class(NSArray);
      v14 = objc_opt_isKindOfClass(v5, v13);

      v15 = v5;
      if ((v14 & 1) != 0)
        goto LABEL_13;
    }
  }
  else
  {
    v5 = 0;
    v10 = 0;
  }
  v16 = sub_10002F074(v1);
  v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
  v15 = (id)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithContentsOfURL:](NSArray, "arrayWithContentsOfURL:", v17));

  if (!v15)
  {
    v18 = 0;
    goto LABEL_17;
  }
LABEL_13:
  v18 = v15;
  v19 = objc_opt_class(NSArray);
  v20 = objc_opt_isKindOfClass(v18, v19);

  if ((v20 & 1) != 0)
  {
    v21 = sub_10002CD90(v18);
    v15 = (id)objc_claimAutoreleasedReturnValue(v21);

  }
  else
  {
    v15 = 0;
  }
LABEL_17:

  objc_autoreleasePoolPop(v2);
  return v15;
}

CFURLRef sub_10002EB5C(const __CFString *a1, const __CFString *a2)
{
  __CFBundle *v4;
  CFURLRef result;
  const void *v6;
  NSObject *v7;
  int v8;
  const __CFString *v9;
  __int16 v10;
  const __CFString *v11;
  __int16 v12;
  uint64_t v13;

  v4 = (__CFBundle *)sub_10002CC88();
  if (!v4 || (result = CFBundleCopyResourceURL(v4, a1, a2, 0)) == 0)
  {
    v6 = sub_100011628("SecWarning");
    v7 = objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = 138412802;
      v9 = a1;
      v10 = 2112;
      v11 = a2;
      v12 = 2112;
      v13 = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "resource: %@.%@ in %@ not found", (uint8_t *)&v8, 0x20u);
    }

    return 0;
  }
  return result;
}

uint64_t sub_10002EC44()
{
  unint64_t v0;
  unint64_t v1;
  unint64_t v2;
  const void *v3;
  NSObject *v4;
  char v5;
  int v7;
  unint64_t v8;
  __int16 v9;
  unint64_t v10;

  if (sub_1000150B0()
    && (v0 = sub_10002F5DC(CFSTR("MobileAssetContentVersion")), v1 = sub_10002F174(0), v1 > v0))
  {
    v2 = v1;
    v3 = sub_100011628("OTATrust");
    v4 = objc_claimAutoreleasedReturnValue(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v7 = 134218240;
      v8 = v2;
      v9 = 2048;
      v10 = v0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Using asset v%llu instead of system v%llu", (uint8_t *)&v7, 0x16u);
    }

    v5 = byte_100082BF8 ^ 1;
  }
  else
  {
    v5 = 0;
  }
  return v5 & 1;
}

id sub_10002ED40(void *a1)
{
  id v1;
  void *v2;
  const char *v3;
  int v4;
  int v5;
  const void *v6;
  NSObject *v7;
  char *v8;
  void *v9;
  id v10;
  void *v11;
  _QWORD v13[5];
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t (*v17)(uint64_t, uint64_t);
  void (*v18)(uint64_t);
  id v19;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  char *v23;

  v1 = a1;
  v14 = 0;
  v15 = &v14;
  v16 = 0x3032000000;
  v17 = sub_1000315DC;
  v18 = sub_1000315EC;
  v19 = 0;
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_100033F68;
  v13[3] = &unk_100079C70;
  v13[4] = &v14;
  sub_1000352AC((uint64_t)CFSTR("SupplementalsAssets"), v13);
  v2 = (void *)v15[5];
  if (!v2)
    goto LABEL_16;
  v3 = (const char *)objc_msgSend(objc_retainAutorelease(v2), "fileSystemRepresentation");
  if (!sub_100015138())
    goto LABEL_16;
  if (qword_100082C28 != -1)
    dispatch_once(&qword_100082C28, &stru_1000767D0);
  if (byte_100082C20 != 1)
    goto LABEL_14;
  v4 = mkpath_np(v3, 0x1EDu);
  v5 = v4;
  if (v4 && v4 != 17)
  {
    v6 = sub_100011628("SecError");
    v7 = objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = strerror(v5);
      *(_DWORD *)buf = 136315394;
      v21 = v3;
      v22 = 2080;
      v23 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "could not create path: %s (%s)", buf, 0x16u);
    }

  }
  else
  {
    chmod(v3, 0x1EDu);
  }
  if (!v5 || v5 == 17)
  {
LABEL_14:
    v9 = (void *)v15[5];
    if (v1)
      v10 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "URLByAppendingPathComponent:", v1));
    else
      v10 = v9;
    v11 = v10;
  }
  else
  {
LABEL_16:
    v11 = 0;
  }
  _Block_object_dispose(&v14, 8);

  return v11;
}

void sub_10002EF4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  _Unwind_Resume(exception_object);
}

void sub_10002EF6C(int a1, uint64_t *a2, void *a3)
{
  void *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  id v9;

  v9 = a3;
  if (a1 == 4 && a2)
  {
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[TrustAnalytics logger](TrustAnalytics, "logger"));
    v6 = v5;
    v7 = *a2;
    v8 = 1;
LABEL_7:
    objc_msgSend(v5, "logResultForEvent:hardFailure:result:withAttributes:", CFSTR("OTAPKIEvent"), v8, v7, v9);

    goto LABEL_8;
  }
  if (a1 == 3 && a2)
  {
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[TrustAnalytics logger](TrustAnalytics, "logger"));
    v6 = v5;
    v7 = *a2;
    v8 = 0;
    goto LABEL_7;
  }
LABEL_8:

}

uint64_t sub_10002F010()
{
  uint64_t v0;

  if (qword_100082C28 != -1)
    dispatch_once(&qword_100082C28, &stru_1000767D0);
  v0 = byte_100082C20;
  if (byte_100082C20 == 1)
  {
    sub_1000317E0();
    sub_100032140(CFSTR("OTAPKIContext.plist"));
  }
  return v0;
}

id sub_10002F074(void *a1)
{
  id v1;
  __CFBundle *v2;
  CFURLRef v3;
  void *v4;
  const void *v5;
  NSObject *v6;
  int v8;
  id v9;

  v1 = a1;
  v2 = (__CFBundle *)sub_10002CC88();
  if (!v2)
  {
    v4 = 0;
    goto LABEL_10;
  }
  v3 = CFBundleCopyResourcesDirectoryURL(v2);
  if (!v3)
    goto LABEL_7;
  v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL URLWithString:relativeToURL:](NSURL, "URLWithString:relativeToURL:", v1, v3));
  if (!v4)
  {
    v5 = sub_100011628("SecWarning");
    v6 = objc_claimAutoreleasedReturnValue(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v8 = 138412290;
      v9 = v1;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "resource: %@ not found", (uint8_t *)&v8, 0xCu);
    }

LABEL_7:
    v4 = 0;
  }

LABEL_10:
  return v4;
}

unint64_t sub_10002F174(_QWORD *a1)
{
  void *v2;
  unint64_t v3;
  id v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  id v8;
  id v9;
  uint64_t v10;
  char isKindOfClass;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  id v16;
  id v17;
  const void *v18;
  NSObject *v19;
  id v21;
  uint64_t v22;
  id v23;
  id v24;
  id v25;
  uint8_t buf[4];
  id v27;
  __int16 v28;
  unint64_t v29;

  v2 = objc_autoreleasePoolPush();
  v3 = sub_10002F5DC(CFSTR("MobileAssetContentVersion"));
  v4 = sub_10002ED40(CFSTR("OTAPKIContext.plist"));
  v7 = (void *)objc_claimAutoreleasedReturnValue(v4);
  if (!v7)
  {
    v9 = 0;
    v8 = 0;
LABEL_9:
    if (!a1)
    {
LABEL_16:
      sub_1000317E0();
      sub_10003185C(CFSTR("CTKillSwitch"), &off_10007FDA0, 0);
      sub_10003185C(CFSTR("CTKillSwitch_nonTLS"), &off_10007FDA0, 0);
      goto LABEL_17;
    }
    v23 = v9;
    sub_100031190(CFSTR("com.apple.MobileAsset.PKITrustSupplementals"), &v23, 3, NSOSStatusErrorDomain, -67871, CFSTR("OTAContext.plist missing dictionary"), v5, v6, v22);
    v17 = v23;

    v16 = 0;
    v9 = v17;
LABEL_11:
    v18 = sub_100011628("OTATrust");
    v19 = objc_claimAutoreleasedReturnValue(v18);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134218240;
      v27 = v16;
      v28 = 2048;
      v29 = v3;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "asset (%llu) is not newer than the system version (%llu); deleting stale data",
        buf,
        0x16u);
    }

    if (v9)
      CFRetain(v9);
    *a1 = v9;
    goto LABEL_16;
  }
  v25 = 0;
  v8 = (id)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithContentsOfURL:error:](NSDictionary, "dictionaryWithContentsOfURL:error:", v7, &v25));
  v9 = v25;
  if (!v8)
    goto LABEL_9;
  v8 = v8;
  v10 = objc_opt_class(NSDictionary);
  isKindOfClass = objc_opt_isKindOfClass(v8, v10);

  if ((isKindOfClass & 1) == 0)
    goto LABEL_9;
  v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "objectForKeyedSubscript:", CFSTR("MobileAssetContentVersion")));
  if (!v14 || (v15 = objc_opt_class(NSNumber), (objc_opt_isKindOfClass(v14, v15) & 1) == 0))
  {
    if (a1)
    {
      v24 = v9;
      sub_100031190(CFSTR("com.apple.MobileAsset.PKITrustSupplementals"), &v24, 3, NSOSStatusErrorDomain, -67694, CFSTR("OTAContext.plist missing version"), v12, v13, v22);
      v21 = v24;

      v9 = v21;
    }

    v16 = 0;
LABEL_21:
    if (!a1)
      goto LABEL_16;
    goto LABEL_11;
  }
  v16 = objc_msgSend(v14, "unsignedLongLongValue");

  if ((unint64_t)v16 <= v3)
    goto LABEL_21;
  v3 = (unint64_t)v16;
LABEL_17:

  objc_autoreleasePoolPop(v2);
  return v3;
}

void *sub_10002F438()
{
  id v0;
  uint64_t v1;
  uint64_t v2;
  void *v3;
  id v4;
  id v5;
  uint64_t v6;
  char isKindOfClass;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  void *v12;
  id v14;
  uint64_t v15;
  id v16;
  id v17;
  id v18;

  v0 = sub_10002ED40(CFSTR("OTAPKIContext.plist"));
  v3 = (void *)objc_claimAutoreleasedReturnValue(v0);
  if (!v3)
  {
    v5 = 0;
    v4 = 0;
LABEL_8:
    v16 = v5;
    sub_100031190(CFSTR("com.apple.MobileAsset.PKITrustSupplementals"), &v16, 3, NSOSStatusErrorDomain, -67871, CFSTR("OTAContext.plist missing dictionary"), v1, v2, v15);
    v12 = 0;
    v10 = v5;
    v5 = v16;
    goto LABEL_9;
  }
  v18 = 0;
  v4 = (id)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithContentsOfURL:error:](NSDictionary, "dictionaryWithContentsOfURL:error:", v3, &v18));
  v5 = v18;
  if (!v4)
    goto LABEL_8;
  v4 = v4;
  v6 = objc_opt_class(NSDictionary);
  isKindOfClass = objc_opt_isKindOfClass(v4, v6);

  if ((isKindOfClass & 1) == 0)
    goto LABEL_8;
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "objectForKeyedSubscript:", CFSTR("MobileAssetLastCheckIn")));
  if (v10 && (v11 = objc_opt_class(NSDate), (objc_opt_isKindOfClass(v10, v11) & 1) != 0))
  {
    CFRetain(v10);
    v12 = v10;
  }
  else
  {
    v17 = v5;
    sub_100031190(CFSTR("com.apple.MobileAsset.PKITrustSupplementals"), &v17, 3, NSOSStatusErrorDomain, -67694, CFSTR("OTAContext.plist missing check-in"), v8, v9, v15);
    v14 = v17;

    v12 = 0;
    v5 = v14;
  }
LABEL_9:

  return v12;
}

uint64_t sub_10002F5DC(const void *a1)
{
  const __CFData *v2;
  const __CFData *v3;
  CFPropertyListRef v4;
  const void *v5;
  CFTypeID TypeID;
  const __CFNumber *Value;
  uint64_t v8;
  unint64_t v10;
  uint64_t valuePtr;

  valuePtr = 0;
  v2 = sub_10002E6C8(CFSTR("AssetVersion"), CFSTR("plist"));
  if (!v2)
    return 0;
  v3 = v2;
  v10 = 0xAAAAAAAAAAAAAAAALL;
  v4 = CFPropertyListCreateWithData(kCFAllocatorDefault, v2, 0, (CFPropertyListFormat *)&v10, 0);
  if (v4)
  {
    v5 = v4;
    TypeID = CFDictionaryGetTypeID();
    if (TypeID == CFGetTypeID(v5) && (Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v5, a1)) != 0)
    {
      CFNumberGetValue(Value, kCFNumberSInt64Type, &valuePtr);
      v8 = valuePtr;
      if (valuePtr < 0)
      {
        v8 = 0;
        valuePtr = 0;
      }
    }
    else
    {
      v8 = 0;
    }
    CFRelease(v5);
  }
  else
  {
    v8 = 0;
  }
  CFRelease(v3);
  return v8;
}

uint64_t sub_10002F6C8(uint64_t a1, const __CFDictionary **a2, _QWORD *a3, size_t *a4, int a5)
{
  uint64_t result;
  const __CFData *v11;
  const __CFData *v12;
  const __CFURL *v13;
  const void *v14;
  NSObject *v15;
  const __CFURL *v16;
  CFStringRef v17;
  const __CFString *v18;
  char *CStringPtr;
  timespec v20;
  int v21;
  int v22;
  int v23;
  int v24;
  const void *v25;
  NSObject *v26;
  int v27;
  const void *v28;
  NSObject *v29;
  const void *v30;
  NSObject *v31;
  int v32;
  off_t st_size;
  const void *v34;
  NSObject *v35;
  const void *v36;
  NSObject *v37;
  void *v38;
  const void *v39;
  NSObject *v40;
  int v41;
  const void *v42;
  NSObject *v43;
  void *v44;
  const UInt8 *BytePtr;
  CFIndex Length;
  const __CFDictionary *Mutable;
  uint64_t v48;
  CFNumberRef v49;
  CFDataRef v50;
  __CFArray *Value;
  __CFArray *v52;
  void *v53;
  size_t v54;
  const __CFData *cf;
  _QWORD *v56;
  size_t *v57;
  int valuePtr;
  char __b[1024];
  uint8_t v60[4];
  char *v61;
  __int16 v62;
  _BYTE v63[10];
  stat buf;

  result = 0;
  if (a2 && a3)
  {
    *a2 = 0;
    *a3 = 0;
    memset(__b, 170, sizeof(__b));
    valuePtr = 0;
    if (a5)
      v11 = (const __CFData *)sub_10002E500(a1, (uint64_t)CFSTR("certsIndex"), (uint64_t)CFSTR("data"));
    else
      v11 = sub_10002E6C8(CFSTR("certsIndex"), CFSTR("data"));
    v12 = v11;
    if (v11)
    {
      if (a5)
      {
LABEL_8:
        v13 = (const __CFURL *)sub_100033D28(a1, (uint64_t)CFSTR("certsTable"), (uint64_t)CFSTR("data"));
        goto LABEL_13;
      }
    }
    else
    {
      v14 = sub_100011628("SecError");
      v15 = objc_claimAutoreleasedReturnValue(v14);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.st_dev) = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "could not find certsIndex", (uint8_t *)&buf, 2u);
      }

      if (a5)
        goto LABEL_8;
    }
    v13 = sub_10002EB5C(CFSTR("certsTable"), CFSTR("data"));
LABEL_13:
    v16 = v13;
    if (!v13)
    {
      v28 = sub_100011628("SecError");
      v29 = objc_claimAutoreleasedReturnValue(v28);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.st_dev) = 0;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "could not find certsTable", (uint8_t *)&buf, 2u);
      }

      goto LABEL_57;
    }
    v17 = CFURLCopyFileSystemPath(v13, kCFURLPOSIXPathStyle);
    if (!v17)
    {
      CFRelease(v16);
      goto LABEL_57;
    }
    v18 = v17;
    v56 = a3;
    v57 = a4;
    bzero(__b, 0x400uLL);
    CStringPtr = (char *)CFStringGetCStringPtr(v18, 0x8000100u);
    if (CStringPtr || (CStringPtr = __b, CFStringGetCString(v18, __b, 1024, 0x8000100u)))
    {
      v20.tv_sec = 0xAAAAAAAAAAAAAAAALL;
      v20.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
      *(timespec *)&buf.st_blksize = v20;
      *(timespec *)buf.st_qspare = v20;
      buf.st_birthtimespec = v20;
      *(timespec *)&buf.st_size = v20;
      buf.st_mtimespec = v20;
      buf.st_ctimespec = v20;
      *(timespec *)&buf.st_uid = v20;
      buf.st_atimespec = v20;
      *(timespec *)&buf.st_dev = v20;
      v21 = open(CStringPtr, 0);
      if (v21 < 0)
      {
        v30 = sub_100011628("SecError");
        v31 = objc_claimAutoreleasedReturnValue(v30);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
        {
          v32 = *__error();
          *(_DWORD *)v60 = 136315394;
          v61 = CStringPtr;
          v62 = 1024;
          *(_DWORD *)v63 = v32;
          _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "MapFile: unable to open %s (errno %d)", v60, 0x12u);
        }

      }
      else
      {
        v22 = v21;
        v23 = fstat(v21, &buf);
        if (v23)
        {
          v24 = v23;
          v25 = sub_100011628("SecError");
          v26 = objc_claimAutoreleasedReturnValue(v25);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            v27 = *__error();
            *(_DWORD *)v60 = 136315650;
            v61 = CStringPtr;
            v62 = 1024;
            *(_DWORD *)v63 = v24;
            *(_WORD *)&v63[4] = 1024;
            *(_DWORD *)&v63[6] = v27;
            _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "MapFile: fstat of %s returned %d (errno %d)", v60, 0x18u);
          }

        }
        else
        {
          st_size = buf.st_size;
          if (buf.st_size < 0x7FFFFFFF)
          {
            v38 = mmap(0, buf.st_size, 1, 2, v22, 0);
            if ((unint64_t)v38 + 1 > 1)
            {
              v44 = v38;
              close(v22);
LABEL_44:
              CFRelease(v18);
              CFRelease(v16);
              if (v12 && v44)
              {
                v53 = v44;
                v54 = st_size;
                BytePtr = CFDataGetBytePtr(v12);
                cf = v12;
                Length = CFDataGetLength(v12);
                Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                if (Length >= 1)
                {
                  v48 = Length + 24;
                  do
                  {
                    valuePtr = *((_DWORD *)BytePtr + 5);
                    v49 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
                    v50 = CFDataCreate(kCFAllocatorDefault, BytePtr, 20);
                    Value = (__CFArray *)CFDictionaryGetValue(Mutable, v50);
                    v52 = Value;
                    if (!Value)
                      v52 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
                    CFArrayAppendValue(v52, v49);
                    CFDictionarySetValue(Mutable, v50, v52);
                    CFRelease(v49);
                    CFRelease(v50);
                    if (!Value)
                      CFRelease(v52);
                    BytePtr += 24;
                    v48 -= 24;
                  }
                  while (v48 > 24);
                }
                CFRelease(cf);
                if (Mutable)
                {
                  *a2 = Mutable;
                  *v56 = v53;
                  result = 1;
                  *v57 = v54;
                  return result;
                }
                sub_100033E90(v53, v54);
                return 0;
              }
              if (v44)
                sub_100033E90(v44, st_size);
LABEL_57:
              if (v12)
                CFRelease(v12);
              return 0;
            }
            v39 = sub_100011628("SecError");
            v40 = objc_claimAutoreleasedReturnValue(v39);
            if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
            {
              v41 = *__error();
              *(_DWORD *)v60 = 136315394;
              v61 = CStringPtr;
              v62 = 1024;
              *(_DWORD *)v63 = v41;
              _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "MapFile: unable to map %s (errno %d)", v60, 0x12u);
            }

          }
          else
          {
            v34 = sub_100011628("SecError");
            v35 = objc_claimAutoreleasedReturnValue(v34);
            if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)v60 = 136315394;
              v61 = CStringPtr;
              v62 = 2048;
              *(_QWORD *)v63 = buf.st_size;
              _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "MapFile: %s is too large (%lld)", v60, 0x16u);
            }

          }
        }
        close(v22);
      }
    }
    else
    {
      v36 = sub_100011628("SecError");
      v37 = objc_claimAutoreleasedReturnValue(v36);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v60 = 0;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "MapFile: path or out_file_size was NULL", v60, 2u);
      }

    }
    v42 = sub_100011628("SecError");
    v43 = objc_claimAutoreleasedReturnValue(v42);
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      buf.st_dev = 138412290;
      *(_QWORD *)&buf.st_mode = v18;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "InitializeAnchorTable: failed to map file at %@", (uint8_t *)&buf, 0xCu);
    }

    v44 = 0;
    st_size = 0;
    goto LABEL_44;
  }
  return result;
}

const void *sub_10002FD68(uint64_t a1)
{
  const void *v2;
  const void *v3;
  NSObject *v4;
  _QWORD block[5];
  uint8_t buf[16];

  if (!sub_1000150B0())
    return 0;
  if (!*(_QWORD *)(a1 + 208))
  {
    v3 = sub_100011628("SecError");
    v4 = objc_claimAutoreleasedReturnValue(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "SecAssetTrustStoreCopyPath: no autoAssetClient", buf, 2u);
    }

    return 0;
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100033C58;
  block[3] = &unk_1000791F8;
  block[4] = a1;
  if (qword_100082C00 != -1)
    dispatch_once(&qword_100082C00, block);
  v2 = *(const void **)(a1 + 216);
  if (v2)
    CFRetain(v2);
  return v2;
}

id sub_10002FE58(void *a1)
{
  id v1;
  id v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  id v6;
  id v7;
  uint64_t v8;
  char isKindOfClass;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  const void *v14;
  NSObject *v15;
  id v16;
  id v18;
  unsigned int v19;
  uint64_t v20;
  id v21;
  id v22;
  id v23;
  uint8_t buf[4];
  id v25;
  __int16 v26;
  unsigned int v27;

  v1 = a1;
  v2 = sub_10002ED40(CFSTR("OTAPKIContext.plist"));
  v5 = (void *)objc_claimAutoreleasedReturnValue(v2);
  if (!v5)
  {
    v7 = 0;
    v6 = 0;
LABEL_10:
    v21 = v7;
    sub_100031190(CFSTR("com.apple.MobileAsset.PKITrustSupplementals"), &v21, 3, NSOSStatusErrorDomain, -67871, CFSTR("OTAContext.plist missing dictionary"), v3, v4, v20);
    v16 = 0;
    v12 = v7;
    v7 = v21;
    goto LABEL_11;
  }
  v23 = 0;
  v6 = (id)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithContentsOfURL:error:](NSDictionary, "dictionaryWithContentsOfURL:error:", v5, &v23));
  v7 = v23;
  if (!v6)
    goto LABEL_10;
  v6 = v6;
  v8 = objc_opt_class(NSDictionary);
  isKindOfClass = objc_opt_isKindOfClass(v6, v8);

  if ((isKindOfClass & 1) == 0)
    goto LABEL_10;
  v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectForKeyedSubscript:", v1));
  if (v12 && (v13 = objc_opt_class(NSNumber), (objc_opt_isKindOfClass(v12, v13) & 1) != 0))
  {
    v14 = sub_100011628("OTATrust");
    v15 = objc_claimAutoreleasedReturnValue(v14);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      v19 = objc_msgSend(v12, "BOOLValue");
      *(_DWORD *)buf = 138543618;
      v25 = v1;
      v26 = 1024;
      v27 = v19;
      _os_log_debug_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "found on-disk kill switch %{public}@ with value %d", buf, 0x12u);
    }

    v16 = objc_msgSend(v12, "BOOLValue");
  }
  else
  {
    v22 = v7;
    sub_100031190(CFSTR("com.apple.MobileAsset.PKITrustSupplementals"), &v22, 3, NSOSStatusErrorDomain, -67694, CFSTR("OTAContext.plist missing kill switch"), v10, v11, v20);
    v18 = v22;

    v16 = 0;
    v7 = v18;
  }
LABEL_11:

  return v16;
}

void sub_1000300A8(id a1, int a2)
{
  const void *v2;
  NSObject *v3;
  id v4;
  id v5;
  id v6;
  const void *v7;
  NSObject *v8;
  const void *v9;
  NSObject *v10;
  id v11;
  id v12;
  void *v13;
  uint64_t v14;
  void *i;
  void *v16;
  void *v17;
  id v18;
  id v19;
  id v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint8_t v25[128];
  uint8_t buf[4];
  id v27;

  v2 = sub_100011628("OTATrust");
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Got notification about a new SecExperiment asset from system trustd.", buf, 2u);
  }

  v4 = objc_msgSend(objc_alloc((Class)MAAssetQuery), "initWithType:", CFSTR("com.apple.MobileAsset.SecExperimentAssets"));
  objc_msgSend(v4, "returnTypes:", 1);
  v5 = objc_msgSend(v4, "queryMetaDataSync");
  if (v5)
  {
    v6 = v5;
    v7 = sub_100011628("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      v27 = v6;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "OTATrust: failed to update SecExperiment Asset after notification: %ld", buf, 0xCu);
    }
LABEL_18:
    v13 = 0;
    goto LABEL_19;
  }
  v9 = sub_100011628("OTATrust");
  v10 = objc_claimAutoreleasedReturnValue(v9);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Updated SecExperiment asset successfully", buf, 2u);
  }

  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v8 = objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "results"));
  v11 = -[NSObject countByEnumeratingWithState:objects:count:](v8, "countByEnumeratingWithState:objects:count:", &v21, v25, 16);
  if (!v11)
    goto LABEL_18;
  v12 = v11;
  v13 = 0;
  v14 = *(_QWORD *)v22;
  do
  {
    for (i = 0; i != v12; i = (char *)i + 1)
    {
      if (*(_QWORD *)v22 != v14)
        objc_enumerationMutation(v8);
      v16 = *(void **)(*((_QWORD *)&v21 + 1) + 8 * (_QWORD)i);
      v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "assetProperty:", CFSTR("_ContentVersion")));
      if (sub_100030344(CFSTR("com.apple.MobileAsset.SecExperimentAssets"), v16))
      {
        v20 = v13;
        v18 = sub_1000306B8(CFSTR("com.apple.MobileAsset.SecExperimentAssets"), v16, v17, (uint64_t *)&v20);
        v19 = v20;

        v13 = v19;
      }

    }
    v12 = -[NSObject countByEnumeratingWithState:objects:count:](v8, "countByEnumeratingWithState:objects:count:", &v21, v25, 16);
  }
  while (v12);
LABEL_19:

}

uint64_t sub_100030344(void *a1, void *a2)
{
  id v3;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  void *v10;
  id v11;
  id v12;
  uint64_t v13;
  uint64_t v14;
  id v15;
  uint64_t v16;
  uint64_t v18;
  CFTypeRef v19;
  uint64_t v20;
  uint64_t v21;
  id v22;
  NSNumber *v23;
  void *v24;
  NSNumber *v25;
  void *v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  id v33;
  id v34;
  id v35;
  id v36;
  id v37;
  CFTypeRef cf;
  _QWORD v39[3];
  _QWORD v40[3];

  v3 = a1;
  v4 = a2;
  if (objc_msgSend(v3, "isEqualToString:", CFSTR("com.apple.MobileAsset.PKITrustSupplementals")))
    v5 = 2;
  else
    v5 = 1;
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "assetProperty:", CFSTR("_CompatibilityVersion")));
  if (v8)
  {
    v9 = objc_opt_class(NSNumber);
    if ((objc_opt_isKindOfClass(v8, v9) & 1) != 0 && objc_msgSend(v8, "unsignedIntegerValue") == (id)v5)
    {
      v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "assetProperty:", CFSTR("_ContentVersion")));
      v11 = v3;
      v12 = v10;
      v13 = objc_opt_class(NSNumber);
      if ((objc_opt_isKindOfClass(v12, v13) & 1) != 0)
      {
        cf = 0;
        if (objc_msgSend(v11, "isEqualToString:", CFSTR("com.apple.MobileAsset.PKITrustSupplementals")))
        {
          v14 = sub_10003224C((__CFString **)&cf);
        }
        else
        {
          if (!objc_msgSend(v11, "isEqualToString:", CFSTR("com.apple.MobileAsset.SecExperimentAssets")))
            goto LABEL_16;
          v14 = sub_100032298((__CFString **)&cf);
        }
        v18 = v14;
        v19 = cf;
        if (!cf)
        {
          v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v18));
          v33 = objc_msgSend(v12, "compare:", v32);

          if (v33 == (id)1)
          {
            v15 = 0;
            v16 = 1;
LABEL_23:

            goto LABEL_11;
          }
LABEL_17:
          if (objc_msgSend(v11, "isEqualToString:", CFSTR("com.apple.MobileAsset.PKITrustSupplementals")))
          {
            v36 = 0;
            if (sub_10003185C(CFSTR("MobileAssetContentVersion"), v12, (uint64_t *)&v36))
              sub_100031A34();
            v22 = v36;
            v40[0] = v12;
            v39[0] = CFSTR("assetVersion");
            v39[1] = CFSTR("systemVersion");
            v23 = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", sub_10002F5DC(CFSTR("MobileAssetContentVersion")));
            v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
            v40[1] = v24;
            v39[2] = CFSTR("installedVersion");
            v25 = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", sub_10003224C(0));
            v26 = (void *)objc_claimAutoreleasedReturnValue(v25);
            v40[2] = v26;
            v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v40, v39, 3));

            v35 = v22;
            sub_1000322E4(v11, &v35, v28, NSOSStatusErrorDomain, v29, v27, v30, v31, (uint64_t)v11);
            v15 = v35;

          }
          else
          {
            v34 = 0;
            sub_100031190(v11, &v34, 3, NSOSStatusErrorDomain, -25299, CFSTR("skipping asset %@ because we already have _ContentVersion %@ (or newer)"), v20, v21, (uint64_t)v11);
            v15 = v34;
          }
          v16 = 0;
          goto LABEL_23;
        }
        cf = 0;
        CFRelease(v19);
      }
LABEL_16:

      goto LABEL_17;
    }
  }
  v37 = 0;
  sub_100031190(v3, &v37, 3, NSOSStatusErrorDomain, -67704, CFSTR("skipping asset %@ because Compatibility Version doesn't match %@"), v6, v7, (uint64_t)v3);
  v15 = v37;
  v16 = 0;
LABEL_11:

  return v16;
}

id sub_1000306B8(void *a1, void *a2, void *a3, uint64_t *a4)
{
  id v7;
  id v8;
  id v9;
  id v10;
  id v11;
  id v12;
  unsigned __int8 v13;
  void *v14;
  int v15;
  const void *v16;
  NSObject *v17;
  void *v18;
  id v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  id v23;
  void *v24;
  void *v25;
  void *v26;
  NSObject *v27;
  uint64_t v28;
  uint64_t v29;
  const void *v31;
  NSObject *v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  __int128 buf;
  void (*v37)(uint64_t);
  void *v38;
  id v39;
  id v40;

  v7 = a1;
  v8 = a2;
  v9 = a3;
  if (objc_msgSend(v7, "isEqualToString:", CFSTR("com.apple.MobileAsset.PKITrustSupplementals")))
  {
    v10 = v8;
    v11 = v9;
    v12 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "getLocalFileUrl"));
    if ((sub_100015138() & 1) != 0)
    {
      if (qword_100082DD0 != -1)
        dispatch_once(&qword_100082DD0, &stru_100077C70);
      v13 = objc_msgSend((id)qword_100082DC8, "installDbFromURL:error:", v12, a4);

      if ((v13 & 1) != 0)
      {
        v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "getLocalFileUrl"));
        v15 = sub_100030A98(v14, v11, a4);

        if (v15)
        {
          v16 = sub_100011628("OTATrust");
          v17 = objc_claimAutoreleasedReturnValue(v16);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 138412290;
            *(_QWORD *)((char *)&buf + 4) = v11;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "finished update to version %@ from installed asset. purging asset.", (uint8_t *)&buf, 0xCu);
          }

          v18 = (void *)objc_claimAutoreleasedReturnValue(+[TrustAnalytics logger](TrustAnalytics, "logger"));
          objc_msgSend(v18, "logSuccessForEventNamed:", CFSTR("OTAPKIEvent"));

          objc_msgSend(v10, "purge:", &stru_1000766D8);
          v19 = v11;
          goto LABEL_21;
        }
        goto LABEL_17;
      }
    }
    else
    {

    }
LABEL_17:
    v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "getLocalFileUrl"));
    sub_100031190(CFSTR("com.apple.MobileAsset.PKITrustSupplementals"), a4, 4, NSOSStatusErrorDomain, -67695, CFSTR("Failed to install new asset version %@ from %@"), v28, v29, (uint64_t)v11);

LABEL_20:
    v19 = 0;
LABEL_21:

    goto LABEL_22;
  }
  if (objc_msgSend(v7, "isEqualToString:", CFSTR("com.apple.MobileAsset.SecExperimentAssets")))
  {
    v10 = v9;
    v20 = objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "getLocalFileUrl"));
    v11 = (id)v20;
    if (v10 && v20)
    {
      v23 = objc_msgSend(v10, "unsignedLongLongValue");
      v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "URLByAppendingPathComponent:", CFSTR("SecExperimentAssets.plist")));
      v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithContentsOfURL:error:](NSDictionary, "dictionaryWithContentsOfURL:error:", v24, a4));
      v26 = v25;
      if (v25)
      {
        v27 = qword_100082BC8;
        *(_QWORD *)&buf = _NSConcreteStackBlock;
        *((_QWORD *)&buf + 1) = 3221225472;
        v37 = sub_1000311C0;
        v38 = &unk_100076700;
        v40 = v23;
        v39 = v25;
        dispatch_sync(v27, &buf);
        notify_post("com.apple.trustd.secexperiment.asset-updated");
        v19 = v10;

      }
      else
      {
        v31 = sub_100011628("SecError");
        v32 = objc_claimAutoreleasedReturnValue(v31);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
        {
          if (a4)
            v33 = *a4;
          else
            v33 = 0;
          LODWORD(buf) = 138412290;
          *(_QWORD *)((char *)&buf + 4) = v33;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "OTATrust: unable to create SecExperiment from asset file: %@", (uint8_t *)&buf, 0xCu);
        }

        v19 = 0;
      }

      goto LABEL_21;
    }
    sub_100031190(CFSTR("com.apple.MobileAsset.SecExperimentAssets"), a4, 4, NSOSStatusErrorDomain, -26276, CFSTR("missing url and version for downloaded SecExperiment asset"), v21, v22, v34);
    goto LABEL_20;
  }
  v19 = 0;
LABEL_22:

  return v19;
}

uint64_t sub_100030A98(void *a1, void *a2, uint64_t *a3)
{
  id v5;
  id v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;
  uint64_t v11;
  void *v12;
  void *v13;
  uint64_t v14;
  void *v15;
  void *v16;
  uint64_t v17;
  void *v18;
  void *v19;
  uint64_t v20;
  void *v21;
  void *v22;
  uint64_t v23;
  const void *v24;
  NSObject *v25;
  uint64_t v26;
  const void *v27;
  NSObject *v28;
  uint64_t v29;
  const void *v30;
  NSObject *v31;
  uint64_t v32;
  const void *v33;
  NSObject *v34;
  uint64_t v35;
  uint64_t v37;
  _QWORD block[9];
  uint64_t v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t (*v42)(uint64_t, uint64_t);
  void (*v43)(uint64_t);
  id v44;
  uint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t (*v48)(uint64_t, uint64_t);
  void (*v49)(uint64_t);
  id v50;
  _QWORD v51[3];
  id v52;
  uint64_t v53;
  uint64_t *v54;
  uint64_t v55;
  uint64_t (*v56)(uint64_t, uint64_t);
  void (*v57)(uint64_t);
  id v58;
  uint64_t v59;
  uint64_t *v60;
  uint64_t v61;
  uint64_t (*v62)(uint64_t, uint64_t);
  void (*v63)(uint64_t);
  id v64;
  uint8_t buf[4];
  uint64_t v66;

  v5 = a1;
  v6 = a2;
  v9 = v6;
  if (v5 && v6)
  {
    v59 = 0;
    v60 = &v59;
    v61 = 0x3032000000;
    v62 = sub_1000315DC;
    v63 = sub_1000315EC;
    v64 = 0;
    v53 = 0;
    v54 = &v53;
    v55 = 0x3032000000;
    v56 = sub_1000315DC;
    v57 = sub_1000315EC;
    v58 = 0;
    v51[0] = 0;
    v51[1] = v51;
    v51[2] = 0x2020000000;
    v52 = (id)0xAAAAAAAAAAAAAAAALL;
    v52 = objc_msgSend(v6, "unsignedLongLongValue");
    v45 = 0;
    v46 = &v45;
    v47 = 0x3032000000;
    v48 = sub_1000315DC;
    v49 = sub_1000315EC;
    v50 = 0;
    v39 = 0;
    v40 = &v39;
    v41 = 0x3032000000;
    v42 = sub_1000315DC;
    v43 = sub_1000315EC;
    v44 = 0;
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "URLByAppendingPathComponent:", CFSTR("TrustedCTLogs.plist")));
    v11 = objc_claimAutoreleasedReturnValue(+[NSArray arrayWithContentsOfURL:error:](NSArray, "arrayWithContentsOfURL:error:", v10, a3));
    v12 = (void *)v60[5];
    v60[5] = v11;

    if (!v60[5])
    {
      v24 = sub_100011628("SecError");
      v25 = objc_claimAutoreleasedReturnValue(v24);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        if (a3)
          v26 = *a3;
        else
          v26 = 0;
        *(_DWORD *)buf = 138412290;
        v66 = v26;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "OTATrust: unable to create TrustedCTLogs from asset file: %@", buf, 0xCu);
      }

      sub_10002EF6C(4, a3, 0);
      v23 = 0;
      goto LABEL_49;
    }
    v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "URLByAppendingPathComponent:", CFSTR("TrustedCTLogs_nonTLS.plist")));
    v14 = objc_claimAutoreleasedReturnValue(+[NSArray arrayWithContentsOfURL:error:](NSArray, "arrayWithContentsOfURL:error:", v13, a3));
    v15 = (void *)v54[5];
    v54[5] = v14;

    if (!v54[5])
    {
      v27 = sub_100011628("SecError");
      v28 = objc_claimAutoreleasedReturnValue(v27);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        if (a3)
          v29 = *a3;
        else
          v29 = 0;
        *(_DWORD *)buf = 138412290;
        v66 = v29;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "OTATrust: unable to create TrustedCTLogs_nonTLS from asset file: %@", buf, 0xCu);
      }

      sub_10002EF6C(4, a3, 0);
      v23 = 0;
      goto LABEL_48;
    }
    v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "URLByAppendingPathComponent:", CFSTR("AnalyticsSamplingRates.plist")));
    v17 = objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithContentsOfURL:error:](NSDictionary, "dictionaryWithContentsOfURL:error:", v16, a3));
    v18 = (void *)v46[5];
    v46[5] = v17;

    if (!v46[5])
    {
      v30 = sub_100011628("SecError");
      v31 = objc_claimAutoreleasedReturnValue(v30);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        if (a3)
          v32 = *a3;
        else
          v32 = 0;
        *(_DWORD *)buf = 138412290;
        v66 = v32;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "OTATrust: unable to create AnalyticsSamplingRates from asset file: %@", buf, 0xCu);
      }

      sub_10002EF6C(4, a3, 0);
      v23 = 0;
      goto LABEL_47;
    }
    v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "URLByAppendingPathComponent:", CFSTR("AppleCertificateAuthorities.plist")));
    v20 = objc_claimAutoreleasedReturnValue(+[NSArray arrayWithContentsOfURL:error:](NSArray, "arrayWithContentsOfURL:error:", v19, a3));
    v21 = (void *)v40[5];
    v40[5] = v20;

    if (v40[5])
    {
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_1000315F4;
      block[3] = &unk_100076728;
      block[4] = v51;
      block[5] = &v59;
      block[6] = &v53;
      block[7] = &v45;
      block[8] = &v39;
      dispatch_sync((dispatch_queue_t)qword_100082BC8, block);
      if (qword_100082C28 != -1)
        dispatch_once(&qword_100082C28, &stru_1000767D0);
      if (byte_100082C20 != 1)
        goto LABEL_19;
      sub_1000317E0();
      if (sub_10003185C(CFSTR("MobileAssetContentVersion"), &off_10007FDA0, 0))
        sub_100031A34();
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate dateWithTimeIntervalSince1970:](NSDate, "dateWithTimeIntervalSince1970:", 0.0));
      sub_10003185C(CFSTR("MobileAssetLastCheckIn"), v22, 0);

      if (sub_100031C74(CFSTR("TrustedCTLogs.plist"), v10, a3)
        && sub_100031C74(CFSTR("TrustedCTLogs_nonTLS.plist"), v13, a3)
        && sub_100031C74(CFSTR("AnalyticsSamplingRates.plist"), v16, a3)
        && sub_100031C74(CFSTR("AppleCertificateAuthorities.plist"), v19, a3)
        && sub_10003185C(CFSTR("MobileAssetContentVersion"), v9, a3)
        && sub_100031A34())
      {
        notify_post("com.apple.trustd.asset-updated");
LABEL_19:
        v23 = 1;
LABEL_46:

LABEL_47:
LABEL_48:

LABEL_49:
        _Block_object_dispose(&v39, 8);

        _Block_object_dispose(&v45, 8);
        _Block_object_dispose(v51, 8);
        _Block_object_dispose(&v53, 8);

        _Block_object_dispose(&v59, 8);
        goto LABEL_50;
      }
    }
    else
    {
      v33 = sub_100011628("SecError");
      v34 = objc_claimAutoreleasedReturnValue(v33);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        if (a3)
          v35 = *a3;
        else
          v35 = 0;
        *(_DWORD *)buf = 138412290;
        v66 = v35;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "OTATrust: unable to create AppleCAs from asset file: %@", buf, 0xCu);
      }

      sub_10002EF6C(4, a3, 0);
    }
    v23 = 0;
    goto LABEL_46;
  }
  sub_100031190(CFSTR("com.apple.MobileAsset.PKITrustSupplementals"), a3, 4, NSOSStatusErrorDomain, -26276, CFSTR("missing url and version for downloaded asset"), v7, v8, v37);
  v23 = 0;
LABEL_50:

  return v23;
}

void sub_10003112C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  uint64_t v35;

  _Block_object_dispose(&a19, 8);
  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a35, 8);
  _Block_object_dispose((const void *)(v35 - 176), 8);
  _Unwind_Resume(a1);
}

void sub_100031190(void *a1, _QWORD *a2, int a3, void *a4, int a5, void *a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1000312C8(a1, a2, a3, a4, a5, 0, a6, (uint64_t)&a9);
}

void sub_1000311C0(uint64_t a1)
{
  const void *v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const void *v7;
  const void *v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  uint64_t v12;

  v2 = sub_100011628("OTATrust");
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = *(_QWORD *)(qword_100082BF0 + 192);
    v5 = *(_QWORD *)(a1 + 40);
    v9 = 134218240;
    v10 = v4;
    v11 = 2048;
    v12 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "updating SecExperiment asset version from %llu to %llu", (uint8_t *)&v9, 0x16u);
  }

  v6 = qword_100082BF0;
  v7 = *(const void **)(a1 + 32);
  v8 = *(const void **)(qword_100082BF0 + 184);
  if (v8 != v7)
  {
    if (!v7 || (CFRetain(*(CFTypeRef *)(a1 + 32)), (v8 = *(const void **)(v6 + 184)) != 0))
      CFRelease(v8);
    *(_QWORD *)(v6 + 184) = v7;
    v6 = qword_100082BF0;
  }
  *(_QWORD *)(v6 + 192) = *(_QWORD *)(a1 + 40);
}

void sub_1000312C8(void *a1, _QWORD *a2, int a3, void *a4, int a5, void *a6, void *a7, uint64_t a8)
{
  id v15;
  id v16;
  id v17;
  id v18;
  id v19;
  id v20;
  void *v21;
  id v22;
  const void *v23;
  NSObject *v24;
  const char *v25;
  const void *v26;
  id v27;
  id v28;
  uint8_t buf[4];
  id v30;

  v15 = a1;
  v16 = a4;
  v17 = a6;
  v18 = a7;
  if (v18)
  {
    v19 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:arguments:", v18, a8);
    v20 = objc_alloc_init((Class)NSMutableDictionary);
    objc_msgSend(v20, "setObject:forKey:", v19, NSLocalizedDescriptionKey);
    if (!a2)
      goto LABEL_7;
  }
  else
  {
    v20 = objc_alloc_init((Class)NSMutableDictionary);
    v19 = 0;
    if (!a2)
      goto LABEL_7;
  }
  if (*a2)
    objc_msgSend(v20, "setObject:forKeyedSubscript:", *a2, NSUnderlyingErrorKey);
LABEL_7:
  v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", v16, a5, v20));
  v22 = v19;
  if (a3 == 4)
  {
    v26 = sub_100011628("SecError");
    v24 = objc_claimAutoreleasedReturnValue(v26);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v30 = v22;
      v25 = "OTATrust: %@";
      goto LABEL_13;
    }
  }
  else
  {
    if (a3 != 3)
      goto LABEL_15;
    v23 = sub_100011628("OTATrust");
    v24 = objc_claimAutoreleasedReturnValue(v23);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v30 = v22;
      v25 = "%@";
LABEL_13:
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, v25, buf, 0xCu);
    }
  }

LABEL_15:
  if (objc_msgSend(v15, "isEqualToString:", CFSTR("com.apple.MobileAsset.PKITrustSupplementals")))
  {
    v28 = v21;
    sub_10002EF6C(a3, (uint64_t *)&v28, v17);
    v27 = v28;

    v21 = v27;
  }
  if (a2)
    *a2 = objc_retainAutorelease(v21);

}

void sub_100031530(id a1, int64_t a2)
{
  const void *v3;
  NSObject *v4;
  int v5;
  int64_t v6;

  if (a2)
  {
    v3 = sub_100011628("SecError");
    v4 = objc_claimAutoreleasedReturnValue(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5 = 134217984;
      v6 = a2;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "OTATrust: purge failed: %ld", (uint8_t *)&v5, 0xCu);
    }

  }
}

uint64_t sub_1000315DC(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_1000315EC(uint64_t a1)
{

}

id sub_1000315F4(_QWORD *a1)
{
  const void *v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  id v7;
  id v8;
  uint64_t v9;
  id v10;
  id v11;
  _QWORD *v12;
  uint64_t v13;
  const void *v14;
  const void *v15;
  uint64_t v16;
  const void *v17;
  const void *v18;
  int v20;
  uint64_t v21;
  __int16 v22;
  uint64_t v23;

  v2 = sub_100011628("OTATrust");
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = *(_QWORD *)(qword_100082BF0 + 152);
    v5 = *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
    v20 = 134218240;
    v21 = v4;
    v22 = 2048;
    v23 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "updating asset version from %llu to %llu", (uint8_t *)&v20, 0x16u);
  }

  v6 = qword_100082BF0;
  v7 = sub_10002CD90(*(void **)(*(_QWORD *)(a1[5] + 8) + 40));
  v8 = *(id *)(v6 + 40);
  if (v8 != v7)
  {
    if (!v7 || (CFRetain(v7), (v8 = *(id *)(v6 + 40)) != 0))
      CFRelease(v8);
    *(_QWORD *)(v6 + 40) = v7;
  }
  v9 = qword_100082BF0;
  if (*(_QWORD *)(qword_100082BF0 + 48))
  {
    v10 = sub_10002CD90(*(void **)(*(_QWORD *)(a1[6] + 8) + 40));
    v11 = *(id *)(v9 + 48);
    if (v11 != v10)
    {
      if (!v10 || (CFRetain(v10), (v11 = *(id *)(v9 + 48)) != 0))
        CFRelease(v11);
      *(_QWORD *)(v9 + 48) = v10;
    }
  }
  v12 = (_QWORD *)qword_100082BF0;
  v13 = *(_QWORD *)(a1[7] + 8);
  v14 = *(const void **)(v13 + 40);
  v15 = *(const void **)(qword_100082BF0 + 168);
  if (v15 != v14)
  {
    if (!v14 || (CFRetain(*(CFTypeRef *)(v13 + 40)), (v15 = (const void *)v12[21]) != 0))
      CFRelease(v15);
    v12[21] = v14;
    v12 = (_QWORD *)qword_100082BF0;
  }
  v16 = *(_QWORD *)(a1[8] + 8);
  v17 = *(const void **)(v16 + 40);
  v18 = (const void *)v12[22];
  if (v18 != v17)
  {
    if (!v17 || (CFRetain(*(CFTypeRef *)(v16 + 40)), (v18 = (const void *)v12[22]) != 0))
      CFRelease(v18);
    v12[22] = v17;
    v12 = (_QWORD *)qword_100082BF0;
  }
  v12[19] = *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
  return sub_100032020();
}

void sub_1000317E0()
{
  if (qword_100082C28 != -1)
    dispatch_once(&qword_100082C28, &stru_1000767D0);
  if (byte_100082C20 == 1)
  {
    sub_100032140(CFSTR("TrustedCTLogs.plist"));
    sub_100032140(CFSTR("TrustedCTLogs_nonTLS.plist"));
    sub_100032140(CFSTR("AnalyticsSamplingRates.plist"));
    sub_100032140(CFSTR("AppleCertificateAuthorities.plist"));
  }
}

id sub_10003185C(void *a1, void *a2, uint64_t *a3)
{
  id v5;
  id v6;
  id v7;
  void *v8;
  void *v9;
  void *v10;
  id v11;
  id v12;
  void *v13;
  const void *v14;
  NSObject *v15;
  uint64_t v16;
  int v18;
  uint64_t v19;

  v5 = a1;
  v6 = a2;
  if (qword_100082C28 != -1)
    dispatch_once(&qword_100082C28, &stru_1000767D0);
  if (byte_100082C20 == 1 && sub_100015138())
  {
    v7 = sub_10002ED40(CFSTR("OTAPKIContext.plist"));
    v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    if (v8)
    {
      v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithContentsOfURL:](NSDictionary, "dictionaryWithContentsOfURL:", v8));
      v10 = v9;
      if (v9)
        v11 = objc_msgSend(v9, "mutableCopy");
      else
        v11 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
      v13 = v11;
      objc_msgSend(v11, "setObject:forKeyedSubscript:", v6, v5);
      v12 = objc_msgSend(v13, "writeToClassDURL:permissions:error:", v8, 420, a3);
      if ((v12 & 1) == 0)
      {
        v14 = sub_100011628("SecError");
        v15 = objc_claimAutoreleasedReturnValue(v14);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          if (a3)
            v16 = *a3;
          else
            v16 = 0;
          v18 = 138412290;
          v19 = v16;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "OTATrust: unable to write OTA Context to disk: %@", (uint8_t *)&v18, 0xCu);
        }

        sub_10002EF6C(4, a3, 0);
      }

    }
    else
    {
      v12 = 0;
    }

  }
  else
  {
    v12 = 0;
  }

  return v12;
}

unint64_t sub_100031A34()
{
  void *v0;
  unint64_t v1;
  id v2;
  const void *v3;
  NSObject *v4;
  _QWORD v6[5];
  id v7;
  _QWORD block[5];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t (*v12)(uint64_t, uint64_t);
  void (*v13)(uint64_t);
  id v14;
  uint8_t buf[4];
  id v16;

  if (qword_100082C28 != -1)
    dispatch_once(&qword_100082C28, &stru_1000767D0);
  if (byte_100082C20 == 1)
  {
    v9 = 0;
    v10 = &v9;
    v11 = 0x3032000000;
    v12 = sub_1000315DC;
    v13 = sub_1000315EC;
    v14 = 0;
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100031FAC;
    block[3] = &unk_100077360;
    block[4] = &v9;
    dispatch_sync((dispatch_queue_t)qword_100082BC8, block);
    v0 = (void *)v10[5];
    v7 = 0;
    v1 = (unint64_t)sub_10003185C(CFSTR("MobileAssetLastCheckIn"), v0, (uint64_t *)&v7);
    v2 = v7;
    if ((v1 & 1) == 0)
    {
      v3 = sub_100011628("SecError");
      v4 = objc_claimAutoreleasedReturnValue(v3);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v16 = v2;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "OTATrust: failed to write last check-in time: %@", buf, 0xCu);
      }

    }
    notify_post("com.apple.trustd.asset-check-in");

    _Block_object_dispose(&v9, 8);
  }
  else
  {
    v9 = 0;
    v10 = &v9;
    v11 = 0x2020000000;
    LOBYTE(v12) = 0;
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    v6[2] = sub_100031FE0;
    v6[3] = &unk_100077360;
    v6[4] = &v9;
    dispatch_sync((dispatch_queue_t)qword_100082BC8, v6);
    v1 = *((_BYTE *)v10 + 24) != 0;
    _Block_object_dispose(&v9, 8);
  }
  return v1;
}

void sub_100031C54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_100031C74(void *a1, void *a2, _QWORD *a3)
{
  id v5;
  id v6;
  id v7;
  void *v8;
  _copyfile_state *v9;
  const char *v10;
  id v11;
  id v12;
  const char *v13;
  int v14;
  const void *v15;
  NSObject *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  _BOOL8 v20;
  int v21;
  uint64_t v22;
  int *v23;
  uint64_t v24;
  uint64_t v25;
  int v27;
  int v28;
  int v29;
  int v30;
  uint64_t v31;
  int *v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  int *v37;
  uint64_t v38;
  uint64_t v39;
  uint8_t buf[4];
  const char *v41;
  __int16 v42;
  char *v43;

  v5 = a1;
  v6 = a2;
  if (qword_100082C28 != -1)
    dispatch_once(&qword_100082C28, &stru_1000767D0);
  if (byte_100082C20 == 1 && sub_100015138())
  {
    v7 = sub_10002ED40(v5);
    v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    v9 = copyfile_state_alloc();
    v10 = (const char *)objc_msgSend(objc_retainAutorelease(v6), "fileSystemRepresentation");
    v11 = objc_retainAutorelease(v8);
    LODWORD(v10) = copyfile(v10, (const char *)objc_msgSend(v11, "fileSystemRepresentation"), v9, 8u);
    copyfile_state_free(v9);
    if ((v10 & 0x80000000) != 0)
    {
      v21 = *__error();
      v22 = *__error();
      v23 = __error();
      strerror(*v23);
      sub_100031190(CFSTR("com.apple.MobileAsset.PKITrustSupplementals"), a3, 4, NSPOSIXErrorDomain, v21, CFSTR("copyfile error for asset %d: %s"), v24, v25, v22);
    }
    else
    {
      v12 = objc_retainAutorelease(v11);
      v13 = (const char *)objc_msgSend(v12, "fileSystemRepresentation");
      if (chmod(v13, 0x1A4u))
      {
        v14 = *__error();
        v15 = sub_100011628("SecError");
        v16 = objc_claimAutoreleasedReturnValue(v15);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315394;
          v41 = v13;
          v42 = 2080;
          v43 = strerror(v14);
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "failed to change permissions of %s: %s", buf, 0x16u);
        }

        v17 = *__error();
        strerror(v14);
        sub_100031190(CFSTR("com.apple.MobileAsset.PKITrustSupplementals"), a3, 4, NSPOSIXErrorDomain, v17, CFSTR("failed to change permissions of %s: %s"), v18, v19, (uint64_t)v13);
      }
      else
      {
        v27 = open((const char *)objc_msgSend(objc_retainAutorelease(v12), "fileSystemRepresentation"), 0);
        if (v27)
        {
          v28 = v27;
          v29 = fcntl(v27, 64, 4);
          v20 = v29 >= 0;
          if (v29 < 0)
          {
            v30 = *__error();
            v31 = *__error();
            v32 = __error();
            strerror(*v32);
            sub_100031190(CFSTR("com.apple.MobileAsset.PKITrustSupplementals"), a3, 4, NSPOSIXErrorDomain, v30, CFSTR("set proteciton class error for asset %d: %s"), v33, v34, v31);
          }
          close(v28);
          goto LABEL_13;
        }
        v35 = *__error();
        v36 = *__error();
        v37 = __error();
        strerror(*v37);
        sub_100031190(CFSTR("com.apple.MobileAsset.PKITrustSupplementals"), a3, 4, NSPOSIXErrorDomain, v35, CFSTR("open error for asset %d: %s"), v38, v39, v36);
      }
    }
    v20 = 0;
LABEL_13:

    goto LABEL_14;
  }
  v20 = 0;
LABEL_14:

  return v20;
}

void sub_100031FAC(uint64_t a1)
{
  id v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;

  v2 = sub_100032020();
  v3 = objc_claimAutoreleasedReturnValue(v2);
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v5 = *(void **)(v4 + 40);
  *(_QWORD *)(v4 + 40) = v3;

}

void sub_100031FE0(uint64_t a1)
{
  id v2;
  void *v3;

  v2 = sub_100032020();
  v3 = (void *)objc_claimAutoreleasedReturnValue(v2);

  if (v3)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
}

id sub_100032020()
{
  void *v0;
  uint64_t v1;
  const void *v2;
  const void *v3;
  CFTypeRef *v4;

  dispatch_assert_queue_V2((dispatch_queue_t)qword_100082BC8);
  if (qword_100082C28 != -1)
    dispatch_once(&qword_100082C28, &stru_1000767D0);
  if (byte_100082C20 != 1)
  {
    v0 = sub_10002F438();
    if (sub_10002F174(0) == *(_QWORD *)(qword_100082BF0 + 152))
    {
      v4 = (CFTypeRef *)(qword_100082BF0 + 160);
      v3 = *(const void **)(qword_100082BF0 + 160);
      if (v3 == v0)
        return v0;
      if (v0)
      {
        CFRetain(v0);
        if (*v4)
          CFRelease(*v4);
        goto LABEL_16;
      }
    }
    else
    {

      v4 = (CFTypeRef *)(qword_100082BF0 + 160);
      v3 = *(const void **)(qword_100082BF0 + 160);
      if (!v3)
      {
        v0 = 0;
        return v0;
      }
    }
    CFRelease(v3);
    v0 = 0;
LABEL_16:
    *v4 = v0;
    return v0;
  }
  v0 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](NSDate, "date"));
  v1 = qword_100082BF0;
  v2 = *(const void **)(qword_100082BF0 + 160);
  if (v2 != v0)
  {
    if (!v0 || (CFRetain(v0), (v2 = *(const void **)(v1 + 160)) != 0))
      CFRelease(v2);
    *(_QWORD *)(v1 + 160) = v0;
  }
  return v0;
}

void sub_100032140(void *a1)
{
  id v1;
  id v2;
  id v3;
  const std::__fs::filesystem::path *v4;
  std::error_code *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  id v10;
  __int16 v11;
  char *v12;

  v1 = a1;
  if (sub_100015138())
  {
    v2 = sub_10002ED40(v1);
    v3 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(v2));
    v4 = (const std::__fs::filesystem::path *)objc_msgSend(v3, "fileSystemRepresentation");
    if (remove(v4, v5) == -1)
    {
      v6 = *__error();
      if (v6 != 2)
      {
        v7 = sub_100011628("OTATrust");
        v8 = objc_claimAutoreleasedReturnValue(v7);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          v9 = 138412546;
          v10 = v3;
          v11 = 2080;
          v12 = strerror(v6);
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "failed to remove %@: %s", (uint8_t *)&v9, 0x16u);
        }

      }
    }

  }
}

uint64_t sub_10003224C(__CFString **a1)
{
  _QWORD *v2;
  uint64_t v3;

  v2 = (_QWORD *)sub_100004464();
  if (v2)
  {
    v3 = v2[19];
    CFRelease(v2);
  }
  else
  {
    sub_100012C88(-26276, a1, CFSTR("Unable to get the current OTAPKIRef"));
    return 0;
  }
  return v3;
}

uint64_t sub_100032298(__CFString **a1)
{
  _QWORD *v2;
  uint64_t v3;

  v2 = (_QWORD *)sub_100004464();
  if (v2)
  {
    v3 = v2[24];
    CFRelease(v2);
  }
  else
  {
    sub_100012C88(-26276, a1, CFSTR("Unable to get the current OTAPKIRef"));
    return 0;
  }
  return v3;
}

void sub_1000322E4(void *a1, _QWORD *a2, uint64_t a3, void *a4, uint64_t a5, void *a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1000312C8(a1, a2, 3, a4, -25299, a6, CFSTR("skipping asset %@ because we already have _ContentVersion %@ (or newer)"), (uint64_t)&a9);
}

void sub_10003231C(id a1)
{
  const void *v1;
  NSObject *v2;
  uint8_t v3[16];

  v1 = sub_100011628("OTATrust");
  v2 = objc_claimAutoreleasedReturnValue(v1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Initial check with MobileAsset for newer SecExperiment asset", v3, 2u);
  }

  sub_10003239C(0, CFSTR("com.apple.MobileAsset.SecExperimentAssets"), 0);
}

BOOL sub_10003239C(_BOOL8 a1, void *a2, _QWORD *a3)
{
  id v5;
  uint64_t v6;
  uint64_t v7;
  id v8;
  id v9;
  void *v10;
  id v11;
  id v12;
  uint64_t v13;
  char isKindOfClass;
  void *v15;
  void *v16;
  id v17;
  uint64_t v18;
  char v19;
  double v20;
  uint64_t v21;
  uint64_t v22;
  dispatch_semaphore_t v23;
  const void *v24;
  NSObject *v25;
  void *v26;
  id v27;
  void *v28;
  id v29;
  NSObject *v30;
  int v31;
  dispatch_time_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  id v38;
  void *v39;
  const __CFString *v40;
  _QWORD v41[4];
  id v42;
  uint64_t *v43;
  uint64_t *v44;
  id *v45;
  BOOL v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t (*v50)(uint64_t, uint64_t);
  void (*v51)(uint64_t);
  id v52;
  uint64_t v53;
  uint64_t *v54;
  uint64_t v55;
  uint64_t (*v56)(uint64_t, uint64_t);
  void (*v57)(uint64_t);
  dispatch_semaphore_t v58;
  id v59;
  id *v60;
  uint64_t v61;
  uint64_t (*v62)(uint64_t, uint64_t);
  void (*v63)(uint64_t);
  id v64;
  uint8_t buf[4];
  id v66;

  v5 = a2;
  if ((sub_1000150B0() & 1) == 0)
  {
    sub_100031190(v5, a3, 3, NSOSStatusErrorDomain, -67585, CFSTR("MobileAsset disabled, skipping check."), v6, v7, (uint64_t)v40);
    goto LABEL_11;
  }
  if (a1)
  {
LABEL_15:
    v23 = 0;
    v59 = 0;
    v60 = &v59;
    v61 = 0x3032000000;
    v53 = 0;
    v54 = &v53;
    v62 = sub_1000315DC;
    v63 = sub_1000315EC;
    v64 = 0;
    v55 = 0x3032000000;
    v56 = sub_1000315DC;
    v57 = sub_1000315EC;
    v58 = (dispatch_semaphore_t)0xAAAAAAAAAAAAAAAALL;
    if (a1)
      v23 = dispatch_semaphore_create(0);
    v58 = v23;
    v47 = 0;
    v48 = &v47;
    v49 = 0x3032000000;
    v50 = sub_1000315DC;
    v51 = sub_1000315EC;
    v52 = 0;
    v24 = sub_100011628("OTATrust");
    v25 = objc_claimAutoreleasedReturnValue(v24);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v66 = v5;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "begin MobileAsset query for catalog %@", buf, 0xCu);
    }

    v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](NSDate, "date"));
    sub_100032924(v5, v26);

    v27 = sub_100032A80();
    v28 = (void *)objc_claimAutoreleasedReturnValue(v27);
    v41[0] = _NSConcreteStackBlock;
    v41[1] = 3221225472;
    v41[2] = sub_100032B70;
    v41[3] = &unk_1000767B0;
    v29 = v5;
    v42 = v29;
    v43 = &v47;
    v46 = a1;
    v44 = &v53;
    v45 = &v59;
    +[MAAsset startCatalogDownload:options:then:](MAAsset, "startCatalogDownload:options:then:", v29, v28, v41);

    if (!a1)
      goto LABEL_23;
    v30 = v54[5];
    v31 = sub_100032D60();
    v32 = dispatch_time(0, 1000000000 * v31);
    if (dispatch_semaphore_wait(v30, v32))
    {
      sub_100032D60();
      sub_100031190(v29, a3, 4, NSOSStatusErrorDomain, -67636, CFSTR("Failed to get asset %@ metadata within %d seconds."), v35, v36, (uint64_t)v29);
    }
    else
    {
      v38 = v60[5];
      a1 = v38 != 0;
      if (a3)
      {
        v39 = (void *)v48[5];
        if (v39)
        {
          *a3 = objc_retainAutorelease(v39);
          goto LABEL_23;
        }
      }
      if (v38)
      {
        a1 = 1;
        goto LABEL_23;
      }
      sub_100031190(v29, a3, 4, NSOSStatusErrorDomain, -2070, CFSTR("Unknown error occurred."), v33, v34, (uint64_t)v40);
    }
    a1 = 0;
LABEL_23:

    _Block_object_dispose(&v47, 8);
    _Block_object_dispose(&v53, 8);

    _Block_object_dispose(&v59, 8);
    goto LABEL_24;
  }
  v8 = v5;
  v9 = sub_10002ED40(CFSTR("OTAPKIContext.plist"));
  v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
  if (!v10)
  {
    v12 = 0;
    v11 = 0;
LABEL_14:

    goto LABEL_15;
  }
  v59 = 0;
  v11 = (id)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithContentsOfURL:error:](NSDictionary, "dictionaryWithContentsOfURL:error:", v10, &v59));
  v12 = v59;
  if (!v11)
    goto LABEL_14;
  v11 = v11;
  v13 = objc_opt_class(NSDictionary);
  isKindOfClass = objc_opt_isKindOfClass(v11, v13);

  if ((isKindOfClass & 1) == 0)
    goto LABEL_14;
  v40 = CFSTR("MobileAssetLastRequest");
  v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@-%@")));
  v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "objectForKeyedSubscript:", v15));

  if (!v16
    || (v17 = v16,
        v18 = objc_opt_class(NSDate),
        v19 = objc_opt_isKindOfClass(v17, v18),
        v17,
        (v19 & 1) == 0)
    || (objc_msgSend(v17, "timeIntervalSinceNow"), fabs(v20) >= (double)(unint64_t)sub_10003288C()))
  {

    goto LABEL_14;
  }

  sub_100031190(v8, a3, 3, NSOSStatusErrorDomain, -25297, CFSTR("last MobileAsset request for %@ too recent, skipping check."), v21, v22, (uint64_t)v8);
LABEL_11:
  a1 = 0;
LABEL_24:

  return a1;
}

void sub_100032850(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  uint64_t v27;

  _Block_object_dispose(&a21, 8);
  _Block_object_dispose(&a27, 8);
  _Block_object_dispose((const void *)(v27 - 176), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10003288C()
{
  id v0;
  void *v1;
  uint64_t v2;
  int v3;
  uint64_t v4;

  v0 = objc_msgSend(objc_alloc((Class)NSUserDefaults), "initWithSuiteName:", CFSTR("com.apple.security"));
  v1 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v0, "valueForKey:", CFSTR("PKITrustSupplementalsUpdatePeriod")));
  if (v1 && (v2 = objc_opt_class(NSNumber), (objc_opt_isKindOfClass(v1, v2) & 1) != 0))
  {
    v3 = objc_msgSend(v1, "intValue");
    if (v3 <= 300)
      v4 = 300;
    else
      v4 = v3;
  }
  else
  {
    v4 = 43200;
  }

  return v4;
}

void sub_100032924(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  unsigned __int8 v6;
  id v7;
  const void *v8;
  NSObject *v9;
  id v10;
  uint8_t buf[4];
  id v12;

  v3 = a1;
  v4 = a2;
  if (qword_100082C28 != -1)
    dispatch_once(&qword_100082C28, &stru_1000767D0);
  if (byte_100082C20 == 1)
  {
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@-%@"), CFSTR("MobileAssetLastRequest"), v3));
    v10 = 0;
    v6 = sub_10003185C(v5, v4, (uint64_t *)&v10);
    v7 = v10;

    if ((v6 & 1) == 0)
    {
      v8 = sub_100011628("SecError");
      v9 = objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v12 = v7;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "OTATrust: failed to write last request time: %@", buf, 0xCu);
      }

    }
  }

}

id sub_100032A80()
{
  id v0;
  const void *v1;
  NSObject *v2;
  const char *v3;
  uint8_t *v4;
  const void *v5;
  __int16 v7;
  uint8_t buf[2];

  v0 = objc_alloc_init((Class)MADownloadOptions);
  objc_msgSend(v0, "setDiscretionary:", 0);
  objc_msgSend(v0, "setAllowsCellularAccess:", 1);
  if (!sub_10000C0C0(3888000.0))
  {
    v5 = sub_100011628("OTATrust");
    v2 = objc_claimAutoreleasedReturnValue(v5);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v3 = "Asset staleness state: warning";
      v4 = buf;
      goto LABEL_7;
    }
LABEL_8:

    return v0;
  }
  if (!sub_10000C0C0(2592000.0))
  {
    v1 = sub_100011628("OTATrust");
    v2 = objc_claimAutoreleasedReturnValue(v1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      v7 = 0;
      v3 = "Asset staleness state: at risk";
      v4 = (uint8_t *)&v7;
LABEL_7:
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, v3, v4, 2u);
      goto LABEL_8;
    }
    goto LABEL_8;
  }
  return v0;
}

void sub_100032B70(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;
  uint64_t v11;
  void *v12;
  id v13;
  NSObject *v14;
  char v15;
  uint64_t v16;
  void *v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  id v21;
  id v22;
  id obj;
  _QWORD handler[4];
  id v25;
  int out_token;

  v4 = objc_autoreleasePoolPush();
  v5 = *(void **)(a1 + 32);
  v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate dateWithTimeIntervalSinceReferenceDate:](NSDate, "dateWithTimeIntervalSinceReferenceDate:", 0.0));
  sub_100032924(v5, v6);

  v9 = (void *)os_transaction_create("com.apple.trustd.asset.download");
  v10 = *(void **)(a1 + 32);
  if (a2)
  {
    v11 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    obj = *(id *)(v11 + 40);
    sub_100031190(v10, &obj, 4, CFSTR("MADownLoadResult"), a2, CFSTR("failed to download catalog for asset %@: %ld"), v7, v8, (uint64_t)v10);
    objc_storeStrong((id *)(v11 + 40), obj);
    if (a2 == 13
      && objc_msgSend(*(id *)(a1 + 32), "isEqualToString:", CFSTR("com.apple.MobileAsset.PKITrustSupplementals")))
    {
      v12 = (void *)qword_100082BC0;
      v13 = *(id *)(a1 + 32);
      v14 = v12;
      if (!sub_10000C0C0(2592000.0))
      {
        out_token = 0;
        handler[0] = _NSConcreteStackBlock;
        handler[1] = 3221225472;
        handler[2] = sub_100032DF0;
        handler[3] = &unk_100079BD0;
        v25 = v13;
        notify_register_dispatch("com.apple.mobile.keybagd.lock_status", &out_token, v14, handler);

      }
    }
  }
  else
  {
    v15 = *(_BYTE *)(a1 + 64);
    v16 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
    v17 = *(void **)(v16 + 40);
    v18 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40);
    v19 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v21 = *(id *)(v19 + 40);
    v22 = v17;
    v20 = sub_100032E84(v10, v15, v18, &v22, &v21);
    objc_storeStrong((id *)(v16 + 40), v22);
    objc_storeStrong((id *)(v19 + 40), v21);
    if (*(_BYTE *)(a1 + 64) && (v20 & 1) == 0)
      dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40));

    v9 = 0;
  }

  objc_autoreleasePoolPop(v4);
}

uint64_t sub_100032D60()
{
  id v0;
  void *v1;
  uint64_t v2;
  uint64_t v3;

  v0 = objc_msgSend(objc_alloc((Class)NSUserDefaults), "initWithSuiteName:", CFSTR("com.apple.security"));
  v1 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v0, "valueForKey:", CFSTR("TrustdAssetDownloadWaitTimeout")));
  if (v1 && (v2 = objc_opt_class(NSNumber), (objc_opt_isKindOfClass(v1, v2) & 1) != 0))
    v3 = (uint64_t)objc_msgSend(v1, "intValue");
  else
    v3 = 60;

  return v3;
}

uint64_t sub_100032DF0(uint64_t a1, int a2)
{
  const void *v4;
  NSObject *v5;
  uint8_t v7[16];

  v4 = sub_100011628("OTATrust");
  v5 = objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v7 = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Got lock status notification for at-risk last check-in after MA daemon error", v7, 2u);
  }

  sub_10003239C(0, *(_QWORD *)(a1 + 32), 0);
  return notify_cancel(a2);
}

uint64_t sub_100032E84(void *a1, char a2, void *a3, _QWORD *a4, _QWORD *a5)
{
  id v6;
  const void *v7;
  NSObject *v8;
  id v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  _BOOL4 v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  id v17;
  void *v18;
  void *v19;
  void *v20;
  id v21;
  void *v22;
  uint64_t v23;
  const void *v24;
  NSObject *v25;
  unsigned int v26;
  char v27;
  void *v28;
  id v29;
  uint64_t v30;
  char isKindOfClass;
  const void *v32;
  NSObject *v33;
  unsigned int v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  void *v39;
  uint64_t v40;
  id v41;
  uint64_t v42;
  void *v43;
  const void *v44;
  NSObject *v45;
  const void *v46;
  NSObject *v47;
  id v48;
  void *v49;
  id v50;
  id v51;
  uint64_t v52;
  uint64_t v53;
  id v54;
  void *v55;
  void *v56;
  id v60;
  char v62;
  id v63;
  id obj;
  uint64_t v65;
  _QWORD v66[4];
  id v67;
  void *v68;
  id v69;
  id v70;
  __int128 *p_buf;
  uint64_t *v72;
  char v73;
  void *v74;
  id v75;
  void *v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  uint64_t v81;
  uint64_t *v82;
  uint64_t v83;
  uint64_t (*v84)(uint64_t, uint64_t);
  void (*v85)(uint64_t);
  id v86;
  _BYTE v87[12];
  uint8_t v88[128];
  __int128 buf;
  uint64_t v90;
  uint64_t (*v91)(uint64_t, uint64_t);
  void (*v92)(uint64_t);
  id v93;
  uint8_t v94[4];
  unsigned int v95;
  uint8_t v96[8];

  v6 = a1;
  v63 = a3;
  v60 = objc_msgSend(objc_alloc((Class)MAAssetQuery), "initWithType:", v6);
  v7 = sub_100011628("OTATrust");
  v8 = objc_claimAutoreleasedReturnValue(v7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 138543362;
    *(_QWORD *)((char *)&buf + 4) = v6;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "begin MobileAsset metadata sync request %{public}@", (uint8_t *)&buf, 0xCu);
  }

  v9 = objc_msgSend(v60, "queryMetaDataSync");
  if (v9)
  {
    sub_100031190(v6, a5, 4, CFSTR("MAQueryResult"), (int)v9, CFSTR("failed to query MobileAsset %@ metadata: %ld"), v10, v11, (uint64_t)v6);
LABEL_5:
    v62 = 0;
    goto LABEL_54;
  }
  v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v60, "results"));
  v13 = v12 == 0;

  if (v13)
  {
    sub_100031190(v6, a5, 4, NSOSStatusErrorDomain, -26276, CFSTR("no results in MobileAsset query for %@"), v14, v15, (uint64_t)v6);
    goto LABEL_5;
  }
  *(_QWORD *)&buf = 0;
  *((_QWORD *)&buf + 1) = &buf;
  v90 = 0x3032000000;
  v91 = sub_1000315DC;
  v92 = sub_1000315EC;
  v93 = 0;
  v81 = 0;
  v82 = &v81;
  v83 = 0x3032000000;
  v84 = sub_1000315DC;
  v85 = sub_1000315EC;
  v86 = 0;
  v77 = 0u;
  v78 = 0u;
  v79 = 0u;
  v80 = 0u;
  v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v60, "results"));
  v17 = objc_msgSend(v16, "countByEnumeratingWithState:objects:count:", &v77, v88, 16);
  if (v17)
  {
    v62 = 0;
    v65 = *(_QWORD *)v78;
    obj = v16;
    do
    {
      v18 = 0;
      do
      {
        if (*(_QWORD *)v78 != v65)
          objc_enumerationMutation(obj);
        v19 = *(void **)(*((_QWORD *)&v77 + 1) + 8 * (_QWORD)v18);
        v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "assetProperty:", CFSTR("_ContentVersion")));
        if ((sub_100030344(v6, v19) & 1) != 0)
        {
          if (objc_msgSend(v6, "isEqualToString:", CFSTR("com.apple.MobileAsset.PKITrustSupplementals")))
          {
            v21 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "attributes"));
            v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "objectForKey:", CFSTR("CTKillSwitch")));
            if (v22 && (v23 = objc_opt_class(NSNumber), (objc_opt_isKindOfClass(v22, v23) & 1) != 0))
            {
              *(_QWORD *)v87 = 0;
              sub_10003185C(CFSTR("CTKillSwitch"), v22, (uint64_t *)v87);
              sub_100033688(CFSTR("CTKillSwitch"), (char)objc_msgSend(v22, "BOOLValue"));
              v24 = sub_100011628("OTATrust");
              v25 = objc_claimAutoreleasedReturnValue(v24);
              if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
              {
                v26 = objc_msgSend(v22, "BOOLValue");
                *(_DWORD *)v96 = 67109120;
                *(_DWORD *)&v96[4] = v26;
                _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "got CT kill switch = %{BOOL}d", v96, 8u);
              }

              v27 = 1;
            }
            else
            {
              v27 = 0;
            }
            v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "objectForKey:", CFSTR("CTKillSwitch_nonTLS")));

            if (v28)
            {
              v29 = v28;
              v30 = objc_opt_class(NSNumber);
              isKindOfClass = objc_opt_isKindOfClass(v29, v30);

              if ((isKindOfClass & 1) != 0)
              {
                *(_QWORD *)v96 = 0;
                sub_10003185C(CFSTR("CTKillSwitch_nonTLS"), v29, (uint64_t *)v96);
                sub_100033688(CFSTR("CTKillSwitch_nonTLS"), (char)objc_msgSend(v29, "BOOLValue"));
                v32 = sub_100011628("OTATrust");
                v33 = objc_claimAutoreleasedReturnValue(v32);
                if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
                {
                  v34 = objc_msgSend(v29, "BOOLValue");
                  *(_DWORD *)v94 = 67109120;
                  v95 = v34;
                  _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "got non-TLS CT kill switch = %{BOOL}d", v94, 8u);
                }

                v27 = 1;
              }
            }
            if (qword_100082C28 != -1)
              dispatch_once(&qword_100082C28, &stru_1000767D0);
            if ((v27 & byte_100082C20) == 1)
              notify_post("com.apple.trustd.kill-switch");

          }
          switch((unint64_t)objc_msgSend(v19, "state"))
          {
            case 0uLL:
              v35 = *((_QWORD *)&buf + 1);
              v74 = *(void **)(*((_QWORD *)&buf + 1) + 40);
              v36 = objc_msgSend(v19, "state");
              sub_100031190(v6, &v74, 4, CFSTR("MAAssetState"), v36, CFSTR("asset %@ is unknown"), v37, v38, (uint64_t)v6);
              v39 = v74;
              goto LABEL_40;
            case 1uLL:
              goto LABEL_36;
            case 2uLL:
              v40 = *((_QWORD *)&buf + 1);
              v75 = *(id *)(*((_QWORD *)&buf + 1) + 40);
              v41 = sub_1000306B8(v6, v19, v20, (uint64_t *)&v75);
              v42 = objc_claimAutoreleasedReturnValue(v41);
              objc_storeStrong((id *)(v40 + 40), v75);
              v43 = (void *)v82[5];
              v82[5] = v42;
              break;
            case 4uLL:
              v44 = sub_100011628("OTATrust");
              v45 = objc_claimAutoreleasedReturnValue(v44);
              if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)v87 = 138543362;
                *(_QWORD *)&v87[4] = v6;
                _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "asset %{public}@ is downloading", v87, 0xCu);
              }

LABEL_36:
              v46 = sub_100011628("OTATrust");
              v47 = objc_claimAutoreleasedReturnValue(v46);
              if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)v87 = 0;
                _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "begin download of OTATrust asset", v87, 2u);
              }

              v48 = sub_100032A80();
              v49 = (void *)objc_claimAutoreleasedReturnValue(v48);
              v66[0] = _NSConcreteStackBlock;
              v66[1] = 3221225472;
              v66[2] = sub_10003370C;
              v66[3] = &unk_100076698;
              v50 = v6;
              p_buf = &buf;
              v72 = &v81;
              v67 = v50;
              v68 = v19;
              v69 = v20;
              v73 = a2;
              v70 = v63;
              objc_msgSend(v19, "startDownload:then:", v49, v66);

              v62 = 1;
              v43 = v67;
              break;
            default:
              v35 = *((_QWORD *)&buf + 1);
              v76 = *(void **)(*((_QWORD *)&buf + 1) + 40);
              v51 = objc_msgSend(v19, "state");
              sub_100031190(v6, &v76, 4, NSOSStatusErrorDomain, -26276, CFSTR("unknown asset state %ld"), v52, v53, (uint64_t)v51);
              v39 = v76;
LABEL_40:
              v54 = v39;
              v43 = *(void **)(v35 + 40);
              *(_QWORD *)(v35 + 40) = v54;
              break;
          }

        }
        v18 = (char *)v18 + 1;
      }
      while (v17 != v18);
      v16 = obj;
      v17 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v77, v88, 16);
    }
    while (v17);
  }
  else
  {
    v62 = 0;
  }

  if (a5)
  {
    v55 = *(void **)(*((_QWORD *)&buf + 1) + 40);
    if (v55)
      *a5 = objc_retainAutorelease(v55);
  }
  if (a4)
  {
    v56 = (void *)v82[5];
    if (v56)
      *a4 = objc_retainAutorelease(v56);
  }
  _Block_object_dispose(&v81, 8);

  _Block_object_dispose(&buf, 8);
LABEL_54:

  return v62 & 1;
}

void sub_10003363C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  uint64_t v47;

  _Block_object_dispose(&a47, 8);
  _Block_object_dispose((const void *)(v47 - 192), 8);
  _Unwind_Resume(a1);
}

void sub_100033688(void *a1, char a2)
{
  id v3;
  NSObject *v4;
  id v5;
  _QWORD block[4];
  id v7;
  char v8;

  v3 = a1;
  v4 = qword_100082BC8;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10003380C;
  block[3] = &unk_100079248;
  v7 = v3;
  v8 = a2;
  v5 = v3;
  dispatch_sync(v4, block);

}

void sub_10003370C(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  void *v8;
  uint64_t v9;
  void *v10;
  void *v11;
  uint64_t v12;
  id v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  NSObject *v17;
  id v18;
  id obj;

  v4 = objc_autoreleasePoolPush();
  v7 = (void *)os_transaction_create("com.apple.trustd.asset.downloadAsset");
  v8 = *(void **)(a1 + 32);
  if (a2)
  {
    v9 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8);
    obj = *(id *)(v9 + 40);
    sub_100031190(v8, &obj, 4, CFSTR("MADownLoadResult"), a2, CFSTR("failed to download asset %@: %ld"), v5, v6, (uint64_t)v8);
    objc_storeStrong((id *)(v9 + 40), obj);
  }
  else
  {
    v10 = *(void **)(a1 + 40);
    v11 = *(void **)(a1 + 48);
    v12 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8);
    v18 = *(id *)(v12 + 40);
    v13 = sub_1000306B8(v8, v10, v11, (uint64_t *)&v18);
    v14 = objc_claimAutoreleasedReturnValue(v13);
    objc_storeStrong((id *)(v12 + 40), v18);
    v15 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8);
    v16 = *(void **)(v15 + 40);
    *(_QWORD *)(v15 + 40) = v14;

    if (*(_BYTE *)(a1 + 80))
    {
      v17 = *(NSObject **)(a1 + 56);
      if (v17)
        dispatch_semaphore_signal(v17);
    }
  }

  objc_autoreleasePoolPop(v4);
}

id sub_10003380C(uint64_t a1)
{
  id result;

  result = objc_msgSend(*(id *)(a1 + 32), "isEqualToString:", CFSTR("CTKillSwitch"));
  if ((_DWORD)result)
  {
    *(_BYTE *)(qword_100082BF0 + 200) = *(_BYTE *)(a1 + 40);
  }
  else
  {
    result = objc_msgSend(*(id *)(a1 + 32), "isEqualToString:", CFSTR("CTKillSwitch_nonTLS"));
    if ((_DWORD)result)
      *(_BYTE *)(qword_100082BF0 + 201) = *(_BYTE *)(a1 + 40);
  }
  return result;
}

void sub_100033874(id a1, int a2)
{
  char v2;
  char v3;

  v2 = sub_10002FE58(CFSTR("CTKillSwitch"));
  sub_100033688(CFSTR("CTKillSwitch"), v2);
  v3 = sub_10002FE58(CFSTR("CTKillSwitch_nonTLS"));
  sub_100033688(CFSTR("CTKillSwitch_nonTLS"), v3);
}

void sub_1000338C0(id a1, int a2)
{
  const void *v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = sub_100011628("OTATrust");
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)v4 = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "Got notification about successful PKITrustSupplementals asset check-in", v4, 2u);
  }

  sub_100031A34();
}

void sub_100033934(id a1, int a2)
{
  const void *v2;
  NSObject *v3;
  NSNumber *v4;
  void *v5;
  void *v6;
  id v7;
  void *v8;
  char v9;
  id v10;
  const void *v11;
  NSObject *v12;
  id v13;
  void *v14;
  uint8_t buf[4];
  id v16;

  v2 = sub_100011628("OTATrust");
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Got notification about a new PKITrustSupplementals asset from system trustd.", buf, 2u);
  }

  v14 = 0;
  v4 = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", sub_10002F174(&v14));
  v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  v6 = v14;
  v7 = sub_10002ED40(0);
  v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
  v13 = v6;
  v9 = sub_100030A98(v8, v5, (uint64_t *)&v13);
  v10 = v13;

  if ((v9 & 1) == 0)
  {
    v11 = sub_100011628("SecError");
    v12 = objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v16 = v10;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "OTATrust: failed to update from asset after notification: %@", buf, 0xCu);
    }

    sub_100033AA8();
  }

}

uint64_t sub_100033AA8()
{
  _QWORD block[5];

  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100033B10;
  block[3] = &unk_1000791F8;
  block[4] = sub_10002F5DC(CFSTR("MobileAssetContentVersion"));
  dispatch_sync((dispatch_queue_t)qword_100082BC8, block);
  return sub_10002F010();
}

void sub_100033B10(uint64_t a1)
{
  uint64_t v1;
  const void *v2;

  v1 = qword_100082BF0;
  *(_QWORD *)(qword_100082BF0 + 152) = *(_QWORD *)(a1 + 32);
  v2 = *(const void **)(v1 + 160);
  if (v2)
  {
    *(_QWORD *)(v1 + 160) = 0;
    CFRelease(v2);
    v1 = qword_100082BF0;
  }
  *(_QWORD *)(v1 + 160) = 0;
}

void sub_100033B50(id a1)
{
  const void *v1;
  NSObject *v2;
  uint8_t v3[16];

  v1 = sub_100011628("OTATrust");
  v2 = objc_claimAutoreleasedReturnValue(v1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Initial check with MobileAsset for newer PKITrustSupplementals asset", v3, 2u);
  }

  sub_10003239C(0, CFSTR("com.apple.MobileAsset.PKITrustSupplementals"), 0);
}

void sub_100033BD0(id a1, int a2)
{
  const void *v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = sub_100011628("OTATrust");
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Got notification about a new PKITrustSupplementals asset from mobileassetd.", v4, 2u);
  }

  sub_100032E84(CFSTR("com.apple.MobileAsset.PKITrustSupplementals"), 0, 0, 0, 0);
}

void sub_100033C58(uint64_t a1)
{
  void *v2;
  void *v3;
  const void *v4;
  NSObject *v5;
  int v6;
  void *v7;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 208), "startUsingLocalAsset"));
  v3 = v2;
  if (v2)
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 216) = v2;
  v4 = sub_100011628("OTATrust");
  v5 = objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = 138412290;
    v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Using asset path: %@", (uint8_t *)&v6, 0xCu);
  }

}

void *sub_100033D28(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const void *v5;
  const void *v6;
  void *v7;
  uint64_t v8;
  void *v9;
  void *v10;
  id v11;
  const void *v12;
  NSObject *v13;
  uint8_t buf[4];
  uint64_t v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  uint64_t v20;

  v5 = sub_10002FD68(a1);
  if (!v5)
    return 0;
  v6 = v5;
  v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@/%@"), v5, a2));
  if (a3)
  {
    v8 = objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@.%@"), v7, a3));

    v7 = (void *)v8;
  }
  v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:isDirectory:](NSURL, "fileURLWithPath:isDirectory:", v7, 0));
  v10 = v9;
  if (v9)
  {
    v11 = v9;
  }
  else
  {
    v12 = sub_100011628("SecWarning");
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412802;
      v16 = a2;
      v17 = 2112;
      v18 = a3;
      v19 = 2112;
      v20 = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "resource: %@.%@ in %@ not found", buf, 0x20u);
    }

  }
  CFRelease(v6);

  return v10;
}

void sub_100033E90(void *a1, size_t a2)
{
  int v4;
  int v5;
  const void *v6;
  NSObject *v7;
  int v8;
  size_t v9;
  __int16 v10;
  void *v11;
  __int16 v12;
  int v13;

  v4 = munmap(a1, a2);
  if (v4)
  {
    v5 = v4;
    v6 = sub_100011628("SecError");
    v7 = objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = 134218496;
      v9 = a2;
      v10 = 2048;
      v11 = a1;
      v12 = 1024;
      v13 = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "unable to unmap %ld bytes at %p (error %d)", (uint8_t *)&v8, 0x1Cu);
    }

  }
}

void sub_100033F68(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  void *v5;
  id v6;

  v6 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a2));
  v3 = objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:isDirectory:](NSURL, "fileURLWithPath:isDirectory:", v6, 1));
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v5 = *(void **)(v4 + 40);
  *(_QWORD *)(v4 + 40) = v3;

}

void sub_100033FD8(id a1)
{
  dispatch_sync((dispatch_queue_t)qword_100082BD0, &stru_1000765B0);
}

void sub_100033FEC(id a1)
{
  const void *v1;
  NSObject *v2;
  const void *v3;
  NSObject *v4;
  uint8_t v5[16];
  uint8_t buf[16];

  v1 = sub_100011628("OTATrust");
  v2 = objc_claimAutoreleasedReturnValue(v1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "--- Received asset download notification ---", buf, 2u);
  }

  v3 = sub_100011628("OTATrust");
  v4 = objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Will exit when clean to use updated assets", v5, 2u);
  }

  xpc_transaction_exit_clean();
}

void sub_1000340A8(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  NSObject *v4;
  NSObject *v5;
  void *v6;
  NSObject *v7;
  _QWORD *context;
  int v9;
  uint64_t v10;

  v2 = sub_10003288C();
  v3 = sub_100011628("OTATrust");
  v4 = objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v9 = 134217984;
    v10 = v2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Setting periodic update delta to %llu seconds", (uint8_t *)&v9, 0xCu);
  }

  v5 = sub_10002B070(*(NSObject **)(a1 + 32), "OTATrust", v2);
  v6 = (void *)qword_100082C08;
  qword_100082C08 = (uint64_t)v5;

  v7 = qword_100082C08;
  context = dispatch_get_context((dispatch_object_t)qword_100082C08);
  context[2] = _Block_copy(&stru_100076788);
  dispatch_activate(v7);
}

void sub_1000341AC(id a1)
{
  const void *v1;
  NSObject *v2;
  NSNumber *v3;
  void *v4;
  void *v5;
  id v6;
  void *v7;
  char v8;
  id v9;
  const void *v10;
  NSObject *v11;
  id v12;
  void *v13;
  uint8_t buf[4];
  id v15;

  if (byte_100082C10 == 1)
  {
    if (qword_100082C28 != -1)
      dispatch_once(&qword_100082C28, &stru_1000767D0);
    if (byte_100082C20 == 1)
    {
      sub_10003239C(0, CFSTR("com.apple.MobileAsset.SecExperimentAssets"), 0);
      sub_10003239C(0, CFSTR("com.apple.MobileAsset.PKITrustSupplementals"), 0);
    }
    else
    {
      v1 = sub_100011628("OTATrust");
      v2 = objc_claimAutoreleasedReturnValue(v1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "periodic re-read asset from disk", buf, 2u);
      }

      v13 = 0;
      v3 = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", sub_10002F174(&v13));
      v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
      v5 = v13;
      v6 = sub_10002ED40(0);
      v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
      v12 = v5;
      v8 = sub_100030A98(v7, v4, (uint64_t *)&v12);
      v9 = v12;

      if ((v8 & 1) == 0)
      {
        v10 = sub_100011628("SecError");
        v11 = objc_claimAutoreleasedReturnValue(v10);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          v15 = v9;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "OTATrust: failed to update from asset during periodic re-read: %@", buf, 0xCu);
        }

        sub_100033AA8();
      }

    }
  }
  byte_100082C10 = 1;
}

uint64_t sub_10003439C()
{
  uint64_t v0;
  _QWORD block[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  if (!qword_100082BC8)
    return 0;
  sub_1000144B0((void *)qword_100082BC0);
  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v6 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100034448;
  block[3] = &unk_100077360;
  block[4] = &v3;
  dispatch_sync((dispatch_queue_t)qword_100082BC8, block);
  v0 = v4[3];
  _Block_object_dispose(&v3, 8);
  return v0;
}

_QWORD *sub_100034448(_QWORD *result)
{
  _QWORD *v1;
  const void *v2;

  if (qword_100082BF0)
  {
    v1 = result;
    v2 = *(const void **)(qword_100082BF0 + 48);
    if (v2
      || (result = sub_10002E8F4(CFSTR("TrustedCTLogs_nonTLS.plist")),
          v2 = result,
          (*(_QWORD *)(qword_100082BF0 + 48) = result) != 0))
    {
      result = CFRetain(v2);
    }
    *(_QWORD *)(*(_QWORD *)(v1[4] + 8) + 24) = v2;
  }
  return result;
}

void *sub_1000344B0(__CFString **a1)
{
  void *v2;
  void *v3;
  void *v4;
  id v5;
  id v6;
  id v7;
  uint64_t v8;
  void *i;
  void *v10;
  void *v11;
  void *v12;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  _BYTE v18[128];

  v2 = (void *)sub_1000074EC();
  v3 = objc_autoreleasePoolPush();
  v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionaryWithCapacity:](NSMutableDictionary, "dictionaryWithCapacity:", objc_msgSend(v2, "count")));
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v17 = 0u;
  v5 = v2;
  v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v14, v18, 16);
  if (v6)
  {
    v7 = v6;
    v8 = *(_QWORD *)v15;
    do
    {
      for (i = 0; i != v7; i = (char *)i + 1)
      {
        if (*(_QWORD *)v15 != v8)
          objc_enumerationMutation(v5);
        v10 = *(void **)(*((_QWORD *)&v14 + 1) + 8 * (_QWORD)i);
        v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKey:", v10, (_QWORD)v14));
        v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "base64EncodedStringWithOptions:", 0));
        objc_msgSend(v4, "setObject:forKeyedSubscript:", v11, v12);

      }
      v7 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v14, v18, 16);
    }
    while (v7);
  }

  objc_autoreleasePoolPop(v3);
  if (!v4)
    sub_100012C88(-26276, a1, CFSTR("Could not get CT logs from the current OTAPKIRef"));
  return v4;
}

const void *sub_100034640(const void *a1)
{
  const __CFDictionary *v2;
  uint64_t v3;
  const __CFDictionary *v4;
  const void *Value;
  const void *result;

  v2 = (const __CFDictionary *)sub_1000074EC();
  v3 = sub_10003439C();
  v4 = (const __CFDictionary *)v3;
  if (v2 && v3)
  {
    Value = CFDictionaryGetValue(v2, a1);
    if (Value || (Value = CFDictionaryGetValue(v4, a1)) != 0)
      CFRetain(Value);
    CFRelease(v2);
LABEL_10:
    CFRelease(v4);
    return Value;
  }
  if (v2)
    CFRelease(v2);
  Value = 0;
  result = 0;
  if (v4)
    goto LABEL_10;
  return result;
}

uint64_t sub_1000346DC(__CFString **a1)
{
  uint64_t v2;
  const void *v3;
  uint64_t v4;

  v2 = sub_100004464();
  if (v2)
  {
    v3 = (const void *)v2;
    v4 = *(_QWORD *)(v2 + 96);
    if (v4)
      CFRetain(*(CFTypeRef *)(v2 + 96));
    CFRelease(v3);
  }
  else
  {
    sub_100012C88(-26276, a1, CFSTR("Unable to get the current OTAPKIRef"));
    return 0;
  }
  return v4;
}

uint64_t sub_10003473C(__CFString **a1)
{
  uint64_t v2;
  const void *v3;
  uint64_t v4;

  v2 = sub_100004464();
  if (v2)
  {
    v3 = (const void *)v2;
    v4 = *(_QWORD *)(v2 + 104);
    if (v4)
      CFRetain(*(CFTypeRef *)(v2 + 104));
    CFRelease(v3);
  }
  else
  {
    sub_100012C88(-26276, a1, CFSTR("Unable to get the current OTAPKIRef"));
    return 0;
  }
  return v4;
}

uint64_t sub_10003479C(uint64_t a1, __CFString **a2)
{
  void *v2;
  void *v3;
  const __CFData *v4;
  const __CFDictionary *v5;
  const __CFDictionary *v6;
  CFTypeID v7;
  const __CFNumber *Value;
  uint64_t v9;
  CFPropertyListFormat format;
  uint64_t valuePtr;

  valuePtr = 0;
  if (a1)
  {
    v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@/%@"), a1, CFSTR("AssetVersion.plist")));
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:isDirectory:](NSURL, "fileURLWithPath:isDirectory:", v2, 0));
    v4 = (const __CFData *)objc_claimAutoreleasedReturnValue(+[NSData dataWithContentsOfURL:](NSData, "dataWithContentsOfURL:", v3));
    if (v4
      && (format = 0xAAAAAAAAAAAAAAAALL,
          (v5 = (const __CFDictionary *)CFPropertyListCreateWithData(kCFAllocatorDefault, v4, 0, &format, 0)) != 0))
    {
      v6 = v5;
      v7 = CFGetTypeID(v5);
      if (v7 == CFDictionaryGetTypeID()
        && (Value = (const __CFNumber *)CFDictionaryGetValue(v6, CFSTR("VersionNumber"))) != 0)
      {
        CFNumberGetValue(Value, kCFNumberSInt64Type, &valuePtr);
        v9 = valuePtr;
        if (valuePtr < 0)
        {
          v9 = 0;
          valuePtr = 0;
        }
      }
      else
      {
        v9 = 0;
      }
      CFRelease(v6);
    }
    else
    {
      v9 = 0;
    }

  }
  else
  {
    sub_100012C88(-26276, a2, CFSTR("Unable to get trust store version (empty path)"));
    return 0;
  }
  return v9;
}

uint64_t sub_1000348EC()
{
  uint64_t v0;

  v0 = sub_10002F5DC(CFSTR("VersionNumber"));
  if (!v0)
    sub_100012C88(-26276, 0, CFSTR("Unable to get the system trust store version"));
  return v0;
}

uint64_t sub_100034930(__CFString **a1)
{
  _QWORD *v2;
  uint64_t v3;

  v2 = (_QWORD *)sub_100004464();
  if (v2)
  {
    v3 = v2[14];
    CFRelease(v2);
  }
  else
  {
    sub_100012C88(-26276, a1, CFSTR("Unable to get the current OTAPKIRef"));
    return 0;
  }
  return v3;
}

unint64_t sub_10003497C(__CFString **a1)
{
  BOOL v2;
  __CFString *v3;
  __CFString *v4;
  unint64_t v5;
  id v7;

  if (qword_100082C28 != -1)
    dispatch_once(&qword_100082C28, &stru_1000767D0);
  if (byte_100082C20 == 1)
  {
    v7 = 0;
    v2 = sub_10003239C(1, CFSTR("com.apple.MobileAsset.PKITrustSupplementals"), &v7);
    v3 = (__CFString *)v7;
    v4 = v3;
    if (a1 && !v2)
    {
      if (v3)
        CFRetain(v3);
      *a1 = v4;
    }
  }
  else
  {
    sub_100012C88(-67585, a1, CFSTR("This function may only be performed by the system trustd."));
    v4 = 0;
  }
  v5 = sub_10002F174(0);

  return v5;
}

uint64_t sub_100034A54(__CFString **a1)
{
  BOOL v2;
  __CFString *v3;
  __CFString *v4;
  uint64_t v5;
  id v7;

  if (qword_100082C28 != -1)
    dispatch_once(&qword_100082C28, &stru_1000767D0);
  if (byte_100082C20 == 1)
  {
    v7 = 0;
    v2 = sub_10003239C(1, CFSTR("com.apple.MobileAsset.SecExperimentAssets"), &v7);
    v3 = (__CFString *)v7;
    v4 = v3;
    if (a1 && !v2)
    {
      if (v3)
        CFRetain(v3);
      *a1 = v4;
    }
  }
  else
  {
    sub_100012C88(-67585, a1, CFSTR("This function may only be performed by the system trustd."));
    v4 = 0;
  }
  v5 = sub_100032298(a1);

  return v5;
}

uint64_t sub_100034B2C()
{
  uint64_t v0;
  _QWORD block[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  if (!qword_100082BC8)
    return 0;
  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v6 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100034BC8;
  block[3] = &unk_100077360;
  block[4] = &v3;
  dispatch_sync((dispatch_queue_t)qword_100082BC8, block);
  v0 = v4[3];
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_100034BC8(uint64_t a1)
{
  uint64_t v1;
  const void *v3;
  NSObject *v4;
  const char *v5;
  uint8_t *v6;
  const void *v7;
  __int16 v8;
  __int16 v9;

  if (qword_100082BF0)
  {
    v1 = *(_QWORD *)(qword_100082BF0 + 184);
    if (v1)
    {
      CFRetain(*(CFTypeRef *)(qword_100082BF0 + 184));
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v1;
      v3 = sub_100011628("OTATrust");
      v4 = objc_claimAutoreleasedReturnValue(v3);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        v9 = 0;
        v5 = "asset found";
        v6 = (uint8_t *)&v9;
LABEL_7:
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v5, v6, 2u);
      }
    }
    else
    {
      v7 = sub_100011628("OTATrust");
      v4 = objc_claimAutoreleasedReturnValue(v7);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        v8 = 0;
        v5 = "asset NULL";
        v6 = (uint8_t *)&v8;
        goto LABEL_7;
      }
    }

  }
}

BOOL sub_100034EC8(const char *a1, _QWORD *a2)
{
  int v4;
  int v5;
  int v6;
  _BOOL8 v7;
  uint64_t v8;
  int *v9;
  NSString *v10;
  void *v11;
  void *v12;
  void *v13;
  uint64_t v14;
  int *v15;
  NSString *v16;
  void *v17;
  void *v18;
  void *v19;
  NSErrorUserInfoKey v21;
  void *v22;
  NSErrorUserInfoKey v23;
  void *v24;

  v4 = open(a1, 0);
  if (v4)
  {
    v5 = v4;
    v6 = fcntl(v4, 64, 4);
    v7 = v6 >= 0;
    if (v6 < 0)
    {
      v8 = *__error();
      v23 = NSLocalizedDescriptionKey;
      v9 = __error();
      v10 = +[NSString localizedStringWithFormat:](NSString, "localizedStringWithFormat:", CFSTR("failed to change protection class of %s: %s"), a1, strerror(*v9));
      v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
      v24 = v11;
      v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v24, &v23, 1));
      v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", NSPOSIXErrorDomain, v8, v12));

      if (a2 && !*a2)
        *a2 = v13;

    }
    close(v5);
  }
  else
  {
    v14 = *__error();
    v21 = NSLocalizedDescriptionKey;
    v15 = __error();
    v16 = +[NSString localizedStringWithFormat:](NSString, "localizedStringWithFormat:", CFSTR("failed to open file for protection class change %s: %s"), a1, strerror(*v15));
    v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
    v22 = v17;
    v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v22, &v21, 1));
    v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", NSPOSIXErrorDomain, v14, v18));

    if (a2 && !*a2)
      *a2 = v19;

    return 0;
  }
  return v7;
}

void sub_1000350F4(id a1)
{
  if (getuid() == 282 || !getuid() && gTrustd)
    byte_100082C20 = 1;
}

void sub_100035134(id a1)
{
  const __CFURL *v1;

  v1 = sub_10001DD50(CFSTR("private/var/protected/"), (uint64_t)CFSTR("trustd"));
  sub_10002B558(v1, (uint64_t)&stru_100076810);
}

void sub_100035160(id a1, const char *a2)
{
  int v3;
  int v4;
  const void *v5;
  NSObject *v6;
  uid_t v7;
  int v8;
  const char *v9;
  __int16 v10;
  char *v11;

  v3 = mkpath_np(a2, 0x1FFu);
  if (v3)
  {
    v4 = v3;
    if (v3 != 17)
    {
      v5 = sub_100011628("SecError");
      v6 = objc_claimAutoreleasedReturnValue(v5);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        v8 = 136315394;
        v9 = a2;
        v10 = 2080;
        v11 = strerror(v4);
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "could not create path: %s (%s)", (uint8_t *)&v8, 0x16u);
      }

    }
  }
  if (qword_100082C28 != -1)
    dispatch_once(&qword_100082C28, &stru_1000767D0);
  if (byte_100082C20 == 1)
  {
    v7 = getuid();
    chown(a2, v7, v7);
    chmod(a2, 0x1EDu);
  }
}

void sub_100035298(id a1)
{
  sub_1000352AC((uint64_t)CFSTR("private"), &stru_100076850);
}

void sub_1000352AC(uint64_t a1, void *a2)
{
  const __CFURL *v3;
  id v4;

  v4 = a2;
  v3 = sub_10001DCB8(a1);
  sub_10002B558(v3, (uint64_t)v4);

}

void sub_1000352EC(id a1, const char *a2)
{
  int v3;
  int v4;
  const void *v5;
  NSObject *v6;
  int v7;
  const char *v8;
  __int16 v9;
  char *v10;

  v3 = mkpath_np(a2, 0x1FFu);
  if (v3)
  {
    v4 = v3;
    if (v3 != 17)
    {
      v5 = sub_100011628("SecError");
      v6 = objc_claimAutoreleasedReturnValue(v5);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        v7 = 136315394;
        v8 = a2;
        v9 = 2080;
        v10 = strerror(v4);
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "could not create path: %s (%s)", (uint8_t *)&v7, 0x16u);
      }

    }
  }
  chmod(a2, 0x1FFu);
}

void sub_1000353D8()
{
  Block_layout *v0;
  const __CFURL *v1;

  v0 = &stru_100076C10;
  v1 = sub_10001DC28((uint64_t)CFSTR("caissuercache.sqlite3"));
  sub_10002B558(v1, (uint64_t)&stru_100076C10);

}

void sub_100035414()
{
  void *v0;
  _QWORD *v1;
  const __CFURL *v2;
  id v3;
  void *v4;
  void *v5;
  void *v6;
  NSObject *v7;
  const void *v8;
  NSObject *v9;
  const void *v10;
  _QWORD v11[4];
  __CFString *v12;
  _QWORD v13[4];
  const __CFString *v14;
  _QWORD v15[5];
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  char v19;
  __int128 buf;
  void (*v21)(uint64_t, char *);
  void *v22;
  uint64_t *v23;

  v0 = objc_autoreleasePoolPush();
  v16 = 0;
  v17 = &v16;
  v18 = 0x2020000000;
  v19 = 0;
  if ((sub_100015138() & 1) != 0)
  {
    *(_QWORD *)&buf = _NSConcreteStackBlock;
    *((_QWORD *)&buf + 1) = 3221225472;
    v21 = sub_100035794;
    v22 = &unk_100079C70;
    v23 = &v16;
    sub_10002B5F4((uint64_t)CFSTR("Analytics"), (uint64_t)&buf);
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 3221225472;
    v15[2] = sub_100035910;
    v15[3] = &unk_100079C70;
    v15[4] = &v16;
    v1 = v15;
    v2 = sub_10001DC28((uint64_t)CFSTR("TrustStore.sqlite3"));
    sub_10002B558(v2, (uint64_t)v1);

    LODWORD(v1) = *((unsigned __int8 *)v17 + 24);
    _Block_object_dispose(&v16, 8);
    if ((_DWORD)v1)
    {
      v3 = objc_msgSend(objc_alloc((Class)NSXPCConnection), "initWithMachServiceName:options:", CFSTR("com.apple.securityuploadd"), 0);
      v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSXPCInterface interfaceWithProtocol:](NSXPCInterface, "interfaceWithProtocol:", &OBJC_PROTOCOL___TrustdFileHelper_protocol));
      objc_msgSend(v3, "setRemoteObjectInterface:", v4);

      objc_msgSend(v3, "resume");
      if (v3)
      {
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 3221225472;
        v13[2] = sub_100035A04;
        v13[3] = &unk_100076878;
        v14 = CFSTR("securityuploadd");
        v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "synchronousRemoteObjectProxyWithErrorHandler:", v13));
        v6 = v5;
        if (v5)
        {
          v11[0] = _NSConcreteStackBlock;
          v11[1] = 3221225472;
          v11[2] = sub_100035AD0;
          v11[3] = &unk_1000768A0;
          v12 = CFSTR("securityuploadd");
          objc_msgSend(v5, "fixFiles:", v11);

        }
        objc_msgSend(v3, "invalidate");

        v7 = v14;
      }
      else
      {
        v10 = sub_100011628("SecError");
        v7 = objc_claimAutoreleasedReturnValue(v10);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 138543362;
          *(_QWORD *)((char *)&buf + 4) = CFSTR("securityuploadd");
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "failed to ceate %{public}@ connection", (uint8_t *)&buf, 0xCu);
        }
      }

      goto LABEL_14;
    }
  }
  else
  {
    _Block_object_dispose(&v16, 8);
  }
  v8 = sub_100011628("helper");
  v9 = objc_claimAutoreleasedReturnValue(v8);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(buf) = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "trustd file permissions already fixed. skipping trustdFileHelper call.", (uint8_t *)&buf, 2u);
  }

LABEL_14:
  objc_autoreleasePoolPop(v0);
}

void sub_1000356F0(_Unwind_Exception *exc_buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
  uint64_t v25;
  uint64_t v26;
  id v27;
  const void *v28;
  NSObject *v29;

  if (a2 == 1)
  {
    v27 = objc_begin_catch(exc_buf);
    v28 = sub_100011628("SecError");
    v29 = objc_claimAutoreleasedReturnValue(v28);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)(v26 - 128) = 138412290;
      *(_QWORD *)(v25 + 4) = v27;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "failed to fix files; caught exception: %@",
        (uint8_t *)(v26 - 128),
        0xCu);
    }

    objc_end_catch();
    JUMPOUT(0x100035680);
  }
  _Unwind_Resume(exc_buf);
}

void sub_100035794(uint64_t a1, char *a2)
{
  timespec v3;
  const void *v4;
  NSObject *v5;
  int *v6;
  char *v7;
  const char *v8;
  NSObject *v9;
  uint32_t v10;
  const void *v11;
  stat v12;
  uint8_t buf[4];
  char *v14;

  v3.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v3.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v12.st_blksize = v3;
  *(timespec *)v12.st_qspare = v3;
  v12.st_birthtimespec = v3;
  *(timespec *)&v12.st_size = v3;
  v12.st_mtimespec = v3;
  v12.st_ctimespec = v3;
  *(timespec *)&v12.st_uid = v3;
  v12.st_atimespec = v3;
  *(timespec *)&v12.st_dev = v3;
  if (!stat(a2, &v12))
  {
    if ((~v12.st_mode & 0x1FF) == 0)
      return;
    v11 = sub_100011628("helper");
    v5 = objc_claimAutoreleasedReturnValue(v11);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      goto LABEL_8;
    *(_DWORD *)buf = 67109120;
    LODWORD(v14) = v12.st_mode;
    v8 = "wrong permissions on Analytics dir: %d";
    v9 = v5;
    v10 = 8;
    goto LABEL_11;
  }
  if (*__error() != 20 && *__error() != 2)
  {
    v4 = sub_100011628("helper");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
LABEL_8:

      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
      return;
    }
    v6 = __error();
    v7 = strerror(*v6);
    *(_DWORD *)buf = 136315138;
    v14 = v7;
    v8 = "failed to stat Analytics dir: %s";
    v9 = v5;
    v10 = 12;
LABEL_11:
    _os_log_debug_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, v8, buf, v10);
    goto LABEL_8;
  }
}

void sub_100035910(uint64_t a1, char *a2)
{
  timespec v3;
  const void *v4;
  NSObject *v5;
  int *v6;
  char *v7;
  stat v8;
  uint8_t buf[4];
  char *v10;

  v3.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v3.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v8.st_blksize = v3;
  *(timespec *)v8.st_qspare = v3;
  v8.st_birthtimespec = v3;
  *(timespec *)&v8.st_size = v3;
  v8.st_mtimespec = v3;
  v8.st_ctimespec = v3;
  *(timespec *)&v8.st_uid = v3;
  v8.st_atimespec = v3;
  *(timespec *)&v8.st_dev = v3;
  if (stat(a2, &v8))
  {
    v4 = sub_100011628("helper");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      v6 = __error();
      v7 = strerror(*v6);
      *(_DWORD *)buf = 136315138;
      v10 = v7;
      _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "failed to stat TrustStore: %s", buf, 0xCu);
    }

    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  }
}

void sub_100035A04(uint64_t a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  id v10;

  v3 = a2;
  v4 = sub_100011628("SecError");
  v5 = objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = *(_QWORD *)(a1 + 32);
    v7 = 138543618;
    v8 = v6;
    v9 = 2112;
    v10 = v3;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "failed to talk to %{public}@: %@", (uint8_t *)&v7, 0x16u);
  }

}

void sub_100035AD0(uint64_t a1, char a2, void *a3)
{
  id v5;
  const void *v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  id v12;

  v5 = a3;
  if ((a2 & 1) == 0)
  {
    v6 = sub_100011628("SecError");
    v7 = objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = *(_QWORD *)(a1 + 32);
      v9 = 138543618;
      v10 = v8;
      v11 = 2112;
      v12 = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}@ failed to fix our files: %@", (uint8_t *)&v9, 0x16u);
    }

  }
}

BOOL sub_100035BA4()
{
  _BOOL8 result;
  CFArrayRef v1;
  char v2;
  CFArrayRef v3;
  char v4;

  if (qword_100082C48 != -1)
    dispatch_once(&qword_100082C48, &stru_1000768E0);
  if (byte_100082C40)
    return 1;
  if (qword_100082B90 != -1)
    dispatch_once(&qword_100082B90, &stru_100076440);
  if (byte_100082B88 != 1)
    return byte_100082C40 != 0;
  if (qword_100082B98 != -1)
    dispatch_once(&qword_100082B98, &stru_100076460);
  if ((byte_100082B88 & 1) == 0)
    return byte_100082C40 != 0;
  v1 = CFPreferencesCopyKeyList(CFSTR("com.apple.security"), kCFPreferencesAnyUser, kCFPreferencesAnyHost);
  v2 = sub_100035D3C((CFIndex)v1);
  if (v1)
    CFRelease(v1);
  if ((v2 & 1) != 0)
    goto LABEL_17;
  v3 = CFPreferencesCopyKeyList(CFSTR("com.apple.security"), kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  v4 = sub_100035D3C((CFIndex)v3);
  if (v3)
    CFRelease(v3);
  if ((v4 & 1) != 0)
  {
LABEL_17:
    result = 1;
  }
  else
  {
    if (qword_100082CA0 != -1)
      dispatch_once(&qword_100082CA0, &stru_100076988);
    dispatch_source_merge_data((dispatch_source_t)qword_100082CA8, 1uLL);
    result = 0;
  }
  byte_100082C40 = result;
  return result;
}

CFIndex sub_100035D3C(CFIndex result)
{
  const __CFArray *v1;
  CFIndex Count;
  CFIndex v3;
  CFIndex v4;
  const __CFString *ValueAtIndex;

  if (result)
  {
    v1 = (const __CFArray *)result;
    result = CFArrayGetCount((CFArrayRef)result);
    if (result)
    {
      Count = CFArrayGetCount(v1);
      if (Count < 1)
      {
        return 0;
      }
      else
      {
        v3 = Count;
        v4 = 0;
        while (1)
        {
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v1, v4);
          if (CFStringHasPrefix(ValueAtIndex, CFSTR("ApplePinningAllowTestCerts"))
            || CFStringHasPrefix(ValueAtIndex, CFSTR("AppleServerAuthenticationAllowUAT")))
          {
            if (CFPreferencesGetAppBooleanValue(ValueAtIndex, CFSTR("com.apple.security"), 0))
              break;
          }
          if (v3 == ++v4)
            return 0;
        }
        return 1;
      }
    }
  }
  return result;
}

void sub_100035E04(id a1)
{
  NSObject *v1;
  _QWORD *context;

  v1 = sub_10002B070(0, "pinning logging UAT", 300);
  qword_100082CA8 = (uint64_t)v1;
  context = dispatch_get_context(v1);
  context[2] = _Block_copy(&stru_1000769C8);
  dispatch_activate(v1);
}

void sub_100035E58(id a1)
{
  NSObject *v1;
  uint8_t v2[16];

  v1 = sub_100011628("pinningQA");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "could not enable test hierarchy: no UAT pinning preferences set", v2, 2u);
  }
}

void sub_100035EBC(id a1)
{
  NSObject *v1;
  _BOOL4 v2;
  BOOL v3;
  char v4;
  _QWORD block[7];
  char v6[8];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  char v14;

  v4 = 0;
  v11 = 0;
  v12 = &v11;
  v13 = 0x2000000000;
  v14 = 0;
  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = -1;
  if (qword_100082C50 != -1)
    dispatch_once(&qword_100082C50, &stru_100076920);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100036040;
  block[3] = &unk_100076948;
  block[6] = &v4;
  strcpy(v6, "ctaa");
  block[4] = &v7;
  block[5] = &v11;
  dispatch_sync((dispatch_queue_t)qword_100082C58, block);
  if (*((_DWORD *)v8 + 6))
  {
    _Block_object_dispose(&v7, 8);
    _Block_object_dispose(&v11, 8);
    v1 = sub_100011628("personalization");
    v2 = os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT);
    v3 = 0;
    if (v2)
    {
      LOWORD(block[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Failed to get entitlement BOOL", (uint8_t *)block, 2u);
      v3 = 0;
    }
  }
  else
  {
    v4 = *((_BYTE *)v12 + 24);
    _Block_object_dispose(&v7, 8);
    _Block_object_dispose(&v11, 8);
    v3 = v4 != 0;
  }
  byte_100082C40 = v3;
}

void sub_100036040(uint64_t a1)
{
  timespec v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  const char *v6;
  NSObject *v7;
  NSObject *v8;
  _BYTE *v9;
  int v10;
  int v11;
  off_t st_size;
  UInt8 *v13;
  UInt8 *v14;
  const __CFData *v15;
  int *v16;
  char *v17;
  NSObject *v18;
  int *v19;
  char *v20;
  const char *v21;
  NSObject *v22;
  uint32_t v23;
  NSObject *v24;
  NSObject *v25;
  int *v26;
  char *v27;
  NSObject *v28;
  int *v29;
  char *v30;
  uint64_t v31;
  char v32;
  uint64_t v33;
  const UInt8 *BytePtr;
  CFIndex Length;
  int v36;
  int v37;
  NSObject *v38;
  const char *v39;
  uint8_t *p_s2;
  NSObject *v41;
  __int128 v42;
  const UInt8 *v43;
  int inited;
  NSObject *v45;
  const __CFData *v46;
  timespec v47;
  NSObject *v48;
  const char *v49;
  size_t v50;
  int v51;
  NSObject *v52;
  uint32_t v53;
  int v54;
  NSObject *v55;
  const UInt8 *v56;
  NSObject *v57;
  int BooleanFromSection;
  char v59;
  uint64_t v60;
  uint8_t buf[4];
  off_t v62;
  __int16 v63;
  char *v64;
  _OWORD __b[65];
  stat __s2;

  if (qword_100082CB0 != -1)
    dispatch_once(&qword_100082CB0, &stru_100076A08);
  v2.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v2.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)__s2.st_qspare = v2;
  *(timespec *)&__s2.st_blksize = v2;
  *(timespec *)&__s2.st_size = v2;
  __s2.st_birthtimespec = v2;
  __s2.st_ctimespec = v2;
  __s2.st_mtimespec = v2;
  __s2.st_atimespec = v2;
  *(timespec *)&__s2.st_uid = v2;
  *(timespec *)&__s2.st_dev = v2;
  memset(__b, 170, 0x401uLL);
  v3 = lookupPathForPersonalizedData(2, __b, 1025);
  if (!v3)
  {
    v10 = open((const char *)__b, 0, 0);
    if (v10 < 0)
    {
      v5 = sub_100011628("personalization");
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        goto LABEL_7;
      v16 = __error();
      v17 = strerror(*v16);
      *(_DWORD *)buf = 136315138;
      v62 = (off_t)v17;
      v6 = "unable to open ticket file: %s";
      goto LABEL_6;
    }
    v11 = v10;
    if (fstat(v10, &__s2) < 0)
    {
      v18 = sub_100011628("personalization");
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        goto LABEL_32;
      v19 = __error();
      v20 = strerror(*v19);
      *(_DWORD *)buf = 136315138;
      v62 = (off_t)v20;
      v21 = "failed to stat ticket file: %s";
      v22 = v18;
      v23 = 12;
    }
    else
    {
      st_size = __s2.st_size;
      if (__s2.st_size < 0)
      {
        v24 = sub_100011628("personalization");
        if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          goto LABEL_32;
        *(_WORD *)buf = 0;
        v21 = "file size is negative";
        v22 = v24;
        v23 = 2;
      }
      else
      {
        v13 = (UInt8 *)malloc_type_malloc(__s2.st_size, 0x6554D264uLL);
        if (v13)
        {
          v14 = v13;
          if (read(v11, v13, st_size) == st_size)
          {
            v15 = CFDataCreateWithBytesNoCopy(0, v14, st_size, kCFAllocatorMalloc);
            if (!v15)
              free(v14);
LABEL_33:
            if (v11)
              close(v11);
            if (!v15)
              goto LABEL_7;
            if (!byte_100082C60)
            {
              v41 = sub_100011628("SecError");
              if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(__b[0]) = 0;
                _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "Got a non-img4 ticket.", (uint8_t *)__b, 2u);
              }
              goto LABEL_69;
            }
            v31 = *(unsigned int *)(a1 + 56);
            v32 = *(_BYTE *)(a1 + 60);
            v33 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
            v60 = 0;
            v59 = v32;
            BytePtr = CFDataGetBytePtr(v15);
            Length = CFDataGetLength(v15);
            v36 = Img4DecodeParseLengthFromBufferWithTag((uint64_t)BytePtr, Length, 0x494D344Du, &v60);
            if (v36)
            {
              v37 = v36;
              v38 = sub_100011628("personalization");
              if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(__b[0]) = 67109120;
                DWORD1(__b[0]) = v37;
                v39 = "Failed to get manifest length: %d";
                p_s2 = (uint8_t *)__b;
LABEL_66:
                v52 = v38;
                v53 = 8;
LABEL_67:
                _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, v39, p_s2, v53);
              }
LABEL_68:
              *(_BYTE *)(v33 + 24) = v32;
              *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v37;
LABEL_69:
              CFRelease(v15);
              return;
            }
            *(_QWORD *)&__b[28] = 0xAAAAAAAAAAAAAAAALL;
            *(_QWORD *)&v42 = 0xAAAAAAAAAAAAAAAALL;
            *((_QWORD *)&v42 + 1) = 0xAAAAAAAAAAAAAAAALL;
            __b[26] = v42;
            __b[27] = v42;
            __b[24] = v42;
            __b[25] = v42;
            __b[22] = v42;
            __b[23] = v42;
            __b[20] = v42;
            __b[21] = v42;
            __b[18] = v42;
            __b[19] = v42;
            __b[16] = v42;
            __b[17] = v42;
            __b[14] = v42;
            __b[15] = v42;
            __b[12] = v42;
            __b[13] = v42;
            __b[10] = v42;
            __b[11] = v42;
            __b[8] = v42;
            __b[9] = v42;
            __b[6] = v42;
            __b[7] = v42;
            __b[4] = v42;
            __b[5] = v42;
            __b[2] = v42;
            __b[3] = v42;
            __b[0] = v42;
            __b[1] = v42;
            if (v60 != Length)
            {
              v45 = sub_100011628("personalization");
              if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
              {
                __s2.st_dev = 134218240;
                *(_QWORD *)&__s2.st_mode = v60;
                WORD2(__s2.st_ino) = 2048;
                *(__darwin_ino64_t *)((char *)&__s2.st_ino + 6) = Length;
                _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "Incorrect amount of data in retrieved manifest. Parsed length: %zu; Have: %zu",
                  (uint8_t *)&__s2,
                  0x16u);
              }
              v37 = 7;
              goto LABEL_68;
            }
            cc_clear(456, __b);
            v43 = CFDataGetBytePtr(v15);
            inited = Img4DecodeInitManifest((uint64_t)v43, v60, (uint64_t)__b);
            if (inited)
            {
              v37 = inited;
              v38 = sub_100011628("personalization");
              if (!os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
                goto LABEL_68;
              __s2.st_dev = 67109120;
              *(_DWORD *)&__s2.st_mode = v37;
              v39 = "Failed to initialize manifest: %d";
              goto LABEL_65;
            }
            if (qword_100082CC8 != -1)
              dispatch_once(&qword_100082CC8, &stru_100076A48);
            v46 = (const __CFData *)qword_100082CB8;
            if (qword_100082CB8)
              CFRetain((CFTypeRef)qword_100082CB8);
            v47.tv_sec = 0xAAAAAAAAAAAAAAAALL;
            v47.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
            *(timespec *)&__s2.st_uid = v47;
            __s2.st_atimespec = v47;
            *(timespec *)&__s2.st_dev = v47;
            v37 = dword_1000827C8;
            if (dword_1000827C8)
            {
              v48 = sub_100011628("personalization");
              if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 67109120;
                LODWORD(v62) = v37;
                v49 = "failed to read boot-manifest-hash from device tree: %d";
LABEL_59:
                _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, v49, buf, 8u);
              }
            }
            else
            {
              v50 = qword_100082CC0;
              v51 = Img4DecodeCopyManifestDigest((uint64_t)__b, &__s2, qword_100082CC0, (uint64_t (**)(uint64_t, _QWORD, _OWORD *, size_t, _QWORD))&xmmword_100082C68);
              if (!v51)
              {
                v56 = CFDataGetBytePtr(v46);
                if (!memcmp(v56, &__s2, v50))
                {
                  v37 = 0;
                }
                else
                {
                  v57 = sub_100011628("personalization");
                  if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "manifest read does not match boot-manifest-hash", buf, 2u);
                  }
                  v37 = 3;
                }
                goto LABEL_60;
              }
              v37 = v51;
              v48 = sub_100011628("personalization");
              if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 67109120;
                LODWORD(v62) = v37;
                v49 = "unable to copy digest of manifest: %d";
                goto LABEL_59;
              }
            }
LABEL_60:
            if (v46)
              CFRelease(v46);
            if (!v37)
            {
              Img4DecodePerformTrustEvaluation(0x6B726E6Cu, (uint64_t)__b, (uint64_t)sub_100036908, (uint64_t)&xmmword_100082C68, 0);
              if (!v54)
              {
                BooleanFromSection = Img4DecodeGetBooleanFromSection((uint64_t)__b, 0, v31, (BOOL *)&v59);
                if (BooleanFromSection == 1)
                {
                  v37 = 0;
                }
                else
                {
                  v32 = v59;
                  v37 = BooleanFromSection;
                }
                goto LABEL_68;
              }
              v37 = v54;
              v55 = sub_100011628("personalization");
              if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(__s2.st_dev) = 0;
                v39 = "failed to verify ap ticket";
                p_s2 = (uint8_t *)&__s2;
                v52 = v55;
                v53 = 2;
                goto LABEL_67;
              }
              goto LABEL_68;
            }
            v38 = sub_100011628("personalization");
            if (!os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
              goto LABEL_68;
            __s2.st_dev = 67109120;
            *(_DWORD *)&__s2.st_mode = v37;
            v39 = "Manifest digests did not match: %d";
LABEL_65:
            p_s2 = (uint8_t *)&__s2;
            goto LABEL_66;
          }
          v28 = sub_100011628("personalization");
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            v29 = __error();
            v30 = strerror(*v29);
            *(_DWORD *)buf = 136315138;
            v62 = (off_t)v30;
            _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "failed to read ticket data: %s", buf, 0xCu);
          }
          free(v14);
LABEL_32:
          v15 = 0;
          goto LABEL_33;
        }
        v25 = sub_100011628("personalization");
        if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
          goto LABEL_32;
        v26 = __error();
        v27 = strerror(*v26);
        *(_DWORD *)buf = 134218242;
        v62 = st_size;
        v63 = 2080;
        v64 = v27;
        v21 = "failed to allocate %zu bytes: %s";
        v22 = v25;
        v23 = 22;
      }
    }
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, v21, buf, v23);
    goto LABEL_32;
  }
  v4 = v3;
  v5 = sub_100011628("personalization");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    v62 = v4;
    v6 = "failed to get ticket file path: %ld";
LABEL_6:
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v6, buf, 0xCu);
  }
LABEL_7:
  v7 = sub_100011628("personalization");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__b[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Unable to read personalization ticket from disk", (uint8_t *)__b, 2u);
  }
  v8 = sub_100011628("personalization");
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__b[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Failed to get ticket", (uint8_t *)__b, 2u);
  }
  v9 = *(_BYTE **)(a1 + 48);
  if (v9)
    *v9 = *(_BYTE *)(a1 + 60);
}

uint64_t sub_100036908()
{
  return 0;
}

void sub_100036910(id a1)
{
  io_registry_entry_t v1;
  io_registry_entry_t v2;
  const __CFString *v3;
  const __CFData *CFProperty;
  const __CFData *v5;
  const UInt8 *BytePtr;
  CFIndex Length;
  const __CFString *v8;
  NSObject *v9;
  NSObject *v10;
  int v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t (**v14)();
  __int128 v15;
  NSObject *v16;
  const void *v17;
  NSObject *v18;
  NSObject *v19;
  int v20;
  const __CFString *v21;

  v1 = IORegistryEntryFromPath(kIOMainPortDefault, "IODeviceTree:/chosen");
  if (v1)
  {
    v2 = v1;
    if (byte_100082C60)
      v3 = CFSTR("boot-manifest-hash");
    else
      v3 = CFSTR("root-ticket-hash");
    qword_100082CB8 = (uint64_t)IORegistryEntryCreateCFProperty(v1, v3, kCFAllocatorDefault, 0);
    if (!qword_100082CB8)
    {
      v19 = sub_100011628("personalization");
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v20) = 0;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "unable to read manifest hash", (uint8_t *)&v20, 2u);
      }
      v8 = 0;
      v5 = 0;
      goto LABEL_30;
    }
    CFProperty = (const __CFData *)IORegistryEntryCreateCFProperty(v2, CFSTR("crypto-hash-method"), kCFAllocatorDefault, 0);
    v5 = CFProperty;
    if (CFProperty)
    {
      BytePtr = CFDataGetBytePtr(CFProperty);
      Length = CFDataGetLength(v5);
      v8 = CFStringCreateWithBytes(0, BytePtr, Length - 1, 0x8000100u, 0);
      v9 = sub_100011628("personalization");
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        v20 = 138412290;
        v21 = v8;
        _os_log_debug_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "using hash method %@", (uint8_t *)&v20, 0xCu);
      }
    }
    else
    {
      v8 = CFSTR("sha1");
    }
    if (CFStringCompare(CFSTR("sha1"), v8, 0))
    {
      if (CFStringCompare(CFSTR("sha2-384"), v8, 0))
      {
        v10 = sub_100011628("personalization");
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          v20 = 138412290;
          v21 = v8;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "unknown hash found in crypto-hash-method entry: %@", (uint8_t *)&v20, 0xCu);
        }
        v11 = 2;
        goto LABEL_29;
      }
      if (qword_100082CD0 != -1)
        dispatch_once(&qword_100082CD0, &stru_100076A88);
      if (byte_100082CD8)
      {
        v13 = sub_100011628("personalization");
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
        {
          LOWORD(v20) = 0;
          _os_log_debug_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "using DDI root", (uint8_t *)&v20, 2u);
        }
        v14 = kImg4DecodeSecureBootRsa4kSha384DDI;
      }
      else
      {
        v14 = kImg4DecodeSecureBootRsa4kSha384;
      }
      v15 = *((_OWORD *)v14 + 1);
      xmmword_100082C68 = *(_OWORD *)v14;
      unk_100082C78 = v15;
      xmmword_100082C88 = *((_OWORD *)v14 + 2);
      qword_100082C98 = (uint64_t)v14[6];
      v12 = 48;
    }
    else
    {
      xmmword_100082C68 = *(_OWORD *)kImg4DecodeSecureBootRsa1kSha1;
      unk_100082C78 = *(_OWORD *)off_1000758C8;
      xmmword_100082C88 = *(_OWORD *)&off_1000758D8;
      qword_100082C98 = (uint64_t)&oidRsa;
      v12 = 20;
    }
    qword_100082CC0 = v12;
    if (v12 == CFDataGetLength((CFDataRef)qword_100082CB8))
    {
      dword_1000827C8 = 0;
LABEL_30:
      IOObjectRelease(v2);
      goto LABEL_31;
    }
    v16 = sub_100011628("personalization");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v20) = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "boot-manifest-hash length does not match crypto-hash-method", (uint8_t *)&v20, 2u);
    }
    v11 = 6;
LABEL_29:
    dword_1000827C8 = v11;
    goto LABEL_30;
  }
  v18 = sub_100011628("personalization");
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v20) = 0;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Unable to read chosen node", (uint8_t *)&v20, 2u);
  }
  v5 = 0;
  v8 = 0;
LABEL_31:
  if (dword_1000827C8)
  {
    v17 = (const void *)qword_100082CB8;
    if (qword_100082CB8)
    {
      qword_100082CB8 = 0;
      CFRelease(v17);
    }
    qword_100082CC0 = 0;
  }
  if (v5)
    CFRelease(v5);
  if (v8)
    CFRelease(v8);
}

void sub_100036D40(id a1)
{
  size_t v1;
  int v2;

  v2 = 0;
  v1 = 4;
  if (!sysctlbyname("kern.hv_vmm_present", &v2, &v1, 0, 0))
    byte_100082CD8 = v2 == 1;
}

void sub_100036D98(id a1)
{
  io_registry_entry_t v1;
  io_object_t v2;
  CFTypeRef CFProperty;
  NSObject *v4;
  _BOOL4 v5;
  char v6;
  NSObject *v7;
  _BOOL4 v8;
  uint8_t v9[16];
  uint8_t buf[16];
  uint8_t v11[16];

  v1 = IORegistryEntryFromPath(kIOMainPortDefault, "IODeviceTree:/chosen");
  if (!v1)
  {
    v7 = sub_100011628("personalization");
    v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    v6 = 0;
    if (!v8)
      goto LABEL_10;
    *(_WORD *)v11 = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Unable to read chosen node", v11, 2u);
    goto LABEL_9;
  }
  v2 = v1;
  CFProperty = IORegistryEntryCreateCFProperty(v1, CFSTR("image4-supported"), kCFAllocatorDefault, 0);
  v4 = sub_100011628("personalization");
  v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG);
  if (!CFProperty)
  {
    if (v5)
    {
      *(_WORD *)buf = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "img3 device", buf, 2u);
    }
    IOObjectRelease(v2);
LABEL_9:
    v6 = 0;
    goto LABEL_10;
  }
  if (v5)
  {
    *(_WORD *)v9 = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "img4 device", v9, 2u);
  }
  IOObjectRelease(v2);
  CFRelease(CFProperty);
  v6 = 1;
LABEL_10:
  byte_100082C60 = v6;
}

void sub_100036EF4(id a1)
{
  qword_100082C58 = (uint64_t)dispatch_queue_create("apticket", 0);
}

void sub_100037064(double *a1)
{
  uint64_t v1;
  const __CFArray *v2;
  const __CFURL *v3;
  double v4;
  int v5;
  const __CFData *v6;
  CFMutableDataRef Mutable;
  sqlite3_stmt *v8;
  const UInt8 *BytePtr;
  unint64_t Length;
  unsigned int v11;
  sqlite3_stmt *v12;
  const UInt8 *v13;
  unint64_t v14;
  int v15;
  NSObject *v16;
  const char *v17;
  uint64_t v18;
  int v19;
  int v20;
  NSObject *v21;
  const char *v22;
  __int128 v23;
  void (*v24)(uint64_t, SecCertificateRef);
  void *v25;
  CFMutableDataRef v26;
  CFRange v27;

  v1 = qword_100082CE8;
  v2 = (const __CFArray *)*((_QWORD *)a1 + 4);
  v3 = (const __CFURL *)*((_QWORD *)a1 + 5);
  v4 = a1[6];
  v5 = sub_100037390(qword_100082CE8);
  if (v5)
  {
    v15 = v5;
    goto LABEL_20;
  }
  v6 = CFURLCreateData(kCFAllocatorDefault, v3, 0x8000100u, 0);
  if (v6)
  {
    Mutable = v6;
    if (CFDataGetLength(v6) < 1)
    {
LABEL_30:
      CFRelease(Mutable);
      goto LABEL_19;
    }
    v8 = *(sqlite3_stmt **)(v1 + 40);
    BytePtr = CFDataGetBytePtr(Mutable);
    Length = CFDataGetLength(Mutable);
    if (Length >> 31)
    {
      CFRelease(Mutable);
      v11 = 18;
      if (!v2)
        goto LABEL_19;
LABEL_9:
      if (!CFArrayGetCount(v2))
        goto LABEL_19;
      Mutable = CFDataCreateMutable(0, 0);
      *(_QWORD *)&v23 = _NSConcreteStackBlock;
      *((_QWORD *)&v23 + 1) = 0x40000000;
      v24 = sub_1000373F0;
      v25 = &unk_100076C30;
      v26 = Mutable;
      v27.length = CFArrayGetCount(v2);
      v27.location = 0;
      CFArrayApplyFunction(v2, v27, (CFArrayApplierFunction)sub_10003745C, &v23);
      if (!Mutable)
        goto LABEL_19;
      if (CFDataGetLength(Mutable) >= 1)
      {
        if (!v11)
        {
          v12 = *(sqlite3_stmt **)(v1 + 40);
          v13 = CFDataGetBytePtr(Mutable);
          v14 = CFDataGetLength(Mutable);
          if (!(v14 >> 31))
          {
            v11 = sqlite3_bind_blob(v12, 3, v13, v14, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
            CFRelease(Mutable);
            if (!v11)
              v11 = sqlite3_step(*(sqlite3_stmt **)(v1 + 40));
LABEL_16:
            v15 = sub_100037470(*(sqlite3_stmt **)(v1 + 40), v11);
            if (!v15)
              goto LABEL_23;
            goto LABEL_20;
          }
          v11 = 18;
        }
        CFRelease(Mutable);
        goto LABEL_16;
      }
      goto LABEL_30;
    }
    v11 = sqlite3_bind_blob(v8, 1, BytePtr, Length, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
    CFRelease(Mutable);
    if (v11)
    {
      if (v2)
        goto LABEL_9;
    }
    else
    {
      v11 = sqlite3_bind_double(*(sqlite3_stmt **)(v1 + 40), 2, v4);
      if (v2)
        goto LABEL_9;
    }
  }
LABEL_19:
  v15 = 7;
LABEL_20:
  v16 = sub_100011628("SecError");
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    v17 = sqlite3_errmsg(*(sqlite3 **)(v1 + 8));
    LODWORD(v23) = 136315138;
    *(_QWORD *)((char *)&v23 + 4) = v17;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "caissuer cache add failed: %s", (uint8_t *)&v23, 0xCu);
  }
  sub_1000521A8(3, 2, v15);
LABEL_23:
  v18 = qword_100082CE8;
  v19 = sub_1000374BC(qword_100082CE8);
  if (v19)
  {
    v20 = v19;
    v21 = sub_100011628("SecError");
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      v22 = sqlite3_errmsg(*(sqlite3 **)(v18 + 8));
      LODWORD(v23) = 136315138;
      *(_QWORD *)((char *)&v23 + 4) = v22;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "caissuer cache flush failed: %s", (uint8_t *)&v23, 0xCu);
    }
    sub_1000521A8(3, 2, v20);
  }
}

uint64_t sub_100037390(uint64_t a1)
{
  uint64_t result;
  unsigned int v3;
  BOOL v4;

  if (*(_BYTE *)(a1 + 64))
    return 0;
  v3 = sqlite3_step(*(sqlite3_stmt **)(a1 + 24));
  if (v3 == 101)
  {
    v3 = 0;
    *(_BYTE *)(a1 + 64) = 1;
  }
  LODWORD(result) = sqlite3_reset(*(sqlite3_stmt **)(a1 + 24));
  if ((_DWORD)result)
    v4 = v3 == 0;
  else
    v4 = 0;
  if (v4)
    return result;
  else
    return v3;
}

void sub_1000373F0(uint64_t a1, SecCertificateRef certificate)
{
  const __CFData *v3;
  const __CFData *v4;
  __CFData *v5;
  const UInt8 *BytePtr;
  CFIndex Length;

  v3 = SecCertificateCopyData(certificate);
  if (v3)
  {
    v4 = v3;
    v5 = *(__CFData **)(a1 + 32);
    BytePtr = CFDataGetBytePtr(v3);
    Length = CFDataGetLength(v4);
    CFDataAppendBytes(v5, BytePtr, Length);
    CFRelease(v4);
  }
}

uint64_t sub_10003745C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_100037470(sqlite3_stmt *a1, unsigned int a2)
{
  unsigned int v3;
  int v4;
  BOOL v5;
  uint64_t result;
  BOOL v7;

  if ((a2 & 0xFFFFFFFE) == 0x64)
    v3 = 0;
  else
    v3 = a2;
  v4 = sqlite3_reset(a1);
  if (v4)
    v5 = v3 == 0;
  else
    v5 = 0;
  if (v5)
    v3 = v4;
  LODWORD(result) = sqlite3_clear_bindings(a1);
  if (v3)
    v7 = 1;
  else
    v7 = (_DWORD)result == 0;
  if (v7)
    return v3;
  else
    return result;
}

uint64_t sub_1000374BC(uint64_t a1)
{
  unsigned int v2;
  uint64_t result;
  BOOL v4;

  if (!*(_BYTE *)(a1 + 64))
    return 0;
  v2 = sqlite3_step(*(sqlite3_stmt **)(a1 + 32));
  if (v2 == 101)
  {
    v2 = 0;
    *(_BYTE *)(a1 + 64) = 0;
  }
  LODWORD(result) = sqlite3_reset(*(sqlite3_stmt **)(a1 + 32));
  if ((_DWORD)result)
    v4 = v2 == 0;
  else
    v4 = 0;
  if (v4)
    return result;
  else
    return v2;
}

void sub_10003751C(id a1, const char *a2)
{
  sqlite3 **v3;
  dispatch_queue_t v4;
  sqlite3 **v5;
  int v6;
  size_t v7;
  sqlite3 *v8;
  size_t v9;
  size_t v10;
  size_t v11;
  int v12;
  int v13;
  int v14;
  NSObject *v15;
  char *errmsg;
  _DWORD __b[258];

  v3 = (sqlite3 **)malloc_type_calloc(0x48uLL, 1uLL, 0xC141852AuLL);
  if (!v3)
    goto LABEL_39;
  v4 = dispatch_queue_create("caissuercache", 0);
  *v3 = (sqlite3 *)v4;
  if (!v4)
  {
    v6 = -108;
    goto LABEL_6;
  }
  v5 = v3 + 1;
  v6 = sqlite3_open_v2(a2, v3 + 1, 4194310, 0);
  if (v6 != 14)
  {
LABEL_24:
    if (v6)
      goto LABEL_6;
    *((_BYTE *)v3 + 64) = 0;
    v14 = sqlite3_prepare_v2(v3[1], "BEGIN EXCLUSIVE TRANSACTION", 28, v3 + 3, 0);
    if (!v14)
    {
      v14 = sqlite3_prepare_v2(v3[1], "COMMIT TRANSACTION", 19, v3 + 4, 0);
      if (!v14)
      {
        v6 = sqlite3_prepare_v2(v3[1], "DELETE FROM issuers", 20, v3 + 2, 0);
        if (v6 == 1)
        {
          v14 = sub_100037390((uint64_t)v3);
          if (v14)
            goto LABEL_47;
          errmsg = 0;
          v6 = sqlite3_exec(*v5, "CREATE TABLE issuers(uri BLOB PRIMARY KEY,expires DOUBLE NOT NULL,certificate BLOB NOT NULL);CREATE IND"
                 "EX iexpires ON issuers(expires);",
                 0,
                 0,
                 &errmsg);
          if (errmsg)
          {
            v15 = sub_100011628("SecError");
            if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
            {
              __b[0] = 136315138;
              *(_QWORD *)&__b[1] = errmsg;
              _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "caissuer db CREATE TABLES: %s", (uint8_t *)__b, 0xCu);
            }
            sqlite3_free(errmsg);
          }
          if (v6)
            goto LABEL_6;
          v6 = sqlite3_prepare_v2(*v5, "DELETE FROM issuers", 20, v3 + 2, 0);
        }
        if (v6)
          goto LABEL_6;
        v14 = sqlite3_prepare_v2(v3[1], "INSERT OR REPLACE INTO issuers (uri,expires,certificate) VALUES (?,?,?)", 72, v3 + 5, 0);
        if (!v14)
        {
          v14 = sqlite3_prepare_v2(v3[1], "SELECT certificate FROM issuers WHERE uri=?", 44, v3 + 6, 0);
          if (!v14)
          {
            v14 = sqlite3_prepare_v2(v3[1], "SELECT certificate FROM issuers WHERE uri=? and expires>?", 58, v3 + 7, 0);
            if (!v14)
              goto LABEL_39;
          }
        }
      }
    }
LABEL_47:
    v6 = v14;
    goto LABEL_6;
  }
  v7 = strlen(a2);
  if (v7 - 1025 >= 0xFFFFFFFFFFFFFC00)
  {
    v9 = v7;
    memset(__b, 170, 0x400uLL);
    __memcpy_chk(__b, a2, v9, 1024);
    v10 = v9 - 1;
    do
    {
      if (!v10)
        goto LABEL_23;
      v11 = v10;
      v12 = *((unsigned __int8 *)__b + v10--);
    }
    while (v12 != 47);
    *((_BYTE *)__b + v11) = 0;
    if (mkdir((const char *)__b, 0x1FFu))
    {
      v13 = *__error();
      if (v13 > 19)
      {
        if (v13 <= 29)
        {
          if (v13 == 20)
            goto LABEL_5;
          if (v13 != 28)
            goto LABEL_46;
LABEL_43:
          v6 = 13;
          goto LABEL_6;
        }
        if (v13 == 69)
          goto LABEL_43;
        if (v13 == 30)
        {
          v6 = 8;
          goto LABEL_6;
        }
LABEL_46:
        v6 = 2;
        goto LABEL_6;
      }
      if (v13 == 5)
      {
        v6 = 10;
        goto LABEL_6;
      }
      if (v13 == 13)
      {
        v6 = 3;
        goto LABEL_6;
      }
      if (v13 != 17)
        goto LABEL_46;
    }
LABEL_23:
    v6 = sqlite3_open(a2, v3 + 1);
    goto LABEL_24;
  }
LABEL_5:
  v6 = 14;
LABEL_6:
  sub_1000521A8(3, 0, v6);
  if (*v3)
    dispatch_release((dispatch_object_t)*v3);
  v8 = v3[1];
  if (v8)
    sqlite3_close(v8);
  free(v3);
  v3 = 0;
LABEL_39:
  qword_100082CE8 = (uint64_t)v3;
}

void sub_1000378BC(uint64_t a1)
{
  uint64_t v2;
  int v3;
  const __CFData *v4;
  const __CFData *Mutable;
  uint64_t v6;
  sqlite3_stmt *v7;
  const UInt8 *BytePtr;
  unint64_t Length;
  unsigned int v10;
  char *v11;
  int v12;
  int v14;
  int v15;
  NSObject *v16;
  const char *v17;
  double Current;
  int v19;
  char *v20;
  const void *v21;
  const void *v22;
  int v23;
  const char *v24;

  v2 = qword_100082CE8;
  v3 = *(unsigned __int8 *)(a1 + 48);
  v4 = CFURLCreateData(kCFAllocatorDefault, *(CFURLRef *)(a1 + 40), 0x8000100u, 0);
  Mutable = v4;
  if (!v4)
    goto LABEL_24;
  if (CFDataGetLength(v4) >= 1)
  {
    v6 = 48;
    if (!v3)
      v6 = 56;
    v7 = *(sqlite3_stmt **)(v2 + v6);
    BytePtr = CFDataGetBytePtr(Mutable);
    Length = CFDataGetLength(Mutable);
    if (Length >> 31)
      v10 = 18;
    else
      v10 = sqlite3_bind_blob(v7, 1, BytePtr, Length, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
    CFRelease(Mutable);
    if (v3)
    {
      if (v10)
      {
LABEL_10:
        if (v10 == 100)
        {
          v11 = (char *)sqlite3_column_blob(v7, 0);
          v12 = sqlite3_column_bytes(v7, 0);
          if (v11 && v12 != 0)
          {
            v19 = v12;
            Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
            if (v19 >= 1)
            {
              v20 = &v11[v19];
              do
              {
                v21 = (const void *)SecCertificateCreateWithBytes(0);
                if (!v21)
                  break;
                v22 = v21;
                CFArrayAppendValue(Mutable, v21);
                v11 += SecCertificateGetLength(v22);
                v19 -= SecCertificateGetLength(v22);
                CFRelease(v22);
              }
              while (v11 < v20);
            }
            if (CFArrayGetCount(Mutable) > 0 || !Mutable)
            {
LABEL_17:
              v14 = sub_100037470(v7, v10);
              if (!v14)
                goto LABEL_24;
              v15 = v14;
              if (v14 == 101)
                goto LABEL_22;
              goto LABEL_19;
            }
            CFRelease(Mutable);
          }
        }
        Mutable = 0;
        goto LABEL_17;
      }
    }
    else
    {
      Current = CFAbsoluteTimeGetCurrent();
      v10 = sqlite3_bind_double(v7, 2, Current);
      if (v10)
        goto LABEL_10;
    }
    v10 = sqlite3_step(v7);
    goto LABEL_10;
  }
  CFRelease(Mutable);
  Mutable = 0;
  v15 = 7;
LABEL_19:
  v16 = sub_100011628("SecError");
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    v17 = sqlite3_errmsg(*(sqlite3 **)(v2 + 8));
    v23 = 136315138;
    v24 = v17;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "caissuer cache lookup failed: %s", (uint8_t *)&v23, 0xCu);
  }
  sub_1000521A8(3, 3, v15);
LABEL_22:
  if (Mutable)
  {
    CFRelease(Mutable);
    Mutable = 0;
  }
LABEL_24:
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = Mutable;
}

void sub_100037B7C(id a1)
{
  uint64_t v1;
  int v2;
  NSObject *v3;
  unsigned int v4;
  int v5;
  NSObject *v6;
  const char *v7;
  int v8;
  const char *v9;

  v1 = qword_100082CE8;
  v2 = sub_100037390(qword_100082CE8);
  if (v2)
    goto LABEL_10;
  v3 = sub_100011628("caissuercache");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v8) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "clearing CAIssuer cache", (uint8_t *)&v8, 2u);
  }
  v4 = sqlite3_step(*(sqlite3_stmt **)(v1 + 16));
  v2 = sub_100037470(*(sqlite3_stmt **)(v1 + 16), v4);
  if (v2)
  {
LABEL_10:
    v5 = v2;
  }
  else
  {
    v5 = sub_1000374BC(v1);
    if (!v5)
      return;
  }
  v6 = sub_100011628("SecError");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v7 = sqlite3_errmsg(*(sqlite3 **)(v1 + 8));
    v8 = 136315138;
    v9 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "caissuer cache delete failed: %s", (uint8_t *)&v8, 0xCu);
  }
  sub_1000521A8(3, 2, v5);
}

void sub_1000382FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  _Block_object_dispose(&a29, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100038484(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_100038494(uint64_t a1)
{

}

uint64_t sub_10003849C(uint64_t a1)
{
  return ((uint64_t (*)(_QWORD, _QWORD))objc_msgSend(*(id *)(a1 + 32), "callback"))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40));
}

void sub_1000384D8(uint64_t a1)
{
  const __CFArray *v2;
  id v3;

  v2 = (const __CFArray *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "URIs"));
  v3 = sub_10003855C(0, v2, 1);

  ((void (*)(_QWORD, id))objc_msgSend(*(id *)(a1 + 32), "callback"))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), v3);
  if (v3)
    CFRelease(v3);
}

id sub_10003855C(uint64_t a1, CFArrayRef theArray, char a3)
{
  const __CFArray *v3;
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;
  const __CFURL *ValueAtIndex;
  CFStringRef v9;
  CFStringRef v10;
  NSObject *v11;
  id v12;
  const void *NormalizedIssuerContent;
  void *v14;
  id v15;
  id v16;
  id v17;
  uint64_t v18;
  void *i;
  uint64_t v20;
  const void *NormalizedSubjectContent;
  uint64_t v23;
  const __CFArray *v24;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  _QWORD block[6];
  char v31;

  v3 = theArray;
  Count = CFArrayGetCount(theArray);
  if (Count >= 1)
  {
    v6 = Count;
    v7 = 0;
    v23 = a1;
    v24 = v3;
    do
    {
      ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v3, v7);
      v9 = CFURLCopyScheme(ValueAtIndex);
      if (v9)
      {
        v10 = v9;
        if (CFEqual(CFSTR("http"), v9))
        {
          if (qword_100082CE0 != -1)
            dispatch_once(&qword_100082CE0, &stru_100076B28);
          *(_QWORD *)&v26 = 0;
          *((_QWORD *)&v26 + 1) = &v26;
          v27 = 0x2000000000uLL;
          if (qword_100082CE8)
          {
            v11 = *(NSObject **)qword_100082CE8;
            block[0] = _NSConcreteStackBlock;
            block[1] = 0x40000000;
            block[2] = sub_1000378BC;
            block[3] = &unk_100076B50;
            block[4] = &v26;
            block[5] = ValueAtIndex;
            v31 = a3;
            dispatch_sync(v11, block);
            v12 = *(id *)(*((_QWORD *)&v26 + 1) + 24);
          }
          else
          {
            v12 = 0;
          }
          _Block_object_dispose(&v26, 8);
          if (a1)
          {
            NormalizedIssuerContent = (const void *)SecCertificateGetNormalizedIssuerContent(a1);
            v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
            v26 = 0u;
            v27 = 0u;
            v28 = 0u;
            v29 = 0u;
            v15 = v12;
            v16 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v26, block, 16);
            if (v16)
            {
              v17 = v16;
              v18 = *(_QWORD *)v27;
              do
              {
                for (i = 0; i != v17; i = (char *)i + 1)
                {
                  if (*(_QWORD *)v27 != v18)
                    objc_enumerationMutation(v15);
                  v20 = *(_QWORD *)(*((_QWORD *)&v26 + 1) + 8 * (_QWORD)i);
                  NormalizedSubjectContent = (const void *)SecCertificateGetNormalizedSubjectContent(v20);
                  if (NormalizedIssuerContent
                    && NormalizedSubjectContent
                    && CFEqual(NormalizedIssuerContent, NormalizedSubjectContent))
                  {
                    objc_msgSend(v14, "addObject:", v20);
                  }
                }
                v17 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v26, block, 16);
              }
              while (v17);
            }

            if (objc_msgSend(v14, "count"))
              v12 = v14;
            else
              v12 = 0;
            v3 = v24;

            a1 = v23;
          }
          if (v12)
          {
            CFRelease(v10);
            return v12;
          }
        }
        CFRelease(v10);
      }
      ++v7;
    }
    while (v7 != v6);
  }
  return 0;
}

void sub_100038814(id a1)
{
  CAIssuerDelegate *v1;
  void *v2;
  TrustURLSessionCache *v3;
  TrustURLSessionCache *v4;
  void *v5;

  v1 = objc_alloc_init(CAIssuerDelegate);
  v2 = (void *)qword_100082CF8;
  qword_100082CF8 = (uint64_t)v1;

  v3 = [TrustURLSessionCache alloc];
  v4 = -[TrustURLSessionCache initWithDelegate:](v3, "initWithDelegate:", qword_100082CF8);
  v5 = (void *)qword_100082CF0;
  qword_100082CF0 = (uint64_t)v4;

}

uint64_t sub_100038868(uint64_t a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass(&unk_100076CC0);
  **(_QWORD **)(a1 + 32) = result;
  return result;
}

CFStringRef sub_100038898(uint64_t a1)
{
  return CFCopyDescription(*(CFTypeRef *)(a1 + 16));
}

CFStringRef sub_1000388A0(uint64_t a1)
{
  sub_100026A10();
  return CFCopyDescription(*(CFTypeRef *)(a1 + 16));
}

uint64_t sub_1000388C4(uint64_t a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass(&unk_100076D40);
  **(_QWORD **)(a1 + 32) = result;
  return result;
}

__CFString *sub_1000388F4(_QWORD *a1)
{
  __CFString *Mutable;
  CFTypeID v3;
  CFStringRef v4;
  uint64_t v5;
  const __CFString *v6;

  Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
  v3 = CFGetTypeID(a1);
  v4 = CFCopyTypeIDDescription(v3);
  CFStringAppendFormat(Mutable, 0, CFSTR("<%@ certs: "), v4);
  CFRelease(v4);
  if ((uint64_t)a1[2] >= 1)
  {
    v5 = 0;
    do
    {
      if (v5)
        CFStringAppend(Mutable, CFSTR(", "));
      v6 = CFCopyDescription((CFTypeRef)a1[v5 + 17]);
      CFStringAppend(Mutable, v6);
      CFRelease(v6);
      ++v5;
    }
    while (v5 < a1[2]);
  }
  CFStringAppend(Mutable, CFSTR(" >"));
  return Mutable;
}

__CFString *sub_1000389E0(_QWORD *a1)
{
  sub_100026A10();
  return sub_1000388F4(a1);
}

void sub_100038A04(uint64_t a1, CFDictionaryRef theDict)
{
  char v3;
  uint64_t v4;
  const void *Value;
  const void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  const void *v11;
  int v12;
  uint64_t v13;

  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    v3 = 1;
  }
  else
  {
    v4 = *(_QWORD *)(a1 + 40);
    Value = CFDictionaryGetValue(theDict, kSecCARevocationSPKIHashKey);
    if (Value && v4 && *(uint64_t *)(v4 + 16) >= 2)
    {
      v6 = Value;
      v3 = 0;
      v7 = 18;
      do
      {
        v8 = *(_QWORD *)(v4 + 8 * v7);
        if (v8)
          v9 = *(_QWORD *)(v8 + 16);
        else
          v9 = 0;
        v10 = (const void *)SecCertificateCopySubjectPublicKeyInfoSHA256Digest(v9);
        if (v10)
        {
          v11 = v10;
          v12 = CFEqual(v6, v10);
          CFRelease(v11);
          if (v12)
          {
            if (v7 - 17 > *(_QWORD *)(v4 + 72))
              *(_QWORD *)(v4 + 72) = v7 - 17;
            v3 = 1;
          }
        }
        v13 = v7 - 16;
        ++v7;
      }
      while (v13 < *(_QWORD *)(v4 + 16));
    }
    else
    {
      v3 = 0;
    }
  }
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v3 & 1;
}

uint64_t sub_100038B0C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_100038B20(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;

  if (DEROidCompare(a1, (uint64_t)&oidAnyPolicy))
    return 0;
  v4 = *(_QWORD *)(a2 + 8);
  if (!v4)
    return 0;
  v5 = 0;
  v6 = 16;
  do
  {
    v7 = *(_QWORD *)(a2 + 16);
    if (DEROidCompare(a1, v7 + v6 - 16))
    {
      v8 = malloc_type_malloc(0x18uLL, 0x1030040D5FA72FAuLL);
      *(_OWORD *)v8 = *(_OWORD *)(v7 + v6);
      v8[2] = v5;
      v5 = v8;
    }
    v6 += 32;
    --v4;
  }
  while (v4);
  if (!v5)
    return 0;
  v9 = *(_QWORD **)(a1 + 24);
  if (v9)
  {
    do
    {
      v10 = (_QWORD *)v9[2];
      free(v9);
      v9 = v10;
    }
    while (v10);
  }
  *(_QWORD *)(a1 + 24) = v5;
  return 1;
}

CFMutableDictionaryRef sub_100038BE8(uint64_t a1, uint64_t a2)
{
  CFMutableDictionaryRef result;
  uint64_t v5;
  const __CFDictionary *v6;
  uint64_t v7;
  uint64_t v8;
  CFIndex v9;
  CFIndex v10;
  const UInt8 *v11;
  CFDataRef v12;
  CFDataRef v13;
  __CFArray *Value;
  __CFArray *Mutable;
  __CFArray *v16;
  _QWORD context[5];

  result = (CFMutableDictionaryRef)DEROidCompare(a1, (uint64_t)&oidAnyPolicy);
  if (!(_DWORD)result)
    return result;
  v5 = *(_QWORD *)(a2 + 8);
  result = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!result)
    return result;
  v6 = result;
  if (!v5)
  {
LABEL_17:
    context[0] = _NSConcreteStackBlock;
    context[1] = 0x40000000;
    context[2] = sub_100038E64;
    context[3] = &unk_100076EC0;
    context[4] = a1;
    CFDictionaryApplyFunction(v6, (CFDictionaryApplierFunction)sub_100038F88, context);
    CFRelease(v6);
    return (CFMutableDictionaryRef)1;
  }
  v7 = 0;
  while (1)
  {
    v8 = *(_QWORD *)(a2 + 16) + v7;
    v9 = *(_QWORD *)(v8 + 8);
    if (v9 < 0)
      goto LABEL_12;
    v10 = *(_QWORD *)(v8 + 24);
    if (v10 < 0)
      goto LABEL_12;
    v11 = *(const UInt8 **)(v8 + 16);
    v12 = CFDataCreateWithBytesNoCopy(0, *(const UInt8 **)v8, v9, kCFAllocatorNull);
    v13 = CFDataCreateWithBytesNoCopy(0, v11, v10, kCFAllocatorNull);
    Value = (__CFArray *)CFDictionaryGetValue(v6, v12);
    if (Value)
    {
      CFArrayAppendValue(Value, v13);
      if (!v12)
        goto LABEL_10;
LABEL_9:
      CFRelease(v12);
      goto LABEL_10;
    }
    Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (!Mutable)
      break;
    v16 = Mutable;
    CFArrayAppendValue(Mutable, v13);
    CFDictionarySetValue(v6, v12, v16);
    CFRelease(v16);
    if (v12)
      goto LABEL_9;
LABEL_10:
    if (v13)
      CFRelease(v13);
LABEL_12:
    v7 += 32;
    if (!--v5)
      goto LABEL_17;
  }
  CFRelease(v6);
  if (v12)
    CFRelease(v12);
  if (v13)
    CFRelease(v13);
  return 0;
}

BOOL sub_100038DCC(uint64_t a1, uint64_t a2)
{
  _BOOL4 v4;
  uint64_t v5;
  uint64_t i;

  v4 = DEROidCompare(a1, (uint64_t)&oidAnyPolicy);
  if (!v4)
  {
    v5 = *(_QWORD *)(a2 + 8);
    if (v5)
    {
      for (i = 0; !DEROidCompare(a1, *(_QWORD *)(a2 + 16) + i); i += 32)
      {
        if (!--v5)
          return !v4;
      }
      if (*(_QWORD *)(a1 + 32))
        sub_100006930((_QWORD **)(a1 + 32));
      *(_QWORD *)(*(_QWORD *)(a1 + 48) + 32) = *(_QWORD *)(a1 + 40);
      sub_100006988((_QWORD *)a1);
    }
  }
  return !v4;
}

void sub_100038E64(uint64_t a1, CFDataRef theData, const __CFArray *a3)
{
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD context[5];
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  CFRange v18;

  if ((CFDataGetLength(theData) & 0x8000000000000000) == 0)
  {
    BytePtr = CFDataGetBytePtr(theData);
    Length = CFDataGetLength(theData);
    v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16);
    v14 = 0;
    v15 = &v14;
    v16 = 0x2000000000;
    v17 = 0;
    context[0] = _NSConcreteStackBlock;
    context[1] = 0x40000000;
    context[2] = sub_100038FA0;
    context[3] = &unk_100076EA0;
    context[4] = &v14;
    v18.length = CFArrayGetCount(a3);
    v18.location = 0;
    CFArrayApplyFunction(a3, v18, (CFArrayApplierFunction)sub_100038B0C, context);
    v9 = *(_QWORD *)(a1 + 32);
    v10 = v15[3];
    v11 = *(_QWORD *)(v9 + 48);
    v12 = malloc_type_malloc(0x38uLL, 0x107004060FBFCD3uLL);
    v12[4] = 0;
    v12[5] = 0;
    *v12 = BytePtr;
    v12[1] = Length;
    v12[2] = v8;
    v12[3] = v10;
    v12[6] = v11;
    v12[5] = *(_QWORD *)(v11 + 32);
    *(_QWORD *)(v11 + 32) = v12;
    _Block_object_dispose(&v14, 8);
  }
}

uint64_t sub_100038F88(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

CFIndex sub_100038FA0(uint64_t a1, CFDataRef theData)
{
  CFIndex result;
  _QWORD *v5;

  result = CFDataGetLength(theData);
  if ((result & 0x8000000000000000) == 0)
  {
    v5 = malloc_type_malloc(0x18uLL, 0x1030040D5FA72FAuLL);
    *v5 = CFDataGetBytePtr(theData);
    result = CFDataGetLength(theData);
    v5[1] = result;
    v5[2] = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v5;
  }
  return result;
}

uint64_t sub_100039024()
{
  return 0;
}

uint64_t sub_10003902C(uint64_t a1, __SecCertificate *a2)
{
  const void *NormalizedIssuerContent;
  const void *v5;
  CFDataRef v6;
  uint64_t v7;
  CFErrorRef error;

  NormalizedIssuerContent = (const void *)SecCertificateGetNormalizedIssuerContent(a2);
  v5 = NormalizedIssuerContent;
  if (NormalizedIssuerContent)
    CFRetain(NormalizedIssuerContent);
  error = 0;
  v6 = SecCertificateCopySerialNumberData(a2, &error);
  v7 = SecItemCertificateExists(v5, v6, *(_QWORD *)(a1 + 24), &error);
  if (error)
  {
    CFErrorGetCode(error);
    if (error)
      CFRelease(error);
  }
  if (v6)
    CFRelease(v6);
  if (v5)
    CFRelease(v5);
  return v7;
}

void sub_1000390D4(uint64_t a1, const __CFData *a2)
{
  SecCertificateRef v3;
  SecCertificateRef v4;

  v3 = SecCertificateCreateWithData(kCFAllocatorDefault, a2);
  if (v3)
  {
    v4 = v3;
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), v3);
    CFRelease(v4);
  }
}

uint64_t sub_100039124(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

id sub_100039138(CFTypeRef *a1)
{
  uint64_t v2;
  const void *v3;
  NSObject *v4;
  id v5;
  uint64_t v6;
  CFURLRef v7;
  void *v8;
  uint64_t v9;
  void *v10;
  CFErrorRef *v11;
  uint64_t v12;
  CFURLRef v13;
  uint8_t v15[16];

  if ((sub_100015138() & 1) != 0)
  {
    v2 = sub_10001D4EC(a1);
    if (a1)
    {
      if (*a1)
      {
        v3 = sub_100011628("SecError");
        v4 = objc_claimAutoreleasedReturnValue(v3);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v15 = 0;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Failed to increment the extensions epoch.", v15, 2u);
        }

        return 0;
      }
      v12 = v2 + 1;
      v13 = sub_10001D628();
      v8 = (void *)objc_claimAutoreleasedReturnValue(v13);
      v9 = v12;
      v10 = v8;
      v11 = (CFErrorRef *)a1;
    }
    else
    {
      v6 = v2 + 1;
      v7 = sub_10001D628();
      v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
      v9 = v6;
      v10 = v8;
      v11 = 0;
    }
    v5 = sub_100039238(v9, v10, v11);

    return v5;
  }
  sub_100012C88(-4, (__CFString **)a1, CFSTR("exception counter not implemented in this environment"));
  return 0;
}

id sub_100039238(uint64_t a1, void *a2, CFErrorRef *a3)
{
  __CFString *v5;
  void *v6;
  NSMutableDictionary *v7;
  void *v8;
  void *v9;
  id v10;
  id v11;
  const void *v12;
  NSObject *v13;
  const void *v14;
  NSObject *v15;
  const void *v16;
  NSObject *v17;
  id v19;
  uint8_t buf[4];
  const __CFString *v21;
  __int16 v22;
  __CFString *v23;

  v5 = a2;
  v6 = objc_autoreleasePoolPush();
  v7 = objc_opt_new(NSMutableDictionary);
  if (v7)
  {
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", 1));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v8, CFSTR("Version"));

    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a1));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v9, CFSTR("ExceptionResetCount"));

    v19 = 0;
    v10 = -[NSMutableDictionary writeToClassDURL:permissions:error:](v7, "writeToClassDURL:permissions:error:", v5, 384, &v19);
    v11 = v19;
    if ((v10 & 1) != 0)
    {
      v12 = sub_100011628("trust");
      v13 = objc_claimAutoreleasedReturnValue(v12);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 138543618;
        v21 = CFSTR("ExceptionResetCount");
        v22 = 2114;
        v23 = v5;
        _os_log_debug_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "'%{public}@' has been committed to permanent storage at '%{public}@'.", buf, 0x16u);
      }

    }
    else
    {
      v16 = sub_100011628("SecError");
      v17 = objc_claimAutoreleasedReturnValue(v16);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138543362;
        v21 = v5;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Failed to write to permanent storage at '%{public}@'.", buf, 0xCu);
      }

      if (a3)
        *a3 = (CFErrorRef)v11;
    }

  }
  else
  {
    v14 = sub_100011628("SecError");
    v15 = objc_claimAutoreleasedReturnValue(v14);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Failed to allocate memory for the exceptions epoch structure.", buf, 2u);
    }

    v10 = 0;
    if (a3)
      *a3 = CFErrorCreate(0, kCFErrorDomainPOSIX, 12, 0);
  }

  objc_autoreleasePoolPop(v6);
  return v10;
}

void sub_1000394BC(id a1, const char *a2)
{
  remove((const std::__fs::filesystem::path *)a2, (std::error_code *)a2);
}

void sub_1000394C4(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  char v8;
  NSObject *v9;
  uint64_t v10;
  __CFError *v11;
  CFIndex Code;
  const void *v13;
  const void *v14;
  int8x16_t v15;
  _QWORD v16[8];
  int8x16_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  char v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  __CFString *v26;
  uint8_t buf[4];
  uint64_t v28;

  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(_QWORD *)(a1 + 56);
  v15 = *(int8x16_t *)(a1 + 40);
  v5 = *(_QWORD *)v15.i64[0];
  if ((CFDataGetLength(*(CFDataRef *)v15.i64[0]) & 0x8000000000000000) == 0)
  {
    v23 = 0;
    v24 = &v23;
    v25 = 0x2000000000;
    v26 = 0;
    v19 = 0;
    v20 = &v19;
    v21 = 0x2000000000;
    v22 = 1;
    v6 = *a2;
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 0x40000000;
    v16[2] = sub_100039AA8;
    v16[3] = &unk_100077168;
    v16[4] = &v19;
    v16[5] = &v23;
    v16[6] = v3;
    v16[7] = v5;
    v17 = vextq_s8(v15, v15, 8uLL);
    v18 = v4;
    v7 = sub_100029AF0(v6, &v26, (uint64_t)v16);
    if (*((_BYTE *)v20 + 24))
      v8 = v7;
    else
      v8 = 0;
    *((_BYTE *)v20 + 24) = v8;
    if ((v8 & 1) == 0)
    {
      v9 = sub_100011628("SecError");
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        v10 = v24[3];
        *(_DWORD *)buf = 138412290;
        v28 = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "_SecOCSPCacheAddResponse failed: %@", buf, 0xCu);
      }
      v11 = (__CFError *)v24[3];
      if (v11)
        Code = CFErrorGetCode(v11);
      else
        Code = -2070;
      sub_1000521A8(2, 2, Code);
      v13 = (const void *)v24[3];
      if (v13)
      {
        v24[3] = 0;
        CFRelease(v13);
      }
    }
    v14 = (const void *)v24[3];
    if (v14)
      CFRelease(v14);
    _Block_object_dispose(&v19, 8);
    _Block_object_dispose(&v23, 8);
  }
}

BOOL sub_10003969C(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _BOOL8 result;
  uint64_t v7;
  BOOL v8;
  _QWORD v9[7];

  v4 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(a1 + 40);
  v5 = *(_QWORD *)(v3 + 8);
  v9[0] = _NSConcreteStackBlock;
  v9[2] = sub_100039728;
  v9[3] = &unk_100077050;
  v9[1] = 0x40000000;
  v9[5] = v3;
  v9[6] = a2;
  v9[4] = v4;
  result = sub_10002884C(a2, 2, (CFTypeRef *)(v5 + 24), (uint64_t)v9);
  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v7 + 24))
    v8 = result;
  else
    v8 = 0;
  *(_BYTE *)(v7 + 24) = v8;
  return result;
}

void sub_100039728(_QWORD *a1, _BYTE *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  uint64_t v9;
  char v10;
  _QWORD v11[7];
  __CFError *v12;

  v12 = 0;
  if ((sub_10001979C(a1[6], CFSTR("SELECT issuerNameHash FROM ocsp WHERE certStatus=0 LIMIT 1"), (CFTypeRef *)&v12, 0) & 1) == 0&& CFErrorGetCode(v12) == 1)
  {
    v5 = a1[4];
    v4 = a1[5];
    v6 = *(_QWORD *)(v4 + 8);
    v11[0] = _NSConcreteStackBlock;
    v11[2] = sub_100039808;
    v11[3] = &unk_100077028;
    v7 = a1[6];
    v11[1] = 0x40000000;
    v11[5] = v4;
    v11[6] = v7;
    v11[4] = v5;
    v8 = sub_10001979C(v7, CFSTR("ALTER TABLE ocsp ADD COLUMN certStatus INTEGER NOT NULL DEFAULT 255"), (CFTypeRef *)(v6 + 24), (uint64_t)v11);
    v9 = *(_QWORD *)(a1[4] + 8);
    if (*(_BYTE *)(v9 + 24))
      v10 = v8;
    else
      v10 = 0;
    *(_BYTE *)(v9 + 24) = v10;
    *a2 = *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24);
  }
  if (v12)
    CFRelease(v12);
}

uint64_t sub_100039808(_QWORD *a1, sqlite3_stmt *a2)
{
  *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = sub_100019D18(a1[6], a2, (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24), 0);
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

BOOL sub_100039854(id a1, __OpaqueSecDb *a2, __OpaqueSecDbConnection *a3, BOOL a4, BOOL *a5, __CFError **a6)
{
  _BOOL4 v7;
  BOOL v9;
  BOOL v10;
  BOOL v11;
  NSObject *v12;
  const char *v13;
  __CFError *v14;
  CFIndex Code;
  _QWORD v17[7];
  CFErrorRef err;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  char v22;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  __CFError *v26;

  v7 = a4;
  v19 = 0;
  v20 = &v19;
  v21 = 0x2000000000;
  v22 = 1;
  err = 0;
  if ((sub_10001979C((uint64_t)a3, CFSTR("SELECT DISTINCT hashAlgorithm FROM ocsp WHERE serialNum=?"), (CFTypeRef *)&err, 0) & 1) == 0&& CFErrorGetCode(err) == 1)
  {
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 0x40000000;
    v17[2] = sub_100039A4C;
    v17[3] = &unk_100077000;
    v17[4] = &v19;
    v17[5] = a3;
    v17[6] = a6;
    v9 = sub_10002884C((uint64_t)a3, 2, (CFTypeRef *)a6, (uint64_t)v17);
    if (*((_BYTE *)v20 + 24))
      v10 = v9;
    else
      v10 = 0;
    *((_BYTE *)v20 + 24) = v10;
  }
  if (err)
    CFRelease(err);
  if (*((_BYTE *)v20 + 24))
  {
    v11 = 1;
  }
  else
  {
    v12 = sub_100011628("SecError");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      v13 = "Open";
      if (v7)
        v13 = "Create";
      if (a6)
        v14 = *a6;
      else
        v14 = 0;
      *(_DWORD *)buf = 136315394;
      v24 = v13;
      v25 = 2112;
      v26 = v14;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%s failed: %@", buf, 0x16u);
    }
    if (a6 && *a6)
      Code = CFErrorGetCode(*a6);
    else
      Code = -2070;
    sub_1000521A8(2, !v7, Code);
    v11 = *((_BYTE *)v20 + 24) != 0;
  }
  _Block_object_dispose(&v19, 8);
  return v11;
}

uint64_t sub_100039A4C(uint64_t a1, _BYTE *a2)
{
  uint64_t result;
  uint64_t v5;
  char v6;

  result = sub_1000279E0(*(_QWORD *)(a1 + 40), CFSTR("CREATE TABLE ocsp(issuerNameHash BLOB NOT NULL,issuerPubKeyHash BLOB NOT NULL,serialNum BLOB NOT NULL,hashAlgorithm BLOB NOT NULL,responseId INTEGER NOT NULL,certStatus INTEGER NOT NULL DEFAULT 255);CREATE INDEX iResponseId ON ocsp(responseId);CREATE INDEX iserialNum ON ocsp(serialNum);CREATE INDEX iSNumDAlg ON ocsp(serialNum,hashAlgorithm);CREATE TABLE responses(responseId INTEGER PRIMARY KEY,ocspResponse BLOB NOT NULL,responderURI BLOB,expires DOUBLE NOT NULL,lastUsed DOUBLE NOT NULL);CREATE INDEX iexpires ON responses(expires);CREATE TRIGGER tocspdel BEFORE DELETE ON responses FOR EACH ROW BEGIN DELETE FROM ocsp WHERE responseId=OLD.responseId; END;"),
             *(CFTypeRef **)(a1 + 48));
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v5 + 24))
    v6 = result;
  else
    v6 = 0;
  *(_BYTE *)(v5 + 24) = v6;
  *a2 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

BOOL sub_100039AA8(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  __int128 v4;
  CFTypeRef *v5;
  _BOOL8 result;
  uint64_t v7;
  BOOL v8;
  _QWORD v9[5];
  __int128 v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;

  v9[0] = _NSConcreteStackBlock;
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(_OWORD *)(a1 + 40);
  v5 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  v9[1] = 0x40000000;
  v9[2] = sub_100039B58;
  v9[3] = &unk_100077140;
  v9[4] = v3;
  v11 = a2;
  v10 = v4;
  v12 = *(_OWORD *)(a1 + 56);
  v13 = *(_QWORD *)(a1 + 72);
  v14 = *(_QWORD *)(a1 + 80);
  result = sub_10002884C(a2, 2, v5, (uint64_t)v9);
  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v7 + 24))
    v8 = result;
  else
    v8 = 0;
  *(_BYTE *)(v7 + 24) = v8;
  return result;
}

void sub_100039B58(uint64_t a1, _BYTE *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  CFTypeRef *v8;
  char v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  CFTypeRef *v22;
  uint64_t v23;
  char v24;
  uint64_t v25;
  char v26;
  uint64_t v27;
  uint64_t v28;
  CFTypeRef *v29;
  char v30;
  uint64_t v31;
  char v32;
  _QWORD v33[9];
  _QWORD v34[7];
  __int128 v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD v39[8];
  _QWORD v40[3];
  unint64_t v41;
  _QWORD v42[7];

  v40[0] = 0;
  v40[1] = v40;
  v40[2] = 0x2000000000;
  v41 = 0xAAAAAAAAAAAAAAAALL;
  v4 = *(_QWORD *)(a1 + 48);
  if (v4)
  {
    v41 = *(_QWORD *)(v4 + 208);
    if ((v41 & 0x8000000000000000) == 0)
    {
      v5 = *(_QWORD *)(a1 + 56);
      v7 = *(_QWORD *)(a1 + 32);
      v6 = *(_QWORD *)(a1 + 40);
      v8 = (CFTypeRef *)(*(_QWORD *)(v6 + 8) + 24);
      v39[0] = _NSConcreteStackBlock;
      v39[1] = 0x40000000;
      v39[2] = sub_100039D98;
      v39[3] = &unk_1000770A0;
      v39[4] = v7;
      v39[5] = v40;
      v39[6] = v6;
      v39[7] = v5;
      v9 = sub_10001979C(v5, CFSTR("DELETE FROM responses WHERE responseId=?"), v8, (uint64_t)v39);
      v10 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      if (*(_BYTE *)(v10 + 24))
        v11 = v9;
      else
        v11 = 0;
      *(_BYTE *)(v10 + 24) = v11;
    }
  }
  v13 = *(_QWORD *)(a1 + 32);
  v12 = *(_QWORD *)(a1 + 40);
  v14 = *(_QWORD *)(v12 + 8);
  v34[2] = sub_100039E58;
  v34[3] = &unk_1000770C8;
  v15 = *(_QWORD *)(a1 + 56);
  v34[0] = _NSConcreteStackBlock;
  v34[1] = 0x40000000;
  v34[4] = v13;
  v34[5] = v12;
  v35 = *(_OWORD *)(a1 + 64);
  v36 = *(_QWORD *)(a1 + 80);
  v37 = *(_QWORD *)(a1 + 88);
  v38 = v15;
  v34[6] = v40;
  v16 = sub_10001979C(v15, CFSTR("INSERT INTO responses (ocspResponse,responderURI,expires,lastUsed) VALUES (?,?,?,?)"), (CFTypeRef *)(v14 + 24), (uint64_t)v34);
  v17 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v17 + 24))
    v18 = v16;
  else
    v18 = 0;
  *(_BYTE *)(v17 + 24) = v18;
  v19 = *(_QWORD *)(a1 + 56);
  v21 = *(_QWORD *)(a1 + 32);
  v20 = *(_QWORD *)(a1 + 40);
  v22 = (CFTypeRef *)(*(_QWORD *)(v20 + 8) + 24);
  v33[0] = _NSConcreteStackBlock;
  v33[1] = 0x40000000;
  v33[2] = sub_10003A068;
  v33[3] = &unk_100077118;
  v23 = *(_QWORD *)(a1 + 80);
  v33[4] = v21;
  v33[5] = v20;
  v33[6] = v40;
  v33[7] = v23;
  v33[8] = v19;
  v24 = sub_10001979C(v19, CFSTR("INSERT INTO ocsp (hashAlgorithm,issuerNameHash,issuerPubKeyHash,serialNum,responseId,certStatus) VALUES (?,?,?,?,?,?)"), v22, (uint64_t)v33);
  v25 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v25 + 24))
    v26 = v24;
  else
    v26 = 0;
  *(_BYTE *)(v25 + 24) = v26;
  v27 = *(_QWORD *)(a1 + 56);
  v28 = *(_QWORD *)(a1 + 88);
  v29 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  v42[0] = _NSConcreteStackBlock;
  v42[1] = 0x40000000;
  v42[2] = sub_10003A148;
  v42[3] = &unk_100077188;
  v42[4] = v28;
  v42[5] = v29;
  v42[6] = v27;
  v30 = sub_10001979C(v27, CFSTR("DELETE FROM responses WHERE expires<? AND responseId NOT IN (SELECT responseId FROM ocsp WHERE certStatus=1)"), v29, (uint64_t)v42);
  v31 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v31 + 24))
    v32 = v30;
  else
    v32 = 0;
  *(_BYTE *)(v31 + 24) = v32;
  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    *a2 = 0;
  _Block_object_dispose(v40, 8);
}

uint64_t sub_100039D98(_QWORD *a1, sqlite3_stmt *a2)
{
  CFTypeRef *v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  BOOL v8;
  char v9;
  uint64_t v10;
  char v11;

  v4 = (CFTypeRef *)(*(_QWORD *)(a1[6] + 8) + 24);
  v5 = sqlite3_bind_int64(a2, 1, *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24));
  v6 = sub_10001A970(v5, a2, v4, CFSTR("bind_int64[%d]"), 1);
  v7 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v7 + 24))
    v8 = v6;
  else
    v8 = 0;
  *(_BYTE *)(v7 + 24) = v8;
  v9 = sub_100019D18(a1[7], a2, (CFTypeRef *)(*(_QWORD *)(a1[6] + 8) + 24), 0);
  v10 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v10 + 24))
    v11 = v9;
  else
    v11 = 0;
  *(_BYTE *)(v10 + 24) = v11;
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

uint64_t sub_100039E58(uint64_t a1, sqlite3_stmt *a2)
{
  const UInt8 *BytePtr;
  CFIndex Length;
  BOOL v6;
  uint64_t v7;
  BOOL v8;
  const __CFURL *v9;
  const __CFData *v10;
  const __CFData *v11;
  const UInt8 *v12;
  CFIndex v13;
  CFTypeRef *v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  BOOL v18;
  CFTypeRef *v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  BOOL v23;
  char v24;
  uint64_t v25;
  char v26;

  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 56));
  Length = CFDataGetLength(*(CFDataRef *)(a1 + 56));
  v6 = sub_10001A8F8(a2, 1, BytePtr, Length, (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v7 + 24))
    v8 = v6;
  else
    v8 = 0;
  *(_BYTE *)(v7 + 24) = v8;
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    v9 = *(const __CFURL **)(a1 + 64);
    if (v9)
    {
      v10 = CFURLCreateData(kCFAllocatorDefault, v9, 0x8000100u, 0);
      if (v10)
      {
        v11 = v10;
        if (CFDataGetLength(v10) >= 1)
        {
          v12 = CFDataGetBytePtr(v11);
          v13 = CFDataGetLength(v11);
          *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = sub_10001A8F8(a2, 2, v12, v13, (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40)+ 8)+ 24));
        }
        CFRelease(v11);
      }
    }
  }
  v14 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  v15 = sqlite3_bind_double(a2, 3, *(double *)(*(_QWORD *)(a1 + 72) + 32));
  v16 = sub_10001A970(v15, a2, v14, CFSTR("bind_double[%d]"), 3);
  v17 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v17 + 24))
    v18 = v16;
  else
    v18 = 0;
  *(_BYTE *)(v17 + 24) = v18;
  v19 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  v20 = sqlite3_bind_double(a2, 4, *(double *)(a1 + 80));
  v21 = sub_10001A970(v20, a2, v19, CFSTR("bind_double[%d]"), 4);
  v22 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v22 + 24))
    v23 = v21;
  else
    v23 = 0;
  *(_BYTE *)(v22 + 24) = v23;
  v24 = sub_100019D18(*(_QWORD *)(a1 + 88), a2, (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), 0);
  v25 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v25 + 24))
    v26 = v24;
  else
    v26 = 0;
  *(_BYTE *)(v25 + 24) = v26;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = sqlite3_last_insert_rowid(*(sqlite3 **)(*(_QWORD *)(a1 + 88) + 64));
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

uint64_t sub_10003A068(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  BOOL v6;
  char v7;
  _QWORD v9[4];
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD v14[5];
  _QWORD v15[5];

  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = sub_10003A1CC;
  v9[3] = &unk_1000770F0;
  v10 = *(_OWORD *)(a1 + 32);
  v3 = *(_QWORD *)(a1 + 56);
  v11 = *(_QWORD *)(a1 + 48);
  v12 = a2;
  v13 = *(_QWORD *)(a1 + 64);
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000;
  v14[2] = sub_10000A05C;
  v14[3] = &unk_1000777F8;
  v14[4] = v9;
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 0x40000000;
  v15[2] = sub_100009F74;
  v15[3] = &unk_100077890;
  v15[4] = v14;
  v4 = DERDecodeSequenceContentWithBlock((unint64_t *)(v3 + 152), (uint64_t)v15);
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (v4)
    v6 = 1;
  else
    v6 = *(_BYTE *)(v5 + 24) == 0;
  v7 = !v6;
  *(_BYTE *)(v5 + 24) = v7;
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

uint64_t sub_10003A148(uint64_t a1, sqlite3_stmt *a2)
{
  CFTypeRef *v4;
  uint64_t v5;
  uint64_t result;

  v4 = *(CFTypeRef **)(a1 + 40);
  v5 = sqlite3_bind_double(a2, 1, *(double *)(a1 + 32));
  result = sub_10001A970(v5, a2, v4, CFSTR("bind_double[%d]"), 1);
  if ((_DWORD)result)
    return sub_100019D18(*(_QWORD *)(a1 + 48), a2, *(CFTypeRef **)(a1 + 40), 0);
  return result;
}

uint64_t sub_10003A1CC(uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4)
{
  BOOL v7;
  uint64_t v8;
  BOOL v9;
  BOOL v10;
  uint64_t v11;
  BOOL v12;
  BOOL v13;
  uint64_t v14;
  BOOL v15;
  BOOL v16;
  uint64_t v17;
  BOOL v18;
  sqlite3_stmt *v19;
  CFTypeRef *v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  BOOL v24;
  sqlite3_stmt *v25;
  int v26;
  CFTypeRef *v27;
  uint64_t v28;
  BOOL v29;
  uint64_t v30;
  BOOL v31;
  char v32;
  uint64_t v33;
  char v34;
  sqlite3_stmt *v35;
  CFTypeRef *v36;
  uint64_t v37;
  BOOL v38;
  uint64_t v39;
  BOOL v40;

  v7 = sub_10001A8F8(*(sqlite3_stmt **)(a1 + 56), 1, *(const void **)a4, *(_QWORD *)(a4 + 8), (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v8 + 24))
    v9 = v7;
  else
    v9 = 0;
  *(_BYTE *)(v8 + 24) = v9;
  v10 = sub_10001A8F8(*(sqlite3_stmt **)(a1 + 56), 2, *(const void **)(a3 + 16), *(_QWORD *)(a3 + 24), (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v11 + 24))
    v12 = v10;
  else
    v12 = 0;
  *(_BYTE *)(v11 + 24) = v12;
  v13 = sub_10001A8F8(*(sqlite3_stmt **)(a1 + 56), 3, *(const void **)(a3 + 32), *(_QWORD *)(a3 + 40), (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
  v14 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v14 + 24))
    v15 = v13;
  else
    v15 = 0;
  *(_BYTE *)(v14 + 24) = v15;
  v16 = sub_10001A8F8(*(sqlite3_stmt **)(a1 + 56), 4, *(const void **)(a3 + 48), *(_QWORD *)(a3 + 56), (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
  v17 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v17 + 24))
    v18 = v16;
  else
    v18 = 0;
  *(_BYTE *)(v17 + 24) = v18;
  v19 = *(sqlite3_stmt **)(a1 + 56);
  v20 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  v21 = sqlite3_bind_int64(v19, 5, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24));
  v22 = sub_10001A970(v21, v19, v20, CFSTR("bind_int64[%d]"), 5);
  v23 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v23 + 24))
    v24 = v22;
  else
    v24 = 0;
  *(_BYTE *)(v23 + 24) = v24;
  v25 = *(sqlite3_stmt **)(a1 + 56);
  v26 = *a2;
  v27 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  v28 = sqlite3_bind_int(v25, 6, v26);
  v29 = sub_10001A970(v28, v25, v27, CFSTR("bind_int[%d]"), 6);
  v30 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v30 + 24))
    v31 = v29;
  else
    v31 = 0;
  *(_BYTE *)(v30 + 24) = v31;
  v32 = sub_100019D18(*(_QWORD *)(a1 + 64), *(sqlite3_stmt **)(a1 + 56), (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), 0);
  v33 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v33 + 24))
    v34 = v32;
  else
    v34 = 0;
  *(_BYTE *)(v33 + 24) = v34;
  v35 = *(sqlite3_stmt **)(a1 + 56);
  v36 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  v37 = sqlite3_reset(v35);
  v38 = sub_10001A970(v37, v35, v36, CFSTR("reset"));
  v39 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v39 + 24))
    v40 = v38;
  else
    v40 = 0;
  *(_BYTE *)(v39 + 24) = v40;
  return (*(char *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) - 1);
}

uint64_t sub_10003A408(uint64_t a1, uint64_t *a2)
{
  uint64_t result;

  result = sub_100019148(a2, *(SecCertificateRef **)(a1 + 40), *(double *)(a1 + 56));
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t sub_10003A444(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[6];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = sub_10003A4CC;
  v3[3] = &unk_100076F98;
  v3[4] = &v4;
  v3[5] = a1;
  sub_100018E98((uint64_t)v3);
  v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_10003A4CC(uint64_t a1, uint64_t *a2)
{
  _QWORD *v3;
  uint64_t v4;
  int v5;
  int v6;
  __CFError *v7;
  CFIndex Code;
  const void *v9;
  char v10;
  _QWORD v11[6];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  __CFString *v19;

  v3 = *(_QWORD **)(a1 + 40);
  v16 = 0;
  v17 = &v16;
  v18 = 0x2000000000;
  v19 = 0;
  v12 = 0;
  v13 = &v12;
  v14 = 0x2000000000;
  v15 = 1;
  v4 = *a2;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  v11[2] = sub_10003A600;
  v11[3] = &unk_100077278;
  v11[4] = &v12;
  v11[5] = &v16;
  v5 = sub_100029AF0(v4, &v19, (uint64_t)v11);
  if (*((_BYTE *)v13 + 24))
    v6 = v5;
  else
    v6 = 0;
  *((_BYTE *)v13 + 24) = v6;
  v7 = (__CFError *)v17[3];
  if (v6 == 1)
  {
    if (!v7)
      goto LABEL_15;
    goto LABEL_8;
  }
  if (v7)
  {
LABEL_8:
    Code = CFErrorGetCode(v7);
    goto LABEL_10;
  }
  Code = -2070;
LABEL_10:
  sub_1000521A8(2, 2, Code);
  v9 = (const void *)v17[3];
  if (v9)
  {
    if (v3 && !*v3)
      *v3 = v9;
    else
      CFRelease(v9);
  }
LABEL_15:
  v10 = *((_BYTE *)v13 + 24);
  _Block_object_dispose(&v12, 8);
  _Block_object_dispose(&v16, 8);
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v10;
}

uint64_t sub_10003A600(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  char v5;

  result = sub_1000279E0(a2, CFSTR("DELETE FROM ocsp WHERE certStatus!=1; DELETE FROM responses WHERE responseId NOT IN (SELECT responseId FROM ocsp WHERE certStatus=1)"),
             (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v4 + 24))
    v5 = result;
  else
    v5 = 0;
  *(_BYTE *)(v4 + 24) = v5;
  return result;
}

uint64_t sub_10003A654(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_10003A668(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t sub_10003A680(uint64_t a1, __CFCalendar *a2)
{
  uint64_t v4;
  uint64_t v5;
  CFAbsoluteTime v6;
  CFAbsoluteTime v7;
  uint64_t result;
  int v9;

  v5 = *(_QWORD *)(a1 + 32);
  v4 = *(_QWORD *)(a1 + 40);
  v9 = *(_DWORD *)(*(_QWORD *)(v5 + 8) + 24);
  v6 = SecCertificateNotValidBefore(v4);
  v7 = SecCertificateNotValidAfter(*(_QWORD *)(a1 + 40));
  result = CFCalendarGetComponentDifference(a2, v6, v7, 0, "M", &v9);
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v9;
  return result;
}

void sub_10003A704(uint64_t a1, const __CFData *a2)
{
  const __CFDictionary *v3;
  CFAbsoluteTime v4;

  v4 = NAN;
  v3 = sub_10001C6A4(a2, 0, *(const __CFData **)(a1 + 48), *(_QWORD *)(a1 + 56), *(const __CFDictionary **)(a1 + 64), &v4, *(CFAbsoluteTime *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  if (v3)
  {
    sub_10001C618(*(const __CFDictionary **)(a1 + 72), v3, v4);
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
  }
}

void sub_10003A778(uint64_t a1, const __CFData *a2)
{
  const __CFDictionary *v3;
  CFAbsoluteTime v4;

  v4 = NAN;
  v3 = sub_10001C6A4(a2, 0, *(const __CFData **)(a1 + 48), *(_QWORD *)(a1 + 56), *(const __CFDictionary **)(a1 + 64), &v4, *(CFAbsoluteTime *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  if (v3)
  {
    sub_10001C618(*(const __CFDictionary **)(a1 + 72), v3, v4);
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
  }
}

void sub_10003A7EC()
{
  CFURLRef v0;
  void *v1;
  const void *v2;
  CFURLRef v3;
  uint64_t v4;
  CFURLRef v5;
  void *v6;
  const void *v7;
  NSObject *v8;
  const void *v9;
  FILE *v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  const __CFURL *v15;
  const __CFURL *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const void *v21;
  const UInt8 *v22;
  int v23;
  const __CFData *v24;
  CFPropertyListRef v25;
  const void *v26;
  CFTypeID v27;
  uint64_t v28;
  int v29;
  BOOL v30;
  uint64_t v31;
  int v32;
  BOOL v33;
  char v34;
  NSObject *v35;
  sqlite3_stmt *v36;
  uint64_t v37;
  uint64_t v38;
  NSObject *v39;
  uint64_t v40;
  sqlite3_int64 v41;
  sqlite3_stmt *v42;
  uint64_t v43;
  NSObject *v44;
  _BOOL4 v45;
  uint64_t v46;
  sqlite3 *v47;
  const __CFString *v48;
  uint64_t v49;
  sqlite3 *v50;
  uint64_t v51;
  uint64_t v52;
  sqlite3_stmt *v53;
  const UInt8 *BytePtr;
  unint64_t Length;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  NSObject *v61;
  _BOOL4 v62;
  NSObject *v63;
  uint64_t v64;
  NSObject *v65;
  int v66;
  int v67;
  NSObject *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  char v73;
  BOOL v74;
  NSObject *v75;
  NSObject *v76;
  CFErrorRef v77;
  CFErrorRef v78;
  const void *v79;
  const void *v80;
  const void *v81;
  const void *v82;
  const void *v83;
  void *v84;
  const __CFString *v85;
  NSObject *v86;
  void *v87;
  NSObject *v88;
  void *v89;
  dispatch_queue_attr_t v90;
  NSObject *v91;
  dispatch_queue_attr_t v92;
  NSObject *v93;
  dispatch_queue_t v94;
  void *v95;
  uint64_t v96;
  void *v97;
  uint64_t v98;
  void *v99;
  void *v100;
  double v101;
  id v102;
  void *v103;
  id v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  CFErrorRef error;
  sqlite3_stmt *v109;
  sqlite3_stmt *pStmt;
  sqlite3_stmt *ppStmt;
  sqlite3 *db;
  sqlite3 **p_db;
  uint64_t v114;
  char v115;
  uint8_t buf[1024];
  _BYTE v117[24];
  void *v118;
  sqlite3 **v119;
  _BYTE v120[12];
  __int16 v121;
  uint64_t v122;
  __int16 v123;
  uint64_t v124;

  gTrustd = &off_100082818;
  if (!sub_100015138())
    goto LABEL_156;
  error = 0;
  if (qword_100082DA8 != -1)
    dispatch_once(&qword_100082DA8, &stru_1000776E8);
  if (qword_100082DB0 != -1)
    dispatch_once(&qword_100082DB0, &stru_100077708);
  *(_QWORD *)v117 = 0;
  v0 = sub_10001D628();
  v1 = (void *)objc_claimAutoreleasedReturnValue(v0);
  sub_10001D644(v1, (CFErrorRef *)v117);

  v2 = *(const void **)v117;
  if (*(_QWORD *)v117)
  {
    *(_QWORD *)v117 = 0;
    CFRelease(v2);
    syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0);
    v3 = sub_10001DD50(CFSTR("Library/Keychains"), (uint64_t)CFSTR("com.apple.security.exception_reset_counter.plist"));
    v4 = sub_10001D644(v3, 0);

    v5 = sub_10001D628();
    v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
    LOBYTE(v4) = sub_100039238(v4, v6, (CFErrorRef *)v117);

    if ((v4 & 1) != 0)
    {
      sub_10002B5F4((uint64_t)CFSTR("com.apple.security.exception_reset_counter.plist"), (uint64_t)&stru_100076F00);
    }
    else
    {
      v7 = sub_100011628("SecError");
      v8 = objc_claimAutoreleasedReturnValue(v7);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        *(_QWORD *)&buf[4] = *(_QWORD *)v117;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Failed to migrate exceptions reset count: %@", buf, 0xCu);
      }

      v9 = *(const void **)v117;
      if (*(_QWORD *)v117)
      {
        *(_QWORD *)v117 = 0;
        CFRelease(v9);
      }
    }
  }
  memset(buf, 170, sizeof(buf));
  if (sub_10005521C(buf))
  {
    v10 = fopen((const char *)buf, "r");
    if (v10)
    {
      fclose(v10);
      *(_QWORD *)v120 = 0;
      ppStmt = 0;
      db = 0;
      v109 = 0;
      pStmt = 0;
      if (sub_100055D98((const char *)buf, &db))
      {
        v13 = 0;
        goto LABEL_115;
      }
      v11 = sqlite3_prepare_v3(db, "SELECT INSTR(sql,'uuid') FROM sqlite_master WHERE type='table' AND name='tsettings'", 84, 0, &ppStmt, 0);
      if ((_DWORD)v11)
      {
        v33 = sub_1000271E8(v11, db, (CFTypeRef *)&error, CFSTR("failed to prepare findColStmt"));
        goto LABEL_61;
      }
      v12 = sqlite3_step(ppStmt);
      if ((_DWORD)v12 && (_DWORD)v12 != 101)
      {
        if ((_DWORD)v12 != 100)
        {
          v33 = sub_10001A970(v12, ppStmt, (CFTypeRef *)&error, CFSTR("check for uuid column failed"));
          goto LABEL_61;
        }
        if (sqlite3_column_int64(ppStmt, 0) > 0)
        {
          v13 = 0;
LABEL_104:
          v34 = 1;
          goto LABEL_116;
        }
        v35 = sub_100011628("config");
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v117 = 0;
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "trust store schema not current, will update", v117, 2u);
        }
      }
      v36 = ppStmt;
      if (!ppStmt || (ppStmt = 0, v37 = sqlite3_finalize(v36), !(_DWORD)v37))
      {
        v13 = sub_10000F7BC(0x11Au);
        if (v13)
        {
          if (!sqlite3_exec(db, "BEGIN EXCLUSIVE TRANSACTION;", 0, 0, 0))
          {
            v38 = sqlite3_exec(db, "CREATE TABLE tmp_tsettings(sha256 BLOB NOT NULL DEFAULT '',subj BLOB NOT NULL DEFAULT '',tset BLOB,data BLOB,uuid BLOB NOT NULL DEFAULT '',UNIQUE(sha256,uuid));",
                    0,
                    0,
                    (char **)v120);
            if (*(_QWORD *)v120)
            {
              v39 = sub_100011628("SecWarning");
              if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)v117 = 136315138;
                *(_QWORD *)&v117[4] = *(_QWORD *)v120;
                _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "CREATE TABLE tmp_tsettings: %s", v117, 0xCu);
              }
              sqlite3_free(*(void **)v120);
            }
            if ((_DWORD)v38)
            {
              v62 = 0;
              goto LABEL_108;
            }
            v40 = sqlite3_prepare_v3(db, "SELECT COUNT(*) FROM tsettings WHERE uuid=?", 44, 0, &pStmt, 0);
            if ((_DWORD)v40)
            {
              v38 = v40;
              v47 = db;
              v48 = CFSTR("failed to prepare countAllStmt");
              goto LABEL_106;
            }
            if (sqlite3_step(pStmt) == 100)
              v41 = sqlite3_column_int64(pStmt, 0);
            else
              v41 = -1;
            v42 = pStmt;
            if (pStmt)
            {
              pStmt = 0;
              v43 = sqlite3_finalize(v42);
              if ((_DWORD)v43)
              {
                v38 = v43;
                v47 = db;
                v48 = CFSTR("failed to finalize countAllStmt");
                goto LABEL_106;
              }
            }
            v44 = sub_100011628("config");
            v45 = os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT);
            if (v41 < 1)
            {
              if (v45)
              {
                *(_DWORD *)v117 = 134217984;
                *(_QWORD *)&v117[4] = v41;
                _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "no existing tsettings (%lld rows)", v117, 0xCu);
              }
            }
            else
            {
              if (v45)
              {
                *(_DWORD *)v117 = 134217984;
                *(_QWORD *)&v117[4] = v41;
                _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "copying %lld rows from tsettings", v117, 0xCu);
              }
              v46 = sqlite3_exec(db, "INSERT OR REPLACE INTO tmp_tsettings(sha256,subj,tset,data) SELECT sha256,subj,tset,data FROM tsettings", 0, 0, 0);
              if ((_DWORD)v46)
              {
                v38 = v46;
                v47 = db;
                v48 = CFSTR("failed to copy table data");
LABEL_106:
                v64 = v38;
LABEL_107:
                v62 = sub_1000271E8(v64, v47, (CFTypeRef *)&error, v48);
LABEL_108:
                v65 = sub_100011628("SecError");
                if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)v117 = 67109378;
                  *(_DWORD *)&v117[4] = v38;
                  *(_WORD *)&v117[8] = 2112;
                  *(_QWORD *)&v117[10] = error;
                  _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "Failed to update trust store: (%d) %@", v117, 0x12u);
                }
                sub_1000521A8(4, 2, (int)v38);
                if (v62)
                  sub_100012C88(-26276, (__CFString **)&error, CFSTR("sqlite3 error: %d"), v38);
                v66 = sqlite3_exec(db, "ROLLBACK TRANSACTION", 0, 0, 0);
                if (v66)
                {
                  v67 = v66;
                  v68 = sub_100011628("SecError");
                  if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)v117 = 67109378;
                    *(_DWORD *)&v117[4] = v67;
                    *(_WORD *)&v117[8] = 2112;
                    *(_QWORD *)&v117[10] = error;
                    _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "Failed to rollback transaction (%d) %@", v117, 0x12u);
                  }
                }
                goto LABEL_115;
              }
            }
            v49 = sqlite3_exec(db, "DROP TABLE tsettings;", 0, 0, 0);
            v50 = db;
            if ((_DWORD)v49)
            {
              v38 = v49;
              v48 = CFSTR("failed to drop old table");
            }
            else
            {
              v51 = sqlite3_exec(db, "ALTER TABLE tmp_tsettings RENAME TO tsettings;", 0, 0, 0);
              if ((_DWORD)v51)
              {
                v38 = v51;
                v47 = db;
                v48 = CFSTR("failed to rename new table");
                goto LABEL_106;
              }
              if (v41 >= 1)
              {
                v52 = sqlite3_prepare_v3(db, "UPDATE tsettings SET uuid=? WHERE uuid=''", 42, 1u, &v109, 0);
                if ((_DWORD)v52)
                {
                  v38 = v52;
                  v47 = db;
                  v48 = CFSTR("failed to prepare updateUUIDStmt");
                  goto LABEL_106;
                }
                v53 = v109;
                BytePtr = CFDataGetBytePtr((CFDataRef)v13);
                Length = CFDataGetLength((CFDataRef)v13);
                if (Length >> 31)
                {
                  v38 = 18;
LABEL_92:
                  v47 = db;
                  v48 = CFSTR("failed to bind uuid value");
                  goto LABEL_106;
                }
                v56 = sqlite3_bind_blob(v53, 1, BytePtr, Length, 0);
                if ((_DWORD)v56)
                {
                  v38 = v56;
                  goto LABEL_92;
                }
                v57 = sqlite3_step(v109);
                if ((_DWORD)v57)
                {
                  v38 = v57;
                  if ((_DWORD)v57 != 101)
                  {
                    v47 = db;
                    v48 = CFSTR("failed to update uuid column");
                    goto LABEL_106;
                  }
                }
              }
              v58 = sqlite3_exec(db, "DROP INDEX IF EXISTS isubj;", 0, 0, 0);
              v50 = db;
              if ((_DWORD)v58)
              {
                v38 = v58;
                v48 = CFSTR("failed to drop old index");
              }
              else
              {
                v59 = sqlite3_exec(db, "CREATE INDEX isubj ON tsettings(subj);", 0, 0, 0);
                v50 = db;
                if (!(_DWORD)v59)
                {
                  v60 = sqlite3_exec(db, "COMMIT TRANSACTION", 0, 0, 0);
                  if (!(_DWORD)v60)
                  {
                    v63 = sub_100011628("config");
                    if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)v117 = 0;
                      _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "successfully updated trust store schema", v117, 2u);
                    }
                    goto LABEL_104;
                  }
                  v38 = v60;
                  v61 = sub_100011628("SecError");
                  if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)v117 = 67109120;
                    *(_DWORD *)&v117[4] = v38;
                    _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "Failed to commit transaction (%d), will attempt rollback", v117, 8u);
                  }
                  v62 = 1;
                  goto LABEL_108;
                }
                v38 = v59;
                v48 = CFSTR("failed to recreate index");
              }
            }
            v64 = v38;
            v47 = v50;
            goto LABEL_107;
          }
        }
        else
        {
          sub_100012C88(-50, (__CFString **)&error, CFSTR("get uuid failed"));
        }
LABEL_115:
        v34 = 0;
        goto LABEL_116;
      }
      v33 = sub_1000271E8(v37, db, (CFTypeRef *)&error, CFSTR("failed to finalize findColStmt"));
LABEL_61:
      v34 = v33;
      v13 = 0;
LABEL_116:
      if (v109 && (v69 = sqlite3_finalize(v109), (_DWORD)v69))
      {
        v74 = sub_1000271E8(v69, db, (CFTypeRef *)&error, CFSTR("failed to finalize updateUUIDStmt"));
      }
      else if (pStmt && (v70 = sqlite3_finalize(pStmt), (_DWORD)v70))
      {
        v74 = sub_1000271E8(v70, db, (CFTypeRef *)&error, CFSTR("failed to finalize countAllStmt"));
      }
      else
      {
        if (!ppStmt || (v71 = sqlite3_finalize(ppStmt), !(_DWORD)v71))
        {
          if (db && (v72 = sqlite3_close(db)) != 0)
          {
            sub_10001BB38(v72, (CFTypeRef *)&error, CFSTR("failed to close trust store after schema update"));
          }
          else if ((v34 & 1) != 0)
          {
LABEL_125:
            v73 = 1;
            goto LABEL_148;
          }
LABEL_146:
          v75 = sub_100011628("SecError");
          v73 = 0;
          if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)v117 = 138412290;
            *(_QWORD *)&v117[4] = v13;
            _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "Failed to update schema (uuid %@)", v117, 0xCu);
            v73 = 0;
          }
LABEL_148:
          if (v13)
            CFRelease(v13);
          if ((v73 & 1) != 0)
            goto LABEL_153;
          goto LABEL_151;
        }
        v74 = sub_1000271E8(v71, db, (CFTypeRef *)&error, CFSTR("failed to finalize findColStmt"));
      }
      if (v74)
        goto LABEL_125;
      goto LABEL_146;
    }
  }
  v14 = sub_100011628("config");
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v117 = 0;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "migrating trust store", v117, 2u);
  }
  *(_QWORD *)v117 = 0;
  *(_QWORD *)v120 = 0;
  syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0);
  v15 = sub_10001DD50(CFSTR("Library/Keychains"), (uint64_t)CFSTR("TrustStore.sqlite3"));
  v16 = v15;
  if (!v15)
  {
    sub_100012C88(-36, (__CFString **)&error, CFSTR("failed to get old DB file URL"));
    goto LABEL_136;
  }
  if (!CFURLGetFileSystemRepresentation(v15, 0, buf, 1024))
  {
    sub_100012C88(-36, (__CFString **)&error, CFSTR("failed to get old DB file path"));
    goto LABEL_136;
  }
  v17 = sqlite3_open_v2((const char *)buf, (sqlite3 **)v117, 1, 0);
  if (v17)
  {
    sub_10001BB38(v17, (CFTypeRef *)&error, CFSTR("failed to open old trust store database; new trust store will be empty"));
    goto LABEL_136;
  }
  v18 = sqlite3_prepare_v2(*(sqlite3 **)v117, "SELECT data,tset FROM tsettings ORDER BY sha1", 46, (sqlite3_stmt **)v120, 0);
  if ((_DWORD)v18)
  {
    v30 = sub_1000271E8(v18, *(sqlite3 **)v117, (CFTypeRef *)&error, CFSTR("failed to prepare old trust store read"));
LABEL_42:
    LOBYTE(v19) = v30;
LABEL_43:
    v26 = 0;
    v24 = 0;
    v21 = 0;
    goto LABEL_44;
  }
  v19 = sub_10000489C(CFSTR("user"), (__CFString **)&error);
  if (!v19)
  {
    sub_100012C88(-108, (__CFString **)&error, CFSTR("failed to open new trust store"));
    goto LABEL_43;
  }
  while (1)
  {
    v20 = sqlite3_step(*(sqlite3_stmt **)v120);
    if ((_DWORD)v20 != 100)
      break;
    sqlite3_column_blob(*(sqlite3_stmt **)v120, 0);
    sqlite3_column_bytes(*(sqlite3_stmt **)v120, 0);
    v21 = (const void *)SecCertificateCreateWithBytes(0);
    if (!v21)
    {
      sub_100012C88(-26275, (__CFString **)&error, CFSTR("failed to decode cert in old DB"));
      v26 = 0;
      v24 = 0;
      goto LABEL_137;
    }
    v22 = (const UInt8 *)sqlite3_column_blob(*(sqlite3_stmt **)v120, 1);
    v23 = sqlite3_column_bytes(*(sqlite3_stmt **)v120, 1);
    v24 = CFDataCreate(0, v22, v23);
    if (!v24)
    {
      sub_100012C88(-50, (__CFString **)&error, CFSTR("no tset data in old DB"));
      v26 = 0;
      goto LABEL_137;
    }
    v25 = CFPropertyListCreateWithData(0, v24, 0, 0, &error);
    v26 = v25;
    if (!v25)
      goto LABEL_137;
    v27 = CFGetTypeID(v25);
    if (v27 != CFArrayGetTypeID())
    {
      sub_100012C88(-26275, (__CFString **)&error, CFSTR("tset is not an array in old DB"));
      goto LABEL_137;
    }
    if (!sub_100055FA0(v19, (uint64_t)v21, (uint64_t)v26, (__CFString **)&error))
      goto LABEL_137;
    CFRelease(v21);
    CFRelease(v24);
    CFRelease(v26);
  }
  if ((_DWORD)v20 && (_DWORD)v20 != 101)
  {
    v30 = sub_10001A970(v20, *(sqlite3_stmt **)v120, (CFTypeRef *)&error, CFSTR("sqlite3_step failed"));
    goto LABEL_42;
  }
  v28 = sqlite3_finalize(*(sqlite3_stmt **)v120);
  if ((_DWORD)v28)
  {
    v30 = sub_1000271E8(v28, *(sqlite3 **)v117, (CFTypeRef *)&error, CFSTR("failed to finalize old trust store read"));
    goto LABEL_42;
  }
  *(_QWORD *)v120 = 0;
  v29 = sqlite3_close(*(sqlite3 **)v117);
  if (!v29)
  {
    *(_QWORD *)v117 = 0;
    sub_10002B5F4((uint64_t)CFSTR("TrustStore.sqlite3"), (uint64_t)&stru_100079AB8);
    v26 = 0;
    v24 = 0;
    v21 = 0;
    LOBYTE(v19) = 1;
    goto LABEL_44;
  }
  sub_10001BB38(v29, (CFTypeRef *)&error, CFSTR("failed to close old trust store"));
LABEL_136:
  v26 = 0;
  v24 = 0;
  v21 = 0;
LABEL_137:
  for (LOBYTE(v19) = 0; ; LOBYTE(v19) = 0)
  {
LABEL_44:
    while (*(_QWORD *)v120)
    {
      v31 = sqlite3_finalize(*(sqlite3_stmt **)v120);
      if (!(_DWORD)v31)
        break;
      LOBYTE(v19) = sub_1000271E8(v31, *(sqlite3 **)v117, (CFTypeRef *)&error, CFSTR("failed to finalize old trust store read"));
    }
    if (!*(_QWORD *)v117)
      break;
    v32 = sqlite3_close(*(sqlite3 **)v117);
    if (!v32)
      break;
    sub_10001BB38(v32, (CFTypeRef *)&error, CFSTR("failed to close old trust store"));
  }
  if (v21)
    CFRelease(v21);
  if (v24)
    CFRelease(v24);
  if (v26)
    CFRelease(v26);
  if (v16)
    CFRelease(v16);
  if ((v19 & 1) != 0)
    goto LABEL_153;
LABEL_151:
  v76 = sub_100011628("SecError");
  if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    *(_QWORD *)&buf[4] = error;
    _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "failed to migrate user trust store; new trust store will be empty: %@",
      buf,
      0xCu);
  }
LABEL_153:
  v77 = error;
  if (error)
  {
    error = 0;
    CFRelease(v77);
    v78 = error;
    if (error)
    {
      error = 0;
      CFRelease(v78);
    }
  }
LABEL_156:
  qword_100082DD8 = (uint64_t)CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, 0);
  qword_100082DE0 = (uint64_t)CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, 0);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, kSecPolicyCheckSSLHostname, sub_1000176C4);
  v79 = (const void *)kSecPolicyCheckEmail;
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, kSecPolicyCheckEmail, sub_10004421C);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, v79, sub_10004421C);
  v80 = (const void *)kSecPolicyCheckTemporalValidity;
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, kSecPolicyCheckTemporalValidity, sub_10000E128);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, v80, sub_10000E128);
  v81 = (const void *)kSecPolicyCheckWeakKeySize;
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, kSecPolicyCheckWeakKeySize, sub_10000A834);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, v81, sub_10000A834);
  v82 = (const void *)kSecPolicyCheckWeakSignature;
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, kSecPolicyCheckWeakSignature, sub_10000ABFC);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, v82, sub_10000ABFC);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, kSecPolicyCheckKeyUsage, sub_10001DE88);
  v83 = (const void *)kSecPolicyCheckExtendedKeyUsage;
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, kSecPolicyCheckExtendedKeyUsage, sub_10001C090);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, v83, sub_10001C090);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, kSecPolicyCheckSubjectCommonName, sub_10004436C);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, kSecPolicyCheckSubjectCommonNamePrefix, sub_100044440);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, kSecPolicyCheckSubjectCommonNameTEST, sub_100020ED0);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, kSecPolicyCheckSubjectOrganization, sub_1000213A4);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, kSecPolicyCheckSubjectOrganizationalUnit, sub_100044514);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, kSecPolicyCheckNotValidBefore, sub_1000445E8);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, kSecPolicyCheckEAPTrustedServerNames, sub_1000446BC);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, kSecPolicyCheckLeafMarkerOid, sub_10001E374);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, kSecPolicyCheckLeafMarkerOidWithoutValueCheck, sub_100044780);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, kSecPolicyCheckLeafMarkersProdAndQA, sub_10002119C);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, kSecPolicyCheckBlackListedLeaf, sub_10001D314);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, kSecPolicyCheckGrayListedLeaf, sub_10001CC6C);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, kSecPolicyCheckLeafSPKISHA256, sub_10004482C);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, kSecPolicyCheckNotCA, sub_10001E280);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, kSecPolicyCheckMarkRepresentation, sub_100044948);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckIssuerCommonName, sub_10001DF34);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckIssuerCommonNamePrefix, sub_100044C34);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckBasicConstraints, nullsub_1);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, kSecPolicyCheckBasicConstraintsCA, sub_100044D08);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckIntermediateSPKISHA256, sub_100044DA8);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckIntermediateEKU, sub_100044E98);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckIntermediateMarkerOid, sub_1000212B4);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckIntermediateMarkerOidWithoutValueCheck, sub_100044F88);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckIntermediateOrganization, sub_100020FA4);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckIntermediateCountry, sub_1000210A0);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckAnchorSHA256, sub_10000E200);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckAnchorApple, sub_1000133B8);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckCAspkiSHA256, sub_100045070);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckNonEmptySubject, sub_10000C2C0);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckIdLinkage, sub_100004FE4);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckKeySize, sub_10000EED8);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckSignatureHashAlgorithms, sub_10001C430);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckCertificatePolicy, sub_10001E008);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckCriticalExtensions, nullsub_2);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckChainLength, sub_10001CD98);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckBasicCertificateProcessing, sub_100005610);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckSystemTrustedWeakHash, sub_10000E958);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckSystemTrustedWeakKey, sub_10000EAC4);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, kSecPolicyCheckPinningRequired, sub_1000451B0);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, kSecPolicyCheckRevocation, sub_10001E300);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, kSecPolicyCheckRevocationResponseRequired, sub_10004529C);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckCTRequired, sub_1000452A8);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckSystemTrustedCTRequired, sub_1000050D0);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckValidityPeriodMaximums, sub_1000452C8);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckSystemTrustValidityPeriod, sub_10001C304);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckOtherTrustValidityPeriod, sub_10000F1C8);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckServerAuthEKU, sub_10001CE68);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckEmailProtectionEKU, sub_100045524);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckSinglePurposeChainEKU, sub_10004562C);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckUnparseableExtension, sub_10000C1D4);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckNonTlsCTRequired, sub_10004576C);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, kSecPolicyCheckDuplicateExtension, sub_10000C3AC);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, kSecPolicyCheckNoNetworkAccess, sub_10001DE38);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, kSecPolicyCheckRevocationOnline, sub_1000458DC);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, kSecPolicyCheckRevocationIfTrusted, sub_1000458EC);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, kSecPolicyCheckRevocationDbIgnored, sub_100021500);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, CFSTR("CheckLeafMarkerOid"), sub_10001E374);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DD8, CFSTR("CheckLeafMarkersProdAndQA"), sub_10002119C);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, CFSTR("CheckIntermediateMarkerOid"), sub_1000212B4);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, CFSTR("CheckIntermediateCountry"), sub_1000210A0);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_100082DE0, CFSTR("CheckIntermediateOrganization"), sub_100020FA4);
  v84 = (void *)os_transaction_create("com.apple.trustd.valid.initialize");
  db = 0;
  p_db = &db;
  v114 = 0x2000000000;
  v115 = 0;
  if (qword_100082C28 != -1)
    dispatch_once(&qword_100082C28, &stru_1000767D0);
  if (byte_100082C20 == 1)
  {
    if (sub_100015138())
    {
      sub_1000352AC(0, &stru_100077E90);
      *(_QWORD *)buf = _NSConcreteStackBlock;
      *(_QWORD *)&buf[8] = 0x40000000;
      *(_QWORD *)&buf[16] = sub_10004F32C;
      *(_QWORD *)&buf[24] = &unk_100077EB8;
      *(_QWORD *)&buf[32] = &db;
      sub_1000352AC((uint64_t)CFSTR(".valid_replace"), buf);
      *(_QWORD *)v117 = _NSConcreteStackBlock;
      *(_QWORD *)&v117[8] = 0x40000000;
      *(_QWORD *)&v117[16] = sub_10004F440;
      v118 = &unk_100077EE0;
      v119 = &db;
      sub_1000352AC((uint64_t)CFSTR("valid.sqlite3"), v117);
      if (*((_BYTE *)p_db + 24))
      {
        v85 = sub_10004F500();
        v86 = sub_100011628("validupdate");
        if (os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v120 = 0;
          _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_DEFAULT, "initializing database", v120, 2u);
        }
        if (!sub_10004F5B8(v85, 0, 0, 1))
        {
          v87 = (void *)sub_10004F788();
          sub_10003E9E8(v87, (uint64_t)v85, 0);
        }
        if (v85)
          CFRelease(v85);
      }
    }
  }
  v88 = sub_100011628("validupdate");
  if (os_log_type_enabled(v88, OS_LOG_TYPE_DEBUG))
  {
    v105 = sub_10004F810();
    v106 = sub_10004F89C();
    v107 = sub_10004F928();
    *(_DWORD *)v120 = 134218496;
    *(_QWORD *)&v120[4] = v105;
    v121 = 2048;
    v122 = v106;
    v123 = 2048;
    v124 = v107;
    _os_log_debug_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEBUG, "starting service with g%ld, v%ld, schema v%ld", v120, 0x20u);
  }
  os_release(v84);
  _Block_object_dispose(&db, 8);
  if (qword_100082DD0 != -1)
    dispatch_once(&qword_100082DD0, &stru_100077C70);
  if (sub_100015138())
  {
    v89 = objc_autoreleasePoolPush();
    v90 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_BACKGROUND, 0);
    v91 = objc_claimAutoreleasedReturnValue(v90);
    v92 = dispatch_queue_attr_make_with_autorelease_frequency(v91, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    v93 = objc_claimAutoreleasedReturnValue(v92);

    v94 = dispatch_queue_create("com.apple.trustd.Background.Analytics", v93);
    v95 = (void *)qword_100082E60;
    qword_100082E60 = (uint64_t)v94;

    qword_100082E78 = mach_absolute_time();
    v96 = objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
    v97 = (void *)qword_100082E68;
    qword_100082E68 = v96;

    v98 = objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
    v99 = (void *)qword_100082E70;
    qword_100082E70 = v98;

    v100 = (void *)objc_claimAutoreleasedReturnValue(+[TrustAnalytics logger](TrustAnalytics, "logger"));
    v101 = SFAnalyticsSamplerIntervalOncePerReport;
    v102 = objc_msgSend(v100, "AddMultiSamplerForName:withTimeInterval:block:", CFSTR("VersionSampler"), &stru_1000791B8, SFAnalyticsSamplerIntervalOncePerReport);

    v103 = (void *)objc_claimAutoreleasedReturnValue(+[NetworkingAnalytics logger](NetworkingAnalytics, "logger"));
    v104 = objc_msgSend(v103, "AddMultiSamplerForName:withTimeInterval:block:", CFSTR("VersionSampler"), &stru_1000791D8, v101);

    objc_autoreleasePoolPop(v89);
  }
}

void sub_10003C4E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  uint64_t v37;

  _Block_object_dispose(&a37, 8);
  _Block_object_dispose((const void *)(v37 - 176), 8);
  _Block_object_dispose((const void *)(v37 - 128), 8);
  _Unwind_Resume(a1);
}

void sub_10003CAF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 a9)
{
  void *v9;
  void *v10;
  id v11;
  const void *v12;
  NSObject *v13;
  id v14;
  id v15;

  if (a2 == 1)
  {
    v11 = objc_begin_catch(exception_object);
    v12 = sub_100011628("validupdate");
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      v14 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "description")));
      v15 = objc_msgSend(v14, "UTF8String");
      LODWORD(a9) = 136315138;
      *(_QWORD *)((char *)&a9 + 4) = v15;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%s", (uint8_t *)&a9, 0xCu);

    }
    sub_100052038((uint64_t)CFSTR("ValidUpdateEvent"), 0, 4294967262);
    objc_msgSend(v9, "cancel");
    objc_msgSend(v10, "reschedule");

    objc_end_catch();
    JUMPOUT(0x10003CAB0);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10003CE90(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_10003CEA0(uint64_t a1)
{

}

void sub_10003CEA8(uint64_t a1)
{
  const void *v2;
  NSObject *v3;
  uint64_t v4;
  void *v5;
  uint8_t v6[16];

  v2 = sub_100011628("validupdate");
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Got SIGTERM, abandon all hope and clear transaction", v6, 2u);
  }

  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v5 = *(void **)(v4 + 40);
  *(_QWORD *)(v4 + 40) = 0;

}

void sub_10003CF2C(uint64_t a1)
{
  const void *v2;
  NSObject *v3;
  const std::__fs::filesystem::path *v4;
  timespec v5;
  int v6;
  int v7;
  uint64_t v8;
  off_t st_size;
  const void *v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  const UInt8 *v15;
  UInt8 *v16;
  NSObject *v17;
  NSObject *v18;
  const __CFData *v19;
  BOOL v20;
  const __CFString *v21;
  unsigned int *BytePtr;
  CFIndex Length;
  CFIndex v24;
  const UInt8 *v25;
  const UInt8 *v26;
  CFIndex v27;
  CFDataRef v28;
  CFDataRef v29;
  CFDataRef v30;
  CFDataRef v31;
  const void *ApplePinned;
  int v33;
  int v34;
  NSObject *v35;
  OSStatus TrustResult;
  NSObject *v37;
  NSObject *v38;
  UInt8 *v39;
  size_t v40;
  dev_t v41;
  const void *v42;
  NSObject *v43;
  CFIndex v44;
  const UInt8 *v45;
  std::error_code *v46;
  uint64_t v47;
  void *v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  void *v52;
  const void *v53;
  NSObject *v54;
  CFAbsoluteTime Current;
  const __CFString *v56;
  const __CFString *v57;
  NSObject *v58;
  const void *v59;
  NSObject *v60;
  uint64_t v61;
  uint64_t *v62;
  uint64_t v63;
  uint64_t v64;
  stat buf;
  _BYTE v66[24];
  int v67;

  v2 = sub_100011628("validupdate");
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    buf.st_dev = 134217984;
    *(_QWORD *)&buf.st_mode = CFAbsoluteTimeGetCurrent();
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "update started at %f", (uint8_t *)&buf, 0xCu);
  }

  v4 = (const std::__fs::filesystem::path *)objc_msgSend(objc_retainAutorelease(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8)+ 40)), "fileSystemRepresentation");
  v5.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v5.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&buf.st_blksize = v5;
  *(timespec *)buf.st_qspare = v5;
  buf.st_birthtimespec = v5;
  *(timespec *)&buf.st_size = v5;
  buf.st_mtimespec = v5;
  buf.st_ctimespec = v5;
  *(timespec *)&buf.st_uid = v5;
  buf.st_atimespec = v5;
  *(timespec *)&buf.st_dev = v5;
  v6 = open((const char *)v4, 0);
  if (v6 < 0)
  {
    v8 = *__error();
    if ((_DWORD)v8)
      goto LABEL_9;
    goto LABEL_22;
  }
  v7 = v6;
  v8 = fstat(v6, &buf);
  if ((_DWORD)v8)
  {
LABEL_7:
    close(v7);
LABEL_9:
    v10 = sub_100011628("SecError");
    v11 = objc_claimAutoreleasedReturnValue(v10);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v12 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
      buf.st_dev = 138412546;
      *(_QWORD *)&buf.st_mode = v12;
      WORD2(buf.st_ino) = 1024;
      *(_DWORD *)((char *)&buf.st_ino + 6) = v8;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "failed to read %@ with error %d", (uint8_t *)&buf, 0x12u);
    }

    sub_100052038((uint64_t)CFSTR("ValidUpdateEvent"), 1, v8);
    objc_msgSend(*(id *)(a1 + 32), "reschedule");
    goto LABEL_12;
  }
  st_size = buf.st_size;
  if (buf.st_size > 2147483646)
  {
    v8 = 27;
    goto LABEL_7;
  }
  v15 = (const UInt8 *)mmap(0, buf.st_size, 1, 2, v7, 0);
  v16 = (UInt8 *)v15;
  if (st_size < 0 || (unint64_t)(v15 + 1) <= 1)
  {
    v8 = *__error();
    v17 = sub_100011628("SecError");
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v66 = 136315394;
      *(_QWORD *)&v66[4] = v4;
      *(_WORD *)&v66[12] = 1024;
      *(_DWORD *)&v66[14] = v8;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "unable to map %s (errno %d)", v66, 0x12u);
    }
    close(v7);
    if ((_DWORD)v8)
    {
      if (v16)
      {
        if (munmap(v16, st_size))
        {
          v18 = sub_100011628("SecError");
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)v66 = 134218496;
            *(_QWORD *)&v66[4] = st_size;
            *(_WORD *)&v66[12] = 2048;
            *(_QWORD *)&v66[14] = v16;
            *(_WORD *)&v66[22] = 1024;
            v67 = v8;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "unable to unmap %ld bytes at %p (error %d)", v66, 0x1Cu);
          }
        }
      }
      goto LABEL_9;
    }
LABEL_22:
    v19 = 0;
    goto LABEL_23;
  }
  v19 = CFDataCreateWithBytesNoCopy(0, v15, st_size, kCFAllocatorNull);
  close(v7);
LABEL_23:
  v20 = *(_QWORD *)(a1 + 80) == 0;
  if (v19)
  {
    v21 = *(const __CFString **)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 40);
    BytePtr = (unsigned int *)CFDataGetBytePtr(v19);
    Length = CFDataGetLength(v19);
    if (!BytePtr)
      goto LABEL_46;
    if (Length < 5)
      goto LABEL_46;
    v24 = bswap32(*BytePtr);
    if (v24 + 8 > (unint64_t)Length)
      goto LABEL_46;
    v25 = (const UInt8 *)(BytePtr + 1);
    v26 = (const UInt8 *)BytePtr + v24 + 4;
    v27 = bswap32(*(_DWORD *)v26);
    if ((v27 + v24) + 8 != Length)
      goto LABEL_46;
    *(_QWORD *)&buf.st_dev = 0;
    v28 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, v26 + 4, v27, kCFAllocatorNull);
    if (!v28)
      goto LABEL_46;
    v29 = v28;
    v30 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, v25, v24, kCFAllocatorNull);
    if (v30)
    {
      v31 = v30;
      ApplePinned = (const void *)SecPolicyCreateApplePinned(CFSTR("ValidUpdate"), CFSTR("1.2.840.113635.100.6.2.10"), CFSTR("1.2.840.113635.100.6.51"));
      v33 = SecCMSVerify(v29, v31, ApplePinned, &buf, 0);
      if (v33)
      {
        v34 = v33;
        v35 = sub_100011628("SecError");
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v66 = 67109120;
          *(_DWORD *)&v66[4] = v34;
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "failed to verify Valid Update: %d", v66, 8u);
        }
        TrustResult = -67671;
      }
      else
      {
        LODWORD(v61) = 0;
        TrustResult = SecTrustGetTrustResult(*(SecTrustRef *)&buf.st_dev, (SecTrustResultType *)&v61);
        if (!TrustResult && (_DWORD)v61 != 1 && (_DWORD)v61 != 4)
        {
          v60 = sub_100011628("SecError");
          if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)v66 = 67109120;
            *(_DWORD *)&v66[4] = v61;
            _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "Valid Update SecTrustEvaluate failed with trust result %d\n", v66, 8u);
          }
          TrustResult = -67671;
        }
      }
      CFRelease(v31);
    }
    else
    {
      ApplePinned = 0;
      TrustResult = -67671;
    }
    CFRelease(v29);
    if (*(_QWORD *)&buf.st_dev)
      CFRelease(*(CFTypeRef *)&buf.st_dev);
    if (ApplePinned)
      CFRelease(ApplePinned);
    if (TrustResult)
    {
LABEL_46:
      v38 = sub_100011628("SecError");
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.st_dev) = 0;
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "failed to verify valid update", (uint8_t *)&buf, 2u);
      }
      sub_100052038((uint64_t)CFSTR("ValidUpdateEvent"), 1, 4294899488);
      goto LABEL_49;
    }
    v56 = (const __CFString *)sub_10004606C();
    v57 = v56;
    if (v21 && v56)
    {
      if (CFStringCompare(v56, v21, 1uLL))
      {
        v58 = sub_100011628("validupdate");
        if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
        {
          buf.st_dev = 138412546;
          *(_QWORD *)&buf.st_mode = v57;
          WORD2(buf.st_ino) = 2112;
          *(__darwin_ino64_t *)((char *)&buf.st_ino + 6) = (__darwin_ino64_t)v21;
          _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "switching db source from \"%@\" to \"%@\"", (uint8_t *)&buf, 0x16u);
        }
      }
    }
    else if (!v56)
    {
LABEL_70:
      *(_QWORD *)v66 = 0;
      *(_QWORD *)&v66[8] = v66;
      *(_QWORD *)&v66[16] = 0x2000000000;
      LOBYTE(v67) = 1;
      v61 = 0;
      v62 = &v61;
      v63 = 0x2000000000;
      v64 = 0;
      *(_QWORD *)&buf.st_dev = _NSConcreteStackBlock;
      buf.st_ino = 0x40000000;
      *(_QWORD *)&buf.st_uid = sub_1000460F4;
      *(_QWORD *)&buf.st_rdev = &unk_100077E50;
      buf.st_atimespec.tv_sec = (__darwin_time_t)v66;
      buf.st_atimespec.tv_nsec = (uint64_t)&v61;
      LOBYTE(buf.st_ctimespec.tv_sec) = v20;
      buf.st_mtimespec.tv_sec = (__darwin_time_t)v21;
      buf.st_mtimespec.tv_nsec = (uint64_t)v19;
      sub_100016C6C((uint64_t)&buf);
      sub_100046288(*(double *)&qword_100082E00);
      v59 = (const void *)v62[3];
      if (v59)
        CFRelease(v59);
      _Block_object_dispose(&v61, 8);
      _Block_object_dispose(v66, 8);
      goto LABEL_49;
    }
    CFRelease(v57);
    goto LABEL_70;
  }
  v37 = sub_100011628("validupdate");
  if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.st_dev) = 0;
    _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "invalid update data", (uint8_t *)&buf, 2u);
  }
LABEL_49:
  if (CFDataGetLength(v19) < 0)
  {
    v41 = 0;
    goto LABEL_53;
  }
  v39 = (UInt8 *)CFDataGetBytePtr(v19);
  v40 = CFDataGetLength(v19);
  v41 = munmap(v39, v40);
  if (v41)
  {
LABEL_53:
    v42 = sub_100011628("SecError");
    v43 = objc_claimAutoreleasedReturnValue(v42);
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      v44 = CFDataGetLength(v19);
      v45 = CFDataGetBytePtr(v19);
      buf.st_dev = 134218496;
      *(_QWORD *)&buf.st_mode = v44;
      WORD2(buf.st_ino) = 2048;
      *(__darwin_ino64_t *)((char *)&buf.st_ino + 6) = (__darwin_ino64_t)v45;
      HIWORD(buf.st_gid) = 1024;
      buf.st_rdev = v41;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "unable to unmap current update %ld bytes at %p (error %d)", (uint8_t *)&buf, 0x1Cu);
    }

  }
  if (v19)
    CFRelease(v19);
  objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 40), "closeFile");
  if (v4)
    remove(v4, v46);
  v47 = *(_QWORD *)(a1 + 32);
  v48 = *(void **)(v47 + 48);
  *(_QWORD *)(v47 + 48) = 0;

  v49 = *(_QWORD *)(a1 + 32);
  v50 = *(void **)(v49 + 56);
  *(_QWORD *)(v49 + 56) = 0;

  v51 = *(_QWORD *)(a1 + 32);
  v52 = *(void **)(v51 + 40);
  *(_QWORD *)(v51 + 40) = 0;

  v53 = sub_100011628("validupdate");
  v54 = objc_claimAutoreleasedReturnValue(v53);
  if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
  {
    Current = CFAbsoluteTimeGetCurrent();
    buf.st_dev = 134217984;
    *(CFAbsoluteTime *)&buf.st_mode = Current;
    _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "update finished at %f", (uint8_t *)&buf, 0xCu);
  }

  qword_100082DF8 = 0;
  (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16) + 16))();
LABEL_12:
  dispatch_source_cancel(*(dispatch_source_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40));
  v13 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
  v14 = *(void **)(v13 + 40);
  *(_QWORD *)(v13 + 40) = 0;

}

void sub_10003E06C(uint64_t a1)
{
  double Current;
  double v3;
  int v4;
  BOOL v5;
  unint64_t v6;
  const void *v7;
  NSObject *v8;
  uint64_t v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  id v15;
  const void *v16;
  NSObject *v17;
  NSString *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  const void *v23;
  NSObject *v24;
  CFAbsoluteTime v25;
  time_t v26;
  size_t v27;
  _BYTE buf[22];
  __int16 v29;
  NSObject *v30;
  int v31[2];

  Current = CFAbsoluteTimeGetCurrent();
  objc_msgSend(*(id *)(a1 + 32), "updateScheduled");
  if (v3 == 0.0)
  {
    memset(buf, 170, 16);
    v26 = 0xAAAAAAAAAAAAAAAALL;
    v27 = 16;
    *(_QWORD *)v31 = 0x1500000001;
    time(&v26);
    v4 = sysctl(v31, 2u, buf, &v27, 0, 0);
    if (*(_QWORD *)buf)
      v5 = v4 == -1;
    else
      v5 = 1;
    if (v5)
      v6 = 0;
    else
      v6 = v26 - *(_QWORD *)buf;
    if (v6 <= 0xB3)
    {
      *(double *)&qword_100082E00 = Current + (double)(180 - v6);
      qword_100082DF8 = 0;
      v16 = sub_100011628("validupdate");
      v17 = objc_claimAutoreleasedReturnValue(v16);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)&buf[4] = qword_100082E00;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "postponing update until %f", buf, 0xCu);
      }
    }
    else
    {
      objc_msgSend(*(id *)(a1 + 32), "setUpdateScheduled:", Current);
      v7 = sub_100011628("validupdate");
      v8 = objc_claimAutoreleasedReturnValue(v7);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        objc_msgSend(*(id *)(a1 + 32), "updateScheduled");
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)&buf[4] = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "scheduling update at %f", buf, 0xCu);
      }

      v10 = (void *)os_transaction_create("com.apple.trustd.valid.scheduleUpdate");
      if (qword_100082D40 != -1)
        dispatch_once(&qword_100082D40, &stru_1000773C8);
      v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "backgroundSession"));

      v12 = *(void **)(a1 + 32);
      if (v11)
      {
        v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "backgroundSession"));
        v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "delegate"));

        v15 = objc_msgSend(*(id *)(a1 + 48), "copy");
        objc_msgSend(v14, "setCurrentUpdateServer:", v15);

      }
      else
      {
        objc_msgSend(v12, "createSessions:forServer:", *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48));
      }
      v18 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("https://%@/g%ld/v%ld"), *(_QWORD *)(a1 + 48), sub_10004ED44(), *(_QWORD *)(a1 + 56));
      v19 = (void *)objc_claimAutoreleasedReturnValue(v18);
      v17 = objc_claimAutoreleasedReturnValue(+[NSURL URLWithString:](NSURL, "URLWithString:", v19));

      v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "backgroundSession"));
      v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "dataTaskWithURL:", v17));

      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%ld"), *(_QWORD *)(a1 + 56)));
      objc_msgSend(v21, "setTaskDescription:", v22);

      objc_msgSend(v21, "resume");
      v23 = sub_100011628("validupdate");
      v24 = objc_claimAutoreleasedReturnValue(v23);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        v25 = CFAbsoluteTimeGetCurrent();
        *(_DWORD *)buf = 138412802;
        *(_QWORD *)&buf[4] = v21;
        *(_WORD *)&buf[12] = 2048;
        *(CFAbsoluteTime *)&buf[14] = v25;
        v29 = 2112;
        v30 = v17;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "scheduled background data task %@ at %f URL:%@", buf, 0x20u);
      }

    }
  }
}

void sub_10003E400(id a1)
{
  void *v1;

  v1 = objc_autoreleasePoolPush();
  +[NSURLSession _obliterateAllBackgroundSessionsWithCompletionHandler:](NSURLSession, "_obliterateAllBackgroundSessionsWithCompletionHandler:", &stru_1000773E8);
  objc_autoreleasePoolPop(v1);
}

void sub_10003E438(id a1)
{
  const void *v1;
  NSObject *v2;
  uint8_t v3[16];

  v1 = sub_100011628("validupdate");
  v2 = objc_claimAutoreleasedReturnValue(v1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "removing all old sessions for trustd", v3, 2u);
  }

}

void sub_10003E4A4(id a1)
{
  objc_msgSend((id)qword_100082D38, "setUpdateScheduled:", 0.0);
}

void sub_10003E83C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10003E9D4(uint64_t a1)
{
  sub_10000FDEC(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 16));
}

void sub_10003E9E8(void *a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  id v6;

  v6 = a1;
  if (qword_100082D70 != -1)
    dispatch_once(&qword_100082D70, &stru_100077470);
  v5 = objc_autoreleasePoolPush();
  objc_msgSend((id)qword_100082D38, "scheduleUpdateFromServer:forVersion:withQueue:", a2, a3, v6);
  objc_autoreleasePoolPop(v5);

}

void sub_10003EA74(id a1)
{
  void *v1;
  ValidUpdateRequest *v2;
  void *v3;

  v1 = objc_autoreleasePoolPush();
  v2 = objc_alloc_init(ValidUpdateRequest);
  v3 = (void *)qword_100082D38;
  qword_100082D38 = (uint64_t)v2;

  objc_autoreleasePoolPop(v1);
}

void sub_10003EAB4(id a1)
{
  OCSPFetchDelegate *v1;
  void *v2;
  TrustURLSessionCache *v3;
  TrustURLSessionCache *v4;
  void *v5;

  v1 = objc_alloc_init(OCSPFetchDelegate);
  v2 = (void *)qword_100082D60;
  qword_100082D60 = (uint64_t)v1;

  v3 = [TrustURLSessionCache alloc];
  v4 = -[TrustURLSessionCache initWithDelegate:](v3, "initWithDelegate:", qword_100082D60);
  v5 = (void *)qword_100082D58;
  qword_100082D58 = (uint64_t)v4;

}

BOOL sub_10003EB08(id a1, id a2, id *a3, __CFError **a4)
{
  id v6;
  uint64_t v7;
  id v8;
  uint64_t v9;
  id v10;
  id v11;
  id v12;
  BOOL v13;
  _QWORD v15[4];
  id v16;
  uint64_t *v17;
  __CFError **v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  char v22;

  v6 = a2;
  v19 = 0;
  v20 = &v19;
  v21 = 0x2020000000;
  v22 = 1;
  v7 = objc_opt_class(NSDictionary);
  if ((objc_opt_isKindOfClass(v6, v7) & 1) == 0)
  {
    sub_100012C88(-50, (__CFString **)a4, CFSTR("value for CT Exceptions is not a dictionary in new configuration"));
LABEL_11:
    v13 = 0;
    goto LABEL_14;
  }
  if (!a3)
    goto LABEL_10;
  v8 = *a3;
  if (!*a3)
  {
LABEL_6:
    v10 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
    *a3 = v10;
    goto LABEL_7;
  }
  v9 = objc_opt_class(NSMutableDictionary);
  if ((objc_opt_isKindOfClass(v8, v9) & 1) == 0)
  {
LABEL_10:
    sub_100012C88(-50, (__CFString **)a4, CFSTR("value for CT Exceptions is not a dictionary in current configuration"));
    goto LABEL_11;
  }
  v10 = *a3;
  if (!*a3)
    goto LABEL_6;
LABEL_7:
  v11 = v10;
  v12 = v6;
  if (objc_msgSend(v12, "count"))
  {
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 3221225472;
    v15[2] = sub_10003ECA4;
    v15[3] = &unk_1000774D8;
    v17 = &v19;
    v18 = a4;
    v16 = v11;
    objc_msgSend(v12, "enumerateKeysAndObjectsUsingBlock:", v15);
    v13 = *((_BYTE *)v20 + 24) != 0;

  }
  else
  {
    v13 = 1;
  }

LABEL_14:
  _Block_object_dispose(&v19, 8);

  return v13;
}

void sub_10003EC88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10003ECA4(_QWORD *a1, void *a2, void *a3, _BYTE *a4)
{
  id v7;
  __CFString **v8;
  void *v9;
  unsigned int v10;
  id v11;
  void *v12;
  id v13;

  v13 = a2;
  v7 = a3;
  if (objc_msgSend(v13, "isEqualToString:", kSecCTExceptionsDomainsKey))
  {
    v8 = (__CFString **)a1[6];
    v9 = sub_10003EDB8;
  }
  else
  {
    v10 = objc_msgSend(v13, "isEqualToString:", kSecCTExceptionsCAsKey);
    v8 = (__CFString **)a1[6];
    if (!v10)
    {
      sub_100012C88(-50, v8, CFSTR("unknown key (%@) in configuration dictionary"), v13);
      *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) = 0;
      goto LABEL_9;
    }
    v9 = sub_10003EF3C;
  }
  if (!sub_10003EE10(v13, v7, (uint64_t)v9, v8))
  {
LABEL_9:
    *a4 = 1;
    *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) = 0;
    goto LABEL_10;
  }
  v11 = objc_msgSend(v7, "count");
  v12 = (void *)a1[4];
  if (v11)
    objc_msgSend(v12, "setObject:forKeyedSubscript:", v7, v13);
  else
    objc_msgSend(v12, "removeObjectForKey:", v13);
LABEL_10:

}

uint64_t sub_10003EDB8(void *a1)
{
  id v1;
  uint64_t v2;
  uint64_t v3;

  v1 = a1;
  v2 = objc_opt_class(NSString);
  if ((objc_opt_isKindOfClass(v1, v2) & 1) != 0)
    v3 = SecDNSIsTLD(v1) ^ 1;
  else
    v3 = 0;

  return v3;
}

BOOL sub_10003EE10(void *a1, void *a2, uint64_t a3, __CFString **a4)
{
  id v7;
  id v8;
  uint64_t v9;
  _BOOL8 v10;
  _QWORD v12[4];
  id v13;
  uint64_t *v14;
  uint64_t v15;
  __CFString **v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  char v20;

  v7 = a1;
  v8 = a2;
  v9 = objc_opt_class(NSArray);
  if ((objc_opt_isKindOfClass(v8, v9) & 1) != 0)
  {
    v17 = 0;
    v18 = &v17;
    v19 = 0x2020000000;
    v20 = 1;
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472;
    v12[2] = sub_10003F094;
    v12[3] = &unk_100077A08;
    v14 = &v17;
    v15 = a3;
    v16 = a4;
    v13 = v7;
    objc_msgSend(v8, "enumerateObjectsUsingBlock:", v12);
    v10 = *((_BYTE *)v18 + 24) != 0;

    _Block_object_dispose(&v17, 8);
  }
  else
  {
    sub_100012C88(-50, a4, CFSTR("value for %@ is not an array in configuration"), v7);
    v10 = 0;
  }

  return v10;
}

void sub_10003EF24(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

id sub_10003EF3C(void *a1)
{
  id v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  void *v7;
  void *v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  char isKindOfClass;
  id v13;

  v1 = a1;
  v2 = objc_opt_class(NSDictionary);
  if ((objc_opt_isKindOfClass(v1, v2) & 1) != 0 && objc_msgSend(v1, "count") == (id)2)
  {
    v3 = kSecTrustStoreHashAlgorithmKey;
    v4 = objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "objectForKeyedSubscript:", kSecTrustStoreHashAlgorithmKey));
    if (v4)
    {
      v5 = (void *)v4;
      v6 = kSecTrustStoreSPKIHashKey;
      v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "objectForKeyedSubscript:", kSecTrustStoreSPKIHashKey));

      if (v7)
      {
        v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "objectForKeyedSubscript:", v3));
        v9 = objc_opt_class(NSString);
        if ((objc_opt_isKindOfClass(v8, v9) & 1) == 0)
        {
          v13 = 0;
          goto LABEL_11;
        }
        v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "objectForKeyedSubscript:", v6));
        v11 = objc_opt_class(NSData);
        isKindOfClass = objc_opt_isKindOfClass(v10, v11);

        if ((isKindOfClass & 1) != 0)
        {
          v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "objectForKeyedSubscript:", v3));
          v13 = objc_msgSend(v8, "isEqualToString:", CFSTR("sha256"));
LABEL_11:

          goto LABEL_9;
        }
      }
    }
  }
  v13 = 0;
LABEL_9:

  return v13;
}

void sub_10003F094(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  if (((*(uint64_t (**)(uint64_t))(a1 + 48))(a2) & 1) == 0)
  {
    sub_100012C88(-50, *(__CFString ***)(a1 + 56), CFSTR("value %lu for %@ is not the expected type"), a3, *(_QWORD *)(a1 + 32));
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
    *a4 = 1;
  }
}

NSDictionary *__cdecl sub_10003F108(id a1, NSURL *a2, id *a3)
{
  return +[NSDictionary dictionaryWithContentsOfURL:error:](NSDictionary, "dictionaryWithContentsOfURL:error:", a2, a3);
}

void *__cdecl sub_10003F11C(id a1, NSDictionary *a2, __CFError **a3)
{
  NSDictionary *v4;
  void *v5;
  void *v6;
  id v7;
  id v8;
  void *v9;
  id v10;
  _QWORD v12[4];
  id v13;
  id v14;
  __CFError **v15;

  v4 = a2;
  v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
  v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_10003F27C;
  v12[3] = &unk_100077580;
  v15 = a3;
  v7 = v5;
  v13 = v7;
  v8 = v6;
  v14 = v8;
  -[NSDictionary enumerateKeysAndObjectsUsingBlock:](v4, "enumerateKeysAndObjectsUsingBlock:", v12);

  v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionaryWithCapacity:](NSMutableDictionary, "dictionaryWithCapacity:", 2));
  if (objc_msgSend(v7, "count"))
    objc_msgSend(v9, "setObject:forKeyedSubscript:", v7, kSecCTExceptionsDomainsKey);
  if (objc_msgSend(v8, "count"))
    objc_msgSend(v9, "setObject:forKeyedSubscript:", v8, kSecCTExceptionsCAsKey);
  if (objc_msgSend(v9, "count"))
  {
    atomic_store(1u, byte_100082D78);
    v10 = v9;
  }
  else
  {
    v10 = 0;
  }

  return v10;
}

void sub_10003F27C(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4;
  char isKindOfClass;
  void *v6;
  id v7;
  void *v8;
  uint64_t v9;
  void *v10;
  void *v11;
  _BOOL4 v12;
  void *v13;
  void *v14;
  void *v15;
  uint64_t v16;
  void *v17;
  void *v18;
  _BOOL4 v19;
  void *v20;
  void *v21;
  id v22;

  v22 = a3;
  v4 = objc_opt_class(NSDictionary);
  isKindOfClass = objc_opt_isKindOfClass(v22, v4);
  v6 = v22;
  if ((isKindOfClass & 1) != 0)
  {
    v7 = v22;
    v8 = (void *)kSecCTExceptionsDomainsKey;
    v9 = objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", kSecCTExceptionsDomainsKey));
    if (v9)
    {
      v10 = (void *)v9;
      v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", v8));
      v12 = sub_10003EE10(v8, v11, (uint64_t)sub_10003EDB8, *(__CFString ***)(a1 + 48));

      if (v12)
      {
        v13 = *(void **)(a1 + 32);
        v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", v8));
        objc_msgSend(v13, "addObjectsFromArray:", v14);

      }
    }
    v15 = (void *)kSecCTExceptionsCAsKey;
    v16 = objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", kSecCTExceptionsCAsKey));
    if (v16)
    {
      v17 = (void *)v16;
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", v15));
      v19 = sub_10003EE10(v15, v18, (uint64_t)sub_10003EF3C, *(__CFString ***)(a1 + 48));

      if (v19)
      {
        v20 = *(void **)(a1 + 40);
        v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", v15));
        objc_msgSend(v20, "addObjectsFromArray:", v21);

      }
    }

    v6 = v22;
  }

}

BOOL sub_10003F3F4(id a1, id a2, id *a3, __CFError **a4)
{
  id v6;
  uint64_t v7;
  id v8;
  uint64_t v9;
  id v10;
  id v11;
  id v12;
  BOOL v13;
  _QWORD v15[4];
  id v16;
  uint64_t *v17;
  __CFError **v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  char v22;

  v6 = a2;
  v19 = 0;
  v20 = &v19;
  v21 = 0x2020000000;
  v22 = 1;
  v7 = objc_opt_class(NSDictionary);
  if ((objc_opt_isKindOfClass(v6, v7) & 1) == 0)
  {
    sub_100012C88(-50, (__CFString **)a4, CFSTR("value for CA revocation additions is not a dictionary in new configuration"));
LABEL_11:
    v13 = 0;
    goto LABEL_14;
  }
  if (!a3)
    goto LABEL_10;
  v8 = *a3;
  if (!*a3)
  {
LABEL_6:
    v10 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
    *a3 = v10;
    goto LABEL_7;
  }
  v9 = objc_opt_class(NSMutableDictionary);
  if ((objc_opt_isKindOfClass(v8, v9) & 1) == 0)
  {
LABEL_10:
    sub_100012C88(-50, (__CFString **)a4, CFSTR("value for CA revocation additions is not a dictionary in existing configuration"));
    goto LABEL_11;
  }
  v10 = *a3;
  if (!*a3)
    goto LABEL_6;
LABEL_7:
  v11 = v10;
  v12 = v6;
  if (objc_msgSend(v12, "count"))
  {
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 3221225472;
    v15[2] = sub_10003F590;
    v15[3] = &unk_1000774D8;
    v17 = &v19;
    v18 = a4;
    v16 = v11;
    objc_msgSend(v12, "enumerateKeysAndObjectsUsingBlock:", v15);
    v13 = *((_BYTE *)v20 + 24) != 0;

  }
  else
  {
    v13 = 1;
  }

LABEL_14:
  _Block_object_dispose(&v19, 8);

  return v13;
}

void sub_10003F574(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10003F590(_QWORD *a1, void *a2, void *a3, _BYTE *a4)
{
  id v7;
  unsigned int v8;
  __CFString **v9;
  id v10;
  void *v11;
  id v12;

  v12 = a2;
  v7 = a3;
  v8 = objc_msgSend(v12, "isEqualToString:", kSecCARevocationAdditionsKey);
  v9 = (__CFString **)a1[6];
  if (!v8)
  {
    sub_100012C88(-50, v9, CFSTR("unknown key (%@) in additions dictionary"), v12);
    *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) = 0;
    goto LABEL_6;
  }
  if (!sub_10003EE10(v12, v7, (uint64_t)sub_10003EF3C, v9))
  {
LABEL_6:
    *a4 = 1;
    *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) = 0;
    goto LABEL_7;
  }
  v10 = objc_msgSend(v7, "count");
  v11 = (void *)a1[4];
  if (v10)
    objc_msgSend(v11, "setObject:forKeyedSubscript:", v7, v12);
  else
    objc_msgSend(v11, "removeObjectForKey:", v12);
LABEL_7:

}

NSDictionary *__cdecl sub_10003F67C(id a1, NSURL *a2, id *a3)
{
  return +[NSDictionary dictionaryWithContentsOfURL:error:](NSDictionary, "dictionaryWithContentsOfURL:error:", a2, a3);
}

void *__cdecl sub_10003F690(id a1, NSDictionary *a2, __CFError **a3)
{
  NSDictionary *v4;
  id v5;
  void *v6;
  id v7;
  void **v9;
  uint64_t v10;
  void (*v11)(uint64_t, uint64_t, void *);
  void *v12;
  id v13;
  __CFError **v14;

  v4 = a2;
  v9 = _NSConcreteStackBlock;
  v10 = 3221225472;
  v11 = sub_10003F7A0;
  v12 = &unk_100077628;
  v14 = a3;
  v5 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
  v13 = v5;
  -[NSDictionary enumerateKeysAndObjectsUsingBlock:](v4, "enumerateKeysAndObjectsUsingBlock:", &v9);

  v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionaryWithCapacity:](NSMutableDictionary, "dictionaryWithCapacity:", 1, v9, v10, v11, v12));
  if (objc_msgSend(v5, "count"))
    objc_msgSend(v6, "setObject:forKeyedSubscript:", v5, kSecCARevocationAdditionsKey);
  if (objc_msgSend(v6, "count"))
  {
    atomic_store(1u, byte_100082D88);
    v7 = v6;
  }
  else
  {
    v7 = 0;
  }

  return v7;
}

void sub_10003F7A0(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4;
  char isKindOfClass;
  void *v6;
  id v7;
  void *v8;
  uint64_t v9;
  void *v10;
  void *v11;
  _BOOL4 v12;
  void *v13;
  void *v14;
  id v15;

  v15 = a3;
  v4 = objc_opt_class(NSDictionary);
  isKindOfClass = objc_opt_isKindOfClass(v15, v4);
  v6 = v15;
  if ((isKindOfClass & 1) != 0)
  {
    v7 = v15;
    v8 = (void *)kSecCARevocationAdditionsKey;
    v9 = objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", kSecCARevocationAdditionsKey));
    if (v9)
    {
      v10 = (void *)v9;
      v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", v8));
      v12 = sub_10003EE10(v8, v11, (uint64_t)sub_10003EF3C, *(__CFString ***)(a1 + 40));

      if (v12)
      {
        v13 = *(void **)(a1 + 32);
        v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", v8));
        objc_msgSend(v13, "addObjectsFromArray:", v14);

      }
    }

    v6 = v15;
  }

}

NSDictionary *__cdecl sub_10003F890(id a1, NSURL *a2, id *a3)
{
  return +[NSDictionary dictionaryWithContentsOfURL:error:](NSDictionary, "dictionaryWithContentsOfURL:error:", a2, a3);
}

BOOL sub_10003F8A4(id a1, id a2, id *a3, __CFError **a4)
{
  id v6;
  id v7;
  uint64_t v8;
  BOOL v9;

  v6 = a2;
  if (!a3)
    goto LABEL_10;
  v7 = *a3;
  if (*a3)
  {
    v8 = objc_opt_class(NSMutableArray);
    if ((objc_opt_isKindOfClass(v7, v8) & 1) != 0)
    {
      if (*a3)
        goto LABEL_6;
      goto LABEL_5;
    }
LABEL_10:
    sub_100012C88(-50, (__CFString **)a4, CFSTR("value for Transparent Connection pins is not an array in existing configuration"));
    goto LABEL_11;
  }
LABEL_5:
  *a3 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
LABEL_6:
  if (!sub_10003EE10(CFSTR("TransparentConnectionPins"), v6, (uint64_t)sub_10003EF3C, (__CFString **)a4))
  {
LABEL_11:
    v9 = 0;
    goto LABEL_14;
  }
  if (v6)
  {
    if (objc_msgSend(v6, "count"))
      *a3 = objc_msgSend(v6, "mutableCopy");
  }
  else
  {
    objc_msgSend(*a3, "removeAllObjects");
  }
  v9 = 1;
LABEL_14:

  return v9;
}

void *__cdecl sub_10003F994(id a1, NSDictionary *a2, __CFError **a3)
{
  NSDictionary *v4;
  id v5;
  id v6;
  void **v8;
  uint64_t v9;
  void (*v10)(uint64_t, uint64_t, void *);
  void *v11;
  id v12;
  __CFError **v13;

  v4 = a2;
  v8 = _NSConcreteStackBlock;
  v9 = 3221225472;
  v10 = sub_10003FA64;
  v11 = &unk_100077628;
  v13 = a3;
  v5 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
  v12 = v5;
  -[NSDictionary enumerateKeysAndObjectsUsingBlock:](v4, "enumerateKeysAndObjectsUsingBlock:", &v8);

  if (objc_msgSend(v5, "count", v8, v9, v10, v11))
  {
    atomic_store(1u, byte_100082D98);
    v6 = v5;
  }
  else
  {
    v6 = 0;
  }

  return v6;
}

void sub_10003FA64(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;

  v4 = a3;
  if (sub_10003EE10(CFSTR("TransparentConnectionPins"), v4, (uint64_t)sub_10003EF3C, *(__CFString ***)(a1 + 40)))
    objc_msgSend(*(id *)(a1 + 32), "addObjectsFromArray:", v4);

}

uint64_t sub_10003FAC0(uint64_t a1, uint64_t a2, __CFString **a3)
{
  CFURLRef v6;
  void *v7;
  uint64_t v8;

  v6 = sub_10003FB4C();
  v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
  v8 = sub_10003FB68(a1, a2, a3, (__CFString *)"CT Exceptions", v7, byte_100082D78, "com.apple.trustd.ct.exceptions-changed", &stru_100077518, &stru_1000774B0);

  return v8;
}

CFURLRef sub_10003FB4C()
{
  return sub_10001DC28((uint64_t)CFSTR("CTExceptions.plist"));
}

uint64_t sub_10003FB68(uint64_t a1, uint64_t a2, __CFString **a3, __CFString *a4, void *a5, unsigned __int8 *a6, const char *a7, void *a8, void *a9)
{
  id v16;
  uint64_t (**v17)(id, id, id *);
  uint64_t (**v18)(id, _QWORD, id *, __CFString **);
  uint64_t v19;
  void *v20;
  id v21;
  id v22;
  void *v23;
  const void *v24;
  NSObject *v25;
  const void *v26;
  NSObject *v27;
  const void *v28;
  NSObject *v29;
  uint64_t v30;
  char v32;
  id v33;
  unsigned __int8 v34;
  __CFString *v35;
  const void *v36;
  NSObject *v37;
  __CFString *v38;
  unsigned __int8 v39;
  const char *v40;
  const void *v41;
  NSObject *v42;
  const void *v43;
  NSObject *v44;
  __CFString *v45;
  unsigned __int8 *v46;
  const char *v47;
  __CFString *v48;
  void *context;
  __CFString *v50;
  id v51;
  id v52;
  uint8_t buf[4];
  __CFString *v54;
  __int16 v55;
  __CFString *v56;

  v16 = a5;
  v17 = a8;
  v18 = a9;
  if ((sub_100015138() & 1) != 0)
  {
    if (qword_100082C28 != -1)
      dispatch_once(&qword_100082C28, &stru_1000767D0);
    if ((byte_100082C20 & 1) != 0)
    {
      if (a1)
      {
        v46 = a6;
        v47 = a7;
        context = objc_autoreleasePoolPush();
        v52 = 0;
        v19 = v17[2](v17, v16, &v52);
        v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
        v48 = (__CFString *)v52;
        v21 = objc_msgSend(v20, "mutableCopy");

        if (v21)
        {
          v22 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "objectForKeyedSubscript:", a1));

          if (v22)
          {
            v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "objectForKeyedSubscript:", a1));
            v22 = objc_msgSend(v23, "mutableCopy");

          }
          if (!a2)
            goto LABEL_26;
        }
        else
        {
          v21 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
          v22 = 0;
          if (!a2)
            goto LABEL_26;
        }
        v51 = v22;
        v32 = v18[2](v18, a2, &v51, a3);
        v33 = v51;

        if ((v32 & 1) == 0)
        {
          v43 = sub_100011628("SecError");
          v44 = objc_claimAutoreleasedReturnValue(v43);
          if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
          {
            if (a3)
              v45 = *a3;
            else
              v45 = 0;
            *(_DWORD *)buf = 136446466;
            v54 = a4;
            v55 = 2112;
            v56 = v45;
            _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "%{public}s have error: %@", buf, 0x16u);
          }

          v30 = 0;
          v35 = v48;
          goto LABEL_44;
        }
        v22 = v33;
        if (objc_msgSend(v33, "count"))
        {
          objc_msgSend(v21, "setObject:forKeyedSubscript:", v33, a1);
          goto LABEL_27;
        }
LABEL_26:
        v33 = v22;
        objc_msgSend(v21, "removeObjectForKey:", a1);
LABEL_27:
        v50 = v48;
        v34 = objc_msgSend(v21, "writeToClassDURL:permissions:error:", v16, 420, &v50);
        v35 = v50;

        if ((v34 & 1) != 0)
        {
          v36 = sub_100011628("config");
          v37 = objc_claimAutoreleasedReturnValue(v36);
          if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
          {
            v38 = (__CFString *)objc_msgSend(v21, "count");
            *(_DWORD *)buf = 134218242;
            v54 = v38;
            v55 = 2082;
            v56 = a4;
            _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "wrote %lu configs for %{public}s", buf, 0x16u);
          }

          v39 = objc_msgSend(v21, "count") != 0;
          v40 = v47;
          atomic_store(v39, v46);
          notify_post(v40);
          v30 = 1;
        }
        else
        {
          v41 = sub_100011628("SecError");
          v42 = objc_claimAutoreleasedReturnValue(v41);
          if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136446466;
            v54 = a4;
            v55 = 2112;
            v56 = v35;
            _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "failed to write %{public}s: %@", buf, 0x16u);
          }

          if (a3)
          {
            if (v35)
              CFRetain(v35);
            v30 = 0;
            *a3 = v35;
          }
          else
          {
            v30 = 0;
          }
        }
LABEL_44:

        objc_autoreleasePoolPop(context);
        goto LABEL_21;
      }
      v28 = sub_100011628("SecError");
      v29 = objc_claimAutoreleasedReturnValue(v28);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v54 = a4;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "application-identifier required to set %{public}s", buf, 0xCu);
      }

      sub_100012C88(-50, a3, CFSTR("application-identifier required to set %s"), a4);
    }
    else
    {
      v26 = sub_100011628("SecError");
      v27 = objc_claimAutoreleasedReturnValue(v26);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v54 = a4;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Unable to write %{public}s from user agent", buf, 0xCu);
      }

      sub_100012C88(-61, a3, CFSTR("Unable to write %s from user agent"), a4);
    }
  }
  else
  {
    v24 = sub_100011628("SecError");
    v25 = objc_claimAutoreleasedReturnValue(v24);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v54 = a4;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Unable to write %{public}s in this environment", buf, 0xCu);
    }

    sub_100012C88(-4, a3, CFSTR("Unable to write %s in this environment"), a4);
  }
  v30 = 0;
LABEL_21:

  return v30;
}

uint64_t sub_1000400A8(uint64_t a1, uint64_t a2)
{
  CFURLRef v4;
  void *v5;
  uint64_t v6;

  if (qword_100082D80 != -1)
    dispatch_once(&qword_100082D80, &stru_1000775A0);
  v4 = sub_10003FB4C();
  v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  v6 = sub_10001D9F8(a1, a2, (uint64_t)"CT Exceptions", byte_100082D78, &dword_100082D7C, v5, &stru_100077518, &stru_100077558);

  return v6;
}

void sub_100040148(id a1)
{
  CFURLRef v1;
  id v2;

  v1 = sub_10003FB4C();
  v2 = (id)objc_claimAutoreleasedReturnValue(v1);
  sub_1000401A0((uint64_t)"CT Exceptions", byte_100082D78, "com.apple.trustd.ct.exceptions-changed", &dword_100082D7C, v2, &stru_100077518);

}

void sub_1000401A0(uint64_t a1, unsigned __int8 *a2, const char *a3, int *a4, void *a5, void *a6)
{
  id v11;
  uint64_t (**v12)(id, id, id *);
  void *v13;
  uint64_t v14;
  void *v15;
  const void *v16;
  NSObject *v17;
  unsigned __int8 v18;
  const void *v19;
  uint32_t v20;
  const void *v21;
  NSObject *v22;
  id v23;
  id v24;
  uint8_t buf[4];
  uint64_t v26;
  __int16 v27;
  id v28;

  v11 = a5;
  v12 = a6;
  if (sub_100015138())
  {
    v13 = objc_autoreleasePoolPush();
    v24 = 0;
    v14 = v12[2](v12, v11, &v24);
    v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
    v23 = v24;
    if (v15 && objc_msgSend(v15, "count"))
    {
      v16 = sub_100011628("config");
      v17 = objc_claimAutoreleasedReturnValue(v16);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v26 = a1;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "have %{public}s. will need to read.", buf, 0xCu);
      }
      v18 = 1;
    }
    else
    {
      v19 = sub_100011628("config");
      v17 = objc_claimAutoreleasedReturnValue(v19);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v26 = a1;
        v27 = 2112;
        v28 = v23;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "skipping further reads. no %{public}s found: %@", buf, 0x16u);
      }
      v18 = 0;
    }

    atomic_store(v18, a2);
    if (qword_100082C28 != -1)
      dispatch_once(&qword_100082C28, &stru_1000767D0);
    if ((byte_100082C20 & 1) == 0)
    {
      v20 = notify_register_check(a3, a4);
      if (v20 || (*(_DWORD *)buf = 0, (v20 = notify_check(*a4, (int *)buf)) != 0))
      {
        v21 = sub_100011628("SecError");
        v22 = objc_claimAutoreleasedReturnValue(v21);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446466;
          v26 = a1;
          v27 = 1024;
          LODWORD(v28) = v20;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "failed to establish notification for %{public}s: %u", buf, 0x12u);
        }

        notify_cancel(*a4);
        *a4 = 0;
      }
    }

    objc_autoreleasePoolPop(v13);
  }

}

uint64_t sub_100040434(uint64_t a1, uint64_t a2, __CFString **a3)
{
  CFURLRef v6;
  void *v7;
  uint64_t v8;

  v6 = sub_10001DC0C();
  v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
  v8 = sub_10003FB68(a1, a2, a3, (__CFString *)"CA Revocation Additions", v7, byte_100082D88, "com.apple.trustd.ca.revocation-changed", &stru_1000775E0, &stru_1000775C0);

  return v8;
}

void sub_1000404C0(id a1)
{
  CFURLRef v1;
  id v2;

  v1 = sub_10001DC0C();
  v2 = (id)objc_claimAutoreleasedReturnValue(v1);
  sub_1000401A0((uint64_t)"CA Revocation Additions", byte_100082D88, "com.apple.trustd.ca.revocation-changed", &dword_100082D8C, v2, &stru_1000775E0);

}

uint64_t sub_100040518(uint64_t a1, uint64_t a2, __CFString **a3)
{
  CFURLRef v6;
  void *v7;
  uint64_t v8;

  v6 = sub_1000405A4();
  v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
  v8 = sub_10003FB68(a1, a2, a3, (__CFString *)"Transparent Connection Pins", v7, byte_100082D98, "com.apple.trustd.hrn.pins-changed", &stru_100077668, &stru_100077688);

  return v8;
}

CFURLRef sub_1000405A4()
{
  return sub_10001DC28((uint64_t)CFSTR("TransparentConnectionPins.plist"));
}

uint64_t sub_1000405C0(uint64_t a1, uint64_t a2)
{
  CFURLRef v4;
  void *v5;
  uint64_t v6;

  if (qword_100082DA0 != -1)
    dispatch_once(&qword_100082DA0, &stru_1000776C8);
  v4 = sub_1000405A4();
  v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  v6 = sub_10001D9F8(a1, a2, (uint64_t)"Transparent Connection Pins", byte_100082D98, &dword_100082D9C, v5, &stru_100077668, &stru_1000776A8);

  return v6;
}

void sub_100040660(id a1)
{
  CFURLRef v1;
  id v2;

  v1 = sub_1000405A4();
  v2 = (id)objc_claimAutoreleasedReturnValue(v1);
  sub_1000401A0((uint64_t)"Transparent Connection Pins", byte_100082D98, "com.apple.trustd.hrn.pins-changed", &dword_100082D9C, v2, &stru_100077668);

}

void sub_1000406B8(id a1)
{
  CFURLRef v1;
  CFURLRef v2;
  void *v3;
  CFURLRef v4;
  CFURLRef v5;
  void *v6;
  CFURLRef v7;
  void *v8;
  CFURLRef v9;

  if (qword_100082C28 != -1)
    dispatch_once(&qword_100082C28, &stru_1000767D0);
  if (byte_100082C20 == 1)
  {
    v1 = sub_10001DD50(CFSTR("Library/Keychains"), (uint64_t)CFSTR("CTExceptions.plist"));
    v2 = sub_10003FB4C();
    v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
    sub_100040800(v1, v3, (uint64_t)"CT Exceptions", &stru_100077518);

    v4 = sub_10001DD50(CFSTR("Library/Keychains"), (uint64_t)CFSTR("CARevocation.plist"));
    v5 = sub_10001DC0C();
    v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
    sub_100040800(v4, v6, (uint64_t)"CA Revocation Additions", &stru_1000775E0);

    v9 = sub_10001DD50(CFSTR("Library/Keychains"), (uint64_t)CFSTR("TransparentConnectionPins.plist"));
    v7 = sub_1000405A4();
    v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    sub_100040800(v9, v8, (uint64_t)"Transparent Connection Pins", &stru_100077668);

  }
}

void sub_100040800(void *a1, void *a2, uint64_t a3, void *a4)
{
  id v7;
  id v8;
  uint64_t (**v9)(id, id, id *);
  uint64_t v10;
  void *v11;
  id v12;
  uint64_t v13;
  void *v14;
  id v15;
  unsigned __int8 v16;
  const void *v17;
  NSObject *v18;
  id v19;
  id v20;
  id v21;
  uint8_t buf[4];
  uint64_t v23;
  __int16 v24;
  id v25;

  v7 = a1;
  v8 = a2;
  v9 = a4;
  v21 = 0;
  v10 = v9[2](v9, v8, &v21);
  v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
  v12 = v21;

  if (!v11)
  {
    v20 = v12;
    v13 = v9[2](v9, v7, &v20);
    v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
    v15 = v20;

    if (!v14)
      v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionary](NSDictionary, "dictionary"));
    v19 = v15;
    v16 = objc_msgSend(v14, "writeToClassDURL:permissions:error:", v8, 420, &v19);
    v12 = v19;

    if ((v16 & 1) != 0)
    {
      sub_10002B558((const __CFURL *)v7, (uint64_t)&stru_1000777C0);
    }
    else
    {
      v17 = sub_100011628("SecError");
      v18 = objc_claimAutoreleasedReturnValue(v17);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v23 = a3;
        v24 = 2112;
        v25 = v12;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "failed to write %{public}s: %@", buf, 0x16u);
      }

    }
  }

}

void sub_1000409BC(id a1, const char *a2)
{
  remove((const std::__fs::filesystem::path *)a2, (std::error_code *)a2);
}

void sub_1000409C4(id a1)
{
  if (qword_100082C28 != -1)
    dispatch_once(&qword_100082C28, &stru_1000767D0);
}

void sub_1000409EC(int a1, const void *a2, const void *a3, void *a4)
{
  id v7;
  void *v8;
  void *v9;
  NSObject *v10;
  id v11;
  _QWORD block[4];
  id v13;
  const void *v14;
  const void *v15;
  int v16;
  __CFString *v17;

  v7 = a4;
  if (sub_100015138() && (sub_100015138() & 1) != 0)
  {
    v8 = _Block_copy(v7);
    v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
    if (a2)
      CFRetain(a2);
    if (a3)
      CFRetain(a3);
    if (qword_100082EF0 != -1)
      dispatch_once(&qword_100082EF0, &stru_100079548);
    v10 = (id)qword_100082EE8;
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100040B30;
    block[3] = &unk_100077730;
    v16 = a1;
    v14 = a2;
    v15 = a3;
    v13 = v9;
    v11 = v9;
    dispatch_async(v10, block);

  }
  else
  {
    v17 = 0;
    sub_100012C88(-4, &v17, CFSTR("Trust settings not implemented in this environment"));
    (*((void (**)(id, _QWORD, __CFString *))v7 + 2))(v7, 0, v17);
  }

}

void sub_100040B30(uint64_t a1)
{
  void (**v2)(id, uint64_t, _QWORD);
  const void *v3;
  const void *v4;

  v2 = (void (**)(id, uint64_t, _QWORD))objc_retainBlock(*(id *)(a1 + 32));
  v2[2](v2, 1, 0);
  _Block_release(v2);

  v3 = *(const void **)(a1 + 48);
  if (v3)
    CFRelease(v3);
  v4 = *(const void **)(a1 + 40);
  if (v4)
    CFRelease(v4);
}

uint64_t sub_100040B94(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  NSObject *v8;
  void *v9;
  uint64_t v10;
  _QWORD v12[9];
  int v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t (*v21)(uint64_t, uint64_t);
  void (*v22)(uint64_t);
  dispatch_semaphore_t v23;

  v18 = 0;
  v19 = &v18;
  v20 = 0x3032000000;
  v21 = sub_100040CD8;
  v22 = sub_100040CE8;
  v23 = (dispatch_semaphore_t)0xAAAAAAAAAAAAAAAALL;
  v23 = dispatch_semaphore_create(0);
  v14 = 0;
  v15 = &v14;
  v16 = 0x2020000000;
  v17 = 0;
  v8 = dispatch_queue_create("truststore.write.recursive", 0);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_100040CF0;
  v12[3] = &unk_100077780;
  v13 = a1;
  v12[6] = a2;
  v12[7] = a3;
  v12[8] = a4;
  v12[4] = &v14;
  v12[5] = &v18;
  dispatch_async(v8, v12);
  dispatch_semaphore_wait((dispatch_semaphore_t)v19[5], 0xFFFFFFFFFFFFFFFFLL);
  v9 = (void *)v19[5];
  v19[5] = 0;

  v10 = *((unsigned __int8 *)v15 + 24);
  _Block_object_dispose(&v14, 8);
  _Block_object_dispose(&v18, 8);

  return v10;
}

uint64_t sub_100040CD8(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_100040CE8(uint64_t a1)
{

}

void sub_100040CF0(uint64_t a1)
{
  int v1;
  const void *v2;
  const void *v3;
  _QWORD v4[4];
  __int128 v5;
  uint64_t v6;

  v1 = *(_DWORD *)(a1 + 72);
  v2 = *(const void **)(a1 + 48);
  v3 = *(const void **)(a1 + 56);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_100040D58;
  v4[3] = &unk_100077758;
  v6 = *(_QWORD *)(a1 + 64);
  v5 = *(_OWORD *)(a1 + 32);
  sub_1000409EC(v1, v2, v3, v4);
}

intptr_t sub_100040D58(_QWORD *a1, char a2, CFTypeRef cf)
{
  _QWORD *v4;

  *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = a2;
  if ((a2 & 1) == 0)
  {
    v4 = (_QWORD *)a1[6];
    if (v4)
    {
      *v4 = cf;
      if (cf)
        CFRetain(cf);
    }
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(_QWORD *)(a1[5] + 8) + 40));
}

BOOL sub_100040DA8(uint64_t a1, uint64_t a2)
{
  int v4;
  _BOOL8 result;
  _QWORD v6[5];
  unint64_t v7[3];

  memset(v7, 170, sizeof(v7));
  v4 = DERDecodeItem(a1, v7);
  result = 0;
  if (!v4 && v7[0] == 0x2000000000000010)
  {
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000;
    v6[2] = sub_100040E48;
    v6[3] = &unk_1000778B0;
    v6[4] = a2;
    return DERDecodeSequenceWithBlock(a1, (uint64_t)v6) == 0;
  }
  return result;
}

uint64_t sub_100040E48(uint64_t a1, _QWORD *a2)
{
  __int128 v3;
  uint64_t result;
  uint64_t v5;
  unint64_t v6[3];
  _OWORD v7[2];
  __int128 v8;

  if (*a2 != 0x2000000000000010)
    return 2;
  *(_QWORD *)&v3 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v7[1] = v3;
  v8 = v3;
  v7[0] = v3;
  result = DERParseSequenceContentToObject(a2 + 1, (unsigned __int16)DERNumExtensionItemSpecs, (uint64_t)&DERExtensionItemSpecs, (unint64_t)v7, 0x30uLL, 0x30uLL);
  if ((_DWORD)result)
    return result;
  result = DEROidCompare((uint64_t)v7, (uint64_t)&oidGoogleOCSPSignedCertificateTimestamp);
  if (!(_DWORD)result)
    return result;
  memset(v6, 170, sizeof(v6));
  result = DERDecodeItem((uint64_t)&v8, v6);
  if ((_DWORD)result)
    return result;
  if (v6[0] != 4)
    return 2;
  v5 = *(_QWORD *)(a1 + 32);
  if (v5)
  {
    if (!*(_QWORD *)(v5 + 40))
      *(_QWORD *)(*(_QWORD *)(a1 + 32) + 40) = sub_10002A03C((unsigned __int16 *)v6[1], v6[2]);
  }
  return 0;
}

uint64_t sub_100040F24(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_100041594(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100041974(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10004212C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  uint64_t v11;
  va_list va;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v11 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 112), 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000429E0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_1000429F0(uint64_t a1)
{

}

void sub_1000429F8(id a1)
{
  NSObject *v1;
  void *v2;
  NSObject *v3;
  _QWORD *context;

  v1 = sub_10002B070(0, "pinning logging charles", 300);
  v2 = (void *)qword_100082DC0;
  qword_100082DC0 = (uint64_t)v1;

  v3 = qword_100082DC0;
  context = dispatch_get_context((dispatch_object_t)qword_100082DC0);
  context[2] = _Block_copy(&stru_100077B60);
  dispatch_activate(v3);
}

_QWORD *sub_100042A58(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  void *v4;

  if (!*(_QWORD *)(result[4] + 16))
  {
    v1 = result;
    v2 = objc_claimAutoreleasedReturnValue(+[SecPinningDb pinningDbPath](SecPinningDb, "pinningDbPath"));
    v3 = v1[4];
    v4 = *(void **)(v3 + 32);
    *(_QWORD *)(v3 + 32) = v2;

    result = objc_msgSend((id)v1[4], "createAtPath");
    *(_QWORD *)(v1[4] + 16) = result;
  }
  return result;
}

BOOL sub_100042AB0(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5, uint64_t a6)
{
  _BOOL8 v10;
  uint64_t v11;
  NSObject *v12;
  _QWORD block[8];
  char v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  char v19;

  if (qword_100082C28 != -1)
    dispatch_once(&qword_100082C28, &stru_1000767D0);
  v10 = 1;
  if (byte_100082C20 == 1)
  {
    dispatch_assert_queue_not_V2(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 32) + 24));
    v16 = 0;
    v17 = &v16;
    v18 = 0x2020000000;
    v19 = 1;
    v11 = *(_QWORD *)(a1 + 32);
    v12 = *(NSObject **)(v11 + 24);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100042BB8;
    block[3] = &unk_100077AD0;
    block[4] = v11;
    block[5] = &v16;
    block[6] = a3;
    block[7] = a6;
    v15 = a4;
    dispatch_sync(v12, block);
    v10 = *((_BYTE *)v17 + 24) != 0;
    _Block_object_dispose(&v16, 8);
  }
  return v10;
}

void sub_100042BB8(uint64_t a1)
{
  id v2;
  void *v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  char isKindOfClass;
  _QWORD *v8;
  char *v9;
  const void *v10;
  NSObject *v11;
  const void *v12;
  NSObject *v13;
  int v14;
  const void *v15;
  NSObject *v16;
  const void *v17;
  NSObject *v18;
  void *v19;
  void *v20;
  uint64_t v21;
  const void *v22;
  NSObject *v23;
  unsigned __int8 v24;
  uint64_t v25;
  unsigned __int8 v26;
  const void *v27;
  NSObject *v28;
  const char *v29;
  _QWORD *v30;
  void *v31;
  uint64_t *v32;
  uint64_t v33;
  _UNKNOWN **v34;
  void *v35;
  const __CFString *v36;
  const __CFString *v37;
  _QWORD v38[2];
  uint8_t buf[4];
  const char *v40;
  __int16 v41;
  _QWORD *v42;

  v2 = objc_msgSend(*(id *)(a1 + 32), "copySystemPinningList");
  v3 = v2;
  if (v2)
  {
    v4 = objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "objectAtIndex:", 0));
    if (v4)
    {
      v5 = (void *)v4;
      v6 = objc_opt_class(NSNumber);
      isKindOfClass = objc_opt_isKindOfClass(v5, v6);

      if ((isKindOfClass & 1) != 0)
      {
        v8 = (_QWORD *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectAtIndex:", 0));
        v9 = (char *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "getContentVersion:error:", *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56)));
        v10 = sub_100011628("pinningDb");
        v11 = objc_claimAutoreleasedReturnValue(v10);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          v40 = v9;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Opening db with version %@", buf, 0xCu);
        }

        if (v9 && objc_msgSend(v8, "compare:", v9) != (id)1)
        {
          v14 = 0;
        }
        else
        {
          v12 = sub_100011628("pinningDb");
          v13 = objc_claimAutoreleasedReturnValue(v12);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138412546;
            v40 = v9;
            v41 = 2112;
            v42 = v8;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Updating pinning database content from version %@ to version %@", buf, 0x16u);
          }

          v14 = 1;
        }
        v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "getSchemaVersion:error:", *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56)));
        v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", 3));
        if (v19 && (objc_msgSend(v19, "isEqualToNumber:", v20) & 1) != 0)
        {
          if (!v14)
          {
LABEL_29:
            if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24))
            {
              v27 = sub_100011628("SecError");
              v28 = objc_claimAutoreleasedReturnValue(v27);
              if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
              {
                v29 = "Create";
                if (!*(_BYTE *)(a1 + 64))
                  v29 = "Open";
                v30 = *(_QWORD **)(a1 + 56);
                if (v30)
                  v30 = (_QWORD *)*v30;
                *(_DWORD *)buf = 136315394;
                v40 = v29;
                v41 = 2112;
                v42 = v30;
                _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "SecPinningDb: %s failed: %@", buf, 0x16u);
              }

              v31 = (void *)objc_claimAutoreleasedReturnValue(+[TrustAnalytics logger](TrustAnalytics, "logger"));
              v32 = *(uint64_t **)(a1 + 56);
              if (v32)
                v33 = *v32;
              else
                v33 = 0;
              v36 = CFSTR("database");
              v37 = CFSTR("operation");
              if (*(_BYTE *)(a1 + 64))
                v34 = &off_10007FDD0;
              else
                v34 = &off_10007FE00;
              v38[0] = &off_10007FDD0;
              v38[1] = v34;
              v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v38, &v36, 2));
              objc_msgSend(v31, "logHardError:withEventName:withAttributes:", v33, CFSTR("DatabaseEvent"), v35, v36, v37);

            }
            goto LABEL_44;
          }
          v21 = 0;
        }
        else
        {
          v22 = sub_100011628("pinningDb");
          v23 = objc_claimAutoreleasedReturnValue(v22);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138412546;
            v40 = (const char *)v19;
            v41 = 2112;
            v42 = v20;
            _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Updating pinning database schema from version %@ to version %@", buf, 0x16u);
          }

          v21 = 1;
        }
        v24 = objc_msgSend(*(id *)(a1 + 32), "updateDb:error:pinningList:updateSchema:updateContent:", *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), v3, v21, 1);
        v25 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
        if (*(_BYTE *)(v25 + 24))
          v26 = v24;
        else
          v26 = 0;
        *(_BYTE *)(v25 + 24) = v26;
        sub_100033AA8();
        goto LABEL_29;
      }
    }
    v15 = sub_100011628("SecError");
    v16 = objc_claimAutoreleasedReturnValue(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "SecPinningDb: pinning plist in wrong format", buf, 2u);
    }

  }
  else
  {
    v17 = sub_100011628("SecError");
    v18 = objc_claimAutoreleasedReturnValue(v17);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "SecPinningDb: failed to find pinning plist in bundle", buf, 2u);
    }

    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
  }
LABEL_44:

}

void sub_10004304C(uint64_t a1, _BYTE *a2)
{
  unsigned __int8 v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int8 v7;
  unsigned __int8 v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 v11;
  unsigned __int8 v12;
  uint64_t v13;
  unsigned __int8 v14;
  unsigned __int8 v15;
  uint64_t v16;
  unsigned __int8 v17;
  void *v18;
  unsigned __int8 v19;
  uint64_t v20;
  uint64_t v21;
  unsigned __int8 v22;
  unsigned __int8 v23;
  uint64_t v24;
  unsigned __int8 v25;

  if (*(_BYTE *)(a1 + 72))
  {
    v4 = objc_msgSend(*(id *)(a1 + 32), "createOrAlterAdminTable:error:", *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64));
    v5 = *(_QWORD *)(a1 + 56);
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
    if (*(_BYTE *)(v6 + 24))
      v7 = v4;
    else
      v7 = 0;
    *(_BYTE *)(v6 + 24) = v7;
    v8 = objc_msgSend(*(id *)(a1 + 32), "createOrAlterRulesTable:error:", v5, *(_QWORD *)(a1 + 64));
    v9 = *(_QWORD *)(a1 + 56);
    v10 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
    if (*(_BYTE *)(v10 + 24))
      v11 = v8;
    else
      v11 = 0;
    *(_BYTE *)(v10 + 24) = v11;
    v12 = objc_msgSend(*(id *)(a1 + 32), "setSchemaVersion:error:", v9, *(_QWORD *)(a1 + 64));
    v13 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
    if (*(_BYTE *)(v13 + 24))
      v14 = v12;
    else
      v14 = 0;
    *(_BYTE *)(v13 + 24) = v14;
  }
  if (*(_BYTE *)(a1 + 73))
  {
    v15 = objc_msgSend(*(id *)(a1 + 32), "removeAllRulesFromDb:error:", *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64));
    v16 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
    if (*(_BYTE *)(v16 + 24))
      v17 = v15;
    else
      v17 = 0;
    *(_BYTE *)(v16 + 24) = v17;
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "objectAtIndex:", 0));
    v19 = objc_msgSend(*(id *)(a1 + 32), "populateDbFromBundle:dbConnection:error:", *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64));
    v20 = *(_QWORD *)(a1 + 56);
    v21 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
    if (*(_BYTE *)(v21 + 24))
      v22 = v19;
    else
      v22 = 0;
    *(_BYTE *)(v21 + 24) = v22;
    v23 = objc_msgSend(*(id *)(a1 + 32), "setContentVersion:dbConnection:error:", v18, v20, *(_QWORD *)(a1 + 64));
    v24 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
    if (*(_BYTE *)(v24 + 24))
      v25 = v23;
    else
      v25 = 0;
    *(_BYTE *)(v24 + 24) = v25;

  }
  *a2 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
}

id sub_100043188(uint64_t a1)
{
  __int128 v2;
  __int128 v3;
  uint64_t v4;
  __CFString **v5;
  char v6;
  uint64_t v7;
  char v8;
  _QWORD v10[4];
  __int128 v11;
  __int128 v12;

  v10[0] = _NSConcreteStackBlock;
  v2 = *(_OWORD *)(a1 + 32);
  v3 = *(_OWORD *)(a1 + 48);
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16);
  v5 = (__CFString **)(*(_QWORD *)(v3 + 8) + 24);
  v10[1] = 3221225472;
  v10[2] = sub_10004321C;
  v10[3] = &unk_100077A58;
  v11 = v2;
  v12 = v3;
  v6 = sub_100029AF0(v4, v5, (uint64_t)v10);
  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  if (*(_BYTE *)(v7 + 24))
    v8 = v6;
  else
    v8 = 0;
  *(_BYTE *)(v7 + 24) = v8;
  return objc_msgSend(*(id *)(a1 + 32), "clearCache");
}

id sub_10004321C(uint64_t a1, uint64_t a2)
{
  id result;
  uint64_t v4;
  char v5;

  result = objc_msgSend(*(id *)(a1 + 32), "updateDb:error:pinningList:updateSchema:updateContent:", a2, *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 40), 0, 1);
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  if (*(_BYTE *)(v4 + 24))
    v5 = (char)result;
  else
    v5 = 0;
  *(_BYTE *)(v4 + 24) = v5;
  return result;
}

uint64_t sub_100043278(uint64_t a1, sqlite3_stmt *a2)
{
  char v3;
  uint64_t v4;
  char v5;

  v3 = sub_100019D18(*(_QWORD *)(a1 + 40), a2, *(CFTypeRef **)(a1 + 48), 0);
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v4 + 24))
    v5 = v3;
  else
    v5 = 0;
  *(_BYTE *)(v4 + 24) = v5;
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

void sub_1000432C8(uint64_t a1, void *a2, uint64_t a3)
{
  id v5;
  void *v6;
  uint64_t v7;
  id v8;
  void *v9;
  uint64_t v10;
  _UNKNOWN **v11;
  uint64_t v12;
  uint64_t v13;
  const void *v14;
  NSObject *v15;
  const void *v16;
  NSObject *v17;
  _QWORD v18[5];
  _UNKNOWN **v19;
  uint8_t *v20;
  uint64_t v21;
  uint64_t *v22;
  __int128 v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t (*v27)(uint64_t, uint64_t);
  void (*v28)(uint64_t);
  id v29;
  uint8_t buf[8];
  uint8_t *v31;
  uint64_t v32;
  uint64_t (*v33)(uint64_t, uint64_t);
  void (*v34)(uint64_t);
  id v35;
  uint8_t v36[4];
  uint64_t v37;

  v5 = a2;
  v6 = v5;
  if (a3)
  {
    if (v5 && (v7 = objc_opt_class(NSDictionary), (objc_opt_isKindOfClass(v6, v7) & 1) != 0))
    {
      v8 = v6;
      *(_QWORD *)buf = 0;
      v31 = buf;
      v32 = 0x3032000000;
      v33 = sub_1000429E0;
      v34 = sub_1000429F0;
      v35 = (id)0xAAAAAAAAAAAAAAAALL;
      v35 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "objectForKey:", CFSTR("policyName")));
      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "objectForKey:", CFSTR("domains")));
      v24 = 0;
      v25 = &v24;
      v26 = 0x3032000000;
      v27 = sub_1000429E0;
      v28 = sub_1000429F0;
      v29 = (id)0xAAAAAAAAAAAAAAAALL;
      v29 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "objectForKey:", CFSTR("rules")));
      v10 = objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "objectForKey:", CFSTR("transparentConnection")));
      if (v10)
        v11 = (_UNKNOWN **)v10;
      else
        v11 = &off_10007FDB8;
      if (*((_QWORD *)v31 + 5) && v9 && v25[5])
      {
        v18[0] = _NSConcreteStackBlock;
        v18[1] = 3221225472;
        v18[2] = sub_1000435DC;
        v18[3] = &unk_1000779E0;
        v13 = *(_QWORD *)(a1 + 32);
        v12 = *(_QWORD *)(a1 + 40);
        v20 = buf;
        v21 = v12;
        v18[4] = v13;
        v22 = &v24;
        v19 = v11;
        v23 = *(_OWORD *)(a1 + 48);
        objc_msgSend(v9, "enumerateObjectsUsingBlock:", v18);

      }
      else
      {
        v16 = sub_100011628("SecError");
        v17 = objc_claimAutoreleasedReturnValue(v16);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v36 = 134217984;
          v37 = a3;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "SecPinningDb: failed to get required fields from rule entry %lu", v36, 0xCu);
        }

        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
      }

      _Block_object_dispose(&v24, 8);
      _Block_object_dispose(buf, 8);

    }
    else
    {
      v14 = sub_100011628("SecError");
      v15 = objc_claimAutoreleasedReturnValue(v14);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "SecPinningDb: rule entry in pinning plist is wrong class", buf, 2u);
      }

      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
    }
  }

}

void sub_1000435A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

void sub_1000435DC(uint64_t a1, void *a2, uint64_t a3)
{
  id v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  void *v9;
  unsigned __int8 v10;
  uint64_t v11;
  unsigned __int8 v12;
  const void *v13;
  NSObject *v14;
  uint64_t v15;
  const void *v16;
  NSObject *v17;
  uint64_t v18;
  uint8_t buf[4];
  uint64_t v20;
  __int16 v21;
  uint64_t v22;

  v5 = a2;
  if (v5 && (v6 = objc_opt_class(NSDictionary), (objc_opt_isKindOfClass(v5, v6) & 1) != 0))
  {
    v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKey:", CFSTR("suffix")));
    v8 = objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKey:", CFSTR("labelRegex")));
    v9 = (void *)v8;
    if (v7 && v8)
    {
      v10 = objc_msgSend(*(id *)(a1 + 32), "insertRuleWithName:domainSuffix:labelRegex:policies:transparentConnection:dbConnection:error:", *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40), v7, v8, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 40), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 80));
      v11 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
      if (*(_BYTE *)(v11 + 24))
        v12 = v10;
      else
        v12 = 0;
      *(_BYTE *)(v11 + 24) = v12;
    }
    else
    {
      v16 = sub_100011628("SecError");
      v17 = objc_claimAutoreleasedReturnValue(v16);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        v18 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40);
        *(_DWORD *)buf = 134218242;
        v20 = a3;
        v21 = 2112;
        v22 = v18;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "SecPinningDb: failed to get required fields for entry %lu for %@", buf, 0x16u);
      }

      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = 0;
    }

  }
  else
  {
    v13 = sub_100011628("SecError");
    v14 = objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      v15 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40);
      *(_DWORD *)buf = 134218242;
      v20 = a3;
      v21 = 2112;
      v22 = v15;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "SecPinningDb: domain entry %lu for %@ in pinning rule is wrong class", buf, 0x16u);
    }

    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = 0;
  }

}

uint64_t sub_1000437F4(uint64_t a1, sqlite3_stmt *a2)
{
  BOOL v4;
  uint64_t v5;
  BOOL v6;
  BOOL v7;
  uint64_t v8;
  BOOL v9;
  BOOL v10;
  uint64_t v11;
  BOOL v12;
  void *v13;
  const void *v14;
  NSObject *v15;
  id v16;
  BOOL v17;
  uint64_t v18;
  BOOL v19;
  int v20;
  CFTypeRef *v21;
  uint64_t v22;
  BOOL v23;
  CFTypeRef *v24;
  uint64_t v25;
  BOOL v26;
  char v27;
  uint64_t v28;
  char v29;
  uint64_t v30;
  uint8_t buf[16];

  v4 = sub_10001A5DC(a2, 1, (const char *)objc_msgSend(objc_retainAutorelease(*(id *)(a1 + 32)), "UTF8String"), (unint64_t)objc_msgSend(*(id *)(a1 + 32), "length"), *(CFTypeRef **)(a1 + 80));
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8);
  if (*(_BYTE *)(v5 + 24))
    v6 = v4;
  else
    v6 = 0;
  *(_BYTE *)(v5 + 24) = v6;
  v7 = sub_10001A5DC(a2, 2, (const char *)objc_msgSend(objc_retainAutorelease(*(id *)(a1 + 40)), "UTF8String"), (unint64_t)objc_msgSend(*(id *)(a1 + 40), "length"), *(CFTypeRef **)(a1 + 80));
  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8);
  if (*(_BYTE *)(v8 + 24))
    v9 = v7;
  else
    v9 = 0;
  *(_BYTE *)(v8 + 24) = v9;
  v10 = sub_10001A5DC(a2, 3, (const char *)objc_msgSend(objc_retainAutorelease(*(id *)(a1 + 48)), "UTF8String"), (unint64_t)objc_msgSend(*(id *)(a1 + 48), "length"), *(CFTypeRef **)(a1 + 80));
  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8);
  if (*(_BYTE *)(v11 + 24))
    v12 = v10;
  else
    v12 = 0;
  *(_BYTE *)(v11 + 24) = v12;
  v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSPropertyListSerialization dataWithPropertyList:format:options:error:](NSPropertyListSerialization, "dataWithPropertyList:format:options:error:", *(_QWORD *)(a1 + 56), 100, 0, 0));
  if (!v13)
  {
    v14 = sub_100011628("SecError");
    v15 = objc_claimAutoreleasedReturnValue(v14);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "SecPinningDb: failed to serialize policies", buf, 2u);
    }

    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24) = 0;
  }
  v16 = objc_retainAutorelease(v13);
  v17 = sub_10001A8F8(a2, 4, objc_msgSend(v16, "bytes"), (unint64_t)objc_msgSend(v16, "length"), *(CFTypeRef **)(a1 + 80));
  v18 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8);
  if (*(_BYTE *)(v18 + 24))
    v19 = v17;
  else
    v19 = 0;
  *(_BYTE *)(v18 + 24) = v19;
  v20 = objc_msgSend(*(id *)(a1 + 64), "intValue");
  v21 = *(CFTypeRef **)(a1 + 80);
  v22 = sqlite3_bind_int(a2, 5, v20);
  v23 = sub_10001A970(v22, a2, v21, CFSTR("bind_int[%d]"), 5);
  v24 = *(CFTypeRef **)(a1 + 80);
  v25 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8);
  if (*(_BYTE *)(v25 + 24))
    v26 = v23;
  else
    v26 = 0;
  *(_BYTE *)(v25 + 24) = v26;
  v27 = sub_100019D18(*(_QWORD *)(a1 + 88), a2, v24, 0);
  v28 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8);
  if (*(_BYTE *)(v28 + 24))
    v29 = v27;
  else
    v29 = 0;
  *(_BYTE *)(v28 + 24) = v29;
  v30 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24);

  return v30;
}

void sub_100043A5C(uint64_t a1, uint64_t a2)
{
  void *v3;
  const void *v4;
  NSObject *v5;
  uint64_t v6;
  const void *v7;
  uint64_t v8;
  int v9;
  void *v10;
  __int16 v11;
  uint64_t v12;

  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "getContentVersion:error:", a2, *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24));
  if (v3 && objc_msgSend(*(id *)(a1 + 40), "compare:", v3) != (id)1)
  {
    v7 = sub_100011628("pinningDb");
    v5 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      v8 = *(_QWORD *)(a1 + 40);
      v9 = 138412546;
      v10 = v3;
      v11 = 2112;
      v12 = v8;
      _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Pinning database should not update from version %@ to version %@", (uint8_t *)&v9, 0x16u);
    }
  }
  else
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = 1;
    v4 = sub_100011628("pinningDb");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_QWORD *)(a1 + 40);
      v9 = 138412546;
      v10 = v3;
      v11 = 2112;
      v12 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Pinning database should update from version %@ to version %@", (uint8_t *)&v9, 0x16u);
    }
  }

}

uint64_t sub_100043BD4(uint64_t a1, sqlite3_stmt *a2)
{
  CFTypeRef *v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  BOOL v8;
  id v9;
  CFTypeRef *v10;
  uint64_t v11;
  BOOL v12;
  CFTypeRef *v13;
  uint64_t v14;
  BOOL v15;
  char v16;
  uint64_t v17;
  char v18;

  v4 = *(CFTypeRef **)(a1 + 48);
  v5 = sqlite3_bind_text(a2, 1, "version", 7, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
  v6 = sub_10001A970(v5, a2, v4, CFSTR("bind_text[%d]"), 1);
  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  if (*(_BYTE *)(v7 + 24))
    v8 = v6;
  else
    v8 = 0;
  *(_BYTE *)(v7 + 24) = v8;
  v9 = objc_msgSend(*(id *)(a1 + 32), "longLongValue");
  v10 = *(CFTypeRef **)(a1 + 48);
  v11 = sqlite3_bind_int64(a2, 2, (sqlite3_int64)v9);
  v12 = sub_10001A970(v11, a2, v10, CFSTR("bind_int64[%d]"), 2);
  v13 = *(CFTypeRef **)(a1 + 48);
  v14 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  if (*(_BYTE *)(v14 + 24))
    v15 = v12;
  else
    v15 = 0;
  *(_BYTE *)(v14 + 24) = v15;
  v16 = sub_100019D18(*(_QWORD *)(a1 + 56), a2, v13, 0);
  v17 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  if (*(_BYTE *)(v17 + 24))
    v18 = v16;
  else
    v18 = 0;
  *(_BYTE *)(v17 + 24) = v18;
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
}

uint64_t sub_100043CDC(_QWORD *a1, sqlite3_stmt *a2)
{
  uint64_t v3;
  CFTypeRef *v4;
  _QWORD *v5;
  char v6;
  uint64_t v7;
  char v8;
  _QWORD v10[6];

  v5 = a1 + 6;
  v3 = a1[6];
  v4 = (CFTypeRef *)v5[1];
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_100043D64;
  v10[3] = &unk_100077918;
  v10[4] = a1[5];
  v10[5] = a2;
  v6 = sub_100019D18(v3, a2, v4, (uint64_t)v10);
  v7 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v7 + 24))
    v8 = v6;
  else
    v8 = 0;
  *(_BYTE *)(v7 + 24) = v8;
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

void sub_100043D64(uint64_t a1)
{
  NSNumber *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;

  v2 = +[NSNumber numberWithLongLong:](NSNumber, "numberWithLongLong:", sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0));
  v3 = objc_claimAutoreleasedReturnValue(v2);
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v5 = *(void **)(v4 + 40);
  *(_QWORD *)(v4 + 40) = v3;

}

uint64_t sub_100043DB0(_QWORD *a1, sqlite3_stmt *a2)
{
  uint64_t v3;
  CFTypeRef *v4;
  _QWORD *v5;
  char v6;
  uint64_t v7;
  char v8;
  _QWORD v10[6];

  v5 = a1 + 6;
  v3 = a1[6];
  v4 = (CFTypeRef *)v5[1];
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_100043E38;
  v10[3] = &unk_100077918;
  v10[4] = a1[5];
  v10[5] = a2;
  v6 = sub_100019D18(v3, a2, v4, (uint64_t)v10);
  v7 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v7 + 24))
    v8 = v6;
  else
    v8 = 0;
  *(_BYTE *)(v7 + 24) = v8;
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

void sub_100043E38(uint64_t a1)
{
  NSNumber *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;

  v2 = +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", sqlite3_column_int(*(sqlite3_stmt **)(a1 + 40), 0));
  v3 = objc_claimAutoreleasedReturnValue(v2);
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v5 = *(void **)(v4 + 40);
  *(_QWORD *)(v4 + 40) = v3;

}

void sub_100043EA0(id a1)
{
  void *v1;
  SecPinningDb *v2;
  void *v3;
  id v4;
  const void *v5;
  NSObject *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  void *v10;
  const void *v11;
  _QWORD v12[5];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD v17[2];
  _QWORD v18[2];
  uint8_t buf[4];
  uint64_t v20;

  if (sub_100015138())
  {
    v1 = objc_autoreleasePoolPush();
    v2 = objc_alloc_init(SecPinningDb);
    v3 = (void *)qword_100082DC8;
    qword_100082DC8 = (uint64_t)v2;

    v13 = 0;
    v14 = &v13;
    v15 = 0x2020000000;
    v16 = 0;
    v4 = objc_msgSend((id)qword_100082DC8, "db");
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472;
    v12[2] = sub_1000440C0;
    v12[3] = &unk_100077C98;
    v12[4] = &v13;
    if (!sub_1000193B4((uint64_t)v4, (uint64_t)(v14 + 3), (uint64_t)v12) || v14[3])
    {
      v5 = sub_100011628("SecError");
      v6 = objc_claimAutoreleasedReturnValue(v5);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        v7 = v14[3];
        *(_DWORD *)buf = 138412290;
        v20 = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "SecPinningDb: unable to initialize db: %@", buf, 0xCu);
      }

      v8 = (void *)objc_claimAutoreleasedReturnValue(+[TrustAnalytics logger](TrustAnalytics, "logger"));
      v9 = v14[3];
      v17[0] = CFSTR("database");
      v17[1] = CFSTR("operation");
      v18[0] = &off_10007FDD0;
      v18[1] = &off_10007FE18;
      v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v18, v17, 2));
      objc_msgSend(v8, "logHardError:withEventName:withAttributes:", v9, CFSTR("DatabaseEvent"), v10);

      v11 = (const void *)v14[3];
      if (v11)
      {
        v14[3] = 0;
        CFRelease(v11);
      }
    }
    _Block_object_dispose(&v13, 8);
    objc_autoreleasePoolPop(v1);
  }
}

void sub_10004409C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000440C0(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;
  const void *v6;
  NSObject *v7;
  int v8;
  void *v9;
  __int16 v10;
  void *v11;

  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)qword_100082DC8, "getContentVersion:error:", a2, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)qword_100082DC8, "getSchemaVersion:error:", a2, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  v6 = sub_100011628("pinningDb");
  v7 = objc_claimAutoreleasedReturnValue(v6);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    v8 = 138412546;
    v9 = v5;
    v10 = 2112;
    v11 = v4;
    _os_log_debug_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "Database Schema: %@ Content: %@", (uint8_t *)&v8, 0x16u);
  }

}

void sub_1000441D0(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  void *v5;

  v3 = objc_claimAutoreleasedReturnValue(objc_msgSend((id)qword_100082DC8, "getContentVersion:error:", a2, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v5 = *(void **)(v4 + 40);
  *(_QWORD *)(v4 + 40) = v3;

}

uint64_t sub_10004421C(uint64_t a1, const void *a2)
{
  CFDictionaryRef *ValueAtIndex;
  uint64_t result;
  uint64_t v6;
  CFTypeID v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _BOOL8 v14;

  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (!result)
    return result;
  v6 = result;
  v7 = CFGetTypeID((CFTypeRef)result);
  result = CFStringGetTypeID();
  if (v7 != result)
    return result;
  v8 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v8)
  {
    if (*(uint64_t *)(v8 + 16) >= 1 && (v9 = *(_QWORD *)(v8 + 136)) != 0)
      v10 = *(_QWORD *)(v9 + 16);
    else
      v10 = 0;
    v11 = *(_QWORD *)(v8 + 16);
    if (v11 >= 1)
    {
      v12 = *(_QWORD *)(v8 + 8 * v11 + 128);
      if (v12)
      {
        v13 = *(_QWORD *)(v12 + 16);
        goto LABEL_13;
      }
    }
  }
  else
  {
    v10 = 0;
  }
  v13 = 0;
LABEL_13:
  v14 = SecCertificateNotValidBefore(v10) >= 670464000.0
     && (off_1000827E0((uint64_t)off_1000827D0, v13) || sub_100045A18(v13, CFSTR("TestSystemRoot")));
  result = SecPolicyCheckCertEmailSAN(v10, v6, v14);
  if ((result & 1) == 0)
    return sub_10000E2C8(a1, a2, 0, kCFBooleanFalse, 0, 0);
  return result;
}

uint64_t sub_10004436C(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  CFDictionaryRef *ValueAtIndex;
  uint64_t result;
  uint64_t v9;
  CFTypeID v10;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v4 && *(uint64_t *)(v4 + 16) >= 1 && (v5 = *(_QWORD *)(v4 + 136)) != 0)
    v6 = *(_QWORD *)(v5 + 16);
  else
    v6 = 0;
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (result)
  {
    v9 = result;
    v10 = CFGetTypeID((CFTypeRef)result);
    result = CFStringGetTypeID();
    if (v10 == result)
    {
      result = SecPolicyCheckCertSubjectCommonName(v6, v9);
      if ((result & 1) == 0)
        return sub_10000E2C8(a1, a2, 0, kCFBooleanFalse, 0, 0);
    }
  }
  return result;
}

uint64_t sub_100044440(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  CFDictionaryRef *ValueAtIndex;
  uint64_t result;
  uint64_t v9;
  CFTypeID v10;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v4 && *(uint64_t *)(v4 + 16) >= 1 && (v5 = *(_QWORD *)(v4 + 136)) != 0)
    v6 = *(_QWORD *)(v5 + 16);
  else
    v6 = 0;
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (result)
  {
    v9 = result;
    v10 = CFGetTypeID((CFTypeRef)result);
    result = CFStringGetTypeID();
    if (v10 == result)
    {
      result = SecPolicyCheckCertSubjectCommonNamePrefix(v6, v9);
      if ((result & 1) == 0)
        return sub_10000E2C8(a1, a2, 0, kCFBooleanFalse, 0, 0);
    }
  }
  return result;
}

uint64_t sub_100044514(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  CFDictionaryRef *ValueAtIndex;
  uint64_t result;
  uint64_t v9;
  CFTypeID v10;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v4 && *(uint64_t *)(v4 + 16) >= 1 && (v5 = *(_QWORD *)(v4 + 136)) != 0)
    v6 = *(_QWORD *)(v5 + 16);
  else
    v6 = 0;
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (result)
  {
    v9 = result;
    v10 = CFGetTypeID((CFTypeRef)result);
    result = CFStringGetTypeID();
    if (v10 == result)
    {
      result = SecPolicyCheckCertSubjectOrganizationalUnit(v6, v9);
      if ((result & 1) == 0)
        return sub_10000E2C8(a1, a2, 0, kCFBooleanFalse, 0, 0);
    }
  }
  return result;
}

uint64_t sub_1000445E8(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  CFDictionaryRef *ValueAtIndex;
  uint64_t result;
  uint64_t v9;
  CFTypeID v10;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v4 && *(uint64_t *)(v4 + 16) >= 1 && (v5 = *(_QWORD *)(v4 + 136)) != 0)
    v6 = *(_QWORD *)(v5 + 16);
  else
    v6 = 0;
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (result)
  {
    v9 = result;
    v10 = CFGetTypeID((CFTypeRef)result);
    result = CFDateGetTypeID();
    if (v10 == result)
    {
      result = SecPolicyCheckCertNotValidBefore(v6, v9);
      if ((result & 1) == 0)
        return sub_10000E2C8(a1, a2, 0, kCFBooleanFalse, 0, 0);
    }
  }
  return result;
}

uint64_t sub_1000446BC(uint64_t a1, const void *a2)
{
  CFDictionaryRef *ValueAtIndex;
  uint64_t result;
  uint64_t v6;
  CFTypeID v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (result)
  {
    v6 = result;
    v7 = CFGetTypeID((CFTypeRef)result);
    result = CFArrayGetTypeID();
    if (v7 == result)
    {
      v8 = *(_QWORD *)(*(_QWORD *)a1 + 200);
      if (v8 && *(uint64_t *)(v8 + 16) >= 1 && (v9 = *(_QWORD *)(v8 + 136)) != 0)
        v10 = *(_QWORD *)(v9 + 16);
      else
        v10 = 0;
      result = SecPolicyCheckCertEAPTrustedServerNames(v10, v6);
      if ((result & 1) == 0)
        return sub_10000E2C8(a1, a2, 0, kCFBooleanFalse, 0, 0);
    }
  }
  return result;
}

uint64_t sub_100044780(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  CFDictionaryRef *ValueAtIndex;
  const void *Value;
  uint64_t result;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v4 && *(uint64_t *)(v4 + 16) >= 1 && (v5 = *(_QWORD *)(v4 + 136)) != 0)
    v6 = *(_QWORD *)(v5 + 16);
  else
    v6 = 0;
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  Value = CFDictionaryGetValue(ValueAtIndex[4], a2);
  result = SecPolicyCheckCertLeafMarkerOidWithoutValueCheck(v6, Value);
  if ((result & 1) == 0)
    return sub_10000E2C8(a1, a2, 0, kCFBooleanFalse, 0, 0);
  return result;
}

void sub_10004482C(uint64_t a1, const void *a2)
{
  CFDictionaryRef *ValueAtIndex;
  const __CFArray *Value;
  const __CFArray *v6;
  CFTypeID v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const void *v12;
  CFRange v13;

  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  Value = (const __CFArray *)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (Value)
  {
    v6 = Value;
    v7 = CFGetTypeID(Value);
    if (v7 == CFArrayGetTypeID())
    {
      v8 = *(_QWORD *)(*(_QWORD *)a1 + 200);
      if (v8 && *(uint64_t *)(v8 + 16) >= 1 && (v9 = *(_QWORD *)(v8 + 136)) != 0)
        v10 = *(_QWORD *)(v9 + 16);
      else
        v10 = 0;
      v11 = SecCertificateCopySubjectPublicKeyInfoSHA256Digest(v10);
      if (v11)
      {
        v12 = (const void *)v11;
        v13.length = CFArrayGetCount(v6);
        v13.location = 0;
        if (!CFArrayContainsValue(v6, v13, v12))
          sub_10000E2C8(a1, a2, 0, kCFBooleanFalse, 0, 0);
        CFRelease(v12);
      }
      else
      {
        sub_10000E2C8(a1, a2, 0, kCFBooleanFalse, 0, 0);
      }
    }
  }
}

void sub_100044948(uint64_t a1, const void *a2)
{
  CFDictionaryRef *ValueAtIndex;
  const __CFDictionary *Value;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t ExtensionValue;
  BOOL v10;
  CFIndex v11;
  CFDataRef v12;
  const __CFData *v13;
  const __CFData *v14;
  const __CFData *v15;
  __CFData *Mutable;
  const UInt8 *BytePtr;
  CFIndex Length;
  CFRange v19;
  __CFData *v20;
  const UInt8 *v21;
  CFIndex v22;
  CFRange v23;
  UInt8 v24[32];
  UInt8 v25[16];
  char v26;
  UInt8 bytes[16];
  CFRange v28;
  CFRange v29;

  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  Value = (const __CFDictionary *)CFDictionaryGetValue(ValueAtIndex[4], a2);
  v6 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v6 && *(uint64_t *)(v6 + 16) >= 1 && (v7 = *(_QWORD *)(v6 + 136)) != 0)
    v8 = *(_QWORD *)(v7 + 16);
  else
    v8 = 0;
  ExtensionValue = SecCertificateGetExtensionValue(v8, CFSTR("1.3.6.1.5.5.7.1.12"));
  if (Value)
    v10 = ExtensionValue == 0;
  else
    v10 = 1;
  if (!v10)
  {
    if (*(_QWORD *)ExtensionValue)
    {
      v11 = *(_QWORD *)(ExtensionValue + 8);
      if (v11)
      {
        v12 = CFDataCreate(kCFAllocatorDefault, *(const UInt8 **)ExtensionValue, v11);
        if (v12)
        {
          v13 = v12;
          qmemcpy(bytes, "image/svg+xml", 13);
          *(_OWORD *)v25 = xmmword_100062004;
          v26 = 20;
          *(_OWORD *)v24 = xmmword_100062015;
          *(_QWORD *)&v24[13] = 0x2004000501020403;
          v14 = (const __CFData *)CFDictionaryGetValue(Value, CFSTR("sha1"));
          v15 = (const __CFData *)CFDictionaryGetValue(Value, CFSTR("sha256"));
          if (v15)
          {
            Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0);
            CFDataAppendBytes(Mutable, bytes, 13);
            CFDataAppendBytes(Mutable, v24, 21);
            BytePtr = CFDataGetBytePtr(v15);
            Length = CFDataGetLength(v15);
            CFDataAppendBytes(Mutable, BytePtr, Length);
            v28.length = CFDataGetLength(v13);
            v28.location = 0;
            v19 = CFDataFind(v13, Mutable, v28, 0);
            if (v19.location < 1)
            {
              LODWORD(v15) = 0;
              if (!Mutable)
                goto LABEL_17;
              goto LABEL_16;
            }
            LODWORD(v15) = v19.length == CFDataGetLength(Mutable);
            if (Mutable)
LABEL_16:
              CFRelease(Mutable);
          }
LABEL_17:
          if (!(_DWORD)v15 && v14)
          {
            v20 = CFDataCreateMutable(kCFAllocatorDefault, 0);
            CFDataAppendBytes(v20, bytes, 13);
            CFDataAppendBytes(v20, v25, 17);
            v21 = CFDataGetBytePtr(v14);
            v22 = CFDataGetLength(v14);
            CFDataAppendBytes(v20, v21, v22);
            v29.length = CFDataGetLength(v13);
            v29.location = 0;
            v23 = CFDataFind(v13, v20, v29, 0);
            if (v23.location >= 1)
            {
              LODWORD(v15) = v23.length == CFDataGetLength(v20);
              if (!v20)
                goto LABEL_22;
              goto LABEL_21;
            }
            LODWORD(v15) = 0;
            if (v20)
LABEL_21:
              CFRelease(v20);
          }
LABEL_22:
          CFRelease(v13);
          if ((_DWORD)v15)
            return;
        }
      }
    }
  }
  sub_10000E2C8(a1, a2, 0, kCFBooleanFalse, 0, 0);
}

uint64_t sub_100044C34(uint64_t a1, CFTypeRef cf1)
{
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  CFDictionaryRef *ValueAtIndex;
  uint64_t v9;
  CFTypeID v10;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (!v4 || *(uint64_t *)(v4 + 16) < 2)
    return sub_10000E2C8(a1, cf1, 0, kCFBooleanFalse, 0, 0);
  v6 = *(_QWORD *)(v4 + 144);
  v7 = v6 ? *(_QWORD *)(v6 + 16) : 0;
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], cf1);
  if (result)
  {
    v9 = result;
    v10 = CFGetTypeID((CFTypeRef)result);
    result = CFStringGetTypeID();
    if (v10 == result)
    {
      result = SecPolicyCheckCertSubjectCommonNamePrefix(v7, v9);
      if ((result & 1) == 0)
        return sub_10000E2C8(a1, cf1, 0, kCFBooleanFalse, 0, 0);
    }
  }
  return result;
}

uint64_t sub_100044D08(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v4 && *(uint64_t *)(v4 + 16) >= 1 && (v5 = *(_QWORD *)(v4 + 136)) != 0)
    v6 = *(_QWORD *)(v5 + 16);
  else
    v6 = 0;
  if (SecCertificateVersion(v6) < 3)
    return sub_10000E2C8(a1, a2, 0, kCFBooleanFalse, 0, 0);
  result = SecCertificateIsCA(v6);
  if ((result & 1) == 0)
    return sub_10000E2C8(a1, a2, 0, kCFBooleanFalse, 0, 0);
  return result;
}

void sub_100044DA8(uint64_t a1, const void *a2)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  const void *v7;

  v3 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v3 && *(uint64_t *)(v3 + 16) > 1)
  {
    v5 = *(_QWORD *)(v3 + 144);
    if (v5)
      v6 = *(_QWORD *)(v5 + 16);
    else
      v6 = 0;
    v7 = (const void *)SecCertificateCopySubjectPublicKeyInfoSHA256Digest(v6);
    if ((sub_10000ED5C(*(const __CFArray **)(a1 + 8), *(_QWORD *)(a1 + 24), a2, v7) & 1) == 0)
      sub_10000E2C8(a1, kSecPolicyCheckIntermediateSPKISHA256, 1, kCFBooleanFalse, 0, 0);
    if (v7)
      CFRelease(v7);
  }
  else
  {
    sub_10000E2C8(a1, kSecPolicyCheckIntermediateSPKISHA256, 0, kCFBooleanFalse, 0, 0);
  }
}

uint64_t sub_100044E98(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  CFDictionaryRef *ValueAtIndex;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v4)
    v5 = *(_QWORD *)(v4 + 16);
  else
    v5 = 0;
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (v5 >= 3)
  {
    v8 = result;
    v9 = 0;
    do
    {
      v10 = *(_QWORD *)(*(_QWORD *)a1 + 200);
      if (v10 && *(_QWORD *)(v10 + 16) > v9 + 1 && (v11 = *(_QWORD *)(v10 + 8 * v9 + 144)) != 0)
        v12 = *(_QWORD *)(v11 + 16);
      else
        v12 = 0;
      result = SecPolicyCheckCertExtendedKeyUsage(v12, v8);
      if ((result & 1) == 0)
        result = sub_10000E2C8(a1, a2, v9 + 1, kCFBooleanFalse, 0, 0);
      ++v9;
    }
    while (v5 - 2 != v9);
  }
  return result;
}

uint64_t sub_100044F88(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  CFDictionaryRef *ValueAtIndex;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v4)
    v5 = *(_QWORD *)(v4 + 16);
  else
    v5 = 0;
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (v5 >= 3)
  {
    v8 = result;
    v9 = 0;
    v10 = v5 - 2;
    do
    {
      v11 = *(_QWORD *)(*(_QWORD *)a1 + 200);
      if (v11 && *(_QWORD *)(v11 + 16) > v9 + 1 && (v12 = *(_QWORD *)(v11 + 8 * v9 + 144)) != 0)
        v13 = *(_QWORD *)(v12 + 16);
      else
        v13 = 0;
      result = SecPolicyCheckCertLeafMarkerOidWithoutValueCheck(v13, v8);
      if ((result & 1) == 0)
        result = sub_10000E2C8(a1, a2, 0, kCFBooleanFalse, 0, 0);
      ++v9;
    }
    while (v10 != v9);
  }
  return result;
}

void sub_100045070(uint64_t a1, const void *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  unsigned __int8 v11;
  char v12;
  const void *v13;
  CFIndex i;

  v3 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v3 && (v4 = *(_QWORD *)(v3 + 16), v4 > 1))
  {
    v6 = 18;
    do
    {
      v7 = *(_QWORD *)(*(_QWORD *)a1 + 200);
      if (v7 && *(_QWORD *)(v7 + 16) > v6 - 17 && (v8 = *(_QWORD *)(v7 + 8 * v6)) != 0)
        v9 = *(_QWORD *)(v8 + 16);
      else
        v9 = 0;
      v10 = (const void *)SecCertificateCopySubjectPublicKeyInfoSHA256Digest(v9);
      v11 = sub_10000ED5C(*(const __CFArray **)(a1 + 8), *(_QWORD *)(a1 + 24), a2, v10);
      if (v10)
        CFRelease(v10);
      if (v6 - 16 >= v4)
        v12 = 1;
      else
        v12 = v11;
      ++v6;
    }
    while ((v12 & 1) == 0);
    if ((v11 & 1) == 0)
    {
      v13 = (const void *)kSecPolicyCheckCAspkiSHA256;
      for (i = 1; i != v4; ++i)
        sub_10000E2C8(a1, v13, i, kCFBooleanFalse, 0, 0);
    }
  }
  else
  {
    sub_10000E2C8(a1, kSecPolicyCheckCAspkiSHA256, 0, kCFBooleanFalse, 0, 0);
  }
}

uint64_t sub_1000451B0(uint64_t a1, const void *a2)
{
  uint64_t result;
  const __CFArray *v5;
  CFIndex v6;
  CFIndex v7;
  const void *v8;
  const void *ValueAtIndex;

  if (!SecIsInternalRelease(a1)
    || (result = CFPreferencesGetAppBooleanValue(CFSTR("AppleServerAuthenticationNoPinning"), CFSTR("com.apple.security"), 0), !(_DWORD)result))
  {
    v5 = *(const __CFArray **)(a1 + 8);
    result = CFArrayGetCount(v5);
    if (result >= 1)
    {
      v6 = result;
      v7 = 0;
      v8 = (const void *)kSecPolicyNameSSLServer;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v5, v7);
        result = SecPolicyGetName(ValueAtIndex);
        if (result && v8)
        {
          result = CFEqual((CFTypeRef)result, v8);
          if ((_DWORD)result)
            goto LABEL_10;
        }
        else if ((const void *)result == v8)
        {
LABEL_10:
          result = sub_10000E2C8(a1, a2, 0, kCFBooleanFalse, 0, 0);
          if (!(_DWORD)result)
            return result;
        }
        ++v7;
      }
      while (v7 < v6);
    }
  }
  return result;
}

uint64_t sub_10004529C(uint64_t result)
{
  *(_BYTE *)(result + 32) = 1;
  return result;
}

uint64_t sub_1000452A8(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(*(_QWORD *)result + 200);
  if (*(uint64_t *)(v1 + 120) <= 1)
    *(_QWORD *)(v1 + 120) = 1;
  return result;
}

uint64_t sub_1000452C8(_QWORD *a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  const void *v6;
  double v7;
  double v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;
  double v14;
  NSObject *v15;
  const char *v16;
  uint8_t *v17;
  __int16 v18;
  __int16 v19;
  __int16 v20;

  v4 = *(_QWORD *)(*a1 + 200);
  if (v4 && *(uint64_t *)(v4 + 16) >= 1 && (v5 = *(_QWORD *)(v4 + 136)) != 0)
    v6 = *(const void **)(v5 + 16);
  else
    v6 = 0;
  v7 = SecCertificateNotValidAfter(v6);
  v8 = SecCertificateNotValidBefore(v6);
  v9 = *(_QWORD *)(*a1 + 200);
  if (v9 && (v10 = *(_QWORD *)(v9 + 16), v10 >= 1) && (v11 = *(_QWORD *)(v9 + 8 * v10 + 128)) != 0)
    v12 = *(_QWORD *)(v11 + 16);
  else
    v12 = 0;
  result = off_1000827E0((uint64_t)off_1000827D0, v12);
  if ((result & 1) != 0 || (result = sub_100045A18(v12, CFSTR("TestSystemRoot")), (_DWORD)result))
  {
    v14 = v7 - v8;
    if (v8 >= 620611200.0)
    {
      if (v14 > 34387200.0)
      {
        v15 = sub_100011628("policy");
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          v18 = 0;
          v16 = "System-trusted leaf validity period longer than 398 days and issued on or after 1 September 2020";
          v17 = (uint8_t *)&v18;
          goto LABEL_20;
        }
        return sub_10000E2C8((uint64_t)a1, a2, 0, kCFBooleanFalse, 0, 0);
      }
    }
    else if (v14 > 71283600.0)
    {
      v15 = sub_100011628("policy");
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        v19 = 0;
        v16 = "System-trusted leaf validity period longer than 825 days and issued on or after 1 March 2018";
        v17 = (uint8_t *)&v19;
LABEL_20:
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, v16, v17, 2u);
        return sub_10000E2C8((uint64_t)a1, a2, 0, kCFBooleanFalse, 0, 0);
      }
      return sub_10000E2C8((uint64_t)a1, a2, 0, kCFBooleanFalse, 0, 0);
    }
  }
  else
  {
    result = sub_10000F2B4(a1, (uint64_t)off_1000827E8, v6);
    if ((result & 1) != 0)
      return result;
    result = SecIsInternalRelease(result);
    if ((_DWORD)result)
    {
      result = CFPreferencesGetAppBooleanValue(CFSTR("IgnoreMaximumValidityPeriod"), CFSTR("com.apple.security"), 0);
      if (v8 <= 583628400.0 || (_DWORD)result)
        return result;
    }
    else if (v8 <= 583628400.0)
    {
      return result;
    }
    if (v7 - v8 > 71283600.0)
    {
      v15 = sub_100011628("policy");
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        return sub_10000E2C8((uint64_t)a1, a2, 0, kCFBooleanFalse, 0, 0);
      v20 = 0;
      v16 = "Non-system-trusted leaf validity period longer than 825 days and issued on or after 1 July 2019";
      v17 = (uint8_t *)&v20;
      goto LABEL_20;
    }
  }
  return result;
}

void sub_100045524(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (!v4)
  {
    v6 = 0;
LABEL_10:
    v9 = 0;
    goto LABEL_11;
  }
  if (*(uint64_t *)(v4 + 16) >= 1 && (v5 = *(_QWORD *)(v4 + 136)) != 0)
    v6 = *(_QWORD *)(v5 + 16);
  else
    v6 = 0;
  v7 = *(_QWORD *)(v4 + 16);
  if (v7 < 1)
    goto LABEL_10;
  v8 = *(_QWORD *)(v4 + 8 * v7 + 128);
  if (!v8)
    goto LABEL_10;
  v9 = *(_QWORD *)(v8 + 16);
LABEL_11:
  if (SecCertificateNotValidBefore(v6) >= 670464000.0
    && (off_1000827E0((uint64_t)off_1000827D0, v9) || sub_100045A18(v9, CFSTR("TestSystemRoot")))
    && (SecPolicyCheckCertExtendedKeyUsage(v6, CFSTR("1.3.6.1.5.5.7.3.4")) & 1) == 0)
  {
    sub_10000E2C8(a1, a2, 0, kCFBooleanFalse, 0, 0);
  }
}

void sub_10004562C(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  CFDictionaryRef *ValueAtIndex;
  const void *Value;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const __CFArray *v12;
  const __CFArray *v13;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v4)
    v5 = *(_QWORD *)(v4 + 16);
  else
    v5 = 0;
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 24));
  Value = CFDictionaryGetValue(ValueAtIndex[4], a2);
  v8 = 0;
  do
  {
    v9 = *(_QWORD *)(*(_QWORD *)a1 + 200);
    if (v9 && *(_QWORD *)(v9 + 16) > v8 && (v10 = *(_QWORD *)(v9 + 8 * v8 + 136)) != 0)
      v11 = *(_QWORD *)(v10 + 16);
    else
      v11 = 0;
    v12 = (const __CFArray *)SecCertificateCopyExtendedKeyUsage(v11);
    if (v12)
    {
      v13 = v12;
      if (CFArrayGetCount(v12) != 1 || !Value || (SecPolicyCheckCertExtendedKeyUsage(v11, Value) & 1) == 0)
        sub_10000E2C8(a1, a2, 0, kCFBooleanFalse, 0, 0);
      CFRelease(v13);
    }
    else
    {
      sub_10000E2C8(a1, a2, 0, kCFBooleanFalse, 0, 0);
    }
    if (v5 < 3)
      break;
    ++v8;
  }
  while (v8 < v5 - 1);
}

void sub_10004576C(uint64_t *a1, const void *a2)
{
  const void *v4;
  const __CFDictionary *v5;
  int v6;
  BOOL v7;
  const __CFDictionary *v8;
  uint64_t v9;
  __int16 v10;
  CFTypeRef v11;
  CFTypeRef cf;

  v4 = *(const void **)(*a1 + 112);
  if (v4)
    CFRetain(*(CFTypeRef *)(*a1 + 112));
  if (sub_100005508((uint64_t)CFSTR("CTKillSwitch_nonTLS")))
    goto LABEL_4;
  if (sub_10000C0C0(5184000.0) || v4)
  {
    v5 = *(const __CFDictionary **)(*a1 + 112);
    if (v5)
      CFRetain(*(CFTypeRef *)(*a1 + 112));
    else
      v5 = (const __CFDictionary *)sub_10003439C();
    v11 = 0;
    cf = 0;
    v10 = 0;
    v9 = 0;
    *(_BYTE *)(*(_QWORD *)(*a1 + 200) + 66) = 0;
    v6 = sub_100007598((uint64_t)a1, v5, (CFMutableDictionaryRef *)&cf, (CFMutableDictionaryRef *)&v11, (_BYTE *)&v10 + 1, &v10);
    v7 = 0;
    v8 = (const __CFDictionary *)cf;
    if (v6)
    {
      v7 = sub_100007DBC(a1, (CFDictionaryRef)cf, (const __CFDictionary *)v11, HIBYTE(v10), v10, &v9);
      sub_100007278((uint64_t)a1, v8, v9);
    }
    if (v8)
      CFRelease(v8);
    if (v11)
      CFRelease(v11);
    if (v5)
      CFRelease(v5);
    if (!v7)
      sub_10000E2C8((uint64_t)a1, a2, 0, kCFBooleanFalse, 0, 0);
LABEL_4:
    if (v4)
      CFRelease(v4);
  }
}

uint64_t sub_1000458DC(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)result + 212) = 1;
  return result;
}

uint64_t sub_1000458EC(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)result + 213) = 1;
  return result;
}

unint64_t sub_1000458FC(const __CFDictionary *a1)
{
  const __CFArray *Value;
  const __CFArray *v2;
  CFTypeID v3;
  CFIndex Count;
  CFIndex v5;
  uint64_t v6;
  CFIndex i;
  const void *ValueAtIndex;
  CFTypeID v9;

  Value = (const __CFArray *)CFDictionaryGetValue(a1, kSecPolicyCheckKeyUsage);
  if (Value)
  {
    v2 = Value;
    v3 = CFGetTypeID(Value);
    if (v3 == CFArrayGetTypeID())
    {
      Count = CFArrayGetCount(v2);
      if (Count >= 1)
      {
        v5 = Count;
        LODWORD(v6) = 0;
        for (i = 0; i != v5; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v2, i);
          v6 = sub_1000459BC((unint64_t)ValueAtIndex) | v6;
        }
        return v6;
      }
    }
    else
    {
      v9 = CFGetTypeID(v2);
      if (v9 == CFNumberGetTypeID())
        return sub_1000459BC((unint64_t)v2);
    }
  }
  return 0;
}

unint64_t sub_1000459BC(unint64_t result)
{
  unsigned int valuePtr;

  valuePtr = 0;
  if (result)
  {
    result = CFNumberGetValue((CFNumberRef)result, kCFNumberSInt32Type, &valuePtr);
    if ((_DWORD)result)
    {
      if (valuePtr == 0x7FFFFFFF)
        return 0xFFFFFFFFLL;
      else
        return (valuePtr >> 2) & 2 | valuePtr & 5 | (32 * ((valuePtr >> 4) & 1));
    }
  }
  return result;
}

BOOL sub_100045A18(uint64_t a1, const __CFString *a2)
{
  const void *v4;
  CFPropertyListRef v5;
  const void *v6;
  CFTypeID v7;
  _BOOL8 v8;

  if (!SecIsInternalRelease())
    return 0;
  v4 = (const void *)SecCertificateCopySHA256Digest(a1);
  v5 = CFPreferencesCopyAppValue(a2, CFSTR("com.apple.security"));
  if (!v5)
  {
    v8 = 0;
    if (!v4)
      return v8;
    goto LABEL_6;
  }
  v6 = v5;
  v7 = CFGetTypeID(v5);
  v8 = v7 == CFDataGetTypeID() && CFEqual(v4, v6) != 0;
  CFRelease(v6);
  if (v4)
LABEL_6:
    CFRelease(v4);
  return v8;
}

CFIndex sub_100045AC8(CFIndex result, CFStringRef theString1)
{
  CFIndex v2;
  char v3;
  const __CFString *v5;
  CFIndex Length;
  CFRange v7;
  const __CFString *v8;
  const __CFString *v9;

  v2 = result;
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24))
    goto LABEL_2;
  v5 = *(const __CFString **)(result + 40);
  v3 = 1;
  result = CFStringCompare(theString1, v5, 1uLL);
  if (!result)
    goto LABEL_11;
  result = CFStringHasPrefix(theString1, CFSTR("."));
  if (!(_DWORD)result)
    goto LABEL_10;
  Length = CFStringGetLength(theString1);
  result = CFStringGetLength(v5);
  v7.location = result - Length;
  if (result > Length)
  {
    v8 = v5;
    v9 = theString1;
    v7.length = Length;
    goto LABEL_9;
  }
  v7.length = result;
  if (result + 1 != Length)
  {
LABEL_10:
    v3 = 0;
    goto LABEL_11;
  }
  v8 = theString1;
  v9 = v5;
  v7.location = 1;
LABEL_9:
  result = CFStringCompareWithOptions(v8, v9, v7, 1uLL);
  if (result)
    goto LABEL_10;
LABEL_2:
  v3 = 1;
LABEL_11:
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v2 + 32) + 8) + 24) = v3;
  return result;
}

uint64_t sub_100045B9C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_100045BB0(uint64_t a1, CFDictionaryRef theDict)
{
  uint64_t v2;
  BOOL v3;
  uint64_t v5;
  const void *Value;
  uint64_t v7;
  uint64_t v8;
  const void *v9;
  const void *v10;
  BOOL v11;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const void *v16;
  const void *v17;
  const __CFArray *PermittedSubtrees;
  const void *v19;
  const void *v20;
  _QWORD context[5];
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  char v25;
  CFRange v26;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (!*(_BYTE *)(v2 + 24))
  {
    v5 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
    v22 = 0;
    v23 = &v22;
    v24 = 0x2000000000;
    v25 = 0;
    Value = CFDictionaryGetValue(theDict, kSecCTExceptionsSPKIHashKey);
    if (v5 && *(uint64_t *)(v5 + 16) >= 1 && (v7 = *(_QWORD *)(v5 + 136)) != 0)
      v8 = *(_QWORD *)(v7 + 16);
    else
      v8 = 0;
    v9 = (const void *)SecCertificateCopySubjectPublicKeyInfoSHA256Digest(v8);
    v10 = v9;
    if (Value)
      v11 = v9 == 0;
    else
      v11 = 1;
    if (v11)
    {
      if (Value == v9)
        goto LABEL_17;
      if (!v9)
      {
LABEL_19:
        v3 = 1;
        if (!*((_BYTE *)v23 + 24))
        {
          v13 = 18;
          if (v5)
          {
            while (1)
            {
              if (v13 - 17 >= *(_QWORD *)(v5 + 16))
                goto LABEL_47;
              v14 = *(_QWORD *)(v5 + 8 * v13);
              v15 = v14 ? *(_QWORD *)(v14 + 16) : 0;
              v16 = (const void *)SecCertificateCopySubjectPublicKeyInfoSHA256Digest(v15);
              v17 = v16;
              if (Value)
              {
                if (v16)
                  break;
              }
              if (Value != v16)
              {
                if (!v16)
                  goto LABEL_46;
LABEL_31:
                CFRelease(v17);
                goto LABEL_46;
              }
              if (v16)
                goto LABEL_33;
LABEL_34:
              if (SecCertificateGetPermittedSubtrees(v15))
              {
                PermittedSubtrees = (const __CFArray *)SecCertificateGetPermittedSubtrees(v15);
                context[0] = _NSConcreteStackBlock;
                context[1] = 0x40000000;
                context[2] = sub_100045E64;
                context[3] = &unk_100077D38;
                context[4] = &v22;
                v26.length = CFArrayGetCount(PermittedSubtrees);
                v26.location = 0;
                CFArrayApplyFunction(PermittedSubtrees, v26, (CFArrayApplierFunction)sub_100045B9C, context);
              }
              if (!*((_BYTE *)v23 + 24))
              {
                v19 = (const void *)SecCertificateCopyOrganization(v8);
                v20 = (const void *)SecCertificateCopyOrganization(v15);
                if (v20 && v19)
                {
                  if (CFEqual(v19, v20))
                    *((_BYTE *)v23 + 24) = 1;
LABEL_42:
                  CFRelease(v19);
                }
                else if (v19)
                {
                  goto LABEL_42;
                }
                if (v20)
                  CFRelease(v20);
              }
              if (*((_BYTE *)v23 + 24))
              {
                v3 = 1;
                goto LABEL_49;
              }
LABEL_46:
              ++v13;
            }
            if (!CFEqual(Value, v16))
              goto LABEL_31;
LABEL_33:
            CFRelease(v17);
            goto LABEL_34;
          }
LABEL_47:
          v3 = *((_BYTE *)v23 + 24) != 0;
        }
LABEL_49:
        _Block_object_dispose(&v22, 8);
        v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
        goto LABEL_50;
      }
    }
    else if (CFEqual(Value, v9))
    {
LABEL_17:
      *((_BYTE *)v23 + 24) = 1;
      if (!v10)
        goto LABEL_19;
    }
    CFRelease(v10);
    goto LABEL_19;
  }
  v3 = 1;
LABEL_50:
  *(_BYTE *)(v2 + 24) = v3;
}

CFIndex sub_100045E64(uint64_t a1, CFDataRef theData)
{
  CFIndex result;
  unint64_t v5[3];
  _QWORD v6[2];

  result = CFDataGetLength(theData);
  if (result >= 1)
  {
    v6[0] = CFDataGetBytePtr(theData);
    v6[1] = CFDataGetLength(theData);
    memset(v5, 170, sizeof(v5));
    result = DERDecodeItem((uint64_t)v6, v5);
    if (!(_DWORD)result)
    {
      result = SecCertificateParseGeneralNameContentProperty(v5[0], &v5[1], 0, sub_100045F00);
      if (!(_DWORD)result)
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
    }
  }
  return result;
}

uint64_t sub_100045F00(uint64_t a1, int a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v4;
  int v5;
  uint64_t result;
  const void *v7;
  unint64_t v8[5];

  if (a2 != 4)
    return 4294941020;
  v8[3] = v3;
  v8[4] = v4;
  memset(v8, 170, 24);
  v5 = DERDecodeItem(a3, v8);
  result = 4294941021;
  if (!v5 && v8[0] == 0x2000000000000010)
  {
    v7 = (const void *)SecCertificateCopyOrganizationFromX501NameContent(&v8[1]);
    if (v7)
    {
      CFRelease(v7);
      return 0;
    }
    else
    {
      return 4294941020;
    }
  }
  return result;
}

void sub_100045F80(uint64_t a1, CFDictionaryRef theDict)
{
  CFMutableDictionaryRef MutableCopy;

  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDict);
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), MutableCopy);
  if (MutableCopy)
    CFRelease(MutableCopy);
}

void sub_100045FD0(id a1)
{
  __CFSet *Mutable;
  uint64_t i;
  CFDataRef v3;
  CFDataRef v4;

  Mutable = CFSetCreateMutable(0, 0, &kCFTypeSetCallBacks);
  for (i = 0; i != 64; i += 8)
  {
    v3 = CFDataCreateWithBytesNoCopy(0, *(const UInt8 **)((char *)&off_100077D98 + i), 32, kCFAllocatorNull);
    if (v3)
    {
      v4 = v3;
      CFSetAddValue(Mutable, v3);
      CFRelease(v4);
    }
  }
  qword_100082DE8 = (uint64_t)Mutable;
}

uint64_t sub_10004606C()
{
  uint64_t v0;
  _QWORD v2[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2000000000;
  v6 = 0;
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000;
  v2[2] = sub_10004EFB8;
  v2[3] = &unk_100078120;
  v2[4] = &v3;
  sub_100016C6C((uint64_t)v2);
  v0 = v4[3];
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t sub_1000460F4(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  uint64_t v7;
  char v8;
  const __CFBoolean *v9;
  const __CFBoolean *v10;
  CFTypeID v11;
  int Value;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  BOOL v16;
  _QWORD v17[5];
  _QWORD v18[5];
  __int128 v19;
  uint64_t v20;
  char v21;

  v4 = *(_QWORD *)(a1 + 32);
  v5 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  v18[2] = sub_1000479AC;
  v18[3] = &unk_100077E00;
  v21 = *(_BYTE *)(a1 + 64);
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 0x40000000;
  v18[4] = v4;
  v19 = *(_OWORD *)(a1 + 48);
  v20 = a2;
  result = sub_10004657C((uint64_t *)a2, v5, (uint64_t)v18);
  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v7 + 24))
    v8 = result;
  else
    v8 = 0;
  *(_BYTE *)(v7 + 24) = v8;
  if (*(_BYTE *)(a2 + 18))
  {
    *(_BYTE *)(a2 + 18) = 0;
    v9 = (const __CFBoolean *)CFPreferencesCopyValue(CFSTR("ValidVerifyEnabled"), CFSTR("com.apple.security"), kCFPreferencesAnyUser, kCFPreferencesCurrentHost);
    if (v9)
    {
      v10 = v9;
      v11 = CFGetTypeID(v9);
      if (v11 == CFBooleanGetTypeID())
      {
        Value = CFBooleanGetValue(v10);
        CFRelease(v10);
        if (Value)
        {
          v13 = *(_QWORD *)(a1 + 32);
          v14 = *(_QWORD *)(v13 + 8);
          if (*(_BYTE *)(v14 + 24))
          {
            v15 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
            v17[0] = _NSConcreteStackBlock;
            v17[1] = 0x40000000;
            v17[2] = sub_100049CE8;
            v17[3] = &unk_100077E28;
            v17[4] = v13;
            v16 = sub_100018D8C((uint64_t *)a2, v15, (uint64_t)v17);
            v14 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
          }
          else
          {
            v16 = 0;
          }
          *(_BYTE *)(v14 + 24) = v16;
        }
      }
      else
      {
        CFRelease(v10);
      }
    }
    return notify_post("com.apple.trustd.valid.db-changed");
  }
  return result;
}

void sub_100046288(double a1)
{
  const void *v1;
  _QWORD v2[7];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v7[3];
  char v8;

  v7[0] = 0;
  v7[1] = v7;
  v7[2] = 0x2000000000;
  v8 = 1;
  v3 = 0;
  v4 = &v3;
  v5 = 0x2000000000;
  v6 = 0;
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000;
  v2[2] = sub_100046330;
  v2[3] = &unk_100078168;
  v2[4] = v7;
  v2[5] = &v3;
  *(double *)&v2[6] = a1;
  sub_100016C6C((uint64_t)v2);
  v1 = (const void *)v4[3];
  if (v1)
    CFRelease(v1);
  _Block_object_dispose(&v3, 8);
  _Block_object_dispose(v7, 8);
}

BOOL sub_100046330(_QWORD *a1, uint64_t *a2)
{
  _QWORD *v4;
  _BOOL8 result;
  uint64_t v6;
  BOOL v7;
  _QWORD v8[5];

  v4 = (_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = sub_1000463BC;
  v8[3] = &unk_100078140;
  v8[4] = a1[6];
  result = sub_10004657C(a2, v4, (uint64_t)v8);
  v6 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v6 + 24))
    v7 = result;
  else
    v7 = 0;
  *(_BYTE *)(v6 + 24) = v7;
  return result;
}

uint64_t sub_1000463BC(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  NSObject *v7;
  uint64_t v8;
  __CFError *v9;
  CFIndex Code;
  const void *v11;
  uint64_t v12;
  _QWORD v14[8];
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  CFTypeRef v22;
  uint8_t buf[4];
  uint64_t v24;

  v4 = *(_QWORD *)(a1 + 32);
  v19 = 0;
  v20 = &v19;
  v21 = 0x2000000000;
  v22 = 0;
  v15 = 0;
  v16 = &v15;
  v17 = 0x2000000000;
  v18 = a2 != 0;
  if (a2)
  {
    v5 = *(_QWORD *)(a2 + 8);
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 0x40000000;
    v14[2] = sub_1000467B0;
    v14[3] = &unk_100078B88;
    v14[4] = &v15;
    v14[5] = &v19;
    v14[6] = v4;
    v14[7] = a2;
    v6 = sub_10001979C(v5, CFSTR("INSERT OR REPLACE INTO admin (key,ival,value) VALUES (?,?,?)"), &v22, (uint64_t)v14);
    *((_BYTE *)v16 + 24) = v6;
    if (v6 && !v20[3])
      goto LABEL_16;
  }
  else
  {
    v18 = 0;
  }
  v7 = sub_100011628("SecError");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    v8 = v20[3];
    *(_DWORD *)buf = 138412290;
    v24 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbSetNextUpdate failed: %@", buf, 0xCu);
  }
  v9 = (__CFError *)v20[3];
  if (v9)
    Code = CFErrorGetCode(v9);
  else
    Code = -2070;
  sub_1000521A8(1, 2, Code);
  v11 = (const void *)v20[3];
  if (v11)
  {
    if (a3 && !*a3)
      *a3 = v11;
    else
      CFRelease(v11);
  }
LABEL_16:
  v12 = *((unsigned __int8 *)v16 + 24);
  _Block_object_dispose(&v15, 8);
  _Block_object_dispose(&v19, 8);
  return v12;
}

BOOL sub_10004657C(uint64_t *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v4;
  int v5;
  uint64_t *v6;
  _BOOL4 v7;
  uint64_t v8;
  _BOOL8 v9;
  _QWORD v11[8];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  __CFString *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  char v19;

  v16 = 0;
  v17 = &v16;
  v18 = 0x2000000000;
  v19 = 1;
  v12 = 0;
  v13 = &v12;
  v14 = 0x2000000000;
  v15 = 0;
  v4 = *a1;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  v11[2] = sub_100046688;
  v11[3] = &unk_100078640;
  v11[6] = &v12;
  v11[7] = a1;
  v11[4] = a3;
  v11[5] = &v16;
  v5 = sub_100029AF0(v4, &v15, (uint64_t)v11);
  v6 = v17;
  if (*((_BYTE *)v17 + 24))
    v7 = v5;
  else
    v7 = 0;
  *((_BYTE *)v17 + 24) = v7;
  v8 = v13[3];
  if (v8)
  {
    if (a2 && !*a2)
    {
      *a2 = v8;
    }
    else
    {
      CFRelease((CFTypeRef)v13[3]);
      v6 = v17;
      v7 = *((_BYTE *)v17 + 24) != 0;
    }
  }
  if (v8)
    v9 = 0;
  else
    v9 = v7;
  *((_BYTE *)v6 + 24) = v9;
  _Block_object_dispose(&v12, 8);
  _Block_object_dispose(&v16, 8);
  return v9;
}

BOOL sub_100046688(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _BOOL8 result;
  uint64_t v8;
  BOOL v9;
  _QWORD v10[9];

  v10[0] = _NSConcreteStackBlock;
  v3 = a1[6];
  v4 = a1[7];
  v5 = *(_QWORD *)(v3 + 8);
  v10[2] = sub_10004671C;
  v10[3] = &unk_100078618;
  v6 = a1[4];
  v10[6] = a1[5];
  v10[7] = v4;
  v10[1] = 0x40000000;
  v10[8] = a2;
  v10[4] = v6;
  v10[5] = v3;
  result = sub_10002884C(a2, 1, (CFTypeRef *)(v5 + 24), (uint64_t)v10);
  v8 = *(_QWORD *)(a1[5] + 8);
  if (*(_BYTE *)(v8 + 24))
    v9 = result;
  else
    v9 = 0;
  *(_BYTE *)(v8 + 24) = v9;
  return result;
}

void sub_10004671C(_QWORD *a1, _BYTE *a2)
{
  _QWORD *v4;
  uint64_t v5;
  char v6;

  v4 = sub_100018B0C(a1[7], a1[8], (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24));
  v5 = *(_QWORD *)(a1[6] + 8);
  if (*(_BYTE *)(v5 + 24))
  {
    v6 = (*(uint64_t (**)(void))(a1[4] + 16))();
    v5 = *(_QWORD *)(a1[6] + 8);
  }
  else
  {
    v6 = 0;
  }
  *(_BYTE *)(v5 + 24) = v6;
  *a2 = *(_BYTE *)(*(_QWORD *)(a1[6] + 8) + 24);
  free(v4);
}

uint64_t sub_1000467B0(_QWORD *a1, sqlite3_stmt *a2)
{
  uint64_t v4;
  CFTypeRef *v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  CFTypeRef *v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  CFTypeRef *v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  char v17;

  v4 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v4 + 24))
  {
    v5 = (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24);
    v6 = sqlite3_bind_text(a2, 1, "check_again", 11, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
    v7 = sub_10001A970(v6, a2, v5, CFSTR("bind_text[%d]"), 1);
    v4 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v7 = 0;
  }
  *(_BYTE *)(v4 + 24) = v7;
  v8 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v8 + 24))
  {
    v9 = (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24);
    v10 = sqlite3_bind_int64(a2, 2, 0);
    v11 = sub_10001A970(v10, a2, v9, CFSTR("bind_int64[%d]"), 2);
    v8 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v11 = 0;
  }
  *(_BYTE *)(v8 + 24) = v11;
  v12 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v12 + 24))
  {
    v13 = (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24);
    v14 = sqlite3_bind_blob(a2, 3, a1 + 6, 8, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
    v15 = sub_10001A970(v14, a2, v13, CFSTR("bind_blob[%d]"), 3);
    v12 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v15 = 0;
  }
  *(_BYTE *)(v12 + 24) = v15;
  v16 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v16 + 24))
  {
    v17 = sub_100019D18(*(_QWORD *)(a1[7] + 8), a2, (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24), 0);
    v16 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v17 = 0;
  }
  *(_BYTE *)(v16 + 24) = v17;
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

void sub_100046958(id a1)
{
  CFStringRef v1;
  CFStringRef v2;
  const __CFURL *v3;
  const __CFString *v4;
  char *v5;
  uint64_t v6;
  char v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  dispatch_queue_t v11;
  CFMutableArrayRef Mutable;
  CFMutableDictionaryRef v13;
  NSObject *v14;
  int out_token[2];
  uint64_t v16;
  BOOL (*v17)(uint64_t, int, uint64_t, int, int, CFTypeRef *);
  void *v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  char v23;

  v1 = CFStringCreateWithFormat(0, 0, CFSTR("%s"), "valid.sqlite3");
  if (!v1)
    return;
  v2 = v1;
  v3 = sub_10001DCB8((uint64_t)v1);
  CFRelease(v2);
  if (!v3)
    return;
  v4 = CFURLCopyFileSystemPath(v3, kCFURLPOSIXPathStyle);
  CFRelease(v3);
  if (!v4)
    return;
  v5 = (char *)malloc_type_malloc(0x30uLL, 0x102004053D0C2FDuLL);
  v6 = (uint64_t)v5;
  if (v5)
  {
    *(_QWORD *)v5 = 0;
    *((_QWORD *)v5 + 1) = 0;
    *(_DWORD *)(v5 + 15) = 0;
    v20 = 0;
    v21 = &v20;
    v22 = 0x2000000000;
    v23 = -86;
    if (qword_100082C28 != -1)
      dispatch_once(&qword_100082C28, &stru_1000767D0);
    v23 = byte_100082C20;
    v7 = *((_BYTE *)v21 + 24);
    *(_QWORD *)out_token = _NSConcreteStackBlock;
    v16 = 0x40000000;
    v17 = sub_100046BFC;
    v18 = &unk_100078520;
    v19 = &v20;
    v8 = sub_1000275D0(v4, 420, v7, 0, 1, 1, out_token);
    _Block_object_dispose(&v20, 8);
    *(_QWORD *)v6 = v8;
    if (v8)
    {
      v9 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_BACKGROUND, 0);
      v10 = dispatch_queue_attr_make_with_autorelease_frequency(v9, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
      v11 = dispatch_queue_create(0, v10);
      *(_QWORD *)(v6 + 8) = v11;
      if (!v11)
      {
LABEL_23:
        if (*(_QWORD *)v6)
          CFRelease(*(CFTypeRef *)v6);
        free((void *)v6);
        v6 = 0;
        goto LABEL_15;
      }
      Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
      *(_QWORD *)(v6 + 24) = Mutable;
      if (Mutable)
      {
        v13 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        *(_QWORD *)(v6 + 32) = v13;
        if (v13)
        {
          *(_DWORD *)(v6 + 40) = 0;
          if (qword_100082C28 != -1)
            dispatch_once(&qword_100082C28, &stru_1000767D0);
          if ((byte_100082C20 & 1) == 0)
          {
            out_token[0] = 0;
            notify_register_dispatch("com.apple.trustd.valid.db-changed", out_token, *(dispatch_queue_t *)(v6 + 8), &stru_1000784D0);
          }
          goto LABEL_15;
        }
      }
    }
    v14 = *(NSObject **)(v6 + 8);
    if (v14)
      dispatch_release(v14);
    goto LABEL_23;
  }
LABEL_15:
  qword_100082E48 = v6;
  CFRelease(v4);
  if (qword_100082E48)
  {
    if (qword_100082C28 != -1)
      dispatch_once(&qword_100082C28, &stru_1000767D0);
    if (byte_100082C20 == 1)
      sub_100046DE8((uint64_t *)qword_100082E48);
  }
}

BOOL sub_100046BFC(uint64_t a1, int a2, uint64_t a3, int a4, int a5, CFTypeRef *a6)
{
  _BOOL4 v8;
  _BOOL4 v9;
  __CFError *v10;
  _BOOL8 v11;
  CFIndex Code;
  char v13;
  NSObject *v14;
  const char *v15;
  CFTypeRef v16;
  _QWORD v18[7];
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  char v22;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  CFTypeRef v26;

  v19 = 0;
  v20 = &v19;
  v21 = 0x2000000000;
  v22 = 1;
  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    goto LABEL_7;
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 0x40000000;
  v18[2] = sub_100047948;
  v18[3] = &unk_1000784F8;
  v18[4] = &v19;
  v18[5] = a3;
  v18[6] = a6;
  v8 = sub_10002884C(a3, 2, a6, (uint64_t)v18);
  v9 = *((_BYTE *)v20 + 24) && v8;
  *((_BYTE *)v20 + 24) = v9;
  if (!v9)
  {
    if (!a6)
    {
      Code = -2070;
      v13 = 1;
      goto LABEL_14;
    }
    v10 = (__CFError *)*a6;
    if (!*a6)
    {
      v13 = 0;
      Code = -2070;
      goto LABEL_14;
    }
  }
  else
  {
LABEL_7:
    if (!a6 || (v10 = (__CFError *)*a6) == 0)
    {
      v11 = 1;
      goto LABEL_22;
    }
  }
  Code = CFErrorGetCode(v10);
  v13 = 0;
LABEL_14:
  v14 = sub_100011628("SecError");
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    v15 = "Open";
    if (a4)
      v15 = "Create";
    if ((v13 & 1) != 0)
      v16 = 0;
    else
      v16 = *a6;
    *(_DWORD *)buf = 136315394;
    v24 = v15;
    v25 = 2112;
    v26 = v16;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%s failed: %@", buf, 0x16u);
  }
  sub_1000521A8(1, 0, Code);
  v11 = *((_BYTE *)v20 + 24) != 0;
LABEL_22:
  _Block_object_dispose(&v19, 8);
  return v11;
}

void sub_100046DE8(uint64_t *a1)
{
  CFTypeRef cf;

  if (a1 && *a1)
  {
    cf = 0;
    sub_10004657C(a1, &cf, (uint64_t)&stru_100078020);
    if (cf)
      CFRelease(cf);
  }
}

BOOL sub_100046E2C(id a1, __SecRevocationDbConnection *a2, __CFError **a3)
{
  int64_t var3;
  BOOL v6;
  __OpaqueSecDbConnection *var1;
  char v8;
  char v9;
  __OpaqueSecDbConnection *v10;
  int v11;
  int v12;
  __OpaqueSecDbConnection *v14;
  char v15;
  char v16;
  char v17;
  NSObject *v18;
  CFTypeRef v19;
  __CFError *v20;
  _QWORD v22[7];
  _QWORD v23[7];
  _QWORD v24[7];
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  BOOL v28;
  uint64_t v29;
  CFTypeRef *v30;
  uint64_t v31;
  CFTypeRef v32;
  uint8_t buf[4];
  CFTypeRef v34;

  v29 = 0;
  v30 = (CFTypeRef *)&v29;
  v31 = 0x2000000000;
  v32 = 0;
  v25 = 0;
  v26 = &v25;
  v27 = 0x2000000000;
  v28 = a2 != 0;
  if (!a2)
    goto LABEL_24;
  var3 = a2->var3;
  if (var3 > 6)
  {
    v6 = 1;
    goto LABEL_32;
  }
  if (var3 > 4)
  {
    v12 = 1;
  }
  else
  {
    var1 = a2->var1;
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 0x40000000;
    v24[2] = sub_1000470F4;
    v24[3] = &unk_100078690;
    v24[4] = &v25;
    v24[5] = &v29;
    v24[6] = a2;
    v8 = sub_10001979C((uint64_t)var1, CFSTR("CREATE TABLE IF NOT EXISTS dates(groupid INTEGER PRIMARY KEY NOT NULL,notbefore REAL,notafter REAL);"),
           &v32,
           (uint64_t)v24);
    if (*((_BYTE *)v26 + 24))
      v9 = v8;
    else
      v9 = 0;
    *((_BYTE *)v26 + 24) = v9;
    v10 = a2->var1;
    v23[0] = _NSConcreteStackBlock;
    v23[1] = 0x40000000;
    v23[2] = sub_100047140;
    v23[3] = &unk_1000786B8;
    v23[5] = &v29;
    v23[6] = a2;
    v23[4] = &v25;
    v11 = sub_10001979C((uint64_t)v10, CFSTR("DROP TRIGGER IF EXISTS group_del;CREATE TRIGGER group_del BEFORE DELETE ON groups FOR EACH ROW BEGIN DELETE FROM serials WHERE groupid=OLD.groupid; DELETE FROM hashes WHERE groupid=OLD.groupid; DELETE FROM issuers WHERE groupid=OLD.groupid; DELETE FROM dates WHERE groupid=OLD.groupid; END;"),
            v30 + 3,
            (uint64_t)v23);
    if (*((_BYTE *)v26 + 24))
      v12 = v11;
    else
      v12 = 0;
    *((_BYTE *)v26 + 24) = v12;
  }
  if ((unint64_t)(var3 - 1) <= 4 && v12 != 0)
  {
    sub_10004718C();
    v12 = *((unsigned __int8 *)v26 + 24);
  }
  if (!v12)
    goto LABEL_24;
  v14 = a2->var1;
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 0x40000000;
  v22[2] = sub_1000472B0;
  v22[3] = &unk_1000786E0;
  v22[4] = &v25;
  v22[5] = &v29;
  v22[6] = a2;
  v15 = sub_10001979C((uint64_t)v14, CFSTR("ALTER TABLE groups ADD COLUMN policies BLOB"), v30 + 3, (uint64_t)v22);
  v16 = *((_BYTE *)v26 + 24) ? v15 : 0;
  *((_BYTE *)v26 + 24) = v16;
  if ((v16 & 1) != 0)
  {
    v17 = sub_1000472FC(a2);
    *((_BYTE *)v26 + 24) = v17;
  }
  else
  {
LABEL_24:
    v18 = sub_100011628("SecError");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      v19 = v30[3];
      *(_DWORD *)buf = 138412290;
      v34 = v19;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbUpdateSchema failed: %@", buf, 0xCu);
    }
  }
  v20 = (__CFError *)v30[3];
  if (v20)
  {
    if (a3 && !*a3)
      *a3 = v20;
    else
      CFRelease(v20);
  }
  v6 = *((_BYTE *)v26 + 24) != 0;
LABEL_32:
  _Block_object_dispose(&v25, 8);
  _Block_object_dispose(&v29, 8);
  return v6;
}

uint64_t sub_1000470F4(_QWORD *a1, sqlite3_stmt *a2)
{
  *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = sub_100019D18(*(_QWORD *)(a1[6] + 8), a2, (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24), 0);
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

uint64_t sub_100047140(_QWORD *a1, sqlite3_stmt *a2)
{
  *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = sub_100019D18(*(_QWORD *)(a1[6] + 8), a2, (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24), 0);
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

BOOL sub_10004718C()
{
  NSObject *v0;
  dispatch_time_t v1;
  NSObject *global_queue;
  _BOOL8 v3;
  uint8_t v5[8];
  _QWORD v6[5];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  char v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 0;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = sub_100047624;
  v6[3] = &unk_1000783E8;
  v6[4] = &v7;
  sub_1000352AC((uint64_t)CFSTR(".valid_replace"), v6);
  if (*((_BYTE *)v8 + 24))
  {
    v0 = sub_100011628("validupdate");
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "process exiting to replace db file", v5, 2u);
    }
    v1 = dispatch_time(0, 3000000000);
    global_queue = dispatch_get_global_queue(0, 0);
    dispatch_after(v1, global_queue, &stru_100078428);
    v3 = *((_BYTE *)v8 + 24) != 0;
  }
  else
  {
    v3 = 0;
  }
  _Block_object_dispose(&v7, 8);
  return v3;
}

uint64_t sub_1000472B0(_QWORD *a1, sqlite3_stmt *a2)
{
  *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = sub_100019D18(*(_QWORD *)(a1[6] + 8), a2, (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24), 0);
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

uint64_t sub_1000472FC(_QWORD *a1)
{
  uint64_t v2;
  int v3;
  _BOOL8 v4;
  NSObject *v5;
  uint64_t v6;
  __CFError *v7;
  CFIndex Code;
  const void *v9;
  _QWORD v11[8];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  CFTypeRef v19;
  uint8_t buf[4];
  uint64_t v21;

  if (!a1 || (uint64_t)a1[3] <= 6)
  {
    v16 = 0;
    v17 = &v16;
    v18 = 0x2000000000;
    v19 = 0;
    v12 = 0;
    v13 = &v12;
    v14 = 0x2000000000;
    v15 = a1 != 0;
    if (a1)
    {
      v2 = a1[1];
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 0x40000000;
      v11[2] = sub_1000474E4;
      v11[3] = &unk_100078708;
      v11[4] = &v12;
      v11[5] = &v16;
      v11[6] = 7;
      v11[7] = a1;
      v3 = sub_10001979C(v2, CFSTR("INSERT OR REPLACE INTO admin (key,ival,value) VALUES (?,?,?)"), &v19, (uint64_t)v11);
      *((_BYTE *)v13 + 24) = v3;
      if (v3 && !v17[3])
      {
        *(_WORD *)(*a1 + 17) = 256;
        a1[3] = 7;
        atomic_store(7uLL, &qword_100082920);
LABEL_16:
        v4 = *((_BYTE *)v13 + 24) != 0;
        _Block_object_dispose(&v12, 8);
        _Block_object_dispose(&v16, 8);
        return v4;
      }
    }
    else
    {
      v15 = 0;
    }
    v5 = sub_100011628("SecError");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = v17[3];
      *(_DWORD *)buf = 138412290;
      v21 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbSetSchemaVersion failed: %@", buf, 0xCu);
    }
    v7 = (__CFError *)v17[3];
    if (v7)
      Code = CFErrorGetCode(v7);
    else
      Code = -2070;
    sub_1000521A8(1, 2, Code);
    v9 = (const void *)v17[3];
    if (v9)
      CFRelease(v9);
    goto LABEL_16;
  }
  return 1;
}

uint64_t sub_1000474E4(_QWORD *a1, sqlite3_stmt *a2)
{
  uint64_t v4;
  CFTypeRef *v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  CFTypeRef *v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  char v13;

  v4 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v4 + 24))
  {
    v5 = (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24);
    v6 = sqlite3_bind_text(a2, 1, "db_version", 10, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
    v7 = sub_10001A970(v6, a2, v5, CFSTR("bind_text[%d]"), 1);
    v4 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v7 = 0;
  }
  *(_BYTE *)(v4 + 24) = v7;
  v8 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v8 + 24))
  {
    v9 = (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24);
    v10 = sqlite3_bind_int64(a2, 2, a1[6]);
    v11 = sub_10001A970(v10, a2, v9, CFSTR("bind_int64[%d]"), 2);
    v8 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v11 = 0;
  }
  *(_BYTE *)(v8 + 24) = v11;
  v12 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v12 + 24))
  {
    v13 = sub_100019D18(*(_QWORD *)(a1[7] + 8), a2, (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24), 0);
    v12 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v13 = 0;
  }
  *(_BYTE *)(v12 + 24) = v13;
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

void sub_100047624(uint64_t a1, char *a2)
{
  timespec v4;
  int v5;
  int v6;
  NSObject *v7;
  int v8;
  NSObject *v9;
  CFTypeRef v10;
  CFTypeRef cf;
  stat v12;
  uint8_t buf[4];
  char *v14;
  __int16 v15;
  int v16;

  v4.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v4.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)v12.st_qspare = v4;
  *(timespec *)&v12.st_size = v4;
  *(timespec *)&v12.st_blksize = v4;
  v12.st_ctimespec = v4;
  v12.st_birthtimespec = v4;
  v12.st_atimespec = v4;
  v12.st_mtimespec = v4;
  *(timespec *)&v12.st_dev = v4;
  *(timespec *)&v12.st_uid = v4;
  v5 = open(a2, 513, 438);
  v6 = v5;
  if (v5 != -1 && !fstat(v5, &v12))
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
    if (v6 < 0)
      return;
    goto LABEL_6;
  }
  v7 = sub_100011628("validupdate");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    v8 = *__error();
    *(_DWORD *)buf = 136315394;
    v14 = a2;
    v15 = 1024;
    v16 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "unable to write %s (error %d)", buf, 0x12u);
  }
  if ((v6 & 0x80000000) == 0)
  {
LABEL_6:
    cf = 0;
    if (!sub_100034EC8(a2, &cf))
    {
      v9 = sub_100011628("SecError");
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v14 = (char *)cf;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "failed to change replace valid db flag protection class: %@", buf, 0xCu);
      }
      v10 = cf;
      if (cf)
      {
        cf = 0;
        CFRelease(v10);
      }
    }
    close(v6);
  }
}

void sub_1000477D8(id a1, int a2)
{
  NSObject *v2;
  uint8_t v3[16];

  v2 = sub_100011628("validupdate");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Got notification of database change", v3, 2u);
  }
  sub_100016C6C((uint64_t)&stru_100078560);
}

void sub_100047848(id a1, __SecRevocationDb *a2)
{
  *(_WORD *)&a2->var3 = 0;
  sub_100018D8C((uint64_t *)a2, 0, (uint64_t)&stru_1000785A0);
  sub_100047880((uint64_t)a2);
}

void sub_100047880(uint64_t a1)
{
  if (a1 && *(_QWORD *)(a1 + 32))
  {
    if (*(_QWORD *)(a1 + 24))
    {
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 40));
      CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 24));
      CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 32));
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 40));
    }
  }
}

BOOL sub_1000478DC(id a1, __SecRevocationDbConnection *a2, __CFError **a3)
{
  atomic_store(sub_10001AEFC((uint64_t)a2, a3), &qword_100082920);
  return 1;
}

sqlite3_int64 sub_100047908(uint64_t a1, _BYTE *a2)
{
  sqlite3_int64 result;

  result = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  *a2 = 1;
  return result;
}

uint64_t sub_100047948(uint64_t a1, _BYTE *a2)
{
  uint64_t v4;
  uint64_t result;

  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v4 + 24))
  {
    result = sub_1000279E0(*(_QWORD *)(a1 + 40), CFSTR("CREATE TABLE IF NOT EXISTS admin(key TEXT PRIMARY KEY NOT NULL,ival INTEGER NOT NULL,value BLOB);CREATE TABLE IF NOT EXISTS issuers(groupid INTEGER NOT NULL,issuer_hash BLOB PRIMARY KEY NOT NULL);CREATE INDEX IF NOT EXISTS issuer_idx ON issuers(issuer_hash);CREATE TABLE IF NOT EXISTS groups(groupid INTEGER PRIMARY KEY AUTOINCREMENT,flags INTEGER,format INTEGER,data BLOB,policies BLOB);CREATE TABLE IF NOT EXISTS serials(groupid INTEGER NOT NULL,serial BLOB NOT NULL,UNIQUE(groupid,serial));CREATE TABLE IF NOT EXISTS hashes(groupid INTEGER NOT NULL,sha256 BLOB NOT NULL,UNIQUE(groupid,sha256));CREATE TABLE IF NOT EXISTS dates(groupid INTEGER PRIMARY KEY NOT NULL,notbefore REAL,notafter REAL);CREATE TRIGGER IF NOT EXISTS group_del BEFORE DELETE ON groups FOR EACH ROW BEGIN DELETE FROM serials WHERE groupid=OLD.groupid; DELETE FROM hashes WHERE groupid=OLD.groupid; DELETE FROM issuers WHERE groupid=OLD.groupid; DELETE FROM dates WHERE groupid=OLD.groupid; END;"),
               *(CFTypeRef **)(a1 + 48));
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  else
  {
    result = 0;
  }
  *(_BYTE *)(v4 + 24) = result;
  *a2 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t sub_1000479AC(uint64_t a1, uint64_t a2, CFErrorRef *a3)
{
  __CFString **v3;
  uint64_t v6;
  char v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  const __CFData *v11;
  const UInt8 *BytePtr;
  unsigned int *v13;
  unint64_t Length;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  NSObject *v18;
  NSObject *v19;
  char v20;
  char v21;
  NSObject *v22;
  __CFString *v23;
  unsigned int v25;
  int v26;
  unsigned int *v27;
  const __CFAllocator *v28;
  unsigned int v29;
  const UInt8 *v30;
  unsigned int v31;
  unint64_t v32;
  unsigned int v33;
  const __CFData *v35;
  CFPropertyListRef v36;
  CFTypeID v37;
  const __CFNumber *v38;
  const __CFNumber *v39;
  CFTypeID v40;
  int64_t v41;
  char v42;
  unsigned int v43;
  char v44;
  NSObject *v45;
  const void *Value;
  CFTypeID v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  const __CFBoolean *v51;
  const __CFBoolean *v52;
  CFTypeID v53;
  const __CFDictionary *v54;
  const __CFArray *v55;
  const __CFArray *v56;
  CFTypeID v57;
  CFIndex v58;
  const __CFData *ValueAtIndex;
  const __CFData *v60;
  CFTypeID v61;
  CFTypeID TypeID;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  NSObject *v68;
  uint64_t v69;
  __CFError *v70;
  CFIndex Code;
  const void *v72;
  const __CFArray *v73;
  const __CFArray *v74;
  CFTypeID v75;
  CFIndex v76;
  const __CFDictionary *v77;
  CFTypeID v78;
  CFTypeID v79;
  uint64_t v80;
  const __CFDictionary *v81;
  const __CFArray *v82;
  const __CFArray *v83;
  uint64_t *v84;
  CFTypeID v85;
  CFIndex v86;
  CFIndex v87;
  CFIndex i;
  const __CFData *v89;
  uint64_t v90;
  uint64_t v91;
  char v92;
  uint64_t v93;
  CFTypeRef *v94;
  int v95;
  const __CFString *v96;
  const __CFString *v97;
  uint64_t v98;
  CFTypeID v99;
  int v100;
  int v101;
  BOOL v102;
  char v103;
  uint64_t v104;
  uint64_t v105;
  char v106;
  uint64_t v107;
  char v108;
  const void *v109;
  const void *v110;
  NSObject *v111;
  uint64_t v112;
  __CFError *v113;
  CFIndex v114;
  const void *v115;
  const __CFArray *v116;
  CFTypeID v117;
  CFIndex v118;
  CFIndex v119;
  CFIndex j;
  const __CFData *v121;
  const __CFData *v122;
  uint64_t v123;
  uint64_t v124;
  char v125;
  NSObject *v126;
  uint64_t v127;
  __CFError *v128;
  CFIndex v129;
  int v130;
  CFTypeRef v131;
  const void *v132;
  int v133;
  const __CFArray *v134;
  const __CFArray *v135;
  CFTypeID v136;
  CFIndex v137;
  int v138;
  const __CFData *v139;
  const __CFData *v140;
  const __CFString *v141;
  uint64_t v142;
  char v143;
  const __CFArray *v144;
  const __CFArray *v145;
  CFTypeID v146;
  CFIndex v147;
  int v148;
  const __CFData *v149;
  const __CFData *v150;
  const __CFString *v151;
  uint64_t v152;
  char v153;
  NSObject *v154;
  uint64_t v155;
  __CFError *v156;
  CFIndex v157;
  const void *v158;
  const void *v159;
  const __CFDate *v160;
  CFTypeID v161;
  CFAbsoluteTime AbsoluteTime;
  CFTypeID v163;
  CFAbsoluteTime v164;
  uint64_t v165;
  char v166;
  char v167;
  CFAbsoluteTime v168;
  CFAbsoluteTime v169;
  uint64_t v170;
  int v171;
  NSObject *v172;
  __CFError *v173;
  CFIndex v174;
  const void *v175;
  const __CFArray *v176;
  const __CFArray *v177;
  CFTypeID v178;
  const __CFData *v179;
  CFIndex v180;
  uint64_t v181;
  uint64_t v182;
  NSObject *v183;
  __CFError *v184;
  CFIndex v185;
  const void *v186;
  const char *v187;
  uint64_t v188;
  const char *v189;
  uint64_t v190;
  NSObject *v191;
  uint64_t v192;
  int v193;
  NSObject *v194;
  uint64_t v195;
  __CFError *v196;
  CFIndex v197;
  _BOOL4 v198;
  const void *v199;
  int v200;
  uint64_t v201;
  int v202;
  NSObject *v203;
  uint64_t v204;
  __CFError *v205;
  CFIndex v206;
  const void *v207;
  uint64_t v208;
  uint64_t v209;
  _BOOL4 v210;
  uint64_t v211;
  BOOL v212;
  uint64_t v213;
  uint64_t v214;
  int v215;
  NSObject *v216;
  uint64_t v217;
  __CFError *v218;
  CFIndex v219;
  const void *v220;
  unint64_t v221;
  uint64_t v222;
  int v223;
  BOOL v224;
  uint64_t v225;
  char v226;
  const __CFNumber *v227;
  const __CFNumber *v228;
  CFTypeID v229;
  __int128 *v230;
  uint64_t v231;
  __CFString *v232;
  NSObject *v233;
  CFTypeRef *v234;
  CFTypeRef *v235;
  CFIndex v236;
  CFIndex v237;
  CFTypeRef *v238;
  __int128 *v239;
  __CFString **v240;
  const __CFArray *v241;
  const __CFArray *v242;
  __int128 *v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  unsigned int v247;
  unsigned int v248;
  const __CFArray *theArray;
  const __CFDictionary *theArraya;
  uint64_t v251;
  __CFString *v252;
  int64_t v253;
  int v254;
  char v255;
  CFIndex Count;
  CFIndex v257;
  CFTypeRef cf;
  unint64_t v259;
  int v260;
  uint64_t v261;
  __CFString *v262;
  uint64_t valuePtr;
  CFTypeRef v264;
  void **v265;
  uint64_t v266;
  uint64_t v267;
  void *v268;
  uint64_t *v269;
  uint64_t *v270;
  uint64_t *v271;
  uint64_t v272;
  uint64_t v273;
  CFTypeRef *v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t *v278;
  uint64_t v279;
  char v280;
  uint64_t v281;
  uint64_t *v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t *v286;
  uint64_t v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t *v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t *v294;
  uint64_t v295;
  int v296;
  uint64_t v297;
  uint64_t *v298;
  uint64_t v299;
  int v300;
  _QWORD v301[3];
  uint64_t v302;
  void **v303;
  uint64_t v304;
  uint64_t v305;
  uint64_t v306;
  __int128 *v307;
  __int128 *v308;
  uint64_t v309;
  uint64_t v310;
  uint64_t v311;
  uint8_t v312[4];
  uint64_t v313;
  _BYTE buf[24];
  void *v315;
  void ***v316;
  void ***v317;
  __int128 *v318;
  _BYTE *v319;
  uint64_t *v320;
  uint64_t *v321;
  uint64_t *v322;
  uint64_t *v323;
  __int128 *v324;
  uint64_t v325;
  const __CFDictionary *v326;
  uint64_t v327;
  _BYTE v328[24];
  uint64_t v329;
  _BYTE v330[24];
  uint64_t v331;
  __int128 v332;
  uint64_t v333;
  const __CFArray *v334;
  __int128 v335;
  uint64_t v336;
  uint64_t v337;

  v3 = (__CFString **)a3;
  if (*(_BYTE *)(a1 + 64))
  {
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    if (*(_BYTE *)(v6 + 24))
    {
      v7 = sub_10004C5D4((_QWORD *)a2, a3);
      v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    }
    else
    {
      v7 = 0;
    }
    *(_BYTE *)(v6 + 24) = v7;
    v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    if (*(_BYTE *)(v9 + 24))
    {
      v10 = sub_10004C77C(a2, *(CFStringRef *)(a1 + 40), v3);
      v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    }
    else
    {
      v10 = 0;
    }
    v8 = 0;
    *(_BYTE *)(v9 + 24) = v10;
    *(_QWORD *)(a2 + 16) = 0;
    *(_BYTE *)(a2 + 40) = 1;
  }
  else
  {
    v8 = *(_QWORD *)(a2 + 16);
  }
  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    goto LABEL_23;
  v11 = *(const __CFData **)(a1 + 48);
  if (!v11)
  {
    sub_100012C88(-50, v3, CFSTR("SecValidUpdateProcessData: invalid update format"));
LABEL_23:
    v20 = 0;
    goto LABEL_24;
  }
  v261 = 0;
  BytePtr = CFDataGetBytePtr(v11);
  if (!BytePtr)
  {
    v15 = 0;
    goto LABEL_20;
  }
  v13 = (unsigned int *)BytePtr;
  Length = CFDataGetLength(v11);
  v15 = Length;
  if (Length <= 7)
  {
LABEL_20:
    v19 = sub_100011628("validupdate");
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = v15;
      _os_log_debug_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "Skipping property list creation (length %ld is too short)", buf, 0xCu);
    }
    sub_100012C88(-50, v3, CFSTR("SecValidUpdateProcessData: data length is too short"));
    goto LABEL_23;
  }
  v16 = bswap32(*v13);
  v17 = Length - 8;
  if (Length - 8 < v16)
  {
    v18 = sub_100011628("validupdate");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134218240;
      *(_QWORD *)&buf[4] = v16;
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v15 - 8;
      _os_log_debug_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "Skipping property list creation (dataLength=%ld, bytesRemaining=%ld)", buf, 0x16u);
    }
    sub_100012C88(-50, v3, CFSTR("SecValidUpdateProcessData: data longer than expected"));
    goto LABEL_23;
  }
  v20 = 0;
  if (Length != 8)
  {
    v25 = v13[1];
    if (v25)
    {
      v246 = v8;
      v251 = 0;
      v252 = 0;
      v254 = 0;
      v253 = 0;
      v26 = 0;
      v27 = v13 + 2;
      v28 = kCFAllocatorNull;
      v255 = 1;
      v247 = bswap32(v25);
      v29 = v247;
      while (1)
      {
        v31 = *v27;
        v30 = (const UInt8 *)(v27 + 1);
        v32 = bswap32(v31);
        v33 = v29 - 1;
        v260 = v26 + 1;
        v259 = v17 - 4;
        if (v32 > 0x7FFFFFFE || v17 - 4 < v32)
          goto LABEL_57;
        v35 = CFDataCreateWithBytesNoCopy(0, v30, v32, v28);
        v36 = CFPropertyListCreateWithData(0, v35, 0, 0, 0);
        if (v35)
          CFRelease(v35);
        if (!v36)
        {
LABEL_57:
          v43 = v33;
          cf = 0;
          v44 = 1;
          goto LABEL_58;
        }
        v37 = CFGetTypeID(v36);
        cf = v36;
        if (v37 != CFDictionaryGetTypeID())
        {
          v43 = v33;
          v44 = 0;
LABEL_58:
          v45 = sub_100011628("validupdate");
          if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 67109376;
            *(_DWORD *)&buf[4] = v26 + 1;
            *(_WORD *)&buf[8] = 1024;
            *(_DWORD *)&buf[10] = v247;
            _os_log_debug_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEBUG, "Failed to deserialize update chunk %u of %u", buf, 0xEu);
          }
          sub_100012C88(-50, v3, CFSTR("SecValidUpdateProcessData: failed to get update chunk"));
          if (!v26)
            qword_100082E00 = sub_10004CCFC(0);
          if ((v44 & 1) != 0)
            goto LABEL_415;
          goto LABEL_414;
        }
        if (v26)
        {
          if ((v255 & 1) == 0)
            goto LABEL_70;
        }
        else
        {
          v303 = 0;
          Value = CFDictionaryGetValue((CFDictionaryRef)v36, CFSTR("generation"));
          v251 = sub_10004ED44();
          if (!Value
            || (v47 = CFGetTypeID(Value), v47 != CFNumberGetTypeID())
            || !CFNumberGetValue((CFNumberRef)Value, kCFNumberCFIndexType, &v303)
            || (void **)v251 != v303)
          {
            v233 = sub_100011628("validupdate");
            if (os_log_type_enabled(v233, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 134218240;
              *(_QWORD *)&buf[4] = v303;
              *(_WORD *)&buf[12] = 2048;
              *(_QWORD *)&buf[14] = v251;
              _os_log_impl((void *)&_mh_execute_header, v233, OS_LOG_TYPE_DEFAULT, "valid generation received %ld is different from requested %ld", buf, 0x16u);
            }
            CFRelease(cf);
            v20 = 1;
            v8 = v246;
            goto LABEL_24;
          }
          if ((v255 & 1) == 0)
          {
LABEL_70:
            v42 = 0;
            v48 = -1;
            if (!v26)
              goto LABEL_400;
            goto LABEL_71;
          }
        }
        v248 = v33;
        v262 = 0;
        valuePtr = 0;
        v38 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v36, CFSTR("version"));
        if (!v38
          || (v39 = v38, v40 = CFGetTypeID(v38), v40 != CFNumberGetTypeID())
          || !CFNumberGetValue(v39, kCFNumberCFIndexType, &valuePtr)
          || (v41 = valuePtr) == 0)
        {
          valuePtr = v253;
          v41 = v253;
        }
        if (v253 <= 0 && v41 <= *(_QWORD *)(a2 + 16))
        {
          valuePtr = -1;
          v42 = 1;
          goto LABEL_395;
        }
        if (*(_QWORD *)a2)
          break;
        v191 = sub_100011628("SecError");
        if (os_log_type_enabled(v191, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v191, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbApplyUpdate failed: invalid args", buf, 2u);
        }
        sub_100012C88(-50, &v262, CFSTR("_SecRevocationDbApplyUpdate: invalid db or update parameter"));
        v42 = 0;
LABEL_395:
        v48 = valuePtr;
        if (v262)
        {
          if (v252)
            CFRelease(v262);
          else
            v252 = v262;
        }
        v36 = cf;
        if (!v26)
        {
LABEL_400:
          *(_QWORD *)(a2 + 16) = v48;
          v227 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v36, CFSTR("check-again"));
          if (v227)
          {
            v228 = v227;
            v229 = CFGetTypeID(v227);
            if (v229 == CFNumberGetTypeID())
              CFNumberGetValue(v228, kCFNumberCFIndexType, &v261);
          }
          v230 = (__int128 *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("hash"));
          v303 = 0;
          v304 = (uint64_t)&v303;
          v305 = 0x2000000000;
          v306 = 0;
          v265 = 0;
          v266 = (uint64_t)&v265;
          v267 = 0x2000000000;
          LOBYTE(v268) = v230 != 0;
          v49 = v254;
          if (v230)
          {
            v231 = *(_QWORD *)(a2 + 8);
            *(_QWORD *)buf = _NSConcreteStackBlock;
            *(_QWORD *)&buf[8] = 0x40000000;
            *(_QWORD *)&buf[16] = sub_10004CABC;
            v315 = &unk_1000783C0;
            v316 = &v265;
            v317 = &v303;
            v318 = v230;
            v319 = (_BYTE *)a2;
            v42 = sub_10001979C(v231, CFSTR("INSERT OR REPLACE INTO admin (key,ival,value) VALUES (?,?,?)"), (CFTypeRef *)&v306, (uint64_t)buf);
            v232 = *(__CFString **)(v304 + 24);
            *(_BYTE *)(v266 + 24) = v42;
            if (v232)
            {
              if (v252)
              {
                CFRelease(v232);
                v42 = *(_BYTE *)(v266 + 24) != 0;
              }
              else
              {
                v252 = v232;
              }
            }
          }
          else
          {
            v42 = 0;
            LOBYTE(v268) = 0;
          }
          _Block_object_dispose(&v265, 8);
          _Block_object_dispose(&v303, 8);
          v253 = v48;
          goto LABEL_410;
        }
LABEL_71:
        v49 = v254;
LABEL_410:
        if ((v42 & (v48 < 0)) != 0)
          v43 = 0;
        else
          v43 = v33;
        v254 = v42 & (v48 < 0) | v49;
        v255 = v42;
        v28 = kCFAllocatorNull;
LABEL_414:
        CFRelease(cf);
LABEL_415:
        v17 = v259 - v32;
        if (v259 != v32)
        {
          v29 = v43;
          v27 = (unsigned int *)&v30[v32];
          v26 = v260;
          if (v43)
            continue;
        }
        v20 = v254;
        if ((v255 & (v253 > 0)) == 1)
        {
          atomic_store(v253, &qword_100082E28);
          qword_100082E00 = sub_10004CCFC(v261);
          v20 = 1;
        }
        v8 = v246;
        if (v252)
        {
          if (v3 && !*v3)
            *v3 = v252;
          else
            CFRelease(v252);
        }
        goto LABEL_24;
      }
      v239 = (__int128 *)v41;
      CFRetain(cf);
      v264 = 0;
      v50 = 1;
      *(_BYTE *)(*(_QWORD *)a2 + 16) = 1;
      v51 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("full"));
      if (v51)
      {
        v52 = v51;
        v53 = CFGetTypeID(v51);
        if (v53 == CFBooleanGetTypeID())
        {
          if (CFBooleanGetValue(v52))
          {
            *(_BYTE *)(a2 + 40) = 1;
            v50 = sub_10004C5D4((_QWORD *)a2, (CFErrorRef *)&v264);
          }
        }
      }
      v54 = (const __CFDictionary *)cf;
      v55 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("delete"));
      v240 = v3;
      if (v55)
      {
        v56 = v55;
        v57 = CFGetTypeID(v55);
        if (v57 == CFArrayGetTypeID())
        {
          Count = CFArrayGetCount(v56);
          if (Count >= 1)
          {
            theArray = v56;
            v58 = 0;
            while (1)
            {
              ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(theArray, v58);
              if (ValueAtIndex)
              {
                v60 = ValueAtIndex;
                v61 = CFGetTypeID(ValueAtIndex);
                TypeID = CFDataGetTypeID();
                v63 = (v61 != TypeID) & v50;
                if (v61 == TypeID)
                {
                  v54 = (const __CFDictionary *)cf;
                  if (((v50 ^ 1) & 1) == 0)
                  {
                    v303 = 0;
                    v304 = (uint64_t)&v303;
                    v305 = 0x2000000000;
                    v306 = -1;
                    v265 = 0;
                    v266 = (uint64_t)&v265;
                    v267 = 0x2000000000;
                    LOBYTE(v268) = 1;
                    *(_QWORD *)&v335 = 0;
                    *((_QWORD *)&v335 + 1) = &v335;
                    v336 = 0x2000000000;
                    v337 = 0;
                    v64 = sub_10001ABF0((_QWORD *)a2, v60, &v337);
                    *(_QWORD *)(v304 + 24) = v64;
                    if (v64 < 0)
                    {
                      if (!*(_QWORD *)(*((_QWORD *)&v335 + 1) + 24))
                        sub_100012C88(-50, (__CFString **)(*((_QWORD *)&v335 + 1) + 24), CFSTR("group not found for issuer"));
                      v65 = v266;
                      *(_BYTE *)(v266 + 24) = 0;
                    }
                    else
                    {
                      v65 = v266;
                      if (*(_BYTE *)(v266 + 24))
                      {
                        v66 = *(_QWORD *)(a2 + 8);
                        *(_QWORD *)buf = _NSConcreteStackBlock;
                        *(_QWORD *)&buf[8] = 0x40000000;
                        *(_QWORD *)&buf[16] = sub_10004CDF8;
                        v315 = &unk_100078758;
                        v316 = &v265;
                        v317 = &v303;
                        v318 = &v335;
                        v319 = (_BYTE *)a2;
                        v67 = sub_10001979C(v66, CFSTR("DELETE FROM groups WHERE groupid=?"), (CFTypeRef *)(*((_QWORD *)&v335 + 1) + 24), (uint64_t)buf);
                        *(_BYTE *)(v266 + 24) = v67;
                        if (v67 && !*(_QWORD *)(*((_QWORD *)&v335 + 1) + 24))
                        {
LABEL_104:
                          v63 = *(_BYTE *)(v266 + 24) != 0;
                          _Block_object_dispose(&v335, 8);
                          _Block_object_dispose(&v265, 8);
                          _Block_object_dispose(&v303, 8);
                          goto LABEL_105;
                        }
LABEL_95:
                        v68 = sub_100011628("SecError");
                        if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
                        {
                          v69 = *(_QWORD *)(*((_QWORD *)&v335 + 1) + 24);
                          LODWORD(v332) = 138412290;
                          *(_QWORD *)((char *)&v332 + 4) = v69;
                          _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbApplyGroupDelete failed: %@", (uint8_t *)&v332, 0xCu);
                        }
                        v70 = *(__CFError **)(*((_QWORD *)&v335 + 1) + 24);
                        if (v70)
                          Code = CFErrorGetCode(v70);
                        else
                          Code = -2070;
                        sub_1000521A8(1, 2, Code);
                        v72 = *(const void **)(*((_QWORD *)&v335 + 1) + 24);
                        if (v72)
                        {
                          if (v264)
                            CFRelease(v72);
                          else
                            v264 = *(CFTypeRef *)(*((_QWORD *)&v335 + 1) + 24);
                        }
                        goto LABEL_104;
                      }
                    }
                    *(_BYTE *)(v65 + 24) = 0;
                    goto LABEL_95;
                  }
                }
                else
                {
                  v54 = (const __CFDictionary *)cf;
                }
              }
              else
              {
                v63 = v50;
              }
LABEL_105:
              ++v58;
              v50 = v63;
              if (Count == v58)
                goto LABEL_108;
            }
          }
        }
      }
      v63 = v50;
LABEL_108:
      v73 = (const __CFArray *)CFDictionaryGetValue(v54, CFSTR("update"));
      if (v73)
      {
        v74 = v73;
        v75 = CFGetTypeID(v73);
        if (v75 == CFArrayGetTypeID())
        {
          v257 = CFArrayGetCount(v74);
          if (v257 >= 1)
          {
            v76 = 0;
            v241 = v74;
            while (1)
            {
              v77 = (const __CFDictionary *)CFArrayGetValueAtIndex(v74, v76);
              if (v77)
              {
                theArraya = v77;
                v78 = CFGetTypeID(v77);
                v79 = CFDictionaryGetTypeID();
                v80 = (v78 != v79) & v63;
                if (v78 == v79 && ((v63 ^ 1) & 1) == 0)
                {
                  v281 = 0;
                  v282 = &v281;
                  v283 = 0x2000000000;
                  v284 = -1;
                  v277 = 0;
                  v278 = &v277;
                  v279 = 0x2000000000;
                  v280 = 1;
                  v273 = 0;
                  v274 = (CFTypeRef *)&v273;
                  v275 = 0x2000000000;
                  v276 = 0;
                  v81 = theArraya;
                  v82 = (const __CFArray *)CFDictionaryGetValue(theArraya, CFSTR("issuer-hash"));
                  v83 = v82;
                  v84 = v278;
                  if (*((_BYTE *)v278 + 24) && v82)
                  {
                    v85 = CFGetTypeID(v82);
                    if (v85 == CFArrayGetTypeID())
                    {
                      v86 = CFArrayGetCount(v83);
                      if (v86 >= 1)
                      {
                        v87 = v86;
                        for (i = 0; i != v87; ++i)
                        {
                          if ((v282[3] & 0x8000000000000000) == 0)
                            break;
                          v89 = (const __CFData *)CFArrayGetValueAtIndex(v83, i);
                          if (v89)
                          {
                            v90 = sub_10001ABF0((_QWORD *)a2, v89, v274 + 3);
                            v282[3] = v90;
                          }
                        }
                      }
                      v84 = v278;
                      if (v282[3] < 0)
                      {
                        v74 = v241;
                      }
                      else
                      {
                        v74 = v241;
                        if (*((_BYTE *)v278 + 24))
                        {
                          v91 = *(_QWORD *)(a2 + 8);
                          v265 = _NSConcreteStackBlock;
                          v266 = 0x40000000;
                          v267 = (uint64_t)sub_10004CEC8;
                          v268 = &unk_100078780;
                          v269 = &v277;
                          v270 = &v281;
                          v271 = &v273;
                          v272 = a2;
                          v92 = sub_10001979C(v91, CFSTR("DELETE FROM issuers WHERE groupid=?"), v274 + 3, (uint64_t)&v265);
                          v84 = v278;
                        }
                        else
                        {
                          v92 = 0;
                        }
                        *((_BYTE *)v84 + 24) = v92;
                      }
                    }
                    else
                    {
                      v84 = v278;
                    }
                  }
                  v93 = v282[3];
                  if (*((_BYTE *)v84 + 24))
                  {
                    v242 = v83;
                    v94 = v274;
                    *(_QWORD *)&v335 = 0;
                    *((_QWORD *)&v335 + 1) = &v335;
                    v336 = 0x2000000000;
                    v337 = -1;
                    *(_QWORD *)&v332 = 0;
                    *((_QWORD *)&v332 + 1) = &v332;
                    v333 = 0x2000000000;
                    LOBYTE(v334) = 1;
                    *(_QWORD *)v330 = 0;
                    *(_QWORD *)&v330[8] = v330;
                    *(_QWORD *)&v330[16] = 0x2000000000;
                    LOBYTE(v331) = 0;
                    *(_QWORD *)v328 = 0;
                    *(_QWORD *)&v328[8] = v328;
                    *(_QWORD *)&v328[16] = 0x2000000000;
                    v329 = 0;
                    v301[0] = 0;
                    v301[1] = v301;
                    v301[2] = 0x2000000000;
                    v302 = 0;
                    v297 = 0;
                    v298 = &v297;
                    v299 = 0x2000000000;
                    v300 = 0;
                    v293 = 0;
                    v294 = &v293;
                    v295 = 0x2000000000;
                    v296 = 0;
                    v289 = 0;
                    v290 = &v289;
                    v291 = 0x2000000000;
                    v292 = 0;
                    v285 = 0;
                    v286 = &v285;
                    v287 = 0x2000000000;
                    v288 = 0;
                    if (v93 < 0
                      || (v95 = sub_10001B964(a2, v93, (uint64_t)&v302, (uint64_t)&v292, (uint64_t)&v288, 0),
                          (*((_DWORD *)v298 + 6) = v95) != 0))
                    {
                      v96 = (const __CFString *)CFDictionaryGetValue(theArraya, CFSTR("format"));
                      if (v96)
                      {
                        v97 = v96;
                        v98 = v93;
                        v99 = CFGetTypeID(v96);
                        v102 = v99 == CFStringGetTypeID();
                        v93 = v98;
                        v81 = theArraya;
                        if (v102)
                        {
                          if (CFStringCompare(v97, CFSTR("serial"), 0))
                          {
                            if (CFStringCompare(v97, CFSTR("sha256"), 0))
                            {
                              if (CFStringCompare(v97, CFSTR("nto1"), 0))
                                goto LABEL_146;
                              v100 = 3;
                            }
                            else
                            {
                              v100 = 2;
                            }
                          }
                          else
                          {
                            v100 = 1;
                          }
                          *((_DWORD *)v294 + 6) = v100;
                        }
                      }
LABEL_146:
                      v101 = *((_DWORD *)v294 + 6);
                      if (v101)
                      {
                        v102 = v93 < 0 || v101 == *((_DWORD *)v298 + 6);
                        v103 = !v102;
                        *(_BYTE *)(*(_QWORD *)&v330[8] + 24) = v103;
                        v104 = *((_QWORD *)&v332 + 1);
                        v74 = v241;
                        if (!v102)
                        {
                          if (*(_BYTE *)(*((_QWORD *)&v332 + 1) + 24))
                          {
                            v105 = *(_QWORD *)(a2 + 8);
                            v303 = _NSConcreteStackBlock;
                            v304 = 0x40000000;
                            v305 = (uint64_t)sub_10004CFA4;
                            v306 = (uint64_t)&unk_1000787A8;
                            v307 = &v332;
                            v308 = (__int128 *)v328;
                            v309 = v93;
                            v310 = a2;
                            v106 = sub_10001979C(v105, CFSTR("DELETE FROM groups WHERE groupid=?"), (CFTypeRef *)(*(_QWORD *)&v328[8] + 24), (uint64_t)&v303);
                            v104 = *((_QWORD *)&v332 + 1);
                          }
                          else
                          {
                            v106 = 0;
                          }
                          *(_BYTE *)(v104 + 24) = v106;
                        }
                      }
                      else
                      {
                        *(_BYTE *)(*(_QWORD *)&v330[8] + 24) = 0;
                        v104 = *((_QWORD *)&v332 + 1);
                        v74 = v241;
                      }
                      if (*(_BYTE *)(v104 + 24))
                      {
                        v107 = *(_QWORD *)(a2 + 8);
                        *(_QWORD *)buf = _NSConcreteStackBlock;
                        *(_QWORD *)&buf[8] = 0x40000000;
                        *(_QWORD *)&buf[16] = sub_10004D07C;
                        v315 = &unk_1000787D0;
                        v316 = (void ***)&v332;
                        v317 = (void ***)v330;
                        v318 = (__int128 *)v328;
                        v319 = v301;
                        v320 = &v297;
                        v321 = &v293;
                        v322 = &v289;
                        v323 = &v285;
                        v326 = v81;
                        v327 = a2;
                        v325 = v93;
                        v324 = &v335;
                        v108 = sub_10001979C(v107, CFSTR("INSERT OR REPLACE INTO groups (groupid,flags,format,data,policies) VALUES (?,?,?,?,?)"), (CFTypeRef *)(*(_QWORD *)&v328[8] + 24), (uint64_t)buf);
                        v104 = *((_QWORD *)&v332 + 1);
                      }
                      else
                      {
                        v108 = 0;
                      }
                      *(_BYTE *)(v104 + 24) = v108;
                      v109 = (const void *)v290[3];
                      if (v109)
                        CFRelease(v109);
                      v110 = (const void *)v286[3];
                      if (v110)
                        CFRelease(v110);
                      if (!*(_BYTE *)(*((_QWORD *)&v332 + 1) + 24) || *(_QWORD *)(*(_QWORD *)&v328[8] + 24))
                      {
                        v111 = sub_100011628("SecError");
                        if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
                        {
                          v112 = *(_QWORD *)(*(_QWORD *)&v328[8] + 24);
                          *(_DWORD *)v312 = 138412290;
                          v313 = v112;
                          _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbUpdateGroup failed: %@", v312, 0xCu);
                        }
                        v113 = *(__CFError **)(*(_QWORD *)&v328[8] + 24);
                        if (v113)
                          v114 = CFErrorGetCode(v113);
                        else
                          v114 = -2070;
                        sub_1000521A8(1, 2, v114);
                        v115 = *(const void **)(*(_QWORD *)&v328[8] + 24);
                        if (v115)
                        {
                          if (v94[3])
                            CFRelease(v115);
                          else
                            v94[3] = v115;
                        }
                      }
                      v93 = *(_QWORD *)(*((_QWORD *)&v335 + 1) + 24);
                    }
                    else
                    {
                      v93 = -1;
                    }
                    _Block_object_dispose(&v285, 8);
                    _Block_object_dispose(&v289, 8);
                    _Block_object_dispose(&v293, 8);
                    _Block_object_dispose(&v297, 8);
                    _Block_object_dispose(v301, 8);
                    _Block_object_dispose(v328, 8);
                    _Block_object_dispose(v330, 8);
                    _Block_object_dispose(&v332, 8);
                    _Block_object_dispose(&v335, 8);
                    v282[3] = v93;
                    v84 = v278;
                    v83 = v242;
                  }
                  if ((v93 & 0x8000000000000000) == 0)
                  {
                    if (*((_BYTE *)v84 + 24) && v83)
                    {
                      v243 = (__int128 *)v93;
                      v235 = v274;
                      v303 = 0;
                      v304 = (uint64_t)&v303;
                      v305 = 0x2000000000;
                      LOBYTE(v306) = 1;
                      *(_QWORD *)&v335 = 0;
                      *((_QWORD *)&v335 + 1) = &v335;
                      v336 = 0x2000000000;
                      v337 = 0;
                      v116 = v83;
                      v117 = CFGetTypeID(v83);
                      if (v117 == CFArrayGetTypeID())
                      {
                        v118 = CFArrayGetCount(v83);
                        if (v118 >= 1)
                        {
                          v119 = v118;
                          for (j = 0; j != v119; ++j)
                          {
                            if (!*(_BYTE *)(v304 + 24))
                              break;
                            v121 = (const __CFData *)CFArrayGetValueAtIndex(v116, j);
                            if (v121)
                            {
                              v122 = v121;
                              if ((CFDataGetLength(v121) & 0x8000000000000000) == 0)
                              {
                                v123 = v304;
                                if (*(_BYTE *)(v304 + 24))
                                {
                                  v124 = *(_QWORD *)(a2 + 8);
                                  *(_QWORD *)buf = _NSConcreteStackBlock;
                                  *(_QWORD *)&buf[8] = 0x40000000;
                                  *(_QWORD *)&buf[16] = sub_10004D9DC;
                                  v315 = &unk_100078848;
                                  v316 = &v303;
                                  v317 = (void ***)&v335;
                                  v318 = v243;
                                  v319 = v122;
                                  v320 = (uint64_t *)a2;
                                  v125 = sub_10001979C(v124, CFSTR("INSERT OR REPLACE INTO issuers (groupid,issuer_hash) VALUES (?,?)"), (CFTypeRef *)(*((_QWORD *)&v335 + 1) + 24), (uint64_t)buf);
                                  v123 = v304;
                                }
                                else
                                {
                                  v125 = 0;
                                }
                                *(_BYTE *)(v123 + 24) = v125;
                              }
                            }
                          }
                        }
                      }
                      v74 = v241;
                      if (!*(_BYTE *)(v304 + 24) || *(_QWORD *)(*((_QWORD *)&v335 + 1) + 24))
                      {
                        v126 = sub_100011628("SecError");
                        if (os_log_type_enabled(v126, OS_LOG_TYPE_DEFAULT))
                        {
                          v127 = *(_QWORD *)(*((_QWORD *)&v335 + 1) + 24);
                          LODWORD(v332) = 138412290;
                          *(_QWORD *)((char *)&v332 + 4) = v127;
                          _os_log_impl((void *)&_mh_execute_header, v126, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbUpdateIssuers failed: %@", (uint8_t *)&v332, 0xCu);
                        }
                        v128 = *(__CFError **)(*((_QWORD *)&v335 + 1) + 24);
                        if (v128)
                          v129 = CFErrorGetCode(v128);
                        else
                          v129 = -2070;
                        sub_1000521A8(1, 2, v129);
                        v132 = *(const void **)(*((_QWORD *)&v335 + 1) + 24);
                        if (v132)
                        {
                          if (v235[3])
                            CFRelease(v132);
                          else
                            v235[3] = v132;
                        }
                      }
                      v133 = *(unsigned __int8 *)(v304 + 24);
                      _Block_object_dispose(&v335, 8);
                      _Block_object_dispose(&v303, 8);
                      v84 = v278;
                      *((_BYTE *)v278 + 24) = v133;
                      if (v133)
                      {
                        v244 = v282[3];
                        if ((v244 & 0x8000000000000000) == 0)
                        {
                          v234 = v274;
                          *(_QWORD *)&v335 = 0;
                          *((_QWORD *)&v335 + 1) = &v335;
                          v336 = 0x2000000000;
                          LOBYTE(v337) = 1;
                          *(_QWORD *)&v332 = 0;
                          *((_QWORD *)&v332 + 1) = &v332;
                          v333 = 0x2000000000;
                          v334 = 0;
                          v134 = (const __CFArray *)CFDictionaryGetValue(theArraya, CFSTR("delete"));
                          if (v134)
                          {
                            v135 = v134;
                            v136 = CFGetTypeID(v134);
                            if (v136 == CFArrayGetTypeID())
                            {
                              v236 = CFArrayGetCount(v135);
                              if (v236 >= 1)
                              {
                                v137 = 0;
                                v138 = 0;
                                do
                                {
                                  v139 = (const __CFData *)CFArrayGetValueAtIndex(v135, v137);
                                  if (v139)
                                  {
                                    v140 = v139;
                                    if (!v138)
                                      v138 = sub_10004DB0C(a2, v244, v139);
                                    if (v138 == 1)
                                    {
                                      v141 = CFSTR("DELETE FROM serials WHERE groupid=? AND hex(serial) LIKE ?");
LABEL_228:
                                      if (*(_BYTE *)(*((_QWORD *)&v335 + 1) + 24))
                                      {
                                        v142 = *(_QWORD *)(a2 + 8);
                                        *(_QWORD *)buf = _NSConcreteStackBlock;
                                        *(_QWORD *)&buf[8] = 0x40000000;
                                        *(_QWORD *)&buf[16] = sub_10004DB60;
                                        v315 = &unk_100078870;
                                        v318 = (__int128 *)v140;
                                        v319 = (_BYTE *)v244;
                                        v316 = (void ***)&v335;
                                        v317 = (void ***)&v332;
                                        v320 = (uint64_t *)a2;
                                        v143 = sub_10001979C(v142, v141, (CFTypeRef *)(*((_QWORD *)&v332 + 1) + 24), (uint64_t)buf);
                                        *(_BYTE *)(*((_QWORD *)&v335 + 1) + 24) = v143;
                                      }
                                      else
                                      {
                                        *(_BYTE *)(*((_QWORD *)&v335 + 1) + 24) = 0;
                                      }
                                      goto LABEL_231;
                                    }
                                    if (v138 == 2)
                                    {
                                      v141 = CFSTR("DELETE FROM hashes WHERE groupid=? AND hex(sha256) LIKE ?");
                                      goto LABEL_228;
                                    }
                                  }
LABEL_231:
                                  ++v137;
                                }
                                while (v236 != v137);
                              }
                            }
                          }
                          v144 = (const __CFArray *)CFDictionaryGetValue(theArraya, CFSTR("add"));
                          if (v144)
                          {
                            v145 = v144;
                            v146 = CFGetTypeID(v144);
                            if (v146 == CFArrayGetTypeID())
                            {
                              v237 = CFArrayGetCount(v145);
                              if (v237 >= 1)
                              {
                                v147 = 0;
                                v148 = 0;
                                while (1)
                                {
                                  v149 = (const __CFData *)CFArrayGetValueAtIndex(v145, v147);
                                  if (!v149)
                                    goto LABEL_247;
                                  v150 = v149;
                                  if (CFDataGetLength(v149) < 0)
                                    goto LABEL_247;
                                  if (!v148)
                                    v148 = sub_10004DB0C(a2, v244, v150);
                                  if (v148 == 1)
                                    break;
                                  if (v148 == 2)
                                  {
                                    v151 = CFSTR("INSERT OR REPLACE INTO hashes (groupid,sha256) VALUES (?,?)");
                                    goto LABEL_244;
                                  }
LABEL_247:
                                  if (v237 == ++v147)
                                    goto LABEL_248;
                                }
                                v151 = CFSTR("INSERT OR REPLACE INTO serials (groupid,serial) VALUES (?,?)");
LABEL_244:
                                if (*(_BYTE *)(*((_QWORD *)&v335 + 1) + 24))
                                {
                                  v152 = *(_QWORD *)(a2 + 8);
                                  v303 = _NSConcreteStackBlock;
                                  v304 = 0x40000000;
                                  v305 = (uint64_t)sub_10004DDAC;
                                  v306 = (uint64_t)&unk_100078898;
                                  v307 = &v335;
                                  v308 = &v332;
                                  v309 = v244;
                                  v310 = (uint64_t)v150;
                                  v311 = a2;
                                  v153 = sub_10001979C(v152, v151, (CFTypeRef *)(*((_QWORD *)&v332 + 1) + 24), (uint64_t)&v303);
                                  *(_BYTE *)(*((_QWORD *)&v335 + 1) + 24) = v153;
                                }
                                else
                                {
                                  *(_BYTE *)(*((_QWORD *)&v335 + 1) + 24) = 0;
                                }
                                goto LABEL_247;
                              }
                            }
                          }
LABEL_248:
                          v74 = v241;
                          if (!*(_BYTE *)(*((_QWORD *)&v335 + 1) + 24) || *(_QWORD *)(*((_QWORD *)&v332 + 1) + 24))
                          {
                            v154 = sub_100011628("SecError");
                            if (os_log_type_enabled(v154, OS_LOG_TYPE_DEFAULT))
                            {
                              v155 = *(_QWORD *)(*((_QWORD *)&v332 + 1) + 24);
                              *(_DWORD *)v330 = 138412290;
                              *(_QWORD *)&v330[4] = v155;
                              _os_log_impl((void *)&_mh_execute_header, v154, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbUpdatePerIssuerData failed: %@", v330, 0xCu);
                            }
                            v156 = *(__CFError **)(*((_QWORD *)&v332 + 1) + 24);
                            if (v156)
                              v157 = CFErrorGetCode(v156);
                            else
                              v157 = -2070;
                            sub_1000521A8(1, 2, v157);
                            v158 = *(const void **)(*((_QWORD *)&v332 + 1) + 24);
                            if (v158)
                            {
                              if (v234[3])
                                CFRelease(v158);
                              else
                                v234[3] = v158;
                            }
                          }
                          v130 = *(unsigned __int8 *)(*((_QWORD *)&v335 + 1) + 24);
                          _Block_object_dispose(&v332, 8);
                          _Block_object_dispose(&v335, 8);
                          *((_BYTE *)v278 + 24) = v130;
                          if (v130)
                          {
                            if (v282[3] < 0)
                            {
                              LOBYTE(v130) = 0;
                            }
                            else
                            {
                              v245 = v282[3];
                              v238 = v274;
                              v303 = 0;
                              v304 = (uint64_t)&v303;
                              v305 = 0x2000000000;
                              LOBYTE(v306) = 1;
                              *(_QWORD *)&v335 = 0;
                              *((_QWORD *)&v335 + 1) = &v335;
                              v336 = 0x2000000000;
                              v337 = 0;
                              *(_QWORD *)&v332 = 0;
                              *((_QWORD *)&v332 + 1) = &v332;
                              v333 = 0x2000000000;
                              v334 = (const __CFArray *)0xC1E7832270000000;
                              *(_QWORD *)v330 = 0;
                              *(_QWORD *)&v330[8] = v330;
                              *(_QWORD *)&v330[16] = 0x2000000000;
                              v331 = 0x421D63C0DC000000;
                              v159 = CFDictionaryGetValue(theArraya, CFSTR("not-before"));
                              v160 = (const __CFDate *)CFDictionaryGetValue(theArraya, CFSTR("not-after"));
                              if (v159)
                              {
                                v161 = CFGetTypeID(v159);
                                if (v161 == CFDateGetTypeID())
                                {
                                  AbsoluteTime = CFDateGetAbsoluteTime((CFDateRef)v159);
                                  *(CFAbsoluteTime *)(*((_QWORD *)&v332 + 1) + 24) = AbsoluteTime;
                                }
                                else
                                {
                                  v159 = 0;
                                }
                              }
                              if (v160 && (v163 = CFGetTypeID(v160), v163 == CFDateGetTypeID()))
                              {
                                v164 = CFDateGetAbsoluteTime(v160);
                                *(CFAbsoluteTime *)(*(_QWORD *)&v330[8] + 24) = v164;
                                v165 = v245;
                                if (!v159)
                                {
                                  v166 = 0;
                                  v167 = 1;
LABEL_272:
                                  *(_QWORD *)buf = 0;
                                  *(_QWORD *)v328 = 0;
                                  if (sub_10004B940(a2, v165, buf, v328, (_QWORD *)(*((_QWORD *)&v335 + 1) + 24)))
                                  {
                                    if ((v166 & 1) != 0)
                                    {
                                      if (*(_QWORD *)buf)
                                        CFRelease(*(CFTypeRef *)buf);
                                    }
                                    else
                                    {
                                      v168 = CFDateGetAbsoluteTime(*(CFDateRef *)buf);
                                      *(CFAbsoluteTime *)(*((_QWORD *)&v332 + 1) + 24) = v168;
                                    }
                                    if ((v167 & 1) != 0)
                                    {
                                      if (*(_QWORD *)v328)
                                        CFRelease(*(CFTypeRef *)v328);
                                    }
                                    else
                                    {
                                      v169 = CFDateGetAbsoluteTime(*(CFDateRef *)v328);
                                      *(CFAbsoluteTime *)(*(_QWORD *)&v330[8] + 24) = v169;
                                    }
                                  }
                                }
                                if (*(_BYTE *)(v304 + 24))
                                {
                                  v170 = *(_QWORD *)(a2 + 8);
                                  *(_QWORD *)buf = _NSConcreteStackBlock;
                                  *(_QWORD *)&buf[8] = 0x40000000;
                                  *(_QWORD *)&buf[16] = sub_10004DEDC;
                                  v315 = &unk_100078940;
                                  v316 = &v303;
                                  v317 = (void ***)&v335;
                                  v318 = &v332;
                                  v319 = v330;
                                  v320 = (uint64_t *)v165;
                                  v321 = (uint64_t *)a2;
                                  v171 = sub_10001979C(v170, CFSTR("INSERT OR REPLACE INTO dates (groupid,notbefore,notafter) VALUES (?,?,?)"), (CFTypeRef *)(*((_QWORD *)&v335 + 1) + 24), (uint64_t)buf);
                                  *(_BYTE *)(v304 + 24) = v171;
                                  if (v171 && !*(_QWORD *)(*((_QWORD *)&v335 + 1) + 24))
                                    goto LABEL_294;
                                }
                                else
                                {
                                  *(_BYTE *)(v304 + 24) = 0;
                                }
                                v172 = sub_100011628("validupdate");
                                if (os_log_type_enabled(v172, OS_LOG_TYPE_DEBUG))
                                {
                                  v187 = "1";
                                  if (!*(_BYTE *)(v304 + 24))
                                    v187 = "0";
                                  v188 = *(_QWORD *)(*((_QWORD *)&v335 + 1) + 24);
                                  *(_DWORD *)v328 = 136315394;
                                  *(_QWORD *)&v328[4] = v187;
                                  *(_WORD *)&v328[12] = 2112;
                                  *(_QWORD *)&v328[14] = v188;
                                  _os_log_debug_impl((void *)&_mh_execute_header, v172, OS_LOG_TYPE_DEBUG, "_SecRevocationDbUpdateDateConstraints failed (ok=%s, localError=%@)", v328, 0x16u);
                                }
                                v173 = *(__CFError **)(*((_QWORD *)&v335 + 1) + 24);
                                if (v173)
                                  v174 = CFErrorGetCode(v173);
                                else
                                  v174 = -2070;
                                sub_1000521A8(1, 2, v174);
                                v175 = *(const void **)(*((_QWORD *)&v335 + 1) + 24);
                                if (v175)
                                {
                                  if (v238[3])
                                    CFRelease(v175);
                                  else
                                    v238[3] = v175;
                                }
                              }
                              else
                              {
                                v165 = v245;
                                if (v159)
                                {
                                  v167 = 0;
                                  v166 = 1;
                                  goto LABEL_272;
                                }
                              }
LABEL_294:
                              v130 = *(unsigned __int8 *)(v304 + 24);
                              _Block_object_dispose(v330, 8);
                              _Block_object_dispose(&v332, 8);
                              _Block_object_dispose(&v335, 8);
                              _Block_object_dispose(&v303, 8);
                              if (v130)
                              {
                                v303 = 0;
                                v304 = (uint64_t)&v303;
                                v305 = 0x2000000000;
                                LOBYTE(v306) = 1;
                                *(_QWORD *)&v335 = 0;
                                *((_QWORD *)&v335 + 1) = &v335;
                                v336 = 0x2000000000;
                                v337 = 0;
                                v176 = (const __CFArray *)CFDictionaryGetValue(theArraya, CFSTR("policies"));
                                if (v176 && (v177 = v176, v178 = CFGetTypeID(v176), v178 == CFArrayGetTypeID()))
                                {
                                  *(_QWORD *)&v332 = 0;
                                  *((_QWORD *)&v332 + 1) = &v332;
                                  v333 = 0x2000000000;
                                  v334 = (const __CFArray *)0xAAAAAAAAAAAAAAAALL;
                                  v334 = sub_10004E07C(v177);
                                  v179 = *(const __CFData **)(*((_QWORD *)&v332 + 1) + 24);
                                  if (v179)
                                  {
                                    v180 = CFDataGetLength(v179);
                                    v181 = v304;
                                    *(_BYTE *)(v304 + 24) = v180 >= 0;
                                    v74 = v241;
                                    if (v180 < 0)
                                    {
                                      LODWORD(v179) = 0;
                                    }
                                    else
                                    {
                                      v182 = *(_QWORD *)(a2 + 8);
                                      *(_QWORD *)buf = _NSConcreteStackBlock;
                                      *(_QWORD *)&buf[8] = 0x40000000;
                                      *(_QWORD *)&buf[16] = sub_10004E184;
                                      v315 = &unk_1000789B8;
                                      v316 = &v303;
                                      v317 = (void ***)&v332;
                                      v318 = &v335;
                                      v319 = (_BYTE *)v165;
                                      v320 = (uint64_t *)a2;
                                      LODWORD(v179) = sub_10001979C(v182, CFSTR("UPDATE OR IGNORE groups SET policies=? WHERE groupid=?"), (CFTypeRef *)(*((_QWORD *)&v335 + 1) + 24), (uint64_t)buf);
                                      v181 = v304;
                                    }
                                  }
                                  else
                                  {
                                    v181 = v304;
                                    *(_BYTE *)(v304 + 24) = 0;
                                    v74 = v241;
                                  }
                                  *(_BYTE *)(v181 + 24) = (_BYTE)v179;
                                  if (*(_QWORD *)(*((_QWORD *)&v332 + 1) + 24))
                                  {
                                    CFRelease(*(CFTypeRef *)(*((_QWORD *)&v332 + 1) + 24));
                                    LODWORD(v179) = *(unsigned __int8 *)(v304 + 24);
                                  }
                                  if (!(_DWORD)v179 || *(_QWORD *)(*((_QWORD *)&v335 + 1) + 24))
                                  {
                                    v183 = sub_100011628("validupdate");
                                    if (os_log_type_enabled(v183, OS_LOG_TYPE_DEBUG))
                                    {
                                      v189 = "1";
                                      if (!*(_BYTE *)(v304 + 24))
                                        v189 = "0";
                                      v190 = *(_QWORD *)(*((_QWORD *)&v335 + 1) + 24);
                                      *(_DWORD *)v330 = 136315394;
                                      *(_QWORD *)&v330[4] = v189;
                                      *(_WORD *)&v330[12] = 2112;
                                      *(_QWORD *)&v330[14] = v190;
                                      _os_log_debug_impl((void *)&_mh_execute_header, v183, OS_LOG_TYPE_DEBUG, "_SecRevocationDbUpdatePolicyConstraints failed (ok=%s, localError=%@)", v330, 0x16u);
                                    }
                                    v184 = *(__CFError **)(*((_QWORD *)&v335 + 1) + 24);
                                    if (v184)
                                      v185 = CFErrorGetCode(v184);
                                    else
                                      v185 = -2070;
                                    sub_1000521A8(1, 2, v185);
                                    v186 = *(const void **)(*((_QWORD *)&v335 + 1) + 24);
                                    if (v186)
                                    {
                                      if (v238[3])
                                        CFRelease(v186);
                                      else
                                        v238[3] = v186;
                                    }
                                  }
                                  v130 = *(unsigned __int8 *)(v304 + 24);
                                  _Block_object_dispose(&v332, 8);
                                }
                                else
                                {
                                  v130 = *(unsigned __int8 *)(v304 + 24);
                                  v74 = v241;
                                }
                                LOBYTE(v130) = v130 != 0;
                                _Block_object_dispose(&v335, 8);
                                _Block_object_dispose(&v303, 8);
                              }
                              else
                              {
                                v74 = v241;
                              }
                            }
                          }
LABEL_201:
                          v84 = v278;
                          *((_BYTE *)v278 + 24) = v130;
LABEL_203:
                          v131 = v274[3];
                          if (v131)
                          {
                            if (v264)
                            {
                              CFRelease(v131);
                              v84 = v278;
                            }
                            else
                            {
                              v264 = v274[3];
                            }
                          }
                          v80 = *((unsigned __int8 *)v84 + 24) != 0;
                          _Block_object_dispose(&v273, 8);
                          _Block_object_dispose(&v277, 8);
                          _Block_object_dispose(&v281, 8);
                          goto LABEL_208;
                        }
                      }
                    }
                    else
                    {
                      *((_BYTE *)v84 + 24) = 0;
                    }
                    LOBYTE(v130) = 0;
                    *((_BYTE *)v84 + 24) = 0;
                    goto LABEL_201;
                  }
                  *((_BYTE *)v84 + 24) = 0;
                  goto LABEL_203;
                }
              }
              else
              {
                v80 = v63;
              }
LABEL_208:
              ++v76;
              v63 = v80;
              if (v76 == v257)
                goto LABEL_328;
            }
          }
        }
        LOBYTE(v80) = v63;
LABEL_328:
        CFRelease(cf);
        if ((v80 & 1) != 0)
          goto LABEL_329;
      }
      else
      {
        CFRelease(v54);
        if ((v63 & 1) != 0)
        {
LABEL_329:
          v303 = 0;
          v304 = (uint64_t)&v303;
          v305 = 0x2000000000;
          v306 = 0;
          v265 = 0;
          v266 = (uint64_t)&v265;
          v267 = 0x2000000000;
          LOBYTE(v268) = 1;
          v192 = *(_QWORD *)(a2 + 8);
          *(_QWORD *)buf = _NSConcreteStackBlock;
          *(_QWORD *)&buf[8] = 0x40000000;
          *(_QWORD *)&buf[16] = sub_10004E2C4;
          v315 = &unk_1000789E0;
          v316 = &v265;
          v317 = &v303;
          v318 = v239;
          v319 = (_BYTE *)a2;
          v193 = sub_10001979C(v192, CFSTR("INSERT OR REPLACE INTO admin (key,ival,value) VALUES (?,?,?)"), (CFTypeRef *)&v306, (uint64_t)buf);
          *(_BYTE *)(v266 + 24) = v193;
          if (!v193 || *(_QWORD *)(v304 + 24))
          {
            v194 = sub_100011628("SecError");
            if (os_log_type_enabled(v194, OS_LOG_TYPE_DEFAULT))
            {
              v195 = *(_QWORD *)(v304 + 24);
              LODWORD(v335) = 138412290;
              *(_QWORD *)((char *)&v335 + 4) = v195;
              _os_log_impl((void *)&_mh_execute_header, v194, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbSetVersion failed: %@", (uint8_t *)&v335, 0xCu);
            }
            v196 = *(__CFError **)(v304 + 24);
            if (v196)
              v197 = CFErrorGetCode(v196);
            else
              v197 = -2070;
            sub_1000521A8(1, 2, v197);
            v199 = *(const void **)(v304 + 24);
            if (v199)
            {
              if (v264)
                CFRelease(v199);
              else
                v264 = *(CFTypeRef *)(v304 + 24);
            }
          }
          v200 = *(unsigned __int8 *)(v266 + 24);
          _Block_object_dispose(&v265, 8);
          _Block_object_dispose(&v303, 8);
          v3 = v240;
          if (v200)
          {
            v303 = 0;
            v304 = (uint64_t)&v303;
            v305 = 0x2000000000;
            v306 = 0;
            v265 = 0;
            v266 = (uint64_t)&v265;
            v267 = 0x2000000000;
            LOBYTE(v268) = 1;
            v201 = *(_QWORD *)(a2 + 8);
            *(_QWORD *)buf = _NSConcreteStackBlock;
            *(_QWORD *)&buf[8] = 0x40000000;
            *(_QWORD *)&buf[16] = sub_10004E404;
            v315 = &unk_100078A08;
            v316 = &v265;
            v317 = &v303;
            v318 = (__int128 *)v251;
            v319 = (_BYTE *)a2;
            v202 = sub_10001979C(v201, CFSTR("INSERT OR REPLACE INTO admin (key,ival,value) VALUES (?,?,?)"), (CFTypeRef *)&v306, (uint64_t)buf);
            *(_BYTE *)(v266 + 24) = v202;
            if (!v202 || *(_QWORD *)(v304 + 24))
            {
              v203 = sub_100011628("SecError");
              if (os_log_type_enabled(v203, OS_LOG_TYPE_DEFAULT))
              {
                v204 = *(_QWORD *)(v304 + 24);
                LODWORD(v335) = 138412290;
                *(_QWORD *)((char *)&v335 + 4) = v204;
                _os_log_impl((void *)&_mh_execute_header, v203, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbSetGeneration failed: %@", (uint8_t *)&v335, 0xCu);
              }
              v205 = *(__CFError **)(v304 + 24);
              if (v205)
                v206 = CFErrorGetCode(v205);
              else
                v206 = -2070;
              sub_1000521A8(1, 2, v206);
              v207 = *(const void **)(v304 + 24);
              if (v207)
              {
                if (v264)
                  CFRelease(v207);
                else
                  v264 = *(CFTypeRef *)(v304 + 24);
              }
            }
            v198 = *(_BYTE *)(v266 + 24) != 0;
            _Block_object_dispose(&v265, 8);
            _Block_object_dispose(&v303, 8);
          }
          else
          {
            v198 = 0;
          }
          goto LABEL_356;
        }
      }
      v198 = 0;
      v3 = v240;
LABEL_356:
      v208 = sub_10004A5C8(a2);
      v209 = *(_QWORD *)(a2 + 32);
      v210 = v208 == v209 && v198;
      if (v208 != v209 && v198)
      {
        v211 = (uint64_t)(double)v209;
        v212 = v209 <= 0;
        v213 = 10800;
        if (!v212)
          v213 = v211;
        v303 = 0;
        v304 = (uint64_t)&v303;
        v305 = 0x2000000000;
        v306 = 0;
        v265 = 0;
        v266 = (uint64_t)&v265;
        v267 = 0x2000000000;
        LOBYTE(v268) = 1;
        v214 = *(_QWORD *)(a2 + 8);
        *(_QWORD *)buf = _NSConcreteStackBlock;
        *(_QWORD *)&buf[8] = 0x40000000;
        *(_QWORD *)&buf[16] = sub_10004E544;
        v315 = &unk_100078A80;
        v316 = &v265;
        v317 = &v303;
        v318 = (__int128 *)v213;
        v319 = (_BYTE *)a2;
        v215 = sub_10001979C(v214, CFSTR("INSERT OR REPLACE INTO admin (key,ival,value) VALUES (?,?,?)"), (CFTypeRef *)&v306, (uint64_t)buf);
        *(_BYTE *)(v266 + 24) = v215;
        if (!v215 || *(_QWORD *)(v304 + 24))
        {
          v216 = sub_100011628("SecError");
          if (os_log_type_enabled(v216, OS_LOG_TYPE_DEFAULT))
          {
            v217 = *(_QWORD *)(v304 + 24);
            LODWORD(v335) = 138412290;
            *(_QWORD *)((char *)&v335 + 4) = v217;
            _os_log_impl((void *)&_mh_execute_header, v216, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbSetUpdateInterval failed: %@", (uint8_t *)&v335, 0xCu);
          }
          v218 = *(__CFError **)(v304 + 24);
          if (v218)
            v219 = CFErrorGetCode(v218);
          else
            v219 = -2070;
          sub_1000521A8(1, 2, v219);
          v220 = *(const void **)(v304 + 24);
          if (v220)
          {
            if (v264)
              CFRelease(v220);
            else
              v264 = *(CFTypeRef *)(v304 + 24);
          }
        }
        v210 = *(_BYTE *)(v266 + 24) != 0;
        _Block_object_dispose(&v265, 8);
        _Block_object_dispose(&v303, 8);
      }
      v221 = atomic_load(&qword_100082920);
      if (v221 == -1)
        atomic_store(sub_10001AEFC(a2, 0), &qword_100082920);
      v222 = atomic_load(&qword_100082920);
      v223 = v222 > 0 && v210;
      if (v222 <= 0)
      {
        v224 = !v210;
        v33 = v248;
        if (!v224)
          v223 = sub_1000472FC((_QWORD *)a2);
      }
      else
      {
        v33 = v248;
      }
      v225 = sub_10004E684(a2, 0);
      if (v225 > 0)
        v226 = v223;
      else
        v226 = 0;
      if (v225 <= 0 && v223)
        v226 = sub_10004E860((_QWORD *)a2, &v264);
      sub_100047880(*(_QWORD *)a2);
      *(_BYTE *)(*(_QWORD *)a2 + 16) = 0;
      if (v264)
      {
        if (v262)
          CFRelease(v264);
        else
          v262 = (__CFString *)v264;
      }
      v42 = v226;
      goto LABEL_395;
    }
  }
LABEL_24:
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v20 & 1;
  v21 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v21)
    v21 = v8 < *(_QWORD *)(a2 + 16);
  *(_BYTE *)(*(_QWORD *)(a1 + 56) + 18) = v21;
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    sub_100051F80((uint64_t)CFSTR("ValidUpdateEvent"));
  }
  else
  {
    v22 = sub_100011628("SecError");
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      if (v3)
        v23 = *v3;
      else
        v23 = 0;
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)&buf[4] = v23;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "failed to process valid update: %@", buf, 0xCu);
    }
    sub_100052038((uint64_t)CFSTR("ValidUpdateEvent"), 1, 4294941021);
  }
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

BOOL sub_100049CE8(uint64_t a1, CFMutableArrayRef Mutable, _QWORD *a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  _BOOL4 v10;
  const void *v11;
  const void *v12;
  const __CFArray *v13;
  CFIndex Count;
  CFIndex v15;
  __int128 v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t *v19;
  uint64_t v20;
  char v21;
  unsigned int v22;
  NSObject *v23;
  uint64_t *v25;
  uint64_t v26;
  char v27;
  __int128 v28;
  CFDataRef v29;
  CFDataRef v30;
  CFDataRef v31;
  CFDataRef v32;
  CFDataRef v33;
  CFDataRef v34;
  CFTypeRef v35;
  CFIndex v36;
  char v37;
  CFIndex v38;
  const void *ValueAtIndex;
  const void *v40;
  NSObject *v41;
  NSObject *v42;
  NSObject *v43;
  const char *v44;
  void **v45;
  uint64_t v46;
  uint64_t v47;
  CFTypeRef v48[8];
  _QWORD v49[8];
  uint64_t v50;
  uint64_t *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t *v55;
  uint64_t v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  unint64_t v63;
  uint64_t v64;
  uint64_t *v65;
  uint64_t v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  unint64_t v73;
  uint64_t v74;
  CFTypeRef *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t *v79;
  uint64_t v80;
  char v81;
  _OWORD md[2];
  __int128 buf;
  uint64_t v84;
  CC_SHA256_CTX v85;
  _DWORD data[2];
  uint64_t v87;

  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    LOBYTE(v10) = 0;
    goto LABEL_31;
  }
  v6 = sub_100011628("validupdate");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(buf) = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "Started verifying db content", (uint8_t *)&buf, 2u);
  }
  v64 = 0;
  v65 = &v64;
  v66 = 0x2000000000;
  *(_QWORD *)&v67 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v67 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v54 = 0;
  v55 = &v54;
  v56 = 0x2000000000;
  LOBYTE(v57) = -86;
  if (Mutable)
  {
    v7 = v65[3];
    LOBYTE(v57) = v7 != 0;
    v45 = 0;
    v46 = (uint64_t)&v45;
    v47 = 0x2000000000;
    v48[0] = 0;
    if (v7)
    {
      v8 = *((_QWORD *)Mutable + 1);
      *(_QWORD *)&buf = _NSConcreteStackBlock;
      *((_QWORD *)&buf + 1) = 0x40000000;
      v84 = (uint64_t)sub_10004A528;
      *(_QWORD *)v85.count = &unk_100078E08;
      *(_QWORD *)v85.hash = &v54;
      *(_QWORD *)&v85.hash[2] = &v45;
      *(_QWORD *)&v85.hash[6] = Mutable;
      *(_QWORD *)&v85.hash[4] = &v64;
      v9 = sub_10001979C(v8, CFSTR("SELECT value FROM admin WHERE key='db_hash'"), v48, (uint64_t)&buf);
      *((_BYTE *)v55 + 24) = v9;
      if (v9 && !*(_QWORD *)(v46 + 24))
        goto LABEL_14;
      goto LABEL_12;
    }
  }
  else
  {
    v45 = 0;
    v46 = (uint64_t)&v45;
    v47 = 0x2000000000;
    v48[0] = 0;
  }
  LOBYTE(v57) = 0;
LABEL_12:
  v11 = (const void *)v65[3];
  if (v11)
  {
    v65[3] = 0;
    CFRelease(v11);
  }
LABEL_14:
  v12 = *(const void **)(v46 + 24);
  if (v12)
  {
    if (a3 && !*a3)
      *a3 = v12;
    else
      CFRelease(v12);
  }
  v13 = (const __CFArray *)v65[3];
  _Block_object_dispose(&v45, 8);
  _Block_object_dispose(&v54, 8);
  _Block_object_dispose(&v64, 8);
  if (!v13 || (Count = CFArrayGetCount(v13), Count <= 0))
  {
    v23 = sub_100011628("validupdate");
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buf) = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEBUG, "Unable to read db_hash values", (uint8_t *)&buf, 2u);
    }
    LOBYTE(v10) = 1;
    if (!v13)
      goto LABEL_31;
    goto LABEL_30;
  }
  v15 = Count;
  if (!Mutable)
    goto LABEL_52;
  v78 = 0;
  v79 = &v78;
  v80 = 0x2000000000;
  v81 = 1;
  v74 = 0;
  v75 = (CFTypeRef *)&v74;
  v76 = 0x2000000000;
  v77 = 0;
  v87 = 0;
  *(_QWORD *)&buf = 0;
  *((_QWORD *)&buf + 1) = &buf;
  v84 = 0x8000000000;
  *(_QWORD *)&v16 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)v85.count = v16;
  *(_OWORD *)&v85.hash[2] = v16;
  *(_OWORD *)&v85.hash[6] = v16;
  *(_OWORD *)&v85.wbuf[2] = v16;
  *(_OWORD *)&v85.wbuf[6] = v16;
  *(_OWORD *)&v85.wbuf[10] = v16;
  *(_QWORD *)&v85.wbuf[14] = 0xAAAAAAAAAAAAAAAALL;
  v64 = 0;
  v65 = &v64;
  v66 = 0x8000000000;
  v67 = v16;
  v68 = v16;
  v69 = v16;
  v70 = v16;
  v71 = v16;
  v72 = v16;
  v73 = 0xAAAAAAAAAAAAAAAALL;
  v54 = 0;
  v55 = &v54;
  v56 = 0x8000000000;
  v57 = v16;
  v58 = v16;
  v59 = v16;
  v60 = v16;
  v61 = v16;
  v62 = v16;
  v63 = 0xAAAAAAAAAAAAAAAALL;
  CC_SHA256_Init(&v85);
  CC_SHA256_Init((CC_SHA256_CTX *)(v65 + 3));
  CC_SHA256_Init((CC_SHA256_CTX *)(v55 + 3));
  data[0] = bswap32(sub_100018BB0((uint64_t)Mutable, 0));
  v17 = sub_10004A5C8((uint64_t)Mutable);
  if (v17 >= 0)
    v18 = v17;
  else
    v18 = 10800;
  data[1] = bswap32(v18);
  v50 = 0;
  v51 = &v50;
  v52 = 0x2000000000;
  v53 = 0;
  v19 = v79;
  if (*((_BYTE *)v79 + 24))
  {
    v20 = *((_QWORD *)Mutable + 1);
    v49[0] = _NSConcreteStackBlock;
    v49[1] = 0x40000000;
    v49[2] = sub_10004A77C;
    v49[3] = &unk_100078E58;
    v49[4] = &v78;
    v49[5] = &v74;
    v49[6] = &v50;
    v49[7] = Mutable;
    v21 = sub_10001979C(v20, CFSTR("SELECT count(*) FROM groups"), v75 + 3, (uint64_t)v49);
    v19 = v79;
    v22 = *((_DWORD *)v51 + 6);
  }
  else
  {
    v22 = 0;
    v21 = 0;
  }
  *((_BYTE *)v19 + 24) = v21;
  LODWORD(v87) = bswap32(v22);
  CC_SHA256_Update((CC_SHA256_CTX *)(*((_QWORD *)&buf + 1) + 24), data, 0xCu);
  v25 = v79;
  if (*((_BYTE *)v79 + 24))
  {
    v26 = *((_QWORD *)Mutable + 1);
    v45 = _NSConcreteStackBlock;
    v46 = 0x40000000;
    v47 = (uint64_t)sub_10004A81C;
    v48[0] = &unk_100079038;
    v48[1] = &v78;
    v48[2] = &v74;
    v48[3] = &v50;
    v48[4] = &buf;
    v48[5] = &v64;
    v48[6] = &v54;
    v48[7] = Mutable;
    v27 = sub_10001979C(v26, CFSTR("SELECT DISTINCT groupid FROM issuers ORDER BY issuer_hash ASC"), v75 + 3, (uint64_t)&v45);
    v25 = v79;
  }
  else
  {
    v27 = 0;
  }
  *((_BYTE *)v25 + 24) = v27;
  Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  if (Mutable)
  {
    *(_QWORD *)&v28 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v28 + 1) = 0xAAAAAAAAAAAAAAAALL;
    md[0] = v28;
    md[1] = v28;
    CC_SHA256_Final((unsigned __int8 *)md, (CC_SHA256_CTX *)(*((_QWORD *)&buf + 1) + 24));
    v29 = CFDataCreate(0, (const UInt8 *)md, 32);
    if (v29)
    {
      v30 = v29;
      CFArrayAppendValue(Mutable, v29);
      CFRelease(v30);
    }
    CC_SHA256_Final((unsigned __int8 *)md, (CC_SHA256_CTX *)(v65 + 3));
    v31 = CFDataCreate(0, (const UInt8 *)md, 32);
    if (v31)
    {
      v32 = v31;
      CFArrayAppendValue(Mutable, v31);
      CFRelease(v32);
    }
    CC_SHA256_Final((unsigned __int8 *)md, (CC_SHA256_CTX *)(v55 + 3));
    v33 = CFDataCreate(0, (const UInt8 *)md, 32);
    if (v33)
    {
      v34 = v33;
      CFArrayAppendValue(Mutable, v33);
      CFRelease(v34);
    }
  }
  v35 = v75[3];
  if (v35)
  {
    if (a3 && !*a3)
      *a3 = v35;
    else
      CFRelease(v35);
  }
  _Block_object_dispose(&v50, 8);
  _Block_object_dispose(&v54, 8);
  _Block_object_dispose(&v64, 8);
  _Block_object_dispose(&buf, 8);
  _Block_object_dispose(&v74, 8);
  _Block_object_dispose(&v78, 8);
  if (Mutable)
  {
    v36 = CFArrayGetCount(Mutable);
    v37 = 0;
  }
  else
  {
LABEL_52:
    v36 = 0;
    v37 = 1;
  }
  LOBYTE(v10) = 0;
  v38 = 0;
  while (1)
  {
    if (v38 >= v36)
      goto LABEL_60;
    ValueAtIndex = CFArrayGetValueAtIndex(v13, v38);
    v40 = CFArrayGetValueAtIndex(Mutable, v38);
    if (!ValueAtIndex || !v40)
      break;
    if (!CFEqual(ValueAtIndex, v40))
      goto LABEL_62;
LABEL_60:
    v10 = ++v38 >= v15;
    if (v15 == v38)
      goto LABEL_69;
  }
  if (ValueAtIndex == v40)
    goto LABEL_60;
LABEL_62:
  if (v10)
  {
    v10 = 1;
  }
  else
  {
    v41 = sub_100011628("validupdate");
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf) = 138412290;
      *(_QWORD *)((char *)&buf + 4) = v13;
      _os_log_debug_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEBUG, "Expected: %@", (uint8_t *)&buf, 0xCu);
    }
    v42 = sub_100011628("validupdate");
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf) = 138412290;
      *(_QWORD *)((char *)&buf + 4) = Mutable;
      _os_log_debug_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEBUG, "Computed: %@", (uint8_t *)&buf, 0xCu);
    }
    v10 = 0;
  }
LABEL_69:
  v43 = sub_100011628("validupdate");
  if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
  {
    v44 = "FAIL";
    if (v10)
      v44 = "SUCCESS";
    LODWORD(buf) = 136315138;
    *(_QWORD *)((char *)&buf + 4) = v44;
    _os_log_debug_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEBUG, "Finished verifying db content; result=%s",
      (uint8_t *)&buf,
      0xCu);
  }
  CFRelease(v13);
  v13 = Mutable;
  if ((v37 & 1) == 0)
LABEL_30:
    CFRelease(v13);
LABEL_31:
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v10;
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    return 1;
  sub_10004718C();
  return *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) != 0;
}

uint64_t sub_10004A528(_QWORD *a1, sqlite3_stmt *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  _QWORD v9[6];

  v3 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v3 + 24))
  {
    v4 = a1[6];
    v5 = *(_QWORD *)(a1[7] + 8);
    v6 = *(_QWORD *)(a1[5] + 8);
    v9[0] = _NSConcreteStackBlock;
    v9[2] = sub_10004C520;
    v9[3] = &unk_100078DE0;
    v9[1] = 0x40000000;
    v9[4] = v4;
    v9[5] = a2;
    v7 = sub_100019D18(v5, a2, (CFTypeRef *)(v6 + 24), (uint64_t)v9);
    v3 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v7 = 0;
  }
  *(_BYTE *)(v3 + 24) = v7;
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

uint64_t sub_10004A5C8(uint64_t a1)
{
  uint64_t v1;
  int v2;
  NSObject *v3;
  uint64_t v4;
  __CFError *v5;
  CFIndex Code;
  const void *v7;
  uint64_t v8;
  _QWORD v10[8];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  CFTypeRef v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint8_t buf[4];
  uint64_t v24;

  v19 = 0;
  v20 = &v19;
  v21 = 0x2000000000;
  v22 = -1;
  v15 = 0;
  v16 = &v15;
  v17 = 0x2000000000;
  v18 = 1;
  v11 = 0;
  v12 = &v11;
  v13 = 0x2000000000;
  v14 = 0;
  v1 = *(_QWORD *)(a1 + 8);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = sub_10004C440;
  v10[3] = &unk_100078A58;
  v10[4] = &v15;
  v10[5] = &v11;
  v10[6] = &v19;
  v10[7] = a1;
  v2 = sub_10001979C(v1, CFSTR("SELECT ival FROM admin WHERE key='interval'"), &v14, (uint64_t)v10);
  *((_BYTE *)v16 + 24) = v2;
  if (!v2 || v12[3])
  {
    v3 = sub_100011628("SecError");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4 = v12[3];
      *(_DWORD *)buf = 138412290;
      v24 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbGetUpdateInterval failed: %@", buf, 0xCu);
    }
    v5 = (__CFError *)v12[3];
    if (v5)
      Code = CFErrorGetCode(v5);
    else
      Code = -2070;
    sub_1000521A8(1, 3, Code);
    v7 = (const void *)v12[3];
    if (v7)
      CFRelease(v7);
  }
  v8 = v20[3];
  _Block_object_dispose(&v11, 8);
  _Block_object_dispose(&v15, 8);
  _Block_object_dispose(&v19, 8);
  return v8;
}

uint64_t sub_10004A77C(_QWORD *a1, sqlite3_stmt *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  _QWORD v9[6];

  v3 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v3 + 24))
  {
    v4 = a1[6];
    v5 = *(_QWORD *)(a1[7] + 8);
    v6 = *(_QWORD *)(a1[5] + 8);
    v9[0] = _NSConcreteStackBlock;
    v9[2] = sub_10004C400;
    v9[3] = &unk_100078E30;
    v9[1] = 0x40000000;
    v9[4] = v4;
    v9[5] = a2;
    v7 = sub_100019D18(v5, a2, (CFTypeRef *)(v6 + 24), (uint64_t)v9);
    v3 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v7 = 0;
  }
  *(_BYTE *)(v3 + 24) = v7;
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

uint64_t sub_10004A81C(uint64_t a1, sqlite3_stmt *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  char v10;
  _QWORD v12[5];
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  sqlite3_stmt *v16;
  uint64_t v17;

  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(_QWORD *)(v3 + 8);
  if (*(_BYTE *)(v4 + 24))
  {
    v6 = *(_QWORD *)(a1 + 72);
    v5 = *(_QWORD *)(a1 + 80);
    v7 = *(_QWORD *)(v5 + 8);
    v12[0] = _NSConcreteStackBlock;
    v8 = *(_OWORD *)(a1 + 40);
    v9 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v12[2] = sub_10004A8D4;
    v12[3] = &unk_100079010;
    v12[1] = 0x40000000;
    v12[4] = v3;
    v16 = a2;
    v17 = v5;
    v13 = v8;
    v14 = *(_OWORD *)(a1 + 56);
    v15 = v6;
    v10 = sub_100029B6C(v7, a2, (CFTypeRef *)(v9 + 24), (uint64_t)v12);
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  else
  {
    v10 = 0;
  }
  *(_BYTE *)(v4 + 24) = v10;
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

uint64_t sub_10004A8D4(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  CFTypeRef *v7;
  __int128 v8;
  char v9;
  uint64_t v10;
  _QWORD v12[6];
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD v17[3];
  sqlite3_int64 v18;

  v17[0] = 0;
  v17[1] = v17;
  v17[2] = 0x2000000000;
  v18 = 0xAAAAAAAAAAAAAAAALL;
  v18 = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 80), 0);
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(v2 + 8);
  if (*(_BYTE *)(v3 + 24))
  {
    v4 = *(_QWORD *)(a1 + 88);
    v5 = *(_QWORD *)(v4 + 8);
    v12[0] = _NSConcreteStackBlock;
    v6 = *(_OWORD *)(a1 + 40);
    v7 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
    v12[1] = 0x40000000;
    v12[2] = sub_10004A9CC;
    v12[3] = &unk_100078FE8;
    v12[4] = v2;
    v12[5] = v17;
    v8 = *(_OWORD *)(a1 + 56);
    v13 = v6;
    v14 = v8;
    v15 = *(_QWORD *)(a1 + 72);
    v16 = v4;
    v9 = sub_10001979C(v5, CFSTR("SELECT flags,format,data FROM groups WHERE groupid=?"), v7, (uint64_t)v12);
    v3 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  else
  {
    v9 = 0;
  }
  *(_BYTE *)(v3 + 24) = v9;
  v10 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  _Block_object_dispose(v17, 8);
  return v10;
}

uint64_t sub_10004A9CC(uint64_t a1, sqlite3_stmt *a2)
{
  uint64_t v4;
  CFTypeRef *v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  char v16;
  _QWORD v18[7];
  __int128 v19;
  __int128 v20;
  sqlite3_stmt *v21;
  uint64_t v22;

  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v4 + 24))
  {
    v5 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
    v6 = sqlite3_bind_int64(a2, 1, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
    v7 = sub_10001A970(v6, a2, v5, CFSTR("bind_int64[%d]"), 1);
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  else
  {
    v7 = 0;
  }
  *(_BYTE *)(v4 + 24) = v7;
  v8 = *(_QWORD *)(a1 + 32);
  v9 = *(_QWORD *)(v8 + 8);
  if (*(_BYTE *)(v9 + 24))
  {
    v10 = *(_QWORD *)(a1 + 88);
    v11 = *(_QWORD *)(v10 + 8);
    v13 = *(_QWORD *)(a1 + 40);
    v12 = *(_QWORD *)(a1 + 48);
    v14 = *(_QWORD *)(v12 + 8);
    v18[0] = _NSConcreteStackBlock;
    v18[2] = sub_10004AAF0;
    v18[3] = &unk_100078FC0;
    v18[1] = 0x40000000;
    v21 = a2;
    v22 = v10;
    v18[4] = v8;
    v18[5] = v12;
    v18[6] = v13;
    v15 = *(_OWORD *)(a1 + 72);
    v19 = *(_OWORD *)(a1 + 56);
    v20 = v15;
    v16 = sub_100019D18(v11, a2, (CFTypeRef *)(v14 + 24), (uint64_t)v18);
    v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  else
  {
    v16 = 0;
  }
  *(_BYTE *)(v9 + 24) = v16;
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

uint64_t sub_10004AAF0(uint64_t a1, _BYTE *a2)
{
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int8x16_t v9;
  CFTypeRef *v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  int16x8_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int8x16_t v19;
  CFTypeRef *v20;
  __int128 v21;
  uint64_t v22;
  char v23;
  char v24;
  int v25;
  int v26;
  const __CFString *v27;
  const __CFString *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int8x16_t v33;
  CFTypeRef *v34;
  uint64_t v35;
  char v36;
  const UInt8 *v37;
  const UInt8 *v38;
  int v39;
  CFDataRef v40;
  const __CFData *v41;
  const __CFData *v42;
  const __CFData *v43;
  const __CFData *v44;
  const __CFDictionary *v45;
  const void *Value;
  const void *v47;
  const void *v48;
  const void *v49;
  uint64_t v50;
  const __CFString *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int8x16_t v56;
  CFTypeRef *v57;
  char v58;
  CFAbsoluteTime v59;
  CFAbsoluteTime AbsoluteTime;
  CFDateRef v61;
  CFDateRef v62;
  uint64_t result;
  int8x8_t v64;
  int8x8_t v65;
  CFDateRef v66;
  CFDateRef theDate;
  _QWORD v68[5];
  int8x16_t v69;
  uint64_t v70;
  uint64_t v71;
  _QWORD v72[5];
  int8x16_t v73;
  uint64_t v74;
  uint64_t v75;
  _QWORD v76[5];
  int8x16_t v77;
  __int128 v78;
  uint64_t v79;
  uint64_t v80;
  char v81;
  unsigned int data;
  _QWORD v83[5];
  int8x16_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;

  v4 = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 88), 0);
  v5 = *(_QWORD *)(a1 + 32);
  v6 = *(_QWORD *)(v5 + 8);
  if (*(_BYTE *)(v6 + 24))
  {
    v7 = *(_QWORD *)(a1 + 96);
    v8 = *(_QWORD *)(v7 + 8);
    v83[0] = _NSConcreteStackBlock;
    v9 = vextq_s8(*(int8x16_t *)(a1 + 40), *(int8x16_t *)(a1 + 40), 8uLL);
    v10 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
    v83[1] = 0x40000000;
    v83[2] = sub_10004B134;
    v83[3] = &unk_100078EA8;
    v84 = v9;
    v86 = v7;
    v11 = *(_QWORD *)(a1 + 56);
    v83[4] = v5;
    v85 = v11;
    v12 = sub_10001979C(v8, CFSTR("SELECT count(*) FROM issuers WHERE groupid=?"), v10, (uint64_t)v83);
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  else
  {
    v12 = 0;
  }
  *(_BYTE *)(v6 + 24) = v12;
  v13 = *(_QWORD *)(a1 + 64);
  data = bswap32(*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24));
  CC_SHA256_Update((CC_SHA256_CTX *)(*(_QWORD *)(v13 + 8) + 24), &data, 4u);
  CC_SHA256_Update((CC_SHA256_CTX *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24), &data, 4u);
  if ((v4 & 0x400) != 0)
    CC_SHA256_Update((CC_SHA256_CTX *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 24), &data, 4u);
  v15 = *(_QWORD *)(a1 + 32);
  v16 = *(_QWORD *)(v15 + 8);
  if (*(_BYTE *)(v16 + 24))
  {
    v17 = *(_QWORD *)(a1 + 96);
    v18 = *(_QWORD *)(v17 + 8);
    v76[0] = _NSConcreteStackBlock;
    v19 = vextq_s8(*(int8x16_t *)(a1 + 40), *(int8x16_t *)(a1 + 40), 8uLL);
    v20 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
    v76[1] = 0x40000000;
    v76[2] = sub_10004B244;
    v76[3] = &unk_100078EF8;
    v21 = *(_OWORD *)(a1 + 64);
    v77 = v19;
    v78 = v21;
    v81 = (unint64_t)(v4 & 0x400) >> 10;
    v22 = *(_QWORD *)(a1 + 80);
    v76[4] = v15;
    v79 = v22;
    v80 = v17;
    v23 = sub_10001979C(v18, CFSTR("SELECT issuer_hash FROM issuers WHERE groupid=? ORDER BY issuer_hash ASC"), v20, (uint64_t)v76);
    v16 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  else
  {
    v23 = 0;
  }
  *(_BYTE *)(v16 + 24) = v23;
  v87 = v4 & 1;
  v14.i64[0] = *(_QWORD *)&vshl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v4) & 0xFF00FF00FF00FFLL), (uint16x4_t)0xFFFAFFFBFFFEFFFFLL) & 0xFF01FF01FF01FF01;
  *(_DWORD *)((char *)&v87 + 1) = vmovn_s16(v14).u32[0];
  *(_WORD *)((char *)&v87 + 5) = (v4 & 8) != 0;
  BYTE6(v87) = (v4 & 0x10) != 0;
  CC_SHA256_Update((CC_SHA256_CTX *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24), &v87, 7u);
  v24 = 1;
  v25 = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 88), 1);
  v26 = v25;
  if (v25 != 1)
  {
    if (v25 != 3)
    {
      if (v25 != 2)
      {
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
        goto LABEL_44;
      }
      v24 = 0;
      v27 = CFSTR("SELECT count(*) FROM hashes WHERE groupid=?");
      v28 = CFSTR("sha256");
      goto LABEL_14;
    }
    sub_10004B368(CFSTR("nto1"), *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24);
    v37 = (const UInt8 *)sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 88), 2);
    if (!v37)
      goto LABEL_44;
    v38 = v37;
    v39 = sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 88), 2);
    v40 = CFDataCreate(kCFAllocatorDefault, v38, v39);
    if (!v40)
      goto LABEL_44;
    v41 = v40;
    CFRetain(v40);
    v42 = sub_10004B678(v41);
    v43 = v41;
    if (v42)
    {
      v44 = v42;
      CFRelease(v41);
      v43 = v44;
    }
    v45 = (const __CFDictionary *)CFPropertyListCreateWithData(kCFAllocatorDefault, v43, 0, 0, 0);
    CFRelease(v43);
    if (!v45)
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
LABEL_43:
      CFRelease(v41);
      goto LABEL_44;
    }
    Value = CFDictionaryGetValue(v45, CFSTR("xor"));
    v47 = Value;
    if (Value)
      CFRetain(Value);
    v48 = CFDictionaryGetValue(v45, CFSTR("params"));
    v49 = v48;
    if (v48)
      CFRetain(v48);
    CFRelease(v45);
    if (v47 && v49)
    {
      sub_10004B794(v49, (CC_SHA256_CTX *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24));
      sub_10004B89C(v47, (CC_SHA256_CTX *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24));
    }
    else
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
      if (!v47)
        goto LABEL_41;
    }
    CFRelease(v47);
LABEL_41:
    if (v49)
      CFRelease(v49);
    goto LABEL_43;
  }
  v27 = CFSTR("SELECT count(*) FROM serials WHERE groupid=?");
  v28 = CFSTR("serial");
LABEL_14:
  sub_10004B368(v28, *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24);
  v29 = *(_QWORD *)(a1 + 32);
  v30 = *(_QWORD *)(v29 + 8);
  if (*(_BYTE *)(v30 + 24))
  {
    v31 = *(_QWORD *)(a1 + 96);
    v32 = *(_QWORD *)(v31 + 8);
    v72[0] = _NSConcreteStackBlock;
    v33 = vextq_s8(*(int8x16_t *)(a1 + 40), *(int8x16_t *)(a1 + 40), 8uLL);
    v34 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
    v72[1] = 0x40000000;
    v72[2] = sub_10004B454;
    v72[3] = &unk_100078F48;
    v73 = v33;
    v75 = v31;
    v35 = *(_QWORD *)(a1 + 56);
    v72[4] = v29;
    v74 = v35;
    v36 = sub_10001979C(v32, v27, v34, (uint64_t)v72);
    v30 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  else
  {
    v36 = 0;
  }
  *(_BYTE *)(v30 + 24) = v36;
  v50 = *(_QWORD *)(a1 + 64);
  data = bswap32(*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24));
  CC_SHA256_Update((CC_SHA256_CTX *)(*(_QWORD *)(v50 + 8) + 24), &data, 4u);
  if ((v24 & 1) != 0)
  {
    v51 = CFSTR("SELECT serial FROM serials WHERE groupid=? ORDER BY serial ASC");
  }
  else
  {
    if (v26 != 2)
      goto LABEL_44;
    v51 = CFSTR("SELECT sha256 FROM hashes WHERE groupid=? ORDER by sha256 ASC");
  }
  v52 = *(_QWORD *)(a1 + 32);
  v53 = *(_QWORD *)(v52 + 8);
  if (*(_BYTE *)(v53 + 24))
  {
    v54 = *(_QWORD *)(a1 + 96);
    v55 = *(_QWORD *)(v54 + 8);
    v68[0] = _NSConcreteStackBlock;
    v56 = vextq_s8(*(int8x16_t *)(a1 + 40), *(int8x16_t *)(a1 + 40), 8uLL);
    v57 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
    v68[1] = 0x40000000;
    v68[2] = sub_10004B564;
    v68[3] = &unk_100078F98;
    v68[4] = v52;
    v69 = v56;
    v70 = *(_QWORD *)(a1 + 64);
    v71 = v54;
    v58 = sub_10001979C(v55, v51, v57, (uint64_t)v68);
    v53 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  else
  {
    v58 = 0;
  }
  *(_BYTE *)(v53 + 24) = v58;
LABEL_44:
  v66 = 0;
  theDate = 0;
  v59 = 3.15569088e10;
  if (sub_10004B940(*(_QWORD *)(a1 + 96), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24), &theDate, &v66, (_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24)))
  {
    if (theDate)
    {
      AbsoluteTime = CFDateGetAbsoluteTime(theDate);
      v61 = theDate;
      if (theDate)
      {
        theDate = 0;
        CFRelease(v61);
      }
    }
    else
    {
      AbsoluteTime = -3155760000.0;
    }
    if (v66)
    {
      v59 = CFDateGetAbsoluteTime(v66);
      v62 = v66;
      if (v66)
      {
        v66 = 0;
        CFRelease(v62);
      }
    }
  }
  else
  {
    AbsoluteTime = -3155760000.0;
  }
  v64 = vrev64_s8(*(int8x8_t *)&v59);
  v65 = vrev64_s8(*(int8x8_t *)&AbsoluteTime);
  CC_SHA256_Update((CC_SHA256_CTX *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24), &v64, 8u);
  result = CC_SHA256_Update((CC_SHA256_CTX *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24), &v65, 8u);
  *a2 = 1;
  return result;
}

uint64_t sub_10004B134(_QWORD *a1, sqlite3_stmt *a2)
{
  uint64_t v4;
  CFTypeRef *v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  _QWORD v14[6];

  v4 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v4 + 24))
  {
    v5 = (CFTypeRef *)(*(_QWORD *)(a1[6] + 8) + 24);
    v6 = sqlite3_bind_int64(a2, 1, *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24));
    v7 = sub_10001A970(v6, a2, v5, CFSTR("bind_int64[%d]"), 1);
    v4 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v7 = 0;
  }
  *(_BYTE *)(v4 + 24) = v7;
  v8 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v8 + 24))
  {
    v9 = a1[7];
    v10 = *(_QWORD *)(a1[8] + 8);
    v11 = *(_QWORD *)(a1[6] + 8);
    v14[0] = _NSConcreteStackBlock;
    v14[2] = sub_10004C3C0;
    v14[3] = &unk_100078E80;
    v14[1] = 0x40000000;
    v14[4] = v9;
    v14[5] = a2;
    v12 = sub_100019D18(v10, a2, (CFTypeRef *)(v11 + 24), (uint64_t)v14);
    v8 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v12 = 0;
  }
  *(_BYTE *)(v8 + 24) = v12;
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

uint64_t sub_10004B244(uint64_t a1, sqlite3_stmt *a2)
{
  uint64_t v4;
  CFTypeRef *v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  _QWORD v16[4];
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  sqlite3_stmt *v20;
  char v21;

  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v4 + 24))
  {
    v5 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
    v6 = sqlite3_bind_int64(a2, 1, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
    v7 = sub_10001A970(v6, a2, v5, CFSTR("bind_int64[%d]"), 1);
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  else
  {
    v7 = 0;
  }
  *(_BYTE *)(v4 + 24) = v7;
  v8 = *(_QWORD *)(a1 + 32);
  v9 = *(_QWORD *)(v8 + 8);
  if (*(_BYTE *)(v9 + 24))
  {
    v10 = *(_QWORD *)(a1 + 72);
    v11 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8);
    v12 = *(_QWORD *)(a1 + 48);
    v16[0] = _NSConcreteStackBlock;
    v13 = *(_QWORD *)(v12 + 8);
    v16[2] = sub_10004C300;
    v16[3] = &unk_100078ED0;
    v21 = *(_BYTE *)(a1 + 88);
    v16[1] = 0x40000000;
    v19 = v8;
    v20 = a2;
    v17 = *(_OWORD *)(a1 + 56);
    v18 = v10;
    v14 = sub_100029B6C(v11, a2, (CFTypeRef *)(v13 + 24), (uint64_t)v16);
    v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  else
  {
    v14 = 0;
  }
  *(_BYTE *)(v9 + 24) = v14;
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

const __CFString *sub_10004B368(const __CFString *cf, uint64_t a2)
{
  const __CFString *v2;
  CFTypeID v4;
  _QWORD v6[6];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  char v10;
  _QWORD v11[5];

  v2 = cf;
  if (cf)
  {
    v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID())
    {
      v7 = 0;
      v8 = &v7;
      v9 = 0x2000000000;
      v10 = 0;
      v6[0] = _NSConcreteStackBlock;
      v6[1] = 0x40000000;
      v6[2] = sub_10004C28C;
      v6[3] = &unk_100079060;
      v6[4] = &v7;
      v6[5] = a2;
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 0x40000000;
      v11[2] = sub_100026C34;
      v11[3] = &unk_100075DD0;
      v11[4] = v6;
      sub_100019A20(v2, (uint64_t)v11);
      v2 = (const __CFString *)(*((_BYTE *)v8 + 24) != 0);
      _Block_object_dispose(&v7, 8);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t sub_10004B454(_QWORD *a1, sqlite3_stmt *a2)
{
  uint64_t v4;
  CFTypeRef *v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  _QWORD v14[6];

  v4 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v4 + 24))
  {
    v5 = (CFTypeRef *)(*(_QWORD *)(a1[6] + 8) + 24);
    v6 = sqlite3_bind_int64(a2, 1, *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24));
    v7 = sub_10001A970(v6, a2, v5, CFSTR("bind_int64[%d]"), 1);
    v4 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v7 = 0;
  }
  *(_BYTE *)(v4 + 24) = v7;
  v8 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v8 + 24))
  {
    v9 = a1[7];
    v10 = *(_QWORD *)(a1[8] + 8);
    v11 = *(_QWORD *)(a1[6] + 8);
    v14[0] = _NSConcreteStackBlock;
    v14[2] = sub_10004C24C;
    v14[3] = &unk_100078F20;
    v14[1] = 0x40000000;
    v14[4] = v9;
    v14[5] = a2;
    v12 = sub_100019D18(v10, a2, (CFTypeRef *)(v11 + 24), (uint64_t)v14);
    v8 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v12 = 0;
  }
  *(_BYTE *)(v8 + 24) = v12;
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

uint64_t sub_10004B564(_QWORD *a1, sqlite3_stmt *a2)
{
  uint64_t v4;
  CFTypeRef *v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  _QWORD v15[7];

  v4 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v4 + 24))
  {
    v5 = (CFTypeRef *)(*(_QWORD *)(a1[6] + 8) + 24);
    v6 = sqlite3_bind_int64(a2, 1, *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24));
    v7 = sub_10001A970(v6, a2, v5, CFSTR("bind_int64[%d]"), 1);
    v4 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v7 = 0;
  }
  *(_BYTE *)(v4 + 24) = v7;
  v8 = a1[4];
  v9 = *(_QWORD *)(v8 + 8);
  if (*(_BYTE *)(v9 + 24))
  {
    v10 = a1[7];
    v11 = *(_QWORD *)(a1[8] + 8);
    v12 = *(_QWORD *)(a1[6] + 8);
    v15[0] = _NSConcreteStackBlock;
    v15[2] = sub_10004C1BC;
    v15[3] = &unk_100078F70;
    v15[1] = 0x40000000;
    v15[5] = v8;
    v15[6] = a2;
    v15[4] = v10;
    v13 = sub_100029B6C(v11, a2, (CFTypeRef *)(v12 + 24), (uint64_t)v15);
    v9 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v13 = 0;
  }
  *(_BYTE *)(v9 + 24) = v13;
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

const __CFData *sub_10004B678(const __CFData *a1)
{
  const __CFData *Mutable;
  size_t v3;
  size_t v4;
  uInt v5;
  Bytef *v6;
  int v7;
  CFIndex Length;
  z_stream v9;

  Mutable = a1;
  if (a1)
  {
    memset(&v9, 0, sizeof(v9));
    if (inflateInit2_(&v9, 47, "1.2.12", 112))
      return 0;
    v9.next_in = (Bytef *)CFDataGetBytePtr(Mutable);
    v9.avail_in = CFDataGetLength(Mutable);
    Mutable = CFDataCreateMutable(0, 0);
    if (Mutable)
    {
      v3 = v9.avail_in ? v9.avail_in : 4096;
      v4 = malloc_good_size(v3);
      v5 = v4;
      v6 = (Bytef *)malloc_type_malloc(v4, 0xE7C77AD2uLL);
      do
      {
        v9.next_out = v6;
        v9.avail_out = v5;
        v7 = inflate(&v9, 0);
        Length = CFDataGetLength(Mutable);
        if ((uint64_t)v9.total_out > Length)
          CFDataAppendBytes(Mutable, v6, v9.total_out - Length);
      }
      while (!v7);
      inflateEnd(&v9);
      free(v6);
      if (v7 != 1)
      {
        CFRelease(Mutable);
        return 0;
      }
    }
  }
  return Mutable;
}

BOOL sub_10004B794(const void *a1, CC_SHA256_CTX *a2)
{
  CFTypeID v4;
  _BOOL8 v5;
  _QWORD context[6];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  char v11;
  unsigned int data;
  CFRange v13;

  v4 = CFGetTypeID(a1);
  if (v4 != CFArrayGetTypeID() || CFArrayGetCount((CFArrayRef)a1) < 0)
    return 0;
  data = bswap32(CFArrayGetCount((CFArrayRef)a1));
  CC_SHA256_Update(a2, &data, 4u);
  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 1;
  context[0] = _NSConcreteStackBlock;
  context[1] = 0x40000000;
  context[2] = sub_10004BD90;
  context[3] = &unk_100079088;
  context[4] = &v8;
  context[5] = a2;
  v13.length = CFArrayGetCount((CFArrayRef)a1);
  v13.location = 0;
  CFArrayApplyFunction((CFArrayRef)a1, v13, (CFArrayApplierFunction)sub_10004BDD4, context);
  v5 = *((_BYTE *)v9 + 24) != 0;
  _Block_object_dispose(&v8, 8);
  return v5;
}

BOOL sub_10004B89C(const void *a1, CC_SHA256_CTX *a2)
{
  CFTypeID v4;
  unsigned int Length;
  const UInt8 *BytePtr;
  _BOOL8 v7;
  unsigned int data;

  v4 = CFGetTypeID(a1);
  if (v4 != CFDataGetTypeID() || CFDataGetLength((CFDataRef)a1) < 0)
    return 0;
  Length = CFDataGetLength((CFDataRef)a1);
  data = bswap32(Length);
  CC_SHA256_Update(a2, &data, 4u);
  BytePtr = CFDataGetBytePtr((CFDataRef)a1);
  v7 = BytePtr != 0;
  if (BytePtr)
    CC_SHA256_Update(a2, BytePtr, Length);
  return v7;
}

uint64_t sub_10004B940(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v8;
  int v9;
  uint64_t *v10;
  BOOL *v11;
  uint64_t v12;
  _BOOL4 v13;
  NSObject *v14;
  uint64_t v15;
  __CFError *v16;
  CFIndex Code;
  const void *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  const void *v22;
  uint64_t v23;
  _QWORD v25[10];
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  CFTypeRef v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  BOOL v41;
  uint8_t buf[4];
  uint64_t v43;

  v38 = 0;
  v39 = &v38;
  v40 = 0x2000000000;
  v41 = a1 != 0;
  v34 = 0;
  v35 = &v34;
  v36 = 0x2000000000;
  v37 = 0;
  v30 = 0;
  v31 = &v30;
  v32 = 0x2000000000;
  v33 = 0;
  v26 = 0;
  v27 = &v26;
  v28 = 0x2000000000;
  v29 = 0;
  if (!a1)
  {
    v13 = 0;
    v11 = &v41;
    v41 = 0;
    goto LABEL_6;
  }
  v8 = *(_QWORD *)(a1 + 8);
  v25[0] = _NSConcreteStackBlock;
  v25[1] = 0x40000000;
  v25[2] = sub_10004BC04;
  v25[3] = &unk_100078990;
  v25[4] = &v38;
  v25[5] = &v26;
  v25[8] = a2;
  v25[9] = a1;
  v25[6] = &v34;
  v25[7] = &v30;
  v9 = sub_10001979C(v8, CFSTR("SELECT notbefore,notafter FROM dates WHERE groupid=?"), &v29, (uint64_t)v25);
  v10 = v39;
  *((_BYTE *)v39 + 24) = v9;
  v11 = (BOOL *)(v10 + 3);
  v12 = v27[3];
  if (v9)
  {
    if (v12)
    {
      *v11 = 0;
      goto LABEL_9;
    }
    if (v35[3])
      v13 = 1;
    else
      v13 = v31[3] != 0;
LABEL_6:
    *v11 = v13;
    if (v13)
      goto LABEL_19;
    goto LABEL_15;
  }
  *v11 = 0;
  if (!v12)
  {
LABEL_15:
    v18 = (const void *)v35[3];
    if (v18)
    {
      v35[3] = 0;
      CFRelease(v18);
    }
    v19 = (const void *)v31[3];
    if (v19)
    {
      v31[3] = 0;
      CFRelease(v19);
    }
    goto LABEL_19;
  }
LABEL_9:
  v14 = sub_100011628("SecError");
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    v15 = v27[3];
    *(_DWORD *)buf = 138412290;
    v43 = v15;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbCopyDateConstraints failed: %@", buf, 0xCu);
  }
  v16 = (__CFError *)v27[3];
  if (v16)
    Code = CFErrorGetCode(v16);
  else
    Code = -2070;
  sub_1000521A8(1, 3, Code);
  if (!*((_BYTE *)v39 + 24))
    goto LABEL_15;
LABEL_19:
  v20 = (const void *)v35[3];
  if (a3)
  {
    *a3 = v20;
  }
  else if (v20)
  {
    CFRelease(v20);
  }
  v21 = (const void *)v31[3];
  if (a4)
  {
    *a4 = v21;
  }
  else if (v21)
  {
    CFRelease(v21);
  }
  v22 = (const void *)v27[3];
  if (v22)
  {
    if (a5 && !*a5)
      *a5 = v22;
    else
      CFRelease(v22);
  }
  v23 = *((unsigned __int8 *)v39 + 24);
  _Block_object_dispose(&v26, 8);
  _Block_object_dispose(&v30, 8);
  _Block_object_dispose(&v34, 8);
  _Block_object_dispose(&v38, 8);
  return v23;
}

uint64_t sub_10004BC04(uint64_t a1, sqlite3_stmt *a2)
{
  CFTypeRef *v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  CFTypeRef *v11;
  char v12;
  _QWORD v14[4];
  __int128 v15;
  sqlite3_stmt *v16;

  v4 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  v5 = sqlite3_bind_int64(a2, 1, *(_QWORD *)(a1 + 64));
  v6 = sub_10001A970(v5, a2, v4, CFSTR("bind_int64[%d]"), 1);
  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v7 + 24))
    v8 = v6;
  else
    v8 = 0;
  *(_BYTE *)(v7 + 24) = v8;
  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v9 + 24))
  {
    v10 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8);
    v11 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 0x40000000;
    v14[2] = sub_10004BD0C;
    v14[3] = &unk_100078968;
    v16 = a2;
    v15 = *(_OWORD *)(a1 + 48);
    v12 = sub_100019D18(v10, a2, v11, (uint64_t)v14);
    v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  else
  {
    v12 = 0;
  }
  *(_BYTE *)(v9 + 24) = v12;
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

CFDateRef sub_10004BD0C(uint64_t a1)
{
  double v2;
  CFDateRef result;
  double v4;

  if (sqlite3_column_type(*(sqlite3_stmt **)(a1 + 48), 0) != 5)
  {
    v2 = sqlite3_column_double(*(sqlite3_stmt **)(a1 + 48), 0);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = CFDateCreate(0, v2);
  }
  result = (CFDateRef)sqlite3_column_type(*(sqlite3_stmt **)(a1 + 48), 1);
  if ((_DWORD)result != 5)
  {
    v4 = sqlite3_column_double(*(sqlite3_stmt **)(a1 + 48), 1);
    result = CFDateCreate(0, v4);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = result;
  }
  return result;
}

uint64_t sub_10004BD90(uint64_t a1, const __CFString *a2)
{
  uint64_t result;
  uint64_t v4;
  char v5;

  result = sub_10004BDE8(a2, *(CC_SHA256_CTX **)(a1 + 40));
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v4 + 24))
    v5 = result;
  else
    v5 = 0;
  *(_BYTE *)(v4 + 24) = v5;
  return result;
}

uint64_t sub_10004BDD4(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_10004BDE8(const __CFString *a1, CC_SHA256_CTX *a2)
{
  CFTypeID v4;
  CFTypeID v6;
  CFTypeID TypeID;
  CFTypeID v8;
  unint64_t Count;
  uint64_t v10;
  CFTypeID v11;
  int64_t v12;
  size_t v13;
  const void **v14;
  const void **v15;
  const void **v16;
  int64_t v17;
  const __CFString *v18;
  const void *Value;
  CFTypeID v21;
  CFTypeID v22;
  CFTypeID v23;
  unsigned int data;
  unsigned int valuePtr;

  if (!a1)
    return 0;
  v4 = CFGetTypeID(a1);
  if (v4 == CFArrayGetTypeID())
    return sub_10004B794(a1, a2);
  v6 = CFGetTypeID(a1);
  TypeID = CFDictionaryGetTypeID();
  v8 = CFGetTypeID(a1);
  if (v6 == TypeID)
  {
    if (v8 == CFDictionaryGetTypeID())
    {
      Count = CFDictionaryGetCount((CFDictionaryRef)a1);
      if (Count <= 0xFFFFFFFFFFFFFFELL)
      {
        v12 = Count;
        v13 = 8 * Count;
        v14 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
        v15 = (const void **)malloc_type_malloc(v13, 0x80040B8603338uLL);
        v16 = v15;
        v10 = 0;
        if (v14 && v15)
        {
          CFDictionaryGetKeysAndValues((CFDictionaryRef)a1, v14, v15);
          qsort(v14, v12, 8uLL, (int (__cdecl *)(const void *, const void *))sub_10004C0C0);
          data = bswap32(v12);
          CC_SHA256_Update(a2, &data, 4u);
          if (v12)
          {
            v17 = 0;
            do
            {
              v18 = (const __CFString *)v14[v17];
              Value = CFDictionaryGetValue((CFDictionaryRef)a1, v18);
              LODWORD(v18) = sub_10004B368(v18, (uint64_t)a2);
              v10 = v18 & sub_10004BDE8(Value, a2);
              ++v17;
            }
            while ((_DWORD)v10 == 1 && v17 < v12);
          }
          else
          {
            v10 = 1;
          }
        }
        free(v14);
        free(v16);
        return v10;
      }
    }
    return 0;
  }
  if (v8 == CFDataGetTypeID())
    return sub_10004B89C(a1, a2);
  v11 = CFGetTypeID(a1);
  if (v11 == CFStringGetTypeID())
    return (uint64_t)sub_10004B368(a1, (uint64_t)a2);
  v21 = CFGetTypeID(a1);
  if (v21 == CFNumberGetTypeID())
  {
    valuePtr = 0;
    v22 = CFGetTypeID(a1);
    v10 = 0;
    if (v22 != CFNumberGetTypeID())
      return v10;
    if (CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt32Type, &valuePtr))
    {
      valuePtr = bswap32(valuePtr);
      CC_SHA256_Update(a2, &valuePtr, 4u);
      return 1;
    }
    return 0;
  }
  v23 = CFGetTypeID(a1);
  if (v23 != CFBooleanGetTypeID())
    return 0;
  return sub_10004C148(a1, a2);
}

uint64_t sub_10004C0C0(CFTypeRef *a1, const __CFString **a2)
{
  const __CFString *v2;
  const __CFString *v3;
  CFTypeID v4;
  CFTypeID v6;
  CFComparisonResult v7;

  v2 = (const __CFString *)*a1;
  if (!*a1)
    return 0xFFFFFFFFLL;
  v3 = *a2;
  v4 = CFGetTypeID(*a1);
  if (v4 != CFStringGetTypeID() || v3 == 0)
    return 0xFFFFFFFFLL;
  v6 = CFGetTypeID(v3);
  if (v6 != CFStringGetTypeID())
    return 0xFFFFFFFFLL;
  v7 = CFStringCompare(v2, v3, 0);
  if (v7 == kCFCompareLessThan)
    return 0xFFFFFFFFLL;
  else
    return v7 == kCFCompareGreaterThan;
}

BOOL sub_10004C148(const void *a1, CC_SHA256_CTX *a2)
{
  CFTypeID v4;
  CFTypeID TypeID;
  BOOL data;

  v4 = CFGetTypeID(a1);
  TypeID = CFBooleanGetTypeID();
  if (v4 == TypeID)
  {
    data = CFBooleanGetValue((CFBooleanRef)a1) != 0;
    CC_SHA256_Update(a2, &data, 1u);
  }
  return v4 == TypeID;
}

uint64_t sub_10004C1BC(uint64_t a1)
{
  const UInt8 *v2;
  const UInt8 *v3;
  int v4;
  CFDataRef v5;
  CFDataRef v6;

  v2 = (const UInt8 *)sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 48), 0);
  if (v2
    && (v3 = v2,
        v4 = sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 48), 0),
        (v5 = CFDataCreate(kCFAllocatorDefault, v3, v4)) != 0))
  {
    v6 = v5;
    sub_10004B89C(v5, (CC_SHA256_CTX *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
    CFRelease(v6);
  }
  else
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
  }
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
}

sqlite3_int64 sub_10004C24C(uint64_t a1, _BYTE *a2)
{
  sqlite3_int64 result;

  result = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  *a2 = 1;
  return result;
}

uint64_t sub_10004C28C(uint64_t a1, char *__s)
{
  unsigned int v4;
  uint64_t result;
  unsigned int data;

  v4 = strlen(__s);
  data = bswap32(v4);
  CC_SHA256_Update(*(CC_SHA256_CTX **)(a1 + 40), &data, 4u);
  result = CC_SHA256_Update(*(CC_SHA256_CTX **)(a1 + 40), __s, v4);
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  return result;
}

uint64_t sub_10004C300(uint64_t a1)
{
  const UInt8 *v2;
  const UInt8 *v3;
  int v4;
  CFDataRef v5;
  CFDataRef v6;

  v2 = (const UInt8 *)sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 64), 0);
  if (v2
    && (v3 = v2,
        v4 = sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 64), 0),
        (v5 = CFDataCreate(kCFAllocatorDefault, v3, v4)) != 0))
  {
    v6 = v5;
    sub_10004B89C(v5, (CC_SHA256_CTX *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
    sub_10004B89C(v6, (CC_SHA256_CTX *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
    if (*(_BYTE *)(a1 + 72))
      sub_10004B89C(v6, (CC_SHA256_CTX *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24));
    CFRelease(v6);
  }
  else
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = 0;
  }
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24);
}

sqlite3_int64 sub_10004C3C0(uint64_t a1, _BYTE *a2)
{
  sqlite3_int64 result;

  result = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  *a2 = 1;
  return result;
}

sqlite3_int64 sub_10004C400(uint64_t a1, _BYTE *a2)
{
  sqlite3_int64 result;

  result = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  *a2 = 1;
  return result;
}

uint64_t sub_10004C440(_QWORD *a1, sqlite3_stmt *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  _QWORD v9[6];

  v3 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v3 + 24))
  {
    v4 = a1[6];
    v5 = *(_QWORD *)(a1[7] + 8);
    v6 = *(_QWORD *)(a1[5] + 8);
    v9[0] = _NSConcreteStackBlock;
    v9[2] = sub_10004C4E0;
    v9[3] = &unk_100078A30;
    v9[1] = 0x40000000;
    v9[4] = v4;
    v9[5] = a2;
    v7 = sub_100019D18(v5, a2, (CFTypeRef *)(v6 + 24), (uint64_t)v9);
    v3 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v7 = 0;
  }
  *(_BYTE *)(v3 + 24) = v7;
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

sqlite3_int64 sub_10004C4E0(uint64_t a1, _BYTE *a2)
{
  sqlite3_int64 result;

  result = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  *a2 = 1;
  return result;
}

void sub_10004C520(uint64_t a1, _BYTE *a2)
{
  const UInt8 *v4;
  int v5;
  int v6;
  CFDataRef v7;
  CFDataRef v8;

  v4 = (const UInt8 *)sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 40), 0);
  v5 = sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 40), 0);
  if (v4 && v5 >= 32)
  {
    v6 = v5 + 32;
    do
    {
      v7 = CFDataCreate(kCFAllocatorDefault, v4, 32);
      if (v7)
      {
        v8 = v7;
        CFArrayAppendValue(*(CFMutableArrayRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), v7);
        CFRelease(v8);
      }
      v4 += 32;
      v6 -= 32;
    }
    while (v6 > 63);
  }
  *a2 = 1;
}

uint64_t sub_10004C5D4(_QWORD *a1, CFErrorRef *a2)
{
  int v4;
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  CFIndex Code;
  CFErrorRef err;
  uint8_t buf[4];
  CFErrorRef v12;

  err = 0;
  if (a1)
    v4 = sub_1000279E0(a1[1], CFSTR("DELETE FROM groups; DELETE FROM admin WHERE key='version'; DELETE FROM sqlite_sequence"),
           (CFTypeRef *)&err);
  else
    v4 = 0;
  v5 = sub_100011628("validupdate");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    LODWORD(v12) = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "resetting database, result: %d (expected 1)", buf, 8u);
  }
  if (v4 && sub_1000472FC(a1))
  {
    v6 = sub_10004E860(a1, &err);
    if ((_DWORD)v6 && !err)
      return 1;
  }
  else
  {
    v6 = 0;
  }
  v7 = sub_100011628("SecError");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    v12 = err;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbRemoveAllEntries failed: %@", buf, 0xCu);
  }
  if (err)
    Code = CFErrorGetCode(err);
  else
    Code = -2070;
  sub_1000521A8(1, 2, Code);
  if (err)
  {
    if (a2 && !*a2)
      *a2 = err;
    else
      CFRelease(err);
  }
  return v6;
}

BOOL sub_10004C77C(uint64_t a1, CFStringRef theString, _QWORD *a3)
{
  __int128 v6;
  NSObject *v7;
  _BOOL8 v8;
  uint64_t v9;
  int v10;
  uint8_t *v11;
  NSObject *v12;
  uint64_t v13;
  __CFError *v14;
  CFIndex Code;
  const void *v16;
  const void *v17;
  NSObject *v19;
  _QWORD v20[8];
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  BOOL v24;
  uint8_t v25[8];
  uint8_t *v26;
  uint64_t v27;
  CFTypeRef v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  const char *CStringPtr;
  uint8_t buf[4];
  uint64_t v34;
  char buffer[16];
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;

  if (theString)
  {
    *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v49 = v6;
    v50 = v6;
    v47 = v6;
    v48 = v6;
    v45 = v6;
    v46 = v6;
    v43 = v6;
    v44 = v6;
    v41 = v6;
    v42 = v6;
    v39 = v6;
    v40 = v6;
    v37 = v6;
    v38 = v6;
    *(_OWORD *)buffer = v6;
    v36 = v6;
    v29 = 0;
    v30 = &v29;
    v31 = 0x2000000000;
    CStringPtr = (const char *)0xAAAAAAAAAAAAAAAALL;
    CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
    if (!v30[3])
    {
      if (CFStringGetCString(theString, buffer, 256, 0x8000100u))
      {
        v30[3] = (uint64_t)buffer;
      }
      else if (!v30[3])
      {
        v19 = sub_100011628("SecError");
        v8 = 0;
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v25 = 0;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbSetUpdateSource failed: unable to get UTF-8 encoding", v25, 2u);
          v8 = 0;
        }
        goto LABEL_26;
      }
    }
    *(_QWORD *)v25 = 0;
    v26 = v25;
    v27 = 0x2000000000;
    v28 = 0;
    v21 = 0;
    v22 = &v21;
    v23 = 0x2000000000;
    v24 = a1 != 0;
    if (a1)
    {
      v9 = *(_QWORD *)(a1 + 8);
      v20[0] = _NSConcreteStackBlock;
      v20[1] = 0x40000000;
      v20[2] = sub_10004EE1C;
      v20[3] = &unk_100078048;
      v20[4] = &v21;
      v20[5] = v25;
      v20[6] = &v29;
      v20[7] = a1;
      v10 = sub_10001979C(v9, CFSTR("INSERT OR REPLACE INTO admin (key,ival,value) VALUES (?,?,?)"), &v28, (uint64_t)v20);
      *((_BYTE *)v22 + 24) = v10;
      if (v10)
      {
        v11 = v26;
        if (!*((_QWORD *)v26 + 3))
        {
LABEL_23:
          v17 = (const void *)*((_QWORD *)v11 + 3);
          if (v17)
            CFRelease(v17);
          v8 = *((_BYTE *)v22 + 24) != 0;
          _Block_object_dispose(&v21, 8);
          _Block_object_dispose(v25, 8);
LABEL_26:
          _Block_object_dispose(&v29, 8);
          return v8;
        }
      }
    }
    else
    {
      v24 = 0;
    }
    v12 = sub_100011628("SecError");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      v13 = *((_QWORD *)v26 + 3);
      *(_DWORD *)buf = 138412290;
      v34 = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbSetUpdateSource failed: %@", buf, 0xCu);
    }
    v14 = (__CFError *)*((_QWORD *)v26 + 3);
    if (v14)
      Code = CFErrorGetCode(v14);
    else
      Code = -2070;
    sub_1000521A8(1, 2, Code);
    v11 = v26;
    v16 = (const void *)*((_QWORD *)v26 + 3);
    if (v16)
    {
      if (a3 && !*a3)
      {
        *a3 = v16;
      }
      else
      {
        CFRelease(v16);
        v11 = v26;
      }
    }
    goto LABEL_23;
  }
  v7 = sub_100011628("SecError");
  v8 = 0;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buffer = 67109120;
    *(_DWORD *)&buffer[4] = -50;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbSetUpdateSource failed: %d", (uint8_t *)buffer, 8u);
    return 0;
  }
  return v8;
}

BOOL sub_10004CABC(uint64_t a1, sqlite3_stmt *a2)
{
  CFIndex Count;
  CFIndex v5;
  unint64_t v6;
  void *v7;
  void *v8;
  BOOL v9;
  CFIndex v10;
  _OWORD *v11;
  const __CFData *ValueAtIndex;
  const __CFData *v13;
  const UInt8 *BytePtr;
  const UInt8 *v15;
  __int128 v16;
  uint64_t v17;
  CFTypeRef *v18;
  uint64_t v19;
  BOOL v20;
  uint64_t v22;
  CFTypeRef *v23;
  uint64_t v24;
  BOOL v25;
  uint64_t v26;
  BOOL v27;
  uint64_t v28;
  char v29;

  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 48));
  if (Count < 0)
    return 0;
  v5 = Count;
  v6 = 32 * Count;
  v7 = malloc_type_calloc(32 * Count, 1uLL, 0x650C5268uLL);
  v8 = v7;
  if (v5)
    v9 = v7 == 0;
  else
    v9 = 1;
  if (!v9)
  {
    v10 = 0;
    v11 = v7;
    do
    {
      ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 48), v10);
      if (ValueAtIndex)
      {
        v13 = ValueAtIndex;
        BytePtr = CFDataGetBytePtr(ValueAtIndex);
        if (BytePtr)
        {
          v15 = BytePtr;
          if (CFDataGetLength(v13) == 32)
          {
            v16 = *((_OWORD *)v15 + 1);
            *v11 = *(_OWORD *)v15;
            v11[1] = v16;
          }
        }
      }
      v11 += 2;
      ++v10;
    }
    while (v5 != v10);
  }
  v17 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v17 + 24))
  {
    v18 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
    v19 = sqlite3_bind_text(a2, 1, "db_hash", 7, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
    v20 = sub_10001A970(v19, a2, v18, CFSTR("bind_text[%d]"), 1);
    v17 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  else
  {
    v20 = 0;
  }
  *(_BYTE *)(v17 + 24) = v20;
  v22 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v22 + 24))
  {
    v23 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
    v24 = sqlite3_bind_int64(a2, 2, 0);
    v25 = sub_10001A970(v24, a2, v23, CFSTR("bind_int64[%d]"), 2);
    v22 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  else
  {
    v25 = 0;
  }
  *(_BYTE *)(v22 + 24) = v25;
  v26 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v26 + 24))
  {
    v27 = sub_10001A8F8(a2, 3, v8, v6, (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
    v26 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  else
  {
    v27 = 0;
  }
  *(_BYTE *)(v26 + 24) = v27;
  v28 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v28 + 24))
  {
    v29 = sub_100019D18(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8), a2, (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), 0);
    v28 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  else
  {
    v29 = 0;
  }
  *(_BYTE *)(v28 + 24) = v29;
  free(v8);
  return *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) != 0;
}

CFAbsoluteTime sub_10004CCFC(uint64_t a1)
{
  uint64_t v1;
  const __CFNumber *v2;
  const __CFNumber *v3;
  CFTypeID v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t valuePtr;

  v1 = a1;
  valuePtr = a1;
  v2 = (const __CFNumber *)CFPreferencesCopyValue(CFSTR("ValidUpdateInterval"), CFSTR("com.apple.security"), kCFPreferencesAnyUser, kCFPreferencesCurrentHost);
  if (v2)
  {
    v3 = v2;
    v4 = CFGetTypeID(v2);
    if (v4 == CFNumberGetTypeID())
      CFNumberGetValue(v3, kCFNumberCFIndexType, &valuePtr);
    CFRelease(v3);
    v1 = valuePtr;
  }
  if (v1 <= 0)
  {
    v5 = 10800;
    goto LABEL_10;
  }
  if ((unint64_t)v1 <= 0x12B)
  {
    v5 = 300;
LABEL_10:
    valuePtr = v5;
    goto LABEL_11;
  }
  v5 = 604800;
  if ((unint64_t)v1 > 0x93A80)
    goto LABEL_10;
LABEL_11:
  v6 = arc4random() % (uint64_t)((double)valuePtr * 0.5);
  return CFAbsoluteTimeGetCurrent() + (double)valuePtr + (double)v6;
}

uint64_t sub_10004CDF8(_QWORD *a1, sqlite3_stmt *a2)
{
  CFTypeRef *v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  char v10;

  v4 = (CFTypeRef *)(*(_QWORD *)(a1[6] + 8) + 24);
  v5 = sqlite3_bind_int64(a2, 1, *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24));
  v6 = sub_10001A970(v5, a2, v4, CFSTR("bind_int64[%d]"), 1);
  v7 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v7 + 24))
    v8 = v6;
  else
    v8 = 0;
  *(_BYTE *)(v7 + 24) = v8;
  v9 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v9 + 24))
  {
    v10 = sub_100019D18(*(_QWORD *)(a1[7] + 8), a2, (CFTypeRef *)(*(_QWORD *)(a1[6] + 8) + 24), 0);
    v9 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v10 = 0;
  }
  *(_BYTE *)(v9 + 24) = v10;
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

uint64_t sub_10004CEC8(_QWORD *a1, sqlite3_stmt *a2)
{
  uint64_t v4;
  CFTypeRef *v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  char v9;

  v4 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v4 + 24))
  {
    v5 = (CFTypeRef *)(*(_QWORD *)(a1[6] + 8) + 24);
    v6 = sqlite3_bind_int64(a2, 1, *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24));
    v7 = sub_10001A970(v6, a2, v5, CFSTR("bind_int64[%d]"), 1);
    v4 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v7 = 0;
  }
  *(_BYTE *)(v4 + 24) = v7;
  v8 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v8 + 24))
  {
    v9 = sub_100019D18(*(_QWORD *)(a1[7] + 8), a2, (CFTypeRef *)(*(_QWORD *)(a1[6] + 8) + 24), 0);
    v8 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v9 = 0;
  }
  *(_BYTE *)(v8 + 24) = v9;
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

uint64_t sub_10004CFA4(_QWORD *a1, sqlite3_stmt *a2)
{
  uint64_t v4;
  CFTypeRef *v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  char v9;

  v4 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v4 + 24))
  {
    v5 = (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24);
    v6 = sqlite3_bind_int64(a2, 1, a1[6]);
    v7 = sub_10001A970(v6, a2, v5, CFSTR("bind_int64[%d]"), 1);
    v4 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v7 = 0;
  }
  *(_BYTE *)(v4 + 24) = v7;
  v8 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v8 + 24))
  {
    v9 = sub_100019D18(*(_QWORD *)(a1[7] + 8), a2, (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24), 0);
    v8 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v9 = 0;
  }
  *(_BYTE *)(v8 + 24) = v9;
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

uint64_t sub_10004D07C(_QWORD *a1, sqlite3_stmt *a2)
{
  const void *v4;
  const void *v5;
  CFTypeID v6;
  CFTypeID v7;
  const void *v8;
  CFTypeID v9;
  CFTypeRef *v10;
  uint64_t v11;
  int v12;
  CFTypeRef *v13;
  uint64_t v14;
  int v15;
  CFMutableDataRef v16;
  const __CFDictionary *Data;
  const __CFData *v18;
  const __CFData *v19;
  CFTypeID v20;
  _BOOL4 v21;
  sqlite3_int64 v22;
  CFTypeRef *v23;
  uint64_t v24;
  const __CFData *v25;
  const __CFArray *v26;
  const __CFArray *v27;
  const __CFArray *v28;
  const UInt8 *v29;
  CFIndex v30;
  void *v32;
  void *v33;
  CFTypeID v34;
  _BOOL4 v35;
  const __CFAllocator *v36;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v38;
  const __CFData *v39;
  const __CFData *v40;
  const __CFData *v41;
  const __CFDictionary *v42;
  const __CFData *v43;
  const __CFDictionary *v44;
  const __CFData *v45;
  void *v46;
  __CFDictionary *v47;
  uint64_t Length;
  __CFData *MutableCopy;
  __CFData *v50;
  UInt8 *MutableBytePtr;
  const UInt8 *BytePtr;
  char v53;
  int v54;
  void *v55;
  __CFDictionary *v56;
  const UInt8 *v57;
  CFIndex v58;
  CFMutableDataRef v59;
  size_t avail_in;
  size_t v61;
  Bytef *v62;
  unsigned int v63;
  int v64;
  CFIndex v65;
  const __CFAllocator *v66;
  CFMutableDictionaryRef value;
  void *valuea;
  const __CFDictionary *cf;
  char v70;
  z_stream strm;

  if (!*(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24))
    goto LABEL_24;
  if (!*(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24))
  {
    v22 = a1[13];
    if ((v22 & 0x8000000000000000) == 0)
    {
      v23 = (CFTypeRef *)(*(_QWORD *)(a1[6] + 8) + 24);
      v24 = sqlite3_bind_int64(a2, 1, v22);
      *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = sub_10001A970(v24, a2, v23, CFSTR("bind_int64[%d]"), 1);
      if (!*(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24))
        goto LABEL_24;
    }
  }
  sub_10004EC40(a1[14], CFSTR("complete"), 1, (uint64_t *)(*(_QWORD *)(a1[7] + 8) + 24));
  sub_10004EC40(a1[14], CFSTR("check-ocsp"), 2, (uint64_t *)(*(_QWORD *)(a1[7] + 8) + 24));
  sub_10004EC40(a1[14], CFSTR("known-intermediates-only"), 4, (uint64_t *)(*(_QWORD *)(a1[7] + 8) + 24));
  sub_10004EC40(a1[14], CFSTR("require-ct"), 8, (uint64_t *)(*(_QWORD *)(a1[7] + 8) + 24));
  sub_10004EC40(a1[14], CFSTR("valid"), 16, (uint64_t *)(*(_QWORD *)(a1[7] + 8) + 24));
  sub_10004EC40(a1[14], CFSTR("no-ca"), 32, (uint64_t *)(*(_QWORD *)(a1[7] + 8) + 24));
  sub_10004EC40(a1[14], CFSTR("no-ca-v2"), 1024, (uint64_t *)(*(_QWORD *)(a1[7] + 8) + 24));
  sub_10004EC40(a1[14], CFSTR("overridable"), 64, (uint64_t *)(*(_QWORD *)(a1[7] + 8) + 24));
  v4 = CFDictionaryGetValue((CFDictionaryRef)a1[14], CFSTR("not-before"));
  v5 = CFDictionaryGetValue((CFDictionaryRef)a1[14], CFSTR("not-after"));
  if (v4 && (v6 = CFGetTypeID(v4), v6 == CFDateGetTypeID()) || v5 && (v7 = CFGetTypeID(v5), v7 == CFDateGetTypeID()))
    sub_10004EC40(a1[14], CFSTR("1"), 128, (uint64_t *)(*(_QWORD *)(a1[7] + 8) + 24));
  v8 = CFDictionaryGetValue((CFDictionaryRef)a1[14], CFSTR("policies"));
  if (v8)
  {
    v9 = CFGetTypeID(v8);
    if (v9 == CFArrayGetTypeID())
      sub_10004EC40(a1[14], CFSTR("1"), 512, (uint64_t *)(*(_QWORD *)(a1[7] + 8) + 24));
  }
  sub_10004EC40(a1[14], CFSTR("0"), 256, (uint64_t *)(*(_QWORD *)(a1[7] + 8) + 24));
  v10 = (CFTypeRef *)(*(_QWORD *)(a1[6] + 8) + 24);
  v11 = sqlite3_bind_int(a2, 2, *(_DWORD *)(*(_QWORD *)(a1[7] + 8) + 24));
  *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = sub_10001A970(v11, a2, v10, CFSTR("bind_int[%d]"), 2);
  if (!*(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24)
    || (*(_DWORD *)(*(_QWORD *)(a1[9] + 8) + 24)
      ? (v12 = *(_DWORD *)(*(_QWORD *)(a1[9] + 8) + 24))
      : (v12 = *(_DWORD *)(*(_QWORD *)(a1[8] + 8) + 24)),
        (v13 = (CFTypeRef *)(*(_QWORD *)(a1[6] + 8) + 24),
         v14 = sqlite3_bind_int(a2, 3, v12),
         (*(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = sub_10001A970(v14, a2, v13, CFSTR("bind_int[%d]"), 3)) == 0)
     || (v15 = *(_DWORD *)(*(_QWORD *)(a1[9] + 8) + 24), v15 != 3)
     && (v15 || *(_DWORD *)(*(_QWORD *)(a1[8] + 8) + 24) != 3)))
  {
LABEL_24:
    Data = 0;
    goto LABEL_25;
  }
  v16 = *(CFMutableDataRef *)(*(_QWORD *)(a1[10] + 8) + 24);
  Data = (const __CFDictionary *)a1[14];
  if (Data)
  {
    v18 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)a1[14], CFSTR("xor"));
    v19 = v18;
    if (v18)
    {
      v20 = CFGetTypeID(v18);
      v21 = v20 == CFDataGetTypeID();
    }
    else
    {
      v21 = 0;
    }
    v32 = (void *)CFDictionaryGetValue(Data, CFSTR("params"));
    v33 = v32;
    if (v32)
    {
      v34 = CFGetTypeID(v32);
      v35 = v34 == CFArrayGetTypeID();
    }
    else
    {
      v35 = 0;
    }
    if (!v21 && !v35
      || (v36 = kCFAllocatorDefault,
          (Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks)) == 0))
    {
LABEL_79:
      Data = 0;
      goto LABEL_80;
    }
    v38 = Mutable;
    if (v16)
    {
      value = Mutable;
      CFRetain(v16);
      v39 = sub_10004B678(v16);
      v40 = v16;
      if (v39)
      {
        v41 = v39;
        CFRelease(v16);
        v40 = v41;
      }
      v36 = kCFAllocatorDefault;
      v42 = (const __CFDictionary *)CFPropertyListCreateWithData(kCFAllocatorDefault, v40, 0, 0, 0);
      v43 = v40;
      v44 = v42;
      CFRelease(v43);
      if (v44)
      {
        v45 = (const __CFData *)CFDictionaryGetValue(v44, CFSTR("xor"));
        cf = v44;
        v46 = (void *)CFDictionaryGetValue(v44, CFSTR("params"));
        v70 = 0;
      }
      else
      {
        cf = 0;
        v46 = 0;
        v45 = 0;
        v70 = 1;
      }
      v38 = value;
    }
    else
    {
      cf = 0;
      v46 = 0;
      v45 = 0;
      v70 = 1;
    }
    if (v21)
    {
      if (v45)
      {
        v66 = v36;
        valuea = v46;
        v47 = v38;
        Length = CFDataGetLength(v19);
        MutableCopy = CFDataCreateMutableCopy(0, 0, v45);
        v50 = MutableCopy;
        if (MutableCopy && Length >= 1)
        {
          CFDataSetLength(MutableCopy, Length);
          MutableBytePtr = CFDataGetMutableBytePtr(v50);
          BytePtr = CFDataGetBytePtr(v19);
          if (!MutableBytePtr || !BytePtr)
          {
            v38 = v47;
            v36 = v66;
            goto LABEL_68;
          }
          do
          {
            v53 = *BytePtr++;
            *MutableBytePtr++ ^= v53;
            --Length;
          }
          while (Length);
        }
        v38 = v47;
        v36 = v66;
        if (!v50)
        {
          v54 = 1;
LABEL_69:
          v46 = valuea;
LABEL_70:
          if (v35)
          {
            v56 = v38;
            v46 = v33;
          }
          else
          {
            if (!v46)
            {
              v54 = 1;
              goto LABEL_75;
            }
            v56 = v38;
          }
          CFDictionaryAddValue(v56, CFSTR("params"), v46);
LABEL_75:
          if ((v70 & 1) == 0)
            CFRelease(cf);
          if (!v54)
          {
            Data = CFPropertyListCreateData(v36, v38, kCFPropertyListXMLFormat_v1_0, 0, 0);
            CFRelease(v38);
            if (Data)
            {
              memset(&strm, 0, sizeof(strm));
              if (!deflateInit_(&strm, 9, "1.2.12", 112))
              {
                strm.next_in = (Bytef *)CFDataGetBytePtr(Data);
                strm.avail_in = CFDataGetLength(Data);
                v59 = CFDataCreateMutable(0, 0);
                if (v59)
                {
                  v16 = v59;
                  if (strm.avail_in)
                    avail_in = strm.avail_in;
                  else
                    avail_in = 4096;
                  v61 = malloc_good_size(avail_in);
                  v62 = (Bytef *)malloc_type_malloc(v61, 0x5F6E1ACEuLL);
                  do
                  {
                    strm.next_out = v62;
                    strm.avail_out = v61;
                    v63 = deflate(&strm, 4);
                    v64 = v63;
                    if (v63 > 1)
                    {
                      if (v63 != -5)
                        break;
                      free(v62);
                      v61 = malloc_good_size(2 * v61);
                      v62 = (Bytef *)malloc_type_malloc(v61, 0xE2CD0AACuLL);
                      if (v62)
                        v64 = 0;
                      else
                        v64 = -5;
                    }
                    else
                    {
                      if ((uint64_t)(v61 - strm.avail_out) < 0)
                        goto LABEL_103;
                      CFDataAppendBytes(v16, v62, v61 - strm.avail_out);
                    }
                  }
                  while (!v64 && strm.avail_in);
                  deflateEnd(&strm);
                  free(v62);
                  if (v64 == 1)
                  {
                    v65 = CFDataGetLength(v16);
                    if (v65 < CFDataGetLength(Data))
                    {
                      CFRelease(Data);
                      Data = v16;
                      goto LABEL_80;
                    }
                  }
LABEL_103:
                  CFRelease(v16);
                }
              }
              v16 = Data;
            }
            goto LABEL_80;
          }
          CFRelease(v38);
          goto LABEL_79;
        }
LABEL_68:
        CFDictionaryAddValue(v38, CFSTR("xor"), v50);
        CFRelease(v50);
        v54 = 0;
        goto LABEL_69;
      }
      if (v19)
      {
        valuea = v46;
        CFRetain(v19);
        v50 = v19;
        goto LABEL_68;
      }
    }
    else if (v45)
    {
      v55 = v46;
      CFDictionaryAddValue(v38, CFSTR("xor"), v45);
      v46 = v55;
      v54 = 0;
      goto LABEL_70;
    }
    v54 = 1;
    goto LABEL_70;
  }
LABEL_80:
  if (v16 && (CFDataGetLength(v16) & 0x8000000000000000) == 0)
  {
    v57 = CFDataGetBytePtr(v16);
    v58 = CFDataGetLength(v16);
    *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = sub_10001A8F8(a2, 4, v57, v58, (CFTypeRef *)(*(_QWORD *)(a1[6] + 8) + 24));
  }
LABEL_25:
  if (*(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24))
  {
    v25 = *(const __CFData **)(*(_QWORD *)(a1[11] + 8) + 24);
    v26 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)a1[14], CFSTR("policies"));
    v27 = sub_10004E07C(v26);
    v28 = v27;
    if (v27)
      v25 = v27;
    if (v25 && (CFDataGetLength(v25) & 0x8000000000000000) == 0)
    {
      v29 = CFDataGetBytePtr(v25);
      v30 = CFDataGetLength(v25);
      *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = sub_10001A8F8(a2, 5, v29, v30, (CFTypeRef *)(*(_QWORD *)(a1[6] + 8) + 24));
    }
  }
  else
  {
    v28 = 0;
  }
  if (*(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24))
  {
    *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = sub_100019D18(*(_QWORD *)(a1[15] + 8), a2, (CFTypeRef *)(*(_QWORD *)(a1[6] + 8) + 24), 0);
    *(_QWORD *)(*(_QWORD *)(a1[12] + 8) + 24) = sqlite3_last_insert_rowid(*(sqlite3 **)(*(_QWORD *)(a1[15] + 8)
                                                                                          + 64));
  }
  if (Data)
    CFRelease(Data);
  if (v28)
    CFRelease(v28);
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

uint64_t sub_10004D9DC(uint64_t a1, sqlite3_stmt *a2)
{
  uint64_t v4;
  CFTypeRef *v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  const UInt8 *BytePtr;
  CFIndex Length;
  BOOL v11;
  uint64_t v12;
  char v13;

  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v4 + 24))
  {
    v5 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
    v6 = sqlite3_bind_int64(a2, 1, *(_QWORD *)(a1 + 48));
    v7 = sub_10001A970(v6, a2, v5, CFSTR("bind_int64[%d]"), 1);
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  else
  {
    v7 = 0;
  }
  *(_BYTE *)(v4 + 24) = v7;
  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v8 + 24))
  {
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 56));
    Length = CFDataGetLength(*(CFDataRef *)(a1 + 56));
    v11 = sub_10001A8F8(a2, 2, BytePtr, Length, (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
    v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  else
  {
    v11 = 0;
  }
  *(_BYTE *)(v8 + 24) = v11;
  v12 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v12 + 24))
  {
    v13 = sub_100019D18(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8), a2, (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), 0);
    v12 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  else
  {
    v13 = 0;
  }
  *(_BYTE *)(v12 + 24) = v13;
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

uint64_t sub_10004DB0C(uint64_t a1, uint64_t a2, const __CFData *a3)
{
  uint64_t result;
  CFIndex Length;
  unsigned int v6;

  result = sub_10001B964(a1, a2, 0, 0, 0, 0);
  if (!(_DWORD)result)
  {
    Length = CFDataGetLength(a3);
    if (Length < 38)
      v6 = 1;
    else
      v6 = 3;
    if (Length == 32)
      return 2;
    else
      return v6;
  }
  return result;
}

BOOL sub_10004DB60(uint64_t a1, sqlite3_stmt *a2)
{
  const __CFData *v2;
  CFTypeID v5;
  CFIndex Length;
  CFMutableStringRef Mutable;
  const UInt8 *BytePtr;
  CFIndex i;
  CFDataRef ExternalRepresentation;
  uint64_t v11;
  CFTypeRef *v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v16;
  const UInt8 *v17;
  CFIndex v18;
  BOOL v19;
  uint64_t v20;
  char v21;

  v2 = *(const __CFData **)(a1 + 48);
  if (!v2)
    return 0;
  v5 = CFGetTypeID(*(CFTypeRef *)(a1 + 48));
  if (v5 != CFDataGetTypeID())
    return 0;
  Length = CFDataGetLength(v2);
  Mutable = CFStringCreateMutable(0, (2 * Length) | 1);
  CFStringAppendCString(Mutable, "%", 1u);
  BytePtr = CFDataGetBytePtr(v2);
  for (i = 0; i < CFDataGetLength(v2); ++i)
  {
    CFStringAppendCString(Mutable, *(char **)((char *)off_1000788B8 + (((unint64_t)BytePtr[i] >> 1) & 0x78)), 1u);
    CFStringAppendCString(Mutable, off_1000788B8[BytePtr[i] & 0xF], 1u);
  }
  ExternalRepresentation = CFStringCreateExternalRepresentation(0, Mutable, 0x8000100u, 0);
  if (Mutable)
    CFRelease(Mutable);
  if (!ExternalRepresentation)
    return 0;
  if (CFDataGetLength(ExternalRepresentation) < 0)
  {
    CFRelease(ExternalRepresentation);
    return 0;
  }
  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v11 + 24))
  {
    v12 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
    v13 = sqlite3_bind_int64(a2, 1, *(_QWORD *)(a1 + 56));
    v14 = sub_10001A970(v13, a2, v12, CFSTR("bind_int64[%d]"), 1);
    v11 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  else
  {
    v14 = 0;
  }
  *(_BYTE *)(v11 + 24) = v14;
  v16 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v16 + 24))
  {
    v17 = CFDataGetBytePtr(ExternalRepresentation);
    v18 = CFDataGetLength(ExternalRepresentation);
    v19 = sub_10001A8F8(a2, 2, v17, v18, (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
    v16 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  else
  {
    v19 = 0;
  }
  *(_BYTE *)(v16 + 24) = v19;
  v20 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v20 + 24))
  {
    v21 = sub_100019D18(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8), a2, (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), 0);
    v20 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  else
  {
    v21 = 0;
  }
  *(_BYTE *)(v20 + 24) = v21;
  CFRelease(ExternalRepresentation);
  return *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) != 0;
}

uint64_t sub_10004DDAC(uint64_t a1, sqlite3_stmt *a2)
{
  uint64_t v4;
  CFTypeRef *v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  const UInt8 *BytePtr;
  CFIndex Length;
  BOOL v11;
  uint64_t v12;
  char v13;

  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v4 + 24))
  {
    v5 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
    v6 = sqlite3_bind_int64(a2, 1, *(_QWORD *)(a1 + 48));
    v7 = sub_10001A970(v6, a2, v5, CFSTR("bind_int64[%d]"), 1);
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  else
  {
    v7 = 0;
  }
  *(_BYTE *)(v4 + 24) = v7;
  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v8 + 24))
  {
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 56));
    Length = CFDataGetLength(*(CFDataRef *)(a1 + 56));
    v11 = sub_10001A8F8(a2, 2, BytePtr, Length, (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
    v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  else
  {
    v11 = 0;
  }
  *(_BYTE *)(v8 + 24) = v11;
  v12 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v12 + 24))
  {
    v13 = sub_100019D18(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8), a2, (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), 0);
    v12 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  else
  {
    v13 = 0;
  }
  *(_BYTE *)(v12 + 24) = v13;
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

uint64_t sub_10004DEDC(_QWORD *a1, sqlite3_stmt *a2)
{
  uint64_t v4;
  CFTypeRef *v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  CFTypeRef *v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  CFTypeRef *v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  char v17;

  v4 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v4 + 24))
  {
    v5 = (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24);
    v6 = sqlite3_bind_int64(a2, 1, a1[8]);
    v7 = sub_10001A970(v6, a2, v5, CFSTR("bind_int64[%d]"), 1);
    v4 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v7 = 0;
  }
  *(_BYTE *)(v4 + 24) = v7;
  v8 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v8 + 24))
  {
    v9 = (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24);
    v10 = sqlite3_bind_double(a2, 2, *(double *)(*(_QWORD *)(a1[6] + 8) + 24));
    v11 = sub_10001A970(v10, a2, v9, CFSTR("bind_double[%d]"), 2);
    v8 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v11 = 0;
  }
  *(_BYTE *)(v8 + 24) = v11;
  v12 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v12 + 24))
  {
    v13 = (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24);
    v14 = sqlite3_bind_double(a2, 3, *(double *)(*(_QWORD *)(a1[7] + 8) + 24));
    v15 = sub_10001A970(v14, a2, v13, CFSTR("bind_double[%d]"), 3);
    v12 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v15 = 0;
  }
  *(_BYTE *)(v12 + 24) = v15;
  v16 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v16 + 24))
  {
    v17 = sub_100019D18(*(_QWORD *)(a1[9] + 8), a2, (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24), 0);
    v16 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v17 = 0;
  }
  *(_BYTE *)(v16 + 24) = v17;
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

const __CFArray *sub_10004E07C(CFArrayRef theArray)
{
  const __CFArray *v1;
  unint64_t Count;
  unint64_t v3;
  CFIndex v4;
  UInt8 *v5;
  UInt8 *v6;
  CFIndex i;
  const __CFNumber *ValueAtIndex;
  const __CFNumber *v9;
  CFTypeID v10;
  UInt8 valuePtr;

  v1 = theArray;
  if (theArray)
  {
    Count = CFArrayGetCount(theArray);
    if (Count <= 0x7F)
    {
      v3 = Count;
      v4 = Count + 1;
      v5 = (UInt8 *)malloc_type_malloc(Count + 1, 0x87CAAAC9uLL);
      v6 = v5;
      if (v5)
      {
        *v5 = v3;
        if (v3)
        {
          for (i = 0; i != v3; ++i)
          {
            valuePtr = 0;
            ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v1, i);
            if (ValueAtIndex)
            {
              v9 = ValueAtIndex;
              v10 = CFGetTypeID(ValueAtIndex);
              if (v10 == CFNumberGetTypeID())
                CFNumberGetValue(v9, kCFNumberSInt8Type, &valuePtr);
            }
            v6[i + 1] = valuePtr;
          }
        }
        v1 = CFDataCreate(kCFAllocatorDefault, v6, v4);
      }
      else
      {
        v1 = 0;
      }
      free(v6);
    }
    else
    {
      return 0;
    }
  }
  return v1;
}

uint64_t sub_10004E184(_QWORD *a1, sqlite3_stmt *a2)
{
  uint64_t v4;
  const UInt8 *BytePtr;
  CFIndex Length;
  BOOL v7;
  uint64_t v8;
  CFTypeRef *v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  char v13;

  v4 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v4 + 24))
  {
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(*(_QWORD *)(a1[5] + 8) + 24));
    Length = CFDataGetLength(*(CFDataRef *)(*(_QWORD *)(a1[5] + 8) + 24));
    v7 = sub_10001A8F8(a2, 1, BytePtr, Length, (CFTypeRef *)(*(_QWORD *)(a1[6] + 8) + 24));
    v4 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v7 = 0;
  }
  *(_BYTE *)(v4 + 24) = v7;
  v8 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v8 + 24))
  {
    v9 = (CFTypeRef *)(*(_QWORD *)(a1[6] + 8) + 24);
    v10 = sqlite3_bind_int64(a2, 2, a1[7]);
    v11 = sub_10001A970(v10, a2, v9, CFSTR("bind_int64[%d]"), 2);
    v8 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v11 = 0;
  }
  *(_BYTE *)(v8 + 24) = v11;
  v12 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v12 + 24))
  {
    v13 = sub_100019D18(*(_QWORD *)(a1[8] + 8), a2, (CFTypeRef *)(*(_QWORD *)(a1[6] + 8) + 24), 0);
    v12 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v13 = 0;
  }
  *(_BYTE *)(v12 + 24) = v13;
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

uint64_t sub_10004E2C4(_QWORD *a1, sqlite3_stmt *a2)
{
  uint64_t v4;
  CFTypeRef *v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  CFTypeRef *v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  char v13;

  v4 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v4 + 24))
  {
    v5 = (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24);
    v6 = sqlite3_bind_text(a2, 1, "version", 7, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
    v7 = sub_10001A970(v6, a2, v5, CFSTR("bind_text[%d]"), 1);
    v4 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v7 = 0;
  }
  *(_BYTE *)(v4 + 24) = v7;
  v8 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v8 + 24))
  {
    v9 = (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24);
    v10 = sqlite3_bind_int64(a2, 2, a1[6]);
    v11 = sub_10001A970(v10, a2, v9, CFSTR("bind_int64[%d]"), 2);
    v8 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v11 = 0;
  }
  *(_BYTE *)(v8 + 24) = v11;
  v12 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v12 + 24))
  {
    v13 = sub_100019D18(*(_QWORD *)(a1[7] + 8), a2, (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24), 0);
    v12 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v13 = 0;
  }
  *(_BYTE *)(v12 + 24) = v13;
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

uint64_t sub_10004E404(_QWORD *a1, sqlite3_stmt *a2)
{
  uint64_t v4;
  CFTypeRef *v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  CFTypeRef *v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  char v13;

  v4 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v4 + 24))
  {
    v5 = (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24);
    v6 = sqlite3_bind_text(a2, 1, "generation", 10, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
    v7 = sub_10001A970(v6, a2, v5, CFSTR("bind_text[%d]"), 1);
    v4 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v7 = 0;
  }
  *(_BYTE *)(v4 + 24) = v7;
  v8 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v8 + 24))
  {
    v9 = (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24);
    v10 = sqlite3_bind_int64(a2, 2, a1[6]);
    v11 = sub_10001A970(v10, a2, v9, CFSTR("bind_int64[%d]"), 2);
    v8 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v11 = 0;
  }
  *(_BYTE *)(v8 + 24) = v11;
  v12 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v12 + 24))
  {
    v13 = sub_100019D18(*(_QWORD *)(a1[7] + 8), a2, (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24), 0);
    v12 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v13 = 0;
  }
  *(_BYTE *)(v12 + 24) = v13;
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

uint64_t sub_10004E544(_QWORD *a1, sqlite3_stmt *a2)
{
  uint64_t v4;
  CFTypeRef *v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  CFTypeRef *v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  char v13;

  v4 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v4 + 24))
  {
    v5 = (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24);
    v6 = sqlite3_bind_text(a2, 1, "interval", 8, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
    v7 = sub_10001A970(v6, a2, v5, CFSTR("bind_text[%d]"), 1);
    v4 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v7 = 0;
  }
  *(_BYTE *)(v4 + 24) = v7;
  v8 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v8 + 24))
  {
    v9 = (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24);
    v10 = sqlite3_bind_int64(a2, 2, a1[6]);
    v11 = sub_10001A970(v10, a2, v9, CFSTR("bind_int64[%d]"), 2);
    v8 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v11 = 0;
  }
  *(_BYTE *)(v8 + 24) = v11;
  v12 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v12 + 24))
  {
    v13 = sub_100019D18(*(_QWORD *)(a1[7] + 8), a2, (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24), 0);
    v12 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v13 = 0;
  }
  *(_BYTE *)(v12 + 24) = v13;
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

uint64_t sub_10004E684(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  int v4;
  NSObject *v5;
  uint64_t v6;
  __CFError *v7;
  CFIndex Code;
  const void *v9;
  uint64_t v10;
  _QWORD v12[8];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  CFTypeRef v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  BOOL v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint8_t buf[4];
  uint64_t v26;

  v21 = 0;
  v22 = &v21;
  v23 = 0x2000000000;
  v24 = -1;
  v17 = 0;
  v18 = &v17;
  v19 = 0x2000000000;
  v20 = a1 != 0;
  v13 = 0;
  v14 = &v13;
  v15 = 0x2000000000;
  v16 = 0;
  if (a1)
  {
    v3 = *(_QWORD *)(a1 + 8);
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 0x40000000;
    v12[2] = sub_10004EB6C;
    v12[3] = &unk_100078B10;
    v12[4] = &v17;
    v12[5] = &v13;
    v12[6] = &v21;
    v12[7] = a1;
    v4 = sub_10001979C(v3, CFSTR("SELECT ival FROM admin WHERE key='db_format'"), &v16, (uint64_t)v12);
    *((_BYTE *)v18 + 24) = v4;
    if (v4 && !v14[3])
      goto LABEL_16;
  }
  else
  {
    v20 = 0;
  }
  v5 = sub_100011628("SecError");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = v14[3];
    *(_DWORD *)buf = 138412290;
    v26 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbGetUpdateFormat failed: %@", buf, 0xCu);
  }
  v7 = (__CFError *)v14[3];
  if (v7)
    Code = CFErrorGetCode(v7);
  else
    Code = -2070;
  sub_1000521A8(1, 3, Code);
  v9 = (const void *)v14[3];
  if (v9)
  {
    if (a2 && !*a2)
      *a2 = v9;
    else
      CFRelease(v9);
  }
LABEL_16:
  v10 = v22[3];
  _Block_object_dispose(&v13, 8);
  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(&v21, 8);
  return v10;
}

uint64_t sub_10004E860(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  int v5;
  NSObject *v6;
  uint64_t v7;
  __CFError *v8;
  CFIndex Code;
  const void *v10;
  uint64_t v11;
  _QWORD v13[8];
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  CFTypeRef v21;
  uint8_t buf[4];
  uint64_t v23;

  v18 = 0;
  v19 = &v18;
  v20 = 0x2000000000;
  v21 = 0;
  v14 = 0;
  v15 = &v14;
  v16 = 0x2000000000;
  v17 = a1 != 0;
  if (a1)
  {
    v4 = a1[1];
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000;
    v13[2] = sub_10004EA2C;
    v13[3] = &unk_100078730;
    v13[4] = &v14;
    v13[5] = &v18;
    v13[6] = 3;
    v13[7] = a1;
    v5 = sub_10001979C(v4, CFSTR("INSERT OR REPLACE INTO admin (key,ival,value) VALUES (?,?,?)"), &v21, (uint64_t)v13);
    *((_BYTE *)v15 + 24) = v5;
    if (v5 && !v19[3])
    {
      *(_WORD *)(*a1 + 17) = 256;
      goto LABEL_16;
    }
  }
  else
  {
    v17 = 0;
  }
  v6 = sub_100011628("SecError");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v7 = v19[3];
    *(_DWORD *)buf = 138412290;
    v23 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbSetUpdateFormat failed: %@", buf, 0xCu);
  }
  v8 = (__CFError *)v19[3];
  if (v8)
    Code = CFErrorGetCode(v8);
  else
    Code = -2070;
  sub_1000521A8(1, 2, Code);
  v10 = (const void *)v19[3];
  if (v10)
  {
    if (a2 && !*a2)
      *a2 = v10;
    else
      CFRelease(v10);
  }
LABEL_16:
  v11 = *((unsigned __int8 *)v15 + 24);
  _Block_object_dispose(&v14, 8);
  _Block_object_dispose(&v18, 8);
  return v11;
}

uint64_t sub_10004EA2C(_QWORD *a1, sqlite3_stmt *a2)
{
  uint64_t v4;
  CFTypeRef *v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  CFTypeRef *v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  char v13;

  v4 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v4 + 24))
  {
    v5 = (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24);
    v6 = sqlite3_bind_text(a2, 1, "db_format", 9, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
    v7 = sub_10001A970(v6, a2, v5, CFSTR("bind_text[%d]"), 1);
    v4 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v7 = 0;
  }
  *(_BYTE *)(v4 + 24) = v7;
  v8 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v8 + 24))
  {
    v9 = (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24);
    v10 = sqlite3_bind_int64(a2, 2, a1[6]);
    v11 = sub_10001A970(v10, a2, v9, CFSTR("bind_int64[%d]"), 2);
    v8 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v11 = 0;
  }
  *(_BYTE *)(v8 + 24) = v11;
  v12 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v12 + 24))
  {
    v13 = sub_100019D18(*(_QWORD *)(a1[7] + 8), a2, (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24), 0);
    v12 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v13 = 0;
  }
  *(_BYTE *)(v12 + 24) = v13;
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

uint64_t sub_10004EB6C(_QWORD *a1, sqlite3_stmt *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  char v8;
  _QWORD v10[6];

  v3 = *(_QWORD *)(a1[7] + 8);
  v4 = a1[6];
  v5 = *(_QWORD *)(a1[5] + 8);
  v10[0] = _NSConcreteStackBlock;
  v10[2] = sub_10004EC00;
  v10[3] = &unk_100078AE8;
  v10[1] = 0x40000000;
  v10[4] = v4;
  v10[5] = a2;
  v6 = sub_100019D18(v3, a2, (CFTypeRef *)(v5 + 24), (uint64_t)v10);
  v7 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v7 + 24))
    v8 = v6;
  else
    v8 = 0;
  *(_BYTE *)(v7 + 24) = v8;
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

sqlite3_int64 sub_10004EC00(uint64_t a1, _BYTE *a2)
{
  sqlite3_int64 result;

  result = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  *a2 = 1;
  return result;
}

CFTypeID sub_10004EC40(CFTypeID result, const __CFString *a2, uint64_t a3, uint64_t *a4)
{
  const __CFDictionary *v7;
  CFTypeID v8;
  CFTypeID v9;
  const __CFBoolean *Value;
  const __CFBoolean *v11;
  CFTypeID v12;
  uint64_t v13;
  uint64_t v14;

  if (result)
  {
    v7 = (const __CFDictionary *)result;
    v8 = CFGetTypeID((CFTypeRef)result);
    result = CFDictionaryGetTypeID();
    if (a2)
    {
      if (v8 == result)
      {
        v9 = CFGetTypeID(a2);
        result = CFStringGetTypeID();
        if (a4)
        {
          if (v9 == result)
          {
            Value = (const __CFBoolean *)CFDictionaryGetValue(v7, a2);
            if (Value && (v11 = Value, v12 = CFGetTypeID(Value), v12 == CFBooleanGetTypeID()))
            {
              result = CFBooleanGetValue(v11);
              v13 = *a4;
              if (!(_DWORD)result)
              {
LABEL_14:
                v14 = v13 & ~a3;
LABEL_17:
                *a4 = v14;
                return result;
              }
            }
            else
            {
              result = CFStringGetLength(a2);
              if (result != 1)
                return result;
              result = CFStringCompare(a2, CFSTR("1"), 0);
              if (result)
              {
                result = CFStringCompare(a2, CFSTR("0"), 0);
                if (result)
                  return result;
                v13 = *a4;
                goto LABEL_14;
              }
              v13 = *a4;
            }
            v14 = v13 | a3;
            goto LABEL_17;
          }
        }
      }
    }
  }
  return result;
}

uint64_t sub_10004ED44()
{
  CFPropertyListRef v0;
  CFPropertyListRef v1;
  CFTypeID v2;
  uint64_t *p_valuePtr;
  unint64_t valuePtr;

  v0 = CFPreferencesCopyAppValue(CFSTR("ValidUpdateGeneration"), CFSTR("com.apple.security"));
  if (v0)
  {
    v1 = v0;
    valuePtr = 0xAAAAAAAAAAAAAAAALL;
  }
  else
  {
    v1 = CFPreferencesCopyValue(CFSTR("ValidUpdateGeneration"), CFSTR("com.apple.security"), kCFPreferencesAnyUser, kCFPreferencesCurrentHost);
    valuePtr = 0xAAAAAAAAAAAAAAAALL;
    if (!v1)
    {
      p_valuePtr = &qword_100082918;
      return *p_valuePtr;
    }
  }
  v2 = CFGetTypeID(v1);
  if (v2 != CFNumberGetTypeID() || !CFNumberGetValue((CFNumberRef)v1, kCFNumberCFIndexType, &valuePtr))
    valuePtr = qword_100082918;
  CFRelease(v1);
  p_valuePtr = (uint64_t *)&valuePtr;
  return *p_valuePtr;
}

uint64_t sub_10004EE1C(_QWORD *a1, sqlite3_stmt *a2)
{
  uint64_t v4;
  CFTypeRef *v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  CFTypeRef *v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  size_t v13;
  BOOL v14;
  uint64_t v15;
  char v16;

  v4 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v4 + 24))
  {
    v5 = (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24);
    v6 = sqlite3_bind_text(a2, 1, "db_source", 9, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
    v7 = sub_10001A970(v6, a2, v5, CFSTR("bind_text[%d]"), 1);
    v4 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v7 = 0;
  }
  *(_BYTE *)(v4 + 24) = v7;
  v8 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v8 + 24))
  {
    v9 = (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24);
    v10 = sqlite3_bind_int64(a2, 2, 0);
    v11 = sub_10001A970(v10, a2, v9, CFSTR("bind_int64[%d]"), 2);
    v8 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v11 = 0;
  }
  *(_BYTE *)(v8 + 24) = v11;
  v12 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v12 + 24))
  {
    v13 = strlen(*(const char **)(*(_QWORD *)(a1[6] + 8) + 24));
    v14 = sub_10001A8F8(a2, 3, *(const void **)(*(_QWORD *)(a1[6] + 8) + 24), v13, (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24));
    v12 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v14 = 0;
  }
  *(_BYTE *)(v12 + 24) = v14;
  v15 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v15 + 24))
  {
    v16 = sub_100019D18(*(_QWORD *)(a1[7] + 8), a2, (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24), 0);
    v15 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v16 = 0;
  }
  *(_BYTE *)(v15 + 24) = v16;
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

BOOL sub_10004EFB8(uint64_t a1, uint64_t *a2)
{
  _QWORD v3[5];

  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = sub_10004F014;
  v3[3] = &unk_1000780F8;
  v3[4] = *(_QWORD *)(a1 + 32);
  return sub_100018D8C(a2, 0, (uint64_t)v3);
}

BOOL sub_10004F014(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  int v6;
  NSObject *v7;
  uint64_t v8;
  __CFError *v9;
  CFIndex Code;
  const void *v11;
  uint64_t v12;
  _QWORD v14[8];
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  CFTypeRef v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint8_t buf[4];
  uint64_t v28;

  v23 = 0;
  v24 = &v23;
  v25 = 0x2000000000;
  v26 = 0;
  v19 = 0;
  v20 = &v19;
  v21 = 0x2000000000;
  v22 = a2 != 0;
  v15 = 0;
  v16 = &v15;
  v17 = 0x2000000000;
  v18 = 0;
  if (a2)
  {
    v5 = *(_QWORD *)(a2 + 8);
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 0x40000000;
    v14[2] = sub_10004F210;
    v14[3] = &unk_100078B60;
    v14[4] = &v19;
    v14[5] = &v15;
    v14[6] = &v23;
    v14[7] = a2;
    v6 = sub_10001979C(v5, CFSTR("SELECT value FROM admin WHERE key='db_source'"), &v18, (uint64_t)v14);
    *((_BYTE *)v20 + 24) = v6;
    if (v6 && !v16[3])
      goto LABEL_16;
  }
  else
  {
    v22 = 0;
  }
  v7 = sub_100011628("SecError");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    v8 = v16[3];
    *(_DWORD *)buf = 138412290;
    v28 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbCopyUpdateSource failed: %@", buf, 0xCu);
  }
  v9 = (__CFError *)v16[3];
  if (v9)
    Code = CFErrorGetCode(v9);
  else
    Code = -2070;
  sub_1000521A8(1, 3, Code);
  v11 = (const void *)v16[3];
  if (v11)
  {
    if (a3 && !*a3)
      *a3 = v11;
    else
      CFRelease(v11);
  }
LABEL_16:
  v12 = v24[3];
  _Block_object_dispose(&v15, 8);
  _Block_object_dispose(&v19, 8);
  _Block_object_dispose(&v23, 8);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v12;
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) != 0;
}

uint64_t sub_10004F210(_QWORD *a1, sqlite3_stmt *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  char v8;
  _QWORD v10[6];

  v3 = *(_QWORD *)(a1[7] + 8);
  v4 = a1[6];
  v5 = *(_QWORD *)(a1[5] + 8);
  v10[0] = _NSConcreteStackBlock;
  v10[2] = sub_10004F2A4;
  v10[3] = &unk_100078B38;
  v10[1] = 0x40000000;
  v10[4] = v4;
  v10[5] = a2;
  v6 = sub_100019D18(v3, a2, (CFTypeRef *)(v5 + 24), (uint64_t)v10);
  v7 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v7 + 24))
    v8 = v6;
  else
    v8 = 0;
  *(_BYTE *)(v7 + 24) = v8;
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

const UInt8 *sub_10004F2A4(uint64_t a1, _BYTE *a2)
{
  const UInt8 *result;
  const UInt8 *v5;

  result = (const UInt8 *)sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 40), 0);
  if (result)
  {
    v5 = result;
    result = (const UInt8 *)sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 40), 0);
    if ((int)result >= 1)
    {
      result = (const UInt8 *)CFStringCreateWithBytes(kCFAllocatorDefault, v5, result, 0x8000100u, 0);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
    }
  }
  *a2 = 1;
  return result;
}

void sub_10004F32C(uint64_t a1, const std::__fs::filesystem::path *a2)
{
  timespec v4;
  std::error_code *v5;
  int v6;
  NSObject *v7;
  char *v8;
  stat v9;
  uint8_t buf[4];
  const std::__fs::filesystem::path *v11;
  __int16 v12;
  char *v13;

  v4.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v4.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v9.st_blksize = v4;
  *(timespec *)v9.st_qspare = v4;
  v9.st_birthtimespec = v4;
  *(timespec *)&v9.st_size = v4;
  v9.st_mtimespec = v4;
  v9.st_ctimespec = v4;
  *(timespec *)&v9.st_uid = v4;
  v9.st_atimespec = v4;
  *(timespec *)&v9.st_dev = v4;
  if (!stat((const char *)a2, &v9))
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
    if (remove(a2, v5) == -1)
    {
      v6 = *__error();
      v7 = sub_100011628("validupdate");
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        v8 = strerror(v6);
        *(_DWORD *)buf = 136315394;
        v11 = a2;
        v12 = 2080;
        v13 = v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "remove (%s): %s", buf, 0x16u);
      }
    }
  }
}

void sub_10004F440(uint64_t a1, char *a2)
{
  timespec v4;
  stat v5;

  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    sub_100050038(a2, "");
    sub_100050038(a2, "-journal");
    sub_100050038(a2, "-shm");
    sub_100050038(a2, "-wal");
  }
  else
  {
    v4.tv_sec = 0xAAAAAAAAAAAAAAAALL;
    v4.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    *(timespec *)&v5.st_blksize = v4;
    *(timespec *)v5.st_qspare = v4;
    v5.st_birthtimespec = v4;
    *(timespec *)&v5.st_size = v4;
    v5.st_mtimespec = v4;
    v5.st_ctimespec = v4;
    *(timespec *)&v5.st_uid = v4;
    v5.st_atimespec = v4;
    *(timespec *)&v5.st_dev = v4;
    if (stat(a2, &v5) == -1)
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  }
}

const __CFString *sub_10004F500()
{
  const __CFString *v0;
  CFTypeID v1;

  v0 = (const __CFString *)CFPreferencesCopyAppValue(CFSTR("ValidUpdateServer"), CFSTR("com.apple.security"));
  if (v0
    || (v0 = (const __CFString *)CFPreferencesCopyValue(CFSTR("ValidUpdateServer"), CFSTR("com.apple.security"), kCFPreferencesAnyUser, kCFPreferencesCurrentHost)) != 0)
  {
    v1 = CFGetTypeID(v0);
    if (v1 == CFStringGetTypeID())
      return v0;
    CFRelease(v0);
  }
  if (os_variant_has_internal_diagnostics("com.apple.security"))
    v0 = CFSTR("valid.apple.com/carry");
  else
    v0 = CFSTR("valid.apple.com");
  CFRetain(v0);
  return v0;
}

BOOL sub_10004F5B8(CFStringRef theString1, uint64_t a2, uint64_t a3, char a4)
{
  BOOL v5;
  _QWORD *v9;
  const void *v10;
  uint64_t v11;
  uint64_t *v12;
  _BOOL8 v13;
  _QWORD v15[5];
  _QWORD v16[6];
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  char v20;

  v5 = 0;
  v17 = 0;
  v18 = &v17;
  v19 = 0x2000000000;
  v20 = 0;
  if (dword_100082E30 <= 1)
  {
    if (CFStringCompare(theString1, CFSTR("valid.apple.com"), 1uLL) || (v9 = (_QWORD *)sub_100004464()) == 0)
    {
      v5 = 0;
      goto LABEL_13;
    }
    v10 = v9;
    if (v9[18] > a3)
    {
      v5 = 0;
      if (v9[16] <= a2 || (uint64_t)v9[17] < 3)
        goto LABEL_12;
      if ((a4 & 1) == 0)
      {
        v5 = sub_10004718C();
        goto LABEL_12;
      }
      v11 = v9[15];
      if (v11)
      {
        v16[0] = _NSConcreteStackBlock;
        v16[1] = 0x40000000;
        v16[2] = sub_10004FE34;
        v16[3] = &unk_100078450;
        v16[4] = &v17;
        v16[5] = v11;
        sub_1000352AC((uint64_t)CFSTR("valid.sqlite3"), v16);
      }
    }
    v5 = 0;
LABEL_12:
    CFRelease(v10);
  }
LABEL_13:
  v12 = v18;
  if (!*((_BYTE *)v18 + 24))
  {
    dword_100082E30 = 0;
    if (v5)
      goto LABEL_15;
LABEL_17:
    v13 = *((unsigned __int8 *)v12 + 24) != 0;
    goto LABEL_18;
  }
  ++dword_100082E30;
  atomic_store(sub_10004F89C(), &qword_100082E28);
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 0x40000000;
  v15[2] = sub_10004FFA0;
  v15[3] = &unk_100078470;
  v15[4] = theString1;
  sub_100016C6C((uint64_t)v15);
  qword_100082DF8 = 0;
  v12 = v18;
  if (!v5)
    goto LABEL_17;
LABEL_15:
  v13 = 1;
  *((_BYTE *)v12 + 24) = 1;
LABEL_18:
  _Block_object_dispose(&v17, 8);
  return v13;
}

uint64_t sub_10004F788()
{
  uint64_t v0;
  _QWORD v2[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2000000000;
  v6 = 0;
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000;
  v2[2] = sub_10004FE14;
  v2[3] = &unk_1000781E0;
  v2[4] = &v3;
  sub_100016C6C((uint64_t)v2);
  v0 = v4[3];
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t sub_10004F810()
{
  uint64_t v0;
  _QWORD v2[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2000000000;
  v6 = -1;
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000;
  v2[2] = sub_10004FAD8;
  v2[3] = &unk_100078320;
  v2[4] = &v3;
  sub_100016C6C((uint64_t)v2);
  v0 = v4[3];
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t sub_10004F89C()
{
  uint64_t v0;
  _QWORD v2[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2000000000;
  v6 = -1;
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000;
  v2[2] = sub_10004FA34;
  v2[3] = &unk_1000782D0;
  v2[4] = &v3;
  sub_100016C6C((uint64_t)v2);
  v0 = v4[3];
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t sub_10004F928()
{
  uint64_t v0;
  _QWORD v2[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2000000000;
  v6 = -1;
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000;
  v2[2] = sub_10004F9B4;
  v2[3] = &unk_100078348;
  v2[4] = &v3;
  sub_100016C6C((uint64_t)v2);
  v0 = v4[3];
  _Block_object_dispose(&v3, 8);
  return v0;
}

BOOL sub_10004F9B4(_BOOL8 result, uint64_t *a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;

  v2 = result;
  v3 = atomic_load(&qword_100082920);
  if (v3 == -1)
    result = sub_100018D8C(a2, 0, (uint64_t)&stru_100078AC0);
  v4 = atomic_load(&qword_100082920);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 32) + 8) + 24) = v4;
  return result;
}

BOOL sub_10004FA08(id a1, __SecRevocationDbConnection *a2, __CFError **a3)
{
  atomic_store(sub_10001AEFC((uint64_t)a2, a3), &qword_100082920);
  return 1;
}

BOOL sub_10004FA34(uint64_t a1, uint64_t *a2)
{
  _QWORD v3[5];

  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = sub_10004FA90;
  v3[3] = &unk_1000782A8;
  v3[4] = *(_QWORD *)(a1 + 32);
  return sub_100018D8C(a2, 0, (uint64_t)v3);
}

BOOL sub_10004FA90(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = sub_100018BB0(a2, a3);
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) >= 0;
}

BOOL sub_10004FAD8(uint64_t a1, uint64_t *a2)
{
  _QWORD v3[5];

  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = sub_10004FB34;
  v3[3] = &unk_1000782F8;
  v3[4] = *(_QWORD *)(a1 + 32);
  return sub_100018D8C(a2, 0, (uint64_t)v3);
}

BOOL sub_10004FB34(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  int v6;
  NSObject *v7;
  uint64_t v8;
  __CFError *v9;
  CFIndex Code;
  const void *v11;
  uint64_t v12;
  _QWORD v14[8];
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  CFTypeRef v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint8_t buf[4];
  uint64_t v28;

  v23 = 0;
  v24 = &v23;
  v25 = 0x2000000000;
  v26 = 4;
  v19 = 0;
  v20 = &v19;
  v21 = 0x2000000000;
  v22 = a2 != 0;
  v15 = 0;
  v16 = &v15;
  v17 = 0x2000000000;
  v18 = 0;
  if (a2)
  {
    v5 = *(_QWORD *)(a2 + 8);
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 0x40000000;
    v14[2] = sub_10004FD34;
    v14[3] = &unk_100078DB8;
    v14[4] = &v19;
    v14[5] = &v15;
    v14[6] = &v23;
    v14[7] = a2;
    v6 = sub_10001979C(v5, CFSTR("SELECT ival FROM admin WHERE key='generation'"), &v18, (uint64_t)v14);
    *((_BYTE *)v20 + 24) = v6;
    if (v6 && !v16[3])
      goto LABEL_16;
  }
  else
  {
    v22 = 0;
  }
  v7 = sub_100011628("SecError");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    v8 = v16[3];
    *(_DWORD *)buf = 138412290;
    v28 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbGetLocalGeneration failed: %@", buf, 0xCu);
  }
  v9 = (__CFError *)v16[3];
  if (v9)
    Code = CFErrorGetCode(v9);
  else
    Code = -2070;
  sub_1000521A8(1, 3, Code);
  v11 = (const void *)v16[3];
  if (v11)
  {
    if (a3 && !*a3)
      *a3 = v11;
    else
      CFRelease(v11);
  }
LABEL_16:
  v12 = v24[3];
  _Block_object_dispose(&v15, 8);
  _Block_object_dispose(&v19, 8);
  _Block_object_dispose(&v23, 8);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v12;
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) >= 0;
}

uint64_t sub_10004FD34(_QWORD *a1, sqlite3_stmt *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  _QWORD v9[6];

  v3 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v3 + 24))
  {
    v4 = a1[6];
    v5 = *(_QWORD *)(a1[7] + 8);
    v6 = *(_QWORD *)(a1[5] + 8);
    v9[0] = _NSConcreteStackBlock;
    v9[2] = sub_10004FDD4;
    v9[3] = &unk_100078D90;
    v9[1] = 0x40000000;
    v9[4] = v4;
    v9[5] = a2;
    v7 = sub_100019D18(v5, a2, (CFTypeRef *)(v6 + 24), (uint64_t)v9);
    v3 = *(_QWORD *)(a1[4] + 8);
  }
  else
  {
    v7 = 0;
  }
  *(_BYTE *)(v3 + 24) = v7;
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

sqlite3_int64 sub_10004FDD4(uint64_t a1, _BYTE *a2)
{
  sqlite3_int64 result;

  result = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  *a2 = 1;
  return result;
}

uint64_t sub_10004FE14(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  if (a2)
    v2 = *(_QWORD *)(a2 + 8);
  else
    v2 = 0;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = v2;
  return result;
}

void sub_10004FE34(uint64_t a1, const char *a2)
{
  _copyfile_state *v4;
  int v5;
  NSObject *v6;
  CFTypeRef v7;
  NSObject *v8;
  CFTypeRef cf;
  uint8_t buf[4];
  CFTypeRef v11;

  v4 = copyfile_state_alloc();
  v5 = copyfile(*(const char **)(a1 + 40), a2, v4, 8u);
  copyfile_state_free(v4);
  if (v5 < 0)
  {
    v8 = sub_100011628("validupdate");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      LODWORD(v11) = v5;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "copyfile error %d", buf, 8u);
    }
  }
  else
  {
    cf = 0;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = sub_100034EC8(a2, &cf);
    if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    {
      v6 = sub_100011628("SecError");
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v11 = cf;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "failed to change protection class of copied valid snapshot: %@", buf, 0xCu);
      }
      v7 = cf;
      if (cf)
      {
        cf = 0;
        CFRelease(v7);
      }
    }
  }
}

void sub_10004FFA0(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  _QWORD v4[5];
  CFTypeRef v5;

  if (a2)
  {
    if (*a2)
    {
      v3 = *(_QWORD *)(a1 + 32);
      v5 = 0;
      v4[0] = _NSConcreteStackBlock;
      v4[1] = 0x40000000;
      v4[2] = sub_100050028;
      v4[3] = &unk_100078068;
      v4[4] = v3;
      sub_10004657C(a2, &v5, (uint64_t)v4);
      if (v5)
        CFRelease(v5);
    }
  }
  sub_100046DE8(a2);
}

BOOL sub_100050028(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  return sub_10004C77C(a2, *(CFStringRef *)(a1 + 32), a3);
}

void sub_100050038(const char *a1, const char *a2)
{
  std::error_code *v2;
  int v3;
  NSObject *v4;
  std::__fs::filesystem::path *v5;
  char *v6;
  std::__fs::filesystem::path *__p;
  uint8_t buf[4];
  std::__fs::filesystem::path *v9;
  __int16 v10;
  char *v11;

  __p = 0;
  asprintf((char **)&__p, "%s%s", a1, a2);
  if (__p)
  {
    if (remove(__p, v2) == -1)
    {
      v3 = *__error();
      if (v3 != 2)
      {
        v4 = sub_100011628("validupdate");
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          v5 = __p;
          v6 = strerror(v3);
          *(_DWORD *)buf = 136315394;
          v9 = v5;
          v10 = 2080;
          v11 = v6;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "remove (%s): %s", buf, 0x16u);
        }
      }
    }
    free(__p);
  }
}

void sub_100050138(id a1, const char *a2)
{
  mkpath_np(a2, 0x1EDu);
}

uint64_t sub_100050144(uint64_t a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass(&unk_100077F00);
  **(_QWORD **)(a1 + 32) = result;
  return result;
}

void sub_100050174(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;

  if (a1)
  {
    v2 = (const void *)a1[3];
    if (v2)
    {
      a1[3] = 0;
      CFRelease(v2);
    }
    v3 = (const void *)a1[4];
    if (v3)
    {
      a1[4] = 0;
      CFRelease(v3);
    }
    v4 = (const void *)a1[5];
    if (v4)
    {
      a1[5] = 0;
      CFRelease(v4);
    }
    v5 = (const void *)a1[8];
    if (v5)
    {
      a1[8] = 0;
      CFRelease(v5);
    }
    v6 = (const void *)a1[9];
    if (v6)
    {
      a1[9] = 0;
      CFRelease(v6);
    }
    v7 = (const void *)a1[10];
    if (v7)
    {
      a1[10] = 0;
      CFRelease(v7);
    }
    v8 = (const void *)a1[11];
    if (v8)
    {
      a1[11] = 0;
      CFRelease(v8);
    }
  }
}

uint64_t sub_10005020C(_QWORD *cf, _QWORD *a2)
{
  uint64_t result;
  CFTypeID v5;
  CFTypeID v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;

  if (cf == a2)
    return 1;
  result = 0;
  if (cf && a2)
  {
    v5 = CFGetTypeID(cf);
    if (v5 == sub_10001BABC())
    {
      v6 = CFGetTypeID(a2);
      if (v6 == sub_10001BABC())
      {
        v7 = (const void *)cf[3];
        v8 = (const void *)a2[3];
        if (v7 && v8)
        {
          result = CFEqual(v7, v8);
          if (!(_DWORD)result)
            return result;
          goto LABEL_14;
        }
        if (v7 == v8)
        {
LABEL_14:
          v9 = (const void *)cf[4];
          v10 = (const void *)a2[4];
          if (v9 && v10)
            return CFEqual(v9, v10) != 0;
          else
            return v9 == v10;
        }
      }
    }
    return 0;
  }
  return result;
}

CFStringRef sub_1000502D4(uint64_t a1, const __CFDictionary *a2)
{
  const __CFData *v4;
  CFIndex Length;
  __CFString *Mutable;
  const UInt8 *BytePtr;
  CFIndex v8;
  CFIndex v9;
  unsigned int v10;
  const __CFData *v11;
  CFIndex v12;
  __CFString *v13;
  const UInt8 *v14;
  CFIndex v15;
  CFIndex v16;
  unsigned int v17;
  CFStringRef v18;

  v4 = *(const __CFData **)(a1 + 24);
  Length = CFDataGetLength(v4);
  Mutable = CFStringCreateMutable(kCFAllocatorDefault, 2 * Length);
  BytePtr = CFDataGetBytePtr(v4);
  v8 = CFDataGetLength(v4);
  if (v8 >= 1)
  {
    v9 = v8;
    do
    {
      v10 = *BytePtr++;
      CFStringAppendFormat(Mutable, 0, CFSTR("%02X"), v10);
      --v9;
    }
    while (v9);
  }
  v11 = *(const __CFData **)(a1 + 32);
  v12 = CFDataGetLength(v11);
  v13 = CFStringCreateMutable(kCFAllocatorDefault, 2 * v12);
  v14 = CFDataGetBytePtr(v11);
  v15 = CFDataGetLength(v11);
  if (v15 >= 1)
  {
    v16 = v15;
    do
    {
      v17 = *v14++;
      CFStringAppendFormat(v13, 0, CFSTR("%02X"), v17);
      --v16;
    }
    while (v16);
  }
  v18 = CFStringCreateWithFormat(0, a2, CFSTR("validInfo certHash: %@ issuerHash: %@"), Mutable, v13);
  if (Mutable)
    CFRelease(Mutable);
  if (v13)
    CFRelease(v13);
  return v18;
}

CFStringRef sub_100050420(uint64_t a1)
{
  const __CFDictionary *v2;

  v2 = (const __CFDictionary *)sub_100026A10();
  return sub_1000502D4(a1, v2);
}

void sub_100050448(id a1)
{
  NSObject *v1;
  NSObject *v2;
  _QWORD *context;

  v1 = sub_10004F788();
  v2 = sub_10002B070(v1, "update_check", 300);
  qword_100082E20 = (uint64_t)v2;
  context = dispatch_get_context(v2);
  context[2] = _Block_copy(&stru_100077FE0);
  dispatch_activate(v2);
}

void sub_10005049C(id a1)
{
  void *v1;
  double Current;
  double v3;
  double v4;
  uint64_t v5;
  const __CFNumber *v6;
  const __CFNumber *v7;
  CFTypeID v8;
  double v9;
  uint64_t v10;
  NSObject *v11;
  const __CFString *v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  void *v16;
  NSObject *v17;
  _QWORD v18[6];
  uint64_t v19;
  double *v20;
  uint64_t v21;
  unint64_t v22;

  v1 = (void *)os_transaction_create("com.apple.trustd.valid.checkNextUpdate");
  if (qword_100082C28 != -1)
    dispatch_once(&qword_100082C28, &stru_1000767D0);
  if (byte_100082C20 == 1)
  {
    Current = CFAbsoluteTimeGetCurrent();
    qword_100082DF8 = *(_QWORD *)&Current;
    v3 = *(double *)&qword_100082E00;
    if (*(double *)&qword_100082E00 == 0.0)
    {
      v19 = 0;
      v20 = (double *)&v19;
      v21 = 0x2000000000;
      v22 = 0xBFF0000000000000;
      v18[0] = _NSConcreteStackBlock;
      v18[1] = 0x40000000;
      v18[2] = sub_100050A8C;
      v18[3] = &unk_1000781B8;
      v18[4] = &v19;
      sub_100016C6C((uint64_t)v18);
      v4 = v20[3];
      _Block_object_dispose(&v19, 8);
      if (v4 >= Current)
        *(double *)&v5 = v4;
      else
        *(double *)&v5 = Current;
      qword_100082E00 = v5;
      v18[0] = -1;
      v6 = (const __CFNumber *)CFPreferencesCopyValue(CFSTR("ValidUpdateInterval"), CFSTR("com.apple.security"), kCFPreferencesAnyUser, kCFPreferencesCurrentHost);
      if (v6)
      {
        v7 = v6;
        v8 = CFGetTypeID(v6);
        if (v8 == CFNumberGetTypeID() && CFNumberGetValue(v7, kCFNumberCFIndexType, v18))
        {
          if (v18[0] > 299)
          {
            if (v18[0] > 0x93A80uLL)
              v18[0] = 604800;
          }
          else
          {
            v18[0] = 300;
          }
        }
        CFRelease(v7);
        v10 = v18[0];
        if (v18[0] <= 0)
          v10 = 10800;
      }
      else
      {
        v10 = 10800;
      }
      qword_100082E38 = v10;
      v3 = *(double *)&qword_100082E00;
      if (*(double *)&qword_100082E00 > *(double *)&qword_100082DF8 + (double)v10)
      {
        *(double *)&qword_100082E00 = *(double *)&qword_100082DF8 + (double)v10;
        v3 = *(double *)&qword_100082DF8 + (double)v10;
      }
      v9 = Current;
    }
    else
    {
      v9 = Current + (double)qword_100082E38;
    }
    if (v3 <= Current)
    {
      v11 = sub_100011628("validupdate");
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v18[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "starting update", (uint8_t *)v18, 2u);
      }
      qword_100082E00 = *(_QWORD *)&v9;
      v12 = sub_10004F500();
      v13 = sub_100050798(v12);
      v14 = sub_10005095C();
      v15 = sub_10004F810();
      if (!sub_10004F5B8(v12, v13, v15, 0))
      {
        if ((v14 & 1) != 0)
        {
          v16 = (void *)sub_10004F788();
          sub_10003E9E8(v16, (uint64_t)v12, v13);
        }
        else
        {
          v17 = sub_100011628("validupdate");
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v18[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "skipping update", (uint8_t *)v18, 2u);
          }
        }
      }
      if (v12)
        CFRelease(v12);
    }
    else
    {
      qword_100082DF8 = 0;
    }
  }
  os_release(v1);
}

uint64_t sub_100050798(const __CFString *a1)
{
  uint64_t v2;
  uint64_t v3;
  const __CFString *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  _BYTE buf[24];
  void *v15;
  uint64_t *v16;

  v2 = sub_10004F89C();
  v3 = sub_10004F810();
  if (v2 <= 0)
  {
    atomic_load(&qword_100082E28);
    v2 = atomic_load(&qword_100082E28);
  }
  v4 = (const __CFString *)sub_10004606C();
  if (!v4)
    v4 = (const __CFString *)CFRetain(CFSTR("valid.apple.com"));
  v5 = sub_10004F928();
  v10 = 0;
  v11 = &v10;
  v12 = 0x2000000000;
  v13 = -1;
  *(_QWORD *)buf = _NSConcreteStackBlock;
  *(_QWORD *)&buf[8] = 0x40000000;
  *(_QWORD *)&buf[16] = sub_1000509E8;
  v15 = &unk_100078398;
  v16 = &v10;
  sub_100016C6C((uint64_t)buf);
  v6 = v11[3];
  _Block_object_dispose(&v10, 8);
  v7 = sub_10004ED44();
  if (v5 < 7 || v6 < 3 || CFStringCompare(a1, v4, 1uLL) || v3 != v7)
  {
    atomic_store(0, &qword_100082E28);
    v8 = sub_100011628("validupdate");
    v2 = 0;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134218240;
      *(_QWORD *)&buf[4] = v7;
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Recreate VALID db generation %ld from previous %ld", buf, 0x16u);
      v2 = 0;
    }
  }
  if (v4)
    CFRelease(v4);
  return v2;
}

uint64_t sub_10005095C()
{
  const __CFBoolean *v0;
  const __CFBoolean *v1;
  CFTypeID v2;
  _BOOL8 v3;

  v0 = (const __CFBoolean *)CFPreferencesCopyValue(CFSTR("ValidUpdateEnabled"), CFSTR("com.apple.security"), kCFPreferencesAnyUser, kCFPreferencesCurrentHost);
  if (!v0)
    return 1;
  v1 = v0;
  v2 = CFGetTypeID(v0);
  v3 = v2 != CFBooleanGetTypeID() || CFBooleanGetValue(v1) != 0;
  CFRelease(v1);
  return v3;
}

BOOL sub_1000509E8(uint64_t a1, uint64_t *a2)
{
  _QWORD v3[5];

  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = sub_100050A44;
  v3[3] = &unk_100078370;
  v3[4] = *(_QWORD *)(a1 + 32);
  return sub_100018D8C(a2, 0, (uint64_t)v3);
}

BOOL sub_100050A44(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = sub_10004E684(a2, a3);
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) >= 0;
}

BOOL sub_100050A8C(uint64_t a1, uint64_t *a2)
{
  _QWORD v3[5];

  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = sub_100050AE8;
  v3[3] = &unk_100078190;
  v3[4] = *(_QWORD *)(a1 + 32);
  return sub_100018D8C(a2, 0, (uint64_t)v3);
}

uint64_t sub_100050AE8(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  int v6;
  NSObject *v7;
  uint64_t v8;
  __CFError *v9;
  CFIndex Code;
  const void *v11;
  uint64_t v12;
  _QWORD v14[8];
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  CFTypeRef v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint8_t buf[4];
  uint64_t v28;

  v23 = 0;
  v24 = &v23;
  v25 = 0x2000000000;
  v26 = 0;
  v19 = 0;
  v20 = &v19;
  v21 = 0x2000000000;
  v22 = a2 != 0;
  v15 = 0;
  v16 = &v15;
  v17 = 0x2000000000;
  v18 = 0;
  if (a2)
  {
    v5 = *(_QWORD *)(a2 + 8);
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 0x40000000;
    v14[2] = sub_100050CDC;
    v14[3] = &unk_100078BD8;
    v14[4] = &v19;
    v14[5] = &v15;
    v14[6] = &v23;
    v14[7] = a2;
    v6 = sub_10001979C(v5, CFSTR("SELECT value FROM admin WHERE key='check_again'"), &v18, (uint64_t)v14);
    *((_BYTE *)v20 + 24) = v6;
    if (v6 && !v16[3])
      goto LABEL_16;
  }
  else
  {
    v22 = 0;
  }
  v7 = sub_100011628("SecError");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    v8 = v16[3];
    *(_DWORD *)buf = 138412290;
    v28 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbGetNextUpdateTime failed: %@", buf, 0xCu);
  }
  v9 = (__CFError *)v16[3];
  if (v9)
    Code = CFErrorGetCode(v9);
  else
    Code = -2070;
  sub_1000521A8(1, 3, Code);
  v11 = (const void *)v16[3];
  if (v11)
  {
    if (a3 && !*a3)
      *a3 = v11;
    else
      CFRelease(v11);
  }
LABEL_16:
  v12 = v24[3];
  _Block_object_dispose(&v15, 8);
  _Block_object_dispose(&v19, 8);
  _Block_object_dispose(&v23, 8);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v12;
  return 1;
}

uint64_t sub_100050CDC(_QWORD *a1, sqlite3_stmt *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  char v8;
  _QWORD v10[6];

  v3 = *(_QWORD *)(a1[7] + 8);
  v4 = a1[6];
  v5 = *(_QWORD *)(a1[5] + 8);
  v10[0] = _NSConcreteStackBlock;
  v10[2] = sub_100050D70;
  v10[3] = &unk_100078BB0;
  v10[1] = 0x40000000;
  v10[4] = v4;
  v10[5] = a2;
  v6 = sub_100019D18(v3, a2, (CFTypeRef *)(v5 + 24), (uint64_t)v10);
  v7 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v7 + 24))
    v8 = v6;
  else
    v8 = 0;
  *(_BYTE *)(v7 + 24) = v8;
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

const void *sub_100050D70(uint64_t a1, _BYTE *a2)
{
  const void *result;
  _QWORD *v5;

  result = sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 40), 0);
  if (result)
  {
    v5 = result;
    result = (const void *)sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 40), 0);
    if ((_DWORD)result == 8)
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *v5;
  }
  *a2 = 1;
  return result;
}

id sub_100050DD8(__CFString **a1)
{
  const __CFString *v2;
  uint64_t v3;
  id v4;
  void *v5;
  id v6;

  if (qword_100082C28 != -1)
    dispatch_once(&qword_100082C28, &stru_1000767D0);
  if ((byte_100082C20 & 1) == 0)
  {
    sub_100012C88(-61, a1, CFSTR("Unable to update Valid DB from user agent"));
    return 0;
  }
  if ((sub_10005095C() & 1) == 0)
  {
    sub_100012C88(-61, a1, CFSTR("Valid updates not enabled on this device"));
    return 0;
  }
  v2 = sub_10004F500();
  v3 = sub_100050798(v2);
  v4 = (id)sub_10004F788();
  if (qword_100082D70 != -1)
    dispatch_once(&qword_100082D70, &stru_100077470);
  v5 = objc_autoreleasePoolPush();
  v6 = objc_msgSend((id)qword_100082D38, "updateNowFromServer:version:queue:", v2, v3, v4);
  objc_autoreleasePoolPop(v5);

  if (v2)
    CFRelease(v2);
  return v6;
}

BOOL sub_100050EE8(uint64_t a1, uint64_t *a2)
{
  _BOOL8 result;
  uint64_t v4;
  BOOL v5;

  result = sub_10004657C(a2, (_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), (uint64_t)&stru_1000780A8);
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v4 + 24))
    v5 = result;
  else
    v5 = 0;
  *(_BYTE *)(v4 + 24) = v5;
  return result;
}

BOOL sub_100050F3C(id a1, __SecRevocationDbConnection *a2, __CFError **a3)
{
  return sub_10004C5D4(a2, a3);
}

uint64_t sub_100050F48(_QWORD *a1, sqlite3_stmt *a2)
{
  CFTypeRef *v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  BOOL v8;
  BOOL v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  CFTypeRef *v13;
  char v14;
  uint64_t v15;
  char v16;
  _QWORD v18[6];

  v4 = (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24);
  v5 = sqlite3_bind_int64(a2, 1, a1[9]);
  v6 = sub_10001A970(v5, a2, v4, CFSTR("bind_int64[%d]"), 1);
  v7 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v7 + 24))
    v8 = v6;
  else
    v8 = 0;
  *(_BYTE *)(v7 + 24) = v8;
  v9 = sub_10001A8F8(a2, 2, (const void *)(*(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24) + 1), *(_QWORD *)(*(_QWORD *)(a1[7] + 8) + 24) - 1, (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24));
  v10 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v10 + 24))
    v11 = v9;
  else
    v11 = 0;
  *(_BYTE *)(v10 + 24) = v11;
  v12 = *(_QWORD *)(a1[10] + 8);
  v13 = (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24);
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 0x40000000;
  v18[2] = sub_1000511FC;
  v18[3] = &unk_100078C50;
  v18[4] = a1[8];
  v18[5] = a2;
  v14 = sub_100019D18(v12, a2, v13, (uint64_t)v18);
  v15 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v15 + 24))
    v16 = v14;
  else
    v16 = 0;
  *(_BYTE *)(v15 + 24) = v16;
  return *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
}

uint64_t sub_10005108C(uint64_t a1, sqlite3_stmt *a2)
{
  CFTypeRef *v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  BOOL v8;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  char v16;
  _QWORD v18[6];

  v4 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  v5 = sqlite3_bind_int64(a2, 1, *(_QWORD *)(a1 + 56));
  v6 = sub_10001A970(v5, a2, v4, CFSTR("bind_int64[%d]"), 1);
  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v7 + 24))
    v8 = v6;
  else
    v8 = 0;
  *(_BYTE *)(v7 + 24) = v8;
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 64));
  Length = CFDataGetLength(*(CFDataRef *)(a1 + 64));
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = sub_10001A8F8(a2, 2, BytePtr, Length, (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8)+ 24));
  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8);
  v12 = *(_QWORD *)(a1 + 48);
  v13 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  v18[0] = _NSConcreteStackBlock;
  v18[2] = sub_1000511C0;
  v18[3] = &unk_100078CA0;
  v18[1] = 0x40000000;
  v18[4] = v12;
  v18[5] = a2;
  v14 = sub_100019D18(v11, a2, (CFTypeRef *)(v13 + 24), (uint64_t)v18);
  v15 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v15 + 24))
    v16 = v14;
  else
    v16 = 0;
  *(_BYTE *)(v15 + 24) = v16;
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

sqlite3_int64 sub_1000511C0(uint64_t a1)
{
  sqlite3_int64 result;

  result = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result > 0;
  return result;
}

sqlite3_int64 sub_1000511FC(uint64_t a1)
{
  sqlite3_int64 result;

  result = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result > 0;
  return result;
}

sqlite3_int64 sub_100051238(uint64_t a1)
{
  sqlite3_int64 result;

  result = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result > 0;
  return result;
}

uint64_t sub_100051274(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[6];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = sub_1000512FC;
  v3[3] = &unk_100078280;
  v3[4] = &v4;
  v3[5] = a1;
  sub_100016C6C((uint64_t)v3);
  v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL sub_1000512FC(uint64_t a1, uint64_t *a2)
{
  _QWORD v3[4];
  __int128 v4;

  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = sub_100051358;
  v3[3] = &unk_100078258;
  v4 = *(_OWORD *)(a1 + 32);
  return sub_100018D8C(a2, 0, (uint64_t)v3);
}

uint64_t sub_100051358(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  const __CFData *v6;
  uint64_t v7;

  v6 = (const __CFData *)SecCertificateCopySHA256Digest(*(_QWORD *)(a1 + 40));
  v7 = sub_10001ABF0(a2, v6, a3);
  if (v6)
    CFRelease(v6);
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v7 > 0;
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

uint64_t sub_1000513D0(uint64_t a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass(&unk_1000790A8);
  **(_QWORD **)(a1 + 32) = result;
  return result;
}

CFStringRef sub_100051400(uint64_t a1, const __CFDictionary *a2)
{
  CFStringRef v4;

  v4 = CFURLGetString(*(CFURLRef *)(a1 + 80));
  return CFStringCreateWithFormat(0, a2, CFSTR("orvc<%p> current url:%@"), a1, v4);
}

CFStringRef sub_100051448(uint64_t a1)
{
  const __CFDictionary *v2;
  CFStringRef v3;

  v2 = (const __CFDictionary *)sub_100026A10();
  v3 = CFURLGetString(*(CFURLRef *)(a1 + 80));
  return CFStringCreateWithFormat(0, v2, CFSTR("orvc<%p> current url:%@"), a1, v3);
}

void sub_100051494(uint64_t *a1)
{
  _BYTE *v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  CFNumberRef v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int valuePtr;
  void **v14;
  uint64_t v15;
  uint64_t (*v16)(uint64_t, uint64_t);
  void *v17;
  uint64_t v18;
  uint64_t v19;
  CFBooleanRef v20;
  char v21;

  if (!a1)
    return;
  v2 = (_BYTE *)a1[3];
  if (!v2)
    return;
  v3 = *a1;
  if (!*a1)
    return;
  if (v2[55])
  {
    v4 = (uint64_t *)&kSecPolicyCheckGrayListedLeaf;
LABEL_12:
    v5 = *v4;
    v6 = a1[1];
    v14 = _NSConcreteStackBlock;
    v15 = 0x40000000;
    v16 = sub_10005512C;
    v17 = &unk_100079658;
    v18 = v5;
    v19 = v6;
    v20 = kCFBooleanFalse;
    v21 = 1;
    sub_10000D610(v3, (uint64_t)&v14);
    return;
  }
  if (v2[48])
  {
    if (!v2[49])
      goto LABEL_10;
LABEL_11:
    v4 = (uint64_t *)&kSecPolicyCheckBlackListedLeaf;
    goto LABEL_12;
  }
  if (!v2[49])
    goto LABEL_11;
LABEL_10:
  if (v2[54])
    goto LABEL_11;
  valuePtr = 0;
  v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  v8 = *a1;
  v9 = a1[1];
  v14 = _NSConcreteStackBlock;
  v15 = 0x40000000;
  v16 = sub_10005512C;
  v17 = &unk_100079658;
  v18 = kSecPolicyCheckRevocation;
  v19 = v9;
  v20 = v7;
  v21 = 1;
  sub_10000D610(v8, (uint64_t)&v14);
  v10 = *(_QWORD *)(*a1 + 200);
  if (v10)
  {
    v11 = a1[1];
    if (*(_QWORD *)(v10 + 16) > v11)
    {
      v12 = *(_QWORD *)(v10 + 8 * v11 + 136);
      if (v7)
        CFRetain(v7);
      *(_QWORD *)(v12 + 32) = v7;
    }
  }
  if (v7)
    CFRelease(v7);
}

uint64_t sub_100051618(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_100051700(uint64_t a1)
{
  void *v1;
  uint64_t v2;
  void *v3;
  void *v4;
  id v5;
  id v6;
  _UNKNOWN **v7;
  void *v8;
  id v9;
  objc_super v10;
  const __CFString *v11;
  const __CFString *v12;
  _QWORD v13[2];

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(void **)(a1 + 48);
  v4 = *(void **)(a1 + 56);
  v5 = *(id *)(a1 + 40);
  v6 = v3;
  v11 = CFSTR("errorDomain");
  if (v5)
  {
    v1 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "domain"));
    v12 = CFSTR("errorCode");
    v13[0] = v1;
    v7 = (_UNKNOWN **)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", objc_msgSend(v5, "code")));
  }
  else
  {
    v12 = CFSTR("errorCode");
    v13[0] = NSOSStatusErrorDomain;
    v7 = &off_10007FE60;
  }
  v13[1] = v7;
  v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v13, &v11, 2));
  if (v5)
  {

  }
  if (v6)
  {
    v9 = objc_msgSend(v6, "mutableCopy");
    objc_msgSend(v9, "setValuesForKeysWithDictionary:", v8);

    v8 = v9;
  }

  v10.receiver = v4;
  v10.super_class = (Class)TrustAnalytics;
  objc_msgSendSuper2(&v10, "logHardFailureForEventNamed:withAttributes:", v2, v8);

}

void sub_100051870(id a1)
{
  dispatch_group_t v1;
  void *v2;

  v1 = dispatch_group_create();
  v2 = (void *)qword_100082EA8;
  qword_100082EA8 = (uint64_t)v1;

}

NSDictionary *__cdecl sub_1000518A4(id a1)
{
  uint64_t v1;
  void *v2;
  double v3;
  void *v4;
  mach_timebase_info info;

  info = (mach_timebase_info)0xAAAAAAAAAAAAAAAALL;
  mach_timebase_info(&info);
  v1 = mach_absolute_time() - qword_100082E78;
  v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionaryWithDictionary:](NSMutableDictionary, "dictionaryWithDictionary:", qword_100082E70));
  *(float *)&v3 = (float)((float)info.numer / (float)info.denom) * (float)v1;
  v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v3));
  objc_msgSend(v2, "setObject:forKeyedSubscript:", v4, CFSTR("uptime"));

  return (NSDictionary *)v2;
}

NSDictionary *__cdecl sub_100051948(id a1)
{
  _QWORD *v1;
  uint64_t v2;
  void *v3;
  NSNumber *v4;
  NSNumber *v5;
  void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  void *v11;
  id v12;
  const void *v13;
  NSObject *v14;
  uint64_t v15;
  const void *v16;
  void *v17;
  uint64_t v18;
  void *v19;
  _UNKNOWN **v20;
  NSNumber *v21;
  void *v22;
  NSNumber *v23;
  void *v24;
  double v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  double v32;
  id v33;
  void *v34;
  void *v35;
  void *v36;
  uint64_t v37;
  void *v38;
  void *v39;
  _BOOL4 v41;
  void *v42;
  mach_timebase_info info;
  _QWORD v44[6];
  uint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t (*v48)(uint64_t, uint64_t);
  void (*v49)(uint64_t);
  id v50;
  uint64_t v51;
  uint64_t *v52;
  uint64_t v53;
  uint64_t v54;
  uint8_t buf[4];
  uint64_t v56;

  v1 = (_QWORD *)sub_100004464();
  if (v1)
    v2 = v1[19];
  else
    v2 = 0;
  v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v2));
  v4 = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", sub_100034930(0));
  v42 = (void *)objc_claimAutoreleasedReturnValue(v4);
  v5 = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", sub_1000348EC());
  v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  v7 = (void *)sub_10000C138();
  v41 = sub_100005508((uint64_t)CFSTR("CTKillSwitch"));
  if (v1)
    CFRelease(v1);
  info = (mach_timebase_info)0xAAAAAAAAAAAAAAAALL;
  mach_timebase_info(&info);
  v8 = mach_absolute_time();
  v9 = qword_100082E78;
  v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionaryWithDictionary:](NSMutableDictionary, "dictionaryWithDictionary:", qword_100082E68));
  objc_msgSend(v10, "setObject:forKeyedSubscript:", v3, CFSTR("OTAPKIAssetVersion"));
  objc_msgSend(v10, "setObject:forKeyedSubscript:", v42, CFSTR("TSContentVersion"));
  objc_msgSend(v10, "setObject:forKeyedSubscript:", v6, CFSTR("TSBuiltInVersion"));
  if (sub_100015138())
  {
    v11 = objc_autoreleasePoolPush();
    v51 = 0;
    v52 = &v51;
    v53 = 0x2020000000;
    v54 = 0;
    v45 = 0;
    v46 = &v45;
    v47 = 0x3032000000;
    v48 = sub_1000429E0;
    v49 = sub_1000429F0;
    v50 = 0;
    v12 = objc_msgSend((id)qword_100082DC8, "db");
    v44[0] = _NSConcreteStackBlock;
    v44[1] = 3221225472;
    v44[2] = sub_1000441D0;
    v44[3] = &unk_100077CC0;
    v44[4] = &v45;
    v44[5] = &v51;
    if (!sub_1000193B4((uint64_t)v12, (uint64_t)(v52 + 3), (uint64_t)v44) || v52[3])
    {
      v13 = sub_100011628("SecError");
      v14 = objc_claimAutoreleasedReturnValue(v13);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        v15 = v52[3];
        *(_DWORD *)buf = 138412290;
        v56 = v15;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "SecPinningDb: unable to get content version: %@", buf, 0xCu);
      }

      v16 = (const void *)v52[3];
      if (v16)
      {
        v52[3] = 0;
        CFRelease(v16);
      }
    }
    v17 = (void *)v46[5];
    if (!v17)
    {
      v18 = objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", 0));
      v19 = (void *)v46[5];
      v46[5] = v18;

      v17 = (void *)v46[5];
    }
    v20 = v17;
    _Block_object_dispose(&v45, 8);

    _Block_object_dispose(&v51, 8);
    objc_autoreleasePoolPop(v11);
  }
  else
  {
    v20 = &off_10007FDB8;
  }
  objc_msgSend(v10, "setObject:forKeyedSubscript:", v20, CFSTR("PinningDbVersion"));

  v21 = +[NSNumber numberWithLong:](NSNumber, "numberWithLong:", sub_10004F89C());
  v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
  objc_msgSend(v10, "setObject:forKeyedSubscript:", v22, CFSTR("RevocationDbVersion"));

  v23 = +[NSNumber numberWithLong:](NSNumber, "numberWithLong:", sub_10004F810());
  v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
  objc_msgSend(v10, "setObject:forKeyedSubscript:", v24, CFSTR("RevocationDbGeneration"));

  *(float *)&v25 = (float)((float)info.numer / (float)info.denom) * (float)(v8 - v9);
  v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v25));
  objc_msgSend(v10, "setObject:forKeyedSubscript:", v26, CFSTR("uptime"));

  v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", qword_100082E80));
  objc_msgSend(v10, "setObject:forKeyedSubscript:", v27, CFSTR("EvaluationCompletedEventCount"));

  v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", qword_100082E88));
  objc_msgSend(v10, "setObject:forKeyedSubscript:", v28, CFSTR("SystemRootUsageEventCount"));

  v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", qword_100082E90));
  objc_msgSend(v10, "setObject:forKeyedSubscript:", v29, CFSTR("TrustFailureEventCount"));

  v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", qword_100082E98));
  objc_msgSend(v10, "setObject:forKeyedSubscript:", v30, CFSTR("PinningEventCount"));

  v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", qword_100082EA0));
  objc_msgSend(v10, "setObject:forKeyedSubscript:", v31, CFSTR("TrustEvaluationEventCount"));

  if (v7)
  {
    objc_msgSend(v7, "timeIntervalSinceNow");
    v33 = sub_100020080((uint64_t)v32, 4);
    v34 = (void *)objc_claimAutoreleasedReturnValue(v33);
    objc_msgSend(v10, "setObject:forKeyedSubscript:", v34, CFSTR("OTAPKIAssetStaleness"));

  }
  else
  {
    objc_msgSend(v10, "setObject:forKeyedSubscript:", &off_10007FE30, CFSTR("OTAPKIAssetStaleness"));
  }
  v35 = (void *)sub_10004606C();
  v36 = v35;
  if (v35)
  {
    if (objc_msgSend(v35, "compare:", CFSTR("valid.apple.com")))
    {
      if (objc_msgSend(v36, "compare:", CFSTR("valid.apple.com/carry")))
      {
        if (objc_msgSend(v36, "compare:", CFSTR("valid.apple.com/seed")))
          v37 = 2;
        else
          v37 = 3;
      }
      else
      {
        v37 = 1;
      }
    }
    else
    {
      v37 = 0;
    }
  }
  else
  {
    v37 = -1;
  }

  v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", v37));
  objc_msgSend(v10, "setObject:forKeyedSubscript:", v38, CFSTR("ValidServer"));

  v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v41));
  objc_msgSend(v10, "setObject:forKeyedSubscript:", v39, CFSTR("CTKillSwitch"));

  return (NSDictionary *)v10;
}

void sub_100051F50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v12;
  va_list va;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a11);
  va_start(va, a11);
  v12 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100051F80(uint64_t a1)
{
  void *v2;
  _QWORD v3[5];

  if (sub_100015138())
  {
    v2 = objc_autoreleasePoolPush();
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_100051FF4;
    v3[3] = &unk_1000791F8;
    v3[4] = a1;
    sub_100017240(v3);
    objc_autoreleasePoolPop(v2);
  }
}

void sub_100051FF4(uint64_t a1)
{
  id v2;

  v2 = (id)objc_claimAutoreleasedReturnValue(+[TrustAnalytics logger](TrustAnalytics, "logger"));
  objc_msgSend(v2, "logSuccessForEventNamed:", *(_QWORD *)(a1 + 32));

}

void sub_100052038(uint64_t a1, char a2, uint64_t a3)
{
  void *v6;
  void *v7;
  void *v8;
  id v9;
  _QWORD v10[4];
  id v11;
  uint64_t v12;
  char v13;
  const __CFString *v14;
  void *v15;

  if (sub_100015138())
  {
    v6 = objc_autoreleasePoolPush();
    v14 = CFSTR("errorCode");
    v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", a3));
    v15 = v7;
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v15, &v14, 1));

    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_100052154;
    v10[3] = &unk_100079220;
    v13 = a2;
    v11 = v8;
    v12 = a1;
    v9 = v8;
    sub_100017240(v10);

    objc_autoreleasePoolPop(v6);
  }
}

void sub_100052154(uint64_t a1)
{
  int v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  id v6;

  v2 = *(unsigned __int8 *)(a1 + 48);
  v3 = (void *)objc_claimAutoreleasedReturnValue(+[TrustAnalytics logger](TrustAnalytics, "logger"));
  v5 = *(_QWORD *)(a1 + 32);
  v4 = *(_QWORD *)(a1 + 40);
  v6 = v3;
  if (v2)
    objc_msgSend(v3, "logHardFailureForEventNamed:withAttributes:", v4, v5);
  else
    objc_msgSend(v3, "logSoftFailureForEventNamed:withAttributes:", v4, v5);

}

void sub_1000521A8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  id v11;
  _QWORD v12[4];
  id v13;
  char v14;
  _QWORD v15[3];
  _QWORD v16[3];

  if (sub_100015138())
  {
    v6 = objc_autoreleasePoolPush();
    v15[0] = CFSTR("errorCode");
    v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithLong:](NSNumber, "numberWithLong:", a3));
    v16[0] = v7;
    v15[1] = CFSTR("database");
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", a1));
    v16[1] = v8;
    v15[2] = CFSTR("operation");
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", a2));
    v16[2] = v9;
    v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v16, v15, 3));

    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472;
    v12[2] = sub_100052318;
    v12[3] = &unk_100079248;
    v14 = 1;
    v13 = v10;
    v11 = v10;
    sub_100017240(v12);

    objc_autoreleasePoolPop(v6);
  }
}

void sub_100052318(uint64_t a1)
{
  int v2;
  void *v3;
  uint64_t v4;
  id v5;

  v2 = *(unsigned __int8 *)(a1 + 40);
  v3 = (void *)objc_claimAutoreleasedReturnValue(+[TrustAnalytics logger](TrustAnalytics, "logger"));
  v4 = *(_QWORD *)(a1 + 32);
  v5 = v3;
  if (v2)
    objc_msgSend(v3, "logHardFailureForEventNamed:withAttributes:", CFSTR("DatabaseEvent"), v4);
  else
    objc_msgSend(v3, "logSoftFailureForEventNamed:withAttributes:", CFSTR("DatabaseEvent"), v4);

}

id sub_100052374(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  NSNumber *v5;
  void *v6;
  NSNumber *v7;
  void *v8;
  void *v9;
  _QWORD v11[3];
  _QWORD v12[3];

  v2 = *(unsigned int *)objc_msgSend(objc_retainAutorelease(*(id *)(a1 + 32)), "bytes");
  v11[0] = CFSTR("Root");
  v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v2));
  v12[0] = v3;
  v11[1] = CFSTR("Policy");
  v4 = sub_100015ECC(*(_QWORD *)(a1 + 40));
  v5 = +[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", sub_1000200E0(*(const __CFArray **)(v4 + 8)));
  v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  v12[1] = v6;
  v11[2] = CFSTR("Caller");
  v7 = +[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", sub_100017818(*(_QWORD *)(a1 + 40)));
  v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
  v12[2] = v8;
  v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v12, v11, 3));

  return v9;
}

id sub_100052498(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  NSNumber *v9;
  void *v10;
  NSNumber *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  uint64_t v18;
  _QWORD v19[5];
  _QWORD v20[5];

  v2 = *(_QWORD *)(a1 + 32);
  if (*(uint64_t *)(v2 + 192) < 1)
    v3 = 0;
  else
    v3 = **(_QWORD **)(v2 + 184);
  v18 = 0x7FFFFFFFFFFFFFFFLL;
  v4 = sub_10005267C(v2, &v18);
  v5 = *(_QWORD *)(a1 + 32);
  if (v18)
  {
    v6 = *(_QWORD *)(v5 + 200);
    if (v6)
      v7 = *(_QWORD *)(v6 + 16) - 1;
    else
      v7 = -1;
    v8 = 1;
    if (v18 == v7)
      v8 = 2;
    v18 = v8;
  }
  ++qword_100082E90;
  v19[0] = CFSTR("Caller");
  v9 = +[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", sub_100017818(v5));
  v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
  v20[0] = v10;
  v19[1] = CFSTR("Policy");
  v11 = +[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", sub_1000200E0(*(const __CFArray **)(v3 + 8)));
  v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
  v20[1] = v12;
  v19[2] = CFSTR("Error");
  v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v4));
  v20[2] = v13;
  v19[3] = CFSTR("Index");
  v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", v18));
  v20[3] = v14;
  v19[4] = CFSTR("TrustResult");
  v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(v3 + 64)));
  v20[4] = v15;
  v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v20, v19, 5));

  return v16;
}

uint64_t sub_10005267C(uint64_t a1, _QWORD *a2)
{
  id v3;
  uint64_t v4;
  _QWORD v6[6];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  int v14;

  v11 = 0;
  v12 = &v11;
  v13 = 0x2020000000;
  v14 = -67671;
  v7 = 0;
  v8 = &v7;
  v9 = 0x2020000000;
  v10 = 0x7FFFFFFFFFFFFFFFLL;
  v3 = *(id *)(**(_QWORD **)(a1 + 184) + 56);
  if (v3)
  {
    if (qword_100082EC0 != -1)
      dispatch_once(&qword_100082EC0, &stru_100079380);
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    v6[2] = sub_1000527B4;
    v6[3] = &unk_1000793A8;
    v6[4] = &v7;
    v6[5] = &v11;
    objc_msgSend(v3, "enumerateObjectsUsingBlock:", v6);
    if (a2)
      *a2 = v8[3];
  }
  v4 = *((unsigned int *)v12 + 6);

  _Block_object_dispose(&v7, 8);
  _Block_object_dispose(&v11, 8);
  return v4;
}

void sub_100052790(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v7 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_1000527B4(uint64_t a1, void *a2, uint64_t a3)
{
  id v3;
  id v4;
  id v5;
  id v6;
  uint64_t v7;
  unsigned int v8;
  void *i;
  uint64_t v10;
  id v11;
  const void *v12;
  NSObject *v13;
  unsigned int v14;
  id v15;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint8_t buf[4];
  uint64_t v23;
  _BYTE v24[128];

  v3 = a2;
  if (objc_msgSend(v3, "count"))
  {
    v20 = 0u;
    v21 = 0u;
    v18 = 0u;
    v19 = 0u;
    v15 = v3;
    v4 = v3;
    v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v18, v24, 16);
    if (v5)
    {
      v6 = v5;
      v7 = *(_QWORD *)v19;
      v8 = 11;
      do
      {
        for (i = 0; i != v6; i = (char *)i + 1)
        {
          if (*(_QWORD *)v19 != v7)
            objc_enumerationMutation(v4);
          v10 = *(_QWORD *)(*((_QWORD *)&v18 + 1) + 8 * (_QWORD)i);
          v11 = objc_msgSend((id)qword_100082EC8, "indexOfObject:", v10);
          if (v11 == (id)0x7FFFFFFFFFFFFFFFLL)
          {
            v12 = sub_100011628("SecWarning");
            v13 = objc_claimAutoreleasedReturnValue(v12);
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 138412290;
              v23 = v10;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "unknown failure key in details dictionary: %@", buf, 0xCu);
            }

          }
          else
          {
            v14 = dword_1000621C8[2 * (_QWORD)v11];
            if (v8 > v14)
            {
              *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a3;
              *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = dword_1000621C8[2 * (_QWORD)v11 + 1];
              v8 = v14;
            }
          }
        }
        v6 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v18, v24, 16);
      }
      while (v6);
    }

    v3 = v15;
  }

}

void sub_100052988(id a1)
{
  void *v1;
  void *v2;
  void *v3;

  v1 = objc_autoreleasePoolPush();
  v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
  objc_msgSend(v2, "addObject:", kSecPolicyCheckSSLHostname);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckEmail);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckTemporalValidity);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckWeakKeySize);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckWeakSignature);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckKeyUsage);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckExtendedKeyUsage);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckSubjectCommonName);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckSubjectCommonNamePrefix);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckSubjectCommonNameTEST);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckSubjectOrganization);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckSubjectOrganizationalUnit);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckNotValidBefore);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckEAPTrustedServerNames);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckLeafMarkerOid);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckLeafMarkerOidWithoutValueCheck);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckLeafMarkersProdAndQA);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckBlackListedLeaf);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckGrayListedLeaf);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckLeafSPKISHA256);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckNotCA);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckMarkRepresentation);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckIssuerCommonName);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckIssuerCommonNamePrefix);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckBasicConstraints);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckBasicConstraintsCA);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckBasicConstraintsPathLen);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckIntermediateSPKISHA256);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckIntermediateEKU);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckIntermediateMarkerOid);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckIntermediateMarkerOidWithoutValueCheck);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckIntermediateOrganization);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckIntermediateCountry);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckAnchorSHA256);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckAnchorTrusted);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckMissingIntermediate);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckAnchorApple);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckCAspkiSHA256);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckNonEmptySubject);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckIdLinkage);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckKeySize);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckSignatureHashAlgorithms);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckCertificatePolicy);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckValidRoot);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckCriticalExtensions);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckChainLength);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckBasicCertificateProcessing);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckNameConstraints);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckPolicyConstraints);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckGrayListedKey);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckBlackListedKey);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckUsageConstraints);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckSystemTrustedWeakHash);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckSystemTrustedWeakKey);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckPinningRequired);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckRevocation);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckRevocationResponseRequired);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckCTRequired);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckSystemTrustedCTRequired);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckIssuerPolicyConstraints);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckIssuerNameConstraints);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckValidityPeriodMaximums);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckSystemTrustValidityPeriod);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckOtherTrustValidityPeriod);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckServerAuthEKU);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckEmailProtectionEKU);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckSinglePurposeChainEKU);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckUnparseableExtension);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckNonTlsCTRequired);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckDuplicateExtension);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckNoNetworkAccess);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckExtendedValidation);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckRevocationOnline);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckRevocationIfTrusted);
  objc_msgSend(v2, "addObject:", kSecPolicyCheckRevocationDbIgnored);
  v3 = (void *)qword_100082EC8;
  qword_100082EC8 = (uint64_t)v2;

  objc_autoreleasePoolPop(v1);
}

void sub_100052FA8(id a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  uint64_t v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;

  v17 = objc_autoreleasePoolPush();
  v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &unk_100062420, 32));
  v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &unk_100062440, 32));
  v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &unk_100062460, 32));
  v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &unk_100062480, 32));
  v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &unk_1000624A0, 32));
  v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &unk_1000624C0, 32));
  v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &unk_1000624E0, 32));
  v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &unk_100062500, 32));
  v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &unk_100062520, 32));
  v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &unk_100062540, 32));
  v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &unk_100062560, 32));
  v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &unk_100062580, 32));
  v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &unk_1000625A0, 32));
  v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &unk_1000625C0, 32));
  v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &unk_1000625E0, 32));
  v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &unk_100062600, 32));
  v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &unk_100062620, 32));
  v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &unk_100062640, 32));
  v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &unk_100062660, 32));
  v7 = objc_claimAutoreleasedReturnValue(+[NSSet setWithObjects:](NSSet, "setWithObjects:", v16, v22, v21, v15, v20, v19, v14, v18, v12, v13, v11, v1, v10, v2, v9, v3,
           v4,
           v5,
           v6,
           0));
  v8 = (void *)qword_100082ED0;
  qword_100082ED0 = v7;

  objc_autoreleasePoolPop(v17);
}

uint64_t sub_100053308(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_100053318(uint64_t a1)
{

}

id sub_100053320(void *a1, uint64_t a2)
{
  id v3;
  id v4;
  _QWORD v6[6];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t (*v10)(uint64_t, uint64_t);
  void (*v11)(uint64_t);
  id v12;

  v3 = a1;
  v7 = 0;
  v8 = &v7;
  v9 = 0x3032000000;
  v10 = sub_100053308;
  v11 = sub_100053318;
  v12 = (id)0xAAAAAAAAAAAAAAAALL;
  v12 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_100053418;
  v6[3] = &unk_100079440;
  v6[4] = &v7;
  v6[5] = a2;
  xpc_array_apply(v3, v6);
  v4 = (id)v8[5];
  _Block_object_dispose(&v7, 8);

  return v4;
}

void sub_100053400(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_100053418(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  void *v5;
  uint64_t v6;
  void *v7;

  v4 = sub_100016F80(a3, *(_QWORD *)(a1 + 40));
  v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v7 = *(void **)(v6 + 40);
  if (v5)
  {
    objc_msgSend(v7, "addObject:", v5);
  }
  else
  {
    *(_QWORD *)(v6 + 40) = 0;

  }
  return v5 != 0;
}

void sub_1000536F0(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100053770(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100053814(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000538B4(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000539D8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100054374(uint64_t a1)
{
  const void *v2;
  NSObject *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  _QWORD v11[2];
  _QWORD v12[2];
  uint8_t buf[4];
  void *v14;

  v2 = sub_100011628("SecError");
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "originalRequest"));
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "taskId"));
    *(_DWORD *)buf = 138412290;
    v14 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "trustd triggered evaluation timeout for taskId %@", buf, 0xCu);

  }
  v11[0] = NSURLErrorFailingURLStringErrorKey;
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "absoluteString"));
  v11[1] = NSDebugDescriptionErrorKey;
  v12[0] = v6;
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "description"));
  v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("(trustd) The request timed out: %@"), v7));
  v12[1] = v8;
  v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v12, v11, 2));
  v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", NSURLErrorDomain, -1001, v9));

  objc_msgSend(*(id *)(a1 + 48), "URLSession:task:didCompleteWithError:", *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 32), v10);
}

void sub_100054534(id a1)
{
  qword_100082EE0 = (uint64_t)dispatch_queue_create("trustsettings.read", 0);
  qword_100082EE8 = (uint64_t)dispatch_queue_create("trustsettings.write", 0);
}

void sub_100054574(int a1, const void *a2, const void *a3, const void *a4, const void *a5, void (**a6)(_QWORD, _QWORD, _QWORD))
{
  void *v12;
  _QWORD block[9];
  int v14;
  __CFString *v15;

  if (sub_100015138() && (sub_100015138() & 1) != 0)
  {
    v12 = _Block_copy(a6);
    if (a2)
      CFRetain(a2);
    if (a3)
      CFRetain(a3);
    if (a4)
      CFRetain(a4);
    if (a5)
      CFRetain(a5);
    if (qword_100082EF0 != -1)
      dispatch_once(&qword_100082EF0, &stru_100079548);
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = sub_1000546AC;
    block[3] = &unk_100079490;
    v14 = a1;
    block[6] = a3;
    block[7] = a4;
    block[8] = a5;
    block[4] = v12;
    block[5] = a2;
    dispatch_async((dispatch_queue_t)qword_100082EE8, block);
  }
  else
  {
    v15 = 0;
    sub_100012C88(-4, &v15, CFSTR("Trust settings not implemented in this environment"));
    ((void (**)(_QWORD, _QWORD, __CFString *))a6)[2](a6, 0, v15);
  }
}

void sub_1000546AC(_QWORD *a1)
{
  uint64_t v2;
  int v3;
  __int16 v4;
  void (**v5)(_QWORD, _QWORD, _QWORD);
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  CFTypeRef cf;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  __int16 v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  char v18;

  cf = 0;
  v11 = 0;
  v2 = a1[6];
  v15 = 0;
  v16 = &v15;
  v17 = 0x2000000000;
  v18 = 1;
  v12 = &v11;
  v13 = 0x2000000000;
  v14 = 0;
  v3 = SecTrustSettingsDomainForName(v2);
  switch(v3)
  {
    case 0:
      v4 = 384;
      goto LABEL_6;
    case 2:
      sub_100012C88(-25292, (__CFString **)&cf, CFSTR("system trust settings are not modifiable"));
      break;
    case 1:
      v4 = 438;
LABEL_6:
      *((_WORD *)v12 + 12) = v4;
      sub_100012C88(-50, (__CFString **)&cf, CFSTR("Authorization not present"));
      *((_BYTE *)v16 + 24) = 0;
      break;
    default:
      sub_100012C88(-25319, (__CFString **)&cf, CFSTR("invalid trust settings domain"));
      break;
  }
  _Block_object_dispose(&v11, 8);
  _Block_object_dispose(&v15, 8);
  v5 = (void (**)(_QWORD, _QWORD, _QWORD))a1[4];
  ((void (**)(_QWORD, _QWORD, CFTypeRef))v5)[2](v5, 0, cf);
  _Block_release(v5);
  if (cf)
    CFRelease(cf);
  v6 = (const void *)a1[5];
  if (v6)
    CFRelease(v6);
  v7 = (const void *)a1[6];
  if (v7)
    CFRelease(v7);
  v8 = (const void *)a1[7];
  if (v8)
    CFRelease(v8);
  v9 = (const void *)a1[8];
  if (v9)
    CFRelease(v9);
}

uint64_t sub_1000547EC(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  NSObject *v10;
  uint64_t v11;
  _QWORD block[10];
  int v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  dispatch_semaphore_t v22;

  v19 = 0;
  v20 = &v19;
  v21 = 0x2000000000;
  v22 = (dispatch_semaphore_t)0xAAAAAAAAAAAAAAAALL;
  v22 = dispatch_semaphore_create(0);
  v15 = 0;
  v16 = &v15;
  v17 = 0x2000000000;
  v18 = 0;
  v10 = dispatch_queue_create("trustsettings.write.recursive", 0);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100054920;
  block[3] = &unk_1000794E0;
  v14 = a1;
  block[6] = a2;
  block[7] = a3;
  block[8] = a4;
  block[9] = a5;
  block[4] = &v15;
  block[5] = &v19;
  dispatch_async(v10, block);
  dispatch_semaphore_wait((dispatch_semaphore_t)v20[3], 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release((dispatch_object_t)v20[3]);
  dispatch_release(v10);
  v11 = *((unsigned __int8 *)v16 + 24);
  _Block_object_dispose(&v15, 8);
  _Block_object_dispose(&v19, 8);
  return v11;
}

void sub_100054920(uint64_t a1)
{
  int v1;
  const void *v2;
  const void *v3;
  const void *v4;
  void (*v5[4])(_QWORD, _QWORD, _QWORD);
  __int128 v6;
  uint64_t v7;

  v1 = *(_DWORD *)(a1 + 80);
  v2 = *(const void **)(a1 + 48);
  v3 = *(const void **)(a1 + 56);
  v5[0] = (void (*)(_QWORD, _QWORD, _QWORD))_NSConcreteStackBlock;
  v5[1] = (void (*)(_QWORD, _QWORD, _QWORD))0x40000000;
  v5[2] = (void (*)(_QWORD, _QWORD, _QWORD))sub_10005498C;
  v5[3] = (void (*)(_QWORD, _QWORD, _QWORD))&unk_1000794B8;
  v4 = *(const void **)(a1 + 64);
  v7 = *(_QWORD *)(a1 + 72);
  v6 = *(_OWORD *)(a1 + 32);
  sub_100054574(v1, 0, v2, v3, v4, v5);
}

intptr_t sub_10005498C(_QWORD *a1, char a2, CFTypeRef cf)
{
  _QWORD *v4;

  *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = a2;
  if ((a2 & 1) == 0)
  {
    v4 = (_QWORD *)a1[6];
    if (v4)
    {
      *v4 = cf;
      if (cf)
        CFRetain(cf);
    }
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(_QWORD *)(a1[5] + 8) + 24));
}

BOOL sub_1000549DC(int a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  _BOOL8 v8;
  _QWORD block[8];
  int v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  char v15;

  if (sub_100015138() && (sub_100015138() & 1) != 0)
  {
    v12 = 0;
    v13 = &v12;
    v14 = 0x2000000000;
    v15 = 1;
    if (qword_100082EF0 != -1)
      dispatch_once(&qword_100082EF0, &stru_100079548);
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = sub_100054AF0;
    block[3] = &unk_100079508;
    v11 = a1;
    block[4] = &v12;
    block[5] = a2;
    block[6] = a4;
    block[7] = a3;
    dispatch_sync((dispatch_queue_t)qword_100082EE0, block);
    v8 = *((_BYTE *)v13 + 24) != 0;
    _Block_object_dispose(&v12, 8);
  }
  else
  {
    sub_100012C88(-4, a4, CFSTR("Trust settings not implemented in this environment"));
    return 0;
  }
  return v8;
}

void sub_100054AF0(uint64_t a1)
{
  int v2;
  __CFString **v3;
  const __CFURL *v4;
  const __CFURL *v5;
  timespec v6;
  int v7;
  int v8;
  int v9;
  int v10;
  void *v11;
  off_t st_size;
  int v13;
  uint64_t v14;
  NSObject *v15;
  CFDataRef v16;
  stat v17;
  _OWORD __b[65];
  uint8_t buf[4];
  uint64_t v20;

  memset(__b, 170, 0x401uLL);
  v2 = SecTrustSettingsDomainForName(*(_QWORD *)(a1 + 40));
  if (v2 == 2)
  {
    strcpy((char *)__b, "/System/Library/Keychains/SystemTrustSettings.plist");
    goto LABEL_10;
  }
  v3 = *(__CFString ***)(a1 + 48);
  if (v2 != 1)
  {
    if (v2)
      goto LABEL_10;
    v4 = sub_10001DC28((uint64_t)CFSTR("TrustSettings.plist"));
    if (!v4)
    {
      sub_100012C88(-61, v3, CFSTR("unable to create user trust settings path"));
      goto LABEL_10;
    }
    goto LABEL_8;
  }
  v4 = sub_10001DC28((uint64_t)CFSTR("Admin.plist"));
  if (v4)
  {
LABEL_8:
    v5 = v4;
    CFURLGetFileSystemRepresentation(v4, 0, (UInt8 *)__b, 1025);
    CFRelease(v5);
    goto LABEL_10;
  }
  sub_100012C88(-61, v3, CFSTR("unable to create admin trust settings path"));
LABEL_10:
  v6.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v6.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v17.st_blksize = v6;
  *(timespec *)v17.st_qspare = v6;
  v17.st_birthtimespec = v6;
  *(timespec *)&v17.st_size = v6;
  v17.st_mtimespec = v6;
  v17.st_ctimespec = v6;
  *(timespec *)&v17.st_uid = v6;
  v17.st_atimespec = v6;
  *(timespec *)&v17.st_dev = v6;
  v7 = open((const char *)__b, 0, 0);
  if (v7 == -1)
  {
    __error();
    v11 = 0;
LABEL_26:
    sub_100012C88(-25263, *(__CFString ***)(a1 + 48), CFSTR("no trust settings for domain"));
    v16 = 0;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
    goto LABEL_27;
  }
  v8 = v7;
  v9 = fstat(v7, &v17);
  if (!v9)
  {
    st_size = v17.st_size;
    v11 = malloc_type_malloc(v17.st_size, 0xAAF489A7uLL);
    if (v11)
    {
      if ((lseek(v8, 0, 0) & 0x80000000) == 0)
      {
        v13 = read(v8, v11, st_size);
        v14 = v13;
        if (v13 == st_size)
        {
          v10 = 0;
          goto LABEL_23;
        }
        if ((v13 & 0x80000000) == 0)
        {
          v15 = sub_100011628("SecError");
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 134217984;
            v20 = v14;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "_readFile: short read (%ld)", buf, 0xCu);
          }
        }
      }
      free(v11);
      v11 = 0;
    }
    st_size = 0;
    v10 = 5;
    goto LABEL_23;
  }
  v10 = v9;
  v11 = 0;
  st_size = 0;
LABEL_23:
  close(v8);
  if (!st_size || v10)
    goto LABEL_26;
  v16 = CFDataCreate(kCFAllocatorDefault, (const UInt8 *)v11, st_size);
LABEL_27:
  **(_QWORD **)(a1 + 56) = v16;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v16 != 0;
  free(v11);
}

uint64_t sub_100054D94(char a1, _QWORD *a2)
{
  NSObject *v4;
  uint64_t result;
  NSObject *v6;
  const void *v7;
  int v8;
  NSObject *v9;
  _QWORD v10[6];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  char v18;

  if ((a1 & 2) == 0)
    goto LABEL_26;
  v4 = sub_100011628("trustsettings");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v10[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "_SecTrustResetSettings: kSecTrustResetOCSPCache", (uint8_t *)v10, 2u);
  }
  result = sub_10003A444((uint64_t)a2);
  if ((_DWORD)result)
  {
    if ((a1 & 8) == 0)
      goto LABEL_14;
LABEL_26:
    v6 = sub_100011628("trustsettings");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v10[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "_SecTrustResetSettings: kSecTrustResetValidDB", (uint8_t *)v10, 2u);
    }
    v15 = 0;
    v16 = &v15;
    v17 = 0x2000000000;
    v18 = 1;
    v11 = 0;
    v12 = &v11;
    v13 = 0x2000000000;
    v14 = 0;
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 0x40000000;
    v10[2] = sub_100050EE8;
    v10[3] = &unk_1000780D0;
    v10[4] = &v15;
    v10[5] = &v11;
    sub_100016C6C((uint64_t)v10);
    v7 = (const void *)v12[3];
    if (v7)
    {
      if (a2 && !*a2)
        *a2 = v7;
      else
        CFRelease(v7);
    }
    v8 = *((unsigned __int8 *)v16 + 24);
    _Block_object_dispose(&v11, 8);
    _Block_object_dispose(&v15, 8);
    if (!v8)
    {
      return 0;
    }
    else
    {
LABEL_14:
      if ((a1 & 4) != 0)
      {
        v9 = sub_100011628("trustsettings");
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v10[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "_SecTrustResetSettings: kSecTrustResetIssuersCache", (uint8_t *)v10, 2u);
        }
        if (qword_100082CE0 != -1)
          dispatch_once(&qword_100082CE0, &stru_100076B90);
        if (qword_100082CE8)
          dispatch_sync(*(dispatch_queue_t *)qword_100082CE8, &stru_100076BD0);
      }
      return 1;
    }
  }
  return result;
}

uint64_t sub_100054FA4(uint64_t a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass(&unk_100079568);
  **(_QWORD **)(a1 + 32) = result;
  return result;
}

CFStringRef sub_100054FD4(uint64_t a1, const __CFDictionary *a2)
{
  return CFStringCreateWithFormat(0, a2, CFSTR("builder<%p> current path: %@"), a1, *(_QWORD *)(a1 + 200));
}

CFStringRef sub_100055004(uint64_t a1)
{
  const __CFDictionary *v2;

  v2 = (const __CFDictionary *)sub_100026A10();
  return CFStringCreateWithFormat(0, v2, CFSTR("builder<%p> current path: %@"), a1, *(_QWORD *)(a1 + 200));
}

void sub_100055048(uint64_t a1, CFDictionaryRef theDict)
{
  const __CFString *Value;
  const __CFString *v5;
  CFTypeID v6;
  const void *v7;
  const void *v8;
  CFTypeID v9;

  Value = (const __CFString *)CFDictionaryGetValue(theDict, kSecTrustStoreHashAlgorithmKey);
  if (Value)
  {
    v5 = Value;
    v6 = CFGetTypeID(Value);
    if (v6 == CFStringGetTypeID() && CFStringCompare(CFSTR("sha256"), v5, 0) == kCFCompareEqualTo)
    {
      v7 = CFDictionaryGetValue(theDict, kSecTrustStoreSPKIHashKey);
      if (v7)
      {
        v8 = v7;
        v9 = CFGetTypeID(v7);
        if (v9 == CFDataGetTypeID())
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), v8);
      }
    }
  }
}

uint64_t sub_100055100(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_100055114(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t sub_10005512C(uint64_t a1, uint64_t a2)
{
  return sub_10000E2C8(a2, *(CFTypeRef *)(a1 + 32), *(_QWORD *)(a1 + 40), *(const void **)(a1 + 48), *(unsigned __int8 *)(a1 + 56), 0);
}

void sub_100055148(id a1)
{
  _OWORD *v1;

  v1 = malloc_type_malloc(0x30uLL, 0x10200409674FD55uLL);
  qword_100082F30 = (uint64_t)v1;
  if (v1)
  {
    v1[1] = 0u;
    v1[2] = 0u;
    *v1 = 0u;
    *((_BYTE *)v1 + 32) = 1;
    *((_DWORD *)v1 + 9) = 1;
  }
}

void sub_100055194(id a1)
{
  _OWORD *v1;
  UInt8 __b[1024];

  memset(__b, 170, sizeof(__b));
  if (sub_10005521C(__b))
  {
    v1 = sub_100055278(3);
    qword_100082F20 = (uint64_t)v1;
    if (v1)
    {
      if (*((_QWORD *)v1 + 1))
        *((_BYTE *)v1 + 32) = 0;
    }
  }
}

BOOL sub_10005521C(UInt8 *a1)
{
  const __CFURL *v2;
  const __CFURL *v3;
  _BOOL8 v4;

  v2 = sub_10001DC28((uint64_t)CFSTR("TrustStore.sqlite3"));
  if (!v2)
    return 0;
  v3 = v2;
  v4 = CFURLGetFileSystemRepresentation(v2, 0, a1, 1024) != 0;
  CFRelease(v3);
  return v4;
}

_OWORD *sub_100055278(int a1)
{
  _OWORD *v2;
  _OWORD *v3;
  uint64_t has_internal_content;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  NSObject *v8;
  const __CFSet *Mutable;
  const __CFSet *v10;
  CFMutableDictionaryRef v11;
  DIR *v12;
  const __CFString *v13;
  const __CFString *v14;
  const __CFString *v15;
  const void *v16;
  const void *v17;
  const void *NormalizedSubjectContent;
  __CFArray *Value;
  CFIndex v20;
  NSObject *v21;
  CFIndex Count;
  uint64_t (*v23)(uint64_t);
  NSObject *v24;
  __uint64_t v25;
  int v26;
  NSObject *v27;
  int v28;
  uid_t v29;
  NSObject *v30;
  const void *v31;
  uint64_t v32;
  NSObject *v34;
  NSObject *v35;
  NSObject *v36;
  NSObject *v37;
  int v38;
  CFMutableSetRef theSet;
  dirent *v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t v44;
  dirent buf;
  uint8_t v46[8];
  uint64_t v47;
  uint64_t (*v48)(uint64_t, char *);
  NSObject *v49;
  uint64_t *v50;
  __int128 v51;
  uint64_t (*v52)(uint64_t);
  uint64_t v53;
  uint8_t *v54;

  v2 = malloc_type_malloc(0x30uLL, 0x10200409674FD55uLL);
  v3 = v2;
  if (!v2)
    goto LABEL_69;
  v2[1] = 0u;
  v2[2] = 0u;
  *v2 = 0u;
  *(_QWORD *)v2 = dispatch_queue_create("truststore", 0);
  *((_DWORD *)v3 + 9) = a1;
  has_internal_content = os_variant_has_internal_content("com.apple.trustd");
  v5 = 0;
  v6 = &unk_100060000;
  v7 = &unk_100060000;
  if ((_DWORD)has_internal_content)
  {
    if (SecIsInternalRelease(has_internal_content))
    {
      v8 = sub_100011628("truststore");
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.d_ino) = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Loading Apple Corporate Roots...", (uint8_t *)&buf, 2u);
      }
      Mutable = CFSetCreateMutable(0, 0, &kCFTypeSetCallBacks);
      v10 = CFSetCreateMutable(0, 0, &kCFTypeSetCallBacks);
      v11 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      v12 = opendir("/AppleInternal/Library/Security/");
      CFRetain(CFSTR("/AppleInternal/Library/Security/"));
      if (v12)
      {
        theSet = v10;
        v40 = (dirent *)0xAAAAAAAAAAAAAAAALL;
        memset(&buf, 170, sizeof(buf));
        while (1)
        {
          while (1)
          {
            while (1)
            {
              if (readdir_r(v12, &buf, &v40) || !v40)
              {
                if (CFSetGetCount(Mutable) >= 1 && (v20 = CFSetGetCount(Mutable), v20 == CFSetGetCount(v10)))
                {
                  v21 = sub_100011628("truststore");
                  v7 = (_QWORD *)&unk_100060000;
                  v6 = (_QWORD *)&unk_100060000;
                  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
                  {
                    Count = CFSetGetCount(Mutable);
                    LODWORD(v51) = 134217984;
                    *(_QWORD *)((char *)&v51 + 4) = Count;
                    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Loaded %ld Apple Corporate Roots", (uint8_t *)&v51, 0xCu);
                  }
                  v5 = malloc_type_malloc(0x20uLL, 0x6004087AB86DCuLL);
                  if (Mutable)
                    CFRetain(Mutable);
                  *v5 = Mutable;
                  if (theSet)
                    CFRetain(theSet);
                  v5[1] = theSet;
                  if (v11)
                    CFRetain(v11);
                  v5[2] = v11;
                  v5[3] = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
                }
                else
                {
                  v5 = 0;
                  v7 = &unk_100060000;
                  v6 = &unk_100060000;
                }
                closedir(v12);
                if (Mutable)
                  goto LABEL_36;
                goto LABEL_37;
              }
              if (v40->d_namlen >= 5u)
              {
                v13 = CFStringCreateWithCString(0, v40->d_name, 0x8000100u);
                if (v13)
                  break;
              }
            }
            v14 = v13;
            if (CFStringHasSuffix(v13, CFSTR(".cer")))
              break;
LABEL_21:
            CFRelease(v14);
          }
          v15 = CFStringCreateWithFormat(0, 0, CFSTR("%@%@"), CFSTR("/AppleInternal/Library/Security/"), v14);
          CFRelease(v14);
          v41 = 0;
          v42 = &v41;
          v43 = 0x2000000000;
          v44 = 0;
          *(_QWORD *)v46 = _NSConcreteStackBlock;
          v47 = 0x40000000;
          v48 = sub_100055B28;
          v49 = &unk_100079AE0;
          v50 = &v41;
          *(_QWORD *)&v51 = _NSConcreteStackBlock;
          *((_QWORD *)&v51 + 1) = 0x40000000;
          v52 = sub_100026C34;
          v53 = (uint64_t)&unk_100075DD0;
          v54 = v46;
          sub_100019A20(v15, (uint64_t)&v51);
          v14 = (const __CFString *)v42[3];
          _Block_object_dispose(&v41, 8);
          if (v15)
            CFRelease(v15);
          if (v14)
          {
            CFSetAddValue(Mutable, v14);
            v16 = (const void *)SecCertificateCopySHA256Digest(v14);
            if (v16)
            {
              v17 = v16;
              CFSetAddValue(v10, v16);
              CFRelease(v17);
            }
            NormalizedSubjectContent = (const void *)SecCertificateGetNormalizedSubjectContent(v14);
            Value = (__CFArray *)CFDictionaryGetValue(v11, NormalizedSubjectContent);
            if (Value
              || (Value = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks),
                  CFDictionaryAddValue(v11, NormalizedSubjectContent, Value),
                  CFRelease(Value),
                  Value))
            {
              CFArrayAppendValue(Value, v14);
            }
            goto LABEL_21;
          }
        }
      }
      v34 = sub_100011628("SecError");
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.d_ino) = 138412290;
        *(__uint64_t *)((char *)&buf.d_ino + 4) = (__uint64_t)CFSTR("/AppleInternal/Library/Security/");
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Failed to open Apple Corporate Root directory (%@)", (uint8_t *)&buf, 0xCu);
      }
      v5 = 0;
      if (Mutable)
LABEL_36:
        CFRelease(Mutable);
LABEL_37:
      if (v11)
        CFRelease(v11);
      CFRelease(CFSTR("/AppleInternal/Library/Security/"));
    }
    else
    {
      v5 = 0;
    }
  }
  *((_QWORD *)v3 + 5) = v5;
  if (!sub_100015138())
    goto LABEL_69;
  *(_QWORD *)&v51 = 0;
  *((_QWORD *)&v51 + 1) = &v51;
  v23 = (uint64_t (*)(uint64_t))v6[22];
  v52 = v23;
  LODWORD(v53) = 1;
  v24 = *(NSObject **)v3;
  if (!*(_QWORD *)v3)
    goto LABEL_66;
  buf.d_ino = (__uint64_t)_NSConcreteStackBlock;
  v25 = v7[18];
  buf.d_seekoff = v25;
  *(_QWORD *)&buf.d_reclen = sub_100055C0C;
  *(_QWORD *)&buf.d_name[3] = &unk_100079B08;
  *(_QWORD *)&buf.d_name[11] = &v51;
  *(_QWORD *)&buf.d_name[19] = v3;
  dispatch_sync(v24, &buf);
  if (*(_DWORD *)(*((_QWORD *)&v51 + 1) + 24))
  {
LABEL_66:
    v35 = sub_100011628("SecError");
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      v38 = *(_DWORD *)(*((_QWORD *)&v51 + 1) + 24);
      *(_DWORD *)v46 = 67109120;
      *(_DWORD *)&v46[4] = v38;
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "Unable to open shared db connection (error %d)", v46, 8u);
    }
    _Block_object_dispose(&v51, 8);
LABEL_69:
    v26 = 0;
    goto LABEL_70;
  }
  _Block_object_dispose(&v51, 8);
  v26 = sqlite3_prepare_v3(*((sqlite3 **)v3 + 1), "SELECT data FROM tsettings WHERE subj=? AND uuid=?", 51, 1u, (sqlite3_stmt **)v3 + 2, 0);
  if (v26 == 1)
  {
    *(_QWORD *)&v51 = 0;
    v26 = sqlite3_exec(*((sqlite3 **)v3 + 1), "CREATE TABLE tsettings(sha256 BLOB NOT NULL DEFAULT '',subj BLOB NOT NULL DEFAULT '',tset BLOB,data BLOB,uuid BLOB NOT NULL DEFAULT '',UNIQUE(sha256,uuid));CREATE INDEX isubj ON tsettings(subj);",
            0,
            0,
            (char **)&v51);
    if ((_QWORD)v51)
    {
      v27 = sub_100011628("SecWarning");
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.d_ino) = 136315138;
        *(__uint64_t *)((char *)&buf.d_ino + 4) = v51;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "CREATE TABLE tsettings: %s", (uint8_t *)&buf, 0xCu);
      }
      sqlite3_free((void *)v51);
    }
    if (v26)
      goto LABEL_70;
    v26 = sqlite3_prepare_v3(*((sqlite3 **)v3 + 1), "SELECT data FROM tsettings WHERE subj=? AND uuid=?", 51, 1u, (sqlite3_stmt **)v3 + 2, 0);
  }
  if (!v26)
  {
    v28 = sqlite3_prepare_v3(*((sqlite3 **)v3 + 1), "SELECT tset FROM tsettings WHERE sha256=? AND uuid=?", 53, 1u, (sqlite3_stmt **)v3 + 3, 0);
    if (!v28)
    {
      *(_QWORD *)&v51 = 0;
      *((_QWORD *)&v51 + 1) = &v51;
      v52 = v23;
      v53 = -1;
      *(_QWORD *)v46 = 0;
      v47 = (uint64_t)v46;
      v48 = (uint64_t (*)(uint64_t, char *))v23;
      v49 = 0xAAAAAAAAAAAAAAAALL;
      if (*((_DWORD *)v3 + 9) == 2)
        v29 = geteuid();
      else
        v29 = 282;
      v49 = sub_10000F7BC(v29);
      if (*(_QWORD *)(v47 + 24))
      {
        v30 = *(NSObject **)v3;
        buf.d_ino = (__uint64_t)_NSConcreteStackBlock;
        buf.d_seekoff = v25;
        *(_QWORD *)&buf.d_reclen = sub_100055CC4;
        *(_QWORD *)&buf.d_name[3] = &unk_100079B30;
        *(_QWORD *)&buf.d_name[11] = v46;
        *(_QWORD *)&buf.d_name[19] = &v51;
        *(_QWORD *)&buf.d_name[27] = v3;
        dispatch_sync(v30, &buf);
        v31 = *(const void **)(v47 + 24);
        if (v31)
        {
          *(_QWORD *)(v47 + 24) = 0;
          CFRelease(v31);
        }
      }
      v32 = *(_QWORD *)(*((_QWORD *)&v51 + 1) + 24);
      _Block_object_dispose(v46, 8);
      _Block_object_dispose(&v51, 8);
      if (v32)
        *((_BYTE *)v3 + 33) = 1;
      else
        *((_BYTE *)v3 + 33) = 0;
      return v3;
    }
    v26 = v28;
  }
LABEL_70:
  if (*((_QWORD *)v3 + 5))
  {
    *((_QWORD *)v3 + 1) = 0;
    *((_BYTE *)v3 + 32) = 1;
    v36 = sub_100011628("SecError");
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf.d_ino) = 67109120;
      HIDWORD(buf.d_ino) = v26;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "Failed to create trust store database: %d", (uint8_t *)&buf, 8u);
    }
    sub_1000521A8(4, 0, v26);
  }
  else
  {
    if (*(_QWORD *)v3)
      dispatch_release(*(dispatch_object_t *)v3);
    free(v3);
    v37 = sub_100011628("SecError");
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf.d_ino) = 67109120;
      HIDWORD(buf.d_ino) = v26;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "Failed to create trust store database: %d", (uint8_t *)&buf, 8u);
    }
    sub_1000521A8(4, 0, v26);
    return 0;
  }
  return v3;
}

uint64_t sub_100055B28(uint64_t a1, char *a2)
{
  uint64_t result;
  int v4;
  timespec v5;
  off_t st_size;
  void *v7;
  stat v8;

  result = open(a2, 0);
  if ((result & 0x80000000) == 0)
  {
    v4 = result;
    v5.tv_sec = 0xAAAAAAAAAAAAAAAALL;
    v5.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    *(timespec *)&v8.st_blksize = v5;
    *(timespec *)v8.st_qspare = v5;
    v8.st_birthtimespec = v5;
    *(timespec *)&v8.st_size = v5;
    v8.st_mtimespec = v5;
    v8.st_ctimespec = v5;
    *(timespec *)&v8.st_uid = v5;
    v8.st_atimespec = v5;
    *(timespec *)&v8.st_dev = v5;
    if (fstat(result, &v8))
      return close(v4);
    st_size = v8.st_size;
    if (v8.st_size < 0 || v8.st_size >= 0x7FFFFFFF)
    {
      return close(v4);
    }
    else
    {
      v7 = mmap(0, v8.st_size, 1, 2, v4, 0);
      if ((unint64_t)v7 + 1 >= 2)
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = SecCertificateCreateWithBytes(0);
      result = close(v4);
      if (v7)
        return munmap(v7, st_size);
    }
  }
  return result;
}

uint64_t sub_100055C0C(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  char __b[1024];

  v1 = result;
  v2 = qword_100082F38;
  if (qword_100082F38)
  {
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = 0;
  }
  else
  {
    memset(__b, 170, sizeof(__b));
    result = sub_10005521C((UInt8 *)__b);
    if ((_DWORD)result)
    {
      result = sub_100055D98(__b, (sqlite3 **)&qword_100082F38);
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v1 + 32) + 8) + 24) = result;
    }
    v2 = qword_100082F38;
  }
  *(_QWORD *)(*(_QWORD *)(v1 + 40) + 8) = v2;
  return result;
}

sqlite3_stmt *sub_100055CC4(_QWORD *a1)
{
  sqlite3_stmt *v2;
  const UInt8 *BytePtr;
  unint64_t Length;
  sqlite3_stmt *result;
  sqlite3_stmt *ppStmt;

  ppStmt = 0;
  if (!sqlite3_prepare_v2(*(sqlite3 **)(a1[6] + 8), "SELECT COUNT(*) FROM tsettings WHERE uuid=?", 44, &ppStmt, 0))
  {
    v2 = ppStmt;
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(*(_QWORD *)(a1[4] + 8) + 24));
    Length = CFDataGetLength(*(CFDataRef *)(*(_QWORD *)(a1[4] + 8) + 24));
    if (!(Length >> 31) && !sqlite3_bind_blob(v2, 1, BytePtr, Length, 0) && sqlite3_step(ppStmt) == 100)
      *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24) = sqlite3_column_int64(ppStmt, 0);
  }
  result = ppStmt;
  if (ppStmt)
    return (sqlite3_stmt *)sqlite3_finalize(ppStmt);
  return result;
}

uint64_t sub_100055D98(const char *a1, sqlite3 **a2)
{
  uint64_t result;
  size_t v5;
  size_t v6;
  size_t v7;
  size_t v8;
  int v9;
  int v10;
  char __b[1024];

  result = sqlite3_open_v2(a1, a2, 4194310, 0);
  if ((_DWORD)result == 14)
  {
    v5 = strlen(a1);
    if (v5 - 1025 < 0xFFFFFFFFFFFFFC00)
      return 14;
    v6 = v5;
    memset(__b, 170, sizeof(__b));
    __memcpy_chk(__b, a1, v6, 1024);
    v7 = v6 - 1;
    do
    {
      if (!v7)
        return sqlite3_open(a1, a2);
      v8 = v7;
      v9 = __b[v7--];
    }
    while (v9 != 47);
    __b[v8] = 0;
    if (mkdir(__b, 0x1FFu))
    {
      v10 = *__error();
      if (v10 > 19)
      {
        if (v10 > 29)
        {
          if (v10 != 69)
          {
            if (v10 == 30)
              return 8;
            return 2;
          }
        }
        else
        {
          if (v10 == 20)
            return 14;
          if (v10 != 28)
            return 2;
        }
        return 13;
      }
      if (v10 == 5)
        return 10;
      if (v10 == 13)
        return 3;
      if (v10 != 17)
        return 2;
    }
    return sqlite3_open(a1, a2);
  }
  return result;
}

void sub_100055F18(id a1)
{
  _OWORD *v1;
  UInt8 __b[1024];

  memset(__b, 170, sizeof(__b));
  if (sub_10005521C(__b))
  {
    v1 = sub_100055278(2);
    qword_100082F10 = (uint64_t)v1;
    if (v1)
    {
      if (*((_QWORD *)v1 + 1))
        *((_BYTE *)v1 + 32) = 0;
    }
  }
}

BOOL sub_100055FA0(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  NSObject *v4;
  _BOOL8 v5;
  _QWORD block[9];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  char v11;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = -86;
  if (!a1)
  {
    sub_100012C88(-50, a4, CFSTR("truststore is NULL"));
LABEL_7:
    v5 = 0;
    *((_BYTE *)v9 + 24) = 0;
    goto LABEL_4;
  }
  if (*(_BYTE *)(a1 + 32))
  {
    sub_100012C88(-25292, a4, CFSTR("truststore is readOnly"));
    goto LABEL_7;
  }
  v4 = *(NSObject **)a1;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100056088;
  block[3] = &unk_1000799D8;
  block[4] = &v8;
  block[5] = a3;
  block[6] = a2;
  block[7] = a4;
  block[8] = a1;
  dispatch_sync(v4, block);
  v5 = *((_BYTE *)v9 + 24) != 0;
LABEL_4:
  _Block_object_dispose(&v8, 8);
  return v5;
}

void sub_100056088(uint64_t a1)
{
  uint64_t v2;
  CFArrayRef v3;
  uint64_t NormalizedSubjectContent;
  const __CFData *v5;
  uint64_t v6;
  const __CFData *v7;
  NSObject *v8;
  NSObject *v9;
  CFTypeID v10;
  CFArrayRef v11;
  CFArrayRef v12;
  CFTypeID v13;
  CFDataRef XMLData;
  CFDataRef v15;
  uint64_t v16;
  uint64_t v17;
  sqlite3_stmt *v18;
  const UInt8 *BytePtr;
  unint64_t Length;
  uint64_t v21;
  uint64_t v22;
  sqlite3_stmt *v23;
  const UInt8 *v24;
  unint64_t v25;
  uint64_t v26;
  sqlite3_stmt *v27;
  const UInt8 *v28;
  unint64_t v29;
  sqlite3_stmt *v30;
  const void *v31;
  unint64_t v32;
  sqlite3_stmt *v33;
  const UInt8 *v34;
  unint64_t v35;
  int v36;
  NSObject *v37;
  _QWORD *v38;
  int v39;
  int v40;
  NSObject *v41;
  _QWORD *v42;
  uint64_t v43;
  sqlite3_stmt *ppStmt;
  void *values;
  uint8_t buf[4];
  int v47;
  __int16 v48;
  _QWORD *v49;

  v3 = *(CFArrayRef *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 48);
  ppStmt = 0;
  values = v3;
  NormalizedSubjectContent = SecCertificateGetNormalizedSubjectContent(v2);
  if (!NormalizedSubjectContent)
  {
    sub_100012C88(-50, *(__CFString ***)(a1 + 56), CFSTR("get normalized subject failed"));
LABEL_60:
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
    return;
  }
  v5 = (const __CFData *)NormalizedSubjectContent;
  v6 = SecCertificateCopySHA256Digest(*(_QWORD *)(a1 + 48));
  if (!v6)
  {
    sub_100012C88(-50, *(__CFString ***)(a1 + 56), CFSTR("get sha256 digest failed"));
    goto LABEL_60;
  }
  v7 = (const __CFData *)v6;
  v8 = sub_10000F78C(*(NSObject **)(a1 + 64));
  if (v8)
  {
    v9 = v8;
    if (v3)
    {
      v10 = CFGetTypeID(v3);
      if (v10 == CFDictionaryGetTypeID())
      {
        v11 = CFArrayCreate(0, (const void **)&values, 1, &kCFTypeArrayCallBacks);
LABEL_8:
        v3 = v11;
        values = v11;
        v12 = v11;
        goto LABEL_11;
      }
      v13 = CFGetTypeID(v3);
      if (v13 == CFArrayGetTypeID())
      {
        v12 = 0;
LABEL_11:
        XMLData = CFPropertyListCreateXMLData(kCFAllocatorDefault, v3);
        if (!XMLData)
        {
          sub_100012C88(-50, *(__CFString ***)(a1 + 56), CFSTR("xml encode failed"));
          *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
          if (!v12)
            goto LABEL_51;
          goto LABEL_50;
        }
        v15 = XMLData;
        v16 = sqlite3_exec(*(sqlite3 **)(*(_QWORD *)(a1 + 64) + 8), "BEGIN EXCLUSIVE TRANSACTION;", 0, 0, 0);
        if ((_DWORD)v16)
        {
          sub_100012C88(-26276, *(__CFString ***)(a1 + 56), CFSTR("sqlite3 error: %d"), v16);
        }
        else
        {
          if (CFDataGetLength(v7) >= 1
            && CFDataGetLength(v5) >= 1
            && CFDataGetLength(v15) >= 1
            && SecCertificateGetLength(*(_QWORD *)(a1 + 48)) > 0)
          {
            v17 = sqlite3_prepare_v2(*(sqlite3 **)(*(_QWORD *)(a1 + 64) + 8), "INSERT OR REPLACE INTO tsettings(sha256,subj,tset,data,uuid)VALUES(?,?,?,?,?)", 78, &ppStmt, 0);
            if ((_DWORD)v17)
              goto LABEL_66;
            v18 = ppStmt;
            BytePtr = CFDataGetBytePtr(v7);
            Length = CFDataGetLength(v7);
            if (Length >> 31)
            {
              v21 = 18;
LABEL_20:
              sub_100012C88(-26276, *(__CFString ***)(a1 + 56), CFSTR("sqlite3 error: %d"), v21);
              *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
              v22 = v21;
LABEL_31:
              if (ppStmt)
                v22 = sqlite3_finalize(ppStmt);
              v36 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
              if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) && !(_DWORD)v22)
              {
                v22 = sqlite3_exec(*(sqlite3 **)(*(_QWORD *)(a1 + 64) + 8), "COMMIT TRANSACTION", 0, 0, 0);
                v36 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
              }
              if (!v36 || (_DWORD)v22)
              {
                v37 = sub_100011628("SecError");
                if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
                {
                  v38 = *(_QWORD **)(a1 + 56);
                  if (v38)
                    v38 = (_QWORD *)*v38;
                  *(_DWORD *)buf = 67109378;
                  v47 = v22;
                  v48 = 2112;
                  v49 = v38;
                  _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "Failed to update trust store: (%d) %@", buf, 0x12u);
                }
                sub_1000521A8(4, 2, (int)v22);
                if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
                {
                  sub_100012C88(-26276, *(__CFString ***)(a1 + 56), CFSTR("sqlite3 error: %d"), v22);
                  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
                }
                v39 = sqlite3_exec(*(sqlite3 **)(*(_QWORD *)(a1 + 64) + 8), "ROLLBACK TRANSACTION", 0, 0, 0);
                if (v39)
                {
                  v40 = v39;
                  v41 = sub_100011628("SecError");
                  if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
                  {
                    v42 = *(_QWORD **)(a1 + 56);
                    if (v42)
                      v42 = (_QWORD *)*v42;
                    *(_DWORD *)buf = 67109378;
                    v47 = v40;
                    v48 = 2112;
                    v49 = v42;
                    _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "Failed to rollback transaction (%d) %@", buf, 0x12u);
                  }
                }
              }
LABEL_49:
              CFRelease(v15);
              if (!v12)
              {
LABEL_51:
                CFRelease(v7);
                CFRelease(v9);
                return;
              }
LABEL_50:
              CFRelease(v12);
              goto LABEL_51;
            }
            v17 = sqlite3_bind_blob(v18, 1, BytePtr, Length, 0);
            if ((_DWORD)v17)
            {
LABEL_66:
              v21 = v17;
              goto LABEL_20;
            }
            v23 = ppStmt;
            v24 = CFDataGetBytePtr(v5);
            v25 = CFDataGetLength(v5);
            if (v25 >> 31)
              goto LABEL_29;
            v26 = sqlite3_bind_blob(v23, 2, v24, v25, 0);
            if (!(_DWORD)v26)
            {
              v27 = ppStmt;
              v28 = CFDataGetBytePtr(v15);
              v29 = CFDataGetLength(v15);
              if (v29 >> 31)
                goto LABEL_29;
              v26 = sqlite3_bind_blob(v27, 3, v28, v29, 0);
              if ((_DWORD)v26)
                goto LABEL_71;
              v30 = ppStmt;
              v31 = (const void *)SecCertificateGetBytePtr(*(_QWORD *)(a1 + 48));
              v32 = SecCertificateGetLength(*(_QWORD *)(a1 + 48));
              if (v32 >> 31)
              {
LABEL_29:
                v22 = 18;
LABEL_30:
                sub_100012C88(-26276, *(__CFString ***)(a1 + 56), CFSTR("sqlite3 error: %d"), v22);
                *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
                goto LABEL_31;
              }
              v26 = sqlite3_bind_blob(v30, 4, v31, v32, 0);
              if (!(_DWORD)v26)
              {
                v33 = ppStmt;
                v34 = CFDataGetBytePtr((CFDataRef)v9);
                v35 = CFDataGetLength((CFDataRef)v9);
                if (v35 >> 31)
                  goto LABEL_29;
                v26 = sqlite3_bind_blob(v33, 5, v34, v35, 0);
                if (!(_DWORD)v26)
                {
                  v43 = sqlite3_step(ppStmt);
                  if ((_DWORD)v43 == 101)
                  {
                    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
                    *(_BYTE *)(*(_QWORD *)(a1 + 64) + 33) = 1;
                    v22 = 101;
                  }
                  else
                  {
                    v22 = v43;
                    if ((_DWORD)v43)
                    {
                      sub_100012C88(-26276, *(__CFString ***)(a1 + 56), CFSTR("sqlite3 error: %d"), v43);
                      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
                    }
                    else
                    {
                      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
                    }
                  }
                  goto LABEL_31;
                }
              }
            }
LABEL_71:
            v22 = v26;
            goto LABEL_30;
          }
          sub_100012C88(-26276, *(__CFString ***)(a1 + 56), CFSTR("size error"));
        }
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
        goto LABEL_49;
      }
      sub_100012C88(-50, *(__CFString ***)(a1 + 56), CFSTR("trustSettingsDictOrArray neither dict nor array"));
    }
    else
    {
      v11 = CFArrayCreate(0, 0, 0, &kCFTypeArrayCallBacks);
      if (v11)
        goto LABEL_8;
      sub_100012C88(-108, *(__CFString ***)(a1 + 56), CFSTR("CFArrayCreate failed"));
    }
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
    goto LABEL_51;
  }
  sub_100012C88(-26276, *(__CFString ***)(a1 + 56), CFSTR("get uuid failed"));
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  CFRelease(v7);
}

uint64_t sub_100056734(uint64_t a1, uint64_t a2, __CFString **a3)
{
  const __CFData *v6;
  const __CFData *v7;
  NSObject *v8;
  uint64_t v9;
  const void *v10;
  _QWORD block[7];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  NSObject *v16;

  v13 = 0;
  v14 = &v13;
  v15 = 0x2000000000;
  v16 = 0xAAAAAAAAAAAAAAAALL;
  v16 = sub_10000F78C(a1);
  if (!a1)
  {
    sub_100012C88(-50, a3, CFSTR("truststore is NULL"));
LABEL_15:
    v7 = 0;
    goto LABEL_18;
  }
  if (*(_BYTE *)(a1 + 32))
  {
    sub_100012C88(-25292, a3, CFSTR("truststore is readOnly"));
    goto LABEL_15;
  }
  if (!v14[3])
  {
    sub_100012C88(-26276, a3, CFSTR("uuid is NULL"));
    goto LABEL_15;
  }
  v6 = (const __CFData *)SecCertificateCopySHA256Digest(a2);
  v7 = v6;
  if (v6)
  {
    if (CFDataGetLength(v6) > 0)
    {
      v8 = *(NSObject **)a1;
      block[0] = _NSConcreteStackBlock;
      block[1] = 0x40000000;
      block[2] = sub_1000568A0;
      block[3] = &unk_100079A00;
      block[5] = a1;
      block[6] = v7;
      block[4] = &v13;
      dispatch_sync(v8, block);
      v9 = 1;
      goto LABEL_7;
    }
    sub_100012C88(-108, a3, CFSTR("cert digest of bad length"));
  }
  else
  {
    sub_100012C88(-108, a3, CFSTR("failed to get cert sha256 digest"));
  }
LABEL_18:
  v9 = 0;
LABEL_7:
  v10 = (const void *)v14[3];
  if (v10)
  {
    v14[3] = 0;
    CFRelease(v10);
  }
  if (v7)
    CFRelease(v7);
  _Block_object_dispose(&v13, 8);
  return v9;
}

void sub_1000568A0(uint64_t a1)
{
  int v2;
  sqlite3_stmt *v3;
  const UInt8 *BytePtr;
  unint64_t Length;
  sqlite3_stmt *v6;
  const UInt8 *v7;
  unint64_t v8;
  int v9;
  NSObject *v10;
  sqlite3_stmt *ppStmt;
  uint8_t buf[4];
  int v13;

  ppStmt = 0;
  v2 = sqlite3_prepare_v2(*(sqlite3 **)(*(_QWORD *)(a1 + 40) + 8), "DELETE FROM tsettings WHERE sha256=? AND uuid=?", 48, &ppStmt, 0);
  if (!v2)
  {
    v3 = ppStmt;
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 48));
    Length = CFDataGetLength(*(CFDataRef *)(a1 + 48));
    if (Length >> 31)
    {
LABEL_5:
      v9 = 18;
      goto LABEL_9;
    }
    v2 = sqlite3_bind_blob(v3, 1, BytePtr, Length, 0);
    if (!v2)
    {
      v6 = ppStmt;
      v7 = CFDataGetBytePtr(*(CFDataRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
      v8 = CFDataGetLength(*(CFDataRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
      if (v8 >> 31)
        goto LABEL_5;
      v2 = sqlite3_bind_blob(v6, 2, v7, v8, 0);
      if (!v2)
        v2 = sqlite3_step(ppStmt);
    }
  }
  v9 = v2;
LABEL_9:
  if (ppStmt)
    sqlite3_finalize(ppStmt);
  if (v9 && v9 != 101)
  {
    v10 = sub_100011628("SecError");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      v13 = v9;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Removal of certificate from trust store failed: %d", buf, 8u);
    }
    sub_1000521A8(4, 2, v9);
  }
}

uint64_t sub_100056A34(uint64_t a1, __CFString **a2)
{
  NSObject *v4;
  const void *v5;
  uint64_t v6;
  _QWORD block[7];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  char v16;

  v13 = 0;
  v14 = &v13;
  v15 = 0x2000000000;
  v16 = 0;
  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = 0xAAAAAAAAAAAAAAAALL;
  v12 = sub_10000F78C(a1);
  if (a1)
  {
    if (*(_BYTE *)(a1 + 32))
    {
      sub_100012C88(-25292, a2, CFSTR("truststore is readOnly"));
    }
    else
    {
      if (v10[3])
      {
        v4 = *(NSObject **)a1;
        block[0] = _NSConcreteStackBlock;
        block[1] = 0x40000000;
        block[2] = sub_100056B68;
        block[3] = &unk_100079A28;
        block[4] = &v9;
        block[5] = &v13;
        block[6] = a1;
        dispatch_sync(v4, block);
        goto LABEL_5;
      }
      sub_100012C88(-26276, a2, CFSTR("uuid is NULL"));
    }
  }
  else
  {
    sub_100012C88(-50, a2, CFSTR("truststore is NULL"));
  }
  *((_BYTE *)v14 + 24) = 0;
LABEL_5:
  v5 = (const void *)v10[3];
  if (v5)
  {
    v10[3] = 0;
    CFRelease(v5);
  }
  v6 = *((unsigned __int8 *)v14 + 24);
  _Block_object_dispose(&v9, 8);
  _Block_object_dispose(&v13, 8);
  return v6;
}

uint64_t sub_100056B68(_QWORD *a1)
{
  int v2;
  sqlite3_stmt *v3;
  const UInt8 *BytePtr;
  unint64_t Length;
  int v6;
  NSObject *v7;
  uint64_t v8;
  sqlite3_stmt *v9;
  uint64_t v10;
  sqlite3_stmt *v11;
  sqlite3_stmt *ppStmt;
  uint8_t buf[4];
  int v15;

  ppStmt = 0;
  v2 = sqlite3_prepare_v2(*(sqlite3 **)(a1[6] + 8), "DELETE from tsettings WHERE uuid=?", 35, &ppStmt, 0);
  if (!v2)
  {
    v3 = ppStmt;
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(*(_QWORD *)(a1[4] + 8) + 24));
    Length = CFDataGetLength(*(CFDataRef *)(*(_QWORD *)(a1[4] + 8) + 24));
    if (Length >> 31)
    {
      v6 = 18;
      goto LABEL_9;
    }
    v2 = sqlite3_bind_blob(v3, 1, BytePtr, Length, 0);
    if (!v2)
    {
      if (!sqlite3_exec(*(sqlite3 **)(a1[6] + 8), "BEGIN EXCLUSIVE TRANSACTION;", 0, 0, 0))
        sqlite3_step(ppStmt);
      v2 = sqlite3_exec(*(sqlite3 **)(a1[6] + 8), "COMMIT TRANSACTION; VACUUM;", 0, 0, 0);
    }
  }
  v6 = v2;
LABEL_9:
  if (ppStmt)
    sqlite3_finalize(ppStmt);
  if (v6)
  {
    v7 = sub_100011628("SecError");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      v15 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Clearing of trust store failed: %d", buf, 8u);
    }
    sub_1000521A8(4, 2, v6);
    v8 = a1[6];
  }
  else
  {
    *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) = 1;
    v8 = a1[6];
    *(_BYTE *)(v8 + 33) = 0;
  }
  v9 = *(sqlite3_stmt **)(v8 + 16);
  if (v9)
  {
    sqlite3_finalize(v9);
    v8 = a1[6];
  }
  sqlite3_prepare_v3(*(sqlite3 **)(v8 + 8), "SELECT data FROM tsettings WHERE subj=? AND uuid=?", 51, 1u, (sqlite3_stmt **)(v8 + 16), 0);
  v10 = a1[6];
  v11 = *(sqlite3_stmt **)(v10 + 24);
  if (v11)
  {
    sqlite3_finalize(v11);
    v10 = a1[6];
  }
  return sqlite3_prepare_v3(*(sqlite3 **)(v10 + 8), "SELECT tset FROM tsettings WHERE sha256=? AND uuid=?", 53, 1u, (sqlite3_stmt **)(v10 + 24), 0);
}

uint64_t sub_100056D80(uint64_t a1, __CFArray **a2, __CFString **a3)
{
  CFMutableArrayRef Mutable;
  uint64_t v7;
  const void *v8;
  CFMutableArrayRef v9;
  const __CFArray *v10;
  uint64_t v11;
  const void *v12;
  const __CFDictionary *v13;
  size_t Count;
  size_t v15;
  NSObject *v16;
  const char *v17;
  NSObject *v18;
  uint64_t *v19;
  uint64_t v20;
  const __CFSet **v21;
  const __CFSet *v22;
  int v23;
  __CFString *v24;
  CFIndex v25;
  __CFArray *v26;
  NSObject *v27;
  NSObject *v28;
  NSObject *v29;
  const void **v30;
  const void **v31;
  uint64_t v32;
  const __CFArray *v33;
  CFTypeID v34;
  CFIndex v35;
  CFIndex v36;
  CFIndex i;
  const void *ValueAtIndex;
  NSObject *v39;
  __CFArray *v40;
  const void *v41;
  const void *v42;
  uint64_t v43;
  const __CFString *v45;
  int v46;
  const __CFDictionary *v47;
  _QWORD block[9];
  uint64_t v49;
  uint64_t *v50;
  uint64_t v51;
  NSObject *v52;
  uint64_t v53;
  uint64_t *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t *v58;
  uint64_t v59;
  char v60;
  uint64_t v61;
  uint64_t *v62;
  uint64_t v63;
  char v64;
  __int128 context;
  void (*v66)(uint64_t, SecCertificateRef);
  void *v67;
  uint64_t *v68;
  uint64_t v69;
  uint64_t v70;

  v57 = 0;
  v58 = &v57;
  v59 = 0x2000000000;
  v60 = 1;
  v53 = 0;
  v54 = &v53;
  v55 = 0x2000000000;
  v56 = 0;
  v49 = 0;
  v50 = &v49;
  v51 = 0x2000000000;
  v52 = 0xAAAAAAAAAAAAAAAALL;
  v52 = sub_10000F78C(a1);
  Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  v54[3] = (uint64_t)Mutable;
  if (!Mutable)
    goto LABEL_15;
  if (!a2)
  {
    v45 = CFSTR("trustStoreContents is NULL");
LABEL_67:
    v46 = -50;
LABEL_69:
    sub_100012C88(v46, a3, v45);
    *((_BYTE *)v58 + 24) = 0;
    goto LABEL_15;
  }
  if (!a1)
  {
    sub_100012C88(-50, a3, CFSTR("ts is NULL"));
    *((_BYTE *)v58 + 24) = 0;
    v19 = v54;
    if (!v54[3])
      goto LABEL_58;
    goto LABEL_23;
  }
  if (*(_DWORD *)(a1 + 36) == 1)
  {
    v7 = sub_100004464();
    if (!v7)
      goto LABEL_57;
    v8 = (const void *)v7;
    v9 = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
    if (!v9)
    {
      v27 = sub_100011628("SecError");
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(context) = 0;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Unable to allocate anchor array", (uint8_t *)&context, 2u);
      }
      goto LABEL_56;
    }
    v10 = v9;
    v11 = sub_100004464();
    if (!v11)
    {
      v28 = sub_100011628("SecError");
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(context) = 0;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Unable to retrieve current OTAPKIRef", (uint8_t *)&context, 2u);
      }
LABEL_52:
      v40 = sub_100002DF0(v10);
      CFRelease(v10);
      CFRelease(v8);
      if (v40)
      {
        if (CFArrayGetCount(v40) >= 1)
        {
          CFRetain(v40);
          *a2 = v40;
        }
        v8 = v40;
LABEL_56:
        CFRelease(v8);
      }
LABEL_57:
      v19 = v54;
      goto LABEL_58;
    }
    v12 = (const void *)v11;
    v13 = *(const __CFDictionary **)(v11 + 72);
    if (!v13)
    {
      v29 = sub_100011628("SecError");
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(context) = 0;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Unable to retrieve anchor lookup table", (uint8_t *)&context, 2u);
      }
      goto LABEL_51;
    }
    CFRetain(*(CFTypeRef *)(v11 + 72));
    Count = CFDictionaryGetCount(v13);
    v15 = Count;
    if (Count - 8193 > 0xFFFFFFFFFFFFDFFFLL)
    {
      v30 = (const void **)malloc_type_calloc(Count, 8uLL, 0x80040B8603338uLL);
      if (v30)
      {
        v31 = v30;
        v47 = v13;
        CFDictionaryGetKeysAndValues(v13, 0, v30);
        v32 = 0;
        do
        {
          v33 = (const __CFArray *)v31[v32];
          if (v33)
          {
            v34 = CFGetTypeID(v31[v32]);
            if (v34 == CFArrayGetTypeID())
            {
              v35 = CFArrayGetCount(v33);
              if (v35 >= 1)
              {
                v36 = v35;
                for (i = 0; i != v36; ++i)
                {
                  ValueAtIndex = CFArrayGetValueAtIndex(v33, i);
                  if (ValueAtIndex)
                    CFArrayAppendValue(v10, ValueAtIndex);
                }
              }
            }
            else
            {
              v39 = sub_100011628("SecError");
              if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(context) = 0;
                _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "Failed to get CFArray type in values, skipping item", (uint8_t *)&context, 2u);
              }
            }
          }
          ++v32;
        }
        while (v32 != v15);
        free(v31);
        v13 = v47;
        goto LABEL_50;
      }
      v16 = sub_100011628("SecError");
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(context) = 134217984;
        *(_QWORD *)((char *)&context + 4) = v15;
        v17 = "Failed to allocate buffer for %lld values";
        goto LABEL_49;
      }
    }
    else
    {
      v16 = sub_100011628("SecError");
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(context) = 134217984;
        *(_QWORD *)((char *)&context + 4) = v15;
        v17 = "Unexpected system store count: %lld";
LABEL_49:
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v17, (uint8_t *)&context, 0xCu);
      }
    }
LABEL_50:
    CFRelease(v13);
LABEL_51:
    CFRelease(v12);
    goto LABEL_52;
  }
  if (!*(_QWORD *)(a1 + 8))
  {
    v45 = CFSTR("ts DB is NULL");
    goto LABEL_67;
  }
  if (!v50[3])
  {
    v45 = CFSTR("uuid is NULL");
    v46 = -26276;
    goto LABEL_69;
  }
  v18 = *(NSObject **)a1;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_1000573A0;
  block[3] = &unk_100079A78;
  block[4] = &v49;
  block[5] = &v57;
  block[7] = a1;
  block[8] = a3;
  block[6] = &v53;
  dispatch_sync(v18, block);
LABEL_15:
  v19 = v54;
  v20 = v54[3];
  if (!v20)
    goto LABEL_58;
  if (a1)
  {
    v21 = *(const __CFSet ***)(a1 + 40);
    if (v21)
    {
      v61 = 0;
      v62 = &v61;
      v63 = 0x2000000000;
      v64 = 0;
      v22 = *v21;
      *(_QWORD *)&context = _NSConcreteStackBlock;
      *((_QWORD *)&context + 1) = 0x40000000;
      v66 = sub_10005769C;
      v67 = &unk_100079BA8;
      v69 = v20;
      v70 = a1;
      v68 = &v61;
      CFSetApplyFunction(v22, (CFSetApplierFunction)sub_1000577E8, &context);
      v23 = *((unsigned __int8 *)v62 + 24);
      _Block_object_dispose(&v61, 8);
      if (v23)
      {
        if (a3)
        {
          v24 = *a3;
          if (*a3)
          {
            *a3 = 0;
            CFRelease(v24);
          }
        }
        *((_BYTE *)v58 + 24) = 1;
      }
    }
  }
LABEL_23:
  v25 = CFArrayGetCount((CFArrayRef)v54[3]);
  v19 = v54;
  if (v25 >= 1)
  {
    v26 = (__CFArray *)v54[3];
    if (v26)
    {
      CFRetain((CFTypeRef)v54[3]);
      v19 = v54;
    }
    *a2 = v26;
  }
LABEL_58:
  v41 = (const void *)v19[3];
  if (v41)
  {
    v19[3] = 0;
    CFRelease(v41);
  }
  v42 = (const void *)v50[3];
  if (v42)
  {
    v50[3] = 0;
    CFRelease(v42);
  }
  v43 = *((unsigned __int8 *)v58 + 24);
  _Block_object_dispose(&v49, 8);
  _Block_object_dispose(&v53, 8);
  _Block_object_dispose(&v57, 8);
  return v43;
}

sqlite3_stmt *sub_1000573A0(uint64_t a1)
{
  int v2;
  sqlite3_stmt *v3;
  const UInt8 *BytePtr;
  unint64_t Length;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  const UInt8 *v10;
  int v11;
  CFDataRef v12;
  const UInt8 *v13;
  int v14;
  CFDataRef v15;
  CFPropertyListRef v16;
  const void *v17;
  CFArrayRef v18;
  CFArrayRef v19;
  NSObject *v20;
  sqlite3_stmt *result;
  sqlite3_stmt *ppStmt;
  void *values[3];

  ppStmt = 0;
  v2 = sqlite3_prepare_v2(*(sqlite3 **)(*(_QWORD *)(a1 + 56) + 8), "SELECT data,tset FROM tsettings WHERE uuid=? ORDER BY sha256", 61, &ppStmt, 0);
  if (v2)
  {
    LODWORD(v6) = v2;
    v17 = 0;
    v15 = 0;
    v12 = 0;
LABEL_16:
    v20 = sub_100011628("SecError");
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(values[0]) = 67109120;
      HIDWORD(values[0]) = v6;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Failed to query for all certs in trust store: %d", (uint8_t *)values, 8u);
    }
    sub_1000521A8(4, 3, (int)v6);
    if (v12)
      CFRelease(v12);
    if (v15)
      CFRelease(v15);
    if (v17)
      CFRelease(v17);
    goto LABEL_24;
  }
  v3 = ppStmt;
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  Length = CFDataGetLength(*(CFDataRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  if (Length >> 31)
  {
    v6 = 18;
    goto LABEL_4;
  }
  v8 = sqlite3_bind_blob(v3, 1, BytePtr, Length, 0);
  if ((_DWORD)v8)
  {
    v6 = v8;
LABEL_4:
    v7 = sub_10001A970(v6, ppStmt, *(CFTypeRef **)(a1 + 64), CFSTR("sqlite3_bind_blob failed"));
LABEL_15:
    v17 = 0;
    v15 = 0;
    v12 = 0;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v7;
    goto LABEL_16;
  }
  while (1)
  {
    v9 = sqlite3_step(ppStmt);
    if ((_DWORD)v9 != 100)
      break;
    v10 = (const UInt8 *)sqlite3_column_blob(ppStmt, 0);
    v11 = sqlite3_column_bytes(ppStmt, 0);
    v12 = CFDataCreate(kCFAllocatorDefault, v10, v11);
    if (!v12)
    {
      v17 = 0;
      v15 = 0;
LABEL_29:
      LODWORD(v6) = 100;
      goto LABEL_16;
    }
    v13 = (const UInt8 *)sqlite3_column_blob(ppStmt, 1);
    v14 = sqlite3_column_bytes(ppStmt, 1);
    v15 = CFDataCreate(0, v13, v14);
    if (!v15)
    {
      v17 = 0;
      goto LABEL_29;
    }
    v16 = CFPropertyListCreateWithData(0, v15, 0, 0, *(CFErrorRef **)(a1 + 64));
    v17 = v16;
    if (!v16)
      goto LABEL_29;
    values[0] = v12;
    values[1] = (void *)v16;
    v18 = CFArrayCreate(0, (const void **)values, 2, &kCFTypeArrayCallBacks);
    if (!v18)
      goto LABEL_29;
    v19 = v18;
    CFArrayAppendValue(*(CFMutableArrayRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24), v18);
    CFRelease(v12);
    CFRelease(v15);
    CFRelease(v17);
    CFRelease(v19);
  }
  LODWORD(v6) = v9;
  if ((_DWORD)v9 && (_DWORD)v9 != 101)
  {
    v7 = sub_10001A970(v9, ppStmt, *(CFTypeRef **)(a1 + 64), CFSTR("sqlite3_step failed"));
    goto LABEL_15;
  }
LABEL_24:
  result = ppStmt;
  if (ppStmt)
    return (sqlite3_stmt *)sqlite3_finalize(ppStmt);
  return result;
}

void sub_10005769C(uint64_t a1, SecCertificateRef certificate)
{
  CFDataRef v3;
  const __CFArray *v4;
  void *v5;
  CFArrayRef v6;
  _QWORD context[6];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  char v11;
  void *values[2];
  CFRange v13;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 0;
  v3 = SecCertificateCopyData(certificate);
  v4 = *(const __CFArray **)(a1 + 40);
  context[0] = _NSConcreteStackBlock;
  context[1] = 0x40000000;
  context[2] = sub_1000577FC;
  context[3] = &unk_100079B80;
  context[4] = &v8;
  context[5] = v3;
  v13.length = CFArrayGetCount(v4);
  v13.location = 0;
  CFArrayApplyFunction(v4, v13, (CFArrayApplierFunction)sub_1000577E8, context);
  if (!*((_BYTE *)v9 + 24))
  {
    v5 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 40) + 24);
    values[0] = v3;
    values[1] = v5;
    v6 = CFArrayCreate(0, (const void **)values, 2, &kCFTypeArrayCallBacks);
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 40), v6);
    if (v6)
      CFRelease(v6);
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  }
  if (v3)
    CFRelease(v3);
  _Block_object_dispose(&v8, 8);
}

uint64_t sub_1000577E8(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_1000577FC(uint64_t a1, CFArrayRef theArray)
{
  const void *v3;
  uint64_t result;
  CFRange v6;

  v3 = *(const void **)(a1 + 40);
  v6.location = 0;
  v6.length = 1;
  result = CFArrayContainsValue(theArray, v6, v3);
  if ((_DWORD)result)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  return result;
}

void sub_100057840(id a1, const char *a2)
{
  remove((const std::__fs::filesystem::path *)a2, (std::error_code *)a2);
}

void sub_10005836C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1000584BC(id a1, MAAutoAssetSelector *a2, NSError *a3)
{
  NSError *v3;
  const void *v4;
  NSObject *v5;
  const char *v6;
  NSObject *v7;
  uint32_t v8;
  const void *v9;
  int v10;
  const __CFString *v11;
  __int16 v12;
  NSError *v13;

  v3 = a3;
  if (v3)
  {
    v4 = sub_100011628("SecError");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v10 = 138412546;
      v11 = CFSTR("trustd");
      v12 = 2112;
      v13 = v3;
      v6 = "Failed to end asset locks for %@: %@";
      v7 = v5;
      v8 = 22;
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v10, v8);
    }
  }
  else
  {
    v9 = sub_100011628("OTATrust");
    v5 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v10 = 138412290;
      v11 = CFSTR("trustd");
      v6 = "Ended local asset locks for %@";
      v7 = v5;
      v8 = 12;
      goto LABEL_6;
    }
  }

}

uint64_t sub_1000585E0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_1000585F0(uint64_t a1)
{

}

void sub_1000585F8(uint64_t a1, uint64_t a2, int a3, void *a4, uint64_t a5, void *a6)
{
  id v9;
  id v10;
  const void *v11;
  NSObject *v12;
  __CFString *v13;
  CFIndex Code;
  void *v15;
  const void *v16;
  NSObject *v17;
  void *v18;
  const void *v19;
  NSObject *v20;
  void *v21;
  void *v22;
  void *v23;
  unsigned __int8 v24;
  void *v25;
  unint64_t v26;
  const void *v27;
  NSObject *v28;
  void *v29;
  const char *v30;
  void *v31;
  unint64_t v32;
  const void *v33;
  NSObject *v34;
  void *v35;
  void *v36;
  unsigned int v37;
  const void *v38;
  NSObject *v39;
  const void *v40;
  NSObject *v41;
  const void *v42;
  NSObject *v43;
  int v44;
  const __CFString *v45;
  __int16 v46;
  void *v47;
  __int16 v48;
  const char *v49;

  v9 = a4;
  v10 = a6;
  if (v10)
  {
    v11 = sub_100011628("SecError");
    v12 = objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      v13 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "description"));
      v44 = 138412290;
      v45 = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Unable to lock any version of auto-asset content: %@", (uint8_t *)&v44, 0xCu);

    }
    Code = CFErrorGetCode((CFErrorRef)v10);
    sub_100052038((uint64_t)CFSTR("AssetBuiltInEvent"), 0, Code);
    goto LABEL_5;
  }
  v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "path"));

  if (!v15)
    goto LABEL_5;
  v16 = sub_100011628("OTATrust");
  v17 = objc_claimAutoreleasedReturnValue(v16);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "path"));
    v44 = 138412546;
    v45 = CFSTR("PKITrustStore");
    v46 = 2112;
    v47 = v18;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Locked %@ asset at path: %@", (uint8_t *)&v44, 0x16u);

  }
  v19 = sub_100011628("OTATrust");
  v20 = objc_claimAutoreleasedReturnValue(v19);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    v21 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
    v44 = 138412546;
    v45 = CFSTR("PKITrustStore");
    v46 = 2112;
    v47 = v21;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Previous %@ asset path: %@", (uint8_t *)&v44, 0x16u);
  }

  v22 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
  if (!v22
    || (v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "path")),
        v24 = objc_msgSend(v22, "isEqualToString:", v23),
        v23,
        (v24 & 1) == 0))
  {
    v33 = sub_100011628("OTATrust");
    v34 = objc_claimAutoreleasedReturnValue(v33);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "path"));
      v44 = 138412546;
      v45 = CFSTR("PKITrustStore");
      v46 = 2112;
      v47 = v35;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "New %@ asset path: %@", (uint8_t *)&v44, 0x16u);

    }
LABEL_24:
    v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "path"));
    v37 = +[OTAAutoAssetClient saveTrustStoreAssetPath:](OTAAutoAssetClient, "saveTrustStoreAssetPath:", v36);

    if (v37)
    {
      v38 = sub_100011628("OTATrust");
      v39 = objc_claimAutoreleasedReturnValue(v38);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v44) = 0;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "--- New asset path obtained from MobileAsset ---", (uint8_t *)&v44, 2u);
      }

      v40 = sub_100011628("OTATrust");
      v41 = objc_claimAutoreleasedReturnValue(v40);
      if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v44) = 0;
        _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "Will exit when clean to use updated asset", (uint8_t *)&v44, 2u);
      }

      sub_100051F80((uint64_t)CFSTR("AssetUpdateEvent"));
      xpc_transaction_exit_clean();
    }
    goto LABEL_5;
  }
  v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "path"));
  v26 = sub_10003479C((uint64_t)v25, 0);

  v27 = sub_100011628("OTATrust");
  v28 = objc_claimAutoreleasedReturnValue(v27);
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    v29 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
    v30 = "false";
    if (a3)
      v30 = "true";
    v44 = 134218498;
    v45 = (const __CFString *)v26;
    v46 = 2048;
    v47 = v29;
    v48 = 2080;
    v49 = v30;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Available version: %llu, our current version: %llu, content locked: %s", (uint8_t *)&v44, 0x20u);
  }

  objc_msgSend(*(id *)(a1 + 32), "setLastAvailableVersion:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "path"));
  objc_msgSend(*(id *)(a1 + 32), "setLastAssetPath:", v31);

  if (v26)
  {
    v32 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
    if (v26 <= v32 || !v32)
      goto LABEL_5;
    goto LABEL_24;
  }
  objc_msgSend(*(id *)(a1 + 32), "setRecheckAssetVersion:", 1);
  v42 = sub_100011628("SecError");
  v43 = objc_claimAutoreleasedReturnValue(v42);
  if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v44) = 0;
    _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "Unable to read trust store version from locked asset path, will retry later", (uint8_t *)&v44, 2u);
  }

LABEL_5:
}

void sub_100058B04(id a1, MAAutoAssetStatus *a2, NSError *a3)
{
  MAAutoAssetStatus *v4;
  NSError *v5;
  const void *v6;
  NSObject *v7;
  __CFString *v8;
  __CFString *v9;
  const void *v10;
  NSObject *v11;
  void *v12;
  const void *v13;
  NSObject *v14;
  const __CFString *v15;
  int v16;
  const __CFString *v17;
  __int16 v18;
  const __CFString *v19;

  v4 = a2;
  v5 = a3;
  if (v5)
  {
    v6 = sub_100011628("SecError");
    v7 = objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = (__CFString *)objc_claimAutoreleasedReturnValue(-[NSError description](v5, "description"));
      v16 = 138412290;
      v17 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Unable to get asset status: %@", (uint8_t *)&v16, 0xCu);

    }
  }
  v9 = (__CFString *)objc_claimAutoreleasedReturnValue(-[MAAutoAssetStatus currentLockUsage](v4, "currentLockUsage"));
  v10 = sub_100011628("OTATrust");
  v11 = objc_claimAutoreleasedReturnValue(v10);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v16 = 138412546;
    v17 = CFSTR("PKITrustStore");
    v18 = 2112;
    v19 = v9;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Current %@ asset usage: %@", (uint8_t *)&v16, 0x16u);
  }

  v12 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKey:](v9, "objectForKey:", CFSTR("system trusted certificates")));
  v13 = sub_100011628("OTATrust");
  v14 = objc_claimAutoreleasedReturnValue(v13);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    v15 = CFSTR("locked");
    if (!v12)
      v15 = CFSTR("unlocked");
    v16 = 138412546;
    v17 = CFSTR("PKITrustStore");
    v18 = 2112;
    v19 = v15;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Current %@ status: %@", (uint8_t *)&v16, 0x16u);
  }

}

void sub_100058D08(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  const void *v5;
  NSObject *v6;
  const char *v7;
  const void *v8;
  void *v9;
  int v10;
  id v11;

  v4 = a3;
  if (v4)
  {
    v5 = sub_100011628("SecError");
    v6 = objc_claimAutoreleasedReturnValue(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v10 = 138412290;
      v11 = v4;
      v7 = "Failed to eliminate asset: %@";
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v10, 0xCu);
    }
  }
  else
  {
    v8 = sub_100011628("OTATrust");
    v6 = objc_claimAutoreleasedReturnValue(v8);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v9 = *(void **)(a1 + 32);
      v10 = 138412290;
      v11 = v9;
      v7 = "Successfully removed interest for %@";
      goto LABEL_6;
    }
  }

}

void sub_100058E10(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  const void *v5;
  NSObject *v6;
  uint64_t v7;
  const void *v8;
  NSObject *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  __int16 v13;
  id v14;

  v4 = a3;
  if (v4)
  {
    v5 = sub_100011628("SecError");
    v6 = objc_claimAutoreleasedReturnValue(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v7 = *(_QWORD *)(a1 + 32);
      v11 = 138412546;
      v12 = v7;
      v13 = 2112;
      v14 = v4;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Interest registration failed for %@ with error: %@", (uint8_t *)&v11, 0x16u);
    }

  }
  else
  {
    v8 = sub_100011628("OTATrust");
    v9 = objc_claimAutoreleasedReturnValue(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      v10 = *(_QWORD *)(a1 + 32);
      v11 = 138412290;
      v12 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Successfully registered interest for %@", (uint8_t *)&v11, 0xCu);
    }

    objc_msgSend(*(id *)(a1 + 40), "_recheckAssetVersion");
  }

}

id sub_100058F48(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "_handleAssetChangedNotification");
}

void sub_1000591B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 112), 8);
  _Unwind_Resume(a1);
}

void sub_1000593C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10005965C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100059684(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  void *v5;

  v3 = objc_claimAutoreleasedReturnValue(+[NSString stringWithCString:encoding:](NSString, "stringWithCString:encoding:", a2, 4));
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v5 = *(void **)(v4 + 40);
  *(_QWORD *)(v4 + 40) = v3;

}

void sub_1000596C8(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  void *v5;

  v3 = objc_claimAutoreleasedReturnValue(+[NSString stringWithCString:encoding:](NSString, "stringWithCString:encoding:", a2, 4));
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v5 = *(void **)(v4 + 40);
  *(_QWORD *)(v4 + 40) = v3;

}

void sub_10005970C(uint64_t a1, const char *a2)
{
  uint64_t v4;
  uint64_t v5;
  void *v6;
  id v7;
  id v8;
  __int128 v9;
  id v10;
  uint64_t v11;
  uint64_t v12;
  void *i;
  timespec v14;
  const void *v15;
  NSObject *v16;
  char *v17;
  const void *v18;
  NSObject *v19;
  NSObject *v20;
  const char *v21;
  const void *v22;
  const void *v23;
  NSObject *v24;
  const void *v25;
  NSObject *v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  uint8_t buf[4];
  char *v34;
  __int16 v35;
  char *v36;
  stat v37;
  _BYTE v38[128];
  _QWORD v39[3];
  char v40[1024];

  memset(&v40[1], 170, 0x3FFuLL);
  v40[0] = 0;
  if (realpath_DARWIN_EXTSN(a2, v40))
  {
    v4 = objc_claimAutoreleasedReturnValue(+[NSString stringWithCString:encoding:](NSString, "stringWithCString:encoding:", v40, 4));
    v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v6 = *(void **)(v5 + 40);
    *(_QWORD *)(v5 + 40) = v4;

    v39[0] = CFSTR("/private/var/MobileAsset/AssetsV2/");
    v39[1] = CFSTR("/System/Library/AssetsV2/");
    v39[2] = CFSTR("/System/Cryptexes/OS/");
    v29 = 0u;
    v30 = 0u;
    v31 = 0u;
    v32 = 0u;
    v7 = (id)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v39, 3));
    v8 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v29, v38, 16);
    if (!v8)
    {
      v12 = 2;
      goto LABEL_26;
    }
    v10 = v8;
    v11 = *(_QWORD *)v30;
    v12 = 2;
    *(_QWORD *)&v9 = 136446466;
    v28 = v9;
    while (1)
    {
      for (i = 0; i != v10; i = (char *)i + 1)
      {
        if (*(_QWORD *)v30 != v11)
          objc_enumerationMutation(v7);
        if (objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), "hasPrefix:", *(_QWORD *)(*((_QWORD *)&v29 + 1) + 8 * (_QWORD)i), v28))
        {
          v14.tv_sec = 0xAAAAAAAAAAAAAAAALL;
          v14.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
          *(timespec *)&v37.st_blksize = v14;
          *(timespec *)v37.st_qspare = v14;
          v37.st_birthtimespec = v14;
          *(timespec *)&v37.st_size = v14;
          v37.st_mtimespec = v14;
          v37.st_ctimespec = v14;
          *(timespec *)&v37.st_uid = v14;
          v37.st_atimespec = v14;
          *(timespec *)&v37.st_dev = v14;
          if (!stat(v40, &v37))
          {
            v18 = sub_100011628("OTATrust");
            v19 = objc_claimAutoreleasedReturnValue(v18);
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136446210;
              v34 = v40;
              v20 = v19;
              v21 = "found valid asset path: %{public}s";
              goto LABEL_17;
            }
LABEL_18:

            v12 = 0;
            *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
            continue;
          }
          if (!*(_BYTE *)(a1 + 48))
          {
            v22 = sub_100011628("OTATrust");
            v19 = objc_claimAutoreleasedReturnValue(v22);
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136446210;
              v34 = v40;
              v20 = v19;
              v21 = "skipping existence check for %{public}s";
LABEL_17:
              _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v21, buf, 0xCu);
            }
            goto LABEL_18;
          }
          v12 = *__error();
          v15 = sub_100011628("OTATrust");
          v16 = objc_claimAutoreleasedReturnValue(v15);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            v17 = strerror(v12);
            *(_DWORD *)buf = v28;
            v34 = v40;
            v35 = 2080;
            v36 = v17;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "failed to stat %{public}s: %s", buf, 0x16u);
          }

        }
      }
      v10 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v29, v38, 16);
      if (!v10)
      {
LABEL_26:

        if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24))
        {
          v25 = sub_100011628("OTATrust");
          v26 = objc_claimAutoreleasedReturnValue(v25);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            v27 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
            v37.st_dev = 138543362;
            *(_QWORD *)&v37.st_mode = v27;
            _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "invalid asset path: %{public}@", (uint8_t *)&v37, 0xCu);
          }

          sub_100052038((uint64_t)CFSTR("AssetBuiltInEvent"), 0, v12);
        }

        return;
      }
    }
  }
  v23 = sub_100011628("OTATrust");
  v24 = objc_claimAutoreleasedReturnValue(v23);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    v37.st_dev = 136446210;
    *(_QWORD *)&v37.st_mode = a2;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "unable to resolve asset path: %{public}s", (uint8_t *)&v37, 0xCu);
  }

  sub_100052038((uint64_t)CFSTR("AssetBuiltInEvent"), 0, 2);
}

CFTypeRef sub_100059B20(void *a1, const char *a2, __CFString **a3)
{
  const UInt8 *data;
  const UInt8 *v6;
  UInt8 *v7;
  const __CFAllocator *v8;
  __CFString *v9;
  NSObject *v10;
  __CFString *v11;
  CFTypeRef v12;
  size_t length;
  CFTypeRef cf;
  uint8_t buf[4];
  __CFString *v17;

  length = 0;
  cf = 0;
  data = (const UInt8 *)xpc_dictionary_get_data(a1, a2, &length);
  if (data)
  {
    v6 = data;
    v7 = (UInt8 *)&data[length];
    v8 = (const __CFAllocator *)SecCFAllocatorZeroize();
    if (sub_10002A618(v8, &cf, (CFTypeRef *)a3, v6, v7) == v7)
    {
      v12 = cf;
    }
    else
    {
      v9 = (__CFString *)CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("trailing garbage after der decoded object for key %s"), a2);
      sub_100012C88(-50, a3, CFSTR("%@"), v9);
      if (a3)
      {
        v10 = sub_100011628("SecError");
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          v11 = *a3;
          *(_DWORD *)buf = 138412290;
          v17 = v11;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "xpc: %@", buf, 0xCu);
        }
      }
      sub_10002B644(v9, 1405091842);
      if (v9)
        CFRelease(v9);
      if (cf)
        CFRelease(cf);
      v12 = 0;
    }
    cc_clear(length, v6);
  }
  else
  {
    sub_100012C88(-50, a3, CFSTR("no object for key %s"), a2);
    return 0;
  }
  return v12;
}

BOOL sub_100059CB0(void *a1, const char *a2, _QWORD *a3, __CFString **a4)
{
  CFTypeRef v8;
  const void *v9;
  CFTypeID v10;
  CFStringRef v11;
  _BOOL8 result;

  if (xpc_dictionary_get_value(a1, a2))
  {
    v8 = sub_100059B20(a1, a2, a4);
    v9 = v8;
    if (v8)
    {
      v10 = CFGetTypeID(v8);
      if (v10 != CFDictionaryGetTypeID())
      {
        v11 = CFCopyTypeIDDescription(v10);
        sub_100012C88(-50, a4, CFSTR("object for key %s not dictionary but %@"), a2, v11);
        if (v11)
          CFRelease(v11);
        CFRelease(v9);
        v9 = 0;
      }
    }
    result = v9 != 0;
  }
  else
  {
    v9 = 0;
    result = 1;
  }
  *a3 = v9;
  return result;
}

BOOL sub_100059D7C(void *a1, _QWORD *a2, __CFString **a3)
{
  const void *data;
  _BOOL8 v7;
  size_t length;

  length = 0;
  data = xpc_dictionary_get_data(a1, "settings", &length);
  if (data)
  {
    data = sub_100059B20(a1, "settings", a3);
    v7 = data != 0;
  }
  else
  {
    v7 = 1;
  }
  *a2 = data;
  return v7;
}

BOOL sub_100059DF4(void *a1, const char *a2, _QWORD *a3, __CFString **a4)
{
  void *value;
  _BOOL8 v9;

  value = xpc_dictionary_get_value(a1, a2);
  if (value)
  {
    value = (void *)sub_100012BFC(a1, a2, a4);
    v9 = value != 0;
  }
  else
  {
    v9 = 1;
  }
  *a3 = value;
  return v9;
}

id objc_msgSend_AddMultiSamplerForName_withTimeInterval_block_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "AddMultiSamplerForName:withTimeInterval:block:");
}

id objc_msgSend_MIMEType(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "MIMEType");
}

id objc_msgSend_URIix(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "URIix");
}

id objc_msgSend_URIs(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "URIs");
}

id objc_msgSend_URL(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "URL");
}

id objc_msgSend_URLByAppendingPathComponent_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "URLByAppendingPathComponent:");
}

id objc_msgSend_URLPathAllowedCharacterSet(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "URLPathAllowedCharacterSet");
}

id objc_msgSend_URLSession_task_didCompleteWithError_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "URLSession:task:didCompleteWithError:");
}

id objc_msgSend_URLWithString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "URLWithString:");
}

id objc_msgSend_URLWithString_relativeToURL_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "URLWithString:relativeToURL:");
}

id objc_msgSend_UTF8String(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "UTF8String");
}

id objc_msgSend_UUID(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "UUID");
}

id objc_msgSend_UUIDString(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "UUIDString");
}

id objc_msgSend__clientLRUList(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_clientLRUList");
}

id objc_msgSend__clientSessionMap(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_clientSessionMap");
}

id objc_msgSend__createAutoAssetWithType_specifier_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_createAutoAssetWithType:specifier:error:");
}

id objc_msgSend__createInterestInAssetType_withAssetSpecifier_withError_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_createInterestInAssetType:withAssetSpecifier:withError:");
}

id objc_msgSend__lockLocalAsset_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_lockLocalAsset:");
}

id objc_msgSend__obliterateAllBackgroundSessionsWithCompletionHandler_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_obliterateAllBackgroundSessionsWithCompletionHandler:");
}

id objc_msgSend__recheckAssetVersion(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_recheckAssetVersion");
}

id objc_msgSend__serverMap(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_serverMap");
}

id objc_msgSend__setFileNameLocalizationEnabled_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_setFileNameLocalizationEnabled:");
}

id objc_msgSend__sharedHSTSCache(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_sharedHSTSCache");
}

id objc_msgSend__taskContextMap(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_taskContextMap");
}

id objc_msgSend__timerMap(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_timerMap");
}

id objc_msgSend_absoluteString(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "absoluteString");
}

id objc_msgSend_addObject_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "addObject:");
}

id objc_msgSend_addObjectsFromArray_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "addObjectsFromArray:");
}

id objc_msgSend_addServer_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "addServer:");
}

id objc_msgSend_addSuffixToCache_entry_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "addSuffixToCache:entry:");
}

id objc_msgSend_addTask_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "addTask:");
}

id objc_msgSend_addValue_forHTTPHeaderField_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "addValue:forHTTPHeaderField:");
}

id objc_msgSend_allHTTPHeaderFields(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "allHTTPHeaderFields");
}

id objc_msgSend_allHeaderFields(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "allHeaderFields");
}

id objc_msgSend_appendData_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "appendData:");
}

id objc_msgSend_appendString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "appendString:");
}

id objc_msgSend_array(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "array");
}

id objc_msgSend_arrayWithCapacity_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "arrayWithCapacity:");
}

id objc_msgSend_arrayWithContentsOfURL_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "arrayWithContentsOfURL:");
}

id objc_msgSend_arrayWithContentsOfURL_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "arrayWithContentsOfURL:error:");
}

id objc_msgSend_arrayWithObjects_count_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "arrayWithObjects:count:");
}

id objc_msgSend_assetDidChangeHandler(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "assetDidChangeHandler");
}

id objc_msgSend_assetProperty_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "assetProperty:");
}

id objc_msgSend_attributes(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "attributes");
}

id objc_msgSend_attribution(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "attribution");
}

id objc_msgSend_authenticationMethod(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "authenticationMethod");
}

id objc_msgSend_backgroundSession(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "backgroundSession");
}

id objc_msgSend_backgroundSessionConfigurationWithIdentifier_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "backgroundSessionConfigurationWithIdentifier:");
}

id objc_msgSend_base64EncodedStringWithOptions_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "base64EncodedStringWithOptions:");
}

id objc_msgSend_BOOLForKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "BOOLForKey:");
}

id objc_msgSend_BOOLValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "BOOLValue");
}

id objc_msgSend_bytes(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "bytes");
}

id objc_msgSend_cStringUsingEncoding_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "cStringUsingEncoding:");
}

id objc_msgSend_calendarWithIdentifier_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "calendarWithIdentifier:");
}

id objc_msgSend_callback(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "callback");
}

id objc_msgSend_cancel(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "cancel");
}

id objc_msgSend_cancelTimer_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "cancelTimer:");
}

id objc_msgSend_clearCache(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "clearCache");
}

id objc_msgSend_closeFile(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "closeFile");
}

id objc_msgSend_code(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "code");
}

id objc_msgSend_compare_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "compare:");
}

id objc_msgSend_components_fromDate_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "components:fromDate:");
}

id objc_msgSend_componentsWithURL_resolvingAgainstBaseURL_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "componentsWithURL:resolvingAgainstBaseURL:");
}

id objc_msgSend_containsObject_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "containsObject:");
}

id objc_msgSend_containsString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "containsString:");
}

id objc_msgSend_context(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "context");
}

id objc_msgSend_contextForTask_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "contextForTask:");
}

id objc_msgSend_copy(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "copy");
}

id objc_msgSend_copySystemPinningList(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "copySystemPinningList");
}

id objc_msgSend_count(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "count");
}

id objc_msgSend_countByEnumeratingWithState_objects_count_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "countByEnumeratingWithState:objects:count:");
}

id objc_msgSend_createAtPath(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "createAtPath");
}

id objc_msgSend_createNextRequest_context_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "createNextRequest:context:");
}

id objc_msgSend_createOrAlterAdminTable_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "createOrAlterAdminTable:error:");
}

id objc_msgSend_createOrAlterRulesTable_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "createOrAlterRulesTable:error:");
}

id objc_msgSend_createSession_queue_forServer_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "createSession:queue:forServer:");
}

id objc_msgSend_createSessionForAuditToken_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "createSessionForAuditToken:");
}

id objc_msgSend_createSessions_forServer_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "createSessions:forServer:");
}

id objc_msgSend_createTimerForTask_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "createTimerForTask:");
}

id objc_msgSend_currentAssetSelector(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "currentAssetSelector");
}

id objc_msgSend_currentHandler(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "currentHandler");
}

id objc_msgSend_currentLockUsage(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "currentLockUsage");
}

id objc_msgSend_currentStatus_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "currentStatus:");
}

id objc_msgSend_data(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "data");
}

id objc_msgSend_dataTaskWithRequest_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dataTaskWithRequest:");
}

id objc_msgSend_dataTaskWithURL_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dataTaskWithURL:");
}

id objc_msgSend_dataWithBytes_length_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dataWithBytes:length:");
}

id objc_msgSend_dataWithContentsOfURL_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dataWithContentsOfURL:");
}

id objc_msgSend_dataWithPropertyList_format_options_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dataWithPropertyList:format:options:error:");
}

id objc_msgSend_date(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "date");
}

id objc_msgSend_dateFromComponents_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dateFromComponents:");
}

id objc_msgSend_dateWithTimeIntervalSince1970_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dateWithTimeIntervalSince1970:");
}

id objc_msgSend_dateWithTimeIntervalSinceReferenceDate_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dateWithTimeIntervalSinceReferenceDate:");
}

id objc_msgSend_db(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "db");
}

id objc_msgSend_delegate(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "delegate");
}

id objc_msgSend_description(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "description");
}

id objc_msgSend_dictionary(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dictionary");
}

id objc_msgSend_dictionaryWithCapacity_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dictionaryWithCapacity:");
}

id objc_msgSend_dictionaryWithContentsOfFile_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dictionaryWithContentsOfFile:");
}

id objc_msgSend_dictionaryWithContentsOfURL_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dictionaryWithContentsOfURL:");
}

id objc_msgSend_dictionaryWithContentsOfURL_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dictionaryWithContentsOfURL:error:");
}

id objc_msgSend_dictionaryWithDictionary_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dictionaryWithDictionary:");
}

id objc_msgSend_dictionaryWithObjects_forKeys_count_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dictionaryWithObjects:forKeys:count:");
}

id objc_msgSend_domain(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "domain");
}

id objc_msgSend_doubleValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "doubleValue");
}

id objc_msgSend_duration(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "duration");
}

id objc_msgSend_eliminateAllForSelector_completion_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "eliminateAllForSelector:completion:");
}

id objc_msgSend_enableInMemoryCache(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "enableInMemoryCache");
}

id objc_msgSend_endAllPreviousLocksOfSelector_completion_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "endAllPreviousLocksOfSelector:completion:");
}

id objc_msgSend_enumerateKeysAndObjectsUsingBlock_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "enumerateKeysAndObjectsUsingBlock:");
}

id objc_msgSend_enumerateObjectsUsingBlock_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "enumerateObjectsUsingBlock:");
}

id objc_msgSend_ephemeralSession(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "ephemeralSession");
}

id objc_msgSend_ephemeralSessionConfiguration(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "ephemeralSessionConfiguration");
}

id objc_msgSend_errorWithDomain_code_userInfo_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "errorWithDomain:code:userInfo:");
}

id objc_msgSend_exceptionWithName_reason_userInfo_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "exceptionWithName:reason:userInfo:");
}

id objc_msgSend_expectedContentLength(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "expectedContentLength");
}

id objc_msgSend_fetchNext_context_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "fetchNext:context:");
}

id objc_msgSend_fileHandleForWritingToURL_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "fileHandleForWritingToURL:error:");
}

id objc_msgSend_fileSystemRepresentation(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "fileSystemRepresentation");
}

id objc_msgSend_fileURLWithPath_isDirectory_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "fileURLWithPath:isDirectory:");
}

id objc_msgSend_finishTasksAndInvalidate(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "finishTasksAndInvalidate");
}

id objc_msgSend_fixFiles_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "fixFiles:");
}

id objc_msgSend_floatValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "floatValue");
}

id objc_msgSend_getBytes_range_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "getBytes:range:");
}

id objc_msgSend_getContentVersion_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "getContentVersion:error:");
}

id objc_msgSend_getLocalFileUrl(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "getLocalFileUrl");
}

id objc_msgSend_getSchemaVersion_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "getSchemaVersion:error:");
}

id objc_msgSend_handleFailureInFunction_file_lineNumber_description_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "handleFailureInFunction:file:lineNumber:description:");
}

id objc_msgSend_hasPrefix_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "hasPrefix:");
}

id objc_msgSend_hasSuffix_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "hasSuffix:");
}

id objc_msgSend_host(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "host");
}

id objc_msgSend_incrementCountForServer_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "incrementCountForServer:");
}

id objc_msgSend_indexOfObject_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "indexOfObject:");
}

id objc_msgSend_init(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "init");
}

id objc_msgSend_initForAssetType_withAssetSpecifier_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initForAssetType:withAssetSpecifier:");
}

id objc_msgSend_initForClientName_selectingAsset_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initForClientName:selectingAsset:error:");
}

id objc_msgSend_initInMemoryStore(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initInMemoryStore");
}

id objc_msgSend_initWithBytes_length_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithBytes:length:");
}

id objc_msgSend_initWithBytes_length_encoding_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithBytes:length:encoding:");
}

id objc_msgSend_initWithContext_uris_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithContext:uris:");
}

id objc_msgSend_initWithDelegate_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithDelegate:");
}

id objc_msgSend_initWithError_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithError:");
}

id objc_msgSend_initWithFormat_arguments_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithFormat:arguments:");
}

id objc_msgSend_initWithMachServiceName_options_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithMachServiceName:options:");
}

id objc_msgSend_initWithSuiteName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithSuiteName:");
}

id objc_msgSend_initWithType_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithType:");
}

id objc_msgSend_initWithUUIDBytes_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithUUIDBytes:");
}

id objc_msgSend_initWithUUIDString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithUUIDString:");
}

id objc_msgSend_initializedDb(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initializedDb");
}

id objc_msgSend_insertObject_atIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "insertObject:atIndex:");
}

id objc_msgSend_insertRuleWithName_domainSuffix_labelRegex_policies_transparentConnection_dbConnection_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "insertRuleWithName:domainSuffix:labelRegex:policies:transparentConnection:dbConnection:error:");
}

id objc_msgSend_installDbFromURL_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "installDbFromURL:error:");
}

id objc_msgSend_intValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "intValue");
}

id objc_msgSend_interestInContent_completion_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "interestInContent:completion:");
}

id objc_msgSend_interfaceWithProtocol_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "interfaceWithProtocol:");
}

id objc_msgSend_invalidate(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "invalidate");
}

id objc_msgSend_isEqualToNumber_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "isEqualToNumber:");
}

id objc_msgSend_isEqualToString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "isEqualToString:");
}

id objc_msgSend_isPinningDisabled_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "isPinningDisabled:");
}

id objc_msgSend_lastAssetPath(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "lastAssetPath");
}

id objc_msgSend_lastAttemptDate(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "lastAttemptDate");
}

id objc_msgSend_lastAvailableVersion(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "lastAvailableVersion");
}

id objc_msgSend_lastCurrentVersion(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "lastCurrentVersion");
}

id objc_msgSend_lastObject(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "lastObject");
}

id objc_msgSend_length(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "length");
}

id objc_msgSend_localizedStringWithFormat_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "localizedStringWithFormat:");
}

id objc_msgSend_lockContent_withUsagePolicy_withTimeout_reportingProgress_completion_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "lockContent:withUsagePolicy:withTimeout:reportingProgress:completion:");
}

id objc_msgSend_logHardError_withEventName_withAttributes_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "logHardError:withEventName:withAttributes:");
}

id objc_msgSend_logHardFailureForEventNamed_withAttributes_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "logHardFailureForEventNamed:withAttributes:");
}

id objc_msgSend_logResultForEvent_hardFailure_result_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "logResultForEvent:hardFailure:result:");
}

id objc_msgSend_logResultForEvent_hardFailure_result_withAttributes_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "logResultForEvent:hardFailure:result:withAttributes:");
}

id objc_msgSend_logSoftFailureForEventNamed_withAttributes_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "logSoftFailureForEventNamed:withAttributes:");
}

id objc_msgSend_logSuccessForEventNamed_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "logSuccessForEventNamed:");
}

id objc_msgSend_logger(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "logger");
}

id objc_msgSend_longLongValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "longLongValue");
}

id objc_msgSend_lowercaseString(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "lowercaseString");
}

id objc_msgSend_maxAge(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "maxAge");
}

id objc_msgSend_mutableCopy(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "mutableCopy");
}

id objc_msgSend_notifyQueue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "notifyQueue");
}

id objc_msgSend_notifyRegistrationName_forAssetType_forAssetSpecifier_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "notifyRegistrationName:forAssetType:forAssetSpecifier:");
}

id objc_msgSend_numTasks(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numTasks");
}

id objc_msgSend_numberOfMatchesInString_options_range_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberOfMatchesInString:options:range:");
}

id objc_msgSend_numberWithBool_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberWithBool:");
}

id objc_msgSend_numberWithDouble_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberWithDouble:");
}

id objc_msgSend_numberWithFloat_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberWithFloat:");
}

id objc_msgSend_numberWithInt_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberWithInt:");
}

id objc_msgSend_numberWithInteger_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberWithInteger:");
}

id objc_msgSend_numberWithLong_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberWithLong:");
}

id objc_msgSend_numberWithLongLong_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberWithLongLong:");
}

id objc_msgSend_numberWithUnsignedChar_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberWithUnsignedChar:");
}

id objc_msgSend_numberWithUnsignedInt_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberWithUnsignedInt:");
}

id objc_msgSend_numberWithUnsignedInteger_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberWithUnsignedInteger:");
}

id objc_msgSend_numberWithUnsignedLong_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberWithUnsignedLong:");
}

id objc_msgSend_numberWithUnsignedLongLong_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberWithUnsignedLongLong:");
}

id objc_msgSend_objectAtIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "objectAtIndex:");
}

id objc_msgSend_objectAtIndexedSubscript_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "objectAtIndexedSubscript:");
}

id objc_msgSend_objectForKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "objectForKey:");
}

id objc_msgSend_objectForKeyedSubscript_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "objectForKeyedSubscript:");
}

id objc_msgSend_originalRequest(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "originalRequest");
}

id objc_msgSend_path(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "path");
}

id objc_msgSend_pinningDbPath(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "pinningDbPath");
}

id objc_msgSend_populateDbFromBundle_dbConnection_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "populateDbFromBundle:dbConnection:error:");
}

id objc_msgSend_propertyListWithData_options_format_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "propertyListWithData:options:format:error:");
}

id objc_msgSend_protectionSpace(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "protectionSpace");
}

id objc_msgSend_purge_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "purge:");
}

id objc_msgSend_queryCacheForSuffix_firstLabel_results_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "queryCacheForSuffix:firstLabel:results:");
}

id objc_msgSend_queryForDomain_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "queryForDomain:");
}

id objc_msgSend_queryForPolicyName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "queryForPolicyName:");
}

id objc_msgSend_queryMetaDataSync(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "queryMetaDataSync");
}

id objc_msgSend_queue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "queue");
}

id objc_msgSend_rangeOfString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "rangeOfString:");
}

id objc_msgSend_recheckAssetVersion(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "recheckAssetVersion");
}

id objc_msgSend_regexCache(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "regexCache");
}

id objc_msgSend_regexCacheList(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "regexCacheList");
}

id objc_msgSend_registerForAssetChangedNotificationsWithBlock_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "registerForAssetChangedNotificationsWithBlock:");
}

id objc_msgSend_regularExpressionWithPattern_options_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "regularExpressionWithPattern:options:error:");
}

id objc_msgSend_removeAllObjects(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "removeAllObjects");
}

id objc_msgSend_removeAllRulesFromDb_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "removeAllRulesFromDb:error:");
}

id objc_msgSend_removeLastObject(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "removeLastObject");
}

id objc_msgSend_removeObject_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "removeObject:");
}

id objc_msgSend_removeObjectForKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "removeObjectForKey:");
}

id objc_msgSend_removeServer_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "removeServer:");
}

id objc_msgSend_removeTask_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "removeTask:");
}

id objc_msgSend_requestWithURL_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "requestWithURL:");
}

id objc_msgSend_reschedule(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "reschedule");
}

id objc_msgSend_response(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "response");
}

id objc_msgSend_results(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "results");
}

id objc_msgSend_resume(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "resume");
}

id objc_msgSend_returnTypes_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "returnTypes:");
}

id objc_msgSend_saveTrustStoreAssetPath_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "saveTrustStoreAssetPath:");
}

id objc_msgSend_savedTrustStoreAssetPath(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "savedTrustStoreAssetPath");
}

id objc_msgSend_scheduleUpdateFromServer_forVersion_withQueue_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "scheduleUpdateFromServer:forVersion:withQueue:");
}

id objc_msgSend_scheme(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "scheme");
}

id objc_msgSend_serverTrust(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "serverTrust");
}

id objc_msgSend_sessionForAuditToken_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "sessionForAuditToken:");
}

id objc_msgSend_sessionWithConfiguration_delegate_delegateQueue_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "sessionWithConfiguration:delegate:delegateQueue:");
}

id objc_msgSend_setAllowsCellularAccess_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setAllowsCellularAccess:");
}

id objc_msgSend_setAssetDidChangeHandler_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setAssetDidChangeHandler:");
}

id objc_msgSend_setAttribution_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setAttribution:");
}

id objc_msgSend_setBackgroundSession_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setBackgroundSession:");
}

id objc_msgSend_setCallback_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setCallback:");
}

id objc_msgSend_setContentVersion_dbConnection_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setContentVersion:dbConnection:error:");
}

id objc_msgSend_setContext_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setContext:");
}

id objc_msgSend_setCurrentAssetSelector_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setCurrentAssetSelector:");
}

id objc_msgSend_setCurrentUpdateServer_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setCurrentUpdateServer:");
}

id objc_msgSend_setDelegate_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setDelegate:");
}

id objc_msgSend_setDiscretionary_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setDiscretionary:");
}

id objc_msgSend_setEphemeralSession_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setEphemeralSession:");
}

id objc_msgSend_setFinishedDownloading_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setFinishedDownloading:");
}

id objc_msgSend_setHTTPAdditionalHeaders_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setHTTPAdditionalHeaders:");
}

id objc_msgSend_setHTTPBody_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setHTTPBody:");
}

id objc_msgSend_setHTTPCookieStorage_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setHTTPCookieStorage:");
}

id objc_msgSend_setHTTPMethod_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setHTTPMethod:");
}

id objc_msgSend_setHandler_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setHandler:");
}

id objc_msgSend_setHost_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setHost:");
}

id objc_msgSend_setLastAssetPath_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setLastAssetPath:");
}

id objc_msgSend_setLastAttemptDate_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setLastAttemptDate:");
}

id objc_msgSend_setLastAvailableVersion_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setLastAvailableVersion:");
}

id objc_msgSend_setLastCurrentVersion_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setLastCurrentVersion:");
}

id objc_msgSend_setMaxAge_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setMaxAge:");
}

id objc_msgSend_setMaxConcurrentOperationCount_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setMaxConcurrentOperationCount:");
}

id objc_msgSend_setNetworkServiceType_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setNetworkServiceType:");
}

id objc_msgSend_setNotifyQueue_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setNotifyQueue:");
}

id objc_msgSend_setNumTasks_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setNumTasks:");
}

id objc_msgSend_setObject_forKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setObject:forKey:");
}

id objc_msgSend_setObject_forKeyedSubscript_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setObject:forKeyedSubscript:");
}

id objc_msgSend_setQueue_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setQueue:");
}

id objc_msgSend_setRecheckAssetVersion_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setRecheckAssetVersion:");
}

id objc_msgSend_setRegexCache_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setRegexCache:");
}

id objc_msgSend_setRegexCacheList_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setRegexCacheList:");
}

id objc_msgSend_setRemoteObjectInterface_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setRemoteObjectInterface:");
}

id objc_msgSend_setResponse_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setResponse:");
}

id objc_msgSend_setRevDbUpdateQueue_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setRevDbUpdateQueue:");
}

id objc_msgSend_setSchemaVersion_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setSchemaVersion:error:");
}

id objc_msgSend_setScheme_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setScheme:");
}

id objc_msgSend_setTLSMinimumSupportedProtocol_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setTLSMinimumSupportedProtocol:");
}

id objc_msgSend_setTaskDescription_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setTaskDescription:");
}

id objc_msgSend_setTimeZone_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setTimeZone:");
}

id objc_msgSend_setTimeoutCounter_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setTimeoutCounter:");
}

id objc_msgSend_setTransaction_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setTransaction:");
}

id objc_msgSend_setURIix_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setURIix:");
}

id objc_msgSend_setURIs_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setURIs:");
}

id objc_msgSend_setURLCache_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setURLCache:");
}

id objc_msgSend_setUnderlyingQueue_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setUnderlyingQueue:");
}

id objc_msgSend_setUpdateScheduled_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setUpdateScheduled:");
}

id objc_msgSend_setUserInitiated_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setUserInitiated:");
}

id objc_msgSend_setValuesForKeysWithDictionary_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setValuesForKeysWithDictionary:");
}

id objc_msgSend_setWithObjects_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setWithObjects:");
}

id objc_msgSend_set_clientLRUList_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "set_clientLRUList:");
}

id objc_msgSend_set_clientSessionMap_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "set_clientSessionMap:");
}

id objc_msgSend_set_hstsStorage_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "set_hstsStorage:");
}

id objc_msgSend_set_requiresPowerPluggedIn_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "set_requiresPowerPluggedIn:");
}

id objc_msgSend_set_serverMap_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "set_serverMap:");
}

id objc_msgSend_set_sharedHSTSCache_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "set_sharedHSTSCache:");
}

id objc_msgSend_set_sourceApplicationAuditTokenData_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "set_sourceApplicationAuditTokenData:");
}

id objc_msgSend_set_sourceApplicationSecondaryIdentifier_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "set_sourceApplicationSecondaryIdentifier:");
}

id objc_msgSend_set_taskContextMap_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "set_taskContextMap:");
}

id objc_msgSend_set_timerMap_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "set_timerMap:");
}

id objc_msgSend_shouldUpdateContent_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "shouldUpdateContent:error:");
}

id objc_msgSend_startCatalogDownload_options_then_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "startCatalogDownload:options:then:");
}

id objc_msgSend_startDownload_then_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "startDownload:then:");
}

id objc_msgSend_startUsingLocalAsset(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "startUsingLocalAsset");
}

id objc_msgSend_state(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "state");
}

id objc_msgSend_statusCode(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "statusCode");
}

id objc_msgSend_stringByAddingPercentEncodingWithAllowedCharacters_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "stringByAddingPercentEncodingWithAllowedCharacters:");
}

id objc_msgSend_stringWithCString_encoding_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "stringWithCString:encoding:");
}

id objc_msgSend_stringWithFormat_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "stringWithFormat:");
}

id objc_msgSend_stringWithString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "stringWithString:");
}

id objc_msgSend_stringWithUTF8String_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "stringWithUTF8String:");
}

id objc_msgSend_substringFromIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "substringFromIndex:");
}

id objc_msgSend_substringToIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "substringToIndex:");
}

id objc_msgSend_synchronousRemoteObjectProxyWithErrorHandler_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "synchronousRemoteObjectProxyWithErrorHandler:");
}

id objc_msgSend_taskDescription(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "taskDescription");
}

id objc_msgSend_taskId(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "taskId");
}

id objc_msgSend_taskInterval(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "taskInterval");
}

id objc_msgSend_timeIntervalSince1970(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "timeIntervalSince1970");
}

id objc_msgSend_timeIntervalSinceNow(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "timeIntervalSinceNow");
}

id objc_msgSend_timeZoneForSecondsFromGMT_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "timeZoneForSecondsFromGMT:");
}

id objc_msgSend_timeoutCounter(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "timeoutCounter");
}

id objc_msgSend_timeoutEntryForServer_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "timeoutEntryForServer:");
}

id objc_msgSend_trustd_logDetailedEventforEventNamed_attributesCallback_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "trustd_logDetailedEventforEventNamed:attributesCallback:");
}

id objc_msgSend_trustd_logDetailedEventforEventNamed_attributesCallback_timestampBucket_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "trustd_logDetailedEventforEventNamed:attributesCallback:timestampBucket:");
}

id objc_msgSend_unsignedIntValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "unsignedIntValue");
}

id objc_msgSend_unsignedIntegerValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "unsignedIntegerValue");
}

id objc_msgSend_unsignedLongLongValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "unsignedLongLongValue");
}

id objc_msgSend_unsignedLongValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "unsignedLongValue");
}

id objc_msgSend_updateDb_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "updateDb:");
}

id objc_msgSend_updateDb_error_pinningList_updateSchema_updateContent_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "updateDb:error:pinningList:updateSchema:updateContent:");
}

id objc_msgSend_updateNowFromServer_version_queue_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "updateNowFromServer:version:queue:");
}

id objc_msgSend_updateScheduled(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "updateScheduled");
}

id objc_msgSend_validTrustStoreAssetPath_mustExist_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "validTrustStoreAssetPath:mustExist:");
}

id objc_msgSend_validUpdateConfiguration_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "validUpdateConfiguration:");
}

id objc_msgSend_valueForKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "valueForKey:");
}

id objc_msgSend_versionFromTask_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "versionFromTask:");
}

id objc_msgSend_writeData_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "writeData:");
}

id objc_msgSend_writeToClassDURL_permissions_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "writeToClassDURL:permissions:error:");
}

id objc_msgSend_writeToURL_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "writeToURL:error:");
}
