_QWORD *sub_10008C2C4(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int64_t v8;
  uint64_t v9;
  int64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  int64_t v18;
  unint64_t v19;
  int64_t v20;
  unint64_t v21;

  v4 = a4 + 64;
  v5 = -1;
  v6 = -1 << *(_BYTE *)(a4 + 32);
  if (-v6 < 64)
    v5 = ~(-1 << -(char)v6);
  v7 = v5 & *(_QWORD *)(a4 + 64);
  if (!a2)
  {
    v8 = 0;
    a3 = 0;
LABEL_35:
    *result = a4;
    result[1] = v4;
    result[2] = ~v6;
    result[3] = v8;
    result[4] = v7;
    return (_QWORD *)a3;
  }
  if (!a3)
  {
    v8 = 0;
    goto LABEL_35;
  }
  if (a3 < 0)
  {
LABEL_37:
    __break(1u);
    goto LABEL_38;
  }
  v8 = 0;
  v9 = 0;
  v10 = (unint64_t)(63 - v6) >> 6;
  while (v7)
  {
    v11 = __clz(__rbit64(v7));
    v7 &= v7 - 1;
    v12 = v11 | (v8 << 6);
LABEL_8:
    ++v9;
    v13 = *(_QWORD *)(a4 + 48) + 8 * v12;
    v14 = *(_DWORD *)v13;
    LOWORD(v13) = *(_WORD *)(v13 + 4);
    v15 = *(_QWORD *)(a4 + 56) + 24 * v12;
    v16 = *(_OWORD *)v15;
    v17 = *(_QWORD *)(v15 + 16);
    *(_DWORD *)a2 = v14;
    *(_WORD *)(a2 + 4) = v13;
    *(_OWORD *)(a2 + 8) = v16;
    *(_QWORD *)(a2 + 24) = v17;
    a2 += 32;
    if (v9 == a3)
      goto LABEL_35;
  }
  v18 = v8 + 1;
  if (__OFADD__(v8, 1))
  {
    __break(1u);
    goto LABEL_37;
  }
  if (v18 >= v10)
    goto LABEL_30;
  v19 = *(_QWORD *)(v4 + 8 * v18);
  if (v19)
    goto LABEL_19;
  v8 += 2;
  if (v18 + 1 >= v10)
  {
    v7 = 0;
    v8 = v18;
    goto LABEL_34;
  }
  v19 = *(_QWORD *)(v4 + 8 * v8);
  if (v19)
  {
LABEL_15:
    v18 = v8;
LABEL_19:
    v21 = __clz(__rbit64(v19));
    v7 = (v19 - 1) & v19;
    v12 = v21 + (v18 << 6);
    v8 = v18;
    goto LABEL_8;
  }
  v20 = v18 + 2;
  if (v18 + 2 >= v10)
    goto LABEL_30;
  v19 = *(_QWORD *)(v4 + 8 * v20);
  if (v19)
  {
LABEL_18:
    v18 = v20;
    goto LABEL_19;
  }
  v8 = v18 + 3;
  if (v18 + 3 >= v10)
  {
    v7 = 0;
    v8 = v18 + 2;
    goto LABEL_34;
  }
  v19 = *(_QWORD *)(v4 + 8 * v8);
  if (v19)
    goto LABEL_15;
  v20 = v18 + 4;
  if (v18 + 4 >= v10)
  {
LABEL_30:
    v7 = 0;
LABEL_34:
    a3 = v9;
    goto LABEL_35;
  }
  v19 = *(_QWORD *)(v4 + 8 * v20);
  if (v19)
    goto LABEL_18;
  while (1)
  {
    v18 = v20 + 1;
    if (__OFADD__(v20, 1))
      break;
    if (v18 >= v10)
    {
      v7 = 0;
      v8 = v10 - 1;
      goto LABEL_34;
    }
    v19 = *(_QWORD *)(v4 + 8 * v18);
    ++v20;
    if (v19)
      goto LABEL_19;
  }
LABEL_38:
  __break(1u);
  return result;
}

_QWORD *sub_10008C480(_QWORD *result, unint64_t a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  uint64_t v11;

  v3 = a2 - (_QWORD)result;
  if (a2 < (unint64_t)result)
  {
    __break(1u);
  }
  else
  {
    if (v3 <= 0x7F)
      return _swiftEmptyArrayStorage;
    v7 = (unint64_t)result;
    v8 = v3 >> 7;
    v9 = sub_100012C44(&qword_100406618);
    v4 = swift_allocObject(v9, v8 + 32, 7);
    v10 = j__malloc_size((const void *)v4);
    *(_QWORD *)(v4 + 16) = v8;
    *(_QWORD *)(v4 + 24) = 2 * v10 - 64;
    result = (_QWORD *)sub_10008BCC4((unint64_t)&v11, (_BYTE *)(v4 + 32), v8, v7, a2, a3);
    if (result == (_QWORD *)v8)
      return (_QWORD *)v4;
  }
  __break(1u);
  return result;
}

unint64_t *sub_10008C538(unint64_t *result, unint64_t a2, unint64_t a3)
{
  unint64_t v3;
  _QWORD *v4;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  unint64_t v11[4];

  v3 = a2 - (_QWORD)result;
  if (a2 < (unint64_t)result)
  {
    __break(1u);
  }
  else
  {
    if (v3 <= 0xF)
      return _swiftEmptyArrayStorage;
    v7 = (unint64_t)result;
    v8 = v3 >> 4;
    v9 = sub_100012C44(&qword_100406610);
    v4 = (_QWORD *)swift_allocObject(v9, v8 + 32, 7);
    v10 = j__malloc_size(v4);
    v4[2] = v8;
    v4[3] = 2 * v10 - 64;
    result = sub_10008BBA0(v11, (uint64_t)(v4 + 4), v8, v7, a2, a3);
    if (result == (unint64_t *)v8)
      return v4;
  }
  __break(1u);
  return result;
}

_QWORD *sub_10008C5F0(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  _QWORD *v4;
  int64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v10;

  v1 = *(_QWORD *)(a1 + 16);
  if (!v1)
    return _swiftEmptyArrayStorage;
  v3 = sub_100012C44(&qword_100406150);
  v4 = (_QWORD *)swift_allocObject(v3, 8 * v1 + 32, 7);
  v5 = j__malloc_size(v4);
  v6 = v5 - 32;
  if (v5 < 32)
    v6 = v5 - 25;
  v4[2] = v1;
  v4[3] = 2 * (v6 >> 3);
  v7 = sub_100180A1C(&v10, (uint64_t)(v4 + 4), v1, a1);
  v8 = v10;
  swift_bridgeObjectRetain(a1);
  swift_bridgeObjectRelease(v8);
  if (v7 != (_QWORD *)v1)
  {
    __break(1u);
    return _swiftEmptyArrayStorage;
  }
  return v4;
}

_QWORD *sub_10008C6AC(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v1 = *(_QWORD *)(a1 + 16);
  if (!v1)
    return _swiftEmptyArrayStorage;
  v3 = sub_100012C44(&qword_100406128);
  v4 = *(_QWORD *)(type metadata accessor for LongTermPairingKeys.PublicIdentity(0) - 8);
  v5 = *(_QWORD *)(v4 + 72);
  v6 = *(unsigned __int8 *)(v4 + 80);
  v7 = (v6 + 32) & ~v6;
  v8 = (_QWORD *)swift_allocObject(v3, v7 + v5 * v1, v6 | 7);
  result = (_QWORD *)j__malloc_size(v8);
  if (v5)
  {
    if ((_QWORD *)((char *)result - v7) != (_QWORD *)0x8000000000000000 || v5 != -1)
    {
      v8[2] = v1;
      v8[3] = 2 * (((uint64_t)result - v7) / v5);
      v11 = sub_10008BE6C(&v13, (uint64_t)v8 + v7, v1, a1);
      v12 = v13;
      swift_bridgeObjectRetain(a1);
      sub_100062B6C(v12);
      if (v11 == v1)
        return v8;
      __break(1u);
      return _swiftEmptyArrayStorage;
    }
  }
  else
  {
    __break(1u);
  }
  __break(1u);
  return result;
}

_QWORD *sub_10008C7C4(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  _QWORD *v4;
  int64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v10;

  v1 = *(_QWORD *)(a1 + 16);
  if (!v1)
    return _swiftEmptyArrayStorage;
  v3 = sub_100012C44(&qword_100406210);
  v4 = (_QWORD *)swift_allocObject(v3, 8 * v1 + 32, 7);
  v5 = j__malloc_size(v4);
  v6 = v5 - 32;
  if (v5 < 32)
    v6 = v5 - 25;
  v4[2] = v1;
  v4[3] = 2 * (v6 >> 3);
  v7 = sub_10008C118(&v10, (uint64_t)(v4 + 4), v1, a1);
  v8 = v10;
  swift_bridgeObjectRetain(a1);
  sub_100062B6C(v8);
  if (v7 != (_QWORD *)v1)
  {
    __break(1u);
    return _swiftEmptyArrayStorage;
  }
  return v4;
}

_QWORD *sub_10008C8A8(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  _QWORD *v4;
  int64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v10;

  v1 = *(_QWORD *)(a1 + 16);
  if (!v1)
    return _swiftEmptyArrayStorage;
  v3 = sub_100012C44(&qword_100406208);
  v4 = (_QWORD *)swift_allocObject(v3, 32 * v1 + 32, 7);
  v5 = j__malloc_size(v4);
  v6 = v5 - 32;
  if (v5 < 32)
    v6 = v5 - 1;
  v4[2] = v1;
  v4[3] = 2 * (v6 >> 5);
  v7 = sub_10008C2C4(&v10, (uint64_t)(v4 + 4), v1, a1);
  v8 = v10;
  swift_bridgeObjectRetain(a1);
  sub_100062B6C(v8);
  if (v7 != (_QWORD *)v1)
  {
    __break(1u);
    return _swiftEmptyArrayStorage;
  }
  return v4;
}

char *sub_10008C98C(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v8;
  char *v9;
  size_t v10;
  char *v11;
  char *v12;
  char *result;

  v4 = a4 >> 1;
  v5 = (a4 >> 1) - a3;
  if (__OFSUB__(a4 >> 1, a3))
    goto LABEL_16;
  if (!v5)
    return (char *)_swiftEmptyArrayStorage;
  if (v5 > 0)
  {
    v8 = sub_100012C44((uint64_t *)&unk_10040EFC0);
    v9 = (char *)swift_allocObject(v8, 7 * v5 + 32, 7);
    v10 = j__malloc_size(v9);
    *((_QWORD *)v9 + 2) = v5;
    *((_QWORD *)v9 + 3) = 2 * ((uint64_t)(v10 - 32) / 7);
    if (v4 != a3)
      goto LABEL_5;
    goto LABEL_15;
  }
  v9 = (char *)_swiftEmptyArrayStorage;
  if (v4 == a3)
  {
LABEL_15:
    __break(1u);
LABEL_16:
    __break(1u);
    goto LABEL_17;
  }
LABEL_5:
  if (v5 < 0)
  {
LABEL_17:
    result = (char *)_fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 1090, 0);
    goto LABEL_18;
  }
  v11 = v9 + 32;
  v12 = (char *)(a2 - a3 + 8 * a3);
  if (v12 >= &v9[7 * v5 + 32] || v11 >= &v12[7 * v5])
  {
    memcpy(v11, v12, 7 * v5);
    return v9;
  }
  result = (char *)_fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 1092, 0);
LABEL_18:
  __break(1u);
  return result;
}

uint64_t sub_10008CB0C(uint64_t *a1, uint64_t (*a2)(uint64_t), uint64_t (*a3)(_QWORD *))
{
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  _QWORD v9[2];

  v6 = *a1;
  if ((swift_isUniquelyReferenced_nonNull_native(*a1) & 1) == 0)
    v6 = a2(v6);
  v7 = *(_QWORD *)(v6 + 16);
  v9[0] = v6 + 32;
  v9[1] = v7;
  result = a3(v9);
  *a1 = v6;
  return result;
}

Swift::Int sub_10008CB84(uint64_t *a1)
{
  uint64_t v1;
  Swift::Int v3;
  Swift::Int result;
  uint64_t v5;
  Swift::Int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  Swift::Int v11;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  Swift::Int v15;
  unsigned int v16;
  uint64_t v17;
  unsigned int v18;
  _DWORD *v19;
  uint64_t v20;
  Swift::Int v21;
  Swift::Int v22;
  uint64_t v23;
  _QWORD *v24;
  int v25;
  char v26;
  char v27;
  char v28;
  Swift::Int v29;
  int *v30;
  int *v31;
  Swift::Int v32;
  int v33;
  __int16 v34;
  char v35;
  unint64_t v36;
  unint64_t v37;
  char *v38;
  char *v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char v44;
  char *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  BOOL v51;
  unint64_t v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  uint64_t v59;
  uint64_t v60;
  BOOL v61;
  uint64_t v62;
  char v63;
  char *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  BOOL v68;
  uint64_t v69;
  uint64_t v70;
  char *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  char *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  char *v80;
  char *v81;
  uint64_t v82;
  char *v83;
  uint64_t v84;
  unint64_t v85;
  char *v86;
  char *v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  int v94;
  __int16 v95;
  char v96;
  uint64_t v98;
  unint64_t v99;
  uint64_t v100;
  uint64_t v101;
  char *v102;
  unint64_t v103;
  uint64_t *v104;
  uint64_t v105;
  _QWORD *v106;
  Swift::Int v107;
  Swift::Int v108;
  uint64_t v109;
  char *__dst;
  uint64_t v111;

  v3 = a1[1];
  result = _minimumMergeRunLength(_:)(v3);
  if (result >= v3)
  {
    if ((v3 & 0x8000000000000000) == 0)
    {
      if ((unint64_t)v3 < 2)
        return result;
      v88 = *a1;
      v89 = *a1 + 8;
      v90 = -1;
      v91 = 1;
      while (1)
      {
        v92 = v89;
        v93 = v90;
        do
        {
          v94 = *(_DWORD *)v92;
          if (*(_DWORD *)v92 >= *(_DWORD *)(v92 - 8))
            break;
          if (!v88)
            goto LABEL_147;
          v95 = *(_WORD *)(v92 + 4);
          v96 = *(_BYTE *)(v92 + 6);
          *(_QWORD *)v92 = *(_QWORD *)(v92 - 8);
          *(_DWORD *)(v92 - 8) = v94;
          *(_WORD *)(v92 - 4) = v95;
          *(_BYTE *)(v92 - 2) = v96;
          v92 -= 8;
        }
        while (!__CFADD__(v93++, 1));
        ++v91;
        --v90;
        v89 += 8;
        if (v91 == v3)
          return result;
      }
    }
    goto LABEL_143;
  }
  if (v3 >= 0)
    v5 = v3;
  else
    v5 = v3 + 1;
  if (v3 < -1)
  {
LABEL_152:
    result = _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Can't construct Array with count < 0", 36, 2, "Swift/Array.swift", 17, 2, 936, 0);
    __break(1u);
    return result;
  }
  v6 = result;
  v111 = v1;
  v104 = a1;
  if (v3 < 2)
  {
    v10 = _swiftEmptyArrayStorage;
    __dst = (char *)&_swiftEmptyArrayStorage[4];
    if (v3 != 1)
    {
      v14 = _swiftEmptyArrayStorage[2];
      v13 = (char *)_swiftEmptyArrayStorage;
      goto LABEL_109;
    }
    v106 = _swiftEmptyArrayStorage;
  }
  else
  {
    v7 = v5 >> 1;
    v8 = sub_100012C44(&qword_100406660);
    v9 = static Array._allocateBufferUninitialized(minimumCapacity:)(v7, v8);
    *(_QWORD *)(v9 + 16) = v7;
    v106 = (_QWORD *)v9;
    __dst = (char *)(v9 + 32);
  }
  v11 = 0;
  v12 = *a1;
  v105 = *a1 + 16;
  v13 = (char *)_swiftEmptyArrayStorage;
  v107 = v6;
  v108 = v3;
  v109 = v12;
  while (1)
  {
    v15 = v11++;
    if (v11 < v3)
    {
      v16 = *(_DWORD *)(v12 + 8 * v11);
      v17 = 8 * v15;
      v18 = *(_DWORD *)(v12 + 8 * v15);
      v11 = v15 + 2;
      if (v15 + 2 < v3)
      {
        v19 = (_DWORD *)(v105 + 8 * v15);
        while (v16 < v18 != *v19 >= *(v19 - 2))
        {
          v19 += 2;
          if (v3 == ++v11)
          {
            v11 = v3;
            break;
          }
        }
      }
      if (v16 < v18)
      {
        if (v11 < v15)
          goto LABEL_144;
        if (v15 < v11)
        {
          v20 = 8 * v11 - 8;
          v21 = v11;
          v22 = v15;
          do
          {
            if (v22 != --v21)
            {
              if (!v12)
                goto LABEL_150;
              v24 = (_QWORD *)(v12 + v17);
              v25 = *(_DWORD *)(v12 + v17);
              v26 = *(_BYTE *)(v12 + v17 + 4);
              v27 = *(_BYTE *)(v12 + v17 + 5);
              v28 = *(_BYTE *)(v12 + v17 + 6);
              if (v17 != v20 || (unint64_t)v24 >= v12 + v20 + 8)
                *v24 = *(_QWORD *)(v12 + v20);
              v23 = v12 + v20;
              *(_DWORD *)v23 = v25;
              *(_BYTE *)(v23 + 4) = v26;
              *(_BYTE *)(v23 + 5) = v27;
              *(_BYTE *)(v23 + 6) = v28;
            }
            ++v22;
            v20 -= 8;
            v17 += 8;
          }
          while (v22 < v21);
        }
      }
    }
    if (v11 < v3)
    {
      if (__OFSUB__(v11, v15))
        goto LABEL_142;
      if (v11 - v15 < v6)
      {
        v29 = v15 + v6;
        if (__OFADD__(v15, v6))
          goto LABEL_145;
        if (v29 >= v3)
          v29 = v3;
        if (v29 < v15)
          goto LABEL_146;
        if (v11 != v29)
        {
          v30 = (int *)(v12 + 8 * v11);
          do
          {
            v31 = v30;
            v32 = v15;
            do
            {
              v33 = *v31;
              if (*v31 >= *(v31 - 2))
                break;
              if (!v12)
                goto LABEL_148;
              v34 = *((_WORD *)v31 + 2);
              v35 = *((_BYTE *)v31 + 6);
              *(_QWORD *)v31 = *((_QWORD *)v31 - 1);
              *(v31 - 2) = v33;
              *((_WORD *)v31 - 2) = v34;
              *((_BYTE *)v31 - 2) = v35;
              ++v32;
              v31 -= 2;
            }
            while (v11 != v32);
            ++v11;
            v30 += 2;
          }
          while (v11 != v29);
          v11 = v29;
        }
      }
    }
    if (v11 < v15)
    {
LABEL_137:
      __break(1u);
      goto LABEL_138;
    }
    if ((swift_isUniquelyReferenced_nonNull_native(v13) & 1) == 0)
      v13 = sub_1000F5C8C(0, *((_QWORD *)v13 + 2) + 1, 1, v13);
    v37 = *((_QWORD *)v13 + 2);
    v36 = *((_QWORD *)v13 + 3);
    v14 = v37 + 1;
    v12 = v109;
    if (v37 >= v36 >> 1)
    {
      v12 = v109;
      v13 = sub_1000F5C8C((char *)(v36 > 1), v37 + 1, 1, v13);
    }
    *((_QWORD *)v13 + 2) = v14;
    v38 = v13 + 32;
    v39 = &v13[16 * v37 + 32];
    *(_QWORD *)v39 = v15;
    *((_QWORD *)v39 + 1) = v11;
    if (v37)
      break;
    v14 = 1;
LABEL_15:
    v6 = v107;
    v3 = v108;
    if (v11 >= v108)
    {
      v10 = v106;
LABEL_109:
      v87 = v13;
      v106 = v10;
      if (v14 < 2)
        goto LABEL_99;
      v98 = *v104;
      while (1)
      {
        v99 = v14 - 2;
        if (v14 < 2)
          break;
        if (!v98)
          goto LABEL_151;
        v86 = v87;
        v100 = *(_QWORD *)&v87[16 * v99 + 32];
        v101 = *(_QWORD *)&v87[16 * v14 + 24];
        sub_10008D9A8((char *)(v98 + 8 * v100), (char *)(v98 + 8 * *(_QWORD *)&v87[16 * v14 + 16]), v98 + 8 * v101, __dst);
        if (v111)
          goto LABEL_98;
        if (v101 < v100)
          goto LABEL_139;
        if ((swift_isUniquelyReferenced_nonNull_native(v86) & 1) == 0)
          v86 = sub_1000F5F78((uint64_t)v86);
        if (v99 >= *((_QWORD *)v86 + 2))
          goto LABEL_140;
        v102 = &v86[16 * v99 + 32];
        *(_QWORD *)v102 = v100;
        *((_QWORD *)v102 + 1) = v101;
        v103 = *((_QWORD *)v86 + 2);
        if (v14 > v103)
          goto LABEL_141;
        memmove(&v86[16 * v14 + 16], &v86[16 * v14 + 32], 16 * (v103 - v14));
        v87 = v86;
        *((_QWORD *)v86 + 2) = v103 - 1;
        v14 = v103 - 1;
        if (v103 <= 2)
          goto LABEL_99;
      }
LABEL_138:
      __break(1u);
LABEL_139:
      __break(1u);
LABEL_140:
      __break(1u);
LABEL_141:
      __break(1u);
LABEL_142:
      __break(1u);
LABEL_143:
      __break(1u);
LABEL_144:
      __break(1u);
LABEL_145:
      __break(1u);
LABEL_146:
      __break(1u);
LABEL_147:
      __break(1u);
LABEL_148:
      __break(1u);
LABEL_149:
      __break(1u);
LABEL_150:
      __break(1u);
LABEL_151:
      __break(1u);
      goto LABEL_152;
    }
  }
  while (1)
  {
    v40 = v14 - 1;
    if (v14 >= 4)
    {
      v45 = &v38[16 * v14];
      v46 = *((_QWORD *)v45 - 8);
      v47 = *((_QWORD *)v45 - 7);
      v51 = __OFSUB__(v47, v46);
      v48 = v47 - v46;
      if (v51)
        goto LABEL_126;
      v50 = *((_QWORD *)v45 - 6);
      v49 = *((_QWORD *)v45 - 5);
      v51 = __OFSUB__(v49, v50);
      v43 = v49 - v50;
      v44 = v51;
      if (v51)
        goto LABEL_127;
      v52 = v14 - 2;
      v53 = &v38[16 * v14 - 32];
      v55 = *(_QWORD *)v53;
      v54 = *((_QWORD *)v53 + 1);
      v51 = __OFSUB__(v54, v55);
      v56 = v54 - v55;
      if (v51)
        goto LABEL_129;
      v51 = __OFADD__(v43, v56);
      v57 = v43 + v56;
      if (v51)
        goto LABEL_132;
      if (v57 >= v48)
      {
        v75 = &v38[16 * v40];
        v77 = *(_QWORD *)v75;
        v76 = *((_QWORD *)v75 + 1);
        v51 = __OFSUB__(v76, v77);
        v78 = v76 - v77;
        if (v51)
          goto LABEL_136;
        v68 = v43 < v78;
        goto LABEL_87;
      }
    }
    else
    {
      if (v14 != 3)
      {
        v69 = *((_QWORD *)v13 + 4);
        v70 = *((_QWORD *)v13 + 5);
        v51 = __OFSUB__(v70, v69);
        v62 = v70 - v69;
        v63 = v51;
        goto LABEL_81;
      }
      v42 = *((_QWORD *)v13 + 4);
      v41 = *((_QWORD *)v13 + 5);
      v51 = __OFSUB__(v41, v42);
      v43 = v41 - v42;
      v44 = v51;
    }
    if ((v44 & 1) != 0)
      goto LABEL_128;
    v52 = v14 - 2;
    v58 = &v38[16 * v14 - 32];
    v60 = *(_QWORD *)v58;
    v59 = *((_QWORD *)v58 + 1);
    v61 = __OFSUB__(v59, v60);
    v62 = v59 - v60;
    v63 = v61;
    if (v61)
      goto LABEL_131;
    v64 = &v38[16 * v40];
    v66 = *(_QWORD *)v64;
    v65 = *((_QWORD *)v64 + 1);
    v51 = __OFSUB__(v65, v66);
    v67 = v65 - v66;
    if (v51)
      goto LABEL_134;
    if (__OFADD__(v62, v67))
      goto LABEL_135;
    if (v62 + v67 >= v43)
    {
      v68 = v43 < v67;
LABEL_87:
      if (v68)
        v40 = v52;
      goto LABEL_89;
    }
LABEL_81:
    if ((v63 & 1) != 0)
      goto LABEL_130;
    v71 = &v38[16 * v40];
    v73 = *(_QWORD *)v71;
    v72 = *((_QWORD *)v71 + 1);
    v51 = __OFSUB__(v72, v73);
    v74 = v72 - v73;
    if (v51)
      goto LABEL_133;
    if (v74 < v62)
      goto LABEL_15;
LABEL_89:
    v79 = v40 - 1;
    if (v40 - 1 >= v14)
    {
      __break(1u);
LABEL_123:
      __break(1u);
LABEL_124:
      __break(1u);
LABEL_125:
      __break(1u);
LABEL_126:
      __break(1u);
LABEL_127:
      __break(1u);
LABEL_128:
      __break(1u);
LABEL_129:
      __break(1u);
LABEL_130:
      __break(1u);
LABEL_131:
      __break(1u);
LABEL_132:
      __break(1u);
LABEL_133:
      __break(1u);
LABEL_134:
      __break(1u);
LABEL_135:
      __break(1u);
LABEL_136:
      __break(1u);
      goto LABEL_137;
    }
    if (!v12)
      goto LABEL_149;
    v80 = v13;
    v81 = &v38[16 * v79];
    v82 = *(_QWORD *)v81;
    v83 = &v38[16 * v40];
    v84 = *((_QWORD *)v83 + 1);
    sub_10008D9A8((char *)(v12 + 8 * *(_QWORD *)v81), (char *)(v12 + 8 * *(_QWORD *)v83), v12 + 8 * v84, __dst);
    if (v111)
      break;
    if (v84 < v82)
      goto LABEL_123;
    if (v40 > *((_QWORD *)v80 + 2))
      goto LABEL_124;
    *(_QWORD *)v81 = v82;
    *(_QWORD *)&v38[16 * v79 + 8] = v84;
    v85 = *((_QWORD *)v80 + 2);
    if (v40 >= v85)
      goto LABEL_125;
    v13 = v80;
    v14 = v85 - 1;
    memmove(&v38[16 * v40], v83 + 16, 16 * (v85 - 1 - v40));
    *((_QWORD *)v80 + 2) = v85 - 1;
    v12 = v109;
    if (v85 <= 2)
      goto LABEL_15;
  }
  v86 = v80;
LABEL_98:
  v87 = v86;
LABEL_99:
  swift_bridgeObjectRelease(v87);
  v106[2] = 0;
  return swift_bridgeObjectRelease(v106);
}

void sub_10008D294(uint64_t *a1)
{
  uint64_t v1;
  Swift::Int v3;
  Swift::Int v4;
  uint64_t v5;
  Swift::Int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  Swift::Int v11;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  Swift::Int v15;
  unsigned int v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int *v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  Swift::Int v24;
  Swift::Int v25;
  _OWORD *v26;
  int v27;
  uint64_t v28;
  __int16 v29;
  __int128 v30;
  uint64_t v31;
  __int128 v32;
  Swift::Int v33;
  uint64_t v34;
  unsigned int v35;
  Swift::Int v36;
  uint64_t v37;
  _OWORD *v38;
  __int128 v39;
  __int128 v40;
  __int16 v41;
  __int128 v42;
  unint64_t v43;
  unint64_t v44;
  char *v45;
  char *v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  char v51;
  char *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  BOOL v58;
  unint64_t v59;
  char *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  char *v65;
  uint64_t v66;
  uint64_t v67;
  BOOL v68;
  uint64_t v69;
  char v70;
  char *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  BOOL v75;
  uint64_t v76;
  uint64_t v77;
  char *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  char *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  unint64_t v86;
  char *v87;
  char *v88;
  uint64_t v89;
  char *v90;
  uint64_t v91;
  unint64_t v92;
  char *v93;
  char *v94;
  char *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  unsigned int v99;
  uint64_t v100;
  _OWORD *v101;
  uint64_t v102;
  __int16 v103;
  __int128 v104;
  uint64_t v105;
  __int128 v106;
  uint64_t v107;
  unint64_t v108;
  uint64_t v109;
  uint64_t v110;
  char *v111;
  unint64_t v112;
  uint64_t v113;
  uint64_t *v114;
  uint64_t v115;
  _QWORD *v116;
  Swift::Int v117;
  Swift::Int v118;
  uint64_t v119;
  char *__dst;

  v3 = a1[1];
  v4 = _minimumMergeRunLength(_:)(v3);
  if (v4 >= v3)
  {
    if ((v3 & 0x8000000000000000) == 0)
    {
      if ((unint64_t)v3 < 2)
        return;
      v96 = 0;
      v97 = *a1;
      v98 = 1;
      while (1)
      {
        v99 = *(_DWORD *)(v97 + 32 * v98);
        v100 = v96;
        do
        {
          v101 = (_OWORD *)(v97 + v100);
          if (v99 >= *(_DWORD *)(v97 + v100))
            break;
          if (!v97)
            goto LABEL_142;
          v102 = v97 + v100;
          v103 = *(_WORD *)(v97 + v100 + 36);
          v104 = *(_OWORD *)(v97 + v100 + 40);
          v105 = *(_QWORD *)(v97 + v100 + 56);
          v106 = v101[1];
          *(_OWORD *)(v97 + v100 + 32) = *v101;
          *(_OWORD *)(v97 + v100 + 48) = v106;
          *(_DWORD *)v102 = v99;
          *(_WORD *)(v102 + 4) = v103;
          *(_OWORD *)(v102 + 8) = v104;
          *(_QWORD *)(v102 + 24) = v105;
          v100 -= 32;
        }
        while (v100 != -32);
        ++v98;
        v96 += 32;
        if (v98 == v3)
          return;
      }
    }
    goto LABEL_138;
  }
  if (v3 >= 0)
    v5 = v3;
  else
    v5 = v3 + 1;
  if (v3 < -1)
  {
LABEL_147:
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Can't construct Array with count < 0", 36, 2, "Swift/Array.swift", 17, 2, 936, 0);
    __break(1u);
    return;
  }
  v6 = v4;
  v114 = a1;
  if (v3 < 2)
  {
    v10 = _swiftEmptyArrayStorage;
    __dst = (char *)&_swiftEmptyArrayStorage[4];
    if (v3 != 1)
    {
      v14 = _swiftEmptyArrayStorage[2];
      v13 = (char *)_swiftEmptyArrayStorage;
      goto LABEL_104;
    }
    v116 = _swiftEmptyArrayStorage;
  }
  else
  {
    v7 = v5 >> 1;
    v8 = sub_100012C44(&qword_100406658);
    v9 = static Array._allocateBufferUninitialized(minimumCapacity:)(v7, v8);
    *(_QWORD *)(v9 + 16) = v7;
    v116 = (_QWORD *)v9;
    __dst = (char *)(v9 + 32);
  }
  v11 = 0;
  v12 = *a1;
  v115 = *a1 + 64;
  v113 = *a1 + 24;
  v13 = (char *)_swiftEmptyArrayStorage;
  v117 = v6;
  v118 = v3;
  v119 = v12;
  while (1)
  {
    v15 = v11++;
    if (v11 < v3)
    {
      v16 = *(_DWORD *)(v12 + 32 * v11);
      v17 = 32 * v15;
      v18 = *(_DWORD *)(v12 + 32 * v15);
      v11 = v15 + 2;
      if (v15 + 2 < v3)
      {
        v19 = (unsigned int *)(v115 + 32 * v15);
        v20 = v16;
        while (1)
        {
          v22 = *v19;
          v19 += 8;
          v21 = v22;
          if (v16 < v18 == v22 >= v20)
            break;
          ++v11;
          v20 = v21;
          if (v3 == v11)
          {
            v11 = v3;
            break;
          }
        }
      }
      if (v16 < v18)
      {
        if (v11 < v15)
          goto LABEL_139;
        if (v15 < v11)
        {
          v23 = 32 * v11;
          v24 = v11;
          v25 = v15;
          do
          {
            if (v25 != --v24)
            {
              if (!v12)
                goto LABEL_145;
              v26 = (_OWORD *)(v12 + v17);
              v27 = *(_DWORD *)(v12 + v17);
              v28 = v12 + v23;
              v29 = *(_WORD *)(v12 + v17 + 4);
              v30 = *(_OWORD *)(v12 + v17 + 8);
              v31 = *(_QWORD *)(v12 + v17 + 24);
              v32 = *(_OWORD *)(v12 + v23 - 16);
              *v26 = *(_OWORD *)(v12 + v23 - 32);
              v26[1] = v32;
              *(_DWORD *)(v28 - 32) = v27;
              *(_WORD *)(v28 - 28) = v29;
              *(_OWORD *)(v28 - 24) = v30;
              *(_QWORD *)(v28 - 8) = v31;
            }
            ++v25;
            v23 -= 32;
            v17 += 32;
          }
          while (v25 < v24);
        }
      }
    }
    if (v11 < v3)
    {
      if (__OFSUB__(v11, v15))
        goto LABEL_137;
      if (v11 - v15 < v6)
      {
        v33 = v15 + v6;
        if (__OFADD__(v15, v6))
          goto LABEL_140;
        if (v33 >= v3)
          v33 = v3;
        if (v33 < v15)
          goto LABEL_141;
        if (v11 != v33)
        {
          v34 = v113 + 32 * v11;
          do
          {
            v35 = *(_DWORD *)(v12 + 32 * v11);
            v36 = v15;
            v37 = v34;
            do
            {
              if (v35 >= *(_DWORD *)(v37 - 56))
                break;
              if (!v12)
                goto LABEL_143;
              v38 = (_OWORD *)(v37 - 24);
              v40 = *(_OWORD *)(v37 - 56);
              v39 = *(_OWORD *)(v37 - 40);
              *(_QWORD *)(v37 - 32) = *(_QWORD *)v37;
              v37 -= 32;
              v41 = *(_WORD *)(v37 + 12);
              v42 = *(_OWORD *)(v37 + 16);
              *v38 = v40;
              v38[1] = v39;
              *(_DWORD *)(v37 - 24) = v35;
              *(_WORD *)(v37 - 20) = v41;
              *(_OWORD *)(v37 - 16) = v42;
              ++v36;
            }
            while (v11 != v36);
            ++v11;
            v34 += 32;
          }
          while (v11 != v33);
          v11 = v33;
        }
      }
    }
    if (v11 < v15)
    {
LABEL_132:
      __break(1u);
      goto LABEL_133;
    }
    if ((swift_isUniquelyReferenced_nonNull_native(v13) & 1) == 0)
      v13 = sub_1000F5C8C(0, *((_QWORD *)v13 + 2) + 1, 1, v13);
    v44 = *((_QWORD *)v13 + 2);
    v43 = *((_QWORD *)v13 + 3);
    v14 = v44 + 1;
    v12 = v119;
    if (v44 >= v43 >> 1)
    {
      v93 = sub_1000F5C8C((char *)(v43 > 1), v44 + 1, 1, v13);
      v12 = v119;
      v13 = v93;
    }
    *((_QWORD *)v13 + 2) = v14;
    v45 = v13 + 32;
    v46 = &v13[16 * v44 + 32];
    *(_QWORD *)v46 = v15;
    *((_QWORD *)v46 + 1) = v11;
    if (v44)
      break;
    v14 = 1;
LABEL_15:
    v6 = v117;
    v3 = v118;
    if (v11 >= v118)
    {
      v10 = v116;
LABEL_104:
      v95 = v13;
      v116 = v10;
      if (v14 < 2)
        goto LABEL_95;
      v107 = *v114;
      while (1)
      {
        v108 = v14 - 2;
        if (v14 < 2)
          break;
        if (!v107)
          goto LABEL_146;
        v94 = v95;
        v109 = *(_QWORD *)&v95[16 * v108 + 32];
        v110 = *(_QWORD *)&v95[16 * v14 + 24];
        sub_10008DC24((char *)(v107 + 32 * v109), (char *)(v107 + 32 * *(_QWORD *)&v95[16 * v14 + 16]), v107 + 32 * v110, __dst);
        if (v1)
          goto LABEL_94;
        if (v110 < v109)
          goto LABEL_134;
        if ((swift_isUniquelyReferenced_nonNull_native(v94) & 1) == 0)
          v94 = sub_1000F5F78((uint64_t)v94);
        if (v108 >= *((_QWORD *)v94 + 2))
          goto LABEL_135;
        v111 = &v94[16 * v108 + 32];
        *(_QWORD *)v111 = v109;
        *((_QWORD *)v111 + 1) = v110;
        v112 = *((_QWORD *)v94 + 2);
        if (v14 > v112)
          goto LABEL_136;
        memmove(&v94[16 * v14 + 16], &v94[16 * v14 + 32], 16 * (v112 - v14));
        v95 = v94;
        *((_QWORD *)v94 + 2) = v112 - 1;
        v14 = v112 - 1;
        if (v112 <= 2)
          goto LABEL_95;
      }
LABEL_133:
      __break(1u);
LABEL_134:
      __break(1u);
LABEL_135:
      __break(1u);
LABEL_136:
      __break(1u);
LABEL_137:
      __break(1u);
LABEL_138:
      __break(1u);
LABEL_139:
      __break(1u);
LABEL_140:
      __break(1u);
LABEL_141:
      __break(1u);
LABEL_142:
      __break(1u);
LABEL_143:
      __break(1u);
LABEL_144:
      __break(1u);
LABEL_145:
      __break(1u);
LABEL_146:
      __break(1u);
      goto LABEL_147;
    }
  }
  while (1)
  {
    v47 = v14 - 1;
    if (v14 >= 4)
    {
      v52 = &v45[16 * v14];
      v53 = *((_QWORD *)v52 - 8);
      v54 = *((_QWORD *)v52 - 7);
      v58 = __OFSUB__(v54, v53);
      v55 = v54 - v53;
      if (v58)
        goto LABEL_121;
      v57 = *((_QWORD *)v52 - 6);
      v56 = *((_QWORD *)v52 - 5);
      v58 = __OFSUB__(v56, v57);
      v50 = v56 - v57;
      v51 = v58;
      if (v58)
        goto LABEL_122;
      v59 = v14 - 2;
      v60 = &v45[16 * v14 - 32];
      v62 = *(_QWORD *)v60;
      v61 = *((_QWORD *)v60 + 1);
      v58 = __OFSUB__(v61, v62);
      v63 = v61 - v62;
      if (v58)
        goto LABEL_124;
      v58 = __OFADD__(v50, v63);
      v64 = v50 + v63;
      if (v58)
        goto LABEL_127;
      if (v64 >= v55)
      {
        v82 = &v45[16 * v47];
        v84 = *(_QWORD *)v82;
        v83 = *((_QWORD *)v82 + 1);
        v58 = __OFSUB__(v83, v84);
        v85 = v83 - v84;
        if (v58)
          goto LABEL_131;
        v75 = v50 < v85;
        goto LABEL_83;
      }
    }
    else
    {
      if (v14 != 3)
      {
        v76 = *((_QWORD *)v13 + 4);
        v77 = *((_QWORD *)v13 + 5);
        v58 = __OFSUB__(v77, v76);
        v69 = v77 - v76;
        v70 = v58;
        goto LABEL_77;
      }
      v49 = *((_QWORD *)v13 + 4);
      v48 = *((_QWORD *)v13 + 5);
      v58 = __OFSUB__(v48, v49);
      v50 = v48 - v49;
      v51 = v58;
    }
    if ((v51 & 1) != 0)
      goto LABEL_123;
    v59 = v14 - 2;
    v65 = &v45[16 * v14 - 32];
    v67 = *(_QWORD *)v65;
    v66 = *((_QWORD *)v65 + 1);
    v68 = __OFSUB__(v66, v67);
    v69 = v66 - v67;
    v70 = v68;
    if (v68)
      goto LABEL_126;
    v71 = &v45[16 * v47];
    v73 = *(_QWORD *)v71;
    v72 = *((_QWORD *)v71 + 1);
    v58 = __OFSUB__(v72, v73);
    v74 = v72 - v73;
    if (v58)
      goto LABEL_129;
    if (__OFADD__(v69, v74))
      goto LABEL_130;
    if (v69 + v74 >= v50)
    {
      v75 = v50 < v74;
LABEL_83:
      if (v75)
        v47 = v59;
      goto LABEL_85;
    }
LABEL_77:
    if ((v70 & 1) != 0)
      goto LABEL_125;
    v78 = &v45[16 * v47];
    v80 = *(_QWORD *)v78;
    v79 = *((_QWORD *)v78 + 1);
    v58 = __OFSUB__(v79, v80);
    v81 = v79 - v80;
    if (v58)
      goto LABEL_128;
    if (v81 < v69)
      goto LABEL_15;
LABEL_85:
    v86 = v47 - 1;
    if (v47 - 1 >= v14)
    {
      __break(1u);
LABEL_118:
      __break(1u);
LABEL_119:
      __break(1u);
LABEL_120:
      __break(1u);
LABEL_121:
      __break(1u);
LABEL_122:
      __break(1u);
LABEL_123:
      __break(1u);
LABEL_124:
      __break(1u);
LABEL_125:
      __break(1u);
LABEL_126:
      __break(1u);
LABEL_127:
      __break(1u);
LABEL_128:
      __break(1u);
LABEL_129:
      __break(1u);
LABEL_130:
      __break(1u);
LABEL_131:
      __break(1u);
      goto LABEL_132;
    }
    if (!v12)
      goto LABEL_144;
    v87 = v13;
    v88 = &v45[16 * v86];
    v89 = *(_QWORD *)v88;
    v90 = &v45[16 * v47];
    v91 = *((_QWORD *)v90 + 1);
    sub_10008DC24((char *)(v12 + 32 * *(_QWORD *)v88), (char *)(v12 + 32 * *(_QWORD *)v90), v12 + 32 * v91, __dst);
    if (v1)
      break;
    if (v91 < v89)
      goto LABEL_118;
    if (v47 > *((_QWORD *)v87 + 2))
      goto LABEL_119;
    *(_QWORD *)v88 = v89;
    *(_QWORD *)&v45[16 * v86 + 8] = v91;
    v92 = *((_QWORD *)v87 + 2);
    if (v47 >= v92)
      goto LABEL_120;
    v13 = v87;
    v14 = v92 - 1;
    memmove(&v45[16 * v47], v90 + 16, 16 * (v92 - 1 - v47));
    *((_QWORD *)v87 + 2) = v92 - 1;
    v12 = v119;
    if (v92 <= 2)
      goto LABEL_15;
  }
  v94 = v87;
LABEL_94:
  v95 = v94;
LABEL_95:
  swift_bridgeObjectRelease(v95);
  v116[2] = 0;
  swift_bridgeObjectRelease(v116);
}

uint64_t sub_10008D9A8(char *__src, char *a2, unint64_t a3, char *__dst)
{
  char *v4;
  char *v6;
  char *v7;
  int64_t v8;
  int64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  size_t v14;
  char *v15;
  char *v16;
  uint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  unsigned int v22;
  uint64_t result;
  char *v24;
  char *v25;
  char *v26;

  v4 = __dst;
  v6 = a2;
  v7 = __src;
  v8 = a2 - __src;
  v9 = a2 - __src + 7;
  if (a2 - __src >= 0)
    v9 = a2 - __src;
  v10 = v9 >> 3;
  v11 = a3 - (_QWORD)a2;
  v12 = a3 - (_QWORD)a2 + 7;
  if ((uint64_t)(a3 - (_QWORD)a2) >= 0)
    v12 = a3 - (_QWORD)a2;
  v13 = v12 >> 3;
  v25 = __dst;
  v26 = __src;
  if (v10 >= v13)
  {
    if (v11 >= -7)
    {
      v17 = 8 * v13;
      if (__dst != a2 || &a2[v17] <= __dst)
        memmove(__dst, a2, 8 * v13);
      v18 = &v4[v17];
      v24 = &v4[v17];
      v26 = v6;
      if (v7 < v6 && (unint64_t)(v11 - 8) <= 0xFFFFFFFFFFFFFFF0)
      {
        v19 = (char *)(a3 - 8);
        v20 = v6;
        while (1)
        {
          v21 = v19 + 8;
          v22 = *((_DWORD *)v20 - 2);
          v20 -= 8;
          if (*((_DWORD *)v18 - 2) >= v22)
          {
            v24 = v18 - 8;
            if (v21 < v18 || v19 >= v18 || v21 != v18)
              *(_QWORD *)v19 = *((_QWORD *)v18 - 1);
            v20 = v6;
            v18 -= 8;
            if (v6 <= v7)
              goto LABEL_42;
          }
          else
          {
            if (v21 != v6 || v19 >= v6)
              *(_QWORD *)v19 = *(_QWORD *)v20;
            v26 = v20;
            if (v20 <= v7)
              goto LABEL_42;
          }
          v19 -= 8;
          v6 = v20;
          if (v18 <= v4)
            goto LABEL_42;
        }
      }
      goto LABEL_42;
    }
  }
  else if (v8 >= -7)
  {
    v14 = 8 * v10;
    if (__dst != __src || &__src[v14] <= __dst)
      memmove(__dst, __src, v14);
    v15 = &v4[v14];
    v24 = &v4[v14];
    if ((unint64_t)v6 < a3 && (unint64_t)(v8 - 8) <= 0xFFFFFFFFFFFFFFF0)
    {
      do
      {
        if (*(_DWORD *)v6 >= *(_DWORD *)v4)
        {
          if (v7 != v4)
            *(_QWORD *)v7 = *(_QWORD *)v4;
          v4 += 8;
          v25 = v4;
          v16 = v6;
        }
        else
        {
          v16 = v6 + 8;
          if (v7 < v6 || v7 >= v16 || v7 != v6)
            *(_QWORD *)v7 = *(_QWORD *)v6;
        }
        v7 += 8;
        if (v4 >= v15)
          break;
        v6 = v16;
      }
      while ((unint64_t)v16 < a3);
      v26 = v7;
    }
LABEL_42:
    sub_1000F5D84((void **)&v26, (const void **)&v25, &v24);
    return 1;
  }
  result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.moveInitialize with negative count", 55, 2, "Swift/UnsafePointer.swift", 25, 2, 1046, 0);
  __break(1u);
  return result;
}

uint64_t sub_10008DC24(char *__src, char *a2, unint64_t a3, char *__dst)
{
  char *v4;
  char *v6;
  char *v7;
  int64_t v8;
  int64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  char *v15;
  __int128 v16;
  __int128 v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  unsigned int v22;
  __int128 v23;
  __int128 v24;
  uint64_t result;
  char *v26;
  char *v27;
  char *v28;

  v4 = __dst;
  v6 = a2;
  v7 = __src;
  v8 = a2 - __src;
  v9 = a2 - __src + 31;
  if (a2 - __src >= 0)
    v9 = a2 - __src;
  v10 = v9 >> 5;
  v11 = a3 - (_QWORD)a2;
  v12 = a3 - (_QWORD)a2 + 31;
  if ((uint64_t)(a3 - (_QWORD)a2) >= 0)
    v12 = a3 - (_QWORD)a2;
  v13 = v12 >> 5;
  v28 = __src;
  v27 = __dst;
  if (v10 >= v12 >> 5)
  {
    if (v11 >= -31)
    {
      if (__dst != a2 || &a2[32 * v13] <= __dst)
        memmove(__dst, a2, 32 * v13);
      v18 = &v4[32 * v13];
      v26 = v18;
      v28 = v6;
      if (v7 < v6 && v11 >= 32)
      {
        v19 = (char *)(a3 - 32);
        v20 = v6;
        while (1)
        {
          v21 = v19 + 32;
          v22 = *((_DWORD *)v20 - 8);
          v20 -= 32;
          if (*((_DWORD *)v18 - 8) >= v22)
          {
            v26 = v18 - 32;
            if (v21 < v18 || v19 >= v18 || v21 != v18)
            {
              v24 = *((_OWORD *)v18 - 1);
              *(_OWORD *)v19 = *((_OWORD *)v18 - 2);
              *((_OWORD *)v19 + 1) = v24;
            }
            v20 = v6;
            v18 -= 32;
            if (v6 <= v7)
              goto LABEL_42;
          }
          else
          {
            if (v21 != v6 || v19 >= v6)
            {
              v23 = *((_OWORD *)v20 + 1);
              *(_OWORD *)v19 = *(_OWORD *)v20;
              *((_OWORD *)v19 + 1) = v23;
            }
            v28 = v20;
            if (v20 <= v7)
              goto LABEL_42;
          }
          v19 -= 32;
          v6 = v20;
          if (v18 <= v4)
            goto LABEL_42;
        }
      }
      goto LABEL_42;
    }
  }
  else if (v8 >= -31)
  {
    if (__dst != __src || &__src[32 * v10] <= __dst)
      memmove(__dst, __src, 32 * v10);
    v14 = &v4[32 * v10];
    v26 = v14;
    if ((unint64_t)v6 < a3 && v8 >= 32)
    {
      do
      {
        if (*(_DWORD *)v6 >= *(_DWORD *)v4)
        {
          if (v7 != v4)
          {
            v17 = *((_OWORD *)v4 + 1);
            *(_OWORD *)v7 = *(_OWORD *)v4;
            *((_OWORD *)v7 + 1) = v17;
          }
          v4 += 32;
          v27 = v4;
          v15 = v6;
        }
        else
        {
          v15 = v6 + 32;
          if (v7 < v6 || v7 >= v15 || v7 != v6)
          {
            v16 = *((_OWORD *)v6 + 1);
            *(_OWORD *)v7 = *(_OWORD *)v6;
            *((_OWORD *)v7 + 1) = v16;
          }
        }
        v7 += 32;
        if (v4 >= v14)
          break;
        v6 = v15;
      }
      while ((unint64_t)v15 < a3);
      v28 = v7;
    }
LABEL_42:
    sub_1000F5E28((void **)&v28, (const void **)&v27, &v26);
    return 1;
  }
  result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.moveInitialize with negative count", 55, 2, "Swift/UnsafePointer.swift", 25, 2, 1046, 0);
  __break(1u);
  return result;
}

uint64_t sub_10008DE9C(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v4;
  uint64_t v9;
  uint64_t v10;
  _BYTE *v12;
  __int128 *v13;
  uint64_t v14;
  __int128 v15[2];
  uint64_t v16;
  uint64_t v17;
  char v18;
  __int128 v19;
  __int128 v20;

  v17 = a3;
  v18 = a4;
  v9 = sub_100012C44(&qword_1004066B8);
  v10 = sub_100012C44((uint64_t *)&unk_100410240);
  if (swift_dynamicCast(v15, &v17, v9, v10, 6))
  {
    sub_1000641F0(v15, (uint64_t)&v19);
    sub_10003259C(&v19, *((uint64_t *)&v20 + 1));
    __chkstk_darwin();
    dispatch thunk of ContiguousBytes.withUnsafeBytes<A>(_:)(sub_100095A70);
    return sub_100014430(&v19);
  }
  v16 = 0;
  memset(v15, 0, sizeof(v15));
  sub_100033A84((uint64_t)v15, &qword_1004066C0);
  if (a3 <= 0)
  {
    v13 = 0;
    v14 = 0;
  }
  else
  {
    if ((unint64_t)a3 > 0x20)
    {
      v12 = (_BYTE *)swift_slowAlloc(a3, -1);
      sub_10008E054(v12, a3, a3, a4, v4, a1, a2, a3);
      return swift_slowDealloc(v12, -1, -1);
    }
    v19 = 0u;
    v20 = 0u;
    v13 = &v19;
    v14 = a3;
  }
  return sub_10008E054(v13, v14, a3, a4, v4, a1, a2, a3);
}

uint64_t sub_10008E054(_BYTE *a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  result = sub_1001807E8((uint64_t)&v16, a1, a2, a3, a4);
  if (result == a2)
  {
    v14 = v17;
    v15 = v16;
    if (v17 == v16)
      return Data._Representation.replaceSubrange(_:with:count:)(a6, a7, a1, a8);
  }
  else
  {
    __break(1u);
  }
  if ((v14 & 0x8000000000000000) == 0 && v14 < v15)
    __break(1u);
  __break(1u);
  return result;
}

void sub_10008E0F8(uint64_t a1, uint64_t a2)
{
  Swift::UInt v4;
  unint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  Swift::UInt16 v8;
  __n128 v9;

  v4 = *(_QWORD *)(a2 + 16);
  Hasher._combine(_:)(v4);
  if (v4)
  {
    v5 = (unint64_t *)(a2 + 56);
    do
    {
      v6 = *(v5 - 1);
      v7 = *v5;
      v8 = *((_WORD *)v5 - 8);
      Hasher._combine(_:)(*((_BYTE *)v5 - 24));
      Hasher._combine(_:)(v8);
      sub_100031FEC(v6, v7);
      Data.hash(into:)(a1, v6, v7, v9);
      sub_10000E614(v6, v7);
      v5 += 4;
      --v4;
    }
    while (v4);
  }
}

void sub_10008E188(uint64_t a1, uint64_t a2)
{
  Swift::UInt v3;
  uint64_t v4;
  __int16 v5;
  __int16 v6;
  Swift::UInt8 v7;
  Swift::UInt8 v8;
  Swift::UInt8 v9;
  Swift::UInt8 v10;
  Swift::UInt8 v11;
  __int16 v12;
  __int16 v13;

  v3 = *(_QWORD *)(a2 + 16);
  Hasher._combine(_:)(v3);
  if (v3)
  {
    v4 = a2 + 32;
    do
    {
      v5 = *(_WORD *)(v4 + 6);
      v6 = *(_WORD *)(v4 + 8);
      v12 = *(_WORD *)(v4 + 10);
      v13 = *(_WORD *)(v4 + 12);
      v7 = *(_BYTE *)(v4 + 1);
      v8 = *(_BYTE *)(v4 + 2);
      v9 = *(_BYTE *)(v4 + 3);
      v10 = *(_BYTE *)(v4 + 4);
      v11 = *(_BYTE *)(v4 + 5);
      Hasher._combine(_:)(*(_BYTE *)v4);
      Hasher._combine(_:)(v7);
      Hasher._combine(_:)(v8);
      Hasher._combine(_:)(v9);
      Hasher._combine(_:)(v10);
      Hasher._combine(_:)(v11);
      if ((v5 & 0xFF00) == 0x2200)
      {
        Hasher._combine(_:)(0);
      }
      else
      {
        Hasher._combine(_:)(1u);
        Hasher._combine(_:)(word_10033EF4C[(char)v5]);
        Hasher._combine(_:)(*(_WORD *)((char *)&unk_10033EFB8 + (((uint64_t)v5 >> 7) & 0xFFFFFFFFFFFFFELL)));
      }
      if ((v6 & 0xFF00) == 0x2200)
      {
        Hasher._combine(_:)(0);
      }
      else
      {
        Hasher._combine(_:)(1u);
        Hasher._combine(_:)(word_10033EF4C[(char)v6]);
        Hasher._combine(_:)(*(_WORD *)((char *)&unk_10033EFB8 + (((uint64_t)v6 >> 7) & 0xFFFFFFFFFFFFFELL)));
      }
      if ((v12 & 0xFF00) == 0x2200)
      {
        Hasher._combine(_:)(0);
      }
      else
      {
        Hasher._combine(_:)(1u);
        Hasher._combine(_:)(word_10033EF4C[(char)v12]);
        Hasher._combine(_:)(*(_WORD *)((char *)&unk_10033EFB8 + (((uint64_t)v12 >> 7) & 0xFFFFFFFFFFFFFELL)));
      }
      if ((v13 & 0xFF00) == 0x2200)
      {
        Hasher._combine(_:)(0);
      }
      else
      {
        Hasher._combine(_:)(1u);
        Hasher._combine(_:)(word_10033EF4C[(char)v13]);
        Hasher._combine(_:)(*(_WORD *)((char *)&unk_10033EFB8 + (((uint64_t)v13 >> 7) & 0xFFFFFFFFFFFFFELL)));
      }
      v4 += 14;
      --v3;
    }
    while (v3);
  }
}

void sub_10008E368(uint64_t a1, uint64_t a2)
{
  Swift::UInt v3;
  Swift::UInt64 *v4;
  Swift::UInt64 v5;
  Swift::UInt64 v6;
  Swift::UInt64 v7;

  v3 = *(_QWORD *)(a2 + 16);
  Hasher._combine(_:)(v3);
  if (v3)
  {
    v4 = (Swift::UInt64 *)(a2 + 32);
    do
    {
      v6 = *v4++;
      v5 = v6;
      if ((v6 & 0x7FFFFFFFFFFFFFFFLL) != 0)
        v7 = v5;
      else
        v7 = 0;
      Hasher._combine(_:)(v7);
      --v3;
    }
    while (v3);
  }
}

void sub_10008E3BC(uint64_t a1, uint64_t a2)
{
  Swift::UInt v3;
  unsigned __int8 *v4;
  Swift::UInt16 v5;
  int v6;
  Swift::UInt16 v7;
  Swift::UInt8 v8;

  v3 = *(_QWORD *)(a2 + 16);
  Hasher._combine(_:)(v3);
  if (v3)
  {
    v4 = (unsigned __int8 *)(a2 + 40);
    do
    {
      v5 = *((_WORD *)v4 - 1);
      v6 = *v4;
      v7 = *((_WORD *)v4 - 3);
      v8 = *(v4 - 4);
      Hasher._combine(_:)(*(v4 - 8));
      Hasher._combine(_:)(v7);
      Hasher._combine(_:)(v8);
      if (v6 == 1)
      {
        Hasher._combine(_:)(0);
      }
      else
      {
        Hasher._combine(_:)(1u);
        Hasher._combine(_:)(v5);
      }
      v4 += 10;
      --v3;
    }
    while (v3);
  }
}

void sub_10008E464(uint64_t a1, uint64_t a2)
{
  Swift::UInt v3;
  unsigned __int8 *v4;
  Swift::UInt v5;
  char v6;
  int v7;

  v3 = *(_QWORD *)(a2 + 16);
  Hasher._combine(_:)(v3);
  if (v3)
  {
    v4 = (unsigned __int8 *)(a2 + 37);
    do
    {
      v6 = *(v4 - 1);
      v7 = *v4;
      Hasher._combine(_:)(*(_DWORD *)(v4 - 5));
      Hasher._combine(_:)(0x801004u >> (8 * v6));
      switch(v7)
      {
        case 2:
          v5 = 0;
          goto LABEL_4;
        case 3:
          v5 = 1;
          goto LABEL_4;
        case 4:
          v5 = 3;
          goto LABEL_4;
        case 5:
          v5 = 4;
          goto LABEL_4;
        case 6:
          v5 = 5;
LABEL_4:
          Hasher._combine(_:)(v5);
          break;
        default:
          Hasher._combine(_:)(2uLL);
          Hasher._combine(_:)(v7 & 1);
          break;
      }
      v4 += 8;
      --v3;
    }
    while (v3);
  }
}

void sub_10008E548(uint64_t a1, uint64_t a2)
{
  Swift::UInt v3;
  unsigned int *v4;
  Swift::UInt8 v5;
  unint64_t v6;

  v3 = *(_QWORD *)(a2 + 16);
  Hasher._combine(_:)(v3);
  if (v3)
  {
    v4 = (unsigned int *)(a2 + 32);
    do
    {
      v6 = *v4 | ((unint64_t)*((unsigned __int16 *)v4 + 2) << 32);
      if ((v6 & 0xFF00000000) == 0x300000000)
      {
        v5 = 0;
LABEL_4:
        Hasher._combine(_:)(v5);
      }
      else
      {
        Hasher._combine(_:)(1u);
        Hasher._combine(_:)(v6);
        Hasher._combine(_:)(0x801004u >> ((v6 >> 29) & 0xF8));
        switch(v6 >> 40)
        {
          case 2uLL:
            Hasher._combine(_:)(0);
            break;
          case 3uLL:
            Hasher._combine(_:)(1uLL);
            break;
          case 4uLL:
            Hasher._combine(_:)(3uLL);
            break;
          case 5uLL:
            Hasher._combine(_:)(4uLL);
            break;
          case 6uLL:
            Hasher._combine(_:)(5uLL);
            break;
          default:
            Hasher._combine(_:)(2uLL);
            v5 = BYTE5(v6) & 1;
            goto LABEL_4;
        }
      }
      v4 += 2;
      --v3;
    }
    while (v3);
  }
}

void sub_10008E664(uint64_t a1, uint64_t a2)
{
  Swift::UInt v3;
  Swift::UInt8 *v4;
  Swift::UInt v5;
  char v6;
  int v7;
  Swift::UInt8 v8;

  v3 = *(_QWORD *)(a2 + 16);
  Hasher._combine(_:)(v3);
  if (v3)
  {
    v4 = (Swift::UInt8 *)(a2 + 38);
    do
    {
      v6 = *(v4 - 2);
      v7 = *(v4 - 1);
      v8 = *v4;
      Hasher._combine(_:)(*(_DWORD *)(v4 - 6));
      Hasher._combine(_:)(0x801004u >> (8 * v6));
      switch(v7)
      {
        case 2:
          v5 = 0;
          goto LABEL_4;
        case 3:
          v5 = 1;
          goto LABEL_4;
        case 4:
          v5 = 3;
          goto LABEL_4;
        case 5:
          v5 = 4;
          goto LABEL_4;
        case 6:
          v5 = 5;
LABEL_4:
          Hasher._combine(_:)(v5);
          break;
        default:
          Hasher._combine(_:)(2uLL);
          Hasher._combine(_:)(v7 & 1);
          break;
      }
      v4 += 8;
      Hasher._combine(_:)(v8);
      --v3;
    }
    while (v3);
  }
}

void sub_10008E754(uint64_t a1, uint64_t a2)
{
  Swift::UInt v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  Swift::UInt8 v8;
  __n128 v9;

  v4 = *(_QWORD *)(a2 + 16);
  Hasher._combine(_:)(v4);
  if (v4)
  {
    v5 = a2 + 32;
    do
    {
      v6 = *(_QWORD *)(v5 + 8);
      v7 = *(_QWORD *)(v5 + 16);
      v8 = *(_BYTE *)(v5 + 1);
      Hasher._combine(_:)(*(_BYTE *)v5);
      Hasher._combine(_:)(v8);
      sub_100031FEC(v6, v7);
      Data.hash(into:)(a1, v6, v7, v9);
      sub_10000E614(v6, v7);
      v5 += 24;
      --v4;
    }
    while (v4);
  }
}

void NANAttribute.FineTimingMeasurementRangeReport.hash(into:)(uint64_t a1, uint64_t a2)
{
  Swift::UInt v3;
  Swift::UInt8 *v4;
  Swift::UInt32 v5;
  Swift::UInt8 v6;
  Swift::UInt8 v7;
  Swift::UInt8 v8;
  Swift::UInt8 v9;
  Swift::UInt8 v10;
  Swift::UInt8 v11;
  Swift::UInt8 v12;
  Swift::UInt8 v13;
  Swift::UInt8 v14;
  Swift::UInt8 v15;

  v3 = *(_QWORD *)(a2 + 16);
  Hasher._combine(_:)(v3);
  if (v3)
  {
    v4 = (Swift::UInt8 *)(a2 + 45);
    do
    {
      v5 = *(_DWORD *)(v4 - 13);
      v6 = *(v4 - 9);
      v7 = *(v4 - 8);
      v8 = *(v4 - 7);
      v9 = *(v4 - 6);
      v10 = *(v4 - 5);
      v11 = *(v4 - 4);
      v12 = *(v4 - 3);
      v14 = *(v4 - 2);
      v15 = *(v4 - 1);
      v13 = *v4;
      v4 += 16;
      Hasher._combine(_:)(v5);
      Hasher._combine(_:)(v6);
      Hasher._combine(_:)(v7);
      Hasher._combine(_:)(v8);
      Hasher._combine(_:)(v9);
      Hasher._combine(_:)(v10);
      Hasher._combine(_:)(v11);
      Hasher._combine(_:)(v12);
      Hasher._combine(_:)(v14);
      Hasher._combine(_:)(v15);
      Hasher._combine(_:)(v13);
      --v3;
    }
    while (v3);
  }
}

void sub_10008E8D0(uint64_t a1, uint64_t a2)
{
  Swift::UInt v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  Swift::UInt8 v10;
  uint64_t v11;
  char v12;
  __n128 v13;
  uint64_t v14;
  unsigned __int8 *v15;
  Swift::UInt16 v16;
  int v17;
  Swift::UInt16 v18;
  Swift::UInt8 v19;
  Swift::UInt8 *v20;
  Swift::UInt8 v21;
  uint64_t v22;
  Swift::UInt v23;
  uint64_t v24;
  uint64_t v25;

  v4 = *(_QWORD *)(a2 + 16);
  Hasher._combine(_:)(v4);
  v23 = v4;
  if (v4)
  {
    v5 = 0;
    v22 = a2 + 32;
    do
    {
      v6 = v22 + 56 * v5;
      v7 = *(_QWORD *)(v6 + 8);
      v8 = *(_QWORD *)(v6 + 16);
      v9 = *(_QWORD *)(v6 + 24);
      v10 = *(_BYTE *)(v6 + 32);
      v11 = *(_QWORD *)(v6 + 40);
      v12 = *(_BYTE *)(v6 + 48);
      Hasher._combine(_:)(*(_WORD *)v6);
      v25 = v7;
      if (v9 >> 60 == 15)
      {
        Hasher._combine(_:)(0);
        sub_100063C28(v7, v8, v9);
        swift_bridgeObjectRetain(v11);
      }
      else
      {
        Hasher._combine(_:)(1u);
        Hasher._combine(_:)(v7);
        sub_100063C28(v7, v8, v9);
        swift_bridgeObjectRetain(v11);
        sub_100063C28(v7, v8, v9);
        Data.hash(into:)(a1, v8, v9, v13);
        sub_1000634E8(v7, v8, v9);
      }
      Hasher._combine(_:)(v10);
      Hasher._combine(_:)(*(_QWORD *)(v11 + 16));
      v14 = *(_QWORD *)(v11 + 16);
      v24 = v8;
      if ((v12 & 1) != 0)
      {
        if (v14)
        {
          v15 = (unsigned __int8 *)(v11 + 40);
          do
          {
            v16 = *((_WORD *)v15 - 1);
            v17 = *v15;
            v18 = *((_WORD *)v15 - 3);
            v19 = *(v15 - 4);
            Hasher._combine(_:)(*(v15 - 8));
            Hasher._combine(_:)(v18);
            Hasher._combine(_:)(v19);
            if (v17 == 1)
            {
              Hasher._combine(_:)(0);
            }
            else
            {
              Hasher._combine(_:)(1u);
              Hasher._combine(_:)(v16);
            }
            v15 += 10;
            --v14;
          }
          while (v14);
        }
      }
      else if (v14)
      {
        v20 = (Swift::UInt8 *)(v11 + 32);
        do
        {
          v21 = *v20++;
          Hasher._combine(_:)(v21);
          --v14;
        }
        while (v14);
      }
      ++v5;
      sub_1000634E8(v25, v24, v9);
      swift_bridgeObjectRelease(v11);
    }
    while (v5 != v23);
  }
}

void sub_10008EAB0(uint64_t a1, uint64_t a2)
{
  Swift::UInt v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  Swift::UInt8 v8;
  Swift::UInt8 v9;
  __n128 v10;

  v4 = *(_QWORD *)(a2 + 16);
  Hasher._combine(_:)(v4);
  if (v4)
  {
    v5 = a2 + 32;
    do
    {
      v6 = *(_QWORD *)(v5 + 8);
      v7 = *(_QWORD *)(v5 + 16);
      v8 = *(_BYTE *)(v5 + 1);
      v9 = *(_BYTE *)(v5 + 2);
      Hasher._combine(_:)(*(_BYTE *)v5);
      Hasher._combine(_:)(v8);
      Hasher._combine(_:)(v9);
      sub_100031FEC(v6, v7);
      Data.hash(into:)(a1, v6, v7, v10);
      sub_10000E614(v6, v7);
      v5 += 24;
      --v4;
    }
    while (v4);
  }
}

void sub_10008EB54(uint64_t a1, uint64_t a2)
{
  Swift::UInt v3;
  Swift::UInt8 *v4;
  Swift::UInt8 v5;
  Swift::UInt8 v6;
  Swift::UInt8 v7;
  Swift::UInt8 v8;
  Swift::UInt8 v9;
  Swift::UInt8 v10;
  Swift::UInt8 v11;

  v3 = *(_QWORD *)(a2 + 16);
  Hasher._combine(_:)(v3);
  if (v3)
  {
    v4 = (Swift::UInt8 *)(a2 + 38);
    do
    {
      v5 = *(v4 - 6);
      v6 = *(v4 - 5);
      v7 = *(v4 - 4);
      v8 = *(v4 - 3);
      v9 = *(v4 - 2);
      v10 = *(v4 - 1);
      v11 = *v4;
      v4 += 7;
      Hasher._combine(_:)(v5);
      Hasher._combine(_:)(v6);
      Hasher._combine(_:)(v7);
      Hasher._combine(_:)(v8);
      Hasher._combine(_:)(v9);
      Hasher._combine(_:)(v10);
      Hasher._combine(_:)(v11);
      --v3;
    }
    while (v3);
  }
}

void sub_10008EC00(uint64_t a1, uint64_t a2)
{
  Swift::UInt v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __n128 v12;
  __n128 v13;

  v4 = *(_QWORD *)(a2 + 16);
  Hasher._combine(_:)(v4);
  if (v4)
  {
    v5 = (_QWORD *)(a2 + 80);
    do
    {
      v7 = *(v5 - 5);
      v6 = *(v5 - 4);
      v8 = *(v5 - 3);
      v9 = *(v5 - 2);
      v11 = *(v5 - 1);
      v10 = *v5;
      Hasher._combine(_:)(*((_BYTE *)v5 - 48) + 1);
      sub_100031FEC(v7, v6);
      sub_1000339F4(v8, v9);
      swift_bridgeObjectRetain(v10);
      sub_100031FEC(v7, v6);
      Data.hash(into:)(a1, v7, v6, v12);
      sub_10000E614(v7, v6);
      if (v9 >> 60 == 15)
      {
        Hasher._combine(_:)(0);
        if (v10)
          goto LABEL_9;
      }
      else
      {
        Hasher._combine(_:)(1u);
        sub_100031FEC(v8, v9);
        Data.hash(into:)(a1, v8, v9, v13);
        sub_10000E658(v8, v9);
        if (v10)
        {
LABEL_9:
          Hasher._combine(_:)(1u);
          swift_bridgeObjectRetain(v10);
          String.hash(into:)(a1, v11, v10);
          swift_bridgeObjectRelease(v10);
          goto LABEL_4;
        }
      }
      Hasher._combine(_:)(0);
LABEL_4:
      sub_10000E614(v7, v6);
      sub_10000E658(v8, v9);
      swift_bridgeObjectRelease(v10);
      v5 += 7;
      --v4;
    }
    while (v4);
  }
}

uint64_t _s7CoreP2P20NANAvailabilityEntryV23__derived_struct_equalsySbAC_ACtFZ_0(unsigned __int16 *a1, unsigned __int16 *a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  char v13;

  if (*a1 != *a2)
    return 0;
  v4 = *((_QWORD *)a1 + 1);
  v5 = *((_QWORD *)a1 + 2);
  v6 = *((_QWORD *)a1 + 3);
  v7 = *((_QWORD *)a2 + 1);
  v8 = *((_QWORD *)a2 + 2);
  v9 = *((_QWORD *)a2 + 3);
  if (v6 >> 60 != 15)
  {
    if (v9 >> 60 != 15)
    {
      if ((unsigned __int16)*((_QWORD *)a1 + 1) != (unsigned __int16)v7)
        return 0;
      sub_100063C28(*((_QWORD *)a1 + 1), v5, v6);
      sub_100063C28(v7, v8, v9);
      _s7CoreP2P6NANPMKV23__derived_struct_equalsySbAC_ACtFZ_0(v5, v6);
      v13 = v12;
      sub_1000634E8(v7, v8, v9);
      sub_1000634E8(v4, v5, v6);
      if ((v13 & 1) == 0)
        return 0;
      goto LABEL_4;
    }
LABEL_10:
    sub_100063C28(*((_QWORD *)a1 + 1), v5, v6);
    sub_100063C28(v7, v8, v9);
    sub_1000634E8(v4, v5, v6);
    sub_1000634E8(v7, v8, v9);
    return 0;
  }
  if (v9 >> 60 != 15)
    goto LABEL_10;
LABEL_4:
  if (*((unsigned __int8 *)a1 + 32) == *((unsigned __int8 *)a2 + 32))
  {
    v10 = *((_QWORD *)a1 + 5);
    v11 = *((_QWORD *)a2 + 5);
    if ((a1[24] & 1) != 0)
    {
      if ((a2[24] & 1) != 0 && (sub_100085C70(v10, v11) & 1) != 0)
        return 1;
    }
    else if ((a2[24] & 1) == 0 && sub_100085D28(v10, v11))
    {
      return 1;
    }
  }
  return 0;
}

unint64_t _s7CoreP2P20NANAvailabilityEntryV15UsagePreferenceO8rawValueAESgSi_tcfC_0(unint64_t result)
{
  if (result >= 4)
    return 4;
  return result;
}

uint64_t sub_10008EEF8(int a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;
  char *v17;
  _QWORD v18[19];
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  v7 = type metadata accessor for Data.Iterator(0);
  v8 = *(_QWORD *)(v7 - 8);
  __chkstk_darwin();
  v10 = (char *)v18 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin();
  __chkstk_darwin();
  v11 = sub_1001642CC(4u);
  v23 = 0;
  v24 = v11;
  v25 = 0;
  if (!v3)
  {
    v18[13] = v10;
    v16 = v11;
    v20 = &v25;
    v21 = v8;
    v17 = (char *)&loc_10008F078
        + dword_10009090C[_s7CoreP2P19NANIntervalDurationO8rawValueACSgs5UInt8V_tcfC_0(a1 & 7)];
    v18[16] = a3;
    v18[15] = a2;
    v18[18] = v16;
    LODWORD(v19) = a1;
    v22 = v7;
    v18[17] = 0;
    __asm { BR              X10 }
  }
  swift_errorRelease(v3);
  v12 = sub_100012C84();
  v13 = swift_allocError(&type metadata for WiFiError, v12, 0, 0);
  *(_OWORD *)v14 = xmmword_100337850;
  *(_BYTE *)(v14 + 16) = 2;
  swift_willThrow(v13);
  return sub_10000E614(a2, a3);
}

_QWORD *sub_100090A10(uint64_t a1, int a2, unint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  int64_t v5;
  _QWORD *v6;
  unsigned int v9;
  _BYTE *i;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  _QWORD *v21;
  unsigned __int16 v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char v28;
  uint64_t v29;
  char v30;
  uint64_t v31[2];
  _QWORD *v32;

  v4 = v3;
  v5 = *(_QWORD *)(a1 + 16);
  v6 = _swiftEmptyArrayStorage;
  if (v5)
  {
    v32 = _swiftEmptyArrayStorage;
    sub_100074EAC(0, v5, 0);
    v6 = _swiftEmptyArrayStorage;
    v9 = a2 & 0xFFFF00FF;
    for (i = (_BYTE *)(a1 + 80); ; i += 56)
    {
      v11 = *((_QWORD *)i - 5);
      v12 = *((_QWORD *)i - 4);
      v13 = *((_QWORD *)i - 3);
      v14 = *(i - 16);
      v15 = *((_QWORD *)i - 1);
      v16 = *i;
      v24 = *((_WORD *)i - 24);
      v25 = v11;
      v26 = v12;
      v27 = v13;
      v28 = v14;
      v29 = v15;
      v30 = v16;
      sub_100063C28(v11, v12, v13);
      swift_bridgeObjectRetain(v15);
      sub_100082008(&v24, v9, a3, v31);
      if (v4)
        break;
      v4 = 0;
      sub_1000634E8(v11, v12, v13);
      swift_bridgeObjectRelease(v15);
      v17 = v31[0];
      v18 = v31[1];
      v32 = v6;
      v20 = v6[2];
      v19 = v6[3];
      if (v20 >= v19 >> 1)
      {
        sub_100074EAC(v19 > 1, v20 + 1, 1);
        v6 = v32;
      }
      v6[2] = v20 + 1;
      v21 = &v6[2 * v20];
      v21[4] = v17;
      v21[5] = v18;
      if (!--v5)
        return v6;
    }
    sub_1000634E8(v11, v12, v13);
    swift_release(v6);
    swift_bridgeObjectRelease(v15);
  }
  return v6;
}

uint64_t sub_100090B94(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v13;
  char v14;

  v2 = sub_100012C44(&qword_100406640);
  v3 = *(_QWORD *)(v2 - 8);
  __chkstk_darwin();
  v5 = (char *)&v13 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  v6 = a1[3];
  v7 = a1[4];
  sub_10003259C(a1, v6);
  v8 = sub_100092A78();
  dispatch thunk of Decoder.container<A>(keyedBy:)(&type metadata for NANScheduleEntry.CodingKeys, &type metadata for NANScheduleEntry.CodingKeys, v8, v6, v7);
  v14 = 0;
  v9 = sub_10009584C();
  KeyedDecodingContainer.decode<A>(_:forKey:)(&v13, &type metadata for NANMapID, &v14, v2, &type metadata for NANMapID, v9);
  v10 = v13;
  v14 = 1;
  v11 = sub_100095890();
  KeyedDecodingContainer.decode<A>(_:forKey:)(&v13, &type metadata for NANBitmap.Time, &v14, v2, &type metadata for NANBitmap.Time, v11);
  (*(void (**)(char *, uint64_t))(v3 + 8))(v5, v2);
  sub_100014430(a1);
  return v10;
}

uint64_t sub_100090D20(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v13[3];
  uint64_t v14;
  uint64_t v15;

  v3 = a1[3];
  v4 = a1[4];
  v5 = (uint64_t)sub_10003259C(a1, v3);
  dispatch thunk of Decoder.singleValueContainer()(v13, v3, v4);
  if (!v1)
  {
    v6 = v14;
    v7 = v15;
    sub_10003259C(v13, v14);
    v5 = dispatch thunk of SingleValueDecodingContainer.decode(_:)(v6, v7);
    sub_100014430(v13);
    v8 = (v5 & 7) == 7 || (v5 & 7) == 0;
    if (v8 || (~(_DWORD)v5 & 5) == 0)
    {
      v9 = sub_100012C84();
      v10 = swift_allocError(&type metadata for WiFiError, v9, 0, 0);
      *(_OWORD *)v11 = xmmword_100337850;
      *(_BYTE *)(v11 + 16) = 2;
      swift_willThrow(v10);
    }
  }
  sub_100014430(a1);
  return v5;
}

uint64_t sub_100090E30(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unsigned __int16 v10;
  unsigned __int16 v11;
  uint64_t v13;
  char v14;
  char v15;

  v3 = sub_100012C44(&qword_100406630);
  v4 = *(_QWORD *)(v3 - 8);
  __chkstk_darwin();
  v6 = (char *)&v13 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = a1[3];
  v8 = a1[4];
  sub_10003259C(a1, v7);
  v9 = sub_100092B44();
  dispatch thunk of Decoder.container<A>(keyedBy:)(&type metadata for NonNANBeaconInformation.CodingKeys, &type metadata for NonNANBeaconInformation.CodingKeys, v9, v7, v8);
  if (v1)
  {
    sub_100014430(a1);
  }
  else
  {
    v15 = 0;
    v10 = KeyedDecodingContainer.decode(_:forKey:)(&v15, v3);
    v14 = 1;
    v11 = KeyedDecodingContainer.decode(_:forKey:)(&v14, v3);
    (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
    sub_100014430(a1);
    return v10 | (v11 << 16);
  }
  return v7;
}

uint64_t sub_100090F80(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unsigned __int8 v10;
  unsigned __int8 v11;
  unsigned __int8 v12;
  uint64_t v14;
  char v15;
  char v16;
  char v17;

  v3 = sub_100012C44(&qword_100406638);
  v4 = *(_QWORD *)(v3 - 8);
  __chkstk_darwin();
  v6 = (char *)&v14 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = a1[3];
  v8 = a1[4];
  sub_10003259C(a1, v7);
  v9 = sub_100092B00();
  dispatch thunk of Decoder.container<A>(keyedBy:)(&type metadata for NonNANOperatingChannelInformation.CodingKeys, &type metadata for NonNANOperatingChannelInformation.CodingKeys, v9, v7, v8);
  if (v1)
    return sub_100014430(a1);
  v17 = 0;
  v10 = KeyedDecodingContainer.decode(_:forKey:)(&v17, v3);
  v16 = 1;
  v11 = KeyedDecodingContainer.decode(_:forKey:)(&v16, v3);
  v15 = 2;
  v12 = KeyedDecodingContainer.decode(_:forKey:)(&v15, v3);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  sub_100014430(a1);
  return (unsigned __int16)(v11 << 8) | (v12 << 16) | v10;
}

uint64_t sub_1000910FC(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char v23;
  __n128 v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  _QWORD v34[3];
  uint64_t v35;
  uint64_t v36;
  char v37;

  v3 = type metadata accessor for CodingUserInfoKey(0);
  v4 = *(_QWORD *)(v3 - 8);
  __chkstk_darwin();
  v6 = (char *)&v30 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = a1[3];
  v8 = a1[4];
  sub_10003259C(a1, v7);
  dispatch thunk of Decoder.unkeyedContainer()(v34, v7, v8);
  if (v1)
    return sub_100014430(a1);
  v9 = v35;
  v10 = v36;
  sub_100034C68((uint64_t)v34, v35);
  UnkeyedDecodingContainer.inferredDecode<A>()(v9, (uint64_t)&type metadata for UInt8, v10, (uint64_t)&protocol witness table for UInt8);
  v11 = v32;
  v12 = v35;
  v13 = v36;
  sub_100034C68((uint64_t)v34, v35);
  UnkeyedDecodingContainer.inferredDecode<A>()(v12, (uint64_t)&type metadata for UInt16, v13, (uint64_t)&protocol witness table for UInt16);
  v14 = (unsigned __int16)v32;
  v15 = v35;
  v16 = v36;
  sub_100034C68((uint64_t)v34, v35);
  UnkeyedDecodingContainer.inferredDecode<A>()(v15, (uint64_t)&type metadata for UInt8, v16, (uint64_t)&protocol witness table for UInt8);
  v30 = v32;
  v31 = v11;
  v18 = a1[3];
  v19 = a1[4];
  sub_10003259C(a1, v18);
  v20 = dispatch thunk of Decoder.userInfo.getter(v18, v19);
  if (qword_100403F40 != -1)
    swift_once(&qword_100403F40, sub_1000C8B68);
  v21 = sub_100014C44(v3, (uint64_t)static CodingUserInfoKey.channelInformationHasAuxillaryBitmap);
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))(v6, v21, v3);
  if (*(_QWORD *)(v20 + 16) && (v22 = sub_10002DA48((uint64_t)v6), (v23 & 1) != 0))
  {
    sub_100014450(*(_QWORD *)(v20 + 56) + 32 * v22, (uint64_t)&v32);
  }
  else
  {
    v32 = 0u;
    v33 = 0u;
  }
  v24 = swift_bridgeObjectRelease(v20);
  (*(void (**)(char *, uint64_t, __n128))(v4 + 8))(v6, v3, v24);
  if (!*((_QWORD *)&v33 + 1))
  {
    sub_100033A84((uint64_t)&v32, &qword_100405050);
LABEL_15:
    v29 = 0;
    goto LABEL_16;
  }
  if ((swift_dynamicCast(&v37, &v32, (char *)&type metadata for Any + 8, &type metadata for Bool, 6) & 1) == 0
    || v37 != 1)
  {
    goto LABEL_15;
  }
  v25 = v35;
  v26 = v36;
  sub_100034C68((uint64_t)v34, v35);
  v27 = sub_100012C44(&qword_1004066D8);
  v28 = sub_100095AF8();
  UnkeyedDecodingContainer.inferredDecode<A>()(v25, v27, v26, v28);
  v29 = (unint64_t)(unsigned __int16)v32 << 48;
LABEL_16:
  sub_100014430(v34);
  sub_100014430(a1);
  return v31 | (v14 << 16) | (v30 << 32) | v29;
}

uint64_t sub_100091430(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int16 v13;
  _QWORD v14[3];
  uint64_t v15;
  uint64_t v16;

  v3 = a1[3];
  v4 = a1[4];
  sub_10003259C(a1, v3);
  dispatch thunk of Decoder.unkeyedContainer()(v14, v3, v4);
  if (!v1)
  {
    v5 = v15;
    v6 = v16;
    sub_100034C68((uint64_t)v14, v15);
    v7 = sub_100095AB4();
    UnkeyedDecodingContainer.inferredDecode<A>()(v5, (uint64_t)&type metadata for NANBitmap.Time.Control, v6, v7);
    v3 = v13;
    v8 = sub_100012C44(&qword_100406180);
    v9 = v15;
    v10 = v16;
    sub_100034C68((uint64_t)v14, v15);
    v11 = sub_100011770(&qword_1004066D0, &qword_100406180, protocol conformance descriptor for LengthValue<A>);
    dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)(v8, v8, v11, v9, v10);
    sub_100014430(v14);
  }
  sub_100014430(a1);
  return v3;
}

unint64_t sub_100091588()
{
  unint64_t result;

  result = qword_1004062B0;
  if (!qword_1004062B0)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANBitmap.Time.Control, &type metadata for NANBitmap.Time.Control);
    atomic_store(result, (unint64_t *)&qword_1004062B0);
  }
  return result;
}

uint64_t sub_1000915CC(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD v17[3];
  uint64_t v18;
  uint64_t v19;
  char v20;

  v3 = a1[3];
  v4 = a1[4];
  sub_10003259C(a1, v3);
  dispatch thunk of Decoder.unkeyedContainer()(v17, v3, v4);
  if (!v1)
  {
    v5 = v18;
    v6 = v19;
    sub_100034C68((uint64_t)v17, v18);
    v7 = sub_1000957C4();
    UnkeyedDecodingContainer.inferredDecode<A>()(v5, (uint64_t)&type metadata for NANIntervalDuration, v6, v7);
    LOBYTE(v6) = v20;
    v8 = v18;
    v9 = v19;
    sub_100034C68((uint64_t)v17, v18);
    UnkeyedDecodingContainer.inferredDecode<A>()(v8, (uint64_t)&type metadata for UInt8, v9, (uint64_t)&protocol witness table for UInt8);
    v10 = v18;
    v11 = v19;
    sub_100034C68((uint64_t)v17, v18);
    UnkeyedDecodingContainer.inferredDecode<A>()(v10, (uint64_t)&type metadata for UInt8, v11, (uint64_t)&protocol witness table for UInt8);
    v12 = NANIntervalDuration.deprecatedAvailabilityMapSize.getter(v6);
    v13 = v18;
    v14 = v19;
    sub_100034C68((uint64_t)v17, v18);
    UnkeyedDecodingContainer.decodeData(with:)(v12, v13, v14);
    __asm { BR              X10 }
  }
  return sub_100014430(a1);
}

void sub_1000917A0(uint64_t a1, ...)
{
  uint64_t v1;
  _QWORD *v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  va_list va;

  va_start(va, a1);
  v4 = Data.subdata(in:)(0, BYTE6(v3), v1, v3);
  v6 = v5;
  sub_10000E614(v1, v3);
  sub_100031FEC(v4, v6);
  sub_10000E614(v1, v3);
  sub_100014430((uint64_t *)va);
  sub_100014430(v2);
  sub_10000E614(v4, v6);
  JUMPOUT(0x100091748);
}

uint64_t sub_10009184C(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unsigned __int8 v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD v17[3];
  uint64_t v18;
  uint64_t v19;
  unsigned __int8 v20;

  v3 = a1[3];
  v4 = a1[4];
  sub_10003259C(a1, v3);
  dispatch thunk of Decoder.unkeyedContainer()(v17, v3, v4);
  if (!v1)
  {
    v5 = v18;
    v6 = v19;
    sub_100034C68((uint64_t)v17, v18);
    v7 = sub_100095808();
    UnkeyedDecodingContainer.inferredDecode<A>()(v5, (uint64_t)&type metadata for DeprecatedNANAvailability.AvailabilityControl, v6, v7);
    v8 = _s7CoreP2P19NANIntervalDurationO8rawValueACSgs5UInt8V_tcfC_0((v20 >> 4) & 3);
    if (v8 != 4)
    {
      v12 = NANIntervalDuration.deprecatedAvailabilityMapSize.getter(v8);
      v13 = v18;
      v14 = v19;
      sub_100034C68((uint64_t)v17, v18);
      UnkeyedDecodingContainer.decodeData(with:)(v12, v13, v14);
      __asm { BR              X10 }
    }
    v9 = sub_100012C84();
    v10 = swift_allocError(&type metadata for WiFiError, v9, 0, 0);
    *(_OWORD *)v11 = xmmword_100337850;
    *(_BYTE *)(v11 + 16) = 2;
    swift_willThrow(v10);
    sub_100014430(v17);
  }
  return sub_100014430(a1);
}

void sub_1000919EC(uint64_t a1, ...)
{
  _QWORD *v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  va_list va;

  va_start(va, a1);
  v4 = Data.subdata(in:)(0, BYTE6(v3), v2, v3);
  v6 = v5;
  sub_10000E614(v2, v3);
  sub_100031FEC(v4, v6);
  sub_10000E614(v2, v3);
  sub_100014430((uint64_t *)va);
  sub_100014430(v1);
  sub_10000E614(v4, v6);
  JUMPOUT(0x10009198CLL);
}

void sub_100091A9C(uint64_t a1, unint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  _QWORD *v6;

  v4 = a2 >> 62;
  sub_100031FEC(a1, a2);
  sub_10001F11C((uint64_t)_swiftEmptyArrayStorage);
  v5 = type metadata accessor for BinaryDecoder();
  v6 = (_QWORD *)swift_allocObject(v5, 48, 7);
  v6[5] = &_swiftEmptyDictionarySingleton;
  v6[2] = a1;
  v6[3] = a2;
  __asm { BR              X10 }
}

void sub_100091B28(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  ValueMetadata *v16;
  unint64_t v17;
  unint64_t v18;
  ValueMetadata *v19;
  unint64_t v20;
  unsigned __int16 v21;
  uint64_t v22;
  unsigned __int16 v23;
  uint64_t v24;
  unint64_t v25;
  _QWORD v26[3];
  ValueMetadata *v27;
  unint64_t v28;
  uint64_t v29;

  *(_QWORD *)(v5 + 32) = (int)v3;
  swift_beginAccess(a1, &v29, 1, 0);
  *(_QWORD *)(v5 + 40) = v1;
  ((void (*)())swift_bridgeObjectRelease)();
  v27 = &type metadata for BinaryDecoder.UnkeyedContainer;
  v8 = sub_10007BA38();
  v28 = v8;
  v26[0] = v5;
  sub_100034C68((uint64_t)v26, (uint64_t)&type metadata for BinaryDecoder.UnkeyedContainer);
  v9 = sub_1000958D4();
  swift_retain();
  UnkeyedDecodingContainer.inferredDecode<A>()((uint64_t)&type metadata for BinaryDecoder.UnkeyedContainer, (uint64_t)&type metadata for NANAvailabilityEntry.Control, v8, v9);
  if (v4)
    goto LABEL_7;
  if ((~v23 & 5) == 0)
  {
    v10 = sub_100012C84();
    v11 = swift_allocError(&type metadata for WiFiError, v10, 0, 0);
    *(_OWORD *)v12 = xmmword_100337850;
    *(_BYTE *)(v12 + 16) = 2;
    swift_willThrow(v11);
LABEL_7:
    sub_10000E614(v3, v2);
    swift_release(v5);
    sub_100014430(v26);
    sub_1000634E8(0, 0, 0xF000000000000000);
    return;
  }
  if ((v23 & 0x1000) != 0)
  {
    v16 = v27;
    v17 = v28;
    sub_100034C68((uint64_t)v26, (uint64_t)v27);
    v18 = sub_100095890();
    dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)(&type metadata for NANBitmap.Time, &type metadata for NANBitmap.Time, v18, v16, v17);
    v21 = v23;
    v22 = v6;
    v13 = v23;
    v14 = v24;
    v15 = v25;
  }
  else
  {
    v21 = v23;
    v22 = v6;
    v13 = 0;
    v14 = 0;
    v15 = 0xF000000000000000;
  }
  v19 = v27;
  *(_QWORD *)(v7 - 72) = v28;
  sub_100034C68((uint64_t)v26, (uint64_t)v19);
  v20 = sub_100095918();
  UnkeyedDecodingContainer.inferredDecode<A>()((uint64_t)v19, (uint64_t)&type metadata for NANAvailabilityEntry.BandChannelEntries, *(_QWORD *)(v7 - 72), v20);
  sub_10000E614(v3, v2);
  swift_release(v5);
  ((void (*)())swift_bridgeObjectRetain)();
  sub_100014430(v26);
  sub_100063C28(v13, v14, v15);
  sub_1000634E8(v13, v14, v15);
  ((void (*)())swift_bridgeObjectRelease)();
  *(_WORD *)v22 = v21;
  *(_QWORD *)(v22 + 8) = v13;
  *(_QWORD *)(v22 + 16) = v14;
  *(_QWORD *)(v22 + 24) = v15;
  *(_BYTE *)(v22 + 32) = v23;
  *(_QWORD *)(v22 + 40) = v24;
  *(_BYTE *)(v22 + 48) = v25;
}

uint64_t sub_100091D9C@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  __int128 v12;
  uint64_t v13;
  unint64_t v14;
  _QWORD v15[3];
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  char v21;

  v5 = a1[3];
  v6 = a1[4];
  sub_10003259C(a1, v5);
  dispatch thunk of Decoder.unkeyedContainer()(v15, v5, v6);
  if (v2)
    return sub_100014430(a1);
  v7 = sub_100012C44(&qword_100406668);
  v8 = v16;
  v9 = v17;
  sub_100034C68((uint64_t)v15, v16);
  v10 = sub_100011770(&qword_100406670, &qword_100406668, protocol conformance descriptor for LengthValue<A>);
  dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)(v7, v7, v10, v8, v9);
  sub_100091A9C(v13, v14);
  sub_100014430(v15);
  result = sub_100014430(a1);
  v12 = v19;
  *(_OWORD *)a2 = v18;
  *(_OWORD *)(a2 + 16) = v12;
  *(_OWORD *)(a2 + 32) = v20;
  *(_BYTE *)(a2 + 48) = v21;
  return result;
}

uint64_t sub_100091ED8(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void (*v18)(char *, uint64_t, uint64_t);
  unint64_t v19;
  char v20;
  __n128 v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void (*v27)(char *, uint64_t, uint64_t);
  _BYTE v28[24];
  _QWORD v29[4];
  _BYTE v30[40];
  _OWORD v31[2];
  _QWORD v32[3];
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;

  v3 = type metadata accessor for CodingUserInfoKey(0);
  v4 = *(_QWORD *)(v3 - 8);
  __chkstk_darwin();
  v6 = (char *)&v26 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin();
  v8 = (char *)&v26 - v7;
  v9 = a1[3];
  v10 = a1[4];
  sub_10003259C(a1, v9);
  dispatch thunk of Decoder.unkeyedContainer()(v32, v9, v10);
  if (v1)
  {
    sub_100014430(a1);
  }
  else
  {
    v11 = v33;
    v12 = v34;
    sub_100034C68((uint64_t)v32, v33);
    v13 = sub_10009595C();
    UnkeyedDecodingContainer.inferredDecode<A>()(v11, (uint64_t)&type metadata for NANAvailabilityEntry.BandChannelEntries.Control, v12, v13);
    v9 = v30[0];
    if ((v30[0] & 1) != 0)
    {
      v35 = (unint64_t)v30[0] >> 4;
      v15 = a1[3];
      v27 = (void (*)(char *, uint64_t, uint64_t))a1[4];
      sub_10003259C(a1, v15);
      v16 = dispatch thunk of Decoder.userInfo.getter(v15, v27);
      if (qword_100403F40 != -1)
        swift_once(&qword_100403F40, sub_1000C8B68);
      v17 = sub_100014C44(v3, (uint64_t)static CodingUserInfoKey.channelInformationHasAuxillaryBitmap);
      v18 = *(void (**)(char *, uint64_t, uint64_t))(v4 + 16);
      v26 = v17;
      v27 = v18;
      ((void (*)(char *))v18)(v8);
      if (*(_QWORD *)(v16 + 16) && (v19 = sub_10002DA48((uint64_t)v8), (v20 & 1) != 0))
        sub_100014450(*(_QWORD *)(v16 + 56) + 32 * v19, (uint64_t)v31);
      else
        memset(v31, 0, sizeof(v31));
      v21 = swift_bridgeObjectRelease(v16);
      (*(void (**)(char *, uint64_t, __n128))(v4 + 8))(v8, v3, v21);
      sub_100031D80((uint64_t)a1, (uint64_t)v30);
      v22 = sub_100012C44(&qword_100406690);
      v23 = type metadata accessor for BinaryDecoder();
      if ((swift_dynamicCast(v29, v30, v22, v23, 6) & 1) != 0)
      {
        v24 = v29[0];
        v27(v6, v26, v3);
        v29[3] = &type metadata for Bool;
        LOBYTE(v29[0]) = (v9 & 2) != 0;
        swift_beginAccess(v24 + 40, v28, 33, 0);
        sub_1000253A8((uint64_t)v29, (uint64_t)v6);
        swift_endAccess(v28);
        swift_release(v24);
      }
      sub_10007BC7C(0, v35, (uint64_t)v32);
      sub_100031D80((uint64_t)a1, (uint64_t)v30);
      if ((swift_dynamicCast(v29, v30, v22, v23, 6) & 1) != 0)
      {
        v25 = v29[0];
        v27(v6, v26, v3);
        sub_1000959A0((uint64_t)v31, (uint64_t)v29);
        swift_beginAccess(v25 + 40, v28, 33, 0);
        sub_1000253A8((uint64_t)v29, (uint64_t)v6);
        swift_endAccess(v28);
        swift_release(v25);
      }
      sub_100033A84((uint64_t)v31, &qword_100405050);
    }
    else
    {
      sub_10007BB1C(0, (unint64_t)v30[0] >> 4, (uint64_t)v32);
    }
    sub_100014430(v32);
    sub_100014430(a1);
  }
  return v9;
}

uint64_t sub_10009229C(uint64_t a1, unint64_t a2)
{
  unint64_t v5;
  unint64_t v7;
  unint64_t v8;
  char v9;

  if (a1 == 0x6E6974617265706FLL && a2 == 0xEE007373616C4367)
  {
    v5 = 0xEE007373616C4367;
    goto LABEL_8;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6E6974617265706FLL, 0xEE007373616C4367, a1, a2, 0) & 1) != 0)
  {
    v5 = a2;
LABEL_8:
    swift_bridgeObjectRelease(v5);
    return 0;
  }
  if (a1 == 0x426C656E6E616863 && a2 == 0xED000070616D7469)
  {
    v7 = 0xED000070616D7469;
LABEL_14:
    swift_bridgeObjectRelease(v7);
    return 1;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x426C656E6E616863, 0xED000070616D7469, a1, a2, 0) & 1) != 0)
  {
    v7 = a2;
    goto LABEL_14;
  }
  if (a1 == 0xD000000000000014)
  {
    v8 = 0x8000000100364570;
    if (a2 == 0x8000000100364570)
      goto LABEL_19;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000014, 0x8000000100364570, a1, a2, 0) & 1) != 0)
  {
    v8 = a2;
LABEL_19:
    swift_bridgeObjectRelease(v8);
    return 2;
  }
  if (a1 == 0xD000000000000016 && a2 == 0x8000000100364590)
  {
    swift_bridgeObjectRelease(0x8000000100364590);
    return 3;
  }
  else
  {
    v9 = _stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000016, 0x8000000100364590, a1, a2, 0);
    swift_bridgeObjectRelease(a2);
    if ((v9 & 1) != 0)
      return 3;
    else
      return 4;
  }
}

unint64_t sub_100092490(unint64_t a1)
{
  uint64_t v1;
  unint64_t result;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  uint64_t v8;

  result = NANIntervalDuration.timeUnits.getter(0);
  if (!result)
  {
    __break(1u);
    goto LABEL_9;
  }
  v4 = a1 / result;
  if (((a1 / result) & 0x8000000000000000) != 0)
  {
LABEL_9:
    __break(1u);
    goto LABEL_10;
  }
  v6 = *(_QWORD *)(v1 + 16);
  v5 = v1 + 16;
  v8 = v6;
  result = NANIntervalDuration.timeUnits.getter(0);
  if (!result)
  {
LABEL_10:
    __break(1u);
    goto LABEL_11;
  }
  if (((a1 / result) & 0x8000000000000000) != 0)
  {
LABEL_11:
    __break(1u);
    goto LABEL_12;
  }
  v7 = *((_BYTE *)&v8 + ((a1 / result) >> 3));
  result = NANIntervalDuration.timeUnits.getter(0);
  if (!result)
  {
LABEL_12:
    __break(1u);
    goto LABEL_13;
  }
  if (((a1 / result) & 0x8000000000000000) == 0)
  {
    *(_BYTE *)(v5 + ((a1 / result) >> 3)) = v7 | (1 << (v4 & 7));
    return result;
  }
LABEL_13:
  __break(1u);
  return result;
}

uint64_t sub_10009253C(unint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t result;
  BOOL v5;
  char v6;

  v3 = a3 - a1;
  if (a3 < a1)
  {
    __break(1u);
    goto LABEL_14;
  }
  if (a2 <= 0)
  {
    if (v3 < 0x80)
    {
      if (a2 < 0)
        return 0;
      goto LABEL_11;
    }
  }
  else
  {
    if (a2 > v3 >> 7)
      return 0;
    if (!((unint64_t)a2 >> 57))
      goto LABEL_11;
    __break(1u);
  }
  if (a2 < 0)
  {
LABEL_15:
    v6 = 2;
    result = _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, v6, 3451, 0);
    __break(1u);
    return result;
  }
LABEL_11:
  v5 = __CFADD__(a1, a2 << 7);
  result = a1 + (a2 << 7);
  if (v5)
  {
LABEL_14:
    __break(1u);
    goto LABEL_15;
  }
  return result;
}

uint64_t sub_1000925EC(unint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t result;
  BOOL v5;
  char v6;

  v3 = a3 - a1;
  if (a3 < a1)
  {
    __break(1u);
    goto LABEL_14;
  }
  if (a2 <= 0)
  {
    if (v3 < 0x10)
    {
      if (a2 < 0)
        return 0;
      goto LABEL_11;
    }
  }
  else
  {
    if (a2 > v3 >> 4)
      return 0;
    if (!((unint64_t)a2 >> 60))
      goto LABEL_11;
    __break(1u);
  }
  if (a2 < 0)
  {
LABEL_15:
    v6 = 2;
    result = _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, v6, 3451, 0);
    __break(1u);
    return result;
  }
LABEL_11:
  v5 = __CFADD__(a1, 16 * a2);
  result = a1 + 16 * a2;
  if (v5)
  {
LABEL_14:
    __break(1u);
    goto LABEL_15;
  }
  return result;
}

uint64_t _s7CoreP2P10TimeBitmapV14repeatingPerDWyA2C4SlotV_A3FtFZ_0(char a1, char a2, char a3, char a4)
{
  int v8;
  unint64_t v9;
  unint64_t v10;
  int64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;

  if (qword_100403F00 != -1)
    swift_once(&qword_100403F00, sub_10007D6E8);
  v8 = (unsigned __int16)static NANBitmap.Time.Control.perDiscoveryWindow;
  sub_100074F24(0, 4, 0);
  v10 = _swiftEmptyArrayStorage[2];
  v9 = _swiftEmptyArrayStorage[3];
  v11 = v9 >> 1;
  v12 = v10 + 1;
  if (v9 >> 1 <= v10)
  {
    sub_100074F24(v9 > 1, v10 + 1, 1);
    v9 = _swiftEmptyArrayStorage[3];
    v11 = v9 >> 1;
  }
  _swiftEmptyArrayStorage[2] = v12;
  *((_BYTE *)&_swiftEmptyArrayStorage[4] + v10) = a1;
  v13 = v10 + 2;
  if (v11 < (uint64_t)(v10 + 2))
  {
    sub_100074F24(v9 > 1, v10 + 2, 1);
    v9 = _swiftEmptyArrayStorage[3];
    v11 = v9 >> 1;
  }
  _swiftEmptyArrayStorage[2] = v13;
  *((_BYTE *)&_swiftEmptyArrayStorage[4] + v12) = a2;
  v14 = v10 + 3;
  if (v11 < (uint64_t)(v10 + 3))
    sub_100074F24(v9 > 1, v10 + 3, 1);
  _swiftEmptyArrayStorage[2] = v14;
  *((_BYTE *)&_swiftEmptyArrayStorage[4] + v13) = a3;
  v15 = _swiftEmptyArrayStorage[3];
  if ((uint64_t)(v10 + 4) > (uint64_t)(v15 >> 1))
    sub_100074F24(v15 > 1, v10 + 4, 1);
  _swiftEmptyArrayStorage[2] = v10 + 4;
  *((_BYTE *)&_swiftEmptyArrayStorage[4] + v14) = a4;
  v16 = sub_1001068EC((uint64_t)_swiftEmptyArrayStorage);
  v18 = v17;
  swift_release(_swiftEmptyArrayStorage);
  return sub_10008EEF8(v8, v16, v18);
}

unint64_t sub_100092884()
{
  unint64_t result;

  result = qword_1004062C0;
  if (!qword_1004062C0)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANAvailabilityEntry.BandChannelEntries.Control, &type metadata for NANAvailabilityEntry.BandChannelEntries.Control);
    atomic_store(result, (unint64_t *)&qword_1004062C0);
  }
  return result;
}

unint64_t sub_1000928C8()
{
  unint64_t result;

  result = qword_1004062D8;
  if (!qword_1004062D8)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANBitmap.Channel, &type metadata for NANBitmap.Channel);
    atomic_store(result, (unint64_t *)&qword_1004062D8);
  }
  return result;
}

unint64_t sub_10009290C()
{
  unint64_t result;

  result = qword_1004062F0;
  if (!qword_1004062F0)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANBitmap.Band, &type metadata for NANBitmap.Band);
    atomic_store(result, (unint64_t *)&qword_1004062F0);
  }
  return result;
}

unint64_t sub_100092950()
{
  unint64_t result;

  result = qword_1004062F8;
  if (!qword_1004062F8)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANAvailabilityEntry.Control, &type metadata for NANAvailabilityEntry.Control);
    atomic_store(result, (unint64_t *)&qword_1004062F8);
  }
  return result;
}

uint64_t sub_100092994(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = sub_100012C44(&qword_100406300);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 - 8) + 32))(a2, a1, v4);
  return a2;
}

uint64_t sub_1000929DC(uint64_t a1)
{
  sub_100063C28(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16));
  return a1;
}

unint64_t sub_100092A08()
{
  unint64_t result;

  result = qword_100406308;
  if (!qword_100406308)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANBitmap.Time, &type metadata for NANBitmap.Time);
    atomic_store(result, (unint64_t *)&qword_100406308);
  }
  return result;
}

uint64_t sub_100092A4C(uint64_t a1)
{
  sub_1000634E8(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16));
  return a1;
}

unint64_t sub_100092A78()
{
  unint64_t result;

  result = qword_100406318;
  if (!qword_100406318)
  {
    result = swift_getWitnessTable(&unk_10033EE9C, &type metadata for NANScheduleEntry.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406318);
  }
  return result;
}

unint64_t sub_100092ABC()
{
  unint64_t result;

  result = qword_100406320;
  if (!qword_100406320)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANMapID, &type metadata for NANMapID);
    atomic_store(result, (unint64_t *)&qword_100406320);
  }
  return result;
}

unint64_t sub_100092B00()
{
  unint64_t result;

  result = qword_100406330;
  if (!qword_100406330)
  {
    result = swift_getWitnessTable(&unk_10033EE4C, &type metadata for NonNANOperatingChannelInformation.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406330);
  }
  return result;
}

unint64_t sub_100092B44()
{
  unint64_t result;

  result = qword_100406340;
  if (!qword_100406340)
  {
    result = swift_getWitnessTable(&unk_10033EDFC, &type metadata for NonNANBeaconInformation.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406340);
  }
  return result;
}

unint64_t sub_100092B88()
{
  unint64_t result;

  result = qword_100406348;
  if (!qword_100406348)
  {
    result = swift_getWitnessTable(&unk_10033EDD4, &type metadata for DeprecatedNANAvailability.AvailabilityControl);
    atomic_store(result, (unint64_t *)&qword_100406348);
  }
  return result;
}

unint64_t sub_100092BCC()
{
  unint64_t result;

  result = qword_100406358;
  if (!qword_100406358)
  {
    result = swift_getWitnessTable(&unk_10033ED84, &type metadata for DeprecatedNANAvailabilityEntry.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406358);
  }
  return result;
}

unint64_t sub_100092C10()
{
  unint64_t result;

  result = qword_100406360;
  if (!qword_100406360)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANIntervalDuration, &type metadata for NANIntervalDuration);
    atomic_store(result, (unint64_t *)&qword_100406360);
  }
  return result;
}

unint64_t sub_100092C58()
{
  unint64_t result;

  result = qword_100406368;
  if (!qword_100406368)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANBitmap.Band, &type metadata for NANBitmap.Band);
    atomic_store(result, (unint64_t *)&qword_100406368);
  }
  return result;
}

unint64_t sub_100092CA0()
{
  unint64_t result;

  result = qword_100406370;
  if (!qword_100406370)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANBitmap.Band, &type metadata for NANBitmap.Band);
    atomic_store(result, (unint64_t *)&qword_100406370);
  }
  return result;
}

unint64_t sub_100092CE8()
{
  unint64_t result;

  result = qword_100406378;
  if (!qword_100406378)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANBitmap.Band, &type metadata for NANBitmap.Band);
    atomic_store(result, (unint64_t *)&qword_100406378);
  }
  return result;
}

unint64_t sub_100092D30()
{
  unint64_t result;

  result = qword_100406380;
  if (!qword_100406380)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANBitmap.Band.Iterator, &type metadata for NANBitmap.Band.Iterator);
    atomic_store(result, (unint64_t *)&qword_100406380);
  }
  return result;
}

unint64_t sub_100092D78()
{
  unint64_t result;

  result = qword_100406388;
  if (!qword_100406388)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANBitmap.Band, &type metadata for NANBitmap.Band);
    atomic_store(result, (unint64_t *)&qword_100406388);
  }
  return result;
}

unint64_t sub_100092DC0()
{
  unint64_t result;

  result = qword_100406390;
  if (!qword_100406390)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANBitmap.Channel, &type metadata for NANBitmap.Channel);
    atomic_store(result, (unint64_t *)&qword_100406390);
  }
  return result;
}

unint64_t sub_100092E08()
{
  unint64_t result;

  result = qword_100406398;
  if (!qword_100406398)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANBitmap.Time.Control, &type metadata for NANBitmap.Time.Control);
    atomic_store(result, (unint64_t *)&qword_100406398);
  }
  return result;
}

unint64_t sub_100092E50()
{
  unint64_t result;

  result = qword_1004063A0;
  if (!qword_1004063A0)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANBitmap.Time.Control, &type metadata for NANBitmap.Time.Control);
    atomic_store(result, (unint64_t *)&qword_1004063A0);
  }
  return result;
}

unint64_t sub_100092E98()
{
  unint64_t result;

  result = qword_1004063A8;
  if (!qword_1004063A8)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANBitmap.Time.Control, &type metadata for NANBitmap.Time.Control);
    atomic_store(result, (unint64_t *)&qword_1004063A8);
  }
  return result;
}

unint64_t sub_100092EE0()
{
  unint64_t result;

  result = qword_1004063B0;
  if (!qword_1004063B0)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANBitmap.Time.Control, &type metadata for NANBitmap.Time.Control);
    atomic_store(result, (unint64_t *)&qword_1004063B0);
  }
  return result;
}

unint64_t sub_100092F28()
{
  unint64_t result;

  result = qword_1004063B8;
  if (!qword_1004063B8)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANBitmap.Time, &type metadata for NANBitmap.Time);
    atomic_store(result, (unint64_t *)&qword_1004063B8);
  }
  return result;
}

unint64_t sub_100092F70()
{
  unint64_t result;

  result = qword_1004063C0;
  if (!qword_1004063C0)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for TimeBitmap.Slot, &type metadata for TimeBitmap.Slot);
    atomic_store(result, (unint64_t *)&qword_1004063C0);
  }
  return result;
}

unint64_t sub_100092FB8()
{
  unint64_t result;

  result = qword_1004063C8;
  if (!qword_1004063C8)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for TimeBitmap.SlotsView, &type metadata for TimeBitmap.SlotsView);
    atomic_store(result, (unint64_t *)&qword_1004063C8);
  }
  return result;
}

uint64_t sub_100092FFC()
{
  return sub_1000934A0(&qword_1004063D0, &qword_1004063D8, (uint64_t (*)(void))sub_100093030, (const char *)&protocol conformance descriptor for <> DefaultIndices<A>);
}

unint64_t sub_100093030()
{
  unint64_t result;

  result = qword_1004063E0;
  if (!qword_1004063E0)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for TimeBitmap.SlotsView, &type metadata for TimeBitmap.SlotsView);
    atomic_store(result, (unint64_t *)&qword_1004063E0);
  }
  return result;
}

uint64_t sub_100093074()
{
  return sub_1000934A0(&qword_1004063E8, &qword_1004063F0, (uint64_t (*)(void))sub_100093030, (const char *)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t sub_1000930AC()
{
  unint64_t result;

  result = qword_1004063F8;
  if (!qword_1004063F8)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for TimeBitmap.SlotsView, &type metadata for TimeBitmap.SlotsView);
    atomic_store(result, (unint64_t *)&qword_1004063F8);
  }
  return result;
}

unint64_t sub_1000930F4()
{
  unint64_t result;

  result = qword_100406400;
  if (!qword_100406400)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for TimeBitmap.SlotsView, &type metadata for TimeBitmap.SlotsView);
    atomic_store(result, (unint64_t *)&qword_100406400);
  }
  return result;
}

uint64_t sub_100093138()
{
  return sub_1000934A0(&qword_100406408, &qword_1004063D8, (uint64_t (*)(void))sub_100092FB8, (const char *)&protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t sub_10009316C()
{
  return sub_1000934A0(&qword_100406410, &qword_1004063F0, (uint64_t (*)(void))sub_100092FB8, (const char *)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t sub_1000931A4()
{
  unint64_t result;

  result = qword_100406418;
  if (!qword_100406418)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for TimeBitmap.SlotsView, &type metadata for TimeBitmap.SlotsView);
    atomic_store(result, (unint64_t *)&qword_100406418);
  }
  return result;
}

unint64_t sub_1000931EC()
{
  unint64_t result;

  result = qword_100406420;
  if (!qword_100406420)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANTimeUnit, &type metadata for NANTimeUnit);
    atomic_store(result, (unint64_t *)&qword_100406420);
  }
  return result;
}

uint64_t sub_100093230()
{
  return sub_100011770(&qword_100406428, &qword_1004063D8, (const char *)&protocol conformance descriptor for DefaultIndices<A>);
}

uint64_t sub_10009325C()
{
  return sub_100011770(&qword_100406430, &qword_1004063F0, (const char *)&protocol conformance descriptor for Slice<A>);
}

uint64_t sub_100093288()
{
  return sub_100011770(&qword_100406438, &qword_100406440, (const char *)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t sub_1000932B8()
{
  unint64_t result;

  result = qword_100406448;
  if (!qword_100406448)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for TimeBitmap, &type metadata for TimeBitmap);
    atomic_store(result, (unint64_t *)&qword_100406448);
  }
  return result;
}

unint64_t sub_100093300()
{
  unint64_t result;

  result = qword_100406450;
  if (!qword_100406450)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for TimeBitmap, &type metadata for TimeBitmap);
    atomic_store(result, (unint64_t *)&qword_100406450);
  }
  return result;
}

uint64_t sub_100093344()
{
  return sub_1000934A0(&qword_100406458, &qword_100406460, (uint64_t (*)(void))sub_100093378, (const char *)&protocol conformance descriptor for <> DefaultIndices<A>);
}

unint64_t sub_100093378()
{
  unint64_t result;

  result = qword_100406468;
  if (!qword_100406468)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for TimeBitmap, &type metadata for TimeBitmap);
    atomic_store(result, (unint64_t *)&qword_100406468);
  }
  return result;
}

uint64_t sub_1000933BC()
{
  return sub_1000934A0(&qword_100406470, &qword_100406478, (uint64_t (*)(void))sub_100093378, (const char *)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t sub_1000933F4()
{
  unint64_t result;

  result = qword_100406480;
  if (!qword_100406480)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for TimeBitmap, &type metadata for TimeBitmap);
    atomic_store(result, (unint64_t *)&qword_100406480);
  }
  return result;
}

uint64_t sub_100093438()
{
  return sub_1000934A0(&qword_100406488, &qword_100406460, (uint64_t (*)(void))sub_100093300, (const char *)&protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t sub_10009346C()
{
  return sub_1000934A0(&qword_100406490, &qword_100406478, (uint64_t (*)(void))sub_100093300, (const char *)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t sub_1000934A0(unint64_t *a1, uint64_t *a2, uint64_t (*a3)(void), const char *a4)
{
  uint64_t result;
  uint64_t v8;
  uint64_t v9;

  result = *a1;
  if (!result)
  {
    v8 = sub_100013C64(a2);
    v9 = a3();
    result = swift_getWitnessTable(a4, v8, &v9);
    atomic_store(result, a1);
  }
  return result;
}

unint64_t sub_100093508()
{
  unint64_t result;

  result = qword_100406498;
  if (!qword_100406498)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for TimeBitmap, &type metadata for TimeBitmap);
    atomic_store(result, (unint64_t *)&qword_100406498);
  }
  return result;
}

uint64_t sub_10009354C()
{
  return sub_100011770(&qword_1004064A0, &qword_100406460, (const char *)&protocol conformance descriptor for DefaultIndices<A>);
}

uint64_t sub_100093578()
{
  return sub_100011770(&qword_1004064A8, &qword_100406478, (const char *)&protocol conformance descriptor for Slice<A>);
}

uint64_t sub_1000935A4()
{
  return sub_100011770(&qword_1004064B0, &qword_1004064B8, (const char *)&protocol conformance descriptor for IndexingIterator<A>);
}

uint64_t sub_1000935D0()
{
  return sub_100011770(&qword_1004064C0, &qword_1004064C8, (const char *)&protocol conformance descriptor for [A]);
}

unint64_t sub_100093600()
{
  unint64_t result;

  result = qword_1004064D0;
  if (!qword_1004064D0)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANAvailabilityEntry.UsagePreference, &type metadata for NANAvailabilityEntry.UsagePreference);
    atomic_store(result, (unint64_t *)&qword_1004064D0);
  }
  return result;
}

unint64_t sub_100093648()
{
  unint64_t result;

  result = qword_1004064D8;
  if (!qword_1004064D8)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANAvailabilityEntry.Control, &type metadata for NANAvailabilityEntry.Control);
    atomic_store(result, (unint64_t *)&qword_1004064D8);
  }
  return result;
}

unint64_t sub_100093690()
{
  unint64_t result;

  result = qword_1004064E0;
  if (!qword_1004064E0)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANAvailabilityEntry.Control, &type metadata for NANAvailabilityEntry.Control);
    atomic_store(result, (unint64_t *)&qword_1004064E0);
  }
  return result;
}

unint64_t sub_1000936D8()
{
  unint64_t result;

  result = qword_1004064E8;
  if (!qword_1004064E8)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANAvailabilityEntry.Control, &type metadata for NANAvailabilityEntry.Control);
    atomic_store(result, (unint64_t *)&qword_1004064E8);
  }
  return result;
}

unint64_t sub_100093720()
{
  unint64_t result;

  result = qword_1004064F0;
  if (!qword_1004064F0)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANAvailabilityEntry.Control, &type metadata for NANAvailabilityEntry.Control);
    atomic_store(result, (unint64_t *)&qword_1004064F0);
  }
  return result;
}

unint64_t sub_100093768()
{
  unint64_t result;

  result = qword_1004064F8;
  if (!qword_1004064F8)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANAvailabilityEntry.BandChannelEntries.Control.EntriesType, &type metadata for NANAvailabilityEntry.BandChannelEntries.Control.EntriesType);
    atomic_store(result, (unint64_t *)&qword_1004064F8);
  }
  return result;
}

unint64_t sub_1000937B0()
{
  unint64_t result;

  result = qword_100406500;
  if (!qword_100406500)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANAvailabilityEntry.BandChannelEntries.Control, &type metadata for NANAvailabilityEntry.BandChannelEntries.Control);
    atomic_store(result, (unint64_t *)&qword_100406500);
  }
  return result;
}

unint64_t sub_1000937F8()
{
  unint64_t result;

  result = qword_100406508;
  if (!qword_100406508)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANAvailabilityEntry.BandChannelEntries.Control, &type metadata for NANAvailabilityEntry.BandChannelEntries.Control);
    atomic_store(result, (unint64_t *)&qword_100406508);
  }
  return result;
}

unint64_t sub_100093840()
{
  unint64_t result;

  result = qword_100406510;
  if (!qword_100406510)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANAvailabilityEntry.BandChannelEntries.Control, &type metadata for NANAvailabilityEntry.BandChannelEntries.Control);
    atomic_store(result, (unint64_t *)&qword_100406510);
  }
  return result;
}

unint64_t sub_100093888()
{
  unint64_t result;

  result = qword_100406518;
  if (!qword_100406518)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANAvailabilityEntry.BandChannelEntries.Control, &type metadata for NANAvailabilityEntry.BandChannelEntries.Control);
    atomic_store(result, (unint64_t *)&qword_100406518);
  }
  return result;
}

unint64_t sub_1000938D0()
{
  unint64_t result;

  result = qword_100406520;
  if (!qword_100406520)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANAvailabilityEntry.BandChannelEntries, &type metadata for NANAvailabilityEntry.BandChannelEntries);
    atomic_store(result, (unint64_t *)&qword_100406520);
  }
  return result;
}

unint64_t sub_100093918()
{
  unint64_t result;

  result = qword_100406528;
  if (!qword_100406528)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANAvailabilityEntry, &type metadata for NANAvailabilityEntry);
    atomic_store(result, (unint64_t *)&qword_100406528);
  }
  return result;
}

unint64_t sub_100093960()
{
  unint64_t result;

  result = qword_100406530;
  if (!qword_100406530)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANScheduleEntry, &type metadata for NANScheduleEntry);
    atomic_store(result, (unint64_t *)&qword_100406530);
  }
  return result;
}

unint64_t sub_1000939A8()
{
  unint64_t result;

  result = qword_100406538;
  if (!qword_100406538)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANMapIDs, &type metadata for NANMapIDs);
    atomic_store(result, (unint64_t *)&qword_100406538);
  }
  return result;
}

unint64_t sub_1000939F0()
{
  unint64_t result;

  result = qword_100406540;
  if (!qword_100406540)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANMapID, &type metadata for NANMapID);
    atomic_store(result, (unint64_t *)&qword_100406540);
  }
  return result;
}

unint64_t sub_100093A38()
{
  unint64_t result;

  result = qword_100406548;
  if (!qword_100406548)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NonNANOperatingChannelInformation, &type metadata for NonNANOperatingChannelInformation);
    atomic_store(result, (unint64_t *)&qword_100406548);
  }
  return result;
}

unint64_t sub_100093A80()
{
  unint64_t result;

  result = qword_100406550;
  if (!qword_100406550)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NonNANBeaconInformation, &type metadata for NonNANBeaconInformation);
    atomic_store(result, (unint64_t *)&qword_100406550);
  }
  return result;
}

unint64_t sub_100093AC8()
{
  unint64_t result;

  result = qword_100406558;
  if (!qword_100406558)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for DeprecatedNANAvailability, &type metadata for DeprecatedNANAvailability);
    atomic_store(result, (unint64_t *)&qword_100406558);
  }
  return result;
}

unint64_t sub_100093B10()
{
  unint64_t result;

  result = qword_100406560;
  if (!qword_100406560)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for DeprecatedNANAvailabilityEntry, &type metadata for DeprecatedNANAvailabilityEntry);
    atomic_store(result, (unint64_t *)&qword_100406560);
  }
  return result;
}

ValueMetadata *type metadata accessor for NANBitmap()
{
  return &type metadata for NANBitmap;
}

ValueMetadata *type metadata accessor for NANBitmap.Band()
{
  return &type metadata for NANBitmap.Band;
}

ValueMetadata *type metadata accessor for NANBitmap.Band.Iterator()
{
  return &type metadata for NANBitmap.Band.Iterator;
}

uint64_t initializeBufferWithCopyOfBuffer for NANBitmap.Channel(uint64_t result, uint64_t *a2)
{
  uint64_t v2;

  v2 = *a2;
  *(_BYTE *)(result + 8) = *((_BYTE *)a2 + 8);
  *(_QWORD *)result = v2;
  return result;
}

uint64_t getEnumTagSinglePayload for NANBitmap.Channel(uint64_t a1, int a2)
{
  if (a2 && *(_BYTE *)(a1 + 9))
    return (*(_DWORD *)a1 + 1);
  else
    return 0;
}

uint64_t storeEnumTagSinglePayload for NANBitmap.Channel(uint64_t result, int a2, int a3)
{
  char v3;

  if (a2)
  {
    *(_BYTE *)(result + 8) = 0;
    *(_QWORD *)result = (a2 - 1);
    if (!a3)
      return result;
    v3 = 1;
  }
  else
  {
    if (!a3)
      return result;
    v3 = 0;
  }
  *(_BYTE *)(result + 9) = v3;
  return result;
}

ValueMetadata *type metadata accessor for NANBitmap.Channel()
{
  return &type metadata for NANBitmap.Channel;
}

uint64_t sub_100093BF8(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;

  *(_WORD *)a1 = *(_WORD *)a2;
  v3 = *(_QWORD *)(a2 + 8);
  v4 = *(_QWORD *)(a2 + 16);
  sub_100031FEC(v3, v4);
  *(_QWORD *)(a1 + 8) = v3;
  *(_QWORD *)(a1 + 16) = v4;
  return a1;
}

uint64_t assignWithCopy for NANBitmap.Time(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;

  *(_WORD *)a1 = *(_WORD *)a2;
  v3 = *(_QWORD *)(a2 + 8);
  v4 = *(_QWORD *)(a2 + 16);
  sub_100031FEC(v3, v4);
  v5 = *(_QWORD *)(a1 + 8);
  v6 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 8) = v3;
  *(_QWORD *)(a1 + 16) = v4;
  sub_10000E614(v5, v6);
  return a1;
}

uint64_t assignWithTake for NANBitmap.Time(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;

  *(_WORD *)a1 = *(_WORD *)a2;
  v3 = *(_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 16);
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  sub_10000E614(v3, v4);
  return a1;
}

uint64_t getEnumTagSinglePayload for NANBitmap.Time(uint64_t a1, unsigned int a2)
{
  unsigned int v3;

  if (!a2)
    return 0;
  if (a2 >= 0xD && *(_BYTE *)(a1 + 24))
    return (*(_DWORD *)a1 + 13);
  v3 = (((*(_QWORD *)(a1 + 16) >> 60) >> 2) & 0xFFFFFFF3 | (4 * ((*(_QWORD *)(a1 + 16) >> 60) & 3))) ^ 0xF;
  if (v3 >= 0xC)
    v3 = -1;
  return v3 + 1;
}

uint64_t storeEnumTagSinglePayload for NANBitmap.Time(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xC)
  {
    *(_QWORD *)(result + 8) = 0;
    *(_QWORD *)(result + 16) = 0;
    *(_QWORD *)result = a2 - 13;
    if (a3 >= 0xD)
      *(_BYTE *)(result + 24) = 1;
  }
  else
  {
    if (a3 >= 0xD)
      *(_BYTE *)(result + 24) = 0;
    if (a2)
    {
      *(_QWORD *)(result + 8) = 0;
      *(_QWORD *)(result + 16) = (unint64_t)(((-a2 >> 2) & 3) - 4 * a2) << 60;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for NANBitmap.Time()
{
  return &type metadata for NANBitmap.Time;
}

ValueMetadata *type metadata accessor for NANBitmap.Time.Control()
{
  return &type metadata for NANBitmap.Time.Control;
}

ValueMetadata *type metadata accessor for TimeBitmap()
{
  return &type metadata for TimeBitmap;
}

ValueMetadata *type metadata accessor for TimeBitmap.Slot()
{
  return &type metadata for TimeBitmap.Slot;
}

ValueMetadata *type metadata accessor for TimeBitmap.SlotsView()
{
  return &type metadata for TimeBitmap.SlotsView;
}

double destroy for NANAvailabilityEntry(uint64_t *a1)
{
  unint64_t v2;
  double result;

  v2 = a1[3];
  if (v2 >> 60 != 15)
    sub_10000E614(a1[2], v2);
  *(_QWORD *)&result = swift_bridgeObjectRelease(a1[5]).n128_u64[0];
  return result;
}

uint64_t initializeWithCopy for NANAvailabilityEntry(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v7;

  *(_WORD *)a1 = *(_WORD *)a2;
  v4 = *(_QWORD *)(a2 + 24);
  if (v4 >> 60 == 15)
  {
    *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  }
  else
  {
    *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 8);
    v5 = *(_QWORD *)(a2 + 16);
    sub_100031FEC(v5, v4);
    *(_QWORD *)(a1 + 16) = v5;
    *(_QWORD *)(a1 + 24) = v4;
  }
  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
  v6 = *(_QWORD *)(a2 + 40);
  v7 = *(_BYTE *)(a2 + 48);
  *(_QWORD *)(a1 + 40) = v6;
  *(_BYTE *)(a1 + 48) = v7;
  swift_bridgeObjectRetain(v6);
  return a1;
}

uint64_t assignWithCopy for NANAvailabilityEntry(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __int128 *v5;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  char v15;
  uint64_t v16;

  *(_WORD *)a1 = *(_WORD *)a2;
  v4 = a1 + 8;
  v5 = (__int128 *)(a2 + 8);
  if (*(_QWORD *)(a1 + 24) >> 60 == 15)
  {
    if (*(_QWORD *)(a2 + 24) >> 60 == 15)
    {
      v6 = *v5;
      *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
      *(_OWORD *)v4 = v6;
    }
    else
    {
      *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 8);
      v8 = *(_QWORD *)(a2 + 16);
      v9 = *(_QWORD *)(a2 + 24);
      sub_100031FEC(v8, v9);
      *(_QWORD *)(a1 + 16) = v8;
      *(_QWORD *)(a1 + 24) = v9;
    }
  }
  else if (*(_QWORD *)(a2 + 24) >> 60 == 15)
  {
    sub_100093F8C(a1 + 8);
    v7 = *((_QWORD *)v5 + 2);
    *(_OWORD *)v4 = *v5;
    *(_QWORD *)(v4 + 16) = v7;
  }
  else
  {
    *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 8);
    v10 = *(_QWORD *)(a2 + 16);
    v11 = *(_QWORD *)(a2 + 24);
    sub_100031FEC(v10, v11);
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 16) = v10;
    *(_QWORD *)(a1 + 24) = v11;
    sub_10000E614(v12, v13);
  }
  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
  v14 = *(_QWORD *)(a2 + 40);
  v15 = *(_BYTE *)(a2 + 48);
  v16 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = v14;
  *(_BYTE *)(a1 + 48) = v15;
  swift_bridgeObjectRetain(v14);
  swift_bridgeObjectRelease(v16);
  return a1;
}

uint64_t sub_100093F8C(uint64_t a1)
{
  sub_10000E614(*(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16));
  return a1;
}

__n128 initializeWithTake for NANAvailabilityEntry(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;
  __int128 v4;

  result = *(__n128 *)a2;
  v3 = *(_OWORD *)(a2 + 16);
  v4 = *(_OWORD *)(a2 + 32);
  *(_BYTE *)(a1 + 48) = *(_BYTE *)(a2 + 48);
  *(_OWORD *)(a1 + 16) = v3;
  *(_OWORD *)(a1 + 32) = v4;
  *(__n128 *)a1 = result;
  return result;
}

uint64_t assignWithTake for NANAvailabilityEntry(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  char v9;
  uint64_t v10;

  *(_WORD *)a1 = *(_WORD *)a2;
  v4 = a1 + 8;
  v5 = a2 + 8;
  v6 = *(_QWORD *)(a1 + 24);
  if (v6 >> 60 != 15)
  {
    v7 = *(_QWORD *)(a2 + 24);
    if (v7 >> 60 != 15)
    {
      *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 8);
      v8 = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
      *(_QWORD *)(a1 + 24) = v7;
      sub_10000E614(v8, v6);
      goto LABEL_6;
    }
    sub_100093F8C(a1 + 8);
  }
  *(_OWORD *)v4 = *(_OWORD *)v5;
  *(_QWORD *)(v4 + 16) = *(_QWORD *)(v5 + 16);
LABEL_6:
  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
  v9 = *(_BYTE *)(a2 + 48);
  v10 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_BYTE *)(a1 + 48) = v9;
  swift_bridgeObjectRelease(v10);
  return a1;
}

uint64_t getEnumTagSinglePayload for NANAvailabilityEntry(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  int v4;

  if (!a2)
    return 0;
  if (a2 >= 0xFF && *(_BYTE *)(a1 + 49))
    return (*(_DWORD *)a1 + 255);
  v3 = *(unsigned __int8 *)(a1 + 48);
  if (v3 <= 1)
    v4 = -1;
  else
    v4 = v3 ^ 0xFF;
  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for NANAvailabilityEntry(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFE)
  {
    *(_QWORD *)(result + 40) = 0;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_BYTE *)(result + 48) = 0;
    *(_QWORD *)result = a2 - 255;
    if (a3 >= 0xFF)
      *(_BYTE *)(result + 49) = 1;
  }
  else
  {
    if (a3 >= 0xFF)
      *(_BYTE *)(result + 49) = 0;
    if (a2)
      *(_BYTE *)(result + 48) = -(char)a2;
  }
  return result;
}

ValueMetadata *type metadata accessor for NANAvailabilityEntry()
{
  return &type metadata for NANAvailabilityEntry;
}

ValueMetadata *type metadata accessor for NANAvailabilityEntry.UsagePreference()
{
  return &type metadata for NANAvailabilityEntry.UsagePreference;
}

ValueMetadata *type metadata accessor for NANAvailabilityEntry.Control()
{
  return &type metadata for NANAvailabilityEntry.Control;
}

uint64_t sub_10009415C(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  char v4;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  v3 = *(_QWORD *)(a2 + 8);
  v4 = *(_BYTE *)(a2 + 16);
  *(_QWORD *)(a1 + 8) = v3;
  *(_BYTE *)(a1 + 16) = v4;
  swift_bridgeObjectRetain(v3);
  return a1;
}

uint64_t assignWithCopy for NANAvailabilityEntry.BandChannelEntries(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  char v4;
  uint64_t v5;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  v3 = *(_QWORD *)(a2 + 8);
  v4 = *(_BYTE *)(a2 + 16);
  v5 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = v3;
  *(_BYTE *)(a1 + 16) = v4;
  swift_bridgeObjectRetain(v3);
  swift_bridgeObjectRelease(v5);
  return a1;
}

uint64_t assignWithTake for NANAvailabilityEntry.BandChannelEntries(uint64_t a1, uint64_t a2)
{
  char v3;
  uint64_t v4;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  v3 = *(_BYTE *)(a2 + 16);
  v4 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 16) = v3;
  swift_bridgeObjectRelease(v4);
  return a1;
}

uint64_t getEnumTagSinglePayload for NANAvailabilityEntry.BandChannelEntries(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  int v4;

  if (!a2)
    return 0;
  if (a2 >= 0xFF && *(_BYTE *)(a1 + 17))
    return (*(_DWORD *)a1 + 255);
  v3 = *(unsigned __int8 *)(a1 + 16);
  if (v3 <= 1)
    v4 = -1;
  else
    v4 = v3 ^ 0xFF;
  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for NANAvailabilityEntry.BandChannelEntries(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFE)
  {
    *(_BYTE *)(result + 16) = 0;
    *(_QWORD *)result = a2 - 255;
    *(_QWORD *)(result + 8) = 0;
    if (a3 >= 0xFF)
      *(_BYTE *)(result + 17) = 1;
  }
  else
  {
    if (a3 >= 0xFF)
      *(_BYTE *)(result + 17) = 0;
    if (a2)
      *(_BYTE *)(result + 16) = -(char)a2;
  }
  return result;
}

ValueMetadata *type metadata accessor for NANAvailabilityEntry.BandChannelEntries()
{
  return &type metadata for NANAvailabilityEntry.BandChannelEntries;
}

ValueMetadata *type metadata accessor for NANAvailabilityEntry.BandChannelEntries.Control()
{
  return &type metadata for NANAvailabilityEntry.BandChannelEntries.Control;
}

ValueMetadata *type metadata accessor for NANAvailabilityEntry.BandChannelEntries.Control.EntriesType()
{
  return &type metadata for NANAvailabilityEntry.BandChannelEntries.Control.EntriesType;
}

uint64_t destroy for NANAttribute.P2POperation(uint64_t a1)
{
  return sub_10000E614(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
}

uint64_t initializeWithCopy for NANScheduleEntry(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 8);
  v3 = *(_QWORD *)(a2 + 16);
  v4 = *(_QWORD *)(a2 + 24);
  sub_100031FEC(v3, v4);
  *(_QWORD *)(a1 + 16) = v3;
  *(_QWORD *)(a1 + 24) = v4;
  return a1;
}

uint64_t assignWithCopy for NANScheduleEntry(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 8);
  v3 = *(_QWORD *)(a2 + 16);
  v4 = *(_QWORD *)(a2 + 24);
  sub_100031FEC(v3, v4);
  v5 = *(_QWORD *)(a1 + 16);
  v6 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 16) = v3;
  *(_QWORD *)(a1 + 24) = v4;
  sub_10000E614(v5, v6);
  return a1;
}

uint64_t assignWithTake for NANScheduleEntry(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  v4 = *(_QWORD *)(a1 + 24);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  sub_10000E614(v3, v4);
  return a1;
}

uint64_t getEnumTagSinglePayload for NANScheduleEntry(uint64_t a1, unsigned int a2)
{
  unsigned int v3;

  if (!a2)
    return 0;
  if (a2 >= 0xD && *(_BYTE *)(a1 + 32))
    return (*(_DWORD *)a1 + 13);
  v3 = (((*(_QWORD *)(a1 + 24) >> 60) >> 2) & 0xFFFFFFF3 | (4 * ((*(_QWORD *)(a1 + 24) >> 60) & 3))) ^ 0xF;
  if (v3 >= 0xC)
    v3 = -1;
  return v3 + 1;
}

uint64_t storeEnumTagSinglePayload for NANScheduleEntry(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xC)
  {
    *(_QWORD *)(result + 16) = 0;
    *(_QWORD *)(result + 24) = 0;
    *(_QWORD *)result = a2 - 13;
    *(_QWORD *)(result + 8) = 0;
    if (a3 >= 0xD)
      *(_BYTE *)(result + 32) = 1;
  }
  else
  {
    if (a3 >= 0xD)
      *(_BYTE *)(result + 32) = 0;
    if (a2)
    {
      *(_QWORD *)(result + 16) = 0;
      *(_QWORD *)(result + 24) = (unint64_t)(((-a2 >> 2) & 3) - 4 * a2) << 60;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for NANScheduleEntry()
{
  return &type metadata for NANScheduleEntry;
}

uint64_t getEnumTagSinglePayload for NANMapIDs(uint64_t a1, int a2)
{
  unsigned int v2;
  unsigned int v3;
  uint64_t v4;

  if (!a2)
    return 0;
  v2 = a2 + 0xFFFF;
  if ((a2 + 0xFFFF) <= 0xFFFEFFFF)
    v3 = 2;
  else
    v3 = 4;
  if (v2 < 0xFF0000)
    v3 = 1;
  if (v2 >= 0x10000)
    v4 = v3;
  else
    v4 = 0;
  return ((uint64_t (*)(void))((char *)&loc_1000944D4 + 4 * byte_10033CCBF[v4]))();
}

uint64_t sub_1000944EC(unsigned __int16 *a1)
{
  uint64_t v1;

  v1 = a1[1];
  if (a1[1])
    return (*a1 | ((_DWORD)v1 << 16)) - 0xFFFF;
  return v1;
}

void sub_1000944F8(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 2))
    JUMPOUT(0x100094500);
  JUMPOUT(0x100094510);
}

uint64_t storeEnumTagSinglePayload for NANMapIDs(_WORD *a1, int a2, int a3)
{
  unsigned int v3;
  int v4;
  uint64_t v5;

  v3 = a3 + 0xFFFF;
  if ((a3 + 0xFFFF) <= 0xFFFEFFFF)
    v4 = 2;
  else
    v4 = 4;
  if (v3 < 0xFF0000)
    v4 = 1;
  if (v3 >= 0x10000)
    LODWORD(v5) = v4;
  else
    LODWORD(v5) = 0;
  if (a3)
    v5 = v5;
  else
    v5 = 0;
  if (!a2)
    return ((uint64_t (*)(void))((char *)sub_10009459C + 4 * byte_10033CCC9[v5]))();
  *a1 = a2 - 1;
  return ((uint64_t (*)(void))((char *)sub_10009457C + 4 * byte_10033CCC4[v5]))();
}

uint64_t sub_10009457C(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 2) = v1;
  return result;
}

uint64_t sub_10009459C(uint64_t result)
{
  *(_BYTE *)(result + 2) = 0;
  return result;
}

uint64_t sub_1000945A4(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 2) = v1;
  return result;
}

uint64_t sub_1000945AC(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 2) = v1;
  return result;
}

uint64_t sub_1000945B4(uint64_t result)
{
  *(_WORD *)(result + 2) = 0;
  return result;
}

uint64_t sub_1000945BC(uint64_t result)
{
  *(_DWORD *)(result + 2) = 0;
  return result;
}

ValueMetadata *type metadata accessor for NANMapIDs()
{
  return &type metadata for NANMapIDs;
}

ValueMetadata *type metadata accessor for NANMapID()
{
  return &type metadata for NANMapID;
}

ValueMetadata *type metadata accessor for NonNANOperatingChannelInformation()
{
  return &type metadata for NonNANOperatingChannelInformation;
}

ValueMetadata *type metadata accessor for NonNANBeaconInformation()
{
  return &type metadata for NonNANBeaconInformation;
}

uint64_t destroy for NANServiceInfo(uint64_t a1)
{
  return sub_10000E614(*(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16));
}

uint64_t assignWithCopy for DeprecatedNANAvailability(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_BYTE *)(a1 + 1) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)(a1 + 2) = *(_BYTE *)(a2 + 2);
  v3 = *(_QWORD *)(a2 + 8);
  v4 = *(_QWORD *)(a2 + 16);
  sub_100031FEC(v3, v4);
  v5 = *(_QWORD *)(a1 + 8);
  v6 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 8) = v3;
  *(_QWORD *)(a1 + 16) = v4;
  sub_10000E614(v5, v6);
  return a1;
}

uint64_t assignWithTake for DeprecatedNANAvailability(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;

  *(_WORD *)a1 = *(_WORD *)a2;
  *(_BYTE *)(a1 + 2) = *(_BYTE *)(a2 + 2);
  v3 = *(_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 16);
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  sub_10000E614(v3, v4);
  return a1;
}

uint64_t getEnumTagSinglePayload for DeprecatedNANAvailability(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  BOOL v4;
  int v5;

  if (!a2)
    return 0;
  if (a2 >= 0xFF && *(_BYTE *)(a1 + 24))
    return (*(_DWORD *)a1 + 255);
  v3 = *(unsigned __int8 *)(a1 + 2);
  v4 = v3 >= 2;
  v5 = (v3 + 2147483646) & 0x7FFFFFFF;
  if (!v4)
    v5 = -1;
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for DeprecatedNANAvailability(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFE)
  {
    *(_QWORD *)(result + 8) = 0;
    *(_QWORD *)(result + 16) = 0;
    *(_QWORD *)result = a2 - 255;
    if (a3 >= 0xFF)
      *(_BYTE *)(result + 24) = 1;
  }
  else
  {
    if (a3 >= 0xFF)
      *(_BYTE *)(result + 24) = 0;
    if (a2)
      *(_BYTE *)(result + 2) = a2 + 1;
  }
  return result;
}

ValueMetadata *type metadata accessor for DeprecatedNANAvailability()
{
  return &type metadata for DeprecatedNANAvailability;
}

uint64_t _s7CoreP2P25DeprecatedNANAvailabilityVwCP_0(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_WORD *)(a1 + 1) = *(_WORD *)(a2 + 1);
  v3 = *(_QWORD *)(a2 + 8);
  v4 = *(_QWORD *)(a2 + 16);
  sub_100031FEC(v3, v4);
  *(_QWORD *)(a1 + 8) = v3;
  *(_QWORD *)(a1 + 16) = v4;
  return a1;
}

uint64_t assignWithTake for DeprecatedNANAvailabilityEntry(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_WORD *)(a1 + 1) = *(_WORD *)(a2 + 1);
  v3 = *(_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 16);
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  sub_10000E614(v3, v4);
  return a1;
}

uint64_t getEnumTagSinglePayload for NANServiceInfo(unsigned __int8 *a1, unsigned int a2)
{
  unsigned int v3;
  BOOL v4;
  int v5;

  if (!a2)
    return 0;
  if (a2 >= 0xFD && a1[24])
    return (*(_DWORD *)a1 + 253);
  v3 = *a1;
  v4 = v3 >= 4;
  v5 = v3 - 4;
  if (!v4)
    v5 = -1;
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for NANServiceInfo(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFC)
  {
    *(_QWORD *)(result + 8) = 0;
    *(_QWORD *)(result + 16) = 0;
    *(_QWORD *)result = a2 - 253;
    if (a3 >= 0xFD)
      *(_BYTE *)(result + 24) = 1;
  }
  else
  {
    if (a3 >= 0xFD)
      *(_BYTE *)(result + 24) = 0;
    if (a2)
      *(_BYTE *)result = a2 + 3;
  }
  return result;
}

ValueMetadata *type metadata accessor for DeprecatedNANAvailabilityEntry()
{
  return &type metadata for DeprecatedNANAvailabilityEntry;
}

ValueMetadata *type metadata accessor for DeprecatedNANAvailabilityEntry.CodingKeys()
{
  return &type metadata for DeprecatedNANAvailabilityEntry.CodingKeys;
}

ValueMetadata *type metadata accessor for DeprecatedNANAvailability.AvailabilityControl()
{
  return &type metadata for DeprecatedNANAvailability.AvailabilityControl;
}

ValueMetadata *type metadata accessor for NonNANBeaconInformation.CodingKeys()
{
  return &type metadata for NonNANBeaconInformation.CodingKeys;
}

uint64_t storeEnumTagSinglePayload for NonNANOperatingChannelInformation.CodingKeys(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 2 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 2) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xFE)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xFD)
    return ((uint64_t (*)(void))((char *)&loc_10009490C + 4 * byte_10033CCD3[v4]))();
  *a1 = a2 + 2;
  return ((uint64_t (*)(void))((char *)sub_100094940 + 4 * byte_10033CCCE[v4]))();
}

uint64_t sub_100094940(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_100094948(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x100094950);
  return result;
}

uint64_t sub_10009495C(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x100094964);
  *(_BYTE *)result = a2 + 2;
  return result;
}

uint64_t sub_100094968(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_100094970(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for NonNANOperatingChannelInformation.CodingKeys()
{
  return &type metadata for NonNANOperatingChannelInformation.CodingKeys;
}

uint64_t _s7CoreP2P20NANAvailabilityEntryV18BandChannelEntriesV7ControlV11EntriesTypeOwst_0(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 1 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 1) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xFF)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xFE)
    return ((uint64_t (*)(void))((char *)&loc_1000949D8 + 4 * byte_10033CCDD[v4]))();
  *a1 = a2 + 1;
  return ((uint64_t (*)(void))((char *)sub_100094A0C + 4 * byte_10033CCD8[v4]))();
}

uint64_t sub_100094A0C(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_100094A14(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x100094A1CLL);
  return result;
}

uint64_t sub_100094A28(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x100094A30);
  *(_BYTE *)result = a2 + 1;
  return result;
}

uint64_t sub_100094A34(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_100094A3C(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for NANScheduleEntry.CodingKeys()
{
  return &type metadata for NANScheduleEntry.CodingKeys;
}

uint64_t getEnumTagSinglePayload for NANBloomFilter.Index(unsigned __int8 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0xFD)
    goto LABEL_17;
  if (a2 + 3 >= 0xFFFF00)
    v2 = 4;
  else
    v2 = 2;
  if ((a2 + 3) >> 8 < 0xFF)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 8)) - 3;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1))
        goto LABEL_17;
      return (*a1 | (v4 << 8)) - 3;
    }
    v4 = a1[1];
    if (a1[1])
      return (*a1 | (v4 << 8)) - 3;
  }
LABEL_17:
  v6 = *a1;
  v7 = v6 >= 4;
  v8 = v6 - 4;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

uint64_t _s7CoreP2P20NANAvailabilityEntryV15UsagePreferenceOwst_0(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 3 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 3) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xFD)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xFC)
    return ((uint64_t (*)(void))((char *)&loc_100094B34 + 4 * byte_10033CCE7[v4]))();
  *a1 = a2 + 3;
  return ((uint64_t (*)(void))((char *)sub_100094B68 + 4 * byte_10033CCE2[v4]))();
}

uint64_t sub_100094B68(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_100094B70(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x100094B78);
  return result;
}

uint64_t sub_100094B84(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x100094B8CLL);
  *(_BYTE *)result = a2 + 3;
  return result;
}

uint64_t sub_100094B90(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_100094B98(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for NANBitmap.Channel.CodingKeys()
{
  return &type metadata for NANBitmap.Channel.CodingKeys;
}

unint64_t sub_100094BB8()
{
  unint64_t result;

  result = qword_100406568;
  if (!qword_100406568)
  {
    result = swift_getWitnessTable(&unk_10033E884, &type metadata for NANBitmap.Channel.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406568);
  }
  return result;
}

unint64_t sub_100094C00()
{
  unint64_t result;

  result = qword_100406570;
  if (!qword_100406570)
  {
    result = swift_getWitnessTable(&unk_10033E93C, &type metadata for NANScheduleEntry.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406570);
  }
  return result;
}

unint64_t sub_100094C48()
{
  unint64_t result;

  result = qword_100406578;
  if (!qword_100406578)
  {
    result = swift_getWitnessTable(&unk_10033E9F4, &type metadata for NonNANOperatingChannelInformation.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406578);
  }
  return result;
}

unint64_t sub_100094C90()
{
  unint64_t result;

  result = qword_100406580;
  if (!qword_100406580)
  {
    result = swift_getWitnessTable(&unk_10033EAAC, &type metadata for NonNANBeaconInformation.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406580);
  }
  return result;
}

unint64_t sub_100094CD8()
{
  unint64_t result;

  result = qword_100406588;
  if (!qword_100406588)
  {
    result = swift_getWitnessTable(&unk_10033EB04, &type metadata for DeprecatedNANAvailability.AvailabilityControl);
    atomic_store(result, (unint64_t *)&qword_100406588);
  }
  return result;
}

unint64_t sub_100094D20()
{
  unint64_t result;

  result = qword_100406590;
  if (!qword_100406590)
  {
    result = swift_getWitnessTable(&unk_10033EAD4, &type metadata for DeprecatedNANAvailability.AvailabilityControl);
    atomic_store(result, (unint64_t *)&qword_100406590);
  }
  return result;
}

unint64_t sub_100094D68()
{
  unint64_t result;

  result = qword_100406598;
  if (!qword_100406598)
  {
    result = swift_getWitnessTable(&unk_10033EB2C, &type metadata for DeprecatedNANAvailability.AvailabilityControl);
    atomic_store(result, (unint64_t *)&qword_100406598);
  }
  return result;
}

unint64_t sub_100094DB0()
{
  unint64_t result;

  result = qword_1004065A0;
  if (!qword_1004065A0)
  {
    result = swift_getWitnessTable(&unk_10033EB64, &type metadata for DeprecatedNANAvailability.AvailabilityControl);
    atomic_store(result, (unint64_t *)&qword_1004065A0);
  }
  return result;
}

unint64_t sub_100094DF8()
{
  unint64_t result;

  result = qword_1004065A8;
  if (!qword_1004065A8)
  {
    result = swift_getWitnessTable(&unk_10033ED5C, &type metadata for DeprecatedNANAvailabilityEntry.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004065A8);
  }
  return result;
}

unint64_t sub_100094E40()
{
  unint64_t result;

  result = qword_1004065B0;
  if (!qword_1004065B0)
  {
    result = swift_getWitnessTable(&unk_10033ECCC, &type metadata for DeprecatedNANAvailabilityEntry.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004065B0);
  }
  return result;
}

unint64_t sub_100094E88()
{
  unint64_t result;

  result = qword_1004065B8;
  if (!qword_1004065B8)
  {
    result = swift_getWitnessTable(&unk_10033ECF4, &type metadata for DeprecatedNANAvailabilityEntry.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004065B8);
  }
  return result;
}

unint64_t sub_100094ED0()
{
  unint64_t result;

  result = qword_1004065C0;
  if (!qword_1004065C0)
  {
    result = swift_getWitnessTable(&unk_10033EA1C, &type metadata for NonNANBeaconInformation.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004065C0);
  }
  return result;
}

unint64_t sub_100094F18()
{
  unint64_t result;

  result = qword_1004065C8;
  if (!qword_1004065C8)
  {
    result = swift_getWitnessTable(&unk_10033EA44, &type metadata for NonNANBeaconInformation.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004065C8);
  }
  return result;
}

unint64_t sub_100094F60()
{
  unint64_t result;

  result = qword_1004065D0;
  if (!qword_1004065D0)
  {
    result = swift_getWitnessTable(&unk_10033E964, &type metadata for NonNANOperatingChannelInformation.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004065D0);
  }
  return result;
}

unint64_t sub_100094FA8()
{
  unint64_t result;

  result = qword_1004065D8;
  if (!qword_1004065D8)
  {
    result = swift_getWitnessTable(&unk_10033E98C, &type metadata for NonNANOperatingChannelInformation.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004065D8);
  }
  return result;
}

unint64_t sub_100094FF0()
{
  unint64_t result;

  result = qword_1004065E0;
  if (!qword_1004065E0)
  {
    result = swift_getWitnessTable(&unk_10033E8AC, &type metadata for NANScheduleEntry.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004065E0);
  }
  return result;
}

unint64_t sub_100095038()
{
  unint64_t result;

  result = qword_1004065E8;
  if (!qword_1004065E8)
  {
    result = swift_getWitnessTable(&unk_10033E8D4, &type metadata for NANScheduleEntry.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004065E8);
  }
  return result;
}

unint64_t sub_100095080()
{
  unint64_t result;

  result = qword_1004065F0;
  if (!qword_1004065F0)
  {
    result = swift_getWitnessTable(&unk_10033E7F4, &type metadata for NANBitmap.Channel.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004065F0);
  }
  return result;
}

unint64_t sub_1000950C8()
{
  unint64_t result;

  result = qword_1004065F8;
  if (!qword_1004065F8)
  {
    result = swift_getWitnessTable(&unk_10033E81C, &type metadata for NANBitmap.Channel.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004065F8);
  }
  return result;
}

uint64_t sub_10009510C(uint64_t a1, unint64_t a2)
{
  unint64_t v5;
  char v7;

  if (a1 == 0x444970616DLL && a2 == 0xE500000000000000)
  {
    v5 = 0xE500000000000000;
    goto LABEL_8;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x444970616DLL, 0xE500000000000000, a1, a2, 0) & 1) != 0)
  {
    v5 = a2;
LABEL_8:
    swift_bridgeObjectRelease(v5);
    return 0;
  }
  if (a1 == 0x6D746942656D6974 && a2 == 0xEA00000000007061)
  {
    swift_bridgeObjectRelease(0xEA00000000007061);
    return 1;
  }
  else
  {
    v7 = _stringCompareWithSmolCheck(_:_:expecting:)(0x6D746942656D6974, 0xEA00000000007061, a1, a2, 0);
    swift_bridgeObjectRelease(a2);
    if ((v7 & 1) != 0)
      return 1;
    else
      return 2;
  }
}

uint64_t sub_100095200(uint64_t a1, unint64_t a2)
{
  unint64_t v4;
  unint64_t v6;
  char v7;

  if (a1 == 0xD000000000000014)
  {
    v4 = 0x80000001003645B0;
    if (a2 == 0x80000001003645B0)
      goto LABEL_5;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000014, 0x80000001003645B0, a1, a2, 0) & 1) != 0)
  {
    v4 = a2;
LABEL_5:
    swift_bridgeObjectRelease(v4);
    return 0;
  }
  if (a1 == 0x4E6C656E6E616863 && a2 == 0xED00007265626D75)
  {
    v6 = 0xED00007265626D75;
LABEL_11:
    swift_bridgeObjectRelease(v6);
    return 1;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x4E6C656E6E616863, 0xED00007265626D75, a1, a2, 0) & 1) != 0)
  {
    v6 = a2;
    goto LABEL_11;
  }
  if (a1 == 0xD000000000000016 && a2 == 0x80000001003645D0)
  {
    swift_bridgeObjectRelease(0x80000001003645D0);
    return 2;
  }
  else
  {
    v7 = _stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000016, 0x80000001003645D0, a1, a2, 0);
    swift_bridgeObjectRelease(a2);
    if ((v7 & 1) != 0)
      return 2;
    else
      return 3;
  }
}

uint64_t sub_100095370(uint64_t a1, unint64_t a2)
{
  unint64_t v4;
  char v6;

  if (a1 == 0xD000000000000022 && a2 == 0x80000001003645F0)
  {
    v4 = 0x80000001003645F0;
LABEL_6:
    swift_bridgeObjectRelease(v4);
    return 0;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000022, 0x80000001003645F0, a1, a2, 0) & 1) != 0)
  {
    v4 = a2;
    goto LABEL_6;
  }
  if (a1 == 0xD000000000000011 && a2 == 0x8000000100364620)
  {
    swift_bridgeObjectRelease(0x8000000100364620);
    return 1;
  }
  else
  {
    v6 = _stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000011, 0x8000000100364620, a1, a2, 0);
    swift_bridgeObjectRelease(a2);
    if ((v6 & 1) != 0)
      return 1;
    else
      return 2;
  }
}

uint64_t sub_10009545C(uint64_t a1, unint64_t a2)
{
  unint64_t v5;
  unint64_t v7;
  unint64_t v8;
  char v9;

  if (a1 == 0x6C6F72746E6F63 && a2 == 0xE700000000000000)
  {
    v5 = 0xE700000000000000;
    goto LABEL_8;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6C6F72746E6F63, 0xE700000000000000, a1, a2, 0) & 1) != 0)
  {
    v5 = a2;
LABEL_8:
    swift_bridgeObjectRelease(v5);
    return 0;
  }
  if (a1 == 0x6E6974617265706FLL && a2 == 0xEE007373616C4367)
  {
    v7 = 0xEE007373616C4367;
LABEL_14:
    swift_bridgeObjectRelease(v7);
    return 1;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6E6974617265706FLL, 0xEE007373616C4367, a1, a2, 0) & 1) != 0)
  {
    v7 = a2;
    goto LABEL_14;
  }
  if (a1 == 0x4E6C656E6E616863 && a2 == 0xED00007265626D75)
  {
    v8 = 0xED00007265626D75;
LABEL_20:
    swift_bridgeObjectRelease(v8);
    return 2;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x4E6C656E6E616863, 0xED00007265626D75, a1, a2, 0) & 1) != 0)
  {
    v8 = a2;
    goto LABEL_20;
  }
  if (a1 == 0x6962616C69617661 && a2 == 0xEF70614D7974696CLL)
  {
    swift_bridgeObjectRelease(0xEF70614D7974696CLL);
    return 3;
  }
  else
  {
    v9 = _stringCompareWithSmolCheck(_:_:expecting:)(0x6962616C69617661, 0xEF70614D7974696CLL, a1, a2, 0);
    swift_bridgeObjectRelease(a2);
    if ((v9 & 1) != 0)
      return 3;
    else
      return 4;
  }
}

unint64_t sub_100095680()
{
  unint64_t result;

  result = qword_100406600;
  if (!qword_100406600)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANMapID, &type metadata for NANMapID);
    atomic_store(result, (unint64_t *)&qword_100406600);
  }
  return result;
}

unint64_t sub_1000956C4()
{
  unint64_t result;

  result = qword_100406608;
  if (!qword_100406608)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANMapIDs, &type metadata for NANMapIDs);
    atomic_store(result, (unint64_t *)&qword_100406608);
  }
  return result;
}

uint64_t sub_100095708(uint64_t a1, uint64_t a2)
{
  initializeWithTake for NANAvailabilityEntry(a2, a1);
  return a2;
}

uint64_t sub_100095744(uint64_t a1, void (*a2)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))
{
  a2(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(unsigned __int8 *)(a1 + 48));
  return a1;
}

uint64_t sub_100095780(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = type metadata accessor for LongTermPairingKeys.PublicIdentity(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 - 8) + 32))(a2, a1, v4);
  return a2;
}

unint64_t sub_1000957C4()
{
  unint64_t result;

  result = qword_100406620;
  if (!qword_100406620)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANIntervalDuration, &type metadata for NANIntervalDuration);
    atomic_store(result, (unint64_t *)&qword_100406620);
  }
  return result;
}

unint64_t sub_100095808()
{
  unint64_t result;

  result = qword_100406628;
  if (!qword_100406628)
  {
    result = swift_getWitnessTable(&unk_10033EC2C, &type metadata for DeprecatedNANAvailability.AvailabilityControl);
    atomic_store(result, (unint64_t *)&qword_100406628);
  }
  return result;
}

unint64_t sub_10009584C()
{
  unint64_t result;

  result = qword_100406648;
  if (!qword_100406648)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANMapID, &type metadata for NANMapID);
    atomic_store(result, (unint64_t *)&qword_100406648);
  }
  return result;
}

unint64_t sub_100095890()
{
  unint64_t result;

  result = qword_100406650;
  if (!qword_100406650)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANBitmap.Time, &type metadata for NANBitmap.Time);
    atomic_store(result, (unint64_t *)&qword_100406650);
  }
  return result;
}

unint64_t sub_1000958D4()
{
  unint64_t result;

  result = qword_100406678;
  if (!qword_100406678)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANAvailabilityEntry.Control, &type metadata for NANAvailabilityEntry.Control);
    atomic_store(result, (unint64_t *)&qword_100406678);
  }
  return result;
}

unint64_t sub_100095918()
{
  unint64_t result;

  result = qword_100406680;
  if (!qword_100406680)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANAvailabilityEntry.BandChannelEntries, &type metadata for NANAvailabilityEntry.BandChannelEntries);
    atomic_store(result, (unint64_t *)&qword_100406680);
  }
  return result;
}

unint64_t sub_10009595C()
{
  unint64_t result;

  result = qword_100406688;
  if (!qword_100406688)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANAvailabilityEntry.BandChannelEntries.Control, &type metadata for NANAvailabilityEntry.BandChannelEntries.Control);
    atomic_store(result, (unint64_t *)&qword_100406688);
  }
  return result;
}

uint64_t sub_1000959A0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = sub_100012C44(&qword_100405050);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 - 8) + 16))(a2, a1, v4);
  return a2;
}

unint64_t sub_1000959E8()
{
  unint64_t result;

  result = qword_100406698;
  if (!qword_100406698)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANBitmap.Band, &type metadata for NANBitmap.Band);
    atomic_store(result, (unint64_t *)&qword_100406698);
  }
  return result;
}

unint64_t sub_100095A2C()
{
  unint64_t result;

  result = qword_1004066A0;
  if (!qword_1004066A0)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANBitmap.Channel, &type metadata for NANBitmap.Channel);
    atomic_store(result, (unint64_t *)&qword_1004066A0);
  }
  return result;
}

uint64_t sub_100095A70(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  if (a1)
    v3 = a2 - a1;
  else
    v3 = 0;
  return Data._Representation.replaceSubrange(_:with:count:)(*(_QWORD *)(v2 + 24), *(_QWORD *)(v2 + 32), a1, v3);
}

unint64_t sub_100095AB4()
{
  unint64_t result;

  result = qword_1004066C8;
  if (!qword_1004066C8)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for NANBitmap.Time.Control, &type metadata for NANBitmap.Time.Control);
    atomic_store(result, (unint64_t *)&qword_1004066C8);
  }
  return result;
}

unint64_t sub_100095AF8()
{
  unint64_t result;
  uint64_t v1;
  void *v2;

  result = qword_1004066E0;
  if (!qword_1004066E0)
  {
    v1 = sub_100013C64(&qword_1004066D8);
    v2 = &protocol witness table for UInt16;
    result = swift_getWitnessTable((const char *)&protocol conformance descriptor for <A> A?, v1, &v2);
    atomic_store(result, (unint64_t *)&qword_1004066E0);
  }
  return result;
}

BOOL sub_100095BB4(uint64_t a1, uint64_t a2)
{
  return sub_10007F26C(a1, a2);
}

BOOL sub_100095C54(unsigned int a1, uint64_t a2)
{
  return ((~*(unsigned __int8 *)(a2 + ((unint64_t)a1 >> 3)) >> (a1 & 7)) & 1) == 0;
}

uint64_t sub_100095C78@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  char v9;
  _QWORD v10[5];
  _BYTE v11[40];

  sub_100063EB8(a1, (uint64_t)v10, &qword_100406958);
  v4 = v10[0];
  v5 = v10[1];
  v7 = v10[2];
  v6 = v10[3];
  result = sub_100063EB8(a1, (uint64_t)v11, &qword_100406958);
  if ((v11[32] & 1) == 0)
  {
    if ((v4 & 0x100000000) == 0)
    {
      v6 = 0;
      v7 = 0;
      v5 = 0;
      v4 = v4;
      v9 = 0;
      goto LABEL_7;
    }
LABEL_6:
    v6 = 0;
    v7 = 0;
    v5 = 0;
    v4 = 0;
    v9 = -1;
    goto LABEL_7;
  }
  if (v6 == 1)
    goto LABEL_6;
  v9 = 1;
  result = swift_bridgeObjectRetain(v6);
LABEL_7:
  *(_QWORD *)a2 = v4;
  *(_QWORD *)(a2 + 8) = v5;
  *(_QWORD *)(a2 + 16) = v7;
  *(_QWORD *)(a2 + 24) = v6;
  *(_BYTE *)(a2 + 32) = v9;
  return result;
}

_QWORD *static DeviceDriver<>.parse(event:)(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, _BYTE *a5, unint64_t a6)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  _QWORD *result;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unsigned int v53;
  uint64_t v54;
  __int16 v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  char v76;
  char v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  _BYTE *v87;
  uint64_t v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  uint64_t v92;
  int v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  char v102;
  uint64_t v103;
  uint64_t v104;
  char *v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  char v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  __int16 v151;
  __int16 v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  unsigned __int8 v160;
  unsigned __int8 v161;
  unsigned __int8 v162;
  unsigned __int8 v163;
  __int16 v164;
  uint64_t v165;
  uint64_t v166;
  __int16 v167;
  __int16 v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  unsigned __int8 v174;
  unsigned __int8 v175;
  unsigned __int8 v176;
  unsigned __int8 v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  unsigned int v183;
  unsigned int v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  unint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  void *v203;
  uint64_t v204;
  char v205;
  uint64_t v206;
  uint64_t v207;
  __int8 v208;
  unint64_t v209;
  unint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  void *v219;
  int8x16_t v220;
  uint64x2_t v221;
  int16x8_t v222;
  uint64_t *KeyPath;
  _QWORD *v224;
  unint64_t v225;
  unint64_t v226;
  uint64_t v227;
  unsigned int v228;
  uint64_t v229;
  unsigned int v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  void *v239;
  unint64_t v240;
  unint64_t v241;
  unint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  unsigned int v246;
  unint64_t v247;
  unsigned __int16 v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  char v254;
  uint64_t v255;
  uint64_t *v256;
  _QWORD *v257;
  uint64_t v258;
  unint64_t v259;
  unint64_t v260;
  uint64_t v261;
  __int8 v262;
  unint64_t v263;
  unint64_t v264;
  unint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  void *v272;
  uint64_t *v273;
  _QWORD *v274;
  uint64_t v275;
  unint64_t v276;
  unint64_t v277;
  uint64_t v278;
  __int8 v279;
  unint64_t v280;
  unint64_t v281;
  unint64_t v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  __int16 v293;
  uint64_t v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  void *v301;
  uint64_t v302;
  uint64_t v303;
  uint64_t v304;
  __int16 v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  uint64_t v311;
  uint64_t v312;
  uint64_t *v313;
  _QWORD *v314;
  uint64_t v315;
  unint64_t v316;
  unint64_t v317;
  uint64_t v318;
  __int8 v319;
  unint64_t v320;
  unint64_t v321;
  unint64_t v322;
  uint64_t v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  uint64_t *v330;
  _QWORD *v331;
  uint64_t v332;
  unint64_t v333;
  unint64_t v334;
  unint64_t v335;
  __int8 v336;
  __int8 v337;
  unint64_t v338;
  unint64_t v339;
  uint64_t v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  uint64_t v345;
  unint64_t v346;
  uint64_t *v347;
  _QWORD *v348;
  uint64_t v349;
  unint64_t v350;
  unint64_t v351;
  unint64_t v352;
  char v353;
  unint64_t v354;
  unint64_t v355;
  unint64_t v356;
  uint64_t v357;
  uint64_t v358;
  uint64_t v359;
  uint64_t v360;
  uint64_t v361;
  uint64_t v362;
  uint64x2_t v363;
  uint64_t v364;
  uint64_t v365;
  unint64_t v366;
  uint64_t *v367;
  _QWORD *v368;
  uint64_t v369;
  unint64_t v370;
  unint64_t v371;
  uint64_t v372;
  uint64_t v373;
  uint64x2_t v374;
  unsigned int v375;
  char v376;
  uint64_t v377;
  int8x8_t v378;
  uint64_t v379;
  uint64_t v380;
  uint64_t v381;
  uint64_t v382;
  uint64_t v383;
  void *v384;
  char v385;
  uint64_t v386;
  uint64_t v387;
  uint64_t v388;
  uint64_t v389;
  uint64_t v390;
  uint64_t v391;
  uint64_t v392;
  uint64_t v393;
  uint64_t v394;
  uint64_t v395;
  uint64_t v396;
  uint64_t v397;
  uint64_t v398;
  uint64_t v399;
  unint64_t v400;
  uint64_t v401;
  uint64_t v402;
  uint64_t v403;
  uint64_t v404;
  uint64_t v405;
  uint64_t v406;
  uint64_t v407;
  void *v408;
  uint64_t v409;
  uint64_t v410;
  uint64_t v411;
  uint64_t v412;
  int v413;
  uint64_t v414;
  uint64_t v415;
  uint64_t v416;
  uint64_t v417;
  uint64_t v418;
  uint64_t v419;
  uint64_t v420;
  uint64_t v421;
  uint64_t v422;
  uint64_t v423;
  void *v424;
  uint64_t v425;
  uint64_t v426;
  unint64_t v427;
  unint64_t v428;
  unint64_t v429;
  uint64_t v430;
  uint64_t v431;
  uint64_t v432;
  uint64_t v433;
  uint64_t v434;
  uint64_t v435;
  uint64_t v436;
  uint64_t v437;
  uint64_t v438;
  uint64_t v439;
  uint64_t v440;
  uint64_t v441;
  uint64_t v442;
  uint64_t v443;
  uint64_t v444;
  uint64_t v445;
  uint64_t v446;
  uint64_t v447;
  char v448;
  uint64_t v449;
  uint64_t v450;
  unint64_t v451;
  unint64_t v452;
  uint64_t v453;
  uint64_t v454;
  uint64_t v455;
  uint64_t v456;
  uint64_t v457;
  uint64_t v458;
  uint64_t v459;
  uint64_t v460;
  uint64_t v461;
  uint64_t v462;
  uint64_t v463;
  unsigned __int16 v464;
  uint64_t v465;
  uint64_t v466;
  uint64_t v467;
  uint64_t v468;
  uint64_t v469;
  char v470;
  char v471;
  char v472;
  char v473;
  char v474;
  char v475;
  char v476;
  char v477;
  uint64_t v478;
  uint64_t v479;
  uint64_t v480;
  uint64_t v481;
  uint64_t v482;
  uint64_t v483;
  uint64_t v484;
  uint64_t v485;
  uint64_t v486;
  uint64_t v487;
  uint64_t v488;
  uint64_t v489;
  uint64_t v490;
  uint64_t v491;
  _OWORD *v492;
  __int128 v493;
  __int128 v494;
  __int128 v495;
  __int128 v496;
  uint64_t v497;
  uint64_t v498;
  uint64_t v499;
  uint64_t v500;
  uint64_t v501;
  uint64_t v502;
  uint64_t v503;
  uint64_t v504;
  uint64_t v505;
  uint64_t v506;
  uint64_t v507;
  uint64_t v508;
  uint64_t v509;
  _QWORD *v510;
  _OWORD *v511;
  _OWORD *v512;
  _QWORD *v513;
  _OWORD *v514;
  _QWORD *v515;
  _OWORD *v516;
  _QWORD *v517;
  _OWORD *v518;
  _QWORD *v519;
  uint64_t v520;
  _QWORD *v521;
  _QWORD *v522;
  uint64_t *v523;
  uint64_t v524;
  uint64_t v525;
  __int16 v526;
  unint64_t v527;
  __int16 v528;
  unsigned int v529;
  uint64_t v530;
  uint64_t v531;
  uint64_t v532;
  uint64_t v533;
  uint64_t v534;
  uint64_t v535;
  uint64_t v536;
  uint64_t v537;
  uint64_t v538;
  uint64_t v539;
  uint64_t v540;
  uint64_t v541;
  uint64_t v542;
  uint64_t v543;
  void *v544;
  void *v545;
  uint64_t v546;
  uint64_t v547;
  uint64_t v548;
  unsigned int v549;
  uint64_t v550;
  uint64_t v551;
  uint64_t v552;
  uint64_t v553;
  uint64_t v554;
  uint64_t v555;
  uint64_t v556;
  uint64_t v557;
  unint64_t v558;
  uint64_t v559;
  uint64_t v560;
  uint64_t v561;
  uint64_t v562;
  uint64_t v563;
  _QWORD *v564;
  __int128 *v565;
  __int128 v566;
  uint64_t v567;
  unint64_t v568;
  uint64_t v569;
  unint64_t v570;
  uint64_t v571;
  uint64_t v572;
  char v573;
  char v574;
  uint64_t v575;
  uint64_t v576;
  uint64_t v577;
  uint64_t v578;
  uint64_t v579;
  uint64_t v580;
  _BYTE *v581;
  uint64_t v582;
  uint64_t v583;
  uint64_t v584;
  uint64_t v585;
  uint64_t v586;
  uint64_t v587;
  uint64_t v588;
  uint64_t v589;
  unsigned int v590;
  unsigned int v591;
  unsigned int v592;
  unsigned int v593;
  unsigned int v594;
  unsigned int v595;
  uint64_t v596;
  uint64_t v597;
  uint64_t v598;
  uint64_t v599;
  uint64_t v600;
  uint64_t v601;
  uint64_t v602;
  uint64_t v603;
  _QWORD *v604;
  _QWORD *v605;
  uint64_t v606;
  _BYTE *v607;
  uint64_t v608;
  uint64_t v609;
  unint64_t v610;
  uint64_t v611;
  uint64_t v612;
  char v613;
  char v614;
  _BYTE *v615;
  uint64_t v616;
  uint64_t v617;
  unint64_t v618;
  uint64_t v619;
  uint64_t v620;
  _BYTE *v621;
  uint64_t v622;
  uint64_t v623;
  unint64_t v624;
  uint64_t v625;
  uint64_t v626;
  int v627;
  char v628;
  char v629;
  unint64_t v630;
  unint64_t v631;
  uint64_t v632;
  uint64_t v633;
  NSString v634;
  char v635;
  NSString v636;
  char v637;
  uint64_t v638;
  uint64_t v639;
  uint64_t v640;
  uint64_t v641;
  uint64_t v642;
  uint64_t v643;
  uint64_t v644;
  uint64_t v645;
  uint64_t v646;
  uint64_t v647;
  unint64_t v648;
  uint64_t v649;
  uint64_t v650;
  uint64_t v651;
  uint64_t v652;
  uint64_t v653;
  uint64_t v654;
  uint64_t v655;
  char v656;
  uint64_t v657;
  uint64_t v658;
  uint64_t v659;
  uint64_t v660;
  uint64_t v661;
  uint64_t v662;
  uint64_t v663;
  uint64_t v664;
  uint64_t v665;
  NSObject *v666;
  os_log_type_t v667;
  uint64_t v668;
  uint64_t v669;
  uint64_t v670;
  uint64_t v671;
  unint64_t v672;
  unint64_t v673;
  unint64_t v674;
  uint64_t v675;
  uint64_t v676;
  uint64_t v677;
  uint64_t v678;
  uint64_t v679;
  char *v680;
  uint64_t v681;
  unsigned int v682;
  uint64_t v683;
  uint64_t v684;
  uint64_t v685;
  uint64_t v686;
  uint64_t v687;
  uint64_t v688;
  uint64_t v689;
  uint64_t v690;
  uint64_t v691;
  uint64_t v692;
  void (*v693)(void);
  uint64_t v694;
  uint64_t v695;
  uint64_t v696;
  uint64_t v697;
  uint64_t v698;
  uint64_t v699;
  uint64_t v700;
  uint64_t v701;
  uint64_t v702;
  uint64_t v703;
  uint64_t v704;
  uint64_t v705;
  uint64_t v706;
  char v707;
  uint64_t v708;
  unint64_t v709;
  uint64_t v710;
  uint64_t v711;
  uint64_t v712;
  uint64_t v713;
  uint64_t v714;
  uint64_t v715;
  uint64_t v716;
  Swift::String v717;
  void *object;
  Swift::String v719;
  Swift::String v720;
  void *v721;
  Swift::String v722;
  uint64_t v723;
  uint64_t v724;
  _QWORD *v725;
  _QWORD *v726;
  __int128 *v727;
  _OWORD *v728;
  _QWORD *v729;
  __int128 *v730;
  _QWORD *v731;
  _OWORD *v732;
  _OWORD *v733;
  _QWORD *v734;
  int v735;
  int v736;
  _QWORD *v737;
  uint64_t v738;
  _OWORD *v739;
  uint64_t v740;
  uint64_t v741;
  uint64_t v742;
  uint64_t v743;
  uint64_t v744;
  uint64_t v745;
  uint64_t v746;
  uint64_t v747;
  uint64_t v748;
  uint64_t v749;
  uint64_t v750;
  uint64_t v751;
  int v752;
  int v753;
  int v754;
  int v755;
  int v756;
  int v757;
  int v758;
  int v759;
  int v760;
  int v761;
  int v762;
  uint64_t v763;
  uint64_t v764;
  unint64_t v765;
  unint64_t v766;
  unint64_t v767;
  unint64_t v768;
  unint64_t v769;
  unint64_t v770;
  int8x16_t v771;
  char *v772;
  unint64_t v773;
  _BYTE *v774;
  unint64_t v775;
  uint64_t v776;
  __int128 v777;
  uint64_t v778;
  __int128 v779;
  uint64_t v780;
  __int128 v781;
  uint64_t v782;
  __int128 v783;
  uint64_t v784;
  __int128 v785;
  uint64_t v786;
  __int128 v787;
  uint64_t v788;
  __int128 v789;
  uint64_t v790;
  __int128 v791;
  uint64_t v792;
  __int128 v793;
  uint64_t v794;
  __int128 v795;
  uint64_t v796;
  __int128 v797;
  uint64_t v798;
  __int128 v799;
  uint64_t v800;
  __int128 v801;
  uint64_t v802;
  __int128 v803;
  uint64_t v804;
  __int128 v805;
  uint64_t v806;
  __int128 v807;
  uint64_t v808;
  __int128 v809;
  uint64_t v810;
  __int128 v811;
  uint64_t v812;
  __int128 v813;
  uint64_t v814;
  __int128 v815;
  uint64_t v816;
  __int128 v817;
  uint64_t v818;
  __int128 v819;
  uint64_t v820;
  __int128 v821;
  uint64_t v822;
  __int128 v823;
  uint64_t v824;
  __int128 v825;
  uint64_t v826;
  __int128 v827;
  uint64_t v828;
  __int128 v829;
  uint64_t v830;
  __int128 v831;
  uint64_t v832;
  __int128 v833;
  uint64_t v834;
  __int128 v835;
  uint64_t v836;
  __int128 v837;
  uint64_t v838;
  __int128 v839;
  uint64_t v840;
  __int128 v841;
  uint64_t v842;
  __int128 v843;
  uint64_t v844;
  __int128 v845;
  uint64_t v846;
  __int128 v847;
  uint64_t v848;
  __int128 v849;
  uint64_t v850;
  __int128 v851;
  uint64_t v852;
  __int128 v853;
  uint64_t v854;
  __int128 v855;
  uint64_t v856;
  __int128 v857;
  uint64_t v858;
  __int128 v859;
  uint64_t v860;
  __int128 v861;
  uint64_t v862;
  __int128 v863;
  uint64_t v864;
  __int128 v865;
  uint64_t v866;
  __int128 v867;
  uint64_t v868;
  __int128 v869;
  uint64_t v870;
  __int128 v871;
  uint64_t v872;
  __int128 v873;
  uint64_t v874;
  __int128 v875;
  uint64_t v876;
  __int128 v877;
  uint64_t v878;
  __int128 v879;
  uint64_t v880;
  __int128 v881;
  uint64_t v882;
  __int128 v883;
  uint64_t v884;
  __int128 v885;
  uint64_t v886;
  __int128 v887;
  uint64_t v888;
  __int128 v889;
  uint64_t v890;
  __int128 v891;
  uint64_t v892;
  __int128 v893;
  uint64_t v894;
  __int128 v895;
  uint64_t v896;
  __int128 v897;
  uint64_t v898;
  __int128 v899;
  uint64_t v900;
  __int128 v901;
  uint64_t v902;
  __int128 v903;
  uint64_t v904;
  __int128 v905;
  uint64_t v906;
  __int128 v907;
  uint64_t v908;
  __int128 v909;
  uint64_t v910;
  __int128 v911;
  uint64_t v912;
  __int128 v913;
  uint64_t v914;
  __int128 v915;
  uint64_t v916;
  __int128 v917;
  uint64_t v918;
  __int128 v919;
  uint64_t v920;
  __int128 v921;
  uint64_t v922;
  __int128 v923;
  uint64_t v924;
  __int128 v925;
  uint64_t v926;
  __int128 v927;
  uint64_t v928;
  __int128 v929;
  uint64_t v930;
  __int128 v931;
  uint64_t v932;
  __int128 v933;
  uint64_t v934;
  __int128 v935;
  uint64_t v936;
  __int128 v937;
  uint64_t v938;
  __int128 v939;
  uint64_t v940;
  __int128 v941;
  uint64_t v942;
  __int128 v943;
  uint64_t v944;
  __int128 v945;
  uint64_t v946;
  __int128 v947;
  uint64_t v948;
  __int128 v949;
  uint64_t v950;
  __int128 v951;
  uint64_t v952;
  __int128 v953;
  uint64_t v954;
  __int128 v955;
  uint64_t v956;
  __int128 v957;
  uint64_t v958;
  __int128 v959;
  uint64_t v960;
  __int128 v961;
  uint64_t v962;
  __int128 v963;
  uint64_t v964;
  __int128 v965;
  uint64_t v966;
  __int128 v967;
  uint64_t v968;
  __int128 v969;
  uint64_t v970;
  __int128 v971;
  uint64_t v972;
  __int128 v973;
  uint64_t v974;
  __int128 v975;
  uint64_t v976;
  __int128 v977;
  uint64_t v978;
  __int128 v979;
  uint64_t v980;
  __int128 v981;
  uint64_t v982;
  __int128 v983;
  uint64_t v984;
  __int128 v985;
  uint64_t v986;
  __int128 v987;
  uint64_t v988;
  __int128 v989;
  uint64_t v990;
  __int128 v991;
  uint64_t v992;
  __int128 v993;
  uint64_t v994;
  __int128 v995;
  uint64_t v996;
  __int128 v997;
  uint64_t v998;
  __int128 v999;
  uint64_t v1000;
  __int128 v1001;
  uint64_t v1002;
  __int128 v1003;
  uint64_t v1004;
  __int128 v1005;
  uint64_t v1006;
  __int128 v1007;
  uint64_t v1008;
  __int128 v1009;
  uint64_t v1010;
  __int128 v1011;
  uint64_t v1012;
  __int128 v1013;
  uint64_t v1014;
  __int128 v1015;
  uint64_t v1016;
  __int128 v1017;
  uint64_t v1018;
  __int128 v1019;
  uint64_t v1020;
  __int128 v1021;
  uint64_t v1022;
  __int128 v1023;
  uint64_t v1024;
  __int128 v1025;
  uint64_t v1026;
  __int128 v1027;
  uint64_t v1028;
  __int128 v1029;
  uint64_t v1030;
  __int128 v1031;
  uint64_t v1032;
  __int128 v1033;
  __int128 v1034;
  __int128 v1035;
  __int128 v1036;
  __int128 v1037;
  __int128 v1038;
  __int128 v1039;
  __int128 v1040;
  __int128 v1041;
  __int128 v1042;
  __int128 v1043;
  __int128 v1044;
  __int128 v1045;
  __int128 v1046;
  __int128 v1047;
  __int128 v1048;
  uint64_t v1049;
  uint64x2_t v1050;
  unint64_t v1051;
  unint64_t v1052;
  _OWORD v1053[10];
  _OWORD v1054[230];
  _BYTE v1055[1608];
  uint64_t v1056;
  __int128 v1057;
  uint64_t v1058;
  _QWORD v1059[3];
  __int128 v1060;
  uint64_t v1061;
  uint64_t v1062;
  __int128 v1063;
  uint64_t v1064;
  uint64_t v1065;
  __int128 v1066;
  uint64_t v1067;
  uint64_t v1068;
  __int128 v1069;
  uint64_t v1070;
  uint64_t v1071;
  __int128 v1072;
  uint64_t v1073;
  uint64_t v1074;
  __int128 v1075;
  uint64_t v1076;
  _QWORD v1077[3];
  __int128 v1078;
  uint64_t v1079;
  uint64_t v1080;
  __int128 v1081;
  uint64_t v1082;
  uint64_t v1083;
  __int128 v1084;
  uint64_t v1085;
  uint64_t v1086;
  __int128 v1087;
  uint64_t v1088;
  uint64_t v1089;
  __int128 v1090;
  uint64_t v1091;
  uint64_t v1092;
  __int128 v1093;
  uint64_t v1094;
  _QWORD v1095[3];
  __int128 v1096;
  uint64_t v1097;
  uint64_t v1098;
  _QWORD v1099[3];
  __int128 v1100;
  uint64_t v1101;
  uint64_t v1102;
  __int128 v1103;
  uint64_t v1104;
  uint64_t v1105;
  __int128 v1106;
  uint64_t v1107;
  uint64_t v1108;
  __int128 v1109;
  uint64_t v1110;
  uint64_t v1111;
  __int128 v1112;
  uint64_t v1113;
  __int128 v1114;
  uint64_t v1115;
  _QWORD v1116[3];
  __int128 v1117;
  uint64_t v1118;
  uint64_t v1119;
  __int128 v1120;
  uint64_t v1121;
  uint64_t v1122;
  __int128 v1123;
  uint64_t v1124;
  uint64_t v1125;
  __int128 v1126;
  uint64_t v1127;
  uint64_t v1128;
  __int128 v1129;
  uint64_t v1130;
  uint64_t v1131;
  __int128 v1132;
  uint64_t v1133;
  _QWORD v1134[3];
  __int128 v1135;
  uint64_t v1136;
  uint64_t v1137;
  __int128 v1138;
  uint64_t v1139;
  uint64_t v1140;
  __int128 v1141;
  uint64_t v1142;
  uint64_t v1143;
  __int128 v1144;
  uint64_t v1145;
  uint64_t v1146;
  __int128 v1147;
  uint64_t v1148;
  uint64_t v1149;
  __int128 v1150;
  uint64_t v1151;
  _QWORD v1152[3];
  __int128 v1153;
  uint64_t v1154;
  uint64_t v1155;
  __int128 v1156;
  uint64_t v1157;
  uint64_t v1158;
  __int128 v1159;
  uint64_t v1160;
  uint64_t v1161;
  __int128 v1162;
  uint64_t v1163;
  uint64_t v1164;
  __int128 v1165;
  uint64_t v1166;
  uint64_t v1167;
  __int128 v1168;
  uint64_t v1169;
  _QWORD v1170[3];
  __int128 v1171;
  uint64_t v1172;
  uint64_t v1173;
  __int128 v1174;
  uint64_t v1175;
  uint64_t v1176;
  __int128 v1177;
  uint64_t v1178;
  uint64_t v1179;
  _OWORD v1180[100];
  uint64_t v1181[200];
  _QWORD v1182[14];
  __int128 v1183;
  _BYTE v1184[32];
  __int128 v1185;
  __int128 v1186;
  __int128 v1187;
  __int128 v1188;

  v773 = a6;
  v774 = a5;
  v775 = a3;
  v776 = a2;
  v7 = type metadata accessor for Logger(0);
  v770 = *(_QWORD *)(v7 - 8);
  v771.i64[0] = v7;
  __chkstk_darwin();
  v772 = (char *)&v725 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  v9 = type metadata accessor for DNSRecords.SRV(0);
  __chkstk_darwin();
  v11 = (char *)&v725 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin();
  v13 = (char *)&v725 - v12;
  sub_100012C44(&qword_100405BC8);
  __chkstk_darwin();
  v15 = (char *)&v725 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  v769 = 0;
  v16 = type metadata accessor for AWDLStatistics.LowLatencyStatistics(0);
  v17 = *(_QWORD *)(v16 - 8);
  __chkstk_darwin();
  v19 = (char *)&v725 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  result = _swiftEmptyArrayStorage;
  v768 = a1;
  switch(a1)
  {
    case 1uLL:
      v21 = sub_100012C44(&qword_100405BD0);
      v22 = type metadata accessor for DriverEvent(0);
      v23 = *(_QWORD *)(v22 - 8);
      v24 = *(_QWORD *)(v23 + 72);
      v25 = *(unsigned __int8 *)(v23 + 80);
      v26 = (v25 + 32) & ~v25;
      v27 = swift_allocObject(v21, v26 + v24, v25 | 7);
      *(_OWORD *)(v27 + 16) = xmmword_10033A110;
      v28 = v27 + v26;
      *(_OWORD *)v28 = 0u;
      *(_OWORD *)(v28 + 16) = 0u;
      *(_OWORD *)(v28 + 25) = 0u;
      goto LABEL_9;
    case 2uLL:
      v29 = sub_100012C44(&qword_100405BD0);
      v22 = type metadata accessor for DriverEvent(0);
      v30 = *(_QWORD *)(v22 - 8);
      v31 = *(_QWORD *)(v30 + 72);
      v32 = *(unsigned __int8 *)(v30 + 80);
      v33 = (v32 + 32) & ~v32;
      v27 = swift_allocObject(v29, v33 + v31, v32 | 7);
      *(_OWORD *)(v27 + 16) = xmmword_10033A110;
      v28 = v27 + v33;
      v34 = 2;
      goto LABEL_8;
    case 3uLL:
      v35 = sub_100012C44(&qword_100405BD0);
      v22 = type metadata accessor for DriverEvent(0);
      v36 = *(_QWORD *)(v22 - 8);
      v37 = *(_QWORD *)(v36 + 72);
      v38 = *(unsigned __int8 *)(v36 + 80);
      v39 = (v38 + 32) & ~v38;
      v27 = swift_allocObject(v35, v39 + v37, v38 | 7);
      *(_OWORD *)(v27 + 16) = xmmword_10033A110;
      v28 = v27 + v39;
      v34 = 3;
      goto LABEL_8;
    case 9uLL:
      type metadata accessor for apple80211_join_status(0);
      v41 = v40;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v41, v42, v43);
      sub_100063EB8((uint64_t)&v1033, (uint64_t)&v1050, &qword_100405BE0);
      sub_100063EB8((uint64_t)&v1050, (uint64_t)v1055, &qword_100405BE0);
      if (sub_1000636E8((uint64_t)v1055) == 1)
        goto LABEL_181;
      memcpy(v1181, v1055, 0x1CCuLL);
      v44 = sub_100012C44(&qword_100405BD0);
      v45 = type metadata accessor for DriverEvent(0);
      v46 = *(_QWORD *)(v45 - 8);
      v47 = *(_QWORD *)(v46 + 72);
      v48 = *(unsigned __int8 *)(v46 + 80);
      v49 = (v48 + 32) & ~v48;
      v50 = swift_allocObject(v44, v49 + v47, v48 | 7);
      *(_OWORD *)(v50 + 16) = xmmword_10033A110;
      v51 = v50 + v49;
      *(_QWORD *)v51 = sub_1000ADA58() & 0xFFFFFFFFFFFFLL;
      *(_QWORD *)(v51 + 8) = v52;
      *(_QWORD *)(v51 + 16) = v54;
      *(_QWORD *)(v51 + 24) = v53;
      *(_QWORD *)(v51 + 32) = 0;
      v55 = 1024;
      goto LABEL_99;
    case 0xBuLL:
      v56 = sub_100012C44(&qword_100405BD0);
      v22 = type metadata accessor for DriverEvent(0);
      v57 = *(_QWORD *)(v22 - 8);
      v58 = *(_QWORD *)(v57 + 72);
      v59 = *(unsigned __int8 *)(v57 + 80);
      v60 = (v59 + 32) & ~v59;
      v27 = swift_allocObject(v56, v60 + v58, v59 | 7);
      *(_OWORD *)(v27 + 16) = xmmword_10033A110;
      v28 = v27 + v60;
      v34 = 1;
LABEL_8:
      *(_QWORD *)v28 = v34;
      *(_OWORD *)(v28 + 24) = 0u;
      *(_OWORD *)(v28 + 8) = 0u;
      *(_BYTE *)(v28 + 40) = 0;
LABEL_9:
      *(_BYTE *)(v28 + 41) = 10;
      v61 = v22;
      v62 = 2;
      goto LABEL_10;
    case 0x2EuLL:
      v63 = sub_100012C44(&qword_100405BD0);
      v64 = type metadata accessor for DriverEvent(0);
      v65 = *(_QWORD *)(v64 - 8);
      v66 = *(_QWORD *)(v65 + 72);
      v67 = *(unsigned __int8 *)(v65 + 80);
      v68 = (v67 + 32) & ~v67;
      v69 = swift_allocObject(v63, v68 + v66, v67 | 7);
      *(_OWORD *)(v69 + 16) = xmmword_10033A110;
      v70 = v69 + v68;
      v71 = type metadata accessor for DriverEvent.AWDL(0);
      v72 = v69 + v68;
      v73 = 10;
      goto LABEL_188;
    case 0x2FuLL:
      type metadata accessor for apple80211_peer_presence_indication(0);
      v75 = v74;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v75, v42, v43);
      if ((v1055[68] & 1) != 0)
        goto LABEL_181;
      if (*(_DWORD *)&v1055[8] != 1)
        goto LABEL_186;
      v76 = v1055[0];
      v774 = (_BYTE *)(*(_QWORD *)v1055 >> 40);
      v77 = v1055[4];
      v78 = *(_QWORD *)v1055 >> 24;
      v79 = *(_QWORD *)v1055 >> 16;
      v80 = *(_QWORD *)v1055 >> 8;
      v81 = sub_100012C44(&qword_100405BD0);
      v82 = type metadata accessor for DriverEvent(0);
      v83 = *(_QWORD *)(v82 - 8);
      v84 = *(_QWORD *)(v83 + 72);
      v85 = *(unsigned __int8 *)(v83 + 80);
      v86 = (v85 + 32) & ~v85;
      v50 = swift_allocObject(v81, v86 + v84, v85 | 7);
      *(_OWORD *)(v50 + 16) = xmmword_10033A110;
      v87 = (_BYTE *)(v50 + v86);
      *v87 = v76;
      v87[1] = v80;
      v87[2] = v79;
      v87[3] = v78;
      v87[4] = v77;
      v87[5] = (_BYTE)v774;
      v88 = type metadata accessor for DriverEvent.AWDL(0);
      swift_storeEnumTagMultiPayload(v50 + v86, v88, 7);
      swift_storeEnumTagMultiPayload(v50 + v86, v82, 1);
      v90 = v775;
      v89 = v776;
      goto LABEL_209;
    case 0x30uLL:
      __asm { BR              X9 }
      return result;
    case 0x31uLL:
      type metadata accessor for apple80211_chip_reset(0);
      v92 = v91;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v92, v42, v43);
      if ((v1055[4] & 1) != 0)
        goto LABEL_181;
      v93 = *(_DWORD *)v1055;
      v94 = sub_100012C44(&qword_100405BD0);
      v95 = type metadata accessor for DriverEvent(0);
      v96 = *(_QWORD *)(v95 - 8);
      v97 = *(_QWORD *)(v96 + 72);
      v98 = *(unsigned __int8 *)(v96 + 80);
      v99 = (v98 + 32) & ~v98;
      v100 = swift_allocObject(v94, v99 + v97, v98 | 7);
      *(_OWORD *)(v100 + 16) = xmmword_10033A110;
      v101 = v100 + v99;
      v102 = v93 == 1;
      goto LABEL_21;
    case 0x37uLL:
      type metadata accessor for apple80211_driver_availability(0);
      v104 = v103;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v104, v42, v43);
      sub_100063EB8((uint64_t)&v1033, (uint64_t)&v1050, &qword_100405BE8);
      sub_100063EB8((uint64_t)&v1050, (uint64_t)v1055, &qword_100405BE8);
      if (sub_100063704((uint64_t)v1055) == 1)
        goto LABEL_181;
      v105 = v772;
      if (!*(_DWORD *)&v1055[8])
        goto LABEL_182;
      v106 = sub_100012C44(&qword_100405BD0);
      v95 = type metadata accessor for DriverEvent(0);
      v107 = *(_QWORD *)(v95 - 8);
      v108 = *(_QWORD *)(v107 + 72);
      v109 = *(unsigned __int8 *)(v107 + 80);
      v110 = (v109 + 32) & ~v109;
      v100 = swift_allocObject(v106, v110 + v108, v109 | 7);
      *(_OWORD *)(v100 + 16) = xmmword_10033A110;
      v101 = v100 + v110;
      v102 = 4;
LABEL_21:
      *(_BYTE *)v101 = v102;
      v111 = v95;
      v112 = 4;
      goto LABEL_171;
    case 0x3BuLL:
      v113 = sub_100012C44(&qword_100405BD0);
      v114 = type metadata accessor for DriverEvent(0);
      v115 = *(_QWORD *)(v114 - 8);
      v116 = *(_QWORD *)(v115 + 72);
      v117 = *(unsigned __int8 *)(v115 + 80);
      v118 = (v117 + 32) & ~v117;
      v27 = swift_allocObject(v113, v118 + v116, v117 | 7);
      *(_OWORD *)(v27 + 16) = xmmword_10033A110;
      v28 = v27 + v118;
      v61 = v114;
      v62 = 5;
LABEL_10:
      swift_storeEnumTagMultiPayload(v28, v61, v62);
      return (_QWORD *)v27;
    case 0x41uLL:
      v119 = sub_100012C44(&qword_100405BD0);
      v64 = type metadata accessor for DriverEvent(0);
      v120 = *(_QWORD *)(v64 - 8);
      v121 = *(_QWORD *)(v120 + 72);
      v122 = *(unsigned __int8 *)(v120 + 80);
      v123 = (v122 + 32) & ~v122;
      v69 = swift_allocObject(v119, v123 + v121, v122 | 7);
      *(_OWORD *)(v69 + 16) = xmmword_10033A110;
      v70 = v69 + v123;
      v71 = type metadata accessor for DriverEvent.AWDL(0);
      v72 = v69 + v123;
      v73 = 12;
      goto LABEL_188;
    case 0x42uLL:
      type metadata accessor for apple80211_assoc_ready(0);
      v125 = v124;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v125, v42, v43);
      if ((v1055[24] & 1) != 0)
        goto LABEL_181;
      v126 = *(_QWORD *)&v1055[16];
      v127 = *(_QWORD *)&v1055[8];
      v128 = *(_QWORD *)v1055;
      v129 = sub_100012C44(&qword_100405BD0);
      v130 = type metadata accessor for DriverEvent(0);
      v131 = *(_QWORD *)(v130 - 8);
      v132 = *(_QWORD *)(v131 + 72);
      v133 = *(unsigned __int8 *)(v131 + 80);
      v134 = (v133 + 32) & ~v133;
      v135 = swift_allocObject(v129, v134 + v132, v133 | 7);
      *(_OWORD *)(v135 + 16) = xmmword_10033A110;
      v136 = v135 + v134;
      sub_1000ADBB4(v128, v127, v126, (uint64_t)v1055);
      v137 = v1055[40];
      *(_QWORD *)v136 = *(unsigned __int16 *)v1055;
      *(_OWORD *)(v136 + 8) = *(_OWORD *)&v1055[8];
      *(_OWORD *)(v136 + 24) = *(_OWORD *)&v1055[24];
      *(_BYTE *)(v136 + 40) = v137;
      *(_BYTE *)(v136 + 41) = 5;
      swift_storeEnumTagMultiPayload(v135 + v134, v130, 2);
      v138 = v776;
      goto LABEL_178;
    case 0x43uLL:
      v139 = sub_100012C44(&qword_100405BD0);
      v64 = type metadata accessor for DriverEvent(0);
      v140 = *(_QWORD *)(v64 - 8);
      v141 = *(_QWORD *)(v140 + 72);
      v142 = *(unsigned __int8 *)(v140 + 80);
      v143 = (v142 + 32) & ~v142;
      v69 = swift_allocObject(v139, v143 + v141, v142 | 7);
      *(_OWORD *)(v69 + 16) = xmmword_10033A110;
      v70 = v69 + v143;
      *(_BYTE *)(v69 + v143) = 1;
      goto LABEL_28;
    case 0x44uLL:
      v144 = sub_100012C44(&qword_100405BD0);
      v64 = type metadata accessor for DriverEvent(0);
      v145 = *(_QWORD *)(v64 - 8);
      v146 = *(_QWORD *)(v145 + 72);
      v147 = *(unsigned __int8 *)(v145 + 80);
      v148 = (v147 + 32) & ~v147;
      v69 = swift_allocObject(v144, v148 + v146, v147 | 7);
      *(_OWORD *)(v69 + 16) = xmmword_10033A110;
      v70 = v69 + v148;
      *(_BYTE *)(v69 + v148) = 0;
LABEL_28:
      v71 = type metadata accessor for DriverEvent.AWDL(0);
      v72 = v70;
      v73 = 0;
      goto LABEL_188;
    case 0x4AuLL:
      type metadata accessor for apple80211_message_auth(0);
      v150 = v149;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v150, v42, v43);
      if ((v1055[104] & 1) != 0)
        goto LABEL_181;
      v151 = *(_WORD *)&v1055[4];
      v152 = *(_WORD *)v1055;
      v153 = sub_100012C44(&qword_100405BD0);
      v154 = type metadata accessor for DriverEvent(0);
      v155 = *(_QWORD *)(v154 - 8);
      v156 = *(_QWORD *)(v155 + 72);
      v157 = *(unsigned __int8 *)(v155 + 80);
      v158 = (v157 + 32) & ~v157;
      v135 = swift_allocObject(v153, v158 + v156, v157 | 7);
      *(_OWORD *)(v135 + 16) = xmmword_10033A110;
      v159 = v135 + v158;
      v160 = _s7CoreP2P15IEEE80211StatusO8rawValueACSgs6UInt16V_tcfC_0(v152 & 0x1FF);
      if (v160 == 54)
        v161 = 1;
      else
        v161 = v160;
      v162 = _s7CoreP2P15IEEE80211ReasonO8rawValueACSgs6UInt16V_tcfC_0(v151 & 0x1FF);
      if (v162 == 34)
        v163 = 1;
      else
        v163 = v162;
      *(_QWORD *)v159 = v161 | ((unint64_t)v163 << 8);
      *(_OWORD *)(v159 + 8) = 0u;
      *(_OWORD *)(v159 + 24) = 0u;
      v164 = 1792;
      goto LABEL_45;
    case 0x4EuLL:
      type metadata accessor for apple80211_message_assoc(0);
      v166 = v165;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v166, v42, v43);
      if ((v1055[8] & 1) != 0)
        goto LABEL_181;
      v167 = *(_WORD *)&v1055[4];
      v168 = *(_WORD *)v1055;
      v169 = sub_100012C44(&qword_100405BD0);
      v154 = type metadata accessor for DriverEvent(0);
      v170 = *(_QWORD *)(v154 - 8);
      v171 = *(_QWORD *)(v170 + 72);
      v172 = *(unsigned __int8 *)(v170 + 80);
      v173 = (v172 + 32) & ~v172;
      v135 = swift_allocObject(v169, v173 + v171, v172 | 7);
      *(_OWORD *)(v135 + 16) = xmmword_10033A110;
      v159 = v135 + v173;
      v174 = _s7CoreP2P15IEEE80211StatusO8rawValueACSgs6UInt16V_tcfC_0(v168 & 0x1FF);
      if (v174 == 54)
        v175 = 1;
      else
        v175 = v174;
      v176 = _s7CoreP2P15IEEE80211ReasonO8rawValueACSgs6UInt16V_tcfC_0(v167 & 0x1FF);
      if (v176 == 34)
        v177 = 1;
      else
        v177 = v176;
      *(_QWORD *)v159 = v175 | ((unint64_t)v177 << 8);
      *(_OWORD *)(v159 + 8) = 0u;
      *(_OWORD *)(v159 + 24) = 0u;
      v164 = 1536;
LABEL_45:
      *(_WORD *)(v159 + 40) = v164;
      v178 = v159;
      v179 = v154;
      v180 = 2;
      goto LABEL_177;
    case 0x52uLL:
      type metadata accessor for apple80211_channel(0);
      v182 = v181;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v182, v42, v43);
      if ((v1055[12] & 1) != 0)
        goto LABEL_181;
      v183 = *(_DWORD *)&v1055[8];
      v184 = *(_DWORD *)&v1055[4];
      v185 = sub_100012C44(&qword_100405BD0);
      v186 = type metadata accessor for DriverEvent(0);
      v187 = *(_QWORD *)(v186 - 8);
      v188 = *(_QWORD *)(v187 + 72);
      v189 = *(unsigned __int8 *)(v187 + 80);
      v190 = (v189 + 32) & ~v189;
      v135 = swift_allocObject(v185, v190 + v188, v189 | 7);
      *(_OWORD *)(v135 + 16) = xmmword_10033A110;
      v191 = v135 + v190;
      *(_QWORD *)v191 = sub_1000B388C(v184, v183) & 0xFFFFFFFFFFFFLL;
      *(_OWORD *)(v191 + 8) = 0u;
      *(_OWORD *)(v191 + 24) = 0u;
      *(_WORD *)(v191 + 40) = 2048;
      v178 = v135 + v190;
      v179 = v186;
      v180 = 2;
      goto LABEL_177;
    case 0x5FuLL:
      type metadata accessor for apple80211_nan_device_role_changed_event_data(0);
      v193 = v192;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v193, v42, v43);
      if ((v1055[12] & 1) != 0)
        goto LABEL_181;
      v194 = v1055[8];
      v195 = *(_QWORD *)v1055;
      v196 = sub_100012C44(&qword_100405BD0);
      v197 = type metadata accessor for DriverEvent(0);
      v198 = *(_QWORD *)(v197 - 8);
      v199 = *(_QWORD *)(v198 + 72);
      v200 = *(unsigned __int8 *)(v198 + 80);
      v201 = (v200 + 32) & ~v200;
      v202 = swift_allocObject(v196, v201 + v199, v200 | 7);
      *(_OWORD *)(v202 + 16) = xmmword_10033A110;
      v203 = (void *)(v202 + v201);
      if ((_DWORD)v195 == 3)
      {
        v204 = v202;
        v205 = HIDWORD(v195) == 1;
      }
      else if ((_DWORD)v195 == 2)
      {
        v204 = v202;
        v205 = 4;
      }
      else
      {
        v204 = v202;
        if ((_DWORD)v195 == 1)
          v205 = 3;
        else
          v205 = 0;
      }
      v1055[0] = v205;
      *(_QWORD *)&v1055[8] = v194;
      sub_100063F60((uint64_t)v1055);
      sub_100063888(v1055, v203);
      v545 = v203;
      v546 = v197;
      goto LABEL_218;
    case 0x61uLL:
      type metadata accessor for apple80211_nan_cluster_changed_event_data(0);
      v207 = v206;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v207, v42, v43);
      if ((v1050.i8[6] & 1) != 0)
        goto LABEL_181;
      v208 = v1050.i8[0];
      v209 = v1050.u32[0] | ((unint64_t)v1050.u16[2] << 32);
      v210 = (unint64_t)v1050.u16[2] >> 8;
      v211 = sub_100012C44(&qword_100405BD0);
      v212 = type metadata accessor for DriverEvent(0);
      v213 = *(_QWORD *)(v212 - 8);
      v214 = *(_QWORD *)(v213 + 72);
      v215 = *(unsigned __int8 *)(v213 + 80);
      v216 = v42;
      v217 = (v215 + 32) & ~v215;
      v218 = swift_allocObject(v211, v217 + v214, v215 | 7);
      *(_OWORD *)(v218 + 16) = xmmword_10033A110;
      v219 = (void *)(v218 + v217);
      v1055[0] = v208;
      v220.i64[0] = 0xFFFFFFFFFFFFLL;
      v220.i64[1] = 0xFFFFFFFFFFFFLL;
      v221 = (uint64x2_t)vandq_s8((int8x16_t)vdupq_n_s64(v209), v220);
      v222 = (int16x8_t)vshlq_u64(v221, (uint64x2_t)xmmword_10033B100);
      *(int32x2_t *)v221.i8 = vmovn_s64((int64x2_t)vshlq_u64(v221, (uint64x2_t)xmmword_10033B0F0));
      *(int32x2_t *)v222.i8 = vmovn_s64((int64x2_t)v222);
      v222.i16[1] = v222.i16[2];
      v222.i16[2] = v221.i16[0];
      v222.i16[3] = v221.i16[2];
      *(_DWORD *)&v1055[1] = vmovn_s16(v222).u32[0];
      v1055[5] = v210;
      sub_100063F6C((uint64_t)v1055);
      goto LABEL_107;
    case 0x62uLL:
      KeyPath = (uint64_t *)swift_getKeyPath(&unk_10033F098);
      v224 = (_QWORD *)swift_getKeyPath(&unk_10033F0B8);
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      v225 = sub_1000B527C();
      v226 = sub_1000B52C0();
      sub_1000AC80C(KeyPath, v224, v42, v43, (uint64_t)&type metadata for IEEE80211Frame, v225, (uint64_t)v1055, v226);
      swift_release(KeyPath);
      swift_release(v224);
      sub_100063EB8((uint64_t)v1055, (uint64_t)&v1033, &qword_100405C38);
      sub_100063EB8((uint64_t)&v1033, (uint64_t)&v1050, &qword_100405C38);
      if (sub_10006391C((uint64_t)&v1050) == 1)
        goto LABEL_181;
      v227 = v1050.i32[0];
      v228 = v1050.u32[2];
      v229 = v1051;
      v230 = v1050.u32[3];
      v231 = HIDWORD(v1051);
      v773 = v1052;
      v232 = sub_100012C44(&qword_100405BD0);
      v233 = type metadata accessor for DriverEvent(0);
      v234 = *(_QWORD *)(v233 - 8);
      v235 = *(_QWORD *)(v234 + 72);
      v236 = *(unsigned __int8 *)(v234 + 80);
      v237 = (v236 + 32) & ~v236;
      v238 = swift_allocObject(v232, v237 + v235, v236 | 7);
      *(_OWORD *)(v238 + 16) = xmmword_10033A110;
      v774 = (_BYTE *)v238;
      v239 = (void *)(v238 + v237);
      sub_100063940((uint64_t)v1053);
      v240 = sub_1000B388C(v228, v230);
      if ((v240 & 0xFF00000000) == 0x300000000)
      {
        if (qword_100404180 != -1)
          swift_once(&qword_100404180, sub_1001902EC);
        LODWORD(v240) = static Channel.nanPrimary;
        LOBYTE(v241) = byte_1004105A4;
        LOBYTE(v242) = byte_1004105A5;
        v243 = v776;
      }
      else
      {
        v241 = HIDWORD(v240);
        v242 = v240 >> 40;
        v243 = v776;
      }
      *(_OWORD *)&v1055[128] = v1053[8];
      *(_OWORD *)&v1055[144] = v1053[9];
      *(_OWORD *)&v1055[160] = v1054[0];
      *(_OWORD *)&v1055[169] = *(_OWORD *)((char *)v1054 + 9);
      *(_OWORD *)&v1055[64] = v1053[4];
      *(_OWORD *)&v1055[80] = v1053[5];
      *(_OWORD *)&v1055[96] = v1053[6];
      *(_OWORD *)&v1055[112] = v1053[7];
      *(_OWORD *)v1055 = v1053[0];
      *(_OWORD *)&v1055[16] = v1053[1];
      *(_OWORD *)&v1055[32] = v1053[2];
      *(_OWORD *)&v1055[48] = v1053[3];
      *(_QWORD *)&v1055[192] = v227;
      *(_DWORD *)&v1055[200] = v240;
      v1055[204] = v241;
      v1055[205] = v242;
      *(_QWORD *)&v1055[208] = v229;
      *(_QWORD *)&v1055[216] = v773 | (v231 << 32);
      sub_100063D44((uint64_t)v1055);
      sub_100063888(v1055, v239);
      swift_storeEnumTagMultiPayload(v239, v233, 0);
      sub_100063D50((uint64_t)&v1033);
      v681 = v243;
      goto LABEL_201;
    case 0x63uLL:
      type metadata accessor for apple80211_nan_follow_up_tx_complete_event_data(0);
      v245 = v244;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v245, v42, v43);
      if ((v1051 & 0x100000000) != 0)
        goto LABEL_181;
      v246 = v1051;
      v247 = v1050.u64[1];
      v248 = v1050.i16[0];
      v249 = sub_100012C44(&qword_100405BD0);
      v212 = type metadata accessor for DriverEvent(0);
      v250 = *(_QWORD *)(v212 - 8);
      v251 = *(_QWORD *)(v250 + 72);
      v252 = *(unsigned __int8 *)(v250 + 80);
      v216 = v42;
      v253 = (v252 + 32) & ~v252;
      v218 = swift_allocObject(v249, v253 + v251, v252 | 7);
      *(_OWORD *)(v218 + 16) = xmmword_10033A110;
      *(_QWORD *)v1055 = sub_1000AD0CC(v248, v247, v246);
      v1055[8] = v254;
      sub_100063E70((uint64_t)v1055);
      sub_100063888(v1055, (void *)(v218 + v253));
      v255 = v218 + v253;
      goto LABEL_108;
    case 0x64uLL:
      v256 = (uint64_t *)swift_getKeyPath(&unk_10033F218);
      v257 = (_QWORD *)swift_getKeyPath(&unk_10033F238);
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      v258 = sub_100012C44(&qword_100405C48);
      v259 = sub_1000B5304();
      v260 = sub_1000B52C0();
      sub_1000AC80C(v256, v257, v42, v43, v258, v259, (uint64_t)&v1050, v260);
      swift_release(v256);
      swift_release(v257);
      v261 = *(_QWORD *)&v1053[0];
      if (!*(_QWORD *)&v1053[0])
        goto LABEL_181;
      v262 = v1050.i8[0];
      v263 = (unint64_t)v1050.i64[0] >> 8;
      v264 = (unint64_t)v1050.i64[0] >> 16;
      v265 = (unint64_t)v1050.i64[0] >> 24;
      v770 = HIDWORD(v1050.i64[0]);
      v771.i64[0] = (unint64_t)v1050.i64[0] >> 40;
      v772 = (char *)HIWORD(v1050.i64[0]);
      v773 = HIBYTE(v1050.i64[0]);
      v774 = (_BYTE *)v1050.i8[8];
      v266 = sub_100012C44(&qword_100405BD0);
      v267 = type metadata accessor for DriverEvent(0);
      v268 = *(_QWORD *)(v267 - 8);
      v269 = *(_QWORD *)(v268 + 72);
      v270 = *(unsigned __int8 *)(v268 + 80);
      v271 = (v270 + 32) & ~v270;
      v218 = swift_allocObject(v266, v271 + v269, v270 | 7);
      *(_OWORD *)(v218 + 16) = xmmword_10033A110;
      v272 = (void *)(v218 + v271);
      v1055[0] = v262;
      v1055[1] = v263;
      v1055[2] = v264;
      v1055[3] = v265;
      v1055[4] = v770;
      v1055[5] = v771.i8[0];
      v1055[6] = (_BYTE)v772;
      v1055[7] = v773;
      *(_QWORD *)&v1055[8] = v774;
      *(_QWORD *)&v1055[16] = v261;
      sub_100063F54((uint64_t)v1055);
      goto LABEL_74;
    case 0x66uLL:
      v273 = (uint64_t *)swift_getKeyPath(&unk_10033F1D8);
      v274 = (_QWORD *)swift_getKeyPath(&unk_10033F1F8);
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      v275 = sub_100012C44(&qword_100405C48);
      v276 = sub_1000B5304();
      v277 = sub_1000B52C0();
      sub_1000AC80C(v273, v274, v42, v43, v275, v276, (uint64_t)&v1050, v277);
      swift_release(v273);
      swift_release(v274);
      v278 = *(_QWORD *)&v1053[0];
      if (!*(_QWORD *)&v1053[0])
        goto LABEL_181;
      v279 = v1050.i8[0];
      v280 = (unint64_t)v1050.i64[0] >> 8;
      v281 = (unint64_t)v1050.i64[0] >> 16;
      v770 = (unint64_t)v1050.i64[0] >> 24;
      v771.i64[0] = HIDWORD(v1050.i64[0]);
      v772 = (char *)((unint64_t)v1050.i64[0] >> 40);
      v773 = HIWORD(v1050.i64[0]);
      v774 = (_BYTE *)v1050.i8[8];
      v282 = HIBYTE(v1050.i64[0]);
      v283 = sub_100012C44(&qword_100405BD0);
      v284 = type metadata accessor for DriverEvent(0);
      v285 = *(_QWORD *)(v284 - 8);
      v286 = *(_QWORD *)(v285 + 72);
      v287 = *(unsigned __int8 *)(v285 + 80);
      v288 = (v287 + 32) & ~v287;
      v289 = swift_allocObject(v283, v288 + v286, v287 | 7);
      *(_OWORD *)(v289 + 16) = xmmword_10033A110;
      v1055[0] = v279;
      v1055[1] = v282;
      v1055[2] = v280;
      v1055[3] = v281;
      v1055[4] = v770;
      v1055[5] = v771.i8[0];
      v1055[6] = (_BYTE)v772;
      v1055[7] = v773;
      *(_QWORD *)&v1055[8] = v774;
      *(_QWORD *)&v1055[16] = v278;
      sub_100063F48((uint64_t)v1055);
      sub_100063888(v1055, (void *)(v289 + v288));
      swift_storeEnumTagMultiPayload(v289 + v288, v284, 0);
      v290 = v776;
      goto LABEL_86;
    case 0x68uLL:
      type metadata accessor for apple80211_nan_publish_terminated_event_data(0);
      v292 = v291;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v292, v42, v43);
      if ((v1050.i8[2] & 1) != 0)
        goto LABEL_181;
      v293 = v1050.i16[0];
      v294 = sub_100012C44(&qword_100405BD0);
      v295 = type metadata accessor for DriverEvent(0);
      v296 = *(_QWORD *)(v295 - 8);
      v297 = *(_QWORD *)(v296 + 72);
      v298 = *(unsigned __int8 *)(v296 + 80);
      v299 = (v298 + 32) & ~v298;
      v300 = swift_allocObject(v294, v299 + v297, v298 | 7);
      *(_OWORD *)(v300 + 16) = xmmword_10033A110;
      v301 = (void *)(v300 + v299);
      v50 = v300;
      if ((HIBYTE(v293) - 1) > 5u)
        v302 = 3;
      else
        v302 = qword_10033F8F0[(char)(HIBYTE(v293) - 1)];
      v1055[0] = v293;
      *(_QWORD *)&v1055[8] = v302;
      sub_100063E88((uint64_t)v1055);
      goto LABEL_206;
    case 0x69uLL:
      type metadata accessor for apple80211_nan_subscribe_terminated_event_data(0);
      v304 = v303;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v304, v42, v43);
      if ((v1050.i8[2] & 1) != 0)
        goto LABEL_181;
      v305 = v1050.i16[0];
      v306 = sub_100012C44(&qword_100405BD0);
      v295 = type metadata accessor for DriverEvent(0);
      v307 = *(_QWORD *)(v295 - 8);
      v308 = *(_QWORD *)(v307 + 72);
      v309 = *(unsigned __int8 *)(v307 + 80);
      v310 = (v309 + 32) & ~v309;
      v311 = swift_allocObject(v306, v310 + v308, v309 | 7);
      *(_OWORD *)(v311 + 16) = xmmword_10033A110;
      v301 = (void *)(v311 + v310);
      v50 = v311;
      if ((HIBYTE(v305) - 1) > 5u)
        v312 = 3;
      else
        v312 = qword_10033F8F0[(char)(HIBYTE(v305) - 1)];
      v1055[0] = v305;
      *(_QWORD *)&v1055[8] = v312;
      sub_100063E94((uint64_t)v1055);
LABEL_206:
      sub_100063888(v1055, v301);
      v394 = (uint64_t)v301;
      v395 = v295;
      goto LABEL_207;
    case 0x6AuLL:
      v313 = (uint64_t *)swift_getKeyPath(&unk_10033F0D8);
      v314 = (_QWORD *)swift_getKeyPath(&unk_10033F0F8);
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      v315 = sub_100012C44(&qword_100405C48);
      v316 = sub_1000B5304();
      v317 = sub_1000B52C0();
      sub_1000AC80C(v313, v314, v42, v43, v315, v316, (uint64_t)&v1050, v317);
      swift_release(v313);
      swift_release(v314);
      v318 = *(_QWORD *)&v1053[0];
      if (!*(_QWORD *)&v1053[0])
        goto LABEL_181;
      v319 = v1050.i8[0];
      v320 = (unint64_t)v1050.i64[0] >> 8;
      v321 = (unint64_t)v1050.i64[0] >> 16;
      v322 = (unint64_t)v1050.i64[0] >> 24;
      v770 = HIDWORD(v1050.i64[0]);
      v771.i64[0] = (unint64_t)v1050.i64[0] >> 40;
      v772 = (char *)HIWORD(v1050.i64[0]);
      v773 = HIBYTE(v1050.i64[0]);
      v774 = (_BYTE *)v1050.i8[8];
      v323 = sub_100012C44(&qword_100405BD0);
      v267 = type metadata accessor for DriverEvent(0);
      v324 = *(_QWORD *)(v267 - 8);
      v325 = *(_QWORD *)(v324 + 72);
      v326 = *(unsigned __int8 *)(v324 + 80);
      v327 = (v326 + 32) & ~v326;
      v218 = swift_allocObject(v323, v327 + v325, v326 | 7);
      *(_OWORD *)(v218 + 16) = xmmword_10033A110;
      v272 = (void *)(v218 + v327);
      v1055[0] = v319;
      v1055[1] = v320;
      v1055[2] = v321;
      v1055[3] = v322;
      v1055[4] = v770;
      v1055[5] = v771.i8[0];
      v1055[6] = (_BYTE)v772;
      v1055[7] = v773;
      *(_QWORD *)&v1055[8] = v774;
      *(_QWORD *)&v1055[16] = v318;
      sub_100063E7C((uint64_t)v1055);
LABEL_74:
      sub_100063888(v1055, v272);
      v328 = (uint64_t)v272;
      v329 = v267;
      goto LABEL_79;
    case 0x70uLL:
      v330 = (uint64_t *)swift_getKeyPath(&unk_10033F198);
      v331 = (_QWORD *)swift_getKeyPath(&unk_10033F1B8);
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      v332 = sub_100012C44(&qword_100405C48);
      v333 = sub_1000B5304();
      v334 = sub_1000B52C0();
      sub_1000AC80C(v330, v331, v42, v43, v332, v333, (uint64_t)&v1050, v334);
      swift_release(v330);
      swift_release(v331);
      v335 = v1052;
      if (!v1052)
        goto LABEL_181;
      v336 = v1050.i8[8];
      v337 = v1050.i8[0];
      v338 = (unint64_t)v1050.i64[0] >> 8;
      v339 = (unint64_t)v1050.i64[0] >> 24;
      v765 = HIDWORD(v1050.i64[0]);
      v766 = (unint64_t)v1050.i64[0] >> 40;
      v767 = HIWORD(v1050.i64[0]);
      v768 = HIBYTE(v1050.i64[0]);
      v769 = (unint64_t)v1050.i64[1] >> 8;
      v770 = (unint64_t)v1050.i64[1] >> 16;
      v771.i64[0] = (unint64_t)v1050.i64[1] >> 24;
      v772 = (char *)HIDWORD(v1050.i64[1]);
      v773 = (unint64_t)v1050.i64[1] >> 40;
      v774 = (_BYTE *)HIWORD(v1050.i64[1]);
      v340 = sub_100012C44(&qword_100405BD0);
      v341 = type metadata accessor for DriverEvent(0);
      v342 = *(_QWORD *)(v341 - 8);
      v343 = *(_QWORD *)(v342 + 72);
      v344 = *(unsigned __int8 *)(v342 + 80);
      v345 = (v344 + 32) & ~v344;
      v135 = swift_allocObject(v340, v345 + v343, v344 | 7);
      *(_OWORD *)(v135 + 16) = xmmword_10033A110;
      v1055[0] = v337;
      v1055[1] = v338;
      v1055[2] = v339;
      v1055[3] = v765;
      v1055[4] = v766;
      v1055[5] = v767;
      v1055[6] = v768;
      v1055[7] = v336;
      v1055[8] = v769;
      v1055[9] = v770;
      v1055[10] = v771.i8[0];
      v1055[11] = (_BYTE)v772;
      v1055[12] = v773;
      v1055[13] = (_BYTE)v774;
      *(_QWORD *)&v1055[16] = v335;
      sub_100063F3C((uint64_t)v1055);
      sub_100063888(v1055, (void *)(v135 + v345));
      swift_storeEnumTagMultiPayload(v135 + v345, v341, 0);
      v346 = v775;
      v138 = v776;
      goto LABEL_179;
    case 0x71uLL:
      v347 = (uint64_t *)swift_getKeyPath(&unk_10033F158);
      v348 = (_QWORD *)swift_getKeyPath(&unk_10033F178);
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      v349 = sub_100012C44(&qword_100405C48);
      v350 = sub_1000B5304();
      v351 = sub_1000B52C0();
      sub_1000AC80C(v347, v348, v42, v43, v349, v350, (uint64_t)&v1050, v351);
      swift_release(v347);
      swift_release(v348);
      v352 = v1052;
      if (!v1052)
        goto LABEL_181;
      v353 = v1051;
      v354 = v1051 >> 8;
      v355 = v1051 >> 16;
      v356 = v1051 >> 24;
      v357 = sub_100012C44(&qword_100405BD0);
      v358 = type metadata accessor for DriverEvent(0);
      v359 = *(_QWORD *)(v358 - 8);
      v360 = *(_QWORD *)(v359 + 72);
      v361 = *(unsigned __int8 *)(v359 + 80);
      v362 = (v361 + 32) & ~v361;
      v218 = swift_allocObject(v357, v362 + v360, v361 | 7);
      *(_OWORD *)(v218 + 16) = xmmword_10033A110;
      v363 = (uint64x2_t)vdupq_lane_s64(v1050.i64[0], 0);
      v1055[0] = v1050.i8[0];
      *(int8x8_t *)&v1055[1] = vmovn_s16(vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v363, (uint64x2_t)xmmword_10033B100), (int32x4_t)vshlq_u64(v363, (uint64x2_t)xmmword_10033B0F0)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v363, (uint64x2_t)xmmword_10033B130), (int32x4_t)vshlq_u64(v1050, (uint64x2_t)xmmword_10033B120))));
      v1055[9] = v1050.i8[15];
      v1055[10] = v353;
      v1055[11] = v354;
      v1055[12] = v355;
      v1055[13] = v356;
      *(_DWORD *)&v1055[14] = v1050.i32[2];
      *(_WORD *)&v1055[18] = v1050.i16[6];
      *(_QWORD *)&v1055[24] = v352;
      sub_100063F30((uint64_t)v1055);
      sub_100063888(v1055, (void *)(v218 + v362));
      v328 = v218 + v362;
      v329 = v358;
LABEL_79:
      v364 = 0;
      goto LABEL_80;
    case 0x72uLL:
      v367 = (uint64_t *)swift_getKeyPath(&unk_10033F118);
      v368 = (_QWORD *)swift_getKeyPath(&unk_10033F138);
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      v369 = sub_100012C44(&qword_100405C48);
      v370 = sub_1000B5304();
      v371 = sub_1000B52C0();
      sub_1000AC80C(v367, v368, v42, v43, v369, v370, (uint64_t)v1055, v371);
      swift_release(v367);
      swift_release(v368);
      v372 = *(_QWORD *)&v1055[16];
      if (!*(_QWORD *)&v1055[16])
        goto LABEL_181;
      v373 = type metadata accessor for DriverEvent(0);
      v771 = *(int8x16_t *)v1055;
      v374 = (uint64x2_t)vdupq_laneq_s64(*(int64x2_t *)v1055, 1);
      v375 = *(_DWORD *)v1055;
      v376 = v1055[1];
      v377 = *(_QWORD *)v1055 >> 40;
      v772 = (char *)*(unsigned __int16 *)&v1055[6];
      v773 = v1055[7];
      v774 = &v1055[2];
      v378 = vmovn_s16(vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v374, (uint64x2_t)xmmword_10033B100), (int32x4_t)vshlq_u64(v374, (uint64x2_t)xmmword_10033B0F0)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64((uint64x2_t)vextq_s8(v771, v771, 8uLL), (uint64x2_t)xmmword_10033B110), (int32x4_t)vshlq_u64((uint64x2_t)vdupq_lane_s64(*(uint64_t *)v1055, 0), (uint64x2_t)xmmword_10033B0F0))));
      v379 = sub_100012C44(&qword_100405BD0);
      v380 = *(_QWORD *)(v373 - 8);
      v381 = *(_QWORD *)(v380 + 72);
      v382 = *(unsigned __int8 *)(v380 + 80);
      v383 = (v382 + 32) & ~v382;
      v289 = swift_allocObject(v379, v383 + v381, v382 | 7);
      *(_OWORD *)(v289 + 16) = xmmword_10033A110;
      v384 = (void *)(v289 + v383);
      v1055[0] = v375;
      *v774 = v771.i8[8];
      if (((v375 >> 8) & 0xFE) != 0)
        v385 = 2;
      else
        v385 = v376;
      v1055[1] = v385;
      *(int8x8_t *)&v1055[3] = v378;
      v1055[11] = v377;
      v1055[12] = (_BYTE)v772;
      v1055[13] = v773;
      *(_QWORD *)&v1055[16] = v372;
      sub_100063F24((uint64_t)v1055);
      sub_100063888(v1055, v384);
      swift_storeEnumTagMultiPayload(v384, v373, 0);
      v290 = v42;
LABEL_86:
      sub_10000E614(v290, v775);
      return (_QWORD *)v289;
    case 0x75uLL:
      type metadata accessor for apple80211_nan_data_path_established_event_data(0);
      v387 = v386;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v387, v42, v43);
      sub_100063EB8((uint64_t)&v1033, (uint64_t)&v1050, &qword_100405C40);
      sub_100063EB8((uint64_t)&v1050, (uint64_t)v1055, &qword_100405C40);
      if (sub_100063EFC((uint64_t)v1055) == 1)
        goto LABEL_181;
      v388 = sub_100012C44(&qword_100405BD0);
      v389 = type metadata accessor for DriverEvent(0);
      v390 = *(_QWORD *)(v389 - 8);
      v391 = *(_QWORD *)(v390 + 72);
      v392 = *(unsigned __int8 *)(v390 + 80);
      v393 = (v392 + 32) & ~v392;
      v50 = swift_allocObject(v388, v393 + v391, v392 | 7);
      *(_OWORD *)(v50 + 16) = xmmword_10033A110;
      LOBYTE(v1033) = v1055[1];
      *(_DWORD *)((char *)&v1033 + 1) = *(_DWORD *)&v1055[3];
      *(_WORD *)((char *)&v1033 + 5) = *(_WORD *)&v1055[7];
      BYTE7(v1033) = v1055[0] == 1;
      DWORD2(v1033) = *(_DWORD *)&v1055[9];
      WORD6(v1033) = *(_WORD *)&v1055[13];
      sub_100063F18((uint64_t)&v1033);
      sub_100063888(&v1033, (void *)(v50 + v393));
      v394 = v50 + v393;
      v395 = v389;
LABEL_207:
      v438 = 0;
      goto LABEL_208;
    case 0x76uLL:
      type metadata accessor for apple80211_nan_data_path_end_event_data(0);
      v397 = v396;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v397, v42, v43);
      if ((v1052 & 0x100000000) != 0)
        goto LABEL_181;
      v398 = v1050.i64[1];
      v399 = v1050.i64[0];
      v400 = HIDWORD(v1050.i64[0]);
      v401 = sub_100012C44(&qword_100405BD0);
      v402 = type metadata accessor for DriverEvent(0);
      v403 = *(_QWORD *)(v402 - 8);
      v404 = *(_QWORD *)(v403 + 72);
      v405 = *(unsigned __int8 *)(v403 + 80);
      v406 = (v405 + 32) & ~v405;
      v407 = swift_allocObject(v401, v406 + v404, v405 | 7);
      *(_OWORD *)(v407 + 16) = xmmword_10033A110;
      v408 = (void *)(v407 + v406);
      v409 = v407;
      if (v400 > 0x14)
        v410 = 3;
      else
        v410 = qword_10033F920[v399 >> 32];
      v703 = v776;
      v1055[0] = v399;
      *(_WORD *)&v1055[1] = v398;
      v1055[3] = BYTE2(v398);
      v1055[4] = BYTE3(v398);
      v1055[5] = BYTE4(v398);
      *(_WORD *)&v1055[6] = BYTE5(v398);
      *(_QWORD *)&v1055[8] = v410;
      sub_100063EAC((uint64_t)v1055);
      sub_100063888(v1055, v408);
      swift_storeEnumTagMultiPayload(v408, v402, 0);
      sub_10000E614(v703, v43);
      return (_QWORD *)v409;
    case 0x7AuLL:
      type metadata accessor for apple80211_nan_dw_start_event_data(0);
      v412 = v411;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v412, v42, v43);
      if ((v1055[72] & 1) != 0)
        goto LABEL_181;
      v413 = *(_DWORD *)&v1055[64];
      v414 = *(_QWORD *)&v1055[56];
      v415 = *(_QWORD *)&v1055[48];
      v416 = sub_100012C44(&qword_100405BD0);
      v417 = type metadata accessor for DriverEvent(0);
      v418 = *(_QWORD *)(v417 - 8);
      v419 = *(_QWORD *)(v418 + 72);
      v420 = *(unsigned __int8 *)(v418 + 80);
      v421 = (v420 + 32) & ~v420;
      v422 = swift_allocObject(v416, v421 + v419, v420 | 7);
      v423 = HIWORD(v413);
      *(_OWORD *)(v422 + 16) = xmmword_10033A110;
      v218 = v422;
      v424 = (void *)(v422 + v421);
      v425 = __ROR8__(v415, 32);
      v426 = __ROR8__(v414, 32);
      v427 = sub_100192784((unsigned __int16)v413);
      if ((v427 & 0xFF00000000) == 0x300000000)
      {
        if (qword_100404180 != -1)
          swift_once(&qword_100404180, sub_1001902EC);
        LODWORD(v427) = static Channel.nanPrimary;
        LOBYTE(v428) = byte_1004105A4;
        LOBYTE(v429) = byte_1004105A5;
        v430 = v776;
      }
      else
      {
        v428 = HIDWORD(v427);
        v429 = v427 >> 40;
        v430 = v776;
      }
      *(_QWORD *)v1055 = v423;
      *(_QWORD *)&v1055[8] = v425;
      *(_QWORD *)&v1055[16] = v426;
      *(_DWORD *)&v1055[24] = v427;
      v1055[28] = v428;
      v1055[29] = v429;
      sub_1000638DC((uint64_t)v1055);
      sub_100063888(v1055, v424);
      swift_storeEnumTagMultiPayload(v424, v417, 0);
      v365 = v430;
      goto LABEL_196;
    case 0x7DuLL:
      type metadata accessor for apple80211_infra_scan_start_event_data(0);
      v432 = v431;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v432, v42, v43);
      sub_100063EB8((uint64_t)&v1033, (uint64_t)&v1050, &qword_100405BD8);
      sub_100063EB8((uint64_t)&v1050, (uint64_t)v1055, &qword_100405BD8);
      if (sub_1000636CC((uint64_t)v1055) == 1)
        goto LABEL_181;
      memcpy(v1181, v1055, 0x193uLL);
      v433 = sub_100012C44(&qword_100405BD0);
      v45 = type metadata accessor for DriverEvent(0);
      v434 = *(_QWORD *)(v45 - 8);
      v435 = *(_QWORD *)(v434 + 72);
      v436 = *(unsigned __int8 *)(v434 + 80);
      v437 = (v436 + 32) & ~v436;
      v50 = swift_allocObject(v433, v437 + v435, v436 | 7);
      *(_OWORD *)(v50 + 16) = xmmword_10033A110;
      v51 = v50 + v437;
      *(_QWORD *)v51 = sub_1000ADDD8();
      *(_OWORD *)(v51 + 8) = 0u;
      *(_OWORD *)(v51 + 24) = 0u;
      v55 = 256;
LABEL_99:
      *(_WORD *)(v51 + 40) = v55;
      v394 = v51;
      v395 = v45;
      v438 = 2;
      goto LABEL_208;
    case 0x7EuLL:
      type metadata accessor for apple80211_infra_scan_complete_event_data(0);
      v440 = v439;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v440, v42, v43);
      if ((v1055[2] & 1) != 0)
        goto LABEL_181;
      v441 = v1055[0];
      v442 = sub_100012C44(&qword_100405BD0);
      v443 = type metadata accessor for DriverEvent(0);
      v444 = *(_QWORD *)(v443 - 8);
      v445 = *(_QWORD *)(v444 + 72);
      v446 = *(unsigned __int8 *)(v444 + 80);
      v447 = (v446 + 32) & ~v446;
      v100 = swift_allocObject(v442, v447 + v445, v446 | 7);
      *(_OWORD *)(v100 + 16) = xmmword_10033A110;
      v101 = v100 + v447;
      *(_QWORD *)v101 = v441;
      *(_OWORD *)(v101 + 8) = 0u;
      *(_OWORD *)(v101 + 24) = 0u;
      *(_BYTE *)(v101 + 40) = 0;
      v448 = 2;
      goto LABEL_170;
    case 0x7FuLL:
      type metadata accessor for apple80211_nan_infra_assoc_start_event_data(0);
      v450 = v449;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v450, v42, v43);
      if ((v1055[12] & 1) != 0)
        goto LABEL_181;
      v451 = sub_1000B388C(*(unsigned int *)&v1055[4], *(unsigned int *)&v1055[8]);
      v105 = v772;
      if ((v451 & 0xFF00000000) == 0x300000000)
        goto LABEL_182;
      v452 = v451;
      v453 = sub_100012C44(&qword_100405BD0);
      v454 = type metadata accessor for DriverEvent(0);
      v455 = *(_QWORD *)(v454 - 8);
      v456 = *(_QWORD *)(v455 + 72);
      v457 = *(unsigned __int8 *)(v455 + 80);
      v458 = (v457 + 32) & ~v457;
      v459 = swift_allocObject(v453, v458 + v456, v457 | 7);
      *(_OWORD *)(v459 + 16) = xmmword_10033A110;
      v460 = v459 + v458;
      *(_QWORD *)v460 = v452 & 0xFFFFFFFFFFFFLL;
      *(_OWORD *)(v460 + 24) = 0u;
      *(_OWORD *)(v460 + 8) = 0u;
      *(_BYTE *)(v460 + 40) = 0;
      *(_BYTE *)(v460 + 41) = 3;
      swift_storeEnumTagMultiPayload(v459 + v458, v454, 2);
      sub_10000E614(v42, v43);
      return (_QWORD *)v459;
    case 0x81uLL:
      type metadata accessor for apple80211_nan_dp_host_assist_event_data(0);
      v462 = v461;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v462, v42, v43);
      if ((v1051 & 0x100000000) != 0)
        goto LABEL_181;
      v463 = v1050.i64[1];
      v464 = v1050.i16[0];
      v465 = sub_100012C44(&qword_100405BD0);
      v212 = type metadata accessor for DriverEvent(0);
      v466 = *(_QWORD *)(v212 - 8);
      v467 = *(_QWORD *)(v466 + 72);
      v468 = *(unsigned __int8 *)(v466 + 80);
      v216 = v42;
      v469 = (v468 + 32) & ~v468;
      v218 = swift_allocObject(v465, v469 + v467, v468 | 7);
      *(_OWORD *)(v218 + 16) = xmmword_10033A110;
      v219 = (void *)(v218 + v469);
      *(_QWORD *)v1055 = sub_1000AD014(v464, v463);
      v1055[8] = v470;
      v1055[9] = v471;
      v1055[10] = v472;
      v1055[11] = v473;
      v1055[12] = v474;
      v1055[13] = v475;
      v1055[14] = v476;
      v1055[15] = v477;
      sub_100063EA0((uint64_t)v1055);
LABEL_107:
      sub_100063888(v1055, v219);
      v255 = (uint64_t)v219;
LABEL_108:
      v478 = v212;
      v479 = 0;
      goto LABEL_195;
    case 0x8EuLL:
      type metadata accessor for apple80211_awdl_low_latency_statistics_reduced(0);
      v481 = v480;
      v482 = v775;
      v483 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v481, v483, v482);
      sub_100063EB8((uint64_t)v1181, (uint64_t)&v1033, &qword_100405C20);
      sub_100063EB8((uint64_t)&v1033, (uint64_t)&v1050, &qword_100405C20);
      if (sub_1000637C4((uint64_t)&v1050) == 1)
      {
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v17 + 56))(v15, 1, 1, v16);
      }
      else
      {
        sub_100063EB8((uint64_t)&v1033, (uint64_t)v1180, &qword_100405C20);
        memcpy(v1055, v1180, 0x640uLL);
        sub_1000AD42C((uint64_t)v1055, (uint64_t)v15);
      }
      v105 = v772;
      if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v17 + 48))(v15, 1, v16) == 1)
      {
        sub_100033A84((uint64_t)v15, &qword_100405BC8);
        v43 = v775;
        v42 = v776;
        goto LABEL_182;
      }
      sub_100033AC0((uint64_t)v15, (uint64_t)v19, type metadata accessor for AWDLStatistics.LowLatencyStatistics);
      v695 = sub_100012C44(&qword_100405BD0);
      v696 = type metadata accessor for DriverEvent(0);
      v697 = *(_QWORD *)(v696 - 8);
      v698 = *(_QWORD *)(v697 + 72);
      v699 = *(unsigned __int8 *)(v697 + 80);
      v700 = (v699 + 32) & ~v699;
      v701 = swift_allocObject(v695, v700 + v698, v699 | 7);
      *(_OWORD *)(v701 + 16) = xmmword_10033A110;
      sub_1000637E0((uint64_t)v19, v701 + v700, type metadata accessor for AWDLStatistics.LowLatencyStatistics);
      v702 = type metadata accessor for DriverEvent.AWDL(0);
      swift_storeEnumTagMultiPayload(v701 + v700, v702, 3);
      swift_storeEnumTagMultiPayload(v701 + v700, v696, 1);
      sub_10000E614(v776, v775);
      sub_100063824((uint64_t)v19, type metadata accessor for AWDLStatistics.LowLatencyStatistics);
      return (_QWORD *)v701;
    case 0x95uLL:
      type metadata accessor for apple80211_p2p_airplay_statistics(0);
      v485 = v484;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v485, v42, v43);
      sub_100063EB8((uint64_t)v1181, (uint64_t)&v1033, &qword_100405C10);
      sub_100063EB8((uint64_t)&v1033, (uint64_t)&v1050, &qword_100405C10);
      if (sub_1000637A8((uint64_t)&v1050) == 1)
        goto LABEL_181;
      sub_100063EB8((uint64_t)&v1033, (uint64_t)v1180, &qword_100405C10);
      *(_OWORD *)&v1055[160] = v1180[10];
      *(_OWORD *)&v1055[176] = v1180[11];
      *(_OWORD *)&v1055[192] = v1180[12];
      *(_OWORD *)&v1055[96] = v1180[6];
      *(_OWORD *)&v1055[112] = v1180[7];
      *(_OWORD *)&v1055[128] = v1180[8];
      *(_OWORD *)&v1055[144] = v1180[9];
      *(_OWORD *)&v1055[32] = v1180[2];
      *(_OWORD *)&v1055[48] = v1180[3];
      *(_OWORD *)&v1055[64] = v1180[4];
      *(_OWORD *)&v1055[80] = v1180[5];
      *(_OWORD *)v1055 = v1180[0];
      *(_OWORD *)&v1055[16] = v1180[1];
      sub_1000B4AF8((uint64_t)v1055, (uint64_t)v1182);
      sub_100063EB8((uint64_t)v1182, (uint64_t)&v1183, &qword_100405C18);
      v105 = v772;
      if (!(_QWORD)v1187)
        goto LABEL_182;
      v486 = sub_100012C44(&qword_100405BD0);
      v487 = type metadata accessor for DriverEvent(0);
      v488 = *(_QWORD *)(v487 - 8);
      v489 = *(_QWORD *)(v488 + 72);
      v490 = *(unsigned __int8 *)(v488 + 80);
      v491 = (v490 + 32) & ~v490;
      v50 = swift_allocObject(v486, v491 + v489, v490 | 7);
      *(_OWORD *)(v50 + 16) = xmmword_10033A110;
      v492 = (_OWORD *)(v50 + v491);
      v493 = *(_OWORD *)v1184;
      *v492 = v1183;
      v492[1] = v493;
      v494 = v1188;
      v495 = v1186;
      v492[5] = v1187;
      v492[6] = v494;
      v496 = v1185;
      v492[2] = *(_OWORD *)&v1184[16];
      v492[3] = v496;
      v492[4] = v495;
      v497 = type metadata accessor for DriverEvent.AWDL(0);
      swift_storeEnumTagMultiPayload(v50 + v491, v497, 2);
      v394 = v50 + v491;
      v395 = v487;
      v438 = 1;
LABEL_208:
      swift_storeEnumTagMultiPayload(v394, v395, v438);
      v89 = v42;
      v90 = v43;
LABEL_209:
      sub_10000E614(v89, v90);
      return (_QWORD *)v50;
    case 0x9DuLL:
      type metadata accessor for apple80211_nan_low_latency_peer_statistics(0);
      v499 = v498;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v499, v42, v43);
      sub_100063EB8((uint64_t)&v1033, (uint64_t)&v1050, &qword_100405C28);
      sub_100063EB8((uint64_t)&v1050, (uint64_t)v1055, &qword_100405C28);
      if (sub_100063860((uint64_t)v1055) == 1)
        goto LABEL_181;
      v771.i64[0] = (uint64_t)v1170;
      v739 = v1152;
      v732 = v1116;
      v733 = v1134;
      v730 = (__int128 *)v1095;
      v727 = (__int128 *)v1099;
      v728 = v1077;
      v725 = v1059;
      v500 = sub_100012C44(&qword_100405BD0);
      v773 = type metadata accessor for DriverEvent(0);
      v501 = *(_QWORD *)(v773 - 8);
      v502 = *(_QWORD *)(v501 + 72);
      v503 = *(unsigned __int8 *)(v501 + 80);
      v504 = (v503 + 32) & ~v503;
      v505 = swift_allocObject(v500, v504 + v502, v503 | 7);
      v774 = (_BYTE *)v505;
      *(_OWORD *)(v505 + 16) = xmmword_10033A110;
      v772 = (char *)(v505 + v504);
      v761 = v1055[4];
      v762 = *(_DWORD *)v1055;
      v759 = v1055[6];
      v760 = v1055[5];
      v757 = v1055[17];
      v758 = v1055[16];
      v755 = v1055[36];
      v756 = v1055[18];
      v753 = v1055[38];
      v754 = v1055[37];
      v752 = *(_DWORD *)&v1055[48];
      v750 = *(_QWORD *)&v1055[64];
      v751 = *(_QWORD *)&v1055[56];
      v748 = *(_QWORD *)&v1055[80];
      v749 = *(_QWORD *)&v1055[72];
      v746 = *(_QWORD *)&v1055[96];
      v747 = *(_QWORD *)&v1055[88];
      v769 = *(_QWORD *)&v1055[112];
      v770 = *(_QWORD *)&v1055[104];
      v767 = *(_QWORD *)&v1055[128];
      v768 = *(_QWORD *)&v1055[120];
      v765 = *(_QWORD *)&v1055[144];
      v766 = *(_QWORD *)&v1055[136];
      v763 = *(_QWORD *)&v1055[160];
      v764 = *(_QWORD *)&v1055[152];
      v1014 = *(_QWORD *)&v1055[288];
      v1016 = *(_QWORD *)&v1055[312];
      v1018 = *(_QWORD *)&v1055[336];
      v1020 = *(_QWORD *)&v1055[360];
      v1022 = *(_QWORD *)&v1055[384];
      v1024 = *(_QWORD *)&v1055[408];
      v1026 = *(_QWORD *)&v1055[432];
      v1028 = *(_QWORD *)&v1055[456];
      v744 = *(_QWORD *)&v1055[168];
      v745 = *(_QWORD *)&v1055[176];
      v1015 = *(_OWORD *)&v1055[296];
      v1017 = *(_OWORD *)&v1055[320];
      v1019 = *(_OWORD *)&v1055[344];
      v1021 = *(_OWORD *)&v1055[368];
      v1023 = *(_OWORD *)&v1055[392];
      v1025 = *(_OWORD *)&v1055[416];
      v1027 = *(_OWORD *)&v1055[440];
      v1029 = *(_OWORD *)&v1055[464];
      v1031 = *(_OWORD *)&v1055[488];
      v1030 = *(_QWORD *)&v1055[480];
      v1032 = *(_QWORD *)&v1055[504];
      v506 = *(_QWORD *)&v1055[192];
      v1013 = *(_OWORD *)&v1055[272];
      v507 = *(_QWORD *)&v1055[8];
      v508 = *(_QWORD *)&v1055[20];
      v509 = *(_QWORD *)&v1055[40];
      v742 = *(_QWORD *)&v1055[264];
      v743 = *(_QWORD *)&v1055[184];
      v738 = *(_QWORD *)&v1055[200];
      v740 = *(_QWORD *)&v1055[256];
      v741 = *(_QWORD *)&v1055[216];
      v735 = *(_DWORD *)&v1055[32];
      v736 = *(_DWORD *)&v1055[28];
      v737 = sub_1000B07EC((uint64_t)&v1013);
      v993 = *(_OWORD *)&v1055[752];
      v995 = *(_OWORD *)&v1055[776];
      v994 = *(_QWORD *)&v1055[768];
      v996 = *(_QWORD *)&v1055[792];
      v997 = *(_OWORD *)&v1055[800];
      v999 = *(_OWORD *)&v1055[824];
      v998 = *(_QWORD *)&v1055[816];
      v1000 = *(_QWORD *)&v1055[840];
      v1001 = *(_OWORD *)&v1055[848];
      v1003 = *(_OWORD *)&v1055[872];
      v1002 = *(_QWORD *)&v1055[864];
      v1004 = *(_QWORD *)&v1055[888];
      v1005 = *(_OWORD *)&v1055[896];
      v1007 = *(_OWORD *)&v1055[920];
      v1006 = *(_QWORD *)&v1055[912];
      v1008 = *(_QWORD *)&v1055[936];
      v1009 = *(_OWORD *)&v1055[944];
      v1011 = *(_OWORD *)&v1055[968];
      v1010 = *(_QWORD *)&v1055[960];
      v1012 = *(_QWORD *)&v1055[984];
      v734 = sub_1000B07EC((uint64_t)&v993);
      v973 = *(_OWORD *)&v1055[992];
      v975 = *(_OWORD *)&v1055[1016];
      v974 = *(_QWORD *)&v1055[1008];
      v976 = *(_QWORD *)&v1055[1032];
      v977 = *(_OWORD *)&v1055[1040];
      v979 = *(_OWORD *)&v1055[1064];
      v978 = *(_QWORD *)&v1055[1056];
      v980 = *(_QWORD *)&v1055[1080];
      v981 = *(_OWORD *)&v1055[1088];
      v983 = *(_OWORD *)&v1055[1112];
      v982 = *(_QWORD *)&v1055[1104];
      v984 = *(_QWORD *)&v1055[1128];
      v985 = *(_OWORD *)&v1055[1136];
      v987 = *(_OWORD *)&v1055[1160];
      v986 = *(_QWORD *)&v1055[1152];
      v988 = *(_QWORD *)&v1055[1176];
      v989 = *(_OWORD *)&v1055[1184];
      v991 = *(_OWORD *)&v1055[1208];
      v990 = *(_QWORD *)&v1055[1200];
      v992 = *(_QWORD *)&v1055[1224];
      v510 = sub_1000B07EC((uint64_t)&v973);
      v953 = *(_OWORD *)&v1055[1232];
      v955 = *(_OWORD *)&v1055[1256];
      v954 = *(_QWORD *)&v1055[1248];
      v956 = *(_QWORD *)&v1055[1272];
      v957 = *(_OWORD *)&v1055[1280];
      v959 = *(_OWORD *)&v1055[1304];
      v958 = *(_QWORD *)&v1055[1296];
      v960 = *(_QWORD *)&v1055[1320];
      v961 = *(_OWORD *)&v1055[1328];
      v963 = *(_OWORD *)&v1055[1352];
      v962 = *(_QWORD *)&v1055[1344];
      v964 = *(_QWORD *)&v1055[1368];
      v965 = *(_OWORD *)&v1055[1376];
      v967 = *(_OWORD *)&v1055[1400];
      v966 = *(_QWORD *)&v1055[1392];
      v968 = *(_QWORD *)&v1055[1416];
      v969 = *(_OWORD *)&v1055[1424];
      v971 = *(_OWORD *)&v1055[1448];
      v970 = *(_QWORD *)&v1055[1440];
      v972 = *(_QWORD *)&v1055[1464];
      v731 = sub_1000B07EC((uint64_t)&v953);
      v933 = *(_OWORD *)&v1055[1472];
      v935 = *(_OWORD *)&v1055[1496];
      v934 = *(_QWORD *)&v1055[1488];
      v936 = *(_QWORD *)&v1055[1512];
      v937 = *(_OWORD *)&v1055[1520];
      v939 = *(_OWORD *)&v1055[1544];
      v938 = *(_QWORD *)&v1055[1536];
      v940 = *(_QWORD *)&v1055[1560];
      v941 = *(_OWORD *)&v1055[1568];
      v943 = *(_OWORD *)&v1055[1592];
      v942 = *(_QWORD *)&v1055[1584];
      v944 = v1056;
      v945 = v1057;
      v511 = v725;
      v947 = *(_OWORD *)v725;
      v946 = v1058;
      v948 = v1059[2];
      v949 = v1060;
      v951 = *((_OWORD *)v725 + 3);
      v950 = v1061;
      v952 = v1062;
      v729 = sub_1000B07EC((uint64_t)&v933);
      v913 = *v727;
      v915 = v1100;
      v914 = v1099[2];
      v916 = v1101;
      v917 = v727[3];
      v919 = v1103;
      v918 = v1102;
      v920 = v1104;
      v921 = v727[6];
      v923 = v1106;
      v922 = v1105;
      v924 = v1107;
      v925 = v727[9];
      v927 = v1109;
      v926 = v1108;
      v928 = v1110;
      v929 = v727[12];
      v931 = v1112;
      v930 = v1111;
      v932 = v1113;
      v727 = (__int128 *)sub_1000B07EC((uint64_t)&v913);
      v901 = v1063;
      v903 = v511[6];
      v902 = v1064;
      v904 = v1065;
      v905 = v1066;
      v907 = v511[9];
      v906 = v1067;
      v908 = v1068;
      v909 = v1069;
      v911 = v511[12];
      v910 = v1070;
      v912 = v1071;
      v726 = sub_1000B0970(&v901);
      v883 = v1072;
      v885 = v511[15];
      v884 = v1073;
      v886 = v1074;
      v887 = v1075;
      v889 = *v728;
      v888 = v1076;
      v890 = v1077[2];
      v891 = v1078;
      v893 = v728[3];
      v892 = v1079;
      v894 = v1080;
      v895 = v1081;
      v512 = v728;
      v897 = v728[6];
      v896 = v1082;
      v898 = v1083;
      v899 = v1084;
      v900 = v1085;
      v725 = sub_1000B0BAC((uint64_t)&v883);
      v865 = v512[9];
      v867 = v1087;
      v866 = v1086;
      v868 = v1088;
      v869 = v512[12];
      v871 = v1090;
      v870 = v1089;
      v872 = v1091;
      v873 = v512[15];
      v875 = v1093;
      v874 = v1092;
      v876 = v1094;
      v877 = *v730;
      v879 = v1096;
      v878 = v1095[2];
      v880 = v1097;
      v881 = v730[3];
      v882 = v1098;
      v513 = sub_1000B0BAC((uint64_t)&v865);
      v845 = v1114;
      v847 = *v732;
      v846 = v1115;
      v848 = v1116[2];
      v849 = v1117;
      v851 = v732[3];
      v850 = v1118;
      v852 = v1119;
      v853 = v1120;
      v855 = v732[6];
      v854 = v1121;
      v856 = v1122;
      v857 = v1123;
      v859 = v732[9];
      v858 = v1124;
      v860 = v1125;
      v861 = v1126;
      v514 = v732;
      v863 = v732[12];
      v862 = v1127;
      v864 = v1128;
      v515 = sub_1000B07EC((uint64_t)&v845);
      v825 = v1129;
      v827 = v514[15];
      v826 = v1130;
      v828 = v1131;
      v829 = v1132;
      v831 = *v733;
      v830 = v1133;
      v832 = v1134[2];
      v833 = v1135;
      v835 = v733[3];
      v834 = v1136;
      v836 = v1137;
      v837 = v1138;
      v839 = v733[6];
      v838 = v1139;
      v840 = v1140;
      v841 = v1141;
      v516 = v733;
      v843 = v733[9];
      v842 = v1142;
      v844 = v1143;
      v517 = sub_1000B07EC((uint64_t)&v825);
      v805 = v1144;
      v807 = v516[12];
      v806 = v1145;
      v808 = v1146;
      v809 = v1147;
      v811 = v516[15];
      v810 = v1148;
      v812 = v1149;
      v813 = v1150;
      v815 = *v739;
      v814 = v1151;
      v816 = v1152[2];
      v817 = v1153;
      v819 = v739[3];
      v818 = v1154;
      v820 = v1155;
      v821 = v1156;
      v518 = v739;
      v823 = v739[6];
      v822 = v1157;
      v824 = v1158;
      v519 = sub_1000B07EC((uint64_t)&v805);
      v785 = v1159;
      v787 = v518[9];
      v786 = v1160;
      v788 = v1161;
      v789 = v1162;
      v791 = v518[12];
      v790 = v1163;
      v792 = v1164;
      v793 = v1165;
      v795 = v518[15];
      v794 = v1166;
      v796 = v1167;
      v797 = v1168;
      v799 = *(_OWORD *)v771.i64[0];
      v798 = v1169;
      v800 = v1170[2];
      v801 = v1171;
      v520 = v771.i64[0];
      v803 = *(_OWORD *)(v771.i64[0] + 48);
      v802 = v1172;
      v804 = v1173;
      v521 = sub_1000B07EC((uint64_t)&v785);
      v777 = v1174;
      v778 = v1175;
      v779 = *(_OWORD *)(v520 + 96);
      v780 = v1176;
      v781 = v1177;
      v782 = v1178;
      v783 = *(_OWORD *)(v520 + 144);
      v784 = v1179;
      v522 = sub_1000B0D20(&v777);
      LODWORD(v1181[0]) = v762;
      BYTE4(v1181[0]) = v761;
      BYTE5(v1181[0]) = v760;
      BYTE6(v1181[0]) = v759;
      LOBYTE(v1181[2]) = v758;
      BYTE1(v1181[2]) = v757;
      WORD1(v1181[2]) = v756;
      HIDWORD(v1181[3]) = v736;
      LODWORD(v1181[4]) = v735;
      BYTE4(v1181[4]) = v755;
      BYTE5(v1181[4]) = v754;
      BYTE6(v1181[4]) = v753;
      LODWORD(v1181[6]) = v752;
      v1181[7] = v751;
      v1181[8] = v750;
      v1181[9] = v749;
      v1181[10] = v748;
      v1181[11] = v747;
      v1181[12] = v746;
      *(uint64_t *)((char *)&v1181[2] + 4) = v508;
      v1181[1] = v507;
      v1181[5] = v509;
      v1181[13] = v770;
      v1181[14] = v769;
      v1181[15] = v768;
      v1181[16] = v767;
      v1181[17] = v766;
      v1181[18] = v765;
      v1181[19] = v764;
      v1181[20] = v763;
      v1181[21] = v744;
      v1181[22] = v745;
      v1181[23] = v743;
      v1181[24] = v506;
      v1181[25] = v738;
      v1181[26] = v740;
      v1181[27] = v742;
      v1181[28] = v741;
      v1181[29] = (uint64_t)v737;
      v1181[30] = (uint64_t)v734;
      v1181[31] = (uint64_t)v510;
      v1181[32] = (uint64_t)v731;
      v1181[33] = (uint64_t)v729;
      v1181[34] = (uint64_t)v727;
      v1181[35] = (uint64_t)v726;
      v1181[36] = (uint64_t)v725;
      v1181[37] = (uint64_t)v513;
      v1181[38] = (uint64_t)v515;
      v1181[39] = (uint64_t)v517;
      v1181[40] = (uint64_t)v519;
      v1181[41] = (uint64_t)v521;
      v1181[42] = (uint64_t)v522;
      memset(&v1181[43], 0, 17);
      sub_10006387C((uint64_t)v1181);
      v523 = v1181;
      goto LABEL_193;
    case 0x9EuLL:
      type metadata accessor for apple80211_nan_oob_act_frm_tx_status(0);
      v525 = v524;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v525, v42, v43);
      if ((v1050.i8[10] & 1) != 0)
        goto LABEL_181;
      v526 = v1050.i16[0];
      v527 = (unint64_t)v1050.i64[0] >> 16;
      v528 = v1050.i16[4];
      v529 = HIWORD(v1050.i64[0]) | (v1050.u16[4] << 16);
      v530 = sub_100012C44(&qword_100405BD0);
      v531 = type metadata accessor for DriverEvent(0);
      v532 = *(_QWORD *)(v531 - 8);
      v533 = *(_QWORD *)(v532 + 72);
      v534 = *(unsigned __int8 *)(v532 + 80);
      v535 = (v534 + 32) & ~v534;
      v218 = swift_allocObject(v530, v535 + v533, v534 | 7);
      *(_OWORD *)(v218 + 16) = xmmword_10033A110;
      *(_WORD *)v1055 = v526;
      *(_QWORD *)&v1055[2] = __PAIR64__(v529, v527);
      *(_DWORD *)v1055 = sub_1000AD0FC(*(unint64_t *)v1055, v528);
      sub_100063910((uint64_t)v1055);
      sub_100063888(v1055, (void *)(v218 + v535));
      swift_storeEnumTagMultiPayload(v218 + v535, v531, 0);
      v365 = v776;
      goto LABEL_196;
    case 0x9FuLL:
      type metadata accessor for apple80211_nan_oob_act_frm_rx_data(0);
      v537 = v536;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v537, v42, v43);
      sub_100063EB8((uint64_t)&v1033, (uint64_t)&v1050, &qword_100405C30);
      sub_100063EB8((uint64_t)&v1050, (uint64_t)v1055, &qword_100405C30);
      if (sub_1000638E8((uint64_t)v1055) == 1)
        goto LABEL_181;
      memcpy(v1181, v1055, 0x3E1uLL);
      v538 = sub_100012C44(&qword_100405BD0);
      v539 = type metadata accessor for DriverEvent(0);
      v540 = *(_QWORD *)(v539 - 8);
      v541 = *(_QWORD *)(v540 + 72);
      v542 = *(unsigned __int8 *)(v540 + 80);
      v543 = (v542 + 32) & ~v542;
      v204 = swift_allocObject(v538, v543 + v541, v542 | 7);
      *(_OWORD *)(v204 + 16) = xmmword_10033A110;
      v544 = (void *)(v204 + v543);
      sub_1000AD144();
      *(_QWORD *)&v1180[0] = v1183;
      DWORD2(v1180[0]) = DWORD2(v1183);
      LOBYTE(v1180[1]) = v1184[0];
      *(_OWORD *)((char *)&v1180[1] + 8) = *(_OWORD *)&v1184[8];
      *((_QWORD *)&v1180[2] + 1) = *(_QWORD *)&v1184[24];
      sub_100063904((uint64_t)v1180);
      sub_100063888(v1180, v544);
      v545 = v544;
      v546 = v539;
LABEL_218:
      swift_storeEnumTagMultiPayload(v545, v546, 0);
      sub_10000E614(v42, v43);
      return (_QWORD *)v204;
    case 0xACuLL:
      type metadata accessor for apple80211_hostap_state(0);
      v548 = v547;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v548, v42, v43);
      if ((v1055[16] & 1) != 0)
        goto LABEL_181;
      v549 = *(unsigned __int16 *)&v1055[8];
      v550 = *(unsigned int *)&v1055[4];
      v551 = sub_100012C44(&qword_100405BD0);
      v552 = type metadata accessor for DriverEvent(0);
      v553 = *(_QWORD *)(v552 - 8);
      v554 = *(_QWORD *)(v553 + 72);
      v555 = *(unsigned __int8 *)(v553 + 80);
      v556 = (v555 + 32) & ~v555;
      v135 = swift_allocObject(v551, v556 + v554, v555 | 7);
      *(_OWORD *)(v135 + 16) = xmmword_10033A110;
      v557 = v135 + v556;
      v558 = sub_100192784(v549);
      *(_BYTE *)v557 = v550 != 0;
      *(_DWORD *)(v557 + 4) = v558;
      *(_WORD *)(v557 + 8) = WORD2(v558);
      v559 = type metadata accessor for DriverEvent.AWDL(0);
      swift_storeEnumTagMultiPayload(v135 + v556, v559, 5);
      v178 = v135 + v556;
      v179 = v552;
      goto LABEL_167;
    case 0xB3uLL:
      type metadata accessor for apple80211_awdl_service_reg_soft_error_event(0);
      v561 = v560;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v561, v42, v43);
      sub_100063EB8((uint64_t)&v1033, (uint64_t)&v1050, &qword_100405BF0);
      sub_100063EB8((uint64_t)&v1050, (uint64_t)v1055, &qword_100405BF0);
      if (sub_100063720((uint64_t)v1055) == 1)
        goto LABEL_181;
      v562 = *(unsigned int *)&v1055[4];
      v105 = v772;
      if (*(_DWORD *)&v1055[4] > 0xFFu)
        goto LABEL_182;
      v1045 = *(_OWORD *)&v1055[200];
      v1046 = *(_OWORD *)&v1055[216];
      v1047 = *(_OWORD *)&v1055[232];
      v1048 = *(_OWORD *)&v1055[248];
      v1041 = *(_OWORD *)&v1055[136];
      v1042 = *(_OWORD *)&v1055[152];
      v1043 = *(_OWORD *)&v1055[168];
      v1044 = *(_OWORD *)&v1055[184];
      v1037 = *(_OWORD *)&v1055[72];
      v1038 = *(_OWORD *)&v1055[88];
      v1039 = *(_OWORD *)&v1055[104];
      v1040 = *(_OWORD *)&v1055[120];
      v1033 = *(_OWORD *)&v1055[8];
      v1034 = *(_OWORD *)&v1055[24];
      v1035 = *(_OWORD *)&v1055[40];
      v1036 = *(_OWORD *)&v1055[56];
      v563 = sub_100012C44(&qword_100405BF8);
      *((_QWORD *)&v1180[1] + 1) = v563;
      *(_QWORD *)&v1180[2] = sub_10006373C();
      v564 = (_QWORD *)swift_allocObject(&unk_1003E0780, 48, 7);
      *(_QWORD *)&v1180[0] = v564;
      v564[2] = 0;
      v564[3] = v562;
      v564[4] = &v1033;
      v564[5] = &v1049;
      v565 = (__int128 *)sub_10003259C(v1180, v563);
      v566 = v565[1];
      v1183 = *v565;
      *(_OWORD *)v1184 = v566;
      v567 = v563;
      v568 = v769;
      Slice<>.withUnsafeBytes<A>(_:)(v1182, sub_100106424, 0, v567, &type metadata for Data._Representation, &protocol witness table for UnsafeRawBufferPointer);
      v569 = v1182[0];
      v570 = v1182[1];
      sub_100014430(v1180);
      static DNSRecords.createRecord(with:value:)(v569, v570, 0, 0xF000000000000000);
      if (v568)
      {
        sub_10000E614(v569, v570);
        swift_errorRelease(v568);
        v769 = 0;
        v42 = v776;
        goto LABEL_182;
      }
      sub_10000E614(v569, v570);
      v704 = sub_100012C44(&qword_100404B88);
      if (swift_dynamicCast(&v1033, v1181, v704, &type metadata for DNSRecords.Identifier, 0))
      {
        v705 = *((_QWORD *)&v1033 + 1);
        v706 = v1033;
        v707 = v1034;
      }
      else if (swift_dynamicCast(&v1033, v1181, v704, &type metadata for DNSRecords.PTR, 0))
      {
        v705 = *((_QWORD *)&v1034 + 1);
        v706 = v1034;
        v707 = v1035;
        swift_bridgeObjectRelease(*((_QWORD *)&v1033 + 1));
      }
      else if (swift_dynamicCast(v13, v1181, v704, v9, 0))
      {
        sub_100033AC0((uint64_t)v13, (uint64_t)v11, type metadata accessor for DNSRecords.SRV);
        v706 = *((_QWORD *)v11 + 2);
        v705 = *((_QWORD *)v11 + 3);
        v707 = v11[32];
        swift_bridgeObjectRetain(v705);
        sub_100063824((uint64_t)v11, type metadata accessor for DNSRecords.SRV);
      }
      else
      {
        v769 = 0;
        if (!swift_dynamicCast(&v1033, v1181, v704, &type metadata for DNSRecords.TXT, 0))
        {
          sub_100014430(v1181);
          v42 = v776;
          goto LABEL_182;
        }
        v705 = *((_QWORD *)&v1034 + 1);
        v706 = v1034;
        v707 = v1035;
        v708 = *((_QWORD *)&v1035 + 1);
        v709 = v1036;
        swift_bridgeObjectRelease(*((_QWORD *)&v1033 + 1));
        sub_10000E614(v708, v709);
      }
      sub_100014430(v1181);
      v710 = sub_100012C44(&qword_100405BD0);
      v711 = type metadata accessor for DriverEvent(0);
      v712 = *(_QWORD *)(v711 - 8);
      v713 = *(_QWORD *)(v712 + 72);
      v714 = *(unsigned __int8 *)(v712 + 80);
      v715 = (v714 + 32) & ~v714;
      v218 = swift_allocObject(v710, v715 + v713, v714 | 7);
      *(_OWORD *)(v218 + 16) = xmmword_10033A110;
      v716 = v218 + v715;
      *(_QWORD *)&v1033 = 0;
      *((_QWORD *)&v1033 + 1) = 0xE000000000000000;
      _StringGuts.grow(_:)(35);
      swift_bridgeObjectRelease(*((_QWORD *)&v1033 + 1));
      *(_QWORD *)&v1033 = 0xD000000000000015;
      *((_QWORD *)&v1033 + 1) = 0x8000000100363860;
      v717._countAndFlagsBits = v706;
      DNSRecords.Identifier.description.getter(v706, v705, v707);
      object = v717._object;
      String.append(_:)(v717);
      swift_bridgeObjectRelease(v705);
      swift_bridgeObjectRelease(object);
      v719._countAndFlagsBits = 0x2064656B61654C20;
      v719._object = (void *)0xE90000000000005BLL;
      String.append(_:)(v719);
      LODWORD(v1181[0]) = *(_DWORD *)v1055;
      v720._countAndFlagsBits = dispatch thunk of CustomStringConvertible.description.getter(&type metadata for UInt32, &protocol witness table for UInt32);
      v721 = v720._object;
      String.append(_:)(v720);
      swift_bridgeObjectRelease(v721);
      v722._countAndFlagsBits = 93;
      v722._object = (void *)0xE100000000000000;
      String.append(_:)(v722);
      v723 = *((_QWORD *)&v1033 + 1);
      *(_QWORD *)v716 = v1033;
      *(_QWORD *)(v716 + 8) = v723;
      *(_QWORD *)(v716 + 16) = 0xD000000000000096;
      *(_QWORD *)(v716 + 24) = 0x8000000100363880;
      *(_BYTE *)(v716 + 32) = 1;
      v724 = type metadata accessor for DriverEvent.AWDL(0);
      swift_storeEnumTagMultiPayload(v716, v724, 6);
      v328 = v716;
      v329 = v711;
      v364 = 1;
LABEL_80:
      swift_storeEnumTagMultiPayload(v328, v329, v364);
      v366 = v775;
      v365 = v776;
      goto LABEL_197;
    case 0xB6uLL:
      type metadata accessor for apple80211_p2p_thread_coex_event(0);
      v572 = v571;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v572, v42, v43);
      if ((v1055[2] & 1) != 0)
        goto LABEL_181;
      v573 = v1055[0];
      v574 = v1055[1];
      v575 = sub_100012C44(&qword_100405BD0);
      v576 = type metadata accessor for DriverEvent(0);
      v577 = *(_QWORD *)(v576 - 8);
      v578 = *(_QWORD *)(v577 + 72);
      v579 = *(unsigned __int8 *)(v577 + 80);
      v580 = (v579 + 32) & ~v579;
      v135 = swift_allocObject(v575, v580 + v578, v579 | 7);
      *(_OWORD *)(v135 + 16) = xmmword_10033A110;
      v581 = (_BYTE *)(v135 + v580);
      *v581 = v573;
      v581[1] = v574;
      v582 = type metadata accessor for DriverEvent.AWDL(0);
      swift_storeEnumTagMultiPayload(v135 + v580, v582, 4);
      v178 = v135 + v580;
      v179 = v576;
      goto LABEL_167;
    case 0xC3uLL:
      v583 = sub_100012C44(&qword_100405BD0);
      v64 = type metadata accessor for DriverEvent(0);
      v584 = *(_QWORD *)(v64 - 8);
      v585 = *(_QWORD *)(v584 + 72);
      v586 = *(unsigned __int8 *)(v584 + 80);
      v587 = (v586 + 32) & ~v586;
      v69 = swift_allocObject(v583, v587 + v585, v586 | 7);
      *(_OWORD *)(v69 + 16) = xmmword_10033A110;
      v70 = v69 + v587;
      v71 = type metadata accessor for DriverEvent.AWDL(0);
      v72 = v69 + v587;
      v73 = 11;
      goto LABEL_188;
    case 0xC5uLL:
      type metadata accessor for apple80211_nan_preferred_channels_changed_event(0);
      v589 = v588;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v589, v42, v43);
      if ((v1055[36] & 1) != 0)
        goto LABEL_181;
      v771.i32[0] = *(_DWORD *)&v1055[32];
      v590 = *(_DWORD *)&v1055[24];
      v591 = *(_DWORD *)&v1055[16];
      v592 = *(_DWORD *)&v1055[8];
      v593 = *(_DWORD *)&v1055[12];
      v594 = *(_DWORD *)&v1055[4];
      v595 = *(_DWORD *)&v1055[20];
      v596 = HIDWORD(*(_QWORD *)&v1055[24]);
      v597 = sub_100012C44(&qword_100405BD0);
      v773 = type metadata accessor for DriverEvent(0);
      v598 = *(_QWORD *)(v773 - 8);
      v599 = *(_QWORD *)(v598 + 72);
      v600 = *(unsigned __int8 *)(v598 + 80);
      v601 = (v600 + 32) & ~v600;
      v602 = swift_allocObject(v597, v601 + v599, v600 | 7);
      v774 = (_BYTE *)v602;
      *(_OWORD *)(v602 + 16) = xmmword_10033A110;
      v772 = (char *)(v602 + v601);
      v1050.i64[0] = __PAIR64__(v592, v594);
      v1050.i64[1] = __PAIR64__(v591, v593);
      v1051 = __PAIR64__(v590, v595);
      v1052 = __PAIR64__(v771.u32[0], v596);
      if (qword_100404150 != -1)
        swift_once(&qword_100404150, sub_100190108);
      v603 = 0;
      v604 = _swiftEmptyArrayStorage;
      break;
    case 0xC8uLL:
      type metadata accessor for apple80211_awdl_stats_p2p_failure(0);
      v633 = v632;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v633, v42, v43);
      if ((v1055[40] & 1) != 0)
        goto LABEL_181;
      v1051 = *(_QWORD *)&v1055[16];
      v1052 = *(_QWORD *)&v1055[24];
      *(_QWORD *)&v1053[0] = *(_QWORD *)&v1055[32];
      v1050 = *(uint64x2_t *)v1055;
      v634 = sub_1000B515C((uint64_t)&v1050);
      v105 = v772;
      if (!v634)
        goto LABEL_182;
      v636 = v634;
      v637 = v635;
      v638 = sub_100012C44(&qword_100405BD0);
      v639 = type metadata accessor for DriverEvent(0);
      v640 = *(_QWORD *)(v639 - 8);
      v641 = *(_QWORD *)(v640 + 72);
      v642 = *(unsigned __int8 *)(v640 + 80);
      v643 = (v642 + 32) & ~v642;
      v135 = swift_allocObject(v638, v643 + v641, v642 | 7);
      *(_OWORD *)(v135 + 16) = xmmword_10033A110;
      v644 = v135 + v643;
      *(_QWORD *)v644 = v636;
      *(_BYTE *)(v644 + 8) = v637;
      v645 = type metadata accessor for DriverEvent.AWDL(0);
      swift_storeEnumTagMultiPayload(v135 + v643, v645, 8);
      v178 = v135 + v643;
      v179 = v639;
LABEL_167:
      v180 = 1;
      goto LABEL_177;
    case 0xD7uLL:
      type metadata accessor for ether_addr(0);
      v647 = v646;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v647, v42, v43);
      if ((v1055[6] & 1) != 0)
        goto LABEL_181;
      v648 = *(unsigned int *)v1055 | ((unint64_t)*(unsigned __int16 *)&v1055[4] << 32);
      v649 = sub_100012C44(&qword_100405BD0);
      v443 = type metadata accessor for DriverEvent(0);
      v650 = *(_QWORD *)(v443 - 8);
      v651 = *(_QWORD *)(v650 + 72);
      v652 = *(unsigned __int8 *)(v650 + 80);
      v653 = (v652 + 32) & ~v652;
      v100 = swift_allocObject(v649, v653 + v651, v652 | 7);
      *(_OWORD *)(v100 + 16) = xmmword_10033A110;
      v101 = v100 + v653;
      *(_QWORD *)v101 = v648;
      *(_OWORD *)(v101 + 24) = 0u;
      *(_OWORD *)(v101 + 8) = 0u;
      *(_BYTE *)(v101 + 40) = 0;
      v448 = 9;
LABEL_170:
      *(_BYTE *)(v101 + 41) = v448;
      v111 = v443;
      v112 = 2;
LABEL_171:
      swift_storeEnumTagMultiPayload(v101, v111, v112);
      sub_10000E614(v42, v43);
      return (_QWORD *)v100;
    case 0xE1uLL:
      type metadata accessor for apple80211_channel_band(0);
      v655 = v654;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v655, v42, v43);
      if ((v1055[4] & 1) != 0)
        goto LABEL_181;
      if (*(_DWORD *)v1055 >= 4u)
        v656 = 1;
      else
        v656 = 0x2010001u >> (8 * v1055[0]);
      v657 = sub_100012C44(&qword_100405BD0);
      v658 = type metadata accessor for DriverEvent(0);
      v659 = *(_QWORD *)(v658 - 8);
      v660 = *(_QWORD *)(v659 + 72);
      v661 = *(unsigned __int8 *)(v659 + 80);
      v662 = (v661 + 32) & ~v661;
      v135 = swift_allocObject(v657, v662 + v660, v661 | 7);
      *(_OWORD *)(v135 + 16) = xmmword_10033A110;
      v1055[0] = v656;
      sub_1000638C4((uint64_t)v1055);
      sub_100063888(v1055, (void *)(v135 + v662));
      v178 = v135 + v662;
      v179 = v658;
      v180 = 0;
LABEL_177:
      swift_storeEnumTagMultiPayload(v178, v179, v180);
      v138 = v42;
LABEL_178:
      v346 = v43;
LABEL_179:
      sub_10000E614(v138, v346);
      return (_QWORD *)v135;
    case 0xEAuLL:
      type metadata accessor for apple80211_idle_detect(0);
      v664 = v663;
      v43 = v775;
      v42 = v776;
      sub_100031FEC(v776, v775);
      sub_1000ACF34(v664, v42, v43);
      if ((v1055[8] & 1) != 0)
      {
LABEL_181:
        v105 = v772;
LABEL_182:
        Logger.init(subsystem:category:)(0xD000000000000012, 0x8000000100360DF0, 0x726576697264, 0xE600000000000000);
        sub_100031FEC(v42, v43);
        v665 = sub_100031FEC(v42, v43);
        v666 = Logger.logObject.getter(v665);
        v667 = static os_log_type_t.error.getter(v666);
        if (os_log_type_enabled(v666, v667))
        {
          v668 = swift_slowAlloc(22, -1);
          v669 = swift_slowAlloc(32, -1);
          v1181[0] = v669;
          *(_DWORD *)v668 = 134218242;
          *(_QWORD *)&v1180[0] = v768;
          UnsafeMutableRawBufferPointer.copyMemory(from:)(v1180, (char *)v1180 + 8);
          *(_WORD *)(v668 + 12) = 2080;
          sub_100031FEC(v776, v43);
          sub_100032030(0, 0xE000000000000000, v776, v43);
          v671 = v670;
          v673 = v672;
          sub_10000E614(v776, v775);
          *(_QWORD *)&v1180[0] = sub_100013CC8(v671, v673, v1181);
          v42 = v776;
          UnsafeMutableRawBufferPointer.copyMemory(from:)(v1180, (char *)v1180 + 8);
          v674 = v673;
          v43 = v775;
          swift_bridgeObjectRelease(v674);
          sub_10000E614(v42, v43);
          sub_10000E614(v42, v43);
          _os_log_impl((void *)&_mh_execute_header, v666, v667, "Failed to parse event[%ld]: %s", (uint8_t *)v668, 0x16u);
          swift_arrayDestroy(v669, 1, (char *)&type metadata for Any + 8);
          swift_slowDealloc(v669, -1, -1);
          swift_slowDealloc(v668, -1, -1);
        }
        else
        {
          sub_10000E614(v42, v43);
          sub_10000E614(v42, v43);
        }

        (*(void (**)(char *, uint64_t))(v770 + 8))(v105, v771.i64[0]);
LABEL_186:
        sub_10000E614(v42, v43);
        return _swiftEmptyArrayStorage;
      }
      else
      {
        v682 = *(_DWORD *)v1055;
        v683 = *(unsigned int *)&v1055[4];
        v684 = sub_100012C44(&qword_100405BD0);
        v685 = type metadata accessor for DriverEvent(0);
        v686 = *(_QWORD *)(v685 - 8);
        v687 = *(_QWORD *)(v686 + 72);
        v688 = *(unsigned __int8 *)(v686 + 80);
        v689 = (v688 + 32) & ~v688;
        v218 = swift_allocObject(v684, v689 + v687, v688 | 7);
        *(_OWORD *)(v218 + 16) = xmmword_10033A110;
        v690 = v218 + v689;
        *(_QWORD *)(v218 + v689) = v682;
        v691 = enum case for DispatchTimeInterval.milliseconds(_:);
        v692 = type metadata accessor for DispatchTimeInterval(0);
        v216 = v42;
        v693 = *(void (**)(void))(*(_QWORD *)(v692 - 8) + 104);
        ((void (*)(uint64_t, uint64_t, uint64_t))v693)(v690, v691, v692);
        *(_QWORD *)(v690 + *(int *)(type metadata accessor for AWDLIdleActivity(0) + 20)) = v683;
        v693();
        v694 = type metadata accessor for DriverEvent.AWDL(0);
        swift_storeEnumTagMultiPayload(v690, v694, 9);
        v255 = v690;
        v478 = v685;
        v479 = 1;
LABEL_195:
        swift_storeEnumTagMultiPayload(v255, v478, v479);
        v365 = v216;
LABEL_196:
        v366 = v43;
LABEL_197:
        sub_10000E614(v365, v366);
        return (_QWORD *)v218;
      }
    case 0xEBuLL:
      v675 = sub_100012C44(&qword_100405BD0);
      v64 = type metadata accessor for DriverEvent(0);
      v676 = *(_QWORD *)(v64 - 8);
      v677 = *(_QWORD *)(v676 + 72);
      v678 = *(unsigned __int8 *)(v676 + 80);
      v679 = (v678 + 32) & ~v678;
      v69 = swift_allocObject(v675, v679 + v677, v678 | 7);
      *(_OWORD *)(v69 + 16) = xmmword_10033A110;
      v70 = v69 + v679;
      v71 = type metadata accessor for DriverEvent.AWDL(0);
      v72 = v69 + v679;
      v73 = 13;
LABEL_188:
      swift_storeEnumTagMultiPayload(v72, v71, v73);
      swift_storeEnumTagMultiPayload(v70, v64, 1);
      return (_QWORD *)v69;
    default:
      return result;
  }
  do
  {
    v606 = v1050.u32[v603];
    v607 = off_100409F48;
    if (*((_QWORD *)off_100409F48 + 2))
    {
      v608 = static Hasher._hash(seed:bytes:count:)(*((_QWORD *)off_100409F48 + 5), v1050.u32[v603], 4);
      v609 = -1 << v607[32];
      v610 = v608 & ~v609;
      if (((*(_QWORD *)&v607[((v610 >> 3) & 0xFFFFFFFFFFFFF8) + 56] >> v610) & 1) != 0)
      {
        v611 = *((_QWORD *)v607 + 6);
        if (*(_DWORD *)(v611 + 4 * v610) == (_DWORD)v606)
        {
LABEL_141:
          v613 = 0;
          v614 = 3;
LABEL_160:
          *(_DWORD *)v1055 = v606;
          v1055[4] = v613;
          v1055[5] = v614;
          sub_10018FA04();
          v627 = *(_DWORD *)v1055;
          v628 = v1055[4];
          v629 = v1055[5];
          if ((swift_isUniquelyReferenced_nonNull_native(v604) & 1) == 0)
            v604 = sub_1000B1E74(0, v604[2] + 1, 1, v604);
          v631 = v604[2];
          v630 = v604[3];
          if (v631 >= v630 >> 1)
            v604 = sub_1000B1E74((_QWORD *)(v630 > 1), v631 + 1, 1, v604);
          v604[2] = v631 + 1;
          v605 = &v604[v631];
          *((_DWORD *)v605 + 8) = v627;
          *((_BYTE *)v605 + 36) = v628;
          *((_BYTE *)v605 + 37) = v629;
          goto LABEL_134;
        }
        v612 = ~v609;
        while (1)
        {
          v610 = (v610 + 1) & v612;
          if (((*(_QWORD *)&v607[((v610 >> 3) & 0xFFFFFFFFFFFFF8) + 56] >> v610) & 1) == 0)
            break;
          if (*(_DWORD *)(v611 + 4 * v610) == (_DWORD)v606)
            goto LABEL_141;
        }
      }
    }
    if (qword_100404158 != -1)
      swift_once(&qword_100404158, sub_10019012C);
    v615 = off_100409F50;
    if (!*((_QWORD *)off_100409F50 + 2))
      goto LABEL_151;
    v616 = static Hasher._hash(seed:bytes:count:)(*((_QWORD *)off_100409F50 + 5), v606, 4);
    v617 = -1 << v615[32];
    v618 = v616 & ~v617;
    if (((*(_QWORD *)&v615[((v618 >> 3) & 0xFFFFFFFFFFFFF8) + 56] >> v618) & 1) == 0)
      goto LABEL_151;
    v619 = *((_QWORD *)v615 + 6);
    if (*(_DWORD *)(v619 + 4 * v618) == (_DWORD)v606)
    {
LABEL_150:
      v613 = 1;
      v614 = 4;
      goto LABEL_160;
    }
    v620 = ~v617;
    while (1)
    {
      v618 = (v618 + 1) & v620;
      if (((*(_QWORD *)&v615[((v618 >> 3) & 0xFFFFFFFFFFFFF8) + 56] >> v618) & 1) == 0)
        break;
      if (*(_DWORD *)(v619 + 4 * v618) == (_DWORD)v606)
        goto LABEL_150;
    }
LABEL_151:
    if (qword_100404160 != -1)
      swift_once(&qword_100404160, sub_100190150);
    v621 = off_100409F58;
    if (*((_QWORD *)off_100409F58 + 2))
    {
      v622 = static Hasher._hash(seed:bytes:count:)(*((_QWORD *)off_100409F58 + 5), v606, 4);
      v623 = -1 << v621[32];
      v624 = v622 & ~v623;
      if (((*(_QWORD *)&v621[((v624 >> 3) & 0xFFFFFFFFFFFFF8) + 56] >> v624) & 1) != 0)
      {
        v625 = *((_QWORD *)v621 + 6);
        if (*(_DWORD *)(v625 + 4 * v624) == (_DWORD)v606)
        {
LABEL_159:
          v613 = 2;
          v614 = 5;
          goto LABEL_160;
        }
        v626 = ~v623;
        while (1)
        {
          v624 = (v624 + 1) & v626;
          if (((*(_QWORD *)&v621[((v624 >> 3) & 0xFFFFFFFFFFFFF8) + 56] >> v624) & 1) == 0)
            break;
          if (*(_DWORD *)(v625 + 4 * v624) == (_DWORD)v606)
            goto LABEL_159;
        }
      }
    }
LABEL_134:
    ++v603;
  }
  while (v603 != 8);
  *(_QWORD *)v1055 = v604;
  sub_1000638D0((uint64_t)v1055);
  v523 = (uint64_t *)v1055;
LABEL_193:
  v680 = v772;
  sub_100063888(v523, v772);
  swift_storeEnumTagMultiPayload(v680, v773, 0);
  v681 = v776;
LABEL_201:
  sub_10000E614(v681, v775);
  return v774;
}

uint64_t AppleIO80211Driver.__allocating_init(device:role:name:)(uint64_t a1, char a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v9;

  v9 = swift_allocObject(v4, *(unsigned int *)(v4 + 48), *(unsigned __int16 *)(v4 + 52));
  AppleIO80211Driver.init(device:role:name:)(a1, a2, a3, a4);
  return v9;
}

unint64_t Channel.init(apple80211:)(uint64_t a1, unsigned int a2)
{
  return sub_1000B388C(HIDWORD(a1), a2) & 0xFFFFFFFFFFFFLL;
}

BOOL sub_10009B344(unsigned int a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 result;
  uint64_t v10;
  unint64_t v11;
  int v12;

  if (!*(_QWORD *)(a2 + 16))
    return 0;
  v4 = static Hasher._hash(seed:bytes:count:)(*(_QWORD *)(a2 + 40), a1, 4);
  v5 = -1 << *(_BYTE *)(a2 + 32);
  v6 = v4 & ~v5;
  v7 = a2 + 56;
  if (((*(_QWORD *)(a2 + 56 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8)) >> v6) & 1) == 0)
    return 0;
  v8 = *(_QWORD *)(a2 + 48);
  if (*(_DWORD *)(v8 + 4 * v6) == a1)
    return 1;
  v10 = ~v5;
  v11 = (v6 + 1) & v10;
  if (((*(_QWORD *)(v7 + ((v11 >> 3) & 0xFFFFFFFFFFFFF8)) >> v11) & 1) == 0)
    return 0;
  do
  {
    v12 = *(_DWORD *)(v8 + 4 * v11);
    result = v12 == a1;
    if (v12 == a1)
      break;
    v11 = (v11 + 1) & v10;
  }
  while (((*(_QWORD *)(v7 + ((v11 >> 3) & 0xFFFFFFFFFFFFF8)) >> v11) & 1) != 0);
  return result;
}

uint64_t sub_10009B410(int a1, uint64_t a2)
{
  Swift::UInt v4;
  Swift::Int v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  _QWORD v10[9];

  if (*(_QWORD *)(a2 + 16))
  {
    Hasher.init(_seed:)(v10);
    switch((char)a1)
    {
      case 2:
        v4 = 0;
        goto LABEL_9;
      case 3:
        v4 = 1;
        goto LABEL_9;
      case 4:
        v4 = 3;
        goto LABEL_9;
      case 5:
        v4 = 4;
        goto LABEL_9;
      case 6:
        v4 = 5;
LABEL_9:
        Hasher._combine(_:)(v4);
        break;
      default:
        Hasher._combine(_:)(2uLL);
        Hasher._combine(_:)(a1 & 1);
        break;
    }
    v5 = Hasher._finalize()();
    v6 = -1 << *(_BYTE *)(a2 + 32);
    v7 = v5 & ~v6;
    if (((*(_QWORD *)(a2 + 56 + ((v7 >> 3) & 0xFFFFFFFFFFFFF8)) >> v7) & 1) != 0)
    {
      v8 = ~v6;
      while (1)
      {
        switch(*(_BYTE *)(*(_QWORD *)(a2 + 48) + v7))
        {
          case 2:
            if (a1 != 2)
              goto LABEL_13;
            return 1;
          case 3:
            if (a1 == 3)
              return 1;
            goto LABEL_13;
          case 4:
            if (a1 == 4)
              return 1;
            goto LABEL_13;
          case 5:
            if (a1 == 5)
              return 1;
            goto LABEL_13;
          case 6:
            if (a1 != 6)
              goto LABEL_13;
            return 1;
          default:
            if ((a1 - 2) >= 5u && ((a1 ^ ((*(_BYTE *)(*(_QWORD *)(a2 + 48) + v7) & 1) == 0)) & 1) != 0)
              return 1;
LABEL_13:
            v7 = (v7 + 1) & v8;
            if (((*(_QWORD *)(a2 + 56 + ((v7 >> 3) & 0xFFFFFFFFFFFFF8)) >> v7) & 1) == 0)
              return 0;
            break;
        }
      }
    }
  }
  return 0;
}

uint64_t Channel.Band.apple80211Band.getter(unsigned __int8 a1)
{
  return a1 + 1;
}

double sub_10009B5DC(uint64_t a1)
{
  return sub_10009B5F4(a1, (uint64_t (*)(uint64_t, uint64_t))sub_1000B73E8);
}

double sub_10009B5E8(uint64_t a1)
{
  return sub_10009B5F4(a1, sub_1000B6894);
}

double sub_10009B5F4(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t))
{
  uint64_t v2;
  double result;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;

  sub_1001A881C(0, *(_QWORD *)(*(_QWORD *)v2 + 16), 0, *(_QWORD *)(a1 + 16), a2);
  v4 = *(_QWORD *)(*(_QWORD *)v2 + 16);
  v5 = *(_QWORD *)(a1 + 16);
  if (v4 < v5)
  {
    v6 = (2 * v5) | 1;
    v7 = swift_bridgeObjectRetain(a1);
    sub_1001A88E8(v7, a1 + 32, v4, v6);
    *(_QWORD *)&result = swift_bridgeObjectRelease(a1).n128_u64[0];
  }
  return result;
}

uint64_t IO80211Device.loadCapabilities(on:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t result;
  _BYTE v6[23];
  char v7;

  memset(v6, 0, sizeof(v6));
  result = (*(uint64_t (**)(uint64_t, _BYTE *, char *, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 32))(12, &v6[4], &v7, 0, a1, a2, a3, a4);
  if (!v4)
    return *(_QWORD *)v6;
  return result;
}

uint64_t AppleBroadcomDriver.interfaceName.getter()
{
  uint64_t v0;
  uint64_t v1;

  v1 = *(_QWORD *)(v0 + 16);
  swift_bridgeObjectRetain(*(_QWORD *)(v0 + 24));
  return v1;
}

uint64_t AppleBroadcomDriver.interfaceRole.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 32);
}

uint64_t AppleBroadcomDriver.device.getter()
{
  uint64_t v0;

  return swift_retain(*(_QWORD *)(v0 + 40));
}

uint64_t AppleBroadcomDriver.eventSource.getter()
{
  _QWORD *v0;
  uint64_t v1;
  _BYTE v3[24];

  swift_beginAccess(v0 + 6, v3, 0, 0);
  v1 = v0[6];
  sub_1000B5380(v1, v0[7], v0[8]);
  return v1;
}

uint64_t AppleBroadcomDriver.eventSource.setter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE v11[24];

  swift_beginAccess(v3 + 6, v11, 1, 0);
  v7 = v3[6];
  v8 = v3[7];
  v9 = v3[8];
  v3[6] = a1;
  v3[7] = a2;
  v3[8] = a3;
  return sub_1000B53AC(v7, v8, v9);
}

void *AppleBroadcomDriver.eventSource.modify(uint64_t a1)
{
  uint64_t v1;

  swift_beginAccess(v1 + 48, a1, 33, 0);
  return &j__swift_endAccess;
}

_QWORD *AppleIO80211Driver.capabilities.getter()
{
  uint64_t v0;
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;

  v1 = *(_QWORD *)(v0 + 72);
  if (v1)
  {
    v2 = *(_QWORD **)(v0 + 72);
  }
  else
  {
    v2 = sub_10009B8C4();
    v3 = *(_QWORD *)(v0 + 72);
    *(_QWORD *)(v0 + 72) = v2;
    swift_bridgeObjectRetain(v2);
    swift_bridgeObjectRelease(v3);
    v1 = 0;
  }
  swift_bridgeObjectRetain(v1);
  return v2;
}

_QWORD *sub_10009B8C4()
{
  _QWORD *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v16;
  _BYTE v17[24];

  v16 = _swiftEmptyArrayStorage;
  v1 = v0[5];
  v2 = v0[2];
  v3 = v0[3];
  swift_retain();
  swift_bridgeObjectRetain(v3);
  v4 = AppleDevice.loadCapabilities(on:)(v2, v3);
  v6 = v5;
  swift_bridgeObjectRelease(v3);
  swift_release(v1);
  if (qword_100403EA8 == -1)
  {
    if ((v6 & 0x10000000000) == 0)
      goto LABEL_4;
    goto LABEL_3;
  }
  swift_once(&qword_100403EA8, sub_100069290);
  if ((v6 & 0x10000000000) != 0)
  {
LABEL_3:
    v7 = static WiFiDriverCapabilities.supportsNAN;
    swift_beginAccess(&v16, v17, 33, 0);
    sub_10009B5F4(v7, (uint64_t (*)(uint64_t, uint64_t))sub_1000B73E8);
    swift_endAccess(v17);
  }
LABEL_4:
  if (qword_100403EB0 == -1)
  {
    if ((v6 & 1) == 0)
      goto LABEL_7;
    goto LABEL_6;
  }
  swift_once(&qword_100403EB0, sub_10006930C);
  if ((v6 & 1) != 0)
  {
LABEL_6:
    v8 = static WiFiDriverCapabilities.supportsAWDL;
    swift_beginAccess(&v16, v17, 33, 0);
    sub_10009B5F4(v8, (uint64_t (*)(uint64_t, uint64_t))sub_1000B73E8);
    swift_endAccess(v17);
  }
LABEL_7:
  if (qword_100403EB8 == -1)
  {
    v9 = BYTE3(v6);
    if ((v4 & 0x2000000000000000) == 0)
      goto LABEL_10;
    goto LABEL_9;
  }
  swift_once(&qword_100403EB8, sub_100069388);
  v9 = BYTE3(v6);
  if ((v4 & 0x2000000000000000) != 0)
  {
LABEL_9:
    v10 = static WiFiDriverCapabilities.supportsDualBand;
    swift_beginAccess(&v16, v17, 33, 0);
    sub_10009B5F4(v10, (uint64_t (*)(uint64_t, uint64_t))sub_1000B73E8);
    swift_endAccess(v17);
  }
LABEL_10:
  if (qword_100403EC0 == -1)
  {
    if ((v9 & 2) == 0)
      goto LABEL_13;
    goto LABEL_12;
  }
  swift_once(&qword_100403EC0, sub_100069404);
  if ((v9 & 2) != 0)
  {
LABEL_12:
    v11 = static WiFiDriverCapabilities.supportsSimultaneousDualBand;
    swift_beginAccess(&v16, v17, 33, 0);
    sub_10009B5F4(v11, (uint64_t (*)(uint64_t, uint64_t))sub_1000B73E8);
    swift_endAccess(v17);
  }
LABEL_13:
  if (qword_100403EC8 == -1)
  {
    if ((v6 & 0x80000) == 0)
      goto LABEL_16;
    goto LABEL_15;
  }
  swift_once(&qword_100403EC8, sub_100069480);
  if ((v6 & 0x80000) != 0)
  {
LABEL_15:
    v12 = static WiFiDriverCapabilities.supportsAWDLSoloMode;
    swift_beginAccess(&v16, v17, 33, 0);
    sub_10009B5F4(v12, (uint64_t (*)(uint64_t, uint64_t))sub_1000B73E8);
    swift_endAccess(v17);
  }
LABEL_16:
  if (qword_100403ED0 == -1)
  {
    if ((v9 & 0x80) == 0)
      goto LABEL_19;
    goto LABEL_18;
  }
  swift_once(&qword_100403ED0, sub_1000694FC);
  if (v9 < 0)
  {
LABEL_18:
    v13 = static WiFiDriverCapabilities.isClmRestricted;
    swift_beginAccess(&v16, v17, 33, 0);
    sub_10009B5F4(v13, (uint64_t (*)(uint64_t, uint64_t))sub_1000B73E8);
    swift_endAccess(v17);
  }
LABEL_19:
  if (qword_100403EE0 != -1)
  {
    swift_once(&qword_100403EE0, sub_1000695F4);
    if ((v6 & 0x800000000) == 0)
      goto LABEL_22;
    goto LABEL_21;
  }
  if ((v6 & 0x800000000) != 0)
  {
LABEL_21:
    v14 = static WiFiDriverCapabilities.supportsDFSProxy;
    swift_beginAccess(&v16, v17, 33, 0);
    sub_10009B5F4(v14, (uint64_t (*)(uint64_t, uint64_t))sub_1000B73E8);
    swift_endAccess(v17);
  }
LABEL_22:
  swift_beginAccess(&v16, v17, 0, 0);
  return v16;
}

_QWORD *IO80211Driver<>.loadCapabilities()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t AssociatedTypeWitness;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t AssociatedConformanceWitness;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v27;
  _QWORD *v28;
  _BYTE v29[24];

  v6 = *(_QWORD *)(a2 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v6, a1, &protocol requirements base descriptor for DeviceDriver);
  v8 = *(_QWORD *)(AssociatedTypeWitness - 8);
  __chkstk_darwin();
  v10 = (char *)&v27 - v9;
  v28 = _swiftEmptyArrayStorage;
  (*(void (**)(uint64_t, uint64_t))(v6 + 56))(a1, v6);
  v11 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 40))(a1, a3);
  v13 = v12;
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a2, a1, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(AssociatedConformanceWitness + 16))(v11, v13, AssociatedTypeWitness, AssociatedConformanceWitness);
  v17 = v16;
  (*(void (**)(char *, uint64_t))(v8 + 8))(v10, AssociatedTypeWitness);
  swift_bridgeObjectRelease(v13);
  if (qword_100403EA8 == -1)
  {
    if ((v17 & 0x10000000000) == 0)
      goto LABEL_4;
    goto LABEL_3;
  }
  swift_once(&qword_100403EA8, sub_100069290);
  if ((v17 & 0x10000000000) != 0)
  {
LABEL_3:
    v18 = static WiFiDriverCapabilities.supportsNAN;
    swift_beginAccess(&v28, v29, 33, 0);
    sub_10009B5F4(v18, (uint64_t (*)(uint64_t, uint64_t))sub_1000B73E8);
    swift_endAccess(v29);
  }
LABEL_4:
  if (qword_100403EB0 == -1)
  {
    if ((v17 & 1) == 0)
      goto LABEL_7;
    goto LABEL_6;
  }
  swift_once(&qword_100403EB0, sub_10006930C);
  if ((v17 & 1) != 0)
  {
LABEL_6:
    v19 = static WiFiDriverCapabilities.supportsAWDL;
    swift_beginAccess(&v28, v29, 33, 0);
    sub_10009B5F4(v19, (uint64_t (*)(uint64_t, uint64_t))sub_1000B73E8);
    swift_endAccess(v29);
  }
LABEL_7:
  if (qword_100403EB8 == -1)
  {
    v20 = BYTE3(v17);
    if ((v15 & 0x2000000000000000) == 0)
      goto LABEL_10;
    goto LABEL_9;
  }
  swift_once(&qword_100403EB8, sub_100069388);
  v20 = BYTE3(v17);
  if ((v15 & 0x2000000000000000) != 0)
  {
LABEL_9:
    v21 = static WiFiDriverCapabilities.supportsDualBand;
    swift_beginAccess(&v28, v29, 33, 0);
    sub_10009B5F4(v21, (uint64_t (*)(uint64_t, uint64_t))sub_1000B73E8);
    swift_endAccess(v29);
  }
LABEL_10:
  if (qword_100403EC0 == -1)
  {
    if ((v20 & 2) == 0)
      goto LABEL_13;
    goto LABEL_12;
  }
  swift_once(&qword_100403EC0, sub_100069404);
  if ((v20 & 2) != 0)
  {
LABEL_12:
    v22 = static WiFiDriverCapabilities.supportsSimultaneousDualBand;
    swift_beginAccess(&v28, v29, 33, 0);
    sub_10009B5F4(v22, (uint64_t (*)(uint64_t, uint64_t))sub_1000B73E8);
    swift_endAccess(v29);
  }
LABEL_13:
  if (qword_100403EC8 == -1)
  {
    if ((v17 & 0x80000) == 0)
      goto LABEL_16;
    goto LABEL_15;
  }
  swift_once(&qword_100403EC8, sub_100069480);
  if ((v17 & 0x80000) != 0)
  {
LABEL_15:
    v23 = static WiFiDriverCapabilities.supportsAWDLSoloMode;
    swift_beginAccess(&v28, v29, 33, 0);
    sub_10009B5F4(v23, (uint64_t (*)(uint64_t, uint64_t))sub_1000B73E8);
    swift_endAccess(v29);
  }
LABEL_16:
  if (qword_100403ED0 == -1)
  {
    if ((v20 & 0x80) == 0)
      goto LABEL_19;
    goto LABEL_18;
  }
  swift_once(&qword_100403ED0, sub_1000694FC);
  if (v20 < 0)
  {
LABEL_18:
    v24 = static WiFiDriverCapabilities.isClmRestricted;
    swift_beginAccess(&v28, v29, 33, 0);
    sub_10009B5F4(v24, (uint64_t (*)(uint64_t, uint64_t))sub_1000B73E8);
    swift_endAccess(v29);
  }
LABEL_19:
  if (qword_100403EE0 != -1)
  {
    swift_once(&qword_100403EE0, sub_1000695F4);
    if ((v17 & 0x800000000) == 0)
      goto LABEL_22;
    goto LABEL_21;
  }
  if ((v17 & 0x800000000) != 0)
  {
LABEL_21:
    v25 = static WiFiDriverCapabilities.supportsDFSProxy;
    swift_beginAccess(&v28, v29, 33, 0);
    sub_10009B5F4(v25, (uint64_t (*)(uint64_t, uint64_t))sub_1000B73E8);
    swift_endAccess(v29);
  }
LABEL_22:
  swift_beginAccess(&v28, v29, 0, 0);
  return v28;
}

uint64_t AppleIO80211Driver.logger.getter@<X0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;

  v3 = v1 + OBJC_IVAR____TtC7CoreP2P18AppleIO80211Driver_logger;
  v4 = type metadata accessor for Logger(0);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 - 8) + 16))(a1, v3, v4);
}

void AppleIO80211Driver.init(device:role:name:)(uint64_t a1, char a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;

  type metadata accessor for Logger(0);
  __chkstk_darwin();
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)(v4 + 64) = 0u;
  *(_QWORD *)(v4 + 40) = a1;
  *(_BYTE *)(v4 + 32) = a2;
  *(_QWORD *)(v4 + 16) = a3;
  *(_QWORD *)(v4 + 24) = a4;
  __asm { BR              X10 }
}

uint64_t sub_10009C208()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  os_log_type_t v8;
  uint8_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;

  swift_retain();
  Logger.init(subsystem:category:)(0x6C7070612E6D6F63, 0xED00006E616E2E65, 0x726576697264, 0xE600000000000000);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v4 + 32))(v0 + OBJC_IVAR____TtC7CoreP2P18AppleIO80211Driver_logger, v3, v1);
  v6 = swift_retain_n(v0, 2);
  v7 = Logger.logObject.getter(v6);
  v8 = static os_log_type_t.info.getter();
  if (os_log_type_enabled(v7, v8))
  {
    v9 = (uint8_t *)swift_slowAlloc(12, -1);
    v10 = swift_slowAlloc(32, -1);
    *(_QWORD *)(v5 - 88) = v10;
    *(_DWORD *)v9 = 136315138;
    swift_retain();
    AppleIO80211Driver.description.getter();
    v12 = v11;
    v14 = v13;
    swift_release(v0);
    *(_QWORD *)(v5 - 96) = sub_100013CC8(v12, v14, (uint64_t *)(v5 - 88));
    UnsafeMutableRawBufferPointer.copyMemory(from:)(v5 - 96, v5 - 88);
    swift_release_n(v0, 2);
    swift_bridgeObjectRelease(v14);
    _os_log_impl((void *)&_mh_execute_header, v7, v8, "Created %s", v9, 0xCu);
    swift_arrayDestroy(v10, 1, (char *)&type metadata for Any + 8);
    swift_slowDealloc(v10, -1, -1);
    swift_slowDealloc(v9, -1, -1);
  }
  else
  {
    swift_release_n(v0, 2);
  }

  swift_release(v2);
  return v0;
}

uint64_t AppleIO80211Driver.deinit()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  os_log_type_t v8;
  uint8_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18[3];

  v1 = v0;
  swift_beginAccess(v0 + 48, v18, 33, 0);
  v2 = *(_QWORD *)(v0 + 64);
  if (v2)
  {
    v3 = *(_QWORD *)(v1 + 48);
    swift_unownedRetain(v3);
    swift_bridgeObjectRetain(v2);
    swift_unownedRelease(v3);
    swift_bridgeObjectRelease(v2);
    v4 = *(_QWORD *)(v1 + 48);
    swift_unownedRetainStrong(v4);
    AppleDevice.stopMonitoringEvents(on:)(*(Swift::String *)(v1 + 56));
    swift_release(v4);
  }
  swift_endAccess(v18);
  v5 = v1 + OBJC_IVAR____TtC7CoreP2P18AppleIO80211Driver_logger;
  v6 = swift_retain_n(v1, 2);
  v7 = Logger.logObject.getter(v6);
  v8 = static os_log_type_t.info.getter();
  if (os_log_type_enabled(v7, v8))
  {
    v9 = (uint8_t *)swift_slowAlloc(12, -1);
    v10 = swift_slowAlloc(32, -1);
    v18[0] = v10;
    *(_DWORD *)v9 = 136315138;
    swift_retain();
    AppleIO80211Driver.description.getter();
    v12 = v11;
    v14 = v13;
    swift_release(v1);
    v17 = sub_100013CC8(v12, v14, v18);
    UnsafeMutableRawBufferPointer.copyMemory(from:)(&v17, v18);
    swift_release_n(v1, 2);
    swift_bridgeObjectRelease(v14);
    _os_log_impl((void *)&_mh_execute_header, v7, v8, "Destroyed %s", v9, 0xCu);
    swift_arrayDestroy(v10, 1, (char *)&type metadata for Any + 8);
    swift_slowDealloc(v10, -1, -1);
    swift_slowDealloc(v9, -1, -1);

  }
  else
  {

    swift_release_n(v1, 2);
  }
  swift_bridgeObjectRelease(*(_QWORD *)(v1 + 24));
  swift_release(*(_QWORD *)(v1 + 40));
  sub_1000B53AC(*(_QWORD *)(v1 + 48), *(_QWORD *)(v1 + 56), *(_QWORD *)(v1 + 64));
  swift_bridgeObjectRelease(*(_QWORD *)(v1 + 72));
  v15 = type metadata accessor for Logger(0);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v15 - 8) + 8))(v5, v15);
  return v1;
}

uint64_t AppleIO80211Driver.__deallocating_deinit()
{
  uint64_t v0;

  AppleIO80211Driver.deinit();
  return swift_deallocClassInstance(v0, *(unsigned int *)(*(_QWORD *)v0 + 48), *(unsigned __int16 *)(*(_QWORD *)v0 + 52));
}

uint64_t DeviceDriver<>.countryCode.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9;
  unsigned __int16 v11;

  if ((*(unsigned __int8 (**)(uint64_t, uint64_t))(a3 + 32))(a1, a3) == 4)
  {
    if (qword_100403F88 != -1)
      swift_once(&qword_100403F88, sub_10012D674);
    return (unsigned __int16)static CountryCode.unknown;
  }
  else
  {
    v9 = sub_100012C44(&qword_100406708);
    sub_1000ABF34(51, v9, a1, v9, a2, a3, a4);
    return v11;
  }
}

uint64_t sub_10009C738(__int16 a1, uint64_t a2, uint64_t a3)
{
  return sub_1000B0F68(a1, a2, a3, (uint64_t (*)(uint64_t, unint64_t))sub_10005A574);
}

uint64_t DeviceDriver<>.update(countryCode:)(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  int v11;
  __int16 v12;
  char v13;

  v11 = 0;
  v12 = a1;
  v13 = 0;
  type metadata accessor for apple80211_country_code_data(0);
  return sub_1000AC020(51, (uint64_t)&v11, a2, v9, a3, a4, a5);
}

uint64_t DeviceDriver<>.userspaceP2POptions.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v10;

  type metadata accessor for apple80211_userspace_p2p_options_t(0);
  sub_1000ABF34(389, v8, a1, v8, a2, *(_QWORD *)(a3 + 16), a4);
  return v10;
}

uint64_t sub_10009C85C(uint64_t a1)
{
  return sub_10005A5BC(0x185uLL, 1, a1);
}

uint64_t DeviceDriver<>.update(userspaceP2POptions:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  int v11;
  uint64_t v12;

  v12 = a1;
  v11 = 1;
  type metadata accessor for apple80211_userspace_p2p_options_t(0);
  return sub_1000AC020(389, (uint64_t)&v11, a2, v9, a3, *(_QWORD *)(a4 + 16), a5);
}

uint64_t sub_10009C900(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1000B0FEC(a1, a2, a3, a4, (uint64_t (*)(uint64_t, int *))sub_10005A45C);
}

uint64_t DeviceDriver<>.updateGateway(macAddress:ipAddress:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return sub_10009C968(a1, a2, a3, a4, a5, a6, 450);
}

uint64_t sub_10009C934(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1000B10F0(a1, a2, a3, a4, (uint64_t (*)(uint64_t, int *))sub_10005A45C);
}

uint64_t DeviceDriver<>.updateInfraPeer(macAddress:ipAddress:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return sub_10009C968(a1, a2, a3, a4, a5, a6, 451);
}

uint64_t sub_10009C968(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return sub_1000AC6D0(a1 & 0xFFFFFFFFFFFFLL, a2, a7, a3, a4, a5, a6);
}

void sub_10009C998(char a1)
{
  sub_1000B11F4(a1);
}

void DeviceDriver<>.updateInterfaceState(for:active:)(char a1)
{
  __asm { BR              X10 }
}

uint64_t sub_10009C9FC(uint64_t a1, char a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _DWORD v8[2];
  uint64_t v9;
  int v10;

  v8[0] = (a2 & 1) != 0;
  v8[1] = 6;
  v9 = 1;
  v10 = 0;
  type metadata accessor for apple80211_virtual_if_state(0);
  return sub_1000AC020(503, (uint64_t)v8, v4, v6, v3, *(_QWORD *)(v5 + 16), v2);
}

BOOL sub_10009CA78()
{
  int v0;

  sub_1000AB43C(0x75uLL);
  return v0 != 0;
}

BOOL IO80211Driver<>.awdlEnabled.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  int v13;

  type metadata accessor for apple80211_awdl_sync_enabled(0);
  v7 = v6;
  v8 = *(_QWORD *)(a3 + 8);
  v9 = *(_QWORD *)(a2 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, a1, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, a1, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  sub_1000ABF34(117, v7, a1, v7, v8, v9, AssociatedConformanceWitness);
  return v13 != 0;
}

uint64_t sub_10009CBA0()
{
  uint64_t v0;

  sub_1000AB51C(0x94uLL);
  return v0;
}

uint64_t IO80211Driver<>.awdlSubstate.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  unsigned int v13;

  type metadata accessor for apple80211_awdl_strategy(0);
  v7 = v6;
  v8 = *(_QWORD *)(a3 + 8);
  v9 = *(_QWORD *)(a2 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, a1, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, a1, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  sub_1000ABF34(148, v7, a1, v7, v8, v9, AssociatedConformanceWitness);
  return v13;
}

uint64_t sub_10009CCBC()
{
  unint64_t v0;
  unsigned __int16 v1;
  unsigned __int16 v2;
  unsigned __int16 v3;
  unint64_t v4;

  v0 = sub_1000AB604(0xF4uLL);
  v1 = WORD2(v0);
  v3 = v2;
  v4 = sub_100192784(HIWORD(v0));
  sub_100192784(v1);
  sub_100192784(v3);
  return v4 & 0xFFFFFFFFFFFFLL;
}

uint64_t IO80211Driver<>.peerPreferredChannels.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  unint64_t v12;
  unsigned __int16 v14;
  unsigned __int16 v15;
  unsigned __int16 v16;

  type metadata accessor for apple80211_awdl_preferred_channels(0);
  v7 = v6;
  v8 = *(_QWORD *)(a3 + 8);
  v9 = *(_QWORD *)(a2 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, a1, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, a1, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  sub_1000ABF34(244, v7, a1, v7, v8, v9, AssociatedConformanceWitness);
  v12 = sub_100192784(v15);
  sub_100192784(v14);
  sub_100192784(v16);
  return v12 & 0xFFFFFFFFFFFFLL;
}

uint64_t sub_10009CE50()
{
  _BYTE __src[400];
  _BYTE __dst[400];

  sub_1000AB6E4(0x81uLL, __src);
  memcpy(__dst, __src, sizeof(__dst));
  return sub_1000B5D60((uint64_t)__dst);
}

uint64_t IO80211Driver<>.awdlChannelSequence.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  _BYTE __src[400];
  _BYTE __dst[408];

  type metadata accessor for apple80211_awdl_sync_channel_sequence(0);
  v7 = v6;
  v8 = *(_QWORD *)(a3 + 8);
  v9 = *(_QWORD *)(a2 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, a1, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, a1, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  sub_1000ABF34(129, v7, a1, v7, v8, v9, AssociatedConformanceWitness);
  memcpy(__dst, __src, 0x190uLL);
  return sub_1000B5D60((uint64_t)__dst);
}

uint64_t sub_10009D000()
{
  return sub_10009D020();
}

uint64_t sub_10009D020()
{
  _QWORD *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  _QWORD *v7;
  char v8;
  uint64_t v9;
  int v10;
  unint64_t v11;
  unint64_t v12;

  v1 = swift_slowAlloc(0x2000, -1);
  v2 = v0[5];
  v3 = v0[2];
  v4 = v0[3];
  swift_retain();
  swift_bridgeObjectRetain(v4);
  AppleDevice.getRequest(requestType:data:on:)(0x1D2uLL, v1, v1 + 0x2000, 0, v3, v4);
  swift_bridgeObjectRelease(v4);
  result = swift_release(v2);
  v6 = 0;
  v7 = _swiftEmptyArrayStorage;
  while (1)
  {
    v8 = *(_BYTE *)(v1 + v6);
    if (v8)
      break;
LABEL_2:
    if (++v6 == 0x2000)
    {
      swift_slowDealloc(v1, -1, -1);
      return (uint64_t)v7;
    }
  }
  if ((v6 & 0xE000) != 0)
    goto LABEL_16;
  v9 = 0;
  while (((1 << v9) & ~v8) != 0)
  {
LABEL_7:
    if (++v9 == 8)
      goto LABEL_2;
  }
  v10 = (unsigned __int16)(8 * v6) + (unsigned __int16)v9;
  if ((v10 & 0x10000) == 0)
  {
    result = swift_isUniquelyReferenced_nonNull_native(v7);
    if ((result & 1) == 0)
    {
      result = (uint64_t)sub_1000B2A64(0, v7[2] + 1, 1, v7);
      v7 = (_QWORD *)result;
    }
    v12 = v7[2];
    v11 = v7[3];
    if (v12 >= v11 >> 1)
    {
      result = (uint64_t)sub_1000B2A64((_QWORD *)(v11 > 1), v12 + 1, 1, v7);
      v7 = (_QWORD *)result;
    }
    v7[2] = v12 + 1;
    *((_WORD *)v7 + v12 + 16) = v10;
    goto LABEL_7;
  }
  __break(1u);
LABEL_16:
  __break(1u);
  return result;
}

uint64_t IO80211Driver<>.activePorts.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  uint64_t result;
  uint64_t v12;
  _QWORD *v13;
  char v14;
  uint64_t v15;
  int v16;
  unint64_t v17;
  unint64_t v18;

  v6 = swift_slowAlloc(0x2000, -1);
  v7 = *(_QWORD *)(a3 + 8);
  v8 = *(_QWORD *)(a2 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v7, a1, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, a1, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  result = sub_1000AB204(466, v6, v6 + 0x2000, a1, v7, v8, AssociatedConformanceWitness);
  v12 = 0;
  v13 = _swiftEmptyArrayStorage;
  while (1)
  {
    v14 = *(_BYTE *)(v6 + v12);
    if (v14)
      break;
LABEL_2:
    if (++v12 == 0x2000)
    {
      swift_slowDealloc(v6, -1, -1);
      return (uint64_t)v13;
    }
  }
  if ((v12 & 0xE000) != 0)
    goto LABEL_16;
  v15 = 0;
  while (((1 << v15) & ~v14) != 0)
  {
LABEL_7:
    if (++v15 == 8)
      goto LABEL_2;
  }
  v16 = (unsigned __int16)(8 * v12) + (unsigned __int16)v15;
  if ((v16 & 0x10000) == 0)
  {
    result = swift_isUniquelyReferenced_nonNull_native(v13);
    if ((result & 1) == 0)
    {
      result = (uint64_t)sub_1000B2A64(0, v13[2] + 1, 1, v13);
      v13 = (_QWORD *)result;
    }
    v18 = v13[2];
    v17 = v13[3];
    if (v18 >= v17 >> 1)
    {
      result = (uint64_t)sub_1000B2A64((_QWORD *)(v17 > 1), v18 + 1, 1, v13);
      v13 = (_QWORD *)result;
    }
    v13[2] = v18 + 1;
    *((_WORD *)v13 + v18 + 16) = v16;
    goto LABEL_7;
  }
  __break(1u);
LABEL_16:
  __break(1u);
  return result;
}

uint64_t IO80211Driver<>.trafficRegistration(for:to:desiredLatency:desiredChannel:desiredSecondaryChannel:options:ssidHash:active:)(uint64_t a1, uint64_t a2, int a3, __int16 a4, unsigned __int16 a5, uint64_t a6, uint64_t a7, char a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t KeyPath;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  _BYTE v38[176];
  uint64_t v39;
  _BYTE v40[16];
  _BYTE *v41;
  uint64_t v42;
  uint64_t v43;
  _OWORD v44[11];
  uint64_t v45;

  *(_WORD *)&v38[8] = 0;
  memset(&v38[12], 0, 156);
  *(_QWORD *)v38 = 1;
  *(_DWORD *)&v38[168] = a8 & 1;
  *(_DWORD *)&v38[172] = sub_10000F6D4(a6);
  LOWORD(v39) = a4;
  *(_DWORD *)((char *)&v39 + 2) = a5;
  v17 = static String._unconditionallyBridgeFromObjectiveC(_:)(a1);
  v19 = v18;
  KeyPath = swift_getKeyPath(&unk_10033F258);
  v41 = v38;
  v42 = KeyPath;
  v43 = 128;
  v21 = (uint64_t)sub_100047824((_QWORD *(*)(uint64_t *__return_ptr, _QWORD *))sub_10000642C, (uint64_t)v40, v17, v19);
  swift_bridgeObjectRelease(v19);
  swift_release(KeyPath);
  v22 = 127;
  if (v21 < 127)
    v22 = v21;
  if (v22 < 0)
    __break(1u);
  v23 = a10;
  *(_DWORD *)&v38[12] = v22;
  *(_DWORD *)&v38[144] = a3;
  *(_WORD *)&v38[4] = a2;
  v38[6] = BYTE2(a2);
  v38[7] = BYTE3(a2);
  v38[8] = BYTE4(a2);
  v38[9] = BYTE5(a2);
  if ((a7 & 0x1000000000000) == 0)
  {
    v24 = sub_100012C44(&qword_100403E88);
    v25 = swift_allocObject(v24, 38, 7);
    *(_OWORD *)(v25 + 16) = xmmword_10033B190;
    *(_WORD *)(v25 + 32) = a7;
    *(_BYTE *)(v25 + 34) = BYTE2(a7);
    *(_BYTE *)(v25 + 35) = BYTE3(a7);
    *(_BYTE *)(v25 + 36) = BYTE4(a7);
    *(_BYTE *)(v25 + 37) = BYTE5(a7);
    v26 = sub_1001068EC(v25);
    v28 = v27;
    v29 = v25;
    v23 = a10;
    swift_bridgeObjectRelease(v29);
    *(_QWORD *)&v44[0] = v26;
    *((_QWORD *)&v44[0] + 1) = v28;
    v30 = sub_100068D00();
    DataProtocol.copyBytes(to:)(&v38[152], &v38[168], &type metadata for Data, v30);
    sub_10000E614(v26, v28);
  }
  v44[8] = *(_OWORD *)&v38[128];
  v44[9] = *(_OWORD *)&v38[144];
  v44[10] = *(_OWORD *)&v38[160];
  v45 = v39;
  v44[4] = *(_OWORD *)&v38[64];
  v44[5] = *(_OWORD *)&v38[80];
  v44[6] = *(_OWORD *)&v38[96];
  v44[7] = *(_OWORD *)&v38[112];
  v44[0] = *(_OWORD *)v38;
  v44[1] = *(_OWORD *)&v38[16];
  v44[2] = *(_OWORD *)&v38[32];
  v44[3] = *(_OWORD *)&v38[48];
  type metadata accessor for apple80211_awdl_peer_traffic_registration(0);
  v32 = v31;
  v33 = *(_QWORD *)(a11 + 8);
  v34 = *(_QWORD *)(v23 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v33, a9, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a11, a9, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000AC020(164, (uint64_t)v44, a9, v32, v33, v34, AssociatedConformanceWitness);
}

uint64_t sub_10009D6CC(char a1, uint64_t a2)
{
  return sub_10005A64C(0x1A1uLL, qword_10033F6E8[a1], a2 & 0xFFFFFFFFFFFFLL);
}

uint64_t IO80211Driver<>.transmit(unicastMasterIndicationOptions:to:)(char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  _DWORD v16[2];
  __int16 v17;
  char v18;
  char v19;
  char v20;
  char v21;

  v8 = dword_10033F840[a1];
  v16[0] = 1;
  v16[1] = v8;
  v17 = a2;
  v18 = BYTE2(a2);
  v19 = BYTE3(a2);
  v20 = BYTE4(a2);
  v21 = BYTE5(a2);
  type metadata accessor for apple80211_awdl_UMI_data(0);
  v10 = v9;
  v11 = *(_QWORD *)(a5 + 8);
  v12 = *(_QWORD *)(a4 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v11, a3, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a3, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000AC020(417, (uint64_t)v16, a3, v10, v11, v12, AssociatedConformanceWitness);
}

unint64_t sub_10009D800()
{
  unint64_t result;

  result = sub_1000AB7E4(0xD9uLL);
  if ((result & 0x8000000000000000) != 0)
    __break(1u);
  else
    result >>= 32;
  return result;
}

uint64_t IO80211Driver<>.operatingMode.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  uint64_t result;
  unsigned int v13;

  type metadata accessor for apple80211_awdl_oper_mode(0);
  v7 = v6;
  v8 = *(_QWORD *)(a3 + 8);
  v9 = *(_QWORD *)(a2 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, a1, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, a1, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  sub_1000ABF34(217, v7, a1, v7, v8, v9, AssociatedConformanceWitness);
  result = v13;
  if ((v13 & 0x80000000) != 0)
    __break(1u);
  return result;
}

uint64_t sub_10009D92C(uint64_t a1)
{
  uint64_t result;
  char v2;

  if ((a1 & 0x80000000) == 0)
    return sub_10005A738(0xD9uLL, a1 << 32);
  v2 = 2;
  result = _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, v2, 3451, 0);
  __break(1u);
  return result;
}

uint64_t IO80211Driver<>.updateOperatingMode(_:)(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  uint64_t result;
  _DWORD v14[2];

  if (a1 < 0)
  {
    result = _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 3451, 0);
    __break(1u);
  }
  else
  {
    v14[0] = 0;
    v14[1] = a1;
    type metadata accessor for apple80211_awdl_oper_mode(0);
    v8 = v7;
    v9 = *(_QWORD *)(a4 + 8);
    v10 = *(_QWORD *)(a3 + 8);
    AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v9, a2, &protocol requirements base descriptor for DeviceDriver);
    AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a4, a2, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
    return sub_1000AC020(217, (uint64_t)v14, a2, v8, v9, v10, AssociatedConformanceWitness);
  }
  return result;
}

_QWORD *sub_10009DAAC(char a1)
{
  uint64_t *v1;
  _QWORD v3[4];
  uint64_t v4;

  v4 = *v1;
  v3[2] = a1 & 1;
  v3[3] = &v4;
  return sub_100047AAC((uint64_t (*)(_QWORD *))sub_1000B6C24, (uint64_t)v3, 0x5379616C70726961, 0xEB000000006B6E69, &v4);
}

_QWORD *IO80211Driver<>.setAirPlaySinkMode(_:)(char a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD v5[5];
  _QWORD *v6;

  v5[2] = a2;
  v5[3] = a3;
  v5[4] = a4;
  v6 = (_QWORD *)(a1 & 1);
  return sub_100047AAC((uint64_t (*)(_QWORD *))sub_1000B7380, (uint64_t)v5, 0x5379616C70726961, 0xEB000000006B6E69, v6);
}

uint64_t sub_10009DB68(char a1)
{
  uint64_t v1;

  if ((a1 & 1) != 0)
    v1 = 0x100000001;
  else
    v1 = 1;
  return sub_10005A7F4(0xA3uLL, v1);
}

uint64_t IO80211Driver<>.setAirPlaySoloMode(_:)(char a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  int v14;
  char v15;

  v14 = 1;
  v15 = a1;
  type metadata accessor for apple80211_awdl_social_time_slots(0);
  v8 = v7;
  v9 = *(_QWORD *)(a4 + 8);
  v10 = *(_QWORD *)(a3 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v9, a2, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a4, a2, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000AC020(163, (uint64_t)&v14, a2, v8, v9, v10, AssociatedConformanceWitness);
}

uint64_t sub_10009DC58(uint64_t a1)
{
  return sub_10009DC78(a1);
}

uint64_t sub_10009DC78(uint64_t a1)
{
  _QWORD *v1;
  unint64_t v2;
  uint64_t v3;
  _WORD *v4;
  _DWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  _OWORD v10[8];
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;

  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v2 = *(_QWORD *)(a1 + 16);
  v3 = 64;
  if (v2 < 0x40)
    v3 = *(_QWORD *)(a1 + 16);
  LODWORD(v21) = 0;
  HIDWORD(v21) = v3;
  if (v3)
  {
    v4 = (_WORD *)&v13 + 2;
    v5 = (_DWORD *)(a1 + 32);
    while (1)
    {
      if (!v2)
        __break(1u);
      if (*v5 >= 0x10000u)
        break;
      *v4++ = *v5;
      --v2;
      v5 += 2;
      if (!--v3)
        goto LABEL_8;
    }
    result = _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 3455, 0);
    __break(1u);
  }
  else
  {
LABEL_8:
    v10[6] = v19;
    v10[7] = v20;
    v11 = v21;
    v10[2] = v15;
    v10[3] = v16;
    v10[4] = v17;
    v10[5] = v18;
    v10[0] = v13;
    v10[1] = v14;
    v6 = v1[5];
    v7 = v1[2];
    v8 = v1[3];
    swift_retain();
    swift_bridgeObjectRetain(v8);
    AppleDevice.setRequest(requestType:data:on:)(0x1A3uLL, (uint64_t)v10, (uint64_t)&v12, 0, v7, v8);
    swift_bridgeObjectRelease(v8);
    return swift_release(v6);
  }
  return result;
}

uint64_t IO80211Driver<>.updateLTERestrictedChannels(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v7;
  uint64_t v8;
  _WORD *v9;
  _DWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  uint64_t result;
  _OWORD v18[8];
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;

  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v7 = *(_QWORD *)(a1 + 16);
  v8 = 64;
  if (v7 < 0x40)
    v8 = *(_QWORD *)(a1 + 16);
  LODWORD(v28) = 0;
  HIDWORD(v28) = v8;
  if (v8)
  {
    v9 = (_WORD *)&v20 + 2;
    v10 = (_DWORD *)(a1 + 32);
    while (v7)
    {
      if (*v10 >= 0x10000u)
        goto LABEL_10;
      *v9++ = *v10;
      --v7;
      v10 += 2;
      if (!--v8)
        goto LABEL_8;
    }
    __break(1u);
LABEL_10:
    result = _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 3455, 0);
    __break(1u);
  }
  else
  {
LABEL_8:
    v18[6] = v26;
    v18[7] = v27;
    v19 = v28;
    v18[2] = v22;
    v18[3] = v23;
    v18[4] = v24;
    v18[5] = v25;
    v18[0] = v20;
    v18[1] = v21;
    type metadata accessor for apple80211_lte_restricted_channels(0);
    v12 = v11;
    v13 = *(_QWORD *)(a4 + 8);
    v14 = *(_QWORD *)(a3 + 8);
    AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v13, a2, &protocol requirements base descriptor for DeviceDriver);
    AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a4, a2, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
    return sub_1000AC020(419, (uint64_t)v18, a2, v12, v13, v14, AssociatedConformanceWitness);
  }
  return result;
}

void sub_10009DF90(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_10009DFB0(a1, a2, a3);
}

void sub_10009DFB0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t KeyPath;
  char v5;
  char v6;

  KeyPath = swift_getKeyPath(&unk_10033F278);
  dispatch thunk of AnyKeyPath._storedInlineOffset.getter(KeyPath);
  v6 = v5;
  swift_release(KeyPath);
  if ((v6 & 1) == 0)
    __asm { BR              X9 }
  __break(1u);
  JUMPOUT(0x10009ED6CLL);
}

void IO80211Driver<>.registerService(active:keyData:valueData:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t KeyPath;
  char v5;
  char v6;

  KeyPath = swift_getKeyPath(&unk_10033F278);
  dispatch thunk of AnyKeyPath._storedInlineOffset.getter(KeyPath);
  v6 = v5;
  swift_release(KeyPath);
  if ((v6 & 1) == 0)
    __asm { BR              X9 }
  __break(1u);
  JUMPOUT(0x10009FCC4);
}

uint64_t sub_10009FE5C(uint64_t a1)
{
  return sub_10009FE7C(a1);
}

uint64_t sub_10009FE7C(uint64_t a1)
{
  _QWORD *v1;
  int *v3;
  uint64_t v4;
  char *v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  char *v9;
  unsigned int v10;
  char v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  char v24;
  char *v25;
  char v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  int v36;
  unint64_t v37;
  uint64_t v38;
  int v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  __int16 v44;
  uint64_t v45;
  __int16 v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v51;
  int v52;
  int v53;
  int v54;
  int v55;
  unsigned int v56;
  unsigned int v57;
  _WORD v58[7];
  char v59;
  char v60;
  char v61;
  char v62;
  char v63;
  int v64;
  int v65;
  int v66;
  char v67;
  char v68;
  char v69;
  char v70;
  char v71;
  char v72;
  int v73;
  __int16 v74;
  uint64_t v75;

  v3 = (int *)type metadata accessor for AWDLPeer(0);
  __chkstk_darwin();
  v5 = (char *)&v51 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_100012C44((uint64_t *)&unk_100410250);
  __chkstk_darwin();
  v7 = (char *)&v51 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_100033B48(a1 + v3[14], (uint64_t)v7, (uint64_t *)&unk_100410250);
  v8 = type metadata accessor for AWDLActionFrame.DataPathState(0);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(v8 - 8) + 48))(v7, 1, v8) == 1)
  {
    sub_100033A84((uint64_t)v7, (uint64_t *)&unk_100410250);
LABEL_4:
    v57 = 0;
    goto LABEL_6;
  }
  v9 = &v7[*(int *)(v8 + 140)];
  v10 = *(_DWORD *)v9;
  v11 = v9[4];
  sub_100063824((uint64_t)v7, type metadata accessor for AWDLActionFrame.DataPathState);
  if ((v11 & 1) != 0)
    goto LABEL_4;
  v57 = v10;
  if (v10 >= 0x10000)
    goto LABEL_43;
LABEL_6:
  v12 = a1 + v3[12];
  v14 = *(_QWORD *)v12;
  v13 = *(_QWORD *)(v12 + 8);
  v15 = *(_QWORD *)(v12 + 40);
  v16 = a1 + v3[21];
  if ((*(_BYTE *)(v16 + 4) & 1) != 0)
  {
    v56 = 0;
  }
  else
  {
    v56 = *(_DWORD *)v16;
    if (v56 >= 0x10000)
      goto LABEL_43;
  }
  v17 = HIWORD(v14);
  v18 = HIDWORD(v13);
  v19 = HIWORD(v13);
  if (!v15)
  {
    LODWORD(v17) = 0;
    LODWORD(v13) = 0;
  }
  v54 = v13;
  v55 = v17;
  if (v15)
    v20 = v19;
  else
    v20 = 0;
  if (v15)
    v21 = v18;
  else
    v21 = 0;
  v52 = v21;
  v53 = v20;
  v22 = a1 + v3[24];
  v23 = *(_QWORD *)v22;
  v24 = *(_BYTE *)(v22 + 8);
  sub_1000637E0(a1, (uint64_t)v5, type metadata accessor for AWDLPeer);
  if ((v24 & 1) != 0)
  {
    v25 = &v5[v3[23]];
    v23 = *(_QWORD *)v25;
    v26 = v25[8];
    sub_100063824((uint64_t)v5, type metadata accessor for AWDLPeer);
    if ((v26 & 1) != 0)
    {
      LOBYTE(v23) = 0;
      goto LABEL_23;
    }
  }
  else
  {
    sub_100063824((uint64_t)v5, type metadata accessor for AWDLPeer);
  }
  if (v23 < -128)
  {
    __break(1u);
LABEL_42:
    __break(1u);
  }
  if (v23 > 127)
    goto LABEL_42;
LABEL_23:
  v27 = *(_QWORD *)(v12 + 40);
  if (v27)
    LOBYTE(v27) = *(_BYTE *)(v12 + 28);
  v28 = a1 + v3[9];
  if (*(_BYTE *)(v28 + 48) == 1)
  {
    LOBYTE(v29) = 0;
    LOBYTE(v30) = 0;
    LOBYTE(v31) = 0;
    LOBYTE(v32) = 0;
    LOBYTE(v33) = 0;
    LOBYTE(v34) = 0;
    LOBYTE(v35) = 0;
    v36 = 0;
    LODWORD(v37) = 0;
    v38 = a1 + v3[22];
    v39 = *(unsigned __int8 *)(v38 + 4);
    v40 = *(_DWORD *)v38;
    if (v39)
      v40 = 0;
    goto LABEL_36;
  }
  v29 = *(_QWORD *)(v28 + 16);
  if (v29 >= 0x100)
  {
LABEL_43:
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 3455, 0);
    __break(1u);
    JUMPOUT(0x1000A0370);
  }
  v30 = *(_QWORD *)v28;
  v42 = *(_QWORD *)(v28 + 24);
  v41 = *(_QWORD *)(v28 + 32);
  v43 = a1 + v3[22];
  if (*(_BYTE *)(v43 + 4))
    v40 = 0;
  else
    v40 = *(_DWORD *)v43;
  if ((v41 & 1) != 0)
    __asm { BR              X17 }
  v36 = HIDWORD(v42);
  if ((v42 & 1) != 0)
    __asm { BR              X16 }
  v37 = HIDWORD(v29);
  v35 = v30 >> 40;
  v34 = HIDWORD(v30);
  v33 = v30 >> 24;
  v32 = v30 >> 16;
  v31 = v30 >> 8;
LABEL_36:
  v44 = WORD1(v14);
  v45 = a1 + v3[5];
  v46 = *(_WORD *)(v45 + 4);
  if (!v15)
    v44 = 0;
  v58[0] = v57;
  v58[1] = v44;
  v58[2] = v56;
  v58[3] = v54;
  v58[4] = v53;
  v58[5] = v52;
  v58[6] = v55;
  v59 = v23;
  v60 = 0;
  v61 = v27;
  v62 = 0;
  v63 = v29;
  v64 = v40;
  v65 = v36;
  v66 = v37;
  v67 = v30;
  v68 = v31;
  v69 = v32;
  v70 = v33;
  v71 = v34;
  v72 = v35;
  v73 = *(_DWORD *)v45;
  v74 = v46;
  v47 = v1[5];
  v48 = v1[2];
  v49 = v1[3];
  swift_retain();
  swift_bridgeObjectRetain(v49);
  AppleDevice.setRequest(requestType:data:on:)(0xE5uLL, (uint64_t)v58, (uint64_t)&v75, 0, v48, v49);
  swift_bridgeObjectRelease(v49);
  return swift_release(v47);
}

uint64_t IO80211Driver<>.elect(peer:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char *v13;
  unsigned int v14;
  char v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  char *v30;
  char v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  int v41;
  unint64_t v42;
  uint64_t v43;
  int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  __int16 v49;
  uint64_t v50;
  __int16 v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  int v60;
  int v61;
  int v62;
  int v63;
  unsigned int v64;
  unsigned int v65;
  uint64_t v66;
  uint64_t v67;
  _WORD v68[7];
  char v69;
  char v70;
  char v71;
  char v72;
  char v73;
  int v74;
  int v75;
  int v76;
  char v77;
  char v78;
  char v79;
  char v80;
  char v81;
  char v82;
  int v83;
  __int16 v84;

  v67 = a4;
  v7 = (int *)type metadata accessor for AWDLPeer(0);
  __chkstk_darwin();
  v9 = (char *)&v60 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_100012C44((uint64_t *)&unk_100410250);
  __chkstk_darwin();
  v11 = (char *)&v60 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_100033B48(a1 + v7[14], (uint64_t)v11, (uint64_t *)&unk_100410250);
  v12 = type metadata accessor for AWDLActionFrame.DataPathState(0);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(v12 - 8) + 48))(v11, 1, v12) == 1)
  {
    sub_100033A84((uint64_t)v11, (uint64_t *)&unk_100410250);
    v65 = 0;
  }
  else
  {
    v13 = &v11[*(int *)(v12 + 140)];
    v14 = *(_DWORD *)v13;
    v15 = v13[4];
    sub_100063824((uint64_t)v11, type metadata accessor for AWDLActionFrame.DataPathState);
    if ((v15 & 1) != 0)
    {
      v65 = 0;
    }
    else
    {
      v65 = v14;
      if (v14 >= 0x10000)
        goto LABEL_43;
    }
  }
  v16 = a1 + v7[12];
  v18 = *(_QWORD *)v16;
  v17 = *(_QWORD *)(v16 + 8);
  v19 = *(_QWORD *)(v16 + 40);
  v20 = a1 + v7[21];
  v21 = *(_BYTE *)(v20 + 4);
  v66 = a3;
  if ((v21 & 1) != 0)
  {
    v64 = 0;
  }
  else
  {
    v64 = *(_DWORD *)v20;
    if (v64 >= 0x10000)
      goto LABEL_43;
  }
  v22 = HIWORD(v18);
  v23 = HIDWORD(v17);
  v24 = HIWORD(v17);
  if (!v19)
  {
    LODWORD(v22) = 0;
    LODWORD(v17) = 0;
  }
  v62 = v17;
  v63 = v22;
  if (v19)
    v25 = v24;
  else
    v25 = 0;
  if (v19)
    v26 = v23;
  else
    v26 = 0;
  v60 = v26;
  v61 = v25;
  v27 = a1 + v7[24];
  v28 = *(_QWORD *)v27;
  v29 = *(_BYTE *)(v27 + 8);
  sub_1000637E0(a1, (uint64_t)v9, type metadata accessor for AWDLPeer);
  if ((v29 & 1) != 0)
  {
    v30 = &v9[v7[23]];
    v28 = *(_QWORD *)v30;
    v31 = v30[8];
    sub_100063824((uint64_t)v9, type metadata accessor for AWDLPeer);
    if ((v31 & 1) != 0)
    {
      LOBYTE(v28) = 0;
      goto LABEL_23;
    }
  }
  else
  {
    sub_100063824((uint64_t)v9, type metadata accessor for AWDLPeer);
  }
  if (v28 < -128)
  {
    __break(1u);
    goto LABEL_42;
  }
  if (v28 > 127)
  {
LABEL_42:
    __break(1u);
    goto LABEL_43;
  }
LABEL_23:
  v32 = *(_QWORD *)(v16 + 40);
  if (v32)
    LOBYTE(v32) = *(_BYTE *)(v16 + 28);
  v33 = a1 + v7[9];
  if (*(_BYTE *)(v33 + 48) == 1)
  {
    LOBYTE(v34) = 0;
    LOBYTE(v35) = 0;
    LOBYTE(v36) = 0;
    LOBYTE(v37) = 0;
    LOBYTE(v38) = 0;
    LOBYTE(v39) = 0;
    LOBYTE(v40) = 0;
    v41 = 0;
    LODWORD(v42) = 0;
    v43 = a1 + v7[22];
    v44 = *(unsigned __int8 *)(v43 + 4);
    v45 = *(_DWORD *)v43;
    if (v44)
      v45 = 0;
    goto LABEL_36;
  }
  v34 = *(_QWORD *)(v33 + 16);
  if (v34 >= 0x100)
  {
LABEL_43:
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 3455, 0);
    __break(1u);
    JUMPOUT(0x1000A08A8);
  }
  v35 = *(_QWORD *)v33;
  v47 = *(_QWORD *)(v33 + 24);
  v46 = *(_QWORD *)(v33 + 32);
  v48 = a1 + v7[22];
  if (*(_BYTE *)(v48 + 4))
    v45 = 0;
  else
    v45 = *(_DWORD *)v48;
  if ((v46 & 1) != 0)
    __asm { BR              X17 }
  v41 = HIDWORD(v47);
  if ((v47 & 1) != 0)
    __asm { BR              X16 }
  v42 = HIDWORD(v34);
  v40 = v35 >> 40;
  v39 = HIDWORD(v35);
  v38 = v35 >> 24;
  v37 = v35 >> 16;
  v36 = v35 >> 8;
LABEL_36:
  v49 = WORD1(v18);
  v50 = a1 + v7[5];
  v51 = *(_WORD *)(v50 + 4);
  if (!v19)
    v49 = 0;
  v68[0] = v65;
  v68[1] = v49;
  v68[2] = v64;
  v68[3] = v62;
  v68[4] = v61;
  v68[5] = v60;
  v68[6] = v63;
  v69 = v28;
  v70 = 0;
  v71 = v32;
  v72 = 0;
  v73 = v34;
  v74 = v45;
  v75 = v41;
  v76 = v42;
  v77 = v35;
  v78 = v36;
  v79 = v37;
  v80 = v38;
  v81 = v39;
  v82 = v40;
  v83 = *(_DWORD *)v50;
  v84 = v51;
  type metadata accessor for awdl_peer_advert_add(0);
  v53 = v52;
  v54 = v67;
  v55 = *(_QWORD *)(v67 + 8);
  v56 = *(_QWORD *)(v66 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v55, a2, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v54, a2, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000AC020(229, (uint64_t)v68, a2, v53, v55, v56, AssociatedConformanceWitness);
}

uint64_t sub_1000A08E0@<X0>(uint64_t a1@<X8>)
{
  _BYTE __dst[3728];
  _BYTE __src[3712];
  _BYTE v5[3720];

  sub_1000AB8A4(0xDFuLL, __src);
  memcpy(__dst, __src, 0xE80uLL);
  sub_1000B5E30((uint64_t)__dst);
  sub_100063EB8((uint64_t)__dst, (uint64_t)v5, &qword_100406710);
  return sub_100063EB8((uint64_t)v5, a1, &qword_100406710);
}

uint64_t IO80211Driver<>.statistics.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  _BYTE __dst[3728];
  _BYTE __src[3712];
  _BYTE v17[3720];

  type metadata accessor for apple80211_awdl_statistics(0);
  v9 = v8;
  v10 = *(_QWORD *)(a3 + 8);
  v11 = *(_QWORD *)(a2 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, a1, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, a1, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  sub_1000ABF34(223, v9, a1, v9, v10, v11, AssociatedConformanceWitness);
  memcpy(__dst, __src, 0xE80uLL);
  sub_1000B5E30((uint64_t)__dst);
  sub_100063EB8((uint64_t)__dst, (uint64_t)v17, &qword_100406710);
  return sub_100063EB8((uint64_t)v17, a4, &qword_100406710);
}

uint64_t sub_1000A0AD0@<X0>(uint64_t a1@<X8>)
{
  _BYTE __dst[4008];
  _BYTE __src[4000];
  _BYTE v5[4000];

  sub_1000AB974(0x157uLL, __src);
  memcpy(__dst, __src, 0xFA0uLL);
  NANBitmap.Channel.operatingClass.getter(__dst);
  sub_100063EB8((uint64_t)__dst, (uint64_t)v5, &qword_100406718);
  return sub_100063EB8((uint64_t)v5, a1, &qword_100406718);
}

uint64_t IO80211Driver<>.lowLatencyStatistics.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  _BYTE __dst[4008];
  _BYTE __src[4000];
  _BYTE v17[4000];

  type metadata accessor for apple80211_awdl_low_latency_statistics(0);
  v9 = v8;
  v10 = *(_QWORD *)(a3 + 8);
  v11 = *(_QWORD *)(a2 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, a1, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, a1, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  sub_1000ABF34(343, v9, a1, v9, v10, v11, AssociatedConformanceWitness);
  memcpy(__dst, __src, 0xFA0uLL);
  NANBitmap.Channel.operatingClass.getter(__dst);
  sub_100063EB8((uint64_t)__dst, (uint64_t)v17, &qword_100406718);
  return sub_100063EB8((uint64_t)v17, a4, &qword_100406718);
}

void sub_1000A0CC0(uint64_t a1@<X8>)
{
  sub_1000A0CE0(a1);
}

void sub_1000A0CE0(uint64_t a1@<X8>)
{
  _QWORD *v1;
  uint64_t v2;
  unsigned __int8 *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t inited;
  unsigned __int8 v17;
  char v18;
  unsigned __int8 v19;
  int *v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  char v24;
  unsigned __int8 v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _BYTE v30[40];
  uint64_t v31;

  v4 = (unsigned __int8 *)swift_slowAlloc(14, -1);
  *(_QWORD *)v4 = 0;
  *(_QWORD *)(v4 + 6) = 0;
  v5 = v1[5];
  v6 = v1[2];
  v7 = v1[3];
  swift_retain();
  swift_bridgeObjectRetain(v7);
  AppleDevice.getRequest(requestType:data:on:)(0x143uLL, (uint64_t)v4, (uint64_t)(v4 + 14), 0, v6, v7);
  swift_bridgeObjectRelease(v7);
  swift_release(v5);
  if (v2)
  {
    swift_slowDealloc(v4, -1, -1);
  }
  else
  {
    v8 = *v4;
    v9 = v4[1];
    v25 = v4[2];
    v10 = *((unsigned __int16 *)v4 + 2);
    v11 = v4[6];
    v12 = v4[7];
    v26 = v4[8];
    v27 = v4[9];
    v28 = v4[10];
    v29 = v4[11];
    v31 = v4[12];
    v13 = v4[3];
    swift_slowDealloc(v4, -1, -1);
    v14 = NANBitmap.Band.bands.getter(v13);
    v15 = sub_100012C44(&qword_1004048C0);
    inited = swift_initStackObject(v15, v30);
    *(_OWORD *)(inited + 16) = xmmword_10033C020;
    *(_BYTE *)(inited + 32) = sub_1001AA35C(v8, 0, 4);
    v17 = sub_1001AA35C(v9, 4, 4);
    *(_BYTE *)(inited + 33) = v17;
    v18 = *(_BYTE *)(inited + 32);
    swift_bridgeObjectRelease(inited);
    if ((v17 & ~v18) != 0)
      v19 = v17;
    else
      v19 = 0;
    v24 = v19 | v18;
    v20 = (int *)type metadata accessor for NANDriverCapabilities(0);
    v21 = (_QWORD *)(a1 + v20[8]);
    *v21 = v10;
    v22 = enum case for DispatchTimeInterval.milliseconds(_:);
    v23 = type metadata accessor for DispatchTimeInterval(0);
    (*(void (**)(_QWORD *, uint64_t, uint64_t))(*(_QWORD *)(v23 - 8) + 104))(v21, v22, v23);
    *(_QWORD *)a1 = v14;
    *(_QWORD *)(a1 + 8) = &off_1003D6D28;
    *(_BYTE *)(a1 + 16) = v25;
    *(_BYTE *)(a1 + 17) = v24;
    *(_QWORD *)(a1 + v20[9]) = v12;
    *(_QWORD *)(a1 + v20[10]) = v26;
    *(_QWORD *)(a1 + v20[11]) = v27;
    *(_QWORD *)(a1 + v20[12]) = v28;
    *(_QWORD *)(a1 + v20[13]) = v29;
    *(_QWORD *)(a1 + v20[14]) = v31;
    *(_BYTE *)(a1 + v20[15]) = v11 != 0;
  }
}

void IO80211Driver<>.initializeNAN()(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v4;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t inited;
  unsigned __int8 v23;
  char v24;
  unsigned __int8 v25;
  int *v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  char v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _BYTE v36[38];
  unsigned __int16 v37;
  unsigned __int8 v38;
  unsigned __int8 v39;
  unsigned __int8 v40;
  unsigned __int8 v41;
  unsigned __int8 v42;
  unsigned __int8 v43;
  unsigned __int8 v44;
  uint64_t v45;

  type metadata accessor for apple80211_nan_device_capability(0);
  v10 = v9;
  v11 = *(_QWORD *)(a2 + 8);
  v12 = *(_QWORD *)(a3 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v11, a1, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a2, a1, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  sub_1000ABF34(323, v10, a1, v10, v11, v12, AssociatedConformanceWitness);
  if (!v4)
  {
    v15 = v36[34];
    v16 = v36[35];
    v31 = v36[36];
    v17 = v37;
    v18 = v38;
    v19 = v39;
    v32 = v40;
    v33 = v41;
    v34 = v42;
    v35 = v43;
    v45 = v44;
    v20 = NANBitmap.Band.bands.getter(v36[37]);
    v21 = sub_100012C44(&qword_1004048C0);
    inited = swift_initStackObject(v21, v36);
    *(_QWORD *)(inited + 24) = 4;
    *(_BYTE *)(inited + 32) = sub_1001AA35C(v15, 0, 4);
    v23 = sub_1001AA35C(v16, 4, 4);
    *(_BYTE *)(inited + 33) = v23;
    v24 = *(_BYTE *)(inited + 32);
    if ((v23 & ~v24) != 0)
      v25 = v23;
    else
      v25 = 0;
    v30 = v25 | v24;
    swift_setDeallocating(inited);
    v26 = (int *)type metadata accessor for NANDriverCapabilities(0);
    v27 = (_QWORD *)(a4 + v26[8]);
    *v27 = v17;
    v28 = enum case for DispatchTimeInterval.milliseconds(_:);
    v29 = type metadata accessor for DispatchTimeInterval(0);
    (*(void (**)(_QWORD *, uint64_t, uint64_t))(*(_QWORD *)(v29 - 8) + 104))(v27, v28, v29);
    *(_QWORD *)a4 = v20;
    *(_QWORD *)(a4 + 8) = &off_1003D6D50;
    *(_BYTE *)(a4 + 16) = v31;
    *(_BYTE *)(a4 + 17) = v30;
    *(_QWORD *)(a4 + v26[9]) = v19;
    *(_QWORD *)(a4 + v26[10]) = v32;
    *(_QWORD *)(a4 + v26[11]) = v33;
    *(_QWORD *)(a4 + v26[12]) = v34;
    *(_QWORD *)(a4 + v26[13]) = v35;
    *(_QWORD *)(a4 + v26[14]) = v45;
    *(_BYTE *)(a4 + v26[15]) = v18 != 0;
  }
}

BOOL sub_1000A11DC()
{
  return sub_1000ABBE8(0x10CuLL) != 0;
}

BOOL IO80211Driver<>.nanState.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  char v13;

  type metadata accessor for apple80211_nan_enable(0);
  v7 = v6;
  v8 = *(_QWORD *)(a2 + 8);
  v9 = *(_QWORD *)(a3 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, a1, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a2, a1, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  sub_1000ABF34(268, v7, a1, v7, v8, v9, AssociatedConformanceWitness);
  return v13 != 0;
}

uint64_t sub_1000A1304(char a1)
{
  return sub_10005A8B8(0x10CuLL, a1 & 1);
}

uint64_t IO80211Driver<>.update(nanState:)(char a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  char v14;

  v14 = a1 & 1;
  type metadata accessor for apple80211_nan_enable(0);
  v8 = v7;
  v9 = *(_QWORD *)(a3 + 8);
  v10 = *(_QWORD *)(a4 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v9, a2, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, a2, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000AC020(268, (uint64_t)&v14, a2, v8, v9, v10, AssociatedConformanceWitness);
}

unint64_t sub_1000A13E8()
{
  _BYTE v1[6];
  unsigned int v2;
  unsigned __int8 v3;
  unsigned __int8 v4;

  sub_1000ABA44(0x10EuLL, (uint64_t)v1);
  return v2 | ((unint64_t)v3 << 32) | ((unint64_t)v4 << 40);
}

unint64_t IO80211Driver<>.clusterID.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  unsigned int v13;
  unsigned __int8 v14;
  unsigned __int8 v15;

  type metadata accessor for apple80211_nan_cluster_id(0);
  v7 = v6;
  v8 = *(_QWORD *)(a2 + 8);
  v9 = *(_QWORD *)(a3 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, a1, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a2, a1, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  sub_1000ABF34(270, v7, a1, v7, v8, v9, AssociatedConformanceWitness);
  return v13 | ((unint64_t)v14 << 32) | ((unint64_t)v15 << 40);
}

uint64_t sub_1000A1550(uint64_t a1)
{
  return sub_10005A900(0x10EuLL, a1 & 0xFFFFFFFFFF00 | ((unint64_t)a1 << 48) & 0xFFFFFFFFFFFF00 | ((unint64_t)BYTE1(a1) << 56) | a1, WORD1(a1));
}

uint64_t IO80211Driver<>.update(clusterID:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  __int16 v14;
  char v15;
  char v16;
  char v17;
  char v18;
  __int16 v19;
  char v20;
  char v21;
  char v22;
  char v23;

  v14 = a1;
  v15 = BYTE2(a1);
  v16 = BYTE3(a1);
  v17 = BYTE4(a1);
  v18 = BYTE5(a1);
  v19 = a1;
  v20 = BYTE2(a1);
  v21 = BYTE3(a1);
  v22 = BYTE4(a1);
  v23 = BYTE5(a1);
  type metadata accessor for apple80211_nan_cluster_id(0);
  v8 = v7;
  v9 = *(_QWORD *)(a3 + 8);
  v10 = *(_QWORD *)(a4 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v9, a2, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, a2, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000AC020(270, (uint64_t)&v14, a2, v8, v9, v10, AssociatedConformanceWitness);
}

uint64_t sub_1000A168C()
{
  unsigned __int8 v0;

  v0 = (unsigned __int16)sub_1000ABB14(0x119uLL) >> 8;
  return sub_1000ABB14(0x11AuLL) & 0xFF00 | v0;
}

uint64_t IO80211Driver<>.electionMetric.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  uint64_t v12;
  unsigned __int8 v14;
  unsigned __int8 v15;

  type metadata accessor for apple80211_nan_master_pref(0);
  v7 = v6;
  v8 = *(_QWORD *)(a2 + 8);
  v9 = *(_QWORD *)(a3 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, a1, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a2, a1, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  sub_1000ABF34(281, v7, a1, v7, v8, v9, AssociatedConformanceWitness);
  type metadata accessor for apple80211_nan_random_factor(0);
  sub_1000ABF34(282, v12, a1, v12, v8, v9, AssociatedConformanceWitness);
  return v15 | (v14 << 8);
}

uint64_t sub_1000A181C(__int16 a1)
{
  uint64_t v1;
  uint64_t result;

  result = sub_10005AA10(0x119uLL, a1 | (unsigned __int16)(a1 << 8));
  if (!v1)
    return sub_10005AA10(0x11AuLL, a1 & 0xFF00u | HIBYTE(a1));
  return result;
}

uint64_t IO80211Driver<>.update(electionMetric:)(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  uint64_t result;
  uint64_t v16;
  _BYTE v17[2];
  _BYTE v18[2];

  v8 = HIBYTE(a1);
  v18[0] = a1;
  v18[1] = a1;
  type metadata accessor for apple80211_nan_master_pref(0);
  v10 = v9;
  v11 = *(_QWORD *)(a3 + 8);
  v12 = *(_QWORD *)(a4 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v11, a2, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, a2, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  result = sub_1000AC020(281, (uint64_t)v18, a2, v10, v11, v12, AssociatedConformanceWitness);
  if (!v4)
  {
    v17[0] = v8;
    v17[1] = v8;
    type metadata accessor for apple80211_nan_random_factor(0);
    return sub_1000AC020(282, (uint64_t)v17, a2, v16, v11, v12, AssociatedConformanceWitness);
  }
  return result;
}

uint64_t sub_1000A196C()
{
  return sub_1000A198C();
}

uint64_t sub_1000A198C()
{
  __int16 v0;
  uint64_t v1;
  unsigned __int8 v2;
  unsigned __int8 v3;
  int v4;
  int v5;

  v0 = sub_1000ABB14(0x111uLL);
  v1 = HIBYTE(v0);
  v2 = _s7CoreP2P18NANAwakeDWIntervalO8intervalACSgAA11NANTimeUnitV_tcfC_0(v0);
  if (v2 == 5)
    v3 = 0;
  else
    v3 = v2;
  v4 = _s7CoreP2P18NANAwakeDWIntervalO8intervalACSgAA11NANTimeUnitV_tcfC_0(v1);
  if (v4 == 5)
    v5 = 0;
  else
    v5 = v4;
  return v3 | (v5 << 8);
}

uint64_t IO80211Driver<>.dwAwakePeriods.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  unsigned __int8 v12;
  unsigned __int8 v13;
  int v14;
  int v15;
  unsigned __int8 v17;
  unsigned __int8 v18;

  type metadata accessor for apple80211_nan_dw_awake_period(0);
  v7 = v6;
  v8 = *(_QWORD *)(a2 + 8);
  v9 = *(_QWORD *)(a3 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, a1, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a2, a1, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  sub_1000ABF34(273, v7, a1, v7, v8, v9, AssociatedConformanceWitness);
  v12 = _s7CoreP2P18NANAwakeDWIntervalO8intervalACSgAA11NANTimeUnitV_tcfC_0(v17);
  if (v12 == 5)
    v13 = 0;
  else
    v13 = v12;
  v14 = _s7CoreP2P18NANAwakeDWIntervalO8intervalACSgAA11NANTimeUnitV_tcfC_0(v18);
  if (v14 == 5)
    v15 = 0;
  else
    v15 = v14;
  return v13 | (v15 << 8);
}

void sub_1000A1B0C(char a1)
{
  sub_1000A1B2C(a1);
}

void sub_1000A1B2C(char a1)
{
  __asm { BR              X12 }
}

uint64_t sub_1000A1B78(unsigned int a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _BYTE v6[2];
  uint64_t v7;

  v6[0] = 1;
  v6[1] = 0x1008040100uLL >> ((a1 >> 5) & 0xF8);
  v2 = v1[5];
  v3 = v1[2];
  v4 = v1[3];
  swift_retain();
  swift_bridgeObjectRetain(v4);
  AppleDevice.setRequest(requestType:data:on:)(0x111uLL, (uint64_t)v6, (uint64_t)&v7, 0, v3, v4);
  swift_bridgeObjectRelease(v4);
  return swift_release(v2);
}

void IO80211Driver<>.update(dwAwakePeriods:)(char a1)
{
  __asm { BR              X12 }
}

uint64_t sub_1000A1C88(unsigned int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  _BYTE v11[66];

  v11[0] = 1;
  v11[1] = 0x1008040100uLL >> ((a1 >> 5) & 0xF8);
  type metadata accessor for apple80211_nan_dw_awake_period(0);
  v5 = v4;
  v6 = *(_QWORD *)(v2 + 8);
  v7 = *(_QWORD *)(v3 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v1, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v2, v1, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000AC020(273, (uint64_t)v11, v1, v5, v6, v7, AssociatedConformanceWitness);
}

unint64_t sub_1000A1D4C(uint64_t a1, uint64_t a2)
{
  return sub_1000A1DAC(a1, a2, 0x11FuLL);
}

unint64_t IO80211Driver<>.primaryChannel.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000A1E14(a1, a2, a3, (uint64_t (*)(_QWORD))type metadata accessor for apple80211_nan_primary_master_channel, 287);
}

uint64_t sub_1000A1D64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000A1F14(a1, a2, a3, 287, (uint64_t (*)(uint64_t, uint64_t))sub_10005A8B8);
}

uint64_t IO80211Driver<>.update(primaryChannel:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1000A1FCC(a1, a2, a3, a4, (uint64_t (*)(_QWORD))type metadata accessor for apple80211_nan_primary_master_channel, 287);
}

unint64_t sub_1000A1DA4(uint64_t a1, uint64_t a2)
{
  return sub_1000A1DAC(a1, a2, 0x120uLL);
}

unint64_t sub_1000A1DAC(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unsigned __int8 v3;

  v3 = sub_1000ABBE8(a3);
  return sub_100192784(v3) & 0xFFFFFFFFFFFFLL;
}

unint64_t IO80211Driver<>.secondaryChannel.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000A1E14(a1, a2, a3, (uint64_t (*)(_QWORD))type metadata accessor for apple80211_nan_secondary_master_channel, 288);
}

unint64_t sub_1000A1E14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(_QWORD), uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  unsigned __int8 v15;

  v9 = a4(0);
  v10 = *(_QWORD *)(a2 + 8);
  v11 = *(_QWORD *)(a3 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, a1, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a2, a1, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  sub_1000ABF34(a5, v9, a1, v9, v10, v11, AssociatedConformanceWitness);
  return sub_100192784(v15) & 0xFFFFFFFFFFFFLL;
}

uint64_t sub_1000A1EF4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000A1F14(a1, a2, a3, 288, (uint64_t (*)(uint64_t, uint64_t))sub_10005A8B8);
}

uint64_t sub_1000A1F14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t))
{
  uint64_t v5;
  uint64_t result;

  if ((a1 & 0xFF00000000) == 0x300000000)
  {
    v5 = 0;
    return a5(a4, v5);
  }
  v5 = a1;
  if (a1 < 0x100)
    return a5(a4, v5);
  result = _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 3455, 0);
  __break(1u);
  return result;
}

uint64_t IO80211Driver<>.update(secondaryChannel:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1000A1FCC(a1, a2, a3, a4, (uint64_t (*)(_QWORD))type metadata accessor for apple80211_nan_secondary_master_channel, 288);
}

uint64_t sub_1000A1FCC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(_QWORD), uint64_t a6)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  uint64_t result;
  char v16;

  if ((a1 & 0xFF00000000) == 0x300000000)
  {
    LOBYTE(a1) = 0;
LABEL_4:
    v16 = a1;
    v10 = a5(0);
    v11 = *(_QWORD *)(a3 + 8);
    v12 = *(_QWORD *)(a4 + 16);
    AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v11, a2, &protocol requirements base descriptor for DeviceDriver);
    AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, a2, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
    return sub_1000AC020(a6, (uint64_t)&v16, a2, v10, v11, v12, AssociatedConformanceWitness);
  }
  if (a1 < 0x100)
    goto LABEL_4;
  result = _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 3455, 0);
  __break(1u);
  return result;
}

BOOL sub_1000A20F8()
{
  return sub_1000ABBE8(0x113uLL) != 0;
}

BOOL IO80211Driver<>.hostElection.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  char v13;

  type metadata accessor for apple80211_nan_host_election(0);
  v7 = v6;
  v8 = *(_QWORD *)(a2 + 8);
  v9 = *(_QWORD *)(a3 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, a1, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a2, a1, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  sub_1000ABF34(275, v7, a1, v7, v8, v9, AssociatedConformanceWitness);
  return v13 != 0;
}

uint64_t sub_1000A2220(char a1)
{
  return sub_10005A8B8(0x113uLL, a1 & 1);
}

uint64_t IO80211Driver<>.update(hostElection:)(char a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  char v14;

  v14 = a1;
  type metadata accessor for apple80211_nan_host_election(0);
  v8 = v7;
  v9 = *(_QWORD *)(a3 + 8);
  v10 = *(_QWORD *)(a4 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v9, a2, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, a2, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000AC020(275, (uint64_t)&v14, a2, v8, v9, v10, AssociatedConformanceWitness);
}

double sub_1000A2300(uint64_t a1)
{
  return sub_1000B5F48(a1);
}

double IO80211Driver<>.transmitAllFrames(with:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  double result;
  unint64_t v10;
  _QWORD v11[5];

  v2 = v1;
  v4 = sub_10001F11C((uint64_t)_swiftEmptyArrayStorage);
  v5 = type metadata accessor for BinaryEncoder();
  v6 = (uint64_t *)swift_allocObject(v5, 40, 7);
  *((_OWORD *)v6 + 1) = xmmword_10033A100;
  v6[4] = v4;
  v11[3] = v5;
  v11[4] = sub_100011DE4((unint64_t *)&qword_100406278, (uint64_t (*)(uint64_t))type metadata accessor for BinaryEncoder, (uint64_t)protocol conformance descriptor for BinaryEncoder);
  v11[0] = v6;
  v7 = type metadata accessor for NANAttribute(0);
  v8 = sub_100011DE4(&qword_100406720, type metadata accessor for NANAttribute, (uint64_t)&protocol conformance descriptor for NANAttribute);
  swift_bridgeObjectRetain(a1);
  swift_retain();
  Array<A>.encode(to:)(v11, a1, v7, v8);
  sub_100014430(v11);
  if (!v2)
  {
    swift_bridgeObjectRelease(a1);
    swift_beginAccess(v6 + 2, v11, 0, 0);
    v10 = v6[3];
    sub_100031FEC(v6[2], v10);
    swift_release(v6);
    __asm { BR              X9 }
  }
  swift_release(v6);
  *(_QWORD *)&result = swift_bridgeObjectRelease(a1).n128_u64[0];
  return result;
}

uint64_t sub_1000A26AC(unsigned __int8 *a1)
{
  return sub_1000A26CC(a1);
}

uint64_t sub_1000A26CC(unsigned __int8 *a1)
{
  _QWORD *v1;
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned __int8 v5;
  char v6;
  unsigned __int8 v7;
  int v8;
  __int16 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE v14[6];
  int v15;
  __int16 v16;
  int v17;
  __int16 v18;
  __int16 v19;
  int v20;
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;

  v2 = *a1;
  v3 = *((_QWORD *)a1 + 3);
  v4 = *((_QWORD *)a1 + 4);
  v5 = a1[1];
  if (v2 >= 5)
    v6 = 3;
  else
    v6 = 0x201000303uLL >> (8 * v2);
  v7 = a1[16];
  v8 = *((_DWORD *)a1 + 5);
  v9 = *((_WORD *)a1 + 3);
  v14[0] = v6;
  v14[4] = v5;
  v14[5] = v7;
  v15 = 0;
  v16 = 0;
  v17 = *(_DWORD *)(a1 + 2);
  v18 = v9;
  v19 = 0;
  v20 = HIDWORD(v3);
  v21 = v3;
  v22 = HIDWORD(v4);
  v23 = v4;
  v24 = *((_QWORD *)a1 + 1);
  v25 = v8;
  v10 = v1[5];
  v11 = v1[2];
  v12 = v1[3];
  swift_retain();
  swift_bridgeObjectRetain(v12);
  AppleDevice.setRequest(requestType:data:on:)(0x14BuLL, (uint64_t)v14, (uint64_t)&v26, 0, v11, v12);
  swift_bridgeObjectRelease(v12);
  return swift_release(v10);
}

uint64_t IO80211Driver<>.update(electionParameters:)(unsigned __int8 *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 v10;
  unsigned __int8 v11;
  int v12;
  char v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  _BYTE v22[6];
  int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  __int16 v27;
  int v28;
  int v29;
  int v30;
  int v31;
  uint64_t v32;
  int v33;

  v7 = *a1;
  v8 = *((_QWORD *)a1 + 3);
  v9 = *((_QWORD *)a1 + 4);
  v10 = a1[1];
  v11 = a1[16];
  v12 = *((_DWORD *)a1 + 5);
  if (v7 >= 5)
    v13 = 3;
  else
    v13 = 0x201000303uLL >> (8 * v7);
  v14 = *((_WORD *)a1 + 3);
  v22[0] = v13;
  v22[4] = v10;
  v22[5] = v11;
  v23 = 0;
  v24 = 0;
  v25 = *(_DWORD *)(a1 + 2);
  v26 = v14;
  v27 = 0;
  v28 = HIDWORD(v8);
  v29 = v8;
  v30 = HIDWORD(v9);
  v31 = v9;
  v32 = *((_QWORD *)a1 + 1);
  v33 = v12;
  type metadata accessor for apple80211_nan_role_cfg(0);
  v16 = v15;
  v17 = *(_QWORD *)(a3 + 8);
  v18 = *(_QWORD *)(a4 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v17, a2, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, a2, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000AC020(331, (uint64_t)v22, a2, v16, v17, v18, AssociatedConformanceWitness);
}

uint64_t sub_1000A2924(uint64_t a1)
{
  return sub_1000A2944(a1);
}

uint64_t sub_1000A2944(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  _QWORD *v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  Swift::String v11;
  uint64_t v12;
  _QWORD *v13;
  __n128 v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t KeyPath;
  uint64_t v19;
  uint64_t v20;
  int *v21;
  uint64_t v22;
  unsigned __int8 *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned __int8 *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  char v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  int v51;
  int v52;
  uint64_t *v53;
  __int16 v54;
  uint64_t v55;
  unint64_t v56;
  unint64_t v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t result;
  _QWORD *v63;
  uint64_t v64;
  _QWORD *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  _BYTE *v70;
  uint64_t v71;
  uint64_t v72;
  _QWORD *v73;
  _BYTE v74[2050];
  __int16 v75;
  char v76;
  __int16 v77;
  char v78;
  _BYTE v79[261];
  __int16 v80;
  _BYTE v81[544];
  _BYTE v82[544];
  _BYTE v83[2066];
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  int v89;
  __int16 v90;
  char v91;
  _BYTE v92[69];
  _BYTE v93[39];
  _QWORD v94[5];
  uint64_t v95;
  _QWORD v96[33];
  _BYTE v97[544];
  _BYTE v98[544];
  _BYTE v99[2050];
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  int v106;
  __int16 v107;
  char v108;
  __int16 v109;
  char v110;
  int v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  char v116;
  __int16 v117;
  char v118;
  int v119;
  int v120;
  int v121;
  int v122;
  int v123;
  __int16 v124;
  int v125;

  v2 = type metadata accessor for DispatchTimeInterval(0);
  v66 = *(_QWORD *)(v2 - 8);
  v67 = v2;
  __chkstk_darwin();
  v65 = (_QWORD **)((char *)&v63 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0));
  v73 = (_QWORD *)type metadata accessor for SHA256Digest(0);
  v71 = *(v73 - 1);
  __chkstk_darwin();
  v5 = (char *)&v63 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  v6 = (_QWORD *)type metadata accessor for SHA256(0);
  v69 = *(v6 - 1);
  v70 = v6;
  __chkstk_darwin();
  v8 = (char *)&v63 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  v91 = 0;
  memset(v79, 0, sizeof(v79));
  bzero(&v80, 0xCA9uLL);
  memset(v92, 0, sizeof(v92));
  memset(&v93[3], 0, 22);
  HIBYTE(v90) = *(_BYTE *)a1;
  v9 = *(_QWORD *)(a1 + 16);
  v68 = *(_QWORD *)(a1 + 8);
  v64 = a1;
  v10 = swift_bridgeObjectRetain(v9);
  SHA256.init()(v10);
  v11 = String.lowercased()();
  swift_bridgeObjectRelease(v9);
  swift_bridgeObjectRetain(v11._object);
  v12 = v72;
  sub_10017550C(v11._countAndFlagsBits, (uint64_t)v11._object, (uint64_t)v8, v11._countAndFlagsBits, (uint64_t)v11._object, v13);
  v14 = swift_bridgeObjectRelease(v11._object);
  SHA256.finalize()(v14);
  SHA256Digest.withUnsafeBytes<A>(_:)(v96, sub_100175E14, 0, &type metadata for Data);
  (*(void (**)(char *, _QWORD *))(v71 + 8))(v5, v73);
  v15 = v96[0];
  v16 = v96[1];
  (*(void (**)(char *, _BYTE *))(v69 + 8))(v8, v70);
  v96[0] = v15;
  v96[1] = v16;
  v17 = sub_100068D00();
  DataProtocol.copyBytes(to:)(v79, &v79[6], &type metadata for Data, v17);
  sub_10000E614(v15, v16);
  KeyPath = swift_getKeyPath(&unk_10033F298);
  v70 = &v79[6];
  v94[2] = &v79[6];
  v94[3] = KeyPath;
  v94[4] = 255;
  v19 = (uint64_t)sub_100047824((_QWORD *(*)(uint64_t *__return_ptr, _QWORD *))sub_10000642C, (uint64_t)v94, v68, v9);
  swift_release(KeyPath);
  v20 = 254;
  if (v19 < 254)
    v20 = v19;
  if (v20 < 0)
  {
    __break(1u);
LABEL_33:
    __break(1u);
    goto LABEL_34;
  }
  v69 = v17;
  v73 = v83;
  v80 = v20;
  v21 = (int *)type metadata accessor for NANSubscribe.Configuration(0);
  v22 = v64;
  v23 = (unsigned __int8 *)(v64 + v21[12]);
  v24 = *((_QWORD *)v23 + 1);
  v72 = v12;
  v25 = *v23;
  v26 = swift_getKeyPath(&unk_10033F2B8);
  v27 = swift_getKeyPath(&unk_10033F2D8);
  sub_1000AE764(v79, v26, v27, v25, v24);
  swift_release(v26);
  swift_release(v27);
  v28 = (unsigned __int8 *)(v22 + v21[11]);
  v29 = *((_QWORD *)v28 + 1);
  v30 = *v28;
  v31 = swift_getKeyPath(&unk_10033F2F8);
  v32 = swift_getKeyPath(&unk_10033F318);
  sub_1000AE764(v79, v31, v32, v30, v29);
  swift_release(v31);
  swift_release(v32);
  LODWORD(v71) = NANSubscribe.Configuration.serviceInfo.getter();
  v34 = v33;
  v36 = v35;
  sub_100031FEC(v33, v35);
  v37 = sub_10001F11C((uint64_t)_swiftEmptyArrayStorage);
  v38 = type metadata accessor for BinaryEncoder();
  v39 = swift_allocObject(v38, 40, 7);
  *(_OWORD *)(v39 + 16) = xmmword_10033A100;
  *(_QWORD *)(v39 + 32) = v37;
  v96[3] = v38;
  v96[4] = sub_100011DE4((unint64_t *)&qword_100406278, (uint64_t (*)(uint64_t))type metadata accessor for BinaryEncoder, (uint64_t)protocol conformance descriptor for BinaryEncoder);
  v96[0] = v39;
  sub_100031FEC(v34, v36);
  swift_retain();
  v40 = v72;
  NANServiceInfo.encode(to:)((uint64_t)v96, v71, v34, v36);
  if (v40)
  {
    sub_100014430(v96);
    sub_10000E614(v34, v36);
    sub_10000E614(v34, v36);
    swift_release(v39);
    swift_errorRelease(v40);
    sub_10000E614(v34, v36);
    v72 = 0;
  }
  else
  {
    v72 = 0;
    sub_100014430(v96);
    sub_10000E614(v34, v36);
    sub_10000E614(v34, v36);
    swift_beginAccess(v39 + 16, &v95, 0, 0);
    v41 = *(_QWORD *)(v39 + 16);
    v42 = *(_QWORD *)(v39 + 24);
    sub_100031FEC(v41, v42);
    swift_release(v39);
    sub_10000E614(v34, v36);
    sub_1000B62E0(v41, v42);
    memcpy(v73, v74, 0x802uLL);
  }
  if (*(_BYTE *)(v22 + 32))
    v43 = 2;
  else
    v43 = 1;
  LOBYTE(v90) = v43;
  HIBYTE(v89) = *(_BYTE *)(v22 + v21[13]);
  v91 = 0x1008040100uLL >> (8 * *(_BYTE *)(v22 + v21[10]));
  v44 = sub_10017C64C();
  v46 = v65;
  v45 = v66;
  *v65 = 0x80000;
  v47 = v67;
  (*(void (**)(_QWORD *, _QWORD, uint64_t))(v45 + 104))(v46, enum case for DispatchTimeInterval.microseconds(_:), v67);
  v48 = sub_10017C64C();
  (*(void (**)(_QWORD *, uint64_t))(v45 + 8))(v46, v47);
  if (!v48)
    goto LABEL_33;
  if (v44 == 0x8000000000000000 && v48 == -1)
LABEL_34:
    __break(1u);
  if (((v44 / v48) & 0x8000000000000000) == 0)
  {
    if ((unint64_t)(v44 / v48) >> 32)
    {
LABEL_36:
      result = _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 3455, 0);
      goto LABEL_37;
    }
    v71 = v44 / v48;
    v49 = v21[14];
    if (*(_BYTE *)(v22 + 33))
      v50 = 194;
    else
      v50 = 192;
    if (*(_BYTE *)(v22 + 33))
      v51 = 2;
    else
      v51 = 0;
    if (*(_BYTE *)(v22 + v21[15]))
      v52 = v50;
    else
      v52 = v51;
    v53 = (uint64_t *)(v22 + v49);
    v54 = *(_WORD *)(v22 + v49 + 16);
    if ((v54 & 0xFF00) == 0x200)
      goto LABEL_31;
    v55 = *v53;
    v56 = v53[1];
    v96[0] = v55;
    v96[1] = v56;
    sub_100031FEC(v55, v56);
    v57 = DataProtocol.copyBytes(to:)(&v92[5], v93, &type metadata for Data, v69);
    if ((v57 & 0x8000000000000000) == 0)
    {
      if (!HIDWORD(v57))
      {
        *(_DWORD *)v92 = v57;
        sub_1000B5F34(v55, v56, v54);
        v92[4] = v54;
        if ((v54 & 0x100) != 0)
          v58 = 8;
        else
          v58 = 12;
        v52 |= v58;
LABEL_31:
        LODWORD(v69) = v52;
        memcpy((char *)v96 + 6, v70, 0x102uLL);
        memcpy(v97, v81, sizeof(v97));
        memcpy(v98, v82, sizeof(v98));
        memcpy(v99, v73, sizeof(v99));
        LODWORD(v96[0]) = *(_DWORD *)v79;
        WORD2(v96[0]) = *(_WORD *)&v79[4];
        v100 = *(_OWORD *)&v83[2050];
        v101 = v84;
        v102 = v85;
        v103 = v86;
        v104 = v87;
        v105 = v88;
        v106 = v89;
        v107 = v90;
        v108 = v91;
        v109 = v77;
        v110 = v78;
        v111 = *(_DWORD *)v92;
        v112 = *(_OWORD *)&v92[4];
        v113 = *(_OWORD *)&v92[20];
        v114 = *(_OWORD *)&v92[36];
        v115 = *(_OWORD *)&v92[52];
        v116 = v92[68];
        v117 = v75;
        v118 = v76;
        v119 = *(_DWORD *)&v93[3];
        v120 = v71;
        v121 = -1;
        v122 = v52;
        v123 = *(_DWORD *)&v93[19];
        v124 = *(_WORD *)&v93[23];
        v59 = v63[5];
        v60 = v63[2];
        v61 = v63[3];
        swift_retain();
        swift_bridgeObjectRetain(v61);
        AppleDevice.setRequest(requestType:data:on:)(0x12FuLL, (uint64_t)v96, (uint64_t)&v125, 0, v60, v61);
        swift_bridgeObjectRelease(v61);
        return swift_release(v59);
      }
      goto LABEL_36;
    }
  }
  result = _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 3451, 0);
LABEL_37:
  __break(1u);
  return result;
}

uint64_t IO80211Driver<>.start(configuration:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  _QWORD *v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  Swift::String v15;
  void *v16;
  _QWORD *v17;
  __n128 v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t KeyPath;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned __int8 *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned __int8 *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  char v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  int v55;
  uint64_t *v56;
  __int16 v57;
  uint64_t v58;
  unint64_t v59;
  unint64_t v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  uint64_t result;
  unint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  _QWORD *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  _BYTE *v81;
  uint64_t v82;
  uint64_t v83;
  _BYTE *v84;
  _BYTE v85[2050];
  __int16 v86;
  char v87;
  __int16 v88;
  char v89;
  _BYTE v90[261];
  __int16 v91;
  _BYTE v92[544];
  _BYTE v93[544];
  _BYTE v94[2066];
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  int v100;
  __int16 v101;
  char v102;
  _BYTE v103[69];
  _BYTE v104[39];
  _QWORD v105[5];
  uint64_t v106;
  _QWORD v107[33];
  _BYTE v108[544];
  _BYTE v109[544];
  _BYTE v110[2050];
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  int v117;
  __int16 v118;
  char v119;
  __int16 v120;
  char v121;
  int v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  char v127;
  __int16 v128;
  char v129;
  int v130;
  int v131;
  int v132;
  int v133;
  int v134;
  __int16 v135;

  v74 = a2;
  v72 = a4;
  v73 = a3;
  v5 = type metadata accessor for DispatchTimeInterval(0);
  v77 = *(_QWORD *)(v5 - 8);
  v78 = v5;
  __chkstk_darwin();
  v76 = (unint64_t *)((char *)&v71 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0));
  v7 = type metadata accessor for SHA256Digest(0);
  v82 = *(_QWORD *)(v7 - 8);
  v83 = v7;
  __chkstk_darwin();
  v9 = (char *)&v71 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  v10 = (_QWORD *)type metadata accessor for SHA256(0);
  v80 = *(v10 - 1);
  v81 = v10;
  __chkstk_darwin();
  v12 = (char *)&v71 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v102 = 0;
  memset(v90, 0, sizeof(v90));
  bzero(&v91, 0xCA9uLL);
  memset(v103, 0, sizeof(v103));
  memset(&v104[3], 0, 22);
  HIBYTE(v101) = *(_BYTE *)a1;
  v13 = *(_QWORD *)(a1 + 16);
  v79 = *(_QWORD *)(a1 + 8);
  v75 = a1;
  v14 = swift_bridgeObjectRetain(v13);
  SHA256.init()(v14);
  v15 = String.lowercased()();
  swift_bridgeObjectRelease(v13);
  swift_bridgeObjectRetain(v15._object);
  v16 = v84;
  sub_10017550C(v15._countAndFlagsBits, (uint64_t)v15._object, (uint64_t)v12, v15._countAndFlagsBits, (uint64_t)v15._object, v17);
  v18 = swift_bridgeObjectRelease(v15._object);
  SHA256.finalize()(v18);
  SHA256Digest.withUnsafeBytes<A>(_:)(v107, sub_100175E14, 0, &type metadata for Data);
  (*(void (**)(char *, uint64_t))(v82 + 8))(v9, v83);
  v19 = v107[0];
  v20 = v107[1];
  (*(void (**)(char *, _BYTE *))(v80 + 8))(v12, v81);
  v107[0] = v19;
  v107[1] = v20;
  v71 = sub_100068D00();
  DataProtocol.copyBytes(to:)(v90, &v90[6], &type metadata for Data, v71);
  sub_10000E614(v19, v20);
  KeyPath = swift_getKeyPath(&unk_10033F298);
  v81 = &v90[6];
  v105[2] = &v90[6];
  v105[3] = KeyPath;
  v105[4] = 255;
  v22 = (uint64_t)sub_100047824((_QWORD *(*)(uint64_t *__return_ptr, _QWORD *))sub_10000642C, (uint64_t)v105, v79, v13);
  swift_release(KeyPath);
  v23 = 254;
  if (v22 < 254)
    v23 = v22;
  if (v23 < 0)
  {
    __break(1u);
LABEL_33:
    __break(1u);
    goto LABEL_34;
  }
  v84 = v94;
  v91 = v23;
  v24 = type metadata accessor for NANSubscribe.Configuration(0);
  v25 = v75;
  v26 = (unsigned __int8 *)(v75 + *(int *)(v24 + 48));
  v27 = *((_QWORD *)v26 + 1);
  v28 = *v26;
  v29 = swift_getKeyPath(&unk_10033F2B8);
  v30 = swift_getKeyPath(&unk_10033F2D8);
  sub_1000AE764(v90, v29, v30, v28, v27);
  swift_release(v29);
  swift_release(v30);
  v83 = v24;
  v31 = (unsigned __int8 *)(v25 + *(int *)(v24 + 44));
  v32 = *((_QWORD *)v31 + 1);
  v33 = *v31;
  v34 = swift_getKeyPath(&unk_10033F2F8);
  v35 = swift_getKeyPath(&unk_10033F318);
  sub_1000AE764(v90, v34, v35, v33, v32);
  swift_release(v34);
  swift_release(v35);
  LODWORD(v82) = NANSubscribe.Configuration.serviceInfo.getter();
  v37 = v36;
  v39 = v38;
  sub_100031FEC(v36, v38);
  v40 = sub_10001F11C((uint64_t)_swiftEmptyArrayStorage);
  v41 = type metadata accessor for BinaryEncoder();
  v42 = swift_allocObject(v41, 40, 7);
  *(_OWORD *)(v42 + 16) = xmmword_10033A100;
  *(_QWORD *)(v42 + 32) = v40;
  v107[3] = v41;
  v107[4] = sub_100011DE4((unint64_t *)&qword_100406278, (uint64_t (*)(uint64_t))type metadata accessor for BinaryEncoder, (uint64_t)protocol conformance descriptor for BinaryEncoder);
  v107[0] = v42;
  sub_100031FEC(v37, v39);
  swift_retain();
  NANServiceInfo.encode(to:)((uint64_t)v107, v82, v37, v39);
  if (v16)
  {
    sub_100014430(v107);
    sub_10000E614(v37, v39);
    sub_10000E614(v37, v39);
    swift_release(v42);
    swift_errorRelease(v16);
    sub_10000E614(v37, v39);
    v82 = 0;
  }
  else
  {
    v82 = 0;
    sub_100014430(v107);
    sub_10000E614(v37, v39);
    sub_10000E614(v37, v39);
    swift_beginAccess(v42 + 16, &v106, 0, 0);
    v43 = *(_QWORD *)(v42 + 16);
    v44 = *(_QWORD *)(v42 + 24);
    sub_100031FEC(v43, v44);
    swift_release(v42);
    sub_10000E614(v37, v39);
    sub_1000B62E0(v43, v44);
    memcpy(v84, v85, 0x802uLL);
  }
  if (*(_BYTE *)(v25 + 32))
    v45 = 2;
  else
    v45 = 1;
  LOBYTE(v101) = v45;
  v46 = v83;
  HIBYTE(v100) = *(_BYTE *)(v25 + *(int *)(v83 + 52));
  v102 = 0x1008040100uLL >> (8 * *(_BYTE *)(v25 + *(int *)(v83 + 40)));
  v47 = sub_10017C64C();
  v49 = v76;
  v48 = v77;
  *v76 = 0x80000;
  v50 = v78;
  (*(void (**)(_QWORD *, _QWORD, uint64_t))(v48 + 104))(v49, enum case for DispatchTimeInterval.microseconds(_:), v78);
  v51 = sub_10017C64C();
  (*(void (**)(_QWORD *, uint64_t))(v48 + 8))(v49, v50);
  if (!v51)
    goto LABEL_33;
  if (v47 == 0x8000000000000000 && v51 == -1)
LABEL_34:
    __break(1u);
  if (((v47 / v51) & 0x8000000000000000) == 0)
  {
    if ((unint64_t)(v47 / v51) >> 32)
    {
LABEL_36:
      result = _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 3455, 0);
      goto LABEL_37;
    }
    v80 = v47 / v51;
    v52 = *(int *)(v46 + 56);
    if (*(_BYTE *)(v25 + 33))
      v53 = 194;
    else
      v53 = 192;
    if (*(_BYTE *)(v25 + 33))
      v54 = 2;
    else
      v54 = 0;
    if (*(_BYTE *)(v25 + *(int *)(v46 + 60)))
      v55 = v53;
    else
      v55 = v54;
    v56 = (uint64_t *)(v25 + v52);
    v57 = *(_WORD *)(v25 + v52 + 16);
    if ((v57 & 0xFF00) == 0x200)
      goto LABEL_31;
    v58 = *v56;
    v59 = v56[1];
    v107[0] = v58;
    v107[1] = v59;
    sub_100031FEC(v58, v59);
    v60 = DataProtocol.copyBytes(to:)(&v103[5], v104, &type metadata for Data, v71);
    if ((v60 & 0x8000000000000000) == 0)
    {
      if (!HIDWORD(v60))
      {
        *(_DWORD *)v103 = v60;
        sub_1000B5F34(v58, v59, v57);
        v103[4] = v57;
        if ((v57 & 0x100) != 0)
          v61 = 8;
        else
          v61 = 12;
        v55 |= v61;
LABEL_31:
        LODWORD(v83) = v55;
        memcpy((char *)v107 + 6, v81, 0x102uLL);
        memcpy(v108, v92, sizeof(v108));
        memcpy(v109, v93, sizeof(v109));
        memcpy(v110, v84, sizeof(v110));
        LODWORD(v107[0]) = *(_DWORD *)v90;
        WORD2(v107[0]) = *(_WORD *)&v90[4];
        v111 = *(_OWORD *)&v94[2050];
        v112 = v95;
        v113 = v96;
        v114 = v97;
        v115 = v98;
        v116 = v99;
        v117 = v100;
        v118 = v101;
        v119 = v102;
        v120 = v88;
        v121 = v89;
        v122 = *(_DWORD *)v103;
        v123 = *(_OWORD *)&v103[4];
        v124 = *(_OWORD *)&v103[20];
        v125 = *(_OWORD *)&v103[36];
        v126 = *(_OWORD *)&v103[52];
        v127 = v103[68];
        v128 = v86;
        v129 = v87;
        v130 = *(_DWORD *)&v104[3];
        v131 = v80;
        v132 = -1;
        v133 = v55;
        v134 = *(_DWORD *)&v104[19];
        v135 = *(_WORD *)&v104[23];
        type metadata accessor for apple80211_nan_subscribe_data(0);
        v63 = v62;
        v64 = v73;
        v65 = *(_QWORD *)(v73 + 8);
        v66 = *(_QWORD *)(v72 + 16);
        v67 = v74;
        AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v65, v74, &protocol requirements base descriptor for DeviceDriver);
        AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v64, v67, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
        return sub_1000AC020(303, (uint64_t)v107, v67, v63, v65, v66, AssociatedConformanceWitness);
      }
      goto LABEL_36;
    }
  }
  result = _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 3451, 0);
LABEL_37:
  __break(1u);
  return result;
}

{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  Swift::String v15;
  uint64_t v16;
  _QWORD *v17;
  __n128 v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t KeyPath;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  char v48;
  int *v49;
  uint64_t v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  int v56;
  uint64_t v57;
  __int16 v58;
  int v59;
  __int16 v60;
  __int16 v61;
  __int16 v62;
  int v63;
  uint64_t v64;
  char v65;
  char v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unint64_t v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  uint64_t result;
  uint64_t v94;
  void *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  _QWORD *v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  unint64_t v103;
  uint64_t v104;
  __int128 v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  _BYTE v109[2050];
  _BYTE v110[2050];
  _QWORD v111[698];
  _QWORD v112[6];
  uint64_t v113;
  uint64_t v114;
  _QWORD v115[697];

  v98 = a2;
  v96 = a4;
  v97 = a3;
  v5 = type metadata accessor for DispatchTimeInterval(0);
  v100 = *(_QWORD *)(v5 - 8);
  v101 = v5;
  __chkstk_darwin();
  v99 = (uint64_t *)((char *)&v94 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0));
  v106 = type metadata accessor for SHA256Digest(0);
  v7 = *(_QWORD *)(v106 - 8);
  __chkstk_darwin();
  v9 = (char *)&v94 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  v10 = type metadata accessor for SHA256(0);
  v103 = *(_QWORD *)(v10 - 8);
  v104 = v10;
  __chkstk_darwin();
  v12 = (char *)&v94 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  *(_QWORD *)&v105 = (char *)v111 + 6;
  LOBYTE(v111[426]) = 0;
  LOWORD(v111[434]) = 0;
  memset(v111, 0, 261);
  bzero((char *)&v111[32] + 6, 0xC49uLL);
  *(_OWORD *)((char *)&v111[431] + 7) = 0u;
  *(_OWORD *)((char *)&v111[428] + 4) = 0u;
  *(_OWORD *)((char *)&v111[430] + 4) = 0u;
  *(_OWORD *)((char *)&v111[426] + 4) = 0u;
  *(_QWORD *)((char *)&v111[434] + 4) = 0;
  BYTE4(v111[435]) = 0;
  *(_QWORD *)((char *)&v111[436] + 5) = 0;
  v111[436] = 0;
  v95 = (char *)&v111[437] + 6;
  bzero((char *)&v111[437] + 6, 0x818uLL);
  HIBYTE(v111[425]) = *(_BYTE *)a1;
  v13 = *(_QWORD *)(a1 + 16);
  v102 = *(_QWORD *)(a1 + 8);
  v108 = a1;
  v14 = swift_bridgeObjectRetain(v13);
  SHA256.init()(v14);
  v15 = String.lowercased()();
  swift_bridgeObjectRelease(v13);
  swift_bridgeObjectRetain(v15._object);
  v16 = v107;
  sub_10017550C(v15._countAndFlagsBits, (uint64_t)v15._object, (uint64_t)v12, v15._countAndFlagsBits, (uint64_t)v15._object, v17);
  v18 = swift_bridgeObjectRelease(v15._object);
  SHA256.finalize()(v18);
  SHA256Digest.withUnsafeBytes<A>(_:)(v115, sub_100175E14, 0, &type metadata for Data);
  (*(void (**)(char *, uint64_t))(v7 + 8))(v9, v106);
  v19 = v115[0];
  v20 = v115[1];
  (*(void (**)(char *, uint64_t))(v103 + 8))(v12, v104);
  v115[0] = v19;
  v115[1] = v20;
  v21 = sub_100068D00();
  v22 = v105;
  v103 = v21;
  DataProtocol.copyBytes(to:)(v111, v105, &type metadata for Data, v21);
  sub_10000E614(v19, v20);
  KeyPath = swift_getKeyPath(&unk_10033F298);
  v112[2] = v22;
  v112[3] = KeyPath;
  v112[4] = 255;
  v24 = (uint64_t)sub_100047824((_QWORD *(*)(uint64_t *__return_ptr, _QWORD *))sub_10000642C, (uint64_t)v112, v102, v13);
  swift_release(KeyPath);
  v25 = 254;
  if (v24 < 254)
    v25 = v24;
  if (v25 < 0)
  {
    __break(1u);
LABEL_51:
    __break(1u);
    goto LABEL_52;
  }
  HIWORD(v111[32]) = v25;
  v26 = v108;
  v27 = *(_QWORD *)(v108 + 48);
  v28 = *(unsigned __int8 *)(v108 + 40);
  v29 = swift_getKeyPath(&unk_10033F338);
  v107 = v16;
  v30 = v29;
  v31 = swift_getKeyPath(&unk_10033F358);
  sub_1000AE848(v111, v30, v31, v28, v27);
  swift_release(v30);
  swift_release(v31);
  v32 = *(_QWORD *)(v26 + 64);
  v33 = *(unsigned __int8 *)(v26 + 56);
  v34 = swift_getKeyPath(&unk_10033F378);
  v35 = swift_getKeyPath(&unk_10033F398);
  sub_1000AE848(v111, v34, v35, v33, v32);
  swift_release(v34);
  swift_release(v35);
  v36 = NANPublish.Configuration.serviceInfo.getter();
  v38 = v37;
  v40 = v39;
  sub_100031FEC(v37, v39);
  v41 = sub_10001F11C((uint64_t)_swiftEmptyArrayStorage);
  v42 = type metadata accessor for BinaryEncoder();
  v43 = swift_allocObject(v42, 40, 7);
  v105 = xmmword_10033A100;
  *(_OWORD *)(v43 + 16) = xmmword_10033A100;
  *(_QWORD *)(v43 + 32) = v41;
  v106 = v42;
  v115[3] = v42;
  v104 = sub_100011DE4((unint64_t *)&qword_100406278, (uint64_t (*)(uint64_t))type metadata accessor for BinaryEncoder, (uint64_t)protocol conformance descriptor for BinaryEncoder);
  v115[4] = v104;
  v115[0] = v43;
  sub_100031FEC(v38, v40);
  swift_retain();
  v44 = v107;
  NANServiceInfo.encode(to:)((uint64_t)v115, v36, v38, v40);
  if (v44)
  {
    sub_100014430(v115);
    sub_10000E614(v38, v40);
    sub_10000E614(v38, v40);
    swift_release(v43);
    swift_errorRelease(v44);
    sub_10000E614(v38, v40);
    v107 = 0;
  }
  else
  {
    v107 = 0;
    sub_100014430(v115);
    sub_10000E614(v38, v40);
    sub_10000E614(v38, v40);
    swift_beginAccess(v43 + 16, &v113, 0, 0);
    v45 = *(_QWORD *)(v43 + 16);
    v46 = *(_QWORD *)(v43 + 24);
    sub_100031FEC(v45, v46);
    swift_release(v43);
    sub_10000E614(v38, v40);
    sub_1000B62E0(v45, v46);
    memcpy(&v111[169], v109, 0x802uLL);
  }
  v47 = v108;
  BYTE4(v111[436]) = *(_BYTE *)(v108 + 32);
  BYTE5(v111[425]) = *(_BYTE *)(v108 + 72) + 1;
  if (*(_BYTE *)(v108 + 73))
    v48 = 1;
  else
    v48 = 2;
  BYTE6(v111[425]) = v48;
  BYTE4(v111[425]) = *(_BYTE *)(v108 + 75);
  v49 = (int *)type metadata accessor for NANPublish.Configuration(0);
  LOBYTE(v111[426]) = 0x1008040100uLL >> (8 * *(_BYTE *)(v47 + v49[19]));
  v50 = sub_10017C64C();
  v51 = v99;
  v52 = v100;
  *v99 = 0x80000;
  v53 = v101;
  (*(void (**)(_QWORD *, _QWORD, uint64_t))(v52 + 104))(v51, enum case for DispatchTimeInterval.microseconds(_:), v101);
  v54 = sub_10017C64C();
  (*(void (**)(_QWORD *, uint64_t))(v52 + 8))(v51, v53);
  if (!v54)
    goto LABEL_51;
  if (v50 == 0x8000000000000000 && v54 == -1)
LABEL_52:
    __break(1u);
  v55 = v50 / v54;
  if (v50 / v54 < 0)
  {
    result = _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 3451, 0);
LABEL_55:
    __break(1u);
    return result;
  }
  if (HIDWORD(v55))
  {
    result = _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 3455, 0);
    goto LABEL_55;
  }
  v111[427] = v55 | 0xFFFFFFFF00000000;
  LODWORD(v111[428]) = *(unsigned __int8 *)(v47 + 74);
  if ((*(_BYTE *)(v47 + 76) & 1) != 0)
  {
    HIDWORD(v111[428]) = 2;
    if (*(_BYTE *)(v47 + v49[20]) != 1)
      goto LABEL_21;
    v56 = 50;
  }
  else
  {
    HIDWORD(v111[428]) = 0;
    if ((*(_BYTE *)(v47 + v49[20]) & 1) == 0)
      goto LABEL_21;
    v56 = 48;
  }
  HIDWORD(v111[428]) = v56;
LABEL_21:
  v57 = v47 + v49[21];
  if (*(_QWORD *)(*(_QWORD *)(v57 + 16) + 16))
    v58 = 580;
  else
    v58 = 516;
  v59 = *(unsigned __int8 *)(v47 + 77);
  if ((v59 & 1) != 0)
    v60 = 3;
  else
    v60 = 1;
  if (v59 == 2)
    v61 = 0;
  else
    v61 = v60;
  LOWORD(v111[429]) = v61 | v58;
  v62 = *(_WORD *)(v47 + 88);
  LODWORD(v111[694]) = *(_DWORD *)(v47 + 84);
  WORD2(v111[694]) = v62;
  v63 = *(unsigned __int8 *)(v57 + 2);
  if (*(_BYTE *)(v57 + 2))
  {
    if (v63 != 1)
    {
      LODWORD(v111[436]) = 5;
      swift_bridgeObjectRelease(0xEA00000000007963);
      v66 = 1;
      goto LABEL_36;
    }
    v64 = 0x656D69746C616572;
    v63 = 5;
  }
  else
  {
    v64 = 0x6576697470616461;
  }
  LODWORD(v111[436]) = v63;
  v65 = _stringCompareWithSmolCheck(_:_:expecting:)(v64, 0xE800000000000000, 0x6E6574614C776F6CLL, 0xEA00000000007963, 0);
  swift_bridgeObjectRelease(0xE800000000000000);
  v66 = v65 & 1;
LABEL_36:
  BYTE4(v111[435]) = v66;
  v67 = *(_QWORD *)(v57 + 8);
  swift_bridgeObjectRetain(v67);
  NANGenericServiceProtocol.packetData(for:)(3, v67);
  v69 = v68;
  v71 = v70;
  swift_bridgeObjectRelease(v67);
  if (v71 >> 60 == 15)
    v72 = 0;
  else
    v72 = v69;
  if (v71 >> 60 == 15)
    v71 = 0xC000000000000000;
  sub_100031FEC(v72, v71);
  v73 = sub_10001F11C((uint64_t)_swiftEmptyArrayStorage);
  v74 = v106;
  v75 = swift_allocObject(v106, 40, 7);
  *(_OWORD *)(v75 + 16) = v105;
  *(_QWORD *)(v75 + 32) = v73;
  v115[3] = v74;
  v115[4] = v104;
  v115[0] = v75;
  sub_100031FEC(v72, v71);
  swift_retain();
  v76 = v107;
  NANServiceInfo.encode(to:)((uint64_t)v115, 2, v72, v71);
  sub_100014430(v115);
  sub_10000E614(v72, v71);
  sub_10000E614(v72, v71);
  if (v76)
  {
    swift_release(v75);
    swift_errorRelease(v76);
    sub_10000E614(v72, v71);
  }
  else
  {
    swift_beginAccess(v75 + 16, &v114, 0, 0);
    v77 = *(_QWORD *)(v75 + 16);
    v78 = *(_QWORD *)(v75 + 24);
    sub_100031FEC(v77, v78);
    swift_release(v75);
    sub_10000E614(v72, v71);
    sub_1000B62E0(v77, v78);
    memcpy(v95, v110, 0x802uLL);
  }
  v79 = *(_QWORD *)(v57 + 16);
  if (*(_QWORD *)(v79 + 16))
  {
    v108 = 0;
    v80 = *(_QWORD *)(v79 + 40);
    v81 = *(_QWORD *)(v79 + 48);
    v82 = *(_QWORD *)(v79 + 56);
    v83 = *(_QWORD *)(v79 + 64);
    v84 = *(_QWORD *)(v79 + 80);
    BYTE6(v111[429]) = *(_BYTE *)(v79 + 32) + 1;
    v115[0] = v80;
    v115[1] = v81;
    sub_100031FEC(v80, v81);
    sub_1000339F4(v82, v83);
    v107 = v84;
    swift_bridgeObjectRetain(v84);
    DataProtocol.copyBytes(to:)((char *)&v111[429] + 7, (char *)&v111[433] + 7, &type metadata for Data, v103);
    if (v83 >> 60 == 15)
    {
      sub_10000E614(v80, v81);
      sub_10000E658(v82, v83);
      swift_bridgeObjectRelease(v107);
    }
    else
    {
      v115[0] = v82;
      v115[1] = v83;
      sub_100031FEC(v82, v83);
      DataProtocol.copyBytes(to:)((char *)&v111[694] + 6, (char *)&v111[696] + 6, &type metadata for Data, v103);
      sub_10000E614(v80, v81);
      sub_10000E658(v82, v83);
      swift_bridgeObjectRelease(v107);
      sub_10000E658(v82, v83);
    }
  }
  else
  {
    BYTE6(v111[429]) = 0;
  }
  memcpy(v115, v111, sizeof(v115));
  type metadata accessor for apple80211_nan_publish_data(0);
  v86 = v85;
  v87 = v97;
  v88 = *(_QWORD *)(v97 + 8);
  v89 = *(_QWORD *)(v96 + 16);
  v90 = v98;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v88, v98, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v87, v90, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000AC020(300, (uint64_t)v115, v90, v86, v88, v89, AssociatedConformanceWitness);
}

{
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  int32x2_t v11;
  int32x2_t v12;
  uint64_t v13;
  uint64_t v14;
  Swift::String v15;
  uint64_t v16;
  _QWORD *v17;
  __n128 v18;
  uint64_t v19;
  unint64_t v20;
  int v21;
  uint64_t v22;
  char v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  uint64_t v53;
  _QWORD *v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  _BYTE v64[2050];
  _QWORD v65[269];
  _BYTE v66[24];
  _QWORD v67[269];

  v61 = a4;
  v63 = a2;
  v62 = a3;
  v5 = type metadata accessor for SHA256Digest(0);
  v58 = *(_QWORD *)(v5 - 8);
  v59 = v5;
  __chkstk_darwin();
  v7 = (char *)&v53 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  v55 = type metadata accessor for SHA256(0);
  v8 = *(_QWORD *)(v55 - 8);
  __chkstk_darwin();
  v10 = (char *)&v53 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  BYTE1(v65[0]) = 0;
  v56 = (char *)&v65[1] + 2;
  v57 = (uint64_t)v65 + 4;
  WORD2(v65[263]) = 0;
  HIDWORD(v65[0]) = 0;
  *(_DWORD *)((char *)v65 + 7) = 0;
  v54 = &v65[3];
  bzero(&v65[3], 0x823uLL);
  LOBYTE(v65[265]) = 0;
  v65[264] = 0;
  *(_QWORD *)((char *)&v65[266] + 4) = 0;
  *(_QWORD *)((char *)&v65[267] + 4) = 0;
  *(_QWORD *)((char *)&v65[265] + 4) = 0;
  HIDWORD(v65[268]) = 0;
  LOBYTE(v65[0]) = *(_BYTE *)a1;
  BYTE2(v65[0]) = *(_BYTE *)(a1 + 24);
  v11 = *(int32x2_t *)(a1 + 25);
  *(_WORD *)((char *)&v65[2] + 5) = *(_WORD *)(a1 + 29);
  v12 = *(int32x2_t *)(a1 + 3);
  *(_WORD *)((char *)&v65[1] + 3) = *(_WORD *)(a1 + 1);
  *(int32x2_t *)((char *)&v65[1] + 5) = vzip1_s32(v12, v11);
  BYTE3(v65[0]) = *(_BYTE *)(a1 + 7);
  v13 = *(_QWORD *)(a1 + 16);
  v14 = swift_bridgeObjectRetain(v13);
  SHA256.init()(v14);
  v15 = String.lowercased()();
  swift_bridgeObjectRelease(v13);
  swift_bridgeObjectRetain(v15._object);
  v16 = v60;
  sub_10017550C(v15._countAndFlagsBits, (uint64_t)v15._object, (uint64_t)v10, v15._countAndFlagsBits, (uint64_t)v15._object, v17);
  v18 = swift_bridgeObjectRelease(v15._object);
  SHA256.finalize()(v18);
  SHA256Digest.withUnsafeBytes<A>(_:)(v67, sub_100175E14, 0, &type metadata for Data);
  (*(void (**)(char *, unint64_t))(v58 + 8))(v7, v59);
  v19 = v67[0];
  v20 = v67[1];
  (*(void (**)(char *, uint64_t))(v8 + 8))(v10, v55);
  v67[0] = v19;
  v67[1] = v20;
  v59 = sub_100068D00();
  DataProtocol.copyBytes(to:)(v57, v56, &type metadata for Data, v59);
  sub_10000E614(v19, v20);
  v21 = *(unsigned __int8 *)(a1 + 32);
  v60 = v16;
  if (v21)
  {
    if (v21 != 1)
    {
      HIDWORD(v65[265]) = 5;
      swift_bridgeObjectRelease(0xEA00000000007963);
      goto LABEL_8;
    }
    v22 = 0x656D69746C616572;
    v21 = 5;
  }
  else
  {
    v22 = 0x6576697470616461;
  }
  HIDWORD(v65[265]) = v21;
  v23 = _stringCompareWithSmolCheck(_:_:expecting:)(v22, 0xE800000000000000, 0x6E6574614C776F6CLL, 0xEA00000000007963, 0);
  swift_bridgeObjectRelease(0xE800000000000000);
  v24 = 0;
  if ((v23 & 1) != 0)
LABEL_8:
    v24 = 1;
  LOBYTE(v65[265]) = v24;
  v25 = *(_QWORD *)(a1 + 40);
  swift_bridgeObjectRetain(v25);
  NANGenericServiceProtocol.packetData(for:)(3, v25);
  v27 = v26;
  v29 = v28;
  swift_bridgeObjectRelease(v25);
  if (v29 >> 60 == 15)
    v30 = 0;
  else
    v30 = v27;
  if (v29 >> 60 == 15)
    v31 = 0xC000000000000000;
  else
    v31 = v29;
  sub_100031FEC(v30, v31);
  v32 = sub_10001F11C((uint64_t)_swiftEmptyArrayStorage);
  v33 = type metadata accessor for BinaryEncoder();
  v34 = swift_allocObject(v33, 40, 7);
  *(_OWORD *)(v34 + 16) = xmmword_10033A100;
  *(_QWORD *)(v34 + 32) = v32;
  v67[3] = v33;
  v67[4] = sub_100011DE4((unint64_t *)&qword_100406278, (uint64_t (*)(uint64_t))type metadata accessor for BinaryEncoder, (uint64_t)protocol conformance descriptor for BinaryEncoder);
  v67[0] = v34;
  sub_100031FEC(v30, v31);
  swift_retain();
  v35 = v60;
  NANServiceInfo.encode(to:)((uint64_t)v67, 2, v30, v31);
  sub_100014430(v67);
  sub_10000E614(v30, v31);
  sub_10000E614(v30, v31);
  if (v35)
  {
    swift_release(v34);
    swift_errorRelease(v35);
    sub_10000E614(v30, v31);
  }
  else
  {
    swift_beginAccess(v34 + 16, v66, 0, 0);
    v36 = *(_QWORD *)(v34 + 16);
    v37 = *(_QWORD *)(v34 + 24);
    sub_100031FEC(v36, v37);
    swift_release(v34);
    sub_10000E614(v30, v31);
    sub_1000B62E0(v36, v37);
    memcpy(v54, v64, 0x802uLL);
  }
  v38 = *(_QWORD *)(a1 + 96);
  if (v38 == 1)
  {
    BYTE2(v65[259]) = 0;
  }
  else
  {
    v60 = 0;
    v39 = *(_QWORD *)(a1 + 48);
    v40 = *(_QWORD *)(a1 + 56);
    v42 = *(_QWORD *)(a1 + 64);
    v41 = *(_QWORD *)(a1 + 72);
    v43 = *(_QWORD *)(a1 + 80);
    v58 = *(_QWORD *)(a1 + 88);
    v56 = (char *)&v65[259] + 3;
    v57 = v39;
    BYTE2(v65[259]) = v39 + 1;
    v67[0] = v40;
    v67[1] = v42;
    sub_100031FEC(v40, v42);
    sub_1000339F4(v41, v43);
    swift_bridgeObjectRetain(v38);
    DataProtocol.copyBytes(to:)(v56, (char *)&v65[263] + 3, &type metadata for Data, v59);
    if (v43 >> 60 == 15)
    {
      sub_1000B6530(v57, v40, v42, v41, v43, v58, v38);
    }
    else
    {
      v56 = (char *)&v65[267];
      v67[0] = v41;
      v67[1] = v43;
      sub_100031FEC(v41, v43);
      DataProtocol.copyBytes(to:)(v56, v66, &type metadata for Data, v59);
      sub_1000B6530(v57, v40, v42, v41, v43, v58, v38);
      sub_10000E658(v41, v43);
    }
  }
  memcpy(v67, v65, sizeof(v67));
  type metadata accessor for apple80211_nan_dp_request(0);
  v45 = v44;
  v46 = v62;
  v47 = *(_QWORD *)(v62 + 8);
  v48 = *(_QWORD *)(v61 + 16);
  v49 = v63;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v47, v63, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v46, v49, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000AC020(315, (uint64_t)v67, v49, v45, v47, v48, AssociatedConformanceWitness);
}

uint64_t sub_1000A3C10(uint64_t a1)
{
  return sub_1000A3C30(a1);
}

uint64_t sub_1000A3C30(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  Swift::String v12;
  uint64_t v13;
  _QWORD *v14;
  __n128 v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t KeyPath;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  char v45;
  int *v46;
  uint64_t v47;
  _QWORD *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  int v53;
  uint64_t v54;
  __int16 v55;
  int v56;
  __int16 v57;
  __int16 v58;
  __int16 v59;
  int v60;
  uint64_t v61;
  char v62;
  char v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t v68;
  uint64_t v69;
  unint64_t v70;
  unint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t result;
  void *v87;
  _QWORD *v88;
  _QWORD *v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  unint64_t v93;
  uint64_t v94;
  __int128 v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  _BYTE v99[2050];
  _BYTE v100[2050];
  _QWORD v101[698];
  _QWORD v102[6];
  uint64_t v103;
  uint64_t v104;
  _QWORD v105[697];
  uint64_t v106[3];

  v2 = type metadata accessor for DispatchTimeInterval(0);
  v90 = *(_QWORD *)(v2 - 8);
  v91 = v2;
  __chkstk_darwin();
  v89 = (void **)((char *)&v87 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0));
  v97 = type metadata accessor for SHA256Digest(0);
  v4 = *(_QWORD *)(v97 - 8);
  __chkstk_darwin();
  v6 = (char *)&v87 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = type metadata accessor for SHA256(0);
  v93 = *(_QWORD *)(v7 - 8);
  v94 = v7;
  __chkstk_darwin();
  v9 = (char *)&v87 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  *(_QWORD *)&v95 = (char *)v101 + 6;
  LOBYTE(v101[426]) = 0;
  LOWORD(v101[434]) = 0;
  memset(v101, 0, 261);
  bzero((char *)&v101[32] + 6, 0xC49uLL);
  *(_OWORD *)((char *)&v101[431] + 7) = 0u;
  *(_OWORD *)((char *)&v101[428] + 4) = 0u;
  *(_OWORD *)((char *)&v101[430] + 4) = 0u;
  *(_OWORD *)((char *)&v101[426] + 4) = 0u;
  *(_QWORD *)((char *)&v101[434] + 4) = 0;
  BYTE4(v101[435]) = 0;
  *(_QWORD *)((char *)&v101[436] + 5) = 0;
  v101[436] = 0;
  v87 = (char *)&v101[437] + 6;
  bzero((char *)&v101[437] + 6, 0x818uLL);
  HIBYTE(v101[425]) = *(_BYTE *)a1;
  v10 = *(_QWORD *)(a1 + 16);
  v92 = *(_QWORD *)(a1 + 8);
  v98 = a1;
  v11 = swift_bridgeObjectRetain(v10);
  SHA256.init()(v11);
  v12 = String.lowercased()();
  swift_bridgeObjectRelease(v10);
  swift_bridgeObjectRetain(v12._object);
  v13 = v96;
  sub_10017550C(v12._countAndFlagsBits, (uint64_t)v12._object, (uint64_t)v9, v12._countAndFlagsBits, (uint64_t)v12._object, v14);
  v15 = swift_bridgeObjectRelease(v12._object);
  SHA256.finalize()(v15);
  SHA256Digest.withUnsafeBytes<A>(_:)(v105, sub_100175E14, 0, &type metadata for Data);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v97);
  v16 = v105[0];
  v17 = v105[1];
  (*(void (**)(char *, uint64_t))(v93 + 8))(v9, v94);
  v105[0] = v16;
  v105[1] = v17;
  v18 = sub_100068D00();
  v19 = v95;
  v93 = v18;
  DataProtocol.copyBytes(to:)(v101, v95, &type metadata for Data, v18);
  sub_10000E614(v16, v17);
  KeyPath = swift_getKeyPath(&unk_10033F298);
  v102[2] = v19;
  v102[3] = KeyPath;
  v102[4] = 255;
  v21 = (uint64_t)sub_100047824((_QWORD *(*)(uint64_t *__return_ptr, _QWORD *))sub_10000642C, (uint64_t)v102, v92, v10);
  swift_release(KeyPath);
  v22 = 254;
  if (v21 < 254)
    v22 = v21;
  if (v22 < 0)
  {
    __break(1u);
LABEL_52:
    __break(1u);
    goto LABEL_53;
  }
  HIWORD(v101[32]) = v22;
  v23 = v98;
  v24 = *(_QWORD *)(v98 + 48);
  v25 = *(unsigned __int8 *)(v98 + 40);
  v26 = swift_getKeyPath(&unk_10033F338);
  v97 = v13;
  v27 = v26;
  v28 = swift_getKeyPath(&unk_10033F358);
  sub_1000AE848(v101, v27, v28, v25, v24);
  swift_release(v27);
  swift_release(v28);
  v29 = *(_QWORD *)(v23 + 64);
  v30 = *(unsigned __int8 *)(v23 + 56);
  v31 = swift_getKeyPath(&unk_10033F378);
  v32 = swift_getKeyPath(&unk_10033F398);
  sub_1000AE848(v101, v31, v32, v30, v29);
  swift_release(v31);
  swift_release(v32);
  v33 = NANPublish.Configuration.serviceInfo.getter();
  v35 = v34;
  v37 = v36;
  sub_100031FEC(v34, v36);
  v38 = sub_10001F11C((uint64_t)_swiftEmptyArrayStorage);
  v39 = type metadata accessor for BinaryEncoder();
  v40 = swift_allocObject(v39, 40, 7);
  v95 = xmmword_10033A100;
  *(_OWORD *)(v40 + 16) = xmmword_10033A100;
  *(_QWORD *)(v40 + 32) = v38;
  v96 = v39;
  v105[3] = v39;
  v94 = sub_100011DE4((unint64_t *)&qword_100406278, (uint64_t (*)(uint64_t))type metadata accessor for BinaryEncoder, (uint64_t)protocol conformance descriptor for BinaryEncoder);
  v105[4] = v94;
  v105[0] = v40;
  sub_100031FEC(v35, v37);
  swift_retain();
  v41 = v97;
  NANServiceInfo.encode(to:)((uint64_t)v105, v33, v35, v37);
  if (v41)
  {
    sub_100014430(v105);
    sub_10000E614(v35, v37);
    sub_10000E614(v35, v37);
    swift_release(v40);
    swift_errorRelease(v41);
    sub_10000E614(v35, v37);
    v97 = 0;
  }
  else
  {
    v97 = 0;
    sub_100014430(v105);
    sub_10000E614(v35, v37);
    sub_10000E614(v35, v37);
    swift_beginAccess(v40 + 16, &v103, 0, 0);
    v42 = *(_QWORD *)(v40 + 16);
    v43 = *(_QWORD *)(v40 + 24);
    sub_100031FEC(v42, v43);
    swift_release(v40);
    sub_10000E614(v35, v37);
    sub_1000B62E0(v42, v43);
    memcpy(&v101[169], v99, 0x802uLL);
  }
  v44 = v98;
  BYTE4(v101[436]) = *(_BYTE *)(v98 + 32);
  BYTE5(v101[425]) = *(_BYTE *)(v98 + 72) + 1;
  if (*(_BYTE *)(v98 + 73))
    v45 = 1;
  else
    v45 = 2;
  BYTE6(v101[425]) = v45;
  BYTE4(v101[425]) = *(_BYTE *)(v98 + 75);
  v46 = (int *)type metadata accessor for NANPublish.Configuration(0);
  LOBYTE(v101[426]) = 0x1008040100uLL >> (8 * *(_BYTE *)(v44 + v46[19]));
  v47 = sub_10017C64C();
  v48 = v89;
  v49 = v90;
  *v89 = 0x80000;
  v50 = v91;
  (*(void (**)(_QWORD *, _QWORD, uint64_t))(v49 + 104))(v48, enum case for DispatchTimeInterval.microseconds(_:), v91);
  v51 = sub_10017C64C();
  (*(void (**)(_QWORD *, uint64_t))(v49 + 8))(v48, v50);
  if (!v51)
    goto LABEL_52;
  if (v47 == 0x8000000000000000 && v51 == -1)
LABEL_53:
    __break(1u);
  v52 = v47 / v51;
  if (v47 / v51 < 0)
  {
    result = _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 3451, 0);
LABEL_56:
    __break(1u);
    return result;
  }
  if (HIDWORD(v52))
  {
    result = _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 3455, 0);
    goto LABEL_56;
  }
  v101[427] = v52 | 0xFFFFFFFF00000000;
  LODWORD(v101[428]) = *(unsigned __int8 *)(v44 + 74);
  if (*(_BYTE *)(v44 + 76) == 1)
  {
    HIDWORD(v101[428]) = 2;
    if ((*(_BYTE *)(v44 + v46[20]) & 1) == 0)
      goto LABEL_21;
    v53 = 50;
  }
  else
  {
    HIDWORD(v101[428]) = 0;
    if (*(_BYTE *)(v44 + v46[20]) != 1)
      goto LABEL_21;
    v53 = 48;
  }
  HIDWORD(v101[428]) = v53;
LABEL_21:
  v54 = v44 + v46[21];
  if (*(_QWORD *)(*(_QWORD *)(v54 + 16) + 16))
    v55 = 580;
  else
    v55 = 516;
  v56 = *(unsigned __int8 *)(v44 + 77);
  if ((v56 & 1) != 0)
    v57 = 3;
  else
    v57 = 1;
  if (v56 == 2)
    v58 = 0;
  else
    v58 = v57;
  LOWORD(v101[429]) = v58 | v55;
  v59 = *(_WORD *)(v44 + 88);
  LODWORD(v101[694]) = *(_DWORD *)(v44 + 84);
  WORD2(v101[694]) = v59;
  v60 = *(unsigned __int8 *)(v54 + 2);
  if (*(_BYTE *)(v54 + 2))
  {
    if (v60 != 1)
    {
      LODWORD(v101[436]) = 5;
      swift_bridgeObjectRelease(0xEA00000000007963);
      v63 = 1;
      goto LABEL_36;
    }
    v61 = 0x656D69746C616572;
    v60 = 5;
  }
  else
  {
    v61 = 0x6576697470616461;
  }
  LODWORD(v101[436]) = v60;
  v62 = _stringCompareWithSmolCheck(_:_:expecting:)(v61, 0xE800000000000000, 0x6E6574614C776F6CLL, 0xEA00000000007963, 0);
  swift_bridgeObjectRelease(0xE800000000000000);
  v63 = v62 & 1;
LABEL_36:
  BYTE4(v101[435]) = v63;
  v64 = *(_QWORD *)(v54 + 8);
  swift_bridgeObjectRetain(v64);
  NANGenericServiceProtocol.packetData(for:)(3, v64);
  v66 = v65;
  v68 = v67;
  swift_bridgeObjectRelease(v64);
  if (v68 >> 60 == 15)
    v69 = 0;
  else
    v69 = v66;
  if (v68 >> 60 == 15)
    v70 = 0xC000000000000000;
  else
    v70 = v68;
  sub_100031FEC(v69, v70);
  v71 = sub_10001F11C((uint64_t)_swiftEmptyArrayStorage);
  v72 = v96;
  v73 = swift_allocObject(v96, 40, 7);
  *(_OWORD *)(v73 + 16) = v95;
  *(_QWORD *)(v73 + 32) = v71;
  v105[3] = v72;
  v105[4] = v94;
  v105[0] = v73;
  sub_100031FEC(v69, v70);
  swift_retain();
  v74 = v97;
  NANServiceInfo.encode(to:)((uint64_t)v105, 2, v69, v70);
  sub_100014430(v105);
  sub_10000E614(v69, v70);
  sub_10000E614(v69, v70);
  if (v74)
  {
    swift_release(v73);
    swift_errorRelease(v74);
    sub_10000E614(v69, v70);
  }
  else
  {
    swift_beginAccess(v73 + 16, &v104, 0, 0);
    v75 = *(_QWORD *)(v73 + 16);
    v76 = *(_QWORD *)(v73 + 24);
    sub_100031FEC(v75, v76);
    swift_release(v73);
    sub_10000E614(v69, v70);
    sub_1000B62E0(v75, v76);
    memcpy(v87, v100, 0x802uLL);
  }
  v77 = *(_QWORD *)(v54 + 16);
  if (*(_QWORD *)(v77 + 16))
  {
    v98 = 0;
    v78 = *(_QWORD *)(v77 + 40);
    v79 = *(_QWORD *)(v77 + 48);
    v80 = *(_QWORD *)(v77 + 56);
    v81 = *(_QWORD *)(v77 + 64);
    v82 = *(_QWORD *)(v77 + 80);
    BYTE6(v101[429]) = *(_BYTE *)(v77 + 32) + 1;
    v105[0] = v78;
    v105[1] = v79;
    sub_100031FEC(v78, v79);
    sub_1000339F4(v80, v81);
    v97 = v82;
    swift_bridgeObjectRetain(v82);
    DataProtocol.copyBytes(to:)((char *)&v101[429] + 7, (char *)&v101[433] + 7, &type metadata for Data, v93);
    if (v81 >> 60 == 15)
    {
      sub_10000E614(v78, v79);
      sub_10000E658(v80, v81);
      swift_bridgeObjectRelease(v97);
    }
    else
    {
      v105[0] = v80;
      v105[1] = v81;
      sub_100031FEC(v80, v81);
      DataProtocol.copyBytes(to:)((char *)&v101[694] + 6, (char *)&v101[696] + 6, &type metadata for Data, v93);
      sub_10000E614(v78, v79);
      sub_10000E658(v80, v81);
      swift_bridgeObjectRelease(v97);
      sub_10000E658(v80, v81);
    }
  }
  else
  {
    BYTE6(v101[429]) = 0;
  }
  memcpy(v105, v101, sizeof(v105));
  v83 = v88[5];
  v84 = v88[2];
  v85 = v88[3];
  swift_retain();
  swift_bridgeObjectRetain(v85);
  AppleDevice.setRequest(requestType:data:on:)(0x12CuLL, (uint64_t)v105, (uint64_t)v106, 0, v84, v85);
  swift_bridgeObjectRelease(v85);
  return swift_release(v83);
}

uint64_t sub_1000A5394(uint64_t a1)
{
  return sub_1000A53B4(a1);
}

uint64_t sub_1000A53B4(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  int32x2_t v8;
  int32x2_t v9;
  uint64_t v10;
  uint64_t v11;
  Swift::String v12;
  uint64_t v13;
  _QWORD *v14;
  __n128 v15;
  uint64_t v16;
  unint64_t v17;
  int v18;
  uint64_t v19;
  char v20;
  char v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v45;
  _QWORD *v46;
  char *v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  _QWORD *v52;
  _BYTE v53[2050];
  _QWORD v54[269];
  _BYTE v55[24];
  _QWORD v56[269];
  uint64_t v57;

  v50 = type metadata accessor for SHA256Digest(0);
  v2 = *(_QWORD *)(v50 - 8);
  __chkstk_darwin();
  v4 = (char *)&v45 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v47 = (char *)type metadata accessor for SHA256(0);
  v5 = *((_QWORD *)v47 - 1);
  __chkstk_darwin();
  v7 = (char *)&v45 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  BYTE1(v54[0]) = 0;
  v48 = (uint64_t)&v54[1] + 2;
  v49 = (uint64_t)v54 + 4;
  WORD2(v54[263]) = 0;
  HIDWORD(v54[0]) = 0;
  *(_DWORD *)((char *)v54 + 7) = 0;
  v46 = &v54[3];
  bzero(&v54[3], 0x823uLL);
  LOBYTE(v54[265]) = 0;
  v54[264] = 0;
  *(_QWORD *)((char *)&v54[266] + 4) = 0;
  *(_QWORD *)((char *)&v54[267] + 4) = 0;
  *(_QWORD *)((char *)&v54[265] + 4) = 0;
  HIDWORD(v54[268]) = 0;
  LOBYTE(v54[0]) = *(_BYTE *)a1;
  BYTE2(v54[0]) = *(_BYTE *)(a1 + 24);
  v8 = *(int32x2_t *)(a1 + 25);
  *(_WORD *)((char *)&v54[2] + 5) = *(_WORD *)(a1 + 29);
  v9 = *(int32x2_t *)(a1 + 3);
  *(_WORD *)((char *)&v54[1] + 3) = *(_WORD *)(a1 + 1);
  *(int32x2_t *)((char *)&v54[1] + 5) = vzip1_s32(v9, v8);
  BYTE3(v54[0]) = *(_BYTE *)(a1 + 7);
  v10 = *(_QWORD *)(a1 + 16);
  v11 = swift_bridgeObjectRetain(v10);
  SHA256.init()(v11);
  v12 = String.lowercased()();
  swift_bridgeObjectRelease(v10);
  swift_bridgeObjectRetain(v12._object);
  v13 = v51;
  sub_10017550C(v12._countAndFlagsBits, (uint64_t)v12._object, (uint64_t)v7, v12._countAndFlagsBits, (uint64_t)v12._object, v14);
  v15 = swift_bridgeObjectRelease(v12._object);
  SHA256.finalize()(v15);
  SHA256Digest.withUnsafeBytes<A>(_:)(v56, sub_100175E14, 0, &type metadata for Data);
  v51 = v13;
  (*(void (**)(char *, unint64_t))(v2 + 8))(v4, v50);
  v16 = v56[0];
  v17 = v56[1];
  (*(void (**)(char *, char *))(v5 + 8))(v7, v47);
  v56[0] = v16;
  v56[1] = v17;
  v50 = sub_100068D00();
  DataProtocol.copyBytes(to:)(v49, v48, &type metadata for Data, v50);
  sub_10000E614(v16, v17);
  v18 = *(unsigned __int8 *)(a1 + 32);
  if (!*(_BYTE *)(a1 + 32))
  {
    v19 = 0x6576697470616461;
    goto LABEL_5;
  }
  if (v18 == 1)
  {
    v19 = 0x656D69746C616572;
    v18 = 5;
LABEL_5:
    HIDWORD(v54[265]) = v18;
    v20 = _stringCompareWithSmolCheck(_:_:expecting:)(v19, 0xE800000000000000, 0x6E6574614C776F6CLL, 0xEA00000000007963, 0);
    swift_bridgeObjectRelease(0xE800000000000000);
    v21 = v20 & 1;
    goto LABEL_7;
  }
  HIDWORD(v54[265]) = 5;
  swift_bridgeObjectRelease(0xEA00000000007963);
  v21 = 1;
LABEL_7:
  LOBYTE(v54[265]) = v21;
  v22 = *(_QWORD *)(a1 + 40);
  swift_bridgeObjectRetain(v22);
  NANGenericServiceProtocol.packetData(for:)(3, v22);
  v24 = v23;
  v26 = v25;
  swift_bridgeObjectRelease(v22);
  if (v26 >> 60 == 15)
    v27 = 0;
  else
    v27 = v24;
  if (v26 >> 60 == 15)
    v28 = 0xC000000000000000;
  else
    v28 = v26;
  sub_100031FEC(v27, v28);
  v29 = sub_10001F11C((uint64_t)_swiftEmptyArrayStorage);
  v30 = type metadata accessor for BinaryEncoder();
  v31 = swift_allocObject(v30, 40, 7);
  *(_OWORD *)(v31 + 16) = xmmword_10033A100;
  *(_QWORD *)(v31 + 32) = v29;
  v56[3] = v30;
  v56[4] = sub_100011DE4((unint64_t *)&qword_100406278, (uint64_t (*)(uint64_t))type metadata accessor for BinaryEncoder, (uint64_t)protocol conformance descriptor for BinaryEncoder);
  v56[0] = v31;
  sub_100031FEC(v27, v28);
  swift_retain();
  v32 = v51;
  NANServiceInfo.encode(to:)((uint64_t)v56, 2, v27, v28);
  sub_100014430(v56);
  sub_10000E614(v27, v28);
  sub_10000E614(v27, v28);
  if (v32)
  {
    swift_release(v31);
    swift_errorRelease(v32);
    sub_10000E614(v27, v28);
  }
  else
  {
    swift_beginAccess(v31 + 16, v55, 0, 0);
    v33 = *(_QWORD *)(v31 + 16);
    v34 = *(_QWORD *)(v31 + 24);
    sub_100031FEC(v33, v34);
    swift_release(v31);
    sub_10000E614(v27, v28);
    sub_1000B62E0(v33, v34);
    memcpy(v46, v53, 0x802uLL);
  }
  v35 = *(_QWORD *)(a1 + 96);
  if (v35 == 1)
  {
    BYTE2(v54[259]) = 0;
  }
  else
  {
    v51 = 0;
    v36 = *(_QWORD *)(a1 + 48);
    v37 = *(_QWORD *)(a1 + 56);
    v39 = *(_QWORD *)(a1 + 64);
    v38 = *(_QWORD *)(a1 + 72);
    v40 = *(_QWORD *)(a1 + 80);
    v49 = *(_QWORD *)(a1 + 88);
    v47 = (char *)&v54[259] + 3;
    v48 = v36;
    BYTE2(v54[259]) = v36 + 1;
    v56[0] = v37;
    v56[1] = v39;
    sub_100031FEC(v37, v39);
    sub_1000339F4(v38, v40);
    swift_bridgeObjectRetain(v35);
    DataProtocol.copyBytes(to:)(v47, (char *)&v54[263] + 3, &type metadata for Data, v50);
    if (v40 >> 60 == 15)
    {
      sub_1000B6530(v48, v37, v39, v38, v40, v49, v35);
    }
    else
    {
      v47 = (char *)&v54[267];
      v56[0] = v38;
      v56[1] = v40;
      sub_100031FEC(v38, v40);
      DataProtocol.copyBytes(to:)(v47, v55, &type metadata for Data, v50);
      sub_1000B6530(v48, v37, v39, v38, v40, v49, v35);
      sub_10000E658(v38, v40);
    }
  }
  memcpy(v56, v54, sizeof(v56));
  v41 = v52[5];
  v42 = v52[2];
  v43 = v52[3];
  swift_retain();
  swift_bridgeObjectRetain(v43);
  AppleDevice.setRequest(requestType:data:on:)(0x13BuLL, (uint64_t)v56, (uint64_t)&v57, 0, v42, v43);
  swift_bridgeObjectRelease(v43);
  return swift_release(v41);
}

uint64_t BroadcomDriver<>.update(configuration:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 184))(a1, a2, a4);
}

{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 192))(a1, a2, a4);
}

{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 200))(a1, a2, a4);
}

uint64_t sub_1000A60D0(unsigned __int8 a1, uint64_t a2)
{
  return sub_10005ABD0(0x13EuLL, a1, a2 & 0xFFFFFFFFFFFFLL, 0);
}

uint64_t IO80211Driver<>.terminate(datapathID:initiatorAddress:)(char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  _BYTE v15[4];
  int v16;
  __int16 v17;
  char v18;
  char v19;
  char v20;
  char v21;
  int v22;
  __int16 v23;

  v15[0] = a1;
  v15[1] = 0;
  v16 = 0;
  v17 = a2;
  v18 = BYTE2(a2);
  v19 = BYTE3(a2);
  v20 = BYTE4(a2);
  v21 = BYTE5(a2);
  type metadata accessor for apple80211_nan_dp_terminate(0);
  v9 = v8;
  v22 = 0;
  v23 = 0;
  v10 = *(_QWORD *)(a4 + 8);
  v11 = *(_QWORD *)(a5 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, a3, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a4, a3, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000AC020(318, (uint64_t)v15, a3, v9, v10, v11, AssociatedConformanceWitness);
}

uint64_t sub_1000A61F8(char a1)
{
  return sub_10005A8B8(0x132uLL, a1);
}

uint64_t IO80211Driver<>.terminate(subscribeID:)(char a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1000A6288(a1, a2, a3, a4, (uint64_t (*)(_QWORD))type metadata accessor for apple80211_nan_cancel_subscribe_data, 306);
}

uint64_t sub_1000A6240(char a1)
{
  return sub_10005A8B8(0x12DuLL, a1);
}

uint64_t IO80211Driver<>.terminate(publishID:)(char a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1000A6288(a1, a2, a3, a4, (uint64_t (*)(_QWORD))type metadata accessor for apple80211_nan_cancel_publish_data, 301);
}

uint64_t sub_1000A6288(char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(_QWORD), uint64_t a6)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  char v16;

  v16 = a1;
  v10 = a5(0);
  v11 = *(_QWORD *)(a3 + 8);
  v12 = *(_QWORD *)(a4 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v11, a2, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, a2, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000AC020(a6, (uint64_t)&v16, a2, v10, v11, v12, AssociatedConformanceWitness);
}

uint64_t sub_1000A6344(uint64_t a1, unint64_t a2, char a3, unint64_t a4, char a5)
{
  char v6;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v15;
  _BYTE v16[2];
  __int16 v17;
  char v18;
  char v19;
  char v20;
  char v21;
  char v22;
  char v23;

  v6 = a4;
  v10 = a4 >> 8;
  v11 = a4 >> 16;
  v15 = a4 >> 24;
  v12 = HIDWORD(a4);
  v13 = a4 >> 40;
  sub_100031FEC(a1, a2);
  sub_1000B62E0(a1, a2);
  v16[0] = a3;
  v16[1] = a5;
  v17 = 0;
  v18 = v6;
  v19 = v10;
  v20 = v11;
  v21 = v15;
  v22 = v12;
  v23 = v13;
  return sub_10005ACF4(0x133uLL, v16);
}

uint64_t IO80211Driver<>.transmit(followUp:for:to:with:)(uint64_t a1, unint64_t a2, char a3, unint64_t a4, char a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v10;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  unint64_t v24;
  unint64_t v25;
  _BYTE v28[2];
  __int16 v29;
  char v30;
  char v31;
  char v32;
  char v33;
  char v34;
  char v35;

  v10 = a4;
  v14 = a4 >> 8;
  v15 = a4 >> 16;
  v16 = a4 >> 24;
  v24 = HIDWORD(a4);
  v25 = a4 >> 40;
  sub_100031FEC(a1, a2);
  sub_1000B62E0(a1, a2);
  v28[0] = a3;
  v28[1] = a5;
  v29 = 0;
  v30 = v10;
  v31 = v14;
  v32 = v15;
  v33 = v16;
  v34 = v24;
  v35 = v25;
  type metadata accessor for apple80211_nan_follow_up_transmit_data(0);
  v18 = v17;
  v19 = *(_QWORD *)(a7 + 8);
  v20 = *(_QWORD *)(a8 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v19, a6, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a7, a6, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000AC020(307, (uint64_t)v28, a6, v18, v19, v20, AssociatedConformanceWitness);
}

uint64_t sub_1000A6548(char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unint64_t a10, unint64_t a11)
{
  return sub_1000A658C(a1, a2, a3, a4, a5 & 0xFFFFFFFFFFFFLL, a6 & 0xFFFFFFFFFFFFLL, a7 & 0xFFFFFFFFFFFFLL, a8, a9, a10, a11);
}

uint64_t sub_1000A658C(char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unint64_t a10, unint64_t a11)
{
  unint64_t v11;
  unint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t result;
  unint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  char v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  __int16 v44[483];
  _QWORD v45[125];
  char v46;
  __int16 v47;
  char v48;
  char v49;
  char v50;
  char v51;
  char v52;

  v11 = a9;
  bzero(v44, 0x3C4uLL);
  v12 = a10 - a9;
  if (a10 < a9)
    goto LABEL_13;
  v13 = _swiftEmptyArrayStorage;
  if (v12 >= 0x80)
  {
    v21 = v12 >> 7;
    v45[0] = _swiftEmptyArrayStorage;
    sub_100074F24(0, v12 >> 7, 0);
    v22 = a11;
    v13 = (_QWORD *)v45[0];
    v23 = a9 >> 7;
    v24 = *(_QWORD *)(v45[0] + 16);
    v25 = HIBYTE(a11);
    v26 = HIWORD(a11);
    v27 = a11 >> 40;
    v28 = HIDWORD(a11);
    v29 = a11 >> 24;
    while (1)
    {
      v46 = v22;
      v47 = *(_WORD *)((char *)&a11 + 1);
      v48 = v29;
      v49 = v28;
      v50 = v27;
      v51 = v26;
      v52 = v25;
      v30 = *(&v46 + v23);
      v31 = v13[3];
      v45[0] = v13;
      if (v24 >= v31 >> 1)
      {
        v42 = v25;
        v43 = v22;
        v40 = v27;
        v41 = v26;
        v38 = v29;
        v39 = v28;
        sub_100074F24(v31 > 1, v24 + 1, 1);
        v29 = v38;
        v28 = v39;
        v27 = v40;
        v26 = v41;
        v25 = v42;
        v22 = v43;
        v13 = (_QWORD *)v45[0];
      }
      v13[2] = v24 + 1;
      *((_BYTE *)v13 + v24 + 32) = v30;
      if (v11 >= 0xFFFFFFFFFFFFFF80)
        break;
      v11 += 128;
      ++v23;
      ++v24;
      if (!--v21)
        goto LABEL_3;
    }
    __break(1u);
LABEL_13:
    __break(1u);
    JUMPOUT(0x1000A6B38);
  }
LABEL_3:
  v14 = sub_1001068EC((uint64_t)v13);
  v16 = v15;
  swift_bridgeObjectRelease(v13);
  sub_100212D94(v14, v16);
  result = sub_10000E614(v14, v16);
  if (!v37)
  {
    v18 = sub_10001F11C((uint64_t)_swiftEmptyArrayStorage);
    v19 = type metadata accessor for BinaryEncoder();
    v20 = (uint64_t *)swift_allocObject(v19, 40, 7);
    *((_OWORD *)v20 + 1) = xmmword_10033A100;
    v20[4] = v18;
    v45[3] = v19;
    v45[4] = sub_100011DE4((unint64_t *)&qword_100406278, (uint64_t (*)(uint64_t))type metadata accessor for BinaryEncoder, (uint64_t)protocol conformance descriptor for BinaryEncoder);
    v45[0] = v20;
    sub_100063D24(a2, a3, a4);
    swift_retain();
    IEEE80211Frame.Management.ActionFrame.encode(to:)(v45, a1, a2, a3, a4);
    sub_100014430(v45);
    sub_1000632E8(a2, a3, a4);
    swift_beginAccess(v20 + 2, &v46, 0, 0);
    v32 = v20[3];
    sub_100031FEC(v20[2], v32);
    swift_release(v20);
    __asm { BR              X9 }
  }
  return result;
}

uint64_t IO80211Driver<>.transmit(outOfBoundActionFrame:from:to:on:mapID:using:)(char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, unint64_t a10, unint64_t a11)
{
  unint64_t v11;
  unint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t result;
  unint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  char v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  __int16 v44[483];
  _QWORD v45[125];
  char v46;
  __int16 v47;
  char v48;
  char v49;
  char v50;
  char v51;
  char v52;

  v11 = a9;
  bzero(v44, 0x3C4uLL);
  v12 = a10 - a9;
  if (a10 < a9)
    goto LABEL_13;
  v13 = _swiftEmptyArrayStorage;
  if (v12 >= 0x80)
  {
    v21 = v12 >> 7;
    v45[0] = _swiftEmptyArrayStorage;
    sub_100074F24(0, v12 >> 7, 0);
    v22 = a11;
    v13 = (_QWORD *)v45[0];
    v23 = a9 >> 7;
    v24 = *(_QWORD *)(v45[0] + 16);
    v25 = HIBYTE(a11);
    v26 = HIWORD(a11);
    v27 = a11 >> 40;
    v28 = HIDWORD(a11);
    v29 = a11 >> 24;
    while (1)
    {
      v46 = v22;
      v47 = *(_WORD *)((char *)&a11 + 1);
      v48 = v29;
      v49 = v28;
      v50 = v27;
      v51 = v26;
      v52 = v25;
      v30 = *(&v46 + v23);
      v31 = v13[3];
      v45[0] = v13;
      if (v24 >= v31 >> 1)
      {
        v42 = v25;
        v43 = v22;
        v40 = v27;
        v41 = v26;
        v38 = v29;
        v39 = v28;
        sub_100074F24(v31 > 1, v24 + 1, 1);
        v29 = v38;
        v28 = v39;
        v27 = v40;
        v26 = v41;
        v25 = v42;
        v22 = v43;
        v13 = (_QWORD *)v45[0];
      }
      v13[2] = v24 + 1;
      *((_BYTE *)v13 + v24 + 32) = v30;
      if (v11 >= 0xFFFFFFFFFFFFFF80)
        break;
      v11 += 128;
      ++v23;
      ++v24;
      if (!--v21)
        goto LABEL_3;
    }
    __break(1u);
LABEL_13:
    __break(1u);
    JUMPOUT(0x1000A71C8);
  }
LABEL_3:
  v14 = sub_1001068EC((uint64_t)v13);
  v16 = v15;
  swift_bridgeObjectRelease(v13);
  sub_100212D94(v14, v16);
  result = sub_10000E614(v14, v16);
  if (!v37)
  {
    v18 = sub_10001F11C((uint64_t)_swiftEmptyArrayStorage);
    v19 = type metadata accessor for BinaryEncoder();
    v20 = (uint64_t *)swift_allocObject(v19, 40, 7);
    *((_OWORD *)v20 + 1) = xmmword_10033A100;
    v20[4] = v18;
    v45[3] = v19;
    v45[4] = sub_100011DE4((unint64_t *)&qword_100406278, (uint64_t (*)(uint64_t))type metadata accessor for BinaryEncoder, (uint64_t)protocol conformance descriptor for BinaryEncoder);
    v45[0] = v20;
    sub_100063D24(a2, a3, a4);
    swift_retain();
    IEEE80211Frame.Management.ActionFrame.encode(to:)(v45, a1, a2, a3, a4);
    sub_100014430(v45);
    sub_1000632E8(a2, a3, a4);
    swift_beginAccess(v20 + 2, &v46, 0, 0);
    v32 = v20[3];
    sub_100031FEC(v20[2], v32);
    swift_release(v20);
    __asm { BR              X9 }
  }
  return result;
}

uint64_t sub_1000A726C(uint64_t a1)
{
  return sub_1000A728C(a1);
}

uint64_t sub_1000A728C(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  Swift::String v10;
  uint64_t v11;
  _QWORD *v12;
  __n128 v13;
  uint64_t v14;
  unint64_t v15;
  __int128 v16;
  __int16 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  unint64_t v32;
  void *v33;
  uint64_t v34;
  _QWORD *v35;
  _QWORD v36[272];
  _QWORD v37[272];
  uint64_t v38;

  v2 = type metadata accessor for SHA256Digest(0);
  v31 = *(_QWORD *)(v2 - 8);
  v32 = v2;
  __chkstk_darwin();
  v4 = (char *)&v28 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v29 = type metadata accessor for SHA256(0);
  v5 = *(_QWORD *)(v29 - 8);
  __chkstk_darwin();
  v7 = (char *)&v28 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  v28 = (char *)v36 + 4;
  v30 = (char *)&v36[1] + 2;
  v33 = (char *)&v36[3] + 4;
  HIDWORD(v36[262]) = 0;
  LOWORD(v36[263]) = 0;
  bzero((char *)v36 + 4, 0x822uLL);
  LOBYTE(v36[262]) = 0;
  v36[261] = 0;
  *(_QWORD *)((char *)&v36[263] + 4) = 0;
  BYTE4(v36[264]) = 0;
  memset(&v36[265], 0, 53);
  LOBYTE(v36[0]) = *(_BYTE *)a1;
  BYTE1(v36[0]) = *(_BYTE *)(a1 + 74);
  WORD1(v36[0]) = *(unsigned __int8 *)(a1 + 1);
  v8 = *(_QWORD *)(a1 + 64);
  v9 = swift_bridgeObjectRetain(v8);
  SHA256.init()(v9);
  v10 = String.lowercased()();
  swift_bridgeObjectRelease(v8);
  swift_bridgeObjectRetain(v10._object);
  v11 = v34;
  sub_10017550C(v10._countAndFlagsBits, (uint64_t)v10._object, (uint64_t)v7, v10._countAndFlagsBits, (uint64_t)v10._object, v12);
  v13 = swift_bridgeObjectRelease(v10._object);
  SHA256.finalize()(v13);
  SHA256Digest.withUnsafeBytes<A>(_:)(v37, sub_100175E14, 0, &type metadata for Data);
  v34 = v11;
  (*(void (**)(char *, unint64_t))(v31 + 8))(v4, v32);
  v14 = v37[0];
  v15 = v37[1];
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v29);
  v37[0] = v14;
  v37[1] = v15;
  v32 = sub_100068D00();
  DataProtocol.copyBytes(to:)(v28, v30, &type metadata for Data, v32);
  sub_10000E614(v14, v15);
  v16 = *(_OWORD *)(a1 + 8);
  WORD2(v16) = *(_OWORD *)(a1 + 12);
  WORD3(v16) = *(_OWORD *)(a1 + 2);
  DWORD2(v16) = *(_DWORD *)(a1 + 4);
  HIDWORD(v16) = *(_DWORD *)(a1 + 46);
  v17 = *(_WORD *)(a1 + 50);
  *(_OWORD *)((char *)&v36[1] + 2) = v16;
  WORD1(v36[3]) = v17;
  HIDWORD(v36[262]) = 0;
  LOWORD(v36[263]) = 0;
  LODWORD(v36[265]) = 0;
  bzero(v33, 0x80AuLL);
  LOBYTE(v36[262]) = 0;
  v36[261] = 0;
  *(_QWORD *)((char *)&v36[263] + 4) = 0;
  BYTE4(v36[264]) = 0;
  v18 = *(_QWORD *)(a1 + 128);
  if (v18 == 1)
  {
    BYTE4(v36[265]) = 0;
  }
  else
  {
    v19 = *(_QWORD *)(a1 + 80);
    v20 = *(_QWORD *)(a1 + 88);
    v22 = *(_QWORD *)(a1 + 96);
    v21 = *(_QWORD *)(a1 + 104);
    v23 = *(_QWORD *)(a1 + 112);
    v33 = *(void **)(a1 + 120);
    v31 = v19;
    BYTE4(v36[265]) = v19 + 1;
    v37[0] = v20;
    v37[1] = v22;
    sub_100031FEC(v20, v22);
    sub_1000339F4(v21, v23);
    swift_bridgeObjectRetain(v18);
    DataProtocol.copyBytes(to:)((char *)&v36[265] + 5, (char *)&v36[269] + 5, &type metadata for Data, v32);
    if (v23 >> 60 == 15)
    {
      sub_1000B6530(v31, v20, v22, v21, v23, (uint64_t)v33, v18);
    }
    else
    {
      v37[0] = v21;
      v37[1] = v23;
      sub_100031FEC(v21, v23);
      DataProtocol.copyBytes(to:)((char *)&v36[269] + 5, (char *)&v36[271] + 5, &type metadata for Data, v32);
      sub_1000B6530(v31, v20, v22, v21, v23, (uint64_t)v33, v18);
      sub_10000E658(v21, v23);
    }
  }
  memcpy(v37, v36, sizeof(v37));
  v24 = v35[5];
  v25 = v35[2];
  v26 = v35[3];
  swift_retain();
  swift_bridgeObjectRetain(v26);
  AppleDevice.setRequest(requestType:data:on:)(0x13CuLL, (uint64_t)v37, (uint64_t)&v38, 0, v25, v26);
  swift_bridgeObjectRelease(v26);
  return swift_release(v24);
}

uint64_t IO80211Driver<>.send(datapathResponse:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  Swift::String v13;
  uint64_t v14;
  _QWORD *v15;
  __n128 v16;
  uint64_t v17;
  unint64_t v18;
  __int128 v19;
  __int16 v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  unint64_t v41;
  void *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD v47[272];
  _QWORD v48[272];

  v44 = a4;
  v46 = a2;
  v45 = a3;
  v5 = type metadata accessor for SHA256Digest(0);
  v40 = *(_QWORD *)(v5 - 8);
  v41 = v5;
  __chkstk_darwin();
  v7 = (char *)&v36 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  v38 = type metadata accessor for SHA256(0);
  v8 = *(_QWORD *)(v38 - 8);
  __chkstk_darwin();
  v10 = (char *)&v36 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  v37 = (char *)v47 + 4;
  v39 = (char *)&v47[1] + 2;
  v42 = (char *)&v47[3] + 4;
  HIDWORD(v47[262]) = 0;
  LOWORD(v47[263]) = 0;
  bzero((char *)v47 + 4, 0x822uLL);
  LOBYTE(v47[262]) = 0;
  v47[261] = 0;
  *(_QWORD *)((char *)&v47[263] + 4) = 0;
  BYTE4(v47[264]) = 0;
  memset(&v47[265], 0, 53);
  LOBYTE(v47[0]) = *(_BYTE *)a1;
  BYTE1(v47[0]) = *(_BYTE *)(a1 + 74);
  WORD1(v47[0]) = *(unsigned __int8 *)(a1 + 1);
  v11 = *(_QWORD *)(a1 + 64);
  v12 = swift_bridgeObjectRetain(v11);
  SHA256.init()(v12);
  v13 = String.lowercased()();
  swift_bridgeObjectRelease(v11);
  swift_bridgeObjectRetain(v13._object);
  v14 = v43;
  sub_10017550C(v13._countAndFlagsBits, (uint64_t)v13._object, (uint64_t)v10, v13._countAndFlagsBits, (uint64_t)v13._object, v15);
  v16 = swift_bridgeObjectRelease(v13._object);
  SHA256.finalize()(v16);
  SHA256Digest.withUnsafeBytes<A>(_:)(v48, sub_100175E14, 0, &type metadata for Data);
  v43 = v14;
  (*(void (**)(char *, unint64_t))(v40 + 8))(v7, v41);
  v17 = v48[0];
  v18 = v48[1];
  (*(void (**)(char *, uint64_t))(v8 + 8))(v10, v38);
  v48[0] = v17;
  v48[1] = v18;
  v41 = sub_100068D00();
  DataProtocol.copyBytes(to:)(v37, v39, &type metadata for Data, v41);
  sub_10000E614(v17, v18);
  v19 = *(_OWORD *)(a1 + 8);
  WORD2(v19) = *(_OWORD *)(a1 + 12);
  WORD3(v19) = *(_OWORD *)(a1 + 2);
  DWORD2(v19) = *(_DWORD *)(a1 + 4);
  HIDWORD(v19) = *(_DWORD *)(a1 + 46);
  v20 = *(_WORD *)(a1 + 50);
  *(_OWORD *)((char *)&v47[1] + 2) = v19;
  WORD1(v47[3]) = v20;
  HIDWORD(v47[262]) = 0;
  LOWORD(v47[263]) = 0;
  LODWORD(v47[265]) = 0;
  bzero(v42, 0x80AuLL);
  LOBYTE(v47[262]) = 0;
  v47[261] = 0;
  *(_QWORD *)((char *)&v47[263] + 4) = 0;
  BYTE4(v47[264]) = 0;
  v21 = *(_QWORD *)(a1 + 128);
  if (v21 == 1)
  {
    BYTE4(v47[265]) = 0;
  }
  else
  {
    v22 = *(_QWORD *)(a1 + 80);
    v23 = *(_QWORD *)(a1 + 88);
    v25 = *(_QWORD *)(a1 + 96);
    v24 = *(_QWORD *)(a1 + 104);
    v26 = *(_QWORD *)(a1 + 112);
    v42 = *(void **)(a1 + 120);
    v40 = v22;
    BYTE4(v47[265]) = v22 + 1;
    v48[0] = v23;
    v48[1] = v25;
    sub_100031FEC(v23, v25);
    sub_1000339F4(v24, v26);
    swift_bridgeObjectRetain(v21);
    DataProtocol.copyBytes(to:)((char *)&v47[265] + 5, (char *)&v47[269] + 5, &type metadata for Data, v41);
    if (v26 >> 60 == 15)
    {
      sub_1000B6530(v40, v23, v25, v24, v26, (uint64_t)v42, v21);
    }
    else
    {
      v48[0] = v24;
      v48[1] = v26;
      sub_100031FEC(v24, v26);
      DataProtocol.copyBytes(to:)((char *)&v47[269] + 5, (char *)&v47[271] + 5, &type metadata for Data, v41);
      sub_1000B6530(v40, v23, v25, v24, v26, (uint64_t)v42, v21);
      sub_10000E658(v24, v26);
    }
  }
  memcpy(v48, v47, sizeof(v48));
  type metadata accessor for apple80211_nan_dp_response(0);
  v28 = v27;
  v29 = v45;
  v30 = *(_QWORD *)(v45 + 8);
  v31 = *(_QWORD *)(v44 + 16);
  v32 = v46;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v30, v46, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v29, v32, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000AC020(316, (uint64_t)v48, v32, v28, v30, v31, AssociatedConformanceWitness);
}

uint64_t sub_1000A7B24(unint64_t a1)
{
  return sub_10005A738(0x13FuLL, HIWORD(a1) & 0xFF00u | a1 | (a1 >> 8 << 16));
}

uint64_t IO80211Driver<>.send(datapathConfirmation:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  _BYTE v14[8];

  v14[0] = a1;
  v14[1] = HIBYTE(a1);
  v14[2] = BYTE1(a1);
  v14[3] = BYTE2(a1);
  v14[4] = BYTE3(a1);
  v14[5] = BYTE4(a1);
  v14[6] = BYTE5(a1);
  v14[7] = BYTE6(a1);
  type metadata accessor for apple80211_nan_dp_confirm(0);
  v8 = v7;
  v9 = *(_QWORD *)(a3 + 8);
  v10 = *(_QWORD *)(a4 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v9, a2, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, a2, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000AC020(319, (uint64_t)v14, a2, v8, v9, v10, AssociatedConformanceWitness);
}

void sub_1000A7C48(uint64_t a1)
{
  IO80211Driver<>.update(availability:)(a1);
}

void IO80211Driver<>.update(availability:)(uint64_t a1)
{
  uint64_t v1;
  __int16 v2;
  uint64_t v3;
  __int16 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  _BYTE v28[27];
  __int16 v29;
  char v30;
  __int16 v31;
  char v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  _BYTE v36[21];
  uint64_t v37;
  char v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  _BYTE v42[21];
  uint64_t v43;
  char v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  _BYTE v48[21];
  uint64_t v49;
  char v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  _BYTE v54[21];
  uint64_t v55;
  char v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  _BYTE v60[21];
  uint64_t v61;
  char v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  _BYTE v66[21];
  uint64_t v67;
  char v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  _BYTE v72[21];
  uint64_t v73;
  char v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  _BYTE v78[21];
  uint64_t v79;
  char v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  _BYTE v84[21];
  uint64_t v85;
  char v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  _BYTE v90[21];
  uint64_t v91;
  char v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  _BYTE v96[21];
  uint64_t v97;
  char v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  _BYTE v102[21];
  uint64_t v103;
  char v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  _BYTE v108[21];
  uint64_t v109;
  char v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  _BYTE v114[21];
  uint64_t v115;
  char v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  _BYTE v120[21];
  uint64_t v121;
  char v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  _BYTE v126[21];
  uint64_t v127;
  char v128;
  __int16 v129;
  char v130;
  __int128 v131;
  __int128 v132;
  __int128 v133;
  _BYTE v134[21];
  uint64_t v135;
  char v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  _BYTE v140[21];
  uint64_t v141;
  char v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  _BYTE v146[21];
  uint64_t v147;
  char v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  _BYTE v152[21];
  uint64_t v153;
  char v154;
  __int128 v155;
  __int128 v156;
  __int128 v157;
  _BYTE v158[21];
  uint64_t v159;
  char v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  _BYTE v164[21];
  uint64_t v165;
  char v166;
  __int128 v167;
  __int128 v168;
  __int128 v169;
  _BYTE v170[21];
  uint64_t v171;
  char v172;
  __int128 v173;
  __int128 v174;
  __int128 v175;
  _BYTE v176[21];
  uint64_t v177;
  char v178;
  __int128 v179;
  __int128 v180;
  __int128 v181;
  _BYTE v182[21];
  uint64_t v183;
  char v184;
  __int128 v185;
  __int128 v186;
  __int128 v187;
  _BYTE v188[21];
  uint64_t v189;
  char v190;
  __int128 v191;
  __int128 v192;
  __int128 v193;
  _BYTE v194[21];
  uint64_t v195;
  char v196;
  __int128 v197;
  __int128 v198;
  __int128 v199;
  _BYTE v200[21];
  uint64_t v201;
  char v202;
  __int128 v203;
  __int128 v204;
  __int128 v205;
  _BYTE v206[21];
  uint64_t v207;
  char v208;
  __int128 v209;
  __int128 v210;
  __int128 v211;
  _BYTE v212[21];
  uint64_t v213;
  char v214;
  __int128 v215;
  __int128 v216;
  __int128 v217;
  _BYTE v218[21];
  uint64_t v219;
  char v220;
  __int128 v221;
  __int128 v222;
  __int128 v223;
  _BYTE v224[21];
  int v225;
  __int16 v226;
  uint64_t v227;

  v2 = 0;
  v35 = 0u;
  memset(v36, 0, sizeof(v36));
  v33 = 0u;
  v34 = 0u;
  v37 = 0;
  v39 = 0u;
  v40 = 0u;
  v41 = 0u;
  memset(v42, 0, sizeof(v42));
  v43 = 0;
  v45 = 0u;
  v46 = 0u;
  v47 = 0u;
  memset(v48, 0, sizeof(v48));
  v49 = 0;
  v51 = 0u;
  v52 = 0u;
  v53 = 0u;
  memset(v54, 0, sizeof(v54));
  v55 = 0;
  v57 = 0u;
  v58 = 0u;
  v59 = 0u;
  memset(v60, 0, sizeof(v60));
  v61 = 0;
  v63 = 0u;
  v64 = 0u;
  v65 = 0u;
  memset(v66, 0, sizeof(v66));
  v67 = 0;
  v71 = 0u;
  memset(v72, 0, sizeof(v72));
  v69 = 0u;
  v70 = 0u;
  v73 = 0;
  v77 = 0u;
  memset(v78, 0, sizeof(v78));
  v75 = 0u;
  v76 = 0u;
  v79 = 0;
  v81 = 0u;
  v82 = 0u;
  v83 = 0u;
  memset(v84, 0, sizeof(v84));
  v85 = 0;
  v89 = 0u;
  memset(v90, 0, sizeof(v90));
  v87 = 0u;
  v88 = 0u;
  v91 = 0;
  v95 = 0u;
  memset(v96, 0, sizeof(v96));
  v93 = 0u;
  v94 = 0u;
  v97 = 0;
  v101 = 0u;
  memset(v102, 0, sizeof(v102));
  v99 = 0u;
  v100 = 0u;
  v103 = 0;
  v107 = 0u;
  memset(v108, 0, sizeof(v108));
  v105 = 0u;
  v106 = 0u;
  v109 = 0;
  v113 = 0u;
  memset(v114, 0, sizeof(v114));
  v111 = 0u;
  v112 = 0u;
  v115 = 0;
  v119 = 0u;
  memset(v120, 0, sizeof(v120));
  v117 = 0u;
  v118 = 0u;
  v121 = 0;
  v125 = 0u;
  memset(v126, 0, sizeof(v126));
  v123 = 0u;
  v124 = 0u;
  v127 = 0;
  v133 = 0u;
  memset(v134, 0, sizeof(v134));
  v131 = 0u;
  v132 = 0u;
  v135 = 0;
  v139 = 0u;
  memset(v140, 0, sizeof(v140));
  v137 = 0u;
  v138 = 0u;
  v141 = 0;
  v145 = 0u;
  memset(v146, 0, sizeof(v146));
  v143 = 0u;
  v144 = 0u;
  v147 = 0;
  v151 = 0u;
  memset(v152, 0, sizeof(v152));
  v149 = 0u;
  v150 = 0u;
  v153 = 0;
  v157 = 0u;
  memset(v158, 0, sizeof(v158));
  v155 = 0u;
  v156 = 0u;
  v159 = 0;
  v163 = 0u;
  memset(v164, 0, sizeof(v164));
  v161 = 0u;
  v162 = 0u;
  v165 = 0;
  v169 = 0u;
  memset(v170, 0, sizeof(v170));
  v167 = 0u;
  v168 = 0u;
  v171 = 0;
  v175 = 0u;
  memset(v176, 0, sizeof(v176));
  v173 = 0u;
  v174 = 0u;
  v177 = 0;
  v181 = 0u;
  memset(v182, 0, sizeof(v182));
  v179 = 0u;
  v180 = 0u;
  v183 = 0;
  v187 = 0u;
  memset(v188, 0, sizeof(v188));
  v185 = 0u;
  v186 = 0u;
  v189 = 0;
  v193 = 0u;
  memset(v194, 0, sizeof(v194));
  v191 = 0u;
  v192 = 0u;
  v195 = 0;
  v199 = 0u;
  memset(v200, 0, sizeof(v200));
  v197 = 0u;
  v198 = 0u;
  v201 = 0;
  v205 = 0u;
  memset(v206, 0, sizeof(v206));
  v203 = 0u;
  v204 = 0u;
  v207 = 0;
  v211 = 0u;
  memset(v212, 0, sizeof(v212));
  v209 = 0u;
  v210 = 0u;
  v213 = 0;
  v217 = 0u;
  memset(v218, 0, sizeof(v218));
  v215 = 0u;
  v216 = 0u;
  v219 = 0;
  v223 = 0u;
  memset(v224, 0, sizeof(v224));
  v221 = 0u;
  v222 = 0u;
  v225 = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v129 = 0;
  v130 = 0;
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v17 = 0u;
  v18 = 0u;
  v19 = 0u;
  v20 = 0u;
  v21 = 0u;
  v22 = 0u;
  v23 = 0u;
  v24 = 0u;
  v25 = 0u;
  v26 = 0u;
  v27 = 0u;
  memset(v28, 0, sizeof(v28));
  v3 = 0;
  v4 = 0;
  v5 = 0u;
  v6 = 0u;
  v7 = 0u;
  v8 = 0u;
  v9 = 0u;
  v10 = 0u;
  v11 = 0u;
  v38 = 0;
  v44 = 0;
  v50 = 0;
  v56 = 0;
  v62 = 0;
  v68 = 0;
  v74 = 0;
  v80 = 0;
  v86 = 0;
  v92 = 0;
  v98 = 0;
  v104 = 0;
  v110 = 0;
  v116 = 0;
  v122 = 0;
  v128 = 0;
  v136 = 0;
  v142 = 0;
  v148 = 0;
  v154 = 0;
  v160 = 0;
  v166 = 0;
  v172 = 0;
  v178 = 0;
  v184 = 0;
  v190 = 0;
  v196 = 0;
  v202 = 0;
  v208 = 0;
  v214 = 0;
  v220 = 0;
  v226 = 0;
  sub_1000AE948((uint64_t)&v29, (uint64_t)&v227, a1, &v1);
}

void sub_1000A80B8(uint64_t a1)
{
  sub_1000B689C(a1);
}

void IO80211Driver<>.update(potentialAvailability:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int16 v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  _OWORD v16[3];
  char v17;
  uint64_t v18;

  v2 = v1;
  v3 = *(_QWORD *)(a1 + 16);
  if (v3)
  {
    v4 = a1 + 32;
    v18 = a1;
    swift_bridgeObjectRetain(a1);
    v5 = 0;
    while (1)
    {
      if (v5 < 2)
      {
        v6 = v4 + 16 * v5;
        v7 = *(_QWORD *)(v6 + 8);
        v8 = *(_WORD *)(v6 + 2);
        swift_bridgeObjectRetain(v7);
        sub_10007CCF8(0, 4, v8);
        if (v2)
        {
          swift_unexpectedError(v2, "CoreP2P/NANAttribute.swift", 26, 1);
          __break(1u);
          return;
        }
        v9 = *(_QWORD *)(v7 + 16);
        if (v9)
        {
          swift_bridgeObjectRetain(v7);
          v10 = 0;
          v11 = 32;
          do
          {
            v12 = *(_OWORD *)(v7 + v11);
            v13 = *(_OWORD *)(v7 + v11 + 16);
            v14 = *(_OWORD *)(v7 + v11 + 32);
            v17 = *(_BYTE *)(v7 + v11 + 48);
            v16[1] = v13;
            v16[2] = v14;
            v16[0] = v12;
            if (v10 <= 0xF)
            {
              sub_1000B6584(v16);
              sub_1000AEB6C((unint64_t)&v15);
              sub_1000B65BC(v16);
              ++v10;
            }
            v11 += 56;
            --v9;
          }
          while (v9);
          swift_bridgeObjectRelease(v7);
        }
        swift_bridgeObjectRelease(v7);
      }
      if (++v5 == v3)
      {
        swift_bridgeObjectRelease(v18);
        return;
      }
    }
  }
}

double sub_1000A8248(uint64_t a1, uint64_t a2)
{
  return IO80211Driver<>.update(dataCluster:)(a1 & 0xFFFFFFFFFFFFFFLL, a2);
}

double IO80211Driver<>.update(dataCluster:)(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v4;
  uint64_t v5;
  __int16 v6;
  unint64_t v7;
  uint64_t v8;
  __int16 v9;
  double result;

  v2 = *(_QWORD *)(a2 + 16);
  if (v2)
  {
    v5 = *(_QWORD *)(a2 + 48);
    v4 = *(_QWORD *)(a2 + 56);
    v6 = *(_WORD *)(a2 + 40);
    swift_bridgeObjectRetain(a2);
    sub_100031FEC(v5, v4);
    sub_1000AEF4C(v6, v5, v4);
    sub_10000E614(v5, v4);
    if (v2 != 1)
    {
      v8 = *(_QWORD *)(a2 + 80);
      v7 = *(_QWORD *)(a2 + 88);
      v9 = *(_WORD *)(a2 + 72);
      sub_100031FEC(v8, v7);
      sub_1000AEF4C(v9, v8, v7);
      sub_10000E614(v8, v7);
    }
    *(_QWORD *)&result = swift_bridgeObjectRelease(a2).n128_u64[0];
  }
  return result;
}

uint64_t sub_1000A8350(uint64_t a1, _QWORD *a2)
{
  return sub_1000A8370(a1, a2);
}

uint64_t sub_1000A8370(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  unint64_t v3;
  char v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  char v9[4];
  int v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int16 v20;
  int v21;
  _BYTE v22[148];
  uint64_t v23;

  v3 = a1;
  v22[4] = 0;
  v22[76] = 0;
  memset(&v22[6], 0, 69);
  memset(&v22[78], 0, 69);
  if (!a2)
  {
    v22[2] = 0;
    sub_1000AF214((uint64_t)&v22[4], (uint64_t)&v23, a1, 0);
    LODWORD(v3) = 0;
    v4 = 0;
    goto LABEL_6;
  }
  if (a2[2] < 0x100uLL)
  {
    v22[2] = a2[2];
    sub_1000AF214((uint64_t)&v22[4], (uint64_t)&v23, a1, a2);
    if (!HIDWORD(v3))
    {
      v4 = 1;
LABEL_6:
      v17 = *(_OWORD *)&v22[98];
      v18 = *(_OWORD *)&v22[114];
      v19 = *(_OWORD *)&v22[130];
      v13 = *(_OWORD *)&v22[34];
      v14 = *(_OWORD *)&v22[50];
      v15 = *(_OWORD *)&v22[66];
      v16 = *(_OWORD *)&v22[82];
      v11 = *(_OWORD *)&v22[2];
      v20 = *(_WORD *)&v22[146];
      v12 = *(_OWORD *)&v22[18];
      v9[0] = v4;
      v10 = v3;
      v21 = 0;
      v5 = v2[5];
      v6 = v2[2];
      v7 = v2[3];
      swift_retain();
      swift_bridgeObjectRetain(v7);
      AppleDevice.setRequest(requestType:data:on:)(0x14DuLL, (uint64_t)v9, (uint64_t)v22, 0, v6, v7);
      swift_bridgeObjectRelease(v7);
      return swift_release(v5);
    }
  }
  result = _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 3455, 0);
  __break(1u);
  return result;
}

uint64_t IO80211Driver<>.update(discoveryBeaconTransmissionSchedule:)(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  uint64_t result;
  char v17[4];
  int v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int16 v28;
  int v29;
  _BYTE v30[146];
  uint64_t v31;

  v8 = a1;
  v30[2] = 0;
  v30[74] = 0;
  memset(&v30[4], 0, 69);
  memset(&v30[76], 0, 69);
  if (!a2)
  {
    v30[0] = 0;
    sub_1000AF214((uint64_t)&v30[2], (uint64_t)&v31, a1, 0);
    LODWORD(v8) = 0;
    v9 = 0;
    goto LABEL_6;
  }
  if (a2[2] < 0x100uLL)
  {
    v30[0] = a2[2];
    sub_1000AF214((uint64_t)&v30[2], (uint64_t)&v31, a1, a2);
    if (!HIDWORD(v8))
    {
      v9 = 1;
LABEL_6:
      v25 = *(_OWORD *)&v30[96];
      v26 = *(_OWORD *)&v30[112];
      v27 = *(_OWORD *)&v30[128];
      v21 = *(_OWORD *)&v30[32];
      v22 = *(_OWORD *)&v30[48];
      v23 = *(_OWORD *)&v30[64];
      v24 = *(_OWORD *)&v30[80];
      v19 = *(_OWORD *)v30;
      v28 = *(_WORD *)&v30[144];
      v20 = *(_OWORD *)&v30[16];
      v17[0] = v9;
      v18 = v8;
      v29 = 0;
      type metadata accessor for apple80211_nan_forced_disc_beacon_transmission(0);
      v11 = v10;
      v12 = *(_QWORD *)(a4 + 8);
      v13 = *(_QWORD *)(a5 + 16);
      AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v12, a3, &protocol requirements base descriptor for DeviceDriver);
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a4, a3, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
      return sub_1000AC020(333, (uint64_t)v17, a3, v11, v12, v13, AssociatedConformanceWitness);
    }
  }
  result = _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 3455, 0);
  __break(1u);
  return result;
}

uint64_t sub_1000A8760(uint64_t a1, uint64_t a2)
{
  return sub_10005ADC8(0x181uLL, a2 & 0xFFFFFFFFFFFFFFLL, a1 != 0);
}

uint64_t IO80211Driver<>.update(linkStatus:for:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  __int16 v15;
  char v16;
  char v17;
  char v18;
  char v19;
  char v20;
  _BOOL4 v21;

  v15 = a2;
  v16 = BYTE2(a2);
  v17 = BYTE3(a2);
  v18 = BYTE4(a2);
  v19 = BYTE5(a2);
  v20 = BYTE6(a2);
  v21 = a1 != 0;
  type metadata accessor for apple80211_nan_dp_link_status(0);
  v9 = v8;
  v10 = *(_QWORD *)(a4 + 8);
  v11 = *(_QWORD *)(a5 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, a3, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a4, a3, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000AC020(385, (uint64_t)&v15, a3, v9, v10, v11, AssociatedConformanceWitness);
}

uint64_t sub_1000A8884(char a1)
{
  return sub_10005AEB8(0x18EuLL, (unint64_t)&_mh_execute_header & 0xFFFFFFFFFFFFFFFELL | a1 & 1);
}

uint64_t IO80211Driver<>.update(powerSaveRestriction:)(char a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  _BYTE v14[4];
  int v15;

  v14[0] = a1;
  v15 = 1;
  type metadata accessor for apple80211_nan_ps_restriction(0);
  v8 = v7;
  v9 = *(_QWORD *)(a3 + 8);
  v10 = *(_QWORD *)(a4 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v9, a2, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, a2, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000AC020(398, (uint64_t)v14, a2, v8, v9, v10, AssociatedConformanceWitness);
}

uint64_t sub_1000A8970(unsigned int a1)
{
  char v1;
  uint64_t v2;

  if ((a1 & 0x100) != 0)
    v1 = 0;
  else
    v1 = a1;
  v2 = 0x200000000;
  if ((a1 & 0x100) == 0)
    v2 = (uint64_t)&_mh_execute_header;
  return sub_10005AF7C(0x190uLL, v2 | HIWORD(a1) & 1, v1);
}

uint64_t IO80211Driver<>.update(internetSharingActivity:)(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  _BYTE v16[4];
  int v17;
  char v18;

  if ((a1 & 0x100) != 0)
    v7 = 0;
  else
    v7 = a1;
  v16[0] = BYTE2(a1) & 1;
  if ((a1 & 0x100) != 0)
    v8 = 2;
  else
    v8 = 1;
  v17 = v8;
  v18 = v7;
  type metadata accessor for apple80211_nan_ir_status(0);
  v10 = v9;
  v11 = *(_QWORD *)(a3 + 8);
  v12 = *(_QWORD *)(a4 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v11, a2, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, a2, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  return sub_1000AC020(400, (uint64_t)v16, a2, v10, v11, v12, AssociatedConformanceWitness);
}

id sub_1000A8A84(uint64_t a1)
{
  return sub_1000A8AA8(a1 & 0xFFFFFFFFFFFFLL);
}

id sub_1000A8AA8(unint64_t a1)
{
  _QWORD *v1;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  Class v12;
  id result;
  char *v14;
  id v15;
  NSNumber v16;
  uint64_t v17;
  NSNumber v18;
  NSNumber v19;
  NSNumber v20;
  NSNumber v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  id v37;
  uint64_t v38;
  Class v39;
  Class v40;
  Class v41;
  uint64_t v42;
  Class v43;
  Class v44;
  Class v45;
  Class v46;
  Class v47;
  Class v48;
  Class v49;
  Class v50;
  Class v51;
  Class v52;
  Class v53;
  Class v54;
  Class v55;
  void *v56;
  Class v57;
  Class v58;
  uint64_t v59;
  Class v60;
  Class v61;
  Class v62;
  Class v63;
  Class v64;
  Class v65;
  Class v66;
  Class v67;
  Class v68;
  uint64_t v69;
  Class v70;
  Class v71;
  Class v72;
  char *v73;
  Class isa;
  uint64_t v75;
  __int128 v76;
  uint64_t v77;
  __int128 v78;
  uint64_t v79;
  __int128 v80;
  uint64_t v81;
  __int128 v82;
  uint64_t v83;
  __int128 v84;
  uint64_t v85;
  __int128 v86;
  uint64_t v87;
  __int128 v88;
  uint64_t v89;
  __int128 v90;
  uint64_t v91;
  __int128 v92;
  uint64_t v93;
  __int128 v94;
  uint64_t v95;
  uint64_t v96;
  _BYTE v97[8];
  _DWORD v98[2];
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  _WORD v110[12];
  __int128 v111;
  uint64_t v112;
  __int128 v113;
  uint64_t v114;
  __int128 v115;
  uint64_t v116;
  __int128 v117;
  uint64_t v118;
  __int128 v119;
  uint64_t v120;
  __int128 v121;
  uint64_t v122;
  __int128 v123;
  uint64_t v124;
  __int128 v125;
  uint64_t v126;
  __int128 v127;
  uint64_t v128;
  __int128 v129;
  uint64_t v130;
  __int128 v131;
  uint64_t v132;
  __int128 v133;
  uint64_t v134;
  __int128 v135;
  uint64_t v136;
  __int128 v137;
  uint64_t v138;
  __int128 v139;
  uint64_t v140;
  __int128 v141;
  uint64_t v142;
  __int128 v143;
  uint64_t v144;
  __int128 v145;
  uint64_t v146;
  __int128 v147;
  uint64_t v148;
  __int128 v149;
  uint64_t v150;
  __int128 v151;
  uint64_t v152;
  __int128 v153;
  uint64_t v154;
  __int128 v155;
  uint64_t v156;
  __int128 v157;
  uint64_t v158;
  __int128 v159;
  uint64_t v160;
  __int128 v161;
  uint64_t v162;
  __int128 v163;
  uint64_t v164;
  __int128 v165;
  uint64_t v166;
  __int128 v167;
  uint64_t v168;
  __int128 v169;
  uint64_t v170;
  __int128 v171;
  uint64_t v172;
  __int128 v173;
  uint64_t v174;
  __int128 v175;
  uint64_t v176;
  __int128 v177;
  uint64_t v178;
  __int128 v179;
  uint64_t v180;
  __int128 v181;
  uint64_t v182;
  __int128 v183;
  uint64_t v184;
  __int128 v185;
  uint64_t v186;
  __int128 v187;
  uint64_t v188;
  __int128 v189;
  uint64_t v190;
  __int128 v191;
  uint64_t v192;
  __int128 v193;
  uint64_t v194;
  __int128 v195;
  uint64_t v196;
  _QWORD v197[3];

  v3 = a1 >> 8;
  v4 = a1 >> 16;
  v5 = a1 >> 24;
  v6 = HIDWORD(a1);
  v7 = a1 >> 40;
  type metadata accessor for String.Encoding(0);
  __chkstk_darwin();
  v73 = (char *)&v38 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  *(_DWORD *)((char *)v98 + 3) = 0;
  v98[0] = 0;
  v99 = 0u;
  v100 = 0u;
  v101 = 0u;
  v102 = 0u;
  v103 = 0u;
  v104 = 0u;
  v105 = 0u;
  v106 = 0u;
  v107 = 0u;
  v108 = 0u;
  v109 = 0u;
  memset(v110, 0, 19);
  bzero(&v111, 0x408uLL);
  v97[0] = a1;
  v97[1] = v3;
  v97[2] = v4;
  v97[3] = v5;
  v97[4] = v6;
  v97[5] = v7;
  v9 = v1[5];
  v10 = v1[2];
  v11 = v1[3];
  swift_retain();
  swift_bridgeObjectRetain(v11);
  v12 = isa;
  AppleDevice.getRequest(requestType:data:on:)(0x16CuLL, (uint64_t)v97, (uint64_t)v197, 0, v10, v11);
  swift_bridgeObjectRelease(v11);
  result = (id)swift_release(v9);
  if (!v12)
  {
    v14 = v73;
    v15 = objc_msgSend(objc_allocWithZone((Class)WiFiMACAddress), "initWithAddress:", a1 & 0xFFFFFFFFFFFFLL);
    v16.super.super.isa = UInt32._bridgeToObjectiveC()().super.super.isa;
    v76 = v111;
    v77 = v112;
    v78 = v113;
    v79 = v114;
    v80 = v115;
    v81 = v116;
    v82 = v117;
    v83 = v118;
    v84 = v119;
    v86 = v121;
    v85 = v120;
    v87 = v122;
    v88 = v123;
    v90 = v125;
    v89 = v124;
    v91 = v126;
    v92 = v127;
    v94 = v129;
    v93 = v128;
    v95 = v130;
    sub_1000AF460((uint64_t)&v76, (uint64_t)&v96, &v75);
    v17 = v75;
    v76 = v131;
    v77 = v132;
    v78 = v133;
    v79 = v134;
    v80 = v135;
    v81 = v136;
    v82 = v137;
    v83 = v138;
    sub_1000AF460((uint64_t)&v76, (uint64_t)&v84, &v75);
    v59 = 0;
    v69 = v75;
    v18.super.super.isa = UInt8._bridgeToObjectiveC()().super.super.isa;
    v19.super.super.isa = UInt8._bridgeToObjectiveC()().super.super.isa;
    isa = UInt8._bridgeToObjectiveC()().super.super.isa;
    v72 = UInt32._bridgeToObjectiveC()().super.super.isa;
    v71 = UInt32._bridgeToObjectiveC()().super.super.isa;
    v70 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v68 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v67 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v66 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v65 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v64 = UInt64._bridgeToObjectiveC()().super.super.isa;
    sub_1000644C8(0, (unint64_t *)&unk_10040D320, NSNumber_ptr);
    v20.super.super.isa = NSNumber.init(integerLiteral:)(0).super.super.isa;
    v63 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v62 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v61 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v60 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v21.super.super.isa = UInt64._bridgeToObjectiveC()().super.super.isa;
    if (__CFADD__((_QWORD)v103, *((_QWORD *)&v105 + 1)))
      __break(1u);
    v56 = v15;
    v57 = v19.super.super.isa;
    v58 = v18.super.super.isa;
    v55 = v21.super.super.isa;
    v54 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v53 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v52 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v51 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v50 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v49 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v48 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v47 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v46 = UInt32._bridgeToObjectiveC()().super.super.isa;
    v45 = UInt32._bridgeToObjectiveC()().super.super.isa;
    v43 = UInt32._bridgeToObjectiveC()().super.super.isa;
    v41 = UInt32._bridgeToObjectiveC()().super.super.isa;
    v40 = UInt32._bridgeToObjectiveC()().super.super.isa;
    v44 = v20.super.super.isa;
    v22 = v110[8];
    v23 = sub_100012C44(&qword_100403E88);
    v24 = swift_allocObject(v23, 34, 7);
    v42 = v17;
    v25 = v24;
    *(_OWORD *)(v24 + 16) = xmmword_10033C020;
    *(_WORD *)(v24 + 32) = v22;
    *(_QWORD *)&v76 = v24;
    static String.Encoding.utf8.getter(v24);
    v26 = sub_100012C44(&qword_100406738);
    v39 = v16.super.super.isa;
    v27 = v26;
    v28 = sub_100011770((unint64_t *)&qword_100406740, &qword_100406738, (const char *)&protocol conformance descriptor for [A]);
    v29 = String.init<A>(bytes:encoding:)(&v76, v14, v27, v28);
    v31 = v30;
    swift_bridgeObjectRelease(v25);
    if (v31)
      v32 = v29;
    else
      v32 = 0;
    if (!v31)
      v31 = 0xE000000000000000;
    v76 = v187;
    v77 = v188;
    v78 = v189;
    v79 = v190;
    v80 = v191;
    v81 = v192;
    v82 = v193;
    v83 = v194;
    v84 = v195;
    v85 = v196;
    sub_1000AF460((uint64_t)&v76, (uint64_t)&v86, &v75);
    v33 = v75;
    v76 = v159;
    v77 = v160;
    v78 = v161;
    v79 = v162;
    v80 = v163;
    v81 = v164;
    v82 = v165;
    v83 = v166;
    v84 = v167;
    v86 = v169;
    v85 = v168;
    v87 = v170;
    v88 = v171;
    v90 = v173;
    v89 = v172;
    v91 = v174;
    v92 = v175;
    v94 = v177;
    v93 = v176;
    v95 = v178;
    sub_1000AF460((uint64_t)&v76, (uint64_t)&v96, &v75);
    v34 = v75;
    v76 = v139;
    v77 = v140;
    v78 = v141;
    v79 = v142;
    v80 = v143;
    v81 = v144;
    v82 = v145;
    v83 = v146;
    v84 = v147;
    v86 = v149;
    v85 = v148;
    v87 = v150;
    v88 = v151;
    v90 = v153;
    v89 = v152;
    v91 = v154;
    v92 = v155;
    v94 = v157;
    v93 = v156;
    v95 = v158;
    sub_1000AF460((uint64_t)&v76, (uint64_t)&v96, &v75);
    v35 = v75;
    v76 = v179;
    v77 = v180;
    v78 = v181;
    v79 = v182;
    v80 = v183;
    v81 = v184;
    v82 = v185;
    v83 = v186;
    sub_1000AF460((uint64_t)&v76, (uint64_t)&v84, &v75);
    v36 = v75;
    v37 = objc_allocWithZone((Class)WiFiAwareDataSessionStatisticsReport);
    return sub_1000B1404(v56, v39, v42, v69, v58, v57, isa, v72, v71, v70, v68, v67, v66, v65, v64, 0, v44, v63, v62,
             v61,
             v60,
             v55,
             v54,
             v53,
             v52,
             v51,
             v50,
             v49,
             v48,
             v47,
             v46,
             v45,
             v43,
             v41,
             v40,
             v32,
             v31,
             v33,
             v34,
             v35,
             v36);
  }
  return result;
}

id IO80211Driver<>.generateStatisticsReport(for:)(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  Class v13;
  id result;
  uint64_t v15;
  NSNumber v16;
  NSNumber v17;
  NSNumber v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  id v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  Class v39;
  Class v40;
  Class v41;
  Class v42;
  Class v43;
  Class v44;
  Class v45;
  Class v46;
  Class v47;
  Class v48;
  Class v49;
  Class v50;
  Class v51;
  Class v52;
  Class v53;
  Class v54;
  uint64_t v55;
  uint64_t v56;
  Class v57;
  Class v58;
  Class v59;
  Class v60;
  Class v61;
  Class v62;
  Class v63;
  Class v64;
  char *v65;
  Class v66;
  uint64_t v67;
  Class v68;
  uint64_t v69;
  Class v70;
  Class v71;
  Class v72;
  Class v73;
  id v74;
  uint64_t v75;
  uint64_t v76;
  Class isa;
  uint64_t v78;
  uint64_t v79;
  __int128 v80;
  uint64_t v81;
  __int128 v82;
  uint64_t v83;
  __int128 v84;
  uint64_t v85;
  __int128 v86;
  uint64_t v87;
  __int128 v88;
  uint64_t v89;
  __int128 v90;
  uint64_t v91;
  __int128 v92;
  uint64_t v93;
  __int128 v94;
  uint64_t v95;
  __int128 v96;
  uint64_t v97;
  __int128 v98;
  uint64_t v99;
  _BYTE v100[8];
  _DWORD v101[2];
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  _WORD v113[12];
  __int128 v114;
  uint64_t v115;
  __int128 v116;
  uint64_t v117;
  __int128 v118;
  uint64_t v119;
  __int128 v120;
  uint64_t v121;
  __int128 v122;
  uint64_t v123;
  __int128 v124;
  uint64_t v125;
  __int128 v126;
  uint64_t v127;
  __int128 v128;
  uint64_t v129;
  __int128 v130;
  uint64_t v131;
  __int128 v132;
  uint64_t v133;
  __int128 v134;
  uint64_t v135;
  __int128 v136;
  uint64_t v137;
  __int128 v138;
  uint64_t v139;
  __int128 v140;
  uint64_t v141;
  __int128 v142;
  uint64_t v143;
  __int128 v144;
  uint64_t v145;
  __int128 v146;
  uint64_t v147;
  __int128 v148;
  uint64_t v149;
  __int128 v150;
  uint64_t v151;
  __int128 v152;
  uint64_t v153;
  __int128 v154;
  uint64_t v155;
  __int128 v156;
  uint64_t v157;
  __int128 v158;
  uint64_t v159;
  __int128 v160;
  uint64_t v161;
  __int128 v162;
  uint64_t v163;
  __int128 v164;
  uint64_t v165;
  __int128 v166;
  uint64_t v167;
  __int128 v168;
  uint64_t v169;
  __int128 v170;
  uint64_t v171;
  __int128 v172;
  uint64_t v173;
  __int128 v174;
  uint64_t v175;
  __int128 v176;
  uint64_t v177;
  __int128 v178;
  uint64_t v179;
  __int128 v180;
  uint64_t v181;
  __int128 v182;
  uint64_t v183;
  __int128 v184;
  uint64_t v185;
  __int128 v186;
  uint64_t v187;
  __int128 v188;
  uint64_t v189;
  __int128 v190;
  uint64_t v191;
  __int128 v192;
  uint64_t v193;
  __int128 v194;
  uint64_t v195;
  __int128 v196;
  uint64_t v197;
  __int128 v198;
  uint64_t v199;
  uint64_t v200[3];

  v78 = a3;
  v79 = a4;
  v75 = a2;
  v5 = a1 >> 8;
  v6 = a1 >> 16;
  v7 = a1 >> 24;
  v8 = HIDWORD(a1);
  v9 = a1 >> 40;
  type metadata accessor for String.Encoding(0);
  __chkstk_darwin();
  v11 = (char *)&v36 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  *(_DWORD *)((char *)v101 + 3) = 0;
  v101[0] = 0;
  v102 = 0u;
  v103 = 0u;
  v104 = 0u;
  v105 = 0u;
  v106 = 0u;
  v107 = 0u;
  v108 = 0u;
  v109 = 0u;
  v110 = 0u;
  v111 = 0u;
  v112 = 0u;
  memset(v113, 0, 19);
  bzero(&v114, 0x408uLL);
  v100[0] = a1;
  v100[1] = v5;
  v100[2] = v6;
  v100[3] = v7;
  v100[4] = v8;
  v100[5] = v9;
  v12 = v75;
  v13 = isa;
  result = (id)sub_1000AF31C((uint64_t)v100, (uint64_t)v200, v76, v75, v78, v79, &v80);
  if (!v13)
  {
    v65 = v11;
    v74 = objc_msgSend(objc_allocWithZone((Class)WiFiMACAddress), "initWithAddress:", a1 & 0xFFFFFFFFFFFFLL);
    isa = UInt32._bridgeToObjectiveC()().super.super.isa;
    v80 = v114;
    v81 = v115;
    v82 = v116;
    v83 = v117;
    v84 = v118;
    v85 = v119;
    v86 = v120;
    v87 = v121;
    v88 = v122;
    v89 = v123;
    v90 = v124;
    v91 = v125;
    v92 = v126;
    v94 = v128;
    v93 = v127;
    v95 = v129;
    v96 = v130;
    v98 = v132;
    v97 = v131;
    v99 = v133;
    v69 = sub_100012C44(&qword_100406728);
    v76 = sub_1000AF3EC((uint64_t)&v80, v12, v69);
    v80 = v134;
    v81 = v135;
    v82 = v136;
    v83 = v137;
    v84 = v138;
    v85 = v139;
    v86 = v140;
    v87 = v141;
    v67 = sub_100012C44(&qword_100406730);
    v15 = sub_1000AF3EC((uint64_t)&v80, v12, v67);
    v64 = UInt8._bridgeToObjectiveC()().super.super.isa;
    v73 = UInt8._bridgeToObjectiveC()().super.super.isa;
    v72 = UInt8._bridgeToObjectiveC()().super.super.isa;
    v71 = UInt32._bridgeToObjectiveC()().super.super.isa;
    v70 = UInt32._bridgeToObjectiveC()().super.super.isa;
    v68 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v66 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v16.super.super.isa = UInt64._bridgeToObjectiveC()().super.super.isa;
    v63 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v62 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v61 = UInt64._bridgeToObjectiveC()().super.super.isa;
    sub_1000644C8(0, (unint64_t *)&unk_10040D320, NSNumber_ptr);
    v17.super.super.isa = NSNumber.init(integerLiteral:)(0).super.super.isa;
    v60 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v59 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v58 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v57 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v18.super.super.isa = UInt64._bridgeToObjectiveC()().super.super.isa;
    if (__CFADD__((_QWORD)v106, *((_QWORD *)&v108 + 1)))
      __break(1u);
    v54 = v18.super.super.isa;
    v55 = v15;
    v53 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v52 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v51 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v50 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v49 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v48 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v47 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v46 = UInt64._bridgeToObjectiveC()().super.super.isa;
    v45 = UInt32._bridgeToObjectiveC()().super.super.isa;
    v43 = UInt32._bridgeToObjectiveC()().super.super.isa;
    v42 = UInt32._bridgeToObjectiveC()().super.super.isa;
    v41 = UInt32._bridgeToObjectiveC()().super.super.isa;
    v39 = UInt32._bridgeToObjectiveC()().super.super.isa;
    v56 = 0;
    v44 = v16.super.super.isa;
    v19 = v113[8];
    v20 = sub_100012C44(&qword_100403E88);
    v21 = swift_allocObject(v20, 34, 7);
    v40 = v17.super.super.isa;
    v22 = v21;
    *(_OWORD *)(v21 + 16) = xmmword_10033C020;
    *(_WORD *)(v21 + 32) = v19;
    *(_QWORD *)&v80 = v21;
    v23 = (uint64_t)v65;
    static String.Encoding.utf8.getter(v21);
    v24 = sub_100012C44(&qword_100406738);
    v25 = sub_100011770((unint64_t *)&qword_100406740, &qword_100406738, (const char *)&protocol conformance descriptor for [A]);
    v26 = String.init<A>(bytes:encoding:)(&v80, v23, v24, v25);
    v28 = v27;
    swift_bridgeObjectRelease(v22);
    if (v28)
      v29 = v26;
    else
      v29 = 0;
    v65 = (char *)v29;
    v30 = 0xE000000000000000;
    if (v28)
      v30 = v28;
    v38 = v30;
    v80 = v190;
    v81 = v191;
    v82 = v192;
    v83 = v193;
    v84 = v194;
    v85 = v195;
    v86 = v196;
    v87 = v197;
    v88 = v198;
    v89 = v199;
    v31 = sub_100012C44(&qword_100406748);
    v37 = sub_1000AF3EC((uint64_t)&v80, v12, v31);
    v80 = v162;
    v81 = v163;
    v82 = v164;
    v83 = v165;
    v84 = v166;
    v85 = v167;
    v86 = v168;
    v87 = v169;
    v88 = v170;
    v89 = v171;
    v90 = v172;
    v91 = v173;
    v92 = v174;
    v94 = v176;
    v93 = v175;
    v95 = v177;
    v96 = v178;
    v98 = v180;
    v97 = v179;
    v99 = v181;
    v32 = v69;
    v36 = sub_1000AF3EC((uint64_t)&v80, v12, v69);
    v80 = v142;
    v81 = v143;
    v82 = v144;
    v83 = v145;
    v84 = v146;
    v85 = v147;
    v86 = v148;
    v87 = v149;
    v88 = v150;
    v89 = v151;
    v90 = v152;
    v91 = v153;
    v92 = v154;
    v94 = v156;
    v93 = v155;
    v95 = v157;
    v96 = v158;
    v98 = v160;
    v97 = v159;
    v99 = v161;
    v33 = sub_1000AF3EC((uint64_t)&v80, v12, v32);
    v80 = v182;
    v81 = v183;
    v82 = v184;
    v83 = v185;
    v84 = v186;
    v85 = v187;
    v86 = v188;
    v87 = v189;
    v34 = sub_1000AF3EC((uint64_t)&v80, v12, v67);
    v35 = objc_allocWithZone((Class)WiFiAwareDataSessionStatisticsReport);
    return sub_1000B1404(v74, isa, v76, v55, v64, v73, v72, v71, v70, v68, v66, v44, v63, v62, v61, 0, v40, v60, v59,
             v58,
             v57,
             v54,
             v53,
             v52,
             v51,
             v50,
             v49,
             v48,
             v47,
             v46,
             v45,
             v43,
             v42,
             v41,
             v39,
             (uint64_t)v65,
             v38,
             v37,
             v36,
             v33,
             v34);
  }
  return result;
}

double static InfraStatistics.none.getter@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  *a1 = 0u;
  return result;
}

uint64_t sub_1000A9CDC(uint64_t a1)
{
  return sub_1000A9CFC(a1);
}

uint64_t sub_1000A9CFC(uint64_t result)
{
  uint8x8_t v1;
  unint64_t v2;
  uint64_t v3;
  int64_t v4;
  uint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  char v11;
  char v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  _BYTE *v17;
  _BYTE *v18;
  __int16 v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  char *v29;
  __n128 v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  _BYTE v36[20];
  __int128 v37;
  __int128 v38;
  uint64_t v39;
  char v40;
  _OWORD v41[4];

  v2 = *(_QWORD *)(result + 16);
  if (v2)
  {
    v3 = result;
    v32 = v2 - 8;
    v33 = *(_QWORD *)(result + 16);
    if (v2 >= 8)
      v4 = 8;
    else
      v4 = *(_QWORD *)(result + 16);
    memset(v41, 0, 61);
    BYTE4(v41[0]) = v4;
    v31 = result + 32;
    *(_QWORD *)v36 = _swiftEmptyArrayStorage;
    swift_bridgeObjectRetain(result);
    sub_1000750B0(0, v4, 0);
    v5 = 0;
    v6 = _swiftEmptyArrayStorage;
    v7 = _swiftEmptyArrayStorage[2];
    v8 = 7 * v7;
    v9 = 7 * v4;
    do
    {
      v1.i32[0] = *(_DWORD *)(v3 + v5 + 32);
      v10 = *(_BYTE *)(v3 + v5 + 36);
      v11 = *(_BYTE *)(v3 + v5 + 37);
      v12 = *(_BYTE *)(v3 + v5 + 38);
      *(_QWORD *)v36 = v6;
      v13 = v6[3];
      v14 = v7 + 1;
      if (v7 >= v13 >> 1)
      {
        sub_1000750B0(v13 > 1, v7 + 1, 1);
        v6 = *(_QWORD **)v36;
      }
      v6[2] = v14;
      v15 = (char *)v6 + v8 + v5;
      *((_DWORD *)v15 + 8) = vmovn_s16((int16x8_t)vmovl_u8(v1)).u32[0];
      v15[36] = v10;
      v15[37] = v11;
      v15[38] = v12;
      v5 += 7;
      v7 = v14;
    }
    while (v9 != v5);
    swift_bridgeObjectRelease(v3);
    v16 = v6[2];
    if (v16)
    {
      v17 = (char *)v6 + 38;
      v18 = (_BYTE *)((unint64_t)v41 | 0xB);
      do
      {
        v19 = *((_WORD *)v17 - 1);
        v20 = *v17;
        *(_DWORD *)(v18 - 6) = *(_DWORD *)(v17 - 6);
        *((_WORD *)v18 - 1) = v19;
        *v18 = v20;
        v18 += 7;
        v17 += 7;
        --v16;
      }
      while (v16);
    }
    swift_bridgeObjectRelease(v6);
    *(_DWORD *)v36 = v41[0];
    *(_OWORD *)&v36[4] = *(_OWORD *)((char *)v41 + 4);
    v37 = *(_OWORD *)((char *)&v41[1] + 4);
    v38 = *(_OWORD *)((char *)&v41[2] + 4);
    v39 = *(_QWORD *)((char *)&v41[3] + 4);
    v40 = BYTE12(v41[3]);
    v21 = v34[5];
    v22 = v34[2];
    v23 = v34[3];
    swift_retain();
    swift_bridgeObjectRetain(v23);
    AppleDevice.setRequest(requestType:data:on:)(0x16FuLL, (uint64_t)v36, (uint64_t)v41, 0, v22, v23);
    swift_bridgeObjectRelease(v23);
    result = swift_release(v21);
    if (!v35 && v33 >= 9)
    {
      v24 = type metadata accessor for __ContiguousArrayStorageBase(0);
      v25 = swift_bridgeObjectRetain(v3);
      v26 = swift_unknownObjectRetain_n(v25, 2);
      v27 = (_QWORD *)swift_dynamicCastClass(v26, v24);
      if (!v27)
      {
        swift_bridgeObjectRelease(v3);
        v27 = _swiftEmptyArrayStorage;
      }
      v28 = v27[2];
      swift_release(v27);
      if (v28 == v32)
      {
        v29 = (char *)swift_dynamicCastClass(v3, v24);
        if (!v29)
        {
          swift_bridgeObjectRelease(v3);
          v29 = (char *)_swiftEmptyArrayStorage;
        }
      }
      else
      {
        swift_bridgeObjectRelease(v3);
        v29 = sub_10008C98C(v3, v31, 8, (2 * v33) | 1);
      }
      v30 = swift_bridgeObjectRelease(v3);
      sub_1000A9CFC(v29, v30);
      return swift_release(v29);
    }
  }
  return result;
}

uint64_t IO80211Driver<>.received(keepAliveDatapathIdentifiers:)(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint8x8_t v5;
  unint64_t v6;
  uint64_t v7;
  int64_t v8;
  uint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  char v15;
  char v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  _BYTE *v21;
  _BYTE *v22;
  __int16 v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  char *v36;
  __n128 v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  _BYTE v44[20];
  __int128 v45;
  __int128 v46;
  uint64_t v47;
  char v48;
  _OWORD v49[4];

  v6 = *(_QWORD *)(result + 16);
  if (v6)
  {
    v7 = result;
    v39 = v6 - 8;
    v40 = *(_QWORD *)(result + 16);
    if (v6 >= 8)
      v8 = 8;
    else
      v8 = *(_QWORD *)(result + 16);
    memset(v49, 0, 61);
    BYTE4(v49[0]) = v8;
    v38 = result + 32;
    *(_QWORD *)v44 = _swiftEmptyArrayStorage;
    swift_bridgeObjectRetain(result);
    sub_1000750B0(0, v8, 0);
    v9 = 0;
    v10 = _swiftEmptyArrayStorage;
    v11 = _swiftEmptyArrayStorage[2];
    v12 = 7 * v11;
    v13 = 7 * v8;
    do
    {
      v5.i32[0] = *(_DWORD *)(v7 + v9 + 32);
      v14 = *(_BYTE *)(v7 + v9 + 36);
      v15 = *(_BYTE *)(v7 + v9 + 37);
      v16 = *(_BYTE *)(v7 + v9 + 38);
      *(_QWORD *)v44 = v10;
      v17 = v10[3];
      v18 = v11 + 1;
      if (v11 >= v17 >> 1)
      {
        sub_1000750B0(v17 > 1, v11 + 1, 1);
        v10 = *(_QWORD **)v44;
      }
      v10[2] = v18;
      v19 = (char *)v10 + v12 + v9;
      *((_DWORD *)v19 + 8) = vmovn_s16((int16x8_t)vmovl_u8(v5)).u32[0];
      v19[36] = v14;
      v19[37] = v15;
      v19[38] = v16;
      v9 += 7;
      v11 = v18;
    }
    while (v13 != v9);
    swift_bridgeObjectRelease(v7);
    v20 = v10[2];
    if (v20)
    {
      v21 = (char *)v10 + 38;
      v22 = (_BYTE *)((unint64_t)v49 | 0xB);
      do
      {
        v23 = *((_WORD *)v21 - 1);
        v24 = *v21;
        *(_DWORD *)(v22 - 6) = *(_DWORD *)(v21 - 6);
        *((_WORD *)v22 - 1) = v23;
        *v22 = v24;
        v22 += 7;
        v21 += 7;
        --v20;
      }
      while (v20);
    }
    swift_bridgeObjectRelease(v10);
    *(_DWORD *)v44 = v49[0];
    *(_OWORD *)&v44[4] = *(_OWORD *)((char *)v49 + 4);
    v45 = *(_OWORD *)((char *)&v49[1] + 4);
    v46 = *(_OWORD *)((char *)&v49[2] + 4);
    v47 = *(_QWORD *)((char *)&v49[3] + 4);
    v48 = BYTE12(v49[3]);
    type metadata accessor for apple80211_nan_keep_alive_dp_identifer(0);
    v26 = v25;
    v27 = *(_QWORD *)(a3 + 8);
    v28 = *(_QWORD *)(a4 + 16);
    AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v27, a2, &protocol requirements base descriptor for DeviceDriver);
    AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, a2, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
    result = sub_1000AC020(367, (uint64_t)v44, a2, v26, v27, v28, AssociatedConformanceWitness);
    if (!v4 && v40 >= 9)
    {
      v31 = type metadata accessor for __ContiguousArrayStorageBase(0);
      v32 = swift_bridgeObjectRetain(v7);
      v33 = swift_unknownObjectRetain_n(v32, 2);
      v34 = (_QWORD *)swift_dynamicCastClass(v33, v31);
      if (!v34)
      {
        swift_bridgeObjectRelease(v7);
        v34 = _swiftEmptyArrayStorage;
      }
      v35 = v34[2];
      swift_release(v34);
      if (v35 == v39)
      {
        v36 = (char *)swift_dynamicCastClass(v7, v31);
        if (!v36)
        {
          swift_bridgeObjectRelease(v7);
          v36 = (char *)_swiftEmptyArrayStorage;
        }
      }
      else
      {
        swift_bridgeObjectRelease(v7);
        v36 = sub_10008C98C(v7, v38, 8, (2 * v40) | 1);
      }
      v37 = swift_bridgeObjectRelease(v7);
      (*(void (**)(char *, uint64_t, uint64_t, __n128))(a4 + 360))(v36, a2, a4, v37);
      return swift_release(v36);
    }
  }
  return result;
}

void sub_1000AA370(uint64_t *a1@<X0>, char a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v5;
  uint64_t v10;
  uint64_t v11;

  v10 = *a1;
  v11 = swift_allocObject(v5, *(unsigned int *)(v5 + 48), *(unsigned __int16 *)(v5 + 52));
  AppleIO80211Driver.init(device:role:name:)(v10, a2, a3, a4);
  *a5 = v11;
}

uint64_t sub_1000AA3D8@<X0>(_QWORD *a1@<X8>)
{
  uint64_t v1;
  uint64_t v2;

  v2 = *(_QWORD *)(*(_QWORD *)v1 + 40);
  *a1 = v2;
  return swift_retain(v2);
}

uint64_t sub_1000AA3E8@<X0>(uint64_t *a1@<X8>)
{
  _QWORD *v1;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _BYTE v8[24];

  v3 = (_QWORD *)*v1;
  swift_beginAccess(v3 + 6, v8, 0, 0);
  v4 = v3[6];
  v5 = v3[7];
  v6 = v3[8];
  *a1 = v4;
  a1[1] = v5;
  a1[2] = v6;
  return sub_1000B5380(v4, v5, v6);
}

uint64_t sub_1000AA438(__int128 *a1)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v8;
  _BYTE v9[24];

  v8 = *a1;
  v2 = *((_QWORD *)a1 + 2);
  v3 = (_QWORD *)*v1;
  swift_beginAccess(v3 + 6, v9, 1, 0);
  v4 = v3[6];
  v5 = v3[7];
  v6 = v3[8];
  *((_OWORD *)v3 + 3) = v8;
  v3[8] = v2;
  return sub_1000B53AC(v4, v5, v6);
}

void *sub_1000AA494(uint64_t a1)
{
  _QWORD *v1;

  swift_beginAccess(*v1 + 48, a1, 33, 0);
  return &j_j__swift_endAccess;
}

_QWORD *sub_1000AA4D4()
{
  return AppleIO80211Driver.capabilities.getter();
}

uint64_t sub_1000AA4F4(uint64_t *a1)
{
  return sub_1000AA528(*a1, (_QWORD *(*)(uint64_t *__return_ptr, _QWORD *))sub_10000642C, (_QWORD *(*)(uint64_t *__return_ptr, _QWORD *))sub_10000642C);
}

uint64_t sub_1000AA528(uint64_t a1, _QWORD *(*a2)(uint64_t *__return_ptr, _QWORD *), _QWORD *(*a3)(uint64_t *__return_ptr, _QWORD *))
{
  _QWORD *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v9;
  uint64_t v10;
  uint64_t KeyPath;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _BYTE v21[16];
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD v25[3];
  _QWORD v26[3];

  if (*(_BYTE *)(a1 + 32) == 4)
  {
    memset(v26, 0, sizeof(v26));
    v9 = *(_QWORD *)(a1 + 16);
    v10 = *(_QWORD *)(a1 + 24);
    KeyPath = swift_getKeyPath(&unk_10033F3D8);
    v22 = v26;
    v23 = __chkstk_darwin();
    v24 = 16;
    swift_bridgeObjectRetain(v10);
    sub_100047824(a2, (uint64_t)v21, v9, v10);
    swift_bridgeObjectRelease(v10);
    swift_release(KeyPath);
    v25[0] = v26[0];
    *(_OWORD *)&v25[1] = *(_OWORD *)&v26[1];
    v12 = (char *)v26;
    v13 = v3[5];
    v14 = v3[2];
    v15 = v3[3];
    swift_retain();
    swift_bridgeObjectRetain(v15);
    v16 = 293;
  }
  else
  {
    if (!*(_BYTE *)(a1 + 32))
    {
      v4 = sub_100012C84();
      v5 = swift_allocError(&type metadata for WiFiError, v4, 0, 0);
      *(_OWORD *)v6 = xmmword_10033B180;
      *(_BYTE *)(v6 + 16) = 0;
      return swift_willThrow(v5);
    }
    memset(v26, 0, 20);
    v18 = *(_QWORD *)(a1 + 16);
    v19 = *(_QWORD *)(a1 + 24);
    v20 = swift_getKeyPath(&unk_10033F3B8);
    v22 = v26;
    v23 = __chkstk_darwin();
    v24 = 16;
    swift_bridgeObjectRetain(v19);
    sub_100047824(a3, (uint64_t)v21, v18, v19);
    swift_bridgeObjectRelease(v19);
    swift_release(v20);
    LODWORD(v25[0]) = v26[0];
    *(_OWORD *)((char *)v25 + 4) = *(_OWORD *)((char *)v26 + 4);
    v12 = (char *)&v25[2] + 4;
    v13 = v3[5];
    v14 = v3[2];
    v15 = v3[3];
    swift_retain();
    swift_bridgeObjectRetain(v15);
    v16 = 95;
  }
  AppleDevice.setRequest(requestType:data:on:)(v16, (uint64_t)v25, (uint64_t)v12, 0, v14, v15);
  swift_bridgeObjectRelease(v15);
  return swift_release(v13);
}

uint64_t DeviceDriver<>.destroyInterface(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  int v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t KeyPath;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _BYTE v28[16];
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD v32[3];
  _QWORD v33[3];
  uint64_t v34;

  v6 = v5;
  v11 = (*(unsigned __int8 (**)(uint64_t, uint64_t))(a4 + 32))(a2, a4);
  if (v11 == 4)
  {
    memset(v33, 0, sizeof(v33));
    v16 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 40))(a2, a4);
    v18 = v17;
    KeyPath = swift_getKeyPath(&unk_10033F3D8);
    v34 = v6;
    v29 = v33;
    v30 = __chkstk_darwin();
    v31 = 16;
    sub_100047824((_QWORD *(*)(uint64_t *__return_ptr, _QWORD *))sub_10000642C, (uint64_t)v28, v16, v18);
    swift_bridgeObjectRelease(v18);
    swift_release(KeyPath);
    v32[0] = v33[0];
    *(_OWORD *)&v32[1] = *(_OWORD *)&v33[1];
    type metadata accessor for apple80211_companion_skywalk_if_create(0);
    v21 = v20;
    v22 = 293;
  }
  else
  {
    if (!v11)
    {
      v12 = sub_100012C84();
      v13 = swift_allocError(&type metadata for WiFiError, v12, 0, 0);
      *(_OWORD *)v14 = xmmword_10033B180;
      *(_BYTE *)(v14 + 16) = 0;
      return swift_willThrow(v13);
    }
    memset(v33, 0, 20);
    v23 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 40))(a2, a4);
    v25 = v24;
    v26 = swift_getKeyPath(&unk_10033F3B8);
    v34 = v6;
    v29 = v33;
    v30 = __chkstk_darwin();
    v31 = 16;
    sub_100047824((_QWORD *(*)(uint64_t *__return_ptr, _QWORD *))sub_10000642C, (uint64_t)v28, v23, v25);
    swift_bridgeObjectRelease(v25);
    swift_release(v26);
    LODWORD(v32[0]) = v33[0];
    *(_OWORD *)((char *)v32 + 4) = *(_OWORD *)((char *)v33 + 4);
    type metadata accessor for apple80211_virt_if_delete_data(0);
    v21 = v27;
    v22 = 95;
  }
  return sub_1000AC020(v22, (uint64_t)v32, a2, v21, a3, a4, a5);
}

uint64_t sub_1000AA9E4()
{
  uint64_t v0;

  return *(unsigned __int8 *)(*(_QWORD *)v0 + 32);
}

uint64_t sub_1000AA9F0()
{
  uint64_t v0;
  uint64_t v1;

  v1 = *(_QWORD *)(*(_QWORD *)v0 + 16);
  swift_bridgeObjectRetain(*(_QWORD *)(*(_QWORD *)v0 + 24));
  return v1;
}

uint64_t sub_1000AAA20(uint64_t a1, uint64_t a2)
{
  return sub_1000B12AC(a1, a2, (uint64_t (*)(_BYTE *, _BYTE *, _BYTE *))sub_1000B742C);
}

uint64_t DeviceDriver<>.supportedChannels.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v10;
  _BYTE __src[10016];
  _BYTE v12[10016];

  type metadata accessor for apple80211_channels_info(0);
  sub_1000ABF34(207, v8, a1, v8, a2, a3, a4);
  memcpy(v12, __src, sizeof(v12));
  memcpy(__src, v12, sizeof(__src));
  sub_1000AC164((uint64_t)__src, (uint64_t)v12, &v10);
  return v10;
}

uint64_t sub_1000AAB88(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000B6A18(a1 & 0xFFFFFFFFFFFFLL, a2, a3);
}

double IO80211Driver<>.postPeerPresence(macAddress:ipv6Address:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;
  uint64_t v13;
  uint64_t AssociatedTypeWitness;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t, uint64_t);
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void (*v22)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v23;
  double result;
  __n128 v25;
  unsigned __int8 (*v26)(uint64_t, uint64_t, __n128);
  char *v27;
  _QWORD v28[3];
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;

  v33 = a5;
  v30 = a3;
  v31 = a4;
  v28[2] = a8;
  v29 = a2;
  v13 = *(_QWORD *)(a8 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v13, a6, &protocol requirements base descriptor for DeviceDriver);
  v32 = *(_QWORD *)(AssociatedTypeWitness - 8);
  __chkstk_darwin();
  v16 = (char *)v28 - v15;
  (*(void (**)(uint64_t, uint64_t))(v13 + 56))(a6, v13);
  v17 = *(_QWORD *)(a7 + 8);
  v18 = *(uint64_t (**)(uint64_t, uint64_t))(v17 + 40);
  v28[0] = v9;
  v19 = v18(a6, v17);
  v21 = v20;
  v22 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a9 + 24);
  v28[1] = a1;
  v23 = v34;
  v22(a1 & 0xFFFFFFFFFFFFLL, v29, v30, v31, v33, v19, v20, 1, AssociatedTypeWitness, a9);
  if (!v23)
  {
    (*(void (**)(char *, uint64_t))(v32 + 8))(v16, AssociatedTypeWitness);
    v25 = swift_bridgeObjectRelease(v21);
    v26 = *(unsigned __int8 (**)(uint64_t, uint64_t, __n128))(v17 + 32);
    v34 = v17;
    v27 = (char *)&loc_1000AAD54 + 4 * byte_10033F07E[v26(a6, v17, v25)];
    __asm { BR              X10 }
  }
  (*(void (**)(char *, uint64_t))(v32 + 8))(v16, AssociatedTypeWitness);
  *(_QWORD *)&result = swift_bridgeObjectRelease(v21).n128_u64[0];
  return result;
}

double sub_1000AAE90(uint64_t a1, uint64_t a2)
{
  return sub_1000AAEB8(a1, a2, (uint64_t (*)(_QWORD *))sub_1000B7454);
}

double sub_1000AAEB8(uint64_t a1, uint64_t a2, uint64_t (*a3)(_QWORD *))
{
  double result;
  _QWORD v5[6];
  uint64_t v6;

  v5[4] = 0x3D67736D2D2069;
  v5[5] = 0xE700000000000000;
  String.append(_:)(*(Swift::String *)&a1);
  v5[2] = &v6;
  sub_100047AAC(a3, (uint64_t)v5, 0x3D67736D2D2069, 0xE700000000000000, &v6);
  *(_QWORD *)&result = swift_bridgeObjectRelease(0xE700000000000000).n128_u64[0];
  return result;
}

double DeviceDriver<>.triggerCoreCapture(reason:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  _QWORD *v11;
  double result;
  _QWORD v13[6];
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;

  v15 = 0x3D67736D2D2069;
  v16 = 0xE700000000000000;
  String.append(_:)(*(Swift::String *)&a1);
  v13[2] = a3;
  v13[3] = a4;
  v13[4] = a5;
  v13[5] = a6;
  v14 = v6;
  sub_100047AAC((uint64_t (*)(_QWORD *))sub_1000B65F4, (uint64_t)v13, 0x3D67736D2D2069, 0xE700000000000000, v11);
  *(_QWORD *)&result = swift_bridgeObjectRelease(0xE700000000000000).n128_u64[0];
  return result;
}

_QWORD *sub_1000AAFE4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1000B13C8(a1, a2, a3, a4, (uint64_t (*)(_QWORD *))sub_1000B7440);
}

_QWORD *DeviceDriver<>.triggerWiFiChipReset(reason:)(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  _QWORD v7[6];

  v7[2] = a3;
  v7[3] = a4;
  v7[4] = a5;
  v7[5] = a6;
  return sub_100047AAC((uint64_t (*)(_QWORD *))sub_1000B6614, (uint64_t)v7, a1, (uint64_t)a2, a2);
}

uint64_t sub_1000AB044@<X0>(uint64_t a1@<X8>)
{
  _QWORD *v1;
  uint64_t v3;
  uint64_t v4;

  v3 = *v1 + OBJC_IVAR____TtC7CoreP2P18AppleIO80211Driver_logger;
  v4 = type metadata accessor for Logger(0);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 - 8) + 16))(a1, v3, v4);
}

void AppleIO80211Driver.description.getter()
{
  _StringGuts.grow(_:)(21);
  swift_bridgeObjectRelease(0xE000000000000000);
  __asm { BR              X10 }
}

uint64_t sub_1000AB120()
{
  uint64_t v0;
  Swift::String v1;
  Swift::String v2;
  void *v3;
  uint64_t v4;
  Swift::String v5;
  Swift::String v6;
  uint64_t v8;

  v1._countAndFlagsBits = 1279547201;
  v1._object = (void *)0xE400000000000000;
  String.append(_:)(v1);
  swift_bridgeObjectRelease(0xE400000000000000);
  v2._countAndFlagsBits = 8250;
  v2._object = (void *)0xE200000000000000;
  String.append(_:)(v2);
  v4 = *(_QWORD *)(v0 + 16);
  v3 = *(void **)(v0 + 24);
  swift_bridgeObjectRetain(v3);
  v5._countAndFlagsBits = v4;
  v5._object = v3;
  String.append(_:)(v5);
  swift_bridgeObjectRelease(v3);
  v6._countAndFlagsBits = 93;
  v6._object = (void *)0xE100000000000000;
  String.append(_:)(v6);
  return v8;
}

void sub_1000AB1E4()
{
  AppleIO80211Driver.description.getter();
}

uint64_t sub_1000AB204(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t AssociatedTypeWitness;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;
  uint64_t v21;

  v20 = a2;
  v21 = a3;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a5, a4, &protocol requirements base descriptor for DeviceDriver, &associated type descriptor for DeviceDriver.Device);
  v13 = *(_QWORD *)(AssociatedTypeWitness - 8);
  __chkstk_darwin(AssociatedTypeWitness);
  v15 = (char *)&v20 - v14;
  (*(void (**)(uint64_t, uint64_t))(a5 + 56))(a4, a5);
  v16 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 40))(a4, a6);
  v18 = v17;
  (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t))(a7 + 24))(a1, v20, v21, 0, v16, v17, AssociatedTypeWitness, a7);
  (*(void (**)(char *, uint64_t))(v13 + 8))(v15, AssociatedTypeWitness);
  return swift_bridgeObjectRelease(v18);
}

uint64_t sub_1000AB320(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t AssociatedTypeWitness;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;
  uint64_t v21;

  v20 = a2;
  v21 = a3;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a5, a4, &protocol requirements base descriptor for DeviceDriver, &associated type descriptor for DeviceDriver.Device);
  v13 = *(_QWORD *)(AssociatedTypeWitness - 8);
  __chkstk_darwin(AssociatedTypeWitness);
  v15 = (char *)&v20 - v14;
  (*(void (**)(uint64_t, uint64_t))(a5 + 56))(a4, a5);
  v16 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 40))(a4, a6);
  v18 = v17;
  (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t))(a7 + 32))(a1, v20, v21, 0, v16, v17, AssociatedTypeWitness, a7);
  (*(void (**)(char *, uint64_t))(v13 + 8))(v15, AssociatedTypeWitness);
  return swift_bridgeObjectRelease(v18);
}

uint64_t sub_1000AB43C(unint64_t a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = v2;
  v5 = swift_slowAlloc(12, -1);
  *(_QWORD *)v5 = 0;
  *(_DWORD *)(v5 + 8) = 0;
  v6 = v1[5];
  v7 = v1[2];
  v8 = v1[3];
  swift_retain();
  swift_bridgeObjectRetain(v8);
  AppleDevice.getRequest(requestType:data:on:)(a1, v5, v5 + 12, 0, v7, v8);
  swift_bridgeObjectRelease(v8);
  swift_release(v6);
  if (!v2)
    v3 = *(_QWORD *)v5;
  swift_slowDealloc(v5, -1, -1);
  return v3;
}

uint64_t sub_1000AB51C(unint64_t a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = v2;
  v5 = (uint64_t *)swift_slowAlloc(24, -1);
  v5[1] = 0;
  v5[2] = 0;
  *v5 = 0;
  v6 = v1[5];
  v7 = v1[2];
  v8 = v1[3];
  swift_retain();
  swift_bridgeObjectRetain(v8);
  AppleDevice.getRequest(requestType:data:on:)(a1, (uint64_t)v5, (uint64_t)(v5 + 3), 0, v7, v8);
  swift_bridgeObjectRelease(v8);
  swift_release(v6);
  if (!v2)
    v3 = *v5;
  swift_slowDealloc(v5, -1, -1);
  return v3;
}

uint64_t sub_1000AB604(unint64_t a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = v2;
  v5 = swift_slowAlloc(12, -1);
  *(_QWORD *)v5 = 0;
  *(_DWORD *)(v5 + 8) = 0;
  v6 = v1[5];
  v7 = v1[2];
  v8 = v1[3];
  swift_retain();
  swift_bridgeObjectRetain(v8);
  AppleDevice.getRequest(requestType:data:on:)(a1, v5, v5 + 12, 0, v7, v8);
  swift_bridgeObjectRelease(v8);
  swift_release(v6);
  if (!v2)
    v3 = *(_QWORD *)v5;
  swift_slowDealloc(v5, -1, -1);
  return v3;
}

uint64_t sub_1000AB6E4@<X0>(unint64_t a1@<X0>, void *a2@<X8>)
{
  _QWORD *v2;
  uint64_t v3;
  _OWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v6 = (_OWORD *)swift_slowAlloc(400, -1);
  *v6 = 0u;
  v6[1] = 0u;
  v6[2] = 0u;
  v6[3] = 0u;
  v6[4] = 0u;
  v6[5] = 0u;
  v6[6] = 0u;
  v6[7] = 0u;
  v6[8] = 0u;
  v6[9] = 0u;
  v6[10] = 0u;
  v6[11] = 0u;
  v6[12] = 0u;
  v6[13] = 0u;
  v6[14] = 0u;
  v6[15] = 0u;
  v6[16] = 0u;
  v6[17] = 0u;
  v6[18] = 0u;
  v6[19] = 0u;
  v6[20] = 0u;
  v6[21] = 0u;
  v6[22] = 0u;
  v6[23] = 0u;
  v6[24] = 0u;
  v7 = v2[5];
  v8 = v2[2];
  v9 = v2[3];
  swift_retain();
  swift_bridgeObjectRetain(v9);
  AppleDevice.getRequest(requestType:data:on:)(a1, (uint64_t)v6, (uint64_t)(v6 + 25), 0, v8, v9);
  swift_bridgeObjectRelease(v9);
  swift_release(v7);
  if (!v3)
    memcpy(a2, v6, 0x190uLL);
  return swift_slowDealloc(v6, -1, -1);
}

uint64_t sub_1000AB7E4(unint64_t a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = v2;
  v5 = (uint64_t *)swift_slowAlloc(8, -1);
  *v5 = 0;
  v6 = v1[5];
  v7 = v1[2];
  v8 = v1[3];
  swift_retain();
  swift_bridgeObjectRetain(v8);
  AppleDevice.getRequest(requestType:data:on:)(a1, (uint64_t)v5, (uint64_t)(v5 + 1), 0, v7, v8);
  swift_bridgeObjectRelease(v8);
  swift_release(v6);
  if (!v2)
    v3 = *v5;
  swift_slowDealloc(v5, -1, -1);
  return v3;
}

uint64_t sub_1000AB8A4@<X0>(unint64_t a1@<X0>, void *a2@<X8>)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v4 = v3;
  v7 = (void *)swift_slowAlloc(3712, -1);
  bzero(v7, 0xE80uLL);
  v8 = v2[5];
  v9 = v2[2];
  v10 = v2[3];
  swift_retain();
  swift_bridgeObjectRetain(v10);
  AppleDevice.getRequest(requestType:data:on:)(a1, (uint64_t)v7, (uint64_t)v7 + 3712, 0, v9, v10);
  swift_bridgeObjectRelease(v10);
  swift_release(v8);
  if (!v4)
    memcpy(a2, v7, 0xE80uLL);
  return swift_slowDealloc(v7, -1, -1);
}

uint64_t sub_1000AB974@<X0>(unint64_t a1@<X0>, void *a2@<X8>)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v4 = v3;
  v7 = (void *)swift_slowAlloc(4000, -1);
  bzero(v7, 0xFA0uLL);
  v8 = v2[5];
  v9 = v2[2];
  v10 = v2[3];
  swift_retain();
  swift_bridgeObjectRetain(v10);
  AppleDevice.getRequest(requestType:data:on:)(a1, (uint64_t)v7, (uint64_t)v7 + 4000, 0, v9, v10);
  swift_bridgeObjectRelease(v10);
  swift_release(v8);
  if (!v4)
    memcpy(a2, v7, 0xFA0uLL);
  return swift_slowDealloc(v7, -1, -1);
}

uint64_t sub_1000ABA44@<X0>(unint64_t a1@<X0>, uint64_t a2@<X8>)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v6 = swift_slowAlloc(12, -1);
  *(_QWORD *)v6 = 0;
  *(_DWORD *)(v6 + 8) = 0;
  v7 = v2[5];
  v8 = v2[2];
  v9 = v2[3];
  swift_retain();
  swift_bridgeObjectRetain(v9);
  AppleDevice.getRequest(requestType:data:on:)(a1, v6, v6 + 12, 0, v8, v9);
  swift_bridgeObjectRelease(v9);
  swift_release(v7);
  if (!v3)
  {
    *(_QWORD *)a2 = *(_QWORD *)v6;
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(v6 + 8);
  }
  return swift_slowDealloc(v6, -1, -1);
}

uint64_t sub_1000ABB14(unint64_t a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _WORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = v2;
  v5 = (_WORD *)swift_slowAlloc(2, -1);
  *v5 = 0;
  v6 = v1[5];
  v7 = v1[2];
  v8 = v1[3];
  swift_retain();
  swift_bridgeObjectRetain(v8);
  AppleDevice.getRequest(requestType:data:on:)(a1, (uint64_t)v5, (uint64_t)(v5 + 1), 0, v7, v8);
  swift_bridgeObjectRelease(v8);
  swift_release(v6);
  if (!v2)
    v3 = (unsigned __int16)*v5;
  swift_slowDealloc(v5, -1, -1);
  return v3;
}

uint64_t sub_1000ABBE8(unint64_t a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _BYTE *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = v2;
  v5 = (_BYTE *)swift_slowAlloc(1, -1);
  *v5 = 0;
  v6 = v1[5];
  v7 = v1[2];
  v8 = v1[3];
  swift_retain();
  swift_bridgeObjectRetain(v8);
  AppleDevice.getRequest(requestType:data:on:)(a1, (uint64_t)v5, (uint64_t)(v5 + 1), 0, v7, v8);
  swift_bridgeObjectRelease(v8);
  swift_release(v6);
  if (!v2)
    v3 = *v5;
  swift_slowDealloc(v5, -1, -1);
  return v3;
}

uint64_t sub_1000ABCA8(unint64_t a1)
{
  _QWORD *v1;
  uint64_t v2;
  unsigned __int16 *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v9;
  int v10;

  v4 = (unsigned __int16 *)swift_slowAlloc(3, -1);
  *v4 = 0;
  *((_BYTE *)v4 + 2) = 0;
  v5 = v1[5];
  v6 = v1[2];
  v7 = v1[3];
  swift_retain();
  swift_bridgeObjectRetain(v7);
  AppleDevice.getRequest(requestType:data:on:)(a1, (uint64_t)v4, (uint64_t)v4 + 3, 0, v6, v7);
  swift_bridgeObjectRelease(v7);
  swift_release(v5);
  if (v2)
    return swift_slowDealloc(v4, -1, -1);
  v9 = *((unsigned __int8 *)v4 + 2);
  v10 = *v4;
  swift_slowDealloc(v4, -1, -1);
  return v10 | (v9 << 16);
}

uint64_t sub_1000ABD84(unint64_t a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = v2;
  v5 = (_QWORD *)swift_slowAlloc(16, -1);
  *v5 = 0;
  v5[1] = 0;
  v6 = v1[5];
  v7 = v1[2];
  v8 = v1[3];
  swift_retain();
  swift_bridgeObjectRetain(v8);
  AppleDevice.getRequest(requestType:data:on:)(a1, (uint64_t)v5, (uint64_t)(v5 + 2), 0, v7, v8);
  swift_bridgeObjectRelease(v8);
  swift_release(v6);
  if (!v2)
    v3 = *(unsigned int *)v5;
  swift_slowDealloc(v5, -1, -1);
  return v3;
}

uint64_t sub_1000ABE60@<X0>(unint64_t a1@<X0>, void *a2@<X8>)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v4 = v3;
  v7 = (void *)swift_slowAlloc(10016, -1);
  bzero(v7, 0x2720uLL);
  v8 = v2[5];
  v9 = v2[2];
  v10 = v2[3];
  swift_retain();
  swift_bridgeObjectRetain(v10);
  AppleDevice.getRequest(requestType:data:on:)(a1, (uint64_t)v7, (uint64_t)v7 + 10016, 0, v9, v10);
  swift_bridgeObjectRelease(v10);
  swift_release(v8);
  if (!v4)
    memcpy(a2, v7, 0x2720uLL);
  return swift_slowDealloc(v7, -1, -1);
}

uint64_t sub_1000ABF34(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  size_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v22;

  v12 = *(_QWORD *)(a4 - 8);
  v13 = *(unsigned __int8 *)(v12 + 80);
  if (v13 > 0xF)
    v14 = v13 + 1;
  else
    v14 = 0;
  v15 = *(_QWORD *)(v12 + 64);
  v16 = (void *)swift_slowAlloc(v15, v14 - 1);
  v17 = (uint64_t)v16;
  v18 = (uint64_t)v16 + v15;
  if (v15)
    bzero(v16, v15);
  sub_1000AB204(a1, v17, v18, a3, a5, a6, a7);
  if (!v22)
    UnsafeMutableRawBufferPointer.load<A>(fromByteOffset:as:)(0, a2, v17, v18, a4);
  return swift_slowDealloc(v17, -1, -1);
}

uint64_t sub_1000AC020(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v19;
  uint64_t v20;
  _BYTE v21[16];
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  v14 = *(_QWORD *)(a4 - 8);
  __chkstk_darwin();
  v16 = (char *)&v19 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *))(v14 + 16))(v16);
  v22 = a3;
  v23 = a4;
  v24 = a5;
  v25 = a6;
  v26 = a7;
  v27 = v7;
  v28 = a1;
  v17 = sub_100012C44((uint64_t *)&unk_10040C360);
  sub_100177494((uint64_t)v16, (uint64_t)sub_1000B73A0, (uint64_t)v21, a4, v17, (uint64_t)&type metadata for () + 8, (uint64_t)&protocol self-conformance witness table for Error, (uint64_t)&v20);
  return (*(uint64_t (**)(char *, uint64_t))(v14 + 8))(v16, a4);
}

unint64_t CountryCode.apple80211Value.getter(__int16 a1)
{
  return ((unint64_t)a1 << 32) | ((unint64_t)HIBYTE(a1) << 40);
}

uint64_t sub_1000AC164@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  int v3;
  uint64_t v4;
  int v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unsigned int v12;
  unsigned __int16 v13;
  unsigned __int16 v14;

  v3 = *(unsigned __int16 *)(a2 + 12);
  if (*(_WORD *)(a2 + 12))
  {
    v4 = result;
    v5 = 0;
    v6 = _swiftEmptyArrayStorage;
    do
    {
      v14 = v5;
      result = sub_1000AC2BC(&v14, v4, (uint64_t)&v12);
      v8 = v12 | ((unint64_t)v13 << 32);
      if ((v8 & 0xFF00000000) != 0x300000000)
      {
        result = swift_isUniquelyReferenced_nonNull_native(v6);
        if ((result & 1) == 0)
        {
          result = (uint64_t)sub_1000B1E74(0, v6[2] + 1, 1, v6);
          v6 = (_QWORD *)result;
        }
        v10 = v6[2];
        v9 = v6[3];
        if (v10 >= v9 >> 1)
        {
          result = (uint64_t)sub_1000B1E74((_QWORD *)(v9 > 1), v10 + 1, 1, v6);
          v6 = (_QWORD *)result;
        }
        v6[2] = v10 + 1;
        v7 = &v6[v10];
        *((_DWORD *)v7 + 8) = v8;
        *((_BYTE *)v7 + 36) = BYTE4(v8);
        *((_BYTE *)v7 + 37) = BYTE5(v8);
      }
      ++v5;
    }
    while (v5 != v3);
  }
  else
  {
    v6 = _swiftEmptyArrayStorage;
  }
  *a3 = v6;
  return result;
}

unint64_t sub_1000AC2BC@<X0>(unsigned __int16 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  uint64_t KeyPath;
  unint64_t result;
  char v8;
  uint64_t v9;
  uint64_t v10;
  void (*v11)(unsigned __int8 *, unint64_t);
  unsigned int v12;
  uint64_t v13;
  char v14;
  int v15;
  uint64_t v16;
  char v17;
  int v18;
  uint64_t v19;
  char v20;
  int v21;
  unsigned int v22;
  char v23;
  unsigned __int8 v24;
  unsigned __int8 v25;
  unsigned __int8 v26;

  v5 = *a1;
  KeyPath = swift_getKeyPath(&unk_10033F668);
  result = dispatch thunk of AnyKeyPath._storedInlineOffset.getter(KeyPath);
  if ((v8 & 1) != 0)
  {
    __break(1u);
    goto LABEL_13;
  }
  v9 = *(&type metadata for UInt8 - 1);
  v10 = *(_QWORD *)(v9 + 72) * v5;
  v11 = *(void (**)(unsigned __int8 *, unint64_t))(v9 + 16);
  v11(&v26, a2 + result + v10);
  swift_release(KeyPath);
  v12 = v26;
  v13 = swift_getKeyPath(&unk_10033F688);
  result = dispatch thunk of AnyKeyPath._storedInlineOffset.getter(v13);
  if ((v14 & 1) != 0)
  {
LABEL_13:
    __break(1u);
    goto LABEL_14;
  }
  ((void (*)(unsigned __int8 *, unint64_t, _QWORD *))v11)(&v25, a2 + result + v10, &type metadata for UInt8);
  swift_release(v13);
  v15 = v25;
  v16 = swift_getKeyPath(&unk_10033F6A8);
  result = dispatch thunk of AnyKeyPath._storedInlineOffset.getter(v16);
  if ((v17 & 1) != 0)
  {
LABEL_14:
    __break(1u);
    goto LABEL_15;
  }
  ((void (*)(unsigned __int8 *, unint64_t, _QWORD *))v11)(&v24, a2 + result + v10, &type metadata for UInt8);
  swift_release(v16);
  v18 = v24;
  v19 = swift_getKeyPath(&unk_10033F6C8);
  result = dispatch thunk of AnyKeyPath._storedInlineOffset.getter(v19);
  if ((v20 & 1) != 0)
  {
LABEL_15:
    __break(1u);
    return result;
  }
  if (v18)
    v21 = ((v15 != 0) << 8) | 4;
  else
    v21 = (v15 != 0) << 8;
  ((void (*)(char *, unint64_t, _QWORD *))v11)(&v23, a2 + result + v10, &type metadata for UInt8);
  swift_release(v19);
  if (v23)
    v22 = v21 | 0x400;
  else
    v22 = v21;
  result = sub_1000B388C(v12, v22);
  *(_DWORD *)a3 = result;
  *(_WORD *)(a3 + 4) = WORD2(result);
  return result;
}

void sub_1000AC454(uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v8 = 0;
  v3 = sub_100334300(a1, &v8);
  v4 = (uint64_t)v3 + v8;
  v5 = a2[5];
  v6 = a2[2];
  v7 = a2[3];
  swift_retain();
  swift_bridgeObjectRetain(v7);
  AppleDevice.setRequest(requestType:data:on:)(0x9DuLL, (uint64_t)v3, v4, 0, v6, v7);
  swift_bridgeObjectRelease(v7);
  swift_release(v5);
  free(v3);
}

void sub_1000AC52C(uint64_t a1, _QWORD *a2)
{
  char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v8 = 0;
  v3 = sub_100334400(a1, &v8);
  v4 = (uint64_t)&v3[v8];
  v5 = a2[5];
  v6 = a2[2];
  v7 = a2[3];
  swift_retain();
  swift_bridgeObjectRetain(v7);
  AppleDevice.setRequest(requestType:data:on:)(0xEFuLL, (uint64_t)v3, v4, 0, v6, v7);
  swift_bridgeObjectRelease(v7);
  swift_release(v5);
  free(v3);
}

void sub_1000AC604(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t (*a7)(uint64_t, uint64_t *), uint64_t a8)
{
  void *v13;
  uint64_t v14;

  v14 = 0;
  v13 = (void *)a7(a1, &v14);
  sub_1000AB320(a8, (uint64_t)v13, (uint64_t)v13 + v14, a3, a4, a5, a6);
  free(v13);
}

uint64_t sub_1000AC6D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v13;
  char v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  char v19;
  uint64_t v20;
  int v22;
  __int16 v23;
  char v24;
  char v25;
  char v26;
  char v27;
  char v28;
  char v29;
  __int16 v30;
  int v31;
  uint64_t v32;
  char v33;
  char v34;
  __int16 v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  _QWORD v40[4];
  char v41;

  sub_100063EB8(a2, (uint64_t)v40, &qword_100405B20);
  if ((v41 & 1) != 0)
  {
    v13 = 0;
    v14 = 0;
    v15 = 0;
    v17 = v40[0];
    v16 = v40[1];
    v18 = 28;
    v19 = 30;
  }
  else
  {
    v17 = 0;
    v16 = 0;
    v19 = 0;
    v18 = 0;
    v15 = 16;
    v13 = v40[0];
    v14 = 2;
  }
  v22 = 1;
  v23 = a1;
  v24 = BYTE2(a1);
  v25 = BYTE3(a1);
  v26 = BYTE4(a1);
  v27 = BYTE5(a1);
  v28 = v15;
  v29 = v14;
  v30 = 0;
  v31 = v13;
  v32 = 0;
  v33 = v18;
  v34 = v19;
  v35 = 0;
  v36 = 0;
  v37 = v17;
  v38 = v16;
  v39 = 0;
  type metadata accessor for apple80211_infra_peer_address_data(0);
  return sub_1000AC020(a3, (uint64_t)&v22, a4, v20, a5, *(_QWORD *)(a6 + 16), a7);
}

uint64_t sub_1000AC80C@<X0>(uint64_t *a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X5>, uint64_t a6@<X7>, uint64_t a7@<X8>, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char v23;
  uint64_t TupleTypeMetadata2;
  _QWORD v26[11];
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;

  v26[7] = a6;
  v32 = a3;
  v28 = a8;
  v29 = a2;
  v11 = *a1;
  v12 = *a2;
  v13 = type metadata accessor for Optional(0, a5);
  v26[4] = *(_QWORD *)(v13 - 8);
  v26[5] = v13;
  __chkstk_darwin();
  v15 = (char *)v26 - v14;
  v26[6] = *(_QWORD *)(a5 - 8);
  __chkstk_darwin();
  v26[3] = (char *)v26 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  v27 = *(_QWORD *)(class metadata base offset for KeyPath + v12 + 8);
  v26[10] = *(_QWORD *)(v27 - 8);
  __chkstk_darwin();
  v26[9] = (char *)v26 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin();
  v26[8] = (char *)v26 - v18;
  v20 = *(_QWORD *)(v11 + v19);
  type metadata accessor for Optional(0, v20);
  __chkstk_darwin();
  v31 = *(_QWORD *)(v20 - 8);
  v21 = __chkstk_darwin();
  v30 = (char *)v26 - v22;
  dispatch thunk of AnyKeyPath._storedInlineOffset.getter(v21);
  if ((v23 & 1) == 0)
  {
    v26[2] = v15;
    __asm { BR              X10 }
  }
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v20, a5, 0, 0);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(TupleTypeMetadata2 - 8) + 56))(a7, 1, 1, TupleTypeMetadata2);
}

void sub_1000ACC24(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  char v12;
  uint64_t v13;
  void (*v14)(_QWORD *, uint64_t);
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void (*v18)(uint64_t, uint64_t, uint64_t);
  uint64_t v19;
  uint64_t v20;

  *(_QWORD *)(v6 - 112) = a1;
  *(_QWORD *)(v6 - 104) = BYTE6(v5);
  v7 = sub_100035EE0();
  v8 = *(_QWORD **)(v6 - 176);
  v9 = *(_QWORD *)(v6 - 152);
  v10 = *(_QWORD *)(v6 - 144);
  dispatch thunk of BinaryInteger.init<A>(_:)(v6 - 104, &type metadata for Int, v7, v9, v10);
  v11 = *(_QWORD **)(v6 - 168);
  swift_getAtKeyPath(v11, v1, *(_QWORD *)(v6 - 136));
  v12 = dispatch thunk of static Equatable.== infix(_:_:)(v8, v11, v9, *(_QWORD *)(*(_QWORD *)(v10 + 16) + 8));
  v13 = v1;
  v14 = *(void (**)(_QWORD *, uint64_t))(*(_QWORD *)(v6 - 160) + 8);
  v14(v11, v9);
  v14(v8, v9);
  if ((v12 & 1) != 0)
  {
    type metadata accessor for BinaryDecoder();
    v15 = *(_QWORD *)(v6 - 224);
    v16 = *(_QWORD *)(v6 - 112);
    static BinaryDecoder.decode<A>(_:data:)(v3, v16, v5);
    if (v2)
    {
      swift_errorRelease(v2);
      sub_10000E614(v16, v5);
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v6 - 192) + 56))(v15, 1, 1, v3);
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v6 - 120) + 8))(*(_QWORD *)(v6 - 128), v4);
      JUMPOUT(0x1000ACD54);
    }
    sub_10000E614(v16, v5);
    v17 = *(_QWORD *)(v6 - 192);
    (*(void (**)(uint64_t, _QWORD, uint64_t, uint64_t))(v17 + 56))(v15, 0, 1, v3);
    v18 = *(void (**)(uint64_t, uint64_t, uint64_t))(v17 + 32);
    v19 = *(_QWORD *)(v6 - 216);
    v18(v19, v15, v3);
    v20 = *(_QWORD *)(v6 - 232) + *(int *)(swift_getTupleTypeMetadata2(0, v4, v3, 0, 0) + 48);
    (*(void (**)(_QWORD, _QWORD, uint64_t))(v6 - 240))(*(_QWORD *)(v6 - 232), *(_QWORD *)(v6 - 128), v4);
    v18(v20, v19, v3);
    JUMPOUT(0x1000ACD88);
  }
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v6 - 120) + 8))(v13, v4);
  sub_10000E614(*(_QWORD *)(v6 - 112), v5);
  JUMPOUT(0x1000ACD58);
}

uint64_t sub_1000ACEC4(uint64_t a1, uint64_t a2, unint64_t a3)
{
  return ((uint64_t (*)(uint64_t, _QWORD, uint64_t, unint64_t))((char *)&loc_1000ACEDC
                                                                             + dword_1000ACF24[a3 >> 62]))(a1, 0, a2, a3);
}

uint64_t sub_1000ACEF0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (BYTE6(a4) < a1)
  {
    __break(1u);
    JUMPOUT(0x1000ACF24);
  }
  return Data._Representation.subscript.getter();
}

void sub_1000ACF34(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __asm { BR              X11 }
}

uint64_t sub_1000ACF74@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (a3 == BYTE6(a2))
  {
    Data.load<A>(as:)(a1);
    v6 = 0;
  }
  else
  {
    v6 = 1;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v5 + 56))(v4, v6, 1, v3);
}

unint64_t sub_1000AD014(unsigned __int16 a1, uint64_t a2)
{
  if (BYTE6(a2) == 24)
    _s7CoreP2P21NANActionFrameSubtypeO8rawValueACSgs5UInt8V_tcfC_0(HIBYTE(a2));
  return a1 | (unint64_t)(a2 << 16);
}

unint64_t sub_1000AD0CC(unsigned __int16 a1, unint64_t a2, unsigned int a3)
{
  return a1 | (HIDWORD(a2) << 16) | ((unint64_t)a3 << 48) | ((unint64_t)(a3 >> 8) << 56);
}

uint64_t sub_1000AD0FC(unint64_t a1, __int16 a2)
{
  unsigned int v2;
  int v3;
  int v4;
  int v6;

  LOWORD(v6) = HIWORD(a1);
  HIWORD(v6) = a2;
  v2 = (a1 >> 16) - 1;
  if (v2 >= 4)
    v3 = 0x40000;
  else
    v3 = v2 << 16;
  if ((v6 - 1) >= 3)
    v4 = 50331648;
  else
    v4 = (v6 - 1) << 24;
  return v3 & 0xFFFF0000 | (unsigned __int16)a1 | v4;
}

void sub_1000AD144()
{
  uint64_t v0;
  __int128 v1;
  __int128 v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  _OWORD __src[64];

  v1 = *(_OWORD *)(v0 + 49);
  __src[0] = *(_OWORD *)(v0 + 33);
  __src[1] = v1;
  v2 = *(_OWORD *)(v0 + 81);
  __src[2] = *(_OWORD *)(v0 + 65);
  __src[3] = v2;
  v3 = *(_OWORD *)(v0 + 113);
  __src[4] = *(_OWORD *)(v0 + 97);
  __src[5] = v3;
  v4 = *(_OWORD *)(v0 + 145);
  __src[6] = *(_OWORD *)(v0 + 129);
  __src[7] = v4;
  v5 = *(_OWORD *)(v0 + 177);
  __src[8] = *(_OWORD *)(v0 + 161);
  __src[9] = v5;
  v6 = *(_OWORD *)(v0 + 209);
  __src[10] = *(_OWORD *)(v0 + 193);
  __src[11] = v6;
  v7 = *(_OWORD *)(v0 + 241);
  __src[12] = *(_OWORD *)(v0 + 225);
  __src[13] = v7;
  v8 = *(_OWORD *)(v0 + 273);
  __src[14] = *(_OWORD *)(v0 + 257);
  __src[15] = v8;
  v9 = *(_OWORD *)(v0 + 305);
  __src[16] = *(_OWORD *)(v0 + 289);
  __src[17] = v9;
  v10 = *(_OWORD *)(v0 + 337);
  __src[18] = *(_OWORD *)(v0 + 321);
  __src[19] = v10;
  v11 = *(_OWORD *)(v0 + 369);
  __src[20] = *(_OWORD *)(v0 + 353);
  __src[21] = v11;
  v12 = *(_OWORD *)(v0 + 401);
  __src[22] = *(_OWORD *)(v0 + 385);
  __src[23] = v12;
  v13 = *(_OWORD *)(v0 + 433);
  __src[24] = *(_OWORD *)(v0 + 417);
  __src[25] = v13;
  v14 = *(_OWORD *)(v0 + 465);
  __src[26] = *(_OWORD *)(v0 + 449);
  __src[27] = v14;
  v15 = *(_OWORD *)(v0 + 497);
  __src[28] = *(_OWORD *)(v0 + 481);
  __src[29] = v15;
  v16 = *(_OWORD *)(v0 + 529);
  __src[30] = *(_OWORD *)(v0 + 513);
  __src[31] = v16;
  v17 = *(_OWORD *)(v0 + 561);
  __src[32] = *(_OWORD *)(v0 + 545);
  __src[33] = v17;
  v18 = *(_OWORD *)(v0 + 593);
  __src[34] = *(_OWORD *)(v0 + 577);
  __src[35] = v18;
  v19 = *(_OWORD *)(v0 + 625);
  __src[36] = *(_OWORD *)(v0 + 609);
  __src[37] = v19;
  v20 = *(_OWORD *)(v0 + 657);
  __src[38] = *(_OWORD *)(v0 + 641);
  __src[39] = v20;
  v21 = *(_OWORD *)(v0 + 689);
  __src[40] = *(_OWORD *)(v0 + 673);
  __src[41] = v21;
  v22 = *(_OWORD *)(v0 + 721);
  __src[42] = *(_OWORD *)(v0 + 705);
  __src[43] = v22;
  v23 = *(_OWORD *)(v0 + 753);
  __src[44] = *(_OWORD *)(v0 + 737);
  __src[45] = v23;
  v24 = *(_OWORD *)(v0 + 785);
  __src[46] = *(_OWORD *)(v0 + 769);
  __src[47] = v24;
  v25 = *(_OWORD *)(v0 + 817);
  __src[48] = *(_OWORD *)(v0 + 801);
  __src[49] = v25;
  v26 = *(_OWORD *)(v0 + 849);
  __src[50] = *(_OWORD *)(v0 + 833);
  __src[51] = v26;
  v27 = *(_OWORD *)(v0 + 881);
  __src[52] = *(_OWORD *)(v0 + 865);
  __src[53] = v27;
  v28 = *(_OWORD *)(v0 + 913);
  __src[54] = *(_OWORD *)(v0 + 897);
  __src[55] = v28;
  v29 = *(_OWORD *)(v0 + 945);
  __src[56] = *(_OWORD *)(v0 + 929);
  __src[57] = v29;
  v30 = *(_OWORD *)(v0 + 977);
  __src[58] = *(_OWORD *)(v0 + 961);
  __src[59] = v30;
  v31 = sub_10021BD08(__src, *(unsigned __int16 *)(v0 + 31));
  v33 = v32;
  v34 = v32 >> 62;
  sub_100031FEC(v31, v32);
  sub_10001F11C((uint64_t)_swiftEmptyArrayStorage);
  v35 = type metadata accessor for BinaryDecoder();
  v36 = (_QWORD *)swift_allocObject(v35, 48, 7);
  v36[5] = &_swiftEmptyDictionarySingleton;
  v36[2] = v31;
  v36[3] = v33;
  __asm { BR              X10 }
}

uint64_t sub_1000AD300(uint64_t a1)
{
  uint64_t v1;
  int32x2_t *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;
  int32x2_t v18;
  int32x2_t v19;
  __int16 v20;

  *(_QWORD *)(v7 + 32) = (int)v5;
  swift_beginAccess(a1, v8 - 112, 1, 0);
  v9 = *(_QWORD *)(v7 + 40);
  *(_QWORD *)(v7 + 40) = v3;
  swift_bridgeObjectRelease(v9);
  *(_QWORD *)(v8 - 128) = v6;
  *(_QWORD *)(v8 - 120) = sub_100011DE4((unint64_t *)&qword_100405BB8, (uint64_t (*)(uint64_t))type metadata accessor for BinaryDecoder, (uint64_t)protocol conformance descriptor for BinaryDecoder);
  *(_QWORD *)(v8 - 152) = v7;
  v10 = sub_10016FA58((_QWORD *)(v8 - 152));
  v12 = v11;
  v14 = v13;
  v16 = v15;
  result = sub_10000E614(v5, v4);
  v19 = *v2;
  v18 = v2[1];
  v20 = v2->i16[2];
  *(_WORD *)v1 = v2->i16[3];
  *(int32x2_t *)(v1 + 2) = vzip1_s32(v18, v19);
  *(_WORD *)(v1 + 10) = v20;
  *(_BYTE *)(v1 + 16) = v10;
  *(_QWORD *)(v1 + 24) = v12;
  *(_QWORD *)(v1 + 32) = v14;
  *(_QWORD *)(v1 + 40) = v16;
  return result;
}

CoreP2P::Channel::Band_optional __swiftcall Channel.Band.init(apple80211:)(__C::apple80211_channel_band apple80211)
{
  if (apple80211.rawValue >= 4)
    return (CoreP2P::Channel::Band_optional)3;
  else
    return (CoreP2P::Channel::Band_optional)(0x2010003u >> (8 * LOBYTE(apple80211.rawValue)));
}

uint64_t sub_1000AD42C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const void *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v36;
  uint64_t v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  _BYTE v80[144];
  _OWORD v81[9];
  __int128 v82[75];
  _OWORD v83[12];

  sub_100012C44(&qword_100406940);
  __chkstk_darwin();
  v5 = (char *)&v51 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  v6 = type metadata accessor for AWDLStatistics.LowLatencyStatistics.Configuration(0);
  v7 = *(_QWORD *)(v6 - 8);
  __chkstk_darwin();
  v9 = (char *)&v51 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  v10 = *(_OWORD *)(a1 + 120);
  v11 = *(_OWORD *)(a1 + 152);
  v83[8] = *(_OWORD *)(a1 + 136);
  v83[9] = v11;
  v83[10] = *(_OWORD *)(a1 + 168);
  v12 = *(_OWORD *)(a1 + 56);
  v13 = *(_OWORD *)(a1 + 88);
  v83[4] = *(_OWORD *)(a1 + 72);
  v83[5] = v13;
  v14 = *(_OWORD *)(a1 + 104);
  v83[7] = v10;
  v83[6] = v14;
  v15 = *(_OWORD *)(a1 + 24);
  v83[0] = *(_OWORD *)(a1 + 8);
  v83[1] = v15;
  v16 = *(_OWORD *)(a1 + 40);
  v83[3] = v12;
  v83[2] = v16;
  sub_1000B04D4((unsigned __int8 *)v83, (uint64_t)v5);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v7 + 48))(v5, 1, v6) == 1)
  {
    sub_100033A84((uint64_t)v5, &qword_100406940);
LABEL_5:
    v34 = type metadata accessor for AWDLStatistics.LowLatencyStatistics(0);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v34 - 8) + 56))(a2, 1, 1, v34);
  }
  sub_100033AC0((uint64_t)v5, (uint64_t)v9, type metadata accessor for AWDLStatistics.LowLatencyStatistics.Configuration);
  v17 = *(_QWORD *)(a1 + 184);
  v69 = *(_QWORD *)(a1 + 200);
  v70 = v17;
  v18 = *(_QWORD *)(a1 + 208);
  v67 = *(_QWORD *)(a1 + 216);
  v68 = v18;
  v19 = *(_QWORD *)(a1 + 224);
  v65 = *(_QWORD *)(a1 + 232);
  v66 = v19;
  v20 = *(_QWORD *)(a1 + 240);
  v21 = *(_QWORD *)(a1 + 256);
  v63 = *(_QWORD *)(a1 + 248);
  v64 = v20;
  v22 = *(_QWORD *)(a1 + 264);
  v61 = *(_QWORD *)(a1 + 272);
  v62 = v22;
  v23 = *(_QWORD *)(a1 + 280);
  v59 = *(_QWORD *)(a1 + 288);
  v60 = v23;
  v24 = *(_QWORD *)(a1 + 296);
  v57 = *(_QWORD *)(a1 + 304);
  v58 = v24;
  v25 = *(_QWORD *)(a1 + 312);
  v55 = *(_QWORD *)(a1 + 320);
  v56 = v25;
  v26 = *(_QWORD *)(a1 + 328);
  v53 = *(_QWORD *)(a1 + 336);
  v54 = v26;
  v27 = *(_QWORD *)(a1 + 352);
  v52 = *(_QWORD *)(a1 + 344);
  v29 = *(_QWORD *)(a1 + 360);
  v28 = *(_QWORD *)(a1 + 368);
  v30 = *(_QWORD *)(a1 + 376);
  v31 = *(_QWORD *)(a1 + 384);
  v32 = (const void *)(a1 + 400);
  v33 = *(_QWORD *)(a1 + 392);
  memcpy(v82, v32, sizeof(v82));
  sub_1000B3B3C(v82, (uint64_t)v80);
  sub_100063EB8((uint64_t)v80, (uint64_t)v81, &qword_100406948);
  if (sub_1000B73F0((uint64_t *)v81) == 1)
  {
    sub_100063824((uint64_t)v9, type metadata accessor for AWDLStatistics.LowLatencyStatistics.Configuration);
    goto LABEL_5;
  }
  v77 = v81[6];
  v78 = v81[7];
  v79 = v81[8];
  v73 = v81[2];
  v74 = v81[3];
  v75 = v81[4];
  v76 = v81[5];
  v71 = v81[0];
  v72 = v81[1];
  sub_100033AC0((uint64_t)v9, a2, type metadata accessor for AWDLStatistics.LowLatencyStatistics.Configuration);
  v36 = type metadata accessor for AWDLStatistics.LowLatencyStatistics(0);
  v37 = a2 + *(int *)(v36 + 20);
  v38 = v72;
  *(_OWORD *)(v37 + 216) = v71;
  v39 = v79;
  *(_OWORD *)(v37 + 328) = v78;
  *(_OWORD *)(v37 + 344) = v39;
  v40 = v77;
  *(_OWORD *)(v37 + 296) = v76;
  *(_OWORD *)(v37 + 312) = v40;
  v41 = v75;
  v42 = v73;
  *(_OWORD *)(v37 + 264) = v74;
  *(_OWORD *)(v37 + 280) = v41;
  *(_OWORD *)(v37 + 248) = v42;
  *(_QWORD *)v37 = v70;
  *(_QWORD *)(v37 + 8) = v21;
  v43 = v68;
  *(_QWORD *)(v37 + 16) = v69;
  *(_QWORD *)(v37 + 24) = v43;
  v44 = v66;
  *(_QWORD *)(v37 + 32) = v67;
  *(_QWORD *)(v37 + 40) = v44;
  v45 = v64;
  *(_QWORD *)(v37 + 48) = v65;
  *(_QWORD *)(v37 + 56) = v45;
  *(_QWORD *)(v37 + 64) = v63;
  *(_QWORD *)(v37 + 72) = v21;
  v46 = v61;
  *(_QWORD *)(v37 + 80) = v62;
  *(_QWORD *)(v37 + 88) = v46;
  v47 = v59;
  *(_QWORD *)(v37 + 96) = v60;
  *(_QWORD *)(v37 + 104) = v47;
  v48 = v57;
  *(_QWORD *)(v37 + 112) = v58;
  *(_QWORD *)(v37 + 120) = v48;
  v49 = v55;
  *(_QWORD *)(v37 + 128) = v56;
  *(_QWORD *)(v37 + 136) = v49;
  v50 = v53;
  *(_QWORD *)(v37 + 144) = v54;
  *(_QWORD *)(v37 + 152) = v50;
  *(_QWORD *)(v37 + 160) = v52;
  *(_QWORD *)(v37 + 168) = v27;
  *(_QWORD *)(v37 + 176) = v29;
  *(_QWORD *)(v37 + 184) = v28;
  *(_QWORD *)(v37 + 192) = v30;
  *(_QWORD *)(v37 + 200) = v31;
  *(_QWORD *)(v37 + 208) = v33;
  *(_OWORD *)(v37 + 232) = v38;
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(v36 - 8) + 56))(a2, 0, 1, v36);
}

uint64_t sub_1000AD79C@<X0>(uint64_t a1@<X8>)
{
  uint64_t *v1;
  uint8x8_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  unint64_t v11;
  int v12;
  unint64_t v13;
  uint64_t v14;
  void (*v15)(_QWORD *, uint64_t, uint64_t);
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int *v20;
  void (*v21)(uint64_t, _QWORD *, uint64_t);
  uint64_t result;
  int16x8_t v23;
  int v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  int v28;
  unint64_t v29;
  unint64_t v30;

  v4 = type metadata accessor for DispatchTimeInterval(0);
  v5 = *(_QWORD *)(v4 - 8);
  __chkstk_darwin();
  v7 = (uint64_t *)((char *)v23.i64 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0));
  __chkstk_darwin();
  v9 = (uint64_t *)((char *)v23.i64 - v8);
  v10 = *v1;
  v2.i32[0] = *((_DWORD *)v1 + 2);
  v11 = sub_1000B388C(*((_DWORD *)v1 + 4), *((_DWORD *)v1 + 5));
  if ((v11 & 0xFF00000000) == 0x300000000)
  {
    if (qword_100404168 != -1)
      swift_once(&qword_100404168, sub_100190174);
    v12 = static Channel.awdlSocial2GHz;
    v30 = byte_10041058C;
    v13 = byte_10041058D;
  }
  else
  {
    v12 = v11;
    v30 = HIDWORD(v11);
    v13 = v11 >> 40;
  }
  v29 = v13;
  v28 = *((_DWORD *)v1 + 6);
  *v9 = *((unsigned int *)v1 + 7);
  v14 = enum case for DispatchTimeInterval.milliseconds(_:);
  v15 = *(void (**)(_QWORD *, uint64_t, uint64_t))(v5 + 104);
  v15(v9, enum case for DispatchTimeInterval.milliseconds(_:), v4);
  *v7 = *((unsigned int *)v1 + 8);
  v15(v7, v14, v4);
  v16 = *((_DWORD *)v1 + 16);
  if (v16 < 0)
  {
    result = _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 3451, 0);
    __break(1u);
  }
  else
  {
    v23 = (int16x8_t)vmovl_u8(v2);
    v17 = *((_DWORD *)v1 + 9);
    v24 = *((_DWORD *)v1 + 10);
    v25 = *((int *)v1 + 11);
    v26 = *((_DWORD *)v1 + 12);
    v27 = v1[7];
    v18 = sub_100012C44(&qword_100406950);
    v19 = swift_allocObject(v18, 36, 7);
    *(_OWORD *)(v19 + 16) = xmmword_10033F040;
    *(_DWORD *)(v19 + 32) = *((_DWORD *)v1 + 17);
    *(_QWORD *)a1 = v10;
    *(_DWORD *)(a1 + 8) = vmovn_s16(v23).u32[0];
    *(_DWORD *)(a1 + 12) = v12;
    *(_BYTE *)(a1 + 16) = v30;
    *(_BYTE *)(a1 + 17) = v29;
    *(_DWORD *)(a1 + 20) = v28;
    v20 = (int *)type metadata accessor for AWDLActionFrame.Header(0);
    v21 = *(void (**)(uint64_t, _QWORD *, uint64_t))(v5 + 32);
    v21(a1 + v20[8], v9, v4);
    result = ((uint64_t (*)(uint64_t, _QWORD *, uint64_t))v21)(a1 + v20[9], v7, v4);
    *(_DWORD *)(a1 + v20[10]) = v17;
    *(_DWORD *)(a1 + v20[11]) = v24;
    *(_QWORD *)(a1 + v20[12]) = v25;
    *(_DWORD *)(a1 + v20[13]) = v26;
    *(_QWORD *)(a1 + v20[14]) = v27;
    *(_DWORD *)(a1 + v20[15]) = v16;
    *(_QWORD *)(a1 + v20[16]) = v19;
  }
  return result;
}

unint64_t sub_1000ADA58()
{
  unsigned int *v0;
  uint8x8_t v1;
  unsigned int *v2;
  uint64_t v3;
  _QWORD *v4;
  __int16 v5;
  int v6;
  char v7;
  char v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  int v14;
  __int16 v15;
  __int128 v16;
  __int128 v17;
  int v18;
  __int32 v19;
  char v20;
  char v21;
  uint64_t v22;
  _QWORD *v23;
  _BYTE __dst[448];

  v2 = v0;
  memcpy(__dst, v0 + 4, 0x1B8uLL);
  v23 = _swiftEmptyArrayStorage;
  sub_10007505C(0, 10, 0);
  v3 = 0;
  v4 = _swiftEmptyArrayStorage;
  do
  {
    v5 = *(_WORD *)&__dst[v3 + 4];
    v6 = *(_DWORD *)&__dst[v3 + 40];
    v14 = *(_DWORD *)&__dst[v3];
    v15 = v5;
    v16 = *(_OWORD *)&__dst[v3 + 8];
    v17 = *(_OWORD *)&__dst[v3 + 24];
    v18 = v6;
    sub_1000AF7FC((uint64_t)&v14, (uint64_t)&v19);
    v1.i32[0] = v19;
    v7 = v20;
    v8 = v21;
    v9 = v22;
    v23 = v4;
    v11 = v4[2];
    v10 = v4[3];
    if (v11 >= v10 >> 1)
    {
      sub_10007505C(v10 > 1, v11 + 1, 1);
      v4 = v23;
    }
    v4[2] = v11 + 1;
    v12 = (char *)v4 + 14 * v11;
    *((_DWORD *)v12 + 8) = vmovn_s16((int16x8_t)vmovl_u8(v1)).u32[0];
    v12[36] = v7;
    v12[37] = v8;
    *(_QWORD *)(v12 + 38) = v9;
    v3 += 44;
  }
  while (v3 != 440);
  return *v2 | ((unint64_t)*((unsigned __int8 *)v2 + 4) << 32) | ((unint64_t)*((unsigned __int8 *)v2 + 5) << 40);
}

__n128 sub_1000ADBB4@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  __int16 v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  uint64_t v20;
  char v21;
  __n128 result;
  __n128 v23;
  __n128 v24;
  uint64_t v25;
  uint64_t v26;
  char v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD v30[2];
  BOOL v31;

  v4 = a1;
  v6 = a1 & 0xFFFF0000;
  if ((a1 & 0xFFFF0000) != 0)
  {
    v28 = a2;
    v29 = a3;
    v7 = sub_1000FADC0((uint64_t)&v28, (uint64_t)v30);
    v9 = v8;
    sub_100212BD4(v7, v8);
    v15 = v14;
    v17 = v16;
    sub_10000E614(v7, v9);
  }
  else
  {
    LOBYTE(v28) = BYTE4(a1);
    BYTE1(v28) = BYTE5(a1);
    BYTE2(v28) = BYTE6(a1);
    BYTE3(v28) = HIBYTE(a1);
    v10 = sub_1000FADC0((uint64_t)&v28, (uint64_t)&v28 + 4);
    v12 = v11;
    sub_100212DDC(v10, v11);
    LODWORD(v15) = v13;
    sub_10000E614(v10, v12);
    v17 = 0;
    v15 = v15;
  }
  v18 = v6 != 0;
  v28 = v15;
  v29 = v17;
  v30[0] = 0;
  v30[1] = 0;
  v31 = v6 != 0;
  sub_100095C78((uint64_t)&v28, (uint64_t)&v24);
  v23 = v24;
  v19 = v25;
  v20 = v26;
  v21 = v27;
  sub_1000B7408(v15, v17, 0, 0, v18);
  *(_WORD *)a4 = v4;
  result = v23;
  *(__n128 *)(a4 + 8) = v23;
  *(_QWORD *)(a4 + 24) = v19;
  *(_QWORD *)(a4 + 32) = v20;
  *(_BYTE *)(a4 + 40) = v21;
  return result;
}

_QWORD *sub_1000ADDD8()
{
  unsigned __int8 *v0;
  uint64_t v1;
  __int128 v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  unsigned __int8 *v26;
  _QWORD *v27;
  unsigned __int8 *v28;
  _QWORD *v29;
  uint64_t v30;
  _BYTE *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char v37;
  char v38;
  _BYTE *v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _BYTE *v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  char v52;
  char v53;
  unint64_t v54;
  unint64_t v55;
  unsigned __int8 *v56;
  _QWORD *v57;
  _QWORD *v58;
  uint64_t v59;
  _BYTE *v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  uint64_t v65;
  char v66;
  char v67;
  _BYTE *v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t v72;
  uint64_t v73;
  _BYTE *v74;
  uint64_t v75;
  uint64_t v76;
  unint64_t v77;
  uint64_t v78;
  uint64_t v79;
  int v80;
  char v81;
  char v82;
  unint64_t v83;
  unint64_t v84;
  uint64_t v86;
  _OWORD v87[25];
  _QWORD *v88;

  v1 = *v0;
  v86 = v0[1];
  v2 = *(_OWORD *)(v0 + 18);
  v3 = *(_OWORD *)(v0 + 34);
  v4 = *(_OWORD *)(v0 + 50);
  v5 = *(_OWORD *)(v0 + 66);
  v6 = *(_OWORD *)(v0 + 82);
  v7 = *(_OWORD *)(v0 + 98);
  v8 = *(_OWORD *)(v0 + 114);
  v9 = *(_OWORD *)(v0 + 130);
  v10 = *(_OWORD *)(v0 + 146);
  v11 = *(_OWORD *)(v0 + 162);
  v12 = *(_OWORD *)(v0 + 178);
  v13 = *(_OWORD *)(v0 + 194);
  v14 = *(_OWORD *)(v0 + 210);
  v15 = *(_OWORD *)(v0 + 226);
  v16 = *(_OWORD *)(v0 + 242);
  v17 = *(_OWORD *)(v0 + 258);
  v18 = *(_OWORD *)(v0 + 274);
  v19 = *(_OWORD *)(v0 + 290);
  v20 = *(_OWORD *)(v0 + 306);
  v87[0] = *(_OWORD *)(v0 + 2);
  v87[1] = v2;
  v87[2] = v3;
  v87[3] = v4;
  v21 = *(_OWORD *)(v0 + 322);
  v22 = *(_OWORD *)(v0 + 338);
  v23 = *(_OWORD *)(v0 + 354);
  v24 = *(_OWORD *)(v0 + 370);
  v25 = *(_OWORD *)(v0 + 386);
  v87[4] = v5;
  v87[5] = v6;
  v87[6] = v7;
  v87[7] = v8;
  v87[8] = v9;
  v87[9] = v10;
  v87[10] = v11;
  v87[11] = v12;
  v87[12] = v13;
  v87[13] = v14;
  v87[14] = v15;
  v87[15] = v16;
  v87[16] = v17;
  v87[17] = v18;
  v87[18] = v19;
  v87[19] = v20;
  v87[20] = v21;
  v87[21] = v22;
  v26 = (unsigned __int8 *)v87 + v1;
  v87[22] = v23;
  v87[23] = v24;
  v87[24] = v25;
  if (v1)
  {
    if (qword_100404150 != -1)
      swift_once(&qword_100404150, sub_100190108);
    v27 = _swiftEmptyArrayStorage;
    v28 = (unsigned __int8 *)v87;
    while (1)
    {
      v30 = *v28;
      v31 = off_100409F48;
      if (*((_QWORD *)off_100409F48 + 2))
      {
        v32 = static Hasher._hash(seed:bytes:count:)(*((_QWORD *)off_100409F48 + 5), *v28, 4);
        v33 = -1 << v31[32];
        v34 = v32 & ~v33;
        if (((*(_QWORD *)&v31[((v34 >> 3) & 0xFFFFFFFFFFFFF8) + 56] >> v34) & 1) != 0)
        {
          v35 = *((_QWORD *)v31 + 6);
          if (*(_DWORD *)(v35 + 4 * v34) == (_DWORD)v30)
          {
LABEL_13:
            v37 = 0;
            v38 = 3;
            goto LABEL_32;
          }
          v36 = ~v33;
          while (1)
          {
            v34 = (v34 + 1) & v36;
            if (((*(_QWORD *)&v31[((v34 >> 3) & 0xFFFFFFFFFFFFF8) + 56] >> v34) & 1) == 0)
              break;
            if (*(_DWORD *)(v35 + 4 * v34) == (_DWORD)v30)
              goto LABEL_13;
          }
        }
      }
      if (qword_100404158 != -1)
        swift_once(&qword_100404158, sub_10019012C);
      v39 = off_100409F50;
      if (*((_QWORD *)off_100409F50 + 2))
      {
        v40 = static Hasher._hash(seed:bytes:count:)(*((_QWORD *)off_100409F50 + 5), v30, 4);
        v41 = -1 << v39[32];
        v42 = v40 & ~v41;
        if (((*(_QWORD *)&v39[((v42 >> 3) & 0xFFFFFFFFFFFFF8) + 56] >> v42) & 1) != 0)
        {
          v43 = *((_QWORD *)v39 + 6);
          if (*(_DWORD *)(v43 + 4 * v42) == (_DWORD)v30)
          {
LABEL_22:
            v37 = 1;
            v38 = 4;
            goto LABEL_32;
          }
          v44 = ~v41;
          while (1)
          {
            v42 = (v42 + 1) & v44;
            if (((*(_QWORD *)&v39[((v42 >> 3) & 0xFFFFFFFFFFFFF8) + 56] >> v42) & 1) == 0)
              break;
            if (*(_DWORD *)(v43 + 4 * v42) == (_DWORD)v30)
              goto LABEL_22;
          }
        }
      }
      if (qword_100404160 != -1)
        swift_once(&qword_100404160, sub_100190150);
      v45 = off_100409F58;
      if (!*((_QWORD *)off_100409F58 + 2))
        goto LABEL_6;
      v46 = static Hasher._hash(seed:bytes:count:)(*((_QWORD *)off_100409F58 + 5), v30, 4);
      v47 = -1 << v45[32];
      v48 = v46 & ~v47;
      if (((*(_QWORD *)&v45[((v48 >> 3) & 0xFFFFFFFFFFFFF8) + 56] >> v48) & 1) == 0)
        goto LABEL_6;
      v49 = *((_QWORD *)v45 + 6);
      if (*(_DWORD *)(v49 + 4 * v48) != (_DWORD)v30)
      {
        v50 = ~v47;
        do
        {
          v48 = (v48 + 1) & v50;
          if (((*(_QWORD *)&v45[((v48 >> 3) & 0xFFFFFFFFFFFFF8) + 56] >> v48) & 1) == 0)
            goto LABEL_6;
        }
        while (*(_DWORD *)(v49 + 4 * v48) != (_DWORD)v30);
      }
      v37 = 2;
      v38 = 5;
LABEL_32:
      LODWORD(v88) = v30;
      BYTE4(v88) = v37;
      BYTE5(v88) = v38;
      sub_10018FA04();
      v51 = (int)v88;
      v52 = BYTE4(v88);
      v53 = BYTE5(v88);
      if ((swift_isUniquelyReferenced_nonNull_native(v27) & 1) == 0)
        v27 = sub_1000B1E74(0, v27[2] + 1, 1, v27);
      v55 = v27[2];
      v54 = v27[3];
      if (v55 >= v54 >> 1)
        v27 = sub_1000B1E74((_QWORD *)(v54 > 1), v55 + 1, 1, v27);
      v27[2] = v55 + 1;
      v29 = &v27[v55];
      *((_DWORD *)v29 + 8) = v51;
      *((_BYTE *)v29 + 36) = v52;
      *((_BYTE *)v29 + 37) = v53;
LABEL_6:
      if (++v28 == v26)
        goto LABEL_37;
    }
  }
  v27 = _swiftEmptyArrayStorage;
LABEL_37:
  if ((_DWORD)v86)
  {
    if (qword_100404150 != -1)
      swift_once(&qword_100404150, sub_100190108);
    v56 = &v26[v86];
    v57 = _swiftEmptyArrayStorage;
    while (1)
    {
      v59 = *v26;
      v60 = off_100409F48;
      if (*((_QWORD *)off_100409F48 + 2))
      {
        v61 = static Hasher._hash(seed:bytes:count:)(*((_QWORD *)off_100409F48 + 5), *v26, 4);
        v62 = -1 << v60[32];
        v63 = v61 & ~v62;
        if (((*(_QWORD *)&v60[((v63 >> 3) & 0xFFFFFFFFFFFFF8) + 56] >> v63) & 1) != 0)
        {
          v64 = *((_QWORD *)v60 + 6);
          if (*(_DWORD *)(v64 + 4 * v63) == (_DWORD)v59)
          {
LABEL_49:
            v66 = 0;
            v67 = 3;
            goto LABEL_68;
          }
          v65 = ~v62;
          while (1)
          {
            v63 = (v63 + 1) & v65;
            if (((*(_QWORD *)&v60[((v63 >> 3) & 0xFFFFFFFFFFFFF8) + 56] >> v63) & 1) == 0)
              break;
            if (*(_DWORD *)(v64 + 4 * v63) == (_DWORD)v59)
              goto LABEL_49;
          }
        }
      }
      if (qword_100404158 != -1)
        swift_once(&qword_100404158, sub_10019012C);
      v68 = off_100409F50;
      if (*((_QWORD *)off_100409F50 + 2))
      {
        v69 = static Hasher._hash(seed:bytes:count:)(*((_QWORD *)off_100409F50 + 5), v59, 4);
        v70 = -1 << v68[32];
        v71 = v69 & ~v70;
        if (((*(_QWORD *)&v68[((v71 >> 3) & 0xFFFFFFFFFFFFF8) + 56] >> v71) & 1) != 0)
        {
          v72 = *((_QWORD *)v68 + 6);
          if (*(_DWORD *)(v72 + 4 * v71) == (_DWORD)v59)
          {
LABEL_58:
            v66 = 1;
            v67 = 4;
            goto LABEL_68;
          }
          v73 = ~v70;
          while (1)
          {
            v71 = (v71 + 1) & v73;
            if (((*(_QWORD *)&v68[((v71 >> 3) & 0xFFFFFFFFFFFFF8) + 56] >> v71) & 1) == 0)
              break;
            if (*(_DWORD *)(v72 + 4 * v71) == (_DWORD)v59)
              goto LABEL_58;
          }
        }
      }
      if (qword_100404160 != -1)
        swift_once(&qword_100404160, sub_100190150);
      v74 = off_100409F58;
      if (!*((_QWORD *)off_100409F58 + 2))
        goto LABEL_42;
      v75 = static Hasher._hash(seed:bytes:count:)(*((_QWORD *)off_100409F58 + 5), v59, 4);
      v76 = -1 << v74[32];
      v77 = v75 & ~v76;
      if (((*(_QWORD *)&v74[((v77 >> 3) & 0xFFFFFFFFFFFFF8) + 56] >> v77) & 1) == 0)
        goto LABEL_42;
      v78 = *((_QWORD *)v74 + 6);
      if (*(_DWORD *)(v78 + 4 * v77) != (_DWORD)v59)
      {
        v79 = ~v76;
        do
        {
          v77 = (v77 + 1) & v79;
          if (((*(_QWORD *)&v74[((v77 >> 3) & 0xFFFFFFFFFFFFF8) + 56] >> v77) & 1) == 0)
            goto LABEL_42;
        }
        while (*(_DWORD *)(v78 + 4 * v77) != (_DWORD)v59);
      }
      v66 = 2;
      v67 = 5;
LABEL_68:
      LODWORD(v88) = v59;
      BYTE4(v88) = v66;
      BYTE5(v88) = v67;
      sub_10018FA04();
      v80 = (int)v88;
      v81 = BYTE4(v88);
      v82 = BYTE5(v88);
      if ((swift_isUniquelyReferenced_nonNull_native(v57) & 1) == 0)
        v57 = sub_1000B1E74(0, v57[2] + 1, 1, v57);
      v84 = v57[2];
      v83 = v57[3];
      if (v84 >= v83 >> 1)
        v57 = sub_1000B1E74((_QWORD *)(v83 > 1), v84 + 1, 1, v57);
      v57[2] = v84 + 1;
      v58 = &v57[v84];
      *((_DWORD *)v58 + 8) = v80;
      *((_BYTE *)v58 + 36) = v81;
      *((_BYTE *)v58 + 37) = v82;
LABEL_42:
      if (++v26 == v56)
        goto LABEL_73;
    }
  }
  v57 = _swiftEmptyArrayStorage;
LABEL_73:
  v88 = v27;
  sub_1001A76D8((uint64_t)v57);
  return v88;
}

void sub_1000AE4AC(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  _DWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v9 = 0;
  v4 = sub_100334374(a1, a2, &v9);
  v5 = (uint64_t)v4 + v9;
  v6 = a3[5];
  v7 = a3[2];
  v8 = a3[3];
  swift_retain();
  swift_bridgeObjectRetain(v8);
  AppleDevice.setRequest(requestType:data:on:)(0xA2uLL, (uint64_t)v4, v5, 0, v7, v8);
  swift_bridgeObjectRelease(v8);
  swift_release(v6);
  free(v4);
}

void sub_1000AE584(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  _DWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  uint64_t v15;

  v15 = 0;
  v9 = sub_100334374(a1, a2, &v15);
  v10 = (uint64_t)v9 + v15;
  v11 = *(_QWORD *)(a6 + 8);
  v12 = *(_QWORD *)(a5 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v11, a4, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a6, a4, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  sub_1000AB320(162, (uint64_t)v9, v10, a4, v11, v12, AssociatedConformanceWitness);
  free(v9);
}

uint64_t sub_1000AE694(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, _QWORD *a7)
{
  uint64_t v7;
  uint64_t v13;
  uint64_t v14;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  uint64_t result;

  v13 = *(_QWORD *)(a6 + 8);
  v14 = *(_QWORD *)(a5 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v13, a4, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a6, a4, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  result = sub_1000AB320(120, a1, a2, a4, v13, v14, AssociatedConformanceWitness);
  if (v7)
    *a7 = v7;
  return result;
}

uint64_t sub_1000AE764(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v10;
  void (*v11)(_BYTE *, _QWORD, double);
  uint64_t v12;
  double v13;
  _QWORD v15[68];
  _BYTE __dst[3608];

  memcpy(__dst, a1, 0xE14uLL);
  swift_getAtKeyPath(v15, __dst, a2);
  if (*(_QWORD *)(a5 + 16) >= 0x10uLL)
    v10 = 16;
  else
    v10 = *(_QWORD *)(a5 + 16);
  v11 = (void (*)(_BYTE *, _QWORD, double))swift_modifyAtWritableKeyPath(__dst, a1, a2);
  v13 = sub_1000AFDE0(v12, v12 + 544, a4, a5, v10);
  v11(__dst, 0, v13);
  __dst[0] = v10;
  return swift_setAtWritableKeyPath(a1, a3, __dst);
}

uint64_t sub_1000AE848(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v10;
  void (*v11)(_BYTE *, _QWORD, double);
  uint64_t v12;
  double v13;
  _QWORD v15[68];
  _BYTE __dst[5576];

  memcpy(__dst, a1, sizeof(__dst));
  swift_getAtKeyPath(v15, __dst, a2);
  if (*(_QWORD *)(a5 + 16) >= 0x10uLL)
    v10 = 16;
  else
    v10 = *(_QWORD *)(a5 + 16);
  v11 = (void (*)(_BYTE *, _QWORD, double))swift_modifyAtWritableKeyPath(__dst, a1, a2);
  v13 = sub_1000AFDE0(v12, v12 + 544, a4, a5, v10);
  v11(__dst, 0, v13);
  __dst[0] = v10;
  return swift_setAtWritableKeyPath(a1, a3, __dst);
}

void sub_1000AE948(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  unint64_t v9;
  _OWORD *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _OWORD *v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  int v20;
  __int128 v21;
  __int128 v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _OWORD v28[5];
  _OWORD v29[3];
  char v30;
  uint64_t v31;

  v5 = v4;
  v6 = *(_QWORD *)(a3 + 16);
  if (v6)
  {
    v8 = a3 + 32;
    v31 = a3;
    swift_bridgeObjectRetain(a3);
    v9 = 0;
    v10 = (_OWORD *)(a1 + 4);
    v25 = v8;
    v26 = a1;
    while (1)
    {
      if (v9 < 2)
      {
        v11 = *(_QWORD *)(v8 + 16 * v9 + 8);
        v12 = *(_QWORD *)(v11 + 16);
        if (v12 >= 0x100)
        {
          _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 3455, 0);
          __break(1u);
          return;
        }
        v13 = a1 + 1284 * v9;
        *(_BYTE *)(v13 + 1) = v12;
        *(_BYTE *)(v13 + 2) = v9;
        v14 = *(_QWORD *)(v11 + 16);
        if (v14)
          break;
      }
LABEL_3:
      ++v9;
      v10 = (_OWORD *)((char *)v10 + 1284);
      if (v9 == v6)
      {
        swift_bridgeObjectRelease(v31);
        return;
      }
    }
    swift_bridgeObjectRetain_n(v11, 2);
    v15 = 32;
    v16 = v10;
    while (1)
    {
      v18 = *(_OWORD *)(v11 + v15 + 16);
      v17 = *(_OWORD *)(v11 + v15 + 32);
      v19 = *(_OWORD *)(v11 + v15);
      v30 = *(_BYTE *)(v11 + v15 + 48);
      v29[1] = v18;
      v29[2] = v17;
      v29[0] = v19;
      v20 = v19 & 7;
      sub_1000B6584(v29);
      if (v20 != 1)
      {
        swift_bridgeObjectRelease(v11);
        v23 = sub_100012C84();
        v5 = swift_allocError(&type metadata for WiFiError, v23, 0, 0);
        *(_OWORD *)v24 = xmmword_10033B1E0;
        *(_BYTE *)(v24 + 16) = 0;
        swift_willThrow(v5);
        goto LABEL_14;
      }
      sub_1000AEB6C((unint64_t)v28);
      if (v5)
        break;
      v21 = v28[3];
      v16[2] = v28[2];
      v16[3] = v21;
      v16[4] = v28[4];
      v22 = v28[1];
      *v16 = v28[0];
      v16[1] = v22;
      v16 += 5;
      sub_1000B65BC(v29);
      v15 += 56;
      if (!--v14)
      {
        swift_bridgeObjectRelease_n(v11, 2);
        v8 = v25;
        a1 = v26;
        goto LABEL_3;
      }
    }
    swift_bridgeObjectRelease(v11);
LABEL_14:
    sub_1000B65BC(v29);
    swift_bridgeObjectRelease(v11);
    swift_bridgeObjectRelease(v31);
    *a4 = v5;
  }
}

uint64_t sub_1000AEB6C@<X0>(unint64_t a1@<X8>)
{
  unsigned __int16 *v1;
  uint64_t v2;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unsigned __int8 v7;
  unsigned __int8 v8;
  uint64_t v9;
  unint64_t v10;
  double v11;
  unint64_t v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t result;
  char v23;
  __int16 v24;
  char v25;
  __int16 v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unsigned __int8 v32;
  unint64_t v33;
  __int16 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  char v39;
  char v40;
  char v41;
  __int128 v42;
  char v43;
  _BYTE v44[16];
  uint64_t v45;
  char v46;

  v4 = *v1;
  v5 = sub_10007CE78(3, 2, *v1, a1);
  v6 = v2;
  if (v2)
    goto LABEL_23;
  v7 = _s7CoreP2P20NANAvailabilityEntryV15UsagePreferenceO8rawValueAESgSi_tcfC_0(v5);
  if (v7 == 4)
  {
LABEL_22:
    v30 = sub_100012C84();
    v6 = swift_allocError(&type metadata for WiFiError, v30, 0, 0);
    *(_OWORD *)v31 = xmmword_100337850;
    *(_BYTE *)(v31 + 16) = 2;
    swift_willThrow(v6);
LABEL_23:
    swift_unexpectedError(v6, "CoreP2P/NANAvailability.swift", 29, 1);
    __break(1u);
    swift_unexpectedError(v4, "CoreP2P/NANAvailability.swift", 29, 1);
    __break(1u);
    goto LABEL_24;
  }
  v8 = v7;
  v9 = sub_10007CE78(5, 2, v4, v7);
  v11 = 0.0;
  if (v9 >= 5)
    goto LABEL_7;
  v11 = (double)v9 * 0.2 * 5.0;
  if ((~*(_QWORD *)&v11 & 0x7FF0000000000000) == 0)
  {
LABEL_21:
    __break(1u);
    goto LABEL_22;
  }
  if (v11 <= -1.0)
  {
    __break(1u);
    goto LABEL_20;
  }
  v10 = 0x4070000000000000;
  if (v11 >= 256.0)
  {
LABEL_20:
    __break(1u);
    goto LABEL_21;
  }
LABEL_7:
  v12 = sub_10007CE78(8, 4, v4, v10);
  v13 = v12;
  if ((v12 & 0x8000000000000000) != 0)
  {
LABEL_24:
    result = _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 3451, 0);
LABEL_26:
    __break(1u);
    return result;
  }
  if (v12 >= 0x100)
  {
    result = _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 3455, 0);
    goto LABEL_26;
  }
  v32 = v8;
  v33 = a1;
  v14 = *((_QWORD *)v1 + 1);
  v15 = *((_QWORD *)v1 + 2);
  v16 = *((_QWORD *)v1 + 3);
  if (v16 >> 60 == 15)
  {
    LOWORD(v17) = TimeBitmap.nanBitmap.getter(0, 0x400uLL, 0);
    v19 = v18;
    v21 = v20;
  }
  else
  {
    v17 = *((_QWORD *)v1 + 1);
    v19 = *((_QWORD *)v1 + 2);
    v21 = *((_QWORD *)v1 + 3);
  }
  sub_100063C28(v14, v15, v16);
  sub_1000AEF4C(v17, v19, v21);
  sub_10000E614(v19, v21);
  v42 = *((_OWORD *)v1 + 2);
  v43 = *((_BYTE *)v1 + 48);
  sub_100063EB8((uint64_t)&v42 + 8, (uint64_t)v44, &qword_1004068E8);
  result = sub_100063EB8((uint64_t)v44, (uint64_t)&v45, &qword_1004068E8);
  if (v46 == 1 && *(_QWORD *)(v45 + 16))
  {
    v23 = *(_BYTE *)(v45 + 32);
    v24 = *(_WORD *)(v45 + 34);
    v25 = *(_BYTE *)(v45 + 36);
    if ((*(_BYTE *)(v45 + 40) & 1) != 0)
      v26 = 0;
    else
      v26 = *(_WORD *)(v45 + 38);
    *(_BYTE *)v33 = v32;
    *(_BYTE *)(v33 + 1) = (int)v11;
    *(_BYTE *)(v33 + 2) = v13;
    *(_WORD *)(v33 + 4) = v34;
    *(_OWORD *)(v33 + 6) = v35;
    *(_OWORD *)(v33 + 22) = v36;
    *(_OWORD *)(v33 + 38) = v37;
    *(_OWORD *)(v33 + 54) = v38;
    *(_BYTE *)(v33 + 70) = v39;
    *(_BYTE *)(v33 + 71) = v40;
    *(_BYTE *)(v33 + 72) = v41;
    *(_BYTE *)(v33 + 74) = v23;
    *(_BYTE *)(v33 + 75) = v25;
    *(_WORD *)(v33 + 76) = v24;
    *(_WORD *)(v33 + 78) = v26;
  }
  else
  {
    v27 = sub_100012C84();
    v28 = swift_allocError(&type metadata for WiFiError, v27, 0, 0);
    *(_OWORD *)v29 = xmmword_10033B1E0;
    *(_BYTE *)(v29 + 16) = 0;
    return swift_willThrow(v28);
  }
  return result;
}

void sub_1000AEF4C(__int16 a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;

  v5 = sub_10007CA7C(6, 9, a1, __stack_chk_guard);
  if ((v5 & 0x8000000000000000) != 0)
  {
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 3451, 0);
  }
  else
  {
    if (v5 < 0x10000)
    {
      v6 = sub_10007CBAC(3uLL, 3, a1);
      _s7CoreP2P14IEEE80211FrameV10ManagementO14AuthenticationO0F9AlgorithmO8rawValueAISgs5UInt8V_tcfC_0(v6);
      v7 = sub_10007CBAC(0, 3, a1);
      if (_s7CoreP2P19NANIntervalDurationO8rawValueACSgs5UInt8V_tcfC_0(v7) == 4)
        __asm { BR              X11 }
      __asm { BR              X11 }
    }
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 3455, 0);
  }
  __break(1u);
  JUMPOUT(0x1000AF1F4);
}

void sub_1000AF214(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *v4;
  uint64_t v5;
  unint64_t *v7;
  _BYTE *v8;
  char v9;
  uint64_t v10;
  unint64_t v11;
  __int16 v12;
  __int16 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int16 v18;
  char v19;

  if (a4)
    v4 = a4;
  else
    v4 = _swiftEmptyArrayStorage;
  v5 = v4[2];
  if (v5)
  {
    swift_bridgeObjectRetain(a4);
    v7 = v4 + 7;
    v8 = (_BYTE *)(a1 + 70);
    do
    {
      v9 = *((_BYTE *)v7 - 24);
      v10 = *(v7 - 1);
      v11 = *v7;
      v12 = *((_WORD *)v7 - 8);
      sub_100031FEC(v10, *v7);
      sub_1000AEF4C(v12, v10, v11);
      *(v8 - 70) = v9;
      *((_WORD *)v8 - 34) = v13;
      *(_OWORD *)(v8 - 66) = v14;
      *(_OWORD *)(v8 - 50) = v15;
      *(_OWORD *)(v8 - 34) = v16;
      *(_OWORD *)(v8 - 18) = v17;
      *((_WORD *)v8 - 1) = v18;
      *v8 = v19;
      v8 += 72;
      sub_10000E614(v10, v11);
      v7 += 4;
      --v5;
    }
    while (v5);
  }
  else
  {
    swift_bridgeObjectRetain(a4);
  }
  swift_bridgeObjectRelease(v4);
}

uint64_t sub_1000AF31C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, _QWORD *a7)
{
  uint64_t v7;
  uint64_t v13;
  uint64_t v14;
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  uint64_t result;

  v13 = *(_QWORD *)(a5 + 8);
  v14 = *(_QWORD *)(a6 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v13, a4, &protocol requirements base descriptor for DeviceDriver);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a4, AssociatedTypeWitness, &protocol requirements base descriptor for IO80211Driver, &associated conformance descriptor for IO80211Driver.DeviceDriver.Device: IO80211Device);
  result = sub_1000AB204(364, a1, a2, a4, v13, v14, AssociatedConformanceWitness);
  if (v7)
    *a7 = v7;
  return result;
}

uint64_t sub_1000AF3EC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;

  v5 = sub_100012C44(&qword_1004068E0);
  sub_100177494(a1, (uint64_t)sub_1000AF460, 0, a3, (uint64_t)&type metadata for Never, v5, (uint64_t)&protocol witness table for Never, v6);
  return v8;
}

uint64_t sub_1000AF460@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  double *v7;
  double v8;
  double v9;
  double v10;
  id v11;
  uint64_t v12;
  uint64_t v13;

  if (!result)
    goto LABEL_6;
  v4 = result;
  v5 = a2 - result;
  if ((unint64_t)(a2 - result + 23) < 0x2F)
    goto LABEL_6;
  v6 = v5 / 24;
  result = specialized ContiguousArray.reserveCapacity(_:)(v5 / 24);
  if (v5 >= -23)
  {
    v7 = (double *)(v4 + 16);
    do
    {
      v8 = *(v7 - 2);
      v9 = *(v7 - 1);
      v10 = *v7;
      v7 += 3;
      v11 = objc_msgSend(objc_allocWithZone((Class)WiFiAwareDataSessionStatisticsHistogramBin), "initWithBinStart:binEnd:value:", v8, v9, v10);
      specialized ContiguousArray._makeUniqueAndReserveCapacityIfNotUnique()();
      v12 = _swiftEmptyArrayStorage[2];
      specialized ContiguousArray._reserveCapacityAssumingUniqueBuffer(oldCount:)(v12);
      v13 = specialized ContiguousArray._appendElementAssumeUniqueAndCapacity(_:newElement:)(v12, v11);
      result = specialized ContiguousArray._endMutation()(v13);
      --v6;
    }
    while (v6);
LABEL_6:
    *a3 = _swiftEmptyArrayStorage;
    return result;
  }
  __break(1u);
  return result;
}

uint64_t sub_1000AF594(unsigned int a1)
{
  if (a1 > 0x14)
    return 3;
  else
    return qword_10033F920[a1];
}

uint64_t sub_1000AF5B4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;

  v6 = sub_100011DE4(&qword_1004068A8, (uint64_t (*)(uint64_t))type metadata accessor for apple80211_virtual_if_role, (uint64_t)&unk_100338BC8);
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000AF628(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;

  v6 = sub_100011DE4(&qword_1004068A8, (uint64_t (*)(uint64_t))type metadata accessor for apple80211_virtual_if_role, (uint64_t)&unk_100338BC8);
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

uint64_t Channel.apple80211Channel.getter(uint64_t a1)
{
  if (qword_100404148 != -1)
    swift_once(&qword_100404148, sub_10018F9E0);
  sub_10009B344(a1, qword_100409F40);
  return (a1 << 32) | 1;
}

uint64_t sub_1000AF748(uint64_t a1)
{
  unsigned int v1;
  int v2;
  int v3;
  unsigned int v4;

  v1 = a1;
  if ((BYTE5(a1) - 2) >= 5u)
  {
    if ((a1 & 0x10000000000) != 0)
      v2 = 516;
    else
      v2 = 4;
  }
  else
  {
    v2 = dword_10033F9D4[(char)(BYTE5(a1) - 2)];
  }
  v3 = dword_10033F9C8[a1 << 24 >> 56];
  if (qword_100404148 != -1)
    swift_once(&qword_100404148, sub_10018F9E0);
  v4 = v3 | v2;
  if (sub_10009B344(v1, qword_100409F40))
    return v4 | 0x100;
  else
    return v4;
}

int8x8_t sub_1000AF7FC@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint8x8_t v2;
  char v4;
  char v5;
  int v6;
  int v7;
  int v8;
  int v9;
  __int16 v10;
  unsigned __int8 v11;
  unsigned __int8 v12;
  __int16 v13;
  __int16 v14;
  __int16 v15;
  int v16;
  char v17;
  char v18;
  __int16 v19;
  char v20;
  char v21;
  unsigned __int8 v22;
  __int16 v23;
  __int16 v24;
  __int16 v25;
  unsigned __int8 v26;
  unsigned __int8 v27;
  __int16 v28;
  __int16 v29;
  __int16 v30;
  unsigned __int8 v31;
  unsigned __int8 v32;
  __int16 v33;
  __int16 v34;
  int8x8_t result;
  int v36;
  int v37;
  int v38;
  int16x8_t v39;

  v2.i32[0] = *(_DWORD *)a1;
  v4 = *(_BYTE *)(a1 + 4);
  v5 = *(_BYTE *)(a1 + 5);
  v6 = *(_DWORD *)(a1 + 8);
  v8 = *(_DWORD *)(a1 + 20);
  v7 = *(_DWORD *)(a1 + 24);
  v9 = *(_DWORD *)(a1 + 28);
  v36 = *(_DWORD *)(a1 + 32);
  v37 = *(_DWORD *)(a1 + 36);
  v38 = *(_DWORD *)(a1 + 40);
  if ((v6 & 1) != 0)
  {
    v16 = *(_DWORD *)(a1 + 24);
    v7 = *(_DWORD *)(a1 + 28);
    v17 = *(_BYTE *)(a1 + 5);
    v18 = *(_BYTE *)(a1 + 4);
    v19 = *(_WORD *)(a1 + 16);
    v20 = _s7CoreP2P15IEEE80211StatusO8rawValueACSgs6UInt16V_tcfC_0(*(_WORD *)(a1 + 12) & 0x1FF);
    if (v20 == 54)
      v21 = 1;
    else
      v21 = v20;
    v4 = v18;
    v5 = v17;
    LOWORD(v9) = v7;
    LOWORD(v7) = v16;
    v22 = v21;
    v23 = _s7CoreP2P15IEEE80211ReasonO8rawValueACSgs6UInt16V_tcfC_0(v19 & 0x1FF);
    if (v23 == 34)
      v24 = 1;
    else
      v24 = v23;
    v10 = v22 | (unsigned __int16)(v24 << 8);
    if ((v6 & 2) != 0)
      goto LABEL_3;
LABEL_17:
    v15 = 8704;
    goto LABEL_18;
  }
  v10 = 8704;
  if ((v6 & 2) == 0)
    goto LABEL_17;
LABEL_3:
  v11 = _s7CoreP2P15IEEE80211StatusO8rawValueACSgs6UInt16V_tcfC_0(v8 & 0x1FF);
  if (v11 == 54)
    v12 = 1;
  else
    v12 = v11;
  v13 = _s7CoreP2P15IEEE80211ReasonO8rawValueACSgs6UInt16V_tcfC_0(v7 & 0x1FF);
  if (v13 == 34)
    v14 = 1;
  else
    v14 = v13;
  v15 = v12 | (unsigned __int16)(v14 << 8);
LABEL_18:
  v39 = (int16x8_t)vmovl_u8(v2);
  if ((v6 & 4) != 0)
  {
    v31 = _s7CoreP2P15IEEE80211StatusO8rawValueACSgs6UInt16V_tcfC_0(v9 & 0x1FF);
    if (v31 == 54)
      v32 = 1;
    else
      v32 = v31;
    v33 = _s7CoreP2P15IEEE80211ReasonO8rawValueACSgs6UInt16V_tcfC_0(v36 & 0x1FF);
    if (v33 == 34)
      v34 = 1;
    else
      v34 = v33;
    v25 = v32 | (unsigned __int16)(v34 << 8);
    if ((v6 & 8) != 0)
      goto LABEL_20;
LABEL_34:
    v30 = 8704;
    goto LABEL_35;
  }
  v25 = 8704;
  if ((v6 & 8) == 0)
    goto LABEL_34;
LABEL_20:
  v26 = _s7CoreP2P15IEEE80211StatusO8rawValueACSgs6UInt16V_tcfC_0(v37 & 0x1FF);
  if (v26 == 54)
    v27 = 1;
  else
    v27 = v26;
  v28 = _s7CoreP2P15IEEE80211ReasonO8rawValueACSgs6UInt16V_tcfC_0(v38 & 0x1FF);
  if (v28 == 34)
    v29 = 1;
  else
    v29 = v28;
  v30 = v27 | (unsigned __int16)(v29 << 8);
LABEL_35:
  result = vmovn_s16(v39);
  *(_DWORD *)a2 = result.i32[0];
  *(_BYTE *)(a2 + 4) = v4;
  *(_BYTE *)(a2 + 5) = v5;
  *(_WORD *)(a2 + 6) = v10;
  *(_WORD *)(a2 + 8) = v15;
  *(_WORD *)(a2 + 10) = v25;
  *(_WORD *)(a2 + 12) = v30;
  return result;
}

unint64_t WiFiNetwork.createRecord()(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4)
{
  char v5;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t inited;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  unint64_t v22;
  _BYTE v23[280];

  v5 = a3;
  v8 = a3 >> 8;
  v9 = a3 >> 16;
  v10 = a3 >> 24;
  v11 = HIDWORD(a3);
  v22 = a3 >> 40;
  v12 = sub_100012C44(qword_100405C70);
  inited = swift_initStackObject(v12, v23);
  *(_OWORD *)(inited + 16) = xmmword_10033F050;
  *(_QWORD *)(inited + 32) = 0x5254535F44495353;
  *(_QWORD *)(inited + 40) = 0xE800000000000000;
  *(_QWORD *)(inited + 48) = a1;
  *(_QWORD *)(inited + 56) = a2;
  *(_QWORD *)(inited + 72) = &type metadata for String;
  *(_QWORD *)(inited + 80) = 1145656147;
  *(_QWORD *)(inited + 88) = 0xE400000000000000;
  swift_bridgeObjectRetain_n(a2, 2);
  *(_QWORD *)(inited + 96) = sub_1000FAE78(a1, a2);
  *(_QWORD *)(inited + 104) = v14;
  *(_QWORD *)(inited + 120) = &type metadata for Data;
  *(_QWORD *)(inited + 128) = 0x4449535342;
  *(_QWORD *)(inited + 136) = 0xE500000000000000;
  v15 = sub_100012C44(&qword_100403E88);
  v16 = swift_allocObject(v15, 38, 7);
  *(_OWORD *)(v16 + 16) = xmmword_10033B190;
  *(_BYTE *)(v16 + 32) = v5;
  *(_BYTE *)(v16 + 33) = v8;
  *(_BYTE *)(v16 + 34) = v9;
  *(_BYTE *)(v16 + 35) = v10;
  *(_BYTE *)(v16 + 36) = v11;
  *(_BYTE *)(v16 + 37) = v22;
  v17 = sub_1001068EC(v16);
  v19 = v18;
  swift_bridgeObjectRelease(v16);
  *(_QWORD *)(inited + 144) = v17;
  *(_QWORD *)(inited + 152) = v19;
  *(_QWORD *)(inited + 168) = &type metadata for Data;
  *(_QWORD *)(inited + 176) = 0x4C454E4E414843;
  *(_QWORD *)(inited + 184) = 0xE700000000000000;
  *(_DWORD *)(inited + 192) = a4;
  *(_QWORD *)(inited + 216) = &type metadata for UInt32;
  strcpy((char *)(inited + 224), "CHANNEL_FLAGS");
  *(_WORD *)(inited + 238) = -4864;
  v20 = sub_1000AF748(a4 & 0xFFFFFFFFFFFFLL);
  *(_QWORD *)(inited + 264) = &type metadata for UInt32;
  *(_DWORD *)(inited + 240) = v20;
  return sub_10001EDC4(inited);
}

void sub_1000AFB88(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  __asm { BR              X9 }
}

uint64_t sub_1000AFBCC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;

  v9 = sub_1000FBFC4(0, *(unsigned __int8 *)(a6 + 4), v7, v6);
  return ((uint64_t (*)(uint64_t, uint64_t))((char *)&loc_1000AFBF4 + *((int *)qword_1000AFCD8 + v8)))(v9, v9);
}

uint64_t sub_1000AFC08(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;

  if (a2 < 0)
  {
    __break(1u);
    JUMPOUT(0x1000AFCC8);
  }
  v3 = ((uint64_t (*)(_QWORD))Data._Representation.subscript.getter)(0);
  v5 = v4;
  sub_10005248C(v3, v4, v2);
  return sub_10000E614(v3, v5);
}

void sub_1000AFCE8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __asm { BR              X11 }
}

uint64_t sub_1000AFD38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t result;

  if (a5 < 0)
  {
    __break(1u);
    JUMPOUT(0x1000AFDD0);
  }
  v8 = ((uint64_t (*)(_QWORD, uint64_t))Data._Representation.subscript.getter)(0, a5);
  v10 = v9;
  v11 = sub_100068D00();
  v12 = DataProtocol.copyBytes(to:)(v7, v6, &type metadata for Data, v11);
  result = sub_10000E614(v8, v10);
  *v5 = v12;
  return result;
}

double sub_1000AFDE0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v7;
  _WORD *v8;
  _WORD *v9;
  __int16 v10;
  __int128 v11;
  double result;

  if ((a5 & 0x8000000000000000) != 0)
  {
    __break(1u);
LABEL_12:
    __break(1u);
  }
  if (*(_QWORD *)(a4 + 16) < a5)
    goto LABEL_12;
  if (a5)
  {
    swift_bridgeObjectRetain(a4);
    sub_1000750CC(0, a5, 0);
    if (a5)
      __asm { BR              X11 }
    __break(1u);
    JUMPOUT(0x1000AFFE8);
  }
  v7 = _swiftEmptyArrayStorage[2];
  if (v7)
  {
    v8 = (_WORD *)(a1 + 32);
    v9 = &_swiftEmptyArrayStorage[8];
    do
    {
      v10 = *v9;
      v11 = *((_OWORD *)v9 - 1);
      *((_OWORD *)v8 - 2) = *((_OWORD *)v9 - 2);
      *((_OWORD *)v8 - 1) = v11;
      *v8 = v10;
      v8 += 17;
      v9 += 17;
      --v7;
    }
    while (v7);
  }
  *(_QWORD *)&result = swift_bridgeObjectRelease(_swiftEmptyArrayStorage).n128_u64[0];
  return result;
}

uint64_t AWDLActionFrame.Header.init(from:)@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  _QWORD v19[3];
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;

  v5 = a1[3];
  v6 = a1[4];
  sub_10003259C(a1, v5);
  dispatch thunk of Decoder.unkeyedContainer()(v19, v5, v6);
  if (!v2)
  {
    v7 = v20;
    v8 = v21;
    sub_100034C68((uint64_t)v19, v20);
    v9 = UnkeyedDecodingContainer.decodeData(with:)(72, v7, v8);
    v11 = v9;
    v12 = v10;
    sub_100213340(v9, v10);
    sub_10000E614(v11, v12);
    v24 = v16;
    v25 = v17;
    v26 = v18;
    v22 = v14;
    v23 = v15;
    sub_1000AD79C(a2);
    sub_100014430(v19);
  }
  return sub_100014430(a1);
}

uint64_t sub_1000B0190@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X8>)
{
  return AWDLActionFrame.Header.init(from:)(a1, a2);
}

unint64_t sub_1000B01A4@<X0>(unint64_t result@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  int64_t v4;
  unint64_t v5;
  unsigned int *v6;
  unsigned int v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;

  v4 = *(unsigned __int8 *)(a2 + 5);
  if (*(_BYTE *)(a2 + 5))
  {
    v5 = result;
    sub_100075000(0, v4, 0);
    v6 = (unsigned int *)(v5 + 4);
    do
    {
      v7 = *v6;
      v6 += 3;
      result = sub_100192784(v7);
      v8 = result;
      v10 = _swiftEmptyArrayStorage[2];
      v9 = _swiftEmptyArrayStorage[3];
      if (v10 >= v9 >> 1)
        result = sub_100075000(v9 > 1, v10 + 1, 1);
      _swiftEmptyArrayStorage[2] = v10 + 1;
      v11 = &_swiftEmptyArrayStorage[v10];
      *((_DWORD *)v11 + 8) = v8;
      *((_WORD *)v11 + 18) = WORD2(v8);
      --v4;
    }
    while (v4);
  }
  *a3 = _swiftEmptyArrayStorage;
  return result;
}

unint64_t sub_1000B0280@<X0>(unint64_t result@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  int64_t v4;
  unint64_t v5;
  unsigned int *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;

  v4 = *(unsigned __int8 *)(a2 + 5);
  if (*(_BYTE *)(a2 + 5))
  {
    v5 = result;
    sub_100075000(0, v4, 0);
    v6 = (unsigned int *)(v5 + 8);
    do
    {
      result = sub_1000B388C(*(v6 - 1), *v6);
      v7 = result;
      v9 = _swiftEmptyArrayStorage[2];
      v8 = _swiftEmptyArrayStorage[3];
      if (v9 >= v8 >> 1)
        result = sub_100075000(v8 > 1, v9 + 1, 1);
      v6 += 3;
      _swiftEmptyArrayStorage[2] = v9 + 1;
      v10 = &_swiftEmptyArrayStorage[v9];
      *((_DWORD *)v10 + 8) = v7;
      *((_WORD *)v10 + 18) = WORD2(v7);
      --v4;
    }
    while (v4);
  }
  *a3 = _swiftEmptyArrayStorage;
  return result;
}

BOOL static apple80211_p2p_airplay_statistics.== infix(_:_:)(_OWORD *a1, _OWORD *a2)
{
  __int128 v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  _OWORD v15[13];
  _OWORD __s1[13];

  v2 = a1[11];
  __s1[10] = a1[10];
  __s1[11] = v2;
  __s1[12] = a1[12];
  v3 = a1[7];
  __s1[6] = a1[6];
  __s1[7] = v3;
  v4 = a1[9];
  __s1[8] = a1[8];
  __s1[9] = v4;
  v5 = a1[3];
  __s1[2] = a1[2];
  __s1[3] = v5;
  v6 = a1[5];
  __s1[4] = a1[4];
  __s1[5] = v6;
  v7 = a1[1];
  __s1[0] = *a1;
  __s1[1] = v7;
  v8 = a2[11];
  v15[10] = a2[10];
  v15[11] = v8;
  v15[12] = a2[12];
  v9 = a2[7];
  v15[6] = a2[6];
  v15[7] = v9;
  v10 = a2[9];
  v15[8] = a2[8];
  v15[9] = v10;
  v11 = a2[3];
  v15[2] = a2[2];
  v15[3] = v11;
  v12 = a2[5];
  v15[4] = a2[4];
  v15[5] = v12;
  v13 = a2[1];
  v15[0] = *a2;
  v15[1] = v13;
  return memcmp(__s1, v15, 0xD0uLL) == 0;
}

BOOL static apple80211_awdl_low_latency_statistics.== infix(_:_:)(const void *a1, const void *a2)
{
  _BYTE __s2[4000];
  _BYTE __dst[4000];

  memcpy(__dst, a1, sizeof(__dst));
  memcpy(__s2, a2, sizeof(__s2));
  return memcmp(__dst, __s2, 0xFA0uLL) == 0;
}

unint64_t sub_1000B04D4@<X0>(unsigned __int8 *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  int v8;
  __int16 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t result;
  uint64_t v14;
  void (*v15)(_QWORD *, _QWORD, uint64_t);
  __int16 v16;
  char v17;
  char v18;
  char v19;
  char v20;
  char v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  int v48;

  v4 = type metadata accessor for DispatchTimeInterval(0);
  v5 = *(_QWORD *)(v4 - 8);
  __chkstk_darwin();
  v7 = (uint64_t *)((char *)&v26 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0));
  *(_WORD *)(a2 + 36) = 3;
  *(_DWORD *)(a2 + 32) = 0;
  *(_WORD *)(a2 + 44) = 3;
  *(_DWORD *)(a2 + 40) = 0;
  *(_WORD *)(a2 + 52) = 3;
  *(_DWORD *)(a2 + 48) = 0;
  *(_WORD *)(a2 + 60) = 3;
  *(_DWORD *)(a2 + 56) = 0;
  v8 = *a1;
  v9 = a1[8];
  v48 = a1[9];
  v10 = *((int *)a1 + 3);
  v11 = *((int *)a1 + 4);
  v12 = *((unsigned int *)a1 + 5);
  v47 = sub_1000B388C(*((_DWORD *)a1 + 7), *((_DWORD *)a1 + 8));
  v46 = sub_1000B388C(*((_DWORD *)a1 + 10), *((_DWORD *)a1 + 11));
  v45 = sub_1000B388C(*((_DWORD *)a1 + 13), *((_DWORD *)a1 + 14));
  result = sub_1000B388C(*((_DWORD *)a1 + 16), *((_DWORD *)a1 + 17));
  v14 = *((_QWORD *)a1 + 13);
  if (v14 < 0)
  {
    __break(1u);
  }
  else
  {
    v44 = a1[96];
    v43 = *((unsigned int *)a1 + 23);
    v42 = *((unsigned int *)a1 + 22);
    *((_QWORD *)&v41 + 1) = *((unsigned int *)a1 + 21);
    *(_QWORD *)&v41 = *((unsigned int *)a1 + 20);
    *((_QWORD *)&v40 + 1) = *((unsigned int *)a1 + 19);
    *(_QWORD *)&v40 = *((unsigned int *)a1 + 18);
    *v7 = v14;
    v15 = *(void (**)(_QWORD *, _QWORD, uint64_t))(v5 + 104);
    v27 = result;
    v15(v7, enum case for DispatchTimeInterval.seconds(_:), v4);
    v39 = *((unsigned int *)a1 + 28);
    v37 = *((unsigned int *)a1 + 29);
    v35 = *((unsigned int *)a1 + 30);
    v32 = *((unsigned int *)a1 + 31);
    v31 = *((unsigned int *)a1 + 32);
    v30 = *((unsigned int *)a1 + 33);
    v28 = *((unsigned int *)a1 + 34);
    v26 = *((unsigned int *)a1 + 35);
    v16 = *((_WORD *)a1 + 72);
    v38 = v11;
    v17 = a1[146];
    v29 = v7;
    v18 = a1[147];
    v36 = v12;
    v19 = a1[148];
    v33 = v8;
    v20 = a1[149];
    v34 = v10;
    v21 = a1[150];
    v22 = a1[151];
    v23 = WiFiAddress.description.getter(*((unsigned __int16 *)a1 + 76) | ((unint64_t)*(unsigned int *)(a1 + 154) << 16));
    sub_1001507D4(v33, v9 | ((_WORD)v48 << 8), v34, v38, v36, v47 & 0xFFFFFFFFFFFFLL, v46 & 0xFFFFFFFFFFFFLL, v45 & 0xFFFFFFFFFFFFLL, a2, v27, (v27 & 0xFFFFFFFFFFFFLL) >> 32, v40, v41, v42, v43, v44, (uint64_t)v29, v39, v37,
      v35,
      v32,
      v31,
      v30,
      v28,
      v26,
      v16,
      v17,
      v18,
      v19,
      v20,
      v21,
      v22,
      v23,
      v24,
      a1[158],
      *((unsigned int *)a1 + 40),
      *((unsigned int *)a1 + 41),
      *((unsigned int *)a1 + 42),
      *((unsigned int *)a1 + 43));
    v25 = type metadata accessor for AWDLStatistics.LowLatencyStatistics.Configuration(0);
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(v25 - 8) + 56))(a2, 0, 1, v25);
  }
  return result;
}

_QWORD *sub_1000B07EC(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *result;
  unint64_t v11;
  uint64_t i;
  uint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  _BYTE v16[16];
  uint64_t v17;
  __int128 v18;
  uint64_t v19;
  __int128 v20;
  uint64_t v21;
  __int128 v22;
  uint64_t v23;
  __int128 v24;
  uint64_t v25;
  __int128 v26;
  uint64_t v27;
  __int128 v28;
  uint64_t v29;
  __int128 v30;
  uint64_t v31;
  __int128 v32;
  uint64_t v33;
  __int128 v34;
  uint64_t v35;

  v1 = *(_QWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 64);
  v3 = *(_QWORD *)(a1 + 88);
  v4 = *(_QWORD *)(a1 + 112);
  v5 = *(_QWORD *)(a1 + 136);
  v6 = *(_QWORD *)(a1 + 160);
  v7 = *(_QWORD *)(a1 + 184);
  v8 = *(_QWORD *)(a1 + 208);
  v9 = *(_QWORD *)(a1 + 232);
  v17 = *(_QWORD *)(a1 + 16);
  v18 = *(_OWORD *)(a1 + 24);
  v19 = v1;
  v20 = *(_OWORD *)(a1 + 48);
  v21 = v2;
  v22 = *(_OWORD *)(a1 + 72);
  v23 = v3;
  v24 = *(_OWORD *)(a1 + 96);
  v26 = *(_OWORD *)(a1 + 120);
  v25 = v4;
  v27 = v5;
  v28 = *(_OWORD *)(a1 + 144);
  v30 = *(_OWORD *)(a1 + 168);
  v29 = v6;
  v31 = v7;
  v32 = *(_OWORD *)(a1 + 192);
  v34 = *(_OWORD *)(a1 + 216);
  v33 = v8;
  v35 = v9;
  sub_100075040(0, 10, 0);
  result = _swiftEmptyArrayStorage;
  v11 = _swiftEmptyArrayStorage[2];
  for (i = 16; i != 256; i += 24)
  {
    v13 = *(_QWORD *)&v16[i];
    v15 = result;
    v14 = result[3];
    if (v11 >= v14 >> 1)
    {
      sub_100075040(v14 > 1, v11 + 1, 1);
      result = v15;
    }
    result[2] = v11 + 1;
    result[v11++ + 4] = v13;
  }
  return result;
}

_QWORD *sub_1000B0970(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *result;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  int64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  int64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  int64_t v22;

  v1 = a1[2];
  v2 = a1[5];
  v3 = a1[8];
  v4 = a1[11];
  v5 = a1[14];
  v6 = a1[17];
  sub_100075040(0, 6, 0);
  result = _swiftEmptyArrayStorage;
  v9 = _swiftEmptyArrayStorage[2];
  v8 = _swiftEmptyArrayStorage[3];
  v10 = v8 >> 1;
  v11 = v9 + 1;
  if (v8 >> 1 <= v9)
  {
    sub_100075040(v8 > 1, v9 + 1, 1);
    result = _swiftEmptyArrayStorage;
    v8 = _swiftEmptyArrayStorage[3];
    v10 = v8 >> 1;
  }
  _swiftEmptyArrayStorage[2] = v11;
  _swiftEmptyArrayStorage[v9 + 4] = v1;
  v12 = v9 + 2;
  if (v10 <= v11)
  {
    sub_100075040(v8 > 1, v12, 1);
    result = _swiftEmptyArrayStorage;
  }
  _swiftEmptyArrayStorage[2] = v12;
  _swiftEmptyArrayStorage[v11 + 4] = v2;
  v14 = _swiftEmptyArrayStorage[2];
  v13 = _swiftEmptyArrayStorage[3];
  v15 = v13 >> 1;
  v16 = v14 + 1;
  if (v13 >> 1 <= v14)
  {
    sub_100075040(v13 > 1, v14 + 1, 1);
    result = _swiftEmptyArrayStorage;
    v13 = _swiftEmptyArrayStorage[3];
    v15 = v13 >> 1;
  }
  _swiftEmptyArrayStorage[2] = v16;
  _swiftEmptyArrayStorage[v14 + 4] = v3;
  v17 = v14 + 2;
  if (v15 <= v16)
  {
    sub_100075040(v13 > 1, v17, 1);
    result = _swiftEmptyArrayStorage;
  }
  _swiftEmptyArrayStorage[2] = v17;
  _swiftEmptyArrayStorage[v16 + 4] = v4;
  v19 = _swiftEmptyArrayStorage[2];
  v18 = _swiftEmptyArrayStorage[3];
  v20 = v18 >> 1;
  v21 = v19 + 1;
  if (v18 >> 1 <= v19)
  {
    sub_100075040(v18 > 1, v19 + 1, 1);
    result = _swiftEmptyArrayStorage;
    v18 = _swiftEmptyArrayStorage[3];
    v20 = v18 >> 1;
  }
  _swiftEmptyArrayStorage[2] = v21;
  _swiftEmptyArrayStorage[v19 + 4] = v5;
  v22 = v19 + 2;
  if (v20 <= v21)
  {
    sub_100075040(v18 > 1, v22, 1);
    result = _swiftEmptyArrayStorage;
  }
  _swiftEmptyArrayStorage[2] = v22;
  _swiftEmptyArrayStorage[v21 + 4] = v6;
  return result;
}

_QWORD *sub_1000B0BAC(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *result;
  unint64_t v10;
  uint64_t i;
  uint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _BYTE v15[16];
  uint64_t v16;
  __int128 v17;
  uint64_t v18;
  __int128 v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  __int128 v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  __int128 v29;
  uint64_t v30;
  __int128 v31;
  uint64_t v32;

  v1 = *(_QWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 64);
  v3 = *(_QWORD *)(a1 + 88);
  v4 = *(_QWORD *)(a1 + 112);
  v5 = *(_QWORD *)(a1 + 136);
  v6 = *(_QWORD *)(a1 + 160);
  v7 = *(_QWORD *)(a1 + 184);
  v8 = *(_QWORD *)(a1 + 208);
  v16 = *(_QWORD *)(a1 + 16);
  v17 = *(_OWORD *)(a1 + 24);
  v18 = v1;
  v19 = *(_OWORD *)(a1 + 48);
  v20 = v2;
  v21 = *(_OWORD *)(a1 + 72);
  v22 = v3;
  v23 = *(_OWORD *)(a1 + 96);
  v25 = *(_OWORD *)(a1 + 120);
  v24 = v4;
  v26 = v5;
  v27 = *(_OWORD *)(a1 + 144);
  v29 = *(_OWORD *)(a1 + 168);
  v28 = v6;
  v30 = v7;
  v31 = *(_OWORD *)(a1 + 192);
  v32 = v8;
  sub_100075040(0, 9, 0);
  result = _swiftEmptyArrayStorage;
  v10 = _swiftEmptyArrayStorage[2];
  for (i = 16; i != 232; i += 24)
  {
    v12 = *(_QWORD *)&v15[i];
    v14 = result;
    v13 = result[3];
    if (v10 >= v13 >> 1)
    {
      sub_100075040(v13 > 1, v10 + 1, 1);
      result = v14;
    }
    result[2] = v10 + 1;
    result[v10++ + 4] = v12;
  }
  return result;
}

_QWORD *sub_1000B0D20(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *result;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  int64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  int64_t v15;

  v1 = a1[2];
  v2 = a1[5];
  v3 = a1[8];
  v4 = a1[11];
  sub_100075040(0, 4, 0);
  result = _swiftEmptyArrayStorage;
  v7 = _swiftEmptyArrayStorage[2];
  v6 = _swiftEmptyArrayStorage[3];
  v8 = v6 >> 1;
  v9 = v7 + 1;
  if (v6 >> 1 <= v7)
  {
    sub_100075040(v6 > 1, v7 + 1, 1);
    result = _swiftEmptyArrayStorage;
    v6 = _swiftEmptyArrayStorage[3];
    v8 = v6 >> 1;
  }
  _swiftEmptyArrayStorage[2] = v9;
  _swiftEmptyArrayStorage[v7 + 4] = v1;
  v10 = v7 + 2;
  if (v8 <= v9)
  {
    sub_100075040(v6 > 1, v10, 1);
    result = _swiftEmptyArrayStorage;
  }
  _swiftEmptyArrayStorage[2] = v10;
  _swiftEmptyArrayStorage[v9 + 4] = v2;
  v12 = _swiftEmptyArrayStorage[2];
  v11 = _swiftEmptyArrayStorage[3];
  v13 = v11 >> 1;
  v14 = v12 + 1;
  if (v11 >> 1 <= v12)
  {
    sub_100075040(v11 > 1, v12 + 1, 1);
    result = _swiftEmptyArrayStorage;
    v11 = _swiftEmptyArrayStorage[3];
    v13 = v11 >> 1;
  }
  _swiftEmptyArrayStorage[2] = v14;
  _swiftEmptyArrayStorage[v12 + 4] = v3;
  v15 = v12 + 2;
  if (v13 <= v14)
  {
    sub_100075040(v11 > 1, v15, 1);
    result = _swiftEmptyArrayStorage;
  }
  _swiftEmptyArrayStorage[2] = v15;
  _swiftEmptyArrayStorage[v14 + 4] = v4;
  return result;
}

uint64_t sub_1000B0EC4()
{
  uint64_t v0;

  if (*(_BYTE *)(*(_QWORD *)v0 + 32) == 4)
  {
    if (qword_100403F88 != -1)
      swift_once(&qword_100403F88, sub_10012D674);
    return (unsigned __int16)static CountryCode.unknown;
  }
  else
  {
    return (unsigned __int16)sub_1000ABCA8(0x33uLL);
  }
}

uint64_t sub_1000B0F68(__int16 a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, unint64_t))
{
  return a4(51, ((unint64_t)a1 << 32) | ((unint64_t)HIBYTE(a1) << 40));
}

uint64_t sub_1000B0F9C()
{
  uint64_t v0;

  sub_1000ABD84(0x185uLL);
  return v0;
}

uint64_t sub_1000B0FEC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, int *))
{
  int v7;
  char v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  char v13;
  _QWORD v15[4];
  char v16;
  int v17;
  __int16 v18;
  char v19;
  char v20;
  char v21;
  char v22;
  char v23;
  char v24;
  __int16 v25;
  int v26;
  uint64_t v27;
  char v28;
  char v29;
  __int16 v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  int v34;

  sub_100063EB8(a2, (uint64_t)v15, &qword_100405B20);
  if ((v16 & 1) != 0)
  {
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v11 = v15[0];
    v10 = v15[1];
    v12 = 28;
    v13 = 30;
  }
  else
  {
    v11 = 0;
    v10 = 0;
    v13 = 0;
    v12 = 0;
    v9 = 16;
    v7 = v15[0];
    v8 = 2;
  }
  v17 = 1;
  v18 = a1;
  v19 = BYTE2(a1);
  v20 = BYTE3(a1);
  v21 = BYTE4(a1);
  v22 = BYTE5(a1);
  v23 = v9;
  v24 = v8;
  v25 = 0;
  v26 = v7;
  v27 = 0;
  v28 = v12;
  v29 = v13;
  v30 = 0;
  v31 = 0;
  v32 = v11;
  v33 = v10;
  v34 = 0;
  return a5(450, &v17);
}

uint64_t sub_1000B10F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, int *))
{
  int v7;
  char v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  char v13;
  _QWORD v15[4];
  char v16;
  int v17;
  __int16 v18;
  char v19;
  char v20;
  char v21;
  char v22;
  char v23;
  char v24;
  __int16 v25;
  int v26;
  uint64_t v27;
  char v28;
  char v29;
  __int16 v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  int v34;

  sub_100063EB8(a2, (uint64_t)v15, &qword_100405B20);
  if ((v16 & 1) != 0)
  {
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v11 = v15[0];
    v10 = v15[1];
    v12 = 28;
    v13 = 30;
  }
  else
  {
    v11 = 0;
    v10 = 0;
    v13 = 0;
    v12 = 0;
    v9 = 16;
    v7 = v15[0];
    v8 = 2;
  }
  v17 = 1;
  v18 = a1;
  v19 = BYTE2(a1);
  v20 = BYTE3(a1);
  v21 = BYTE4(a1);
  v22 = BYTE5(a1);
  v23 = v9;
  v24 = v8;
  v25 = 0;
  v26 = v7;
  v27 = 0;
  v28 = v12;
  v29 = v13;
  v30 = 0;
  v31 = 0;
  v32 = v11;
  v33 = v10;
  v34 = 0;
  return a5(451, &v17);
}

void sub_1000B11F4(char a1)
{
  __asm { BR              X10 }
}

uint64_t sub_1000B1220(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t, uint64_t, _QWORD))
{
  return a5(503, ((a2 & 1) != 0) | 0x600000000, 1, 0);
}

uint64_t sub_1000B1260(uint64_t a1, uint64_t a2)
{
  return sub_1000B12AC(a1, a2, (uint64_t (*)(_BYTE *, _BYTE *, _BYTE *))variable initialization expression of NANMatchingFilter.matchingFilterList);
}

uint64_t sub_1000B12AC(uint64_t a1, uint64_t a2, uint64_t (*a3)(_BYTE *, _BYTE *, _BYTE *))
{
  _BYTE v5[16];
  _BYTE __src[10016];
  _BYTE v7[10016];

  sub_1000ABE60(0xCFuLL, __src);
  memcpy(v7, __src, sizeof(v7));
  memcpy(__src, v7, sizeof(__src));
  return a3(__src, v7, v5);
}

double sub_1000B1384(uint64_t a1, uint64_t a2)
{
  return sub_1000AAEB8(a1, a2, (uint64_t (*)(_QWORD *))sub_1000B6878);
}

_QWORD *sub_1000B13AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1000B13C8(a1, a2, a3, a4, (uint64_t (*)(_QWORD *))sub_1000B685C);
}

_QWORD *sub_1000B13C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(_QWORD *))
{
  uint64_t *v5;
  _QWORD v7[3];
  uint64_t v8;

  v8 = *v5;
  v7[2] = &v8;
  return sub_100047AAC(a5, (uint64_t)v7, a1, a2, &v8);
}

id sub_1000B1404(void *a1, void *a2, uint64_t a3, uint64_t a4, void *a5, void *a6, void *a7, void *a8, void *a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, char a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22,void *a23,void *a24,void *a25,void *a26,void *a27,void *a28,void *a29,void *a30,void *a31,void *a32,void *a33,void *a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41)
{
  uint64_t v45;
  NSString v46;
  Class v47;
  Class v48;
  Class v49;
  Class v50;
  Class v51;
  Class isa;
  void *v56;
  id v57;

  sub_1000644C8(0, (unint64_t *)&qword_1004068D8, WiFiAwareDataSessionStatisticsHistogramBin_ptr);
  isa = Array._bridgeToObjectiveC()().super.isa;
  swift_bridgeObjectRelease(a3);
  v51 = Array._bridgeToObjectiveC()().super.isa;
  swift_bridgeObjectRelease(a4);
  v46 = String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease(a37);
  v47 = Array._bridgeToObjectiveC()().super.isa;
  swift_bridgeObjectRelease(a38);
  v48 = Array._bridgeToObjectiveC()().super.isa;
  swift_bridgeObjectRelease(a39);
  v49 = Array._bridgeToObjectiveC()().super.isa;
  swift_bridgeObjectRelease(a40);
  v50 = Array._bridgeToObjectiveC()().super.isa;
  LOBYTE(v45) = a16;
  v57 = objc_msgSend(v56, "initWithPeerAddress:infrastructureChannel:txCCAHistogram:rxRSSIHistogram:preferred2GChannelsCount:preferred5GChannelsCount:dfsChannelsCount:csaCount:quietIECount:txErrorCount:packetsOn2GCount:packetsNAVOn2GCount:packetsHOFOn2GCount:packetsOn5GCount:packetsOverridenOn5GCount:infraRelayOperationStatus:infraRelayRequestersCount:txExpiredCount:txNoACKCount:txFailedCount:txNoResourcesCount:txIOErrorCount:txMemoryErrorCount:txChipModeErrorCount:txNoRemotePeerCount:txInternalErrorCount:txDroppedCount:txFirmwareFreePacketCount:txMaxRetriesCount:txForceLifetimeExpiredCount:channelSequenceMismatchOn5GCount:channelSequenceMismatchOn2GCount:infraScanCount:infraAssocCount:infraDisassocCount:countryCode:txConsecutiveErrorsHistogram:rxFWDelayHistogram:rxIPCDelayHistogram:txPacketExpiryHistogram:", a1, a2, isa, v51, a5, a6, swift_bridgeObjectRelease(a41).n128_f64[0], a7, a8, a9,
          a10,
          a11,
          a12,
          a13,
          a14,
          a15,
          v45,
          a17,
          a18,
          a19,
          a20,
          a21,
          a22,
          a23,
          a24,
          a25,
          a26,
          a27,
          a28,
          a29,
          a30,
          a31,
          a32,
          a33,
          a34,
          a35,
          v46,
          v47,
          v48,
          v49,
          v50);

  return v57;
}

_QWORD *sub_1000B1814(_QWORD *result, int64_t a2, char a3, _QWORD *a4)
{
  char v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  int64_t v12;
  uint64_t v13;
  _QWORD *v14;

  v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    v7 = a2;
    goto LABEL_8;
  }
  v6 = a4[3];
  v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2)
    goto LABEL_8;
  if (v7 + 0x4000000000000000 >= 0)
  {
    v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
      v7 = a2;
LABEL_8:
    v8 = a4[2];
    if (v7 <= v8)
      v9 = a4[2];
    else
      v9 = v7;
    if (v9)
    {
      v10 = sub_100012C44(&qword_100406910);
      v11 = (_QWORD *)swift_allocObject(v10, 16 * v9 + 32, 7);
      v12 = j__malloc_size(v11);
      v13 = v12 - 32;
      if (v12 < 32)
        v13 = v12 - 17;
      v11[2] = v8;
      v11[3] = 2 * (v13 >> 4);
      v14 = v11 + 4;
      if ((v5 & 1) != 0)
        goto LABEL_15;
    }
    else
    {
      v11 = _swiftEmptyArrayStorage;
      v14 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
      {
LABEL_15:
        if (v11 != a4 || v14 >= &a4[2 * v8 + 4])
          memmove(v14, a4 + 4, 16 * v8);
        a4[2] = 0;
        goto LABEL_24;
      }
    }
    sub_1000B35A8(0, v8, (unint64_t)v14, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease(a4);
    return v11;
  }
  __break(1u);
  return result;
}

_QWORD *sub_1000B1920(_QWORD *a1, int64_t a2, char a3, _QWORD *a4)
{
  return sub_1000B2624(a1, a2, a3, a4, &qword_100403E88);
}

_QWORD *sub_1000B192C(_QWORD *result, int64_t a2, char a3, _QWORD *a4)
{
  char v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  int64_t v12;
  uint64_t v13;
  _QWORD *v14;

  v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    v7 = a2;
    goto LABEL_8;
  }
  v6 = a4[3];
  v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2)
    goto LABEL_8;
  if (v7 + 0x4000000000000000 >= 0)
  {
    v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
      v7 = a2;
LABEL_8:
    v8 = a4[2];
    if (v7 <= v8)
      v9 = a4[2];
    else
      v9 = v7;
    if (v9)
    {
      v10 = sub_100012C44((uint64_t *)&unk_10040CB00);
      v11 = (_QWORD *)swift_allocObject(v10, 16 * v9 + 32, 7);
      v12 = j__malloc_size(v11);
      v13 = v12 - 32;
      if (v12 < 32)
        v13 = v12 - 17;
      v11[2] = v8;
      v11[3] = 2 * (v13 >> 4);
      v14 = v11 + 4;
      if ((v5 & 1) != 0)
        goto LABEL_15;
    }
    else
    {
      v11 = _swiftEmptyArrayStorage;
      v14 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
      {
LABEL_15:
        if (v11 != a4 || v14 >= &a4[2 * v8 + 4])
          memmove(v14, a4 + 4, 16 * v8);
        a4[2] = 0;
        goto LABEL_24;
      }
    }
    sub_1000B36B0(0, v8, (unint64_t)v14, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease(a4);
    return v11;
  }
  __break(1u);
  return result;
}

_QWORD *sub_1000B1A38(_QWORD *result, int64_t a2, char a3, _QWORD *a4)
{
  char v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  int64_t v12;
  uint64_t v13;
  _QWORD *v14;

  v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    v7 = a2;
    goto LABEL_8;
  }
  v6 = a4[3];
  v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2)
    goto LABEL_8;
  if (v7 + 0x4000000000000000 >= 0)
  {
    v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
      v7 = a2;
LABEL_8:
    v8 = a4[2];
    if (v7 <= v8)
      v9 = a4[2];
    else
      v9 = v7;
    if (v9)
    {
      v10 = sub_100012C44(&qword_100406900);
      v11 = (_QWORD *)swift_allocObject(v10, 16 * v9 + 32, 7);
      v12 = j__malloc_size(v11);
      v13 = v12 - 32;
      if (v12 < 32)
        v13 = v12 - 17;
      v11[2] = v8;
      v11[3] = 2 * (v13 >> 4);
      v14 = v11 + 4;
      if ((v5 & 1) != 0)
        goto LABEL_15;
    }
    else
    {
      v11 = _swiftEmptyArrayStorage;
      v14 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
      {
LABEL_15:
        if (v11 != a4 || v14 >= &a4[2 * v8 + 4])
          memmove(v14, a4 + 4, 16 * v8);
        a4[2] = 0;
        goto LABEL_24;
      }
    }
    sub_1000B34A0(0, v8, (unint64_t)v14, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease(a4);
    return v11;
  }
  __break(1u);
  return result;
}

uint64_t sub_1000B1B44(char a1, int64_t a2, char a3, unint64_t a4)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  size_t v16;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t result;

  if ((a3 & 1) != 0)
  {
    v6 = *(_QWORD *)(a4 + 24);
    v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
LABEL_29:
        result = _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 14377, 0);
LABEL_31:
        __break(1u);
        return result;
      }
      v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
        v7 = a2;
    }
  }
  else
  {
    v7 = a2;
  }
  v8 = *(_QWORD *)(a4 + 16);
  if (v7 <= v8)
    v9 = *(_QWORD *)(a4 + 16);
  else
    v9 = v7;
  if (!v9)
  {
    v15 = _swiftEmptyArrayStorage;
    goto LABEL_19;
  }
  v10 = sub_100012C44(&qword_100406920);
  v11 = *(_QWORD *)(sub_100012C44(&qword_100404EF0) - 8);
  v12 = *(_QWORD *)(v11 + 72);
  v13 = *(unsigned __int8 *)(v11 + 80);
  v14 = (v13 + 32) & ~v13;
  v15 = (_QWORD *)swift_allocObject(v10, v14 + v12 * v9, v13 | 7);
  v16 = j__malloc_size(v15);
  if (!v12)
    goto LABEL_29;
  if (v16 - v14 == 0x8000000000000000 && v12 == -1)
  {
    result = _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 14384, 0);
    goto LABEL_31;
  }
  v15[2] = v8;
  v15[3] = 2 * ((uint64_t)(v16 - v14) / v12);
LABEL_19:
  v18 = sub_100012C44(&qword_100404EF0);
  v19 = *(_QWORD *)(v18 - 8);
  v20 = (*(unsigned __int8 *)(v19 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v19 + 80);
  v21 = (unint64_t)v15 + v20;
  if ((a1 & 1) != 0)
  {
    v22 = a4 + v20;
    if ((unint64_t)v15 < a4 || v21 >= v22 + *(_QWORD *)(v19 + 72) * v8)
    {
      swift_arrayInitWithTakeFrontToBack((char *)v15 + v20, v22, v8, v18);
    }
    else if (v15 != (_QWORD *)a4)
    {
      swift_arrayInitWithTakeBackToFront((char *)v15 + v20);
    }
    *(_QWORD *)(a4 + 16) = 0;
  }
  else
  {
    sub_1000B3938(0, v8, v21, a4);
  }
  swift_bridgeObjectRelease(a4);
  return (uint64_t)v15;
}

_QWORD *sub_1000B1D54(_QWORD *result, int64_t a2, char a3, _QWORD *a4)
{
  char v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  size_t v12;
  _QWORD *v13;

  v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    v7 = a2;
    goto LABEL_8;
  }
  v6 = a4[3];
  v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2)
    goto LABEL_8;
  if (v7 + 0x4000000000000000 >= 0)
  {
    v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
      v7 = a2;
LABEL_8:
    v8 = a4[2];
    if (v7 <= v8)
      v9 = a4[2];
    else
      v9 = v7;
    if (v9)
    {
      v10 = sub_100012C44(&qword_1004068C0);
      v11 = (_QWORD *)swift_allocObject(v10, 6 * v9 + 32, 7);
      v12 = j__malloc_size(v11);
      v11[2] = v8;
      v11[3] = 2 * ((uint64_t)(v12 - 32) / 6);
      v13 = v11 + 4;
      if ((v5 & 1) != 0)
      {
LABEL_13:
        if (v11 != a4 || v13 >= (_QWORD *)((char *)a4 + 6 * v8 + 32))
          memmove(v13, a4 + 4, 6 * v8);
        a4[2] = 0;
        goto LABEL_22;
      }
    }
    else
    {
      v11 = _swiftEmptyArrayStorage;
      v13 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
        goto LABEL_13;
    }
    sub_1000B37A0(0, v8, (char *)v13, (uint64_t)a4);
LABEL_22:
    swift_bridgeObjectRelease(a4);
    return v11;
  }
  __break(1u);
  return result;
}

_QWORD *sub_1000B1E74(_QWORD *result, int64_t a2, char a3, _QWORD *a4)
{
  char v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  int64_t v12;
  uint64_t v13;
  _QWORD *v14;

  v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    v7 = a2;
    goto LABEL_8;
  }
  v6 = a4[3];
  v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2)
    goto LABEL_8;
  if (v7 + 0x4000000000000000 >= 0)
  {
    v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
      v7 = a2;
LABEL_8:
    v8 = a4[2];
    if (v7 <= v8)
      v9 = a4[2];
    else
      v9 = v7;
    if (v9)
    {
      v10 = sub_100012C44(&qword_10040EFD0);
      v11 = (_QWORD *)swift_allocObject(v10, 8 * v9 + 32, 7);
      v12 = j__malloc_size(v11);
      v13 = v12 - 32;
      if (v12 < 32)
        v13 = v12 - 25;
      v11[2] = v8;
      v11[3] = 2 * (v13 >> 3);
      v14 = v11 + 4;
      if ((v5 & 1) != 0)
        goto LABEL_15;
    }
    else
    {
      v11 = _swiftEmptyArrayStorage;
      v14 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
      {
LABEL_15:
        if (v11 != a4 || v14 >= &a4[v8 + 4])
          memmove(v14, a4 + 4, 8 * v8);
        a4[2] = 0;
        goto LABEL_24;
      }
    }
    sub_1000B3A54(0, v8, (char *)v14, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease(a4);
    return v11;
  }
  __break(1u);
  return result;
}

_QWORD *sub_1000B1F80(_QWORD *result, int64_t a2, char a3, _QWORD *a4)
{
  char v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  int64_t v12;
  uint64_t v13;
  _QWORD *v14;

  v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    v7 = a2;
    goto LABEL_8;
  }
  v6 = a4[3];
  v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2)
    goto LABEL_8;
  if (v7 + 0x4000000000000000 >= 0)
  {
    v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
      v7 = a2;
LABEL_8:
    v8 = a4[2];
    if (v7 <= v8)
      v9 = a4[2];
    else
      v9 = v7;
    if (v9)
    {
      v10 = sub_100012C44(&qword_10040F000);
      v11 = (_QWORD *)swift_allocObject(v10, 8 * v9 + 32, 7);
      v12 = j__malloc_size(v11);
      v13 = v12 - 32;
      if (v12 < 32)
        v13 = v12 - 25;
      v11[2] = v8;
      v11[3] = 2 * (v13 >> 3);
      v14 = v11 + 4;
      if ((v5 & 1) != 0)
        goto LABEL_15;
    }
    else
    {
      v11 = _swiftEmptyArrayStorage;
      v14 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
      {
LABEL_15:
        if (v11 != a4 || v14 >= &a4[v8 + 4])
          memmove(v14, a4 + 4, 8 * v8);
        a4[2] = 0;
        goto LABEL_24;
      }
    }
    sub_1000B3A54(0, v8, (char *)v14, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease(a4);
    return v11;
  }
  __break(1u);
  return result;
}

_QWORD *sub_1000B208C(_QWORD *result, int64_t a2, char a3, _QWORD *a4)
{
  char v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  size_t v12;
  _QWORD *v13;

  v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    v7 = a2;
    goto LABEL_8;
  }
  v6 = a4[3];
  v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2)
    goto LABEL_8;
  if (v7 + 0x4000000000000000 >= 0)
  {
    v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
      v7 = a2;
LABEL_8:
    v8 = a4[2];
    if (v7 <= v8)
      v9 = a4[2];
    else
      v9 = v7;
    if (v9)
    {
      v10 = sub_100012C44(&qword_100406938);
      v11 = (_QWORD *)swift_allocObject(v10, 72 * v9 + 32, 7);
      v12 = j__malloc_size(v11);
      v11[2] = v8;
      v11[3] = 2 * ((uint64_t)(v12 - 32) / 72);
      v13 = v11 + 4;
      if ((v5 & 1) != 0)
      {
LABEL_13:
        if (v11 != a4 || v13 >= &a4[9 * v8 + 4])
          memmove(v13, a4 + 4, 72 * v8);
        a4[2] = 0;
        goto LABEL_22;
      }
    }
    else
    {
      v11 = _swiftEmptyArrayStorage;
      v13 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
        goto LABEL_13;
    }
    sub_1000B53D8(0, v8, (unint64_t)v13, (uint64_t)a4);
LABEL_22:
    swift_bridgeObjectRelease(a4);
    return v11;
  }
  __break(1u);
  return result;
}

_QWORD *sub_1000B21B4(_QWORD *result, int64_t a2, char a3, _QWORD *a4)
{
  char v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  int64_t v12;
  uint64_t v13;
  _QWORD *v14;

  v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    v7 = a2;
    goto LABEL_8;
  }
  v6 = a4[3];
  v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2)
    goto LABEL_8;
  if (v7 + 0x4000000000000000 >= 0)
  {
    v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
      v7 = a2;
LABEL_8:
    v8 = a4[2];
    if (v7 <= v8)
      v9 = a4[2];
    else
      v9 = v7;
    if (v9)
    {
      v10 = sub_100012C44((uint64_t *)&unk_100410220);
      v11 = (_QWORD *)swift_allocObject(v10, 32 * v9 + 32, 7);
      v12 = j__malloc_size(v11);
      v13 = v12 - 32;
      if (v12 < 32)
        v13 = v12 - 1;
      v11[2] = v8;
      v11[3] = 2 * (v13 >> 5);
      v14 = v11 + 4;
      if ((v5 & 1) != 0)
        goto LABEL_15;
    }
    else
    {
      v11 = _swiftEmptyArrayStorage;
      v14 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
      {
LABEL_15:
        if (v11 != a4 || v14 >= &a4[4 * v8 + 4])
          memmove(v14, a4 + 4, 32 * v8);
        a4[2] = 0;
        goto LABEL_24;
      }
    }
    sub_1000B56A4(0, v8, (unint64_t)v14, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease(a4);
    return v11;
  }
  __break(1u);
  return result;
}

uint64_t sub_1000B22C0(char a1, int64_t a2, char a3, unint64_t a4)
{
  return sub_1000B22E8(a1, a2, a3, a4, &qword_100406128, type metadata accessor for LongTermPairingKeys.PublicIdentity);
}

uint64_t sub_1000B22D4(char a1, int64_t a2, char a3, unint64_t a4)
{
  return sub_1000B22E8(a1, a2, a3, a4, &qword_1004068C8, (uint64_t (*)(_QWORD))&type metadata accessor for UUID);
}

uint64_t sub_1000B22E8(char a1, int64_t a2, char a3, unint64_t a4, uint64_t *a5, uint64_t (*a6)(_QWORD))
{
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  size_t v19;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t result;

  if ((a3 & 1) != 0)
  {
    v9 = *(_QWORD *)(a4 + 24);
    v10 = v9 >> 1;
    if ((uint64_t)(v9 >> 1) < a2)
    {
      if (v10 + 0x4000000000000000 < 0)
      {
        __break(1u);
LABEL_29:
        result = _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 14377, 0);
LABEL_31:
        __break(1u);
        return result;
      }
      v10 = v9 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v9 & 0xFFFFFFFFFFFFFFFELL) <= a2)
        v10 = a2;
    }
  }
  else
  {
    v10 = a2;
  }
  v11 = *(_QWORD *)(a4 + 16);
  if (v10 <= v11)
    v12 = *(_QWORD *)(a4 + 16);
  else
    v12 = v10;
  if (!v12)
  {
    v18 = _swiftEmptyArrayStorage;
    goto LABEL_19;
  }
  v13 = sub_100012C44(a5);
  v14 = *(_QWORD *)(a6(0) - 8);
  v15 = *(_QWORD *)(v14 + 72);
  v16 = *(unsigned __int8 *)(v14 + 80);
  v17 = (v16 + 32) & ~v16;
  v18 = (_QWORD *)swift_allocObject(v13, v17 + v15 * v12, v16 | 7);
  v19 = j__malloc_size(v18);
  if (!v15)
    goto LABEL_29;
  if (v19 - v17 == 0x8000000000000000 && v15 == -1)
  {
    result = _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 14384, 0);
    goto LABEL_31;
  }
  v18[2] = v11;
  v18[3] = 2 * ((uint64_t)(v19 - v17) / v15);
LABEL_19:
  v21 = a6(0);
  v22 = *(_QWORD *)(v21 - 8);
  v23 = (*(unsigned __int8 *)(v22 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v22 + 80);
  v24 = (unint64_t)v18 + v23;
  if ((a1 & 1) != 0)
  {
    v25 = a4 + v23;
    if ((unint64_t)v18 < a4 || v24 >= v25 + *(_QWORD *)(v22 + 72) * v11)
    {
      swift_arrayInitWithTakeFrontToBack((char *)v18 + v23, v25, v11, v21);
    }
    else if (v18 != (_QWORD *)a4)
    {
      swift_arrayInitWithTakeBackToFront((char *)v18 + v23);
    }
    *(_QWORD *)(a4 + 16) = 0;
  }
  else
  {
    sub_1000B6D48(0, v11, v24, a4, a6);
  }
  swift_bridgeObjectRelease(a4);
  return (uint64_t)v18;
}

_QWORD *sub_1000B24F4(_QWORD *result, int64_t a2, char a3, _QWORD *a4)
{
  char v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  size_t v12;
  _QWORD *v13;

  v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    v7 = a2;
    goto LABEL_8;
  }
  v6 = a4[3];
  v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2)
    goto LABEL_8;
  if (v7 + 0x4000000000000000 >= 0)
  {
    v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
      v7 = a2;
LABEL_8:
    v8 = a4[2];
    if (v7 <= v8)
      v9 = a4[2];
    else
      v9 = v7;
    if (v9)
    {
      v10 = sub_100012C44(&qword_100406928);
      v11 = (_QWORD *)swift_allocObject(v10, 24 * v9 + 32, 7);
      v12 = j__malloc_size(v11);
      v11[2] = v8;
      v11[3] = 2 * ((uint64_t)(v12 - 32) / 24);
      v13 = v11 + 4;
      if ((v5 & 1) != 0)
      {
LABEL_13:
        if (v11 != a4 || v13 >= &a4[3 * v8 + 4])
          memmove(v13, a4 + 4, 24 * v8);
        a4[2] = 0;
        goto LABEL_22;
      }
    }
    else
    {
      v11 = _swiftEmptyArrayStorage;
      v13 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
        goto LABEL_13;
    }
    sub_1000B58A0(0, v8, (unint64_t)v13, (uint64_t)a4);
LABEL_22:
    swift_bridgeObjectRelease(a4);
    return v11;
  }
  __break(1u);
  return result;
}

_QWORD *sub_1000B2618(_QWORD *a1, int64_t a2, char a3, _QWORD *a4)
{
  return sub_1000B2624(a1, a2, a3, a4, (uint64_t *)&unk_10040F020);
}

_QWORD *sub_1000B2624(_QWORD *result, int64_t a2, char a3, _QWORD *a4, uint64_t *a5)
{
  char v6;
  unint64_t v7;
  int64_t v8;
  int64_t v9;
  int64_t v10;
  uint64_t v11;
  _QWORD *v12;
  size_t v13;
  _QWORD *v14;

  v6 = (char)result;
  if ((a3 & 1) == 0)
  {
    v8 = a2;
    goto LABEL_8;
  }
  v7 = a4[3];
  v8 = v7 >> 1;
  if ((uint64_t)(v7 >> 1) >= a2)
    goto LABEL_8;
  if (v8 + 0x4000000000000000 >= 0)
  {
    v8 = v7 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v7 & 0xFFFFFFFFFFFFFFFELL) <= a2)
      v8 = a2;
LABEL_8:
    v9 = a4[2];
    if (v8 <= v9)
      v10 = a4[2];
    else
      v10 = v8;
    if (v10)
    {
      v11 = sub_100012C44(a5);
      v12 = (_QWORD *)swift_allocObject(v11, v10 + 32, 7);
      v13 = j__malloc_size(v12);
      v12[2] = v9;
      v12[3] = 2 * v13 - 64;
      v14 = v12 + 4;
      if ((v6 & 1) != 0)
      {
LABEL_13:
        if (v12 != a4 || v14 >= (_QWORD *)((char *)a4 + v9 + 32))
          memmove(v14, a4 + 4, v9);
        a4[2] = 0;
        goto LABEL_22;
      }
    }
    else
    {
      v12 = _swiftEmptyArrayStorage;
      v14 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
        goto LABEL_13;
    }
    sub_1000B59AC(0, v9, (char *)v14, (uint64_t)a4);
LABEL_22:
    swift_bridgeObjectRelease(a4);
    return v12;
  }
  __break(1u);
  return result;
}

_QWORD *sub_1000B2718(_QWORD *result, int64_t a2, char a3, _QWORD *a4)
{
  char v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  size_t v12;
  _QWORD *v13;

  v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    v7 = a2;
    goto LABEL_8;
  }
  v6 = a4[3];
  v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2)
    goto LABEL_8;
  if (v7 + 0x4000000000000000 >= 0)
  {
    v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
      v7 = a2;
LABEL_8:
    v8 = a4[2];
    if (v7 <= v8)
      v9 = a4[2];
    else
      v9 = v7;
    if (v9)
    {
      v10 = sub_100012C44(&qword_10040F010);
      v11 = (_QWORD *)swift_allocObject(v10, 10 * v9 + 32, 7);
      v12 = j__malloc_size(v11);
      v11[2] = v8;
      v11[3] = 2 * ((uint64_t)(v12 - 32) / 10);
      v13 = v11 + 4;
      if ((v5 & 1) != 0)
      {
LABEL_13:
        if (v11 != a4 || v13 >= (_QWORD *)((char *)a4 + 10 * v8 + 32))
          memmove(v13, a4 + 4, 10 * v8);
        a4[2] = 0;
        goto LABEL_22;
      }
    }
    else
    {
      v11 = _swiftEmptyArrayStorage;
      v13 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
        goto LABEL_13;
    }
    sub_1000B5A90(0, v8, (char *)v13, (uint64_t)a4);
LABEL_22:
    swift_bridgeObjectRelease(a4);
    return v11;
  }
  __break(1u);
  return result;
}

_QWORD *sub_1000B2834(_QWORD *result, int64_t a2, char a3, _QWORD *a4)
{
  char v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  size_t v12;
  _QWORD *v13;

  v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    v7 = a2;
    goto LABEL_8;
  }
  v6 = a4[3];
  v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2)
    goto LABEL_8;
  if (v7 + 0x4000000000000000 >= 0)
  {
    v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
      v7 = a2;
LABEL_8:
    v8 = a4[2];
    if (v7 <= v8)
      v9 = a4[2];
    else
      v9 = v7;
    if (v9)
    {
      v10 = sub_100012C44(&qword_1004068F8);
      v11 = (_QWORD *)swift_allocObject(v10, 56 * v9 + 32, 7);
      v12 = j__malloc_size(v11);
      v11[2] = v8;
      v11[3] = 2 * ((uint64_t)(v12 - 32) / 56);
      v13 = v11 + 4;
      if ((v5 & 1) != 0)
      {
LABEL_13:
        if (v11 != a4 || v13 >= &a4[7 * v8 + 4])
          memmove(v13, a4 + 4, 56 * v8);
        a4[2] = 0;
        goto LABEL_22;
      }
    }
    else
    {
      v11 = _swiftEmptyArrayStorage;
      v13 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
        goto LABEL_13;
    }
    sub_1000B5B7C(0, v8, (unint64_t)v13, (uint64_t)a4);
LABEL_22:
    swift_bridgeObjectRelease(a4);
    return v11;
  }
  __break(1u);
  return result;
}

_QWORD *sub_1000B2958(_QWORD *result, int64_t a2, char a3, _QWORD *a4)
{
  char v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  int64_t v12;
  uint64_t v13;
  _QWORD *v14;

  v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    v7 = a2;
    goto LABEL_8;
  }
  v6 = a4[3];
  v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2)
    goto LABEL_8;
  if (v7 + 0x4000000000000000 >= 0)
  {
    v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
      v7 = a2;
LABEL_8:
    v8 = a4[2];
    if (v7 <= v8)
      v9 = a4[2];
    else
      v9 = v7;
    if (v9)
    {
      v10 = sub_100012C44((uint64_t *)&unk_10040EFF0);
      v11 = (_QWORD *)swift_allocObject(v10, 16 * v9 + 32, 7);
      v12 = j__malloc_size(v11);
      v13 = v12 - 32;
      if (v12 < 32)
        v13 = v12 - 17;
      v11[2] = v8;
      v11[3] = 2 * (v13 >> 4);
      v14 = v11 + 4;
      if ((v5 & 1) != 0)
        goto LABEL_15;
    }
    else
    {
      v11 = _swiftEmptyArrayStorage;
      v14 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
      {
LABEL_15:
        if (v11 != a4 || v14 >= &a4[2 * v8 + 4])
          memmove(v14, a4 + 4, 16 * v8);
        a4[2] = 0;
        goto LABEL_24;
      }
    }
    sub_1000B5C70(0, v8, (unint64_t)v14, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease(a4);
    return v11;
  }
  __break(1u);
  return result;
}

_QWORD *sub_1000B2A64(_QWORD *result, int64_t a2, char a3, _QWORD *a4)
{
  char v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  int64_t v12;
  int64_t v13;
  _QWORD *v14;

  v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    v7 = a2;
    goto LABEL_8;
  }
  v6 = a4[3];
  v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2)
    goto LABEL_8;
  if (v7 + 0x4000000000000000 >= 0)
  {
    v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
      v7 = a2;
LABEL_8:
    v8 = a4[2];
    if (v7 <= v8)
      v9 = a4[2];
    else
      v9 = v7;
    if (v9)
    {
      v10 = sub_100012C44(&qword_1004061C8);
      v11 = (_QWORD *)swift_allocObject(v10, 2 * v9 + 32, 7);
      v12 = j__malloc_size(v11);
      v13 = v12 - 32;
      if (v12 < 32)
        v13 = v12 - 31;
      v11[2] = v8;
      v11[3] = v13 & 0xFFFFFFFFFFFFFFFELL;
      v14 = v11 + 4;
      if ((v5 & 1) != 0)
        goto LABEL_15;
    }
    else
    {
      v11 = _swiftEmptyArrayStorage;
      v14 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
      {
LABEL_15:
        if (v11 != a4 || v14 >= (_QWORD *)((char *)a4 + 2 * v8 + 32))
          memmove(v14, a4 + 4, 2 * v8);
        a4[2] = 0;
        goto LABEL_24;
      }
    }
    sub_1000B5E4C(0, v8, (char *)v14, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease(a4);
    return v11;
  }
  __break(1u);
  return result;
}

_QWORD *sub_1000B2B6C(_QWORD *result, int64_t a2, char a3, _QWORD *a4)
{
  char v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  int64_t v12;
  uint64_t v13;
  _QWORD *v14;

  v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    v7 = a2;
    goto LABEL_8;
  }
  v6 = a4[3];
  v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2)
    goto LABEL_8;
  if (v7 + 0x4000000000000000 >= 0)
  {
    v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
      v7 = a2;
LABEL_8:
    v8 = a4[2];
    if (v7 <= v8)
      v9 = a4[2];
    else
      v9 = v7;
    if (v9)
    {
      v10 = sub_100012C44(&qword_1004061E0);
      v11 = (_QWORD *)swift_allocObject(v10, 16 * v9 + 32, 7);
      v12 = j__malloc_size(v11);
      v13 = v12 - 32;
      if (v12 < 32)
        v13 = v12 - 17;
      v11[2] = v8;
      v11[3] = 2 * (v13 >> 4);
      v14 = v11 + 4;
      if ((v5 & 1) != 0)
        goto LABEL_15;
    }
    else
    {
      v11 = _swiftEmptyArrayStorage;
      v14 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
      {
LABEL_15:
        if (v11 != a4 || v14 >= &a4[2 * v8 + 4])
          memmove(v14, a4 + 4, 16 * v8);
        a4[2] = 0;
        goto LABEL_24;
      }
    }
    sub_1000B54CC(0, v8, (unint64_t)v14, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease(a4);
    return v11;
  }
  __break(1u);
  return result;
}

_QWORD *sub_1000B2C78(_QWORD *result, int64_t a2, char a3, _QWORD *a4)
{
  char v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  int64_t v12;
  uint64_t v13;
  _QWORD *v14;

  v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    v7 = a2;
    goto LABEL_8;
  }
  v6 = a4[3];
  v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2)
    goto LABEL_8;
  if (v7 + 0x4000000000000000 >= 0)
  {
    v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
      v7 = a2;
LABEL_8:
    v8 = a4[2];
    if (v7 <= v8)
      v9 = a4[2];
    else
      v9 = v7;
    if (v9)
    {
      v10 = sub_100012C44(&qword_1004068D0);
      v11 = (_QWORD *)swift_allocObject(v10, 16 * v9 + 32, 7);
      v12 = j__malloc_size(v11);
      v13 = v12 - 32;
      if (v12 < 32)
        v13 = v12 - 17;
      v11[2] = v8;
      v11[3] = 2 * (v13 >> 4);
      v14 = v11 + 4;
      if ((v5 & 1) != 0)
        goto LABEL_15;
    }
    else
    {
      v11 = _swiftEmptyArrayStorage;
      v14 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
      {
LABEL_15:
        if (v11 != a4 || v14 >= &a4[2 * v8 + 4])
          memmove(v14, a4 + 4, 16 * v8);
        a4[2] = 0;
        goto LABEL_24;
      }
    }
    sub_1000B6C40(0, v8, (unint64_t)v14, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease(a4);
    return v11;
  }
  __break(1u);
  return result;
}

_QWORD *sub_1000B2D84(_QWORD *result, int64_t a2, char a3, _QWORD *a4)
{
  char v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  size_t v12;
  _QWORD *v13;

  v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    v7 = a2;
    goto LABEL_8;
  }
  v6 = a4[3];
  v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2)
    goto LABEL_8;
  if (v7 + 0x4000000000000000 >= 0)
  {
    v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
      v7 = a2;
LABEL_8:
    v8 = a4[2];
    if (v7 <= v8)
      v9 = a4[2];
    else
      v9 = v7;
    if (v9)
    {
      v10 = sub_100012C44(&qword_1004061B0);
      v11 = (_QWORD *)swift_allocObject(v10, 24 * v9 + 32, 7);
      v12 = j__malloc_size(v11);
      v11[2] = v8;
      v11[3] = 2 * ((uint64_t)(v12 - 32) / 24);
      v13 = v11 + 4;
      if ((v5 & 1) != 0)
      {
LABEL_13:
        if (v11 != a4 || v13 >= &a4[3 * v8 + 4])
          memmove(v13, a4 + 4, 24 * v8);
        a4[2] = 0;
        goto LABEL_22;
      }
    }
    else
    {
      v11 = _swiftEmptyArrayStorage;
      v13 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
        goto LABEL_13;
    }
    sub_1000B5794(0, v8, (unint64_t)v13, (uint64_t)a4);
LABEL_22:
    swift_bridgeObjectRelease(a4);
    return v11;
  }
  __break(1u);
  return result;
}

_QWORD *sub_1000B2EA8(_QWORD *result, int64_t a2, char a3, _QWORD *a4)
{
  char v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  int64_t v12;
  uint64_t v13;
  _QWORD *v14;

  v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    v7 = a2;
    goto LABEL_8;
  }
  v6 = a4[3];
  v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2)
    goto LABEL_8;
  if (v7 + 0x4000000000000000 >= 0)
  {
    v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
      v7 = a2;
LABEL_8:
    v8 = a4[2];
    if (v7 <= v8)
      v9 = a4[2];
    else
      v9 = v7;
    if (v9)
    {
      v10 = sub_100012C44(&qword_1004061D0);
      v11 = (_QWORD *)swift_allocObject(v10, 8 * v9 + 32, 7);
      v12 = j__malloc_size(v11);
      v13 = v12 - 32;
      if (v12 < 32)
        v13 = v12 - 25;
      v11[2] = v8;
      v11[3] = 2 * (v13 >> 3);
      v14 = v11 + 4;
      if ((v5 & 1) != 0)
        goto LABEL_15;
    }
    else
    {
      v11 = _swiftEmptyArrayStorage;
      v14 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
      {
LABEL_15:
        if (v11 != a4 || v14 >= &a4[v8 + 4])
          memmove(v14, a4 + 4, 8 * v8);
        a4[2] = 0;
        goto LABEL_24;
      }
    }
    sub_1000B6F6C(0, v8, (unint64_t)v14, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease(a4);
    return v11;
  }
  __break(1u);
  return result;
}

_QWORD *sub_1000B2FB4(_QWORD *result, int64_t a2, char a3, _QWORD *a4)
{
  char v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  size_t v12;
  _QWORD *v13;

  v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    v7 = a2;
    goto LABEL_8;
  }
  v6 = a4[3];
  v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2)
    goto LABEL_8;
  if (v7 + 0x4000000000000000 >= 0)
  {
    v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
      v7 = a2;
LABEL_8:
    v8 = a4[2];
    if (v7 <= v8)
      v9 = a4[2];
    else
      v9 = v7;
    if (v9)
    {
      v10 = sub_100012C44(qword_100405C70);
      v11 = (_QWORD *)swift_allocObject(v10, 48 * v9 + 32, 7);
      v12 = j__malloc_size(v11);
      v11[2] = v8;
      v11[3] = 2 * ((uint64_t)(v12 - 32) / 48);
      v13 = v11 + 4;
      if ((v5 & 1) != 0)
      {
LABEL_13:
        if (v11 != a4 || v13 >= &a4[6 * v8 + 4])
          memmove(v13, a4 + 4, 48 * v8);
        a4[2] = 0;
        goto LABEL_22;
      }
    }
    else
    {
      v11 = _swiftEmptyArrayStorage;
      v13 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
        goto LABEL_13;
    }
    sub_1000B7074(0, v8, (unint64_t)v13, (uint64_t)a4);
LABEL_22:
    swift_bridgeObjectRelease(a4);
    return v11;
  }
  __break(1u);
  return result;
}

uint64_t sub_1000B30D8(char a1, int64_t a2, char a3, unint64_t a4)
{
  return sub_1000B22E8(a1, a2, a3, a4, &qword_10040D570, type metadata accessor for NANAttribute);
}

_QWORD *sub_1000B30EC(_QWORD *result, int64_t a2, char a3, _QWORD *a4)
{
  char v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  int64_t v12;
  uint64_t v13;
  _QWORD *v14;

  v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    v7 = a2;
    goto LABEL_8;
  }
  v6 = a4[3];
  v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2)
    goto LABEL_8;
  if (v7 + 0x4000000000000000 >= 0)
  {
    v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
      v7 = a2;
LABEL_8:
    v8 = a4[2];
    if (v7 <= v8)
      v9 = a4[2];
    else
      v9 = v7;
    if (v9)
    {
      v10 = sub_100012C44(&qword_100405F08);
      v11 = (_QWORD *)swift_allocObject(v10, 8 * v9 + 32, 7);
      v12 = j__malloc_size(v11);
      v13 = v12 - 32;
      if (v12 < 32)
        v13 = v12 - 25;
      v11[2] = v8;
      v11[3] = 2 * (v13 >> 3);
      v14 = v11 + 4;
      if ((v5 & 1) != 0)
        goto LABEL_15;
    }
    else
    {
      v11 = _swiftEmptyArrayStorage;
      v14 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
      {
LABEL_15:
        if (v11 != a4 || v14 >= &a4[v8 + 4])
          memmove(v14, a4 + 4, 8 * v8);
        a4[2] = 0;
        goto LABEL_24;
      }
    }
    sub_1000B7270(0, v8, (unint64_t)v14, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease(a4);
    return v11;
  }
  __break(1u);
  return result;
}

_QWORD *sub_1000B31F8(_QWORD *result, int64_t a2, char a3, _QWORD *a4)
{
  char v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  int64_t v12;
  uint64_t v13;
  _QWORD *v14;

  v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    v7 = a2;
    goto LABEL_8;
  }
  v6 = a4[3];
  v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2)
    goto LABEL_8;
  if (v7 + 0x4000000000000000 >= 0)
  {
    v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
      v7 = a2;
LABEL_8:
    v8 = a4[2];
    if (v7 <= v8)
      v9 = a4[2];
    else
      v9 = v7;
    if (v9)
    {
      v10 = sub_100012C44(&qword_100406158);
      v11 = (_QWORD *)swift_allocObject(v10, 32 * v9 + 32, 7);
      v12 = j__malloc_size(v11);
      v13 = v12 - 32;
      if (v12 < 32)
        v13 = v12 - 1;
      v11[2] = v8;
      v11[3] = 2 * (v13 >> 5);
      v14 = v11 + 4;
      if ((v5 & 1) != 0)
        goto LABEL_15;
    }
    else
    {
      v11 = _swiftEmptyArrayStorage;
      v14 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
      {
LABEL_15:
        if (v11 != a4 || v14 >= &a4[4 * v8 + 4])
          memmove(v14, a4 + 4, 32 * v8);
        a4[2] = 0;
        goto LABEL_24;
      }
    }
    sub_1000B7180(0, v8, (unint64_t)v14, (uint64_t)a4);
LABEL_24:
    swift_bridgeObjectRelease(a4);
    return v11;
  }
  __break(1u);
  return result;
}

_QWORD *sub_1000B3304(_QWORD *result, int64_t a2, char a3, _QWORD *a4)
{
  char v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  size_t v12;
  _QWORD *v13;

  v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    v7 = a2;
    goto LABEL_8;
  }
  v6 = a4[3];
  v7 = v6 >> 1;
  if ((uint64_t)(v6 >> 1) >= a2)
    goto LABEL_8;
  if (v7 + 0x4000000000000000 >= 0)
  {
    v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
      v7 = a2;
LABEL_8:
    v8 = a4[2];
    if (v7 <= v8)
      v9 = a4[2];
    else
      v9 = v7;
    if (v9)
    {
      v10 = sub_100012C44(&qword_1004068B0);
      v11 = (_QWORD *)swift_allocObject(v10, 24 * v9 + 32, 7);
      v12 = j__malloc_size(v11);
      v11[2] = v8;
      v11[3] = 2 * ((uint64_t)(v12 - 32) / 24);
      v13 = v11 + 4;
      if ((v5 & 1) != 0)
      {
LABEL_13:
        if (v11 != a4 || v13 >= &a4[3 * v8 + 4])
          memmove(v13, a4 + 4, 24 * v8);
        a4[2] = 0;
        goto LABEL_22;
      }
    }
    else
    {
      v11 = _swiftEmptyArrayStorage;
      v13 = &_swiftEmptyArrayStorage[4];
      if ((result & 1) != 0)
        goto LABEL_13;
    }
    sub_1000B6E60(0, v8, (unint64_t)v13, (uint64_t)a4);
LABEL_22:
    swift_bridgeObjectRelease(a4);
    return v11;
  }
  __break(1u);
  return result;
}

unint64_t sub_1000B3428(unint64_t result)
{
  unint64_t v1;
  uint64_t v2;
  _QWORD *v3;

  if ((result & 0x8000000000000000) != 0)
  {
    __break(1u);
  }
  else
  {
    v1 = result;
    if (result)
    {
      v2 = sub_100012C44(&qword_100404E78);
      v3 = (_QWORD *)static Array._allocateBufferUninitialized(minimumCapacity:)(v1, v2);
      v3[2] = v1;
    }
    else
    {
      v3 = _swiftEmptyArrayStorage;
    }
    sub_100012C44(&qword_100404E78);
    return (unint64_t)v3;
  }
  return result;
}

uint64_t sub_1000B34A0(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4;
  unint64_t v6;
  unint64_t v7;
  uint64_t result;

  v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else
  {
    if (v4 < 0)
    {
      result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 1090, 0);
      goto LABEL_9;
    }
    v6 = a4 + 16 * a1 + 32;
    v7 = a3 + 16 * v4;
    if (v6 >= v7 || v6 + 16 * v4 <= a3)
    {
      sub_100012C44(&qword_100406908);
      swift_arrayInitWithCopy(a3);
      return v7;
    }
  }
  result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 1092, 0);
LABEL_9:
  __break(1u);
  return result;
}

uint64_t sub_1000B35A8(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4;
  unint64_t v6;
  unint64_t v7;
  uint64_t result;

  v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else
  {
    if (v4 < 0)
    {
      result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 1090, 0);
      goto LABEL_9;
    }
    v6 = a4 + 16 * a1 + 32;
    v7 = a3 + 16 * v4;
    if (v6 >= v7 || v6 + 16 * v4 <= a3)
    {
      sub_100012C44(&qword_100406918);
      swift_arrayInitWithCopy(a3);
      return v7;
    }
  }
  result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 1092, 0);
LABEL_9:
  __break(1u);
  return result;
}

uint64_t sub_1000B36B0(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t result;

  v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else
  {
    if (v4 < 0)
    {
      result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 1090, 0);
      goto LABEL_9;
    }
    v5 = a4 + 16 * a1 + 32;
    v6 = a3 + 16 * v4;
    if (v5 >= v6 || v5 + 16 * v4 <= a3)
    {
      swift_arrayInitWithCopy(a3);
      return v6;
    }
  }
  result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 1092, 0);
LABEL_9:
  __break(1u);
  return result;
}

char *sub_1000B37A0(uint64_t a1, uint64_t a2, char *__dst, uint64_t a4)
{
  uint64_t v4;
  char *v5;
  size_t v6;
  char *v7;
  char *result;

  v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
    goto LABEL_9;
  }
  if (v4 < 0)
  {
LABEL_9:
    result = (char *)_fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 1090, 0);
    goto LABEL_11;
  }
  v5 = (char *)(a4 + 6 * a1 + 32);
  v6 = 6 * v4;
  v7 = &__dst[v6];
  if (v5 >= &__dst[v6] || &v5[v6] <= __dst)
  {
    memcpy(__dst, v5, v6);
    return v7;
  }
  result = (char *)_fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 1092, 0);
LABEL_11:
  __break(1u);
  return result;
}

unint64_t sub_1000B388C(unsigned int a1, unsigned int a2)
{
  char v2;
  int v3;
  char v4;
  char v5;
  char v7;
  unsigned __int8 v9;
  unsigned __int8 v10;

  if ((a2 & 0x800) != 0)
    v2 = 5;
  else
    v2 = 3;
  if ((a2 & 0x400) != 0)
    LOBYTE(v3) = 4;
  else
    LOBYTE(v3) = v2;
  if ((a2 & 4) != 0)
    v3 = (a2 >> 9) & 1;
  if ((a2 & 2) != 0)
    v4 = 3;
  else
    v4 = v3;
  if ((a2 & 1) != 0)
    v5 = 2;
  else
    v5 = v4;
  if ((a2 & 8) != 0)
  {
    v7 = 0;
  }
  else if ((a2 & 0x10) != 0)
  {
    v7 = 1;
  }
  else
  {
    if ((a2 & 0x2000) == 0)
      return 0x300000000;
    v7 = 2;
  }
  v9 = v7;
  v10 = v5;
  sub_10018FA04();
  return a1 | ((unint64_t)v9 << 32) | ((unint64_t)v10 << 40);
}

uint64_t sub_1000B3938(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t result;

  v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
    goto LABEL_9;
  }
  if (v4 < 0)
  {
LABEL_9:
    result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 1090, 0);
    goto LABEL_11;
  }
  v8 = *(_QWORD *)(sub_100012C44(&qword_100404EF0) - 8);
  v9 = *(unsigned __int8 *)(v8 + 80);
  v10 = *(_QWORD *)(v8 + 72);
  v11 = a4 + ((v9 + 32) & ~v9) + v10 * a1;
  v12 = v10 * v4;
  v13 = a3 + v12;
  v14 = v11 + v12;
  if (v11 >= v13 || v14 <= a3)
  {
    swift_arrayInitWithCopy(a3);
    return v13;
  }
  result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 1092, 0);
LABEL_11:
  __break(1u);
  return result;
}

char *sub_1000B3A54(uint64_t a1, uint64_t a2, char *__dst, uint64_t a4)
{
  uint64_t v4;
  char *v5;
  size_t v6;
  char *v7;
  char *result;

  v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else
  {
    if (v4 < 0)
    {
      result = (char *)_fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 1090, 0);
      goto LABEL_9;
    }
    v5 = (char *)(a4 + 8 * a1 + 32);
    v6 = 8 * v4;
    v7 = &__dst[v6];
    if (v5 >= &__dst[v6] || &v5[v6] <= __dst)
    {
      memcpy(__dst, v5, v6);
      return v7;
    }
  }
  result = (char *)_fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 1092, 0);
LABEL_9:
  __break(1u);
  return result;
}

uint64_t sub_1000B3B3C@<X0>(__int128 *a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v3;
  __int128 v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  _QWORD *v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  _QWORD *v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;
  _QWORD *v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  __int128 v63;
  __int128 v64;
  uint64_t v65;
  _QWORD *v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  __int128 v70;
  __int128 v71;
  uint64_t v72;
  _QWORD *v73;
  unint64_t v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  unint64_t v82;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  int64_t v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  int64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  unint64_t v98;
  unint64_t v99;
  unint64_t v100;
  unint64_t v101;
  int64_t v102;
  unint64_t v103;
  unint64_t v104;
  unint64_t v105;
  unint64_t v106;
  int64_t v107;
  unint64_t v108;
  unint64_t v109;
  __int128 v110;
  __int128 v111;
  uint64_t v112;
  unint64_t v113;
  uint64_t v114;
  unint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  unint64_t v120;
  unint64_t v121;
  unint64_t v122;
  unint64_t v123;
  int64_t v124;
  unint64_t v125;
  unint64_t v126;
  __int128 v127;
  __int128 v128;
  uint64_t v129;
  unint64_t v130;
  uint64_t v131;
  unint64_t v132;
  __int128 v133;
  __int128 v134;
  uint64_t v135;
  unint64_t v136;
  uint64_t v137;
  unint64_t v138;
  __int128 v139;
  __int128 v140;
  uint64_t v141;
  unint64_t v142;
  uint64_t v143;
  unint64_t v144;
  __int128 v145;
  __int128 v146;
  uint64_t v147;
  unint64_t v148;
  uint64_t v149;
  unint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  unint64_t v155;
  unint64_t v156;
  unint64_t v157;
  unint64_t v158;
  int64_t v159;
  unint64_t v160;
  unint64_t v161;
  unint64_t v162;
  unint64_t v163;
  int64_t v164;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  _QWORD *v170;
  _QWORD *v171;
  uint64_t v172;
  _QWORD *v173;
  _QWORD *v174;
  _QWORD *v175;
  _QWORD *v176;
  _QWORD *v177;
  _QWORD *v178;
  _QWORD *v179;
  _QWORD *v180;
  _QWORD *v181;
  _QWORD *v182;
  _QWORD *v183;
  _QWORD *v184;
  __int128 v185;
  __int128 v186;
  __int128 v187;
  __int128 v188;
  __int128 v189;
  uint64_t v190;
  _QWORD *v191;
  uint64_t v192;
  _QWORD *v193;
  _QWORD *v194;
  _QWORD *v195;
  _QWORD *v196;
  _QWORD *v197;

  v3 = a1[3];
  v187 = a1[2];
  v188 = v3;
  v189 = a1[4];
  v4 = a1[1];
  v185 = *a1;
  v186 = v4;
  sub_100075040(0, 10, 0);
  v5 = 0;
  v6 = _swiftEmptyArrayStorage[2];
  do
  {
    v7 = *(_QWORD *)((char *)&v185 + v5);
    v8 = _swiftEmptyArrayStorage[3];
    if (v6 >= v8 >> 1)
      sub_100075040(v8 > 1, v6 + 1, 1);
    _swiftEmptyArrayStorage[2] = v6 + 1;
    _swiftEmptyArrayStorage[v6 + 4] = v7;
    v5 += 8;
    ++v6;
  }
  while (v5 != 80);
  v9 = a1[8];
  v187 = a1[7];
  v188 = v9;
  v189 = a1[9];
  v10 = a1[6];
  v185 = a1[5];
  v186 = v10;
  sub_100075040(0, 10, 0);
  v11 = 0;
  v12 = _swiftEmptyArrayStorage;
  v13 = _swiftEmptyArrayStorage[2];
  do
  {
    v14 = *(_QWORD *)((char *)&v185 + v11);
    v178 = v12;
    v15 = v12[3];
    if (v13 >= v15 >> 1)
    {
      sub_100075040(v15 > 1, v13 + 1, 1);
      v12 = v178;
    }
    v12[2] = v13 + 1;
    v12[v13 + 4] = v14;
    v11 += 8;
    ++v13;
  }
  while (v11 != 80);
  v177 = v12;
  v16 = a1[13];
  v187 = a1[12];
  v188 = v16;
  v189 = a1[14];
  v17 = a1[11];
  v185 = a1[10];
  v186 = v17;
  sub_100075040(0, 10, 0);
  v18 = 0;
  v19 = _swiftEmptyArrayStorage;
  v20 = _swiftEmptyArrayStorage[2];
  do
  {
    v21 = *(_QWORD *)((char *)&v185 + v18);
    v179 = v19;
    v22 = v19[3];
    if (v20 >= v22 >> 1)
    {
      sub_100075040(v22 > 1, v20 + 1, 1);
      v19 = v179;
    }
    v19[2] = v20 + 1;
    v19[v20 + 4] = v21;
    v18 += 8;
    ++v20;
  }
  while (v18 != 80);
  v176 = v19;
  v23 = a1[18];
  v187 = a1[17];
  v188 = v23;
  v189 = a1[19];
  v24 = a1[16];
  v185 = a1[15];
  v186 = v24;
  sub_100075040(0, 10, 0);
  v25 = 0;
  v26 = _swiftEmptyArrayStorage;
  v27 = _swiftEmptyArrayStorage[2];
  do
  {
    v28 = *(_QWORD *)((char *)&v185 + v25);
    v180 = v26;
    v29 = v26[3];
    if (v27 >= v29 >> 1)
    {
      sub_100075040(v29 > 1, v27 + 1, 1);
      v26 = v180;
    }
    v26[2] = v27 + 1;
    v26[v27 + 4] = v28;
    v25 += 8;
    ++v27;
  }
  while (v25 != 80);
  v175 = v26;
  v30 = a1[23];
  v187 = a1[22];
  v188 = v30;
  v189 = a1[24];
  v31 = a1[21];
  v185 = a1[20];
  v186 = v31;
  sub_100075040(0, 10, 0);
  v32 = 0;
  v33 = _swiftEmptyArrayStorage;
  v34 = _swiftEmptyArrayStorage[2];
  do
  {
    v35 = *(_QWORD *)((char *)&v185 + v32);
    v181 = v33;
    v36 = v33[3];
    if (v34 >= v36 >> 1)
    {
      sub_100075040(v36 > 1, v34 + 1, 1);
      v33 = v181;
    }
    v33[2] = v34 + 1;
    v33[v34 + 4] = v35;
    v32 += 8;
    ++v34;
  }
  while (v32 != 80);
  v174 = v33;
  v37 = a1[28];
  v187 = a1[27];
  v188 = v37;
  v189 = a1[29];
  v38 = a1[26];
  v185 = a1[25];
  v186 = v38;
  sub_100075040(0, 10, 0);
  v39 = 0;
  v40 = _swiftEmptyArrayStorage;
  v41 = _swiftEmptyArrayStorage[2];
  do
  {
    v42 = *(_QWORD *)((char *)&v185 + v39);
    v182 = v40;
    v43 = v40[3];
    if (v41 >= v43 >> 1)
    {
      sub_100075040(v43 > 1, v41 + 1, 1);
      v40 = v182;
    }
    v40[2] = v41 + 1;
    v40[v41 + 4] = v42;
    v39 += 8;
    ++v41;
  }
  while (v39 != 80);
  v173 = v40;
  v45 = *((_QWORD *)a1 + 60);
  v44 = *((_QWORD *)a1 + 61);
  v47 = *((_QWORD *)a1 + 62);
  v46 = *((_QWORD *)a1 + 63);
  v48 = *((_QWORD *)a1 + 64);
  v49 = *((_QWORD *)a1 + 65);
  *(_QWORD *)&v185 = _swiftEmptyArrayStorage;
  sub_100075040(0, 6, 0);
  v50 = v185;
  v52 = *(_QWORD *)(v185 + 16);
  v51 = *(_QWORD *)(v185 + 24);
  v53 = v51 >> 1;
  v54 = v52 + 1;
  if (v51 >> 1 <= v52)
  {
    sub_100075040(v51 > 1, v52 + 1, 1);
    v50 = v185;
    v51 = *(_QWORD *)(v185 + 24);
    v53 = v51 >> 1;
  }
  *(_QWORD *)(v50 + 16) = v54;
  *(_QWORD *)(v50 + 8 * v52 + 32) = v45;
  *(_QWORD *)&v185 = v50;
  if (v53 <= v54)
  {
    sub_100075040(v51 > 1, v52 + 2, 1);
    v50 = v185;
  }
  *(_QWORD *)(v50 + 16) = v52 + 2;
  *(_QWORD *)(v50 + 8 * v54 + 32) = v44;
  *(_QWORD *)&v185 = v50;
  v56 = *(_QWORD *)(v50 + 16);
  v55 = *(_QWORD *)(v50 + 24);
  v57 = v55 >> 1;
  v58 = v56 + 1;
  if (v55 >> 1 <= v56)
  {
    sub_100075040(v55 > 1, v56 + 1, 1);
    v50 = v185;
    v55 = *(_QWORD *)(v185 + 24);
    v57 = v55 >> 1;
  }
  *(_QWORD *)(v50 + 16) = v58;
  *(_QWORD *)(v50 + 8 * v56 + 32) = v47;
  *(_QWORD *)&v185 = v50;
  if (v57 <= v58)
  {
    sub_100075040(v55 > 1, v56 + 2, 1);
    v50 = v185;
  }
  *(_QWORD *)(v50 + 16) = v56 + 2;
  *(_QWORD *)(v50 + 8 * v58 + 32) = v46;
  *(_QWORD *)&v185 = v50;
  v60 = *(_QWORD *)(v50 + 16);
  v59 = *(_QWORD *)(v50 + 24);
  v61 = v59 >> 1;
  v62 = v60 + 1;
  if (v59 >> 1 <= v60)
  {
    sub_100075040(v59 > 1, v60 + 1, 1);
    v50 = v185;
    v59 = *(_QWORD *)(v185 + 24);
    v61 = v59 >> 1;
  }
  *(_QWORD *)(v50 + 16) = v62;
  *(_QWORD *)(v50 + 8 * v60 + 32) = v48;
  *(_QWORD *)&v185 = v50;
  if (v61 <= v62)
  {
    sub_100075040(v59 > 1, v60 + 2, 1);
    v50 = v185;
  }
  *(_QWORD *)(v50 + 16) = v60 + 2;
  v172 = v50;
  *(_QWORD *)(v50 + 8 * v62 + 32) = v49;
  v63 = a1[36];
  v187 = a1[35];
  v188 = v63;
  *(_QWORD *)&v189 = *((_QWORD *)a1 + 74);
  v64 = a1[34];
  v185 = a1[33];
  v186 = v64;
  sub_100075040(0, 9, 0);
  v65 = 0;
  v66 = _swiftEmptyArrayStorage;
  v67 = _swiftEmptyArrayStorage[2];
  do
  {
    v68 = *(_QWORD *)((char *)&v185 + v65);
    v183 = v66;
    v69 = v66[3];
    if (v67 >= v69 >> 1)
    {
      sub_100075040(v69 > 1, v67 + 1, 1);
      v66 = v183;
    }
    v66[2] = v67 + 1;
    v66[v67 + 4] = v68;
    v65 += 8;
    ++v67;
  }
  while (v65 != 72);
  v171 = v66;
  v70 = *(__int128 *)((char *)a1 + 648);
  v187 = *(__int128 *)((char *)a1 + 632);
  v188 = v70;
  *(_QWORD *)&v189 = *((_QWORD *)a1 + 83);
  v71 = *(__int128 *)((char *)a1 + 616);
  v185 = *(__int128 *)((char *)a1 + 600);
  v186 = v71;
  sub_100075040(0, 9, 0);
  v72 = 0;
  v73 = _swiftEmptyArrayStorage;
  v74 = _swiftEmptyArrayStorage[2];
  do
  {
    v75 = *(_QWORD *)((char *)&v185 + v72);
    v184 = v73;
    v76 = v73[3];
    if (v74 >= v76 >> 1)
    {
      sub_100075040(v76 > 1, v74 + 1, 1);
      v73 = v184;
    }
    v73[2] = v74 + 1;
    v73[v74 + 4] = v75;
    v72 += 8;
    ++v74;
  }
  while (v72 != 72);
  v170 = v73;
  v77 = *((_QWORD *)a1 + 84);
  v78 = *((_QWORD *)a1 + 85);
  v79 = *((_QWORD *)a1 + 86);
  v80 = *((_QWORD *)a1 + 87);
  *(_QWORD *)&v185 = _swiftEmptyArrayStorage;
  sub_100075040(0, 4, 0);
  v81 = v185;
  v83 = *(_QWORD *)(v185 + 16);
  v82 = *(_QWORD *)(v185 + 24);
  v84 = v82 >> 1;
  v85 = v83 + 1;
  if (v82 >> 1 <= v83)
  {
    sub_100075040(v82 > 1, v83 + 1, 1);
    v81 = v185;
    v82 = *(_QWORD *)(v185 + 24);
    v84 = v82 >> 1;
  }
  *(_QWORD *)(v81 + 16) = v85;
  *(_QWORD *)(v81 + 8 * v83 + 32) = v77;
  *(_QWORD *)&v185 = v81;
  v86 = v83 + 2;
  if (v84 <= v85)
  {
    sub_100075040(v82 > 1, v86, 1);
    v81 = v185;
  }
  *(_QWORD *)(v81 + 16) = v86;
  *(_QWORD *)(v81 + 8 * v85 + 32) = v78;
  *(_QWORD *)&v185 = v81;
  v88 = *(_QWORD *)(v81 + 16);
  v87 = *(_QWORD *)(v81 + 24);
  v89 = v87 >> 1;
  v90 = v88 + 1;
  if (v87 >> 1 <= v88)
  {
    sub_100075040(v87 > 1, v88 + 1, 1);
    v81 = v185;
    v87 = *(_QWORD *)(v185 + 24);
    v89 = v87 >> 1;
  }
  *(_QWORD *)(v81 + 16) = v90;
  *(_QWORD *)(v81 + 8 * v88 + 32) = v79;
  *(_QWORD *)&v185 = v81;
  v91 = v88 + 2;
  if (v89 <= v90)
  {
    sub_100075040(v87 > 1, v91, 1);
    v81 = v185;
  }
  *(_QWORD *)(v81 + 16) = v91;
  v169 = v81;
  *(_QWORD *)(v81 + 8 * v90 + 32) = v80;
  v92 = *((_QWORD *)a1 + 88);
  v93 = *((_QWORD *)a1 + 89);
  v94 = *((_QWORD *)a1 + 90);
  v95 = *((_QWORD *)a1 + 91);
  v96 = *((_QWORD *)a1 + 92);
  *(_QWORD *)&v185 = _swiftEmptyArrayStorage;
  sub_100075040(0, 5, 0);
  v97 = v185;
  v99 = *(_QWORD *)(v185 + 16);
  v98 = *(_QWORD *)(v185 + 24);
  v100 = v98 >> 1;
  v101 = v99 + 1;
  if (v98 >> 1 <= v99)
  {
    sub_100075040(v98 > 1, v99 + 1, 1);
    v97 = v185;
    v98 = *(_QWORD *)(v185 + 24);
    v100 = v98 >> 1;
  }
  *(_QWORD *)(v97 + 16) = v101;
  *(_QWORD *)(v97 + 8 * v99 + 32) = v92;
  *(_QWORD *)&v185 = v97;
  v102 = v99 + 2;
  if (v100 <= v101)
  {
    sub_100075040(v98 > 1, v102, 1);
    v97 = v185;
  }
  *(_QWORD *)(v97 + 16) = v102;
  *(_QWORD *)(v97 + 8 * v101 + 32) = v93;
  *(_QWORD *)&v185 = v97;
  v104 = *(_QWORD *)(v97 + 16);
  v103 = *(_QWORD *)(v97 + 24);
  v105 = v103 >> 1;
  v106 = v104 + 1;
  if (v103 >> 1 <= v104)
  {
    sub_100075040(v103 > 1, v104 + 1, 1);
    v97 = v185;
    v103 = *(_QWORD *)(v185 + 24);
    v105 = v103 >> 1;
  }
  *(_QWORD *)(v97 + 16) = v106;
  *(_QWORD *)(v97 + 8 * v104 + 32) = v94;
  *(_QWORD *)&v185 = v97;
  v107 = v104 + 2;
  if (v105 <= v106)
  {
    sub_100075040(v103 > 1, v107, 1);
    v97 = v185;
  }
  *(_QWORD *)(v97 + 16) = v107;
  *(_QWORD *)(v97 + 8 * v106 + 32) = v95;
  *(_QWORD *)&v185 = v97;
  v109 = *(_QWORD *)(v97 + 16);
  v108 = *(_QWORD *)(v97 + 24);
  if (v109 >= v108 >> 1)
  {
    sub_100075040(v108 > 1, v109 + 1, 1);
    v97 = v185;
  }
  *(_QWORD *)(v97 + 16) = v109 + 1;
  v168 = v97;
  *(_QWORD *)(v97 + 8 * v109 + 32) = v96;
  v110 = *(__int128 *)((char *)a1 + 792);
  v187 = *(__int128 *)((char *)a1 + 776);
  v188 = v110;
  v189 = *(__int128 *)((char *)a1 + 808);
  v111 = *(__int128 *)((char *)a1 + 760);
  v185 = *(__int128 *)((char *)a1 + 744);
  v186 = v111;
  sub_100075040(0, 10, 0);
  v112 = 0;
  v113 = _swiftEmptyArrayStorage[2];
  do
  {
    v114 = *(_QWORD *)((char *)&v185 + v112);
    v115 = _swiftEmptyArrayStorage[3];
    if (v113 >= v115 >> 1)
      sub_100075040(v115 > 1, v113 + 1, 1);
    _swiftEmptyArrayStorage[2] = v113 + 1;
    _swiftEmptyArrayStorage[v113 + 4] = v114;
    v112 += 8;
    ++v113;
  }
  while (v112 != 80);
  v116 = *((_QWORD *)a1 + 103);
  v117 = *((_QWORD *)a1 + 104);
  v118 = *((_QWORD *)a1 + 105);
  *(_QWORD *)&v185 = _swiftEmptyArrayStorage;
  sub_100075040(0, 3, 0);
  v119 = v185;
  v121 = *(_QWORD *)(v185 + 16);
  v120 = *(_QWORD *)(v185 + 24);
  v122 = v120 >> 1;
  v123 = v121 + 1;
  if (v120 >> 1 <= v121)
  {
    sub_100075040(v120 > 1, v121 + 1, 1);
    v119 = v185;
    v120 = *(_QWORD *)(v185 + 24);
    v122 = v120 >> 1;
  }
  *(_QWORD *)(v119 + 16) = v123;
  *(_QWORD *)(v119 + 8 * v121 + 32) = v116;
  *(_QWORD *)&v185 = v119;
  v124 = v121 + 2;
  if (v122 <= v123)
  {
    sub_100075040(v120 > 1, v124, 1);
    v119 = v185;
  }
  *(_QWORD *)(v119 + 16) = v124;
  *(_QWORD *)(v119 + 8 * v123 + 32) = v117;
  *(_QWORD *)&v185 = v119;
  v126 = *(_QWORD *)(v119 + 16);
  v125 = *(_QWORD *)(v119 + 24);
  if (v126 >= v125 >> 1)
  {
    sub_100075040(v125 > 1, v126 + 1, 1);
    v119 = v185;
  }
  *(_QWORD *)(v119 + 16) = v126 + 1;
  v167 = v119;
  *(_QWORD *)(v119 + 8 * v126 + 32) = v118;
  v127 = a1[56];
  v187 = a1[55];
  v188 = v127;
  v189 = a1[57];
  v128 = a1[54];
  v185 = a1[53];
  v186 = v128;
  sub_100075040(0, 10, 0);
  v129 = 0;
  v130 = _swiftEmptyArrayStorage[2];
  do
  {
    v131 = *(_QWORD *)((char *)&v185 + v129);
    v132 = _swiftEmptyArrayStorage[3];
    if (v130 >= v132 >> 1)
      sub_100075040(v132 > 1, v130 + 1, 1);
    _swiftEmptyArrayStorage[2] = v130 + 1;
    _swiftEmptyArrayStorage[v130 + 4] = v131;
    v129 += 8;
    ++v130;
  }
  while (v129 != 80);
  v133 = a1[61];
  v187 = a1[60];
  v188 = v133;
  v189 = a1[62];
  v134 = a1[59];
  v185 = a1[58];
  v186 = v134;
  sub_100075040(0, 10, 0);
  v135 = 0;
  v136 = _swiftEmptyArrayStorage[2];
  do
  {
    v137 = *(_QWORD *)((char *)&v185 + v135);
    v138 = _swiftEmptyArrayStorage[3];
    if (v136 >= v138 >> 1)
      sub_100075040(v138 > 1, v136 + 1, 1);
    _swiftEmptyArrayStorage[2] = v136 + 1;
    _swiftEmptyArrayStorage[v136 + 4] = v137;
    v135 += 8;
    ++v136;
  }
  while (v135 != 80);
  v139 = a1[66];
  v187 = a1[65];
  v188 = v139;
  v189 = a1[67];
  v140 = a1[64];
  v185 = a1[63];
  v186 = v140;
  sub_100075040(0, 10, 0);
  v141 = 0;
  v142 = _swiftEmptyArrayStorage[2];
  do
  {
    v143 = *(_QWORD *)((char *)&v185 + v141);
    v144 = _swiftEmptyArrayStorage[3];
    if (v142 >= v144 >> 1)
      sub_100075040(v144 > 1, v142 + 1, 1);
    _swiftEmptyArrayStorage[2] = v142 + 1;
    _swiftEmptyArrayStorage[v142 + 4] = v143;
    v141 += 8;
    ++v142;
  }
  while (v141 != 80);
  v145 = a1[69];
  v146 = a1[71];
  v187 = a1[70];
  v188 = v146;
  v189 = a1[72];
  v185 = a1[68];
  v186 = v145;
  sub_100075040(0, 10, 0);
  v147 = 0;
  v148 = _swiftEmptyArrayStorage[2];
  do
  {
    v149 = *(_QWORD *)((char *)&v185 + v147);
    v150 = _swiftEmptyArrayStorage[3];
    if (v148 >= v150 >> 1)
      sub_100075040(v150 > 1, v148 + 1, 1);
    _swiftEmptyArrayStorage[2] = v148 + 1;
    _swiftEmptyArrayStorage[v148 + 4] = v149;
    v147 += 8;
    ++v148;
  }
  while (v147 != 80);
  v151 = *((_QWORD *)a1 + 146);
  v152 = *((_QWORD *)a1 + 147);
  v153 = *((_QWORD *)a1 + 148);
  v154 = *((_QWORD *)a1 + 149);
  sub_100075040(0, 4, 0);
  v156 = _swiftEmptyArrayStorage[2];
  v155 = _swiftEmptyArrayStorage[3];
  v157 = v155 >> 1;
  v158 = v156 + 1;
  if (v155 >> 1 <= v156)
  {
    sub_100075040(v155 > 1, v156 + 1, 1);
    v155 = _swiftEmptyArrayStorage[3];
    v157 = v155 >> 1;
  }
  _swiftEmptyArrayStorage[2] = v158;
  _swiftEmptyArrayStorage[v156 + 4] = v151;
  v159 = v156 + 2;
  if (v157 <= v158)
    sub_100075040(v155 > 1, v159, 1);
  _swiftEmptyArrayStorage[2] = v159;
  _swiftEmptyArrayStorage[v158 + 4] = v152;
  v161 = _swiftEmptyArrayStorage[2];
  v160 = _swiftEmptyArrayStorage[3];
  v162 = v160 >> 1;
  v163 = v161 + 1;
  if (v160 >> 1 <= v161)
  {
    sub_100075040(v160 > 1, v161 + 1, 1);
    v160 = _swiftEmptyArrayStorage[3];
    v162 = v160 >> 1;
  }
  _swiftEmptyArrayStorage[2] = v163;
  _swiftEmptyArrayStorage[v161 + 4] = v153;
  v164 = v161 + 2;
  if (v162 <= v163)
    sub_100075040(v160 > 1, v164, 1);
  _swiftEmptyArrayStorage[2] = v164;
  _swiftEmptyArrayStorage[v163 + 4] = v154;
  *(_QWORD *)&v185 = _swiftEmptyArrayStorage;
  *((_QWORD *)&v185 + 1) = v177;
  *(_QWORD *)&v186 = v176;
  *((_QWORD *)&v186 + 1) = v175;
  *(_QWORD *)&v187 = v174;
  *((_QWORD *)&v187 + 1) = v173;
  *(_QWORD *)&v188 = v172;
  *((_QWORD *)&v188 + 1) = v171;
  *(_QWORD *)&v189 = v170;
  *((_QWORD *)&v189 + 1) = v169;
  v190 = v168;
  v191 = _swiftEmptyArrayStorage;
  v192 = v167;
  v193 = _swiftEmptyArrayStorage;
  v194 = _swiftEmptyArrayStorage;
  v195 = _swiftEmptyArrayStorage;
  v196 = _swiftEmptyArrayStorage;
  v197 = _swiftEmptyArrayStorage;
  NANBitmap.Channel.operatingClass.getter(&v185);
  return sub_100063EB8((uint64_t)&v185, a2, &qword_100406948);
}

__n128 sub_1000B4AF8@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  int v4;
  int v5;
  int v6;
  int v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  int64_t v16;
  int v17;
  int v18;
  int v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  int64_t v28;
  int v29;
  int v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  int64_t v39;
  int v40;
  int v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  int64_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v62;
  __n128 result;
  __int128 v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;

  v4 = *(_DWORD *)(a1 + 80);
  v5 = *(_DWORD *)(a1 + 88);
  v6 = *(_DWORD *)(a1 + 96);
  v7 = *(_DWORD *)(a1 + 104);
  sub_100075094(0, 4, 0);
  v9 = _swiftEmptyArrayStorage[2];
  v8 = _swiftEmptyArrayStorage[3];
  v10 = v8 >> 1;
  v11 = v9 + 1;
  if (v8 >> 1 <= v9)
  {
    sub_100075094(v8 > 1, v9 + 1, 1);
    v8 = _swiftEmptyArrayStorage[3];
    v10 = v8 >> 1;
  }
  _swiftEmptyArrayStorage[2] = v11;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v9) = v4;
  if (v10 <= v11)
    sub_100075094(v8 > 1, v9 + 2, 1);
  _swiftEmptyArrayStorage[2] = v9 + 2;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v11) = v5;
  v13 = _swiftEmptyArrayStorage[2];
  v12 = _swiftEmptyArrayStorage[3];
  v14 = v12 >> 1;
  v15 = v13 + 1;
  if (v12 >> 1 <= v13)
  {
    sub_100075094(v12 > 1, v13 + 1, 1);
    v12 = _swiftEmptyArrayStorage[3];
    v14 = v12 >> 1;
  }
  _swiftEmptyArrayStorage[2] = v15;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v13) = v6;
  v16 = v13 + 2;
  if (v14 <= v15)
    sub_100075094(v12 > 1, v16, 1);
  _swiftEmptyArrayStorage[2] = v16;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v15) = v7;
  v17 = *(_DWORD *)(a1 + 112);
  v18 = *(_DWORD *)(a1 + 120);
  v67 = *(_DWORD *)(a1 + 128);
  v19 = *(_DWORD *)(a1 + 136);
  sub_100075094(0, 4, 0);
  v21 = _swiftEmptyArrayStorage[2];
  v20 = _swiftEmptyArrayStorage[3];
  v22 = v20 >> 1;
  v23 = v21 + 1;
  if (v20 >> 1 <= v21)
  {
    sub_100075094(v20 > 1, v21 + 1, 1);
    v20 = _swiftEmptyArrayStorage[3];
    v22 = v20 >> 1;
  }
  _swiftEmptyArrayStorage[2] = v23;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v21) = v17;
  if (v22 <= v23)
    sub_100075094(v20 > 1, v21 + 2, 1);
  _swiftEmptyArrayStorage[2] = v21 + 2;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v23) = v18;
  v25 = _swiftEmptyArrayStorage[2];
  v24 = _swiftEmptyArrayStorage[3];
  v26 = v24 >> 1;
  v27 = v25 + 1;
  if (v24 >> 1 <= v25)
  {
    sub_100075094(v24 > 1, v25 + 1, 1);
    v24 = _swiftEmptyArrayStorage[3];
    v26 = v24 >> 1;
  }
  _swiftEmptyArrayStorage[2] = v27;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v25) = v67;
  v28 = v25 + 2;
  if (v26 <= v27)
    sub_100075094(v24 > 1, v28, 1);
  _swiftEmptyArrayStorage[2] = v28;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v27) = v19;
  v29 = *(_DWORD *)(a1 + 144);
  v30 = *(_DWORD *)(a1 + 152);
  v65 = *(_DWORD *)(a1 + 160);
  v68 = *(_DWORD *)(a1 + 168);
  sub_100075094(0, 4, 0);
  v32 = _swiftEmptyArrayStorage[2];
  v31 = _swiftEmptyArrayStorage[3];
  v33 = v31 >> 1;
  v34 = v32 + 1;
  if (v31 >> 1 <= v32)
  {
    sub_100075094(v31 > 1, v32 + 1, 1);
    v31 = _swiftEmptyArrayStorage[3];
    v33 = v31 >> 1;
  }
  _swiftEmptyArrayStorage[2] = v34;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v32) = v29;
  if (v33 <= v34)
    sub_100075094(v31 > 1, v32 + 2, 1);
  _swiftEmptyArrayStorage[2] = v32 + 2;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v34) = v30;
  v36 = _swiftEmptyArrayStorage[2];
  v35 = _swiftEmptyArrayStorage[3];
  v37 = v35 >> 1;
  v38 = v36 + 1;
  if (v35 >> 1 <= v36)
  {
    sub_100075094(v35 > 1, v36 + 1, 1);
    v35 = _swiftEmptyArrayStorage[3];
    v37 = v35 >> 1;
  }
  _swiftEmptyArrayStorage[2] = v38;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v36) = v65;
  v39 = v36 + 2;
  if (v37 <= v38)
    sub_100075094(v35 > 1, v39, 1);
  _swiftEmptyArrayStorage[2] = v39;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v38) = v68;
  v40 = *(_DWORD *)(a1 + 176);
  v41 = *(_DWORD *)(a1 + 184);
  v66 = *(_DWORD *)(a1 + 192);
  v69 = *(_DWORD *)(a1 + 200);
  sub_100075094(0, 4, 0);
  v43 = _swiftEmptyArrayStorage[2];
  v42 = _swiftEmptyArrayStorage[3];
  v44 = v42 >> 1;
  v45 = v43 + 1;
  if (v42 >> 1 <= v43)
  {
    sub_100075094(v42 > 1, v43 + 1, 1);
    v42 = _swiftEmptyArrayStorage[3];
    v44 = v42 >> 1;
  }
  _swiftEmptyArrayStorage[2] = v45;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v43) = v40;
  if (v44 <= v45)
    sub_100075094(v42 > 1, v43 + 2, 1);
  _swiftEmptyArrayStorage[2] = v43 + 2;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v45) = v41;
  v47 = _swiftEmptyArrayStorage[2];
  v46 = _swiftEmptyArrayStorage[3];
  v48 = v46 >> 1;
  v49 = v47 + 1;
  if (v46 >> 1 <= v47)
  {
    sub_100075094(v46 > 1, v47 + 1, 1);
    v46 = _swiftEmptyArrayStorage[3];
    v48 = v46 >> 1;
  }
  _swiftEmptyArrayStorage[2] = v49;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v47) = v66;
  v50 = v47 + 2;
  if (v48 <= v49)
    sub_100075094(v46 > 1, v50, 1);
  _swiftEmptyArrayStorage[2] = v50;
  *((_DWORD *)&_swiftEmptyArrayStorage[4] + v49) = v69;
  v51 = *(_QWORD *)(a1 + 32);
  v52 = *(unsigned __int8 *)(a1 + 72);
  v53 = *(unsigned int *)(a1 + 40) | ((unint64_t)*(unsigned __int8 *)(a1 + 44) << 32);
  v54 = *(unsigned int *)(a1 + 48) | ((unint64_t)*(unsigned __int8 *)(a1 + 52) << 32);
  v55 = 0x1000000000000;
  if (!*(_BYTE *)(a1 + 62))
    v55 = 0;
  v56 = 0x100000000000000;
  if (!*(_BYTE *)(a1 + 63))
    v56 = 0;
  v57 = *(unsigned int *)(a1 + 56) | ((unint64_t)*(unsigned __int8 *)(a1 + 60) << 32) | ((unint64_t)*(unsigned __int8 *)(a1 + 61) << 40) | v55 | v56;
  v58 = 256;
  if (!*(_BYTE *)(a1 + 65))
    v58 = 0;
  v59 = v58 | *(unsigned __int8 *)(a1 + 64);
  v60 = 0x10000;
  if (!*(_BYTE *)(a1 + 66))
    v60 = 0;
  v61 = 0x1000000;
  if (!*(_BYTE *)(a1 + 67))
    v61 = 0;
  v62 = v59 | v60 | v61 | ((unint64_t)*(unsigned __int8 *)(a1 + 68) << 32) | ((unint64_t)*(unsigned __int8 *)(a1 + 69) << 40) | ((unint64_t)*(unsigned __int8 *)(a1 + 70) << 48) | ((unint64_t)*(unsigned __int8 *)(a1 + 71) << 56);
  result = *(__n128 *)a1;
  v64 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(_OWORD *)(a2 + 16) = v64;
  *(_QWORD *)(a2 + 32) = v51;
  *(_QWORD *)(a2 + 40) = v53;
  *(_QWORD *)(a2 + 48) = v54;
  *(_QWORD *)(a2 + 56) = v57;
  *(_QWORD *)(a2 + 64) = v62;
  *(_QWORD *)(a2 + 72) = v52;
  *(_QWORD *)(a2 + 80) = _swiftEmptyArrayStorage;
  *(_QWORD *)(a2 + 88) = _swiftEmptyArrayStorage;
  *(_QWORD *)(a2 + 96) = _swiftEmptyArrayStorage;
  *(_QWORD *)(a2 + 104) = _swiftEmptyArrayStorage;
  return result;
}

NSString sub_1000B515C(uint64_t a1)
{
  unsigned int v1;
  __int128 v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  NSString v7;
  _OWORD v9[2];
  uint64_t v10;

  v1 = *(_DWORD *)(a1 + 36);
  v2 = *(_OWORD *)(a1 + 16);
  v9[0] = *(_OWORD *)a1;
  v9[1] = v2;
  v10 = *(_QWORD *)(a1 + 32);
  if (v1 > 2)
    return 0;
  BYTE3(v10) = 0;
  v3 = String.init(cString:)((char *)v9 + 4);
  v5 = v4;
  v6 = HIBYTE(v4) & 0xF;
  if ((v4 & 0x2000000000000000) == 0)
    v6 = v3 & 0xFFFFFFFFFFFFLL;
  if (!v6)
  {
    swift_bridgeObjectRelease(v4);
    return 0;
  }
  v7 = String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease(v5);
  return v7;
}

uint64_t sub_1000B5224(__int16 a1)
{
  uint64_t result;

  LODWORD(result) = _s7CoreP2P15IEEE80211StatusO8rawValueACSgs6UInt16V_tcfC_0(a1 & 0x1FF);
  if (result == 54)
    return 1;
  else
    return result;
}

uint64_t sub_1000B5248(__int16 a1)
{
  uint64_t result;

  LODWORD(result) = _s7CoreP2P15IEEE80211ReasonO8rawValueACSgs6UInt16V_tcfC_0(a1 & 0x1FF);
  if (result == 34)
    return 1;
  else
    return result;
}

uint64_t sub_1000B526C()
{
  uint64_t v0;

  return swift_deallocObject(v0, 48, 7);
}

unint64_t sub_1000B527C()
{
  unint64_t result;

  result = qword_1004066E8;
  if (!qword_1004066E8)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for IEEE80211Frame, &type metadata for IEEE80211Frame);
    atomic_store(result, (unint64_t *)&qword_1004066E8);
  }
  return result;
}

unint64_t sub_1000B52C0()
{
  unint64_t result;

  result = qword_1004066F0;
  if (!qword_1004066F0)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt16, &type metadata for UInt16);
    atomic_store(result, (unint64_t *)&qword_1004066F0);
  }
  return result;
}

unint64_t sub_1000B5304()
{
  unint64_t result;
  uint64_t v1;
  uint64_t v2;

  result = qword_1004066F8;
  if (!qword_1004066F8)
  {
    v1 = sub_100013C64(&qword_100405C48);
    v2 = sub_100011DE4(&qword_100406700, type metadata accessor for NANAttribute, (uint64_t)&protocol conformance descriptor for NANAttribute);
    result = swift_getWitnessTable((const char *)&protocol conformance descriptor for <A> [A], v1, &v2);
    atomic_store(result, (unint64_t *)&qword_1004066F8);
  }
  return result;
}

uint64_t sub_1000B5380(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  if (a3)
  {
    swift_unownedRetain();
    return swift_bridgeObjectRetain(a3);
  }
  return result;
}

uint64_t sub_1000B53AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  if (a3)
  {
    swift_unownedRelease();
    return swift_bridgeObjectRelease(a3);
  }
  return result;
}

uint64_t sub_1000B53D8(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t result;

  v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
    goto LABEL_9;
  }
  if (v4 < 0)
  {
LABEL_9:
    result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 1090, 0);
    goto LABEL_11;
  }
  v5 = a4 + 72 * a1 + 32;
  v6 = a3 + 72 * v4;
  if (v5 >= v6 || v5 + 72 * v4 <= a3)
  {
    swift_arrayInitWithCopy(a3);
    return v6;
  }
  result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 1092, 0);
LABEL_11:
  __break(1u);
  return result;
}

uint64_t sub_1000B54CC(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t result;

  v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else
  {
    if (v4 < 0)
    {
      result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 1090, 0);
      goto LABEL_9;
    }
    v5 = a4 + 16 * a1 + 32;
    v6 = a3 + 16 * v4;
    if (v5 >= v6 || v5 + 16 * v4 <= a3)
    {
      swift_arrayInitWithCopy(a3);
      return v6;
    }
  }
  result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 1092, 0);
LABEL_9:
  __break(1u);
  return result;
}

char *sub_1000B55BC(uint64_t a1, uint64_t a2, char *__dst, uint64_t a4)
{
  uint64_t v4;
  char *v5;
  size_t v6;
  char *v7;
  char *result;

  v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else
  {
    if (v4 < 0)
    {
      result = (char *)_fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 1090, 0);
      goto LABEL_9;
    }
    v5 = (char *)(a4 + 4 * a1 + 32);
    v6 = 4 * v4;
    v7 = &__dst[v6];
    if (v5 >= &__dst[v6] || &v5[v6] <= __dst)
    {
      memcpy(__dst, v5, v6);
      return v7;
    }
  }
  result = (char *)_fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 1092, 0);
LABEL_9:
  __break(1u);
  return result;
}

uint64_t sub_1000B56A4(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t result;

  v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else
  {
    if (v4 < 0)
    {
      result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 1090, 0);
      goto LABEL_9;
    }
    v5 = a4 + 32 * a1 + 32;
    v6 = a3 + 32 * v4;
    if (v5 >= v6 || v5 + 32 * v4 <= a3)
    {
      swift_arrayInitWithCopy(a3);
      return v6;
    }
  }
  result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 1092, 0);
LABEL_9:
  __break(1u);
  return result;
}

uint64_t sub_1000B5794(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4;
  unint64_t v6;
  unint64_t v7;
  uint64_t result;

  v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
    goto LABEL_9;
  }
  if (v4 < 0)
  {
LABEL_9:
    result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 1090, 0);
    goto LABEL_11;
  }
  v6 = a4 + 24 * a1 + 32;
  v7 = a3 + 24 * v4;
  if (v6 >= v7 || v6 + 24 * v4 <= a3)
  {
    sub_100012C44(&qword_1004061B8);
    swift_arrayInitWithCopy(a3);
    return v7;
  }
  result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 1092, 0);
LABEL_11:
  __break(1u);
  return result;
}

uint64_t sub_1000B58A0(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4;
  unint64_t v6;
  unint64_t v7;
  uint64_t result;

  v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
    goto LABEL_9;
  }
  if (v4 < 0)
  {
LABEL_9:
    result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 1090, 0);
    goto LABEL_11;
  }
  v6 = a4 + 24 * a1 + 32;
  v7 = a3 + 24 * v4;
  if (v6 >= v7 || v6 + 24 * v4 <= a3)
  {
    sub_100012C44(&qword_100406248);
    swift_arrayInitWithCopy(a3);
    return v7;
  }
  result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 1092, 0);
LABEL_11:
  __break(1u);
  return result;
}

char *sub_1000B59AC(uint64_t a1, uint64_t a2, char *__dst, uint64_t a4)
{
  size_t v4;
  char *v5;
  char *v6;
  char *result;

  v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else
  {
    if ((v4 & 0x8000000000000000) != 0)
    {
      result = (char *)_fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 1090, 0);
      goto LABEL_9;
    }
    v5 = (char *)(a4 + a1 + 32);
    v6 = &__dst[v4];
    if (v5 >= &__dst[v4] || &v5[v4] <= __dst)
    {
      memcpy(__dst, v5, v4);
      return v6;
    }
  }
  result = (char *)_fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 1092, 0);
LABEL_9:
  __break(1u);
  return result;
}

char *sub_1000B5A90(uint64_t a1, uint64_t a2, char *__dst, uint64_t a4)
{
  uint64_t v4;
  char *v5;
  size_t v6;
  char *v7;
  char *result;

  v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
    goto LABEL_9;
  }
  if (v4 < 0)
  {
LABEL_9:
    result = (char *)_fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 1090, 0);
    goto LABEL_11;
  }
  v5 = (char *)(a4 + 10 * a1 + 32);
  v6 = 10 * v4;
  v7 = &__dst[v6];
  if (v5 >= &__dst[v6] || &v5[v6] <= __dst)
  {
    memcpy(__dst, v5, v6);
    return v7;
  }
  result = (char *)_fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 1092, 0);
LABEL_11:
  __break(1u);
  return result;
}

uint64_t sub_1000B5B7C(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t result;

  v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
    goto LABEL_9;
  }
  if (v4 < 0)
  {
LABEL_9:
    result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 1090, 0);
    goto LABEL_11;
  }
  v5 = a4 + 56 * a1 + 32;
  v6 = a3 + 56 * v4;
  if (v5 >= v6 || v5 + 56 * v4 <= a3)
  {
    swift_arrayInitWithCopy(a3);
    return v6;
  }
  result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 1092, 0);
LABEL_11:
  __break(1u);
  return result;
}

uint64_t sub_1000B5C70(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t result;

  v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else
  {
    if (v4 < 0)
    {
      result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 1090, 0);
      goto LABEL_9;
    }
    v5 = a4 + 16 * a1 + 32;
    v6 = a3 + 16 * v4;
    if (v5 >= v6 || v5 + 16 * v4 <= a3)
    {
      swift_arrayInitWithCopy(a3);
      return v6;
    }
  }
  result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 1092, 0);
LABEL_9:
  __break(1u);
  return result;
}

uint64_t sub_1000B5D60(uint64_t a1)
{
  const void *v2;
  _BYTE __dst[384];
  uint64_t v5;

  v2 = (const void *)(a1 + 12);
  if (*(_BYTE *)(a1 + 6))
  {
    memcpy(__dst, v2, sizeof(__dst));
    sub_1000B0280((unint64_t)__dst, a1, &v5);
  }
  else
  {
    memcpy(__dst, v2, sizeof(__dst));
    sub_1000B01A4((unint64_t)__dst, a1, &v5);
  }
  return v5;
}

void sub_1000B5E04(_BYTE *a1)
{
  bzero(a1, 0xE80uLL);
  a1[3712] = 1;
}

uint64_t sub_1000B5E30(uint64_t result)
{
  *(_BYTE *)(result + 3712) = 0;
  return result;
}

void sub_1000B5E38(_OWORD *a1)
{
  *a1 = xmmword_10033B1F0;
  bzero(a1 + 1, 0xF90uLL);
}

char *sub_1000B5E4C(uint64_t a1, uint64_t a2, char *__dst, uint64_t a4)
{
  uint64_t v4;
  char *v5;
  size_t v6;
  char *v7;
  char *result;

  v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else
  {
    if (v4 < 0)
    {
      result = (char *)_fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 1090, 0);
      goto LABEL_9;
    }
    v5 = (char *)(a4 + 2 * a1 + 32);
    v6 = 2 * v4;
    v7 = &__dst[v6];
    if (v5 >= &__dst[v6] || &v5[v6] <= __dst)
    {
      memcpy(__dst, v5, v6);
      return v7;
    }
  }
  result = (char *)_fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 1092, 0);
LABEL_9:
  __break(1u);
  return result;
}

uint64_t sub_1000B5F34(uint64_t result, unint64_t a2, __int16 a3)
{
  if ((a3 & 0xFF00) != 0x200)
    return sub_10000E614(result, a2);
  return result;
}

double sub_1000B5F48(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  double result;
  unint64_t v10;
  _QWORD v11[5];

  v2 = v1;
  v4 = sub_10001F11C((uint64_t)_swiftEmptyArrayStorage);
  v5 = type metadata accessor for BinaryEncoder();
  v6 = (uint64_t *)swift_allocObject(v5, 40, 7);
  *((_OWORD *)v6 + 1) = xmmword_10033A100;
  v6[4] = v4;
  v11[3] = v5;
  v11[4] = sub_100011DE4((unint64_t *)&qword_100406278, (uint64_t (*)(uint64_t))type metadata accessor for BinaryEncoder, (uint64_t)protocol conformance descriptor for BinaryEncoder);
  v11[0] = v6;
  v7 = type metadata accessor for NANAttribute(0);
  v8 = sub_100011DE4(&qword_100406720, type metadata accessor for NANAttribute, (uint64_t)&protocol conformance descriptor for NANAttribute);
  swift_bridgeObjectRetain(a1);
  swift_retain();
  Array<A>.encode(to:)(v11, a1, v7, v8);
  sub_100014430(v11);
  if (!v2)
  {
    swift_bridgeObjectRelease(a1);
    swift_beginAccess(v6 + 2, v11, 0, 0);
    v10 = v6[3];
    sub_100031FEC(v6[2], v10);
    swift_release(v6);
    __asm { BR              X9 }
  }
  swift_release(v6);
  *(_QWORD *)&result = swift_bridgeObjectRelease(a1).n128_u64[0];
  return result;
}

void sub_1000B62E0(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  __int16 v3;

  v2 = a2 >> 62;
  bzero(&v3, 0x802uLL);
  __asm { BR              X9 }
}

uint64_t sub_1000B6530(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t result;

  if (a7 != 1)
  {
    sub_10000E614(a2, a3);
    sub_10000E658(a4, a5);
    return swift_bridgeObjectRelease(a7);
  }
  return result;
}

_QWORD *sub_1000B6584(_QWORD *a1)
{
  uint64_t v2;

  v2 = a1[5];
  sub_100063C28(a1[1], a1[2], a1[3]);
  swift_bridgeObjectRetain(v2);
  return a1;
}

_QWORD *sub_1000B65BC(_QWORD *a1)
{
  uint64_t v2;

  v2 = a1[5];
  sub_1000634E8(a1[1], a1[2], a1[3]);
  swift_bridgeObjectRelease(v2);
  return a1;
}

void sub_1000B65F4(uint64_t a1)
{
  sub_1000B6634(a1, (uint64_t (*)(uint64_t, uint64_t *))sub_100334300, 157);
}

void sub_1000B6614(uint64_t a1)
{
  sub_1000B6634(a1, (uint64_t (*)(uint64_t, uint64_t *))sub_100334400, 239);
}

void sub_1000B6634(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t *), uint64_t a3)
{
  uint64_t *v3;

  sub_1000AC604(a1, v3[6], v3[2], v3[3], v3[4], v3[5], a2, a3);
}

uint64_t sub_1000B665C()
{
  return sub_100011DE4(&qword_100405178, type metadata accessor for AppleDevice, (uint64_t)&protocol conformance descriptor for AppleDevice);
}

uint64_t sub_1000B6688(uint64_t a1)
{
  uint64_t result;

  result = sub_100011DE4((unint64_t *)&unk_100405C50, type metadata accessor for AppleIO80211Driver, (uint64_t)&protocol conformance descriptor for AppleIO80211Driver);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t type metadata accessor for AppleIO80211Driver(uint64_t a1)
{
  uint64_t result;

  result = qword_1004067F8;
  if (!qword_1004067F8)
    return swift_getSingletonMetadata(a1, &nominal type descriptor for AppleIO80211Driver);
  return result;
}

uint64_t sub_1000B6700()
{
  return sub_100011DE4(&qword_100405180, type metadata accessor for AppleDevice, (uint64_t)&protocol conformance descriptor for AppleDevice);
}

uint64_t sub_1000B672C()
{
  return sub_100011770(&qword_100406768, &qword_100406770, "u<\n");
}

_QWORD *sub_1000B6758@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *result;

  result = AppleIO80211Driver.capabilities.getter();
  *a1 = result;
  return result;
}

uint64_t sub_1000B6780(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *a1;
  v3 = *(_QWORD *)(*(_QWORD *)a2 + 72);
  *(_QWORD *)(*(_QWORD *)a2 + 72) = v2;
  swift_bridgeObjectRetain(v2);
  return swift_bridgeObjectRelease(v3);
}

uint64_t sub_1000B67B0()
{
  return type metadata accessor for AppleIO80211Driver(0);
}

uint64_t sub_1000B67B8(uint64_t a1)
{
  uint64_t result;
  unint64_t v3;
  _QWORD v4[6];

  v4[0] = &unk_10033F608;
  v4[1] = &unk_10033F620;
  v4[2] = (char *)&value witness table for Builtin.NativeObject + 64;
  v4[3] = &unk_10033F638;
  v4[4] = &unk_10033F650;
  result = type metadata accessor for Logger(319);
  if (v3 <= 0x3F)
  {
    v4[5] = *(_QWORD *)(result - 8) + 64;
    result = swift_updateClassMetadata2(a1, 256, 6, v4, a1 + 80);
    if (!result)
      return 0;
  }
  return result;
}

void sub_1000B685C(uint64_t a1)
{
  uint64_t v1;

  sub_1000AC52C(a1, **(_QWORD ***)(v1 + 16));
}

void sub_1000B6878(uint64_t a1)
{
  uint64_t v1;

  sub_1000AC454(a1, **(_QWORD ***)(v1 + 16));
}

uint64_t sub_1000B6894(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  return sub_1001CF7A0(a1, a2, *(_QWORD *)(v2 + 16), *(_QWORD **)(v2 + 24));
}

void sub_1000B689C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int16 v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  _OWORD v16[3];
  char v17;
  uint64_t v18;

  v2 = v1;
  v3 = *(_QWORD *)(a1 + 16);
  if (v3)
  {
    v4 = a1 + 32;
    v18 = a1;
    swift_bridgeObjectRetain(a1);
    v5 = 0;
    while (1)
    {
      if (v5 <= 1)
      {
        v6 = v4 + 16 * v5;
        v7 = *(_QWORD *)(v6 + 8);
        v8 = *(_WORD *)(v6 + 2);
        swift_bridgeObjectRetain(v7);
        sub_10007CCF8(0, 4, v8);
        if (v2)
        {
          swift_unexpectedError(v2, "CoreP2P/NANAttribute.swift", 26, 1);
          __break(1u);
          return;
        }
        v9 = *(_QWORD *)(v7 + 16);
        if (v9)
        {
          swift_bridgeObjectRetain(v7);
          v10 = 0;
          v11 = 32;
          do
          {
            v12 = *(_OWORD *)(v7 + v11);
            v13 = *(_OWORD *)(v7 + v11 + 16);
            v14 = *(_OWORD *)(v7 + v11 + 32);
            v17 = *(_BYTE *)(v7 + v11 + 48);
            v16[1] = v13;
            v16[2] = v14;
            v16[0] = v12;
            if (v10 <= 0xF)
            {
              sub_1000B6584(v16);
              sub_1000AEB6C((unint64_t)&v15);
              sub_1000B65BC(v16);
              ++v10;
            }
            v11 += 56;
            --v9;
          }
          while (v9);
          swift_bridgeObjectRelease(v7);
        }
        swift_bridgeObjectRelease(v7);
      }
      if (++v5 == v3)
      {
        swift_bridgeObjectRelease(v18);
        return;
      }
    }
  }
}

uint64_t sub_1000B6A18(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;

  v5 = v3;
  v8 = *(_QWORD *)(v3 + 40);
  v10 = *(_QWORD *)(v5 + 16);
  v9 = *(_QWORD *)(v5 + 24);
  v11 = a1 & 0xFFFFFFFFFFFFLL;
  swift_retain();
  swift_bridgeObjectRetain(v9);
  sub_10005FC48(v11, a2, a3, v10, v9, 1u);
  swift_bridgeObjectRelease(v9);
  result = swift_release(v8);
  if (!v4)
    __asm { BR              X10 }
  return result;
}

void sub_1000B6C24(uint64_t a1)
{
  uint64_t v1;

  sub_1000AE4AC(a1, *(_QWORD *)(v1 + 16), **(_QWORD ***)(v1 + 24));
}

uint64_t sub_1000B6C40(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4;
  unint64_t v6;
  unint64_t v7;
  uint64_t result;

  v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else
  {
    if (v4 < 0)
    {
      result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 1090, 0);
      goto LABEL_9;
    }
    v6 = a4 + 16 * a1 + 32;
    v7 = a3 + 16 * v4;
    if (v6 >= v7 || v6 + 16 * v4 <= a3)
    {
      sub_100012C44(&qword_100406668);
      swift_arrayInitWithCopy(a3);
      return v7;
    }
  }
  result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 1092, 0);
LABEL_9:
  __break(1u);
  return result;
}

uint64_t sub_1000B6D48(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t (*a5)(_QWORD))
{
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t result;

  v5 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
    goto LABEL_9;
  }
  if (v5 < 0)
  {
LABEL_9:
    result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 1090, 0);
    goto LABEL_11;
  }
  v9 = *(_QWORD *)(a5(0) - 8);
  v10 = *(unsigned __int8 *)(v9 + 80);
  v11 = *(_QWORD *)(v9 + 72);
  v12 = a4 + ((v10 + 32) & ~v10) + v11 * a1;
  v13 = v11 * v5;
  v14 = a3 + v13;
  v15 = v12 + v13;
  if (v12 >= v14 || v15 <= a3)
  {
    swift_arrayInitWithCopy(a3);
    return v14;
  }
  result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 1092, 0);
LABEL_11:
  __break(1u);
  return result;
}

uint64_t sub_1000B6E60(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4;
  unint64_t v6;
  unint64_t v7;
  uint64_t result;

  v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
    goto LABEL_9;
  }
  if (v4 < 0)
  {
LABEL_9:
    result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 1090, 0);
    goto LABEL_11;
  }
  v6 = a4 + 24 * a1 + 32;
  v7 = a3 + 24 * v4;
  if (v6 >= v7 || v6 + 24 * v4 <= a3)
  {
    sub_100012C44(&qword_1004068B8);
    swift_arrayInitWithCopy(a3);
    return v7;
  }
  result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 1092, 0);
LABEL_11:
  __break(1u);
  return result;
}

uint64_t sub_1000B6F6C(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4;
  unint64_t v6;
  unint64_t v7;
  uint64_t result;

  v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else
  {
    if (v4 < 0)
    {
      result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 1090, 0);
      goto LABEL_9;
    }
    v6 = a4 + 8 * a1 + 32;
    v7 = a3 + 8 * v4;
    if (v6 >= v7 || v6 + 8 * v4 <= a3)
    {
      sub_100012C44((uint64_t *)&unk_10040D330);
      swift_arrayInitWithCopy(a3);
      return v7;
    }
  }
  result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 1092, 0);
LABEL_9:
  __break(1u);
  return result;
}

uint64_t sub_1000B7074(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4;
  unint64_t v6;
  unint64_t v7;
  uint64_t result;

  v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
    goto LABEL_9;
  }
  if (v4 < 0)
  {
LABEL_9:
    result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 1090, 0);
    goto LABEL_11;
  }
  v6 = a4 + 48 * a1 + 32;
  v7 = a3 + 48 * v4;
  if (v6 >= v7 || v6 + 48 * v4 <= a3)
  {
    sub_100012C44(&qword_100404EE0);
    swift_arrayInitWithCopy(a3);
    return v7;
  }
  result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 1092, 0);
LABEL_11:
  __break(1u);
  return result;
}

uint64_t sub_1000B7180(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t result;

  v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else
  {
    if (v4 < 0)
    {
      result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 1090, 0);
      goto LABEL_9;
    }
    v5 = a4 + 32 * a1 + 32;
    v6 = a3 + 32 * v4;
    if (v5 >= v6 || v5 + 32 * v4 <= a3)
    {
      swift_arrayInitWithCopy(a3);
      return v6;
    }
  }
  result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 1092, 0);
LABEL_9:
  __break(1u);
  return result;
}

uint64_t sub_1000B7270(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t result;

  v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
  }
  else
  {
    if (v4 < 0)
    {
      result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 1090, 0);
      goto LABEL_9;
    }
    v5 = a4 + 8 * a1 + 32;
    v6 = a3 + 8 * v4;
    if (v5 >= v6 || v5 + 8 * v4 <= a3)
    {
      swift_arrayInitWithCopy(a3);
      return v6;
    }
  }
  result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 1092, 0);
LABEL_9:
  __break(1u);
  return result;
}

void sub_1000B7360(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  sub_1000AFCE8(a1, a2, *(_QWORD *)(v2 + 16), *(_QWORD *)(v2 + 24));
}

void sub_1000B7380(uint64_t a1)
{
  uint64_t *v1;

  sub_1000AE584(a1, v1[5], v1[6], v1[2], v1[3], v1[4]);
}

uint64_t sub_1000B73A0(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t result;

  result = sub_1000AB320(v3[8], a1, a2, v3[2], v3[4], v3[5], v3[6]);
  if (v4)
    *a3 = v4;
  return result;
}

uint64_t sub_1000B73E8(unint64_t a1, unint64_t a2)
{
  uint64_t v2;

  return sub_10020942C(a1, a2, *(_QWORD **)(v2 + 16), *(uint64_t **)(v2 + 24));
}

uint64_t sub_1000B73F0(uint64_t *a1)
{
  uint64_t v1;

  v1 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF)
    LODWORD(v1) = -1;
  return (v1 + 1);
}

uint64_t sub_1000B7408(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  if ((a5 & 1) != 0)
    return sub_1000B7414(a1, a2, a3, a4);
  return a1;
}

uint64_t sub_1000B7414(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;

  if (a4 != 1)
    return swift_bridgeObjectRelease(a4);
  return result;
}

void *sub_1000B742C()
{
  return variable initialization expression of NANMatchingFilter.matchingFilterList();
}

void sub_1000B7440(uint64_t a1)
{
  sub_1000B685C(a1);
}

void sub_1000B7454(uint64_t a1)
{
  sub_1000B6878(a1);
}

uint64_t *SCPreferencesRef.p2pPreferences.unsafeMutableAddressor()
{
  if (qword_100403F28 != -1)
    swift_once(&qword_100403F28, sub_1000BC658);
  return &static SCPreferencesRef.p2pPreferences;
}

uint64_t CachedPreferenceStorage.init(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;

  v8 = type metadata accessor for InMemoryPreferenceStorage();
  v9 = swift_allocObject(v8, 24, 7);
  *(_QWORD *)(v9 + 16) = &_swiftEmptyDictionarySingleton;
  *a4 = v9;
  v11 = (char *)a4 + *(int *)(type metadata accessor for CachedPreferenceStorage(0, a2, a3, v10) + 36);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 32))(v11, a1, a2);
}

uint64_t LockedPreferencesStorage.init(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  _DWORD *v10;
  uint64_t v11;
  char *v12;

  v8 = type metadata accessor for Lock();
  v9 = swift_allocObject(v8, 24, 7);
  v10 = (_DWORD *)swift_slowAlloc(4, -1);
  *(_QWORD *)(v9 + 16) = v10;
  *v10 = 0;
  *a4 = v9;
  v12 = (char *)a4 + *(int *)(type metadata accessor for LockedPreferencesStorage(0, a2, a3, v11) + 36);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 32))(v12, a1, a2);
}

Swift::Void __swiftcall CachedPreferenceStorage.invalidateCache()()
{
  uint64_t *v0;
  uint64_t v1;
  uint64_t v2;
  _BYTE v3[24];

  v1 = *v0;
  swift_beginAccess(*v0 + 16, v3, 1, 0);
  v2 = *(_QWORD *)(v1 + 16);
  *(_QWORD *)(v1 + 16) = &_swiftEmptyDictionarySingleton;
  swift_bridgeObjectRelease(v2);
}

void LockedPreferencesStorage.withBackingStorage(_:)(void (*a1)(uint64_t), uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  os_unfair_lock_s *v6;

  v6 = *(os_unfair_lock_s **)(*(_QWORD *)v3 + 16);
  os_unfair_lock_lock(v6);
  a1(v3 + *(int *)(a3 + 36));
  os_unfair_lock_unlock(v6);
}

uint64_t CachedPreferenceStorage.withBackingStorage(_:)(uint64_t (*a1)(uint64_t), uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  return a1(v3 + *(int *)(a3 + 36));
}

void *PreferenceDefaults.EnableUserspaceP2POptions.none.unsafeMutableAddressor()
{
  return &static PreferenceDefaults.EnableUserspaceP2POptions.none;
}

void *PreferenceDefaults.EnableUserspaceP2POptions.localeManager.unsafeMutableAddressor()
{
  return &static PreferenceDefaults.EnableUserspaceP2POptions.localeManager;
}

void *PreferenceDefaults.EnableUserspaceP2POptions.infraManager.unsafeMutableAddressor()
{
  return &static PreferenceDefaults.EnableUserspaceP2POptions.infraManager;
}

void *PreferenceDefaults.EnableUserspaceP2POptions.rawEventPayload.unsafeMutableAddressor()
{
  return &static PreferenceDefaults.EnableUserspaceP2POptions.rawEventPayload;
}

void *PreferenceDefaults.EnableUserspaceP2POptions.awdlToWiFiAwareMigration.unsafeMutableAddressor()
{
  return &static PreferenceDefaults.EnableUserspaceP2POptions.awdlToWiFiAwareMigration;
}

void *PreferenceDefaults.EnableUserspaceP2POptions.keepAliveTermination.unsafeMutableAddressor()
{
  return &static PreferenceDefaults.EnableUserspaceP2POptions.keepAliveTermination;
}

void *PreferenceDefaults.EnableUserspaceP2POptions.infraRealTimePacketThreshold.unsafeMutableAddressor()
{
  return &static PreferenceDefaults.EnableUserspaceP2POptions.infraRealTimePacketThreshold;
}

void *PreferenceDefaults.EnableUserspaceP2POptions.remoteScreenRTGSyncElection.unsafeMutableAddressor()
{
  return &static PreferenceDefaults.EnableUserspaceP2POptions.remoteScreenRTGSyncElection;
}

void *PreferenceDefaults.EnableUserspaceP2POptions.all.unsafeMutableAddressor()
{
  return &static PreferenceDefaults.EnableUserspaceP2POptions.all;
}

uint64_t static PreferenceDefaults.EnableUserspaceP2POptions.all.getter()
{
  return 127;
}

uint64_t PreferenceDefaults.EnableUserspaceP2POptions.description.getter(char a1)
{
  unint64_t v2;
  Swift::String v3;
  Swift::String v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  Swift::String v15;
  Swift::String v17;
  Swift::String v18;
  Swift::String v19;
  Swift::String v20;
  Swift::String v21;
  Swift::String v22;
  Swift::String v23;
  uint64_t v24;
  unint64_t v25;

  v24 = dispatch thunk of CustomStringConvertible.description.getter(&type metadata for UInt64, &protocol witness table for UInt64);
  v25 = v2;
  v3._countAndFlagsBits = 10272;
  v3._object = (void *)0xE200000000000000;
  String.append(_:)(v3);
  if ((a1 & 0x7F) != 0)
  {
    if ((a1 & 1) != 0)
    {
      v18._object = (void *)0x8000000100364810;
      v18._countAndFlagsBits = 0xD000000000000010;
      String.append(_:)(v18);
      if ((a1 & 2) == 0)
      {
LABEL_4:
        if ((a1 & 4) == 0)
          goto LABEL_5;
        goto LABEL_15;
      }
    }
    else if ((a1 & 2) == 0)
    {
      goto LABEL_4;
    }
    v19._countAndFlagsBits = 0x614D206172666E49;
    v19._object = (void *)0xEF202C726567616ELL;
    String.append(_:)(v19);
    if ((a1 & 4) == 0)
    {
LABEL_5:
      if ((a1 & 8) == 0)
        goto LABEL_6;
      goto LABEL_16;
    }
LABEL_15:
    v20._countAndFlagsBits = 0xD000000000000013;
    v20._object = (void *)0x80000001003647F0;
    String.append(_:)(v20);
    if ((a1 & 8) == 0)
    {
LABEL_6:
      if ((a1 & 0x10) == 0)
        goto LABEL_7;
      goto LABEL_17;
    }
LABEL_16:
    v21._countAndFlagsBits = 0xD00000000000001ELL;
    v21._object = (void *)0x80000001003647D0;
    String.append(_:)(v21);
    if ((a1 & 0x10) == 0)
    {
LABEL_7:
      if ((a1 & 0x20) == 0)
        goto LABEL_8;
      goto LABEL_18;
    }
LABEL_17:
    v22._countAndFlagsBits = 0xD000000000000018;
    v22._object = (void *)0x80000001003647B0;
    String.append(_:)(v22);
    if ((a1 & 0x20) == 0)
    {
LABEL_8:
      if ((a1 & 0x40) == 0)
      {
LABEL_10:
        v5 = sub_1000BE238(2, v24, v25);
        v7 = v6;
        v9 = v8;
        v11 = v10;
        swift_bridgeObjectRelease(v25);
        v12 = static String._fromSubstring(_:)(v5, v7, v9, v11);
        v14 = v13;
        swift_bridgeObjectRelease(v11);
        swift_bridgeObjectRetain(v14);
        v15._countAndFlagsBits = 41;
        v15._object = (void *)0xE100000000000000;
        String.append(_:)(v15);
        swift_bridgeObjectRelease(v14);
        return v12;
      }
LABEL_9:
      v4._countAndFlagsBits = 0xD000000000000021;
      v4._object = (void *)0x8000000100364750;
      String.append(_:)(v4);
      goto LABEL_10;
    }
LABEL_18:
    v23._countAndFlagsBits = 0xD000000000000022;
    v23._object = (void *)0x8000000100364780;
    String.append(_:)(v23);
    if ((a1 & 0x40) == 0)
      goto LABEL_10;
    goto LABEL_9;
  }
  v17._countAndFlagsBits = 0x61736944206C6C41;
  v17._object = (void *)0xED00002964656C62;
  String.append(_:)(v17);
  return v24;
}

uint64_t sub_1000B7920()
{
  _QWORD *v0;

  return PreferenceDefaults.EnableUserspaceP2POptions.description.getter(*v0);
}

_UNKNOWN **static PreferenceDefaults.InternetSharingOptions.allCases.getter()
{
  return &off_1003D6DD8;
}

uint64_t PreferenceDefaults.InternetSharingOptions.rawValue.getter(char a1)
{
  if (!a1)
    return 6710895;
  if (a1 == 1)
    return 0x6775626564;
  return 0x61427963696C6F70;
}

uint64_t sub_1000B798C(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return sub_10003BAD4(*a1, *a2);
}

Swift::Int sub_1000B7998()
{
  unsigned __int8 *v0;
  int v1;
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  _QWORD v7[9];

  v1 = *v0;
  Hasher.init(_seed:)(v7);
  v2 = 0xE500000000000000;
  v3 = 0x6775626564;
  if (v1 != 1)
  {
    v3 = 0x61427963696C6F70;
    v2 = 0xEB00000000646573;
  }
  if (v1)
    v4 = v3;
  else
    v4 = 6710895;
  if (v1)
    v5 = v2;
  else
    v5 = 0xE300000000000000;
  String.hash(into:)(v7, v4, v5);
  swift_bridgeObjectRelease(v5);
  return Hasher._finalize()();
}

uint64_t sub_1000B7A34(uint64_t a1)
{
  _BYTE *v1;
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;

  v2 = 0xE500000000000000;
  v3 = 0x6775626564;
  if (*v1 != 1)
  {
    v3 = 0x61427963696C6F70;
    v2 = 0xEB00000000646573;
  }
  if (*v1)
    v4 = v3;
  else
    v4 = 6710895;
  if (*v1)
    v5 = v2;
  else
    v5 = 0xE300000000000000;
  String.hash(into:)(a1, v4, v5);
  return swift_bridgeObjectRelease(v5);
}

Swift::Int sub_1000B7AAC()
{
  unsigned __int8 *v0;
  int v1;
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  _QWORD v7[9];

  v1 = *v0;
  Hasher.init(_seed:)(v7);
  v2 = 0xE500000000000000;
  v3 = 0x6775626564;
  if (v1 != 1)
  {
    v3 = 0x61427963696C6F70;
    v2 = 0xEB00000000646573;
  }
  if (v1)
    v4 = v3;
  else
    v4 = 6710895;
  if (v1)
    v5 = v2;
  else
    v5 = 0xE300000000000000;
  String.hash(into:)(v7, v4, v5);
  swift_bridgeObjectRelease(v5);
  return Hasher._finalize()();
}

unint64_t sub_1000B7B44@<X0>(Swift::String *a1@<X0>, _BYTE *a2@<X8>)
{
  unint64_t result;

  result = _s7CoreP2P18PreferenceDefaultsV22InternetSharingOptionsO8rawValueAESgSS_tcfC_0(*a1);
  *a2 = result;
  return result;
}

void sub_1000B7B70(uint64_t *a1@<X8>)
{
  _BYTE *v1;
  int v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;

  v2 = *v1;
  v3 = 0xE300000000000000;
  v4 = 0xE500000000000000;
  v5 = 0x6775626564;
  if (v2 != 1)
  {
    v5 = 0x61427963696C6F70;
    v4 = 0xEB00000000646573;
  }
  v6 = v2 == 0;
  if (*v1)
    v7 = v5;
  else
    v7 = 6710895;
  if (!v6)
    v3 = v4;
  *a1 = v7;
  a1[1] = v3;
}

void sub_1000B7BCC(_QWORD *a1@<X8>)
{
  *a1 = &off_1003D6E00;
}

void *PreferenceDefaults.enableUserspaceP2POptions.unsafeMutableAddressor()
{
  return &static PreferenceDefaults.enableUserspaceP2POptions;
}

uint64_t sub_1000B7BE8()
{
  uint64_t result;

  result = os_variant_allows_internal_security_policies(0);
  static PreferenceDefaults.isAppleInternal = result;
  return result;
}

char *PreferenceDefaults.isAppleInternal.unsafeMutableAddressor()
{
  if (qword_100403F18 != -1)
    swift_once(&qword_100403F18, sub_1000B7BE8);
  return &static PreferenceDefaults.isAppleInternal;
}

uint64_t static PreferenceDefaults.isAppleInternal.getter()
{
  return sub_1000B7D7C(&qword_100403F18, (unsigned __int8 *)&static PreferenceDefaults.isAppleInternal);
}

id static PreferenceDefaults.deviceName.getter()
{
  id result;
  void *v1;
  id v2;
  uint64_t v3;

  result = (id)MobileGestalt_get_current_device();
  if (result)
  {
    v1 = result;
    v2 = (id)MobileGestalt_copy_userAssignedDeviceName_obj();

    if (!v2)
      return 0;
    v3 = static String._unconditionallyBridgeFromObjectiveC(_:)(v2);

    return (id)v3;
  }
  else
  {
    __break(1u);
  }
  return result;
}

void sub_1000B7CDC()
{
  id v0;
  void *v1;
  char iPadCapability;

  v0 = (id)MobileGestalt_get_current_device();
  if (v0)
  {
    v1 = v0;
    iPadCapability = MobileGestalt_get_iPadCapability();

    static PreferenceDefaults.isiPad = iPadCapability;
  }
  else
  {
    __break(1u);
  }
}

char *PreferenceDefaults.isiPad.unsafeMutableAddressor()
{
  if (qword_100403F20 != -1)
    swift_once(&qword_100403F20, sub_1000B7CDC);
  return &static PreferenceDefaults.isiPad;
}

uint64_t static PreferenceDefaults.isiPad.getter()
{
  return sub_1000B7D7C(&qword_100403F20, (unsigned __int8 *)&static PreferenceDefaults.isiPad);
}

uint64_t sub_1000B7D7C(_QWORD *a1, unsigned __int8 *a2)
{
  if (*a1 != -1)
    swift_once();
  return *a2;
}

uint64_t PreferencesName.rawValue.getter(unsigned __int8 a1)
{
  return ((uint64_t (*)(unint64_t, unint64_t))((char *)sub_1000B7DF4 + 4 * byte_10033F9F0[a1]))(0xD00000000000001ALL, 0x8000000100361D10);
}

uint64_t sub_1000B7DF4()
{
  uint64_t v0;

  return v0 - 1;
}

uint64_t sub_1000B7F8C(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  char v10;

  v2 = *a2;
  v3 = PreferencesName.rawValue.getter(*a1);
  v5 = v4;
  v6 = PreferencesName.rawValue.getter(v2);
  if (v3 == v6 && v5 == v7)
  {
    v10 = 1;
    v9 = v5;
  }
  else
  {
    v9 = v7;
    v10 = _stringCompareWithSmolCheck(_:_:expecting:)(v3, v5, v6, v7, 0);
  }
  swift_bridgeObjectRelease(v5);
  swift_bridgeObjectRelease(v9);
  return v10 & 1;
}

Swift::Int sub_1000B8014()
{
  unsigned __int8 *v0;
  unsigned __int8 v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD v6[9];

  v1 = *v0;
  Hasher.init(_seed:)(v6);
  v2 = PreferencesName.rawValue.getter(v1);
  v4 = v3;
  String.hash(into:)(v6, v2, v3);
  swift_bridgeObjectRelease(v4);
  return Hasher._finalize()();
}

double sub_1000B8074(uint64_t a1)
{
  unsigned __int8 *v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  double result;

  v3 = PreferencesName.rawValue.getter(*v1);
  v5 = v4;
  String.hash(into:)(a1, v3, v4);
  *(_QWORD *)&result = swift_bridgeObjectRelease(v5).n128_u64[0];
  return result;
}

Swift::Int sub_1000B80B4()
{
  unsigned __int8 *v0;
  unsigned __int8 v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD v6[9];

  v1 = *v0;
  Hasher.init(_seed:)(v6);
  v2 = PreferencesName.rawValue.getter(v1);
  v4 = v3;
  String.hash(into:)(v6, v2, v3);
  swift_bridgeObjectRelease(v4);
  return Hasher._finalize()();
}

uint64_t sub_1000B8110@<X0>(uint64_t *a1@<X0>, _BYTE *a2@<X8>)
{
  uint64_t result;

  result = _s7CoreP2P15PreferencesNameO8rawValueACSgSS_tcfC_0(*a1, a1[1]);
  *a2 = result;
  return result;
}

uint64_t sub_1000B813C@<X0>(uint64_t *a1@<X8>)
{
  unsigned __int8 *v1;
  uint64_t result;
  uint64_t v4;

  result = PreferencesName.rawValue.getter(*v1);
  *a1 = result;
  a1[1] = v4;
  return result;
}

uint64_t Preferences.Preference.wrappedValue.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v16;

  v5 = *(_QWORD *)(a1 - 8);
  v6 = __chkstk_darwin(a1);
  v8 = (char *)&v16 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  v9 = *(_QWORD *)(v6 + 24);
  v10 = type metadata accessor for Optional(0, v9);
  v11 = *(_QWORD *)(v10 - 8);
  __chkstk_darwin(v10);
  v13 = (char *)&v16 - v12;
  if (*(_BYTE *)(v2 + *(int *)(a1 + 52)) != 1)
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v9 - 8) + 16))(a2, v2 + *(int *)(a1 + 48), v9);
  (*(void (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)(a1 + 32) + 8))(*(unsigned __int8 *)(v2 + *(int *)(a1 + 44)), v9, *(_QWORD *)(a1 + 16));
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v8, v2, a1);
  v14 = *(_QWORD *)(v9 - 8);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v14 + 48))(v13, 1, v9) == 1)
  {
    (*(void (**)(uint64_t, char *, uint64_t))(v14 + 16))(a2, &v8[*(int *)(a1 + 48)], v9);
    (*(void (**)(char *, uint64_t))(v5 + 8))(v8, a1);
    return (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v13, v10);
  }
  else
  {
    (*(void (**)(char *, uint64_t))(v5 + 8))(v8, a1);
    return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v14 + 32))(a2, v13, v9);
  }
}

uint64_t Preferences.Preference.wrappedValue.setter(uint64_t a1, uint64_t a2)
{
  return sub_1000B8844(a1, a2, (void (*)(void))sub_1000BE444);
}

void (*Preferences.Preference.wrappedValue.modify(_QWORD *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  size_t v8;
  void *v9;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = a2;
  v5[1] = v2;
  v6 = *(_QWORD *)(a2 + 24);
  v5[2] = v6;
  v7 = *(_QWORD *)(v6 - 8);
  v5[3] = v7;
  v8 = *(_QWORD *)(v7 + 64);
  v5[4] = malloc(v8);
  v9 = malloc(v8);
  v5[5] = v9;
  Preferences.Preference.wrappedValue.getter(a2, (uint64_t)v9);
  return sub_1000B839C;
}

void sub_1000B839C(uint64_t **a1, char a2)
{
  sub_1000B8910(a1, a2, (void (*)(void *, uint64_t))sub_1000BE444);
}

uint64_t MutableDriverProperty.projectedValue.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;

  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a1 - 8) + 16))(a2, v2);
}

Swift::Void __swiftcall Preferences.Preference.reset()()
{
  uint64_t v0;
  uint64_t v1;

  (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(v0 + 32) + 32))(*(unsigned __int8 *)(v1 + *(int *)(v0 + 44)), *(_QWORD *)(v0 + 16));
}

uint64_t Preferences.Preference.description.getter(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  Swift::String v8;
  uint64_t v10;
  char v11;
  _QWORD v12[2];

  v3 = *(_QWORD *)(a1 + 24);
  v4 = *(_QWORD *)(v3 - 8);
  v5 = __chkstk_darwin();
  v7 = (char *)&v10 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12[0] = 0;
  v12[1] = 0xE000000000000000;
  v11 = *(_BYTE *)(v1 + *(int *)(v5 + 44));
  _print_unlocked<A, B>(_:_:)(&v11, v12, &type metadata for PreferencesName, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
  v8._countAndFlagsBits = 2112800;
  v8._object = (void *)0xE300000000000000;
  String.append(_:)(v8);
  Preferences.Preference.wrappedValue.getter(a1, (uint64_t)v7);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v7, v3);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v7, v3);
  return v12[0];
}

uint64_t sub_1000B84C4@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, int a4@<W3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t AssociatedTypeWitness;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int *v24;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  _QWORD v31[4];

  v26 = a3;
  v27 = a7;
  v29 = a2;
  v30 = a4;
  v28 = a9;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a8, a6, &protocol requirements base descriptor for RawRepresentable);
  v14 = *(_QWORD *)(AssociatedTypeWitness - 8);
  __chkstk_darwin();
  v16 = (uint64_t *)((char *)&v26 - v15);
  v17 = *(_QWORD *)(a5 - 8);
  __chkstk_darwin();
  v19 = (char *)&v26 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t, uint64_t))(v17 + 16))(v19, a1, a5);
  dispatch thunk of RawRepresentable.rawValue.getter(v16, a6, a8);
  (*(void (**)(uint64_t, uint64_t))(v17 + 8))(a1, a5);
  v31[0] = a5;
  v31[1] = a6;
  v20 = v27;
  v31[2] = v27;
  v31[3] = a8;
  v21 = type metadata accessor for Preferences.EnumPreference(0, (uint64_t)v31);
  v22 = v28;
  v23 = v28 + *(int *)(v21 + 52);
  (*(void (**)(uint64_t, char *, uint64_t))(v17 + 32))(v23, v19, a5);
  v24 = (int *)type metadata accessor for Preferences.Preference(0, a5, AssociatedTypeWitness, v20);
  *(_BYTE *)(v23 + v24[11]) = v29;
  (*(void (**)(uint64_t, _QWORD *, uint64_t))(v14 + 32))(v23 + v24[12], v16, AssociatedTypeWitness);
  *(_BYTE *)(v23 + v24[13]) = v30;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a6 - 8) + 32))(v22, v26, a6);
}

uint64_t Preferences.EnumPreference.wrappedValue.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t AssociatedTypeWitness;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v22 = a2;
  v4 = *(_QWORD *)(a1 - 8);
  v5 = __chkstk_darwin();
  v7 = (char *)&v19 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  v8 = *(_QWORD *)(v5 + 40);
  v9 = *(_QWORD *)(v5 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v8, v9, &protocol requirements base descriptor for RawRepresentable, &associated type descriptor for RawRepresentable.RawValue);
  __chkstk_darwin();
  v12 = (char *)&v19 - v11;
  v13 = type metadata accessor for Optional(0, v9);
  v20 = *(_QWORD *)(v13 - 8);
  v21 = v13;
  __chkstk_darwin();
  v15 = (char *)&v19 - v14;
  v16 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), AssociatedTypeWitness, *(_QWORD *)(a1 + 32));
  Preferences.Preference.wrappedValue.getter(v16, (uint64_t)v12);
  dispatch thunk of RawRepresentable.init(rawValue:)(v12, v9, v8);
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))(v7, v2, a1);
  v17 = *(_QWORD *)(v9 - 8);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v17 + 48))(v15, 1, v9) == 1)
  {
    (*(void (**)(uint64_t, char *, uint64_t))(v17 + 16))(v22, v7, v9);
    (*(void (**)(char *, uint64_t))(v4 + 8))(v7, a1);
    return (*(uint64_t (**)(char *, uint64_t))(v20 + 8))(v15, v21);
  }
  else
  {
    (*(void (**)(char *, uint64_t))(v4 + 8))(v7, a1);
    return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v17 + 32))(v22, v15, v9);
  }
}

uint64_t Preferences.EnumPreference.wrappedValue.setter(uint64_t a1, uint64_t a2)
{
  return sub_1000B8844(a1, a2, (void (*)(void))sub_1000BE518);
}

uint64_t sub_1000B8844(uint64_t a1, uint64_t a2, void (*a3)(void))
{
  a3();
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(*(_QWORD *)(a2 + 24) - 8) + 8))(a1);
}

void (*Preferences.EnumPreference.wrappedValue.modify(_QWORD *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  size_t v8;
  void *v9;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = a2;
  v5[1] = v2;
  v6 = *(_QWORD *)(a2 + 24);
  v5[2] = v6;
  v7 = *(_QWORD *)(v6 - 8);
  v5[3] = v7;
  v8 = *(_QWORD *)(v7 + 64);
  v5[4] = malloc(v8);
  v9 = malloc(v8);
  v5[5] = v9;
  Preferences.EnumPreference.wrappedValue.getter(a2, (uint64_t)v9);
  return sub_1000B8904;
}

void sub_1000B8904(uint64_t **a1, char a2)
{
  sub_1000B8910(a1, a2, (void (*)(void *, uint64_t))sub_1000BE518);
}

void sub_1000B8910(uint64_t **a1, char a2, void (*a3)(void *, uint64_t))
{
  uint64_t *v4;
  void *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void (*v10)(void *, uint64_t);

  v4 = *a1;
  v5 = (void *)(*a1)[4];
  v6 = (void *)(*a1)[5];
  v7 = (*a1)[2];
  v8 = (*a1)[3];
  v9 = **a1;
  if ((a2 & 1) != 0)
  {
    (*(void (**)(uint64_t, void *, uint64_t))(v8 + 16))((*a1)[4], v6, v7);
    a3(v5, v9);
    v10 = *(void (**)(void *, uint64_t))(v8 + 8);
    v10(v5, v7);
  }
  else
  {
    a3((void *)(*a1)[5], v9);
    v10 = *(void (**)(void *, uint64_t))(v8 + 8);
  }
  v10(v6, v7);
  free(v6);
  free(v5);
  free(v4);
}

Swift::Void __swiftcall Preferences.EnumPreference.reset()()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t AssociatedTypeWitness;
  uint64_t v6;

  v2 = v0;
  v3 = v1 + *(int *)(v0 + 52);
  v4 = *(_QWORD *)(v0 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(_QWORD *)(v0 + 40), *(_QWORD *)(v0 + 24), &protocol requirements base descriptor for RawRepresentable);
  v6 = type metadata accessor for Preferences.Preference(0, v4, AssociatedTypeWitness, *(_QWORD *)(v2 + 32));
  (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(v6 + 32) + 32))(*(unsigned __int8 *)(v3 + *(int *)(v6 + 44)), *(_QWORD *)(v6 + 16));
}

uint64_t Preferences.EnumPreference.description.getter(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t AssociatedTypeWitness;
  Swift::String v11;
  uint64_t v13;
  char v14;
  _QWORD v15[2];

  v3 = *(_QWORD *)(a1 + 24);
  v4 = *(_QWORD *)(v3 - 8);
  v5 = __chkstk_darwin();
  v7 = (char *)&v13 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15[0] = 0;
  v15[1] = 0xE000000000000000;
  v8 = v1 + *(int *)(v5 + 52);
  v9 = *(_QWORD *)(v5 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(_QWORD *)(v5 + 40), v3, &protocol requirements base descriptor for RawRepresentable);
  v14 = *(_BYTE *)(v8
                 + *(int *)(type metadata accessor for Preferences.Preference(0, v9, AssociatedTypeWitness, *(_QWORD *)(a1 + 32))+ 44));
  _print_unlocked<A, B>(_:_:)(&v14, v15, &type metadata for PreferencesName, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
  v11._countAndFlagsBits = 2112800;
  v11._object = (void *)0xE300000000000000;
  String.append(_:)(v11);
  Preferences.EnumPreference.wrappedValue.getter(a1, (uint64_t)v7);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v7, v3);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v7, v3);
  return v15[0];
}

uint64_t sub_1000B8B68@<X0>(char a1@<W1>, char a2@<W2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v10;
  char *v11;
  uint64_t v12;
  void (*v13)(char *);
  int *v14;
  uint64_t result;
  __int128 v16;

  __chkstk_darwin();
  v11 = (char *)&v16 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = *(void (**)(char *))(v12 + 32);
  v13(v11);
  v16 = xmmword_10033A100;
  ((void (*)(uint64_t, char *, uint64_t))v13)(a5, v11, a3);
  v14 = (int *)type metadata accessor for Preferences.Preference(0, a3, (uint64_t)&type metadata for Data, a4);
  *(_BYTE *)(a5 + v14[11]) = a1;
  result = (*(uint64_t (**)(uint64_t, __int128 *, _QWORD *))(*(&type metadata for Data - 1) + 32))(a5 + v14[12], &v16, &type metadata for Data);
  *(_BYTE *)(a5 + v14[13]) = a2;
  return result;
}

uint64_t Preferences.WiFiAddressPreference.wrappedValue.getter(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;
  uint64_t v4[2];

  v1 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Data, *(_QWORD *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)v4);
  v2 = sub_10000E38C(v4[0], v4[1]);
  return v2 & 0xFFFFFFFFFFFFLL | ((HIWORD(v2) & 1) << 48);
}

uint64_t Preferences.WiFiAddressPreference.wrappedValue.setter(unint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v17;
  _QWORD v18[2];

  if ((a1 & 0x1000000000000) != 0)
  {
    v17 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for Data, *(_QWORD *)(a2 + 24));
    return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(v17 + 32) + 32))(*(unsigned __int8 *)(v2 + *(int *)(v17 + 44)), *(_QWORD *)(v17 + 16));
  }
  else
  {
    v4 = a1;
    v5 = a1 >> 8;
    v6 = a1 >> 16;
    v7 = a1 >> 24;
    v8 = HIDWORD(a1);
    v9 = a1 >> 40;
    v10 = sub_100012C44(&qword_100403E88);
    v11 = swift_allocObject(v10, 38, 7);
    *(_OWORD *)(v11 + 16) = xmmword_10033B190;
    *(_BYTE *)(v11 + 32) = v4;
    *(_BYTE *)(v11 + 33) = v5;
    *(_BYTE *)(v11 + 34) = v6;
    *(_BYTE *)(v11 + 35) = v7;
    *(_BYTE *)(v11 + 36) = v8;
    *(_BYTE *)(v11 + 37) = v9;
    v12 = sub_1001068EC(v11);
    v14 = v13;
    swift_bridgeObjectRelease(v11);
    v18[0] = v12;
    v18[1] = v14;
    v15 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for Data, *(_QWORD *)(a2 + 24));
    sub_1000BE444((uint64_t)v18, v15);
    return sub_10000E614(v12, v14);
  }
}

uint64_t (*Preferences.WiFiAddressPreference.wrappedValue.modify(uint64_t *a1, uint64_t a2))(uint64_t a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;

  v3 = a1;
  *a1 = a2;
  a1[1] = v2;
  v4 = Preferences.WiFiAddressPreference.wrappedValue.getter(a2);
  *((_DWORD *)v3 + 4) = v4;
  v3 += 2;
  *((_WORD *)v3 + 2) = WORD2(v4);
  *((_BYTE *)v3 + 6) = BYTE6(v4) & 1;
  return sub_1000B8E18;
}

uint64_t sub_1000B8E18(uint64_t a1)
{
  return Preferences.WiFiAddressPreference.wrappedValue.setter((*(unsigned int *)(a1 + 16) | ((unint64_t)*(unsigned __int16 *)(a1 + 20) << 32)) & 0xFFFFFFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(a1 + 22) << 48), *(_QWORD *)a1);
}

Swift::Void __swiftcall Preferences.WiFiAddressPreference.reset()()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;

  v2 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(v0 + 16), (uint64_t)&type metadata for Data, *(_QWORD *)(v0 + 24));
  (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(v2 + 32) + 32))(*(unsigned __int8 *)(v1 + *(int *)(v2 + 44)), *(_QWORD *)(v2 + 16));
}

uint64_t Preferences.WiFiAddressPreference.description.getter(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  Swift::String v5;
  Swift::String v6;
  void *object;
  Swift::String v8;
  char v10;
  uint64_t v11;
  unint64_t v12;

  v3 = Preferences.WiFiAddressPreference.wrappedValue.getter(a1);
  if ((v3 & 0x1000000000000) != 0)
  {
    v11 = 0;
    v12 = 0xE000000000000000;
    v10 = *(_BYTE *)(v1
                   + *(int *)(type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Data, *(_QWORD *)(a1 + 24))+ 44));
    _print_unlocked<A, B>(_:_:)(&v10, &v11, &type metadata for PreferencesName, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    v8._countAndFlagsBits = 0x6F646E6172203D20;
    v8._object = (void *)0xE90000000000006DLL;
    String.append(_:)(v8);
  }
  else
  {
    v4 = v3;
    v11 = 0;
    v12 = 0xE000000000000000;
    v10 = *(_BYTE *)(v1
                   + *(int *)(type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Data, *(_QWORD *)(a1 + 24))+ 44));
    _print_unlocked<A, B>(_:_:)(&v10, &v11, &type metadata for PreferencesName, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    v5._countAndFlagsBits = 2112800;
    v5._object = (void *)0xE300000000000000;
    String.append(_:)(v5);
    v6._countAndFlagsBits = WiFiAddress.description.getter(v4 & 0xFFFFFFFFFFFFLL);
    object = v6._object;
    String.append(_:)(v6);
    swift_bridgeObjectRelease(object);
  }
  return v11;
}

uint64_t Preferences.automaticallyUseEncryption.getter(uint64_t a1)
{
  uint64_t v1;
  unsigned __int8 v3;

  v1 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.automaticallyUseEncryption.setter(char a1, uint64_t a2)
{
  uint64_t v2;
  char v4;

  v4 = a1;
  v2 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a2 + 24));
  return sub_1000BE444((uint64_t)&v4, v2);
}

uint64_t (*Preferences.automaticallyUseEncryption.modify(uint64_t *a1, uint64_t a2))()
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = (uint64_t)(a1 + 3);
  v4 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a2 + 24));
  *a1 = v4;
  v5 = *(_QWORD *)(v4 - 8);
  a1[1] = v5;
  a1[2] = (uint64_t)malloc(*(_QWORD *)(v5 + 64));
  (*(void (**)(void))(v5 + 16))();
  Preferences.Preference.wrappedValue.getter(v4, v3);
  return sub_1000B90C8;
}

uint64_t Preferences.$automaticallyUseEncryption.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v4;

  v4 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 - 8) + 16))(a2, v2, v4);
}

uint64_t Preferences.disableAuthentication.getter(uint64_t a1)
{
  uint64_t v1;
  unsigned __int8 v3;

  v1 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.disableAuthentication.setter(char a1, uint64_t a2)
{
  uint64_t v2;
  char v4;

  v4 = a1;
  v2 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a2 + 24));
  return sub_1000BE444((uint64_t)&v4, v2);
}

uint64_t (*Preferences.disableAuthentication.modify(uint64_t *a1, uint64_t a2))()
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = (uint64_t)(a1 + 3);
  v4 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a2 + 24));
  *a1 = v4;
  v5 = *(_QWORD *)(v4 - 8);
  a1[1] = v5;
  a1[2] = (uint64_t)malloc(*(_QWORD *)(v5 + 64));
  (*(void (**)(void))(v5 + 16))();
  Preferences.Preference.wrappedValue.getter(v4, v3);
  return sub_1000B90C8;
}

uint64_t Preferences.$disableAuthentication.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;

  v4 = v2 + *(int *)(a1 + 36);
  v5 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 16))(a2, v4, v5);
}

uint64_t Preferences.subscribeFilterEnabled.getter(uint64_t a1)
{
  uint64_t v1;
  unsigned __int8 v3;

  v1 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.subscribeFilterEnabled.setter(char a1, uint64_t a2)
{
  uint64_t v2;
  char v4;

  v4 = a1;
  v2 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a2 + 24));
  return sub_1000BE444((uint64_t)&v4, v2);
}

uint64_t (*Preferences.subscribeFilterEnabled.modify(uint64_t *a1, uint64_t a2))()
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = (uint64_t)(a1 + 3);
  v4 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a2 + 24));
  *a1 = v4;
  v5 = *(_QWORD *)(v4 - 8);
  a1[1] = v5;
  a1[2] = (uint64_t)malloc(*(_QWORD *)(v5 + 64));
  (*(void (**)(void))(v5 + 16))();
  Preferences.Preference.wrappedValue.getter(v4, v3);
  return sub_1000B90C8;
}

uint64_t Preferences.$subscribeFilterEnabled.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;

  v4 = v2 + *(int *)(a1 + 40);
  v5 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 16))(a2, v4, v5);
}

uint64_t Preferences.unsolicitedPublishOnUpdate.getter(uint64_t a1)
{
  uint64_t v1;
  unsigned __int8 v3;

  v1 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.unsolicitedPublishOnUpdate.setter(char a1, uint64_t a2)
{
  uint64_t v2;
  char v4;

  v4 = a1;
  v2 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a2 + 24));
  return sub_1000BE444((uint64_t)&v4, v2);
}

uint64_t (*Preferences.unsolicitedPublishOnUpdate.modify(uint64_t *a1, uint64_t a2))()
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = (uint64_t)(a1 + 3);
  v4 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a2 + 24));
  *a1 = v4;
  v5 = *(_QWORD *)(v4 - 8);
  a1[1] = v5;
  a1[2] = (uint64_t)malloc(*(_QWORD *)(v5 + 64));
  (*(void (**)(void))(v5 + 16))();
  Preferences.Preference.wrappedValue.getter(v4, v3);
  return sub_1000B90C8;
}

uint64_t Preferences.$unsolicitedPublishOnUpdate.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;

  v4 = v2 + *(int *)(a1 + 44);
  v5 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 16))(a2, v4, v5);
}

uint64_t Preferences.unsolicitedPublishSeconds.getter(uint64_t a1)
{
  uint64_t v1;
  unsigned int v3;

  v1 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for UInt32, *(_QWORD *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.unsolicitedPublishSeconds.setter(int a1, uint64_t a2)
{
  uint64_t v2;
  int v4;

  v4 = a1;
  v2 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for UInt32, *(_QWORD *)(a2 + 24));
  return sub_1000BE444((uint64_t)&v4, v2);
}

uint64_t (*Preferences.unsolicitedPublishSeconds.modify(_QWORD *a1, uint64_t a2))()
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;

  v4 = malloc(0x28uLL);
  *a1 = v4;
  v5 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for UInt32, *(_QWORD *)(a2 + 24));
  *v4 = v5;
  v6 = *(_QWORD *)(v5 - 8);
  v4[1] = v6;
  v4[2] = malloc(*(_QWORD *)(v6 + 64));
  (*(void (**)(void))(v6 + 16))();
  Preferences.Preference.wrappedValue.getter(v5, (uint64_t)(v4 + 3));
  return sub_1000B96F0;
}

uint64_t Preferences.$unsolicitedPublishSeconds.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;

  v4 = v2 + *(int *)(a1 + 48);
  v5 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for UInt32, *(_QWORD *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 16))(a2, v4, v5);
}

uint64_t Preferences.internetSharingOptions.getter(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD v4[4];

  v1 = *(_QWORD *)(a1 + 24);
  v4[0] = *(_QWORD *)(a1 + 16);
  v4[1] = &type metadata for PreferenceDefaults.InternetSharingOptions;
  v4[2] = v1;
  v4[3] = sub_1000BE600();
  v2 = type metadata accessor for Preferences.EnumPreference(0, (uint64_t)v4);
  Preferences.EnumPreference.wrappedValue.getter(v2, (uint64_t)v4);
  return LOBYTE(v4[0]);
}

uint64_t Preferences.internetSharingOptions.setter(char a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t *v3;
  _QWORD v5[4];
  char v6;

  v6 = a1;
  v2 = *(_QWORD *)(a2 + 24);
  v5[0] = *(_QWORD *)(a2 + 16);
  v5[1] = &type metadata for PreferenceDefaults.InternetSharingOptions;
  v5[2] = v2;
  v5[3] = sub_1000BE600();
  v3 = (uint64_t *)type metadata accessor for Preferences.EnumPreference(0, (uint64_t)v5);
  return sub_1000BE518((uint64_t)&v6, v3);
}

void (*Preferences.internetSharingOptions.modify(_QWORD *a1, uint64_t a2))(uint64_t a1, char a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v4 = malloc(0x40uLL);
  *a1 = v4;
  v5 = *(_QWORD *)(a2 + 16);
  v6 = *(_QWORD *)(a2 + 24);
  v7 = sub_1000BE600();
  *v4 = v5;
  v4[1] = &type metadata for PreferenceDefaults.InternetSharingOptions;
  v4[2] = v6;
  v4[3] = v7;
  v8 = type metadata accessor for Preferences.EnumPreference(0, (uint64_t)v4);
  v4[4] = v8;
  v9 = *(_QWORD *)(v8 - 8);
  v4[5] = v9;
  v4[6] = malloc(*(_QWORD *)(v9 + 64));
  (*(void (**)(void))(v9 + 16))();
  Preferences.EnumPreference.wrappedValue.getter(v8, (uint64_t)(v4 + 7));
  return sub_1000B98C4;
}

void sub_1000B98C4(uint64_t a1, char a2)
{
  _BYTE *v2;
  char v3;
  void *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v2 = *(_BYTE **)a1;
  v3 = *(_BYTE *)(*(_QWORD *)a1 + 56);
  v5 = *(_QWORD *)(*(_QWORD *)a1 + 40);
  v4 = *(void **)(*(_QWORD *)a1 + 48);
  v6 = *(uint64_t **)(*(_QWORD *)a1 + 32);
  v7 = 57;
  if ((a2 & 1) != 0)
  {
    v8 = *(_QWORD *)a1 + 57;
  }
  else
  {
    v7 = 58;
    v8 = *(_QWORD *)a1 + 58;
  }
  v2[v7] = v3;
  sub_1000BE518(v8, v6);
  (*(void (**)(void *, uint64_t *))(v5 + 8))(v4, v6);
  free(v4);
  free(v2);
}

uint64_t Preferences.$internetSharingOptions.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v8[4];

  v4 = v2 + *(int *)(a1 + 52);
  v5 = *(_QWORD *)(a1 + 24);
  v8[0] = *(_QWORD *)(a1 + 16);
  v8[1] = &type metadata for PreferenceDefaults.InternetSharingOptions;
  v8[2] = v5;
  v8[3] = sub_1000BE600();
  v6 = type metadata accessor for Preferences.EnumPreference(0, (uint64_t)v8);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v6 - 8) + 16))(a2, v4, v6);
}

uint64_t Preferences.createNetworkAgent.getter(uint64_t a1)
{
  uint64_t v1;
  unsigned __int8 v3;

  v1 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.createNetworkAgent.setter(char a1, uint64_t a2)
{
  uint64_t v2;
  char v4;

  v4 = a1;
  v2 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a2 + 24));
  return sub_1000BE444((uint64_t)&v4, v2);
}

uint64_t (*Preferences.createNetworkAgent.modify(uint64_t *a1, uint64_t a2))()
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = (uint64_t)(a1 + 3);
  v4 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a2 + 24));
  *a1 = v4;
  v5 = *(_QWORD *)(v4 - 8);
  a1[1] = v5;
  a1[2] = (uint64_t)malloc(*(_QWORD *)(v5 + 64));
  (*(void (**)(void))(v5 + 16))();
  Preferences.Preference.wrappedValue.getter(v4, v3);
  return sub_1000B90C8;
}

uint64_t Preferences.$createNetworkAgent.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;

  v4 = v2 + *(int *)(a1 + 56);
  v5 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 16))(a2, v4, v5);
}

uint64_t Preferences.edgeKitSupport.getter(uint64_t a1)
{
  uint64_t v1;
  unsigned __int8 v3;

  v1 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.edgeKitSupport.setter(char a1, uint64_t a2)
{
  uint64_t v2;
  char v4;

  v4 = a1;
  v2 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a2 + 24));
  return sub_1000BE444((uint64_t)&v4, v2);
}

uint64_t (*Preferences.edgeKitSupport.modify(uint64_t *a1, uint64_t a2))()
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = (uint64_t)(a1 + 3);
  v4 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a2 + 24));
  *a1 = v4;
  v5 = *(_QWORD *)(v4 - 8);
  a1[1] = v5;
  a1[2] = (uint64_t)malloc(*(_QWORD *)(v5 + 64));
  (*(void (**)(void))(v5 + 16))();
  Preferences.Preference.wrappedValue.getter(v4, v3);
  return sub_1000B90C8;
}

uint64_t Preferences.$edgeKitSupport.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;

  v4 = v2 + *(int *)(a1 + 60);
  v5 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 16))(a2, v4, v5);
}

uint64_t Preferences.linkTestIntervalMinutes.getter(uint64_t a1)
{
  uint64_t v1;
  unsigned int v3;

  v1 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for UInt32, *(_QWORD *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.linkTestIntervalMinutes.setter(int a1, uint64_t a2)
{
  uint64_t v2;
  int v4;

  v4 = a1;
  v2 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for UInt32, *(_QWORD *)(a2 + 24));
  return sub_1000BE444((uint64_t)&v4, v2);
}

uint64_t (*Preferences.linkTestIntervalMinutes.modify(_QWORD *a1, uint64_t a2))()
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;

  v4 = malloc(0x28uLL);
  *a1 = v4;
  v5 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for UInt32, *(_QWORD *)(a2 + 24));
  *v4 = v5;
  v6 = *(_QWORD *)(v5 - 8);
  v4[1] = v6;
  v4[2] = malloc(*(_QWORD *)(v6 + 64));
  (*(void (**)(void))(v6 + 16))();
  Preferences.Preference.wrappedValue.getter(v5, (uint64_t)(v4 + 3));
  return sub_1000B96F0;
}

void sub_1000B9DFC(uint64_t **a1, char a2)
{
  uint64_t *v2;
  int v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = *a1;
  v3 = *((_DWORD *)*a1 + 6);
  v5 = (*a1)[1];
  v4 = (void *)(*a1)[2];
  v6 = **a1;
  v7 = 32;
  if ((a2 & 1) != 0)
  {
    v7 = 28;
    v8 = (uint64_t)*a1 + 28;
  }
  else
  {
    v8 = (uint64_t)(*a1 + 4);
  }
  *(_DWORD *)((char *)v2 + v7) = v3;
  sub_1000BE444(v8, v6);
  (*(void (**)(void *, uint64_t))(v5 + 8))(v4, v6);
  free(v4);
  free(v2);
}

uint64_t Preferences.$linkTestIntervalMinutes.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;

  v4 = v2 + *(int *)(a1 + 64);
  v5 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for UInt32, *(_QWORD *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 16))(a2, v4, v5);
}

uint64_t Preferences.disableAWDLLinkWhenInactive.getter(uint64_t a1)
{
  uint64_t v1;
  unsigned __int8 v3;

  v1 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.disableAWDLLinkWhenInactive.setter(char a1, uint64_t a2)
{
  uint64_t v2;
  char v4;

  v4 = a1;
  v2 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a2 + 24));
  return sub_1000BE444((uint64_t)&v4, v2);
}

uint64_t (*Preferences.disableAWDLLinkWhenInactive.modify(uint64_t *a1, uint64_t a2))()
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = (uint64_t)(a1 + 3);
  v4 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a2 + 24));
  *a1 = v4;
  v5 = *(_QWORD *)(v4 - 8);
  a1[1] = v5;
  a1[2] = (uint64_t)malloc(*(_QWORD *)(v5 + 64));
  (*(void (**)(void))(v5 + 16))();
  Preferences.Preference.wrappedValue.getter(v4, v3);
  return sub_1000B90C8;
}

uint64_t Preferences.$disableAWDLLinkWhenInactive.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;

  v4 = v2 + *(int *)(a1 + 68);
  v5 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 16))(a2, v4, v5);
}

uint64_t Preferences.disableMulticastRateAdapter.getter(uint64_t a1)
{
  uint64_t v1;
  unsigned __int8 v3;

  v1 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.disableMulticastRateAdapter.setter(char a1, uint64_t a2)
{
  uint64_t v2;
  char v4;

  v4 = a1;
  v2 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a2 + 24));
  return sub_1000BE444((uint64_t)&v4, v2);
}

uint64_t (*Preferences.disableMulticastRateAdapter.modify(uint64_t *a1, uint64_t a2))()
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = (uint64_t)(a1 + 3);
  v4 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a2 + 24));
  *a1 = v4;
  v5 = *(_QWORD *)(v4 - 8);
  a1[1] = v5;
  a1[2] = (uint64_t)malloc(*(_QWORD *)(v5 + 64));
  (*(void (**)(void))(v5 + 16))();
  Preferences.Preference.wrappedValue.getter(v4, v3);
  return sub_1000B90C8;
}

uint64_t Preferences.$disableMulticastRateAdapter.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;

  v4 = v2 + *(int *)(a1 + 72);
  v5 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 16))(a2, v4, v5);
}

double Preferences.multicastRateAdapterSettlingPER.getter(uint64_t a1)
{
  uint64_t v1;
  double v3;

  v1 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Double, *(_QWORD *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.multicastRateAdapterSettlingPER.setter(uint64_t a1, double a2)
{
  uint64_t v2;
  double v4;

  v4 = a2;
  v2 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Double, *(_QWORD *)(a1 + 24));
  return sub_1000BE444((uint64_t)&v4, v2);
}

uint64_t (*Preferences.multicastRateAdapterSettlingPER.modify(_QWORD *a1, uint64_t a2))()
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;

  v4 = malloc(0x30uLL);
  *a1 = v4;
  v5 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for Double, *(_QWORD *)(a2 + 24));
  v4[3] = v5;
  v6 = *(_QWORD *)(v5 - 8);
  v4[4] = v6;
  v4[5] = malloc(*(_QWORD *)(v6 + 64));
  (*(void (**)(void))(v6 + 16))();
  Preferences.Preference.wrappedValue.getter(v5, (uint64_t)v4);
  return sub_1000BA304;
}

uint64_t Preferences.$multicastRateAdapterSettlingPER.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;

  v4 = v2 + *(int *)(a1 + 76);
  v5 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Double, *(_QWORD *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 16))(a2, v4, v5);
}

double Preferences.multicastRateAdapterInitialFeedbackInterval.getter(uint64_t a1)
{
  uint64_t v1;
  double v3;

  v1 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Double, *(_QWORD *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.multicastRateAdapterInitialFeedbackInterval.setter(uint64_t a1, double a2)
{
  uint64_t v2;
  double v4;

  v4 = a2;
  v2 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Double, *(_QWORD *)(a1 + 24));
  return sub_1000BE444((uint64_t)&v4, v2);
}

uint64_t (*Preferences.multicastRateAdapterInitialFeedbackInterval.modify(_QWORD *a1, uint64_t a2))()
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;

  v4 = malloc(0x30uLL);
  *a1 = v4;
  v5 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for Double, *(_QWORD *)(a2 + 24));
  v4[3] = v5;
  v6 = *(_QWORD *)(v5 - 8);
  v4[4] = v6;
  v4[5] = malloc(*(_QWORD *)(v6 + 64));
  (*(void (**)(void))(v6 + 16))();
  Preferences.Preference.wrappedValue.getter(v5, (uint64_t)v4);
  return sub_1000BA304;
}

void sub_1000BA48C(uint64_t **a1, char a2)
{
  uint64_t *v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = *a1;
  v3 = **a1;
  v5 = (*a1)[4];
  v4 = (void *)(*a1)[5];
  v6 = (*a1)[3];
  v7 = 2;
  if ((a2 & 1) != 0)
  {
    v7 = 1;
    v8 = (uint64_t)(*a1 + 1);
  }
  else
  {
    v8 = (uint64_t)(*a1 + 2);
  }
  v2[v7] = v3;
  sub_1000BE444(v8, v6);
  (*(void (**)(void *, uint64_t))(v5 + 8))(v4, v6);
  free(v4);
  free(v2);
}

uint64_t Preferences.$multicastRateAdapterInitialFeedbackInterval.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;

  v4 = v2 + *(int *)(a1 + 80);
  v5 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Double, *(_QWORD *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 16))(a2, v4, v5);
}

uint64_t Preferences.awdl.getter(uint64_t a1)
{
  uint64_t v1;
  unsigned __int8 v3;

  v1 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.awdl.setter(char a1, uint64_t a2)
{
  uint64_t v2;
  char v4;

  v4 = a1;
  v2 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a2 + 24));
  return sub_1000BE444((uint64_t)&v4, v2);
}

uint64_t (*Preferences.awdl.modify(uint64_t *a1, uint64_t a2))()
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = (uint64_t)(a1 + 3);
  v4 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a2 + 24));
  *a1 = v4;
  v5 = *(_QWORD *)(v4 - 8);
  a1[1] = v5;
  a1[2] = (uint64_t)malloc(*(_QWORD *)(v5 + 64));
  (*(void (**)(void))(v5 + 16))();
  Preferences.Preference.wrappedValue.getter(v4, v3);
  return sub_1000B90C8;
}

uint64_t Preferences.$awdl.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;

  v4 = v2 + *(int *)(a1 + 84);
  v5 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 16))(a2, v4, v5);
}

uint64_t Preferences.awdlMACAddress.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  unint64_t v5;

  v4 = type metadata accessor for Preferences.WiFiAddressPreference(0, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), a4);
  v5 = Preferences.WiFiAddressPreference.wrappedValue.getter(v4);
  return v5 & 0xFFFFFFFFFFFFLL | ((HIWORD(v5) & 1) << 48);
}

uint64_t Preferences.awdlMACAddress.setter(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;

  v5 = type metadata accessor for Preferences.WiFiAddressPreference(0, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), a4);
  return Preferences.WiFiAddressPreference.wrappedValue.setter(a1 & 0xFFFFFFFFFFFFLL | ((HIWORD(a1) & 1) << 48), v5);
}

uint64_t (*Preferences.awdlMACAddress.modify(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4))()
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v5 = type metadata accessor for Preferences.WiFiAddressPreference(0, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), a4);
  *(_QWORD *)a1 = v5;
  v6 = *(_QWORD *)(v5 - 8);
  *(_QWORD *)(a1 + 8) = v6;
  *(_QWORD *)(a1 + 16) = malloc(*(_QWORD *)(v6 + 64));
  (*(void (**)(void))(v6 + 16))();
  v7 = Preferences.WiFiAddressPreference.wrappedValue.getter(v5);
  *(_DWORD *)(a1 + 24) = v7;
  a1 += 24;
  *(_WORD *)(a1 + 4) = WORD2(v7);
  *(_BYTE *)(a1 + 6) = BYTE6(v7) & 1;
  return sub_1000BA808;
}

uint64_t Preferences.$awdlMACAddress.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;

  v5 = v3 + *(int *)(a1 + 88);
  v6 = type metadata accessor for Preferences.WiFiAddressPreference(0, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), a2);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v6 - 8) + 16))(a3, v5, v6);
}

uint64_t Preferences.nan.getter(uint64_t a1)
{
  uint64_t v1;
  unsigned __int8 v3;

  v1 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.nan.setter(char a1, uint64_t a2)
{
  uint64_t v2;
  char v4;

  v4 = a1;
  v2 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a2 + 24));
  return sub_1000BE444((uint64_t)&v4, v2);
}

uint64_t (*Preferences.nan.modify(uint64_t *a1, uint64_t a2))()
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = (uint64_t)(a1 + 3);
  v4 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a2 + 24));
  *a1 = v4;
  v5 = *(_QWORD *)(v4 - 8);
  a1[1] = v5;
  a1[2] = (uint64_t)malloc(*(_QWORD *)(v5 + 64));
  (*(void (**)(void))(v5 + 16))();
  Preferences.Preference.wrappedValue.getter(v4, v3);
  return sub_1000B90C8;
}

uint64_t Preferences.$nan.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;

  v4 = v2 + *(int *)(a1 + 92);
  v5 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 16))(a2, v4, v5);
}

uint64_t Preferences.nanMACAddress.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  unint64_t v5;

  v4 = type metadata accessor for Preferences.WiFiAddressPreference(0, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), a4);
  v5 = Preferences.WiFiAddressPreference.wrappedValue.getter(v4);
  return v5 & 0xFFFFFFFFFFFFLL | ((HIWORD(v5) & 1) << 48);
}

uint64_t Preferences.nanMACAddress.setter(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;

  v5 = type metadata accessor for Preferences.WiFiAddressPreference(0, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), a4);
  return Preferences.WiFiAddressPreference.wrappedValue.setter(a1 & 0xFFFFFFFFFFFFLL | ((HIWORD(a1) & 1) << 48), v5);
}

uint64_t (*Preferences.nanMACAddress.modify(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4))()
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v5 = type metadata accessor for Preferences.WiFiAddressPreference(0, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), a4);
  *(_QWORD *)a1 = v5;
  v6 = *(_QWORD *)(v5 - 8);
  *(_QWORD *)(a1 + 8) = v6;
  *(_QWORD *)(a1 + 16) = malloc(*(_QWORD *)(v6 + 64));
  (*(void (**)(void))(v6 + 16))();
  v7 = Preferences.WiFiAddressPreference.wrappedValue.getter(v5);
  *(_DWORD *)(a1 + 24) = v7;
  a1 += 24;
  *(_WORD *)(a1 + 4) = WORD2(v7);
  *(_BYTE *)(a1 + 6) = BYTE6(v7) & 1;
  return sub_1000BA808;
}

uint64_t Preferences.$nanMACAddress.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;

  v5 = v3 + *(int *)(a1 + 96);
  v6 = type metadata accessor for Preferences.WiFiAddressPreference(0, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), a2);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v6 - 8) + 16))(a3, v5, v6);
}

uint64_t Preferences.nanDataMACAddress.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  unint64_t v5;

  v4 = type metadata accessor for Preferences.WiFiAddressPreference(0, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), a4);
  v5 = Preferences.WiFiAddressPreference.wrappedValue.getter(v4);
  return v5 & 0xFFFFFFFFFFFFLL | ((HIWORD(v5) & 1) << 48);
}

uint64_t Preferences.nanDataMACAddress.setter(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;

  v5 = type metadata accessor for Preferences.WiFiAddressPreference(0, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), a4);
  return Preferences.WiFiAddressPreference.wrappedValue.setter(a1 & 0xFFFFFFFFFFFFLL | ((HIWORD(a1) & 1) << 48), v5);
}

uint64_t (*Preferences.nanDataMACAddress.modify(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4))()
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v5 = type metadata accessor for Preferences.WiFiAddressPreference(0, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), a4);
  *(_QWORD *)a1 = v5;
  v6 = *(_QWORD *)(v5 - 8);
  *(_QWORD *)(a1 + 8) = v6;
  *(_QWORD *)(a1 + 16) = malloc(*(_QWORD *)(v6 + 64));
  (*(void (**)(void))(v6 + 16))();
  v7 = Preferences.WiFiAddressPreference.wrappedValue.getter(v5);
  *(_DWORD *)(a1 + 24) = v7;
  a1 += 24;
  *(_WORD *)(a1 + 4) = WORD2(v7);
  *(_BYTE *)(a1 + 6) = BYTE6(v7) & 1;
  return sub_1000BA808;
}

void sub_1000BAC84(uint64_t a1)
{
  void *v1;
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 8);
  v1 = *(void **)(a1 + 16);
  v3 = *(_QWORD *)a1;
  Preferences.WiFiAddressPreference.wrappedValue.setter((*(unsigned int *)(a1 + 24) | ((unint64_t)*(unsigned __int16 *)(a1 + 28) << 32)) & 0xFFFFFFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(a1 + 30) << 48), *(_QWORD *)a1);
  (*(void (**)(void *, uint64_t))(v2 + 8))(v1, v3);
  free(v1);
}

uint64_t Preferences.$nanDataMACAddress.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;

  v5 = v3 + *(int *)(a1 + 100);
  v6 = type metadata accessor for Preferences.WiFiAddressPreference(0, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), a2);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v6 - 8) + 16))(a3, v5, v6);
}

uint64_t Preferences.enableUserspaceP2POptions.getter(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD v4[4];

  v1 = *(_QWORD *)(a1 + 24);
  v4[0] = *(_QWORD *)(a1 + 16);
  v4[1] = &type metadata for PreferenceDefaults.EnableUserspaceP2POptions;
  v4[2] = v1;
  v4[3] = sub_1000BE65C();
  v2 = type metadata accessor for Preferences.EnumPreference(0, (uint64_t)v4);
  Preferences.EnumPreference.wrappedValue.getter(v2, (uint64_t)v4);
  return v4[0];
}

uint64_t Preferences.enableUserspaceP2POptions.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t *v3;
  _QWORD v5[4];
  uint64_t v6;

  v6 = a1;
  v2 = *(_QWORD *)(a2 + 24);
  v5[0] = *(_QWORD *)(a2 + 16);
  v5[1] = &type metadata for PreferenceDefaults.EnableUserspaceP2POptions;
  v5[2] = v2;
  v5[3] = sub_1000BE65C();
  v3 = (uint64_t *)type metadata accessor for Preferences.EnumPreference(0, (uint64_t)v5);
  return sub_1000BE518((uint64_t)&v6, v3);
}

void (*Preferences.enableUserspaceP2POptions.modify(_QWORD *a1, uint64_t a2))(char **a1, char a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v4 = malloc(0x50uLL);
  *a1 = v4;
  v5 = *(_QWORD *)(a2 + 16);
  v6 = *(_QWORD *)(a2 + 24);
  v7 = sub_1000BE65C();
  *v4 = v5;
  v4[1] = &type metadata for PreferenceDefaults.EnableUserspaceP2POptions;
  v4[2] = v6;
  v4[3] = v7;
  v8 = type metadata accessor for Preferences.EnumPreference(0, (uint64_t)v4);
  v4[7] = v8;
  v9 = *(_QWORD *)(v8 - 8);
  v4[8] = v9;
  v4[9] = malloc(*(_QWORD *)(v9 + 64));
  (*(void (**)(void))(v9 + 16))();
  Preferences.EnumPreference.wrappedValue.getter(v8, (uint64_t)(v4 + 4));
  return sub_1000BAEB0;
}

void sub_1000BAEB0(char **a1, char a2)
{
  char *v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v2 = *a1;
  v3 = *((_QWORD *)*a1 + 4);
  v5 = *((_QWORD *)*a1 + 8);
  v4 = (void *)*((_QWORD *)*a1 + 9);
  v6 = (uint64_t *)*((_QWORD *)*a1 + 7);
  v7 = 48;
  if ((a2 & 1) != 0)
  {
    v7 = 40;
    v8 = (uint64_t)(*a1 + 40);
  }
  else
  {
    v8 = (uint64_t)(*a1 + 48);
  }
  *(_QWORD *)&v2[v7] = v3;
  sub_1000BE518(v8, v6);
  (*(void (**)(void *, uint64_t *))(v5 + 8))(v4, v6);
  free(v4);
  free(v2);
}

uint64_t Preferences.$enableUserspaceP2POptions.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v8[4];

  v4 = v2 + *(int *)(a1 + 104);
  v5 = *(_QWORD *)(a1 + 24);
  v8[0] = *(_QWORD *)(a1 + 16);
  v8[1] = &type metadata for PreferenceDefaults.EnableUserspaceP2POptions;
  v8[2] = v5;
  v8[3] = sub_1000BE65C();
  v6 = type metadata accessor for Preferences.EnumPreference(0, (uint64_t)v8);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v6 - 8) + 16))(a2, v4, v6);
}

uint64_t Preferences.reportSoftErrorsWithTTR.getter(uint64_t a1)
{
  uint64_t v1;
  unsigned __int8 v3;

  v1 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.reportSoftErrorsWithTTR.setter(char a1, uint64_t a2)
{
  uint64_t v2;
  char v4;

  v4 = a1;
  v2 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a2 + 24));
  return sub_1000BE444((uint64_t)&v4, v2);
}

uint64_t (*Preferences.reportSoftErrorsWithTTR.modify(uint64_t *a1, uint64_t a2))()
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = (uint64_t)(a1 + 3);
  v4 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a2 + 24));
  *a1 = v4;
  v5 = *(_QWORD *)(v4 - 8);
  a1[1] = v5;
  a1[2] = (uint64_t)malloc(*(_QWORD *)(v5 + 64));
  (*(void (**)(void))(v5 + 16))();
  Preferences.Preference.wrappedValue.getter(v4, v3);
  return sub_1000B90C8;
}

uint64_t Preferences.$reportSoftErrorsWithTTR.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;

  v4 = v2 + *(int *)(a1 + 108);
  v5 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 16))(a2, v4, v5);
}

uint64_t Preferences.disableWiFiDisconnectRemoteCamera.getter(uint64_t a1)
{
  uint64_t v1;
  unsigned __int8 v3;

  v1 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.disableWiFiDisconnectRemoteCamera.setter(char a1, uint64_t a2)
{
  uint64_t v2;
  char v4;

  v4 = a1;
  v2 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a2 + 24));
  return sub_1000BE444((uint64_t)&v4, v2);
}

uint64_t (*Preferences.disableWiFiDisconnectRemoteCamera.modify(uint64_t *a1, uint64_t a2))()
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = (uint64_t)(a1 + 3);
  v4 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a2 + 24));
  *a1 = v4;
  v5 = *(_QWORD *)(v4 - 8);
  a1[1] = v5;
  a1[2] = (uint64_t)malloc(*(_QWORD *)(v5 + 64));
  (*(void (**)(void))(v5 + 16))();
  Preferences.Preference.wrappedValue.getter(v4, v3);
  return sub_1000B90C8;
}

uint64_t Preferences.$disableWiFiDisconnectRemoteCamera.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;

  v4 = v2 + *(int *)(a1 + 112);
  v5 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 16))(a2, v4, v5);
}

uint64_t Preferences.allowOnenessWombatCoex.getter(uint64_t a1)
{
  uint64_t v1;
  unsigned __int8 v3;

  v1 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a1 + 24));
  Preferences.Preference.wrappedValue.getter(v1, (uint64_t)&v3);
  return v3;
}

uint64_t Preferences.allowOnenessWombatCoex.setter(char a1, uint64_t a2)
{
  uint64_t v2;
  char v4;

  v4 = a1;
  v2 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a2 + 24));
  return sub_1000BE444((uint64_t)&v4, v2);
}

uint64_t (*Preferences.allowOnenessWombatCoex.modify(uint64_t *a1, uint64_t a2))()
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = (uint64_t)(a1 + 3);
  v4 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a2 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a2 + 24));
  *a1 = v4;
  v5 = *(_QWORD *)(v4 - 8);
  a1[1] = v5;
  a1[2] = (uint64_t)malloc(*(_QWORD *)(v5 + 64));
  (*(void (**)(void))(v5 + 16))();
  Preferences.Preference.wrappedValue.getter(v4, v3);
  return sub_1000B90C8;
}

void sub_1000BB3E0(uint64_t a1, char a2)
{
  char v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v2 = *(_BYTE *)(a1 + 24);
  v4 = *(_QWORD *)(a1 + 8);
  v3 = *(void **)(a1 + 16);
  v5 = *(_QWORD *)a1;
  if ((a2 & 1) != 0)
  {
    *(_BYTE *)(a1 + 25) = v2;
    v6 = a1 + 25;
  }
  else
  {
    *(_BYTE *)(a1 + 26) = v2;
    v6 = a1 + 26;
  }
  sub_1000BE444(v6, v5);
  (*(void (**)(void *, uint64_t))(v4 + 8))(v3, v5);
  free(v3);
}

uint64_t Preferences.$allowOnenessWombatCoex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;

  v4 = v2 + *(int *)(a1 + 116);
  v5 = type metadata accessor for Preferences.Preference(0, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Bool, *(_QWORD *)(a1 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 16))(a2, v4, v5);
}

uint64_t Preferences.init(storage:)@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  char *v8;
  char *v9;
  char *v10;
  char v11;
  void (*v12)(uint64_t, char *, uint64_t);
  uint64_t v13;
  int *v14;
  void (*v15)(uint64_t, uint64_t *, _QWORD *);
  void (*v16)(char *, uint64_t, uint64_t);
  uint64_t v17;
  int *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int *v25;
  uint64_t v26;
  int *v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  int *v31;
  uint64_t v32;
  void (*v33)(char *, uint64_t, uint64_t);
  void (*v34)(uint64_t, char *, uint64_t);
  void (*v35)(uint64_t, uint64_t *, _QWORD *);
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int *v39;
  uint64_t v40;
  void (*v41)(char *);
  uint64_t v42;
  void (*v43)(uint64_t, char *, uint64_t);
  void (*v44)(uint64_t, uint64_t *, _QWORD *);
  void (*v45)(char *, uint64_t, uint64_t);
  int *v46;
  uint64_t v47;
  uint64_t v48;
  void (*v49)(char *, uint64_t, uint64_t);
  int *v50;
  uint64_t v51;
  unint64_t v52;
  char *v53;
  uint64_t v54;
  int *v55;
  uint64_t v56;
  void (*v57)(uint64_t, char *, uint64_t);
  uint64_t v58;
  void (*v59)(uint64_t, uint64_t *, _QWORD *);
  void (*v60)(char *);
  uint64_t v61;
  uint64_t v62;
  void (*v63)(char *, uint64_t, uint64_t);
  int *v64;
  uint64_t v65;
  void (*v66)(uint64_t, uint64_t *, _QWORD *);
  char *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  int *v71;
  void (*v72)(uint64_t, uint64_t *, _QWORD *);
  uint64_t v73;
  uint64_t result;
  uint64_t v75;
  char *v76;
  void (*v77)(uint64_t, uint64_t *, _QWORD *);
  uint64_t v78;
  void (*v79)(uint64_t, char *, uint64_t);
  uint64_t v80;
  int *v81;
  void (*v82)(char *);
  void (*v83)(uint64_t, uint64_t *, _QWORD *);
  uint64_t v84;

  v6 = *(_QWORD *)(a1 - 8);
  __chkstk_darwin();
  v8 = (char *)&v75 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  v10 = v9;
  v82 = *(void (**)(char *))(v6 + 16);
  v82(v8);
  LOBYTE(v84) = 1;
  if (qword_100403F18 != -1)
    swift_once(&qword_100403F18, sub_1000B7BE8);
  v11 = static PreferenceDefaults.isAppleInternal;
  LODWORD(v77) = static PreferenceDefaults.isAppleInternal;
  v12 = *(void (**)(uint64_t, char *, uint64_t))(v6 + 32);
  v12(a3, v8, a1);
  v13 = type metadata accessor for Preferences.Preference(0, a1, (uint64_t)&type metadata for Bool, a2);
  v80 = a2;
  v14 = (int *)v13;
  *(_BYTE *)(a3 + *(int *)(v13 + 44)) = 0;
  v15 = *(void (**)(uint64_t, uint64_t *, _QWORD *))(*(&type metadata for Bool - 1) + 32);
  v15(a3 + *(int *)(v13 + 48), &v84, &type metadata for Bool);
  *(_BYTE *)(a3 + v14[13]) = v11;
  v16 = (void (*)(char *, uint64_t, uint64_t))v82;
  ((void (*)(char *, char *, uint64_t))v82)(v8, v10, a1);
  LOBYTE(v84) = 0;
  v18 = (int *)type metadata accessor for Preferences(0, a1, a2, v17);
  v19 = a3 + v18[9];
  v12(v19, v8, a1);
  *(_BYTE *)(v19 + v14[11]) = 1;
  v15(v19 + v14[12], &v84, &type metadata for Bool);
  *(_BYTE *)(v19 + v14[13]) = (_BYTE)v77;
  v16(v8, (uint64_t)v10, a1);
  LOBYTE(v84) = 1;
  v20 = a3 + v18[10];
  v12(v20, v8, a1);
  *(_BYTE *)(v20 + v14[11]) = 2;
  v15(v20 + v14[12], &v84, &type metadata for Bool);
  v83 = v15;
  *(_BYTE *)(v20 + v14[13]) = 1;
  v16(v8, (uint64_t)v10, a1);
  LOBYTE(v84) = 1;
  v21 = v18[11];
  v81 = v18;
  v22 = a3 + v21;
  v12(a3 + v21, v8, a1);
  v79 = v12;
  *(_BYTE *)(v22 + v14[11]) = 3;
  v15(v22 + v14[12], &v84, &type metadata for Bool);
  *(_BYTE *)(v22 + v14[13]) = 1;
  v16(v8, (uint64_t)v10, a1);
  LODWORD(v84) = 4;
  v23 = a3 + v18[12];
  v12(v23, v8, a1);
  v24 = v80;
  v25 = (int *)type metadata accessor for Preferences.Preference(0, a1, (uint64_t)&type metadata for UInt32, v80);
  *(_BYTE *)(v23 + v25[11]) = 4;
  v26 = v23 + v25[12];
  v77 = *(void (**)(uint64_t, uint64_t *, _QWORD *))(*(&type metadata for UInt32 - 1) + 32);
  v77(v26, &v84, &type metadata for UInt32);
  *(_BYTE *)(v23 + v25[13]) = 1;
  v16(v8, (uint64_t)v10, a1);
  LOBYTE(v84) = 2;
  v27 = v81;
  v28 = a3 + v81[13];
  v29 = sub_1000BE600();
  sub_1000B84C4((uint64_t)v8, 5, (uint64_t)&v84, 1, a1, (uint64_t)&type metadata for PreferenceDefaults.InternetSharingOptions, v24, v29, v28);
  v16(v8, (uint64_t)v10, a1);
  LOBYTE(v84) = 0;
  v30 = a3;
  v78 = a3;
  v31 = v27;
  v32 = v30 + v27[14];
  v33 = v16;
  v34 = v79;
  v79(v32, v8, a1);
  *(_BYTE *)(v32 + v14[11]) = 6;
  v35 = v83;
  v83(v32 + v14[12], &v84, &type metadata for Bool);
  *(_BYTE *)(v32 + v14[13]) = 1;
  v33(v8, (uint64_t)v10, a1);
  LOBYTE(v84) = 0;
  v36 = v31[15];
  v37 = v78;
  v38 = v78 + v36;
  v34(v78 + v36, v8, a1);
  *(_BYTE *)(v38 + v14[11]) = 13;
  v35(v38 + v14[12], &v84, &type metadata for Bool);
  *(_BYTE *)(v38 + v14[13]) = 1;
  v33(v8, (uint64_t)v10, a1);
  LODWORD(v84) = 60;
  v39 = v81;
  v40 = v37 + v81[16];
  v34(v40, v8, a1);
  *(_BYTE *)(v40 + v25[11]) = 14;
  v77(v40 + v25[12], &v84, &type metadata for UInt32);
  *(_BYTE *)(v40 + v25[13]) = 1;
  v41 = v82;
  ((void (*)(char *, char *, uint64_t))v82)(v8, v10, a1);
  LOBYTE(v84) = 1;
  v42 = v37 + v39[21];
  v34(v42, v8, a1);
  v43 = v34;
  *(_BYTE *)(v42 + v14[11]) = 7;
  v44 = v83;
  v83(v42 + v14[12], &v84, &type metadata for Bool);
  *(_BYTE *)(v42 + v14[13]) = 1;
  v45 = (void (*)(char *, uint64_t, uint64_t))v41;
  ((void (*)(char *, char *, uint64_t))v41)(v8, v10, a1);
  v47 = v80;
  v46 = v81;
  sub_1000B8B68(8, 1, a1, v80, v37 + v81[22]);
  v45(v8, (uint64_t)v10, a1);
  LOBYTE(v84) = 1;
  v48 = v37 + v46[23];
  v43(v48, v8, a1);
  *(_BYTE *)(v48 + v14[11]) = 9;
  v44(v48 + v14[12], &v84, &type metadata for Bool);
  *(_BYTE *)(v48 + v14[13]) = 1;
  v49 = (void (*)(char *, uint64_t, uint64_t))v82;
  ((void (*)(char *, char *, uint64_t))v82)(v8, v10, a1);
  sub_1000B8B68(10, 1, a1, v47, v37 + v46[24]);
  v49(v8, (uint64_t)v10, a1);
  sub_1000B8B68(11, 1, a1, v47, v37 + v46[25]);
  v49(v8, (uint64_t)v10, a1);
  v84 = 32;
  v50 = v46;
  v51 = v37 + v46[26];
  v52 = sub_1000BE65C();
  sub_1000B84C4((uint64_t)v8, 12, (uint64_t)&v84, 1, a1, (uint64_t)&type metadata for PreferenceDefaults.EnableUserspaceP2POptions, v47, v52, v51);
  v53 = v10;
  v49(v8, (uint64_t)v10, a1);
  LOBYTE(v84) = 0;
  v54 = v50[27];
  v55 = v50;
  v56 = v78;
  v57 = v79;
  v58 = v78 + v54;
  v79(v78 + v54, v8, a1);
  *(_BYTE *)(v58 + v14[11]) = 15;
  v59 = v83;
  v83(v58 + v14[12], &v84, &type metadata for Bool);
  *(_BYTE *)(v58 + v14[13]) = 1;
  v76 = v53;
  v60 = v82;
  ((void (*)(char *, char *, uint64_t))v82)(v8, v53, a1);
  LOBYTE(v84) = 0;
  v61 = v56 + v55[28];
  v62 = v56;
  v57(v61, v8, a1);
  *(_BYTE *)(v61 + v14[11]) = 16;
  v59(v61 + v14[12], &v84, &type metadata for Bool);
  *(_BYTE *)(v61 + v14[13]) = 1;
  v63 = (void (*)(char *, uint64_t, uint64_t))v60;
  ((void (*)(char *, char *, uint64_t))v60)(v8, v53, a1);
  LOBYTE(v84) = 1;
  v64 = v81;
  v65 = v62 + v81[29];
  v57(v65, v8, a1);
  *(_BYTE *)(v65 + v14[11]) = 17;
  v66 = v83;
  v83(v65 + v14[12], &v84, &type metadata for Bool);
  *(_BYTE *)(v65 + v14[13]) = 1;
  v67 = v76;
  v63(v8, (uint64_t)v76, a1);
  LOBYTE(v84) = 0;
  v68 = v62 + v64[17];
  v57(v68, v8, a1);
  *(_BYTE *)(v68 + v14[11]) = 18;
  v66(v68 + v14[12], &v84, &type metadata for Bool);
  *(_BYTE *)(v68 + v14[13]) = 1;
  v63(v8, (uint64_t)v67, a1);
  LOBYTE(v84) = 0;
  v69 = v62 + v64[18];
  v57(v69, v8, a1);
  *(_BYTE *)(v69 + v14[11]) = 19;
  v66(v69 + v14[12], &v84, &type metadata for Bool);
  *(_BYTE *)(v69 + v14[13]) = 1;
  v63(v8, (uint64_t)v67, a1);
  v84 = 0x3FC999999999999ALL;
  v70 = v62 + v64[19];
  v57(v70, v8, a1);
  v71 = (int *)type metadata accessor for Preferences.Preference(0, a1, (uint64_t)&type metadata for Double, v80);
  *(_BYTE *)(v70 + v71[11]) = 20;
  v72 = *(void (**)(uint64_t, uint64_t *, _QWORD *))(*(&type metadata for Double - 1) + 32);
  v72(v70 + v71[12], &v84, &type metadata for Double);
  *(_BYTE *)(v70 + v71[13]) = 1;
  v84 = 0x3FE0000000000000;
  v73 = v62 + v64[20];
  v57(v73, v67, a1);
  *(_BYTE *)(v73 + v71[11]) = 21;
  result = ((uint64_t (*)(uint64_t, uint64_t *, _QWORD *))v72)(v73 + v71[12], &v84, &type metadata for Double);
  *(_BYTE *)(v73 + v71[13]) = 1;
  return result;
}

uint64_t Preferences.description.getter(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t WitnessTable;
  void (*v28)(char *, uint64_t);
  Swift::String v29;
  uint64_t v30;
  void (*v31)(char *, uint64_t, uint64_t);
  Swift::String v32;
  Swift::String v33;
  Swift::String v34;
  Swift::String v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  Swift::String v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  Swift::String v44;
  void (*v45)(char *, uint64_t, uint64_t);
  uint64_t v46;
  void (*v47)(char *, uint64_t);
  Swift::String v48;
  Swift::String v49;
  ValueMetadata *v50;
  Swift::String v51;
  Swift::String v52;
  char *v53;
  void (*v54)(char *, uint64_t, uint64_t);
  uint64_t v55;
  void (*v56)(char *, uint64_t);
  Swift::String v57;
  Swift::String v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  Swift::String v62;
  void (*v63)(char *, uint64_t, uint64_t);
  uint64_t v64;
  void (*v65)(char *, uint64_t);
  Swift::String v66;
  Swift::String v67;
  Swift::String v68;
  Swift::String v69;
  char *v70;
  uint64_t v71;
  Swift::String v72;
  Swift::String v73;
  Swift::String v74;
  uint64_t v75;
  char *v76;
  void (*v77)(char *, uint64_t, uint64_t);
  uint64_t v78;
  uint64_t v79;
  void (*v80)(char *, uint64_t);
  Swift::String v81;
  ValueMetadata *v83;
  uint64_t v84;
  char *v85;
  void (*v86)(char *, uint64_t);
  uint64_t v87;
  void (*v88)(char *, uint64_t, uint64_t);
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  void (*v94)(char *, uint64_t, uint64_t);
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  char *v98;
  uint64_t v99;
  uint64_t v100;
  void (*v101)(char *, uint64_t);
  void (*v102)(char *, uint64_t, uint64_t);
  uint64_t v103;
  char *v104;
  uint64_t v105;
  uint64_t v106;
  ValueMetadata *v107;
  uint64_t v108;
  unint64_t v109;

  v2 = v1;
  v5 = *(_QWORD *)(a1 + 16);
  v4 = *(_QWORD *)(a1 + 24);
  v6 = type metadata accessor for Preferences.Preference(0, v5, (uint64_t)&type metadata for Double, v4);
  v99 = *(_QWORD *)(v6 - 8);
  v100 = v6;
  __chkstk_darwin();
  v98 = (char *)&v83 - v7;
  v8 = sub_1000BE65C();
  v106 = v5;
  v107 = &type metadata for PreferenceDefaults.EnableUserspaceP2POptions;
  v108 = v4;
  v109 = v8;
  v9 = type metadata accessor for Preferences.EnumPreference(0, (uint64_t)&v106);
  v10 = *(_QWORD *)(v9 - 8);
  v96 = v9;
  v97 = v10;
  __chkstk_darwin();
  v95 = (uint64_t)&v83 - v11;
  v12 = sub_1000BE600();
  v106 = v5;
  v107 = &type metadata for PreferenceDefaults.InternetSharingOptions;
  v108 = v4;
  v109 = v12;
  v13 = type metadata accessor for Preferences.EnumPreference(0, (uint64_t)&v106);
  v14 = *(_QWORD *)(v13 - 8);
  v90 = v13;
  v91 = v14;
  __chkstk_darwin();
  v89 = (uint64_t)&v83 - v15;
  v105 = type metadata accessor for Preferences.Preference(0, v5, (uint64_t)&type metadata for UInt32, v4);
  v92 = *(_QWORD *)(v105 - 8);
  __chkstk_darwin();
  v104 = (char *)&v83 - v16;
  v18 = type metadata accessor for Preferences.WiFiAddressPreference(0, v5, v4, v17);
  v19 = *(_QWORD *)(v18 - 8);
  __chkstk_darwin();
  v21 = (char *)&v83 - v20;
  v22 = type metadata accessor for Preferences.Preference(0, v5, (uint64_t)&type metadata for Bool, v4);
  v23 = *(_QWORD *)(v22 - 8);
  __chkstk_darwin();
  v25 = (char *)&v83 - v24;
  v106 = 0;
  v107 = (ValueMetadata *)0xE000000000000000;
  v26 = v2 + *(int *)(a1 + 84);
  v102 = *(void (**)(char *, uint64_t, uint64_t))(v23 + 16);
  v102((char *)&v83 - v24, v26, v22);
  WitnessTable = swift_getWitnessTable(protocol conformance descriptor for Preferences<A>.Preference<A1>, v22);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v25, v22, WitnessTable);
  v28 = *(void (**)(char *, uint64_t))(v23 + 8);
  v28(v25, v22);
  v29._countAndFlagsBits = 10;
  v29._object = (void *)0xE100000000000000;
  String.append(_:)(v29);
  v30 = v2 + *(int *)(a1 + 88);
  v88 = *(void (**)(char *, uint64_t, uint64_t))(v19 + 16);
  v85 = v21;
  v88(v21, v30, v18);
  v87 = swift_getWitnessTable(protocol conformance descriptor for Preferences<A>.WiFiAddressPreference, v18);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v21, v18, v87);
  v86 = *(void (**)(char *, uint64_t))(v19 + 8);
  v86(v21, v18);
  v84 = v106;
  v83 = v107;
  v106 = 0;
  v107 = (ValueMetadata *)0xE000000000000000;
  _StringGuts.grow(_:)(62);
  v31 = v102;
  v102(v25, v2, v22);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v25, v22, WitnessTable);
  v28(v25, v22);
  v32._countAndFlagsBits = 10;
  v32._object = (void *)0xE100000000000000;
  String.append(_:)(v32);
  v31(v25, v2 + *(int *)(a1 + 36), v22);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v25, v22, WitnessTable);
  v28(v25, v22);
  v33._countAndFlagsBits = 10;
  v33._object = (void *)0xE100000000000000;
  String.append(_:)(v33);
  v31(v25, v2 + *(int *)(a1 + 40), v22);
  v103 = WitnessTable;
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v25, v22, WitnessTable);
  v28(v25, v22);
  v101 = v28;
  v34._countAndFlagsBits = 10;
  v34._object = (void *)0xE100000000000000;
  String.append(_:)(v34);
  v31(v25, v2 + *(int *)(a1 + 44), v22);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v25, v22, WitnessTable);
  v28(v25, v22);
  v35._countAndFlagsBits = 10;
  v35._object = (void *)0xE100000000000000;
  String.append(_:)(v35);
  v36 = v2 + *(int *)(a1 + 48);
  v37 = v92;
  v94 = *(void (**)(char *, uint64_t, uint64_t))(v92 + 16);
  v39 = v104;
  v38 = v105;
  v94(v104, v36, v105);
  v93 = swift_getWitnessTable(protocol conformance descriptor for Preferences<A>.Preference<A1>, v38);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v39, v38, v93);
  v92 = *(_QWORD *)(v37 + 8);
  ((void (*)(char *, uint64_t))v92)(v39, v38);
  v40._countAndFlagsBits = 10;
  v40._object = (void *)0xE100000000000000;
  String.append(_:)(v40);
  v41 = v89;
  Preferences.$internetSharingOptions.getter(a1, v89);
  v42 = v90;
  v43 = swift_getWitnessTable(protocol conformance descriptor for Preferences<A>.EnumPreference<A1>, v90);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v41, v42, v43);
  (*(void (**)(uint64_t, uint64_t))(v91 + 8))(v41, v42);
  v44._countAndFlagsBits = 10;
  v44._object = (void *)0xE100000000000000;
  String.append(_:)(v44);
  v45 = v31;
  v31(v25, v2 + *(int *)(a1 + 56), v22);
  v46 = v103;
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v25, v22, v103);
  v47 = v101;
  v101(v25, v22);
  v48._countAndFlagsBits = 10;
  v48._object = (void *)0xE100000000000000;
  String.append(_:)(v48);
  v49._countAndFlagsBits = v84;
  v50 = v83;
  v49._object = v83;
  String.append(_:)(v49);
  swift_bridgeObjectRelease(v50);
  v51._countAndFlagsBits = 10;
  v51._object = (void *)0xE100000000000000;
  String.append(_:)(v51);
  v45(v25, v2 + *(int *)(a1 + 92), v22);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v25, v22, v46);
  v47(v25, v22);
  v52._countAndFlagsBits = 10;
  v52._object = (void *)0xE100000000000000;
  String.append(_:)(v52);
  v53 = v85;
  v54 = v88;
  v88(v85, v2 + *(int *)(a1 + 96), v18);
  v55 = v87;
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v53, v18, v87);
  v56 = v86;
  v86(v53, v18);
  v57._countAndFlagsBits = 10;
  v57._object = (void *)0xE100000000000000;
  String.append(_:)(v57);
  v54(v53, v2 + *(int *)(a1 + 100), v18);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v53, v18, v55);
  v56(v53, v18);
  v58._countAndFlagsBits = 10;
  v58._object = (void *)0xE100000000000000;
  String.append(_:)(v58);
  v59 = v95;
  Preferences.$enableUserspaceP2POptions.getter(a1, v95);
  v60 = v96;
  v61 = swift_getWitnessTable(protocol conformance descriptor for Preferences<A>.EnumPreference<A1>, v96);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v59, v60, v61);
  (*(void (**)(uint64_t, uint64_t))(v97 + 8))(v59, v60);
  v62._countAndFlagsBits = 10;
  v62._object = (void *)0xE100000000000000;
  String.append(_:)(v62);
  v63 = v102;
  v102(v25, v2 + *(int *)(a1 + 108), v22);
  v64 = v103;
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v25, v22, v103);
  v65 = v101;
  v101(v25, v22);
  v66._countAndFlagsBits = 10;
  v66._object = (void *)0xE100000000000000;
  String.append(_:)(v66);
  v63(v25, v2 + *(int *)(a1 + 112), v22);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v25, v22, v64);
  v65(v25, v22);
  v67._countAndFlagsBits = 10;
  v67._object = (void *)0xE100000000000000;
  String.append(_:)(v67);
  v63(v25, v2 + *(int *)(a1 + 116), v22);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v25, v22, v64);
  v65(v25, v22);
  v68._countAndFlagsBits = 10;
  v68._object = (void *)0xE100000000000000;
  String.append(_:)(v68);
  v63(v25, v2 + *(int *)(a1 + 60), v22);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v25, v22, v64);
  v65(v25, v22);
  v69._countAndFlagsBits = 10;
  v69._object = (void *)0xE100000000000000;
  String.append(_:)(v69);
  v70 = v104;
  v71 = v105;
  v94(v104, v2 + *(int *)(a1 + 64), v105);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v70, v71, v93);
  ((void (*)(char *, uint64_t))v92)(v70, v71);
  v72._countAndFlagsBits = 10;
  v72._object = (void *)0xE100000000000000;
  String.append(_:)(v72);
  v63(v25, v2 + *(int *)(a1 + 68), v22);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v25, v22, v64);
  v65(v25, v22);
  v73._countAndFlagsBits = 10;
  v73._object = (void *)0xE100000000000000;
  String.append(_:)(v73);
  v63(v25, v2 + *(int *)(a1 + 72), v22);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v25, v22, v64);
  v65(v25, v22);
  v74._countAndFlagsBits = 10;
  v74._object = (void *)0xE100000000000000;
  String.append(_:)(v74);
  v76 = v98;
  v75 = v99;
  v77 = *(void (**)(char *, uint64_t, uint64_t))(v99 + 16);
  v78 = v100;
  v77(v98, v2 + *(int *)(a1 + 76), v100);
  v79 = swift_getWitnessTable(protocol conformance descriptor for Preferences<A>.Preference<A1>, v78);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v76, v78, v79);
  v80 = *(void (**)(char *, uint64_t))(v75 + 8);
  v80(v76, v78);
  v81._countAndFlagsBits = 10;
  v81._object = (void *)0xE100000000000000;
  String.append(_:)(v81);
  v77(v76, v2 + *(int *)(a1 + 80), v78);
  DefaultStringInterpolation.appendInterpolation<A>(_:)(v76, v78, v79);
  v80(v76, v78);
  return v106;
}

SCPreferencesRef sub_1000BC658()
{
  SCPreferencesRef result;

  result = sub_1000BC674();
  static SCPreferencesRef.p2pPreferences = (uint64_t)result;
  return result;
}

SCPreferencesRef sub_1000BC674()
{
  id v0;
  NSString v1;
  unsigned int v2;
  NSString v3;
  unsigned __int8 v4;
  NSString v5;
  NSString v6;
  unsigned int v7;
  id v8;
  id v9;
  id v10;
  uint64_t v11;
  id v12;
  __CFString *v13;
  uint64_t v14;
  uint64_t v15;
  __CFString *v16;
  SCPreferencesRef v17;
  id v19;

  v0 = objc_msgSend((id)objc_opt_self(NSFileManager), "defaultManager");
  v1 = String._bridgeToObjectiveC()();
  v2 = objc_msgSend(v0, "fileExistsAtPath:", v1);

  if (v2)
  {
    v3 = String._bridgeToObjectiveC()();
    v4 = objc_msgSend(v0, "fileExistsAtPath:", v3);

    if ((v4 & 1) == 0)
    {
      v5 = String._bridgeToObjectiveC()();
      v6 = String._bridgeToObjectiveC()();
      v19 = 0;
      v7 = objc_msgSend(v0, "moveItemAtPath:toPath:error:", v5, v6, &v19);

      v8 = v19;
      if (v7)
      {
        v9 = v19;
      }
      else
      {
        v10 = v19;
        v11 = _convertNSErrorToError(_:)(v8);

        swift_willThrow();
        swift_errorRelease(v11);
      }
    }
  }
  v12 = objc_msgSend((id)objc_opt_self(NSProcessInfo), "processInfo");
  v13 = (__CFString *)objc_msgSend(v12, "processName");

  if (!v13)
  {
    static String._unconditionallyBridgeFromObjectiveC(_:)(0);
    v15 = v14;
    v13 = (__CFString *)String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease(v15);
  }
  v16 = (__CFString *)String._bridgeToObjectiveC()();
  v17 = SCPreferencesCreate(kCFAllocatorDefault, v13, v16);

  if (!v17)
    __break(1u);

  return v17;
}

id static SCPreferencesRef.p2pPreferences.getter()
{
  if (qword_100403F28 != -1)
    swift_once(&qword_100403F28, sub_1000BC658);
  return (id)static SCPreferencesRef.p2pPreferences;
}

uint64_t SCPreferencesRef.subscript.getter@<X0>(unsigned __int8 a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  const __SCPreferences *v3;
  uint64_t v7;
  uint64_t v8;
  __CFString *v9;
  CFPropertyListRef v10;
  uint64_t v11;
  int v12;
  CFPropertyListRef v14;

  SCPreferencesLock(v3, 1u);
  PreferencesName.rawValue.getter(a1);
  v8 = v7;
  v9 = (__CFString *)String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease(v8);
  v10 = (id)SCPreferencesGetValue(v3, v9);

  v14 = v10;
  v11 = sub_100012C44(&qword_100406970);
  v12 = swift_dynamicCast(a3, &v14, v11, a2, 6);
  (*(void (**)(uint64_t, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 56))(a3, v12 ^ 1u, 1, a2);
  return SCPreferencesUnlock(v3);
}

uint64_t SCPreferencesRef.subscript.setter(uint64_t a1, unsigned __int8 a2, uint64_t a3)
{
  const __SCPreferences *v3;
  const __SCPreferences *v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  void (*v15)(char *, uint64_t);
  uint64_t v16;
  uint64_t v17;
  __CFString *v18;
  uint64_t v20;

  v4 = v3;
  v8 = type metadata accessor for Optional(0, a3);
  v9 = *(_QWORD *)(v8 - 8);
  __chkstk_darwin();
  v11 = (char *)&v20 - v10;
  v12 = *(_QWORD *)(a3 - 8);
  __chkstk_darwin();
  v14 = (char *)&v20 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v11, a1, v8);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v12 + 48))(v11, 1, a3) == 1)
  {
    v15 = *(void (**)(char *, uint64_t))(v9 + 8);
    v15(v11, v8);
    SCPreferencesLock(v4, 1u);
    SCPreferencesSynchronize(v4);
    PreferencesName.rawValue.getter(a2);
    v17 = v16;
    v18 = (__CFString *)String._bridgeToObjectiveC()();
    swift_bridgeObjectRelease(v17);
    SCPreferencesRemoveValue(v4, v18);

    SCPreferencesCommitChanges(v4);
    SCPreferencesApplyChanges(v4);
    SCPreferencesUnlock(v4);
    return ((uint64_t (*)(uint64_t, uint64_t))v15)(a1, v8);
  }
  else
  {
    (*(void (**)(char *, char *, uint64_t))(v12 + 32))(v14, v11, a3);
    SCPreferencesLock(v4, 1u);
    SCPreferencesSynchronize(v4);
    sub_1000BCC10(v4, a2, (uint64_t)v14, a3);
    SCPreferencesCommitChanges(v4);
    SCPreferencesApplyChanges(v4);
    SCPreferencesUnlock(v4);
    (*(void (**)(uint64_t, uint64_t))(v9 + 8))(a1, v8);
    return (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v14, a3);
  }
}

Swift::Void __swiftcall SCPreferencesRef.removeValue(forKey:)(CoreP2P::PreferencesName forKey)
{
  const __SCPreferences *v1;
  uint64_t v3;
  uint64_t v4;
  __CFString *v5;

  SCPreferencesLock(v1, 1u);
  SCPreferencesSynchronize(v1);
  PreferencesName.rawValue.getter(forKey);
  v4 = v3;
  v5 = (__CFString *)String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease(v4);
  SCPreferencesRemoveValue(v1, v5);

  SCPreferencesCommitChanges(v1);
  SCPreferencesApplyChanges(v1);
  SCPreferencesUnlock(v1);
}

uint64_t sub_1000BCC10(const __SCPreferences *a1, unsigned __int8 a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  __CFString *v9;
  __n128 v10;
  const void *v11;

  PreferencesName.rawValue.getter(a2);
  v8 = v7;
  v9 = (__CFString *)String._bridgeToObjectiveC()();
  v10 = swift_bridgeObjectRelease(v8);
  v11 = (const void *)_bridgeAnythingToObjectiveC<A>(_:)(a3, a4, v10);
  SCPreferencesSetValue(a1, v9, v11);

  return swift_unknownObjectRelease(v11);
}

void (*SCPreferencesRef.subscript.modify(_QWORD *a1, unsigned __int8 a2, uint64_t a3))(uint64_t *a1, char a2)
{
  uint64_t v3;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  void *v11;

  v7 = malloc(0x38uLL);
  *a1 = v7;
  *v7 = a3;
  v7[1] = v3;
  *((_BYTE *)v7 + 48) = a2;
  v8 = type metadata accessor for Optional(0, a3);
  v7[2] = v8;
  v9 = *(_QWORD *)(v8 - 8);
  v7[3] = v9;
  v10 = *(_QWORD *)(v9 + 64);
  v7[4] = malloc(v10);
  v11 = malloc(v10);
  v7[5] = v11;
  SCPreferencesRef.subscript.getter(a2, a3, (uint64_t)v11);
  return sub_1000BCD28;
}

void sub_1000BCD28(uint64_t *a1, char a2)
{
  uint64_t v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned __int8 v8;

  v2 = *a1;
  v3 = *(void **)(*a1 + 32);
  v4 = *(void **)(*a1 + 40);
  if ((a2 & 1) != 0)
  {
    v5 = *(_QWORD *)(v2 + 16);
    v6 = *(_QWORD *)(v2 + 24);
    v7 = *(_QWORD *)v2;
    v8 = *(_BYTE *)(v2 + 48);
    (*(void (**)(_QWORD, void *, uint64_t))(v6 + 16))(*(_QWORD *)(*a1 + 32), v4, v5);
    SCPreferencesRef.subscript.setter((uint64_t)v3, v8, v7);
    (*(void (**)(void *, uint64_t))(v6 + 8))(v4, v5);
  }
  else
  {
    SCPreferencesRef.subscript.setter(*(_QWORD *)(*a1 + 40), *(_BYTE *)(v2 + 48), *(_QWORD *)v2);
  }
  free(v4);
  free(v3);
  free((void *)v2);
}

uint64_t sub_1000BCDCC@<X0>(unsigned __int8 a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return SCPreferencesRef.subscript.getter(a1, a2, a3);
}

uint64_t sub_1000BCDEC(uint64_t a1, unsigned __int8 a2, uint64_t a3)
{
  return SCPreferencesRef.subscript.setter(a1, a2, a3);
}

void (*sub_1000BCE0C(_QWORD *a1, unsigned __int8 a2, uint64_t a3))(uint64_t *a1, char a2)
{
  uint64_t *v3;
  _BYTE *v7;
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  void *v11;
  uint64_t v12;

  v7 = malloc(0x38uLL);
  *a1 = v7;
  *(_QWORD *)v7 = a3;
  v7[48] = a2;
  v8 = type metadata accessor for Optional(0, a3);
  *((_QWORD *)v7 + 1) = v8;
  v9 = *(_QWORD *)(v8 - 8);
  *((_QWORD *)v7 + 2) = v9;
  v10 = *(_QWORD *)(v9 + 64);
  *((_QWORD *)v7 + 3) = malloc(v10);
  v11 = malloc(v10);
  v12 = *v3;
  *((_QWORD *)v7 + 4) = v11;
  *((_QWORD *)v7 + 5) = v12;
  SCPreferencesRef.subscript.getter(a2, a3, (uint64_t)v11);
  return sub_1000BCEB0;
}

void sub_1000BCEB0(uint64_t *a1, char a2)
{
  uint64_t v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned __int8 v8;

  v2 = *a1;
  v3 = *(void **)(*a1 + 32);
  v4 = *(void **)(*a1 + 24);
  if ((a2 & 1) != 0)
  {
    v5 = *(_QWORD *)(v2 + 8);
    v6 = *(_QWORD *)(v2 + 16);
    v7 = *(_QWORD *)v2;
    v8 = *(_BYTE *)(v2 + 48);
    (*(void (**)(_QWORD, void *, uint64_t))(v6 + 16))(*(_QWORD *)(*a1 + 24), v3, v5);
    SCPreferencesRef.subscript.setter((uint64_t)v4, v8, v7);
    (*(void (**)(void *, uint64_t))(v6 + 8))(v3, v5);
  }
  else
  {
    SCPreferencesRef.subscript.setter(*(_QWORD *)(*a1 + 32), *(_BYTE *)(v2 + 48), *(_QWORD *)v2);
  }
  free(v3);
  free(v4);
  free((void *)v2);
}

uint64_t sub_1000BCF58(unsigned __int8 a1)
{
  const __SCPreferences **v1;
  const __SCPreferences *v3;
  uint64_t v4;
  uint64_t v5;
  __CFString *v6;

  v3 = *v1;
  SCPreferencesLock(v3, 1u);
  SCPreferencesSynchronize(v3);
  PreferencesName.rawValue.getter(a1);
  v5 = v4;
  v6 = (__CFString *)String._bridgeToObjectiveC()();
  swift_bridgeObjectRelease(v5);
  SCPreferencesRemoveValue(v3, v6);

  SCPreferencesCommitChanges(v3);
  SCPreferencesApplyChanges(v3);
  return SCPreferencesUnlock(v3);
}

uint64_t InMemoryPreferenceStorage.__allocating_init()()
{
  uint64_t v0;
  uint64_t result;

  result = swift_allocObject(v0, 24, 7);
  *(_QWORD *)(result + 16) = &_swiftEmptyDictionarySingleton;
  return result;
}

uint64_t type metadata accessor for InMemoryPreferenceStorage()
{
  return objc_opt_self(_TtC7CoreP2P25InMemoryPreferenceStorage);
}

uint64_t InMemoryPreferenceStorage.init()()
{
  uint64_t v0;
  uint64_t result;

  result = v0;
  *(_QWORD *)(v0 + 16) = &_swiftEmptyDictionarySingleton;
  return result;
}

uint64_t type metadata accessor for CachedPreferenceStorage(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_100033C60(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for CachedPreferenceStorage);
}

uint64_t type metadata accessor for LockedPreferencesStorage(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_100033C60(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for LockedPreferencesStorage);
}

uint64_t InMemoryPreferenceStorage.subscript.getter@<X0>(unsigned __int8 a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  __int128 v16;
  __int128 v17;
  char v18[24];

  v6 = PreferencesName.rawValue.getter(a1);
  v8 = v7;
  swift_beginAccess(v3 + 16, v18, 0, 0);
  v9 = *(_QWORD *)(v3 + 16);
  if (*(_QWORD *)(v9 + 16))
  {
    swift_bridgeObjectRetain(v9);
    v10 = sub_10000FA00(v6, v8);
    if ((v11 & 1) != 0)
    {
      sub_100014450(*(_QWORD *)(v9 + 56) + 32 * v10, (uint64_t)&v16);
    }
    else
    {
      v16 = 0u;
      v17 = 0u;
    }
    swift_bridgeObjectRelease(v8);
    v12 = v9;
  }
  else
  {
    v16 = 0u;
    v17 = 0u;
    v12 = v8;
  }
  swift_bridgeObjectRelease(v12);
  v13 = sub_100012C44(&qword_100405050);
  v14 = swift_dynamicCast(a3, &v16, v13, a2, 6);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 56))(a3, v14 ^ 1u, 1, a2);
}

uint64_t InMemoryPreferenceStorage.subscript.setter(uint64_t a1, unsigned __int8 a2, uint64_t a3)
{
  uint64_t v5;

  sub_1000BE0F8(a1, a2, a3);
  v5 = type metadata accessor for Optional(0, a3);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 8))(a1, v5);
}

void (*InMemoryPreferenceStorage.subscript.modify(_QWORD *a1, unsigned __int8 a2, uint64_t a3))(uint64_t **a1, char a2)
{
  uint64_t v3;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  void *v11;

  v7 = malloc(0x38uLL);
  *a1 = v7;
  *v7 = a3;
  v7[1] = v3;
  *((_BYTE *)v7 + 48) = a2;
  v8 = type metadata accessor for Optional(0, a3);
  v7[2] = v8;
  v9 = *(_QWORD *)(v8 - 8);
  v7[3] = v9;
  v10 = *(_QWORD *)(v9 + 64);
  v7[4] = malloc(v10);
  v11 = malloc(v10);
  v7[5] = v11;
  InMemoryPreferenceStorage.subscript.getter(a2, a3, (uint64_t)v11);
  return sub_1000BD22C;
}

void sub_1000BD22C(uint64_t **a1, char a2)
{
  uint64_t *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned __int8 v8;
  void (*v9)(void *, uint64_t);

  v2 = *a1;
  v3 = (void *)(*a1)[4];
  v4 = (void *)(*a1)[5];
  v5 = (*a1)[2];
  v6 = (*a1)[3];
  v7 = **a1;
  v8 = *((_BYTE *)*a1 + 48);
  if ((a2 & 1) != 0)
  {
    (*(void (**)(uint64_t, void *, uint64_t))(v6 + 16))((*a1)[4], v4, v5);
    sub_1000BE0F8((uint64_t)v3, v8, v7);
    v9 = *(void (**)(void *, uint64_t))(v6 + 8);
    v9(v3, v5);
  }
  else
  {
    sub_1000BE0F8((*a1)[5], v8, v7);
    v9 = *(void (**)(void *, uint64_t))(v6 + 8);
  }
  v9(v4, v5);
  free(v4);
  free(v3);
  free(v2);
}

Swift::Void __swiftcall InMemoryPreferenceStorage.removeValue(forKey:)(CoreP2P::PreferencesName forKey)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _BYTE v5[24];
  _OWORD v6[2];

  v2 = PreferencesName.rawValue.getter(forKey);
  v4 = v3;
  swift_beginAccess(v1 + 16, v5, 33, 0);
  sub_10002FC54(v2, v4, v6);
  sub_1000BE6AC((uint64_t)v6);
  swift_endAccess(v5);
  swift_bridgeObjectRelease(v4);
}

Swift::Void __swiftcall InMemoryPreferenceStorage.removeAll()()
{
  uint64_t v0;
  uint64_t v1;
  _BYTE v2[24];

  swift_beginAccess(v0 + 16, v2, 1, 0);
  v1 = *(_QWORD *)(v0 + 16);
  *(_QWORD *)(v0 + 16) = &_swiftEmptyDictionarySingleton;
  swift_bridgeObjectRelease(v1);
}

uint64_t InMemoryPreferenceStorage.deinit()
{
  uint64_t v0;

  swift_bridgeObjectRelease(*(_QWORD *)(v0 + 16));
  return v0;
}

uint64_t InMemoryPreferenceStorage.__deallocating_deinit()
{
  uint64_t v0;

  swift_bridgeObjectRelease(*(_QWORD *)(v0 + 16));
  return swift_deallocClassInstance(v0, 24, 7);
}

uint64_t sub_1000BD3D4@<X0>(unsigned __int8 a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return InMemoryPreferenceStorage.subscript.getter(a1, a2, a3);
}

uint64_t sub_1000BD3F4(uint64_t a1, unsigned __int8 a2, uint64_t a3)
{
  uint64_t v5;

  sub_1000BE0F8(a1, a2, a3);
  v5 = type metadata accessor for Optional(0, a3);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 8))(a1, v5);
}

void (*sub_1000BD440(_QWORD *a1, unsigned __int8 a2, uint64_t a3))(uint64_t **a1, char a2)
{
  uint64_t *v3;
  _BYTE *v7;
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  void *v11;
  uint64_t v12;

  v7 = malloc(0x38uLL);
  *a1 = v7;
  *(_QWORD *)v7 = a3;
  v7[48] = a2;
  v8 = type metadata accessor for Optional(0, a3);
  *((_QWORD *)v7 + 1) = v8;
  v9 = *(_QWORD *)(v8 - 8);
  *((_QWORD *)v7 + 2) = v9;
  v10 = *(_QWORD *)(v9 + 64);
  *((_QWORD *)v7 + 3) = malloc(v10);
  v11 = malloc(v10);
  v12 = *v3;
  *((_QWORD *)v7 + 4) = v11;
  *((_QWORD *)v7 + 5) = v12;
  InMemoryPreferenceStorage.subscript.getter(a2, a3, (uint64_t)v11);
  return sub_1000BD4E4;
}

void sub_1000BD4E4(uint64_t **a1, char a2)
{
  uint64_t *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned __int8 v8;
  void (*v9)(void *, uint64_t);

  v2 = *a1;
  v3 = (void *)(*a1)[4];
  v5 = (*a1)[2];
  v4 = (void *)(*a1)[3];
  v7 = **a1;
  v6 = (*a1)[1];
  v8 = *((_BYTE *)*a1 + 48);
  if ((a2 & 1) != 0)
  {
    (*(void (**)(uint64_t, void *, uint64_t))(v5 + 16))((*a1)[3], v3, v6);
    sub_1000BE0F8((uint64_t)v4, v8, v7);
    v9 = *(void (**)(void *, uint64_t))(v5 + 8);
    v9(v4, v6);
  }
  else
  {
    sub_1000BE0F8((*a1)[4], v8, v7);
    v9 = *(void (**)(void *, uint64_t))(v5 + 8);
  }
  v9(v3, v6);
  free(v3);
  free(v4);
  free(v2);
}

double sub_1000BD598(unsigned __int8 a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  double result;
  _BYTE v7[24];
  _OWORD v8[2];

  v2 = *v1;
  v3 = PreferencesName.rawValue.getter(a1);
  v5 = v4;
  swift_beginAccess(v2 + 16, v7, 33, 0);
  sub_10002FC54(v3, v5, v8);
  sub_1000BE6AC((uint64_t)v8);
  swift_endAccess(v7);
  *(_QWORD *)&result = swift_bridgeObjectRelease(v5).n128_u64[0];
  return result;
}

void LockedPreferencesStorage.subscript.getter(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v5 = v4;
  v10 = type metadata accessor for Optional(0, a3);
  v11 = *(_QWORD *)(v10 - 8);
  __chkstk_darwin(v10);
  v13 = (char *)&v16 - v12;
  os_unfair_lock_lock(*(os_unfair_lock_t *)(*(_QWORD *)v4 + 16));
  (*(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)(a2 + 24) + 8))(a1, a3, *(_QWORD *)(a2 + 16));
  v14 = *(_QWORD *)(a3 - 8);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v14 + 48))(v13, 1, a3) == 1)
  {
    (*(void (**)(char *, uint64_t))(v11 + 8))(v13, v10);
    v15 = 1;
  }
  else
  {
    (*(void (**)(uint64_t, char *, uint64_t))(v14 + 32))(a4, v13, a3);
    v15 = 0;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v14 + 56))(a4, v15, 1, a3);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(*(_QWORD *)v5 + 16));
}

uint64_t LockedPreferencesStorage.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1000BDCB4(a1, a2, a3, a4, (void (*)(void))sub_1000BE2C0);
}

void (*LockedPreferencesStorage.subscript.modify(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4))(uint64_t **a1, char a2)
{
  uint64_t v4;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  size_t v12;
  void *v13;

  v9 = malloc(0x40uLL);
  *a1 = v9;
  v9[1] = a4;
  v9[2] = v4;
  *v9 = a3;
  *((_BYTE *)v9 + 56) = a2;
  v10 = type metadata accessor for Optional(0, a4);
  v9[3] = v10;
  v11 = *(_QWORD *)(v10 - 8);
  v9[4] = v11;
  v12 = *(_QWORD *)(v11 + 64);
  v9[5] = malloc(v12);
  v13 = malloc(v12);
  v9[6] = v13;
  LockedPreferencesStorage.subscript.getter(a2, a3, a4, (uint64_t)v13);
  return sub_1000BD7EC;
}

void sub_1000BD7EC(uint64_t **a1, char a2)
{
  sub_1000BDDB4(a1, a2, (void (*)(void *, uint64_t, uint64_t, uint64_t))sub_1000BE2C0);
}

Swift::Void __swiftcall LockedPreferencesStorage.removeValue(forKey:)(CoreP2P::PreferencesName forKey)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v3 = v1;
  v4 = forKey;
  os_unfair_lock_lock(*(os_unfair_lock_t *)(*(_QWORD *)v2 + 16));
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)(v3 + 24) + 32))(v4, *(_QWORD *)(v3 + 16));
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(*(_QWORD *)v2 + 16));
}

void sub_1000BD850(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  LockedPreferencesStorage.subscript.getter(a1, a3, a2, a4);
}

uint64_t sub_1000BD860(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return sub_1000BDF20(a1, a2, a3, a4, a5, sub_1000BE2C0);
}

void (*sub_1000BD86C(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4))(uint64_t **a1, char a2)
{
  uint64_t v4;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  size_t v12;
  void *v13;

  v9 = malloc(0x40uLL);
  *a1 = v9;
  v9[1] = v4;
  v9[2] = a4;
  *v9 = a3;
  *((_BYTE *)v9 + 56) = a2;
  v10 = type metadata accessor for Optional(0, a3);
  v9[3] = v10;
  v11 = *(_QWORD *)(v10 - 8);
  v9[4] = v11;
  v12 = *(_QWORD *)(v11 + 64);
  v9[5] = malloc(v12);
  v13 = malloc(v12);
  v9[6] = v13;
  LockedPreferencesStorage.subscript.getter(a2, a4, a3, (uint64_t)v13);
  return sub_1000BD918;
}

void sub_1000BD918(uint64_t **a1, char a2)
{
  sub_1000BE028(a1, a2, (void (*)(void *, uint64_t, uint64_t, uint64_t))sub_1000BE2C0);
}

uint64_t LockedPreferencesStorage<>.init()()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  _DWORD *v3;

  v0 = type metadata accessor for InMemoryPreferenceStorage();
  *(_QWORD *)(swift_allocObject(v0, 24, 7) + 16) = &_swiftEmptyDictionarySingleton;
  v1 = type metadata accessor for Lock();
  v2 = swift_allocObject(v1, 24, 7);
  v3 = (_DWORD *)swift_slowAlloc(4, -1);
  *(_QWORD *)(v2 + 16) = v3;
  *v3 = 0;
  return v2;
}

uint64_t CachedPreferenceStorage.subscript.getter@<X0>(unsigned int a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  uint64_t *v4;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  char *v17;
  unsigned int (*v18)(char *, uint64_t, uint64_t);
  void (*v19)(char *, uint64_t);
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  unsigned __int8 v27;
  unsigned int v28;
  char *v29;
  uint64_t v30;
  uint64_t (*v31)(uint64_t, uint64_t, uint64_t, uint64_t);
  char *v32;
  void (*v33)(char *, char *, uint64_t);
  char *v34;
  void (*v36)(char *, char *, uint64_t);
  char *v37;
  uint64_t v38;
  unsigned __int8 v39;
  uint64_t (*v40)(char *, _QWORD, uint64_t, uint64_t);
  uint64_t v41[2];
  void (*v42)(uint64_t, uint64_t);
  char *v43;
  char *v44;
  char *v45;
  uint64_t *v46;
  uint64_t v47;
  unsigned int v48;
  uint64_t v49;
  char *v50;
  char v51;
  char v52;

  v47 = a2;
  v50 = a4;
  v49 = type metadata accessor for Optional(0, a3);
  v46 = *(uint64_t **)(v49 - 8);
  __chkstk_darwin();
  v8 = (char *)v41 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin();
  v10 = (char *)v41 - v9;
  __chkstk_darwin();
  v12 = (char *)v41 - v11;
  v13 = *(_QWORD *)(a3 - 8);
  __chkstk_darwin();
  v15 = (char *)v41 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin();
  v17 = (char *)v41 - v16;
  v48 = a1;
  InMemoryPreferenceStorage.subscript.getter(a1, a3, (uint64_t)v12);
  v18 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v13 + 48);
  if (v18(v12, 1, a3) != 1)
  {
    v33 = *(void (**)(char *, char *, uint64_t))(v13 + 32);
    v33(v17, v12, a3);
    v34 = v50;
    v33(v50, v17, a3);
    return (*(uint64_t (**)(char *, _QWORD, uint64_t, uint64_t))(v13 + 56))(v34, 0, 1, a3);
  }
  v44 = v8;
  v45 = v10;
  v43 = v15;
  v19 = (void (*)(char *, uint64_t))v46[1];
  v19(v12, v49);
  v46 = v4;
  v20 = *v4;
  v21 = *(_QWORD *)(v47 + 16);
  v22 = *(_QWORD *)(v47 + 24);
  v24 = type metadata accessor for CachedPreferenceStorage.EmptyPreference(0, v21, v22, v23);
  v25 = v48;
  InMemoryPreferenceStorage.subscript.getter(v48, v24, (uint64_t)&v52);
  if ((v52 & 1) != 0)
  {
    v41[0] = v24;
    v41[1] = v20;
    v42 = (void (*)(uint64_t, uint64_t))v19;
    v26 = v45;
    v27 = v25;
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v22 + 8))(v25, a3, v21, v22);
    v28 = v18(v26, 1, a3);
    v30 = v49;
    v29 = v50;
    if (v28 != 1)
    {
      v36 = *(void (**)(char *, char *, uint64_t))(v13 + 32);
      v37 = v43;
      v36(v43, v26, a3);
      v38 = (uint64_t)v44;
      (*(void (**)(char *, char *, uint64_t))(v13 + 16))(v44, v37, a3);
      v39 = v27;
      v40 = *(uint64_t (**)(char *, _QWORD, uint64_t, uint64_t))(v13 + 56);
      v40((char *)v38, 0, 1, a3);
      sub_1000BE0F8(v38, v39, a3);
      v42(v38, v30);
      v36(v29, v37, a3);
      return v40(v29, 0, 1, a3);
    }
    v42((uint64_t)v26, v49);
    v51 = 0;
    sub_1000BE0F8((uint64_t)&v51, v25, v41[0]);
    v31 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v13 + 56);
    v32 = v29;
  }
  else
  {
    v31 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v13 + 56);
    v32 = v50;
  }
  return v31((uint64_t)v32, 1, 1, a3);
}

uint64_t CachedPreferenceStorage.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1000BDCB4(a1, a2, a3, a4, (void (*)(void))sub_1000BE374);
}

uint64_t sub_1000BDCB4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void))
{
  uint64_t v7;

  a5();
  v7 = type metadata accessor for Optional(0, a4);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v7 - 8) + 8))(a1, v7);
}

void (*CachedPreferenceStorage.subscript.modify(_QWORD *a1, unsigned int a2, uint64_t a3, uint64_t a4))(uint64_t **a1, char a2)
{
  uint64_t v4;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  size_t v12;
  char *v13;

  v9 = malloc(0x40uLL);
  *a1 = v9;
  v9[1] = a4;
  v9[2] = v4;
  *v9 = a3;
  *((_BYTE *)v9 + 56) = a2;
  v10 = type metadata accessor for Optional(0, a4);
  v9[3] = v10;
  v11 = *(_QWORD *)(v10 - 8);
  v9[4] = v11;
  v12 = *(_QWORD *)(v11 + 64);
  v9[5] = malloc(v12);
  v13 = (char *)malloc(v12);
  v9[6] = v13;
  CachedPreferenceStorage.subscript.getter(a2, a3, a4, v13);
  return sub_1000BDDA8;
}

void sub_1000BDDA8(uint64_t **a1, char a2)
{
  sub_1000BDDB4(a1, a2, (void (*)(void *, uint64_t, uint64_t, uint64_t))sub_1000BE374);
}

void sub_1000BDDB4(uint64_t **a1, char a2, void (*a3)(void *, uint64_t, uint64_t, uint64_t))
{
  uint64_t *v4;
  void *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void (*v12)(void *, uint64_t);

  v4 = *a1;
  v5 = (void *)(*a1)[5];
  v6 = (void *)(*a1)[6];
  v7 = (*a1)[3];
  v8 = (*a1)[4];
  v9 = (*a1)[1];
  v10 = **a1;
  v11 = *((unsigned __int8 *)*a1 + 56);
  if ((a2 & 1) != 0)
  {
    (*(void (**)(uint64_t, void *, uint64_t))(v8 + 16))((*a1)[5], v6, v7);
    a3(v5, v11, v10, v9);
    v12 = *(void (**)(void *, uint64_t))(v8 + 8);
    v12(v5, v7);
  }
  else
  {
    a3((void *)(*a1)[6], v11, v10, v9);
    v12 = *(void (**)(void *, uint64_t))(v8 + 8);
  }
  v12(v6, v7);
  free(v6);
  free(v5);
  free(v4);
}

Swift::Void __swiftcall CachedPreferenceStorage.removeValue(forKey:)(CoreP2P::PreferencesName forKey)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v7;

  v3 = forKey;
  v4 = *(_QWORD *)(v1 + 16);
  v5 = *(_QWORD *)(v1 + 24);
  v7 = 0;
  v6 = type metadata accessor for CachedPreferenceStorage.EmptyPreference(0, v4, v5, v2);
  sub_1000BE0F8((uint64_t)&v7, v3, v6);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v5 + 32))(v3, v4, v5);
}

uint64_t sub_1000BDF04@<X0>(unsigned int a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  return CachedPreferenceStorage.subscript.getter(a1, a3, a2, a4);
}

uint64_t sub_1000BDF14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return sub_1000BDF20(a1, a2, a3, a4, a5, (void (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1000BE374);
}

uint64_t sub_1000BDF20(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void (*a6)(uint64_t, uint64_t, uint64_t, uint64_t))
{
  uint64_t v8;

  a6(a1, a2, a4, a3);
  v8 = type metadata accessor for Optional(0, a3);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v8 - 8) + 8))(a1, v8);
}

void (*sub_1000BDF70(_QWORD *a1, unsigned int a2, uint64_t a3, uint64_t a4))(uint64_t **a1, char a2)
{
  uint64_t v4;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  size_t v12;
  char *v13;

  v9 = malloc(0x40uLL);
  *a1 = v9;
  v9[1] = v4;
  v9[2] = a4;
  *v9 = a3;
  *((_BYTE *)v9 + 56) = a2;
  v10 = type metadata accessor for Optional(0, a3);
  v9[3] = v10;
  v11 = *(_QWORD *)(v10 - 8);
  v9[4] = v11;
  v12 = *(_QWORD *)(v11 + 64);
  v9[5] = malloc(v12);
  v13 = (char *)malloc(v12);
  v9[6] = v13;
  CachedPreferenceStorage.subscript.getter(a2, a4, a3, v13);
  return sub_1000BE01C;
}

void sub_1000BE01C(uint64_t **a1, char a2)
{
  sub_1000BE028(a1, a2, (void (*)(void *, uint64_t, uint64_t, uint64_t))sub_1000BE374);
}

void sub_1000BE028(uint64_t **a1, char a2, void (*a3)(void *, uint64_t, uint64_t, uint64_t))
{
  uint64_t *v4;
  void *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void (*v12)(void *, uint64_t);

  v4 = *a1;
  v5 = (void *)(*a1)[5];
  v6 = (void *)(*a1)[6];
  v7 = (*a1)[3];
  v8 = (*a1)[4];
  v9 = (*a1)[2];
  v10 = **a1;
  v11 = *((unsigned __int8 *)*a1 + 56);
  if ((a2 & 1) != 0)
  {
    (*(void (**)(uint64_t, void *, uint64_t))(v8 + 16))((*a1)[5], v6, v7);
    a3(v5, v11, v9, v10);
    v12 = *(void (**)(void *, uint64_t))(v8 + 8);
    v12(v5, v7);
  }
  else
  {
    a3((void *)(*a1)[6], v11, v9, v10);
    v12 = *(void (**)(void *, uint64_t))(v8 + 8);
  }
  v12(v6, v7);
  free(v6);
  free(v5);
  free(v4);
}

uint64_t sub_1000BE0F8(uint64_t a1, unsigned __int8 a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _BYTE v12[24];
  _QWORD v13[4];

  v6 = PreferencesName.rawValue.getter(a2);
  v8 = v7;
  v9 = type metadata accessor for Optional(0, a3);
  v13[3] = v9;
  v10 = sub_100033C24(v13);
  (*(void (**)(_QWORD *, uint64_t, uint64_t))(*(_QWORD *)(v9 - 8) + 16))(v10, a1, v9);
  swift_beginAccess(v3 + 16, v12, 33, 0);
  sub_100025214((uint64_t)v13, v6, v8);
  return swift_endAccess(v12);
}

uint64_t _s7CoreP2P15PreferencesNameO8rawValueACSgSS_tcfC_0(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = _findStringSwitchCaseWithCache(cases:string:cache:)(&off_1003D5DD0, a1, a2, &unk_100404278);
  swift_bridgeObjectRelease(a2);
  if (v3 >= 0x16)
    return 22;
  else
    return v3;
}

unint64_t _s7CoreP2P18PreferenceDefaultsV22InternetSharingOptionsO8rawValueAESgSS_tcfC_0(Swift::String string)
{
  void *object;
  Swift::String v2;
  unint64_t v3;

  object = string._object;
  v2._countAndFlagsBits = string._countAndFlagsBits;
  v2._object = object;
  v3 = _findStringSwitchCase(cases:string:)((Swift::OpaquePointer)&off_1003D6218, v2);
  swift_bridgeObjectRelease(object);
  if (v3 >= 3)
    return 3;
  else
    return v3;
}

uint64_t sub_1000BE238(uint64_t result, uint64_t a2, unint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  uint64_t v9;

  if (result < 0)
  {
    __break(1u);
  }
  else
  {
    v5 = HIBYTE(a3) & 0xF;
    if ((a3 & 0x2000000000000000) == 0)
      v5 = a2;
    v6 = 7;
    if (((a3 >> 60) & ((a2 & 0x800000000000000) == 0)) != 0)
      v6 = 11;
    v7 = String.index(_:offsetBy:limitedBy:)(v6 | (v5 << 16), -result, 15, a2, a3);
    if ((v8 & 1) != 0)
      v9 = 15;
    else
      v9 = v7;
    return String.subscript.getter(15, v9, a2, a3);
  }
  return result;
}

void sub_1000BE2C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v9;
  _QWORD *v10;
  _QWORD v11[4];

  os_unfair_lock_lock(*(os_unfair_lock_t *)(*(_QWORD *)v4 + 16));
  v9 = type metadata accessor for Optional(0, a4);
  v11[3] = v9;
  v10 = sub_100033C24(v11);
  (*(void (**)(_QWORD *, uint64_t, uint64_t))(*(_QWORD *)(v9 - 8) + 16))(v10, a1, v9);
  (*(void (**)(_QWORD *, uint64_t, char *, _QWORD))(*(_QWORD *)(a3 + 24) + 16))(v11, a2, &type metadata for Any[8], *(_QWORD *)(a3 + 16));
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(*(_QWORD *)v4 + 16));
}

uint64_t sub_1000BE374(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v13;

  v8 = type metadata accessor for Optional(0, a4);
  v9 = *(_QWORD *)(v8 - 8);
  __chkstk_darwin();
  v11 = (char *)&v13 - v10;
  sub_1000BE0F8(a1, a2, a4);
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v11, a1, v8);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(a3 + 24) + 16))(v11, a2, a4, *(_QWORD *)(a3 + 16));
}

uint64_t sub_1000BE444(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;

  v5 = *(_QWORD *)(a2 + 24);
  v6 = type metadata accessor for Optional(0, v5);
  __chkstk_darwin(v6);
  v8 = (char *)&v12 - v7;
  v9 = *(_QWORD *)(v5 - 8);
  v10 = *(unsigned __int8 *)(v2 + *(int *)(a2 + 44));
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))((char *)&v12 - v7, a1, v5);
  (*(void (**)(char *, _QWORD, uint64_t, uint64_t))(v9 + 56))(v8, 0, 1, v5);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(a2 + 32) + 16))(v8, v10, v5, *(_QWORD *)(a2 + 16));
}

uint64_t type metadata accessor for Preferences.Preference(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_100033C60(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Preferences.Preference);
}

uint64_t sub_1000BE518(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t AssociatedTypeWitness;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v11;

  v3 = a2[5];
  v4 = a2[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v3, v4, &protocol requirements base descriptor for RawRepresentable);
  v6 = *(_QWORD *)(AssociatedTypeWitness - 8);
  __chkstk_darwin();
  v8 = (char *)&v11 - v7;
  dispatch thunk of RawRepresentable.rawValue.getter((uint64_t *)((char *)&v11 - v7), v4, v3);
  v9 = type metadata accessor for Preferences.Preference(0, a2[2], AssociatedTypeWitness, a2[4]);
  sub_1000BE444((uint64_t)v8, v9);
  return (*(uint64_t (**)(char *, uint64_t))(v6 + 8))(v8, AssociatedTypeWitness);
}

unint64_t sub_1000BE600()
{
  unint64_t result;

  result = qword_100406960;
  if (!qword_100406960)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for PreferenceDefaults.InternetSharingOptions, &type metadata for PreferenceDefaults.InternetSharingOptions);
    atomic_store(result, (unint64_t *)&qword_100406960);
  }
  return result;
}

uint64_t type metadata accessor for Preferences.EnumPreference(uint64_t a1, uint64_t a2)
{
  return swift_getGenericMetadata(a1, a2, &nominal type descriptor for Preferences.EnumPreference);
}

uint64_t type metadata accessor for Preferences.WiFiAddressPreference(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_100033C60(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Preferences.WiFiAddressPreference);
}

unint64_t sub_1000BE65C()
{
  unint64_t result;

  result = qword_100406968;
  if (!qword_100406968)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for PreferenceDefaults.EnableUserspaceP2POptions, &type metadata for PreferenceDefaults.EnableUserspaceP2POptions);
    atomic_store(result, (unint64_t *)&qword_100406968);
  }
  return result;
}

uint64_t type metadata accessor for Preferences(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_100033C60(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Preferences);
}

uint64_t sub_1000BE6AC(uint64_t a1)
{
  uint64_t v2;

  v2 = sub_100012C44(&qword_100405050);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v2 - 8) + 8))(a1, v2);
  return a1;
}

uint64_t type metadata accessor for CachedPreferenceStorage.EmptyPreference(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_100033C60(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for CachedPreferenceStorage.EmptyPreference);
}

unint64_t sub_1000BE700()
{
  unint64_t result;

  result = qword_100406978;
  if (!qword_100406978)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for PreferenceDefaults.EnableUserspaceP2POptions, &type metadata for PreferenceDefaults.EnableUserspaceP2POptions);
    atomic_store(result, (unint64_t *)&qword_100406978);
  }
  return result;
}

unint64_t sub_1000BE748()
{
  unint64_t result;

  result = qword_100406980;
  if (!qword_100406980)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for PreferenceDefaults.EnableUserspaceP2POptions, &type metadata for PreferenceDefaults.EnableUserspaceP2POptions);
    atomic_store(result, (unint64_t *)&qword_100406980);
  }
  return result;
}

unint64_t sub_1000BE790()
{
  unint64_t result;

  result = qword_100406988;
  if (!qword_100406988)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for PreferenceDefaults.EnableUserspaceP2POptions, &type metadata for PreferenceDefaults.EnableUserspaceP2POptions);
    atomic_store(result, (unint64_t *)&qword_100406988);
  }
  return result;
}

unint64_t sub_1000BE7D8()
{
  unint64_t result;

  result = qword_100406990;
  if (!qword_100406990)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for PreferenceDefaults.InternetSharingOptions, &type metadata for PreferenceDefaults.InternetSharingOptions);
    atomic_store(result, (unint64_t *)&qword_100406990);
  }
  return result;
}

unint64_t sub_1000BE820()
{
  unint64_t result;
  uint64_t v1;

  result = qword_100406998;
  if (!qword_100406998)
  {
    v1 = sub_100013C64(&qword_1004069A0);
    result = swift_getWitnessTable((const char *)&protocol conformance descriptor for [A], v1);
    atomic_store(result, (unint64_t *)&qword_100406998);
  }
  return result;
}

unint64_t sub_1000BE870()
{
  unint64_t result;

  result = qword_1004069A8[0];
  if (!qword_1004069A8[0])
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for PreferencesName, &type metadata for PreferencesName);
    atomic_store(result, qword_1004069A8);
  }
  return result;
}

ValueMetadata *type metadata accessor for PreferenceDefaults()
{
  return &type metadata for PreferenceDefaults;
}

ValueMetadata *type metadata accessor for PreferenceDefaults.EnableUserspaceP2POptions()
{
  return &type metadata for PreferenceDefaults.EnableUserspaceP2POptions;
}

uint64_t storeEnumTagSinglePayload for PreferenceDefaults.InternetSharingOptions(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 2 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 2) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xFE)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xFD)
    return ((uint64_t (*)(void))((char *)&loc_1000BE920 + 4 * byte_10033FA0B[v4]))();
  *a1 = a2 + 2;
  return ((uint64_t (*)(void))((char *)sub_1000BE954 + 4 * byte_10033FA06[v4]))();
}

uint64_t sub_1000BE954(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000BE95C(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x1000BE964);
  return result;
}

uint64_t sub_1000BE970(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x1000BE978);
  *(_BYTE *)result = a2 + 2;
  return result;
}

uint64_t sub_1000BE97C(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000BE984(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for PreferenceDefaults.InternetSharingOptions()
{
  return &type metadata for PreferenceDefaults.InternetSharingOptions;
}

uint64_t getEnumTagSinglePayload for PreferencesName(unsigned __int8 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0xEB)
    goto LABEL_17;
  if (a2 + 21 >= 0xFFFF00)
    v2 = 4;
  else
    v2 = 2;
  if ((a2 + 21) >> 8 < 0xFF)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 8)) - 21;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1))
        goto LABEL_17;
      return (*a1 | (v4 << 8)) - 21;
    }
    v4 = a1[1];
    if (a1[1])
      return (*a1 | (v4 << 8)) - 21;
  }
LABEL_17:
  v6 = *a1;
  v7 = v6 >= 0x16;
  v8 = v6 - 22;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for PreferencesName(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 21 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 21) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xEB)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xEA)
    return ((uint64_t (*)(void))((char *)&loc_1000BEA7C + 4 * byte_10033FA15[v4]))();
  *a1 = a2 + 21;
  return ((uint64_t (*)(void))((char *)sub_1000BEAB0 + 4 * byte_10033FA10[v4]))();
}

uint64_t sub_1000BEAB0(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000BEAB8(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x1000BEAC0);
  return result;
}

uint64_t sub_1000BEACC(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x1000BEAD4);
  *(_BYTE *)result = a2 + 21;
  return result;
}

uint64_t sub_1000BEAD8(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000BEAE0(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for PreferencesName()
{
  return &type metadata for PreferencesName;
}

uint64_t sub_1000BEAFC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_allocateGenericValueMetadata(a1, a2, a3, 104);
}

uint64_t sub_1000BEB04(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  ValueMetadata *v15;
  uint64_t v16;
  unint64_t v17;
  _QWORD v18[11];
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  v3 = *(_QWORD *)(a1 + 16);
  v2 = *(_QWORD *)(a1 + 24);
  result = type metadata accessor for Preferences.Preference(319, v3, (uint64_t)&type metadata for Bool, v2);
  if (v5 <= 0x3F)
  {
    v6 = *(_QWORD *)(result - 8) + 64;
    v18[0] = v6;
    v18[1] = v6;
    v18[2] = v6;
    v18[3] = v6;
    result = type metadata accessor for Preferences.Preference(319, v3, (uint64_t)&type metadata for UInt32, v2);
    if (v7 <= 0x3F)
    {
      v8 = *(_QWORD *)(result - 8) + 64;
      v18[4] = v8;
      v14 = v3;
      v15 = &type metadata for PreferenceDefaults.InternetSharingOptions;
      v16 = v2;
      v17 = sub_1000BE600();
      result = type metadata accessor for Preferences.EnumPreference(319, (uint64_t)&v14);
      if (v9 <= 0x3F)
      {
        v18[5] = *(_QWORD *)(result - 8) + 64;
        v18[6] = v6;
        v18[7] = v6;
        v18[8] = v8;
        v18[9] = v6;
        v18[10] = v6;
        result = type metadata accessor for Preferences.Preference(319, v3, (uint64_t)&type metadata for Double, v2);
        if (v10 <= 0x3F)
        {
          v19 = *(_QWORD *)(result - 8) + 64;
          v20 = v19;
          v21 = v6;
          result = type metadata accessor for Preferences.Preference(319, v3, (uint64_t)&type metadata for Data, v2);
          if (v11 <= 0x3F)
          {
            v22 = *(_QWORD *)(result - 8) + 64;
            v23 = v6;
            v24 = v22;
            v25 = v22;
            v12 = sub_1000BE65C();
            v14 = v3;
            v15 = &type metadata for PreferenceDefaults.EnableUserspaceP2POptions;
            v16 = v2;
            v17 = v12;
            result = type metadata accessor for Preferences.EnumPreference(319, (uint64_t)&v14);
            if (v13 <= 0x3F)
            {
              v26 = *(_QWORD *)(result - 8) + 64;
              v27 = v6;
              v28 = v6;
              v29 = v6;
              swift_initStructMetadata(a1, 0, 22, v18, a1 + 32);
              return 0;
            }
          }
        }
      }
    }
  }
  return result;
}

_QWORD *sub_1000BEC94(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  void (*v21)(unint64_t, unint64_t, uint64_t);
  _BYTE *v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  _BYTE *v27;
  unint64_t v28;
  unint64_t v29;
  _BYTE *v30;
  unint64_t v31;
  unint64_t v32;
  _BYTE *v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  _BYTE *v38;
  uint64_t v39;
  _BYTE *v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  _BYTE *v48;
  unint64_t v49;
  unint64_t v50;
  _BYTE *v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  _BYTE *v58;
  unint64_t v59;
  unint64_t v60;
  _BYTE *v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  _BYTE *v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  _BYTE *v81;
  uint64_t v82;
  uint64_t v83;
  unint64_t v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  uint64_t v89;
  unint64_t v90;
  unint64_t v91;
  uint64_t v92;
  unint64_t v93;
  _QWORD *v94;
  _QWORD *v95;
  uint64_t v96;
  uint64_t v97;
  unint64_t v98;
  unint64_t v99;
  unint64_t v100;
  unint64_t v101;
  _QWORD *v102;
  unint64_t v103;
  _BYTE *v104;
  unint64_t v105;
  unint64_t v106;
  _BYTE *v107;
  unint64_t v108;
  unint64_t v109;
  _BYTE *v110;
  uint64_t v111;
  uint64_t v113;
  unint64_t v114;
  unint64_t v115;
  uint64_t v116;
  unint64_t v117;
  unint64_t v118;
  unint64_t v119;
  _QWORD *v120;
  void (*v121)(unint64_t, unint64_t, uint64_t);
  uint64_t v122;
  uint64_t v123;

  v5 = *(_QWORD *)(a3 + 16);
  v6 = *(_QWORD *)(v5 - 8);
  v7 = *(_DWORD *)(v6 + 80);
  v8 = v7 | 7;
  v9 = ~v8;
  if (v7 > 7u)
    goto LABEL_5;
  if ((v7 & 0x100000) != 0)
    goto LABEL_5;
  v10 = *(_QWORD *)(v6 + 64);
  v11 = v10 + 3 + v7;
  v12 = (v10 & 0xFFFFFFFFFFFFFFFCLL) + 9;
  v13 = (v10 & 0xFFFFFFFFFFFFFFF8) + 25;
  v14 = v12 + v7;
  v15 = (v11
       + ((v14
         + (((v7 | 3)
           + v10
           + 3
           + ((v11
             + ((v13
               + v7
               + ((v8 + 1) & ~v8)
               + ((v8
                 + v12
                 + (((v7 | 3)
                   + v10
                   + 3
                   + ((v11
                     + ((v11 + (v11 & ~(unint64_t)v7)) & ~(unint64_t)v7)) & ~(unint64_t)v7)) & ~(v7 | 3))) & ~v8)) & ~(unint64_t)v7)) & ~(unint64_t)v7)) & ~(v7 | 3))) & ~(unint64_t)v7)) & ~(unint64_t)v7;
  v16 = v8 + v10 + 3;
  v17 = (v10 & 0xFFFFFFFFFFFFFFF8) + 17;
  v18 = (v8 + v17 + ((v16 + v15) & ~v8)) & ~v8;
  v19 = v17 + v7;
  if (((v11
       + ((v11
         + ((v19
           + ((v7 + 8) & ~v8)
           + ((v8
             + v13
             + ((v8
               + v13
               + ((v16
                 + ((v13 + v7 + ((v16 + ((v19 + v18) & ~(unint64_t)v7)) & ~v8)) & ~(unint64_t)v7)) & ~v8)) & ~v8)) & ~v8)) & ~(unint64_t)v7)) & ~(unint64_t)v7)) & ~(unint64_t)v7)
     + v10
     + 3 > 0x18)
  {
LABEL_5:
    v111 = *a2;
    *a1 = *a2;
    v102 = (_QWORD *)(v111 + ((v7 + 16) & v9));
    swift_retain();
  }
  else
  {
    v20 = ~(unint64_t)v7;
    v122 = (v7 | 3) + v10 + 3;
    v123 = ~(v7 | 3);
    v21 = *(void (**)(unint64_t, unint64_t, uint64_t))(v6 + 16);
    v118 = v13 + v7;
    v119 = v19 + ((v7 + 8) & ~v8);
    v117 = v19;
    v114 = v118 + ((v8 + 1) & ~v8);
    v115 = v14;
    v21((unint64_t)a1, (unint64_t)a2, v5);
    v120 = a1;
    v23 = (char *)a1 + v10;
    *v23 = *((_BYTE *)a2 + v10);
    v23[1] = *((_BYTE *)a2 + v10 + 1);
    v23[2] = *((_BYTE *)a2 + v10 + 2);
    v24 = v11;
    v25 = ((unint64_t)a1 + v11) & v20;
    v26 = ((unint64_t)a2 + v24) & v20;
    v21(v25, v26, v5);
    v27 = (_BYTE *)(v25 + v10);
    *v27 = *(_BYTE *)(v26 + v10);
    v27[1] = *(_BYTE *)(v26 + v10 + 1);
    v27[2] = *(_BYTE *)(v26 + v10 + 2);
    v28 = (v24 + v25) & v20;
    v29 = (v24 + v26) & v20;
    v21(v28, v29, v5);
    v30 = (_BYTE *)(v28 + v10);
    *v30 = *(_BYTE *)(v29 + v10);
    v30[1] = *(_BYTE *)(v29 + v10 + 1);
    v30[2] = *(_BYTE *)(v29 + v10 + 2);
    v31 = (v24 + v28) & v20;
    v32 = (v24 + v29) & v20;
    v21(v31, v32, v5);
    v33 = (_BYTE *)(v31 + v10);
    *v33 = *(_BYTE *)(v32 + v10);
    v33[1] = *(_BYTE *)(v32 + v10 + 1);
    v33[2] = *(_BYTE *)(v32 + v10 + 2);
    v34 = (v122 + v31) & v123;
    v35 = (v122 + v32) & v123;
    v21(v34, v35, v5);
    *(_BYTE *)(v34 + v10) = *(_BYTE *)(v35 + v10);
    v36 = (v34 + v10) & 0xFFFFFFFFFFFFFFFCLL;
    v37 = (v35 + v10) & 0xFFFFFFFFFFFFFFFCLL;
    *(_DWORD *)(v36 + 4) = *(_DWORD *)(v37 + 4);
    *(_BYTE *)(v36 + 8) = *(_BYTE *)(v37 + 8);
    v38 = (_BYTE *)((v10 + 16 + v35) & v9);
    v39 = v9;
    v40 = (_BYTE *)((v10 + 16 + v34) & v9);
    *v40 = *v38;
    v41 = (unint64_t)(v40 + 8) & v39;
    v42 = (unint64_t)(v38 + 8) & v39;
    v21(v41, v42, v5);
    *(_BYTE *)(v41 + v10) = *(_BYTE *)(v42 + v10);
    v43 = (v41 + v10) & 0xFFFFFFFFFFFFFFF8;
    v44 = (v42 + v10) & 0xFFFFFFFFFFFFFFF8;
    *(_QWORD *)(v43 + 8) = *(_QWORD *)(v44 + 8);
    v45 = *(_QWORD *)(v44 + 16);
    *(_QWORD *)(v43 + 16) = v45;
    *(_BYTE *)(v43 + 24) = *(_BYTE *)(v44 + 24);
    v46 = (unint64_t)&v40[v114] & v20;
    v47 = (unint64_t)&v38[v114] & v20;
    swift_bridgeObjectRetain(v45);
    v21(v46, v47, v5);
    v48 = (_BYTE *)(v46 + v10);
    *v48 = *(_BYTE *)(v47 + v10);
    v48[1] = *(_BYTE *)(v47 + v10 + 1);
    v48[2] = *(_BYTE *)(v47 + v10 + 2);
    v49 = (v24 + v46) & v20;
    v50 = (v24 + v47) & v20;
    v21(v49, v50, v5);
    v51 = (_BYTE *)(v49 + v10);
    *v51 = *(_BYTE *)(v50 + v10);
    v51[1] = *(_BYTE *)(v50 + v10 + 1);
    v51[2] = *(_BYTE *)(v50 + v10 + 2);
    v52 = (v122 + v49) & v123;
    v53 = (v122 + v50) & v123;
    v21(v52, v53, v5);
    *(_BYTE *)(v52 + v10) = *(_BYTE *)(v53 + v10);
    v54 = (v52 + v10) & 0xFFFFFFFFFFFFFFFCLL;
    v55 = (v53 + v10) & 0xFFFFFFFFFFFFFFFCLL;
    *(_DWORD *)(v54 + 4) = *(_DWORD *)(v55 + 4);
    *(_BYTE *)(v54 + 8) = *(_BYTE *)(v55 + 8);
    v56 = (v115 + v52) & v20;
    v57 = (v115 + v53) & v20;
    v21(v56, v57, v5);
    v58 = (_BYTE *)(v56 + v10);
    *v58 = *(_BYTE *)(v57 + v10);
    v58[1] = *(_BYTE *)(v57 + v10 + 1);
    v58[2] = *(_BYTE *)(v57 + v10 + 2);
    v116 = v24;
    v59 = (v24 + v56) & v20;
    v60 = (v24 + v57) & v20;
    v21(v59, v60, v5);
    v61 = (_BYTE *)(v59 + v10);
    *v61 = *(_BYTE *)(v60 + v10);
    v61[1] = *(_BYTE *)(v60 + v10 + 1);
    v61[2] = *(_BYTE *)(v60 + v10 + 2);
    v62 = (v10 + 10 + v59) & v39;
    v63 = (v10 + 10 + v60) & v39;
    v21(v62, v63, v5);
    *(_BYTE *)(v62 + v10) = *(_BYTE *)(v63 + v10);
    v64 = (v62 + v10) & 0xFFFFFFFFFFFFFFF8;
    v65 = (v63 + v10) & 0xFFFFFFFFFFFFFFF8;
    *(_QWORD *)(v64 + 8) = *(_QWORD *)(v65 + 8);
    *(_BYTE *)(v64 + 16) = *(_BYTE *)(v65 + 16);
    v66 = (v10 + 24 + v62) & v39;
    v67 = (v10 + 24 + v63) & v39;
    v21(v66, v67, v5);
    *(_BYTE *)(v66 + v10) = *(_BYTE *)(v67 + v10);
    v68 = (v66 + v10) & 0xFFFFFFFFFFFFFFF8;
    v69 = (v67 + v10) & 0xFFFFFFFFFFFFFFF8;
    *(_QWORD *)(v68 + 8) = *(_QWORD *)(v69 + 8);
    *(_BYTE *)(v68 + 16) = *(_BYTE *)(v69 + 16);
    v70 = (v117 + v66) & v20;
    v71 = (v117 + v67) & v20;
    v113 = v5;
    v21(v70, v71, v5);
    v121 = v21;
    v72 = (_BYTE *)(v70 + v10);
    *v72 = *(_BYTE *)(v71 + v10);
    v72[1] = *(_BYTE *)(v71 + v10 + 1);
    v72[2] = *(_BYTE *)(v71 + v10 + 2);
    v73 = (v10 + 10 + v70) & v39;
    v74 = (v10 + 10 + v71) & v39;
    v21(v73, v74, v5);
    *(_BYTE *)(v73 + v10) = *(_BYTE *)(v74 + v10);
    v75 = (v73 + v10) & 0xFFFFFFFFFFFFFFF8;
    v76 = (v74 + v10) & 0xFFFFFFFFFFFFFFF8;
    v77 = *(_QWORD *)(v76 + 8);
    v78 = *(_QWORD *)(v76 + 16);
    sub_100031FEC(v77, v78);
    *(_QWORD *)(v75 + 8) = v77;
    *(_QWORD *)(v75 + 16) = v78;
    *(_BYTE *)(v75 + 24) = *(_BYTE *)(v76 + 24);
    v79 = (v118 + v73) & v20;
    v80 = (v118 + v74) & v20;
    v121(v79, v80, v113);
    v81 = (_BYTE *)(v79 + v10);
    *v81 = *(_BYTE *)(v80 + v10);
    v81[1] = *(_BYTE *)(v80 + v10 + 1);
    v81[2] = *(_BYTE *)(v80 + v10 + 2);
    v82 = (v10 + 10 + v79) & v39;
    v83 = (v10 + 10 + v80) & v39;
    v121(v82, v83, v113);
    *(_BYTE *)(v82 + v10) = *(_BYTE *)(v83 + v10);
    v84 = (v82 + v10) & 0xFFFFFFFFFFFFFFF8;
    v85 = (v83 + v10) & 0xFFFFFFFFFFFFFFF8;
    v86 = *(_QWORD *)(v85 + 8);
    v87 = *(_QWORD *)(v85 + 16);
    sub_100031FEC(v86, v87);
    *(_QWORD *)(v84 + 8) = v86;
    *(_QWORD *)(v84 + 16) = v87;
    *(_BYTE *)(v84 + 24) = *(_BYTE *)(v85 + 24);
    v88 = (v10 + 32 + v82) & v39;
    v89 = (v10 + 32 + v83) & v39;
    v121(v88, v89, v113);
    *(_BYTE *)(v88 + v10) = *(_BYTE *)(v89 + v10);
    v90 = (v88 + v10) & 0xFFFFFFFFFFFFFFF8;
    v91 = (v89 + v10) & 0xFFFFFFFFFFFFFFF8;
    v92 = *(_QWORD *)(v91 + 8);
    v93 = *(_QWORD *)(v91 + 16);
    sub_100031FEC(v92, v93);
    *(_QWORD *)(v90 + 8) = v92;
    *(_QWORD *)(v90 + 16) = v93;
    *(_BYTE *)(v90 + 24) = *(_BYTE *)(v91 + 24);
    v94 = (_QWORD *)((v10 + 32 + v89) & v39);
    v95 = (_QWORD *)((v10 + 32 + v88) & v39);
    *v95 = *v94;
    v96 = ((unint64_t)v95 + 15) & v39;
    v97 = ((unint64_t)v94 + 15) & v39;
    v121(v96, v97, v113);
    *(_BYTE *)(v96 + v10) = *(_BYTE *)(v97 + v10);
    v98 = (v96 + v10) & 0xFFFFFFFFFFFFFFF8;
    v99 = (v97 + v10) & 0xFFFFFFFFFFFFFFF8;
    *(_QWORD *)(v98 + 8) = *(_QWORD *)(v99 + 8);
    *(_BYTE *)(v98 + 16) = *(_BYTE *)(v99 + 16);
    v100 = ((unint64_t)v95 + v119) & v20;
    v101 = (unint64_t)v94 + v119;
    v102 = v120;
    v103 = v101 & v20;
    v121(v100, v101 & v20, v113);
    v104 = (_BYTE *)(v100 + v10);
    *v104 = *(_BYTE *)(v103 + v10);
    v104[1] = *(_BYTE *)(v103 + v10 + 1);
    v104[2] = *(_BYTE *)(v103 + v10 + 2);
    v105 = (v116 + v100) & v20;
    v106 = (v116 + v103) & v20;
    v121(v105, v106, v113);
    v107 = (_BYTE *)(v105 + v10);
    *v107 = *(_BYTE *)(v106 + v10);
    v107[1] = *(_BYTE *)(v106 + v10 + 1);
    v107[2] = *(_BYTE *)(v106 + v10 + 2);
    v108 = (v116 + v105) & v20;
    v109 = (v116 + v106) & v20;
    v121(v108, v109, v113);
    v110 = (_BYTE *)(v108 + v10);
    *v110 = *(_BYTE *)(v109 + v10);
    v110[1] = *(_BYTE *)(v109 + v10 + 1);
    v110[2] = *(_BYTE *)(v109 + v10 + 2);
  }
  return v102;
}

uint64_t sub_1000BF4D0(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __n128 v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v34;
  unint64_t v35;
  void (*v36)(uint64_t, uint64_t);

  v3 = *(_QWORD *)(a2 + 16);
  v4 = *(_QWORD *)(v3 - 8);
  v36 = *(void (**)(uint64_t, uint64_t))(v4 + 8);
  v36(a1, v3);
  v5 = *(_QWORD *)(v4 + 64);
  v6 = *(unsigned __int8 *)(v4 + 80);
  v34 = v5 + 3 + v6;
  v7 = (v34 + a1) & ~v6;
  v36(v7, v3);
  v8 = (v34 + v7) & ~v6;
  v36(v8, v3);
  v9 = (v34 + v8) & ~v6;
  v36(v9, v3);
  v10 = (v6 | 3) + v5 + 3;
  v11 = (v10 + v9) & ~(v6 | 3);
  v36(v11, v3);
  v12 = (v5 & 0xFFFFFFFFFFFFFFFCLL) + 9;
  v13 = v6 | 7;
  v14 = ((v6 | 7) + v12 + v11) & ~(v6 | 7);
  v15 = (v6 | 7) + 1;
  v36((v15 + v14) & ~(v6 | 7), v3);
  v16 = swift_bridgeObjectRelease(*(_QWORD *)(((((v15 + v14) & ~(v6 | 7)) + v5) & 0xFFFFFFFFFFFFF8) + 0x10));
  v35 = (v5 & 0xFFFFFFFFFFFFFFF8) + 25;
  ((void (*)(unint64_t, uint64_t, __n128))v36)((v35 + v6 + (v15 & ~(v6 | 7)) + v14) & ~v6, v3, v16);
  v17 = (v34 + ((v35 + v6 + (v15 & ~(v6 | 7)) + v14) & ~v6)) & ~v6;
  v36(v17, v3);
  v18 = (v10 + v17) & ~(v6 | 3);
  v36(v18, v3);
  v19 = (v12 + v6 + v18) & ~v6;
  v36(v19, v3);
  v20 = (v34 + v19) & ~v6;
  v36(v20, v3);
  v21 = (v6 | 7) + v5 + 3;
  v22 = (v13 + v5 + 3 + v20) & ~v13;
  v36(v22, v3);
  v23 = (v5 & 0xFFFFFFFFFFFFFFF8) + 17;
  v24 = (v13 + v23 + v22) & ~v13;
  v36(v24, v3);
  v25 = (v23 + v6 + v24) & ~v6;
  v36(v25, v3);
  v26 = (v21 + v25) & ~(v6 | 7);
  v36(v26, v3);
  sub_10000E614(*(_QWORD *)(((v26 + v5) & 0xFFFFFFFFFFFFFFF8) + 8), *(_QWORD *)(((v26 + v5) & 0xFFFFFFFFFFFFFFF8) + 16));
  v27 = (v35 + v6 + v26) & ~v6;
  v36(v27, v3);
  v28 = (v21 + v27) & ~(v6 | 7);
  v36(v28, v3);
  sub_10000E614(*(_QWORD *)(((v28 + v5) & 0xFFFFFFFFFFFFFFF8) + 8), *(_QWORD *)(((v28 + v5) & 0xFFFFFFFFFFFFFFF8) + 16));
  v29 = (v13 + v35 + v28) & ~v13;
  v36(v29, v3);
  sub_10000E614(*(_QWORD *)(((v29 + v5) & 0xFFFFFFFFFFFFFFF8) + 8), *(_QWORD *)(((v29 + v5) & 0xFFFFFFFFFFFFFFF8) + 16));
  v30 = ((v6 | 7) + v35 + v29) & ~(v6 | 7);
  v36((v6 + 8 + v30) & ~(v6 | 7), v3);
  v31 = (v23 + v6 + ((v6 + 8) & ~(v6 | 7)) + v30) & ~v6;
  v36(v31, v3);
  v32 = (v34 + v31) & ~v6;
  v36(v32, v3);
  return ((uint64_t (*)(uint64_t, uint64_t))v36)((v34 + v32) & ~v6, v3);
}

uint64_t sub_1000BF7F4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  void (*v7)(void);
  uint64_t v8;
  void (*v9)(void);
  uint64_t v10;
  _BYTE *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _BYTE *v17;
  uint64_t v18;
  uint64_t v19;
  _BYTE *v20;
  uint64_t v21;
  uint64_t v22;
  _BYTE *v23;
  uint64_t v24;
  uint64_t v25;
  void (*v26)(void);
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  _BYTE *v31;
  _BYTE *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  _BYTE *v42;
  unint64_t v43;
  unint64_t v44;
  _BYTE *v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  _BYTE *v52;
  unint64_t v53;
  unint64_t v54;
  _BYTE *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  _BYTE *v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  unint64_t v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  _BYTE *v78;
  uint64_t v79;
  uint64_t v80;
  unint64_t v81;
  unint64_t v82;
  uint64_t v83;
  unint64_t v84;
  unint64_t v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  uint64_t v90;
  unint64_t v91;
  _QWORD *v92;
  _QWORD *v93;
  uint64_t v94;
  uint64_t v95;
  unint64_t v96;
  unint64_t v97;
  uint64_t v98;
  unint64_t v99;
  unint64_t v100;
  _BYTE *v101;
  unint64_t v102;
  uint64_t v103;
  unint64_t v104;
  _BYTE *v105;
  unint64_t v106;
  unint64_t v107;
  _BYTE *v108;
  unint64_t v110;
  uint64_t v111;
  uint64_t v112;
  unint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  void (*v117)(void);

  v5 = *(_QWORD *)(a3 + 16);
  v6 = *(_QWORD *)(v5 - 8);
  v7 = *(void (**)(void))(v6 + 16);
  v8 = v5;
  v7();
  v9 = v7;
  v10 = *(_QWORD *)(v6 + 64);
  v11 = (_BYTE *)(v10 + a1);
  v114 = a1;
  *v11 = *(_BYTE *)(v10 + a2);
  v11[1] = *(_BYTE *)(v10 + a2 + 1);
  v11[2] = *(_BYTE *)(v10 + a2 + 2);
  v12 = *(unsigned __int8 *)(v6 + 80);
  v13 = v10 + 3 + v12;
  v14 = (v13 + a1) & ~v12;
  v15 = (v13 + a2) & ~v12;
  v16 = v8;
  ((void (*)(uint64_t, uint64_t, uint64_t))v9)(v14, v15, v8);
  v17 = (_BYTE *)(v14 + v10);
  *v17 = *(_BYTE *)(v15 + v10);
  v17[1] = *(_BYTE *)(v15 + v10 + 1);
  v17[2] = *(_BYTE *)(v15 + v10 + 2);
  v18 = (v13 + v14) & ~v12;
  v19 = (v13 + v15) & ~v12;
  ((void (*)(uint64_t, uint64_t, uint64_t))v9)(v18, v19, v8);
  v20 = (_BYTE *)(v18 + v10);
  *v20 = *(_BYTE *)(v19 + v10);
  v20[1] = *(_BYTE *)(v19 + v10 + 1);
  v20[2] = *(_BYTE *)(v19 + v10 + 2);
  v116 = v13;
  v21 = (v13 + v18) & ~v12;
  v22 = (v13 + v19) & ~v12;
  ((void (*)(uint64_t, uint64_t, uint64_t))v9)(v21, v22, v8);
  v23 = (_BYTE *)(v21 + v10);
  *v23 = *(_BYTE *)(v22 + v10);
  v23[1] = *(_BYTE *)(v22 + v10 + 1);
  v23[2] = *(_BYTE *)(v22 + v10 + 2);
  v111 = (v12 | 3) + v10 + 3;
  v24 = (v111 + v21) & ~(v12 | 3);
  v25 = (v111 + v22) & ~(v12 | 3);
  ((void (*)(uint64_t, uint64_t, uint64_t))v9)(v24, v25, v8);
  v26 = v9;
  v117 = v9;
  *(_BYTE *)(v24 + v10) = *(_BYTE *)(v25 + v10);
  v27 = (v24 + v10) & 0xFFFFFFFFFFFFFFFCLL;
  v28 = (v25 + v10) & 0xFFFFFFFFFFFFFFFCLL;
  *(_DWORD *)(v27 + 4) = *(_DWORD *)(v28 + 4);
  *(_BYTE *)(v27 + 8) = *(_BYTE *)(v28 + 8);
  v110 = (v10 & 0xFFFFFFFFFFFFFFFCLL) + 9;
  v29 = v12 | 7;
  v30 = (v12 | 7) + v110;
  v31 = (_BYTE *)((v30 + v24) & ~(v12 | 7));
  v32 = (_BYTE *)((v30 + v25) & ~(v12 | 7));
  *v31 = *v32;
  v33 = (v12 | 7) + 1;
  v34 = (unint64_t)&v31[v33] & ~(v12 | 7);
  v35 = (unint64_t)&v32[v33] & ~(v12 | 7);
  ((void (*)(uint64_t, uint64_t, uint64_t))v26)(v34, v35, v16);
  *(_BYTE *)(v34 + v10) = *(_BYTE *)(v35 + v10);
  v36 = (v34 + v10) & 0xFFFFFFFFFFFFFFF8;
  v37 = (v35 + v10) & 0xFFFFFFFFFFFFFFF8;
  *(_QWORD *)(v36 + 8) = *(_QWORD *)(v37 + 8);
  v38 = *(_QWORD *)(v37 + 16);
  *(_QWORD *)(v36 + 16) = v38;
  *(_BYTE *)(v36 + 24) = *(_BYTE *)(v37 + 24);
  v113 = (v10 & 0xFFFFFFFFFFFFFFF8) + 25;
  v39 = v113 + v12 + (v33 & ~(v12 | 7));
  v40 = (unint64_t)&v31[v39] & ~v12;
  v41 = (unint64_t)&v32[v39] & ~v12;
  swift_bridgeObjectRetain(v38);
  ((void (*)(unint64_t, unint64_t, uint64_t))v117)(v40, v41, v16);
  v42 = (_BYTE *)(v40 + v10);
  *v42 = *(_BYTE *)(v41 + v10);
  v42[1] = *(_BYTE *)(v41 + v10 + 1);
  v42[2] = *(_BYTE *)(v41 + v10 + 2);
  v43 = (v116 + v40) & ~v12;
  v44 = (v116 + v41) & ~v12;
  ((void (*)(unint64_t, unint64_t, uint64_t))v117)(v43, v44, v16);
  v45 = (_BYTE *)(v43 + v10);
  *v45 = *(_BYTE *)(v44 + v10);
  v45[1] = *(_BYTE *)(v44 + v10 + 1);
  v45[2] = *(_BYTE *)(v44 + v10 + 2);
  v46 = (v111 + v43) & ~(v12 | 3);
  v47 = (v111 + v44) & ~(v12 | 3);
  ((void (*)(uint64_t, uint64_t, uint64_t))v117)(v46, v47, v16);
  *(_BYTE *)(v46 + v10) = *(_BYTE *)(v47 + v10);
  v48 = (v46 + v10) & 0xFFFFFFFFFFFFFFFCLL;
  v49 = (v47 + v10) & 0xFFFFFFFFFFFFFFFCLL;
  *(_DWORD *)(v48 + 4) = *(_DWORD *)(v49 + 4);
  *(_BYTE *)(v48 + 8) = *(_BYTE *)(v49 + 8);
  v50 = (v110 + v12 + v46) & ~v12;
  v51 = (v110 + v12 + v47) & ~v12;
  ((void (*)(unint64_t, unint64_t, uint64_t))v117)(v50, v51, v16);
  v52 = (_BYTE *)(v50 + v10);
  *v52 = *(_BYTE *)(v51 + v10);
  v52[1] = *(_BYTE *)(v51 + v10 + 1);
  v52[2] = *(_BYTE *)(v51 + v10 + 2);
  v53 = (v116 + v50) & ~v12;
  v54 = (v116 + v51) & ~v12;
  ((void (*)(unint64_t, unint64_t, uint64_t))v117)(v53, v54, v16);
  v55 = (_BYTE *)(v53 + v10);
  *v55 = *(_BYTE *)(v54 + v10);
  v55[1] = *(_BYTE *)(v54 + v10 + 1);
  v55[2] = *(_BYTE *)(v54 + v10 + 2);
  v56 = (v12 | 7) + v10 + 3;
  v57 = (v29 + v10 + 3 + v53) & ~v29;
  v58 = (v29 + v10 + 3 + v54) & ~v29;
  ((void (*)(uint64_t, uint64_t, uint64_t))v117)(v57, v58, v16);
  *(_BYTE *)(v57 + v10) = *(_BYTE *)(v58 + v10);
  v59 = (v57 + v10) & 0xFFFFFFFFFFFFFFF8;
  v60 = (v58 + v10) & 0xFFFFFFFFFFFFFFF8;
  *(_QWORD *)(v59 + 8) = *(_QWORD *)(v60 + 8);
  *(_BYTE *)(v59 + 16) = *(_BYTE *)(v60 + 16);
  v61 = (v10 & 0xFFFFFFFFFFFFFFF8) + 17;
  v62 = (v12 | 7) + v61;
  v63 = (v62 + v57) & ~(v12 | 7);
  v64 = (v62 + v58) & ~(v12 | 7);
  ((void (*)(uint64_t, uint64_t, uint64_t))v117)(v63, v64, v16);
  *(_BYTE *)(v63 + v10) = *(_BYTE *)(v64 + v10);
  v65 = (v63 + v10) & 0xFFFFFFFFFFFFFFF8;
  v66 = (v64 + v10) & 0xFFFFFFFFFFFFFFF8;
  *(_QWORD *)(v65 + 8) = *(_QWORD *)(v66 + 8);
  *(_BYTE *)(v65 + 16) = *(_BYTE *)(v66 + 16);
  v112 = v61 + v12;
  v67 = (v61 + v12 + v63) & ~v12;
  v68 = (v61 + v12 + v64) & ~v12;
  v115 = v16;
  ((void (*)(unint64_t, unint64_t, uint64_t))v117)(v67, v68, v16);
  v69 = (_BYTE *)(v67 + v10);
  *v69 = *(_BYTE *)(v68 + v10);
  v69[1] = *(_BYTE *)(v68 + v10 + 1);
  v69[2] = *(_BYTE *)(v68 + v10 + 2);
  v70 = (v56 + v67) & ~(v12 | 7);
  v71 = (v56 + v68) & ~(v12 | 7);
  ((void (*)(uint64_t, uint64_t, uint64_t))v117)(v70, v71, v16);
  *(_BYTE *)(v70 + v10) = *(_BYTE *)(v71 + v10);
  v72 = (v70 + v10) & 0xFFFFFFFFFFFFFFF8;
  v73 = (v71 + v10) & 0xFFFFFFFFFFFFFFF8;
  v74 = *(_QWORD *)(v73 + 8);
  v75 = *(_QWORD *)(v73 + 16);
  sub_100031FEC(v74, v75);
  *(_QWORD *)(v72 + 8) = v74;
  *(_QWORD *)(v72 + 16) = v75;
  *(_BYTE *)(v72 + 24) = *(_BYTE *)(v73 + 24);
  v76 = (v113 + v12 + v70) & ~v12;
  v77 = (v113 + v12 + v71) & ~v12;
  ((void (*)(unint64_t, unint64_t, uint64_t))v117)(v76, v77, v115);
  v78 = (_BYTE *)(v76 + v10);
  *v78 = *(_BYTE *)(v77 + v10);
  v78[1] = *(_BYTE *)(v77 + v10 + 1);
  v78[2] = *(_BYTE *)(v77 + v10 + 2);
  v79 = (v56 + v76) & ~(v12 | 7);
  v80 = (v56 + v77) & ~(v12 | 7);
  ((void (*)(uint64_t, uint64_t, uint64_t))v117)(v79, v80, v115);
  *(_BYTE *)(v79 + v10) = *(_BYTE *)(v80 + v10);
  v81 = (v79 + v10) & 0xFFFFFFFFFFFFFFF8;
  v82 = (v80 + v10) & 0xFFFFFFFFFFFFFFF8;
  v83 = *(_QWORD *)(v82 + 8);
  v84 = *(_QWORD *)(v82 + 16);
  sub_100031FEC(v83, v84);
  *(_QWORD *)(v81 + 8) = v83;
  *(_QWORD *)(v81 + 16) = v84;
  *(_BYTE *)(v81 + 24) = *(_BYTE *)(v82 + 24);
  v85 = (v12 | 7) + v113;
  v86 = (v29 + v113 + v79) & ~v29;
  v87 = (v29 + v113 + v80) & ~v29;
  ((void (*)(unint64_t, unint64_t, uint64_t))v117)(v86, v87, v115);
  *(_BYTE *)(v86 + v10) = *(_BYTE *)(v87 + v10);
  v88 = (v86 + v10) & 0xFFFFFFFFFFFFFFF8;
  v89 = (v87 + v10) & 0xFFFFFFFFFFFFFFF8;
  v90 = *(_QWORD *)(v89 + 8);
  v91 = *(_QWORD *)(v89 + 16);
  sub_100031FEC(v90, v91);
  *(_QWORD *)(v88 + 8) = v90;
  *(_QWORD *)(v88 + 16) = v91;
  *(_BYTE *)(v88 + 24) = *(_BYTE *)(v89 + 24);
  v92 = (_QWORD *)((v85 + v86) & ~(v12 | 7));
  v93 = (_QWORD *)((v85 + v87) & ~(v12 | 7));
  *v92 = *v93;
  v94 = ((unint64_t)v92 + v12 + 8) & ~(v12 | 7);
  v95 = ((unint64_t)v93 + v12 + 8) & ~(v12 | 7);
  ((void (*)(unint64_t, unint64_t, uint64_t))v117)(((unint64_t)v92 + v12 + 8) & ~v29, ((unint64_t)v93 + v12 + 8) & ~v29, v115);
  *(_BYTE *)(v94 + v10) = *(_BYTE *)(v95 + v10);
  v96 = (v94 + v10) & 0xFFFFFFFFFFFFFFF8;
  v97 = (v95 + v10) & 0xFFFFFFFFFFFFFFF8;
  *(_QWORD *)(v96 + 8) = *(_QWORD *)(v97 + 8);
  *(_BYTE *)(v96 + 16) = *(_BYTE *)(v97 + 16);
  v98 = v112 + ((v12 + 8) & ~(v12 | 7));
  v99 = ((unint64_t)v92 + v98) & ~v12;
  v100 = ((unint64_t)v93 + v98) & ~v12;
  ((void (*)(unint64_t, unint64_t, uint64_t))v117)(v99, v100, v115);
  v101 = (_BYTE *)(v99 + v10);
  *v101 = *(_BYTE *)(v100 + v10);
  v101[1] = *(_BYTE *)(v100 + v10 + 1);
  v101[2] = *(_BYTE *)(v100 + v10 + 2);
  v102 = (v116 + v99) & ~v12;
  v103 = v10 + 3 + v12;
  v104 = (v116 + v100) & ~v12;
  ((void (*)(unint64_t, unint64_t, uint64_t))v117)(v102, v104, v115);
  v105 = (_BYTE *)(v102 + v10);
  *v105 = *(_BYTE *)(v104 + v10);
  v105[1] = *(_BYTE *)(v104 + v10 + 1);
  v105[2] = *(_BYTE *)(v104 + v10 + 2);
  v106 = (v103 + v102) & ~v12;
  v107 = (v103 + v104) & ~v12;
  ((void (*)(unint64_t, unint64_t, uint64_t))v117)(v106, v107, v115);
  v108 = (_BYTE *)(v106 + v10);
  *v108 = *(_BYTE *)(v107 + v10);
  v108[1] = *(_BYTE *)(v107 + v10 + 1);
  v108[2] = *(_BYTE *)(v107 + v10 + 2);
  return v114;
}

uint64_t sub_1000BFF40(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  void (*v7)(void);
  uint64_t v8;
  void (*v9)(void);
  uint64_t v10;
  _BYTE *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _BYTE *v17;
  uint64_t v18;
  uint64_t v19;
  _BYTE *v20;
  uint64_t v21;
  uint64_t v22;
  _BYTE *v23;
  uint64_t v24;
  uint64_t v25;
  void (*v26)(void);
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  _BYTE *v31;
  _BYTE *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  __n128 v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  _BYTE *v45;
  unint64_t v46;
  unint64_t v47;
  _BYTE *v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  _BYTE *v55;
  unint64_t v56;
  unint64_t v57;
  _BYTE *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  _BYTE *v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  _BYTE *v83;
  uint64_t v84;
  uint64_t v85;
  unint64_t v86;
  unint64_t v87;
  uint64_t v88;
  unint64_t v89;
  uint64_t v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  uint64_t v97;
  unint64_t v98;
  uint64_t v99;
  unint64_t v100;
  _QWORD *v101;
  _QWORD *v102;
  uint64_t v103;
  uint64_t v104;
  unint64_t v105;
  unint64_t v106;
  uint64_t v107;
  unint64_t v108;
  unint64_t v109;
  _BYTE *v110;
  unint64_t v111;
  uint64_t v112;
  unint64_t v113;
  _BYTE *v114;
  unint64_t v115;
  unint64_t v116;
  _BYTE *v117;
  unint64_t v119;
  uint64_t v120;
  uint64_t v121;
  unint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  void (*v126)(void);

  v5 = *(_QWORD *)(a3 + 16);
  v6 = *(_QWORD *)(v5 - 8);
  v7 = *(void (**)(void))(v6 + 24);
  v8 = v5;
  v7();
  v9 = v7;
  v10 = *(_QWORD *)(v6 + 64);
  v11 = (_BYTE *)(v10 + a1);
  v123 = a1;
  *v11 = *(_BYTE *)(v10 + a2);
  v11[1] = *(_BYTE *)(v10 + a2 + 1);
  v11[2] = *(_BYTE *)(v10 + a2 + 2);
  v12 = *(unsigned __int8 *)(v6 + 80);
  v13 = v10 + 3 + v12;
  v14 = (v13 + a1) & ~v12;
  v15 = (v13 + a2) & ~v12;
  v16 = v8;
  ((void (*)(uint64_t, uint64_t, uint64_t))v9)(v14, v15, v8);
  v17 = (_BYTE *)(v14 + v10);
  *v17 = *(_BYTE *)(v15 + v10);
  v17[1] = *(_BYTE *)(v15 + v10 + 1);
  v17[2] = *(_BYTE *)(v15 + v10 + 2);
  v18 = (v13 + v14) & ~v12;
  v19 = (v13 + v15) & ~v12;
  ((void (*)(uint64_t, uint64_t, uint64_t))v9)(v18, v19, v8);
  v20 = (_BYTE *)(v18 + v10);
  *v20 = *(_BYTE *)(v19 + v10);
  v20[1] = *(_BYTE *)(v19 + v10 + 1);
  v20[2] = *(_BYTE *)(v19 + v10 + 2);
  v125 = v13;
  v21 = (v13 + v18) & ~v12;
  v22 = (v13 + v19) & ~v12;
  ((void (*)(uint64_t, uint64_t, uint64_t))v9)(v21, v22, v8);
  v23 = (_BYTE *)(v21 + v10);
  *v23 = *(_BYTE *)(v22 + v10);
  v23[1] = *(_BYTE *)(v22 + v10 + 1);
  v23[2] = *(_BYTE *)(v22 + v10 + 2);
  v120 = (v12 | 3) + v10 + 3;
  v24 = (v120 + v21) & ~(v12 | 3);
  v25 = (v120 + v22) & ~(v12 | 3);
  ((void (*)(uint64_t, uint64_t, uint64_t))v9)(v24, v25, v8);
  v26 = v9;
  v126 = v9;
  *(_BYTE *)(v24 + v10) = *(_BYTE *)(v25 + v10);
  v27 = (v24 + v10) & 0xFFFFFFFFFFFFFFFCLL;
  v28 = (v25 + v10) & 0xFFFFFFFFFFFFFFFCLL;
  *(_DWORD *)(v27 + 4) = *(_DWORD *)(v28 + 4);
  *(_BYTE *)(v27 + 8) = *(_BYTE *)(v28 + 8);
  v119 = (v10 & 0xFFFFFFFFFFFFFFFCLL) + 9;
  v29 = v12 | 7;
  v30 = (v12 | 7) + v119;
  v31 = (_BYTE *)((v30 + v24) & ~(v12 | 7));
  v32 = (_BYTE *)((v30 + v25) & ~(v12 | 7));
  *v31 = *v32;
  v33 = (v12 | 7) + 1;
  v34 = (unint64_t)&v31[v33] & ~(v12 | 7);
  v35 = (unint64_t)&v32[v33] & ~(v12 | 7);
  ((void (*)(uint64_t, uint64_t, uint64_t))v26)(v34, v35, v16);
  v36 = v35 + v10;
  *(_BYTE *)(v34 + v10) = *(_BYTE *)(v35 + v10);
  v37 = (v34 + v10) & 0xFFFFFFFFFFFFFFF8;
  v38 = v36 & 0xFFFFFFFFFFFFFFF8;
  *(_QWORD *)(v37 + 8) = *(_QWORD *)((v36 & 0xFFFFFFFFFFFFFFF8) + 8);
  v39 = *(_QWORD *)((v36 & 0xFFFFFFFFFFFFFFF8) + 16);
  v40 = *(_QWORD *)(v37 + 16);
  *(_QWORD *)(v37 + 16) = v39;
  swift_bridgeObjectRetain(v39);
  v41 = swift_bridgeObjectRelease(v40);
  *(_BYTE *)(v37 + 24) = *(_BYTE *)(v38 + 24);
  v122 = (v10 & 0xFFFFFFFFFFFFFFF8) + 25;
  v42 = v122 + v12 + (v33 & ~(v12 | 7));
  v43 = (unint64_t)&v31[v42] & ~v12;
  v44 = (unint64_t)&v32[v42] & ~v12;
  ((void (*)(unint64_t, unint64_t, uint64_t, __n128))v126)(v43, v44, v16, v41);
  v45 = (_BYTE *)(v43 + v10);
  *v45 = *(_BYTE *)(v44 + v10);
  v45[1] = *(_BYTE *)(v44 + v10 + 1);
  v45[2] = *(_BYTE *)(v44 + v10 + 2);
  v46 = (v125 + v43) & ~v12;
  v47 = (v125 + v44) & ~v12;
  ((void (*)(unint64_t, unint64_t, uint64_t))v126)(v46, v47, v16);
  v48 = (_BYTE *)(v46 + v10);
  *v48 = *(_BYTE *)(v47 + v10);
  v48[1] = *(_BYTE *)(v47 + v10 + 1);
  v48[2] = *(_BYTE *)(v47 + v10 + 2);
  v49 = (v120 + v46) & ~(v12 | 3);
  v50 = (v120 + v47) & ~(v12 | 3);
  ((void (*)(uint64_t, uint64_t, uint64_t))v126)(v49, v50, v16);
  *(_BYTE *)(v49 + v10) = *(_BYTE *)(v50 + v10);
  v51 = (v49 + v10) & 0xFFFFFFFFFFFFFFFCLL;
  v52 = (v50 + v10) & 0xFFFFFFFFFFFFFFFCLL;
  *(_DWORD *)(v51 + 4) = *(_DWORD *)(v52 + 4);
  *(_BYTE *)(v51 + 8) = *(_BYTE *)(v52 + 8);
  v53 = (v119 + v12 + v49) & ~v12;
  v54 = (v119 + v12 + v50) & ~v12;
  ((void (*)(unint64_t, unint64_t, uint64_t))v126)(v53, v54, v16);
  v55 = (_BYTE *)(v53 + v10);
  *v55 = *(_BYTE *)(v54 + v10);
  v55[1] = *(_BYTE *)(v54 + v10 + 1);
  v55[2] = *(_BYTE *)(v54 + v10 + 2);
  v56 = (v125 + v53) & ~v12;
  v57 = (v125 + v54) & ~v12;
  ((void (*)(unint64_t, unint64_t, uint64_t))v126)(v56, v57, v16);
  v58 = (_BYTE *)(v56 + v10);
  *v58 = *(_BYTE *)(v57 + v10);
  v58[1] = *(_BYTE *)(v57 + v10 + 1);
  v58[2] = *(_BYTE *)(v57 + v10 + 2);
  v59 = (v12 | 7) + v10 + 3;
  v60 = (v29 + v10 + 3 + v56) & ~v29;
  v61 = (v29 + v10 + 3 + v57) & ~v29;
  ((void (*)(uint64_t, uint64_t, uint64_t))v126)(v60, v61, v16);
  *(_BYTE *)(v60 + v10) = *(_BYTE *)(v61 + v10);
  v62 = (v60 + v10) & 0xFFFFFFFFFFFFFFF8;
  v63 = (v61 + v10) & 0xFFFFFFFFFFFFFFF8;
  *(_QWORD *)(v62 + 8) = *(_QWORD *)(v63 + 8);
  *(_BYTE *)(v62 + 16) = *(_BYTE *)(v63 + 16);
  v64 = (v10 & 0xFFFFFFFFFFFFFFF8) + 17;
  v65 = (v12 | 7) + v64;
  v66 = (v65 + v60) & ~(v12 | 7);
  v67 = (v65 + v61) & ~(v12 | 7);
  ((void (*)(uint64_t, uint64_t, uint64_t))v126)(v66, v67, v16);
  *(_BYTE *)(v66 + v10) = *(_BYTE *)(v67 + v10);
  v68 = (v66 + v10) & 0xFFFFFFFFFFFFFFF8;
  v69 = (v67 + v10) & 0xFFFFFFFFFFFFFFF8;
  *(_QWORD *)(v68 + 8) = *(_QWORD *)(v69 + 8);
  *(_BYTE *)(v68 + 16) = *(_BYTE *)(v69 + 16);
  v121 = v64 + v12;
  v70 = (v64 + v12 + v66) & ~v12;
  v71 = (v64 + v12 + v67) & ~v12;
  v124 = v16;
  ((void (*)(unint64_t, unint64_t, uint64_t))v126)(v70, v71, v16);
  v72 = (_BYTE *)(v70 + v10);
  *v72 = *(_BYTE *)(v71 + v10);
  v72[1] = *(_BYTE *)(v71 + v10 + 1);
  v72[2] = *(_BYTE *)(v71 + v10 + 2);
  v73 = (v59 + v70) & ~(v12 | 7);
  v74 = (v59 + v71) & ~(v12 | 7);
  ((void (*)(uint64_t, uint64_t, uint64_t))v126)(v73, v74, v16);
  *(_BYTE *)(v73 + v10) = *(_BYTE *)(v74 + v10);
  v75 = (v73 + v10) & 0xFFFFFFFFFFFFFFF8;
  v76 = (v74 + v10) & 0xFFFFFFFFFFFFFFF8;
  v77 = *(_QWORD *)(v76 + 8);
  v78 = *(_QWORD *)(v76 + 16);
  sub_100031FEC(v77, v78);
  v79 = *(_QWORD *)(v75 + 8);
  v80 = *(_QWORD *)(v75 + 16);
  *(_QWORD *)(v75 + 8) = v77;
  *(_QWORD *)(v75 + 16) = v78;
  sub_10000E614(v79, v80);
  *(_BYTE *)(v75 + 24) = *(_BYTE *)(v76 + 24);
  v81 = (v122 + v12 + v73) & ~v12;
  v82 = (v122 + v12 + v74) & ~v12;
  ((void (*)(unint64_t, unint64_t, uint64_t))v126)(v81, v82, v124);
  v83 = (_BYTE *)(v81 + v10);
  *v83 = *(_BYTE *)(v82 + v10);
  v83[1] = *(_BYTE *)(v82 + v10 + 1);
  v83[2] = *(_BYTE *)(v82 + v10 + 2);
  v84 = (v59 + v81) & ~(v12 | 7);
  v85 = (v59 + v82) & ~(v12 | 7);
  ((void (*)(uint64_t, uint64_t, uint64_t))v126)(v84, v85, v124);
  *(_BYTE *)(v84 + v10) = *(_BYTE *)(v85 + v10);
  v86 = (v84 + v10) & 0xFFFFFFFFFFFFFFF8;
  v87 = (v85 + v10) & 0xFFFFFFFFFFFFFFF8;
  v88 = *(_QWORD *)(v87 + 8);
  v89 = *(_QWORD *)(v87 + 16);
  sub_100031FEC(v88, v89);
  v90 = *(_QWORD *)(v86 + 8);
  v91 = *(_QWORD *)(v86 + 16);
  *(_QWORD *)(v86 + 8) = v88;
  *(_QWORD *)(v86 + 16) = v89;
  sub_10000E614(v90, v91);
  *(_BYTE *)(v86 + 24) = *(_BYTE *)(v87 + 24);
  v92 = (v12 | 7) + v122;
  v93 = (v29 + v122 + v84) & ~v29;
  v94 = (v29 + v122 + v85) & ~v29;
  ((void (*)(unint64_t, unint64_t, uint64_t))v126)(v93, v94, v124);
  *(_BYTE *)(v93 + v10) = *(_BYTE *)(v94 + v10);
  v95 = (v93 + v10) & 0xFFFFFFFFFFFFFFF8;
  v96 = (v94 + v10) & 0xFFFFFFFFFFFFFFF8;
  v97 = *(_QWORD *)(v96 + 8);
  v98 = *(_QWORD *)(v96 + 16);
  sub_100031FEC(v97, v98);
  v99 = *(_QWORD *)(v95 + 8);
  v100 = *(_QWORD *)(v95 + 16);
  *(_QWORD *)(v95 + 8) = v97;
  *(_QWORD *)(v95 + 16) = v98;
  sub_10000E614(v99, v100);
  *(_BYTE *)(v95 + 24) = *(_BYTE *)(v96 + 24);
  v101 = (_QWORD *)((v92 + v93) & ~(v12 | 7));
  v102 = (_QWORD *)((v92 + v94) & ~(v12 | 7));
  *v101 = *v102;
  v103 = ((unint64_t)v101 + v12 + 8) & ~(v12 | 7);
  v104 = ((unint64_t)v102 + v12 + 8) & ~(v12 | 7);
  ((void (*)(unint64_t, unint64_t, uint64_t))v126)(((unint64_t)v101 + v12 + 8) & ~v29, ((unint64_t)v102 + v12 + 8) & ~v29, v124);
  *(_BYTE *)(v103 + v10) = *(_BYTE *)(v104 + v10);
  v105 = (v103 + v10) & 0xFFFFFFFFFFFFFFF8;
  v106 = (v104 + v10) & 0xFFFFFFFFFFFFFFF8;
  *(_QWORD *)(v105 + 8) = *(_QWORD *)(v106 + 8);
  *(_BYTE *)(v105 + 16) = *(_BYTE *)(v106 + 16);
  v107 = v121 + ((v12 + 8) & ~(v12 | 7));
  v108 = ((unint64_t)v101 + v107) & ~v12;
  v109 = ((unint64_t)v102 + v107) & ~v12;
  ((void (*)(unint64_t, unint64_t, uint64_t))v126)(v108, v109, v124);
  v110 = (_BYTE *)(v108 + v10);
  *v110 = *(_BYTE *)(v109 + v10);
  v110[1] = *(_BYTE *)(v109 + v10 + 1);
  v110[2] = *(_BYTE *)(v109 + v10 + 2);
  v111 = (v125 + v108) & ~v12;
  v112 = v10 + 3 + v12;
  v113 = (v125 + v109) & ~v12;
  ((void (*)(unint64_t, unint64_t, uint64_t))v126)(v111, v113, v124);
  v114 = (_BYTE *)(v111 + v10);
  *v114 = *(_BYTE *)(v113 + v10);
  v114[1] = *(_BYTE *)(v113 + v10 + 1);
  v114[2] = *(_BYTE *)(v113 + v10 + 2);
  v115 = (v112 + v111) & ~v12;
  v116 = (v112 + v113) & ~v12;
  ((void (*)(unint64_t, unint64_t, uint64_t))v126)(v115, v116, v124);
  v117 = (_BYTE *)(v115 + v10);
  *v117 = *(_BYTE *)(v116 + v10);
  v117[1] = *(_BYTE *)(v116 + v10 + 1);
  v117[2] = *(_BYTE *)(v116 + v10 + 2);
  return v123;
}

uint64_t sub_1000C06B0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  void (*v7)(uint64_t, uint64_t, uint64_t);
  void (*v8)(uint64_t, uint64_t, uint64_t);
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _BYTE *v15;
  uint64_t v16;
  uint64_t v17;
  _BYTE *v18;
  uint64_t v19;
  uint64_t v20;
  _BYTE *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, uint64_t, uint64_t);
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  _BYTE *v29;
  _BYTE *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void (*v35)(unint64_t, unint64_t, uint64_t);
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  _BYTE *v41;
  unint64_t v42;
  unint64_t v43;
  _BYTE *v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  _BYTE *v51;
  unint64_t v52;
  unint64_t v53;
  _BYTE *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  _BYTE *v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  _BYTE *v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  unint64_t v84;
  _QWORD *v85;
  _QWORD *v86;
  uint64_t v87;
  uint64_t v88;
  unint64_t v89;
  unint64_t v90;
  uint64_t v91;
  unint64_t v92;
  unint64_t v93;
  _BYTE *v94;
  unint64_t v95;
  unint64_t v96;
  _BYTE *v97;
  unint64_t v98;
  unint64_t v99;
  _BYTE *v100;
  uint64_t v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;

  v5 = *(_QWORD *)(a3 + 16);
  v6 = *(_QWORD *)(v5 - 8);
  v7 = *(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 32);
  v7(a1, a2, v5);
  v8 = v7;
  v9 = *(_QWORD *)(v6 + 64);
  v10 = (_BYTE *)(v9 + a1);
  v106 = a1;
  *v10 = *(_BYTE *)(v9 + a2);
  v10[1] = *(_BYTE *)(v9 + a2 + 1);
  v10[2] = *(_BYTE *)(v9 + a2 + 2);
  v11 = *(unsigned __int8 *)(v6 + 80);
  v12 = v9 + 3 + v11;
  v13 = (v12 + a1) & ~v11;
  v14 = (v12 + a2) & ~v11;
  v8(v13, v14, v5);
  v15 = (_BYTE *)(v13 + v9);
  *v15 = *(_BYTE *)(v14 + v9);
  v15[1] = *(_BYTE *)(v14 + v9 + 1);
  v15[2] = *(_BYTE *)(v14 + v9 + 2);
  v16 = (v12 + v13) & ~v11;
  v17 = (v12 + v14) & ~v11;
  v8(v16, v17, v5);
  v18 = (_BYTE *)(v16 + v9);
  *v18 = *(_BYTE *)(v17 + v9);
  v18[1] = *(_BYTE *)(v17 + v9 + 1);
  v18[2] = *(_BYTE *)(v17 + v9 + 2);
  v19 = (v12 + v16) & ~v11;
  v20 = (v12 + v17) & ~v11;
  v8(v19, v20, v5);
  v21 = (_BYTE *)(v19 + v9);
  *v21 = *(_BYTE *)(v20 + v9);
  v21[1] = *(_BYTE *)(v20 + v9 + 1);
  v21[2] = *(_BYTE *)(v20 + v9 + 2);
  v104 = (v11 | 3) + v9 + 3;
  v22 = (v104 + v19) & ~(v11 | 3);
  v23 = (v104 + v20) & ~(v11 | 3);
  v102 = v5;
  v8(v22, v23, v5);
  v24 = v8;
  *(_BYTE *)(v22 + v9) = *(_BYTE *)(v23 + v9);
  v25 = (v22 + v9) & 0xFFFFFFFFFFFFFFFCLL;
  v26 = (v23 + v9) & 0xFFFFFFFFFFFFFFFCLL;
  *(_DWORD *)(v25 + 4) = *(_DWORD *)(v26 + 4);
  *(_BYTE *)(v25 + 8) = *(_BYTE *)(v26 + 8);
  v103 = (v9 & 0xFFFFFFFFFFFFFFFCLL) + 9;
  v27 = v11 | 7;
  v28 = (v11 | 7) + v103;
  v29 = (_BYTE *)((v28 + v22) & ~(v11 | 7));
  v30 = (_BYTE *)((v28 + v23) & ~(v11 | 7));
  *v29 = *v30;
  v31 = (v11 | 7) + 1;
  v32 = (unint64_t)&v29[v31] & ~(v11 | 7);
  v33 = (unint64_t)&v30[v31] & ~(v11 | 7);
  v34 = v5;
  v35 = (void (*)(unint64_t, unint64_t, uint64_t))v24;
  v24(v32, v33, v34);
  *(_BYTE *)(v32 + v9) = *(_BYTE *)(v33 + v9);
  v36 = (v32 + v9) & 0xFFFFFFFFFFFFFFF8;
  v37 = (v33 + v9) & 0xFFFFFFFFFFFFFFF8;
  *(_OWORD *)(v36 + 8) = *(_OWORD *)(v37 + 8);
  *(_BYTE *)(v36 + 24) = *(_BYTE *)(v37 + 24);
  v105 = (v9 & 0xFFFFFFFFFFFFFFF8) + 25;
  v38 = v105 + v11 + (v31 & ~(v11 | 7));
  v39 = (unint64_t)&v29[v38] & ~v11;
  v40 = (unint64_t)&v30[v38] & ~v11;
  v35(v39, v40, v102);
  v41 = (_BYTE *)(v39 + v9);
  *v41 = *(_BYTE *)(v40 + v9);
  v41[1] = *(_BYTE *)(v40 + v9 + 1);
  v41[2] = *(_BYTE *)(v40 + v9 + 2);
  v42 = (v12 + v39) & ~v11;
  v43 = (v12 + v40) & ~v11;
  v35(v42, v43, v102);
  v44 = (_BYTE *)(v42 + v9);
  *v44 = *(_BYTE *)(v43 + v9);
  v44[1] = *(_BYTE *)(v43 + v9 + 1);
  v44[2] = *(_BYTE *)(v43 + v9 + 2);
  v45 = (v104 + v42) & ~(v11 | 3);
  v46 = (v104 + v43) & ~(v11 | 3);
  v35(v45, v46, v102);
  *(_BYTE *)(v45 + v9) = *(_BYTE *)(v46 + v9);
  v47 = (v45 + v9) & 0xFFFFFFFFFFFFFFFCLL;
  v48 = (v46 + v9) & 0xFFFFFFFFFFFFFFFCLL;
  *(_DWORD *)(v47 + 4) = *(_DWORD *)(v48 + 4);
  *(_BYTE *)(v47 + 8) = *(_BYTE *)(v48 + 8);
  v49 = (v103 + v11 + v45) & ~v11;
  v50 = (v103 + v11 + v46) & ~v11;
  v35(v49, v50, v102);
  v51 = (_BYTE *)(v49 + v9);
  *v51 = *(_BYTE *)(v50 + v9);
  v51[1] = *(_BYTE *)(v50 + v9 + 1);
  v51[2] = *(_BYTE *)(v50 + v9 + 2);
  v52 = (v12 + v49) & ~v11;
  v53 = (v12 + v50) & ~v11;
  v35(v52, v53, v102);
  v54 = (_BYTE *)(v52 + v9);
  *v54 = *(_BYTE *)(v53 + v9);
  v54[1] = *(_BYTE *)(v53 + v9 + 1);
  v54[2] = *(_BYTE *)(v53 + v9 + 2);
  v55 = (v11 | 7) + v9 + 3;
  v56 = (v27 + v9 + 3 + v52) & ~v27;
  v57 = (v27 + v9 + 3 + v53) & ~v27;
  v35(v56, v57, v102);
  *(_BYTE *)(v56 + v9) = *(_BYTE *)(v57 + v9);
  v58 = (v56 + v9) & 0xFFFFFFFFFFFFFFF8;
  v59 = (v57 + v9) & 0xFFFFFFFFFFFFFFF8;
  *(_QWORD *)(v58 + 8) = *(_QWORD *)(v59 + 8);
  *(_BYTE *)(v58 + 16) = *(_BYTE *)(v59 + 16);
  v60 = (v9 & 0xFFFFFFFFFFFFFFF8) + 17;
  v61 = (v11 | 7) + v60;
  v62 = (v61 + v56) & ~(v11 | 7);
  v63 = (v61 + v57) & ~(v11 | 7);
  v35(v62, v63, v102);
  *(_BYTE *)(v62 + v9) = *(_BYTE *)(v63 + v9);
  v64 = (v62 + v9) & 0xFFFFFFFFFFFFFFF8;
  v65 = (v63 + v9) & 0xFFFFFFFFFFFFFFF8;
  *(_QWORD *)(v64 + 8) = *(_QWORD *)(v65 + 8);
  *(_BYTE *)(v64 + 16) = *(_BYTE *)(v65 + 16);
  v66 = (v60 + v11 + v62) & ~v11;
  v67 = (v60 + v11 + v63) & ~v11;
  v35(v66, v67, v102);
  v68 = (_BYTE *)(v66 + v9);
  *v68 = *(_BYTE *)(v67 + v9);
  v68[1] = *(_BYTE *)(v67 + v9 + 1);
  v68[2] = *(_BYTE *)(v67 + v9 + 2);
  v69 = (v55 + v66) & ~(v11 | 7);
  v70 = (v55 + v67) & ~(v11 | 7);
  v35(v69, v70, v102);
  *(_BYTE *)(v69 + v9) = *(_BYTE *)(v70 + v9);
  v71 = (v69 + v9) & 0xFFFFFFFFFFFFFFF8;
  v72 = (v70 + v9) & 0xFFFFFFFFFFFFFFF8;
  *(_OWORD *)(v71 + 8) = *(_OWORD *)(v72 + 8);
  *(_BYTE *)(v71 + 24) = *(_BYTE *)(v72 + 24);
  v73 = (v105 + v11 + v69) & ~v11;
  v74 = (v105 + v11 + v70) & ~v11;
  v35(v73, v74, v102);
  v75 = (_BYTE *)(v73 + v9);
  *v75 = *(_BYTE *)(v74 + v9);
  v75[1] = *(_BYTE *)(v74 + v9 + 1);
  v75[2] = *(_BYTE *)(v74 + v9 + 2);
  v76 = (v55 + v73) & ~(v11 | 7);
  v77 = (v55 + v74) & ~(v11 | 7);
  v35(v76, v77, v102);
  *(_BYTE *)(v76 + v9) = *(_BYTE *)(v77 + v9);
  v78 = (v76 + v9) & 0xFFFFFFFFFFFFFFF8;
  v79 = (v77 + v9) & 0xFFFFFFFFFFFFFFF8;
  *(_OWORD *)(v78 + 8) = *(_OWORD *)(v79 + 8);
  *(_BYTE *)(v78 + 24) = *(_BYTE *)(v79 + 24);
  v80 = (v11 | 7) + v105;
  v81 = (v27 + v105 + v76) & ~v27;
  v82 = (v27 + v105 + v77) & ~v27;
  v35(v81, v82, v102);
  *(_BYTE *)(v81 + v9) = *(_BYTE *)(v82 + v9);
  v83 = (v81 + v9) & 0xFFFFFFFFFFFFFFF8;
  v84 = (v82 + v9) & 0xFFFFFFFFFFFFFFF8;
  *(_OWORD *)(v83 + 8) = *(_OWORD *)(v84 + 8);
  *(_BYTE *)(v83 + 24) = *(_BYTE *)(v84 + 24);
  v85 = (_QWORD *)((v80 + v81) & ~(v11 | 7));
  v86 = (_QWORD *)((v80 + v82) & ~(v11 | 7));
  *v85 = *v86;
  v87 = ((unint64_t)v85 + v11 + 8) & ~(v11 | 7);
  v88 = ((unint64_t)v86 + v11 + 8) & ~(v11 | 7);
  v35(((unint64_t)v85 + v11 + 8) & ~v27, ((unint64_t)v86 + v11 + 8) & ~v27, v102);
  *(_BYTE *)(v87 + v9) = *(_BYTE *)(v88 + v9);
  v89 = (v87 + v9) & 0xFFFFFFFFFFFFFFF8;
  v90 = (v88 + v9) & 0xFFFFFFFFFFFFFFF8;
  *(_QWORD *)(v89 + 8) = *(_QWORD *)(v90 + 8);
  *(_BYTE *)(v89 + 16) = *(_BYTE *)(v90 + 16);
  v91 = v60 + v11 + ((v11 + 8) & ~(v11 | 7));
  v92 = ((unint64_t)v85 + v91) & ~v11;
  v93 = ((unint64_t)v86 + v91) & ~v11;
  v35(v92, v93, v102);
  v94 = (_BYTE *)(v92 + v9);
  *v94 = *(_BYTE *)(v93 + v9);
  v94[1] = *(_BYTE *)(v93 + v9 + 1);
  v94[2] = *(_BYTE *)(v93 + v9 + 2);
  v95 = (v12 + v92) & ~v11;
  v96 = (v12 + v93) & ~v11;
  v35(v95, v96, v102);
  v97 = (_BYTE *)(v95 + v9);
  *v97 = *(_BYTE *)(v96 + v9);
  v97[1] = *(_BYTE *)(v96 + v9 + 1);
  v97[2] = *(_BYTE *)(v96 + v9 + 2);
  v98 = (v12 + v95) & ~v11;
  v99 = (v12 + v96) & ~v11;
  v35(v98, v99, v102);
  v100 = (_BYTE *)(v98 + v9);
  *v100 = *(_BYTE *)(v99 + v9);
  v100[1] = *(_BYTE *)(v99 + v9 + 1);
  v100[2] = *(_BYTE *)(v99 + v9 + 2);
  return v106;
}

uint64_t sub_1000C0DBC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  void (*v7)(uint64_t, uint64_t, uint64_t);
  void (*v8)(uint64_t, uint64_t, uint64_t);
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _BYTE *v15;
  uint64_t v16;
  uint64_t v17;
  _BYTE *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _BYTE *v22;
  uint64_t v23;
  uint64_t v24;
  void (*v25)(uint64_t, uint64_t, uint64_t);
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  _BYTE *v30;
  _BYTE *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t v37;
  __n128 v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  void (*v42)(unint64_t, unint64_t, uint64_t);
  _BYTE *v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  void (*v48)(unint64_t, unint64_t, uint64_t);
  _BYTE *v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  _BYTE *v56;
  unint64_t v57;
  unint64_t v58;
  _BYTE *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  _BYTE *v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  unint64_t v77;
  uint64_t v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  _BYTE *v82;
  uint64_t v83;
  uint64_t v84;
  unint64_t v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  uint64_t v94;
  unint64_t v95;
  _QWORD *v96;
  _QWORD *v97;
  uint64_t v98;
  uint64_t v99;
  unint64_t v100;
  unint64_t v101;
  uint64_t v102;
  unint64_t v103;
  unint64_t v104;
  _BYTE *v105;
  unint64_t v106;
  uint64_t v107;
  unint64_t v108;
  _BYTE *v109;
  unint64_t v110;
  unint64_t v111;
  _BYTE *v112;
  unint64_t v114;
  uint64_t v115;
  uint64_t v116;
  unint64_t v117;
  uint64_t v118;
  uint64_t v119;

  v5 = *(_QWORD *)(a3 + 16);
  v6 = *(_QWORD *)(v5 - 8);
  v7 = *(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 40);
  v7(a1, a2, v5);
  v8 = v7;
  v9 = *(_QWORD *)(v6 + 64);
  v10 = (_BYTE *)(v9 + a1);
  v118 = a1;
  *v10 = *(_BYTE *)(v9 + a2);
  v10[1] = *(_BYTE *)(v9 + a2 + 1);
  v10[2] = *(_BYTE *)(v9 + a2 + 2);
  v11 = *(unsigned __int8 *)(v6 + 80);
  v12 = v9 + 3 + v11;
  v13 = (v12 + a1) & ~v11;
  v14 = (v12 + a2) & ~v11;
  v8(v13, v14, v5);
  v15 = (_BYTE *)(v13 + v9);
  *v15 = *(_BYTE *)(v14 + v9);
  v15[1] = *(_BYTE *)(v14 + v9 + 1);
  v15[2] = *(_BYTE *)(v14 + v9 + 2);
  v16 = (v12 + v13) & ~v11;
  v17 = (v12 + v14) & ~v11;
  v8(v16, v17, v5);
  v18 = (_BYTE *)(v16 + v9);
  *v18 = *(_BYTE *)(v17 + v9);
  v18[1] = *(_BYTE *)(v17 + v9 + 1);
  v18[2] = *(_BYTE *)(v17 + v9 + 2);
  v119 = v12;
  v19 = (v12 + v16) & ~v11;
  v20 = (v12 + v17) & ~v11;
  v21 = v5;
  v8(v19, v20, v5);
  v22 = (_BYTE *)(v19 + v9);
  *v22 = *(_BYTE *)(v20 + v9);
  v22[1] = *(_BYTE *)(v20 + v9 + 1);
  v22[2] = *(_BYTE *)(v20 + v9 + 2);
  v115 = (v11 | 3) + v9 + 3;
  v23 = (v115 + v19) & ~(v11 | 3);
  v24 = (v115 + v20) & ~(v11 | 3);
  v8(v23, v24, v5);
  v25 = v8;
  *(_BYTE *)(v23 + v9) = *(_BYTE *)(v24 + v9);
  v26 = (v23 + v9) & 0xFFFFFFFFFFFFFFFCLL;
  v27 = (v24 + v9) & 0xFFFFFFFFFFFFFFFCLL;
  *(_DWORD *)(v26 + 4) = *(_DWORD *)(v27 + 4);
  *(_BYTE *)(v26 + 8) = *(_BYTE *)(v27 + 8);
  v114 = (v9 & 0xFFFFFFFFFFFFFFFCLL) + 9;
  v28 = v11 | 7;
  v29 = (v11 | 7) + v114;
  v30 = (_BYTE *)((v29 + v23) & ~(v11 | 7));
  v31 = (_BYTE *)((v29 + v24) & ~(v11 | 7));
  *v30 = *v31;
  v32 = (v11 | 7) + 1;
  v33 = (unint64_t)&v30[v32] & ~(v11 | 7);
  v34 = (unint64_t)&v31[v32] & ~(v11 | 7);
  v25(v33, v34, v21);
  *(_BYTE *)(v33 + v9) = *(_BYTE *)(v34 + v9);
  v35 = (v33 + v9) & 0xFFFFFFFFFFFFFFF8;
  v36 = (v34 + v9) & 0xFFFFFFFFFFFFFFF8;
  *(_QWORD *)(v35 + 8) = *(_QWORD *)(v36 + 8);
  v37 = *(_QWORD *)(v35 + 16);
  *(_QWORD *)(v35 + 16) = *(_QWORD *)(v36 + 16);
  v38 = swift_bridgeObjectRelease(v37);
  *(_BYTE *)(v35 + 24) = *(_BYTE *)(v36 + 24);
  v117 = (v9 & 0xFFFFFFFFFFFFFFF8) + 25;
  v39 = v117 + v11 + (v32 & ~(v11 | 7));
  v40 = (unint64_t)&v30[v39] & ~v11;
  v41 = (unint64_t)&v31[v39] & ~v11;
  v42 = (void (*)(unint64_t, unint64_t, uint64_t))v25;
  ((void (*)(unint64_t, unint64_t, uint64_t, __n128))v25)(v40, v41, v21, v38);
  v43 = (_BYTE *)(v40 + v9);
  *v43 = *(_BYTE *)(v41 + v9);
  v43[1] = *(_BYTE *)(v41 + v9 + 1);
  v43[2] = *(_BYTE *)(v41 + v9 + 2);
  v44 = (v119 + v40) & ~v11;
  v45 = v9 + 3 + v11;
  v46 = (v119 + v41) & ~v11;
  v47 = v21;
  v42(v44, v46, v21);
  v48 = v42;
  v49 = (_BYTE *)(v44 + v9);
  *v49 = *(_BYTE *)(v46 + v9);
  v49[1] = *(_BYTE *)(v46 + v9 + 1);
  v49[2] = *(_BYTE *)(v46 + v9 + 2);
  v50 = (v115 + v44) & ~(v11 | 3);
  v51 = (v115 + v46) & ~(v11 | 3);
  v42(v50, v51, v47);
  *(_BYTE *)(v50 + v9) = *(_BYTE *)(v51 + v9);
  v52 = (v50 + v9) & 0xFFFFFFFFFFFFFFFCLL;
  v53 = (v51 + v9) & 0xFFFFFFFFFFFFFFFCLL;
  *(_DWORD *)(v52 + 4) = *(_DWORD *)(v53 + 4);
  *(_BYTE *)(v52 + 8) = *(_BYTE *)(v53 + 8);
  v54 = (v114 + v11 + v50) & ~v11;
  v55 = (v114 + v11 + v51) & ~v11;
  v42(v54, v55, v47);
  v56 = (_BYTE *)(v54 + v9);
  *v56 = *(_BYTE *)(v55 + v9);
  v56[1] = *(_BYTE *)(v55 + v9 + 1);
  v56[2] = *(_BYTE *)(v55 + v9 + 2);
  v57 = (v45 + v54) & ~v11;
  v58 = (v45 + v55) & ~v11;
  v42(v57, v58, v47);
  v59 = (_BYTE *)(v57 + v9);
  *v59 = *(_BYTE *)(v58 + v9);
  v59[1] = *(_BYTE *)(v58 + v9 + 1);
  v59[2] = *(_BYTE *)(v58 + v9 + 2);
  v60 = (v11 | 7) + v9 + 3;
  v61 = (v28 + v9 + 3 + v57) & ~v28;
  v62 = (v28 + v9 + 3 + v58) & ~v28;
  v42(v61, v62, v47);
  *(_BYTE *)(v61 + v9) = *(_BYTE *)(v62 + v9);
  v63 = (v61 + v9) & 0xFFFFFFFFFFFFFFF8;
  v64 = (v62 + v9) & 0xFFFFFFFFFFFFFFF8;
  *(_QWORD *)(v63 + 8) = *(_QWORD *)(v64 + 8);
  *(_BYTE *)(v63 + 16) = *(_BYTE *)(v64 + 16);
  v65 = (v9 & 0xFFFFFFFFFFFFFFF8) + 17;
  v66 = (v11 | 7) + v65;
  v67 = (v66 + v61) & ~(v11 | 7);
  v68 = (v66 + v62) & ~(v11 | 7);
  v42(v67, v68, v47);
  *(_BYTE *)(v67 + v9) = *(_BYTE *)(v68 + v9);
  v69 = (v67 + v9) & 0xFFFFFFFFFFFFFFF8;
  v70 = (v68 + v9) & 0xFFFFFFFFFFFFFFF8;
  *(_QWORD *)(v69 + 8) = *(_QWORD *)(v70 + 8);
  *(_BYTE *)(v69 + 16) = *(_BYTE *)(v70 + 16);
  v116 = v65 + v11;
  v71 = (v65 + v11 + v67) & ~v11;
  v72 = (v65 + v11 + v68) & ~v11;
  v42(v71, v72, v47);
  v73 = (_BYTE *)(v71 + v9);
  *v73 = *(_BYTE *)(v72 + v9);
  v73[1] = *(_BYTE *)(v72 + v9 + 1);
  v73[2] = *(_BYTE *)(v72 + v9 + 2);
  v74 = (v60 + v71) & ~(v11 | 7);
  v75 = (v60 + v72) & ~(v11 | 7);
  v42(v74, v75, v47);
  *(_BYTE *)(v74 + v9) = *(_BYTE *)(v75 + v9);
  v76 = (v74 + v9) & 0xFFFFFFFFFFFFFFF8;
  v77 = (v75 + v9) & 0xFFFFFFFFFFFFFFF8;
  v78 = *(_QWORD *)(v76 + 8);
  v79 = *(_QWORD *)(v76 + 16);
  *(_OWORD *)(v76 + 8) = *(_OWORD *)(v77 + 8);
  sub_10000E614(v78, v79);
  *(_BYTE *)(v76 + 24) = *(_BYTE *)(v77 + 24);
  v80 = (v117 + v11 + v74) & ~v11;
  v81 = (v117 + v11 + v75) & ~v11;
  v48(v80, v81, v47);
  v82 = (_BYTE *)(v80 + v9);
  *v82 = *(_BYTE *)(v81 + v9);
  v82[1] = *(_BYTE *)(v81 + v9 + 1);
  v82[2] = *(_BYTE *)(v81 + v9 + 2);
  v83 = (v60 + v80) & ~(v11 | 7);
  v84 = (v60 + v81) & ~(v11 | 7);
  v48(v83, v84, v47);
  *(_BYTE *)(v83 + v9) = *(_BYTE *)(v84 + v9);
  v85 = (v83 + v9) & 0xFFFFFFFFFFFFFFF8;
  v86 = (v84 + v9) & 0xFFFFFFFFFFFFFFF8;
  v87 = *(_QWORD *)(v85 + 8);
  v88 = *(_QWORD *)(v85 + 16);
  *(_OWORD *)(v85 + 8) = *(_OWORD *)(v86 + 8);
  sub_10000E614(v87, v88);
  *(_BYTE *)(v85 + 24) = *(_BYTE *)(v86 + 24);
  v89 = (v11 | 7) + v117;
  v90 = (v28 + v117 + v83) & ~v28;
  v91 = (v28 + v117 + v84) & ~v28;
  v48(v90, v91, v47);
  *(_BYTE *)(v90 + v9) = *(_BYTE *)(v91 + v9);
  v92 = (v90 + v9) & 0xFFFFFFFFFFFFFFF8;
  v93 = (v91 + v9) & 0xFFFFFFFFFFFFFFF8;
  v94 = *(_QWORD *)(v92 + 8);
  v95 = *(_QWORD *)(v92 + 16);
  *(_OWORD *)(v92 + 8) = *(_OWORD *)(v93 + 8);
  sub_10000E614(v94, v95);
  *(_BYTE *)(v92 + 24) = *(_BYTE *)(v93 + 24);
  v96 = (_QWORD *)((v89 + v90) & ~(v11 | 7));
  v97 = (_QWORD *)((v89 + v91) & ~(v11 | 7));
  *v96 = *v97;
  v98 = ((unint64_t)v96 + v11 + 8) & ~(v11 | 7);
  v99 = ((unint64_t)v97 + v11 + 8) & ~(v11 | 7);
  v48(((unint64_t)v96 + v11 + 8) & ~v28, ((unint64_t)v97 + v11 + 8) & ~v28, v47);
  *(_BYTE *)(v98 + v9) = *(_BYTE *)(v99 + v9);
  v100 = (v98 + v9) & 0xFFFFFFFFFFFFFFF8;
  v101 = (v99 + v9) & 0xFFFFFFFFFFFFFFF8;
  *(_QWORD *)(v100 + 8) = *(_QWORD *)(v101 + 8);
  *(_BYTE *)(v100 + 16) = *(_BYTE *)(v101 + 16);
  v102 = v116 + ((v11 + 8) & ~(v11 | 7));
  v103 = ((unint64_t)v96 + v102) & ~v11;
  v104 = ((unint64_t)v97 + v102) & ~v11;
  v48(v103, v104, v47);
  v105 = (_BYTE *)(v103 + v9);
  *v105 = *(_BYTE *)(v104 + v9);
  v105[1] = *(_BYTE *)(v104 + v9 + 1);
  v105[2] = *(_BYTE *)(v104 + v9 + 2);
  v106 = (v119 + v103) & ~v11;
  v107 = v9 + 3 + v11;
  v108 = (v119 + v104) & ~v11;
  v48(v106, v108, v47);
  v109 = (_BYTE *)(v106 + v9);
  *v109 = *(_BYTE *)(v108 + v9);
  v109[1] = *(_BYTE *)(v108 + v9 + 1);
  v109[2] = *(_BYTE *)(v108 + v9 + 2);
  v110 = (v107 + v106) & ~v11;
  v111 = (v107 + v108) & ~v11;
  v48(v110, v111, v47);
  v112 = (_BYTE *)(v110 + v9);
  *v112 = *(_BYTE *)(v111 + v9);
  v112[1] = *(_BYTE *)(v111 + v9 + 1);
  v112[2] = *(_BYTE *)(v111 + v9 + 2);
  return v118;
}

uint64_t sub_1000C14F0(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  BOOL v19;
  unsigned int v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  char v24;
  int v25;
  unsigned int v26;
  int v27;
  int v28;
  unint64_t v29;
  unsigned int v31;
  int v32;

  v4 = *(_QWORD *)(*(_QWORD *)(a3 + 16) - 8);
  v5 = *(_DWORD *)(v4 + 84);
  if (v5 <= 0xFE)
    v6 = 254;
  else
    v6 = *(_DWORD *)(v4 + 84);
  if (v5 <= 0x7FFFFFFF)
    v7 = 0x7FFFFFFF;
  else
    v7 = *(_DWORD *)(v4 + 84);
  if (v7 <= v6)
    v8 = v6;
  else
    v8 = v7;
  if (!a2)
    return 0;
  v9 = *(_QWORD *)(v4 + 64);
  v11 = *(unsigned __int8 *)(v4 + 80);
  v12 = v9 + 3 + v11;
  v13 = v11 | 3;
  v14 = (v11 | 3) + v9 + 3;
  v15 = (v9 & 0xFFFFFFFFFFFFFFFCLL) + 9;
  v16 = v11 | 7;
  v17 = (v11 | 7) + v15;
  v18 = (v11 | 7) + 1;
  v19 = a2 >= v8;
  v20 = a2 - v8;
  if (v20 != 0 && v19)
  {
    v21 = (v9 & 0xFFFFFFFFFFFFFFF8) + 25;
    v22 = (v9 & 0xFFFFFFFFFFFFFFF8) + 17;
    v10 = v9 + 3;
    v23 = ((v12
          + ((v12
            + ((v22
              + v11
              + ((v11 + 8) & ~v16)
              + ((v16
                + v21
                + ((v16
                  + v21
                  + ((v16
                    + v10
                    + ((v21
                      + v11
                      + ((v16
                        + v10
                        + ((v22
                          + v11
                          + ((v16
                            + v22
                            + ((v16
                              + v10
                              + ((v12
                                + ((v15
                                  + v11
                                  + ((v14
                                    + ((v12
                                      + ((v21
                                        + v11
                                        + (v18 & ~v16)
                                        + ((v17 + ((v14 + ((v12 + ((v12 + (v12 & ~v11)) & ~v11)) & ~v11)) & ~v13)) & ~v16)) & ~v11)) & ~v11)) & ~v13)) & ~v11)) & ~v11)) & ~v16)) & ~v16)) & ~v11)) & ~v16)) & ~v11)) & ~v16)) & ~v16)) & ~v16)) & ~v11)) & ~v11)) & ~v11)
        + v10;
    v24 = 8 * v23;
    if (v23 <= 3)
    {
      v26 = ((v20 + ~(-1 << v24)) >> v24) + 1;
      if (HIWORD(v26))
      {
        v25 = *(_DWORD *)(a1 + v23);
        if (!v25)
          goto LABEL_30;
        goto LABEL_21;
      }
      if (v26 > 0xFF)
      {
        v25 = *(unsigned __int16 *)(a1 + v23);
        if (!*(_WORD *)(a1 + v23))
          goto LABEL_30;
        goto LABEL_21;
      }
      if (v26 < 2)
        goto LABEL_30;
    }
    v25 = *(unsigned __int8 *)(a1 + v23);
    if (!*(_BYTE *)(a1 + v23))
      goto LABEL_30;
LABEL_21:
    v27 = (v25 - 1) << v24;
    if (v23 > 3)
      v27 = 0;
    if ((_DWORD)v23)
    {
      if (v23 <= 3)
        v28 = v23;
      else
        v28 = 4;
      __asm { BR              X12 }
    }
    v32 = v8 + v27;
    return (v32 + 1);
  }
LABEL_30:
  if (v6 >= v7)
  {
    if (v5 >= 0xFE)
      return (*(uint64_t (**)(uint64_t))(v4 + 48))(a1);
    v31 = *(unsigned __int8 *)(a1 + v9 + 1);
    if (v31 < 2)
      return 0;
    v32 = (v31 + 2147483646) & 0x7FFFFFFF;
    return (v32 + 1);
  }
  a1 = (v18 + ((v17 + ((v14 + ((v12 + ((v12 + ((v12 + a1) & ~v11)) & ~v11)) & ~v11)) & ~v13)) & ~v16)) & ~v16;
  if (v5 >= 0x7FFFFFFF)
    return (*(uint64_t (**)(uint64_t))(v4 + 48))(a1);
  v29 = *(_QWORD *)(((a1 + v9) & 0xFFFFFFFFFFFFF8) + 0x10);
  if (v29 >= 0xFFFFFFFF)
    LODWORD(v29) = -1;
  return (v29 + 1);
}

void sub_1000C17D8(_WORD *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  size_t v17;
  BOOL v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  unsigned int v22;
  int v23;

  v6 = *(_QWORD *)(*(_QWORD *)(a4 + 16) - 8);
  v7 = *(_DWORD *)(v6 + 84);
  if (v7 <= 0xFE)
    v8 = 254;
  else
    v8 = *(_DWORD *)(v6 + 84);
  if (v7 <= 0x7FFFFFFF)
    v9 = 0x7FFFFFFF;
  else
    v9 = *(_DWORD *)(v6 + 84);
  if (v9 <= v8)
    v10 = v8;
  else
    v10 = v9;
  v11 = *(_QWORD *)(v6 + 64);
  v12 = *(unsigned __int8 *)(v6 + 80);
  v13 = v11 + 3 + v12;
  v14 = (v11 & 0xFFFFFFFFFFFFFFF8) + 25;
  v15 = (v12 | 7) + v11 + 3;
  v16 = (v11 & 0xFFFFFFFFFFFFFFF8) + 17;
  v17 = ((v13
        + ((v13
          + ((v16
            + v12
            + ((v12 + 8) & ~(v12 | 7))
            + (((v12 | 7)
              + v14
              + (((v12 | 7)
                + v14
                + ((v15
                  + ((v14
                    + v12
                    + ((v15
                      + ((v16
                        + v12
                        + (((v12 | 7)
                          + v16
                          + ((v15
                            + ((v13
                              + (((v11 & 0xFFFFFFFFFFFFFFFCLL)
                                + 9
                                + v12
                                + (((v12 | 3)
                                  + v11
                                  + 3
                                  + ((v13
                                    + (((((v12 | 7) + 1) & ~(v12 | 7))
                                      + v14
                                      + v12
                                      + (((v12 | 7)
                                        + (v11 & 0xFFFFFFFFFFFFFFFCLL)
                                        + 9
                                        + (((v12 | 3) + v11 + 3 + ((v13 + ((v13 + (v13 & ~v12)) & ~v12)) & ~v12)) & ~(v12 | 3))) & ~(v12 | 7))) & ~v12)) & ~v12)) & ~(v12 | 3))) & ~v12)) & ~v12)) & ~(v12 | 7))) & ~(v12 | 7))) & ~v12)) & ~(v12 | 7))) & ~v12)) & ~(v12 | 7))) & ~(v12 | 7))) & ~(v12 | 7))) & ~v12)) & ~v12)) & ~v12)
      + v11
      + 3;
  v18 = a3 >= v10;
  v19 = a3 - v10;
  if (v19 != 0 && v18)
  {
    if (v17 <= 3)
    {
      v22 = ((v19 + ~(-1 << (8 * v17))) >> (8 * v17)) + 1;
      if (HIWORD(v22))
      {
        v20 = &dword_100000004;
      }
      else if (v22 >= 0x100)
      {
        v20 = 2;
      }
      else
      {
        v20 = v22 > 1;
      }
    }
    else
    {
      v20 = &_mh_execute_header.magic + 1;
    }
  }
  else
  {
    v20 = 0;
  }
  if (v10 < a2)
  {
    v21 = ~v10 + a2;
    if (v17 < 4)
    {
      if ((_DWORD)v17)
      {
        v23 = v21 & ~(-1 << (8 * v17));
        bzero(a1, v17);
        if ((_DWORD)v17 == 3)
        {
          *a1 = v23;
          *((_BYTE *)a1 + 2) = BYTE2(v23);
        }
        else if ((_DWORD)v17 == 2)
        {
          *a1 = v23;
        }
        else
        {
          *(_BYTE *)a1 = v23;
        }
      }
    }
    else
    {
      bzero(a1, v17);
      *(_DWORD *)a1 = v21;
    }
    __asm { BR              X10 }
  }
  __asm { BR              X7 }
}

uint64_t sub_1000C1C2C(uint64_t a1)
{
  uint64_t result;
  unint64_t v3;
  unint64_t v4;
  _QWORD v5[4];

  result = swift_checkMetadataState(319, *(_QWORD *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    v5[0] = *(_QWORD *)(result - 8) + 64;
    v5[1] = &unk_10033FF98;
    result = swift_checkMetadataState(319, *(_QWORD *)(a1 + 24));
    if (v4 <= 0x3F)
    {
      v5[2] = *(_QWORD *)(result - 8) + 64;
      v5[3] = &unk_10033FFB0;
      swift_initStructMetadata(a1, 0, 4, v5, a1 + 40);
      return 0;
    }
  }
  return result;
}

_QWORD *sub_1000C1CC8(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;

  v4 = a1;
  v5 = *(_QWORD *)(a3 + 24);
  v6 = *(_QWORD *)(*(_QWORD *)(a3 + 16) - 8);
  v7 = *(_QWORD *)(v6 + 64);
  v8 = *(_QWORD *)(v5 - 8);
  v9 = *(_DWORD *)(v8 + 80);
  v10 = *(_QWORD *)(v8 + 64);
  v11 = (*(_BYTE *)(v6 + 80) | *(_BYTE *)(v8 + 80));
  if (v11 > 7
    || ((*(_DWORD *)(v6 + 80) | *(_DWORD *)(v8 + 80)) & 0x100000) != 0
    || v10 + ((v9 + v7 + 1) & (unint64_t)~v9) + 1 > 0x18)
  {
    v14 = *a2;
    *v4 = *a2;
    v4 = (_QWORD *)(v14 + ((v11 + 16) & ~v11));
    swift_retain(v14);
  }
  else
  {
    (*(void (**)(_QWORD *, _QWORD *))(v6 + 16))(a1, a2);
    *((_BYTE *)v4 + v7) = *((_BYTE *)a2 + v7);
    v15 = (char *)a2 + v7 + v9;
    v16 = ((unint64_t)v4 + v7 + v9 + 1) & ~v9;
    v17 = (unint64_t)(v15 + 1) & ~v9;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 16))(v16, v17, v5);
    *(_BYTE *)(v16 + v10) = *(_BYTE *)(v17 + v10);
  }
  return v4;
}

uint64_t sub_1000C1DD0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = *(_QWORD *)(*(_QWORD *)(a2 + 16) - 8);
  (*(void (**)(void))(v4 + 8))();
  return (*(uint64_t (**)(unint64_t))(*(_QWORD *)(*(_QWORD *)(a2 + 24) - 8) + 8))((a1 + *(_QWORD *)(v4 + 64) + *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) - 8) + 80) + 1) & ~(unint64_t)*(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) - 8) + 80));
}

uint64_t sub_1000C1E2C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _BYTE *v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v6 = *(_QWORD *)(*(_QWORD *)(a3 + 16) - 8);
  (*(void (**)(void))(v6 + 16))();
  v7 = *(_QWORD *)(v6 + 64);
  v8 = (_BYTE *)(v7 + a1);
  v9 = (_BYTE *)(v7 + a2);
  *v8 = *v9;
  v10 = *(_QWORD *)(*(_QWORD *)(a3 + 24) - 8);
  v11 = *(unsigned __int8 *)(v10 + 80);
  v12 = (unint64_t)&v8[v11 + 1] & ~v11;
  v13 = (unint64_t)&v9[v11 + 1] & ~v11;
  (*(void (**)(uint64_t, uint64_t))(v10 + 16))(v12, v13);
  *(_BYTE *)(v12 + *(_QWORD *)(v10 + 64)) = *(_BYTE *)(v13 + *(_QWORD *)(v10 + 64));
  return a1;
}

uint64_t sub_1000C1EBC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _BYTE *v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v6 = *(_QWORD *)(*(_QWORD *)(a3 + 16) - 8);
  (*(void (**)(void))(v6 + 24))();
  v7 = *(_QWORD *)(v6 + 64);
  v8 = (_BYTE *)(v7 + a1);
  v9 = (_BYTE *)(v7 + a2);
  *v8 = *v9;
  v10 = *(_QWORD *)(*(_QWORD *)(a3 + 24) - 8);
  v11 = *(unsigned __int8 *)(v10 + 80);
  v12 = (unint64_t)&v8[v11 + 1] & ~v11;
  v13 = (unint64_t)&v9[v11 + 1] & ~v11;
  (*(void (**)(uint64_t, uint64_t))(v10 + 24))(v12, v13);
  *(_BYTE *)(v12 + *(_QWORD *)(v10 + 64)) = *(_BYTE *)(v13 + *(_QWORD *)(v10 + 64));
  return a1;
}

uint64_t sub_1000C1F4C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _BYTE *v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v6 = *(_QWORD *)(*(_QWORD *)(a3 + 16) - 8);
  (*(void (**)(void))(v6 + 32))();
  v7 = *(_QWORD *)(v6 + 64);
  v8 = (_BYTE *)(v7 + a1);
  v9 = (_BYTE *)(v7 + a2);
  *v8 = *v9;
  v10 = *(_QWORD *)(*(_QWORD *)(a3 + 24) - 8);
  v11 = *(unsigned __int8 *)(v10 + 80);
  v12 = (unint64_t)&v8[v11 + 1] & ~v11;
  v13 = (unint64_t)&v9[v11 + 1] & ~v11;
  (*(void (**)(uint64_t, uint64_t))(v10 + 32))(v12, v13);
  *(_BYTE *)(v12 + *(_QWORD *)(v10 + 64)) = *(_BYTE *)(v13 + *(_QWORD *)(v10 + 64));
  return a1;
}

uint64_t sub_1000C1FDC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _BYTE *v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v6 = *(_QWORD *)(*(_QWORD *)(a3 + 16) - 8);
  (*(void (**)(void))(v6 + 40))();
  v7 = *(_QWORD *)(v6 + 64);
  v8 = (_BYTE *)(v7 + a1);
  v9 = (_BYTE *)(v7 + a2);
  *v8 = *v9;
  v10 = *(_QWORD *)(*(_QWORD *)(a3 + 24) - 8);
  v11 = *(unsigned __int8 *)(v10 + 80);
  v12 = (unint64_t)&v8[v11 + 1] & ~v11;
  v13 = (unint64_t)&v9[v11 + 1] & ~v11;
  (*(void (**)(uint64_t, uint64_t))(v10 + 40))(v12, v13);
  *(_BYTE *)(v12 + *(_QWORD *)(v10 + 64)) = *(_BYTE *)(v13 + *(_QWORD *)(v10 + 64));
  return a1;
}

uint64_t sub_1000C206C(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  char v14;
  int v15;
  unsigned int v16;
  int v17;
  int v18;
  uint64_t v20;
  unsigned int v21;

  v4 = *(_QWORD *)(*(_QWORD *)(a3 + 16) - 8);
  v5 = *(_DWORD *)(v4 + 84);
  v6 = *(_QWORD *)(*(_QWORD *)(a3 + 24) - 8);
  v7 = *(_DWORD *)(v6 + 84);
  if (v5 <= v7)
    v8 = *(_DWORD *)(v6 + 84);
  else
    v8 = *(_DWORD *)(v4 + 84);
  if (v8 <= 0xFE)
    v8 = 254;
  if (!a2)
    return 0;
  v9 = *(_QWORD *)(v4 + 64);
  v10 = *(unsigned __int8 *)(v6 + 80);
  v11 = *(_QWORD *)(v6 + 64);
  v12 = a2 - v8;
  if (a2 <= v8)
    goto LABEL_25;
  v13 = v11 + ((v9 + v10 + 1) & ~v10) + 1;
  v14 = 8 * v13;
  if (v13 > 3)
    goto LABEL_9;
  v16 = ((v12 + ~(-1 << v14)) >> v14) + 1;
  if (HIWORD(v16))
  {
    v15 = *(_DWORD *)(a1 + v13);
    if (v15)
      goto LABEL_16;
  }
  else
  {
    if (v16 <= 0xFF)
    {
      if (v16 < 2)
        goto LABEL_25;
LABEL_9:
      v15 = *(unsigned __int8 *)(a1 + v13);
      if (!*(_BYTE *)(a1 + v13))
        goto LABEL_25;
LABEL_16:
      v17 = (v15 - 1) << v14;
      if (v13 > 3)
        v17 = 0;
      if ((_DWORD)v11 + (((_DWORD)v9 + (_DWORD)v10 + 1) & ~(_DWORD)v10) == -1)
        return v8 + v17 + 1;
      if (v13 <= 3)
        v18 = v11 + ((v9 + v10 + 1) & ~(_DWORD)v10) + 1;
      else
        v18 = 4;
      return ((uint64_t (*)(void))((char *)&loc_1000C2154 + 4 * byte_10033FA2C[v18 - 1]))();
    }
    v15 = *(unsigned __int16 *)(a1 + v13);
    if (*(_WORD *)(a1 + v13))
      goto LABEL_16;
  }
LABEL_25:
  if (v5 == v8)
    return (*(uint64_t (**)(void))(v4 + 48))();
  v20 = (a1 + v9 + v10 + 1) & ~v10;
  if (v7 == v8)
    return (*(uint64_t (**)(uint64_t))(v6 + 48))(v20);
  v21 = *(unsigned __int8 *)(v20 + v11);
  if (v21 < 2)
    return 0;
  return ((v21 + 2147483646) & 0x7FFFFFFF) + 1;
}

void sub_1000C21FC(_WORD *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  size_t v9;
  unsigned int v10;
  int v11;
  unsigned int v12;
  int v13;

  v5 = *(_QWORD *)(*(_QWORD *)(a4 + 16) - 8);
  v6 = *(_QWORD *)(*(_QWORD *)(a4 + 24) - 8);
  if (*(_DWORD *)(v5 + 84) <= *(_DWORD *)(v6 + 84))
    v7 = *(_DWORD *)(v6 + 84);
  else
    v7 = *(_DWORD *)(v5 + 84);
  if (v7 <= 0xFE)
    v8 = 254;
  else
    v8 = v7;
  v9 = *(_QWORD *)(v6 + 64)
     + ((*(_QWORD *)(v5 + 64) + *(unsigned __int8 *)(v6 + 80) + 1) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80))
     + 1;
  if (a3 > v8)
  {
    if (v9 <= 3)
    {
      v12 = ((a3 - v8 + ~(-1 << (8 * v9))) >> (8 * v9)) + 1;
      if (HIWORD(v12))
      {
        v10 = &dword_100000004;
      }
      else if (v12 >= 0x100)
      {
        v10 = 2;
      }
      else
      {
        v10 = v12 > 1;
      }
    }
    else
    {
      v10 = &_mh_execute_header.magic + 1;
    }
  }
  else
  {
    v10 = 0;
  }
  if (v8 < a2)
  {
    v11 = ~v8 + a2;
    if (v9 < 4)
    {
      if (*(_DWORD *)(v6 + 64)
         + ((*(_DWORD *)(v5 + 64) + *(unsigned __int8 *)(v6 + 80) + 1) & ~*(unsigned __int8 *)(v6 + 80)) != -1)
      {
        v13 = v11 & ~(-1 << (8 * v9));
        bzero(a1, v9);
        if ((_DWORD)v9 == 3)
        {
          *a1 = v13;
          *((_BYTE *)a1 + 2) = BYTE2(v13);
        }
        else if ((_DWORD)v9 == 2)
        {
          *a1 = v13;
        }
        else
        {
          *(_BYTE *)a1 = v13;
        }
      }
    }
    else
    {
      bzero(a1, v9);
      *(_DWORD *)a1 = v11;
    }
    __asm { BR              X10 }
  }
  __asm { BR              X4 }
}

uint64_t sub_1000C2428(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t AssociatedTypeWitness;
  uint64_t v7;
  unint64_t v8;
  _QWORD v10[2];

  v2 = swift_checkMetadataState(319, a1[3]);
  v3 = v2;
  if (v4 <= 0x3F)
  {
    v10[0] = *(_QWORD *)(v2 - 8) + 64;
    v5 = a1[2];
    AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, a1[5], v2, &protocol requirements base descriptor for RawRepresentable);
    v7 = type metadata accessor for Preferences.Preference(319, v5, AssociatedTypeWitness, a1[4]);
    v3 = v7;
    if (v8 <= 0x3F)
    {
      v10[1] = *(_QWORD *)(v7 - 8) + 64;
      swift_initStructMetadata(a1, 0, 2, v10, a1 + 6);
      return 0;
    }
  }
  return v3;
}

uint64_t *sub_1000C24E8(uint64_t *a1, uint64_t *a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t AssociatedTypeWitness;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v24;
  uint64_t v25;
  void (*v26)(uint64_t *, uint64_t *, uint64_t);
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;

  v6 = a3[2];
  v5 = a3[3];
  v7 = *(_QWORD *)(v5 - 8);
  v8 = *(_QWORD *)(v7 + 64);
  v9 = *(_QWORD *)(v6 - 8);
  v10 = *(_DWORD *)(v9 + 80);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a3[5], v5, &protocol requirements base descriptor for RawRepresentable, &associated type descriptor for RawRepresentable.RawValue);
  v12 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v13 = *(_DWORD *)(v12 + 80);
  v14 = *(_DWORD *)(v12 + 80) | v10;
  v15 = (*(_BYTE *)(v12 + 80) | v10);
  v16 = v8 + v15;
  v17 = *(_QWORD *)(v9 + 64);
  v18 = v13 + 1;
  v19 = *(_DWORD *)(v7 + 80) | v14;
  v20 = (*(_BYTE *)(v7 + 80) | v14);
  v21 = v19 & 0x100000;
  if (v20 > 7
    || v21 != 0
    || *(_QWORD *)(v12 + 64) + ((v13 + 1 + v17) & ~v13) + (v16 & (unint64_t)~v15) + 1 > 0x18)
  {
    v24 = *a2;
    *a1 = *a2;
    a1 = (uint64_t *)(v24 + ((v20 + 16) & ~v20));
    swift_retain(v24);
  }
  else
  {
    v34 = v6;
    v25 = ~v15;
    v35 = ~v13;
    v36 = AssociatedTypeWitness;
    v26 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v7 + 16);
    v27 = *(_QWORD *)(v12 + 64);
    v26(a1, a2, v5);
    v28 = ((unint64_t)a1 + v16) & v25;
    v29 = ((unint64_t)a2 + v16) & v25;
    (*(void (**)(unint64_t, unint64_t, uint64_t))(v9 + 16))(v28, v29, v34);
    v30 = v29 + v17;
    *(_BYTE *)(v28 + v17) = *(_BYTE *)(v29 + v17);
    v31 = (v18 + v28 + v17) & v35;
    v32 = (v18 + v30) & v35;
    (*(void (**)(unint64_t, uint64_t, uint64_t))(v12 + 16))(v31, v32, v36);
    *(_BYTE *)(v31 + v27) = *(_BYTE *)(v32 + v27);
  }
  return a1;
}

uint64_t sub_1000C2668(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v4 = a2[3];
  v5 = *(_QWORD *)(v4 - 8);
  (*(void (**)(uint64_t, uint64_t))(v5 + 8))(a1, v4);
  v6 = *(_QWORD *)(v5 + 64) + a1;
  v7 = a2[2];
  v8 = *(_QWORD *)(v7 - 8);
  v9 = *(unsigned __int8 *)(v8 + 80);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a2[5], v4, &protocol requirements base descriptor for RawRepresentable, &associated type descriptor for RawRepresentable.RawValue);
  v11 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v12 = *(_DWORD *)(v11 + 80);
  v13 = *(_DWORD *)(v11 + 80) | v9;
  v14 = (v6 + v13) & ~v13;
  (*(void (**)(uint64_t, uint64_t))(v8 + 8))(v14, v7);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v11 + 8))((v12 + *(_QWORD *)(v8 + 64) + v14 + 1) & ~v12, AssociatedTypeWitness);
}

uint64_t sub_1000C2734(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t AssociatedTypeWitness;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _BYTE *v19;
  _BYTE *v20;
  uint64_t v21;
  uint64_t v22;

  v6 = a3[3];
  v7 = *(_QWORD *)(v6 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 16))(a1, a2, v6);
  v8 = *(_QWORD *)(v7 + 64);
  v9 = a3[2];
  v10 = *(_QWORD *)(v9 - 8);
  v11 = *(unsigned __int8 *)(v10 + 80);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a3[5], v6, &protocol requirements base descriptor for RawRepresentable, &associated type descriptor for RawRepresentable.RawValue);
  v13 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v14 = *(_DWORD *)(v13 + 80);
  v15 = *(_DWORD *)(v13 + 80) | v11;
  v16 = (v8 + v15 + a1) & ~v15;
  v17 = (v8 + v15 + a2) & ~v15;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 16))(v16, v17, v9);
  v18 = *(_QWORD *)(v10 + 64);
  v19 = (_BYTE *)(v16 + v18);
  v20 = (_BYTE *)(v17 + v18);
  *v19 = *v20;
  v21 = (unint64_t)&v19[v14 + 1] & ~v14;
  v22 = (unint64_t)&v20[v14 + 1] & ~v14;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v13 + 16))(v21, v22, AssociatedTypeWitness);
  *(_BYTE *)(v21 + *(_QWORD *)(v13 + 64)) = *(_BYTE *)(v22 + *(_QWORD *)(v13 + 64));
  return a1;
}

uint64_t sub_1000C2848(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t AssociatedTypeWitness;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _BYTE *v19;
  _BYTE *v20;
  uint64_t v21;
  uint64_t v22;

  v6 = a3[3];
  v7 = *(_QWORD *)(v6 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 24))(a1, a2, v6);
  v8 = *(_QWORD *)(v7 + 64);
  v9 = a3[2];
  v10 = *(_QWORD *)(v9 - 8);
  v11 = *(unsigned __int8 *)(v10 + 80);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a3[5], v6, &protocol requirements base descriptor for RawRepresentable, &associated type descriptor for RawRepresentable.RawValue);
  v13 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v14 = *(_DWORD *)(v13 + 80);
  v15 = *(_DWORD *)(v13 + 80) | v11;
  v16 = (v8 + v15 + a1) & ~v15;
  v17 = (v8 + v15 + a2) & ~v15;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 24))(v16, v17, v9);
  v18 = *(_QWORD *)(v10 + 64);
  v19 = (_BYTE *)(v16 + v18);
  v20 = (_BYTE *)(v17 + v18);
  *v19 = *v20;
  v21 = (unint64_t)&v19[v14 + 1] & ~v14;
  v22 = (unint64_t)&v20[v14 + 1] & ~v14;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v13 + 24))(v21, v22, AssociatedTypeWitness);
  *(_BYTE *)(v21 + *(_QWORD *)(v13 + 64)) = *(_BYTE *)(v22 + *(_QWORD *)(v13 + 64));
  return a1;
}

uint64_t sub_1000C295C(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t AssociatedTypeWitness;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _BYTE *v19;
  _BYTE *v20;
  uint64_t v21;
  uint64_t v22;

  v6 = a3[3];
  v7 = *(_QWORD *)(v6 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 32))(a1, a2, v6);
  v8 = *(_QWORD *)(v7 + 64);
  v9 = a3[2];
  v10 = *(_QWORD *)(v9 - 8);
  v11 = *(unsigned __int8 *)(v10 + 80);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a3[5], v6, &protocol requirements base descriptor for RawRepresentable, &associated type descriptor for RawRepresentable.RawValue);
  v13 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v14 = *(_DWORD *)(v13 + 80);
  v15 = *(_DWORD *)(v13 + 80) | v11;
  v16 = (v8 + v15 + a1) & ~v15;
  v17 = (v8 + v15 + a2) & ~v15;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 32))(v16, v17, v9);
  v18 = *(_QWORD *)(v10 + 64);
  v19 = (_BYTE *)(v16 + v18);
  v20 = (_BYTE *)(v17 + v18);
  *v19 = *v20;
  v21 = (unint64_t)&v19[v14 + 1] & ~v14;
  v22 = (unint64_t)&v20[v14 + 1] & ~v14;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v13 + 32))(v21, v22, AssociatedTypeWitness);
  *(_BYTE *)(v21 + *(_QWORD *)(v13 + 64)) = *(_BYTE *)(v22 + *(_QWORD *)(v13 + 64));
  return a1;
}

uint64_t sub_1000C2A70(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t AssociatedTypeWitness;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _BYTE *v19;
  _BYTE *v20;
  uint64_t v21;
  uint64_t v22;

  v6 = a3[3];
  v7 = *(_QWORD *)(v6 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 40))(a1, a2, v6);
  v8 = *(_QWORD *)(v7 + 64);
  v9 = a3[2];
  v10 = *(_QWORD *)(v9 - 8);
  v11 = *(unsigned __int8 *)(v10 + 80);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a3[5], v6, &protocol requirements base descriptor for RawRepresentable, &associated type descriptor for RawRepresentable.RawValue);
  v13 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v14 = *(_DWORD *)(v13 + 80);
  v15 = *(_DWORD *)(v13 + 80) | v11;
  v16 = (v8 + v15 + a1) & ~v15;
  v17 = (v8 + v15 + a2) & ~v15;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 40))(v16, v17, v9);
  v18 = *(_QWORD *)(v10 + 64);
  v19 = (_BYTE *)(v16 + v18);
  v20 = (_BYTE *)(v17 + v18);
  *v19 = *v20;
  v21 = (unint64_t)&v19[v14 + 1] & ~v14;
  v22 = (unint64_t)&v20[v14 + 1] & ~v14;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v13 + 40))(v21, v22, AssociatedTypeWitness);
  *(_BYTE *)(v21 + *(_QWORD *)(v13 + 64)) = *(_BYTE *)(v22 + *(_QWORD *)(v13 + 64));
  return a1;
}

uint64_t sub_1000C2B84(uint64_t a1, unsigned int a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t AssociatedTypeWitness;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char v24;
  int v25;
  unsigned int v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t (*v30)(uint64_t, uint64_t, uint64_t);
  unsigned int v32;
  int v33;

  v5 = a3[2];
  v6 = a3[3];
  v7 = *(_QWORD *)(v6 - 8);
  v8 = *(unsigned int *)(v7 + 84);
  v9 = *(_QWORD *)(v5 - 8);
  v10 = *(unsigned int *)(v9 + 84);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a3[5], v6, &protocol requirements base descriptor for RawRepresentable, &associated type descriptor for RawRepresentable.RawValue);
  v12 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v13 = *(unsigned int *)(v12 + 84);
  if (v10 <= v13)
    v14 = *(_DWORD *)(v12 + 84);
  else
    v14 = v10;
  if (v14 <= 0xFE)
    v15 = 254;
  else
    v15 = v14;
  if (v15 <= v8)
    v16 = v8;
  else
    v16 = v15;
  if (!a2)
    return 0;
  v17 = AssociatedTypeWitness;
  v18 = *(_DWORD *)(v12 + 80);
  v19 = *(_DWORD *)(v12 + 80) | *(unsigned __int8 *)(v9 + 80);
  v20 = *(_QWORD *)(v7 + 64) + v19;
  v21 = *(_QWORD *)(v9 + 64) + v18 + 1;
  v22 = *(_QWORD *)(v12 + 64);
  if (a2 <= v16)
    goto LABEL_29;
  v23 = v22 + (v21 & ~v18) + (v20 & ~v19) + 1;
  v24 = 8 * v23;
  if (v23 > 3)
    goto LABEL_13;
  v26 = ((a2 - v16 + ~(-1 << v24)) >> v24) + 1;
  if (HIWORD(v26))
  {
    v25 = *(_DWORD *)(a1 + v23);
    if (v25)
      goto LABEL_20;
  }
  else
  {
    if (v26 <= 0xFF)
    {
      if (v26 < 2)
        goto LABEL_29;
LABEL_13:
      v25 = *(unsigned __int8 *)(a1 + v23);
      if (!*(_BYTE *)(a1 + v23))
        goto LABEL_29;
LABEL_20:
      v27 = (v25 - 1) << v24;
      if (v23 > 3)
        v27 = 0;
      if ((_DWORD)v22 + (v21 & ~(_DWORD)v18) + (v20 & ~(_DWORD)v19) != -1)
      {
        if (v23 <= 3)
          v28 = v22 + (v21 & ~(_DWORD)v18) + (v20 & ~(_DWORD)v19) + 1;
        else
          v28 = 4;
        __asm { BR              X12 }
      }
      v33 = v16 + v27;
      return (v33 + 1);
    }
    v25 = *(unsigned __int16 *)(a1 + v23);
    if (*(_WORD *)(a1 + v23))
      goto LABEL_20;
  }
LABEL_29:
  if (v8 >= v15)
  {
    v30 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v7 + 48);
    v29 = a1;
    v13 = v8;
    v17 = v6;
    return v30(v29, v13, v17);
  }
  v29 = (v20 + a1) & ~v19;
  if ((_DWORD)v10 == v15)
  {
    v30 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v9 + 48);
    v13 = v10;
    v17 = v5;
    return v30(v29, v13, v17);
  }
  v29 = (v21 + v29) & ~v18;
  if ((_DWORD)v13 == v15)
  {
    v30 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v12 + 48);
    return v30(v29, v13, v17);
  }
  v32 = *(unsigned __int8 *)(v29 + v22);
  if (v32 < 2)
    return 0;
  v33 = (v32 + 2147483646) & 0x7FFFFFFF;
  return (v33 + 1);
}

void sub_1000C2DC8(_BYTE *a1, unsigned int a2, unsigned int a3, _QWORD *a4)
{
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  size_t v16;
  unsigned int v17;
  int v18;
  unsigned int v19;
  int v20;

  v7 = a4[3];
  v8 = *(_QWORD *)(v7 - 8);
  v9 = *(_DWORD *)(v8 + 84);
  v10 = *(_QWORD *)(a4[2] - 8);
  v11 = *(_DWORD *)(v10 + 84);
  v12 = *(_QWORD *)(swift_getAssociatedTypeWitness(0, a4[5], v7, &protocol requirements base descriptor for RawRepresentable, &associated type descriptor for RawRepresentable.RawValue)- 8);
  if (v11 <= *(_DWORD *)(v12 + 84))
    v13 = *(_DWORD *)(v12 + 84);
  else
    v13 = v11;
  if (v13 <= 0xFE)
    v13 = 254;
  if (v13 <= v9)
    v14 = v9;
  else
    v14 = v13;
  v15 = *(_DWORD *)(v12 + 80) | *(unsigned __int8 *)(v10 + 80);
  v16 = ((*(_QWORD *)(v8 + 64) + v15) & ~v15)
      + *(_QWORD *)(v12 + 64)
      + ((*(_QWORD *)(v10 + 64) + *(_DWORD *)(v12 + 80) + 1) & ~(unint64_t)*(_DWORD *)(v12 + 80))
      + 1;
  if (a3 <= v14)
  {
    v17 = 0;
  }
  else if (v16 <= 3)
  {
    v19 = ((a3 - v14 + ~(-1 << (8 * v16))) >> (8 * v16)) + 1;
    if (HIWORD(v19))
    {
      v17 = &dword_100000004;
    }
    else if (v19 >= 0x100)
    {
      v17 = 2;
    }
    else
    {
      v17 = v19 > 1;
    }
  }
  else
  {
    v17 = &_mh_execute_header.magic + 1;
  }
  if (v14 < a2)
  {
    v18 = ~v14 + a2;
    if (v16 < 4)
    {
      if ((_DWORD)v16)
      {
        v20 = v18 & ~(-1 << (8
                           * (((*(_BYTE *)(v8 + 64) + v15) & ~(_BYTE)v15)
                            + *(_BYTE *)(v12 + 64)
                            + ((*(_BYTE *)(v10 + 64) + *(_DWORD *)(v12 + 80) + 1) & ~*(_DWORD *)(v12 + 80))
                            + 1)));
        bzero(a1, v16);
        if ((_DWORD)v16 == 3)
        {
          *(_WORD *)a1 = v20;
          a1[2] = BYTE2(v20);
        }
        else if ((_DWORD)v16 == 2)
        {
          *(_WORD *)a1 = v20;
        }
        else
        {
          *a1 = v20;
        }
      }
    }
    else
    {
      bzero(a1, v16);
      *(_DWORD *)a1 = v18;
    }
    __asm { BR              X10 }
  }
  __asm { BR              X17 }
}

void sub_1000C30EC()
{
  uint64_t v0;
  int v1;

  *(_WORD *)v0 = v1;
  *(_BYTE *)(v0 + 2) = BYTE2(v1);
  JUMPOUT(0x1000C30A4);
}

void sub_1000C30FC()
{
  _WORD *v0;
  __int16 v1;

  *v0 = v1;
  JUMPOUT(0x1000C30A4);
}

void sub_1000C3104()
{
  _DWORD *v0;
  int v1;

  *v0 = v1;
  JUMPOUT(0x1000C30A4);
}

uint64_t sub_1000C3110(uint64_t a1)
{
  uint64_t result;
  unint64_t v3;
  uint64_t v4;

  result = type metadata accessor for Preferences.Preference(319, *(_QWORD *)(a1 + 16), (uint64_t)&type metadata for Data, *(_QWORD *)(a1 + 24));
  if (v3 <= 0x3F)
  {
    v4 = *(_QWORD *)(result - 8) + 64;
    swift_initStructMetadata(a1, 0, 1, &v4, a1 + 32);
    return 0;
  }
  return result;
}

_QWORD *sub_1000C3184(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;

  v4 = a1;
  v5 = *(_QWORD *)(*(_QWORD *)(a3 + 16) - 8);
  v6 = *(_QWORD *)(v5 + 64);
  v7 = *(_DWORD *)(v5 + 80);
  if ((v6 & 0xFFFFFFFFFFFFFFF8) >= 0xFFFFFFFFFFFFFFE7 && (v7 & 0x1000F8) == 0)
  {
    (*(void (**)(_QWORD *, _QWORD *))(v5 + 16))(a1, a2);
    *((_BYTE *)v4 + v6) = *((_BYTE *)a2 + v6);
    v10 = ((unint64_t)v4 + v6) & 0xFFFFFFFFFFFFFFF8;
    v11 = ((unint64_t)a2 + v6) & 0xFFFFFFFFFFFFFFF8;
    v12 = *(_QWORD *)(v11 + 8);
    v13 = *(_QWORD *)(v11 + 16);
    sub_100031FEC(v12, v13);
    *(_QWORD *)(v10 + 8) = v12;
    *(_QWORD *)(v10 + 16) = v13;
    *(_BYTE *)(v10 + 24) = *(_BYTE *)(v11 + 24);
  }
  else
  {
    v9 = *a2;
    *v4 = *a2;
    v4 = (_QWORD *)(v9 + ((unsigned __int16)((v7 & 0xF8) + 23) & (unsigned __int16)~(v7 & 0xF8) & 0x1F8));
    swift_retain();
  }
  return v4;
}

uint64_t sub_1000C3248(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(*(_QWORD *)(a2 + 16) - 8);
  (*(void (**)(void))(v3 + 8))();
  return sub_10000E614(*(_QWORD *)(((*(_QWORD *)(v3 + 64) + a1) & 0xFFFFFFFFFFFFFFF8) + 8), *(_QWORD *)(((*(_QWORD *)(v3 + 64) + a1) & 0xFFFFFFFFFFFFFFF8) + 16));
}

uint64_t sub_1000C3284(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;

  v5 = *(_QWORD *)(*(_QWORD *)(a3 + 16) - 8);
  (*(void (**)(void))(v5 + 16))();
  v6 = *(_QWORD *)(v5 + 64);
  v7 = v6 + a1;
  v8 = v6 + a2;
  *(_BYTE *)v7 = *(_BYTE *)v8;
  v9 = v7 & 0xFFFFFFFFFFFFFFF8;
  v10 = v8 & 0xFFFFFFFFFFFFFFF8;
  v11 = *(_QWORD *)((v8 & 0xFFFFFFFFFFFFFFF8) + 8);
  v12 = *(_QWORD *)((v8 & 0xFFFFFFFFFFFFFFF8) + 16);
  sub_100031FEC(v11, v12);
  *(_QWORD *)(v9 + 8) = v11;
  *(_QWORD *)(v9 + 16) = v12;
  *(_BYTE *)(v9 + 24) = *(_BYTE *)(v10 + 24);
  return a1;
}

uint64_t sub_1000C3300(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;

  v5 = *(_QWORD *)(*(_QWORD *)(a3 + 16) - 8);
  (*(void (**)(void))(v5 + 24))();
  v6 = *(_QWORD *)(v5 + 64);
  v7 = v6 + a1;
  v8 = v6 + a2;
  *(_BYTE *)v7 = *(_BYTE *)v8;
  v9 = v7 & 0xFFFFFFFFFFFFFFF8;
  v10 = v8 & 0xFFFFFFFFFFFFFFF8;
  v11 = *(_QWORD *)((v8 & 0xFFFFFFFFFFFFFFF8) + 8);
  v12 = *(_QWORD *)((v8 & 0xFFFFFFFFFFFFFFF8) + 16);
  sub_100031FEC(v11, v12);
  v13 = *(_QWORD *)(v9 + 8);
  v14 = *(_QWORD *)(v9 + 16);
  *(_QWORD *)(v9 + 8) = v11;
  *(_QWORD *)(v9 + 16) = v12;
  sub_10000E614(v13, v14);
  *(_BYTE *)(v9 + 24) = *(_BYTE *)(v10 + 24);
  return a1;
}

uint64_t sub_1000C3384(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v5 = *(_QWORD *)(*(_QWORD *)(a3 + 16) - 8);
  (*(void (**)(void))(v5 + 32))();
  v6 = *(_QWORD *)(v5 + 64);
  v7 = v6 + a1;
  v8 = v6 + a2;
  *(_BYTE *)v7 = *(_BYTE *)v8;
  v7 &= 0xFFFFFFFFFFFFFFF8;
  v8 &= 0xFFFFFFFFFFFFFFF8;
  *(_OWORD *)(v7 + 8) = *(_OWORD *)(v8 + 8);
  *(_BYTE *)(v7 + 24) = *(_BYTE *)(v8 + 24);
  return a1;
}

uint64_t sub_1000C33EC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;

  v5 = *(_QWORD *)(*(_QWORD *)(a3 + 16) - 8);
  (*(void (**)(void))(v5 + 40))();
  v6 = *(_QWORD *)(v5 + 64);
  v7 = v6 + a1;
  v8 = v6 + a2;
  *(_BYTE *)v7 = *(_BYTE *)v8;
  v9 = v7 & 0xFFFFFFFFFFFFFFF8;
  v10 = v8 & 0xFFFFFFFFFFFFFFF8;
  v11 = *(_QWORD *)((v7 & 0xFFFFFFFFFFFFFFF8) + 8);
  v12 = *(_QWORD *)((v7 & 0xFFFFFFFFFFFFFFF8) + 16);
  *(_OWORD *)((v7 & 0xFFFFFFFFFFFFFFF8) + 8) = *(_OWORD *)((v8 & 0xFFFFFFFFFFFFFFF8) + 8);
  sub_10000E614(v11, v12);
  *(_BYTE *)(v9 + 24) = *(_BYTE *)(v10 + 24);
  return a1;
}

uint64_t sub_1000C345C(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v14;

  v4 = *(_QWORD *)(*(_QWORD *)(a3 + 16) - 8);
  v5 = *(_DWORD *)(v4 + 84);
  if (v5 <= 0xFE)
    v6 = 254;
  else
    v6 = *(_DWORD *)(v4 + 84);
  if (!a2)
    return 0;
  v7 = *(_QWORD *)(v4 + 64);
  if (v6 >= a2)
  {
    if (v5 >= 0xFE)
      return (*(uint64_t (**)(void))(v4 + 48))();
    v14 = *(unsigned __int8 *)(((v7 + a1) & 0xFFFFFFFFFFFFF8) + 0x18);
    if (v14 >= 2)
      return ((v14 + 2147483646) & 0x7FFFFFFF) + 1;
    return 0;
  }
  v8 = (v7 & 0xFFFFFFF8) + 25;
  v9 = (a2 - v6 + 255) >> (8 * v8);
  if (v8 < 4)
    v10 = v9 + 1;
  else
    v10 = 2;
  if (v10 >= 0x10000)
    v11 = 4;
  else
    v11 = 2;
  if (v10 < 0x100)
    v11 = 1;
  if (v10 >= 2)
    v12 = v11;
  else
    v12 = 0;
  return ((uint64_t (*)(void))((char *)&loc_1000C34E0 + 4 * byte_10033FA4C[v12]))();
}

void sub_1000C3574(_BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v5;
  unsigned int v6;
  size_t v7;
  unsigned int v8;
  int v9;
  int v10;
  unsigned int v11;

  v5 = *(_QWORD *)(*(_QWORD *)(a4 + 16) - 8);
  if (*(_DWORD *)(v5 + 84) <= 0xFEu)
    v6 = 254;
  else
    v6 = *(_DWORD *)(v5 + 84);
  v7 = (*(_QWORD *)(v5 + 64) & 0xFFFFFFFFFFFFFFF8) + 25;
  if (v6 >= a3)
  {
    v10 = 0;
    if (v6 >= a2)
      goto LABEL_17;
  }
  else
  {
    if (v7 <= 3)
      v8 = ((a3 - v6 + 255) >> (8 * v7)) + 1;
    else
      v8 = 2;
    if (v8 >= 0x10000)
      v9 = 4;
    else
      v9 = 2;
    if (v8 < 0x100)
      v9 = 1;
    if (v8 >= 2)
      v10 = v9;
    else
      v10 = 0;
    if (v6 >= a2)
LABEL_17:
      __asm { BR              X12 }
  }
  if (v7 >= 4)
    v11 = ~v6 + a2;
  else
    v11 = (~(_BYTE)v6 + a2);
  bzero(a1, v7);
  if ((_DWORD)v7 == 1)
    *a1 = v11;
  else
    *(_DWORD *)a1 = v11;
  __asm { BR              X10 }
}

void sub_1000C368C()
{
  uint64_t v0;
  uint64_t v1;
  char v2;

  *(_BYTE *)(v0 + v1) = v2;
}

void sub_1000C3694(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;

  *(_DWORD *)(v2 + v3) = 0;
  if (a2)
    JUMPOUT(0x1000C369CLL);
}

void sub_1000C36D8()
{
  uint64_t v0;
  uint64_t v1;
  __int16 v2;

  *(_WORD *)(v0 + v1) = v2;
}

void sub_1000C36E0()
{
  uint64_t v0;
  uint64_t v1;
  int v2;

  *(_DWORD *)(v0 + v1) = v2;
}

uint64_t sub_1000C36E8(uint64_t a1, int a2, unsigned int a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *(_WORD *)(v6 + v7) = 0;
  if (!a2)
LABEL_2:
    JUMPOUT(0x1000C36F0);
  if (a3 < 0xFE)
  {
    *(_BYTE *)(((v5 + v6) & 0xFFFFFFFFFFFFFFF8) + 24) = a2 + 1;
    goto LABEL_2;
  }
  return (*(uint64_t (**)(uint64_t))(v4 + 56))(v6);
}

uint64_t sub_1000C372C(uint64_t a1)
{
  uint64_t result;
  unint64_t v3;
  _QWORD v4[2];

  v4[0] = (char *)&value witness table for Builtin.NativeObject + 64;
  result = swift_checkMetadataState(319, *(_QWORD *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    v4[1] = *(_QWORD *)(result - 8) + 64;
    swift_initStructMetadata(a1, 0, 2, v4, a1 + 32);
    return 0;
  }
  return result;
}

uint64_t *sub_1000C37A8(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v12;
  uint64_t v13;
  void (*v14)(uint64_t, uint64_t, uint64_t);

  v4 = *(_QWORD *)(a3 + 16);
  v5 = *(_QWORD *)(v4 - 8);
  v6 = *(_DWORD *)(v5 + 80);
  v7 = ((v6 + 8) & ~v6) + *(_QWORD *)(v5 + 64);
  v8 = *(_DWORD *)(v5 + 80) & 0x100000;
  v9 = *a2;
  *a1 = *a2;
  if (v6 > 7 || v8 != 0 || v7 > 0x18)
  {
    a1 = (uint64_t *)(v9 + ((v6 & 0xF8 ^ 0x1F8) & (v6 + 16)));
    swift_retain(v9);
  }
  else
  {
    v12 = ((unint64_t)a1 + v6 + 8) & ~v6;
    v13 = ((unint64_t)a2 + v6 + 8) & ~v6;
    v14 = *(void (**)(uint64_t, uint64_t, uint64_t))(v5 + 16);
    swift_retain(v9);
    v14(v12, v13, v4);
  }
  return a1;
}

uint64_t sub_1000C3864(_QWORD *a1, uint64_t a2)
{
  swift_release(*a1);
  return (*(uint64_t (**)(unint64_t))(*(_QWORD *)(*(_QWORD *)(a2 + 16) - 8) + 8))(((unint64_t)a1 + *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) - 8) + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) - 8) + 80));
}

uint64_t *sub_1000C38A8(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void (*v10)(uint64_t, uint64_t, uint64_t);

  v4 = *a2;
  *a1 = *a2;
  v5 = *(_QWORD *)(a3 + 16);
  v6 = *(_QWORD *)(v5 - 8);
  v7 = *(unsigned __int8 *)(v6 + 80);
  v8 = ((unint64_t)a1 + v7 + 8) & ~v7;
  v9 = ((unint64_t)a2 + v7 + 8) & ~v7;
  v10 = *(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 16);
  swift_retain(v4);
  v10(v8, v9, v5);
  return a1;
}

uint64_t *sub_1000C3918(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v6 = *a2;
  v7 = *a1;
  *a1 = *a2;
  swift_retain(v6);
  swift_release(v7);
  v8 = *(_QWORD *)(*(_QWORD *)(a3 + 16) - 8);
  (*(void (**)(unint64_t, unint64_t))(v8 + 24))(((unint64_t)a1 + *(unsigned __int8 *)(v8 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v8 + 80), ((unint64_t)a2 + *(unsigned __int8 *)(v8 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v8 + 80));
  return a1;
}

_QWORD *sub_1000C3988(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v4;

  *a1 = *a2;
  v4 = *(_QWORD *)(*(_QWORD *)(a3 + 16) - 8);
  (*(void (**)(unint64_t, unint64_t))(v4 + 32))(((unint64_t)a1 + *(unsigned __int8 *)(v4 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80), ((unint64_t)a2 + *(unsigned __int8 *)(v4 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80));
  return a1;
}

uint64_t *sub_1000C39D8(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;

  v6 = *a1;
  *a1 = *a2;
  swift_release(v6);
  v7 = *(_QWORD *)(*(_QWORD *)(a3 + 16) - 8);
  (*(void (**)(unint64_t, unint64_t))(v7 + 40))(((unint64_t)a1 + *(unsigned __int8 *)(v7 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80), ((unint64_t)a2 + *(unsigned __int8 *)(v7 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80));
  return a1;
}

uint64_t sub_1000C3A40(_QWORD *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  char v10;
  int v11;
  unsigned int v13;
  int v14;
  uint64_t v15;

  v4 = *(_QWORD *)(*(_QWORD *)(a3 + 16) - 8);
  v5 = *(_DWORD *)(v4 + 84);
  if (v5 <= 0x7FFFFFFF)
    v6 = 0x7FFFFFFF;
  else
    v6 = *(_DWORD *)(v4 + 84);
  if (!a2)
    return 0;
  v7 = *(unsigned __int8 *)(v4 + 80);
  v8 = a2 - v6;
  if (a2 <= v6)
    goto LABEL_22;
  v9 = ((v7 + 8) & ~v7) + *(_QWORD *)(v4 + 64);
  v10 = 8 * v9;
  if (v9 <= 3)
  {
    v13 = ((v8 + ~(-1 << v10)) >> v10) + 1;
    if (HIWORD(v13))
    {
      v11 = *(_DWORD *)((char *)a1 + v9);
      if (!v11)
        goto LABEL_22;
      goto LABEL_15;
    }
    if (v13 > 0xFF)
    {
      v11 = *(unsigned __int16 *)((char *)a1 + v9);
      if (!*(_WORD *)((char *)a1 + v9))
        goto LABEL_22;
      goto LABEL_15;
    }
    if (v13 < 2)
    {
LABEL_22:
      if ((v5 & 0x80000000) != 0)
        return (*(uint64_t (**)(unint64_t))(v4 + 48))(((unint64_t)a1 + v7 + 8) & ~v7);
      v15 = *a1;
      if (*a1 >= 0xFFFFFFFFuLL)
        LODWORD(v15) = -1;
      return (v15 + 1);
    }
  }
  v11 = *((unsigned __int8 *)a1 + v9);
  if (!*((_BYTE *)a1 + v9))
    goto LABEL_22;
LABEL_15:
  v14 = (v11 - 1) << v10;
  if (v9 > 3)
    v14 = 0;
  if (!(_DWORD)v9)
    return v6 + v14 + 1;
  if (v9 > 3)
    LODWORD(v9) = 4;
  return ((uint64_t (*)(void))((char *)&loc_1000C3B14 + 4 * byte_10033FA5B[(v9 - 1)]))();
}

void sub_1000C3B84(_WORD *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v5;
  unsigned int v6;
  size_t v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  int v11;

  v5 = *(_QWORD *)(*(_QWORD *)(a4 + 16) - 8);
  if (*(_DWORD *)(v5 + 84) <= 0x7FFFFFFFu)
    v6 = 0x7FFFFFFF;
  else
    v6 = *(_DWORD *)(v5 + 84);
  v7 = ((*(unsigned __int8 *)(v5 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v5 + 80)) + *(_QWORD *)(v5 + 64);
  if (a3 > v6)
  {
    if (v7 <= 3)
    {
      v10 = ((a3 - v6 + ~(-1 << (8 * v7))) >> (8 * v7)) + 1;
      if (HIWORD(v10))
      {
        v8 = &dword_100000004;
      }
      else if (v10 >= 0x100)
      {
        v8 = 2;
      }
      else
      {
        v8 = v10 > 1;
      }
    }
    else
    {
      v8 = &_mh_execute_header.magic + 1;
    }
  }
  else
  {
    v8 = 0;
  }
  if (v6 < a2)
  {
    v9 = ~v6 + a2;
    if (v7 < 4)
    {
      if ((_DWORD)v7)
      {
        v11 = v9 & ~(-1 << (8 * v7));
        bzero(a1, v7);
        if ((_DWORD)v7 == 3)
        {
          *a1 = v11;
          *((_BYTE *)a1 + 2) = BYTE2(v11);
        }
        else if ((_DWORD)v7 == 2)
        {
          *a1 = v11;
        }
        else
        {
          *(_BYTE *)a1 = v11;
        }
      }
    }
    else
    {
      bzero(a1, v7);
      *(_DWORD *)a1 = v9;
    }
    __asm { BR              X10 }
  }
  __asm { BR              X13 }
}

uint64_t sub_1000C3D78(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_allocateGenericValueMetadata(a1, a2, a3, 16);
}

uint64_t InfraAssociationStartEvent.init(channel:)(uint64_t a1)
{
  return a1 & 0xFFFFFFFFFFFFLL;
}

void __swiftcall InfraAssociationJoinStatus.SubstateInformation.init(bssid:authorizationStatus:associationStatus:setSSIDStatus:supplicantEventStatus:)(CoreP2P::InfraAssociationJoinStatus::SubstateInformation *__return_ptr retstr, CoreP2P::WiFiAddress *bssid, CoreP2P::IEEE80211StatusAndReason_optional authorizationStatus, CoreP2P::IEEE80211StatusAndReason_optional associationStatus, CoreP2P::IEEE80211StatusAndReason_optional setSSIDStatus, CoreP2P::IEEE80211StatusAndReason_optional supplicantEventStatus)
{
  ;
}

__n128 InfraAssociationReadyEvent.init(status:ipAddress:)@<Q0>(__int16 a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  char v5;
  __n128 result;
  __int128 v7;
  _OWORD v8[2];
  char v9;

  sub_1000C3DF4(a2, (uint64_t)v8);
  v5 = v9;
  result = (__n128)v8[0];
  v7 = v8[1];
  *(_WORD *)a3 = a1;
  *(__n128 *)(a3 + 8) = result;
  *(_OWORD *)(a3 + 24) = v7;
  *(_BYTE *)(a3 + 40) = v5;
  return result;
}

uint64_t sub_1000C3DF4(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = sub_100012C44(&qword_100406E10);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 - 8) + 32))(a2, a1, v4);
  return a2;
}

void InfraScanStartEvent.hash(into:)(uint64_t a1, uint64_t a2)
{
  Swift::UInt v3;
  unsigned __int8 *v4;
  Swift::UInt v5;
  char v6;
  int v7;

  v3 = *(_QWORD *)(a2 + 16);
  Hasher._combine(_:)(v3);
  if (v3)
  {
    v4 = (unsigned __int8 *)(a2 + 37);
    do
    {
      v6 = *(v4 - 1);
      v7 = *v4;
      Hasher._combine(_:)(*(_DWORD *)(v4 - 5));
      Hasher._combine(_:)(0x801004u >> (8 * v6));
      switch(v7)
      {
        case 2:
          v5 = 0;
          goto LABEL_4;
        case 3:
          v5 = 1;
          goto LABEL_4;
        case 4:
          v5 = 3;
          goto LABEL_4;
        case 5:
          v5 = 4;
          goto LABEL_4;
        case 6:
          v5 = 5;
LABEL_4:
          Hasher._combine(_:)(v5);
          break;
        default:
          Hasher._combine(_:)(2uLL);
          Hasher._combine(_:)(v7 & 1);
          break;
      }
      v4 += 8;
      --v3;
    }
    while (v3);
  }
}

Swift::Int InfraScanStartEvent.hashValue.getter(uint64_t a1)
{
  _QWORD v3[9];

  Hasher.init(_seed:)(v3);
  sub_10008E464((uint64_t)v3, a1);
  return Hasher._finalize()();
}

Swift::Int sub_1000C3F68()
{
  uint64_t *v0;
  uint64_t v1;
  _QWORD v3[9];

  v1 = *v0;
  Hasher.init(_seed:)(v3);
  sub_10008E464((uint64_t)v3, v1);
  return Hasher._finalize()();
}

void sub_1000C3FAC(uint64_t a1)
{
  uint64_t *v1;

  InfraScanStartEvent.hash(into:)(a1, *v1);
}

Swift::Int sub_1000C3FB4()
{
  uint64_t *v0;
  uint64_t v1;
  _QWORD v3[9];

  v1 = *v0;
  Hasher.init(_seed:)(v3);
  InfraScanStartEvent.hash(into:)((uint64_t)v3, v1);
  return Hasher._finalize()();
}

uint64_t sub_1000C3FF4(uint64_t *a1, uint64_t *a2)
{
  return _s7CoreP2P19InfraScanStartEventV23__derived_struct_equalsySbAC_ACtFZ_0(*a1, *a2);
}

uint64_t InfraAssociationStartEvent.channel.setter(uint64_t result)
{
  uint64_t v1;

  *(_DWORD *)v1 = result;
  *(_BYTE *)(v1 + 4) = BYTE4(result);
  *(_BYTE *)(v1 + 5) = BYTE5(result);
  return result;
}

void InfraAssociationStartEvent.hash(into:)(int a1, unint64_t a2)
{
  Swift::UInt v3;

  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(0x801004u >> ((a2 >> 29) & 0xF8));
  switch(BYTE5(a2))
  {
    case 2:
      v3 = 0;
      goto LABEL_8;
    case 3:
      v3 = 1;
      goto LABEL_8;
    case 4:
      v3 = 3;
      goto LABEL_8;
    case 5:
      v3 = 4;
      goto LABEL_8;
    case 6:
      v3 = 5;
LABEL_8:
      Hasher._combine(_:)(v3);
      break;
    default:
      Hasher._combine(_:)(2uLL);
      Hasher._combine(_:)(BYTE5(a2) & 1);
      break;
  }
}

uint64_t static InfraAssociationStartEvent.__derived_struct_equals(_:_:)(unint64_t a1, unint64_t a2)
{
  uint64_t result;

  if ((_DWORD)a1 != (_DWORD)a2
    || ((0x801004u >> ((a1 >> 29) & 0xF8)) & 0xFFC) != ((0x801004u >> ((a2 >> 29) & 0xF8)) & 0xFFC))
  {
    return 0;
  }
  switch(BYTE5(a1))
  {
    case 2:
      if (BYTE5(a2) != 2)
        return 0;
      result = 1;
      break;
    case 3:
      if (BYTE5(a2) != 3)
        return 0;
      result = 1;
      break;
    case 4:
      if (BYTE5(a2) != 4)
        return 0;
      result = 1;
      break;
    case 5:
      if (BYTE5(a2) != 5)
        return 0;
      result = 1;
      break;
    case 6:
      if (BYTE5(a2) != 6)
        return 0;
      result = 1;
      break;
    default:
      if (BYTE5(a2) - 2 < 5 || ((a1 & 0x10000000000) == 0) == ((a2 >> 40) & 1))
        return 0;
      result = 1;
      break;
  }
  return result;
}

Swift::Int InfraAssociationStartEvent.hashValue.getter(unint64_t a1)
{
  Swift::UInt v2;
  _QWORD v4[9];

  Hasher.init(_seed:)(v4);
  Hasher._combine(_:)(a1);
  Hasher._combine(_:)(0x801004u >> ((a1 >> 29) & 0xF8));
  switch(BYTE5(a1))
  {
    case 2:
      v2 = 0;
      goto LABEL_8;
    case 3:
      v2 = 1;
      goto LABEL_8;
    case 4:
      v2 = 3;
      goto LABEL_8;
    case 5:
      v2 = 4;
      goto LABEL_8;
    case 6:
      v2 = 5;
LABEL_8:
      Hasher._combine(_:)(v2);
      break;
    default:
      Hasher._combine(_:)(2uLL);
      Hasher._combine(_:)(BYTE5(a1) & 1);
      break;
  }
  return Hasher._finalize()();
}

Swift::Int sub_1000C4284()
{
  unsigned int *v0;

  return InfraAssociationStartEvent.hashValue.getter(*v0 | ((unint64_t)*((unsigned __int8 *)v0 + 4) << 32) | ((unint64_t)*((unsigned __int8 *)v0 + 5) << 40));
}

void sub_1000C429C(int a1)
{
  unsigned int *v1;

  InfraAssociationStartEvent.hash(into:)(a1, *v1 | ((unint64_t)*((unsigned __int8 *)v1 + 4) << 32) | ((unint64_t)*((unsigned __int8 *)v1 + 5) << 40));
}

Swift::Int sub_1000C42B4()
{
  uint64_t v0;
  Swift::UInt32 v1;
  char v2;
  int v3;
  Swift::UInt v4;
  _QWORD v6[9];

  v1 = *(_DWORD *)v0;
  v2 = *(_BYTE *)(v0 + 4);
  v3 = *(unsigned __int8 *)(v0 + 5);
  Hasher.init(_seed:)(v6);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(0x801004u >> (8 * v2));
  switch(v3)
  {
    case 2:
      v4 = 0;
      goto LABEL_8;
    case 3:
      v4 = 1;
      goto LABEL_8;
    case 4:
      v4 = 3;
      goto LABEL_8;
    case 5:
      v4 = 4;
      goto LABEL_8;
    case 6:
      v4 = 5;
LABEL_8:
      Hasher._combine(_:)(v4);
      break;
    default:
      Hasher._combine(_:)(2uLL);
      Hasher._combine(_:)(v3 & 1);
      break;
  }
  return Hasher._finalize()();
}

uint64_t sub_1000C439C(uint64_t a1, uint64_t a2)
{
  int v2;

  if (*(_DWORD *)a1 != *(_DWORD *)a2
    || ((0x801004u >> (8 * *(_BYTE *)(a1 + 4))) & 0xFFC) != ((0x801004u >> (8 * *(_BYTE *)(a2 + 4))) & 0xFFC))
  {
    return 0;
  }
  v2 = *(unsigned __int8 *)(a2 + 5);
  switch(*(_BYTE *)(a1 + 5))
  {
    case 2:
      if (v2 != 2)
        return 0;
      break;
    case 3:
      if (v2 != 3)
        return 0;
      break;
    case 4:
      if (v2 != 4)
        return 0;
      break;
    case 5:
      if (v2 != 5)
        return 0;
      break;
    case 6:
      if (v2 != 6)
        return 0;
      break;
    default:
      if ((v2 - 2) < 5 || ((((*(_BYTE *)(a1 + 5) & 1) == 0) ^ v2) & 1) == 0)
        return 0;
      break;
  }
  return 1;
}

uint64_t InfraAssociationJoinStatus.SubstateInformation.bssid.setter(uint64_t result)
{
  uint64_t v1;

  *(_WORD *)v1 = result;
  *(_BYTE *)(v1 + 2) = BYTE2(result);
  *(_BYTE *)(v1 + 3) = BYTE3(result);
  *(_BYTE *)(v1 + 4) = BYTE4(result);
  *(_BYTE *)(v1 + 5) = BYTE5(result);
  return result;
}

unint64_t IEEE80211InformationElement.VeryHighThroughputCapability.rxHighLGIRate.getter(unint64_t a1)
{
  return HIWORD(a1);
}

uint64_t IEEE80211InformationElement.VeryHighThroughputCapability.rxHighLGIRate.setter(uint64_t result)
{
  uint64_t v1;

  *(_WORD *)(v1 + 6) = result;
  return result;
}

uint64_t IEEE80211InformationElement.VeryHighThroughputCapability.txMCSMap.setter(uint64_t result)
{
  uint64_t v1;

  *(_WORD *)(v1 + 8) = result;
  return result;
}

unint64_t InfraAssociationJoinStatus.SubstateInformation.setSSIDStatus.getter(uint64_t a1, unint64_t a2)
{
  return a2 >> 16;
}

uint64_t IEEE80211InformationElement.VeryHighThroughputCapability.txHighLGIRate.setter(uint64_t result)
{
  uint64_t v1;

  *(_WORD *)(v1 + 10) = result;
  return result;
}

uint64_t (*IEEE80211InformationElement.VeryHighThroughputCapability.txHighLGIRate.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

unint64_t InfraAssociationJoinStatus.SubstateInformation.supplicantEventStatus.getter(uint64_t a1, unint64_t a2)
{
  return HIDWORD(a2);
}

uint64_t InfraAssociationJoinStatus.SubstateInformation.supplicantEventStatus.setter(uint64_t result)
{
  uint64_t v1;

  *(_WORD *)(v1 + 12) = result;
  return result;
}

uint64_t (*InfraAssociationJoinStatus.SubstateInformation.supplicantEventStatus.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

void InfraAssociationJoinStatus.SubstateInformation.hash(into:)(int a1, unint64_t a2, uint64_t a3)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;

  v5 = a2 >> 8;
  v6 = a2 >> 16;
  v7 = a2 >> 24;
  v8 = HIDWORD(a2);
  v9 = a2 >> 40;
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  if (HIBYTE(a2) == 34)
  {
    Hasher._combine(_:)(0);
  }
  else
  {
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(word_10034042E[(uint64_t)(a2 << 8) >> 56]);
    Hasher._combine(_:)(word_10034049A[(uint64_t)a2 >> 56]);
  }
  if ((a3 & 0xFF00) == 0x2200)
  {
    Hasher._combine(_:)(0);
  }
  else
  {
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(word_10034042E[(char)a3]);
    Hasher._combine(_:)(word_10034049A[(uint64_t)(__int16)a3 >> 8]);
  }
  if ((a3 & 0xFF000000) == 0x22000000)
  {
    Hasher._combine(_:)(0);
  }
  else
  {
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(word_10034042E[a3 << 40 >> 56]);
    Hasher._combine(_:)(word_10034049A[(uint64_t)(int)a3 >> 24]);
  }
  if ((a3 & 0xFF0000000000) == 0x220000000000)
  {
    Hasher._combine(_:)(0);
  }
  else
  {
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(word_10034042E[a3 << 24 >> 56]);
    Hasher._combine(_:)(word_10034049A[a3 << 16 >> 56]);
  }
}

BOOL static InfraAssociationJoinStatus.SubstateInformation.__derived_struct_equals(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1000C4FB8(a1, a2 & 0xFFFFFFFFFFFFLL, a3, a4 & 0xFFFFFFFFFFFFLL);
}

Swift::Int InfraAssociationJoinStatus.SubstateInformation.hashValue.getter(unint64_t a1, uint64_t a2)
{
  _QWORD v5[9];

  Hasher.init(_seed:)(v5);
  InfraAssociationJoinStatus.SubstateInformation.hash(into:)((int)v5, a1, a2 & 0xFFFFFFFFFFFFLL);
  return Hasher._finalize()();
}

Swift::Int sub_1000C46CC()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  _QWORD v5[9];

  v1 = *(unsigned int *)(v0 + 8);
  v2 = *(unsigned __int16 *)(v0 + 12);
  v3 = *(_QWORD *)v0;
  Hasher.init(_seed:)(v5);
  InfraAssociationJoinStatus.SubstateInformation.hash(into:)((int)v5, v3, v1 | (v2 << 32));
  return Hasher._finalize()();
}

void sub_1000C4724(int a1)
{
  uint64_t v1;

  InfraAssociationJoinStatus.SubstateInformation.hash(into:)(a1, *(_QWORD *)v1, *(unsigned int *)(v1 + 8) | ((unint64_t)*(unsigned __int16 *)(v1 + 12) << 32));
}

Swift::Int sub_1000C4738()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  _QWORD v5[9];

  v1 = *(unsigned int *)(v0 + 8);
  v2 = *(unsigned __int16 *)(v0 + 12);
  v3 = *(_QWORD *)v0;
  Hasher.init(_seed:)(v5);
  InfraAssociationJoinStatus.SubstateInformation.hash(into:)((int)v5, v3, v1 | (v2 << 32));
  return Hasher._finalize()();
}

BOOL sub_1000C478C(uint64_t a1, uint64_t a2)
{
  return sub_1000C4FB8(*(_QWORD *)a1, *(unsigned int *)(a1 + 8) | ((unint64_t)*(unsigned __int16 *)(a1 + 12) << 32), *(_QWORD *)a2, *(unsigned int *)(a2 + 8) | ((unint64_t)*(unsigned __int16 *)(a2 + 12) << 32));
}

uint64_t InfraAssociationJoinStatus.returnValue.setter(uint64_t result)
{
  uint64_t v1;

  *(_DWORD *)(v1 + 8) = result;
  return result;
}

uint64_t InfraAssociationJoinStatus.ieeeStatus.setter(uint64_t result)
{
  uint64_t v1;

  *(_DWORD *)(v1 + 12) = result;
  return result;
}

uint64_t NANDataRequestReceivedEvent.attributes.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_bridgeObjectRetain(a3);
}

uint64_t IEEE80211InformationElement.RSNCapability.authenticationKeyManagementSuites.setter(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;

  result = swift_bridgeObjectRelease(*(_QWORD *)(v1 + 16));
  *(_QWORD *)(v1 + 16) = a1;
  return result;
}

uint64_t NANBeacon.Metadata.tsf.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a4;
}

uint64_t InfraAssociationJoinStatus.extensionReturnValue.setter(uint64_t result)
{
  uint64_t v1;

  *(_DWORD *)(v1 + 24) = result;
  return result;
}

uint64_t (*NANBeacon.Metadata.tsf.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

void InfraAssociationJoinStatus.hash(into:)(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, Swift::UInt32 a5)
{
  Swift::UInt32 v7;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;

  v7 = a3;
  v9 = a2 >> 8;
  v10 = a2 >> 16;
  v11 = a2 >> 24;
  v12 = HIDWORD(a2);
  v13 = a2 >> 40;
  v14 = HIDWORD(a3);
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(v11);
  Hasher._combine(_:)(v12);
  Hasher._combine(_:)(v13);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v14);
  sub_10008E188(a1, a4);
  Hasher._combine(_:)(a5);
}

uint64_t static InfraAssociationJoinStatus.__derived_struct_equals(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  return sub_1000C5200(a1 & 0xFFFFFFFFFFFFLL, a2, a3, a4, a5 & 0xFFFFFFFFFFFFLL, a6, a7, a8);
}

Swift::Int InfraAssociationJoinStatus.hashValue.getter(unint64_t a1, unint64_t a2, uint64_t a3, Swift::UInt32 a4)
{
  Swift::UInt32 v5;
  Swift::UInt8 v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  _QWORD v15[9];

  v5 = a2;
  v6 = a1;
  v7 = a1 >> 8;
  v8 = a1 >> 16;
  v9 = a1 >> 24;
  v10 = HIDWORD(a1);
  v11 = a1 >> 40;
  v12 = HIDWORD(a2);
  Hasher.init(_seed:)(v15);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(v11);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v12);
  sub_10008E188((uint64_t)v15, a3);
  Hasher._combine(_:)(a4);
  return Hasher._finalize()();
}

Swift::Int sub_1000C49C8()
{
  uint64_t v0;
  Swift::UInt32 v1;
  Swift::UInt32 v2;
  uint64_t v3;
  Swift::UInt8 v4;
  Swift::UInt8 v5;
  Swift::UInt8 v6;
  Swift::UInt8 v7;
  Swift::UInt8 v8;
  Swift::UInt8 v9;
  Swift::UInt32 v11;
  _QWORD v12[9];

  v1 = *(_DWORD *)(v0 + 8);
  v2 = *(_DWORD *)(v0 + 12);
  v3 = *(_QWORD *)(v0 + 16);
  v11 = *(_DWORD *)(v0 + 24);
  v4 = *(_BYTE *)v0;
  v5 = *(_BYTE *)(v0 + 1);
  v6 = *(_BYTE *)(v0 + 2);
  v7 = *(_BYTE *)(v0 + 3);
  v8 = *(_BYTE *)(v0 + 4);
  v9 = *(_BYTE *)(v0 + 5);
  Hasher.init(_seed:)(v12);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  sub_10008E188((uint64_t)v12, v3);
  Hasher._combine(_:)(v11);
  return Hasher._finalize()();
}

void sub_1000C4ABC(uint64_t a1)
{
  uint64_t v1;
  Swift::UInt32 v3;
  Swift::UInt32 v4;
  uint64_t v5;
  Swift::UInt8 v6;
  Swift::UInt8 v7;
  Swift::UInt8 v8;
  Swift::UInt8 v9;
  Swift::UInt8 v10;
  Swift::UInt32 v11;

  v3 = *(_DWORD *)(v1 + 8);
  v4 = *(_DWORD *)(v1 + 12);
  v5 = *(_QWORD *)(v1 + 16);
  v11 = *(_DWORD *)(v1 + 24);
  v6 = *(_BYTE *)(v1 + 1);
  v7 = *(_BYTE *)(v1 + 2);
  v8 = *(_BYTE *)(v1 + 3);
  v9 = *(_BYTE *)(v1 + 4);
  v10 = *(_BYTE *)(v1 + 5);
  Hasher._combine(_:)(*(_BYTE *)v1);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  sub_10008E188(a1, v5);
  Hasher._combine(_:)(v11);
}

Swift::Int sub_1000C4B7C()
{
  uint64_t v0;
  Swift::UInt32 v1;
  Swift::UInt32 v2;
  uint64_t v3;
  Swift::UInt8 v4;
  Swift::UInt8 v5;
  Swift::UInt8 v6;
  Swift::UInt8 v7;
  Swift::UInt8 v8;
  Swift::UInt8 v9;
  Swift::UInt32 v11;
  _QWORD v12[9];

  v1 = *(_DWORD *)(v0 + 8);
  v2 = *(_DWORD *)(v0 + 12);
  v3 = *(_QWORD *)(v0 + 16);
  v11 = *(_DWORD *)(v0 + 24);
  v4 = *(_BYTE *)v0;
  v5 = *(_BYTE *)(v0 + 1);
  v6 = *(_BYTE *)(v0 + 2);
  v7 = *(_BYTE *)(v0 + 3);
  v8 = *(_BYTE *)(v0 + 4);
  v9 = *(_BYTE *)(v0 + 5);
  Hasher.init(_seed:)(v12);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  sub_10008E188((uint64_t)v12, v3);
  Hasher._combine(_:)(v11);
  return Hasher._finalize()();
}

uint64_t sub_1000C4C6C(unsigned int *a1, unsigned int *a2)
{
  return sub_1000C5200(*a1 | ((unint64_t)*((unsigned __int8 *)a1 + 4) << 32) | ((unint64_t)*((unsigned __int8 *)a1 + 5) << 40), *((_QWORD *)a1 + 1), *((_QWORD *)a1 + 2), a1[6], *a2 | ((unint64_t)*((unsigned __int8 *)a2 + 4) << 32) | ((unint64_t)*((unsigned __int8 *)a2 + 5) << 40), *((_QWORD *)a2 + 1), *((_QWORD *)a2 + 2), a2[6]);
}

uint64_t InfraAssociationReadyEvent.ipAddress.getter@<X0>(uint64_t a1@<X8>)
{
  uint64_t v1;

  return sub_1000C52D0(v1 + 8, a1);
}

uint64_t InfraAssociationReadyEvent.ipAddress.setter(uint64_t a1)
{
  uint64_t v1;

  return sub_1000C5318(a1, v1 + 8);
}

void InfraAssociationReadyEvent.hash(into:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  __n128 v12;
  _QWORD v13[2];
  uint64_t v14;

  v2 = v1;
  Hasher._combine(_:)(*(_WORD *)v2);
  v4 = *(unsigned __int8 *)(v2 + 40);
  if (v4 == 255)
  {
    Hasher._combine(_:)(0);
    return;
  }
  v5 = *(_QWORD *)(v2 + 8);
  v6 = *(_QWORD *)(v2 + 16);
  v7 = *(_QWORD *)(v2 + 24);
  v8 = *(_QWORD *)(v2 + 32);
  Hasher._combine(_:)(1u);
  if ((v4 & 1) != 0)
  {
    v13[0] = v5;
    v13[1] = v6;
    swift_bridgeObjectRetain_n(v8, 3);
    v9 = sub_1000FADC0((uint64_t)v13, (uint64_t)&v14);
    v11 = v10;
    Data.hash(into:)(a1, v9, v10, v12);
    sub_10000E614(v9, v11);
    if (v8)
    {
      Hasher._combine(_:)(1u);
      swift_bridgeObjectRetain(v8);
      String.hash(into:)(a1, v7, v8);
      sub_1000C5CE0(v2, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))sub_100062394);
      sub_1000C5CE0(v2, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))sub_100062394);
      sub_1000C5CE0(v2, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))sub_100062394);
      sub_1000623AC(v5, v6, v7, v8, 1);
      return;
    }
    Hasher._combine(_:)(0);
    sub_1000C5CE0(v2, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))sub_100062394);
  }
  else
  {
    Hasher._combine(_:)(v5);
  }
  sub_1000C5CE0(v2, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))sub_100062394);
  sub_1000C5CE0(v2, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))sub_100062394);
}

Swift::Int InfraAssociationReadyEvent.hashValue.getter()
{
  _QWORD v1[9];

  Hasher.init(_seed:)(v1);
  InfraAssociationReadyEvent.hash(into:)((uint64_t)v1);
  return Hasher._finalize()();
}

Swift::Int sub_1000C4E9C()
{
  __int128 *v0;
  __int128 v1;
  _QWORD v3[9];
  __int128 v4;
  _OWORD v5[2];

  v1 = v0[1];
  v4 = *v0;
  v5[0] = v1;
  *(_OWORD *)((char *)v5 + 9) = *(__int128 *)((char *)v0 + 25);
  Hasher.init(_seed:)(v3);
  InfraAssociationReadyEvent.hash(into:)((uint64_t)v3);
  return Hasher._finalize()();
}

void sub_1000C4EEC(uint64_t a1)
{
  InfraAssociationReadyEvent.hash(into:)(a1);
}

Swift::Int sub_1000C4F24()
{
  __int128 *v0;
  __int128 v1;
  _QWORD v3[9];
  __int128 v4;
  _OWORD v5[2];

  v1 = v0[1];
  v4 = *v0;
  v5[0] = v1;
  *(_OWORD *)((char *)v5 + 9) = *(__int128 *)((char *)v0 + 25);
  Hasher.init(_seed:)(v3);
  InfraAssociationReadyEvent.hash(into:)((uint64_t)v3);
  return Hasher._finalize()();
}

uint64_t sub_1000C4F70(__int128 *a1, __int128 *a2)
{
  __int128 v2;
  __int128 v3;
  __int128 v5;
  _OWORD v6[2];
  __int128 v7;
  _OWORD v8[2];

  v2 = a1[1];
  v5 = *a1;
  v6[0] = v2;
  *(_OWORD *)((char *)v6 + 9) = *(__int128 *)((char *)a1 + 25);
  v3 = a2[1];
  v7 = *a2;
  v8[0] = v3;
  *(_OWORD *)((char *)v8 + 9) = *(__int128 *)((char *)a2 + 25);
  return _s7CoreP2P26InfraAssociationReadyEventV23__derived_struct_equalsySbAC_ACtFZ_0((unsigned __int16 *)&v5, (unsigned __int16 *)&v7) & 1;
}

BOOL sub_1000C4FB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int16 v10;
  __int16 v11;

  LOBYTE(v11) = BYTE4(a1);
  HIBYTE(v11) = BYTE5(a1);
  LOBYTE(v10) = BYTE4(a3);
  HIBYTE(v10) = BYTE5(a3);
  if ((_DWORD)a1 != (_DWORD)a3 || v11 != v10)
    return 0;
  v6 = a3 & 0xFF00000000000000;
  if (HIBYTE(a1) == 34)
  {
    if (v6 != 0x2200000000000000)
      return 0;
  }
  else if (v6 == 0x2200000000000000
         || word_10034042E[a1 << 8 >> 56] != word_10034042E[a3 << 8 >> 56]
         || word_10034049A[a1 >> 56] != word_10034049A[a3 >> 56])
  {
    return 0;
  }
  v7 = (unsigned __int16)a4 & 0xFF00;
  if ((a2 & 0xFF00) == 0x2200)
  {
    if (v7 != 8704)
      return 0;
  }
  else if (v7 == 8704
         || word_10034042E[(char)a2] != word_10034042E[(char)a4]
         || word_10034049A[(uint64_t)(__int16)a2 >> 8] != word_10034049A[(uint64_t)(__int16)a4 >> 8])
  {
    return 0;
  }
  v8 = a4 & 0xFF000000;
  if ((a2 & 0xFF000000) == 0x22000000)
  {
    if (v8 != 570425344)
      return 0;
  }
  else if (v8 == 570425344
         || word_10034042E[a2 << 40 >> 56] != word_10034042E[a4 << 40 >> 56]
         || word_10034049A[(uint64_t)(int)a2 >> 24] != word_10034049A[(uint64_t)(int)a4 >> 24])
  {
    return 0;
  }
  v9 = a4 & 0xFF0000000000;
  if ((a2 & 0xFF0000000000) != 0x220000000000)
    return v9 != 0x220000000000
        && word_10034042E[a2 << 24 >> 56] == word_10034042E[a4 << 24 >> 56]
        && word_10034049A[a2 << 16 >> 56] == word_10034049A[a4 << 16 >> 56];
  return v9 == 0x220000000000;
}

uint64_t sub_1000C5200(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  __int16 v13;
  __int16 v14;

  LOBYTE(v14) = BYTE4(a1);
  HIBYTE(v14) = BYTE5(a1);
  LOBYTE(v13) = BYTE4(a5);
  HIBYTE(v13) = BYTE5(a5);
  if ((_DWORD)a1 == (_DWORD)a5 && v14 == v13 && (_DWORD)a2 == (_DWORD)a6 && HIDWORD(a2) == HIDWORD(a6))
    return sub_100088E80(a3, a7) & (a4 == a8);
  else
    return 0;
}

uint64_t sub_1000C52D0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = sub_100012C44(&qword_100406E10);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 - 8) + 16))(a2, a1, v4);
  return a2;
}

uint64_t sub_1000C5318(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = sub_100012C44(&qword_100406E10);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 - 8) + 40))(a2, a1, v4);
  return a2;
}

uint64_t _s7CoreP2P26InfraAssociationReadyEventV23__derived_struct_equalsySbAC_ACtFZ_0(unsigned __int16 *a1, unsigned __int16 *a2)
{
  int v4;
  int v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  uint64_t v15;

  if (*a1 == *a2)
  {
    v4 = *((unsigned __int8 *)a1 + 40);
    v5 = *((unsigned __int8 *)a2 + 40);
    if (v4 == 255)
    {
      if (v5 == 255)
        return 1;
    }
    else if (v5 != 255)
    {
      v7 = *((_QWORD *)a1 + 1);
      v8 = *((_QWORD *)a2 + 1);
      if ((v4 & 1) != 0)
      {
        if ((v5 & 1) != 0)
        {
          v9 = *((_QWORD *)a1 + 3);
          v15 = *((_QWORD *)a1 + 2);
          v10 = *((_QWORD *)a1 + 4);
          v11 = *((_QWORD *)a2 + 2);
          v12 = *((_QWORD *)a2 + 3);
          v13 = *((_QWORD *)a2 + 4);
          sub_1000C5CE0((uint64_t)a2, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))sub_1000C5D18);
          sub_1000C5CE0((uint64_t)a1, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))sub_1000C5D18);
          v14 = _s7CoreP2P11IPv6AddressV2eeoiySbAC_ACtFZ_0(v7, v15, v9, v10, v8, v11, v12, v13);
          sub_1000C5CE0((uint64_t)a2, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))sub_100062394);
          sub_1000C5CE0((uint64_t)a1, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))sub_100062394);
          if ((v14 & 1) != 0)
            return 1;
        }
      }
      else if ((v5 & 1) == 0 && (_DWORD)v7 == (_DWORD)v8)
      {
        return 1;
      }
    }
  }
  return 0;
}

unint64_t sub_1000C5488()
{
  unint64_t result;

  result = qword_100406E18;
  if (!qword_100406E18)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for InfraScanStartEvent, &type metadata for InfraScanStartEvent);
    atomic_store(result, (unint64_t *)&qword_100406E18);
  }
  return result;
}

unint64_t sub_1000C54D0()
{
  unint64_t result;

  result = qword_100406E20;
  if (!qword_100406E20)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for InfraScanCompleteEvent, &type metadata for InfraScanCompleteEvent);
    atomic_store(result, (unint64_t *)&qword_100406E20);
  }
  return result;
}

unint64_t sub_1000C5518()
{
  unint64_t result;

  result = qword_100406E28;
  if (!qword_100406E28)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for InfraAssociationStartEvent, &type metadata for InfraAssociationStartEvent);
    atomic_store(result, (unint64_t *)&qword_100406E28);
  }
  return result;
}

unint64_t sub_1000C5560()
{
  unint64_t result;

  result = qword_100406E30;
  if (!qword_100406E30)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for InfraAssociationJoinStatus.SubstateInformation, &type metadata for InfraAssociationJoinStatus.SubstateInformation);
    atomic_store(result, (unint64_t *)&qword_100406E30);
  }
  return result;
}

unint64_t sub_1000C55A8()
{
  unint64_t result;

  result = qword_100406E38;
  if (!qword_100406E38)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for InfraAssociationJoinStatus, &type metadata for InfraAssociationJoinStatus);
    atomic_store(result, (unint64_t *)&qword_100406E38);
  }
  return result;
}

unint64_t sub_1000C55F0()
{
  unint64_t result;

  result = qword_100406E40;
  if (!qword_100406E40)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for InfraAssociationReadyEvent, &type metadata for InfraAssociationReadyEvent);
    atomic_store(result, (unint64_t *)&qword_100406E40);
  }
  return result;
}

ValueMetadata *type metadata accessor for InfraScanStartEvent()
{
  return &type metadata for InfraScanStartEvent;
}

ValueMetadata *type metadata accessor for InfraScanCompleteEvent()
{
  return &type metadata for InfraScanCompleteEvent;
}

uint64_t initializeBufferWithCopyOfBuffer for Channel(uint64_t result, int *a2)
{
  int v2;

  v2 = *a2;
  *(_WORD *)(result + 4) = *((_WORD *)a2 + 2);
  *(_DWORD *)result = v2;
  return result;
}

uint64_t getEnumTagSinglePayload for Channel(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  BOOL v4;
  int v5;

  if (!a2)
    return 0;
  if (a2 >= 0xFE && *(_BYTE *)(a1 + 6))
    return (*(_DWORD *)a1 + 254);
  v3 = *(unsigned __int8 *)(a1 + 4);
  v4 = v3 >= 3;
  v5 = v3 - 3;
  if (!v4)
    v5 = -1;
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for Channel(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFD)
  {
    *(_WORD *)(result + 4) = 0;
    *(_DWORD *)result = a2 - 254;
    if (a3 >= 0xFE)
      *(_BYTE *)(result + 6) = 1;
  }
  else
  {
    if (a3 >= 0xFE)
      *(_BYTE *)(result + 6) = 0;
    if (a2)
      *(_BYTE *)(result + 4) = a2 + 2;
  }
  return result;
}

ValueMetadata *type metadata accessor for InfraAssociationStartEvent()
{
  return &type metadata for InfraAssociationStartEvent;
}

uint64_t destroy for NANAttribute.RangingSetup(uint64_t a1)
{
  return swift_bridgeObjectRelease(*(_QWORD *)(a1 + 16));
}

uint64_t initializeWithCopy for InfraAssociationJoinStatus(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_WORD *)(a1 + 4) = *(_WORD *)(a2 + 4);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  v3 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 16) = v3;
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  swift_bridgeObjectRetain(v3);
  return a1;
}

uint64_t assignWithCopy for InfraAssociationJoinStatus(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_BYTE *)(a1 + 1) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)(a1 + 2) = *(_BYTE *)(a2 + 2);
  *(_BYTE *)(a1 + 3) = *(_BYTE *)(a2 + 3);
  *(_BYTE *)(a1 + 4) = *(_BYTE *)(a2 + 4);
  *(_BYTE *)(a1 + 5) = *(_BYTE *)(a2 + 5);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  v4 = *(_QWORD *)(a2 + 16);
  v5 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v4;
  swift_bridgeObjectRetain(v4);
  swift_bridgeObjectRelease(v5);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  return a1;
}

__n128 initializeWithTake for InfraAssociationJoinStatus(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)a2;
  *(_OWORD *)(a1 + 12) = *(_OWORD *)(a2 + 12);
  *(__n128 *)a1 = result;
  return result;
}

uint64_t assignWithTake for InfraAssociationJoinStatus(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_WORD *)(a1 + 4) = *(_WORD *)(a2 + 4);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  v4 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  swift_bridgeObjectRelease(v4);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  return a1;
}

uint64_t getEnumTagSinglePayload for InfraAssociationJoinStatus(uint64_t a1, int a2)
{
  unint64_t v2;

  if (!a2)
    return 0;
  if (a2 < 0 && *(_BYTE *)(a1 + 28))
    return *(_DWORD *)a1 + 0x80000000;
  v2 = *(_QWORD *)(a1 + 16);
  if (v2 >= 0xFFFFFFFF)
    LODWORD(v2) = -1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for InfraAssociationJoinStatus(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_QWORD *)(result + 8) = 0;
    *(_QWORD *)(result + 16) = 0;
    *(_DWORD *)(result + 24) = 0;
    *(_QWORD *)result = a2 ^ 0x80000000;
    if (a3 < 0)
      *(_BYTE *)(result + 28) = 1;
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
        return result;
LABEL_8:
      *(_QWORD *)(result + 16) = (a2 - 1);
      return result;
    }
    *(_BYTE *)(result + 28) = 0;
    if (a2)
      goto LABEL_8;
  }
  return result;
}

ValueMetadata *type metadata accessor for InfraAssociationJoinStatus()
{
  return &type metadata for InfraAssociationJoinStatus;
}

_QWORD *initializeBufferWithCopyOfBuffer for NANDataEstablishedEvent(_QWORD *result, uint64_t *a2)
{
  uint64_t v2;

  v2 = *a2;
  *(_QWORD *)((char *)result + 6) = *(uint64_t *)((char *)a2 + 6);
  *result = v2;
  return result;
}

uint64_t getEnumTagSinglePayload for InfraAssociationJoinStatus.SubstateInformation(uint64_t a1, unsigned int a2)
{
  int v3;
  int v4;
  int v5;

  if (!a2)
    return 0;
  if (a2 >= 0xDE && *(_BYTE *)(a1 + 14))
    return (*(_DWORD *)a1 + 222);
  if (*(unsigned __int8 *)(a1 + 7) <= 0x22u)
    v3 = 34;
  else
    v3 = *(unsigned __int8 *)(a1 + 7);
  v4 = v3 - 35;
  if (*(unsigned __int8 *)(a1 + 7) < 0x22u)
    v5 = -1;
  else
    v5 = v4;
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for InfraAssociationJoinStatus.SubstateInformation(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xDD)
  {
    *(_WORD *)(result + 12) = 0;
    *(_DWORD *)(result + 8) = 0;
    *(_QWORD *)result = a2 - 222;
    if (a3 >= 0xDE)
      *(_BYTE *)(result + 14) = 1;
  }
  else
  {
    if (a3 >= 0xDE)
      *(_BYTE *)(result + 14) = 0;
    if (a2)
      *(_BYTE *)(result + 7) = a2 + 34;
  }
  return result;
}

ValueMetadata *type metadata accessor for InfraAssociationJoinStatus.SubstateInformation()
{
  return &type metadata for InfraAssociationJoinStatus.SubstateInformation;
}

uint64_t destroy for InfraAssociationReadyEvent(uint64_t result)
{
  int v1;

  v1 = *(unsigned __int8 *)(result + 40);
  if (v1 != 255)
    return sub_1000623AC(*(_QWORD *)(result + 8), *(_QWORD *)(result + 16), *(_QWORD *)(result + 24), *(_QWORD *)(result + 32), v1 & 1);
  return result;
}

uint64_t initializeWithCopy for InfraAssociationReadyEvent(uint64_t a1, uint64_t a2)
{
  int v3;
  __int128 v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  *(_WORD *)a1 = *(_WORD *)a2;
  v3 = *(unsigned __int8 *)(a2 + 40);
  if (v3 == 255)
  {
    v4 = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
    *(_OWORD *)(a1 + 24) = v4;
    *(_BYTE *)(a1 + 40) = *(_BYTE *)(a2 + 40);
  }
  else
  {
    v5 = v3 & 1;
    v6 = *(_QWORD *)(a2 + 8);
    v7 = *(_QWORD *)(a2 + 16);
    v8 = *(_QWORD *)(a2 + 24);
    v9 = *(_QWORD *)(a2 + 32);
    sub_1000628F8(v6, v7, v8, v9, v3 & 1);
    *(_QWORD *)(a1 + 8) = v6;
    *(_QWORD *)(a1 + 16) = v7;
    *(_QWORD *)(a1 + 24) = v8;
    *(_QWORD *)(a1 + 32) = v9;
    *(_BYTE *)(a1 + 40) = v5;
  }
  return a1;
}

uint64_t assignWithCopy for InfraAssociationReadyEvent(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  __int128 *v4;
  int v5;
  char v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  *(_WORD *)a1 = *(_WORD *)a2;
  v3 = a1 + 8;
  v4 = (__int128 *)(a2 + 8);
  v5 = *(unsigned __int8 *)(a2 + 40);
  if (*(unsigned __int8 *)(a1 + 40) == 255)
  {
    if (v5 == 255)
    {
      v8 = *v4;
      v9 = *(_OWORD *)(a2 + 24);
      *(_BYTE *)(a1 + 40) = *(_BYTE *)(a2 + 40);
      *(_OWORD *)v3 = v8;
      *(_OWORD *)(a1 + 24) = v9;
    }
    else
    {
      v20 = v5 & 1;
      v21 = *(_QWORD *)(a2 + 8);
      v22 = *(_QWORD *)(a2 + 16);
      v23 = *(_QWORD *)(a2 + 24);
      v24 = *(_QWORD *)(a2 + 32);
      sub_1000628F8(v21, v22, v23, v24, v5 & 1);
      *(_QWORD *)(a1 + 8) = v21;
      *(_QWORD *)(a1 + 16) = v22;
      *(_QWORD *)(a1 + 24) = v23;
      *(_QWORD *)(a1 + 32) = v24;
      *(_BYTE *)(a1 + 40) = v20;
    }
  }
  else if (v5 == 255)
  {
    sub_1000C5B5C(a1 + 8);
    v6 = *((_BYTE *)v4 + 32);
    v7 = v4[1];
    *(_OWORD *)v3 = *v4;
    *(_OWORD *)(v3 + 16) = v7;
    *(_BYTE *)(v3 + 32) = v6;
  }
  else
  {
    v10 = v5 & 1;
    v11 = *(_QWORD *)(a2 + 8);
    v12 = *(_QWORD *)(a2 + 16);
    v13 = *(_QWORD *)(a2 + 24);
    v14 = *(_QWORD *)(a2 + 32);
    sub_1000628F8(v11, v12, v13, v14, v5 & 1);
    v15 = *(_QWORD *)(a1 + 8);
    v16 = *(_QWORD *)(a1 + 16);
    v17 = *(_QWORD *)(a1 + 24);
    v18 = *(_QWORD *)(a1 + 32);
    v19 = *(_BYTE *)(a1 + 40);
    *(_QWORD *)(a1 + 8) = v11;
    *(_QWORD *)(a1 + 16) = v12;
    *(_QWORD *)(a1 + 24) = v13;
    *(_QWORD *)(a1 + 32) = v14;
    *(_BYTE *)(a1 + 40) = v10;
    sub_1000623AC(v15, v16, v17, v18, v19);
  }
  return a1;
}

uint64_t sub_1000C5B5C(uint64_t a1)
{
  uint64_t v2;

  v2 = sub_100012C44(&qword_100405B20);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v2 - 8) + 8))(a1, v2);
  return a1;
}

uint64_t assignWithTake for InfraAssociationReadyEvent(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  __int128 v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  *(_WORD *)a1 = *(_WORD *)a2;
  v3 = a1 + 8;
  v4 = a2 + 8;
  v5 = *(unsigned __int8 *)(a1 + 40);
  if (v5 != 255)
  {
    v6 = *(unsigned __int8 *)(a2 + 40);
    if (v6 != 255)
    {
      v8 = v5 & 1;
      v9 = *(_QWORD *)(a1 + 8);
      v10 = *(_QWORD *)(a1 + 16);
      v11 = *(_QWORD *)(a1 + 24);
      v12 = *(_QWORD *)(a1 + 32);
      *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
      *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
      *(_BYTE *)(a1 + 40) = v6 & 1;
      sub_1000623AC(v9, v10, v11, v12, v8);
      return a1;
    }
    sub_1000C5B5C(a1 + 8);
  }
  v7 = *(_OWORD *)(v4 + 16);
  *(_OWORD *)v3 = *(_OWORD *)v4;
  *(_OWORD *)(v3 + 16) = v7;
  *(_BYTE *)(v3 + 32) = *(_BYTE *)(v4 + 32);
  return a1;
}

uint64_t getEnumTagSinglePayload for InfraAssociationReadyEvent(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  int v4;

  if (!a2)
    return 0;
  if (a2 >= 0xFE && *(_BYTE *)(a1 + 41))
    return (*(_DWORD *)a1 + 254);
  v3 = *(unsigned __int8 *)(a1 + 40);
  if (v3 <= 1)
    v4 = -1;
  else
    v4 = (v3 ^ 0xFF) - 1;
  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for InfraAssociationReadyEvent(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFD)
  {
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_BYTE *)(result + 40) = 0;
    *(_QWORD *)result = a2 - 254;
    if (a3 >= 0xFE)
      *(_BYTE *)(result + 41) = 1;
  }
  else
  {
    if (a3 >= 0xFE)
      *(_BYTE *)(result + 41) = 0;
    if (a2)
      *(_BYTE *)(result + 40) = ~(_BYTE)a2;
  }
  return result;
}

ValueMetadata *type metadata accessor for InfraAssociationReadyEvent()
{
  return &type metadata for InfraAssociationReadyEvent;
}

uint64_t sub_1000C5CE0(uint64_t a1, void (*a2)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))
{
  a2(*(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
  return a1;
}

uint64_t sub_1000C5D18(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 a5)
{
  if (a5 != 255)
    return sub_1000628F8(result, a2, a3, a4, a5 & 1);
  return result;
}

BOOL sub_1000C5D30(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  void (*v9)(char *, uint64_t, uint64_t);
  char v10;
  void (*v11)(char *, uint64_t);
  char v13;
  uint64_t v14;
  uint64_t v15;

  v4 = type metadata accessor for DispatchTimeInterval(0);
  v5 = *(_QWORD *)(v4 - 8);
  __chkstk_darwin();
  v7 = (char *)&v15 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  v8 = enum case for DispatchTimeInterval.never(_:);
  v9 = *(void (**)(char *, uint64_t, uint64_t))(v5 + 104);
  v9(v7, enum case for DispatchTimeInterval.never(_:), v4);
  v10 = static DispatchTimeInterval.== infix(_:_:)(a1, v7);
  v11 = *(void (**)(char *, uint64_t))(v5 + 8);
  v11(v7, v4);
  if ((v10 & 1) != 0)
    return 1;
  v9(v7, v8, v4);
  v13 = static DispatchTimeInterval.== infix(_:_:)(a2, v7);
  v11(v7, v4);
  if ((v13 & 1) != 0)
    return 0;
  v14 = sub_10017C64C();
  return v14 >= sub_10017C64C();
}

uint64_t sub_1000C5E40(char a1, unsigned __int8 a2)
{
  int v4;
  uint64_t v5;
  uint64_t result;

  v4 = a2;
  v5 = sub_100012C44(&qword_100406E48);
  if (v4 == 2)
    return 1;
  if (a1 == 2)
    return 0;
  if (a2 == 3)
    return 1;
  if (a1 == 3)
    return 0;
  if ((a2 - 2) >= 5u && (a2 & 1) == 0)
    return 1;
  if ((a1 - 2) >= 5u && (a1 & 1) == 0)
    return 0;
  if ((a2 - 2) >= 5u && (a2 & 1) != 0)
    return 1;
  if ((a1 - 2) >= 5u && (a1 & 1) != 0)
    return 0;
  if (a2 == 4)
    return 1;
  if (a1 == 4)
    return 0;
  if (a2 == 5)
    return 1;
  if (a1 == 5)
    return 0;
  if (a2 == 6)
    return 1;
  if (a1 == 6)
    return 0;
  result = _diagnoseUnexpectedEnumCase<A>(type:)(v5, v5);
  __break(1u);
  return result;
}

BOOL sub_1000C5F4C(uint64_t a1, uint64_t a2)
{
  if ((a1 & 0x100000000) != 0)
    LODWORD(a1) = dword_100340CC0[(int)a1];
  if ((a2 & 0x100000000) != 0)
    LODWORD(a2) = dword_100340CC0[(int)a2];
  return a1 >= a2;
}

void sub_1000C5F78()
{
  static Bandwidth.allCases = (uint64_t)&off_1003D6E28;
}

uint64_t *Bandwidth.allCases.unsafeMutableAddressor()
{
  if (qword_100403F30 != -1)
    swift_once(&qword_100403F30, sub_1000C5F78);
  return &static Bandwidth.allCases;
}

uint64_t static Bandwidth.allCases.getter()
{
  _BYTE v1[24];

  if (qword_100403F30 != -1)
    swift_once(&qword_100403F30, sub_1000C5F78);
  swift_beginAccess(&static Bandwidth.allCases, v1, 0, 0);
  return swift_bridgeObjectRetain(static Bandwidth.allCases);
}

double static Bandwidth.allCases.setter(uint64_t a1)
{
  uint64_t v2;
  double result;
  _BYTE v4[24];

  if (qword_100403F30 != -1)
    swift_once(&qword_100403F30, sub_1000C5F78);
  swift_beginAccess(&static Bandwidth.allCases, v4, 1, 0);
  v2 = static Bandwidth.allCases;
  static Bandwidth.allCases = a1;
  *(_QWORD *)&result = swift_bridgeObjectRelease(v2).n128_u64[0];
  return result;
}

uint64_t (*static Bandwidth.allCases.modify(uint64_t a1))(_QWORD)
{
  if (qword_100403F30 != -1)
    swift_once(&qword_100403F30, sub_1000C5F78);
  swift_beginAccess(&static Bandwidth.allCases, a1, 33, 0);
  return j__swift_endAccess;
}

uint64_t Bandwidth.suffix.getter(unsigned __int8 a1)
{
  int v1;
  uint64_t result;

  v1 = a1;
  result = 0;
  switch(v1)
  {
    case 2:
    case 3:
      return result;
    case 4:
      result = 11051;
      break;
    case 5:
      result = 30840;
      break;
    case 6:
      result = 31097;
      break;
    default:
      if ((v1 & 1) != 0)
        result = 43;
      else
        result = 45;
      break;
  }
  return result;
}

uint64_t Bandwidth.description.getter(unsigned __int8 a1)
{
  int v1;
  uint64_t result;

  v1 = a1;
  result = 0x7A484D203031;
  switch(v1)
  {
    case 2:
      return result;
    case 3:
      result = 0x7A484D203032;
      break;
    case 4:
      result = 0x7A484D203038;
      break;
    case 5:
      result = 0x7A484D20303631;
      break;
    case 6:
      result = 0x7A484D20303233;
      break;
    default:
      if ((v1 & 1) != 0)
        result = 0x7A484D202B3034;
      else
        result = 0x7A484D202D3034;
      break;
  }
  return result;
}

uint64_t Bandwidth.updateWithFloor(bandwidth:)(unsigned __int8 a1)
{
  unsigned __int8 *v1;
  int v3;
  uint64_t result;
  int v5;

  v3 = *v1;
  result = sub_100012C44(&qword_100406E48);
  if (v3 == 2)
    goto LABEL_5;
  if (a1 == 2)
    goto LABEL_3;
  if (v3 == 3)
    goto LABEL_5;
  if (a1 == 3)
    goto LABEL_3;
  if ((v3 - 2) >= 5 && (v3 & 1) == 0)
    goto LABEL_5;
  if ((a1 - 2) >= 5u && (a1 & 1) == 0)
    goto LABEL_3;
  if ((v3 - 2) >= 5u && (v3 & 1) != 0)
    goto LABEL_5;
  if ((a1 - 2) >= 5u && (a1 & 1) != 0)
    goto LABEL_3;
  if (v3 == 4)
    goto LABEL_5;
  if (a1 == 4)
    goto LABEL_3;
  if (v3 == 5)
    goto LABEL_5;
  if (a1 == 5)
  {
LABEL_3:
    a1 = v3;
LABEL_5:
    *v1 = a1;
    return result;
  }
  if (v3 == 6)
    goto LABEL_5;
  v5 = a1;
  a1 = v3;
  if (v5 == 6)
    goto LABEL_5;
  result = _diagnoseUnexpectedEnumCase<A>(type:)(result, result);
  __break(1u);
  return result;
}

void Bandwidth.hash(into:)(uint64_t a1, char a2)
{
  Swift::UInt v2;
  Swift::UInt8 v3;

  switch(a2)
  {
    case 2:
      v2 = 0;
      goto LABEL_8;
    case 3:
      v2 = 1;
      goto LABEL_8;
    case 4:
      v2 = 3;
      goto LABEL_8;
    case 5:
      v2 = 4;
      goto LABEL_8;
    case 6:
      v2 = 5;
LABEL_8:
      Hasher._combine(_:)(v2);
      break;
    default:
      v3 = a2 & 1;
      Hasher._combine(_:)(2uLL);
      Hasher._combine(_:)(v3);
      break;
  }
}

uint64_t static Bandwidth.__derived_enum_equals(_:_:)(char a1, unsigned __int8 a2)
{
  uint64_t result;

  switch(a1)
  {
    case 2:
      if (a2 != 2)
        goto LABEL_13;
      goto LABEL_11;
    case 3:
      if (a2 != 3)
        goto LABEL_13;
      goto LABEL_11;
    case 4:
      if (a2 != 4)
        goto LABEL_13;
      goto LABEL_11;
    case 5:
      if (a2 != 5)
        goto LABEL_13;
      goto LABEL_11;
    case 6:
      if (a2 != 6)
        goto LABEL_13;
LABEL_11:
      result = 1;
      break;
    default:
      if (a2 - 2 >= 5)
        result = (((a1 & 1) == 0) ^ a2) & 1;
      else
LABEL_13:
        result = 0;
      break;
  }
  return result;
}

uint64_t sub_1000C643C()
{
  unsigned __int8 *v0;

  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_1000C6468 + 4 * byte_1003404F4[*v0]))(0x7A484D6E6574, 0xE600000000000000);
}

uint64_t sub_1000C6468()
{
  return 0x484D79746E657774;
}

uint64_t sub_1000C64A8()
{
  return 0x7974786953656E6FLL;
}

uint64_t sub_1000C64C8()
{
  return 0x6577546565726874;
}

uint64_t sub_1000C64EC@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;

  result = sub_1000C8294(a1, a2);
  *a3 = result;
  return result;
}

void sub_1000C6510(_BYTE *a1@<X8>)
{
  *a1 = 6;
}

uint64_t sub_1000C651C(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000C7114();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000C6544(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000C7114();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t sub_1000C656C(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000C71E0();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000C6594(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000C71E0();
  return CodingKey.debugDescription.getter(a1, v2);
}

unint64_t sub_1000C65BC()
{
  return 0xD000000000000015;
}

uint64_t sub_1000C65D8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;

  result = sub_1000C8560(a1, a2);
  *a3 = result & 1;
  return result;
}

uint64_t sub_1000C6600(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000C7224();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000C6628(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000C7224();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t sub_1000C6650(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000C719C();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000C6678(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000C719C();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t sub_1000C66A0(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000C72AC();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000C66C8(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000C72AC();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t sub_1000C66F0(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000C7158();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000C6718(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000C7158();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t sub_1000C6740(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000C7268();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000C6768(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000C7268();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t Bandwidth.encode(to:)(_QWORD *a1, unsigned __int8 a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t result;
  unint64_t v32;
  unint64_t v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  char v56;
  char v57;
  char v58;
  char v59;
  char v60;
  char v61;

  v55 = a2;
  v3 = sub_100012C44(&qword_100406E50);
  v51 = *(_QWORD *)(v3 - 8);
  v52 = v3;
  __chkstk_darwin();
  v50 = (char *)&v39 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  v5 = sub_100012C44(&qword_100406E58);
  v48 = *(_QWORD *)(v5 - 8);
  v49 = v5;
  __chkstk_darwin();
  v47 = (char *)&v39 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = sub_100012C44(&qword_100406E60);
  v45 = *(_QWORD *)(v7 - 8);
  v46 = v7;
  __chkstk_darwin();
  v44 = (char *)&v39 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  v9 = sub_100012C44(&qword_100406E68);
  v42 = *(_QWORD *)(v9 - 8);
  v43 = v9;
  __chkstk_darwin();
  v11 = (char *)&v39 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = sub_100012C44(&qword_100406E70);
  v40 = *(_QWORD *)(v12 - 8);
  v41 = v12;
  __chkstk_darwin();
  v14 = (char *)&v39 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = sub_100012C44(&qword_100406E78);
  v16 = *(_QWORD *)(v15 - 8);
  __chkstk_darwin();
  v18 = (char *)&v39 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  v19 = sub_100012C44(&qword_100406E80);
  v53 = *(_QWORD *)(v19 - 8);
  v54 = v19;
  __chkstk_darwin();
  v21 = (char *)&v39 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  v22 = a1[3];
  v23 = a1[4];
  sub_10003259C(a1, v22);
  v24 = sub_1000C7114();
  dispatch thunk of Encoder.container<A>(keyedBy:)(&type metadata for Bandwidth.CodingKeys, &type metadata for Bandwidth.CodingKeys, v24, v22, v23);
  switch(v55)
  {
    case 2:
      v56 = 0;
      v25 = sub_1000C72AC();
      v26 = v54;
      KeyedEncodingContainer.nestedContainer<A>(keyedBy:forKey:)(&type metadata for Bandwidth.TenMHzCodingKeys, &v56, v54, &type metadata for Bandwidth.TenMHzCodingKeys, v25);
      (*(void (**)(char *, uint64_t))(v16 + 8))(v18, v15);
      goto LABEL_9;
    case 3:
      v57 = 1;
      v32 = sub_1000C7268();
      v26 = v54;
      KeyedEncodingContainer.nestedContainer<A>(keyedBy:forKey:)(&type metadata for Bandwidth.TwentyMHzCodingKeys, &v57, v54, &type metadata for Bandwidth.TwentyMHzCodingKeys, v32);
      (*(void (**)(char *, uint64_t))(v40 + 8))(v14, v41);
      goto LABEL_9;
    case 4:
      v59 = 3;
      v33 = sub_1000C71E0();
      v34 = v44;
      v26 = v54;
      KeyedEncodingContainer.nestedContainer<A>(keyedBy:forKey:)(&type metadata for Bandwidth.EightyMHzCodingKeys, &v59, v54, &type metadata for Bandwidth.EightyMHzCodingKeys, v33);
      v36 = v45;
      v35 = v46;
      goto LABEL_8;
    case 5:
      v60 = 4;
      v37 = sub_1000C719C();
      v34 = v47;
      v26 = v54;
      KeyedEncodingContainer.nestedContainer<A>(keyedBy:forKey:)(&type metadata for Bandwidth.OneSixtyMHzCodingKeys, &v60, v54, &type metadata for Bandwidth.OneSixtyMHzCodingKeys, v37);
      v36 = v48;
      v35 = v49;
      goto LABEL_8;
    case 6:
      v61 = 5;
      v38 = sub_1000C7158();
      v34 = v50;
      v26 = v54;
      KeyedEncodingContainer.nestedContainer<A>(keyedBy:forKey:)(&type metadata for Bandwidth.ThreeTwentyMHzCodingKeys, &v61, v54, &type metadata for Bandwidth.ThreeTwentyMHzCodingKeys, v38);
      v36 = v51;
      v35 = v52;
LABEL_8:
      (*(void (**)(char *, uint64_t))(v36 + 8))(v34, v35);
LABEL_9:
      result = (*(uint64_t (**)(char *, uint64_t))(v53 + 8))(v21, v26);
      break;
    default:
      v27 = v55 & 1;
      v58 = 2;
      v28 = sub_1000C7224();
      v29 = v54;
      KeyedEncodingContainer.nestedContainer<A>(keyedBy:forKey:)(&type metadata for Bandwidth.FortyMHzCodingKeys, &v58, v54, &type metadata for Bandwidth.FortyMHzCodingKeys, v28);
      v30 = v43;
      KeyedEncodingContainer.encode(_:forKey:)(v27);
      (*(void (**)(char *, uint64_t))(v42 + 8))(v11, v30);
      result = (*(uint64_t (**)(char *, uint64_t))(v53 + 8))(v21, v29);
      break;
  }
  return result;
}

Swift::Int Bandwidth.hashValue.getter(char a1)
{
  Swift::UInt v2;
  _QWORD v4[9];

  Hasher.init(_seed:)(v4);
  switch(a1)
  {
    case 2:
      v2 = 0;
      goto LABEL_8;
    case 3:
      v2 = 1;
      goto LABEL_8;
    case 4:
      v2 = 3;
      goto LABEL_8;
    case 5:
      v2 = 4;
      goto LABEL_8;
    case 6:
      v2 = 5;
LABEL_8:
      Hasher._combine(_:)(v2);
      break;
    default:
      Hasher._combine(_:)(2uLL);
      Hasher._combine(_:)(a1 & 1);
      break;
  }
  return Hasher._finalize()();
}

uint64_t Bandwidth.init(from:)(_QWORD *a1)
{
  return sub_1000C72F0(a1);
}

Swift::Int sub_1000C6CA8()
{
  char *v0;

  return Bandwidth.hashValue.getter(*v0);
}

void sub_1000C6CB0()
{
  _BYTE *v0;
  Swift::UInt v1;
  Swift::UInt8 v2;

  switch(*v0)
  {
    case 2:
      v1 = 0;
      goto LABEL_8;
    case 3:
      v1 = 1;
      goto LABEL_8;
    case 4:
      v1 = 3;
      goto LABEL_8;
    case 5:
      v1 = 4;
      goto LABEL_8;
    case 6:
      v1 = 5;
LABEL_8:
      Hasher._combine(_:)(v1);
      break;
    default:
      v2 = *v0 & 1;
      Hasher._combine(_:)(2uLL);
      Hasher._combine(_:)(v2);
      break;
  }
}

Swift::Int sub_1000C6D38()
{
  unsigned __int8 *v0;
  int v1;
  Swift::UInt v2;
  _QWORD v4[9];

  v1 = *v0;
  Hasher.init(_seed:)(v4);
  switch(v1)
  {
    case 2:
      v2 = 0;
      goto LABEL_8;
    case 3:
      v2 = 1;
      goto LABEL_8;
    case 4:
      v2 = 3;
      goto LABEL_8;
    case 5:
      v2 = 4;
      goto LABEL_8;
    case 6:
      v2 = 5;
LABEL_8:
      Hasher._combine(_:)(v2);
      break;
    default:
      Hasher._combine(_:)(2uLL);
      Hasher._combine(_:)(v1 & 1);
      break;
  }
  return Hasher._finalize()();
}

uint64_t sub_1000C6DEC@<X0>(_QWORD *a1@<X8>)
{
  uint64_t v2;
  _BYTE v4[24];

  if (qword_100403F30 != -1)
    swift_once(&qword_100403F30, sub_1000C5F78);
  swift_beginAccess(&static Bandwidth.allCases, v4, 0, 0);
  v2 = static Bandwidth.allCases;
  *a1 = static Bandwidth.allCases;
  return swift_bridgeObjectRetain(v2);
}

uint64_t sub_1000C6E60()
{
  _BYTE *v0;
  uint64_t result;

  result = 0x7A484D203031;
  switch(*v0)
  {
    case 2:
      return result;
    case 3:
      result = 0x7A484D203032;
      break;
    case 4:
      result = 0x7A484D203038;
      break;
    case 5:
      result = 0x7A484D20303631;
      break;
    case 6:
      result = 0x7A484D20303233;
      break;
    default:
      if ((*v0 & 1) != 0)
        result = 0x7A484D202B3034;
      else
        result = 0x7A484D202D3034;
      break;
  }
  return result;
}

uint64_t sub_1000C6F00(char *a1, unsigned __int8 *a2)
{
  return _s7CoreP2P9BandwidthO1loiySbAC_ACtFZ_0(*a1, *a2);
}

uint64_t sub_1000C6F0C(unsigned __int8 *a1, char *a2)
{
  return sub_10017C444(*a1, *a2);
}

uint64_t sub_1000C6F18(char *a1, unsigned __int8 *a2)
{
  return sub_1000C5E40(*a1, *a2);
}

uint64_t sub_1000C6F24(unsigned __int8 *a1, char *a2)
{
  return sub_10014EAD0(*a1, *a2);
}

uint64_t sub_1000C6F30@<X0>(_QWORD *a1@<X0>, _BYTE *a2@<X8>)
{
  uint64_t v2;
  uint64_t result;

  result = sub_1000C72F0(a1);
  if (!v2)
    *a2 = result;
  return result;
}

uint64_t sub_1000C6F58(_QWORD *a1)
{
  unsigned __int8 *v1;

  return Bandwidth.encode(to:)(a1, *v1);
}

uint64_t sub_1000C6F70(_BYTE *a1, unsigned __int8 *a2)
{
  int v2;
  uint64_t result;

  v2 = *a2;
  switch(*a1)
  {
    case 2:
      if (v2 == 2)
        goto LABEL_11;
      goto LABEL_13;
    case 3:
      if (v2 != 3)
        goto LABEL_13;
      goto LABEL_11;
    case 4:
      if (v2 != 4)
        goto LABEL_13;
      goto LABEL_11;
    case 5:
      if (v2 != 5)
        goto LABEL_13;
      goto LABEL_11;
    case 6:
      if (v2 != 6)
        goto LABEL_13;
LABEL_11:
      result = 1;
      break;
    default:
      if ((v2 - 2) >= 5)
        result = (((*a1 & 1) == 0) ^ v2) & 1;
      else
LABEL_13:
        result = 0;
      break;
  }
  return result;
}

uint64_t _s7CoreP2P9BandwidthO1loiySbAC_ACtFZ_0(char a1, unsigned __int8 a2)
{
  int v4;
  uint64_t v5;
  uint64_t result;

  v4 = a2;
  v5 = sub_100012C44(&qword_100406E48);
  if (v4 == 2)
    return 0;
  if (a1 == 2)
    return 1;
  if (a2 == 3)
    return 0;
  if (a1 == 3)
    return 1;
  if ((a2 - 2) >= 5u && (a2 & 1) == 0)
    return 0;
  if ((a1 - 2) >= 5u && (a1 & 1) == 0)
    return 1;
  if ((a2 - 2) >= 5u && (a2 & 1) != 0)
    return 0;
  if ((a1 - 2) >= 5u && (a1 & 1) != 0)
    return 1;
  if (a2 == 4)
    return 0;
  if (a1 == 4)
    return 1;
  if (a2 == 5)
    return 0;
  if (a1 == 5)
    return 1;
  if (a2 == 6)
    return 0;
  if (a1 == 6)
    return 1;
  result = _diagnoseUnexpectedEnumCase<A>(type:)(v5, v5);
  __break(1u);
  return result;
}

unint64_t sub_1000C7114()
{
  unint64_t result;

  result = qword_100406E88;
  if (!qword_100406E88)
  {
    result = swift_getWitnessTable(&unk_100340C6C, &type metadata for Bandwidth.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406E88);
  }
  return result;
}

unint64_t sub_1000C7158()
{
  unint64_t result;

  result = qword_100406E90;
  if (!qword_100406E90)
  {
    result = swift_getWitnessTable(&unk_100340C1C, &type metadata for Bandwidth.ThreeTwentyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406E90);
  }
  return result;
}

unint64_t sub_1000C719C()
{
  unint64_t result;

  result = qword_100406E98;
  if (!qword_100406E98)
  {
    result = swift_getWitnessTable(&unk_100340BCC, &type metadata for Bandwidth.OneSixtyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406E98);
  }
  return result;
}

unint64_t sub_1000C71E0()
{
  unint64_t result;

  result = qword_100406EA0;
  if (!qword_100406EA0)
  {
    result = swift_getWitnessTable(&unk_100340B7C, &type metadata for Bandwidth.EightyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406EA0);
  }
  return result;
}

unint64_t sub_1000C7224()
{
  unint64_t result;

  result = qword_100406EA8;
  if (!qword_100406EA8)
  {
    result = swift_getWitnessTable(&unk_100340B2C, &type metadata for Bandwidth.FortyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406EA8);
  }
  return result;
}

unint64_t sub_1000C7268()
{
  unint64_t result;

  result = qword_100406EB0;
  if (!qword_100406EB0)
  {
    result = swift_getWitnessTable(&unk_100340ADC, &type metadata for Bandwidth.TwentyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406EB0);
  }
  return result;
}

unint64_t sub_1000C72AC()
{
  unint64_t result;

  result = qword_100406EB8;
  if (!qword_100406EB8)
  {
    result = swift_getWitnessTable(&unk_100340A8C, &type metadata for Bandwidth.TenMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406EB8);
  }
  return result;
}

uint64_t sub_1000C72F0(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  __n128 v27;
  _QWORD v29[8];
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  char *v36;
  char *v37;
  char *v38;
  char *v39;
  uint64_t v40;
  _QWORD *v41;
  uint64_t v42;

  v34 = sub_100012C44(&qword_100406F58);
  v40 = *(_QWORD *)(v34 - 8);
  __chkstk_darwin();
  v39 = (char *)v29 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0);
  v33 = sub_100012C44(&qword_100406F60);
  v29[7] = *(_QWORD *)(v33 - 8);
  __chkstk_darwin();
  v38 = (char *)v29 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v4 = sub_100012C44(&qword_100406F68);
  v31 = *(_QWORD *)(v4 - 8);
  v32 = v4;
  __chkstk_darwin();
  v37 = (char *)v29 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v30 = sub_100012C44(&qword_100406F70);
  v29[6] = *(_QWORD *)(v30 - 8);
  __chkstk_darwin();
  v36 = (char *)v29 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = sub_100012C44(&qword_100406F78);
  v29[4] = *(_QWORD *)(v7 - 8);
  v29[5] = v7;
  __chkstk_darwin();
  v35 = (char *)v29 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  v9 = sub_100012C44(&qword_100406F80);
  v10 = *(_QWORD *)(v9 - 8);
  __chkstk_darwin();
  v12 = (char *)v29 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = sub_100012C44(&qword_100406F88);
  v14 = *(_QWORD *)(v13 - 8);
  __chkstk_darwin();
  v16 = (char *)v29 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  v17 = a1[3];
  v18 = a1[4];
  v41 = a1;
  sub_10003259C(a1, v17);
  v19 = sub_1000C7114();
  v20 = v42;
  dispatch thunk of Decoder.container<A>(keyedBy:)(&type metadata for Bandwidth.CodingKeys, &type metadata for Bandwidth.CodingKeys, v19, v17, v18);
  if (!v20)
  {
    v29[2] = v9;
    v29[3] = v12;
    v29[1] = v10;
    v42 = v14;
    v21 = KeyedDecodingContainer.allKeys.getter(v13);
    v22 = v21;
    if (*(_QWORD *)(v21 + 16) == 1)
      __asm { BR              X10 }
    v17 = type metadata accessor for DecodingError(0);
    swift_allocError(v17, &protocol witness table for DecodingError, 0, 0);
    v24 = v23;
    sub_100012C44(&qword_100406000);
    *v24 = &type metadata for Bandwidth;
    v25 = KeyedDecodingContainer.codingPath.getter(v13);
    DecodingError.Context.init(codingPath:debugDescription:underlyingError:)(v25, 0xD00000000000002BLL, 0x80000001003644E0, 0);
    v26 = (*(uint64_t (**)(_QWORD *, _QWORD, uint64_t))(*(_QWORD *)(v17 - 8) + 104))(v24, enum case for DecodingError.typeMismatch(_:), v17);
    swift_willThrow(v26);
    v27 = swift_bridgeObjectRelease(v22);
    (*(void (**)(char *, uint64_t, __n128))(v42 + 8))(v16, v13, v27);
  }
  sub_100014430(v41);
  return v17;
}

void sub_1000C78C0()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  __n128 v9;

  *(_BYTE *)(v7 - 65) = 5;
  v8 = sub_1000C7158();
  KeyedDecodingContainer.nestedContainer<A>(keyedBy:forKey:)(&type metadata for Bandwidth.ThreeTwentyMHzCodingKeys, v7 - 65, v0, &type metadata for Bandwidth.ThreeTwentyMHzCodingKeys, v8);
  if (v1)
  {
    swift_bridgeObjectRelease(v6);
    JUMPOUT(0x1000C76A8);
  }
  (*(void (**)(uint64_t, _QWORD))(v5 + 8))(v3, *(_QWORD *)(v7 - 160));
  v9 = swift_bridgeObjectRelease(v6);
  (*(void (**)(uint64_t, uint64_t, __n128))(v4 + 8))(v2, v0, v9);
  JUMPOUT(0x1000C7978);
}

unint64_t sub_1000C7988()
{
  unint64_t result;

  result = qword_100406EC0;
  if (!qword_100406EC0)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Bandwidth, &type metadata for Bandwidth);
    atomic_store(result, (unint64_t *)&qword_100406EC0);
  }
  return result;
}

unint64_t sub_1000C79D0()
{
  unint64_t result;
  uint64_t v1;

  result = qword_100406EC8;
  if (!qword_100406EC8)
  {
    v1 = sub_100013C64(&qword_100406ED0);
    result = swift_getWitnessTable((const char *)&protocol conformance descriptor for [A], v1);
    atomic_store(result, (unint64_t *)&qword_100406EC8);
  }
  return result;
}

uint64_t getEnumTagSinglePayload for Bandwidth(unsigned __int8 *a1, unsigned int a2)
{
  unsigned int v2;
  unsigned int v3;
  uint64_t v4;
  uint64_t result;
  unsigned int v6;
  unsigned int v7;

  if (!a2)
    return 0;
  if (a2 < 0xFA)
  {
    v6 = *a1;
    if (v6 >= 2)
    {
      v7 = (v6 + 2147483646) & 0x7FFFFFFF;
      result = v7 - 4;
      if (v7 > 4)
        return result;
    }
    return 0;
  }
  v2 = a2 + 6;
  if (a2 + 6 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if (v2 >> 8 < 0xFF)
    v3 = 1;
  if (v2 >= 0x100)
    v4 = v3;
  else
    v4 = 0;
  return ((uint64_t (*)(void))((char *)&loc_1000C7A6C + 4 * byte_10034051E[v4]))();
}

uint64_t storeEnumTagSinglePayload for Bandwidth(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3;
  int v4;
  uint64_t v5;

  v3 = a3 + 6;
  if (a3 + 6 >= 0xFFFF00)
    v4 = 4;
  else
    v4 = 2;
  if (v3 >> 8 < 0xFF)
    v4 = 1;
  if (v3 >= 0x100)
    LODWORD(v5) = v4;
  else
    LODWORD(v5) = 0;
  if (a3 >= 0xFA)
    v5 = v5;
  else
    v5 = 0;
  if (a2 <= 0xF9)
    return ((uint64_t (*)(void))((char *)&loc_1000C7B18 + 4 * byte_100340528[v5]))();
  *a1 = a2 + 6;
  return ((uint64_t (*)(void))((char *)sub_1000C7B4C + 4 * byte_100340523[v5]))();
}

uint64_t sub_1000C7B4C(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000C7B54(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x1000C7B5CLL);
  return result;
}

uint64_t sub_1000C7B68(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x1000C7B70);
  *(_BYTE *)result = a2 + 6;
  return result;
}

uint64_t sub_1000C7B74(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000C7B7C(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000C7B88(unsigned __int8 *a1)
{
  unsigned int v1;
  BOOL v2;
  int v3;

  v1 = *a1;
  v2 = v1 >= 2;
  v3 = (v1 + 2147483646) & 0x7FFFFFFF;
  if (v2)
    return (v3 + 1);
  else
    return 0;
}

_BYTE *sub_1000C7BA4(_BYTE *result, int a2)
{
  if (a2)
    *result = a2 + 1;
  return result;
}

ValueMetadata *type metadata accessor for Bandwidth()
{
  return &type metadata for Bandwidth;
}

uint64_t getEnumTagSinglePayload for WatchdogResetStatus(unsigned __int8 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0xFB)
    goto LABEL_17;
  if (a2 + 5 >= 0xFFFF00)
    v2 = 4;
  else
    v2 = 2;
  if ((a2 + 5) >> 8 < 0xFF)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 8)) - 5;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1))
        goto LABEL_17;
      return (*a1 | (v4 << 8)) - 5;
    }
    v4 = a1[1];
    if (a1[1])
      return (*a1 | (v4 << 8)) - 5;
  }
LABEL_17:
  v6 = *a1;
  v7 = v6 >= 6;
  v8 = v6 - 6;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for Bandwidth.CodingKeys(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 5 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 5) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xFB)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xFA)
    return ((uint64_t (*)(void))((char *)&loc_1000C7CA8 + 4 * byte_100340532[v4]))();
  *a1 = a2 + 5;
  return ((uint64_t (*)(void))((char *)sub_1000C7CDC + 4 * byte_10034052D[v4]))();
}

uint64_t sub_1000C7CDC(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000C7CE4(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x1000C7CECLL);
  return result;
}

uint64_t sub_1000C7CF8(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x1000C7D00);
  *(_BYTE *)result = a2 + 5;
  return result;
}

uint64_t sub_1000C7D04(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000C7D0C(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for Bandwidth.CodingKeys()
{
  return &type metadata for Bandwidth.CodingKeys;
}

ValueMetadata *type metadata accessor for Bandwidth.TenMHzCodingKeys()
{
  return &type metadata for Bandwidth.TenMHzCodingKeys;
}

ValueMetadata *type metadata accessor for Bandwidth.TwentyMHzCodingKeys()
{
  return &type metadata for Bandwidth.TwentyMHzCodingKeys;
}

uint64_t storeEnumTagSinglePayload for Bandwidth.FortyMHzCodingKeys(uint64_t a1, int a2, int a3)
{
  int v3;
  uint64_t v4;

  if ((a3 + 1) >= 0x10000)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 1) < 0x100)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3)
    v4 = v4;
  else
    v4 = 0;
  if (a2)
    return ((uint64_t (*)(void))((char *)sub_1000C7D88 + 4 * byte_100340537[v4]))();
  else
    return ((uint64_t (*)(void))((char *)sub_1000C7DA8 + 4 * byte_10034053C[v4]))();
}

_BYTE *sub_1000C7D88(_BYTE *result, char a2)
{
  *result = a2;
  return result;
}

_BYTE *sub_1000C7DA8(_BYTE *result)
{
  *result = 0;
  return result;
}

_DWORD *sub_1000C7DB0(_DWORD *result, int a2)
{
  *result = a2;
  return result;
}

_WORD *sub_1000C7DB8(_WORD *result, __int16 a2)
{
  *result = a2;
  return result;
}

_WORD *sub_1000C7DC0(_WORD *result)
{
  *result = 0;
  return result;
}

_DWORD *sub_1000C7DC8(_DWORD *result)
{
  *result = 0;
  return result;
}

ValueMetadata *type metadata accessor for Bandwidth.FortyMHzCodingKeys()
{
  return &type metadata for Bandwidth.FortyMHzCodingKeys;
}

ValueMetadata *type metadata accessor for Bandwidth.EightyMHzCodingKeys()
{
  return &type metadata for Bandwidth.EightyMHzCodingKeys;
}

ValueMetadata *type metadata accessor for Bandwidth.OneSixtyMHzCodingKeys()
{
  return &type metadata for Bandwidth.OneSixtyMHzCodingKeys;
}

ValueMetadata *type metadata accessor for Bandwidth.ThreeTwentyMHzCodingKeys()
{
  return &type metadata for Bandwidth.ThreeTwentyMHzCodingKeys;
}

unint64_t sub_1000C7E18()
{
  unint64_t result;

  result = qword_100406ED8;
  if (!qword_100406ED8)
  {
    result = swift_getWitnessTable(&unk_10034090C, &type metadata for Bandwidth.FortyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406ED8);
  }
  return result;
}

unint64_t sub_1000C7E60()
{
  unint64_t result;

  result = qword_100406EE0;
  if (!qword_100406EE0)
  {
    result = swift_getWitnessTable(&unk_100340A64, &type metadata for Bandwidth.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406EE0);
  }
  return result;
}

unint64_t sub_1000C7EA8()
{
  unint64_t result;

  result = qword_100406EE8;
  if (!qword_100406EE8)
  {
    result = swift_getWitnessTable(&unk_100340984, &type metadata for Bandwidth.TenMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406EE8);
  }
  return result;
}

unint64_t sub_1000C7EF0()
{
  unint64_t result;

  result = qword_100406EF0;
  if (!qword_100406EF0)
  {
    result = swift_getWitnessTable(&unk_1003409AC, &type metadata for Bandwidth.TenMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406EF0);
  }
  return result;
}

unint64_t sub_1000C7F38()
{
  unint64_t result;

  result = qword_100406EF8;
  if (!qword_100406EF8)
  {
    result = swift_getWitnessTable(&unk_100340934, &type metadata for Bandwidth.TwentyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406EF8);
  }
  return result;
}

unint64_t sub_1000C7F80()
{
  unint64_t result;

  result = qword_100406F00;
  if (!qword_100406F00)
  {
    result = swift_getWitnessTable(&unk_10034095C, &type metadata for Bandwidth.TwentyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406F00);
  }
  return result;
}

unint64_t sub_1000C7FC8()
{
  unint64_t result;

  result = qword_100406F08;
  if (!qword_100406F08)
  {
    result = swift_getWitnessTable(&unk_10034087C, &type metadata for Bandwidth.FortyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406F08);
  }
  return result;
}

unint64_t sub_1000C8010()
{
  unint64_t result;

  result = qword_100406F10;
  if (!qword_100406F10)
  {
    result = swift_getWitnessTable(&unk_1003408A4, &type metadata for Bandwidth.FortyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406F10);
  }
  return result;
}

unint64_t sub_1000C8058()
{
  unint64_t result;

  result = qword_100406F18;
  if (!qword_100406F18)
  {
    result = swift_getWitnessTable(&unk_10034082C, &type metadata for Bandwidth.EightyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406F18);
  }
  return result;
}

unint64_t sub_1000C80A0()
{
  unint64_t result;

  result = qword_100406F20;
  if (!qword_100406F20)
  {
    result = swift_getWitnessTable(&unk_100340854, &type metadata for Bandwidth.EightyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406F20);
  }
  return result;
}

unint64_t sub_1000C80E8()
{
  unint64_t result;

  result = qword_100406F28;
  if (!qword_100406F28)
  {
    result = swift_getWitnessTable(&unk_1003407DC, &type metadata for Bandwidth.OneSixtyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406F28);
  }
  return result;
}

unint64_t sub_1000C8130()
{
  unint64_t result;

  result = qword_100406F30;
  if (!qword_100406F30)
  {
    result = swift_getWitnessTable(&unk_100340804, &type metadata for Bandwidth.OneSixtyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406F30);
  }
  return result;
}

unint64_t sub_1000C8178()
{
  unint64_t result;

  result = qword_100406F38;
  if (!qword_100406F38)
  {
    result = swift_getWitnessTable(&unk_10034078C, &type metadata for Bandwidth.ThreeTwentyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406F38);
  }
  return result;
}

unint64_t sub_1000C81C0()
{
  unint64_t result;

  result = qword_100406F40;
  if (!qword_100406F40)
  {
    result = swift_getWitnessTable(&unk_1003407B4, &type metadata for Bandwidth.ThreeTwentyMHzCodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406F40);
  }
  return result;
}

unint64_t sub_1000C8208()
{
  unint64_t result;

  result = qword_100406F48;
  if (!qword_100406F48)
  {
    result = swift_getWitnessTable(&unk_1003409D4, &type metadata for Bandwidth.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406F48);
  }
  return result;
}

unint64_t sub_1000C8250()
{
  unint64_t result;

  result = qword_100406F50;
  if (!qword_100406F50)
  {
    result = swift_getWitnessTable(&unk_1003409FC, &type metadata for Bandwidth.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100406F50);
  }
  return result;
}

uint64_t sub_1000C8294(uint64_t a1, unint64_t a2)
{
  unint64_t v5;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char v11;

  if (a1 == 0x7A484D6E6574 && a2 == 0xE600000000000000)
  {
    v5 = 0xE600000000000000;
    goto LABEL_8;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x7A484D6E6574, 0xE600000000000000, a1, a2, 0) & 1) != 0)
  {
    v5 = a2;
LABEL_8:
    swift_bridgeObjectRelease(v5);
    return 0;
  }
  if (a1 == 0x484D79746E657774 && a2 == 0xE90000000000007ALL)
  {
    v7 = 0xE90000000000007ALL;
LABEL_14:
    swift_bridgeObjectRelease(v7);
    return 1;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x484D79746E657774, 0xE90000000000007ALL, a1, a2, 0) & 1) != 0)
  {
    v7 = a2;
    goto LABEL_14;
  }
  if (a1 == 0x7A484D7974726F66 && a2 == 0xE800000000000000)
  {
    v8 = 0xE800000000000000;
LABEL_20:
    swift_bridgeObjectRelease(v8);
    return 2;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x7A484D7974726F66, 0xE800000000000000, a1, a2, 0) & 1) != 0)
  {
    v8 = a2;
    goto LABEL_20;
  }
  if (a1 == 0x484D797468676965 && a2 == 0xE90000000000007ALL)
  {
    v9 = 0xE90000000000007ALL;
LABEL_26:
    swift_bridgeObjectRelease(v9);
    return 3;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x484D797468676965, 0xE90000000000007ALL, a1, a2, 0) & 1) != 0)
  {
    v9 = a2;
    goto LABEL_26;
  }
  if (a1 == 0x7974786953656E6FLL && a2 == 0xEB000000007A484DLL)
  {
    v10 = 0xEB000000007A484DLL;
LABEL_32:
    swift_bridgeObjectRelease(v10);
    return 4;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x7974786953656E6FLL, 0xEB000000007A484DLL, a1, a2, 0) & 1) != 0)
  {
    v10 = a2;
    goto LABEL_32;
  }
  if (a1 == 0x6577546565726874 && a2 == 0xEE007A484D79746ELL)
  {
    swift_bridgeObjectRelease(0xEE007A484D79746ELL);
    return 5;
  }
  else
  {
    v11 = _stringCompareWithSmolCheck(_:_:expecting:)(0x6577546565726874, 0xEE007A484D79746ELL, a1, a2, 0);
    swift_bridgeObjectRelease(a2);
    if ((v11 & 1) != 0)
      return 5;
    else
      return 6;
  }
}

uint64_t sub_1000C8560(uint64_t a1, uint64_t a2)
{
  char v3;
  char v4;

  if (a1 == 0xD000000000000015 && a2 == 0x8000000100364920)
  {
    swift_bridgeObjectRelease(0x8000000100364920);
    v3 = 0;
  }
  else
  {
    v4 = _stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000015, 0x8000000100364920, a1, a2, 0);
    swift_bridgeObjectRelease(a2);
    v3 = v4 ^ 1;
  }
  return v3 & 1;
}

uint64_t UnkeyedDecodingContainer.inferredDecode<A>()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)(a2, a2, a4, a1, a3);
}

void static BinaryDecoder.decode<A>(_:data:)(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v5;
  uint64_t v6;
  _QWORD *v7;

  v5 = a3 >> 62;
  sub_100031FEC(a2, a3);
  sub_10001F11C((uint64_t)_swiftEmptyArrayStorage);
  v6 = type metadata accessor for BinaryDecoder();
  v7 = (_QWORD *)swift_allocObject(v6, 48, 7);
  v7[5] = &_swiftEmptyDictionarySingleton;
  v7[2] = a2;
  v7[3] = a3;
  __asm { BR              X10 }
}

uint64_t sub_1000C86A4(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v9;

  *(_QWORD *)(v4 + 32) = v6;
  swift_beginAccess(a1, &v9, 1, 0);
  v7 = *(_QWORD *)(v4 + 40);
  *(_QWORD *)(v4 + 40) = v5;
  swift_bridgeObjectRelease(v7);
  BinaryDecoder.decode<A>(_:)(v2, (uint64_t)v2, v1, v3);
  return swift_release(v4);
}

uint64_t UnkeyedDecodingContainer.decodeData(with:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  _QWORD v16[2];

  v5 = v4;
  v9 = *(_QWORD *)(a2 - 8);
  __chkstk_darwin();
  v11 = (char *)v16 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v11, v3, a2);
  if (swift_dynamicCast(v16, v11, a2, &type metadata for BinaryDecoder.UnkeyedContainer, 0))
  {
    v12 = v16[0];
    swift_retain();
    BinaryDecoder.decodeData(with:)(a1);
    v5 = v13;
    swift_release_n(v12, 2);
  }
  else
  {
    v14 = sub_10007BAC0();
    dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)(&type metadata for Data, &type metadata for Data, v14, a2, a3);
    if (!v4)
      __asm { BR              X10 }
  }
  (*(void (**)(char *, uint64_t))(v9 + 8))(v11, a2);
  return v5;
}

void BinaryDecoder.__allocating_init(data:userInfo:)(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v5;

  v5 = (_QWORD *)swift_allocObject(v2, 48, 7);
  v5[5] = &_swiftEmptyDictionarySingleton;
  v5[2] = a1;
  v5[3] = a2;
  __asm { BR              X11 }
}

uint64_t sub_1000C8970(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v6;

  *(_QWORD *)(v2 + 32) = v3;
  swift_beginAccess(a1, &v6, 1, 0);
  v4 = *(_QWORD *)(v2 + 40);
  *(_QWORD *)(v2 + 40) = v1;
  swift_bridgeObjectRelease(v4);
  return v2;
}

void static BinaryDecoder.decode<A>(_:data:)(uint64_t a1, unint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  _QWORD *v6;

  v4 = a2 >> 62;
  sub_100031FEC(a1, a2);
  sub_10001F11C((uint64_t)_swiftEmptyArrayStorage);
  v5 = type metadata accessor for BinaryDecoder();
  v6 = (_QWORD *)swift_allocObject(v5, 48, 7);
  v6[5] = &_swiftEmptyDictionarySingleton;
  v6[2] = a1;
  v6[3] = a2;
  __asm { BR              X10 }
}

uint64_t sub_1000C8A3C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;

  *(_QWORD *)(v2 + 32) = v3;
  swift_beginAccess(a1, &v8, 1, 0);
  v4 = *(_QWORD *)(v2 + 40);
  *(_QWORD *)(v2 + 40) = v1;
  swift_bridgeObjectRelease(v4);
  BinaryDecoder.decode<A>(_:)();
  v6 = v5;
  swift_release(v2);
  return v6;
}

uint64_t CodingUserInfoKey.channelInformationHasAuxillaryBitmap.unsafeMutableAddressor()
{
  return sub_1000C8B0C(&qword_100403F40, (uint64_t)static CodingUserInfoKey.channelInformationHasAuxillaryBitmap, (uint64_t)sub_1000C8B68);
}

uint64_t sub_1000C8ACC(uint64_t a1)
{
  return sub_1000C8B8C(a1, static CodingUserInfoKey.fourByteAlignedValue, 0xD000000000000014, 0x8000000100364970);
}

uint64_t CodingUserInfoKey.fourByteAlignedValue.unsafeMutableAddressor()
{
  return sub_1000C8B0C(&qword_100403F38, (uint64_t)static CodingUserInfoKey.fourByteAlignedValue, (uint64_t)sub_1000C8ACC);
}

uint64_t sub_1000C8B0C(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  if (*a1 != -1)
    swift_once(a1, a3);
  v4 = type metadata accessor for CodingUserInfoKey(0);
  return sub_100014C44(v4, a2);
}

uint64_t static CodingUserInfoKey.fourByteAlignedValue.getter@<X0>(uint64_t a1@<X8>)
{
  return sub_1000C8C84(&qword_100403F38, (uint64_t)static CodingUserInfoKey.fourByteAlignedValue, (uint64_t)sub_1000C8ACC, a1);
}

uint64_t sub_1000C8B68(uint64_t a1)
{
  return sub_1000C8B8C(a1, static CodingUserInfoKey.channelInformationHasAuxillaryBitmap, 0xD000000000000024, 0x8000000100364990);
}

uint64_t sub_1000C8B8C(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  uint64_t v13;

  sub_100012C44(&qword_1004071B8);
  __chkstk_darwin();
  v8 = (char *)&v13 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  v9 = type metadata accessor for CodingUserInfoKey(0);
  sub_10001C964(v9, a2);
  v10 = sub_100014C44(v9, (uint64_t)a2);
  CodingUserInfoKey.init(rawValue:)(a3, a4);
  v11 = *(_QWORD *)(v9 - 8);
  result = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v11 + 48))(v8, 1, v9);
  if ((_DWORD)result != 1)
    return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v11 + 32))(v10, v8, v9);
  __break(1u);
  return result;
}

uint64_t static CodingUserInfoKey.channelInformationHasAuxillaryBitmap.getter@<X0>(uint64_t a1@<X8>)
{
  return sub_1000C8C84(&qword_100403F40, (uint64_t)static CodingUserInfoKey.channelInformationHasAuxillaryBitmap, (uint64_t)sub_1000C8B68, a1);
}

uint64_t sub_1000C8C84@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v6;
  uint64_t v7;

  if (*a1 != -1)
    swift_once(a1, a3);
  v6 = type metadata accessor for CodingUserInfoKey(0);
  v7 = sub_100014C44(v6, a2);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v6 - 8) + 16))(a4, v7, v6);
}

void sub_1000C8CEC(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;

  BinaryDecoder.decode<A>(_:)();
  if (!v2)
  {
    v6 = v5;
    a2[3] = type metadata accessor for Array(0, a1);
    *a2 = v6;
  }
}

void sub_1000C8D48(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  sub_1000C8CEC(*(_QWORD *)(a1 + 16), a2);
}

void BinaryDecoder.init(data:userInfo:)(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;

  v2[5] = &_swiftEmptyDictionarySingleton;
  v2[2] = a1;
  v2[3] = a2;
  __asm { BR              X12 }
}

uint64_t sub_1000C8DB0@<X0>(uint64_t a1@<X0>, int a2@<W8>)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;

  *(_QWORD *)(v3 + 32) = a2;
  swift_beginAccess(a1, &v6, 1, 0);
  v4 = *(_QWORD *)(v3 + 40);
  *(_QWORD *)(v3 + 40) = v2;
  swift_bridgeObjectRelease(v4);
  return v3;
}

uint64_t BinaryDecoder.userInfo.getter()
{
  uint64_t v0;
  _BYTE v2[24];

  swift_beginAccess(v0 + 40, v2, 0, 0);
  return swift_bridgeObjectRetain(*(_QWORD *)(v0 + 40));
}

uint64_t BinaryDecoder.userInfo.setter(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  _BYTE v5[24];

  swift_beginAccess(v1 + 40, v5, 1, 0);
  v3 = *(_QWORD *)(v1 + 40);
  *(_QWORD *)(v1 + 40) = a1;
  return swift_bridgeObjectRelease(v3);
}

void *BinaryDecoder.userInfo.modify(uint64_t a1)
{
  uint64_t v1;

  swift_beginAccess(v1 + 40, a1, 33, 0);
  return &j__swift_endAccess;
}

void sub_1000C8EA4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BinaryDecoder.decode<A>(_:)(a5, a5, a3, a8);
}

void sub_1000C8ED0(_QWORD *a1@<X4>, uint64_t a2@<X6>, uint64_t a3@<X8>)
{
  BinaryDecoder.decode<A>(_:)(a1, (uint64_t)a1, a2, a3);
}

uint64_t sub_1000C8EFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return BinaryDecoder.container<A>(keyedBy:)(a1, a5, a7, a4);
}

uint64_t sub_1000C8F24@<X0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  a2[3] = &type metadata for BinaryDecoder.UnkeyedContainer;
  a2[4] = sub_10007BA38();
  *a2 = a1;
  return swift_retain();
}

uint64_t sub_1000C8F74@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  a2[3] = type metadata accessor for BinaryDecoder();
  a2[4] = sub_1000CB2CC();
  *a2 = a1;
  return swift_retain();
}

uint64_t sub_1000C8FC0@<X0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  a2[3] = type metadata accessor for BinaryDecoder();
  a2[4] = sub_1000CB2CC();
  *a2 = a1;
  return swift_retain();
}

uint64_t sub_1000C900C(uint64_t a1)
{
  return sub_1000CB8C4(*(_QWORD *)(a1 + 16));
}

uint64_t sub_1000C9018()
{
  uint64_t v0;
  char v1;
  char v3;

  sub_1000C8ED0(&type metadata for Bool, (uint64_t)&protocol witness table for Bool, (uint64_t)&v3);
  if (!v0)
    v1 = v3;
  return v1 & 1;
}

void sub_1000C906C()
{
  uint64_t v0;

  sub_1000C8ED0(&type metadata for String, (uint64_t)&protocol witness table for String, (uint64_t)&v0);
}

double sub_1000C90BC()
{
  uint64_t v0;
  double result;
  double v2;

  sub_1000C8ED0(&type metadata for Double, (uint64_t)&protocol witness table for Double, (uint64_t)&v2);
  if (!v0)
    return v2;
  return result;
}

float sub_1000C910C()
{
  uint64_t v0;
  float result;
  float v2;

  sub_1000C8ED0(&type metadata for Float, (uint64_t)&protocol witness table for Float, (uint64_t)&v2);
  if (!v0)
    return v2;
  return result;
}

void sub_1000C915C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_1000C94B4(a1, a2, a3, (uint64_t (*)(void))sub_1000CB880, (uint64_t)&type metadata for Int, (uint64_t)&protocol witness table for Int);
}

void sub_1000C9188(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_1000C92A4(a1, a2, a3, (uint64_t (*)(void))sub_1000CB83C, (uint64_t)&type metadata for Int8, (uint64_t)&protocol witness table for Int8);
}

void sub_1000C91B4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_1000C9354(a1, a2, a3, (uint64_t (*)(void))sub_1000CB7F8, (uint64_t)&type metadata for Int16, (uint64_t)&protocol witness table for Int16);
}

void sub_1000C91E0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_1000C9404(a1, a2, a3, (uint64_t (*)(void))sub_1000CB7B4, (uint64_t)&type metadata for Int32, (uint64_t)&protocol witness table for Int32);
}

void sub_1000C920C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_1000C94B4(a1, a2, a3, (uint64_t (*)(void))sub_1000CB770, (uint64_t)&type metadata for Int64, (uint64_t)&protocol witness table for Int64);
}

uint64_t sub_1000C9238()
{
  return KeyedDecodingContainerProtocol.decode(_:forKey:)();
}

void sub_1000C924C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_1000C94B4(a1, a2, a3, (uint64_t (*)(void))sub_1000CB72C, (uint64_t)&type metadata for UInt, (uint64_t)&protocol witness table for UInt);
}

void sub_1000C9278(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_1000C92A4(a1, a2, a3, (uint64_t (*)(void))sub_1000CB6E8, (uint64_t)&type metadata for UInt8, (uint64_t)&protocol witness table for UInt8);
}

void sub_1000C92A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void), uint64_t a5, uint64_t a6)
{
  uint64_t *v6;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v10 = *v6;
  v11 = *(_QWORD *)(a2 + 16);
  v12 = *(_QWORD *)(a2 + 24);
  v13 = a4();
  sub_1000C8EA4(a5, a1, v10, v11, a5, v12, a6, v13);
}

void sub_1000C9328(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_1000C9354(a1, a2, a3, (uint64_t (*)(void))sub_1000CB6A4, (uint64_t)&type metadata for UInt16, (uint64_t)&protocol witness table for UInt16);
}

void sub_1000C9354(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void), uint64_t a5, uint64_t a6)
{
  uint64_t *v6;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v10 = *v6;
  v11 = *(_QWORD *)(a2 + 16);
  v12 = *(_QWORD *)(a2 + 24);
  v13 = a4();
  sub_1000C8EA4(a5, a1, v10, v11, a5, v12, a6, v13);
}

void sub_1000C93D8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_1000C9404(a1, a2, a3, (uint64_t (*)(void))sub_1000CB660, (uint64_t)&type metadata for UInt32, (uint64_t)&protocol witness table for UInt32);
}

void sub_1000C9404(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void), uint64_t a5, uint64_t a6)
{
  uint64_t *v6;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v10 = *v6;
  v11 = *(_QWORD *)(a2 + 16);
  v12 = *(_QWORD *)(a2 + 24);
  v13 = a4();
  sub_1000C8EA4(a5, a1, v10, v11, a5, v12, a6, v13);
}

void sub_1000C9488(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_1000C94B4(a1, a2, a3, (uint64_t (*)(void))sub_1000CB61C, (uint64_t)&type metadata for UInt64, (uint64_t)&protocol witness table for UInt64);
}

void sub_1000C94B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void), uint64_t a5, uint64_t a6)
{
  uint64_t *v6;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v10 = *v6;
  v11 = *(_QWORD *)(a2 + 16);
  v12 = *(_QWORD *)(a2 + 24);
  v13 = a4();
  sub_1000C8EA4(a5, a1, v10, v11, a5, v12, a6, v13);
}

uint64_t sub_1000C9538()
{
  return KeyedDecodingContainerProtocol.decode(_:forKey:)();
}

void sub_1000C954C(_QWORD *a1@<X2>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  sub_1000C8ED0(a1, a2, a3);
}

uint64_t sub_1000C9574()
{
  return KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)();
}

uint64_t sub_1000C9588()
{
  return KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)();
}

uint64_t sub_1000C959C()
{
  uint64_t v0;
  uint64_t result;
  uint64_t v2;

  result = KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)();
  if (v0)
    return v2;
  return result;
}

uint64_t sub_1000C95BC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000C974C(a1, a2, a3, (uint64_t (*)(void))&KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:));
}

uint64_t sub_1000C95D8()
{
  uint64_t v0;
  uint64_t result;
  uint64_t v2;

  result = KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)();
  if (v0)
    return v2;
  return result;
}

uint64_t sub_1000C95F8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000C96C4(a1, a2, a3, (uint64_t (*)(void))&KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:));
}

uint64_t sub_1000C9614(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000C9708(a1, a2, a3, (uint64_t (*)(void))&KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:));
}

uint64_t sub_1000C9630(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000C974C(a1, a2, a3, (uint64_t (*)(void))&KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:));
}

uint64_t sub_1000C964C()
{
  uint64_t v0;
  uint64_t result;
  uint64_t v2;

  result = KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)();
  if (v0)
    return v2;
  return result;
}

uint64_t sub_1000C966C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000C97B8(a1, a2, a3, (uint64_t (*)(void))&KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:));
}

uint64_t sub_1000C9688()
{
  uint64_t v0;
  uint64_t result;
  uint64_t v2;

  result = KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)();
  if (v0)
    return v2;
  return result;
}

uint64_t sub_1000C96A8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000C96C4(a1, a2, a3, (uint64_t (*)(void))&KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:));
}

uint64_t sub_1000C96C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void))
{
  return a4() & 0x1FF;
}

uint64_t sub_1000C96EC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000C9708(a1, a2, a3, (uint64_t (*)(void))&KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:));
}

uint64_t sub_1000C9708(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void))
{
  return a4() & 0x1FFFF;
}

uint64_t sub_1000C9730(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000C974C(a1, a2, a3, (uint64_t (*)(void))&KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:));
}

uint64_t sub_1000C974C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void))
{
  unint64_t v4;

  v4 = a4();
  return v4 | ((HIDWORD(v4) & 1) << 32);
}

uint64_t sub_1000C977C()
{
  uint64_t v0;
  uint64_t result;
  uint64_t v2;

  result = KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)();
  if (v0)
    return v2;
  return result;
}

uint64_t sub_1000C979C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000C97B8(a1, a2, a3, (uint64_t (*)(void))&KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:));
}

uint64_t sub_1000C97B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void))
{
  uint64_t v4;
  uint64_t result;
  uint64_t v6;

  result = a4();
  if (v4)
    return v6;
  return result;
}

uint64_t sub_1000C97DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return KeyedDecodingContainerProtocol.decodeIfPresent<A>(_:forKey:)(a1, a2, a5, a3, a6, a4);
}

uint64_t sub_1000C9804(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t *v5;

  return sub_1000C8EFC(a1, a2, *v5, *(_QWORD *)(a5 + 16), a3, *(_QWORD *)(a5 + 24), a4);
}

uint64_t sub_1000C982C@<X0>(_QWORD *a1@<X8>)
{
  uint64_t *v1;

  return sub_1000C8F24(*v1, a1);
}

uint64_t sub_1000C984C@<X0>(_QWORD *a1@<X8>)
{
  uint64_t *v1;

  return sub_1000C8F74(*v1, a1);
}

uint64_t sub_1000C986C@<X0>(_QWORD *a1@<X8>)
{
  uint64_t *v1;

  return sub_1000C8FC0(*v1, a1);
}

void sub_1000C988C(_QWORD *a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  BinaryDecoder.decode<A>(_:)(a1, a2, a3, a4);
}

uint64_t sub_1000C98B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return BinaryDecoder.container<A>(keyedBy:)(a1, a3, a4, a4);
}

uint64_t sub_1000C98DC()
{
  uint64_t v0;

  return ((uint64_t (*)(void))((char *)sub_1000C9908 + 4 * byte_100340CF0[*(_QWORD *)(*(_QWORD *)v0 + 24) >> 62]))();
}

BOOL sub_1000C9908@<W0>(uint64_t a1@<X8>)
{
  uint64_t v1;

  return a1 == BYTE6(v1);
}

BOOL sub_1000C9928()
{
  char v0;

  sub_1000CA514();
  return v0 != 0;
}

uint64_t sub_1000C9958()
{
  uint64_t *v0;
  uint64_t v1;
  _QWORD v3[5];

  v1 = *v0;
  v3[3] = type metadata accessor for BinaryDecoder();
  v3[4] = sub_1000CB2CC();
  v3[0] = v1;
  swift_retain();
  return String.init(from:)(v3);
}

double sub_1000C99A8()
{
  double v0;

  sub_1000CA91C();
  return v0;
}

uint64_t sub_1000C99D4()
{
  uint64_t *v0;
  uint64_t v1;
  _QWORD v3[5];

  v1 = *v0;
  v3[3] = type metadata accessor for BinaryDecoder();
  v3[4] = sub_1000CB2CC();
  v3[0] = v1;
  swift_retain();
  return Float.init(from:)(v3);
}

void sub_1000C9A24()
{
  sub_1000CA91C();
}

void sub_1000C9A4C()
{
  sub_1000CA514();
}

void sub_1000C9A74()
{
  sub_1000CA7C4();
}

void sub_1000C9A9C()
{
  sub_1000CA66C();
}

uint64_t sub_1000C9AC4(uint64_t a1, uint64_t a2)
{
  unint64_t v4;

  v4 = sub_1000CB288();
  return SingleValueDecodingContainer<>.decode(_:)(a1, v4, a2);
}

uint64_t sub_1000C9B08(uint64_t a1, uint64_t a2)
{
  unint64_t v4;

  v4 = sub_1000CB288();
  return SingleValueDecodingContainer<>.decode(_:)(a1, v4, a2);
}

void sub_1000C9B4C(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  sub_1000C988C(a1, a2, a3, a4);
}

uint64_t sub_1000C9B6C()
{
  return UnkeyedDecodingContainer.decodeIfPresent(_:)();
}

uint64_t sub_1000C9B80()
{
  return UnkeyedDecodingContainer.decodeIfPresent(_:)();
}

uint64_t sub_1000C9B94()
{
  uint64_t v0;
  uint64_t result;
  uint64_t v2;

  result = UnkeyedDecodingContainer.decodeIfPresent(_:)();
  if (v0)
    return v2;
  return result;
}

uint64_t sub_1000C9BB4(uint64_t a1, uint64_t a2)
{
  return sub_1000C9D44(a1, a2, (uint64_t (*)(void))&UnkeyedDecodingContainer.decodeIfPresent(_:));
}

uint64_t sub_1000C9BD0()
{
  uint64_t v0;
  uint64_t result;
  uint64_t v2;

  result = UnkeyedDecodingContainer.decodeIfPresent(_:)();
  if (v0)
    return v2;
  return result;
}

uint64_t sub_1000C9BF0(uint64_t a1, uint64_t a2)
{
  return sub_1000C9CBC(a1, a2, (uint64_t (*)(void))&UnkeyedDecodingContainer.decodeIfPresent(_:));
}

uint64_t sub_1000C9C0C(uint64_t a1, uint64_t a2)
{
  return sub_1000C9D00(a1, a2, (uint64_t (*)(void))&UnkeyedDecodingContainer.decodeIfPresent(_:));
}

uint64_t sub_1000C9C28(uint64_t a1, uint64_t a2)
{
  return sub_1000C9D44(a1, a2, (uint64_t (*)(void))&UnkeyedDecodingContainer.decodeIfPresent(_:));
}

uint64_t sub_1000C9C44()
{
  uint64_t v0;
  uint64_t result;
  uint64_t v2;

  result = UnkeyedDecodingContainer.decodeIfPresent(_:)();
  if (v0)
    return v2;
  return result;
}

uint64_t sub_1000C9C64(uint64_t a1, uint64_t a2)
{
  return sub_1000C9DB0(a1, a2, (uint64_t (*)(void))&UnkeyedDecodingContainer.decodeIfPresent(_:));
}

uint64_t sub_1000C9C80()
{
  uint64_t v0;
  uint64_t result;
  uint64_t v2;

  result = UnkeyedDecodingContainer.decodeIfPresent(_:)();
  if (v0)
    return v2;
  return result;
}

uint64_t sub_1000C9CA0(uint64_t a1, uint64_t a2)
{
  return sub_1000C9CBC(a1, a2, (uint64_t (*)(void))&UnkeyedDecodingContainer.decodeIfPresent(_:));
}

uint64_t sub_1000C9CBC(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  return a3() & 0x1FF;
}

uint64_t sub_1000C9CE4(uint64_t a1, uint64_t a2)
{
  return sub_1000C9D00(a1, a2, (uint64_t (*)(void))&UnkeyedDecodingContainer.decodeIfPresent(_:));
}

uint64_t sub_1000C9D00(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  return a3() & 0x1FFFF;
}

uint64_t sub_1000C9D28(uint64_t a1, uint64_t a2)
{
  return sub_1000C9D44(a1, a2, (uint64_t (*)(void))&UnkeyedDecodingContainer.decodeIfPresent(_:));
}

uint64_t sub_1000C9D44(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  unint64_t v3;

  v3 = a3();
  return v3 | ((HIDWORD(v3) & 1) << 32);
}

uint64_t sub_1000C9D74()
{
  uint64_t v0;
  uint64_t result;
  uint64_t v2;

  result = UnkeyedDecodingContainer.decodeIfPresent(_:)();
  if (v0)
    return v2;
  return result;
}

uint64_t sub_1000C9D94(uint64_t a1, uint64_t a2)
{
  return sub_1000C9DB0(a1, a2, (uint64_t (*)(void))&UnkeyedDecodingContainer.decodeIfPresent(_:));
}

uint64_t sub_1000C9DB0(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v3;
  uint64_t result;
  uint64_t v5;

  result = a3();
  if (v3)
    return v5;
  return result;
}

uint64_t sub_1000C9DD4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return UnkeyedDecodingContainer.decodeIfPresent<A>(_:)(a1, a4, a2, a5, a3);
}

uint64_t sub_1000C9DFC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v3;

  return sub_1000C98B4(a1, *v3, a2, a3);
}

uint64_t sub_1000C9E1C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t *v3;
  uint64_t v4;

  v4 = *v3;
  a3[3] = a1;
  a3[4] = a2;
  *a3 = v4;
  return swift_retain(v4);
}

uint64_t sub_1000C9E40@<X0>(_QWORD *a1@<X8>)
{
  uint64_t *v1;
  uint64_t v3;

  v3 = *v1;
  a1[3] = type metadata accessor for BinaryDecoder();
  a1[4] = sub_1000CB2CC();
  *a1 = v3;
  return swift_retain();
}

uint64_t sub_1000C9E8C(uint64_t a1, uint64_t a2)
{
  unint64_t v4;

  v4 = sub_10007BA38();
  return SingleValueDecodingContainer<>.decode(_:)(a1, a2, v4);
}

uint64_t sub_1000C9ED0(uint64_t a1, uint64_t a2)
{
  unint64_t v4;

  v4 = sub_10007BA38();
  return SingleValueDecodingContainer<>.decode(_:)(a1, a2, v4);
}

uint64_t BinaryDecoder.container<A>(keyedBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t WitnessTable;
  uint64_t v8;

  v5 = type metadata accessor for BinaryDecoder.KeyedContainer(0, a2, a3, a4);
  swift_retain();
  WitnessTable = swift_getWitnessTable(byte_10034110C, v5);
  return KeyedDecodingContainer.init<A>(_:)(&v8, a2, v5, WitnessTable);
}

uint64_t BinaryDecoder.unkeyedContainer()@<X0>(_QWORD *a1@<X8>)
{
  return sub_1000C9FC4((uint64_t (*)(void))sub_10007BA38, a1);
}

uint64_t BinaryDecoder.singleValueContainer()@<X0>(_QWORD *a1@<X8>)
{
  return sub_1000C9FC4((uint64_t (*)(void))sub_1000CB288, a1);
}

uint64_t sub_1000C9FC4@<X0>(uint64_t (*a1)(void)@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;

  a2[3] = &type metadata for BinaryDecoder.UnkeyedContainer;
  a2[4] = a1();
  *a2 = v2;
  return swift_retain(v2);
}

void BinaryDecoder.peekBytes(_:)(uint64_t a1)
{
  uint64_t v1;

  if (!__OFADD__(*(_QWORD *)(v1 + 32), a1))
    __asm { BR              X10 }
  __break(1u);
  JUMPOUT(0x1000CA0D4);
}

void BinaryDecoder.decode<A>(_:)(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  _QWORD v18[5];

  if (a1 == &type metadata for Data)
  {
    sub_1000CB310();
    if (v5)
      return;
    v18[0] = v14;
    v18[1] = v15;
    v13 = (char *)&type metadata for Data;
    goto LABEL_19;
  }
  if (a1 == (_QWORD *)&type metadata for Bool)
  {
    sub_1000CA514();
    if (v5)
      return;
    LOBYTE(v18[0]) = v16 != 0;
    v13 = (char *)&type metadata for Bool;
    goto LABEL_19;
  }
  if (a1 == (_QWORD *)&type metadata for Double)
  {
    sub_1000CA91C();
    if (v5)
      return;
    v18[0] = v17;
    v13 = (char *)&type metadata for Double;
    goto LABEL_19;
  }
  v10 = swift_conformsToProtocol2(a1, &protocol descriptor for BinaryDecodableArray);
  if (v10)
    v11 = v10;
  else
    v11 = 0;
  if (v10)
    v12 = a1;
  else
    v12 = 0;
  if (v12)
  {
    (*(void (**)(_QWORD *__return_ptr, uint64_t))(v11 + 8))(v18, v4);
    if (v5)
      return;
    v13 = (char *)&type metadata for Any + 8;
LABEL_19:
    swift_dynamicCast(a4, v18, v13, a2, 7);
    return;
  }
  v18[3] = type metadata accessor for BinaryDecoder();
  v18[4] = sub_1000CB2CC();
  v18[0] = v4;
  swift_retain(v4);
  dispatch thunk of Decodable.init(from:)(v18, a2, a3);
}

void BinaryDecoder.decode<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;

  v7 = __chkstk_darwin();
  v9 = (char *)&v11 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_1000CAA74(v7, v10);
  if (!v4)
    dispatch thunk of FixedWidthInteger.init(littleEndian:)(v9, a2, a4);
}

double BinaryDecoder.decode(_:)()
{
  double v0;

  sub_1000CA91C();
  return v0;
}

void BinaryDecoder.decode(_:)()
{
  sub_1000CB310();
}

BOOL BinaryDecoder.decode(_:)()
{
  char v0;

  sub_1000CA514();
  return v0 != 0;
}

void BinaryDecoder.decode<A>(_:)()
{
  uint64_t v1;

  v1 = __chkstk_darwin();
  Array.init()(v1);
  __asm { BR              X10 }
}

uint64_t sub_1000CA420@<X0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;

  if (a1 >= *(_QWORD *)(v5 - 128))
    return *(_QWORD *)(v5 - 72);
  BinaryDecoder.decode<A>(_:)(v3, (uint64_t)v3, v2, v4);
  if (!v1)
    JUMPOUT(0x1000CA3ECLL);
  *(_QWORD *)(v5 - 88) = v1;
  swift_errorRetain(v1);
  v6 = sub_100012C44((uint64_t *)&unk_10040C360);
  if (swift_dynamicCast(v5 - 112, v5 - 88, v6, &type metadata for WiFiError, 0))
  {
    v7 = *(_QWORD *)(v5 - 112);
    v8 = *(unsigned __int8 *)(v5 - 96);
    if (v8 == 2)
    {
      if ((v7 & 1) != 0)
      {
        swift_errorRelease(v1);
        swift_errorRelease(*(_QWORD *)(v5 - 88));
        JUMPOUT(0x1000CA408);
      }
    }
    else
    {
      sub_100013024(v7, *(_QWORD *)(v5 - 104), v8);
    }
  }
  swift_bridgeObjectRelease(*(_QWORD *)(v5 - 72));
  return swift_errorRelease(*(_QWORD *)(v5 - 88));
}

void sub_1000CA514()
{
  uint64_t v0;

  if (!__OFADD__(*(_QWORD *)(v0 + 32), 1))
    __asm { BR              X10 }
  __break(1u);
  JUMPOUT(0x1000CA658);
}

void sub_1000CA66C()
{
  uint64_t v0;

  if (!__OFADD__(*(_QWORD *)(v0 + 32), 4))
    __asm { BR              X10 }
  __break(1u);
  JUMPOUT(0x1000CA7B0);
}

void sub_1000CA7C4()
{
  uint64_t v0;

  if (!__OFADD__(*(_QWORD *)(v0 + 32), 2))
    __asm { BR              X10 }
  __break(1u);
  JUMPOUT(0x1000CA908);
}

void sub_1000CA91C()
{
  uint64_t v0;

  if (!__OFADD__(*(_QWORD *)(v0 + 32), 8))
    __asm { BR              X10 }
  __break(1u);
  JUMPOUT(0x1000CAA60);
}

void sub_1000CAA74(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  if (!__OFADD__(*(_QWORD *)(v2 + 32), *(_QWORD *)(*(_QWORD *)(a2 - 8) + 64)))
    __asm { BR              X10 }
  __break(1u);
  JUMPOUT(0x1000CABCCLL);
}

void BinaryDecoder.inferredDecode<A>()(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  BinaryDecoder.decode<A>(_:)(a1, (uint64_t)a1, a2, a3);
}

void BinaryDecoder.decodeData(with:)(uint64_t a1)
{
  uint64_t v1;

  if (!__OFADD__(*(_QWORD *)(v1 + 32), a1))
    __asm { BR              X11 }
  __break(1u);
  JUMPOUT(0x1000CACD4);
}

uint64_t IEEE80211InformationElement.MessageIntegrityCode.code.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t result;

  result = sub_10000E614(*(_QWORD *)v2, *(_QWORD *)(v2 + 8));
  *(_QWORD *)v2 = a1;
  *(_QWORD *)(v2 + 8) = a2;
  return result;
}

void BinaryDecoder.DataCopy.init(_:)(uint64_t a1, uint64_t a2)
{
  __asm { BR              X10 }
}

uint64_t sub_1000CAD58()
{
  unint64_t v0;
  uint64_t v1;
  uint64_t v2;

  v2 = Data.subdata(in:)(0, BYTE6(v0), v1, v0);
  sub_10000E614(v1, v0);
  return v2;
}

uint64_t BinaryDecoder.DataCopy.init(from:)(_QWORD *a1)
{
  return sub_1000CB45C(a1);
}

uint64_t InterfaceIdentifier.encode(to:)(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  _QWORD v11[2];
  _QWORD v12[3];
  uint64_t v13;
  uint64_t v14;

  v5 = a1[3];
  v6 = a1[4];
  sub_10003259C(a1, v5);
  dispatch thunk of Encoder.singleValueContainer()(v12, v5, v6);
  v11[0] = a2;
  v11[1] = a3;
  v7 = v13;
  v8 = v14;
  sub_100034C68((uint64_t)v12, v13);
  v9 = sub_100068570();
  dispatch thunk of SingleValueEncodingContainer.encode<A>(_:)(v11, &type metadata for Data, v9, v7, v8);
  return sub_100014430(v12);
}

uint64_t sub_1000CAE84@<X0>(_QWORD *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v5;

  result = BinaryDecoder.DataCopy.init(from:)(a1);
  if (!v2)
  {
    *a2 = result;
    a2[1] = v5;
  }
  return result;
}

uint64_t sub_1000CAEAC(_QWORD *a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  _QWORD v10[2];
  _QWORD v11[3];
  uint64_t v12;
  uint64_t v13;

  v2 = *v1;
  v3 = v1[1];
  v4 = a1[3];
  v5 = a1[4];
  sub_10003259C(a1, v4);
  dispatch thunk of Encoder.singleValueContainer()(v11, v4, v5);
  v10[0] = v2;
  v10[1] = v3;
  v6 = v12;
  v7 = v13;
  sub_100034C68((uint64_t)v11, v12);
  v8 = sub_100068570();
  dispatch thunk of SingleValueEncodingContainer.encode<A>(_:)(v10, &type metadata for Data, v8, v6, v7);
  return sub_100014430(v11);
}

uint64_t sub_1000CAF50()
{
  uint64_t *v0;
  uint64_t v1;
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = *v0;
  v2 = v0[1];
  sub_100031FEC(v1, v2);
  sub_100032030(0, 0xE000000000000000, v1, v2);
  v4 = v3;
  sub_10000E614(v1, v2);
  return v4;
}

_QWORD *BinaryDecoder.deinit()
{
  _QWORD *v0;

  sub_10000E614(v0[2], v0[3]);
  swift_bridgeObjectRelease(v0[5]);
  return v0;
}

uint64_t BinaryDecoder.__deallocating_deinit()
{
  _QWORD *v0;

  sub_10000E614(v0[2], v0[3]);
  swift_bridgeObjectRelease(v0[5]);
  return swift_deallocClassInstance(v0, 48, 7);
}

uint64_t sub_1000CB00C()
{
  uint64_t *v0;
  uint64_t v1;
  _BYTE v3[24];

  v1 = *v0;
  swift_beginAccess(*v0 + 40, v3, 0, 0);
  return swift_bridgeObjectRetain(*(_QWORD *)(v1 + 40));
}

uint64_t sub_1000CB04C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return BinaryDecoder.container<A>(keyedBy:)(a1, a2, a3, a4);
}

uint64_t sub_1000CB06C@<X0>(_QWORD *a1@<X8>)
{
  return sub_1000CB0A4((uint64_t (*)(void))sub_10007BA38, a1);
}

uint64_t sub_1000CB088@<X0>(_QWORD *a1@<X8>)
{
  return sub_1000CB0A4((uint64_t (*)(void))sub_1000CB288, a1);
}

uint64_t sub_1000CB0A4@<X0>(uint64_t (*a1)(void)@<X2>, _QWORD *a2@<X8>)
{
  uint64_t *v2;
  uint64_t v4;

  v4 = *v2;
  a2[3] = &type metadata for BinaryDecoder.UnkeyedContainer;
  a2[4] = a1();
  *a2 = v4;
  return swift_retain(v4);
}

uint64_t UnkeyedDecodingContainer.inferredArrayDecode<A>()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t WitnessTable;
  uint64_t v19;
  uint64_t v20;

  v6 = v5;
  v11 = *(_QWORD *)(a1 - 8);
  __chkstk_darwin();
  v13 = (char *)&v19 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v13, v4, a1);
  if (swift_dynamicCast(&v20, v13, a1, &type metadata for BinaryDecoder.UnkeyedContainer, 0))
  {
    v14 = v20;
    swift_retain();
    BinaryDecoder.decode<A>(_:)();
    v6 = v15;
    swift_release_n(v14, 2);
  }
  else
  {
    v16 = type metadata accessor for Array(0, a2);
    v19 = a4;
    WitnessTable = swift_getWitnessTable((const char *)&protocol conformance descriptor for <A> [A], v16, &v19);
    dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)(v16, v16, WitnessTable, a1, a3);
    if (!v5)
      v6 = v20;
  }
  (*(void (**)(char *, uint64_t))(v11 + 8))(v13, a1);
  return v6;
}

uint64_t type metadata accessor for BinaryDecoder()
{
  return objc_opt_self(_TtC7CoreP2P13BinaryDecoder);
}

uint64_t type metadata accessor for BinaryDecoder.KeyedContainer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_100033C60(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for BinaryDecoder.KeyedContainer);
}

unint64_t sub_1000CB288()
{
  unint64_t result;

  result = qword_100406F90;
  if (!qword_100406F90)
  {
    result = swift_getWitnessTable("%\n\n", &type metadata for BinaryDecoder.UnkeyedContainer);
    atomic_store(result, (unint64_t *)&qword_100406F90);
  }
  return result;
}

unint64_t sub_1000CB2CC()
{
  unint64_t result;
  uint64_t v1;

  result = qword_100405BB8;
  if (!qword_100405BB8)
  {
    v1 = type metadata accessor for BinaryDecoder();
    result = swift_getWitnessTable(protocol conformance descriptor for BinaryDecoder, v1);
    atomic_store(result, (unint64_t *)&qword_100405BB8);
  }
  return result;
}

void sub_1000CB310()
{
  __asm { BR              X9 }
}

uint64_t sub_1000CB45C(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  _QWORD v10[3];
  uint64_t v11;
  uint64_t v12;

  v3 = a1[3];
  v4 = a1[4];
  sub_10003259C(a1, v3);
  dispatch thunk of Decoder.unkeyedContainer()(v10, v3, v4);
  if (!v1)
  {
    v5 = v11;
    v6 = v12;
    sub_100034C68((uint64_t)v10, v11);
    v7 = sub_10007BAC0();
    dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)(&type metadata for Data, &type metadata for Data, v7, v5, v6);
    __asm { BR              X10 }
  }
  sub_100014430(a1);
  return v4;
}

void sub_1000CB548(uint64_t a1, uint64_t a2, uint64_t a3, ...)
{
  _QWORD *v3;
  uint64_t v4;
  unint64_t v5;
  va_list va;

  va_start(va, a3);
  Data.subdata(in:)(0, BYTE6(v5), v4, v5);
  sub_10000E614(v4, v5);
  sub_100014430((uint64_t *)va);
  sub_100014430(v3);
  JUMPOUT(0x1000CB4FCLL);
}

unint64_t sub_1000CB5B8()
{
  unint64_t result;

  result = qword_100406F98;
  if (!qword_100406F98)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for BinaryDecoder.DataCopy, &type metadata for BinaryDecoder.DataCopy);
    atomic_store(result, (unint64_t *)&qword_100406F98);
  }
  return result;
}

ValueMetadata *type metadata accessor for BinaryDecoder.DataCopy()
{
  return &type metadata for BinaryDecoder.DataCopy;
}

ValueMetadata *type metadata accessor for BinaryDecoder.UnkeyedContainer()
{
  return &type metadata for BinaryDecoder.UnkeyedContainer;
}

unint64_t sub_1000CB61C()
{
  unint64_t result;

  result = qword_100407170;
  if (!qword_100407170)
  {
    result = swift_getWitnessTable((const char *)&protocol conformance descriptor for UInt64, &type metadata for UInt64);
    atomic_store(result, (unint64_t *)&qword_100407170);
  }
  return result;
}

unint64_t sub_1000CB660()
{
  unint64_t result;

  result = qword_100407178;
  if (!qword_100407178)
  {
    result = swift_getWitnessTable((const char *)&protocol conformance descriptor for UInt32, &type metadata for UInt32);
    atomic_store(result, (unint64_t *)&qword_100407178);
  }
  return result;
}

unint64_t sub_1000CB6A4()
{
  unint64_t result;

  result = qword_100407180;
  if (!qword_100407180)
  {
    result = swift_getWitnessTable((const char *)&protocol conformance descriptor for UInt16, &type metadata for UInt16);
    atomic_store(result, (unint64_t *)&qword_100407180);
  }
  return result;
}

unint64_t sub_1000CB6E8()
{
  unint64_t result;

  result = qword_100407188;
  if (!qword_100407188)
  {
    result = swift_getWitnessTable((const char *)&protocol conformance descriptor for UInt8, &type metadata for UInt8);
    atomic_store(result, (unint64_t *)&qword_100407188);
  }
  return result;
}

unint64_t sub_1000CB72C()
{
  unint64_t result;

  result = qword_100407190;
  if (!qword_100407190)
  {
    result = swift_getWitnessTable((const char *)&protocol conformance descriptor for UInt, &type metadata for UInt);
    atomic_store(result, (unint64_t *)&qword_100407190);
  }
  return result;
}

unint64_t sub_1000CB770()
{
  unint64_t result;

  result = qword_100407198;
  if (!qword_100407198)
  {
    result = swift_getWitnessTable((const char *)&protocol conformance descriptor for Int64, &type metadata for Int64);
    atomic_store(result, (unint64_t *)&qword_100407198);
  }
  return result;
}

unint64_t sub_1000CB7B4()
{
  unint64_t result;

  result = qword_1004071A0;
  if (!qword_1004071A0)
  {
    result = swift_getWitnessTable((const char *)&protocol conformance descriptor for Int32, &type metadata for Int32);
    atomic_store(result, (unint64_t *)&qword_1004071A0);
  }
  return result;
}

unint64_t sub_1000CB7F8()
{
  unint64_t result;

  result = qword_1004071A8;
  if (!qword_1004071A8)
  {
    result = swift_getWitnessTable((const char *)&protocol conformance descriptor for Int16, &type metadata for Int16);
    atomic_store(result, (unint64_t *)&qword_1004071A8);
  }
  return result;
}

unint64_t sub_1000CB83C()
{
  unint64_t result;

  result = qword_1004071B0;
  if (!qword_1004071B0)
  {
    result = swift_getWitnessTable((const char *)&protocol conformance descriptor for Int8, &type metadata for Int8);
    atomic_store(result, (unint64_t *)&qword_1004071B0);
  }
  return result;
}

unint64_t sub_1000CB880()
{
  unint64_t result;

  result = qword_1004101F0;
  if (!qword_1004101F0)
  {
    result = swift_getWitnessTable((const char *)&protocol conformance descriptor for Int, &type metadata for Int);
    atomic_store(result, (unint64_t *)&qword_1004101F0);
  }
  return result;
}

uint64_t sub_1000CB8C4(uint64_t a1)
{
  return static Array._allocateUninitialized(_:)(0, a1);
}

unint64_t sub_1000CB8D0(__int16 a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  char v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  _QWORD *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  unsigned __int8 v27;
  uint64_t v28;
  uint64_t v29;

  v3 = (HIBYTE(a1) - a1);
  v26 = HIBYTE(a1);
  v27 = a1;
  if (HIBYTE(a1) < a1)
    v4 = -(uint64_t)(a1 - HIBYTE(a1));
  else
    v4 = (HIBYTE(a1) - a1);
  if (!v4)
    return (unint64_t)_swiftEmptyArrayStorage;
  result = sub_100074F00(0, v4 & ~(v4 >> 63), 0);
  if ((v4 & 0x8000000000000000) == 0)
  {
    LODWORD(v7) = v26 - v27;
    if (v26 >= v27)
      v7 = v7;
    else
      v7 = 0;
    v8 = -v7;
    while (v4)
    {
      v9 = *(_QWORD *)(a2 + 24);
      v10 = *(_QWORD *)(a2 + 32);
      sub_100034C68(a2, v9);
      v11 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v9, v10);
      if (v2)
        goto LABEL_23;
      v12 = v11;
      v29 = v4;
      v13 = *(_QWORD *)(a2 + 24);
      v14 = *(_QWORD *)(a2 + 32);
      sub_100034C68(a2, v13);
      LOBYTE(v14) = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v13, v14);
      v28 = v3;
      v15 = *(_QWORD *)(a2 + 24);
      v16 = *(_QWORD *)(a2 + 32);
      sub_100034C68(a2, v15);
      v17 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v15, v16);
      result = sub_1000DD8A0(v12, v14);
      if ((result & 0xFF00000000) == 0x300000000 || BYTE4(result) < 2u)
      {
        v23 = sub_100012C84();
        v24 = swift_allocError(&type metadata for WiFiError, v23, 0, 0);
        *(_OWORD *)v25 = xmmword_100337850;
        *(_BYTE *)(v25 + 16) = 2;
        swift_willThrow(v24);
LABEL_23:
        swift_release(_swiftEmptyArrayStorage);
        return (unint64_t)_swiftEmptyArrayStorage;
      }
      v19 = result;
      v21 = _swiftEmptyArrayStorage[2];
      v20 = _swiftEmptyArrayStorage[3];
      if (v21 >= v20 >> 1)
        result = sub_100074F00(v20 > 1, v21 + 1, 1);
      _swiftEmptyArrayStorage[2] = v21 + 1;
      v22 = &_swiftEmptyArrayStorage[v21];
      *((_DWORD *)v22 + 8) = v19;
      *((_BYTE *)v22 + 36) = BYTE4(v19);
      *((_BYTE *)v22 + 37) = BYTE5(v19);
      *((_BYTE *)v22 + 38) = v17;
      if (v26 < v27)
        goto LABEL_26;
      if (!v8)
        goto LABEL_27;
      ++v8;
      v4 = v29 - 1;
      v3 = v28 - 1;
      if (v28 == 1)
        return (unint64_t)_swiftEmptyArrayStorage;
    }
    __break(1u);
LABEL_26:
    __break(1u);
LABEL_27:
    __break(1u);
  }
  __break(1u);
  return result;
}

void sub_1000CBB14(__int16 a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unsigned __int8 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 v10;
  unsigned __int8 v11;
  _BYTE *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  char v19;
  _BYTE *v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _BYTE *v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char *v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int v41;
  unsigned __int8 v42;
  unsigned __int8 v43;

  v41 = HIBYTE(a1);
  v40 = (HIBYTE(a1) - a1);
  if (HIBYTE(a1) < a1)
    v3 = -(uint64_t)(a1 - HIBYTE(a1));
  else
    v3 = (HIBYTE(a1) - a1);
  if (!v3)
    return;
  v5 = a1;
  sub_100075000(0, v3 & ~(v3 >> 63), 0);
  if (v3 < 0)
    goto LABEL_52;
  v6 = 0;
  LODWORD(v7) = v41 - v5;
  if (v41 >= v5)
    v7 = v7;
  else
    v7 = 0;
  v38 = v3;
  v39 = v7;
  while (v6 != v3)
  {
    v8 = *(_QWORD *)(a2 + 24);
    v9 = *(_QWORD *)(a2 + 32);
    sub_100034C68(a2, v8);
    v10 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v8, v9);
    if (v2)
    {
      swift_release(_swiftEmptyArrayStorage);
      return;
    }
    v11 = v10;
    if (qword_100404150 != -1)
      swift_once(&qword_100404150, sub_100190108);
    v12 = off_100409F48;
    if (*((_QWORD *)off_100409F48 + 2))
    {
      v13 = static Hasher._hash(seed:bytes:count:)(*((_QWORD *)off_100409F48 + 5), v11, 4);
      v14 = -1 << v12[32];
      v15 = v13 & ~v14;
      if (((*(_QWORD *)&v12[((v15 >> 3) & 0xFFFFFFFFFFFFF8) + 56] >> v15) & 1) != 0)
      {
        v16 = *((_QWORD *)v12 + 6);
        if (*(_DWORD *)(v16 + 4 * v15) == v11)
        {
LABEL_20:
          v18 = 0;
          v19 = 3;
          goto LABEL_36;
        }
        v17 = ~v14;
        while (1)
        {
          v15 = (v15 + 1) & v17;
          if (((*(_QWORD *)&v12[((v15 >> 3) & 0xFFFFFFFFFFFFF8) + 56] >> v15) & 1) == 0)
            break;
          if (*(_DWORD *)(v16 + 4 * v15) == v11)
            goto LABEL_20;
        }
      }
    }
    if (qword_100404158 != -1)
      swift_once(&qword_100404158, sub_10019012C);
    v20 = off_100409F50;
    if (*((_QWORD *)off_100409F50 + 2))
    {
      v21 = static Hasher._hash(seed:bytes:count:)(*((_QWORD *)off_100409F50 + 5), v11, 4);
      v22 = -1 << v20[32];
      v23 = v21 & ~v22;
      if (((*(_QWORD *)&v20[((v23 >> 3) & 0xFFFFFFFFFFFFF8) + 56] >> v23) & 1) != 0)
      {
        v24 = *((_QWORD *)v20 + 6);
        if (*(_DWORD *)(v24 + 4 * v23) == v11)
        {
LABEL_29:
          v18 = 1;
          v19 = 4;
          goto LABEL_36;
        }
        v25 = ~v22;
        while (1)
        {
          v23 = (v23 + 1) & v25;
          if (((*(_QWORD *)&v20[((v23 >> 3) & 0xFFFFFFFFFFFFF8) + 56] >> v23) & 1) == 0)
            break;
          if (*(_DWORD *)(v24 + 4 * v23) == v11)
            goto LABEL_29;
        }
      }
    }
    if (qword_100404160 != -1)
      swift_once(&qword_100404160, sub_100190150);
    v26 = off_100409F58;
    if (*((_QWORD *)off_100409F58 + 2))
    {
      v27 = static Hasher._hash(seed:bytes:count:)(*((_QWORD *)off_100409F58 + 5), v11, 4);
      v28 = -1 << v26[32];
      v29 = v27 & ~v28;
      v30 = v26 + 56;
      if (((*(_QWORD *)&v26[((v29 >> 3) & 0xFFFFFFFFFFFFF8) + 56] >> v29) & 1) != 0)
      {
        v31 = *((_QWORD *)v26 + 6);
        if (*(_DWORD *)(v31 + 4 * v29) == v11)
          goto LABEL_35;
        v33 = ~v28;
        v34 = (v29 + 1) & v33;
        if (((*(_QWORD *)&v30[(v34 >> 3) & 0xFFFFFFFFFFFFF8] >> v34) & 1) != 0)
        {
          while (*(_DWORD *)(v31 + 4 * v34) != v11)
          {
            v34 = (v34 + 1) & v33;
            if (((*(_QWORD *)&v30[(v34 >> 3) & 0xFFFFFFFFFFFFF8] >> v34) & 1) == 0)
              goto LABEL_40;
          }
LABEL_35:
          v18 = 2;
          v19 = 5;
LABEL_36:
          v42 = v18;
          v43 = v19;
          sub_10018FA04();
          v32 = v11 | ((unint64_t)v42 << 32) | ((unint64_t)v43 << 40);
          goto LABEL_41;
        }
      }
    }
LABEL_40:
    v32 = 0x300000000;
LABEL_41:
    v36 = _swiftEmptyArrayStorage[2];
    v35 = _swiftEmptyArrayStorage[3];
    if (v36 >= v35 >> 1)
      sub_100075000(v35 > 1, v36 + 1, 1);
    _swiftEmptyArrayStorage[2] = v36 + 1;
    v37 = &_swiftEmptyArrayStorage[v36];
    *((_DWORD *)v37 + 8) = v32;
    *((_WORD *)v37 + 18) = WORD2(v32);
    if (v41 < v5)
      goto LABEL_50;
    if (v6 == v39)
      goto LABEL_51;
    ++v6;
    v3 = v38;
    if (v6 == v40)
      return;
  }
  __break(1u);
LABEL_50:
  __break(1u);
LABEL_51:
  __break(1u);
LABEL_52:
  __break(1u);
}

void sub_1000CBF10(__int16 a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  _QWORD *v13;
  unsigned int v15;
  unsigned __int8 v16;
  uint64_t v17;
  unsigned int v18;
  unsigned __int16 v19;
  _QWORD *v20;

  v3 = v2;
  v4 = (HIBYTE(a1) - a1);
  v15 = HIBYTE(a1);
  v16 = a1;
  if (HIBYTE(a1) < a1)
    v5 = -(uint64_t)(a1 - HIBYTE(a1));
  else
    v5 = (HIBYTE(a1) - a1);
  if (v5)
  {
    v20 = _swiftEmptyArrayStorage;
    sub_100075000(0, v5 & ~(v5 >> 63), 0);
    if ((v5 & 0x8000000000000000) == 0)
    {
      v6 = v20;
      LODWORD(v7) = v15 - v16;
      if (v15 >= v16)
        v7 = v7;
      else
        v7 = 0;
      v8 = -v7;
      while (v5)
      {
        sub_1000DD66C(a2, &v17, (uint64_t)&v18);
        if (v3)
        {
          swift_release(v6);
          return;
        }
        v3 = 0;
        v9 = v19;
        v10 = v18;
        v20 = v6;
        v12 = v6[2];
        v11 = v6[3];
        if (v12 >= v11 >> 1)
        {
          sub_100075000(v11 > 1, v12 + 1, 1);
          v6 = v20;
        }
        v6[2] = v12 + 1;
        v13 = &v6[v12];
        *((_DWORD *)v13 + 8) = v10;
        *((_WORD *)v13 + 18) = (v10 | (unint64_t)(v9 << 32)) >> 32;
        if (v15 < v16)
          goto LABEL_21;
        if (!v8)
          goto LABEL_22;
        ++v8;
        --v5;
        if (!--v4)
          return;
      }
      __break(1u);
LABEL_21:
      __break(1u);
LABEL_22:
      __break(1u);
    }
    __break(1u);
  }
}

_QWORD *sub_1000CC078(__int16 a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *result;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  unsigned int v21;
  unsigned __int8 v22;
  uint64_t v23;

  v3 = (HIBYTE(a1) - a1);
  v21 = HIBYTE(a1);
  v22 = a1;
  if (HIBYTE(a1) < a1)
    v4 = -(uint64_t)(a1 - HIBYTE(a1));
  else
    v4 = (HIBYTE(a1) - a1);
  result = _swiftEmptyArrayStorage;
  if (v4)
  {
    result = (_QWORD *)sub_100075000(0, v4 & ~(v4 >> 63), 0);
    if ((v4 & 0x8000000000000000) == 0)
    {
      result = _swiftEmptyArrayStorage;
      LODWORD(v7) = v21 - v22;
      if (v21 >= v22)
        v7 = v7;
      else
        v7 = 0;
      v8 = -v7;
      while (v4)
      {
        v23 = v3;
        v9 = result;
        v10 = *(_QWORD *)(a2 + 24);
        v11 = *(_QWORD *)(a2 + 32);
        sub_100034C68(a2, v10);
        v12 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v10, v11);
        if (v2)
          return (_QWORD *)swift_release(v9);
        v13 = v12;
        v14 = *(_QWORD *)(a2 + 24);
        v15 = *(_QWORD *)(a2 + 32);
        sub_100034C68(a2, v14);
        v16 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v14, v15);
        v17 = sub_1000DD8A0(v13, v16);
        result = v9;
        v19 = v9[2];
        v18 = v9[3];
        if (v19 >= v18 >> 1)
        {
          sub_100075000(v18 > 1, v19 + 1, 1);
          result = v9;
        }
        result[2] = v19 + 1;
        v20 = &result[v19];
        *((_DWORD *)v20 + 8) = v17;
        *((_WORD *)v20 + 18) = WORD2(v17);
        if (v21 < v22)
          goto LABEL_21;
        if (!v8)
          goto LABEL_22;
        ++v8;
        --v4;
        v3 = v23 - 1;
        if (v23 == 1)
          return result;
      }
      __break(1u);
LABEL_21:
      __break(1u);
LABEL_22:
      __break(1u);
    }
    __break(1u);
  }
  return result;
}

uint64_t AWDLActionFrame.DataPathState.UnicastMasterIndicationOptions.rawValue.getter(char a1)
{
  return dword_1003458A8[a1];
}

BOOL AWDLActionFrame.OUIType.init(rawValue:)(char a1)
{
  return a1 != 8;
}

_BYTE *sub_1000CC24C@<X0>(_BYTE *result@<X0>, BOOL *a2@<X8>)
{
  *a2 = *result != 8;
  return result;
}

void sub_1000CC260(_BYTE *a1@<X8>)
{
  *a1 = 8;
}

uint64_t sub_1000CC26C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000F0568();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000CC2C8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000F0568();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

Swift::Int sub_1000CC314()
{
  _QWORD v1[9];

  Hasher.init(_seed:)(v1);
  Hasher._combine(_:)(8u);
  return Hasher._finalize()();
}

void sub_1000CC354()
{
  Hasher._combine(_:)(8u);
}

Swift::Int sub_1000CC378()
{
  _QWORD v1[9];

  Hasher.init(_seed:)(v1);
  Hasher._combine(_:)(8u);
  return Hasher._finalize()();
}

CoreP2P::AWDLActionFrame::OUISubtype_optional __swiftcall AWDLActionFrame.OUISubtype.init(rawValue:)(Swift::UInt8 rawValue)
{
  CoreP2P::AWDLActionFrame::OUISubtype_optional v1;

  if (rawValue == 3)
    v1.value = CoreP2P_AWDLActionFrame_OUISubtype_masterIndication;
  else
    v1.value = CoreP2P_AWDLActionFrame_OUISubtype_unknownDefault;
  if (rawValue)
    return v1;
  else
    return 0;
}

uint64_t AWDLActionFrame.OUISubtype.rawValue.getter(int a1)
{
  return (a1 << 31 >> 31) & 3;
}

_BYTE *sub_1000CC3DC@<X0>(_BYTE *result@<X0>, char *a2@<X8>)
{
  char v2;
  char v3;

  if (*result == 3)
    v2 = 1;
  else
    v2 = 2;
  if (*result)
    v3 = v2;
  else
    v3 = 0;
  *a2 = v3;
  return result;
}

void sub_1000CC3FC(char *a1@<X8>)
{
  _BYTE *v1;
  char v2;

  if (*v1)
    v2 = 3;
  else
    v2 = 0;
  *a1 = v2;
}

uint64_t sub_1000CC414(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000F0524();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000CC470(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000F0524();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

Swift::Int sub_1000CC4BC()
{
  unsigned __int8 *v0;
  int v1;
  Swift::UInt8 v2;
  _QWORD v4[9];

  v1 = *v0;
  Hasher.init(_seed:)(v4);
  if (v1)
    v2 = 3;
  else
    v2 = 0;
  Hasher._combine(_:)(v2);
  return Hasher._finalize()();
}

void sub_1000CC508()
{
  _BYTE *v0;
  Swift::UInt8 v1;

  if (*v0)
    v1 = 3;
  else
    v1 = 0;
  Hasher._combine(_:)(v1);
}

Swift::Int sub_1000CC53C()
{
  unsigned __int8 *v0;
  int v1;
  Swift::UInt8 v2;
  _QWORD v4[9];

  v1 = *v0;
  Hasher.init(_seed:)(v4);
  if (v1)
    v2 = 3;
  else
    v2 = 0;
  Hasher._combine(_:)(v2);
  return Hasher._finalize()();
}

uint64_t NANInternetSharingStatistics.Provider.onEthernet.getter(unsigned int a1)
{
  return (a1 >> 8) & 1;
}

uint64_t AWDLActionFrame.AirDrop.state.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 1) = result & 1;
  return result;
}

uint64_t AWDLActionFrame.ProMode.status.setter(uint64_t result)
{
  uint64_t v1;

  *(_DWORD *)(v1 + 4) = result;
  return result;
}

uint64_t NANDiscoveryBeaconTransmissionSchedule.entries.getter(uint64_t a1, uint64_t a2)
{
  return swift_bridgeObjectRetain(a2);
}

void AWDLActionFrame.ServiceRequest.hash(into:)(int a1, unsigned int a2, uint64_t a3)
{
  unsigned int v4;
  Swift::UInt v5;
  Swift::UInt8 *v6;
  Swift::UInt8 v7;

  v4 = HIWORD(a2);
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v4);
  v5 = *(_QWORD *)(a3 + 16);
  Hasher._combine(_:)(v5);
  if (v5)
  {
    v6 = (Swift::UInt8 *)(a3 + 32);
    do
    {
      v7 = *v6++;
      Hasher._combine(_:)(v7);
      --v5;
    }
    while (v5);
  }
}

uint64_t static AWDLActionFrame.ServiceRequest.__derived_struct_equals(_:_:)(int a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a1 == a3)
    return sub_1000851D0(a2, a4);
  else
    return 0;
}

uint64_t sub_1000CC624()
{
  _BYTE *v0;
  uint64_t v1;

  v1 = 7955819;
  if (*v0 == 1)
    v1 = 0x6574736575716572;
  if (*v0)
    return v1;
  else
    return 0x6574736575716572;
}

uint64_t sub_1000CC680@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;

  result = sub_1000EE6CC(a1, a2);
  *a3 = result;
  return result;
}

uint64_t sub_1000CC6A4(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000CC874();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000CC6CC(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000CC874();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t AWDLActionFrame.ServiceRequest.encode(to:)(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;
  char v19;
  char v20;
  char v21;

  v7 = sub_100012C44(&qword_1004071C0);
  v8 = *(_QWORD *)(v7 - 8);
  __chkstk_darwin();
  v10 = (char *)&v17 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  v11 = a1[3];
  v12 = a1[4];
  sub_10003259C(a1, v11);
  v13 = sub_1000CC874();
  dispatch thunk of Encoder.container<A>(keyedBy:)(&type metadata for AWDLActionFrame.ServiceRequest.CodingKeys, &type metadata for AWDLActionFrame.ServiceRequest.CodingKeys, v13, v11, v12);
  v21 = 0;
  KeyedEncodingContainer.encode(_:forKey:)(a2, &v21, v7);
  if (!v3)
  {
    v20 = 1;
    KeyedEncodingContainer.encode(_:forKey:)(WORD1(a2), &v20, v7);
    v18 = a3;
    v19 = 2;
    v14 = sub_100012C44(&qword_100406738);
    v15 = sub_1000F08DC((unint64_t *)&qword_1004071D0, (uint64_t)&protocol witness table for UInt8, (const char *)&protocol conformance descriptor for <A> [A]);
    KeyedEncodingContainer.encode<A>(_:forKey:)(&v18, &v19, v7, v14, v15);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v8 + 8))(v10, v7);
}

unint64_t sub_1000CC874()
{
  unint64_t result;

  result = qword_1004071C8;
  if (!qword_1004071C8)
  {
    result = swift_getWitnessTable(byte_10034531C, &type metadata for AWDLActionFrame.ServiceRequest.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004071C8);
  }
  return result;
}

Swift::Int AWDLActionFrame.ServiceRequest.hashValue.getter(unsigned int a1, uint64_t a2)
{
  Swift::UInt16 v3;
  unsigned int v4;
  Swift::UInt v5;
  Swift::UInt8 *v6;
  Swift::UInt8 v7;
  _QWORD v9[9];

  v3 = a1;
  v4 = HIWORD(a1);
  Hasher.init(_seed:)(v9);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  v5 = *(_QWORD *)(a2 + 16);
  Hasher._combine(_:)(v5);
  if (v5)
  {
    v6 = (Swift::UInt8 *)(a2 + 32);
    do
    {
      v7 = *v6++;
      Hasher._combine(_:)(v7);
      --v5;
    }
    while (v5);
  }
  return Hasher._finalize()();
}

uint64_t AWDLActionFrame.ServiceRequest.init(from:)(_QWORD *a1)
{
  return sub_1000E4498(a1);
}

uint64_t sub_1000CC958@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v5;

  result = sub_1000E4498(a1);
  if (!v2)
  {
    *(_DWORD *)a2 = result;
    *(_QWORD *)(a2 + 8) = v5;
  }
  return result;
}

uint64_t sub_1000CC98C(_QWORD *a1)
{
  unsigned int *v1;

  return AWDLActionFrame.ServiceRequest.encode(to:)(a1, *v1, *((_QWORD *)v1 + 1));
}

Swift::Int sub_1000CC9A8()
{
  uint64_t v0;

  return AWDLActionFrame.ServiceRequest.hashValue.getter(*(_DWORD *)v0, *(_QWORD *)(v0 + 8));
}

void sub_1000CC9B4(int a1)
{
  uint64_t v1;

  AWDLActionFrame.ServiceRequest.hash(into:)(a1, *(_DWORD *)v1, *(_QWORD *)(v1 + 8));
}

Swift::Int sub_1000CC9C0()
{
  uint64_t v0;
  uint64_t v1;
  Swift::UInt16 v2;
  Swift::UInt16 v3;
  Swift::UInt v4;
  Swift::UInt8 *v5;
  Swift::UInt8 v6;
  _QWORD v8[9];

  v1 = *(_QWORD *)(v0 + 8);
  v2 = *(_WORD *)v0;
  v3 = *(_WORD *)(v0 + 2);
  Hasher.init(_seed:)(v8);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  v4 = *(_QWORD *)(v1 + 16);
  Hasher._combine(_:)(v4);
  if (v4)
  {
    v5 = (Swift::UInt8 *)(v1 + 32);
    do
    {
      v6 = *v5++;
      Hasher._combine(_:)(v6);
      --v4;
    }
    while (v4);
  }
  return Hasher._finalize()();
}

uint64_t sub_1000CCA48(unsigned __int16 *a1, unsigned __int16 *a2)
{
  if (*a1 == *a2 && a1[1] == a2[1])
    return sub_1000851D0(*((_QWORD *)a1 + 1), *((_QWORD *)a2 + 1));
  else
    return 0;
}

uint64_t AWDLActionFrame.ServiceResponse.hash(into:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  int *v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t (*v10)(_QWORD);
  int EnumCaseMultiPayload;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  unint64_t v16;
  Swift::UInt8 v17;
  Swift::String v18;
  Swift::String v19;
  uint64_t v20;
  __n128 v21;
  uint64_t v23;
  uint64_t v24;
  int v25;
  Swift::UInt8 v26;
  Swift::String v27;
  Swift::String v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  Swift::UInt8 v33;
  Swift::String v34;
  Swift::String v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;

  v2 = v1;
  v4 = (int *)type metadata accessor for DNSRecords.SRV(0);
  __chkstk_darwin();
  v6 = (char *)&v42 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = type metadata accessor for AWDLActionFrame.ServiceResponse(0);
  __chkstk_darwin();
  v9 = (char *)&v42 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_1000637E0(v2, (uint64_t)v9, v10);
  EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(v9, v7);
  if (EnumCaseMultiPayload)
  {
    if (EnumCaseMultiPayload == 1)
    {
      v12 = *((_QWORD *)v9 + 1);
      v13 = *((_QWORD *)v9 + 3);
      v14 = v9[32];
      v15 = *((_QWORD *)v9 + 5);
      v16 = *((_QWORD *)v9 + 6);
      v17 = v9[33];
      Hasher._combine(_:)(1uLL);
      v18 = String.lowercased()();
      swift_bridgeObjectRetain(v12);
      swift_bridgeObjectRetain(v13);
      String.hash(into:)(a1, v18._countAndFlagsBits, v18._object);
      swift_bridgeObjectRelease(v18._object);
      v19 = String.lowercased()();
      swift_bridgeObjectRetain(v13);
      String.hash(into:)(a1, v19._countAndFlagsBits, v19._object);
      swift_bridgeObjectRelease(v19._object);
      if (v14)
        v20 = 7365749;
      else
        v20 = 7365492;
      String.hash(into:)(a1, v20, 0xE300000000000000);
      swift_bridgeObjectRelease(0xE300000000000000);
      Hasher._combine(_:)(v17);
      swift_bridgeObjectRelease(v12);
      swift_bridgeObjectRelease_n(v13, 2);
      sub_100031FEC(v15, v16);
      Data.hash(into:)(a1, v15, v16, v21);
      sub_10000E614(v15, v16);
      swift_bridgeObjectRelease(v13);
      swift_bridgeObjectRelease(v12);
      return sub_10000E614(v15, v16);
    }
    else
    {
      sub_100033AC0((uint64_t)v9, (uint64_t)v6, type metadata accessor for DNSRecords.SRV);
      Hasher._combine(_:)(2uLL);
      v30 = *((_QWORD *)v6 + 1);
      v31 = *((_QWORD *)v6 + 3);
      v32 = v6[32];
      v33 = v6[33];
      v34 = String.lowercased()();
      swift_bridgeObjectRetain(v30);
      swift_bridgeObjectRetain(v31);
      String.hash(into:)(a1, v34._countAndFlagsBits, v34._object);
      swift_bridgeObjectRelease(v34._object);
      v35 = String.lowercased()();
      swift_bridgeObjectRetain(v31);
      String.hash(into:)(a1, v35._countAndFlagsBits, v35._object);
      swift_bridgeObjectRelease(v35._object);
      if (v32)
        v36 = 7365749;
      else
        v36 = 7365492;
      String.hash(into:)(a1, v36, 0xE300000000000000);
      swift_bridgeObjectRelease(0xE300000000000000);
      Hasher._combine(_:)(v33);
      swift_bridgeObjectRelease(v30);
      swift_bridgeObjectRelease_n(v31, 2);
      v37 = type metadata accessor for NWEndpoint.Port(0);
      v38 = sub_100011DE4(&qword_100406108, (uint64_t (*)(uint64_t))&type metadata accessor for NWEndpoint.Port, (uint64_t)&protocol conformance descriptor for NWEndpoint.Port);
      dispatch thunk of Hashable.hash(into:)(a1, v37, v38);
      v39 = &v6[v4[6]];
      v40 = *(_QWORD *)v39;
      v41 = *((_QWORD *)v39 + 1);
      swift_bridgeObjectRetain(v41);
      String.hash(into:)(a1, v40, v41);
      swift_bridgeObjectRelease(v41);
      Hasher._combine(_:)(*(_WORD *)&v6[v4[7]]);
      Hasher._combine(_:)(*(_WORD *)&v6[v4[8]]);
      return sub_100063824((uint64_t)v6, type metadata accessor for DNSRecords.SRV);
    }
  }
  else
  {
    v23 = *((_QWORD *)v9 + 1);
    v24 = *((_QWORD *)v9 + 3);
    v25 = v9[32];
    v26 = v9[33];
    Hasher._combine(_:)(0);
    v27 = String.lowercased()();
    String.hash(into:)(a1, v27._countAndFlagsBits, v27._object);
    swift_bridgeObjectRelease(v27._object);
    v28 = String.lowercased()();
    swift_bridgeObjectRetain(v24);
    String.hash(into:)(a1, v28._countAndFlagsBits, v28._object);
    swift_bridgeObjectRelease(v28._object);
    if (v25)
      v29 = 7365749;
    else
      v29 = 7365492;
    String.hash(into:)(a1, v29, 0xE300000000000000);
    swift_bridgeObjectRelease(0xE300000000000000);
    Hasher._combine(_:)(v26);
    swift_bridgeObjectRelease(v23);
    return swift_bridgeObjectRelease_n(v24, 2);
  }
}

Swift::Int AWDLActionFrame.ServiceResponse.hashValue.getter()
{
  return sub_1000DE8A0((void (*)(_QWORD *))AWDLActionFrame.ServiceResponse.hash(into:));
}

uint64_t sub_1000CCECC@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X8>)
{
  return AWDLActionFrame.ServiceResponse.init(from:)(a1, a2);
}

void sub_1000CCEE0(_QWORD *a1)
{
  AWDLActionFrame.ServiceResponse.encode(to:)(a1);
}

Swift::Int sub_1000CCEF4(uint64_t a1, uint64_t a2)
{
  return sub_1000DE8EC(a1, a2, (void (*)(_QWORD *))AWDLActionFrame.ServiceResponse.hash(into:));
}

Swift::Int sub_1000CCF04(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000D72EC(a1, a2, a3, (void (*)(_QWORD *))AWDLActionFrame.ServiceResponse.hash(into:));
}

void AWDLActionFrame.AWDLChannelSequenceParameter.hash(into:)(uint64_t a1, uint64_t a2)
{
  Swift::UInt v3;
  unsigned int *v4;
  Swift::UInt8 v5;
  unint64_t v6;

  v3 = *(_QWORD *)(a2 + 16);
  Hasher._combine(_:)(v3);
  if (v3)
  {
    v4 = (unsigned int *)(a2 + 32);
    do
    {
      v6 = *v4 | ((unint64_t)*((unsigned __int16 *)v4 + 2) << 32);
      if ((v6 & 0xFF00000000) == 0x300000000)
      {
        v5 = 0;
LABEL_4:
        Hasher._combine(_:)(v5);
      }
      else
      {
        Hasher._combine(_:)(1u);
        Hasher._combine(_:)(v6);
        Hasher._combine(_:)(0x801004u >> ((v6 >> 29) & 0xF8));
        switch(v6 >> 40)
        {
          case 2uLL:
            Hasher._combine(_:)(0);
            break;
          case 3uLL:
            Hasher._combine(_:)(1uLL);
            break;
          case 4uLL:
            Hasher._combine(_:)(3uLL);
            break;
          case 5uLL:
            Hasher._combine(_:)(4uLL);
            break;
          case 6uLL:
            Hasher._combine(_:)(5uLL);
            break;
          default:
            Hasher._combine(_:)(2uLL);
            v5 = BYTE5(v6) & 1;
            goto LABEL_4;
        }
      }
      v4 += 2;
      --v3;
    }
    while (v3);
  }
}

Swift::Int ChannelSequence.hashValue.getter(uint64_t a1)
{
  _QWORD v3[9];

  Hasher.init(_seed:)(v3);
  sub_10008E548((uint64_t)v3, a1);
  return Hasher._finalize()();
}

uint64_t sub_1000CD074@<X0>(_QWORD *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v2;
  uint64_t result;

  result = AWDLActionFrame.AWDLChannelSequenceParameter.init(from:)(a1);
  if (!v2)
    *a2 = result;
  return result;
}

uint64_t AWDLActionFrame.AWDLChannelSequenceParameter.init(from:)(_QWORD *a1)
{
  return sub_1000E6920(a1);
}

uint64_t sub_1000CD0B0(_QWORD *a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  uint64_t v13;

  v3 = *v1;
  v4 = a1[3];
  v5 = a1[4];
  sub_10003259C(a1, v4);
  dispatch thunk of Encoder.unkeyedContainer()(v11, v4, v5);
  sub_1000DCEE4((uint64_t)v11, 3u, v3);
  if (!v2)
  {
    v6 = v12;
    v7 = v13;
    sub_100034C68((uint64_t)v11, v12);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(0, v6, v7);
    v8 = v12;
    v9 = v13;
    sub_100034C68((uint64_t)v11, v12);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(0, v8, v9);
  }
  return sub_100014430(v11);
}

uint64_t AWDLActionFrame.AWDLChannelSequenceParameter.encode(to:)(_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  uint64_t v13;

  v4 = a1[3];
  v5 = a1[4];
  sub_10003259C(a1, v4);
  dispatch thunk of Encoder.unkeyedContainer()(v11, v4, v5);
  sub_1000DCEE4((uint64_t)v11, 3u, a2);
  if (!v2)
  {
    v6 = v12;
    v7 = v13;
    sub_100034C68((uint64_t)v11, v12);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(0, v6, v7);
    v8 = v12;
    v9 = v13;
    sub_100034C68((uint64_t)v11, v12);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(0, v8, v9);
  }
  return sub_100014430(v11);
}

Swift::Int sub_1000CD268()
{
  uint64_t *v0;
  uint64_t v1;
  _QWORD v3[9];

  v1 = *v0;
  Hasher.init(_seed:)(v3);
  sub_10008E548((uint64_t)v3, v1);
  return Hasher._finalize()();
}

void sub_1000CD2AC(uint64_t a1)
{
  uint64_t *v1;

  AWDLActionFrame.AWDLChannelSequenceParameter.hash(into:)(a1, *v1);
}

Swift::Int sub_1000CD2B4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000D3ED4(a1, a2, a3, (void (*)(_QWORD *, uint64_t))AWDLActionFrame.AWDLChannelSequenceParameter.hash(into:));
}

uint64_t sub_1000CD2C0(uint64_t *a1, uint64_t *a2)
{
  return _s7CoreP2P15AWDLActionFrameV28AWDLChannelSequenceParameterV23__derived_struct_equalsySbAE_AEtFZ_0(*a1, *a2);
}

uint64_t AWDLPeer.AdvertisedService.instanceID.getter()
{
  unsigned __int8 *v0;

  return *v0;
}

uint64_t AWDLActionFrame.SynchronizationParameter.downCounter.getter()
{
  uint64_t v0;

  return *(unsigned __int16 *)(v0 + 2);
}

uint64_t AWDLActionFrame.SynchronizationParameter.masterHomeChannel.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 4);
}

uint64_t AWDLActionFrame.SynchronizationParameter.guardTime.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 5);
}

uint64_t Channel.bandwidth.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 5) = result;
  return result;
}

uint64_t (*Channel.bandwidth.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.SynchronizationParameter.availabilityWindowPeriod.getter()
{
  uint64_t v0;

  return *(unsigned __int16 *)(v0 + 6);
}

uint64_t AWDLActionFrame.SynchronizationParameter.actionFramePeriod.getter()
{
  uint64_t v0;

  return *(unsigned __int16 *)(v0 + 8);
}

uint64_t AWDLActionFrame.SynchronizationParameter.flags.getter()
{
  uint64_t v0;

  return *(unsigned __int16 *)(v0 + 10);
}

uint64_t AWDLActionFrame.SynchronizationParameter.availabilityWindowExtensionLength.getter()
{
  uint64_t v0;

  return *(unsigned __int16 *)(v0 + 12);
}

uint64_t AWDLActionFrame.SynchronizationParameter.availabilityWindowLength.getter()
{
  uint64_t v0;

  return *(unsigned __int16 *)(v0 + 14);
}

uint64_t AWDLActionFrame.SynchronizationParameter.availabilityWindowLength.setter(uint64_t result)
{
  uint64_t v1;

  *(_WORD *)(v1 + 14) = result;
  return result;
}

uint64_t (*AWDLActionFrame.SynchronizationParameter.availabilityWindowLength.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.SynchronizationParameter.availabilityWindowRemain.getter()
{
  uint64_t v0;

  return *(unsigned __int16 *)(v0 + 16);
}

uint64_t AWDLActionFrame.SynchronizationParameter.availabilityWindowRemain.setter(uint64_t result)
{
  uint64_t v1;

  *(_WORD *)(v1 + 16) = result;
  return result;
}

uint64_t AWDLActionFrame.SynchronizationParameter.minimumExtensions.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 18);
}

uint64_t AWDLActionFrame.SynchronizationParameter.minimumExtensions.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 18) = result;
  return result;
}

uint64_t (*AWDLActionFrame.SynchronizationParameter.minimumExtensions.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t NANCoreAnalyticsMetrics.singleBandPeers.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 19);
}

uint64_t NANCoreAnalyticsMetrics.singleBandPeers.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 19) = result;
  return result;
}

uint64_t (*NANCoreAnalyticsMetrics.singleBandPeers.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.SynchronizationParameter.maximumUnicastExtensions.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 20);
}

uint64_t AWDLActionFrame.SynchronizationParameter.maximumUnicastExtensions.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 20) = result;
  return result;
}

uint64_t (*AWDLActionFrame.Header.flags.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.SynchronizationParameter.maximumActionFrameExtensions.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 21);
}

uint64_t AWDLActionFrame.SynchronizationParameter.maximumActionFrameExtensions.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 21) = result;
  return result;
}

uint64_t (*AWDLActionFrame.SynchronizationParameter.maximumActionFrameExtensions.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

unint64_t AWDLActionFrame.SynchronizationParameter.master.getter()
{
  uint64_t v0;

  return *(unsigned __int16 *)(v0 + 22) | ((unint64_t)*(unsigned int *)(v0 + 24) << 16);
}

uint64_t AWDLActionFrame.SynchronizationParameter.master.setter(uint64_t result)
{
  uint64_t v1;

  *(_WORD *)(v1 + 22) = result;
  *(_BYTE *)(v1 + 24) = BYTE2(result);
  *(_BYTE *)(v1 + 25) = BYTE3(result);
  *(_BYTE *)(v1 + 26) = BYTE4(result);
  *(_BYTE *)(v1 + 27) = BYTE5(result);
  return result;
}

uint64_t (*AWDLActionFrame.SynchronizationParameter.master.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.SynchronizationParameter.presenceMode.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 28);
}

uint64_t AWDLActionFrame.SynchronizationParameter.presenceMode.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 28) = result;
  return result;
}

uint64_t (*AWDLActionFrame.SynchronizationParameter.presenceMode.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.SynchronizationParameter.reserved.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 29);
}

uint64_t AWDLActionFrame.SynchronizationParameter.reserved.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 29) = result;
  return result;
}

uint64_t (*AWDLActionFrame.SynchronizationParameter.reserved.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.SynchronizationParameter.sequence.getter()
{
  uint64_t v0;

  return *(unsigned __int16 *)(v0 + 30);
}

uint64_t AWDLActionFrame.SynchronizationParameter.sequence.setter(uint64_t result)
{
  uint64_t v1;

  *(_WORD *)(v1 + 30) = result;
  return result;
}

uint64_t (*AWDLActionFrame.SynchronizationParameter.sequence.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.SynchronizationParameter.accessPointBeaconDeltaAlignment.getter()
{
  uint64_t v0;

  return *(unsigned __int16 *)(v0 + 32);
}

uint64_t AWDLActionFrame.SynchronizationParameter.accessPointBeaconDeltaAlignment.setter(uint64_t result)
{
  uint64_t v1;

  *(_WORD *)(v1 + 32) = result;
  return result;
}

uint64_t AWDLActionFrame.SynchronizationParameter.channelSequence.getter()
{
  uint64_t v0;
  uint64_t v1;

  v1 = *(_QWORD *)(v0 + 40);
  sub_1000E6AFC(v0);
  return v1;
}

void AWDLActionFrame.SynchronizationParameter.hash(into:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  Swift::UInt8 v4;
  Swift::UInt8 v5;
  Swift::UInt8 v6;
  Swift::UInt8 v7;
  Swift::UInt8 v8;

  v2 = v1;
  Hasher._combine(_:)(*(_BYTE *)v2);
  Hasher._combine(_:)(*(_WORD *)(v2 + 2));
  Hasher._combine(_:)(*(_BYTE *)(v2 + 4));
  Hasher._combine(_:)(*(_BYTE *)(v2 + 5));
  Hasher._combine(_:)(*(_WORD *)(v2 + 6));
  Hasher._combine(_:)(*(_WORD *)(v2 + 8));
  Hasher._combine(_:)(*(_WORD *)(v2 + 10));
  Hasher._combine(_:)(*(_WORD *)(v2 + 12));
  Hasher._combine(_:)(*(_WORD *)(v2 + 14));
  Hasher._combine(_:)(*(_WORD *)(v2 + 16));
  Hasher._combine(_:)(*(_BYTE *)(v2 + 18));
  Hasher._combine(_:)(*(_BYTE *)(v2 + 19));
  Hasher._combine(_:)(*(_BYTE *)(v2 + 20));
  Hasher._combine(_:)(*(_BYTE *)(v2 + 21));
  v4 = *(_BYTE *)(v2 + 23);
  v5 = *(_BYTE *)(v2 + 24);
  v6 = *(_BYTE *)(v2 + 25);
  v7 = *(_BYTE *)(v2 + 26);
  v8 = *(_BYTE *)(v2 + 27);
  Hasher._combine(_:)(*(_BYTE *)(v2 + 22));
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(*(_BYTE *)(v2 + 28));
  Hasher._combine(_:)(*(_BYTE *)(v2 + 29));
  Hasher._combine(_:)(*(_WORD *)(v2 + 30));
  Hasher._combine(_:)(*(_WORD *)(v2 + 32));
  sub_10008E548(a1, *(_QWORD *)(v2 + 40));
}

uint64_t sub_1000CD5D4(unsigned __int8 a1)
{
  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_1000CD614 + 4 * byte_100341295[a1]))(0x74696D736E617274, 0xEF6C656E6E616843);
}

uint64_t sub_1000CD614()
{
  return 0x6E756F436E776F64;
}

unint64_t sub_1000CD634()
{
  return 0xD000000000000011;
}

uint64_t sub_1000CD7BC()
{
  unsigned __int8 *v0;

  return sub_1000CD5D4(*v0);
}

uint64_t sub_1000CD7C4@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;

  result = sub_1000EE850(a1, a2);
  *a3 = result;
  return result;
}

void sub_1000CD7E8(_BYTE *a1@<X8>)
{
  *a1 = 20;
}

uint64_t sub_1000CD7F4(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000F0AB4();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000CD81C(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000F0AB4();
  return CodingKey.debugDescription.getter(a1, v2);
}

Swift::Int AWDLActionFrame.SynchronizationParameter.hashValue.getter()
{
  uint64_t v0;
  Swift::UInt8 v1;
  Swift::UInt8 v2;
  Swift::UInt8 v3;
  Swift::UInt8 v4;
  Swift::UInt8 v5;
  _QWORD v7[9];

  Hasher.init(_seed:)(v7);
  Hasher._combine(_:)(*(_BYTE *)v0);
  Hasher._combine(_:)(*(_WORD *)(v0 + 2));
  Hasher._combine(_:)(*(_BYTE *)(v0 + 4));
  Hasher._combine(_:)(*(_BYTE *)(v0 + 5));
  Hasher._combine(_:)(*(_WORD *)(v0 + 6));
  Hasher._combine(_:)(*(_WORD *)(v0 + 8));
  Hasher._combine(_:)(*(_WORD *)(v0 + 10));
  Hasher._combine(_:)(*(_WORD *)(v0 + 12));
  Hasher._combine(_:)(*(_WORD *)(v0 + 14));
  Hasher._combine(_:)(*(_WORD *)(v0 + 16));
  Hasher._combine(_:)(*(_BYTE *)(v0 + 18));
  Hasher._combine(_:)(*(_BYTE *)(v0 + 19));
  Hasher._combine(_:)(*(_BYTE *)(v0 + 20));
  Hasher._combine(_:)(*(_BYTE *)(v0 + 21));
  v1 = *(_BYTE *)(v0 + 23);
  v2 = *(_BYTE *)(v0 + 24);
  v3 = *(_BYTE *)(v0 + 25);
  v4 = *(_BYTE *)(v0 + 26);
  v5 = *(_BYTE *)(v0 + 27);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 22));
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 28));
  Hasher._combine(_:)(*(_BYTE *)(v0 + 29));
  Hasher._combine(_:)(*(_WORD *)(v0 + 30));
  Hasher._combine(_:)(*(_WORD *)(v0 + 32));
  sub_10008E548((uint64_t)v7, *(_QWORD *)(v0 + 40));
  return Hasher._finalize()();
}

double AWDLActionFrame.SynchronizationParameter.init(from:)@<D0>(_QWORD *a1@<X0>, _OWORD *a2@<X8>)
{
  uint64_t v2;
  double result;
  __int128 v5;
  _OWORD v6[2];
  __int128 v7;

  sub_1000E4660(a1, (uint64_t)v6);
  if (!v2)
  {
    v5 = v6[1];
    *a2 = v6[0];
    a2[1] = v5;
    result = *(double *)&v7;
    a2[2] = v7;
  }
  return result;
}

uint64_t sub_1000CDA14(_QWORD *a1)
{
  return AWDLActionFrame.SynchronizationParameter.encode(to:)(a1);
}

uint64_t AWDLActionFrame.SynchronizationParameter.encode(to:)(_QWORD *a1)
{
  unsigned __int8 *v1;
  uint64_t v2;
  unsigned __int8 *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  _QWORD v66[3];
  uint64_t v67;
  uint64_t v68;
  int v69;
  __int16 v70;

  v3 = v1;
  v4 = a1[3];
  v5 = a1[4];
  sub_10003259C(a1, v4);
  dispatch thunk of Encoder.unkeyedContainer()(v66, v4, v5);
  v6 = v67;
  v7 = v68;
  v8 = *v1;
  sub_100034C68((uint64_t)v66, v67);
  dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v8, v6, v7);
  if (!v2)
  {
    v9 = v67;
    v10 = v68;
    v11 = *((unsigned __int16 *)v3 + 1);
    sub_100034C68((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v11, v9, v10);
    v12 = v67;
    v13 = v68;
    v14 = v3[4];
    sub_100034C68((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v14, v12, v13);
    v15 = v67;
    v16 = v68;
    v17 = v3[5];
    sub_100034C68((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v17, v15, v16);
    v18 = v67;
    v19 = v68;
    v20 = *((unsigned __int16 *)v3 + 3);
    sub_100034C68((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v20, v18, v19);
    v21 = v67;
    v22 = v68;
    v23 = *((unsigned __int16 *)v3 + 4);
    sub_100034C68((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v23, v21, v22);
    v24 = v67;
    v25 = v68;
    v26 = *((unsigned __int16 *)v3 + 5);
    sub_100034C68((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v26, v24, v25);
    v27 = v67;
    v28 = v68;
    v29 = *((unsigned __int16 *)v3 + 6);
    sub_100034C68((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v29, v27, v28);
    v30 = v67;
    v31 = v68;
    v32 = *((unsigned __int16 *)v3 + 7);
    sub_100034C68((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v32, v30, v31);
    v33 = v67;
    v34 = v68;
    v35 = *((unsigned __int16 *)v3 + 8);
    sub_100034C68((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v35, v33, v34);
    v36 = v67;
    v37 = v68;
    v38 = v3[18];
    sub_100034C68((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v38, v36, v37);
    v39 = v67;
    v40 = v68;
    v41 = v3[19];
    sub_100034C68((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v41, v39, v40);
    v42 = v67;
    v43 = v68;
    v44 = v3[20];
    sub_100034C68((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v44, v42, v43);
    v45 = v67;
    v46 = v68;
    v47 = v3[21];
    sub_100034C68((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v47, v45, v46);
    v69 = *(_DWORD *)(v3 + 22);
    v70 = *((_WORD *)v3 + 13);
    v48 = v67;
    v49 = v68;
    sub_100034C68((uint64_t)v66, v67);
    v50 = sub_100039C34();
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(&v69, &type metadata for WiFiAddress, v50, v48, v49);
    v51 = v67;
    v52 = v68;
    v53 = v3[28];
    sub_100034C68((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v53, v51, v52);
    v54 = v67;
    v55 = v68;
    v56 = v3[29];
    sub_100034C68((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v56, v54, v55);
    v57 = v67;
    v58 = v68;
    v59 = *((unsigned __int16 *)v3 + 15);
    sub_100034C68((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v59, v57, v58);
    v60 = v67;
    v61 = v68;
    v62 = *((unsigned __int16 *)v3 + 16);
    sub_100034C68((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v62, v60, v61);
    sub_1000DCEE4((uint64_t)v66, 1u, *((_QWORD *)v3 + 5));
    v63 = v67;
    v64 = v68;
    sub_100034C68((uint64_t)v66, v67);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(0, v63, v64);
  }
  return sub_100014430(v66);
}

Swift::Int sub_1000CDF1C()
{
  uint64_t v0;
  Swift::UInt8 v1;
  Swift::UInt16 v2;
  Swift::UInt8 v3;
  Swift::UInt8 v4;
  Swift::UInt16 v5;
  Swift::UInt16 v6;
  Swift::UInt16 v7;
  Swift::UInt16 v8;
  Swift::UInt16 v9;
  Swift::UInt16 v11;
  Swift::UInt8 v12;
  Swift::UInt8 v13;
  Swift::UInt8 v14;
  Swift::UInt8 v15;
  Swift::UInt8 v16;
  Swift::UInt8 v17;
  Swift::UInt8 v18;
  Swift::UInt8 v19;
  Swift::UInt8 v20;
  Swift::UInt8 v21;
  Swift::UInt8 v22;
  Swift::UInt8 v23;
  Swift::UInt16 v24;
  Swift::UInt16 v25;
  uint64_t v26;
  _QWORD v27[9];

  v26 = *(_QWORD *)(v0 + 40);
  v1 = *(_BYTE *)v0;
  v2 = *(_WORD *)(v0 + 2);
  v3 = *(_BYTE *)(v0 + 4);
  v4 = *(_BYTE *)(v0 + 5);
  v5 = *(_WORD *)(v0 + 6);
  v6 = *(_WORD *)(v0 + 8);
  v7 = *(_WORD *)(v0 + 10);
  v8 = *(_WORD *)(v0 + 12);
  v9 = *(_WORD *)(v0 + 14);
  v11 = *(_WORD *)(v0 + 16);
  v12 = *(_BYTE *)(v0 + 18);
  v13 = *(_BYTE *)(v0 + 19);
  v14 = *(_BYTE *)(v0 + 20);
  v15 = *(_BYTE *)(v0 + 21);
  v16 = *(_BYTE *)(v0 + 22);
  v17 = *(_BYTE *)(v0 + 23);
  v18 = *(_BYTE *)(v0 + 24);
  v19 = *(_BYTE *)(v0 + 25);
  v20 = *(_BYTE *)(v0 + 26);
  v21 = *(_BYTE *)(v0 + 27);
  v22 = *(_BYTE *)(v0 + 28);
  v23 = *(_BYTE *)(v0 + 29);
  v24 = *(_WORD *)(v0 + 30);
  v25 = *(_WORD *)(v0 + 32);
  Hasher.init(_seed:)(v27);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v11);
  Hasher._combine(_:)(v12);
  Hasher._combine(_:)(v13);
  Hasher._combine(_:)(v14);
  Hasher._combine(_:)(v15);
  Hasher._combine(_:)(v16);
  Hasher._combine(_:)(v17);
  Hasher._combine(_:)(v18);
  Hasher._combine(_:)(v19);
  Hasher._combine(_:)(v20);
  Hasher._combine(_:)(v21);
  Hasher._combine(_:)(v22);
  Hasher._combine(_:)(v23);
  Hasher._combine(_:)(v24);
  Hasher._combine(_:)(v25);
  sub_10008E548((uint64_t)v27, v26);
  return Hasher._finalize()();
}

uint64_t sub_1000CE120(_OWORD *a1, __int128 *a2)
{
  __int128 v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  _OWORD v7[3];
  _OWORD v8[3];

  v2 = a1[1];
  v7[0] = *a1;
  v7[1] = v2;
  v3 = *a2;
  v4 = a2[1];
  v7[2] = a1[2];
  v8[0] = v3;
  v5 = a2[2];
  v8[1] = v4;
  v8[2] = v5;
  return _s7CoreP2P15AWDLActionFrameV24SynchronizationParameterV23__derived_struct_equalsySbAE_AEtFZ_0((unsigned __int8 *)v7, (unsigned __int8 *)v8) & 1;
}

unint64_t Channel.bandwidth.getter(unint64_t a1)
{
  return a1 >> 40;
}

unint64_t AWDLActionFrame.DeprecatedElectionParameter.address.getter(unint64_t a1, unsigned int a2)
{
  return HIWORD(a1) & 0xFFFF00000000FFFFLL | ((unint64_t)a2 << 16);
}

uint64_t AWDLActionFrame.Header.bssid.setter(uint64_t result)
{
  uint64_t v1;

  *(_WORD *)(v1 + 6) = result;
  *(_BYTE *)(v1 + 8) = BYTE2(result);
  *(_BYTE *)(v1 + 9) = BYTE3(result);
  *(_BYTE *)(v1 + 10) = BYTE4(result);
  *(_BYTE *)(v1 + 11) = BYTE5(result);
  return result;
}

uint64_t AWDLActionFrame.DeprecatedElectionParameter.topMasterMetric.getter(uint64_t a1, uint64_t a2, char a3)
{
  __int128 v4;

  *((_QWORD *)&v4 + 1) = a3 & 1;
  *(_QWORD *)&v4 = a2;
  return v4 >> 32;
}

uint64_t AWDLActionFrame.DeprecatedElectionParameter.topMasterMetric.setter(uint64_t result)
{
  uint64_t v1;

  *(_DWORD *)(v1 + 12) = result;
  *(_BYTE *)(v1 + 16) = BYTE4(result) & 1;
  return result;
}

uint64_t AWDLActionFrame.DeprecatedElectionParameter.selfElectionMetric.getter(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  __int128 v5;

  *((_QWORD *)&v5 + 1) = a4 & 1;
  *(_QWORD *)&v5 = a3;
  return v5 >> 32;
}

uint64_t AWDLActionFrame.DeprecatedElectionParameter.selfElectionMetric.setter(uint64_t result)
{
  uint64_t v1;

  *(_DWORD *)(v1 + 20) = result;
  *(_BYTE *)(v1 + 24) = BYTE4(result) & 1;
  return result;
}

void AWDLActionFrame.DeprecatedElectionParameter.hash(into:)(int a1, unint64_t a2, unint64_t a3, uint64_t a4, char a5)
{
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  Swift::UInt32 v15;
  Swift::UInt8 v16[8];
  unint64_t v18;

  v18 = HIDWORD(a4);
  v7 = a2 >> 16;
  v8 = HIDWORD(a2);
  v9 = a2 >> 40;
  v10 = HIWORD(a2);
  v11 = HIBYTE(a2);
  v12 = a3 >> 8;
  v13 = a3 >> 16;
  *(_QWORD *)v16 = a3 >> 24;
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(v11);
  Hasher._combine(_:)(a3);
  Hasher._combine(_:)(v12);
  Hasher._combine(_:)(v13);
  Hasher._combine(_:)(v16[0]);
  if ((a4 & 1) != 0)
    LODWORD(v14) = dword_100345874[(uint64_t)a3 >> 32];
  else
    v14 = HIDWORD(a3);
  Hasher._combine(_:)(v14);
  v15 = v18;
  if ((a5 & 1) != 0)
    v15 = dword_100345874[a4 >> 32];
  Hasher._combine(_:)(v15);
}

uint64_t static AWDLActionFrame.DeprecatedElectionParameter.__derived_struct_equals(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5, uint64_t a6, uint64_t a7, char a8)
{
  return sub_1000E2118(a1 & 0xFFFFFFFFFFFF00FFLL, a2, a3 & 0xFFFFFFFF00000001, a4 & 1, a5 & 0xFFFFFFFFFFFF00FFLL, a6, a7 & 0xFFFFFFFF00000001, a8 & 1);
}

uint64_t sub_1000CE33C(unsigned __int8 a1)
{
  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_1000CE36C + 4 * byte_1003412A9[a1]))(0x7367616C66, 0xE500000000000000);
}

uint64_t sub_1000CE36C()
{
  return 0x6E6F697463656C65;
}

uint64_t sub_1000CE388()
{
  return 0x65636E6174736964;
}

uint64_t sub_1000CE3AC()
{
  return 0x6465767265736572;
}

uint64_t sub_1000CE3D0()
{
  return 0x73736572646461;
}

uint64_t sub_1000CE3E8()
{
  return 0x657473614D706F74;
}

unint64_t sub_1000CE40C()
{
  return 0xD000000000000012;
}

uint64_t sub_1000CE428()
{
  unsigned __int8 *v0;

  return sub_1000CE33C(*v0);
}

uint64_t sub_1000CE430@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;

  result = sub_1000EEFF4(a1, a2);
  *a3 = result;
  return result;
}

void sub_1000CE454(_BYTE *a1@<X8>)
{
  *a1 = 7;
}

uint64_t sub_1000CE460(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000F0A70();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000CE488(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000F0A70();
  return CodingKey.debugDescription.getter(a1, v2);
}

Swift::Int AWDLActionFrame.DeprecatedElectionParameter.hashValue.getter(uint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
  char v5;
  unint64_t v8;
  _QWORD v10[9];

  v5 = a3;
  v8 = a3 & 0xFFFFFFFF00000000;
  Hasher.init(_seed:)(v10);
  AWDLActionFrame.DeprecatedElectionParameter.hash(into:)((int)v10, a1 & 0xFFFFFFFFFFFF00FFLL, a2, v8 | v5 & 1, a4 & 1);
  return Hasher._finalize()();
}

unint64_t AWDLActionFrame.DeprecatedElectionParameter.init(from:)(_QWORD *a1)
{
  uint64_t v1;
  unint64_t result;

  result = sub_1000E4B74(a1);
  if (!v1)
    result &= 0xFFFFFFFFFFFF00FFLL;
  return result;
}

unint64_t sub_1000CE570@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  unint64_t result;
  uint64_t v5;
  char v6;
  int v7;
  char v8;

  result = sub_1000E4B74(a1);
  if (!v2)
  {
    *(_BYTE *)a2 = result;
    *(_WORD *)(a2 + 2) = WORD1(result);
    *(_BYTE *)(a2 + 4) = BYTE4(result);
    *(_BYTE *)(a2 + 5) = BYTE5(result);
    *(_BYTE *)(a2 + 6) = BYTE6(result);
    *(_BYTE *)(a2 + 7) = HIBYTE(result);
    *(_QWORD *)(a2 + 8) = v5;
    *(_BYTE *)(a2 + 16) = v6 & 1;
    *(_DWORD *)(a2 + 20) = v7;
    *(_BYTE *)(a2 + 24) = v8 & 1;
  }
  return result;
}

uint64_t sub_1000CE5FC(_QWORD *a1)
{
  unsigned __int8 *v1;

  return AWDLActionFrame.DeprecatedElectionParameter.encode(to:)(a1, *v1 | ((unint64_t)*((unsigned __int16 *)v1 + 1) << 16) | ((unint64_t)v1[4] << 32) | ((unint64_t)v1[5] << 40) | ((unint64_t)v1[6] << 48) | ((unint64_t)v1[7] << 56), *((_QWORD *)v1 + 1), v1[16] | ((unint64_t)*((unsigned int *)v1 + 5) << 32), v1[24]);
}

uint64_t AWDLActionFrame.DeprecatedElectionParameter.encode(to:)(_QWORD *a1, unint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t v5;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v31;
  char v32;
  char v33;
  _QWORD v34[3];
  uint64_t v35;
  uint64_t v36;

  v10 = a1[3];
  v11 = a1[4];
  sub_10003259C(a1, v10);
  dispatch thunk of Encoder.unkeyedContainer()(v34, v10, v11);
  v12 = v35;
  v13 = v36;
  sub_100034C68((uint64_t)v34, v35);
  dispatch thunk of UnkeyedEncodingContainer.encode(_:)(a2, v12, v13);
  if (!v5)
  {
    v14 = v35;
    v15 = v36;
    sub_100034C68((uint64_t)v34, v35);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(a2 >> 16, v14, v15);
    v16 = v35;
    v17 = v36;
    sub_100034C68((uint64_t)v34, v35);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(HIDWORD(a2), v16, v17);
    v18 = v35;
    v19 = v36;
    sub_100034C68((uint64_t)v34, v35);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(a2 >> 40, v18, v19);
    LOBYTE(v31) = BYTE6(a2);
    BYTE1(v31) = HIBYTE(a2);
    HIWORD(v31) = a3;
    v32 = BYTE2(a3);
    v33 = BYTE3(a3);
    v20 = v35;
    v21 = v36;
    sub_100034C68((uint64_t)v34, v35);
    v22 = sub_100039C34();
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(&v31, &type metadata for WiFiAddress, v22, v20, v21);
    v31 = HIDWORD(a3);
    v32 = a4 & 1;
    v23 = v35;
    v24 = v36;
    sub_100034C68((uint64_t)v34, v35);
    v25 = sub_1000E6B24();
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(&v31, &type metadata for AWDLElectionMetric, v25, v23, v24);
    v31 = HIDWORD(a4);
    v32 = a5 & 1;
    v26 = v35;
    v27 = v36;
    sub_100034C68((uint64_t)v34, v35);
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(&v31, &type metadata for AWDLElectionMetric, v25, v26, v27);
    v28 = v35;
    v29 = v36;
    sub_100034C68((uint64_t)v34, v35);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(0, v28, v29);
  }
  return sub_100014430(v34);
}

Swift::Int sub_1000CE8EC()
{
  unsigned __int8 *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned __int8 v6;
  char v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  _QWORD v12[9];

  v1 = *v0;
  v2 = *((unsigned __int16 *)v0 + 1);
  v3 = v0[4];
  v4 = v0[5];
  v5 = v0[6];
  v6 = v0[16];
  v7 = v0[24];
  v8 = v0[7];
  v9 = *((_QWORD *)v0 + 1);
  v10 = *((unsigned int *)v0 + 5);
  Hasher.init(_seed:)(v12);
  AWDLActionFrame.DeprecatedElectionParameter.hash(into:)((int)v12, v1 | (v2 << 16) | (v3 << 32) | (v4 << 40) | (v5 << 48) | (v8 << 56), v9, v6 | (unint64_t)(v10 << 32), v7);
  return Hasher._finalize()();
}

void sub_1000CE99C(int a1)
{
  unsigned __int8 *v1;

  AWDLActionFrame.DeprecatedElectionParameter.hash(into:)(a1, *v1 | ((unint64_t)*((unsigned __int16 *)v1 + 1) << 16) | ((unint64_t)v1[4] << 32) | ((unint64_t)v1[5] << 40) | ((unint64_t)v1[6] << 48) | ((unint64_t)v1[7] << 56), *((_QWORD *)v1 + 1), v1[16] | ((unint64_t)*((unsigned int *)v1 + 5) << 32), v1[24]);
}

Swift::Int sub_1000CE9F0()
{
  unsigned __int8 *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned __int8 v6;
  char v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  _QWORD v12[9];

  v1 = *v0;
  v2 = *((unsigned __int16 *)v0 + 1);
  v3 = v0[4];
  v4 = v0[5];
  v5 = v0[6];
  v6 = v0[16];
  v7 = v0[24];
  v8 = v0[7];
  v9 = *((_QWORD *)v0 + 1);
  v10 = *((unsigned int *)v0 + 5);
  Hasher.init(_seed:)(v12);
  AWDLActionFrame.DeprecatedElectionParameter.hash(into:)((int)v12, v1 | (v2 << 16) | (v3 << 32) | (v4 << 40) | (v5 << 48) | (v8 << 56), v9, v6 | (unint64_t)(v10 << 32), v7);
  return Hasher._finalize()();
}

uint64_t sub_1000CEA9C(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return sub_1000E2118(*a1 | ((unint64_t)*((unsigned __int16 *)a1 + 1) << 16) | ((unint64_t)a1[4] << 32) | ((unint64_t)a1[5] << 40) | ((unint64_t)a1[6] << 48) | ((unint64_t)a1[7] << 56), *((_QWORD *)a1 + 1), a1[16] | ((unint64_t)*((unsigned int *)a1 + 5) << 32), a1[24], *a2 | ((unint64_t)*((unsigned __int16 *)a2 + 1) << 16) | ((unint64_t)a2[4] << 32) | ((unint64_t)a2[5] << 40) | ((unint64_t)a2[6] << 48) | ((unint64_t)a2[7] << 56), *((_QWORD *)a2 + 1), a2[16] | ((unint64_t)*((unsigned int *)a2 + 5) << 32), a2[24]);
}

void *AWDLActionFrame.ServiceParameter.Flags.serviceRequests.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.ServiceParameter.Flags.serviceRequests;
}

void *AWDLActionFrame.ServiceParameter.Flags.missingBits.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.ServiceParameter.Flags.missingBits;
}

void *AWDLActionFrame.ServiceParameter.Flags.duplicates.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.ServiceParameter.Flags.duplicates;
}

void *AWDLActionFrame.ServiceParameter.Flags.autoGenerateAAAA.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.ServiceParameter.Flags.autoGenerateAAAA;
}

void *AWDLActionFrame.ServiceParameter.Flags.allKeys.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.ServiceParameter.Flags.allKeys;
}

void *AWDLActionFrame.ServiceParameter.Flags.serviceResponseOverflow.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.ServiceParameter.Flags.serviceResponseOverflow;
}

void *AWDLActionFrame.ServiceParameter.Flags.supportsWiFiAwareMigration.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.ServiceParameter.Flags.supportsWiFiAwareMigration;
}

uint64_t sub_1000CEBA0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000E7B84();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000CEBFC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000E7B84();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

uint64_t sub_1000CEC48()
{
  uint64_t result;
  uint64_t v1;

  result = Data.subdata(in:)(0, 0, 0, 0xC000000000000000);
  static AWDLActionFrame.ServiceParameter.SSTH.zero = 0;
  qword_100410440 = result;
  unk_100410448 = v1;
  return result;
}

uint64_t AWDLActionFrame.ServiceParameter.SSTH.init(ssthByteMap:compressedSSTH:)(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v7;

  sub_1000E605C(a1, a2, a3);
  if (!v4)
    v3 = v7;
  sub_10000E614(a2, a3);
  return v3;
}

int *AWDLActionFrame.ServiceParameter.SSTH.zero.unsafeMutableAddressor()
{
  if (qword_100403F48 != -1)
    swift_once(&qword_100403F48, sub_1000CEC48);
  return &static AWDLActionFrame.ServiceParameter.SSTH.zero;
}

uint64_t static AWDLActionFrame.ServiceParameter.SSTH.zero.getter()
{
  uint64_t v0;

  if (qword_100403F48 != -1)
    swift_once(&qword_100403F48, sub_1000CEC48);
  v0 = static AWDLActionFrame.ServiceParameter.SSTH.zero;
  sub_100031FEC(qword_100410440, unk_100410448);
  return v0;
}

uint64_t AWDLActionFrame.ServiceParameter.SSTH.init(from:)(_QWORD *a1)
{
  uint64_t v1;
  uint64_t result;
  unsigned int v3;

  LODWORD(result) = sub_1000E64D8(a1);
  if (v1)
    return v3;
  else
    return result;
}

uint64_t AWDLActionFrame.ServiceParameter.SSTH.hash(into:)(uint64_t a1, Swift::UInt32 a2, uint64_t a3, unint64_t a4)
{
  __n128 v7;

  Hasher._combine(_:)(a2);
  sub_100031FEC(a3, a4);
  Data.hash(into:)(a1, a3, a4, v7);
  return sub_10000E614(a3, a4);
}

void static AWDLActionFrame.ServiceParameter.SSTH.__derived_struct_equals(_:_:)(int a1, uint64_t a2, uint64_t a3, int a4)
{
  if (a1 == a4)
    _s7CoreP2P6NANPMKV23__derived_struct_equalsySbAC_ACtFZ_0(a2, a3);
}

uint64_t sub_1000CEE40()
{
  _BYTE *v0;

  if (*v0)
    return 0x73736572706D6F63;
  else
    return 0x6574794268747373;
}

uint64_t sub_1000CEE90@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;

  result = sub_1000EF344(a1, a2);
  *a3 = result;
  return result;
}

uint64_t sub_1000CEEB4(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000E6B68();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000CEEDC(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000E6B68();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t AWDLActionFrame.ServiceParameter.SSTH.encode(to:)(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v17;
  uint64_t v18;
  _QWORD v19[2];
  char v20;

  v18 = a4;
  v8 = sub_100012C44(&qword_1004071E0);
  v9 = *(_QWORD *)(v8 - 8);
  __chkstk_darwin();
  v11 = (char *)&v17 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = a1[3];
  v13 = a1[4];
  sub_10003259C(a1, v12);
  v14 = sub_1000E6B68();
  dispatch thunk of Encoder.container<A>(keyedBy:)(&type metadata for AWDLActionFrame.ServiceParameter.SSTH.CodingKeys, &type metadata for AWDLActionFrame.ServiceParameter.SSTH.CodingKeys, v14, v12, v13);
  LOBYTE(v19[0]) = 0;
  KeyedEncodingContainer.encode(_:forKey:)(a2, v19, v8);
  if (!v4)
  {
    v19[0] = a3;
    v19[1] = v18;
    v20 = 1;
    v15 = sub_100068570();
    KeyedEncodingContainer.encode<A>(_:forKey:)(v19, &v20, v8, &type metadata for Data, v15);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v11, v8);
}

Swift::Int AWDLActionFrame.ServiceParameter.SSTH.hashValue.getter(Swift::UInt32 a1, uint64_t a2, unint64_t a3)
{
  __n128 v6;
  _QWORD v8[9];

  Hasher.init(_seed:)(v8);
  Hasher._combine(_:)(a1);
  sub_100031FEC(a2, a3);
  Data.hash(into:)(v8, a2, a3, v6);
  sub_10000E614(a2, a3);
  return Hasher._finalize()();
}

Swift::Int sub_1000CF0BC()
{
  uint64_t v0;
  Swift::UInt32 v1;
  uint64_t v2;
  unint64_t v3;
  __n128 v4;
  _QWORD v6[9];

  v1 = *(_DWORD *)v0;
  v2 = *(_QWORD *)(v0 + 8);
  v3 = *(_QWORD *)(v0 + 16);
  Hasher.init(_seed:)(v6);
  Hasher._combine(_:)(v1);
  sub_100031FEC(v2, v3);
  Data.hash(into:)(v6, v2, v3, v4);
  sub_10000E614(v2, v3);
  return Hasher._finalize()();
}

uint64_t sub_1000CF134(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  unint64_t v4;
  __n128 v5;

  v3 = *(_QWORD *)(v1 + 8);
  v4 = *(_QWORD *)(v1 + 16);
  Hasher._combine(_:)(*(_DWORD *)v1);
  sub_100031FEC(v3, v4);
  Data.hash(into:)(a1, v3, v4, v5);
  return sub_10000E614(v3, v4);
}

Swift::Int sub_1000CF18C()
{
  uint64_t v0;
  Swift::UInt32 v1;
  uint64_t v2;
  unint64_t v3;
  __n128 v4;
  _QWORD v6[9];

  v1 = *(_DWORD *)v0;
  v2 = *(_QWORD *)(v0 + 8);
  v3 = *(_QWORD *)(v0 + 16);
  Hasher.init(_seed:)(v6);
  Hasher._combine(_:)(v1);
  sub_100031FEC(v2, v3);
  Data.hash(into:)(v6, v2, v3, v4);
  sub_10000E614(v2, v3);
  return Hasher._finalize()();
}

_QWORD *sub_1000CF200@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  _QWORD *result;
  uint64_t v5;
  uint64_t v6;

  result = sub_1000E64D8(a1);
  if (!v2)
  {
    *(_DWORD *)a2 = (_DWORD)result;
    *(_QWORD *)(a2 + 8) = v5;
    *(_QWORD *)(a2 + 16) = v6;
  }
  return result;
}

uint64_t sub_1000CF22C(_QWORD *a1)
{
  unsigned int *v1;

  return AWDLActionFrame.ServiceParameter.SSTH.encode(to:)(a1, *v1, *((_QWORD *)v1 + 1), *((_QWORD *)v1 + 2));
}

void sub_1000CF248(uint64_t a1, _DWORD *a2)
{
  if (*(_DWORD *)a1 == *a2)
    _s7CoreP2P6NANPMKV23__derived_struct_equalsySbAC_ACtFZ_0(*(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16));
}

uint64_t IEEE80211InformationElement.VeryHighThroughputCapability.rxMCSMap.setter(uint64_t result)
{
  uint64_t v1;

  *(_WORD *)(v1 + 4) = result;
  return result;
}

uint64_t AWDLActionFrame.ServiceParameter.ssth.setter(int a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t result;

  result = sub_10000E614(*(_QWORD *)(v3 + 16), *(_QWORD *)(v3 + 24));
  *(_DWORD *)(v3 + 8) = a1;
  *(_QWORD *)(v3 + 16) = a2;
  *(_QWORD *)(v3 + 24) = a3;
  return result;
}

uint64_t AWDLActionFrame.ServiceParameter.hash(into:)(uint64_t a1, unint64_t a2, Swift::UInt32 a3, uint64_t a4, unint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  __n128 v11;

  v9 = a2 >> 16;
  v10 = HIDWORD(a2);
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(a3);
  sub_100031FEC(a4, a5);
  Data.hash(into:)(a1, a4, a5, v11);
  return sub_10000E614(a4, a5);
}

BOOL static AWDLActionFrame.ServiceParameter.__derived_struct_equals(_:_:)(unint64_t a1, int a2, uint64_t a3, uint64_t a4, unint64_t a5, int a6)
{
  _BOOL8 result;
  char v8;

  result = 0;
  if (a1 == a5 && (a1 >> 16) == (a5 >> 16))
  {
    result = 0;
    if (a2 == a6)
    {
      _s7CoreP2P6NANPMKV23__derived_struct_equalsySbAC_ACtFZ_0(a3, a4);
      if ((v8 & 1) != 0)
        return 1;
    }
  }
  return result;
}

uint64_t sub_1000CF394()
{
  unsigned __int8 *v0;

  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_1000CF3C0 + 4 * byte_1003412B0[*v0]))(0x7367616C66, 0xE500000000000000);
}

uint64_t sub_1000CF3C0()
{
  return 0x6D69546C6C657764;
}

unint64_t sub_1000CF3DC()
{
  return 0xD000000000000016;
}

uint64_t sub_1000CF3F8()
{
  return 1752462195;
}

uint64_t sub_1000CF408@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;

  result = sub_1000EF470(a1, a2);
  *a3 = result;
  return result;
}

uint64_t sub_1000CF42C(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000E6BAC();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000CF454(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000E6BAC();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t AWDLActionFrame.ServiceParameter.encode(to:)(_QWORD *a1, unint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  char v28;

  v23 = a4;
  v24 = a5;
  v9 = sub_100012C44(&qword_1004071F0);
  v10 = *(_QWORD *)(v9 - 8);
  __chkstk_darwin();
  v12 = (char *)&v22 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = a1[3];
  v13 = a1[4];
  sub_10003259C(a1, v14);
  v15 = sub_1000E6BAC();
  dispatch thunk of Encoder.container<A>(keyedBy:)(&type metadata for AWDLActionFrame.ServiceParameter.CodingKeys, &type metadata for AWDLActionFrame.ServiceParameter.CodingKeys, v15, v14, v13);
  LOBYTE(v25) = a2;
  v28 = 0;
  v16 = sub_1000E6BF0();
  KeyedEncodingContainer.encode<A>(_:forKey:)(&v25, &v28, v9, &type metadata for AWDLActionFrame.ServiceParameter.Flags, v16);
  if (!v5)
  {
    v17 = a3;
    v18 = v23;
    v19 = v24;
    LOBYTE(v25) = 1;
    KeyedEncodingContainer.encode(_:forKey:)(a2 >> 16, &v25, v9);
    LOBYTE(v25) = 2;
    KeyedEncodingContainer.encode(_:forKey:)(HIDWORD(a2), &v25, v9);
    v25 = v17;
    v26 = v18;
    v27 = v19;
    v28 = 3;
    v20 = sub_1000E6C34();
    KeyedEncodingContainer.encode<A>(_:forKey:)(&v25, &v28, v9, &type metadata for AWDLActionFrame.ServiceParameter.SSTH, v20);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v10 + 8))(v12, v9);
}

Swift::Int AWDLActionFrame.ServiceParameter.hashValue.getter(unint64_t a1, Swift::UInt32 a2, uint64_t a3, unint64_t a4)
{
  Swift::UInt8 v7;
  unint64_t v8;
  unint64_t v9;
  __n128 v10;
  _QWORD v12[9];

  v7 = a1;
  v8 = a1 >> 16;
  v9 = HIDWORD(a1);
  Hasher.init(_seed:)(v12);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(a2);
  sub_100031FEC(a3, a4);
  Data.hash(into:)(v12, a3, a4, v10);
  sub_10000E614(a3, a4);
  return Hasher._finalize()();
}

unint64_t sub_1000CF6E0@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  unint64_t result;
  int v5;
  uint64_t v6;
  uint64_t v7;

  result = AWDLActionFrame.ServiceParameter.init(from:)(a1);
  if (!v2)
  {
    *(_BYTE *)a2 = result;
    *(_WORD *)(a2 + 2) = WORD1(result);
    *(_WORD *)(a2 + 4) = WORD2(result);
    *(_DWORD *)(a2 + 8) = v5;
    *(_QWORD *)(a2 + 16) = v6;
    *(_QWORD *)(a2 + 24) = v7;
  }
  return result;
}

unint64_t AWDLActionFrame.ServiceParameter.init(from:)(_QWORD *a1)
{
  return sub_1000E6E74(a1) & 0xFFFFFFFF00FFLL;
}

uint64_t sub_1000CF750(_QWORD *a1)
{
  unsigned __int8 *v1;

  return AWDLActionFrame.ServiceParameter.encode(to:)(a1, *v1 | ((unint64_t)*((unsigned __int16 *)v1 + 1) << 16) | ((unint64_t)*((unsigned __int16 *)v1+ 2) << 32), *((_DWORD *)v1 + 2), *((_QWORD *)v1 + 2), *((_QWORD *)v1 + 3));
}

Swift::Int sub_1000CF780()
{
  uint64_t v0;
  Swift::UInt32 v1;
  uint64_t v2;
  unint64_t v3;
  Swift::UInt8 v4;
  Swift::UInt16 v5;
  Swift::UInt16 v6;
  __n128 v7;
  _QWORD v9[9];

  v1 = *(_DWORD *)(v0 + 8);
  v2 = *(_QWORD *)(v0 + 16);
  v3 = *(_QWORD *)(v0 + 24);
  v4 = *(_BYTE *)v0;
  v5 = *(_WORD *)(v0 + 2);
  v6 = *(_WORD *)(v0 + 4);
  Hasher.init(_seed:)(v9);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v1);
  sub_100031FEC(v2, v3);
  Data.hash(into:)(v9, v2, v3, v7);
  sub_10000E614(v2, v3);
  return Hasher._finalize()();
}

uint64_t sub_1000CF838(uint64_t a1)
{
  uint64_t v1;
  Swift::UInt32 v3;
  uint64_t v4;
  unint64_t v5;
  Swift::UInt16 v6;
  Swift::UInt16 v7;
  __n128 v8;

  v3 = *(_DWORD *)(v1 + 8);
  v4 = *(_QWORD *)(v1 + 16);
  v5 = *(_QWORD *)(v1 + 24);
  v6 = *(_WORD *)(v1 + 2);
  v7 = *(_WORD *)(v1 + 4);
  Hasher._combine(_:)(*(_BYTE *)v1);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v3);
  sub_100031FEC(v4, v5);
  Data.hash(into:)(a1, v4, v5, v8);
  return sub_10000E614(v4, v5);
}

Swift::Int sub_1000CF8C4()
{
  uint64_t v0;
  Swift::UInt32 v1;
  uint64_t v2;
  unint64_t v3;
  Swift::UInt8 v4;
  Swift::UInt16 v5;
  Swift::UInt16 v6;
  __n128 v7;
  _QWORD v9[9];

  v1 = *(_DWORD *)(v0 + 8);
  v2 = *(_QWORD *)(v0 + 16);
  v3 = *(_QWORD *)(v0 + 24);
  v4 = *(_BYTE *)v0;
  v5 = *(_WORD *)(v0 + 2);
  v6 = *(_WORD *)(v0 + 4);
  Hasher.init(_seed:)(v9);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v1);
  sub_100031FEC(v2, v3);
  Data.hash(into:)(v9, v2, v3, v7);
  sub_10000E614(v2, v3);
  return Hasher._finalize()();
}

BOOL sub_1000CF978(unsigned __int8 *a1, unsigned __int8 *a2)
{
  BOOL v3;
  char v4;
  _BOOL8 result;

  v3 = *a1 == *a2
    && *((unsigned __int16 *)a1 + 1) == *((unsigned __int16 *)a2 + 1)
    && *((unsigned __int16 *)a1 + 2) == *((unsigned __int16 *)a2 + 2);
  result = 0;
  if (v3 && *((_DWORD *)a1 + 2) == *((_DWORD *)a2 + 2))
  {
    _s7CoreP2P6NANPMKV23__derived_struct_equalsySbAC_ACtFZ_0(*((_QWORD *)a1 + 2), *((_QWORD *)a1 + 3));
    if ((v4 & 1) != 0)
      return 1;
  }
  return result;
}

uint64_t sub_1000CF9E8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000EDA70();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000CFA44(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000EDA70();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

uint64_t sub_1000CFA90(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000EDB90();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000CFAEC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000EDB90();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

BOOL sub_1000CFB3C(char *a1, char *a2)
{
  return dword_1003458A8[*a1] == dword_1003458A8[*a2];
}

uint64_t sub_1000CFB60@<X0>(int *a1@<X0>, _BYTE *a2@<X8>)
{
  uint64_t result;

  result = _s7CoreP2P15AWDLActionFrameV13DataPathStateV30UnicastMasterIndicationOptionsO8rawValueAGSgs6UInt32V_tcfC_0(*a1);
  *a2 = result;
  return result;
}

void sub_1000CFB88(_DWORD *a1@<X8>)
{
  char *v1;

  *a1 = dword_1003458A8[*v1];
}

Swift::Int sub_1000CFBA0()
{
  char *v0;
  uint64_t v1;
  _QWORD v3[9];

  v1 = *v0;
  Hasher.init(_seed:)(v3);
  Hasher._combine(_:)(dword_1003458A8[v1]);
  return Hasher._finalize()();
}

void sub_1000CFBEC()
{
  char *v0;

  Hasher._combine(_:)(dword_1003458A8[*v0]);
}

Swift::Int sub_1000CFC20()
{
  char *v0;
  uint64_t v1;
  _QWORD v3[9];

  v1 = *v0;
  Hasher.init(_seed:)(v3);
  Hasher._combine(_:)(dword_1003458A8[v1]);
  return Hasher._finalize()();
}

uint64_t sub_1000CFC68(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000F04E0();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000CFCC4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000F04E0();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

uint64_t AWDLActionFrame.DataPathState.countryCode.getter()
{
  unsigned __int16 *v0;

  return *v0 | (*((unsigned __int8 *)v0 + 2) << 16);
}

uint64_t AWDLActionFrame.DataPathState.countryCode.setter(uint64_t result)
{
  uint64_t v1;

  *(_WORD *)v1 = result;
  *(_BYTE *)(v1 + 2) = BYTE2(result) & 1;
  return result;
}

unint64_t AWDLActionFrame.DataPathState.socialChannelMap.getter()
{
  uint64_t v0;

  return *(unsigned int *)(v0 + 4) | ((unint64_t)*(unsigned __int16 *)(v0 + 8) << 32);
}

uint64_t AWDLActionFrame.DataPathState.socialChannelMap.setter(uint64_t result)
{
  uint64_t v1;

  *(_DWORD *)(v1 + 4) = result;
  *(_WORD *)(v1 + 8) = WORD2(result);
  return result;
}

unint64_t AWDLActionFrame.DataPathState.infraBSSID.getter()
{
  uint64_t v0;

  return *(unsigned int *)(v0 + 10) | ((unint64_t)*(unsigned __int16 *)(v0 + 14) << 32) | ((unint64_t)*(unsigned __int8 *)(v0 + 16) << 48);
}

uint64_t AWDLActionFrame.DataPathState.infraBSSID.setter(uint64_t result)
{
  uint64_t v1;

  *(_DWORD *)(v1 + 10) = result;
  *(_WORD *)(v1 + 14) = WORD2(result);
  *(_BYTE *)(v1 + 16) = BYTE6(result) & 1;
  return result;
}

unint64_t AWDLActionFrame.DataPathState.infraChannel.getter()
{
  uint64_t v0;

  return *(unsigned int *)(v0 + 20) | ((unint64_t)*(unsigned __int16 *)(v0 + 24) << 32);
}

uint64_t AWDLActionFrame.DataPathState.infraChannel.setter(uint64_t result)
{
  uint64_t v1;

  *(_DWORD *)(v1 + 20) = result;
  *(_WORD *)(v1 + 24) = WORD2(result);
  return result;
}

unint64_t AWDLActionFrame.DataPathState.infraAddress.getter()
{
  uint64_t v0;

  return *(unsigned int *)(v0 + 26) | ((unint64_t)*(unsigned __int16 *)(v0 + 30) << 32) | ((unint64_t)*(unsigned __int8 *)(v0 + 32) << 48);
}

uint64_t AWDLActionFrame.DataPathState.infraAddress.setter(uint64_t result)
{
  uint64_t v1;

  *(_DWORD *)(v1 + 26) = result;
  *(_WORD *)(v1 + 30) = WORD2(result);
  *(_BYTE *)(v1 + 32) = BYTE6(result) & 1;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.infraAddress.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.infraSSID.getter()
{
  uint64_t v0;
  uint64_t v1;

  v1 = *(_QWORD *)(v0 + 40);
  swift_bridgeObjectRetain(*(_QWORD *)(v0 + 48));
  return v1;
}

uint64_t AWDLActionFrame.DataPathState.infraSSID.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t result;

  result = swift_bridgeObjectRelease(*(_QWORD *)(v2 + 48));
  *(_QWORD *)(v2 + 40) = a1;
  *(_QWORD *)(v2 + 48) = a2;
  return result;
}

uint64_t (*IEEE80211InformationElement.RSNCapability.groupManagementCipherSuite.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

unint64_t AWDLActionFrame.DataPathState.awdlAddress.getter()
{
  uint64_t v0;

  return *(unsigned int *)(v0 + 56) | ((unint64_t)*(unsigned __int16 *)(v0 + 60) << 32) | ((unint64_t)*(unsigned __int8 *)(v0 + 62) << 48);
}

uint64_t AWDLActionFrame.DataPathState.awdlAddress.setter(uint64_t result)
{
  uint64_t v1;

  *(_DWORD *)(v1 + 56) = result;
  *(_WORD *)(v1 + 60) = WORD2(result);
  *(_BYTE *)(v1 + 62) = BYTE6(result) & 1;
  return result;
}

uint64_t (*InfraStatistics.viOutputBytes.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.isUnicast.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 63);
}

uint64_t AWDLActionFrame.DataPathState.isUnicast.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 63) = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.isUnicast.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.unicastOptions.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 64);
}

uint64_t AWDLActionFrame.DataPathState.unicastOptions.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 64) = result;
  return result;
}

uint64_t (*InfraStatistics.ctlOutputPackets.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.unicastPeerCachingIndication.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 65);
}

uint64_t AWDLActionFrame.DataPathState.unicastPeerCachingIndication.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 65) = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.unicastPeerCachingIndication.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.portUniqueLogID.getter()
{
  uint64_t v0;

  return *(unsigned __int16 *)(v0 + 66) | (*(unsigned __int8 *)(v0 + 68) << 16);
}

uint64_t AWDLActionFrame.DataPathState.portUniqueLogID.setter(uint64_t result)
{
  uint64_t v1;

  *(_WORD *)(v1 + 66) = result;
  *(_BYTE *)(v1 + 68) = BYTE2(result) & 1;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.portUniqueLogID.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

unint64_t AWDLActionFrame.DataPathState.rootLoopFreeCounter.getter()
{
  uint64_t v0;

  return *(unsigned int *)(v0 + 72) | ((unint64_t)*(unsigned __int8 *)(v0 + 76) << 32);
}

uint64_t AWDLActionFrame.DataPathState.rootLoopFreeCounter.setter(uint64_t result)
{
  uint64_t v1;

  *(_DWORD *)(v1 + 72) = result;
  *(_BYTE *)(v1 + 76) = BYTE4(result) & 1;
  return result;
}

uint64_t (*InfraStatistics.inputPackets.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.supportsDualBand.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 77);
}

uint64_t AWDLActionFrame.DataPathState.supportsDualBand.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 77) = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.supportsDualBand.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.isAirPlaySink.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 78);
}

uint64_t AWDLActionFrame.DataPathState.isAirPlaySink.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 78) = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.isAirPlaySink.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.followChannelSequence.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 79);
}

uint64_t AWDLActionFrame.DataPathState.followChannelSequence.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 79) = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.followChannelSequence.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.supportsAirPlaySolo.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 80);
}

uint64_t AWDLActionFrame.DataPathState.supportsAirPlaySolo.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 80) = result;
  return result;
}

uint64_t (*InfraStatistics.inputBytes.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.supportsUnicastMasterIndication.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 81);
}

uint64_t AWDLActionFrame.DataPathState.supportsUnicastMasterIndication.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 81) = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.supportsUnicastMasterIndication.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.infraRealTimeActive.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 82);
}

uint64_t AWDLActionFrame.DataPathState.infraRealTimeActive.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 82) = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.infraRealTimeActive.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.isRangeable.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 83);
}

uint64_t AWDLActionFrame.DataPathState.isRangeable.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 83) = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.isRangeable.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.supportsSimultaneousDualBand.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 84);
}

uint64_t AWDLActionFrame.DataPathState.supportsSimultaneousDualBand.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 84) = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.supportsSimultaneousDualBand.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.supportsDFSProxy.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 85);
}

uint64_t AWDLActionFrame.DataPathState.supportsDFSProxy.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 85) = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.supportsDFSProxy.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.assistedDiscoveryActive.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 86);
}

uint64_t AWDLActionFrame.DataPathState.assistedDiscoveryActive.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 86) = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.assistedDiscoveryActive.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.supportsSocialChannelMap.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 87);
}

uint64_t AWDLActionFrame.DataPathState.supportsSocialChannelMap.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 87) = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.supportsSocialChannelMap.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.nanConcurrencyEnabled.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 88);
}

uint64_t AWDLActionFrame.DataPathState.nanConcurrencyEnabled.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 88) = result;
  return result;
}

uint64_t (*InfraStatistics.linkRate.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.supportsHighEfficiencyRate.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 89);
}

uint64_t AWDLActionFrame.DataPathState.supportsHighEfficiencyRate.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 89) = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.supportsHighEfficiencyRate.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.isSidekickHub.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 90);
}

uint64_t AWDLActionFrame.DataPathState.isSidekickHub.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 90) = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.isSidekickHub.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.supports6GHz.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 91);
}

uint64_t AWDLActionFrame.DataPathState.supports6GHz.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 91) = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.supports6GHz.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.supportsUltraLowLatencyInfra.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 92);
}

uint64_t AWDLActionFrame.DataPathState.supportsUltraLowLatencyInfra.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 92) = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.supportsUltraLowLatencyInfra.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.proModeActive.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 93);
}

uint64_t AWDLActionFrame.DataPathState.proModeActive.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 93) = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.proModeActive.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.hasChannelSequence.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 94);
}

uint64_t AWDLActionFrame.DataPathState.hasChannelSequence.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 94) = result;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.hasChannelSequence.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.DataPathState.awdlOnSince.getter@<X0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  uint64_t v3;

  v3 = v1 + *(int *)(type metadata accessor for AWDLActionFrame.DataPathState(0) + 136);
  return sub_1000E7054(v3, a1);
}

uint64_t AWDLActionFrame.DataPathState.awdlOnSince.setter(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;

  v3 = v1 + *(int *)(type metadata accessor for AWDLActionFrame.DataPathState(0) + 136);
  return sub_1000E709C(a1, v3);
}

uint64_t (*AWDLActionFrame.DataPathState.awdlOnSince.modify())(_QWORD)
{
  type metadata accessor for AWDLActionFrame.DataPathState(0);
  return NANBitmap.Channel.operatingClass.getter;
}

unint64_t AWDLActionFrame.DataPathState.availabilityWindowSequenceNumber.getter()
{
  uint64_t v0;
  unsigned int *v1;

  v1 = (unsigned int *)(v0 + *(int *)(type metadata accessor for AWDLActionFrame.DataPathState(0) + 140));
  return *v1 | ((unint64_t)*((unsigned __int8 *)v1 + 4) << 32);
}

uint64_t AWDLActionFrame.DataPathState.availabilityWindowSequenceNumber.setter(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;
  uint64_t v4;

  result = type metadata accessor for AWDLActionFrame.DataPathState(0);
  v4 = v1 + *(int *)(result + 140);
  *(_DWORD *)v4 = a1;
  *(_BYTE *)(v4 + 4) = BYTE4(a1) & 1;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.availabilityWindowSequenceNumber.modify())(_QWORD)
{
  type metadata accessor for AWDLActionFrame.DataPathState(0);
  return NANBitmap.Channel.operatingClass.getter;
}

unint64_t AWDLActionFrame.DataPathState.actionFrameUpdateCounter.getter()
{
  uint64_t v0;
  unsigned int *v1;

  v1 = (unsigned int *)(v0 + *(int *)(type metadata accessor for AWDLActionFrame.DataPathState(0) + 144));
  return *v1 | ((unint64_t)*((unsigned __int8 *)v1 + 4) << 32);
}

uint64_t AWDLActionFrame.DataPathState.actionFrameUpdateCounter.setter(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;
  uint64_t v4;

  result = type metadata accessor for AWDLActionFrame.DataPathState(0);
  v4 = v1 + *(int *)(result + 144);
  *(_DWORD *)v4 = a1;
  *(_BYTE *)(v4 + 4) = BYTE4(a1) & 1;
  return result;
}

uint64_t (*AWDLActionFrame.DataPathState.actionFrameUpdateCounter.modify())(_QWORD)
{
  type metadata accessor for AWDLActionFrame.DataPathState(0);
  return NANBitmap.Channel.operatingClass.getter;
}

void AWDLActionFrame.DataPathState.hash(into:)(uint64_t a1)
{
  unsigned __int16 *v1;
  unsigned __int16 *v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  unsigned int v9;
  unsigned int v10;
  unint64_t v11;
  Swift::UInt8 v12;
  Swift::UInt v13;
  char v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  Swift::UInt8 v23;
  unsigned int v24;
  Swift::UInt v25;
  unsigned int v26;
  unsigned int v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  Swift::UInt16 v44;
  Swift::UInt32 v45;
  int *v46;
  char *v47;
  char *v48;
  Swift::UInt32 v49;
  char *v50;
  Swift::UInt32 v51;
  uint64_t v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;

  v2 = v1;
  v4 = type metadata accessor for DispatchTimeInterval(0);
  v5 = *(_QWORD *)(v4 - 8);
  __chkstk_darwin();
  v53 = (char *)&v52 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_100012C44(&qword_100407210);
  __chkstk_darwin();
  v8 = (char *)&v52 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  LOBYTE(v7) = *((_BYTE *)v2 + 2);
  v54 = v5;
  if ((v7 & 1) != 0)
  {
    LOBYTE(v9) = 0;
  }
  else
  {
    v10 = *v2;
    v9 = v10 >> 8;
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(v10);
  }
  Hasher._combine(_:)(v9);
  v11 = *((unsigned int *)v2 + 1) | ((unint64_t)v2[4] << 32);
  if ((v11 & 0xFF00000000) == 0x300000000)
  {
    v12 = 0;
LABEL_6:
    Hasher._combine(_:)(v12);
  }
  else
  {
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(v11);
    Hasher._combine(_:)(0x801004u >> ((v11 >> 29) & 0xF8));
    switch(v11 >> 40)
    {
      case 2uLL:
        v13 = 0;
        break;
      case 3uLL:
        v13 = 1;
        break;
      case 4uLL:
        v13 = 3;
        break;
      case 5uLL:
        v13 = 4;
        break;
      case 6uLL:
        v13 = 5;
        break;
      default:
        Hasher._combine(_:)(2uLL);
        v12 = BYTE5(v11) & 1;
        goto LABEL_6;
    }
    Hasher._combine(_:)(v13);
  }
  v14 = *((_BYTE *)v2 + 16);
  v55 = v4;
  if ((v14 & 1) != 0)
  {
    LOBYTE(v15) = 0;
  }
  else
  {
    v16 = v2[7];
    v17 = *(_DWORD *)(v2 + 5);
    v18 = v17 | ((unint64_t)v2[7] << 32);
    v19 = v18 >> 8;
    v20 = v18 >> 16;
    v21 = v18 >> 24;
    v15 = v16 >> 8;
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(v17);
    Hasher._combine(_:)(v19);
    Hasher._combine(_:)(v20);
    Hasher._combine(_:)(v21);
    Hasher._combine(_:)(v16);
  }
  Hasher._combine(_:)(v15);
  v22 = *((unsigned int *)v2 + 5) | ((unint64_t)v2[12] << 32);
  if ((v22 & 0xFF00000000) == 0x300000000)
  {
    v23 = 0;
LABEL_20:
    Hasher._combine(_:)(v23);
    if ((v2[16] & 1) != 0)
    {
LABEL_21:
      LOBYTE(v24) = 0;
      goto LABEL_31;
    }
  }
  else
  {
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(v22);
    Hasher._combine(_:)(0x801004u >> ((v22 >> 29) & 0xF8));
    switch(v22 >> 40)
    {
      case 2uLL:
        v25 = 0;
        break;
      case 3uLL:
        v25 = 1;
        break;
      case 4uLL:
        v25 = 3;
        break;
      case 5uLL:
        v25 = 4;
        break;
      case 6uLL:
        v25 = 5;
        break;
      default:
        Hasher._combine(_:)(2uLL);
        v23 = BYTE5(v22) & 1;
        goto LABEL_20;
    }
    Hasher._combine(_:)(v25);
    if ((v2[16] & 1) != 0)
      goto LABEL_21;
  }
  v26 = v2[15];
  v27 = *(_DWORD *)(v2 + 13);
  v28 = v27 | ((unint64_t)v2[15] << 32);
  v29 = v28 >> 8;
  v30 = v28 >> 16;
  v31 = v28 >> 24;
  v24 = v26 >> 8;
  Hasher._combine(_:)(1u);
  Hasher._combine(_:)(v27);
  Hasher._combine(_:)(v29);
  Hasher._combine(_:)(v30);
  Hasher._combine(_:)(v31);
  Hasher._combine(_:)(v26);
LABEL_31:
  Hasher._combine(_:)(v24);
  v32 = *((_QWORD *)v2 + 6);
  if (v32)
  {
    v33 = *((_QWORD *)v2 + 5);
    Hasher._combine(_:)(1u);
    swift_bridgeObjectRetain(v32);
    String.hash(into:)(a1, v33, v32);
    swift_bridgeObjectRelease(v32);
    if ((v2[31] & 1) != 0)
    {
LABEL_33:
      LOBYTE(v34) = 0;
      goto LABEL_36;
    }
  }
  else
  {
    Hasher._combine(_:)(0);
    if ((v2[31] & 1) != 0)
      goto LABEL_33;
  }
  v35 = v2[30];
  v36 = *((_DWORD *)v2 + 14);
  v37 = v36 | ((unint64_t)v2[30] << 32);
  v38 = v37 >> 8;
  v39 = v37 >> 16;
  v40 = v37 >> 24;
  v34 = v35 >> 8;
  Hasher._combine(_:)(1u);
  Hasher._combine(_:)(v36);
  Hasher._combine(_:)(v38);
  Hasher._combine(_:)(v39);
  Hasher._combine(_:)(v40);
  Hasher._combine(_:)(v35);
LABEL_36:
  v42 = v54;
  v41 = v55;
  Hasher._combine(_:)(v34);
  Hasher._combine(_:)(*((_BYTE *)v2 + 63));
  v43 = *((char *)v2 + 64);
  if (v43 == 43)
  {
    Hasher._combine(_:)(0);
  }
  else
  {
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(dword_1003458A8[v43]);
  }
  Hasher._combine(_:)(*((_BYTE *)v2 + 65));
  if (*((_BYTE *)v2 + 68) == 1)
  {
    Hasher._combine(_:)(0);
  }
  else
  {
    v44 = v2[33];
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(v44);
  }
  if (*((_BYTE *)v2 + 76) == 1)
  {
    Hasher._combine(_:)(0);
  }
  else
  {
    v45 = *((_DWORD *)v2 + 18);
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(v45);
  }
  Hasher._combine(_:)(*((_BYTE *)v2 + 77));
  Hasher._combine(_:)(*((_BYTE *)v2 + 78));
  Hasher._combine(_:)(*((_BYTE *)v2 + 79));
  Hasher._combine(_:)(*((_BYTE *)v2 + 80));
  Hasher._combine(_:)(*((_BYTE *)v2 + 81));
  Hasher._combine(_:)(*((_BYTE *)v2 + 82));
  Hasher._combine(_:)(*((_BYTE *)v2 + 83));
  Hasher._combine(_:)(*((_BYTE *)v2 + 84));
  Hasher._combine(_:)(*((_BYTE *)v2 + 85));
  Hasher._combine(_:)(*((_BYTE *)v2 + 86));
  Hasher._combine(_:)(*((_BYTE *)v2 + 87));
  Hasher._combine(_:)(*((_BYTE *)v2 + 88));
  Hasher._combine(_:)(*((_BYTE *)v2 + 89));
  Hasher._combine(_:)(*((_BYTE *)v2 + 90));
  Hasher._combine(_:)(*((_BYTE *)v2 + 91));
  Hasher._combine(_:)(*((_BYTE *)v2 + 92));
  Hasher._combine(_:)(*((_BYTE *)v2 + 93));
  Hasher._combine(_:)(*((_BYTE *)v2 + 94));
  v46 = (int *)type metadata accessor for AWDLActionFrame.DataPathState(0);
  sub_1000E7054((uint64_t)v2 + v46[34], (uint64_t)v8);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v42 + 48))(v8, 1, v41) == 1)
  {
    Hasher._combine(_:)(0);
  }
  else
  {
    v47 = v53;
    (*(void (**)(char *, char *, uint64_t))(v42 + 32))(v53, v8, v41);
    Hasher._combine(_:)(1u);
    DispatchTimeInterval.hash(into:)();
    (*(void (**)(char *, uint64_t))(v42 + 8))(v47, v41);
  }
  v48 = (char *)v2 + v46[35];
  if (v48[4] == 1)
  {
    Hasher._combine(_:)(0);
  }
  else
  {
    v49 = *(_DWORD *)v48;
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(v49);
  }
  v50 = (char *)v2 + v46[36];
  if (v50[4] == 1)
  {
    Hasher._combine(_:)(0);
  }
  else
  {
    v51 = *(_DWORD *)v50;
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(v51);
  }
}

Swift::Int AWDLActionFrame.DataPathState.hashValue.getter()
{
  return sub_1000DE8A0((void (*)(_QWORD *))AWDLActionFrame.DataPathState.hash(into:));
}

uint64_t sub_1000D0A18@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X8>)
{
  return AWDLActionFrame.DataPathState.init(from:)(a1, a2);
}

uint64_t AWDLActionFrame.DataPathState.init(from:)@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void (*v11)(uint64_t, uint64_t, uint64_t, uint64_t);
  char *v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  int16x8_t v22;
  char *v23;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned __int16 v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned __int16 v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  _QWORD *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  unint64_t v60;
  char *v61;
  uint64_t v62;
  char *v63;
  char *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  int16x8_t v73;
  int16x8_t v74;
  unsigned int v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  unsigned int v82;
  _QWORD *v83;
  uint64_t v84;
  uint64_t v85;
  int v86;
  char *v87;
  uint64_t v88;
  uint64_t v89;
  int v90;
  char *v91;
  uint64_t v92;
  char *v93;
  char *v94;
  char *v95;
  uint64_t v96;
  _QWORD *v97;
  _QWORD *v98;
  uint64_t v99;
  char *v100;
  _QWORD v101[3];
  uint64_t v102;
  uint64_t v103;
  int v104;
  unsigned __int8 v105;
  unsigned __int8 v106;

  v96 = a2;
  type metadata accessor for String.Encoding(0);
  __chkstk_darwin();
  v95 = (char *)&v92 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v4 = type metadata accessor for AWDLActionFrame.DataPathState(0);
  v5 = __chkstk_darwin();
  v7 = (char *)&v92 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  *(_WORD *)v7 = 0;
  v7[2] = 1;
  *((_WORD *)v7 + 4) = 3;
  *((_DWORD *)v7 + 1) = 0;
  *((_WORD *)v7 + 7) = 0;
  *(_DWORD *)(v7 + 10) = 0;
  v7[16] = 1;
  *((_WORD *)v7 + 12) = 3;
  *((_DWORD *)v7 + 5) = 0;
  *((_WORD *)v7 + 15) = 0;
  *(_DWORD *)(v7 + 26) = 0;
  v7[32] = 1;
  *((_QWORD *)v7 + 5) = 0;
  *((_QWORD *)v7 + 6) = 0;
  *(_QWORD *)(v7 + 54) = 0;
  v7[62] = 1;
  v7[64] = 43;
  *((_WORD *)v7 + 33) = 0;
  v7[68] = 1;
  *((_DWORD *)v7 + 18) = 0;
  v8 = (uint64_t)&v7[*(int *)(v5 + 136)];
  v7[76] = 1;
  v9 = type metadata accessor for DispatchTimeInterval(0);
  v10 = *(_QWORD *)(v9 - 8);
  v11 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v10 + 56);
  v97 = (_QWORD *)v8;
  v11(v8, 1, 1, v9);
  v12 = &v7[*(int *)(v4 + 140)];
  *(_DWORD *)v12 = 0;
  v12[4] = 1;
  v13 = *(int *)(v4 + 144);
  v100 = v7;
  v14 = &v7[v13];
  *(_DWORD *)v14 = 0;
  v14[4] = 1;
  v16 = a1[3];
  v15 = a1[4];
  v98 = a1;
  sub_10003259C(a1, v16);
  v17 = v99;
  dispatch thunk of Decoder.unkeyedContainer()(v101, v16, v15);
  if (v17)
  {
    v23 = v100;
    sub_100014430(v98);
    swift_bridgeObjectRelease(*((_QWORD *)v23 + 6));
    return sub_100033A84((uint64_t)v97, &qword_100407210);
  }
  v99 = v10;
  v93 = v14;
  v94 = v12;
  v18 = v96;
  v19 = v102;
  v20 = v103;
  sub_100034C68((uint64_t)v101, v102);
  v21 = sub_1000E70E4();
  dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)(&type metadata for AWDLActionFrame.DataPathState.Flags, &type metadata for AWDLActionFrame.DataPathState.Flags, v21, v19, v20);
  v25 = (__int16)v104;
  v26 = (uint64_t)v100;
  v100[77] = (v104 & 0x20) != 0;
  *(_BYTE *)(v26 + 78) = (v25 & 0x40) != 0;
  *(_BYTE *)(v26 + 94) = (v25 & 0x10) != 0;
  *(_BYTE *)(v26 + 79) = (v25 & 0x80) != 0;
  v22.i64[0] = *(_QWORD *)&vshl_u16((uint16x4_t)vdup_n_s16(v25), (uint16x4_t)0xFFF2FFF3FFF5FFF6) & 0xFFC1FFC1FFC1FFC1;
  *(_DWORD *)(v26 + 80) = vmovn_s16(v22).u32[0];
  if ((v25 & 0x100) != 0)
  {
    v35 = v102;
    v36 = v103;
    sub_100034C68((uint64_t)v101, v102);
    LOBYTE(v36) = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v35, v36);
    v37 = v102;
    v92 = v103;
    sub_100034C68((uint64_t)v101, v102);
    *(_WORD *)v26 = v36 | (unsigned __int16)((unsigned __int16)dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v37, v92) << 8);
    *(_BYTE *)(v26 + 2) = 0;
    v38 = v102;
    v39 = v103;
    sub_100034C68((uint64_t)v101, v102);
    dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v38, v39);
  }
  if ((v25 & 0x200) != 0)
  {
    v27 = v102;
    v28 = v103;
    sub_100034C68((uint64_t)v101, v102);
    v29 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v27, v28);
    v30 = sub_100192784(v29);
    *(_DWORD *)(v26 + 4) = v30;
    *(_WORD *)(v26 + 8) = WORD2(v30);
  }
  if ((v25 & 1) == 0)
  {
    if ((v25 & 2) == 0)
      goto LABEL_12;
    goto LABEL_10;
  }
  LODWORD(v92) = v25;
  v40 = v102;
  v41 = v103;
  sub_100034C68((uint64_t)v101, v102);
  v42 = sub_10003A65C();
  dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)(&type metadata for WiFiAddress, &type metadata for WiFiAddress, v42, v40, v41);
  v43 = ((unint64_t)v106 << 40) | ((unint64_t)v105 << 32);
  *(_DWORD *)(v26 + 10) = v104;
  *(_WORD *)(v26 + 14) = WORD2(v43);
  *(_BYTE *)(v26 + 16) = 0;
  v44 = v102;
  v45 = v103;
  sub_100034C68((uint64_t)v101, v102);
  v46 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v44, v45);
  v47 = sub_100192784(v46);
  *(_DWORD *)(v26 + 20) = v47;
  *(_WORD *)(v26 + 24) = WORD2(v47);
  v25 = v92;
  if ((v92 & 2) != 0)
  {
LABEL_10:
    v31 = v102;
    v32 = v103;
    sub_100034C68((uint64_t)v101, v102);
    v33 = sub_10003A65C();
    dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)(&type metadata for WiFiAddress, &type metadata for WiFiAddress, v33, v31, v32);
    v34 = ((unint64_t)v106 << 40) | ((unint64_t)v105 << 32);
    *(_DWORD *)(v26 + 26) = v104;
    *(_WORD *)(v26 + 30) = WORD2(v34);
    *(_BYTE *)(v26 + 32) = 0;
  }
LABEL_12:
  if ((v25 & 4) != 0)
  {
    v48 = v102;
    v49 = v103;
    sub_100034C68((uint64_t)v101, v102);
    v50 = sub_10003A65C();
    dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)(&type metadata for WiFiAddress, &type metadata for WiFiAddress, v50, v48, v49);
    v51 = ((unint64_t)v106 << 40) | ((unint64_t)v105 << 32);
    *(_DWORD *)(v26 + 56) = v104;
    *(_WORD *)(v26 + 60) = WORD2(v51);
    *(_BYTE *)(v26 + 62) = 0;
  }
  if ((v25 & 8) == 0)
  {
    if ((v25 & 0x1000) == 0)
      goto LABEL_16;
LABEL_20:
    v65 = v102;
    v66 = v103;
    sub_100034C68((uint64_t)v101, v102);
    dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v65, v66);
    v67 = v102;
    v68 = v103;
    sub_100034C68((uint64_t)v101, v102);
    v69 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v67, v68);
    *(_BYTE *)(v26 + 65) = v69 & 1;
    *(_BYTE *)(v26 + 64) = _s7CoreP2P15AWDLActionFrameV13DataPathStateV30UnicastMasterIndicationOptionsO8rawValueAGSgs6UInt32V_tcfC_0(v69 & 0xFFFFFFFE);
    *(_BYTE *)(v26 + 63) = 1;
    if ((v25 & 0x80000000) == 0)
      goto LABEL_17;
LABEL_21:
    v70 = v102;
    v71 = v103;
    sub_100034C68((uint64_t)v101, v102);
    v72 = sub_1000E7128();
    dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)(&type metadata for AWDLActionFrame.DataPathState.ExtensionFlags, &type metadata for AWDLActionFrame.DataPathState.ExtensionFlags, v72, v70, v71);
    v75 = (unsigned __int16)v104;
    if ((v104 & 1) != 0)
    {
      v76 = v102;
      v77 = v103;
      sub_100034C68((uint64_t)v101, v102);
      *(_WORD *)(v26 + 66) = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v76, v77);
      *(_BYTE *)(v26 + 68) = 0;
    }
    if ((v75 & 4) != 0)
    {
      v78 = v102;
      v79 = v103;
      sub_100034C68((uint64_t)v101, v102);
      *(_DWORD *)(v26 + 72) = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v78, v79);
      *(_BYTE *)(v26 + 76) = 0;
    }
    if ((v75 & 0x20) != 0)
    {
      LODWORD(v95) = v75;
      v80 = v102;
      v81 = v103;
      sub_100034C68((uint64_t)v101, v102);
      v82 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v80, v81);
      v83 = v97;
      sub_100033A84((uint64_t)v97, &qword_100407210);
      *v83 = v82;
      (*(void (**)(_QWORD *, _QWORD, uint64_t))(v99 + 104))(v83, enum case for DispatchTimeInterval.milliseconds(_:), v9);
      v11((uint64_t)v83, 0, 1, v9);
      v84 = v102;
      v85 = v103;
      sub_100034C68((uint64_t)v101, v102);
      v86 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v84, v85);
      v87 = v94;
      *(_DWORD *)v94 = v86;
      v87[4] = 0;
      v88 = v102;
      v89 = v103;
      sub_100034C68((uint64_t)v101, v102);
      v90 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v88, v89);
      v91 = v93;
      *(_DWORD *)v93 = v90;
      v91[4] = 0;
      v26 = (uint64_t)v100;
      v75 = v95;
    }
    *(int16x4_t *)v73.i8 = vdup_n_s16(v75);
    *(uint16x4_t *)v74.i8 = vshl_u16(*(uint16x4_t *)v73.i8, (uint16x4_t)0xFFF4FFF5FFF7FFF8);
    v73.i64[0] = *(_QWORD *)&vshl_u16((uint16x4_t)(v73.i64[0] & 0xFF00FF00FF00FFLL), (uint16x4_t)0xFFFDFFFFFFFAFFFCLL) & 0xFF01FF01FF01FF01;
    *(_DWORD *)(v26 + 84) = vmovn_s16(v73).u32[0];
    *(_BYTE *)(v26 + 88) = (v75 & 0x80) != 0;
    v74.i64[0] &= 0xFF01FF01FF01FF01;
    *(_DWORD *)(v26 + 89) = vmovn_s16(v74).u32[0];
    *(_BYTE *)(v26 + 93) = (v75 & 0x2000) != 0;
    goto LABEL_18;
  }
  v53 = v102;
  v54 = v103;
  sub_100034C68((uint64_t)v101, v102);
  v55 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v53, v54);
  v56 = v102;
  v57 = v103;
  sub_100034C68((uint64_t)v101, v102);
  v58 = UnkeyedDecodingContainer.decodeData(with:)(v55, v56, v57);
  v60 = v59;
  v61 = v95;
  static String.Encoding.utf8.getter(v58);
  v62 = String.init(data:encoding:)(v58, v60, v61);
  v95 = v63;
  sub_10000E614(v58, v60);
  v64 = v95;
  *(_QWORD *)(v26 + 40) = v62;
  *(_QWORD *)(v26 + 48) = v64;
  if ((v25 & 0x1000) != 0)
    goto LABEL_20;
LABEL_16:
  *(_BYTE *)(v26 + 63) = 0;
  *(_BYTE *)(v26 + 65) = 0;
  if ((v25 & 0x80000000) != 0)
    goto LABEL_21;
LABEL_17:
  *(_WORD *)(v26 + 92) = 0;
  *(_QWORD *)(v26 + 84) = 0;
LABEL_18:
  v52 = v98;
  sub_100014430(v101);
  sub_1000637E0(v26, v18, type metadata accessor for AWDLActionFrame.DataPathState);
  sub_100014430(v52);
  return sub_100063824(v26, type metadata accessor for AWDLActionFrame.DataPathState);
}

uint64_t sub_1000D129C(unsigned __int16 *a1)
{
  return AWDLActionFrame.DataPathState.encode(to:)(a1);
}

uint64_t AWDLActionFrame.DataPathState.encode(to:)(unsigned __int16 *a1)
{
  unsigned __int16 *v1;
  unsigned __int16 *v2;
  uint64_t v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  int v9;
  int v10;
  int v11;
  char v12;
  BOOL v13;
  uint64_t v14;
  int v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unsigned __int16 *v24;
  unint64_t v25;
  ValueMetadata *v26;
  unint64_t v27;
  uint64_t v28;
  char v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  int8x16_t v33;
  uint64x2_t v34;
  int16x8_t v35;
  ValueMetadata *v36;
  unint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  unint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int8x16_t v51;
  uint64x2_t v52;
  int16x8_t v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  unint64_t v57;
  _QWORD *v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int8x16_t v67;
  uint64x2_t v68;
  int16x8_t v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  unint64_t v73;
  _QWORD *v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v78;
  unsigned __int16 *v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  uint64_t v83;
  ValueMetadata *v84;
  unint64_t v85;
  uint64_t v86;
  ValueMetadata *v87;
  unint64_t v88;
  uint64_t v89;
  uint64_t v90;
  unint64_t v91;
  unint64_t v92;
  uint64_t v93;
  int v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  ValueMetadata *v98;
  unint64_t v99;
  uint64_t v100;
  _QWORD *v101;
  int *v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  char *v106;
  char *v107;
  int v108;
  __int16 v109;
  _QWORD *v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  unint64_t v115;
  uint64_t v116;
  _OWORD *v117;
  uint64_t v118;
  uint64_t v119;
  unint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  unint64_t v124;
  uint64_t v125;
  unsigned int *v126;
  uint64_t v127;
  char *v128;
  uint64_t v129;
  ValueMetadata *v130;
  unint64_t v131;
  uint64_t v132;
  ValueMetadata *v133;
  unint64_t v134;
  uint64_t v135;
  ValueMetadata *v136;
  unint64_t v137;
  uint64_t v138;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  unsigned __int16 *v144;
  uint64_t v145;
  char *v146;
  char *v147;
  uint64_t v148;
  __int128 v149;
  _OWORD *v150;
  _BYTE v151[12];
  __int128 v152;
  _OWORD v153[2];
  _WORD v154[12];
  _QWORD v155[3];
  uint64_t v156;
  uint64_t v157;
  _QWORD v158[3];
  ValueMetadata *v159;
  unint64_t v160;
  uint64_t v161;
  ValueMetadata *v162;
  unint64_t v163;

  v2 = v1;
  sub_100012C44(&qword_100407210);
  __chkstk_darwin();
  v5 = (char *)&v143 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  v6 = type metadata accessor for DispatchTimeInterval(0);
  __chkstk_darwin();
  v146 = (char *)&v143 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  v8 = *((_BYTE *)v2 + 78);
  v9 = *((unsigned __int8 *)v2 + 94);
  v10 = *((unsigned __int8 *)v2 + 79);
  v11 = *((unsigned __int8 *)v2 + 80);
  v12 = *((_BYTE *)v2 + 81);
  v13 = *((_BYTE *)v2 + 77) == 1;
  v148 = v14;
  v147 = v5;
  if (!v13)
  {
    if ((v8 & 1) != 0)
    {
      if ((v9 & 1) != 0)
      {
        if (v10)
        {
          if (v11)
          {
            if ((v12 & 1) != 0)
            {
              v15 = 3280;
              goto LABEL_97;
            }
            if ((v2[41] & 1) != 0)
            {
              v15 = 1232;
              goto LABEL_98;
            }
            v15 = 1232;
            if ((*((_BYTE *)v2 + 83) & 1) == 0)
              goto LABEL_101;
LABEL_100:
            v15 |= 0x4000u;
            goto LABEL_101;
          }
          if ((v12 & 1) == 0)
          {
            if ((v2[41] & 1) != 0)
            {
              v15 = 208;
              goto LABEL_98;
            }
            v15 = 208;
            if ((*((_BYTE *)v2 + 83) & 1) == 0)
              goto LABEL_101;
            goto LABEL_100;
          }
          v15 = 2256;
        }
        else if (v11)
        {
          if ((v12 & 1) == 0)
          {
            if ((v2[41] & 1) != 0)
            {
              v15 = 1104;
              goto LABEL_98;
            }
            v15 = 1104;
            if ((*((_BYTE *)v2 + 83) & 1) == 0)
              goto LABEL_101;
            goto LABEL_100;
          }
          v15 = 3152;
        }
        else
        {
          if ((v12 & 1) == 0)
          {
            if ((v2[41] & 1) != 0)
            {
              v15 = 80;
              goto LABEL_98;
            }
            v15 = 80;
            if ((*((_BYTE *)v2 + 83) & 1) == 0)
              goto LABEL_101;
            goto LABEL_100;
          }
          v15 = 2128;
        }
      }
      else if (v10)
      {
        if (v11)
        {
          if ((v12 & 1) == 0)
          {
            if ((v2[41] & 1) != 0)
            {
              v15 = 1216;
              goto LABEL_98;
            }
            v15 = 1216;
            if ((*((_BYTE *)v2 + 83) & 1) == 0)
              goto LABEL_101;
            goto LABEL_100;
          }
          v15 = 3264;
        }
        else
        {
          if ((v12 & 1) == 0)
          {
            if ((v2[41] & 1) != 0)
            {
              v15 = 192;
              goto LABEL_98;
            }
            v15 = 192;
            if ((*((_BYTE *)v2 + 83) & 1) == 0)
              goto LABEL_101;
            goto LABEL_100;
          }
          v15 = 2240;
        }
      }
      else if (v11)
      {
        if ((v12 & 1) == 0)
        {
          if ((v2[41] & 1) != 0)
          {
            v15 = 1088;
            goto LABEL_98;
          }
          v15 = 1088;
          if ((*((_BYTE *)v2 + 83) & 1) == 0)
            goto LABEL_101;
          goto LABEL_100;
        }
        v15 = 3136;
      }
      else
      {
        if ((v12 & 1) == 0)
        {
          if ((v2[41] & 1) != 0)
          {
            v15 = 64;
            goto LABEL_98;
          }
          v15 = 64;
          if ((*((_BYTE *)v2 + 83) & 1) == 0)
            goto LABEL_101;
          goto LABEL_100;
        }
        v15 = 2112;
      }
    }
    else if (v9)
    {
      if ((v10 & 1) != 0)
      {
        if ((v11 & 1) != 0)
        {
          if ((v12 & 1) == 0)
          {
            if ((v2[41] & 1) != 0)
            {
              v15 = 1168;
              goto LABEL_98;
            }
            v15 = 1168;
            if ((*((_BYTE *)v2 + 83) & 1) == 0)
              goto LABEL_101;
            goto LABEL_100;
          }
          v15 = 3216;
        }
        else
        {
          if ((v12 & 1) == 0)
          {
            if ((v2[41] & 1) != 0)
            {
              v15 = 144;
              goto LABEL_98;
            }
            v15 = 144;
            if ((*((_BYTE *)v2 + 83) & 1) == 0)
              goto LABEL_101;
            goto LABEL_100;
          }
          v15 = 2192;
        }
      }
      else if ((v11 & 1) != 0)
      {
        if ((v12 & 1) == 0)
        {
          if ((v2[41] & 1) != 0)
          {
            v15 = 1040;
            goto LABEL_98;
          }
          v15 = 1040;
          if ((*((_BYTE *)v2 + 83) & 1) == 0)
            goto LABEL_101;
          goto LABEL_100;
        }
        v15 = 3088;
      }
      else
      {
        if ((v12 & 1) == 0)
        {
          if ((v2[41] & 1) != 0)
          {
            v15 = 16;
            goto LABEL_98;
          }
          v15 = 16;
          if ((*((_BYTE *)v2 + 83) & 1) == 0)
            goto LABEL_101;
          goto LABEL_100;
        }
        v15 = 2064;
      }
    }
    else if (v10)
    {
      if (v11)
      {
        if ((v12 & 1) == 0)
        {
          if ((v2[41] & 1) != 0)
          {
            v15 = 1152;
            goto LABEL_98;
          }
          v15 = 1152;
          if ((*((_BYTE *)v2 + 83) & 1) == 0)
            goto LABEL_101;
          goto LABEL_100;
        }
        v15 = 3200;
      }
      else
      {
        if ((v12 & 1) == 0)
        {
          if ((v2[41] & 1) != 0)
          {
            v15 = 128;
            goto LABEL_98;
          }
          v15 = 128;
          if ((*((_BYTE *)v2 + 83) & 1) == 0)
            goto LABEL_101;
          goto LABEL_100;
        }
        v15 = 2176;
      }
    }
    else if (v11)
    {
      if ((v12 & 1) == 0)
      {
        if ((v2[41] & 1) != 0)
        {
          v15 = 1024;
          goto LABEL_98;
        }
        v15 = 1024;
        if ((*((_BYTE *)v2 + 83) & 1) == 0)
          goto LABEL_101;
        goto LABEL_100;
      }
      v15 = 3072;
    }
    else
    {
      if ((v12 & 1) == 0)
      {
        if ((v2[41] & 1) != 0)
        {
          v15 = 0;
          goto LABEL_98;
        }
        v15 = 0;
        if ((*((_BYTE *)v2 + 83) & 1) == 0)
          goto LABEL_101;
        goto LABEL_100;
      }
      v15 = 2048;
    }
    goto LABEL_97;
  }
  if ((v8 & 1) == 0)
  {
    if ((v9 & 1) != 0)
    {
      if ((v10 & 1) != 0)
      {
        if (v11)
        {
          if ((v12 & 1) == 0)
          {
            if ((v2[41] & 1) != 0)
            {
              v15 = 1200;
              goto LABEL_98;
            }
            v15 = 1200;
            if ((*((_BYTE *)v2 + 83) & 1) == 0)
              goto LABEL_101;
            goto LABEL_100;
          }
          v15 = 3248;
        }
        else
        {
          if ((v12 & 1) == 0)
          {
            if ((v2[41] & 1) != 0)
            {
              v15 = 176;
              goto LABEL_98;
            }
            v15 = 176;
            if ((*((_BYTE *)v2 + 83) & 1) == 0)
              goto LABEL_101;
            goto LABEL_100;
          }
          v15 = 2224;
        }
      }
      else if (v11)
      {
        if ((v12 & 1) == 0)
        {
          if ((v2[41] & 1) != 0)
          {
            v15 = 1072;
            goto LABEL_98;
          }
          v15 = 1072;
          if ((*((_BYTE *)v2 + 83) & 1) == 0)
            goto LABEL_101;
          goto LABEL_100;
        }
        v15 = 3120;
      }
      else
      {
        if ((v12 & 1) == 0)
        {
          if ((v2[41] & 1) != 0)
          {
            v15 = 48;
            goto LABEL_98;
          }
          v15 = 48;
          if ((*((_BYTE *)v2 + 83) & 1) == 0)
            goto LABEL_101;
          goto LABEL_100;
        }
        v15 = 2096;
      }
    }
    else if (v10)
    {
      if (v11)
      {
        if ((v12 & 1) == 0)
        {
          if ((v2[41] & 1) != 0)
          {
            v15 = 1184;
            goto LABEL_98;
          }
          v15 = 1184;
          if ((*((_BYTE *)v2 + 83) & 1) == 0)
            goto LABEL_101;
          goto LABEL_100;
        }
        v15 = 3232;
      }
      else
      {
        if ((v12 & 1) == 0)
        {
          if ((v2[41] & 1) != 0)
          {
            v15 = 160;
            goto LABEL_98;
          }
          v15 = 160;
          if ((*((_BYTE *)v2 + 83) & 1) == 0)
            goto LABEL_101;
          goto LABEL_100;
        }
        v15 = 2208;
      }
    }
    else if (v11)
    {
      if ((v12 & 1) == 0)
      {
        if ((v2[41] & 1) != 0)
        {
          v15 = 1056;
          goto LABEL_98;
        }
        v15 = 1056;
        if ((*((_BYTE *)v2 + 83) & 1) == 0)
          goto LABEL_101;
        goto LABEL_100;
      }
      v15 = 3104;
    }
    else
    {
      if ((v12 & 1) == 0)
      {
        if ((v2[41] & 1) != 0)
        {
          v15 = 32;
          goto LABEL_98;
        }
        v15 = 32;
        if ((*((_BYTE *)v2 + 83) & 1) == 0)
          goto LABEL_101;
        goto LABEL_100;
      }
      v15 = 2080;
    }
LABEL_97:
    if ((v2[41] & 1) == 0)
      goto LABEL_99;
    goto LABEL_98;
  }
  if (!v9)
  {
    if (v10)
    {
      if (v11)
      {
        if ((v12 & 1) == 0)
        {
          if ((v2[41] & 1) != 0)
          {
            v15 = 1248;
            goto LABEL_98;
          }
          v15 = 1248;
          if ((*((_BYTE *)v2 + 83) & 1) == 0)
            goto LABEL_101;
          goto LABEL_100;
        }
        v15 = 3296;
      }
      else
      {
        if ((v12 & 1) == 0)
        {
          if ((v2[41] & 1) != 0)
          {
            v15 = 224;
            goto LABEL_98;
          }
          v15 = 224;
          if ((*((_BYTE *)v2 + 83) & 1) == 0)
            goto LABEL_101;
          goto LABEL_100;
        }
        v15 = 2272;
      }
    }
    else if (v11)
    {
      if ((v12 & 1) == 0)
      {
        if ((v2[41] & 1) != 0)
        {
          v15 = 1120;
          goto LABEL_98;
        }
        v15 = 1120;
        if ((*((_BYTE *)v2 + 83) & 1) == 0)
          goto LABEL_101;
        goto LABEL_100;
      }
      v15 = 3168;
    }
    else
    {
      if ((v12 & 1) == 0)
      {
        if ((v2[41] & 1) != 0)
        {
          v15 = 96;
          goto LABEL_98;
        }
        v15 = 96;
        if ((*((_BYTE *)v2 + 83) & 1) == 0)
          goto LABEL_101;
        goto LABEL_100;
      }
      v15 = 2144;
    }
    goto LABEL_97;
  }
  if (!v10)
  {
    if (v11)
    {
      if ((v12 & 1) == 0)
      {
        if ((v2[41] & 1) != 0)
        {
          v15 = 1136;
          goto LABEL_98;
        }
        v15 = 1136;
        if ((*((_BYTE *)v2 + 83) & 1) == 0)
          goto LABEL_101;
        goto LABEL_100;
      }
      v15 = 3184;
    }
    else
    {
      if ((v12 & 1) == 0)
      {
        if ((v2[41] & 1) != 0)
        {
          v15 = 112;
          goto LABEL_98;
        }
        v15 = 112;
        if ((*((_BYTE *)v2 + 83) & 1) == 0)
          goto LABEL_101;
        goto LABEL_100;
      }
      v15 = 2160;
    }
    goto LABEL_97;
  }
  if (!v11)
  {
    if ((v12 & 1) == 0)
    {
      if ((v2[41] & 1) != 0)
      {
        v15 = 240;
        goto LABEL_98;
      }
      v15 = 240;
      if ((*((_BYTE *)v2 + 83) & 1) == 0)
        goto LABEL_101;
      goto LABEL_100;
    }
    v15 = 2288;
    goto LABEL_97;
  }
  if ((v12 & 1) != 0)
  {
    v15 = 3312;
    goto LABEL_97;
  }
  if ((v2[41] & 1) != 0)
  {
    v15 = 1264;
LABEL_98:
    v15 |= 0x2000u;
LABEL_99:
    if (*((_BYTE *)v2 + 83) != 1)
      goto LABEL_101;
    goto LABEL_100;
  }
  v15 = 1264;
  if ((*((_BYTE *)v2 + 83) & 1) != 0)
    goto LABEL_100;
LABEL_101:
  *(_DWORD *)v151 = v15;
  v16 = sub_1000B3428(0);
  v17 = sub_10001F11C(v16);
  v18 = type metadata accessor for BinaryEncoder();
  v19 = swift_allocObject(v18, 40, 7);
  v149 = xmmword_10033A100;
  *(_OWORD *)(v19 + 16) = xmmword_10033A100;
  v150 = (_OWORD *)(v19 + 16);
  *(_QWORD *)(v19 + 32) = v17;
  v162 = &type metadata for BinaryEncoder.UnkeyedContainer;
  v20 = sub_100079B58();
  v21 = v20;
  v163 = v20;
  v161 = v19;
  if ((v2[1] & 1) != 0)
  {
    swift_retain();
  }
  else
  {
    v78 = v6;
    v79 = a1;
    v80 = *v2;
    v81 = v20;
    sub_100034C68((uint64_t)&v161, (uint64_t)&type metadata for BinaryEncoder.UnkeyedContainer);
    swift_retain();
    v82 = *(_QWORD *)&v151[4];
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v80, &type metadata for BinaryEncoder.UnkeyedContainer, v81);
    *(_QWORD *)&v151[4] = v82;
    if (v82)
      goto LABEL_121;
    v83 = v80 >> 8;
    v84 = v162;
    v85 = v163;
    sub_100034C68((uint64_t)&v161, (uint64_t)v162);
    v86 = *(_QWORD *)&v151[4];
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v83, v84, v85);
    *(_QWORD *)&v151[4] = v86;
    if (v86)
      goto LABEL_121;
    v87 = v162;
    v88 = v163;
    sub_100034C68((uint64_t)&v161, (uint64_t)v162);
    v89 = *(_QWORD *)&v151[4];
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(0, v87, v88);
    *(_QWORD *)&v151[4] = v89;
    if (v89)
      goto LABEL_121;
    *(_QWORD *)v151 = *(_DWORD *)v151 | 0x100u;
    v21 = v81;
    a1 = v79;
    v6 = v78;
  }
  v22 = *((unsigned int *)v2 + 1) | ((unint64_t)v2[4] << 32);
  if ((v22 & 0xFF00000000) == 0x300000000)
    goto LABEL_107;
  v144 = v2;
  if ((v22 & 0xFFFF0000) != 0)
    goto LABEL_645;
  v23 = v6;
  v24 = a1;
  v25 = v21;
  v26 = v162;
  v27 = v163;
  sub_100034C68((uint64_t)&v161, (uint64_t)v162);
  v28 = *(_QWORD *)&v151[4];
  dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v22, v26, v27);
  *(_QWORD *)&v151[4] = v28;
  if (!v28)
  {
    *(_QWORD *)v151 = *(_DWORD *)v151 | 0x200u;
    v21 = v25;
    a1 = v24;
    v6 = v23;
    v2 = v144;
LABEL_107:
    v29 = *((_BYTE *)v2 + 16);
    v144 = a1;
    v145 = v21;
    if ((v29 & 1) != 0
      || (v30 = *((unsigned int *)v2 + 5) | ((unint64_t)v2[12] << 32), (v30 & 0xFF00000000) == 0x300000000))
    {
LABEL_112:
      if ((v2[16] & 1) == 0)
      {
        v43 = v2[15];
        v44 = *(unsigned int *)(v2 + 13);
        v45 = v44 | (v43 << 32);
        v159 = &type metadata for BinaryEncoder.UnkeyedContainer;
        v160 = v21;
        v46 = v43 >> 8;
        *(_DWORD *)v151 |= 2u;
        v158[0] = v19;
        v47 = sub_100012C44(&qword_100403E88);
        v48 = swift_allocObject(v47, 38, 7);
        v49 = sub_10021BCF8(v48, 6);
        *(_BYTE *)v50 = v44;
        v51.i64[0] = 0xFFFFFFFFFFFFLL;
        v51.i64[1] = 0xFFFFFFFFFFFFLL;
        v52 = (uint64x2_t)vandq_s8((int8x16_t)vdupq_n_s64(v45), v51);
        v53 = (int16x8_t)vshlq_u64(v52, (uint64x2_t)xmmword_10033B100);
        *(int32x2_t *)v52.i8 = vmovn_s64((int64x2_t)vshlq_u64(v52, (uint64x2_t)xmmword_10033B0F0));
        *(int32x2_t *)v53.i8 = vmovn_s64((int64x2_t)v53);
        v53.i16[1] = v53.i16[2];
        v53.i16[2] = v52.i16[0];
        v53.i16[3] = v52.i16[2];
        *(_DWORD *)(v50 + 1) = vmovn_s16(v53).u32[0];
        *(_BYTE *)(v50 + 5) = v46;
        v54 = NANBitmap.Channel.operatingClass.getter(v49);
        swift_retain_n(v19, 2);
        v55 = sub_1001068EC(v54);
        v57 = v56;
        swift_bridgeObjectRelease(v54);
        v58 = (_QWORD *)sub_100034C68((uint64_t)v158, (uint64_t)v159);
        swift_beginAccess(*v58 + 16, v155, 33, 0);
        sub_1000FBDAC(v55, v57);
        swift_endAccess(v155);
        sub_10000E614(v55, v57);
        sub_100014430(v158);
        swift_release(v19);
      }
      if ((v2[31] & 1) == 0)
      {
        v59 = v2[30];
        v60 = *((unsigned int *)v2 + 14);
        v61 = v60 | (v59 << 32);
        v159 = &type metadata for BinaryEncoder.UnkeyedContainer;
        v160 = v145;
        v62 = v59 >> 8;
        *(_DWORD *)v151 |= 4u;
        v158[0] = v19;
        v63 = sub_100012C44(&qword_100403E88);
        v64 = swift_allocObject(v63, 38, 7);
        v65 = sub_10021BCF8(v64, 6);
        *(_BYTE *)v66 = v60;
        v67.i64[0] = 0xFFFFFFFFFFFFLL;
        v67.i64[1] = 0xFFFFFFFFFFFFLL;
        v68 = (uint64x2_t)vandq_s8((int8x16_t)vdupq_n_s64(v61), v67);
        v69 = (int16x8_t)vshlq_u64(v68, (uint64x2_t)xmmword_10033B100);
        *(int32x2_t *)v68.i8 = vmovn_s64((int64x2_t)vshlq_u64(v68, (uint64x2_t)xmmword_10033B0F0));
        *(int32x2_t *)v69.i8 = vmovn_s64((int64x2_t)v69);
        v69.i16[1] = v69.i16[2];
        v69.i16[2] = v68.i16[0];
        v69.i16[3] = v68.i16[2];
        *(_DWORD *)(v66 + 1) = vmovn_s16(v69).u32[0];
        *(_BYTE *)(v66 + 5) = v62;
        v70 = NANBitmap.Channel.operatingClass.getter(v65);
        swift_retain_n(v19, 2);
        v71 = sub_1001068EC(v70);
        v73 = v72;
        swift_bridgeObjectRelease(v70);
        v74 = (_QWORD *)sub_100034C68((uint64_t)v158, (uint64_t)v159);
        swift_beginAccess(*v74 + 16, v155, 33, 0);
        sub_1000FBDAC(v71, v73);
        swift_endAccess(v155);
        sub_10000E614(v71, v73);
        sub_100014430(v158);
        swift_release(v19);
      }
      v75 = *((_QWORD *)v2 + 6);
      v143 = v6;
      if (v75)
      {
        v76 = *((_QWORD *)v2 + 5);
        swift_bridgeObjectRetain(v75);
        sub_1000FAE78(v76, v75);
        *(_DWORD *)v151 |= 8u;
        __asm { BR              X11 }
      }
      if (*((_BYTE *)v2 + 63) == 1)
      {
        *(_DWORD *)v151 |= 0x1000u;
        __asm { BR              X10 }
      }
      v90 = v145;
      v91 = sub_1000B3428(0);
      v92 = sub_10001F11C(v91);
      v93 = swift_allocObject(v18, 40, 7);
      *(_OWORD *)(v93 + 16) = v149;
      *(_QWORD *)(v93 + 32) = v92;
      v159 = &type metadata for BinaryEncoder.UnkeyedContainer;
      v160 = v90;
      v158[0] = v93;
      if (*((_BYTE *)v2 + 84) == 1)
      {
        if ((*((_BYTE *)v2 + 85) & 1) != 0)
        {
          if (*((_BYTE *)v2 + 87))
          {
            if (*((_BYTE *)v2 + 89))
            {
              if (*((_BYTE *)v2 + 86))
              {
                if ((v2[44] & 1) != 0)
                {
                  v94 = 474;
                  goto LABEL_348;
                }
                if ((v2[45] & 1) != 0)
                {
                  v94 = 346;
LABEL_349:
                  v94 |= 0x200u;
LABEL_350:
                  if (*((_BYTE *)v2 + 91) != 1)
                    goto LABEL_352;
                  goto LABEL_351;
                }
                if ((*((_BYTE *)v2 + 91) & 1) != 0)
                {
                  v94 = 346;
LABEL_351:
                  v94 |= 0x800u;
LABEL_352:
                  if (*((_BYTE *)v2 + 92) != 1)
                    goto LABEL_354;
                  goto LABEL_353;
                }
                if ((v2[46] & 1) != 0)
                {
                  v94 = 346;
LABEL_353:
                  v94 |= 0x1000u;
LABEL_354:
                  if (*((_BYTE *)v2 + 93) != 1)
                    goto LABEL_356;
                  goto LABEL_355;
                }
                v94 = 346;
                if ((*((_BYTE *)v2 + 93) & 1) == 0)
                  goto LABEL_356;
                goto LABEL_355;
              }
              if ((v2[44] & 1) == 0)
              {
                if ((v2[45] & 1) != 0)
                {
                  v94 = 344;
                  goto LABEL_349;
                }
                if ((*((_BYTE *)v2 + 91) & 1) != 0)
                {
                  v94 = 344;
                  goto LABEL_351;
                }
                if ((v2[46] & 1) != 0)
                {
                  v94 = 344;
                  goto LABEL_353;
                }
                v94 = 344;
                if ((*((_BYTE *)v2 + 93) & 1) == 0)
                  goto LABEL_356;
                goto LABEL_355;
              }
              v94 = 472;
            }
            else if (*((_BYTE *)v2 + 86))
            {
              if ((v2[44] & 1) == 0)
              {
                if ((v2[45] & 1) != 0)
                {
                  v94 = 90;
                  goto LABEL_349;
                }
                if ((*((_BYTE *)v2 + 91) & 1) != 0)
                {
                  v94 = 90;
                  goto LABEL_351;
                }
                if ((v2[46] & 1) != 0)
                {
                  v94 = 90;
                  goto LABEL_353;
                }
                v94 = 90;
                if ((*((_BYTE *)v2 + 93) & 1) == 0)
                  goto LABEL_356;
                goto LABEL_355;
              }
              v94 = 218;
            }
            else
            {
              if ((v2[44] & 1) == 0)
              {
                if ((v2[45] & 1) != 0)
                {
                  v94 = 88;
                  goto LABEL_349;
                }
                if ((*((_BYTE *)v2 + 91) & 1) != 0)
                {
                  v94 = 88;
                  goto LABEL_351;
                }
                if ((v2[46] & 1) != 0)
                {
                  v94 = 88;
                  goto LABEL_353;
                }
                v94 = 88;
                if ((*((_BYTE *)v2 + 93) & 1) == 0)
                  goto LABEL_356;
                goto LABEL_355;
              }
              v94 = 216;
            }
          }
          else if (*((_BYTE *)v2 + 89))
          {
            if (*((_BYTE *)v2 + 86))
            {
              if ((v2[44] & 1) == 0)
              {
                if ((v2[45] & 1) != 0)
                {
                  v94 = 338;
                  goto LABEL_349;
                }
                if ((*((_BYTE *)v2 + 91) & 1) != 0)
                {
                  v94 = 338;
                  goto LABEL_351;
                }
                if ((v2[46] & 1) != 0)
                {
                  v94 = 338;
                  goto LABEL_353;
                }
                v94 = 338;
                if ((*((_BYTE *)v2 + 93) & 1) == 0)
                  goto LABEL_356;
                goto LABEL_355;
              }
              v94 = 466;
            }
            else
            {
              if ((v2[44] & 1) == 0)
              {
                if ((v2[45] & 1) != 0)
                {
                  v94 = 336;
                  goto LABEL_349;
                }
                if ((*((_BYTE *)v2 + 91) & 1) != 0)
                {
                  v94 = 336;
                  goto LABEL_351;
                }
                if ((v2[46] & 1) != 0)
                {
                  v94 = 336;
                  goto LABEL_353;
                }
                v94 = 336;
                if ((*((_BYTE *)v2 + 93) & 1) == 0)
                  goto LABEL_356;
                goto LABEL_355;
              }
              v94 = 464;
            }
          }
          else if (*((_BYTE *)v2 + 86))
          {
            if ((v2[44] & 1) == 0)
            {
              if ((v2[45] & 1) != 0)
              {
                v94 = 82;
                goto LABEL_349;
              }
              if ((*((_BYTE *)v2 + 91) & 1) != 0)
              {
                v94 = 82;
                goto LABEL_351;
              }
              if ((v2[46] & 1) != 0)
              {
                v94 = 82;
                goto LABEL_353;
              }
              v94 = 82;
              if ((*((_BYTE *)v2 + 93) & 1) == 0)
                goto LABEL_356;
              goto LABEL_355;
            }
            v94 = 210;
          }
          else
          {
            if ((v2[44] & 1) == 0)
            {
              if ((v2[45] & 1) != 0)
              {
                v94 = 80;
                goto LABEL_349;
              }
              if ((*((_BYTE *)v2 + 91) & 1) != 0)
              {
                v94 = 80;
                goto LABEL_351;
              }
              if ((v2[46] & 1) != 0)
              {
                v94 = 80;
                goto LABEL_353;
              }
              v94 = 80;
              if ((*((_BYTE *)v2 + 93) & 1) == 0)
                goto LABEL_356;
              goto LABEL_355;
            }
            v94 = 208;
          }
        }
        else if ((*((_BYTE *)v2 + 87) & 1) != 0)
        {
          if ((*((_BYTE *)v2 + 89) & 1) != 0)
          {
            if (*((_BYTE *)v2 + 86))
            {
              if ((v2[44] & 1) == 0)
              {
                if ((v2[45] & 1) != 0)
                {
                  v94 = 282;
                  goto LABEL_349;
                }
                if ((*((_BYTE *)v2 + 91) & 1) != 0)
                {
                  v94 = 282;
                  goto LABEL_351;
                }
                if ((v2[46] & 1) != 0)
                {
                  v94 = 282;
                  goto LABEL_353;
                }
                v94 = 282;
                if ((*((_BYTE *)v2 + 93) & 1) == 0)
                  goto LABEL_356;
                goto LABEL_355;
              }
              v94 = 410;
            }
            else
            {
              if ((v2[44] & 1) == 0)
              {
                if ((v2[45] & 1) != 0)
                {
                  v94 = 280;
                  goto LABEL_349;
                }
                if ((*((_BYTE *)v2 + 91) & 1) != 0)
                {
                  v94 = 280;
                  goto LABEL_351;
                }
                if ((v2[46] & 1) != 0)
                {
                  v94 = 280;
                  goto LABEL_353;
                }
                v94 = 280;
                if ((*((_BYTE *)v2 + 93) & 1) == 0)
                  goto LABEL_356;
                goto LABEL_355;
              }
              v94 = 408;
            }
          }
          else if (*((_BYTE *)v2 + 86))
          {
            if ((v2[44] & 1) == 0)
            {
              if ((v2[45] & 1) != 0)
              {
                v94 = 26;
                goto LABEL_349;
              }
              if ((*((_BYTE *)v2 + 91) & 1) != 0)
              {
                v94 = 26;
                goto LABEL_351;
              }
              if ((v2[46] & 1) != 0)
              {
                v94 = 26;
                goto LABEL_353;
              }
              v94 = 26;
              if ((*((_BYTE *)v2 + 93) & 1) == 0)
                goto LABEL_356;
              goto LABEL_355;
            }
            v94 = 154;
          }
          else
          {
            if ((v2[44] & 1) == 0)
            {
              if ((v2[45] & 1) != 0)
              {
                v94 = 24;
                goto LABEL_349;
              }
              if ((*((_BYTE *)v2 + 91) & 1) != 0)
              {
                v94 = 24;
                goto LABEL_351;
              }
              if ((v2[46] & 1) != 0)
              {
                v94 = 24;
                goto LABEL_353;
              }
              v94 = 24;
              if ((*((_BYTE *)v2 + 93) & 1) == 0)
                goto LABEL_356;
              goto LABEL_355;
            }
            v94 = 152;
          }
        }
        else if (*((_BYTE *)v2 + 89))
        {
          if (*((_BYTE *)v2 + 86))
          {
            if ((v2[44] & 1) == 0)
            {
              if ((v2[45] & 1) != 0)
              {
                v94 = 274;
                goto LABEL_349;
              }
              if ((*((_BYTE *)v2 + 91) & 1) != 0)
              {
                v94 = 274;
                goto LABEL_351;
              }
              if ((v2[46] & 1) != 0)
              {
                v94 = 274;
                goto LABEL_353;
              }
              v94 = 274;
              if ((*((_BYTE *)v2 + 93) & 1) == 0)
                goto LABEL_356;
              goto LABEL_355;
            }
            v94 = 402;
          }
          else
          {
            if ((v2[44] & 1) == 0)
            {
              if ((v2[45] & 1) != 0)
              {
                v94 = 272;
                goto LABEL_349;
              }
              if ((*((_BYTE *)v2 + 91) & 1) != 0)
              {
                v94 = 272;
                goto LABEL_351;
              }
              if ((v2[46] & 1) != 0)
              {
                v94 = 272;
                goto LABEL_353;
              }
              v94 = 272;
              if ((*((_BYTE *)v2 + 93) & 1) == 0)
                goto LABEL_356;
              goto LABEL_355;
            }
            v94 = 400;
          }
        }
        else if (*((_BYTE *)v2 + 86))
        {
          if ((v2[44] & 1) == 0)
          {
            if ((v2[45] & 1) != 0)
            {
              v94 = 18;
              goto LABEL_349;
            }
            if ((*((_BYTE *)v2 + 91) & 1) != 0)
            {
              v94 = 18;
              goto LABEL_351;
            }
            if ((v2[46] & 1) != 0)
            {
              v94 = 18;
              goto LABEL_353;
            }
            v94 = 18;
            if ((*((_BYTE *)v2 + 93) & 1) == 0)
              goto LABEL_356;
            goto LABEL_355;
          }
          v94 = 146;
        }
        else
        {
          if ((v2[44] & 1) == 0)
          {
            if ((v2[45] & 1) != 0)
            {
              v94 = 16;
              goto LABEL_349;
            }
            if ((*((_BYTE *)v2 + 91) & 1) != 0)
            {
              v94 = 16;
              goto LABEL_351;
            }
            if ((v2[46] & 1) != 0)
            {
              v94 = 16;
              goto LABEL_353;
            }
            v94 = 16;
            if ((*((_BYTE *)v2 + 93) & 1) == 0)
              goto LABEL_356;
            goto LABEL_355;
          }
          v94 = 144;
        }
      }
      else if ((*((_BYTE *)v2 + 85) & 1) != 0)
      {
        if ((*((_BYTE *)v2 + 87) & 1) != 0)
        {
          if (*((_BYTE *)v2 + 89))
          {
            if (*((_BYTE *)v2 + 86))
            {
              if ((v2[44] & 1) == 0)
              {
                if ((v2[45] & 1) != 0)
                {
                  v94 = 330;
                  goto LABEL_349;
                }
                if ((*((_BYTE *)v2 + 91) & 1) != 0)
                {
                  v94 = 330;
                  goto LABEL_351;
                }
                if ((v2[46] & 1) != 0)
                {
                  v94 = 330;
                  goto LABEL_353;
                }
                v94 = 330;
                if ((*((_BYTE *)v2 + 93) & 1) == 0)
                {
LABEL_356:
                  if (*((_BYTE *)v2 + 68) == 1)
                  {
                    swift_retain();
                    if ((v2[38] & 1) != 0)
                    {
LABEL_358:
                      *(_QWORD *)&v149 = v93;
LABEL_363:
                      v101 = v144;
                      v145 = v93 + 16;
                      v102 = (int *)type metadata accessor for AWDLActionFrame.DataPathState(0);
                      v103 = (uint64_t)v147;
                      sub_1000E7054((uint64_t)v2 + v102[34], (uint64_t)v147);
                      v104 = v148;
                      v105 = v143;
                      if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v148 + 48))(v103, 1, v143) == 1)
                      {
                        sub_100033A84(v103, &qword_100407210);
LABEL_367:
                        v93 = v149;
                        v108 = v94;
LABEL_368:
                        if (v108)
                          v109 = *(_WORD *)v151 | 0x8000;
                        else
                          v109 = *(_WORD *)v151;
                        v110 = v101;
                        v111 = v101[3];
                        v112 = v110[4];
                        sub_10003259C(v110, v111);
                        dispatch thunk of Encoder.unkeyedContainer()(v155, v111, v112);
                        v154[0] = v109;
                        v113 = v156;
                        v114 = v157;
                        sub_100034C68((uint64_t)v155, v156);
                        v115 = sub_1000E716C();
                        v116 = *(_QWORD *)&v151[4];
                        dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(v154, &type metadata for AWDLActionFrame.DataPathState.Flags, v115, v113, v114);
                        *(_QWORD *)&v151[4] = v116;
                        if (v116)
                          goto LABEL_375;
                        v117 = v150;
                        swift_beginAccess(v150, v154, 0, 0);
                        v153[0] = *v117;
                        v118 = v156;
                        v119 = v157;
                        sub_100034C68((uint64_t)v155, v156);
                        v120 = sub_100068570();
                        v121 = *(_QWORD *)&v151[4];
                        dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(v153, &type metadata for Data, v120, v118, v119);
                        *(_QWORD *)&v151[4] = v121;
                        if (v121)
                          goto LABEL_375;
                        if ((v109 & 0x8000) == 0)
                          goto LABEL_375;
                        LOWORD(v153[0]) = v108;
                        v122 = v156;
                        v123 = v157;
                        sub_100034C68((uint64_t)v155, v156);
                        v124 = sub_1000E71B0();
                        v125 = *(_QWORD *)&v151[4];
                        dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(v153, &type metadata for AWDLActionFrame.DataPathState.ExtensionFlags, v124, v122, v123);
                        *(_QWORD *)&v151[4] = v125;
                        if (v125)
                        {
LABEL_375:
                          swift_release(v19);
                          swift_release(v93);
                        }
                        else
                        {
                          swift_beginAccess(v145, v153, 0, 0);
                          v152 = *(_OWORD *)(v93 + 16);
                          v140 = v156;
                          v141 = v157;
                          sub_100034C68((uint64_t)v155, v156);
                          v142 = *(_QWORD *)&v151[4];
                          dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(&v152, &type metadata for Data, v120, v140, v141);
                          swift_release(v19);
                          swift_release(v93);
                          *(_QWORD *)&v151[4] = v142;
                        }
                        sub_100014430(v155);
                        goto LABEL_385;
                      }
                      v106 = v146;
                      (*(void (**)(char *, uint64_t, uint64_t))(v104 + 32))(v146, v103, v105);
                      v107 = (char *)v2 + v102[35];
                      if (v107[4] == 1)
                      {
                        (*(void (**)(char *, uint64_t))(v104 + 8))(v106, v105);
                        goto LABEL_367;
                      }
                      v126 = (unsigned int *)((char *)v2 + v102[36]);
                      v108 = v94;
                      if (*((_BYTE *)v126 + 4) == 1)
                      {
                        (*(void (**)(char *, uint64_t))(v104 + 8))(v146, v143);
                        v93 = v149;
                        goto LABEL_368;
                      }
                      LODWORD(v147) = *(_DWORD *)v107;
                      v127 = *v126;
                      v128 = v146;
                      v129 = ((int)sub_10017C64C() / 1000000);
                      v130 = v159;
                      v131 = v160;
                      sub_100034C68((uint64_t)v158, (uint64_t)v159);
                      v132 = *(_QWORD *)&v151[4];
                      dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v129, v130, v131);
                      v93 = v149;
                      *(_QWORD *)&v151[4] = v132;
                      if (v132)
                      {
                        (*(void (**)(char *, uint64_t))(v104 + 8))(v128, v143);
                      }
                      else
                      {
                        v133 = v159;
                        v134 = v160;
                        sub_100034C68((uint64_t)v158, (uint64_t)v159);
                        v135 = *(_QWORD *)&v151[4];
                        dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v147, v133, v134);
                        *(_QWORD *)&v151[4] = v135;
                        if (!v135)
                        {
                          v136 = v159;
                          v137 = v160;
                          sub_100034C68((uint64_t)v158, (uint64_t)v159);
                          v138 = *(_QWORD *)&v151[4];
                          dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v127, v136, v137);
                          *(_QWORD *)&v151[4] = v138;
                          if (!v138)
                          {
                            v108 |= 0x20u;
                            (*(void (**)(char *, uint64_t))(v104 + 8))(v146, v143);
                            v101 = v144;
                            goto LABEL_368;
                          }
                        }
                        (*(void (**)(char *, uint64_t))(v104 + 8))(v146, v143);
                      }
LABEL_384:
                      swift_release(v19);
                      swift_release(v93);
LABEL_385:
                      sub_100014430(v158);
                      return sub_100014430(&v161);
                    }
                  }
                  else
                  {
                    v95 = v2[33];
                    sub_100034C68((uint64_t)v158, (uint64_t)&type metadata for BinaryEncoder.UnkeyedContainer);
                    swift_retain();
                    v96 = *(_QWORD *)&v151[4];
                    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v95, &type metadata for BinaryEncoder.UnkeyedContainer, v90);
                    *(_QWORD *)&v151[4] = v96;
                    if (v96)
                      goto LABEL_384;
                    v94 |= 1u;
                    if ((v2[38] & 1) != 0)
                      goto LABEL_358;
                  }
                  v97 = *((unsigned int *)v2 + 18);
                  v98 = v159;
                  v99 = v160;
                  sub_100034C68((uint64_t)v158, (uint64_t)v159);
                  v100 = *(_QWORD *)&v151[4];
                  dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v97, v98, v99);
                  *(_QWORD *)&v151[4] = v100;
                  if (v100)
                    goto LABEL_384;
                  *(_QWORD *)&v149 = v93;
                  v94 |= 4u;
                  goto LABEL_363;
                }
LABEL_355:
                v94 |= 0x2000u;
                goto LABEL_356;
              }
              v94 = 458;
            }
            else
            {
              if ((v2[44] & 1) == 0)
              {
                if ((v2[45] & 1) != 0)
                {
                  v94 = 328;
                  goto LABEL_349;
                }
                if ((*((_BYTE *)v2 + 91) & 1) != 0)
                {
                  v94 = 328;
                  goto LABEL_351;
                }
                if ((v2[46] & 1) != 0)
                {
                  v94 = 328;
                  goto LABEL_353;
                }
                v94 = 328;
                if ((*((_BYTE *)v2 + 93) & 1) == 0)
                  goto LABEL_356;
                goto LABEL_355;
              }
              v94 = 456;
            }
          }
          else if (*((_BYTE *)v2 + 86))
          {
            if ((v2[44] & 1) == 0)
            {
              if ((v2[45] & 1) != 0)
              {
                v94 = 74;
                goto LABEL_349;
              }
              if ((*((_BYTE *)v2 + 91) & 1) != 0)
              {
                v94 = 74;
                goto LABEL_351;
              }
              if ((v2[46] & 1) != 0)
              {
                v94 = 74;
                goto LABEL_353;
              }
              v94 = 74;
              if ((*((_BYTE *)v2 + 93) & 1) == 0)
                goto LABEL_356;
              goto LABEL_355;
            }
            v94 = 202;
          }
          else
          {
            if ((v2[44] & 1) == 0)
            {
              if ((v2[45] & 1) != 0)
              {
                v94 = 72;
                goto LABEL_349;
              }
              if ((*((_BYTE *)v2 + 91) & 1) != 0)
              {
                v94 = 72;
                goto LABEL_351;
              }
              if ((v2[46] & 1) != 0)
              {
                v94 = 72;
                goto LABEL_353;
              }
              v94 = 72;
              if ((*((_BYTE *)v2 + 93) & 1) == 0)
                goto LABEL_356;
              goto LABEL_355;
            }
            v94 = 200;
          }
        }
        else if (*((_BYTE *)v2 + 89))
        {
          if (*((_BYTE *)v2 + 86))
          {
            if ((v2[44] & 1) == 0)
            {
              if ((v2[45] & 1) != 0)
              {
                v94 = 322;
                goto LABEL_349;
              }
              if ((*((_BYTE *)v2 + 91) & 1) != 0)
              {
                v94 = 322;
                goto LABEL_351;
              }
              if ((v2[46] & 1) != 0)
              {
                v94 = 322;
                goto LABEL_353;
              }
              v94 = 322;
              if ((*((_BYTE *)v2 + 93) & 1) == 0)
                goto LABEL_356;
              goto LABEL_355;
            }
            v94 = 450;
          }
          else
          {
            if ((v2[44] & 1) == 0)
            {
              if ((v2[45] & 1) != 0)
              {
                v94 = 320;
                goto LABEL_349;
              }
              if ((*((_BYTE *)v2 + 91) & 1) != 0)
              {
                v94 = 320;
                goto LABEL_351;
              }
              if ((v2[46] & 1) != 0)
              {
                v94 = 320;
                goto LABEL_353;
              }
              v94 = 320;
              if ((*((_BYTE *)v2 + 93) & 1) == 0)
                goto LABEL_356;
              goto LABEL_355;
            }
            v94 = 448;
          }
        }
        else if (*((_BYTE *)v2 + 86))
        {
          if ((v2[44] & 1) == 0)
          {
            if ((v2[45] & 1) != 0)
            {
              v94 = 66;
              goto LABEL_349;
            }
            if ((*((_BYTE *)v2 + 91) & 1) != 0)
            {
              v94 = 66;
              goto LABEL_351;
            }
            if ((v2[46] & 1) != 0)
            {
              v94 = 66;
              goto LABEL_353;
            }
            v94 = 66;
            if ((*((_BYTE *)v2 + 93) & 1) == 0)
              goto LABEL_356;
            goto LABEL_355;
          }
          v94 = 194;
        }
        else
        {
          if ((v2[44] & 1) == 0)
          {
            if ((v2[45] & 1) != 0)
            {
              v94 = 64;
              goto LABEL_349;
            }
            if ((*((_BYTE *)v2 + 91) & 1) != 0)
            {
              v94 = 64;
              goto LABEL_351;
            }
            if ((v2[46] & 1) != 0)
            {
              v94 = 64;
              goto LABEL_353;
            }
            v94 = 64;
            if ((*((_BYTE *)v2 + 93) & 1) == 0)
              goto LABEL_356;
            goto LABEL_355;
          }
          v94 = 192;
        }
      }
      else if (*((_BYTE *)v2 + 87))
      {
        if ((*((_BYTE *)v2 + 89) & 1) != 0)
        {
          if ((v2[43] & 1) != 0)
          {
            if ((v2[44] & 1) == 0)
            {
              if ((v2[45] & 1) != 0)
              {
                v94 = 266;
                goto LABEL_349;
              }
              if ((*((_BYTE *)v2 + 91) & 1) != 0)
              {
                v94 = 266;
                goto LABEL_351;
              }
              if ((v2[46] & 1) != 0)
              {
                v94 = 266;
                goto LABEL_353;
              }
              v94 = 266;
              if ((*((_BYTE *)v2 + 93) & 1) == 0)
                goto LABEL_356;
              goto LABEL_355;
            }
            v94 = 394;
          }
          else
          {
            if ((v2[44] & 1) == 0)
            {
              if ((v2[45] & 1) != 0)
              {
                v94 = 264;
                goto LABEL_349;
              }
              if ((*((_BYTE *)v2 + 91) & 1) != 0)
              {
                v94 = 264;
                goto LABEL_351;
              }
              if ((v2[46] & 1) != 0)
              {
                v94 = 264;
                goto LABEL_353;
              }
              v94 = 264;
              if ((*((_BYTE *)v2 + 93) & 1) == 0)
                goto LABEL_356;
              goto LABEL_355;
            }
            v94 = 392;
          }
        }
        else if ((v2[43] & 1) != 0)
        {
          if ((v2[44] & 1) == 0)
          {
            if ((v2[45] & 1) != 0)
            {
              v94 = 10;
              goto LABEL_349;
            }
            if ((*((_BYTE *)v2 + 91) & 1) != 0)
            {
              v94 = 10;
              goto LABEL_351;
            }
            if ((v2[46] & 1) != 0)
            {
              v94 = 10;
              goto LABEL_353;
            }
            v94 = 10;
            if ((*((_BYTE *)v2 + 93) & 1) == 0)
              goto LABEL_356;
            goto LABEL_355;
          }
          v94 = 138;
        }
        else
        {
          if ((v2[44] & 1) == 0)
          {
            if ((v2[45] & 1) != 0)
            {
              v94 = 8;
              goto LABEL_349;
            }
            if ((*((_BYTE *)v2 + 91) & 1) != 0)
            {
              v94 = 8;
              goto LABEL_351;
            }
            if ((v2[46] & 1) != 0)
            {
              v94 = 8;
              goto LABEL_353;
            }
            v94 = 8;
            if ((*((_BYTE *)v2 + 93) & 1) == 0)
              goto LABEL_356;
            goto LABEL_355;
          }
          v94 = 136;
        }
      }
      else if (*((_BYTE *)v2 + 89))
      {
        if (*((_BYTE *)v2 + 86))
        {
          if ((v2[44] & 1) == 0)
          {
            if ((v2[45] & 1) != 0)
            {
              v94 = 258;
              goto LABEL_349;
            }
            if ((*((_BYTE *)v2 + 91) & 1) != 0)
            {
              v94 = 258;
              goto LABEL_351;
            }
            if ((v2[46] & 1) != 0)
            {
              v94 = 258;
              goto LABEL_353;
            }
            v94 = 258;
            if ((*((_BYTE *)v2 + 93) & 1) == 0)
              goto LABEL_356;
            goto LABEL_355;
          }
          v94 = 386;
        }
        else
        {
          if ((v2[44] & 1) == 0)
          {
            if ((v2[45] & 1) != 0)
            {
              v94 = 256;
              goto LABEL_349;
            }
            if ((*((_BYTE *)v2 + 91) & 1) != 0)
            {
              v94 = 256;
              goto LABEL_351;
            }
            if ((v2[46] & 1) != 0)
            {
              v94 = 256;
              goto LABEL_353;
            }
            v94 = 256;
            if ((*((_BYTE *)v2 + 93) & 1) == 0)
              goto LABEL_356;
            goto LABEL_355;
          }
          v94 = 384;
        }
      }
      else if (*((_BYTE *)v2 + 86))
      {
        if ((v2[44] & 1) == 0)
        {
          if ((v2[45] & 1) != 0)
          {
            v94 = 2;
            goto LABEL_349;
          }
          if ((*((_BYTE *)v2 + 91) & 1) != 0)
          {
            v94 = 2;
            goto LABEL_351;
          }
          if ((v2[46] & 1) != 0)
          {
            v94 = 2;
            goto LABEL_353;
          }
          v94 = 2;
          if ((*((_BYTE *)v2 + 93) & 1) == 0)
            goto LABEL_356;
          goto LABEL_355;
        }
        v94 = 130;
      }
      else
      {
        if ((v2[44] & 1) == 0)
        {
          if ((v2[45] & 1) != 0)
          {
            v94 = 0;
            goto LABEL_349;
          }
          if ((*((_BYTE *)v2 + 91) & 1) != 0)
          {
            v94 = 0;
            goto LABEL_351;
          }
          if ((v2[46] & 1) != 0)
          {
            v94 = 0;
            goto LABEL_353;
          }
          v94 = 0;
          if ((*((_BYTE *)v2 + 93) & 1) == 0)
            goto LABEL_356;
          goto LABEL_355;
        }
        v94 = 128;
      }
LABEL_348:
      if ((v2[45] & 1) == 0)
        goto LABEL_350;
      goto LABEL_349;
    }
    v31 = v2[7];
    v32 = *(unsigned int *)(v2 + 5) | (unint64_t)(v31 << 32);
    LOBYTE(v158[0]) = *(_DWORD *)(v2 + 5);
    v33.i64[0] = 0xFFFFFFFFFFFFLL;
    v33.i64[1] = 0xFFFFFFFFFFFFLL;
    v34 = (uint64x2_t)vandq_s8((int8x16_t)vdupq_n_s64(v32), v33);
    v35 = (int16x8_t)vshlq_u64(v34, (uint64x2_t)xmmword_10033B100);
    *(int32x2_t *)v34.i8 = vmovn_s64((int64x2_t)vshlq_u64(v34, (uint64x2_t)xmmword_10033B0F0));
    *(int32x2_t *)v35.i8 = vmovn_s64((int64x2_t)v35);
    v35.i16[1] = v35.i16[2];
    v35.i16[2] = v34.i16[0];
    v35.i16[3] = v34.i16[2];
    *(_DWORD *)((char *)v158 + 1) = vmovn_s16(v35).u32[0];
    BYTE5(v158[0]) = BYTE1(v31);
    v36 = v162;
    v37 = v163;
    sub_100034C68((uint64_t)&v161, (uint64_t)v162);
    v38 = sub_100039C34();
    v39 = *(_QWORD *)&v151[4];
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(v158, &type metadata for WiFiAddress, v38, v36, v37);
    *(_QWORD *)&v151[4] = v39;
    if (!v39)
    {
      if ((v30 & 0xFFFF0000) == 0)
      {
        *(_DWORD *)v151 |= 1u;
        LOWORD(v155[0]) = v30;
        v40 = sub_1000FADC0((uint64_t)v155, (uint64_t)v155 + 2);
        v42 = v41;
        swift_beginAccess(v150, v158, 33, 0);
        sub_1000FBDAC(v40, v42);
        swift_endAccess(v158);
        sub_10000E614(v40, v42);
        v21 = v145;
        goto LABEL_112;
      }
LABEL_645:
      _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 3455, 0);
      __break(1u);
      JUMPOUT(0x1000D33A4);
    }
  }
LABEL_121:
  swift_release(v19);
  return sub_100014430(&v161);
}

Swift::Int sub_1000D3464(uint64_t a1, uint64_t a2)
{
  return sub_1000DE8EC(a1, a2, (void (*)(_QWORD *))AWDLActionFrame.DataPathState.hash(into:));
}

Swift::Int sub_1000D3474(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000D72EC(a1, a2, a3, (void (*)(_QWORD *))AWDLActionFrame.DataPathState.hash(into:));
}

void *AWDLActionFrame.Arpa.Flags.isLinkLocal.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.Arpa.Flags.isLinkLocal;
}

void *AWDLActionFrame.Arpa.Flags.isIPv6.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.Arpa.Flags.isIPv6;
}

void *AWDLActionFrame.Arpa.Flags.isIPv4.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.Arpa.Flags.isIPv4;
}

uint64_t sub_1000D34A8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000E7DA8();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000D3504(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000E7DA8();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

uint64_t AWDLActionFrame.Arpa.hostname.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  swift_bridgeObjectRetain(a3);
  return a2;
}

uint64_t AWDLActionFrame.Arpa.hostname.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t result;

  result = swift_bridgeObjectRelease(*(_QWORD *)(v2 + 16));
  *(_QWORD *)(v2 + 8) = a1;
  *(_QWORD *)(v2 + 16) = a2;
  return result;
}

uint64_t AWDLActionFrame.Arpa.hash(into:)(uint64_t a1, Swift::UInt8 a2, uint64_t a3, uint64_t a4)
{
  Hasher._combine(_:)(a2);
  swift_bridgeObjectRetain(a4);
  String.hash(into:)(a1, a3, a4);
  return swift_bridgeObjectRelease(a4);
}

uint64_t static AWDLActionFrame.Arpa.__derived_struct_equals(_:_:)(char a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5, uint64_t a6)
{
  if (a1 != a4)
    return 0;
  if (a2 == a5 && a3 == a6)
    return 1;
  return _stringCompareWithSmolCheck(_:_:expecting:)(a2, a3, a5, a6, 0);
}

Swift::Int AWDLActionFrame.Arpa.hashValue.getter(Swift::UInt8 a1, uint64_t a2, uint64_t a3)
{
  _QWORD v7[9];

  Hasher.init(_seed:)(v7);
  Hasher._combine(_:)(a1);
  swift_bridgeObjectRetain(a3);
  String.hash(into:)(v7, a2, a3);
  swift_bridgeObjectRelease(a3);
  return Hasher._finalize()();
}

uint64_t sub_1000D36BC@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;

  result = AWDLActionFrame.Arpa.init(from:)(a1);
  if (!v2)
  {
    *(_BYTE *)a2 = result;
    *(_QWORD *)(a2 + 8) = v5;
    *(_QWORD *)(a2 + 16) = v6;
  }
  return result;
}

uint64_t AWDLActionFrame.Arpa.init(from:)(_QWORD *a1)
{
  return sub_1000E6C78(a1);
}

uint64_t sub_1000D3708(_QWORD *a1)
{
  uint64_t v1;

  return AWDLActionFrame.Arpa.encode(to:)(a1, *(_BYTE *)v1, *(_QWORD *)(v1 + 8), *(_QWORD *)(v1 + 16));
}

uint64_t AWDLActionFrame.Arpa.encode(to:)(_QWORD *a1, char a2, uint64_t a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v15;
  _QWORD v16[3];
  uint64_t v17;
  uint64_t v18;

  v8 = a1[3];
  v9 = a1[4];
  sub_10003259C(a1, v8);
  dispatch thunk of Encoder.unkeyedContainer()(v16, v8, v9);
  LOBYTE(v15) = a2;
  v10 = v17;
  v11 = v18;
  sub_100034C68((uint64_t)v16, v17);
  v12 = sub_1000E71F4();
  dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(&v15, &type metadata for AWDLActionFrame.Arpa.Flags, v12, v10, v11);
  if (!v4)
  {
    swift_bridgeObjectRetain(a4);
    sub_1000FAE78(a3, a4);
    __asm { BR              X10 }
  }
  return sub_100014430(v16);
}

Swift::Int sub_1000D39D4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  Swift::UInt8 v3;
  _QWORD v5[9];

  v1 = *(_QWORD *)(v0 + 8);
  v2 = *(_QWORD *)(v0 + 16);
  v3 = *(_BYTE *)v0;
  Hasher.init(_seed:)(v5);
  Hasher._combine(_:)(v3);
  swift_bridgeObjectRetain(v2);
  String.hash(into:)(v5, v1, v2);
  swift_bridgeObjectRelease(v2);
  return Hasher._finalize()();
}

uint64_t sub_1000D3A44(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(v1 + 8);
  v4 = *(_QWORD *)(v1 + 16);
  Hasher._combine(_:)(*(_BYTE *)v1);
  swift_bridgeObjectRetain(v4);
  String.hash(into:)(a1, v3, v4);
  return swift_bridgeObjectRelease(v4);
}

Swift::Int sub_1000D3A94()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  Swift::UInt8 v3;
  _QWORD v5[9];

  v1 = *(_QWORD *)(v0 + 8);
  v2 = *(_QWORD *)(v0 + 16);
  v3 = *(_BYTE *)v0;
  Hasher.init(_seed:)(v5);
  Hasher._combine(_:)(v3);
  swift_bridgeObjectRetain(v2);
  String.hash(into:)(v5, v1, v2);
  swift_bridgeObjectRelease(v2);
  return Hasher._finalize()();
}

uint64_t sub_1000D3B00(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (*a1 != *a2)
    return 0;
  v4 = *((_QWORD *)a1 + 1);
  v5 = *((_QWORD *)a1 + 2);
  v6 = *((_QWORD *)a2 + 1);
  v7 = *((_QWORD *)a2 + 2);
  if (v4 == v6 && v5 == v7)
    return 1;
  else
    return _stringCompareWithSmolCheck(_:_:expecting:)(v4, v5, v6, v7, 0);
}

void AWDLActionFrame.SyncTreePath.hash(into:)(uint64_t a1, uint64_t a2)
{
  Swift::UInt v3;
  Swift::UInt8 *v4;
  Swift::UInt8 v5;
  Swift::UInt8 v6;
  Swift::UInt8 v7;
  Swift::UInt8 v8;
  Swift::UInt8 v9;
  Swift::UInt8 v10;

  v3 = *(_QWORD *)(a2 + 16);
  Hasher._combine(_:)(v3);
  if (v3)
  {
    v4 = (Swift::UInt8 *)(a2 + 37);
    do
    {
      v5 = *(v4 - 5);
      v6 = *(v4 - 4);
      v7 = *(v4 - 3);
      v8 = *(v4 - 2);
      v9 = *(v4 - 1);
      v10 = *v4;
      v4 += 6;
      Hasher._combine(_:)(v5);
      Hasher._combine(_:)(v6);
      Hasher._combine(_:)(v7);
      Hasher._combine(_:)(v8);
      Hasher._combine(_:)(v9);
      Hasher._combine(_:)(v10);
      --v3;
    }
    while (v3);
  }
}

uint64_t sub_1000D3BE4()
{
  return 1752457584;
}

uint64_t sub_1000D3BF4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  char v6;
  uint64_t result;
  char v8;

  if (a1 == 1752457584 && a2 == 0xE400000000000000)
  {
    result = swift_bridgeObjectRelease(0xE400000000000000);
    v8 = 0;
  }
  else
  {
    v6 = _stringCompareWithSmolCheck(_:_:expecting:)(1752457584, 0xE400000000000000, a1, a2, 0);
    result = swift_bridgeObjectRelease(a2);
    v8 = v6 ^ 1;
  }
  *a3 = v8 & 1;
  return result;
}

uint64_t sub_1000D3C78(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000E7238();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000D3CA0(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000E7238();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t AWDLActionFrame.SyncTreePath.encode(to:)(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v16;

  v4 = sub_100012C44(&qword_100407240);
  v5 = *(_QWORD *)(v4 - 8);
  __chkstk_darwin();
  v7 = (char *)&v15 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  v8 = a1[3];
  v9 = a1[4];
  sub_10003259C(a1, v8);
  v10 = sub_1000E7238();
  dispatch thunk of Encoder.container<A>(keyedBy:)(&type metadata for AWDLActionFrame.SyncTreePath.CodingKeys, &type metadata for AWDLActionFrame.SyncTreePath.CodingKeys, v10, v8, v9);
  v16 = a2;
  v11 = sub_100012C44(&qword_100407250);
  v12 = sub_1000F093C(&qword_100407258, (uint64_t (*)(void))sub_100039C34, (const char *)&protocol conformance descriptor for <A> [A]);
  KeyedEncodingContainer.encode<A>(_:forKey:)(&v16, v13, v4, v11, v12);
  return (*(uint64_t (**)(char *, uint64_t))(v5 + 8))(v7, v4);
}

Swift::Int AWDLActionFrame.SyncTreePath.hashValue.getter(uint64_t a1)
{
  _QWORD v3[9];

  Hasher.init(_seed:)(v3);
  AWDLActionFrame.SyncTreePath.hash(into:)((uint64_t)v3, a1);
  return Hasher._finalize()();
}

_QWORD *AWDLActionFrame.SyncTreePath.init(from:)(_QWORD *a1)
{
  return sub_1000E4354(a1);
}

_QWORD *sub_1000D3E3C@<X0>(_QWORD *a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  _QWORD *result;

  result = sub_1000E4354(a1);
  if (!v2)
    *a2 = result;
  return result;
}

uint64_t sub_1000D3E64(_QWORD *a1)
{
  uint64_t *v1;

  return AWDLActionFrame.SyncTreePath.encode(to:)(a1, *v1);
}

Swift::Int sub_1000D3E7C()
{
  uint64_t *v0;
  uint64_t v1;
  _QWORD v3[9];

  v1 = *v0;
  Hasher.init(_seed:)(v3);
  AWDLActionFrame.SyncTreePath.hash(into:)((uint64_t)v3, v1);
  return Hasher._finalize()();
}

void sub_1000D3EC0(uint64_t a1)
{
  uint64_t *v1;

  AWDLActionFrame.SyncTreePath.hash(into:)(a1, *v1);
}

Swift::Int sub_1000D3EC8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000D3ED4(a1, a2, a3, (void (*)(_QWORD *, uint64_t))AWDLActionFrame.SyncTreePath.hash(into:));
}

Swift::Int sub_1000D3ED4(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(_QWORD *, uint64_t))
{
  uint64_t *v4;
  uint64_t v6;
  _QWORD v8[9];

  v6 = *v4;
  Hasher.init(_seed:)(v8);
  a4(v8, v6);
  return Hasher._finalize()();
}

BOOL sub_1000D3F18(uint64_t *a1, uint64_t *a2)
{
  return _s7CoreP2P15AWDLActionFrameV12SyncTreePathV23__derived_struct_equalsySbAE_AEtFZ_0(*a1, *a2);
}

CoreP2P::AWDLActionFrame::AWDLVersion __swiftcall AWDLActionFrame.AWDLVersion.init(majorVersion:minorVersion:)(Swift::UInt8 majorVersion, Swift::UInt8 minorVersion)
{
  return (CoreP2P::AWDLActionFrame::AWDLVersion)(minorVersion & 0xF | (16 * majorVersion));
}

void *AWDLActionFrame.AWDLVersion.latest.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.AWDLVersion.latest;
}

uint64_t static AWDLActionFrame.AWDLVersion.latest.getter()
{
  return 146;
}

uint64_t static AWDLActionFrame.AWDLVersion.< infix(_:_:)(unsigned __int8 a1, unsigned __int8 a2)
{
  unsigned int v2;
  unsigned int v3;
  _BOOL4 v4;

  v2 = a1 >> 4;
  v3 = a2 >> 4;
  v4 = (a1 & 0xFu) < (a2 & 0xFu);
  if (v2 != v3)
    v4 = 0;
  return v2 < v3 || v4;
}

BOOL AWDLActionFrame.AWDLVersion.supportsLoopFreeAlgorithm.getter(unsigned __int8 a1)
{
  _BOOL4 v1;

  v1 = (a1 & 0xF0) != 0x30 || (a1 & 0xFu) > 2;
  return a1 >= 0x30u && v1;
}

BOOL AWDLActionFrame.AWDLVersion.supportsDynamicSDB.getter(unsigned __int8 a1)
{
  _BOOL4 v1;

  v1 = (a1 & 0xF0) != 0x30 || (a1 & 0xC) != 0;
  return a1 >= 0x30u && v1;
}

BOOL AWDLActionFrame.AWDLVersion.supportsServiceDiscoverySize.getter(unsigned __int8 a1)
{
  return a1 > 0x3Fu;
}

BOOL AWDLActionFrame.AWDLVersion.isSDBAware.getter(unsigned __int8 a1)
{
  return a1 > 0x2Fu;
}

uint64_t sub_1000D3FEC()
{
  return 0x65756C6156776172;
}

uint64_t sub_1000D4004@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  char v6;
  uint64_t result;
  char v8;

  if (a1 == 0x65756C6156776172 && a2 == 0xE800000000000000)
  {
    result = swift_bridgeObjectRelease(0xE800000000000000);
    v8 = 0;
  }
  else
  {
    v6 = _stringCompareWithSmolCheck(_:_:expecting:)(0x65756C6156776172, 0xE800000000000000, a1, a2, 0);
    result = swift_bridgeObjectRelease(a2);
    v8 = v6 ^ 1;
  }
  *a3 = v8 & 1;
  return result;
}

uint64_t sub_1000D4098(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000E727C();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000D40C0(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000E727C();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t AWDLActionFrame.AWDLVersion.encode(to:)(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;

  v4 = sub_100012C44(&qword_100407260);
  v5 = *(_QWORD *)(v4 - 8);
  __chkstk_darwin();
  v7 = (char *)&v13 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  v8 = a1[3];
  v9 = a1[4];
  sub_10003259C(a1, v8);
  v10 = sub_1000E727C();
  dispatch thunk of Encoder.container<A>(keyedBy:)(&type metadata for AWDLActionFrame.AWDLVersion.CodingKeys, &type metadata for AWDLActionFrame.AWDLVersion.CodingKeys, v10, v8, v9);
  KeyedEncodingContainer.encode(_:forKey:)(a2, v11, v4);
  return (*(uint64_t (**)(char *, uint64_t))(v5 + 8))(v7, v4);
}

_QWORD *AWDLActionFrame.AWDLVersion.init(from:)(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;

  v3 = sub_100012C44(&qword_100407270);
  v4 = *(_QWORD *)(v3 - 8);
  __chkstk_darwin();
  v6 = (char *)&v13 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = a1[3];
  v8 = a1[4];
  v9 = sub_10003259C(a1, v7);
  v10 = sub_1000E727C();
  v11 = dispatch thunk of Decoder.container<A>(keyedBy:)(&type metadata for AWDLActionFrame.AWDLVersion.CodingKeys, &type metadata for AWDLActionFrame.AWDLVersion.CodingKeys, v10, v7, v8);
  if (!v1)
  {
    v9 = (_QWORD *)KeyedDecodingContainer.decode(_:forKey:)(v11, v3);
    (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  }
  sub_100014430(a1);
  return v9;
}

uint64_t sub_1000D42D0(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  _BOOL4 v5;

  v2 = *a1;
  v3 = *a2;
  v4 = v2 >> 4;
  v5 = (v2 & 0xF) < (v3 & 0xF);
  if (v4 != v3 >> 4)
    v5 = 0;
  return v4 < v3 >> 4 || v5;
}

uint64_t sub_1000D4304(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  _BOOL4 v6;

  v2 = *a1;
  v3 = *a2;
  v4 = v2 >> 4;
  if (v3 >> 4 < v2 >> 4)
    return 0;
  v6 = (v3 & 0xF) >= (v2 & 0xF);
  return v3 >> 4 != v4 || v6;
}

uint64_t sub_1000D4344(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  _BOOL4 v6;

  v2 = *a1;
  v3 = *a2;
  v4 = v2 >> 4;
  if (v2 >> 4 < v3 >> 4)
    return 0;
  v6 = (v2 & 0xF) >= (v3 & 0xF);
  return v4 != v3 >> 4 || v6;
}

uint64_t sub_1000D4384(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  _BOOL4 v5;

  v2 = *a1;
  v3 = *a2;
  v4 = v2 >> 4;
  v5 = (v3 & 0xF) < (v2 & 0xF);
  if (v3 >> 4 != v4)
    v5 = 0;
  return v3 >> 4 < v4 || v5;
}

uint64_t sub_1000D43B8@<X0>(_QWORD *a1@<X0>, _BYTE *a2@<X8>)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char v13;
  uint64_t result;
  uint64_t v15;

  v5 = sub_100012C44(&qword_100407270);
  v6 = *(_QWORD *)(v5 - 8);
  __chkstk_darwin();
  v8 = (char *)&v15 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  v9 = a1[3];
  v10 = a1[4];
  sub_10003259C(a1, v9);
  v11 = sub_1000E727C();
  v12 = dispatch thunk of Decoder.container<A>(keyedBy:)(&type metadata for AWDLActionFrame.AWDLVersion.CodingKeys, &type metadata for AWDLActionFrame.AWDLVersion.CodingKeys, v11, v9, v10);
  if (v2)
    return sub_100014430(a1);
  v13 = KeyedDecodingContainer.decode(_:forKey:)(v12, v5);
  (*(void (**)(char *, uint64_t))(v6 + 8))(v8, v5);
  result = sub_100014430(a1);
  *a2 = v13;
  return result;
}

uint64_t sub_1000D44C8(_QWORD *a1)
{
  unsigned __int8 *v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;

  v3 = sub_100012C44(&qword_100407260);
  v4 = *(_QWORD *)(v3 - 8);
  __chkstk_darwin();
  v6 = (char *)&v13 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = a1[3];
  v8 = a1[4];
  v9 = *v1;
  sub_10003259C(a1, v7);
  v10 = sub_1000E727C();
  dispatch thunk of Encoder.container<A>(keyedBy:)(&type metadata for AWDLActionFrame.AWDLVersion.CodingKeys, &type metadata for AWDLActionFrame.AWDLVersion.CodingKeys, v10, v7, v8);
  KeyedEncodingContainer.encode(_:forKey:)(v9, v11, v3);
  return (*(uint64_t (**)(char *, uint64_t))(v4 + 8))(v6, v3);
}

unint64_t AWDLActionFrame.Version.PlatformType.rawValue.getter(char a1)
{
  return 0x1008040201uLL >> (8 * a1);
}

BOOL sub_1000D45D0(_BYTE *a1, _BYTE *a2)
{
  return ((0x1008040201uLL >> (8 * *a1)) & 0x1F) == ((0x1008040201uLL >> (8 * *a2)) & 0x1F);
}

uint64_t sub_1000D4608@<X0>(unsigned __int8 *a1@<X0>, _BYTE *a2@<X8>)
{
  uint64_t result;

  result = _s7CoreP2P15AWDLActionFrameV7VersionV12PlatformTypeO8rawValueAGSgs5UInt8V_tcfC_0(*a1);
  *a2 = result;
  return result;
}

void sub_1000D4630(_BYTE *a1@<X8>)
{
  _BYTE *v1;

  *a1 = 0x1008040201uLL >> (8 * *v1);
}

Swift::Int sub_1000D4650()
{
  char *v0;
  char v1;
  _QWORD v3[9];

  v1 = *v0;
  Hasher.init(_seed:)(v3);
  Hasher._combine(_:)(0x1008040201uLL >> (8 * v1));
  return Hasher._finalize()();
}

void sub_1000D46A4()
{
  _BYTE *v0;

  Hasher._combine(_:)(0x1008040201uLL >> (8 * *v0));
}

Swift::Int sub_1000D46E0()
{
  char *v0;
  char v1;
  _QWORD v3[9];

  v1 = *v0;
  Hasher.init(_seed:)(v3);
  Hasher._combine(_:)(0x1008040201uLL >> (8 * v1));
  return Hasher._finalize()();
}

uint64_t sub_1000D4730(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000F049C();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t AWDLActionFrame.Version.platformType.getter(__int16 a1)
{
  int v1;
  uint64_t result;

  v1 = HIBYTE(a1) - 1;
  result = 0;
  switch(v1)
  {
    case 0:
      return result;
    case 1:
      result = 1;
      break;
    case 3:
      result = 2;
      break;
    case 7:
      result = 3;
      break;
    case 15:
      result = 4;
      break;
    default:
      result = 5;
      break;
  }
  return result;
}

CoreP2P::AWDLActionFrame::Version __swiftcall AWDLActionFrame.Version.init(version:platformType:)(CoreP2P::AWDLActionFrame::AWDLVersion version, CoreP2P::AWDLActionFrame::Version::PlatformType platformType)
{
  return (CoreP2P::AWDLActionFrame::Version)(version.rawValue | ((0x1008040201uLL >> (8 * platformType)) << 8));
}

void AWDLThreadCoexistenceEvent.hash(into:)(int a1, __int16 a2)
{
  Swift::UInt8 v2;

  v2 = HIBYTE(a2);
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v2);
}

BOOL static AWDLThreadCoexistenceEvent.__derived_struct_equals(_:_:)(__int16 a1, __int16 a2)
{
  return a1 == a2;
}

uint64_t sub_1000D4844()
{
  _BYTE *v0;

  if (*v0)
    return 0x726F6674616C705FLL;
  else
    return 0x6E6F6973726576;
}

uint64_t sub_1000D488C@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;

  result = sub_1000EF614(a1, a2);
  *a3 = result;
  return result;
}

uint64_t sub_1000D48B0(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000E72C0();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000D48D8(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000E72C0();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t AWDLActionFrame.Version.encode(to:)(_QWORD *a1, __int16 a2)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v14;
  char v15;
  char v16;
  char v17;

  v5 = sub_100012C44(&qword_100407278);
  v6 = *(_QWORD *)(v5 - 8);
  __chkstk_darwin();
  v8 = (char *)&v14 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  v9 = a1[3];
  v10 = a1[4];
  sub_10003259C(a1, v9);
  v11 = sub_1000E72C0();
  dispatch thunk of Encoder.container<A>(keyedBy:)(&type metadata for AWDLActionFrame.Version.CodingKeys, &type metadata for AWDLActionFrame.Version.CodingKeys, v11, v9, v10);
  v17 = a2;
  v16 = 0;
  v12 = sub_1000E7304();
  KeyedEncodingContainer.encode<A>(_:forKey:)(&v17, &v16, v5, &type metadata for AWDLActionFrame.AWDLVersion, v12);
  if (!v2)
  {
    v15 = 1;
    KeyedEncodingContainer.encode(_:forKey:)(HIBYTE(a2), &v15, v5);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v6 + 8))(v8, v5);
}

Swift::Int AWDLThreadCoexistenceEvent.hashValue.getter(__int16 a1)
{
  Swift::UInt8 v1;
  Swift::UInt8 v2;
  _QWORD v4[9];

  v1 = a1;
  v2 = HIBYTE(a1);
  Hasher.init(_seed:)(v4);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  return Hasher._finalize()();
}

uint64_t AWDLActionFrame.Version.init(from:)(_QWORD *a1)
{
  return sub_1000E4E40(a1);
}

uint64_t sub_1000D4A98@<X0>(_QWORD *a1@<X0>, _WORD *a2@<X8>)
{
  uint64_t v2;
  uint64_t result;

  result = sub_1000E4E40(a1);
  if (!v2)
    *a2 = result;
  return result;
}

uint64_t sub_1000D4AC0(_QWORD *a1)
{
  __int16 *v1;

  return AWDLActionFrame.Version.encode(to:)(a1, *v1);
}

Swift::Int sub_1000D4AD8()
{
  Swift::UInt8 *v0;
  Swift::UInt8 v1;
  Swift::UInt8 v2;
  _QWORD v4[9];

  v1 = *v0;
  v2 = v0[1];
  Hasher.init(_seed:)(v4);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  return Hasher._finalize()();
}

void sub_1000D4B34()
{
  Swift::UInt8 *v0;
  Swift::UInt8 v1;

  v1 = v0[1];
  Hasher._combine(_:)(*v0);
  Hasher._combine(_:)(v1);
}

Swift::Int sub_1000D4B70()
{
  Swift::UInt8 *v0;
  Swift::UInt8 v1;
  Swift::UInt8 v2;
  _QWORD v4[9];

  v1 = *v0;
  v2 = v0[1];
  Hasher.init(_seed:)(v4);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  return Hasher._finalize()();
}

BOOL sub_1000D4BC8(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2 && a1[1] == a2[1];
}

void AWDLActionFrame.PeerMACAddressListBloomFilter.hash(into:)(int a1, __int16 a2, uint64_t a3)
{
  Swift::UInt8 v4;
  Swift::UInt v5;
  Swift::UInt8 *v6;
  Swift::UInt8 v7;

  v4 = HIBYTE(a2);
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v4);
  v5 = *(_QWORD *)(a3 + 16);
  Hasher._combine(_:)(v5);
  if (v5)
  {
    v6 = (Swift::UInt8 *)(a3 + 32);
    do
    {
      v7 = *v6++;
      Hasher._combine(_:)(v7);
      --v5;
    }
    while (v5);
  }
}

uint64_t static AWDLActionFrame.PeerMACAddressListBloomFilter.__derived_struct_equals(_:_:)(__int16 a1, uint64_t a2, __int16 a3, uint64_t a4)
{
  if (a1 == a3)
    return sub_1000851D0(a2, a4);
  else
    return 0;
}

unint64_t sub_1000D4C68()
{
  _BYTE *v0;
  uint64_t v1;

  v1 = 0x746E756F63;
  if (*v0 != 1)
    v1 = 0x6D6F6F6C62;
  if (*v0)
    return v1;
  else
    return 0xD000000000000014;
}

uint64_t sub_1000D4CC0@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;

  result = sub_1000EF728(a1, a2);
  *a3 = result;
  return result;
}

uint64_t sub_1000D4CE4(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000E7348();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000D4D0C(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000E7348();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t AWDLActionFrame.PeerMACAddressListBloomFilter.encode(to:)(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;
  char v19;
  char v20;
  char v21;

  v7 = sub_100012C44(&qword_100407290);
  v8 = *(_QWORD *)(v7 - 8);
  __chkstk_darwin();
  v10 = (char *)&v17 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  v11 = a1[3];
  v12 = a1[4];
  sub_10003259C(a1, v11);
  v13 = sub_1000E7348();
  dispatch thunk of Encoder.container<A>(keyedBy:)(&type metadata for AWDLActionFrame.PeerMACAddressListBloomFilter.CodingKeys, &type metadata for AWDLActionFrame.PeerMACAddressListBloomFilter.CodingKeys, v13, v11, v12);
  v21 = 0;
  KeyedEncodingContainer.encode(_:forKey:)(a2, &v21, v7);
  if (!v3)
  {
    v20 = 1;
    KeyedEncodingContainer.encode(_:forKey:)(BYTE1(a2), &v20, v7);
    v18 = a3;
    v19 = 2;
    v14 = sub_100012C44(&qword_100406738);
    v15 = sub_1000F08DC((unint64_t *)&qword_1004071D0, (uint64_t)&protocol witness table for UInt8, (const char *)&protocol conformance descriptor for <A> [A]);
    KeyedEncodingContainer.encode<A>(_:forKey:)(&v18, &v19, v7, v14, v15);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v8 + 8))(v10, v7);
}

Swift::Int AWDLActionFrame.PeerMACAddressListBloomFilter.hashValue.getter(__int16 a1, uint64_t a2)
{
  Swift::UInt8 v3;
  Swift::UInt8 v4;
  Swift::UInt v5;
  Swift::UInt8 *v6;
  Swift::UInt8 v7;
  _QWORD v9[9];

  v3 = a1;
  v4 = HIBYTE(a1);
  Hasher.init(_seed:)(v9);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  v5 = *(_QWORD *)(a2 + 16);
  Hasher._combine(_:)(v5);
  if (v5)
  {
    v6 = (Swift::UInt8 *)(a2 + 32);
    do
    {
      v7 = *v6++;
      Hasher._combine(_:)(v7);
      --v5;
    }
    while (v5);
  }
  return Hasher._finalize()();
}

uint64_t AWDLActionFrame.PeerMACAddressListBloomFilter.init(from:)(_QWORD *a1)
{
  return sub_1000E4FA4(a1);
}

uint64_t sub_1000D4F54@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v5;

  result = sub_1000E4FA4(a1);
  if (!v2)
  {
    *(_WORD *)a2 = result;
    *(_QWORD *)(a2 + 8) = v5;
  }
  return result;
}

uint64_t sub_1000D4F88(_QWORD *a1)
{
  unsigned __int16 *v1;

  return AWDLActionFrame.PeerMACAddressListBloomFilter.encode(to:)(a1, *v1, *((_QWORD *)v1 + 1));
}

Swift::Int sub_1000D4FA4()
{
  uint64_t v0;

  return AWDLActionFrame.PeerMACAddressListBloomFilter.hashValue.getter(*(_WORD *)v0, *(_QWORD *)(v0 + 8));
}

void sub_1000D4FB0(int a1)
{
  uint64_t v1;

  AWDLActionFrame.PeerMACAddressListBloomFilter.hash(into:)(a1, *(_WORD *)v1, *(_QWORD *)(v1 + 8));
}

Swift::Int sub_1000D4FBC()
{
  uint64_t v0;
  uint64_t v1;
  Swift::UInt8 v2;
  Swift::UInt8 v3;
  Swift::UInt v4;
  Swift::UInt8 *v5;
  Swift::UInt8 v6;
  _QWORD v8[9];

  v1 = *(_QWORD *)(v0 + 8);
  v2 = *(_BYTE *)v0;
  v3 = *(_BYTE *)(v0 + 1);
  Hasher.init(_seed:)(v8);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  v4 = *(_QWORD *)(v1 + 16);
  Hasher._combine(_:)(v4);
  if (v4)
  {
    v5 = (Swift::UInt8 *)(v1 + 32);
    do
    {
      v6 = *v5++;
      Hasher._combine(_:)(v6);
      --v4;
    }
    while (v4);
  }
  return Hasher._finalize()();
}

uint64_t sub_1000D5044(unsigned __int8 *a1, unsigned __int8 *a2)
{
  if (*a1 == *a2 && a1[1] == a2[1])
    return sub_1000851D0(*((_QWORD *)a1 + 1), *((_QWORD *)a2 + 1));
  else
    return 0;
}

unint64_t NANElectionParameters.clusterID.getter()
{
  uint64_t v0;

  return *(unsigned __int16 *)(v0 + 2) | ((unint64_t)*(unsigned int *)(v0 + 4) << 16);
}

uint64_t NANElectionParameters.clusterID.setter(uint64_t result)
{
  uint64_t v1;

  *(_WORD *)(v1 + 2) = result;
  *(_BYTE *)(v1 + 4) = BYTE2(result);
  *(_BYTE *)(v1 + 5) = BYTE3(result);
  *(_BYTE *)(v1 + 6) = BYTE4(result);
  *(_BYTE *)(v1 + 7) = BYTE5(result);
  return result;
}

unint64_t AWDLActionFrame.NANSynchronization.clusterID.getter()
{
  uint64_t v0;

  return *(unsigned __int16 *)(v0 + 8) | ((unint64_t)*(unsigned int *)(v0 + 10) << 16);
}

uint64_t AWDLActionFrame.NANSynchronization.clusterID.setter(uint64_t result)
{
  uint64_t v1;

  *(_WORD *)(v1 + 8) = result;
  *(_BYTE *)(v1 + 10) = BYTE2(result);
  *(_BYTE *)(v1 + 11) = BYTE3(result);
  *(_BYTE *)(v1 + 12) = BYTE4(result);
  *(_BYTE *)(v1 + 13) = BYTE5(result);
  return result;
}

uint64_t IEEE80211InformationElement.RSNCapability.capabilities.getter()
{
  uint64_t v0;

  return *(unsigned __int16 *)(v0 + 24);
}

uint64_t IEEE80211InformationElement.RSNCapability.capabilities.setter(uint64_t result)
{
  uint64_t v1;

  *(_WORD *)(v1 + 24) = result;
  return result;
}

unint64_t AWDLActionFrame.NANSynchronization.anchorMasterRank.getter()
{
  uint64_t v0;

  return __rev16(*(unsigned __int16 *)(v0 + 32)) | ((unint64_t)*(unsigned __int8 *)(v0 + 26) << 16) | ((unint64_t)*(unsigned __int8 *)(v0 + 27) << 24) | ((unint64_t)*(unsigned int *)(v0 + 28) << 32);
}

unint64_t AWDLActionFrame.NANSynchronization.anchorMasterCluster.getter()
{
  uint64_t v0;

  return __rev16(*(unsigned __int16 *)(v0 + 32)) | ((unint64_t)*(unsigned __int8 *)(v0 + 26) << 16) | ((unint64_t)*(unsigned __int8 *)(v0 + 27) << 24) | ((unint64_t)*(unsigned __int8 *)(v0 + 28) << 32) | ((unint64_t)*(unsigned __int8 *)(v0 + 29) << 40) | ((unint64_t)*(unsigned __int8 *)(v0 + 30) << 48) | ((unint64_t)*(unsigned __int8 *)(v0 + 31) << 56);
}

void AWDLActionFrame.NANSynchronization.hash(into:)()
{
  uint64_t v0;
  Swift::UInt8 v1;
  Swift::UInt8 v2;
  Swift::UInt8 v3;
  Swift::UInt8 v4;
  Swift::UInt8 v5;
  Swift::UInt8 v6;
  Swift::UInt8 v7;
  Swift::UInt8 v8;
  Swift::UInt8 v9;
  Swift::UInt8 v10;
  Swift::UInt8 v11;
  Swift::UInt8 v12;
  Swift::UInt8 v13;
  Swift::UInt8 v14;
  Swift::UInt8 v15;
  Swift::UInt8 v16;

  Hasher._combine(_:)(*(_WORD *)v0);
  v1 = *(_BYTE *)(v0 + 3);
  v2 = *(_BYTE *)(v0 + 4);
  v3 = *(_BYTE *)(v0 + 5);
  v4 = *(_BYTE *)(v0 + 6);
  v5 = *(_BYTE *)(v0 + 7);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 2));
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  v6 = *(_BYTE *)(v0 + 9);
  v7 = *(_BYTE *)(v0 + 10);
  v8 = *(_BYTE *)(v0 + 11);
  v9 = *(_BYTE *)(v0 + 12);
  v10 = *(_BYTE *)(v0 + 13);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 8));
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(*(_QWORD *)(v0 + 16));
  v11 = *(_BYTE *)(v0 + 25);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 24));
  Hasher._combine(_:)(v11);
  v12 = *(_BYTE *)(v0 + 27);
  v13 = *(_BYTE *)(v0 + 28);
  v14 = *(_BYTE *)(v0 + 29);
  v15 = *(_BYTE *)(v0 + 30);
  v16 = *(_BYTE *)(v0 + 31);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 26));
  Hasher._combine(_:)(v12);
  Hasher._combine(_:)(v13);
  Hasher._combine(_:)(v14);
  Hasher._combine(_:)(v15);
  Hasher._combine(_:)(v16);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 32));
  Hasher._combine(_:)(*(_BYTE *)(v0 + 33));
  Hasher._combine(_:)(*(_WORD *)(v0 + 34));
  Hasher._combine(_:)(*(_DWORD *)(v0 + 36));
}

uint64_t sub_1000D52BC(unsigned __int8 a1)
{
  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_1000D52F0 + 4 * byte_1003412CE[a1]))(0x746E756F43706F68, 0xE800000000000000);
}

uint64_t sub_1000D52F0()
{
  return 0x6F4E656372756F73;
}

uint64_t sub_1000D530C()
{
  return 0x4972657473756C63;
}

unint64_t sub_1000D5328()
{
  return 0xD00000000000001BLL;
}

uint64_t sub_1000D53E0()
{
  unsigned __int8 *v0;

  return sub_1000D52BC(*v0);
}

uint64_t sub_1000D53E8@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;

  result = sub_1000EF868(a1, a2);
  *a3 = result;
  return result;
}

void sub_1000D540C(_BYTE *a1@<X8>)
{
  *a1 = 10;
}

uint64_t sub_1000D5418(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000E738C();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000D5440(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000E738C();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t AWDLActionFrame.NANSynchronization.encode(to:)(_QWORD *a1)
{
  unsigned __int16 *v1;
  uint64_t v2;
  unsigned __int16 *v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v21;
  char v22;

  v3 = v1;
  v5 = sub_100012C44(&qword_1004072A0);
  v6 = *(_QWORD *)(v5 - 8);
  __chkstk_darwin();
  v8 = (char *)&v21 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  v9 = a1[3];
  v10 = a1[4];
  sub_10003259C(a1, v9);
  v11 = sub_1000E738C();
  dispatch thunk of Encoder.container<A>(keyedBy:)(&type metadata for AWDLActionFrame.NANSynchronization.CodingKeys, &type metadata for AWDLActionFrame.NANSynchronization.CodingKeys, v11, v9, v10);
  v12 = *v3;
  LOBYTE(v21) = 0;
  KeyedEncodingContainer.encode(_:forKey:)(v12, &v21, v5);
  if (!v2)
  {
    LODWORD(v21) = *(_DWORD *)(v3 + 1);
    WORD2(v21) = v3[3];
    v22 = 1;
    v13 = sub_100039C34();
    KeyedEncodingContainer.encode<A>(_:forKey:)(&v21, &v22, v5, &type metadata for WiFiAddress, v13);
    LODWORD(v21) = *((_DWORD *)v3 + 2);
    WORD2(v21) = v3[6];
    v22 = 2;
    KeyedEncodingContainer.encode<A>(_:forKey:)(&v21, &v22, v5, &type metadata for WiFiAddress, v13);
    v21 = *((_QWORD *)v3 + 2);
    v22 = 3;
    v14 = sub_1000E73D0();
    KeyedEncodingContainer.encode<A>(_:forKey:)(&v21, &v22, v5, &type metadata for NANTimeSynchronizationFunction, v14);
    LOWORD(v21) = v3[12];
    v22 = 4;
    v15 = sub_1000E7414();
    KeyedEncodingContainer.encode<A>(_:forKey:)(&v21, &v22, v5, &type metadata for NANAttribute.MasterIndication, v15);
    LODWORD(v21) = *(_DWORD *)(v3 + 13);
    WORD2(v21) = v3[15];
    v22 = 5;
    KeyedEncodingContainer.encode<A>(_:forKey:)(&v21, &v22, v5, &type metadata for WiFiAddress, v13);
    v16 = *((unsigned __int8 *)v3 + 32);
    LOBYTE(v21) = 6;
    KeyedEncodingContainer.encode(_:forKey:)(v16, &v21, v5);
    v17 = *((unsigned __int8 *)v3 + 33);
    LOBYTE(v21) = 7;
    KeyedEncodingContainer.encode(_:forKey:)(v17, &v21, v5);
    v18 = v3[17];
    LOBYTE(v21) = 8;
    KeyedEncodingContainer.encode(_:forKey:)(v18, &v21, v5);
    v19 = *((unsigned int *)v3 + 9);
    LOBYTE(v21) = 9;
    KeyedEncodingContainer.encode(_:forKey:)(v19, &v21, v5);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v6 + 8))(v8, v5);
}

Swift::Int AWDLActionFrame.NANSynchronization.hashValue.getter()
{
  uint64_t v0;
  Swift::UInt8 v1;
  Swift::UInt8 v2;
  Swift::UInt8 v3;
  Swift::UInt8 v4;
  Swift::UInt8 v5;
  Swift::UInt8 v6;
  Swift::UInt8 v7;
  Swift::UInt8 v8;
  Swift::UInt8 v9;
  Swift::UInt8 v10;
  Swift::UInt8 v11;
  Swift::UInt8 v12;
  Swift::UInt8 v13;
  Swift::UInt8 v14;
  Swift::UInt8 v15;
  Swift::UInt8 v16;
  _QWORD v18[9];

  Hasher.init(_seed:)(v18);
  Hasher._combine(_:)(*(_WORD *)v0);
  v1 = *(_BYTE *)(v0 + 3);
  v2 = *(_BYTE *)(v0 + 4);
  v3 = *(_BYTE *)(v0 + 5);
  v4 = *(_BYTE *)(v0 + 6);
  v5 = *(_BYTE *)(v0 + 7);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 2));
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  v6 = *(_BYTE *)(v0 + 9);
  v7 = *(_BYTE *)(v0 + 10);
  v8 = *(_BYTE *)(v0 + 11);
  v9 = *(_BYTE *)(v0 + 12);
  v10 = *(_BYTE *)(v0 + 13);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 8));
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(*(_QWORD *)(v0 + 16));
  v11 = *(_BYTE *)(v0 + 25);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 24));
  Hasher._combine(_:)(v11);
  v12 = *(_BYTE *)(v0 + 27);
  v13 = *(_BYTE *)(v0 + 28);
  v14 = *(_BYTE *)(v0 + 29);
  v15 = *(_BYTE *)(v0 + 30);
  v16 = *(_BYTE *)(v0 + 31);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 26));
  Hasher._combine(_:)(v12);
  Hasher._combine(_:)(v13);
  Hasher._combine(_:)(v14);
  Hasher._combine(_:)(v15);
  Hasher._combine(_:)(v16);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 32));
  Hasher._combine(_:)(*(_BYTE *)(v0 + 33));
  Hasher._combine(_:)(*(_WORD *)(v0 + 34));
  Hasher._combine(_:)(*(_DWORD *)(v0 + 36));
  return Hasher._finalize()();
}

double AWDLActionFrame.NANSynchronization.init(from:)@<D0>(_QWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  double result;
  __int128 v5;
  _OWORD v6[2];
  uint64_t v7;

  sub_1000E5158(a1, (uint64_t)v6);
  if (!v2)
  {
    result = *(double *)v6;
    v5 = v6[1];
    *(_OWORD *)a2 = v6[0];
    *(_OWORD *)(a2 + 16) = v5;
    *(_QWORD *)(a2 + 32) = v7;
  }
  return result;
}

uint64_t sub_1000D5954(_QWORD *a1)
{
  return AWDLActionFrame.NANSynchronization.encode(to:)(a1);
}

Swift::Int sub_1000D5970(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000D72EC(a1, a2, a3, (void (*)(_QWORD *))AWDLActionFrame.NANSynchronization.hash(into:));
}

BOOL sub_1000D597C(uint64_t a1, uint64_t a2)
{
  __int128 v2;
  __int128 v3;
  _OWORD v5[2];
  uint64_t v6;
  _OWORD v7[2];
  uint64_t v8;

  v2 = *(_OWORD *)(a1 + 16);
  v5[0] = *(_OWORD *)a1;
  v5[1] = v2;
  v6 = *(_QWORD *)(a1 + 32);
  v3 = *(_OWORD *)(a2 + 16);
  v7[0] = *(_OWORD *)a2;
  v7[1] = v3;
  v8 = *(_QWORD *)(a2 + 32);
  return _s7CoreP2P15AWDLActionFrameV18NANSynchronizationV23__derived_struct_equalsySbAE_AEtFZ_0((unsigned __int16 *)v5, (unsigned __int16 *)v7);
}

unint64_t NANOOBActionFrameReceivedEvent.peerAddress.getter()
{
  unsigned __int16 *v0;

  return *v0 | ((unint64_t)*(unsigned int *)(v0 + 1) << 16);
}

unint64_t NANOOBActionFrameReceivedEvent.localAddress.getter()
{
  uint64_t v0;

  return *(unsigned __int16 *)(v0 + 6) | ((unint64_t)*(unsigned int *)(v0 + 8) << 16);
}

uint64_t AWDLActionFrame.ElectionParameter.rootLoopFreeCounter.getter()
{
  uint64_t v0;

  return *(unsigned int *)(v0 + 12);
}

uint64_t Socket.rawValue.getter()
{
  uint64_t v0;

  return *(unsigned int *)(v0 + 16);
}

uint64_t AWDLActionFrame.ElectionParameter.hopCount.setter(uint64_t result)
{
  uint64_t v1;

  *(_DWORD *)(v1 + 16) = result;
  return result;
}

unint64_t AWDLActionFrame.ElectionParameter.rootMetric.getter()
{
  uint64_t v0;

  return *(unsigned int *)(v0 + 20) | ((unint64_t)*(unsigned __int8 *)(v0 + 24) << 32);
}

unint64_t AWDLActionFrame.ElectionParameter.selfMetric.getter()
{
  uint64_t v0;

  return *(unsigned int *)(v0 + 28) | ((unint64_t)*(unsigned __int8 *)(v0 + 32) << 32);
}

uint64_t AWDLActionFrame.ElectionParameter.selfMetric.setter(uint64_t result)
{
  uint64_t v1;

  *(_DWORD *)(v1 + 28) = result;
  *(_BYTE *)(v1 + 32) = BYTE4(result) & 1;
  return result;
}

uint64_t AWDLActionFrame.ElectionParameter.electionID.getter()
{
  uint64_t v0;

  return *(unsigned int *)(v0 + 36);
}

uint64_t AWDLActionFrame.ElectionParameter.electionID.setter(uint64_t result)
{
  uint64_t v1;

  *(_DWORD *)(v1 + 36) = result;
  return result;
}

uint64_t (*AWDLActionFrame.ElectionParameter.electionID.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.ElectionParameter.electionFlags.getter()
{
  uint64_t v0;

  return *(unsigned int *)(v0 + 40);
}

uint64_t AWDLActionFrame.ElectionParameter.electionFlags.setter(uint64_t result)
{
  uint64_t v1;

  *(_DWORD *)(v1 + 40) = result;
  return result;
}

uint64_t AWDLActionFrame.ElectionParameter.selfLoopFreeCounter.getter()
{
  uint64_t v0;

  return *(unsigned int *)(v0 + 44);
}

uint64_t AWDLActionFrame.ElectionParameter.selfLoopFreeCounter.setter(uint64_t result)
{
  uint64_t v1;

  *(_DWORD *)(v1 + 44) = result;
  return result;
}

uint64_t (*AWDLActionFrame.ElectionParameter.selfLoopFreeCounter.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.ElectionParameter.init(rootNode:parentNode:rootLoopFreeCounter:hopCount:rootMetric:selfMetric:electionID:electionFlags:selfLoopFreeCounter:)@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, int a3@<W2>, int a4@<W3>, uint64_t a5@<X4>, uint64_t a6@<X5>, int a7@<W6>, int a8@<W7>, uint64_t a9@<X8>, int a10)
{
  *(_WORD *)a9 = result;
  *(_BYTE *)(a9 + 2) = BYTE2(result);
  *(_BYTE *)(a9 + 3) = BYTE3(result);
  *(_BYTE *)(a9 + 4) = BYTE4(result);
  *(_BYTE *)(a9 + 5) = BYTE5(result);
  *(_WORD *)(a9 + 6) = a2;
  *(_BYTE *)(a9 + 8) = BYTE2(a2);
  *(_BYTE *)(a9 + 9) = BYTE3(a2);
  *(_BYTE *)(a9 + 10) = BYTE4(a2);
  *(_BYTE *)(a9 + 11) = BYTE5(a2);
  *(_DWORD *)(a9 + 12) = a3;
  *(_DWORD *)(a9 + 16) = a4;
  *(_DWORD *)(a9 + 20) = a5;
  *(_BYTE *)(a9 + 24) = BYTE4(a5) & 1;
  *(_DWORD *)(a9 + 28) = a6;
  *(_BYTE *)(a9 + 32) = BYTE4(a6) & 1;
  *(_DWORD *)(a9 + 36) = a7;
  *(_DWORD *)(a9 + 40) = a8;
  *(_DWORD *)(a9 + 44) = a10;
  return result;
}

void AWDLActionFrame.ElectionParameter.hash(into:)()
{
  uint64_t v0;
  Swift::UInt8 v1;
  Swift::UInt8 v2;
  Swift::UInt8 v3;
  Swift::UInt8 v4;
  Swift::UInt8 v5;
  Swift::UInt8 v6;
  Swift::UInt8 v7;
  Swift::UInt8 v8;
  Swift::UInt8 v9;
  Swift::UInt8 v10;
  Swift::UInt32 v11;
  Swift::UInt32 v12;
  int v13;
  int v14;
  Swift::UInt32 v15;
  char v16;
  Swift::UInt32 v17;
  char v18;

  v1 = *(_BYTE *)(v0 + 1);
  v2 = *(_BYTE *)(v0 + 2);
  v3 = *(_BYTE *)(v0 + 3);
  v4 = *(_BYTE *)(v0 + 4);
  v5 = *(_BYTE *)(v0 + 5);
  Hasher._combine(_:)(*(_BYTE *)v0);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  v6 = *(_BYTE *)(v0 + 7);
  v7 = *(_BYTE *)(v0 + 8);
  v8 = *(_BYTE *)(v0 + 9);
  v9 = *(_BYTE *)(v0 + 10);
  v10 = *(_BYTE *)(v0 + 11);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 6));
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(*(_DWORD *)(v0 + 12));
  Hasher._combine(_:)(*(_DWORD *)(v0 + 16));
  sub_1000E7458((int *)(v0 + 20), (uint64_t)&v14);
  sub_1000E7458(&v14, (uint64_t)&v15);
  v11 = v15;
  if (v16 == 1)
    v11 = dword_100345874[v15];
  Hasher._combine(_:)(v11);
  sub_1000E7458((int *)(v0 + 28), (uint64_t)&v13);
  sub_1000E7458(&v13, (uint64_t)&v17);
  v12 = v17;
  if (v18 == 1)
    v12 = dword_100345874[v17];
  Hasher._combine(_:)(v12);
  Hasher._combine(_:)(*(_DWORD *)(v0 + 36));
  Hasher._combine(_:)(*(_DWORD *)(v0 + 40));
  Hasher._combine(_:)(*(_DWORD *)(v0 + 44));
}

uint64_t sub_1000D5C84(unsigned __int8 a1)
{
  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_1000D5CB8 + 4 * byte_1003412D8[a1]))(0x65646F4E746F6F72, 0xE800000000000000);
}

uint64_t sub_1000D5CB8()
{
  return 0x6F4E746E65726170;
}

unint64_t sub_1000D5CD8()
{
  return 0xD000000000000013;
}

uint64_t sub_1000D5D6C()
{
  unsigned __int8 *v0;

  return sub_1000D5C84(*v0);
}

uint64_t sub_1000D5D74@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;

  result = sub_1000EFC48(a1, a2);
  *a3 = result;
  return result;
}

void sub_1000D5D98(_BYTE *a1@<X8>)
{
  *a1 = 9;
}

uint64_t sub_1000D5DA4(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000E7494();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000D5DCC(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000E7494();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t AWDLActionFrame.ElectionParameter.encode(to:)(_QWORD *a1)
{
  int *v1;
  uint64_t v2;
  int *v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;
  int v21;
  __int16 v22;
  int v23;
  int v24;

  v3 = v1;
  v5 = sub_100012C44(&qword_1004072C0);
  v6 = *(_QWORD *)(v5 - 8);
  __chkstk_darwin();
  v8 = (char *)&v20 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  v9 = a1[3];
  v10 = a1[4];
  sub_10003259C(a1, v9);
  v11 = sub_1000E7494();
  dispatch thunk of Encoder.container<A>(keyedBy:)(&type metadata for AWDLActionFrame.ElectionParameter.CodingKeys, &type metadata for AWDLActionFrame.ElectionParameter.CodingKeys, v11, v9, v10);
  v21 = *v3;
  v22 = *((_WORD *)v3 + 2);
  HIBYTE(v20) = 0;
  v12 = sub_100039C34();
  KeyedEncodingContainer.encode<A>(_:forKey:)(&v21, (char *)&v20 + 7, v5, &type metadata for WiFiAddress, v12);
  if (!v2)
  {
    v21 = *(int *)((char *)v3 + 6);
    v22 = *((_WORD *)v3 + 5);
    HIBYTE(v20) = 1;
    KeyedEncodingContainer.encode<A>(_:forKey:)(&v21, (char *)&v20 + 7, v5, &type metadata for WiFiAddress, v12);
    v13 = v3[3];
    LOBYTE(v21) = 2;
    KeyedEncodingContainer.encode(_:forKey:)(v13, &v21, v5);
    v14 = v3[4];
    LOBYTE(v21) = 3;
    KeyedEncodingContainer.encode(_:forKey:)(v14, &v21, v5);
    sub_1000E7458(v3 + 5, (uint64_t)&v24);
    sub_1000E7458(&v24, (uint64_t)&v21);
    HIBYTE(v20) = 4;
    v15 = sub_1000E6B24();
    KeyedEncodingContainer.encode<A>(_:forKey:)(&v21, (char *)&v20 + 7, v5, &type metadata for AWDLElectionMetric, v15);
    sub_1000E7458(v3 + 7, (uint64_t)&v23);
    sub_1000E7458(&v23, (uint64_t)&v21);
    HIBYTE(v20) = 5;
    KeyedEncodingContainer.encode<A>(_:forKey:)(&v21, (char *)&v20 + 7, v5, &type metadata for AWDLElectionMetric, v15);
    v16 = v3[9];
    LOBYTE(v21) = 6;
    KeyedEncodingContainer.encode(_:forKey:)(v16, &v21, v5);
    v17 = v3[10];
    LOBYTE(v21) = 7;
    KeyedEncodingContainer.encode(_:forKey:)(v17, &v21, v5);
    v18 = v3[11];
    LOBYTE(v21) = 8;
    KeyedEncodingContainer.encode(_:forKey:)(v18, &v21, v5);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v6 + 8))(v8, v5);
}

Swift::Int AWDLActionFrame.ElectionParameter.hashValue.getter()
{
  _QWORD v1[9];

  Hasher.init(_seed:)(v1);
  AWDLActionFrame.ElectionParameter.hash(into:)();
  return Hasher._finalize()();
}

double AWDLActionFrame.ElectionParameter.init(from:)@<D0>(_QWORD *a1@<X0>, _OWORD *a2@<X8>)
{
  uint64_t v2;
  double result;
  __int128 v5;
  _OWORD v6[2];
  __int128 v7;

  sub_1000E5544(a1, v6);
  if (!v2)
  {
    v5 = v6[1];
    *a2 = v6[0];
    a2[1] = v5;
    result = *(double *)&v7;
    a2[2] = v7;
  }
  return result;
}

uint64_t sub_1000D612C(_QWORD *a1)
{
  return AWDLActionFrame.ElectionParameter.encode(to:)(a1);
}

Swift::Int sub_1000D6164()
{
  __int128 *v0;
  __int128 v1;
  _QWORD v3[9];
  __int128 v4;
  __int128 v5;
  __int128 v6;

  v1 = v0[1];
  v4 = *v0;
  v5 = v1;
  v6 = v0[2];
  Hasher.init(_seed:)(v3);
  AWDLActionFrame.ElectionParameter.hash(into:)();
  return Hasher._finalize()();
}

void sub_1000D61B4()
{
  AWDLActionFrame.ElectionParameter.hash(into:)();
}

Swift::Int sub_1000D61EC()
{
  __int128 *v0;
  __int128 v1;
  _QWORD v3[9];
  __int128 v4;
  __int128 v5;
  __int128 v6;

  v1 = v0[1];
  v4 = *v0;
  v5 = v1;
  v6 = v0[2];
  Hasher.init(_seed:)(v3);
  AWDLActionFrame.ElectionParameter.hash(into:)();
  return Hasher._finalize()();
}

BOOL sub_1000D6238(_OWORD *a1, __int128 *a2)
{
  __int128 v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  _OWORD v7[3];
  _OWORD v8[3];

  v2 = a1[1];
  v7[0] = *a1;
  v7[1] = v2;
  v3 = *a2;
  v4 = a2[1];
  v7[2] = a1[2];
  v8[0] = v3;
  v5 = a2[2];
  v8[1] = v4;
  v8[2] = v5;
  return _s7CoreP2P15AWDLActionFrameV17ElectionParameterV23__derived_struct_equalsySbAE_AEtFZ_0((uint64_t)v7, (uint64_t)v8);
}

uint64_t sub_1000D6280@<X0>(unsigned __int8 *a1@<X0>, _BYTE *a2@<X8>)
{
  uint64_t result;

  result = _s7CoreP2P15AWDLActionFrameV20MultiPeerBSSSteeringV17SteeringMessageIDO8rawValueAGSgs5UInt8V_tcfC_0(*a1);
  *a2 = result;
  return result;
}

uint64_t sub_1000D62A8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000F0458();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000D6304(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000F0458();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

uint64_t sub_1000D6350()
{
  return 0x496567617373656DLL;
}

uint64_t sub_1000D636C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  char v6;
  uint64_t result;
  char v8;

  if (a1 == 0x496567617373656DLL && a2 == 0xE900000000000044)
  {
    result = swift_bridgeObjectRelease(0xE900000000000044);
    v8 = 0;
  }
  else
  {
    v6 = _stringCompareWithSmolCheck(_:_:expecting:)(0x496567617373656DLL, 0xE900000000000044, a1, a2, 0);
    result = swift_bridgeObjectRelease(a2);
    v8 = v6 ^ 1;
  }
  *a3 = v8 & 1;
  return result;
}

uint64_t sub_1000D640C(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000E74D8();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000D6434(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000E74D8();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t AWDLActionFrame.MultiPeerBSSSteering.encode(to:)(_QWORD *a1, char a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v14;
  char v15;

  v4 = sub_100012C44(&qword_1004072D0);
  v5 = *(_QWORD *)(v4 - 8);
  __chkstk_darwin();
  v7 = (char *)&v14 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  v8 = a1[3];
  v9 = a1[4];
  sub_10003259C(a1, v8);
  v10 = sub_1000E74D8();
  dispatch thunk of Encoder.container<A>(keyedBy:)(&type metadata for AWDLActionFrame.MultiPeerBSSSteering.CodingKeys, &type metadata for AWDLActionFrame.MultiPeerBSSSteering.CodingKeys, v10, v8, v9);
  v15 = a2;
  v11 = sub_1000E751C();
  KeyedEncodingContainer.encode<A>(_:forKey:)(&v15, v12, v4, &type metadata for AWDLActionFrame.MultiPeerBSSSteering.SteeringMessageID, v11);
  return (*(uint64_t (**)(char *, uint64_t))(v5 + 8))(v7, v4);
}

unint64_t AWDLActionFrame.MultiPeerBSSSteering.init(from:)(_QWORD *a1)
{
  return sub_1000E58B4(a1);
}

unint64_t sub_1000D6568@<X0>(_QWORD *a1@<X0>, _BYTE *a2@<X8>)
{
  uint64_t v2;
  unint64_t result;

  result = sub_1000E58B4(a1);
  if (!v2)
    *a2 = result;
  return result;
}

uint64_t sub_1000D6590(_QWORD *a1)
{
  char *v1;

  return AWDLActionFrame.MultiPeerBSSSteering.encode(to:)(a1, *v1);
}

uint64_t sub_1000D65A8()
{
  _BYTE *v0;

  if (*v0)
    return 0x44496E656B6F74;
  else
    return 0x7367616C66;
}

uint64_t sub_1000D65E0@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;

  result = sub_1000F0014(a1, a2);
  *a3 = result;
  return result;
}

uint64_t sub_1000D6604(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000E7560();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000D662C(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000E7560();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t AWDLActionFrame.Ranging.encode(to:)(_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v14;
  char v15;
  _BYTE v16[6];
  char v17;

  v5 = sub_100012C44(&qword_1004072E8);
  v6 = *(_QWORD *)(v5 - 8);
  __chkstk_darwin();
  v8 = (char *)&v14 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  v9 = a1[3];
  v10 = a1[4];
  sub_10003259C(a1, v9);
  v11 = sub_1000E7560();
  dispatch thunk of Encoder.container<A>(keyedBy:)(&type metadata for AWDLActionFrame.Ranging.CodingKeys, &type metadata for AWDLActionFrame.Ranging.CodingKeys, v11, v9, v10);
  v17 = 0;
  KeyedEncodingContainer.encode(_:forKey:)(a2, &v17, v5);
  if (!v2)
  {
    v16[0] = BYTE1(a2);
    v16[1] = BYTE2(a2);
    v16[2] = BYTE3(a2);
    v16[3] = BYTE4(a2);
    v16[4] = BYTE5(a2);
    v16[5] = BYTE6(a2);
    v15 = 1;
    v12 = sub_100039C34();
    KeyedEncodingContainer.encode<A>(_:forKey:)(v16, &v15, v5, &type metadata for WiFiAddress, v12);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v6 + 8))(v8, v5);
}

uint64_t AWDLActionFrame.Ranging.init(from:)(_QWORD *a1)
{
  return sub_1000E59D4(a1) & 0xFFFFFFFFFFFFFFLL;
}

uint64_t sub_1000D67C0@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t result;

  result = sub_1000E59D4(a1);
  if (!v2)
  {
    *(_WORD *)a2 = result;
    *(_BYTE *)(a2 + 2) = BYTE2(result);
    *(_BYTE *)(a2 + 3) = BYTE3(result);
    *(_BYTE *)(a2 + 4) = BYTE4(result);
    *(_BYTE *)(a2 + 5) = BYTE5(result);
    *(_BYTE *)(a2 + 6) = BYTE6(result);
  }
  return result;
}

uint64_t sub_1000D6818(_QWORD *a1)
{
  unsigned __int16 *v1;

  return AWDLActionFrame.Ranging.encode(to:)(a1, *v1 | ((unint64_t)*((unsigned __int8 *)v1 + 2) << 16) | ((unint64_t)*(unsigned int *)((char *)v1 + 3) << 24));
}

void *AWDLActionFrame.RealtimeGroup.Flags.airPlaySender.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.Flags.airPlaySender;
}

void *AWDLActionFrame.RealtimeGroup.Flags.universalControl.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.Flags.universalControl;
}

void *AWDLActionFrame.RealtimeGroup.Flags.sidecar.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.Flags.sidecar;
}

void *AWDLActionFrame.RealtimeGroup.Flags.airPlay.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.Flags.airPlay;
}

void *AWDLActionFrame.RealtimeGroup.Flags.mpRemoteCamera.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.Flags.mpRemoteCamera;
}

void *AWDLActionFrame.RealtimeGroup.Flags.ultraLowLatencyInfrastructure.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.Flags.ultraLowLatencyInfrastructure;
}

void *AWDLActionFrame.RealtimeGroup.Flags.discoveryActive.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.Flags.discoveryActive;
}

void *AWDLActionFrame.RealtimeGroup.Flags.forceRetro.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.Flags.forceRetro;
}

uint64_t sub_1000D68A0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000E81E0();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000D68FC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000E81E0();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

void *AWDLActionFrame.RealtimeGroup.AdditionalFlags.alwaysPrioritizeInfra.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.AdditionalFlags.alwaysPrioritizeInfra;
}

void *AWDLActionFrame.RealtimeGroup.AdditionalFlags.twoGHzRetroModeSupported.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.AdditionalFlags.twoGHzRetroModeSupported;
}

void *AWDLActionFrame.RealtimeGroup.AdditionalFlags.edgeKit.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.AdditionalFlags.edgeKit;
}

void *AWDLActionFrame.RealtimeGroup.AdditionalFlags.disableWiFiDisconnect.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.AdditionalFlags.disableWiFiDisconnect;
}

void *AWDLActionFrame.RealtimeGroup.AdditionalFlags.disableRemoteScreenRTGSync.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.AdditionalFlags.disableRemoteScreenRTGSync;
}

void *AWDLActionFrame.RealtimeGroup.AdditionalFlags.remoteCamera.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.AdditionalFlags.remoteCamera;
}

void *AWDLActionFrame.RealtimeGroup.AdditionalFlags.tvRemoteCamera.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.AdditionalFlags.tvRemoteCamera;
}

void *AWDLActionFrame.RealtimeGroup.AdditionalFlags.remoteScreen.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.RealtimeGroup.AdditionalFlags.remoteScreen;
}

uint64_t sub_1000D69A8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000E8300();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000D6A04(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000E8300();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

unint64_t AWDLActionFrame.RealtimeGroup.groupID.getter()
{
  uint64_t v0;

  return *(unsigned __int16 *)(v0 + 1) | ((unint64_t)*(unsigned int *)(v0 + 3) << 16);
}

unint64_t AWDLActionFrame.RealtimeGroup.infrastructureChannel.getter()
{
  uint64_t v0;

  return *(unsigned int *)(v0 + 8) | ((unint64_t)*(unsigned __int16 *)(v0 + 12) << 32);
}

uint64_t AWDLActionFrame.RealtimeGroup.infrastructureChannel.setter(uint64_t result)
{
  uint64_t v1;

  *(_DWORD *)(v1 + 8) = result;
  *(_WORD *)(v1 + 12) = WORD2(result);
  return result;
}

uint64_t InfraStatistics.bkOutputPackets.getter()
{
  uint64_t v0;

  return *(_QWORD *)(v0 + 16);
}

uint64_t NANBeacon.Metadata.rate.setter(uint64_t result)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 16) = result;
  return result;
}

uint64_t IEEE80211InformationElement.PreAssociationSecurityNegotiationParameters.finiteCylicGroupID.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 24);
}

uint64_t AWDLActionFrame.RealtimeGroup.additionalFlags.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 24) = result;
  return result;
}

unint64_t AWDLActionFrame.RealtimeGroup.customRealtimeGroupInfraChannel.getter()
{
  uint64_t v0;

  return *(unsigned int *)(v0 + 28) | ((unint64_t)*(unsigned __int16 *)(v0 + 32) << 32);
}

uint64_t AWDLActionFrame.RealtimeGroup.customRealtimeGroupInfraChannel.setter(uint64_t result)
{
  uint64_t v1;

  *(_DWORD *)(v1 + 28) = result;
  *(_WORD *)(v1 + 32) = WORD2(result);
  return result;
}

void *AWDLActionFrame.RealtimeGroup.activeServiceIdentifiers.getter()
{
  char *v0;
  char v1;
  char v2;
  id v4;
  void *v5;

  v5 = &_swiftEmptySetSingleton;
  v1 = *v0;
  if ((*v0 & 4) != 0)
  {
    sub_1000DEA34(&v4, AWDLTrafficRegistrationServiceSidecar);

  }
  if ((v1 & 2) != 0)
  {
    sub_1000DEA34(&v4, AWDLTrafficRegistrationServiceUniversalControl);

  }
  if ((v1 & 9) != 0)
  {
    sub_1000DEA34(&v4, AWDLTrafficRegistrationServiceAirPlay);

  }
  if ((v1 & 0x10) != 0)
  {
    sub_1000DEA34(&v4, AWDLTrafficRegistrationServiceMPRemoteCamera);

    v2 = v0[24];
    if ((v2 & 4) == 0)
    {
LABEL_9:
      if ((v2 & 0x20) == 0)
        goto LABEL_10;
      goto LABEL_15;
    }
  }
  else
  {
    v2 = v0[24];
    if ((v2 & 4) == 0)
      goto LABEL_9;
  }
  sub_1000DEA34(&v4, AWDLTrafficRegistrationServiceEdgeKit);

  if ((v2 & 0x20) == 0)
  {
LABEL_10:
    if ((v2 & 0x40) == 0)
      goto LABEL_11;
LABEL_16:
    sub_1000DEA34(&v4, AWDLTrafficRegistrationServiceTVRemoteCamera);

    if ((v2 & 0x80) == 0)
      return v5;
LABEL_17:
    sub_1000DEA34(&v4, AWDLTrafficRegistrationServiceRemoteScreen);

    return v5;
  }
LABEL_15:
  sub_1000DEA34(&v4, AWDLTrafficRegistrationServiceRemoteCamera);

  if ((v2 & 0x40) != 0)
    goto LABEL_16;
LABEL_11:
  if (v2 < 0)
    goto LABEL_17;
  return v5;
}

void AWDLActionFrame.RealtimeGroup.hash(into:)()
{
  uint64_t v0;
  Swift::UInt8 v1;
  Swift::UInt8 v2;
  Swift::UInt8 v3;
  Swift::UInt8 v4;
  Swift::UInt8 v5;
  unint64_t v6;
  Swift::UInt8 v7;
  unint64_t v8;
  Swift::UInt8 v9;
  Swift::UInt8 v10;
  Swift::UInt8 v11;
  Swift::UInt8 v12;
  Swift::UInt8 v13;
  Swift::UInt8 v14;

  Hasher._combine(_:)(*(_BYTE *)v0);
  v1 = *(_BYTE *)(v0 + 2);
  v2 = *(_BYTE *)(v0 + 3);
  v3 = *(_BYTE *)(v0 + 4);
  v4 = *(_BYTE *)(v0 + 5);
  v5 = *(_BYTE *)(v0 + 6);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 1));
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  v6 = *(unsigned int *)(v0 + 8) | ((unint64_t)*(unsigned __int16 *)(v0 + 12) << 32);
  if ((v6 & 0xFF00000000) == 0x300000000)
  {
    v7 = 0;
LABEL_3:
    Hasher._combine(_:)(v7);
  }
  else
  {
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(v6);
    Hasher._combine(_:)(0x801004u >> ((v6 >> 29) & 0xF8));
    switch(v6 >> 40)
    {
      case 2uLL:
        Hasher._combine(_:)(0);
        break;
      case 3uLL:
        Hasher._combine(_:)(1uLL);
        break;
      case 4uLL:
        Hasher._combine(_:)(3uLL);
        break;
      case 5uLL:
        Hasher._combine(_:)(4uLL);
        break;
      case 6uLL:
        Hasher._combine(_:)(5uLL);
        break;
      default:
        Hasher._combine(_:)(2uLL);
        v7 = BYTE5(v6) & 1;
        goto LABEL_3;
    }
  }
  Hasher._combine(_:)(*(_QWORD *)(v0 + 16));
  Hasher._combine(_:)(*(_BYTE *)(v0 + 24));
  v8 = *(unsigned int *)(v0 + 28) | ((unint64_t)*(unsigned __int16 *)(v0 + 32) << 32);
  if ((v8 & 0xFF00000000) == 0x300000000)
  {
    v9 = 0;
LABEL_6:
    Hasher._combine(_:)(v9);
  }
  else
  {
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(v8);
    Hasher._combine(_:)(0x801004u >> ((v8 >> 29) & 0xF8));
    switch(v8 >> 40)
    {
      case 2uLL:
        Hasher._combine(_:)(0);
        break;
      case 3uLL:
        Hasher._combine(_:)(1uLL);
        break;
      case 4uLL:
        Hasher._combine(_:)(3uLL);
        break;
      case 5uLL:
        Hasher._combine(_:)(4uLL);
        break;
      case 6uLL:
        Hasher._combine(_:)(5uLL);
        break;
      default:
        Hasher._combine(_:)(2uLL);
        v9 = BYTE5(v8) & 1;
        goto LABEL_6;
    }
  }
  v10 = *(_BYTE *)(v0 + 35);
  v11 = *(_BYTE *)(v0 + 36);
  v12 = *(_BYTE *)(v0 + 37);
  v13 = *(_BYTE *)(v0 + 38);
  v14 = *(_BYTE *)(v0 + 39);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 34));
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(v11);
  Hasher._combine(_:)(v12);
  Hasher._combine(_:)(v13);
  Hasher._combine(_:)(v14);
}

Swift::Int AWDLActionFrame.RealtimeGroup.hashValue.getter()
{
  _QWORD v1[9];

  Hasher.init(_seed:)(v1);
  AWDLActionFrame.RealtimeGroup.hash(into:)();
  return Hasher._finalize()();
}

double sub_1000D6F14@<D0>(_QWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  double result;
  __int128 v5;
  _OWORD v6[2];
  uint64_t v7;

  result = AWDLActionFrame.RealtimeGroup.init(from:)(a1, (uint64_t)v6);
  if (!v2)
  {
    result = *(double *)v6;
    v5 = v6[1];
    *(_OWORD *)a2 = v6[0];
    *(_OWORD *)(a2 + 16) = v5;
    *(_QWORD *)(a2 + 32) = v7;
  }
  return result;
}

double AWDLActionFrame.RealtimeGroup.init(from:)@<D0>(_QWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  double result;
  __int128 v5;
  _OWORD v6[2];
  uint64_t v7;

  sub_1000E6644(a1, (uint64_t)v6);
  if (!v2)
  {
    result = *(double *)v6;
    v5 = v6[1];
    *(_OWORD *)a2 = v6[0];
    *(_OWORD *)(a2 + 16) = v5;
    *(_QWORD *)(a2 + 32) = v7;
  }
  return result;
}

uint64_t sub_1000D6F9C(_QWORD *a1)
{
  return AWDLActionFrame.RealtimeGroup.encode(to:)(a1);
}

uint64_t AWDLActionFrame.RealtimeGroup.encode(to:)(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t result;
  int v27;
  __int16 v28;
  _QWORD v29[3];
  uint64_t v30;
  uint64_t v31;
  _BYTE v32[8];
  _BYTE v33[8];
  unsigned int v34;
  unsigned __int16 v35;
  unsigned int v36;
  unsigned __int16 v37;

  v3 = v1;
  v4 = a1[3];
  v5 = a1[4];
  sub_10003259C(a1, v4);
  dispatch thunk of Encoder.unkeyedContainer()(v29, v4, v5);
  LOBYTE(v27) = *(_BYTE *)v1;
  v6 = v30;
  v7 = v31;
  sub_100034C68((uint64_t)v29, v30);
  v8 = sub_1000E75A4();
  dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(&v27, &type metadata for AWDLActionFrame.RealtimeGroup.Flags, v8, v6, v7);
  if (v2)
    return sub_100014430(v29);
  v27 = *(_DWORD *)(v1 + 1);
  v28 = *(_WORD *)(v1 + 5);
  v9 = v30;
  v10 = v31;
  sub_100034C68((uint64_t)v29, v30);
  v11 = sub_100039C34();
  dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(&v27, &type metadata for WiFiAddress, v11, v9, v10);
  sub_1000E75E8(v1 + 8, (uint64_t)v33);
  sub_1000E75E8((uint64_t)v33, (uint64_t)&v34);
  v12 = v34 | ((unint64_t)v35 << 32);
  if ((v12 & 0xFF00000000) == 0x300000000)
  {
    v12 = 0;
  }
  else if (v34 >= 0x100)
  {
    goto LABEL_19;
  }
  v13 = v30;
  v14 = v31;
  sub_100034C68((uint64_t)v29, v30);
  dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v12, v13, v14);
  v15 = *(_QWORD *)(v3 + 16);
  if (v15 < -128)
  {
    __break(1u);
  }
  else if (v15 <= 127)
  {
    v16 = v30;
    v17 = v31;
    sub_100034C68((uint64_t)v29, v30);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v15, v16, v17);
    LOBYTE(v27) = *(_BYTE *)(v3 + 24);
    v18 = v30;
    v19 = v31;
    sub_100034C68((uint64_t)v29, v30);
    v20 = sub_1000E7630();
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(&v27, &type metadata for AWDLActionFrame.RealtimeGroup.AdditionalFlags, v20, v18, v19);
    sub_1000E75E8(v3 + 28, (uint64_t)v32);
    sub_1000E75E8((uint64_t)v32, (uint64_t)&v36);
    if (((v36 | ((unint64_t)v37 << 32)) & 0xFF00000000) == 0x300000000)
      v21 = 0;
    else
      v21 = v36;
    v22 = v30;
    v23 = v31;
    sub_100034C68((uint64_t)v29, v30);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v21, v22, v23);
    v27 = *(_DWORD *)(v3 + 34);
    v28 = *(_WORD *)(v3 + 38);
    v24 = v30;
    v25 = v31;
    sub_100034C68((uint64_t)v29, v30);
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(&v27, &type metadata for WiFiAddress, v11, v24, v25);
    return sub_100014430(v29);
  }
  __break(1u);
LABEL_19:
  result = _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 3455, 0);
  __break(1u);
  return result;
}

Swift::Int sub_1000D72E0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000D72EC(a1, a2, a3, (void (*)(_QWORD *))AWDLActionFrame.RealtimeGroup.hash(into:));
}

Swift::Int sub_1000D72EC(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(_QWORD *))
{
  _QWORD v6[9];

  Hasher.init(_seed:)(v6);
  a4(v6);
  return Hasher._finalize()();
}

BOOL sub_1000D7328(uint64_t a1, uint64_t a2)
{
  __int128 v2;
  __int128 v3;
  _OWORD v5[2];
  uint64_t v6;
  _OWORD v7[2];
  uint64_t v8;

  v2 = *(_OWORD *)(a1 + 16);
  v5[0] = *(_OWORD *)a1;
  v5[1] = v2;
  v6 = *(_QWORD *)(a1 + 32);
  v3 = *(_OWORD *)(a2 + 16);
  v7[0] = *(_OWORD *)a2;
  v7[1] = v3;
  v8 = *(_QWORD *)(a2 + 32);
  return _s7CoreP2P15AWDLActionFrameV13RealtimeGroupV23__derived_struct_equalsySbAE_AEtFZ_0((unsigned __int8 *)v5, (unsigned __int8 *)v7);
}

uint64_t sub_1000D7370(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000E7674();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000D7398(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000E7674();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t AWDLActionFrame.ExtendedChannelSequence.encode(to:)(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v10;

  v2 = sub_100012C44(&qword_100407308);
  v3 = *(_QWORD *)(v2 - 8);
  __chkstk_darwin();
  v5 = (char *)&v10 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  v6 = a1[3];
  v7 = a1[4];
  sub_10003259C(a1, v6);
  v8 = sub_1000E7674();
  dispatch thunk of Encoder.container<A>(keyedBy:)(&type metadata for AWDLActionFrame.ExtendedChannelSequence.CodingKeys, &type metadata for AWDLActionFrame.ExtendedChannelSequence.CodingKeys, v8, v6, v7);
  return (*(uint64_t (**)(char *, uint64_t))(v3 + 8))(v5, v2);
}

Swift::Int NANBeacon.hashValue.getter()
{
  _QWORD v1[9];

  Hasher.init(_seed:)(v1);
  return Hasher._finalize()();
}

uint64_t IEEE80211InformationElement.VeryHighThroughputOperation.init(from:)(_QWORD *a1)
{
  return sub_100014430(a1);
}

Swift::Int sub_1000D74DC()
{
  _QWORD v1[9];

  Hasher.init(_seed:)(v1);
  return Hasher._finalize()();
}

uint64_t AWDLActionFrame.PreferredChannels.PreferredChannel.txPower.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 6) = result;
  return result;
}

void AWDLActionFrame.PreferredChannels.PreferredChannel.hash(into:)(int a1, unint64_t a2)
{
  Swift::UInt v3;

  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(0x801004u >> ((a2 >> 29) & 0xF8));
  switch(BYTE5(a2))
  {
    case 2:
      v3 = 0;
      goto LABEL_8;
    case 3:
      v3 = 1;
      goto LABEL_8;
    case 4:
      v3 = 3;
      goto LABEL_8;
    case 5:
      v3 = 4;
      goto LABEL_8;
    case 6:
      v3 = 5;
LABEL_8:
      Hasher._combine(_:)(v3);
      break;
    default:
      Hasher._combine(_:)(2uLL);
      Hasher._combine(_:)(BYTE5(a2) & 1);
      break;
  }
  Hasher._combine(_:)(BYTE6(a2));
}

BOOL static AWDLActionFrame.PreferredChannels.PreferredChannel.__derived_struct_equals(_:_:)(uint64_t a1, uint64_t a2)
{
  return sub_1000E1E28(a1 & 0xFFFFFFFFFFFFFFLL, a2 & 0xFFFFFFFFFFFFFFLL);
}

Swift::Int AWDLActionFrame.PreferredChannels.PreferredChannel.hashValue.getter(uint64_t a1)
{
  _QWORD v3[9];

  Hasher.init(_seed:)(v3);
  AWDLActionFrame.PreferredChannels.PreferredChannel.hash(into:)((int)v3, a1 & 0xFFFFFFFFFFFFFFLL);
  return Hasher._finalize()();
}

Swift::Int sub_1000D7610()
{
  unsigned __int8 *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD v6[9];

  v1 = *(unsigned int *)v0;
  v2 = v0[4];
  v3 = v0[5];
  v4 = v0[6];
  Hasher.init(_seed:)(v6);
  AWDLActionFrame.PreferredChannels.PreferredChannel.hash(into:)((int)v6, v1 | (v2 << 32) | (v3 << 40) | (v4 << 48));
  return Hasher._finalize()();
}

void sub_1000D7670(int a1)
{
  unsigned __int8 *v1;

  AWDLActionFrame.PreferredChannels.PreferredChannel.hash(into:)(a1, *(unsigned int *)v1 | ((unint64_t)v1[4] << 32) | ((unint64_t)v1[5] << 40) | ((unint64_t)v1[6] << 48));
}

Swift::Int sub_1000D7690()
{
  unsigned __int8 *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD v6[9];

  v1 = *(unsigned int *)v0;
  v2 = v0[4];
  v3 = v0[5];
  v4 = v0[6];
  Hasher.init(_seed:)(v6);
  AWDLActionFrame.PreferredChannels.PreferredChannel.hash(into:)((int)v6, v1 | (v2 << 32) | (v3 << 40) | (v4 << 48));
  return Hasher._finalize()();
}

BOOL sub_1000D76EC(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return sub_1000E1E28(*(unsigned int *)a1 | ((unint64_t)a1[4] << 32) | ((unint64_t)a1[5] << 40) | ((unint64_t)a1[6] << 48), *(unsigned int *)a2 | ((unint64_t)a2[4] << 32) | ((unint64_t)a2[5] << 40) | ((unint64_t)a2[6] << 48));
}

void AWDLActionFrame.PreferredChannels.hash(into:)(uint64_t a1, unint64_t a2, uint64_t a3)
{
  Swift::UInt v6;

  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(0x801004u >> ((a2 >> 29) & 0xF8));
  switch(BYTE5(a2))
  {
    case 2:
      v6 = 0;
      goto LABEL_8;
    case 3:
      v6 = 1;
      goto LABEL_8;
    case 4:
      v6 = 3;
      goto LABEL_8;
    case 5:
      v6 = 4;
      goto LABEL_8;
    case 6:
      v6 = 5;
LABEL_8:
      Hasher._combine(_:)(v6);
      break;
    default:
      Hasher._combine(_:)(2uLL);
      Hasher._combine(_:)(BYTE5(a2) & 1);
      break;
  }
  sub_10008E664(a1, a3);
}

uint64_t static AWDLActionFrame.PreferredChannels.__derived_struct_equals(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1000E1F08(a1 & 0xFFFFFFFFFFFFLL, a2, a3 & 0xFFFFFFFFFFFFLL, a4);
}

Swift::Int AWDLActionFrame.PreferredChannels.hashValue.getter(unint64_t a1, uint64_t a2)
{
  Swift::UInt v4;
  _QWORD v6[9];

  Hasher.init(_seed:)(v6);
  Hasher._combine(_:)(a1);
  Hasher._combine(_:)(0x801004u >> ((a1 >> 29) & 0xF8));
  switch(BYTE5(a1))
  {
    case 2:
      v4 = 0;
      goto LABEL_8;
    case 3:
      v4 = 1;
      goto LABEL_8;
    case 4:
      v4 = 3;
      goto LABEL_8;
    case 5:
      v4 = 4;
      goto LABEL_8;
    case 6:
      v4 = 5;
LABEL_8:
      Hasher._combine(_:)(v4);
      break;
    default:
      Hasher._combine(_:)(2uLL);
      Hasher._combine(_:)(BYTE5(a1) & 1);
      break;
  }
  sub_10008E664((uint64_t)v6, a2);
  return Hasher._finalize()();
}

uint64_t sub_1000D78E4@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v5;

  result = sub_1000E5B4C(a1);
  if (!v2)
  {
    *(_DWORD *)a2 = result;
    *(_BYTE *)(a2 + 4) = BYTE4(result);
    *(_BYTE *)(a2 + 5) = BYTE5(result);
    *(_QWORD *)(a2 + 8) = v5;
  }
  return result;
}

uint64_t AWDLActionFrame.PreferredChannels.init(from:)(_QWORD *a1)
{
  return sub_1000E5B4C(a1) & 0xFFFFFFFFFFFFLL;
}

uint64_t sub_1000D7944(_QWORD *a1)
{
  unsigned int *v1;

  return AWDLActionFrame.PreferredChannels.encode(to:)(a1, *v1 | ((unint64_t)*((unsigned __int8 *)v1 + 4) << 32) | ((unint64_t)*((unsigned __int8 *)v1 + 5) << 40), *((_QWORD *)v1 + 1));
}

uint64_t AWDLActionFrame.PreferredChannels.encode(to:)(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned __int8 *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  _QWORD v31[3];
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;

  v6 = a1[3];
  v7 = a1[4];
  sub_10003259C(a1, v6);
  dispatch thunk of Encoder.unkeyedContainer()(v31, v6, v7);
  v8 = v32;
  v9 = v33;
  sub_100034C68((uint64_t)v31, v32);
  dispatch thunk of UnkeyedEncodingContainer.encode(_:)(0, v8, v9);
  if (!v3)
  {
    if ((a2 & 0xFFFFFF00) != 0)
      goto LABEL_15;
    v10 = v32;
    v11 = v33;
    sub_100034C68((uint64_t)v31, v32);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(a2, v10, v11);
    v12 = Channel.operatingClass.getter(a2 & 0xFFFFFFFFFFFFLL);
    v13 = v32;
    v14 = v33;
    sub_100034C68((uint64_t)v31, v32);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v12, v13, v14);
    v15 = *(_QWORD *)(a3 + 16);
    if (v15 >= 0x100)
      goto LABEL_15;
    v16 = v32;
    v17 = v33;
    sub_100034C68((uint64_t)v31, v32);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v15, v16, v17);
    if (v15)
    {
      v18 = *(unsigned int *)(a3 + 32);
      if (v18 <= 0xFF)
      {
        v34 = *(unsigned __int8 *)(a3 + 38);
        v19 = *(unsigned __int8 *)(a3 + 37);
        v20 = *(unsigned __int8 *)(a3 + 36);
        swift_bridgeObjectRetain(a3);
        v30 = a3;
        v21 = (unsigned __int8 *)(a3 + 46);
        while (1)
        {
          v22 = v32;
          v23 = v33;
          sub_100034C68((uint64_t)v31, v32);
          dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v18, v22, v23);
          v24 = Channel.operatingClass.getter((v19 << 40) | (v20 << 32) | v18);
          v25 = v32;
          v26 = v33;
          sub_100034C68((uint64_t)v31, v32);
          dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v24, v25, v26);
          v27 = v32;
          v28 = v33;
          sub_100034C68((uint64_t)v31, v32);
          dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v34, v27, v28);
          if (!--v15)
            goto LABEL_16;
          v34 = *v21;
          v19 = *(v21 - 1);
          v20 = *(v21 - 2);
          v18 = *(unsigned int *)(v21 - 6);
          v21 += 8;
          if (v18 > 0xFF)
            goto LABEL_15;
        }
      }
      swift_bridgeObjectRetain(a3);
LABEL_15:
      _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 3455, 0);
      __break(1u);
LABEL_16:
      swift_bridgeObjectRelease(v30);
    }
  }
  return sub_100014430(v31);
}

Swift::Int sub_1000D7C2C()
{
  unsigned int *v0;

  return AWDLActionFrame.PreferredChannels.hashValue.getter(*v0 | ((unint64_t)*((unsigned __int8 *)v0 + 4) << 32) | ((unint64_t)*((unsigned __int8 *)v0 + 5) << 40), *((_QWORD *)v0 + 1));
}

void sub_1000D7C48(uint64_t a1)
{
  unsigned int *v1;

  AWDLActionFrame.PreferredChannels.hash(into:)(a1, *v1 | ((unint64_t)*((unsigned __int8 *)v1 + 4) << 32) | ((unint64_t)*((unsigned __int8 *)v1 + 5) << 40), *((_QWORD *)v1 + 1));
}

Swift::Int sub_1000D7C64()
{
  uint64_t v0;
  Swift::UInt32 v1;
  char v2;
  int v3;
  uint64_t v4;
  Swift::UInt v5;
  _QWORD v7[9];

  v1 = *(_DWORD *)v0;
  v2 = *(_BYTE *)(v0 + 4);
  v3 = *(unsigned __int8 *)(v0 + 5);
  v4 = *(_QWORD *)(v0 + 8);
  Hasher.init(_seed:)(v7);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(0x801004u >> (8 * v2));
  switch(v3)
  {
    case 2:
      v5 = 0;
      goto LABEL_8;
    case 3:
      v5 = 1;
      goto LABEL_8;
    case 4:
      v5 = 3;
      goto LABEL_8;
    case 5:
      v5 = 4;
      goto LABEL_8;
    case 6:
      v5 = 5;
LABEL_8:
      Hasher._combine(_:)(v5);
      break;
    default:
      Hasher._combine(_:)(2uLL);
      Hasher._combine(_:)(v3 & 1);
      break;
  }
  sub_10008E664((uint64_t)v7, v4);
  return Hasher._finalize()();
}

uint64_t sub_1000D7D64(unsigned int *a1, unsigned int *a2)
{
  return sub_1000E1F08(*a1 | ((unint64_t)*((unsigned __int8 *)a1 + 4) << 32) | ((unint64_t)*((unsigned __int8 *)a1 + 5) << 40), *((_QWORD *)a1 + 1), *a2 | ((unint64_t)*((unsigned __int8 *)a2 + 4) << 32) | ((unint64_t)*((unsigned __int8 *)a2 + 5) << 40), *((_QWORD *)a2 + 1));
}

CoreP2P::AWDLActionFrame::ProMode::Command_optional __swiftcall AWDLActionFrame.ProMode.Command.init(rawValue:)(Swift::UInt8 rawValue)
{
  if ((rawValue & 0xFC) != 0)
    return (CoreP2P::AWDLActionFrame::ProMode::Command_optional)3;
  else
    return (CoreP2P::AWDLActionFrame::ProMode::Command_optional)(0x2010003u >> (8 * rawValue));
}

uint64_t IEEE80211InformationElement.AuthenticationKeyManagementSuite.rawValue.getter(int a1)
{
  return (a1 + 1);
}

unsigned __int8 *sub_1000D7DC8@<X0>(unsigned __int8 *result@<X0>, char *a2@<X8>)
{
  unsigned int v2;
  char v3;

  v2 = *result;
  if (v2 <= 3)
    v3 = 0x2010003u >> (8 * v2);
  else
    v3 = 3;
  *a2 = v3;
  return result;
}

void sub_1000D7DF0(_BYTE *a1@<X8>)
{
  _BYTE *v1;

  *a1 = *v1 + 1;
}

uint64_t sub_1000D7E00(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000F0414();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000D7E5C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000F0414();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

Swift::Int sub_1000D7EA8()
{
  char *v0;
  char v1;
  _QWORD v3[9];

  v1 = *v0;
  Hasher.init(_seed:)(v3);
  Hasher._combine(_:)(v1 + 1);
  return Hasher._finalize()();
}

void sub_1000D7EEC()
{
  _BYTE *v0;

  Hasher._combine(_:)(*v0 + 1);
}

Swift::Int sub_1000D7F18()
{
  char *v0;
  char v1;
  _QWORD v3[9];

  v1 = *v0;
  Hasher.init(_seed:)(v3);
  Hasher._combine(_:)(v1 + 1);
  return Hasher._finalize()();
}

void *AWDLActionFrame.ProMode.Flags.running.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.ProMode.Flags.running;
}

void *AWDLActionFrame.ProMode.Flags.entering.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.ProMode.Flags.entering;
}

void *AWDLActionFrame.ProMode.Flags.exiting.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.ProMode.Flags.exiting;
}

void *AWDLActionFrame.ProMode.Flags.waitingForResponse.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.ProMode.Flags.waitingForResponse;
}

void *AWDLActionFrame.ProMode.Flags.waitingToEnter.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.ProMode.Flags.waitingToEnter;
}

void *AWDLActionFrame.ProMode.Flags.sendingResponse.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.ProMode.Flags.sendingResponse;
}

uint64_t sub_1000D7FA8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000E8588();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000D8004(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000E8588();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

void sub_1000D8050(_DWORD *a1@<X8>)
{
  *a1 = 0;
}

uint64_t sub_1000D8058@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X8>)
{
  int v4;
  uint64_t result;

  v4 = sub_1001A4AD0();
  result = swift_bridgeObjectRelease(a1);
  *a2 = v4;
  return result;
}

unint64_t NANFollowUpTransferCompleteEvent.peerInstanceID.getter(unint64_t a1)
{
  return a1 >> 8;
}

void AWDLActionFrame.ProMode.hash(into:)(int a1, unint64_t a2, Swift::UInt32 a3)
{
  unint64_t v4;
  unint64_t v5;

  v4 = a2 >> 8;
  v5 = HIDWORD(a2);
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v4 + 1);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(a3);
}

BOOL static AWDLActionFrame.ProMode.__derived_struct_equals(_:_:)(uint64_t a1, int a2, uint64_t a3, int a4)
{
  _BOOL4 v6;

  v6 = BYTE1(a1) == BYTE1(a3) && HIDWORD(a1) == HIDWORD(a3) && a2 == a4;
  return a1 == a3 && v6;
}

uint64_t sub_1000D811C()
{
  unsigned __int8 *v0;

  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_1000D814C + 4 * byte_1003412FF[*v0]))(0x6E6F6973726576, 0xE700000000000000);
}

uint64_t sub_1000D814C()
{
  return 0x646E616D6D6F63;
}

uint64_t sub_1000D8160()
{
  return 0x737574617473;
}

uint64_t sub_1000D8174()
{
  return 0x7367616C66;
}

uint64_t sub_1000D8188@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;

  result = sub_1000F00FC(a1, a2);
  *a3 = result;
  return result;
}

uint64_t sub_1000D81AC(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000E76B8();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000D81D4(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000E76B8();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t AWDLActionFrame.ProMode.encode(to:)(_QWORD *a1, unint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v17;
  char v18;
  int v19;
  char v20;
  char v21;
  char v22;
  char v23;

  v7 = sub_100012C44(&qword_100407318);
  v8 = *(_QWORD *)(v7 - 8);
  __chkstk_darwin();
  v10 = (char *)&v17 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  v11 = a1[3];
  v12 = a1[4];
  sub_10003259C(a1, v11);
  v13 = sub_1000E76B8();
  dispatch thunk of Encoder.container<A>(keyedBy:)(&type metadata for AWDLActionFrame.ProMode.CodingKeys, &type metadata for AWDLActionFrame.ProMode.CodingKeys, v13, v11, v12);
  v23 = 0;
  KeyedEncodingContainer.encode(_:forKey:)(a2, &v23, v7);
  if (!v3)
  {
    v22 = BYTE1(a2);
    v21 = 1;
    v14 = sub_1000E76FC();
    KeyedEncodingContainer.encode<A>(_:forKey:)(&v22, &v21, v7, &type metadata for AWDLActionFrame.ProMode.Command, v14);
    v20 = 2;
    KeyedEncodingContainer.encode(_:forKey:)(HIDWORD(a2), &v20, v7);
    v19 = a3;
    v18 = 3;
    v15 = sub_1000E7740();
    KeyedEncodingContainer.encode<A>(_:forKey:)(&v19, &v18, v7, &type metadata for AWDLActionFrame.ProMode.Flags, v15);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v8 + 8))(v10, v7);
}

Swift::Int AWDLActionFrame.ProMode.hashValue.getter(unint64_t a1, Swift::UInt32 a2)
{
  Swift::UInt8 v3;
  unint64_t v4;
  unint64_t v5;
  _QWORD v7[9];

  v3 = a1;
  v4 = a1 >> 8;
  v5 = HIDWORD(a1);
  Hasher.init(_seed:)(v7);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4 + 1);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(a2);
  return Hasher._finalize()();
}

unint64_t AWDLActionFrame.ProMode.init(from:)(_QWORD *a1)
{
  return sub_1000E5D10(a1) & 0xFFFFFFFF0000FFFFLL;
}

uint64_t sub_1000D8440@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t result;
  int v5;

  result = sub_1000E5D10(a1);
  if (!v2)
  {
    *(_WORD *)a2 = result;
    *(_DWORD *)(a2 + 4) = HIDWORD(result);
    *(_DWORD *)(a2 + 8) = v5;
  }
  return result;
}

uint64_t sub_1000D8478(_QWORD *a1)
{
  unsigned __int16 *v1;

  return AWDLActionFrame.ProMode.encode(to:)(a1, *v1 | ((unint64_t)*((unsigned int *)v1 + 1) << 32), *((_DWORD *)v1 + 2));
}

Swift::Int sub_1000D8498()
{
  uint64_t v0;
  char v1;
  Swift::UInt32 v2;
  Swift::UInt32 v3;
  Swift::UInt8 v4;
  _QWORD v6[9];

  v1 = *(_BYTE *)(v0 + 1);
  v2 = *(_DWORD *)(v0 + 4);
  v3 = *(_DWORD *)(v0 + 8);
  v4 = *(_BYTE *)v0;
  Hasher.init(_seed:)(v6);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v1 + 1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  return Hasher._finalize()();
}

void sub_1000D8518()
{
  uint64_t v0;
  char v1;
  Swift::UInt32 v2;
  Swift::UInt32 v3;

  v1 = *(_BYTE *)(v0 + 1);
  v2 = *(_DWORD *)(v0 + 4);
  v3 = *(_DWORD *)(v0 + 8);
  Hasher._combine(_:)(*(_BYTE *)v0);
  Hasher._combine(_:)(v1 + 1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
}

Swift::Int sub_1000D8570()
{
  uint64_t v0;
  char v1;
  Swift::UInt32 v2;
  Swift::UInt32 v3;
  Swift::UInt8 v4;
  _QWORD v6[9];

  v1 = *(_BYTE *)(v0 + 1);
  v2 = *(_DWORD *)(v0 + 4);
  v3 = *(_DWORD *)(v0 + 8);
  v4 = *(_BYTE *)v0;
  Hasher.init(_seed:)(v6);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v1 + 1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  return Hasher._finalize()();
}

BOOL sub_1000D85EC(unsigned __int8 *a1, unsigned __int8 *a2)
{
  if (*a1 != *a2)
    return 0;
  return a1[1] == a2[1] && *((_DWORD *)a1 + 1) == *((_DWORD *)a2 + 1) && *((_DWORD *)a1 + 2) == *((_DWORD *)a2 + 2);
}

uint64_t sub_1000D8628(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000F03D0();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000D8684(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000F03D0();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

void AWDLActionFrame.AirDrop.hash(into:)(int a1, __int16 a2)
{
  char v2;

  v2 = HIBYTE(a2);
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v2 & 1);
}

uint64_t static AWDLActionFrame.AirDrop.__derived_struct_equals(_:_:)(__int16 a1, __int16 a2)
{
  if (a1 == a2)
    return ((a1 & 0x100) == 0) ^ ((unsigned __int16)(a2 & 0x100) >> 8);
  else
    return 0;
}

uint64_t sub_1000D8720()
{
  _BYTE *v0;

  if (*v0)
    return 0x6574617473;
  else
    return 0x6E6F6973726576;
}

uint64_t sub_1000D8758@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;

  result = sub_1000F02A4(a1, a2);
  *a3 = result;
  return result;
}

uint64_t sub_1000D877C(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000E7784();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000D87A4(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000E7784();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t AWDLActionFrame.AirDrop.encode(to:)(_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v14;
  char v15;
  char v16;
  char v17;

  v5 = sub_100012C44(&qword_100407338);
  v6 = *(_QWORD *)(v5 - 8);
  __chkstk_darwin();
  v8 = (char *)&v14 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  v9 = a1[3];
  v10 = a1[4];
  sub_10003259C(a1, v9);
  v11 = sub_1000E7784();
  dispatch thunk of Encoder.container<A>(keyedBy:)(&type metadata for AWDLActionFrame.AirDrop.CodingKeys, &type metadata for AWDLActionFrame.AirDrop.CodingKeys, v11, v9, v10);
  v17 = 0;
  KeyedEncodingContainer.encode(_:forKey:)(a2, &v17, v5);
  if (!v2)
  {
    v16 = BYTE1(a2) & 1;
    v15 = 1;
    v12 = sub_1000E77C8();
    KeyedEncodingContainer.encode<A>(_:forKey:)(&v16, &v15, v5, &type metadata for AWDLActionFrame.AirDrop.State, v12);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v6 + 8))(v8, v5);
}

Swift::Int AWDLActionFrame.AirDrop.hashValue.getter(__int16 a1)
{
  _QWORD v3[9];

  Hasher.init(_seed:)(v3);
  Hasher._combine(_:)(a1);
  Hasher._combine(_:)(HIBYTE(a1) & 1);
  return Hasher._finalize()();
}

uint64_t AWDLActionFrame.AirDrop.init(from:)(_QWORD *a1)
{
  return sub_1000E5EEC(a1) & 0x1FF;
}

uint64_t sub_1000D8960@<X0>(_QWORD *a1@<X0>, _BYTE *a2@<X8>)
{
  uint64_t v2;
  uint64_t result;

  result = sub_1000E5EEC(a1);
  if (!v2)
  {
    *a2 = result;
    a2[1] = BYTE1(result) & 1;
  }
  return result;
}

uint64_t sub_1000D8990(_QWORD *a1)
{
  unsigned __int8 *v1;
  int v2;

  if (v1[1])
    v2 = 256;
  else
    v2 = 0;
  return AWDLActionFrame.AirDrop.encode(to:)(a1, v2 | *v1);
}

Swift::Int sub_1000D89BC()
{
  Swift::UInt8 *v0;
  Swift::UInt8 v1;
  Swift::UInt8 v2;
  _QWORD v4[9];

  v1 = v0[1];
  v2 = *v0;
  Hasher.init(_seed:)(v4);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

void sub_1000D8A18()
{
  Swift::UInt8 *v0;
  Swift::UInt8 v1;

  v1 = v0[1];
  Hasher._combine(_:)(*v0);
  Hasher._combine(_:)(v1);
}

Swift::Int sub_1000D8A54()
{
  Swift::UInt8 *v0;
  Swift::UInt8 v1;
  Swift::UInt8 v2;
  _QWORD v4[9];

  v1 = v0[1];
  v2 = *v0;
  Hasher.init(_seed:)(v4);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

uint64_t sub_1000D8AAC(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return (*a1 == *a2) & (a2[1] ^ a1[1] ^ 1u);
}

uint64_t AWDLActionFrame.AWDLAttribute.AttributeType.rawValue.getter(char a1)
{
  return byte_100345890[a1];
}

BOOL sub_1000D8AEC(char *a1, char *a2)
{
  return byte_100345890[*a1] == byte_100345890[*a2];
}

Swift::Int sub_1000D8B10()
{
  char *v0;
  uint64_t v1;
  _QWORD v3[9];

  v1 = *v0;
  Hasher.init(_seed:)(v3);
  Hasher._combine(_:)(byte_100345890[v1]);
  return Hasher._finalize()();
}

void sub_1000D8B5C()
{
  char *v0;

  Hasher._combine(_:)(byte_100345890[*v0]);
}

Swift::Int sub_1000D8B90()
{
  char *v0;
  uint64_t v1;
  _QWORD v3[9];

  v1 = *v0;
  Hasher.init(_seed:)(v3);
  Hasher._combine(_:)(byte_100345890[v1]);
  return Hasher._finalize()();
}

uint64_t sub_1000D8BD8@<X0>(unsigned __int8 *a1@<X0>, _BYTE *a2@<X8>)
{
  uint64_t result;

  result = _s7CoreP2P15AWDLActionFrameV13AWDLAttributeO13AttributeTypeO8rawValueAGSgs5UInt8V_tcfC_0(*a1);
  *a2 = result;
  return result;
}

void sub_1000D8C00(_BYTE *a1@<X8>)
{
  char *v1;

  *a1 = byte_100345890[*v1];
}

uint64_t sub_1000D8C18(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000F038C();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000D8C74(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000F038C();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

uint64_t AWDLActionFrame.AWDLAttribute.init(from:)@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  _QWORD v39[25];
  unsigned __int8 v40;
  _QWORD v41[3];
  uint64_t v42;
  uint64_t v43;
  _QWORD *v44;

  v39[22] = a2;
  v39[21] = type metadata accessor for AWDLActionFrame.AWDLAttribute(0);
  __chkstk_darwin();
  v39[20] = (char *)v39 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin();
  v39[9] = (char *)v39 - v4;
  __chkstk_darwin();
  v39[8] = (char *)v39 - v5;
  __chkstk_darwin();
  v39[23] = (char *)v39 - v6;
  __chkstk_darwin();
  v39[24] = (char *)v39 - v7;
  __chkstk_darwin();
  v39[7] = (char *)v39 - v8;
  __chkstk_darwin();
  v39[19] = (char *)v39 - v9;
  __chkstk_darwin();
  v39[18] = (char *)v39 - v10;
  __chkstk_darwin();
  v39[17] = (char *)v39 - v11;
  __chkstk_darwin();
  v39[16] = (char *)v39 - v12;
  __chkstk_darwin();
  v39[15] = (char *)v39 - v13;
  __chkstk_darwin();
  v39[14] = (char *)v39 - v14;
  __chkstk_darwin();
  v39[13] = (char *)v39 - v15;
  __chkstk_darwin();
  v39[12] = (char *)v39 - v16;
  __chkstk_darwin();
  v39[11] = (char *)v39 - v17;
  __chkstk_darwin();
  v39[10] = (char *)v39 - v18;
  __chkstk_darwin();
  v39[5] = (char *)v39 - v19;
  __chkstk_darwin();
  v39[4] = (char *)v39 - v20;
  __chkstk_darwin();
  v39[6] = (char *)v39 - v21;
  __chkstk_darwin();
  v23 = (char *)v39 - v22;
  __chkstk_darwin();
  v25 = (char *)v39 - v24;
  __chkstk_darwin();
  v27 = (char *)v39 - v26;
  __chkstk_darwin();
  v29 = (char *)v39 - v28;
  v31 = a1[3];
  v30 = a1[4];
  sub_10003259C(a1, v31);
  v32 = v44;
  dispatch thunk of Decoder.unkeyedContainer()(v41, v31, v30);
  if (!v32)
  {
    v39[1] = v27;
    v39[2] = v25;
    v39[0] = v23;
    v39[3] = v29;
    v44 = a1;
    v33 = sub_100012C44(&qword_100406248);
    v35 = v42;
    v34 = v43;
    sub_100034C68((uint64_t)v41, v42);
    v36 = sub_100011770(&qword_100406240, &qword_100406248, "%@\t");
    dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)(v33, v33, v36, v35, v34);
    v37 = (char *)&loc_1000D90D4
        + 4
        * word_100341304[_s7CoreP2P15AWDLActionFrameV13AWDLAttributeO13AttributeTypeO8rawValueAGSgs5UInt8V_tcfC_0(v40)];
    __asm { BR              X10 }
  }
  return sub_100014430(a1);
}

void AWDLActionFrame.AWDLAttribute.encode(to:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  _QWORD v13[8];
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v18 = a1;
  v14 = sub_100012C44(&qword_100407308);
  v13[6] = *(_QWORD *)(v14 - 8);
  __chkstk_darwin();
  v13[4] = (char *)v13 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0);
  v16 = sub_100012C44(&qword_1004072D0);
  v13[2] = *(_QWORD *)(v16 - 8);
  __chkstk_darwin();
  v13[7] = (char *)v13 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = sub_100012C44(&qword_100407240);
  v13[1] = *(_QWORD *)(v15 - 8);
  __chkstk_darwin();
  v13[5] = (char *)v13 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  type metadata accessor for AWDLActionFrame.DataPathState(0);
  __chkstk_darwin();
  v13[3] = (char *)v13 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  type metadata accessor for AWDLActionFrame.ServiceResponse(0);
  __chkstk_darwin();
  v6 = type metadata accessor for AWDLActionFrame.AWDLAttribute(0);
  __chkstk_darwin();
  v8 = (char *)v13 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  v9 = sub_10001F11C((uint64_t)_swiftEmptyArrayStorage);
  v10 = type metadata accessor for BinaryEncoder();
  v11 = swift_allocObject(v10, 40, 7);
  *(_OWORD *)(v11 + 16) = xmmword_10033A100;
  v17 = v11 + 16;
  *(_QWORD *)(v11 + 32) = v9;
  v19 = v1;
  sub_1000637E0(v1, (uint64_t)v8, type metadata accessor for AWDLActionFrame.AWDLAttribute);
  v12 = (char *)&loc_1000DAE20 + *((int *)qword_1000DBBB0 + swift_getEnumCaseMultiPayload(v8, v6));
  __asm { BR              X10 }
}

uint64_t sub_1000DAE34()
{
  uint64_t v0;
  unsigned int *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;

  v5 = *v1;
  v6 = *((_QWORD *)v1 + 1);
  *(_QWORD *)(v0 + 176) = v2;
  *(_QWORD *)(v0 + 184) = sub_100011DE4((unint64_t *)&qword_100406278, (uint64_t (*)(uint64_t))type metadata accessor for BinaryEncoder, (uint64_t)protocol conformance descriptor for BinaryEncoder);
  *(_QWORD *)(v0 + 152) = v3;
  swift_bridgeObjectRetain(v6);
  swift_retain();
  AWDLActionFrame.ServiceRequest.encode(to:)((_QWORD *)(v0 + 152), v5, v6);
  sub_100014430((_QWORD *)(v0 + 152));
  if (!v4)
  {
    swift_bridgeObjectRelease_n(v6, 2);
    v8 = *(_QWORD **)(v0 + 96);
    v9 = v8[3];
    v10 = v8[4];
    sub_10003259C(v8, v9);
    dispatch thunk of Encoder.unkeyedContainer()((_QWORD *)(v0 + 152), v9, v10);
    AWDLActionFrame.AWDLAttribute.attributeType.getter();
    *(_BYTE *)(v0 + 128) = v11;
    v12 = *(_QWORD *)(v0 + 176);
    v13 = *(_QWORD *)(v0 + 184);
    sub_100034C68(v0 + 152, v12);
    v14 = sub_1000E7820();
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(v0 + 128, &type metadata for AWDLActionFrame.AWDLAttribute.AttributeType, v14, v12, v13);
    swift_beginAccess(*(_QWORD *)(v0 + 88), v0 + 128, 0, 0);
    __asm { BR              X12 }
  }
  swift_release(v3);
  return swift_bridgeObjectRelease_n(v6, 2);
}

void AWDLActionFrame.AWDLAttribute.attributeType.getter()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  char *v3;
  uint64_t (*v4)(_QWORD);
  char *v5;
  uint64_t v6;

  v1 = type metadata accessor for AWDLActionFrame.AWDLAttribute(0);
  __chkstk_darwin();
  v3 = (char *)&v6 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_1000637E0(v0, (uint64_t)v3, v4);
  v5 = (char *)sub_1000DBCA8 + 4 * byte_1003413DC[swift_getEnumCaseMultiPayload(v3, v1)];
  __asm { BR              X10 }
}

uint64_t sub_1000DBCA8()
{
  uint64_t v0;

  sub_100063824(v0, type metadata accessor for AWDLActionFrame.AWDLAttribute);
  return 1;
}

void AWDLActionFrame.AWDLAttribute.hash(into:)()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char *v4;
  uint64_t (*v5)(_QWORD);
  char *v6;
  uint64_t v7;

  v1 = v0;
  type metadata accessor for AWDLActionFrame.DataPathState(0);
  __chkstk_darwin();
  type metadata accessor for AWDLActionFrame.ServiceResponse(0);
  __chkstk_darwin();
  v2 = type metadata accessor for AWDLActionFrame.AWDLAttribute(0);
  __chkstk_darwin();
  v4 = (char *)&v7 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_1000637E0(v1, (uint64_t)v4, v5);
  v6 = (char *)sub_1000DBF2C + 4 * word_1003413F4[swift_getEnumCaseMultiPayload(v4, v2)];
  __asm { BR              X10 }
}

void sub_1000DBF2C()
{
  uint64_t v0;
  uint64_t v1;
  Swift::UInt16 v2;
  Swift::UInt16 v3;
  uint64_t v4;
  uint64_t i;
  uint64_t v6;

  v1 = *(_QWORD *)(v0 + 8);
  v2 = *(_WORD *)v0;
  v3 = *(_WORD *)(v0 + 2);
  Hasher._combine(_:)(1uLL);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(*(_QWORD *)(v1 + 16));
  v4 = *(_QWORD *)(v1 + 16);
  if (v4)
  {
    for (i = 0; i != v4; ++i)
    {
      v6 = v1 + i;
      Hasher._combine(_:)(*(_BYTE *)(v6 + 32));
    }
  }
  swift_bridgeObjectRelease(v1);
}

Swift::Int AWDLActionFrame.AWDLAttribute.hashValue.getter()
{
  return sub_1000DE8A0((void (*)(_QWORD *))AWDLActionFrame.AWDLAttribute.hash(into:));
}

uint64_t sub_1000DC800@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X8>)
{
  return AWDLActionFrame.AWDLAttribute.init(from:)(a1, a2);
}

void sub_1000DC814(uint64_t a1)
{
  AWDLActionFrame.AWDLAttribute.encode(to:)(a1);
}

Swift::Int sub_1000DC828(uint64_t a1, uint64_t a2)
{
  return sub_1000DE8EC(a1, a2, (void (*)(_QWORD *))AWDLActionFrame.AWDLAttribute.hash(into:));
}

Swift::Int sub_1000DC838(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000D72EC(a1, a2, a3, (void (*)(_QWORD *))AWDLActionFrame.AWDLAttribute.hash(into:));
}

double AWDLActionFrame.hash(into:)(uint64_t a1, unint64_t a2, Swift::UInt32 a3, uint64_t a4)
{
  __int16 v6;
  unint64_t v7;
  unint64_t v8;
  Swift::UInt8 v9;
  Swift::UInt v10;
  double result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v6 = a2;
  v7 = a2 >> 16;
  v8 = HIDWORD(a2);
  Hasher._combine(_:)(8u);
  Hasher._combine(_:)(v6);
  if ((v6 & 0x100) != 0)
    v9 = 3;
  else
    v9 = 0;
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(a3);
  v10 = *(_QWORD *)(a4 + 16);
  Hasher._combine(_:)(v10);
  if (v10)
  {
    v12 = *(_QWORD *)(type metadata accessor for AWDLActionFrame.AWDLAttribute(0) - 8);
    v13 = a4 + ((*(unsigned __int8 *)(v12 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v12 + 80));
    v14 = *(_QWORD *)(v12 + 72);
    swift_bridgeObjectRetain(a4);
    do
    {
      AWDLActionFrame.AWDLAttribute.hash(into:)();
      v13 += v14;
      --v10;
    }
    while (v10);
    *(_QWORD *)&result = swift_bridgeObjectRelease(a4).n128_u64[0];
  }
  return result;
}

uint64_t static AWDLActionFrame.__derived_struct_equals(_:_:)(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6)
{
  return sub_1000E22A0(a1 & 0xFFFFFFFF00FF01FFLL, a2, a3, a4 & 0xFFFFFFFF00FF01FFLL, a5, a6);
}

Swift::Int AWDLActionFrame.hashValue.getter(unint64_t a1, Swift::UInt32 a2, uint64_t a3)
{
  __int16 v5;
  unint64_t v6;
  unint64_t v7;
  Swift::UInt8 v8;
  Swift::UInt v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v14[9];

  v5 = a1;
  v6 = a1 >> 16;
  v7 = HIDWORD(a1);
  Hasher.init(_seed:)(v14);
  Hasher._combine(_:)(8u);
  Hasher._combine(_:)(v5);
  if ((v5 & 0x100) != 0)
    v8 = 3;
  else
    v8 = 0;
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(a2);
  v9 = *(_QWORD *)(a3 + 16);
  Hasher._combine(_:)(v9);
  if (v9)
  {
    v10 = *(_QWORD *)(type metadata accessor for AWDLActionFrame.AWDLAttribute(0) - 8);
    v11 = a3 + ((*(unsigned __int8 *)(v10 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80));
    v12 = *(_QWORD *)(v10 + 72);
    swift_bridgeObjectRetain(a3);
    do
    {
      AWDLActionFrame.AWDLAttribute.hash(into:)();
      v11 += v12;
      --v9;
    }
    while (v9);
    swift_bridgeObjectRelease(a3);
  }
  return Hasher._finalize()();
}

uint64_t sub_1000DCA48@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t result;
  int v5;
  uint64_t v6;

  result = sub_1000E6208(a1);
  if (!v2)
  {
    *(_BYTE *)a2 = result;
    *(_BYTE *)(a2 + 1) = BYTE1(result) & 1;
    *(_BYTE *)(a2 + 2) = BYTE2(result);
    *(_DWORD *)(a2 + 4) = HIDWORD(result);
    *(_DWORD *)(a2 + 8) = v5;
    *(_QWORD *)(a2 + 16) = v6;
  }
  return result;
}

unint64_t AWDLActionFrame.init(from:)(_QWORD *a1)
{
  return sub_1000E6208(a1) & 0xFFFFFFFF00FF01FFLL;
}

uint64_t sub_1000DCABC(_QWORD *a1)
{
  unsigned __int8 *v1;
  uint64_t v2;

  v2 = 256;
  if (!v1[1])
    v2 = 0;
  return AWDLActionFrame.encode(to:)(a1, v2 | *v1 | ((unint64_t)v1[2] << 16) | ((unint64_t)*((unsigned int *)v1 + 1) << 32), *((unsigned int *)v1 + 2), *((_QWORD *)v1 + 2));
}

uint64_t AWDLActionFrame.encode(to:)(_QWORD *a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  _QWORD v31[3];
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;

  v8 = a1[3];
  v9 = a1[4];
  sub_10003259C(a1, v8);
  dispatch thunk of Encoder.unkeyedContainer()(v31, v8, v9);
  v10 = v32;
  v11 = v33;
  sub_100034C68((uint64_t)v31, v32);
  v12 = sub_1000E788C();
  dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(v12, &type metadata for AWDLActionFrame.OUIType, v12, v10, v11);
  if (!v4)
  {
    LOBYTE(v34) = a2;
    v13 = v32;
    v14 = v33;
    sub_100034C68((uint64_t)v31, v32);
    v15 = sub_1000E7304();
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(&v34, &type metadata for AWDLActionFrame.AWDLVersion, v15, v13, v14);
    LOBYTE(v34) = BYTE1(a2) & 1;
    v16 = v32;
    v17 = v33;
    sub_100034C68((uint64_t)v31, v32);
    v18 = sub_1000E78D0();
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(&v34, &type metadata for AWDLActionFrame.OUISubtype, v18, v16, v17);
    v19 = v32;
    v20 = v33;
    sub_100034C68((uint64_t)v31, v32);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(a2 >> 16, v19, v20);
    v21 = HIDWORD(a2);
    v22 = v32;
    v23 = v33;
    sub_100034C68((uint64_t)v31, v32);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v21, v22, v23);
    v24 = v32;
    v25 = v33;
    sub_100034C68((uint64_t)v31, v32);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(a3, v24, v25);
    v34 = a4;
    v26 = v32;
    v27 = v33;
    sub_100034C68((uint64_t)v31, v32);
    v28 = sub_100012C44(&qword_100407398);
    v29 = sub_1000E7914();
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(&v34, v28, v29, v26, v27);
  }
  return sub_100014430(v31);
}

Swift::Int sub_1000DCD24()
{
  unsigned __int8 *v0;
  uint64_t v1;

  v1 = 256;
  if (!v0[1])
    v1 = 0;
  return AWDLActionFrame.hashValue.getter(v1 | *v0 | ((unint64_t)v0[2] << 16) | ((unint64_t)*((unsigned int *)v0 + 1) << 32), *((_DWORD *)v0 + 2), *((_QWORD *)v0 + 2));
}

double sub_1000DCD54(uint64_t a1)
{
  unsigned __int8 *v1;
  uint64_t v2;

  v2 = 256;
  if (!v1[1])
    v2 = 0;
  return AWDLActionFrame.hash(into:)(a1, v2 | *v1 | ((unint64_t)v1[2] << 16) | ((unint64_t)*((unsigned int *)v1 + 1) << 32), *((_DWORD *)v1 + 2), *((_QWORD *)v1 + 2));
}

Swift::Int sub_1000DCD84()
{
  uint64_t v0;
  int v1;
  Swift::UInt32 v2;
  Swift::UInt32 v3;
  uint64_t v4;
  Swift::UInt8 v5;
  Swift::UInt8 v6;
  Swift::UInt8 v7;
  Swift::UInt v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v13[9];

  v1 = *(unsigned __int8 *)(v0 + 1);
  v2 = *(_DWORD *)(v0 + 4);
  v3 = *(_DWORD *)(v0 + 8);
  v4 = *(_QWORD *)(v0 + 16);
  v5 = *(_BYTE *)v0;
  v6 = *(_BYTE *)(v0 + 2);
  Hasher.init(_seed:)(v13);
  Hasher._combine(_:)(8u);
  Hasher._combine(_:)(v5);
  if (v1)
    v7 = 3;
  else
    v7 = 0;
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  v8 = *(_QWORD *)(v4 + 16);
  Hasher._combine(_:)(v8);
  if (v8)
  {
    v9 = *(_QWORD *)(type metadata accessor for AWDLActionFrame.AWDLAttribute(0) - 8);
    v10 = v4 + ((*(unsigned __int8 *)(v9 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80));
    v11 = *(_QWORD *)(v9 + 72);
    swift_bridgeObjectRetain(v4);
    do
    {
      AWDLActionFrame.AWDLAttribute.hash(into:)();
      v10 += v11;
      --v8;
    }
    while (v8);
    swift_bridgeObjectRelease(v4);
  }
  return Hasher._finalize()();
}

uint64_t sub_1000DCE88(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  unint64_t v6;

  v2 = *((_QWORD *)a1 + 2);
  v3 = 256;
  if (a1[1])
    v4 = 256;
  else
    v4 = 0;
  v5 = *((_DWORD *)a1 + 2);
  v6 = v4 | *a1 | ((unint64_t)a1[2] << 16) | ((unint64_t)*((unsigned int *)a1 + 1) << 32);
  if (!a2[1])
    v3 = 0;
  return static AWDLActionFrame.__derived_struct_equals(_:_:)(v6, v5, v2, v3 | *a2 | ((unint64_t)a2[2] << 16) | ((unint64_t)*((unsigned int *)a2 + 1) << 32), *((_DWORD *)a2 + 2), *((_QWORD *)a2 + 2));
}

void sub_1000DCEE4(uint64_t a1, unsigned __int8 a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char v40;
  uint64_t v41;
  unint64_t v42;
  int v44;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char v49;
  unsigned __int8 v50;

  v4 = *(_QWORD *)(a3 + 16);
  if (!v4)
  {
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 3451, 0);
LABEL_38:
    __break(1u);
    return;
  }
  if ((unint64_t)(v4 - 1) >= 0x100)
  {
LABEL_37:
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 3455, 0);
    goto LABEL_38;
  }
  v8 = *(_QWORD *)(a1 + 24);
  v9 = *(_QWORD *)(a1 + 32);
  sub_100034C68(a1, v8);
  dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v4 - 1, v8, v9);
  if (!v3)
  {
    v50 = a2;
    v10 = *(_QWORD *)(a1 + 24);
    v11 = *(_QWORD *)(a1 + 32);
    sub_100034C68(a1, v10);
    v12 = sub_1000F0B3C();
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(&v50, &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.Encoding, v12, v10, v11);
    v13 = *(_QWORD *)(a1 + 24);
    v14 = *(_QWORD *)(a1 + 32);
    sub_100034C68(a1, v13);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(0, v13, v14);
    v15 = *(_QWORD *)(a1 + 24);
    v16 = *(_QWORD *)(a1 + 32);
    sub_100034C68(a1, v15);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(3, v15, v16);
    v17 = *(_QWORD *)(a1 + 24);
    v18 = *(_QWORD *)(a1 + 32);
    sub_100034C68(a1, v17);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(0xFFFFLL, v17, v18);
    if (a2 - 2 < 2)
    {
      swift_bridgeObjectRetain(a3);
      v19 = 32;
      while (1)
      {
        v20 = *(unsigned int *)(a3 + v19) | ((unint64_t)*(unsigned __int16 *)(a3 + v19 + 4) << 32);
        if ((v20 & 0xFF00000000) == 0x300000000)
        {
          v21 = *(_QWORD *)(a1 + 24);
          v22 = *(_QWORD *)(a1 + 32);
          sub_100034C68(a1, v21);
          dispatch thunk of UnkeyedEncodingContainer.encode(_:)(0, v21, v22);
          v23 = *(_QWORD *)(a1 + 24);
          v24 = *(_QWORD *)(a1 + 32);
          sub_100034C68(a1, v23);
          dispatch thunk of UnkeyedEncodingContainer.encode(_:)(0, v23, v24);
        }
        else
        {
          if ((*(_DWORD *)(a3 + v19) & 0xFFFFFF00) != 0)
            goto LABEL_37;
          v25 = *(_QWORD *)(a1 + 24);
          v26 = *(_QWORD *)(a1 + 32);
          sub_100034C68(a1, v25);
          dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v20, v25, v26);
          v27 = Channel.operatingClass.getter(v20);
          v28 = *(_QWORD *)(a1 + 24);
          v29 = *(_QWORD *)(a1 + 32);
          sub_100034C68(a1, v28);
          dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v27, v28, v29);
        }
        v19 += 8;
        if (!--v4)
          goto LABEL_17;
      }
    }
    if (a2)
    {
      swift_bridgeObjectRetain(a3);
      v34 = 32;
      while (1)
      {
        v35 = *(unsigned int *)(a3 + v34) | ((unint64_t)*(unsigned __int16 *)(a3 + v34 + 4) << 32);
        if ((v35 & 0xFF00000000) == 0x300000000)
        {
          v36 = *(_QWORD *)(a1 + 24);
          v37 = *(_QWORD *)(a1 + 32);
          sub_100034C68(a1, v36);
          dispatch thunk of UnkeyedEncodingContainer.encode(_:)(0, v36, v37);
          v38 = *(_QWORD *)(a1 + 24);
          v39 = *(_QWORD *)(a1 + 32);
          sub_100034C68(a1, v38);
          dispatch thunk of UnkeyedEncodingContainer.encode(_:)(0, v38, v39);
        }
        else
        {
          v40 = sub_1000E3DA0(SBYTE4(v35), BYTE5(v35));
          v49 = v40;
          v41 = *(_QWORD *)(a1 + 24);
          v48 = *(_QWORD *)(a1 + 32);
          sub_100034C68(a1, v41);
          v42 = sub_1000F0B80();
          dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(&v49, &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.NChannelOperatingClass, v42, v41, v48);
          if (sub_10007CD0C(0, 2, v40) == 2 && v35 > 2)
          {
            v35 = (v35 - 2);
          }
          else
          {
            v44 = sub_10007CD0C(0, 2, v40);
            if (v35 < 0xDE && v44 == 1)
              v35 = (v35 + 2);
            else
              v35 = v35;
          }
          if (v35 >= 0x100)
            goto LABEL_37;
          v46 = *(_QWORD *)(a1 + 24);
          v47 = *(_QWORD *)(a1 + 32);
          sub_100034C68(a1, v46);
          dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v35, v46, v47);
        }
        v34 += 8;
        if (!--v4)
          goto LABEL_17;
      }
    }
    swift_bridgeObjectRetain(a3);
    v30 = 32;
    do
    {
      v31 = *(unsigned int *)(a3 + v30) | ((unint64_t)*(unsigned __int16 *)(a3 + v30 + 4) << 32);
      if ((v31 & 0xFF00000000) == 0x300000000)
      {
        v31 = 0;
      }
      else if (*(_DWORD *)(a3 + v30) >= 0x100u)
      {
        goto LABEL_37;
      }
      v32 = *(_QWORD *)(a1 + 24);
      v33 = *(_QWORD *)(a1 + 32);
      sub_100034C68(a1, v32);
      dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v31, v32, v33);
      v30 += 8;
      --v4;
    }
    while (v4);
LABEL_17:
    swift_bridgeObjectRelease(a3);
  }
}

uint64_t sub_1000DD44C@<X0>(unsigned __int8 *a1@<X0>, _BYTE *a2@<X8>)
{
  uint64_t result;

  result = _s7CoreP2P19NANIntervalDurationO8rawValueACSgs5UInt8V_tcfC_0(*a1);
  *a2 = result;
  return result;
}

uint64_t sub_1000DD474(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000F12F8();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000DD4D0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000F12F8();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

uint64_t sub_1000DD51C(char a1)
{
  char v2;

  v2 = sub_10007CD0C(2uLL, 2, a1);
  if (v2 == 1)
    return 2;
  if (v2 == 3)
    return sub_10007CD0C(0, 2, a1) == 2;
  return 3;
}

uint64_t sub_1000DD5C4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000F114C();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000DD620(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000F114C();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

void sub_1000DD66C(uint64_t a1@<X1>, _QWORD *a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 v12;
  unsigned __int8 v13;
  char v14;
  char v17;
  int v18;
  BOOL v19;
  unint64_t v20;
  unsigned __int8 v21;
  char v22;

  v7 = *(_QWORD *)(a1 + 24);
  v8 = *(_QWORD *)(a1 + 32);
  sub_100034C68(a1, v7);
  v9 = sub_1000F0C08();
  dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)(&type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.NChannelOperatingClass, &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.NChannelOperatingClass, v9, v7, v8);
  if (v3)
  {
    *a2 = v3;
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 24);
    v11 = *(_QWORD *)(a1 + 32);
    sub_100034C68(a1, v10);
    v12 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v10, v11);
    v13 = v12;
    if (!v12)
      goto LABEL_18;
    v14 = sub_10007CD0C(0, 2, v22);
    if (v13 <= 0xDDu && v14 == 2)
    {
      v13 += 2;
    }
    else if (sub_10007CD0C(0, 2, v22) == 1 && v13 > 2u)
    {
      v13 -= 2;
    }
    v17 = sub_10007CD0C(4uLL, 4, v22) == 1;
    v18 = sub_1000DD51C(v22);
    if ((_s7CoreP2P7ChannelV7isValid7channel2on4withSbs6UInt32V_AC4BandOAA9BandwidthOtFZ_0(v13, v17, v18) & 1) != 0)
    {
      v19 = sub_10007CD0C(4uLL, 4, v22) == 1;
      v21 = sub_1000DD51C(v22);
      sub_10018FA04();
      *(_DWORD *)a3 = v13;
      v20 = (v13 | ((unint64_t)v19 << 32) | ((unint64_t)v21 << 40)) >> 32;
    }
    else
    {
LABEL_18:
      *(_DWORD *)a3 = 0;
      LOWORD(v20) = 3;
    }
    *(_WORD *)(a3 + 4) = v20;
  }
}

unint64_t sub_1000DD8A0(char a1, char a2)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  unsigned int v6;
  int v7;
  char *v8;
  unint64_t v9;
  uint64_t *v10;
  _QWORD *v11;
  char *v12;
  unsigned __int8 v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  _QWORD *v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  int v25;
  _QWORD *v26;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v34;
  int v35;
  uint64_t v36;
  unsigned __int8 v37;
  uint64_t v38;
  _QWORD *v39;
  int v40;

  LOBYTE(v2) = a2;
  LOBYTE(v3) = a1;
  if (qword_100404198 != -1)
    goto LABEL_66;
  while (1)
  {
    v4 = off_100409F60;
    v5 = *((_QWORD *)off_100409F60 + 2);
    if (!v5)
      return 0x300000000;
    v6 = v3;
    v7 = v2;
    v8 = (char *)off_100409F60 + 32;
    swift_bridgeObjectRetain(off_100409F60);
    v9 = 0;
    v10 = &qword_100404000;
    v11 = (_QWORD *)&unk_100409000;
    while (1)
    {
      if (v9 >= v4[2])
        goto LABEL_64;
      v12 = &v8[16 * v9];
      if (*v12 != v7)
        goto LABEL_6;
      v13 = v12[1];
      LODWORD(v2) = v12[2];
      v3 = *((_QWORD *)v12 + 1);
      if (((_DWORD)v2 - 4) < 3)
        break;
      v20 = *(_QWORD *)(v3 + 16);
      if (v20)
      {
        if (*(_DWORD *)(v3 + 32) == v6)
          goto LABEL_61;
        if (v20 != 1)
        {
          if (*(_DWORD *)(v3 + 36) == v6)
            goto LABEL_61;
          if (v20 != 2)
          {
            if (*(_DWORD *)(v3 + 40) == v6)
              goto LABEL_61;
            if (v20 != 3)
            {
              v21 = 11;
              while (1)
              {
                v22 = v21 - 7;
                if (__OFADD__(v21 - 8, 1))
                  goto LABEL_65;
                if (*(_DWORD *)(v3 + 4 * v21) == v6)
                  break;
                ++v21;
                if (v22 == v20)
                  goto LABEL_6;
              }
LABEL_61:
              swift_bridgeObjectRetain(v3);
LABEL_58:
              swift_bridgeObjectRelease(v4);
              sub_10018FA04();
              swift_bridgeObjectRelease(v3);
              return v6 | ((unint64_t)v13 << 32) | ((unint64_t)v2 << 40);
            }
          }
        }
      }
LABEL_6:
      if (++v9 == v5)
      {
        swift_bridgeObjectRelease(v4);
        return 0x300000000;
      }
    }
    v40 = v12[2];
    v14 = v10[52];
    swift_bridgeObjectRetain(v3);
    if (v14 != -1)
      swift_once(&qword_1004041A0, sub_1001919B8);
    v2 = (_QWORD *)v11[493];
    v15 = v2[2];
    if (!v15)
    {
      v2 = (_QWORD *)v3;
LABEL_5:
      swift_bridgeObjectRelease(v2);
      v10 = &qword_100404000;
      v11 = &unk_100409000;
      goto LABEL_6;
    }
    v34 = v8;
    v35 = v7;
    v37 = v13;
    v38 = v3;
    v36 = v5;
    v16 = 0x801004u >> (8 * v13);
    v17 = v2 + 4;
    swift_bridgeObjectRetain_n(v2, 2);
    v18 = 0;
    v19 = v40;
    v39 = v2;
    while (1)
    {
      v23 = v18 + 1;
      if (__OFADD__(v18, 1))
        break;
      if ((0x801004u >> (8 * LOBYTE(v17[2 * v18]))) == v16)
      {
        v24 = &v17[2 * v18];
        v25 = *((unsigned __int8 *)v24 + 1);
        v26 = (_QWORD *)v24[1];
        if (v25 == 6)
        {
          if (v19 != 6)
            goto LABEL_27;
        }
        else if (v25 == 5)
        {
          if (v19 != 5)
            goto LABEL_27;
        }
        else if (v25 != 4 || v19 != 4)
        {
          goto LABEL_27;
        }
        v3 = v26[2];
        if (v3)
        {
          v2 = v26 + 4;
          swift_bridgeObjectRetain_n(v24[1], 2);
          v28 = 0;
          while (1)
          {
            v29 = v2[2 * v28 + 1];
            v30 = *(_QWORD *)(v29 + 16);
            if (v30)
            {
              if (*(_DWORD *)(v29 + 32) == v6)
                goto LABEL_57;
              if (v30 != 1)
              {
                if (*(_DWORD *)(v29 + 36) == v6)
                  goto LABEL_57;
                if (v30 != 2)
                {
                  if (*(_DWORD *)(v29 + 40) == v6)
                  {
LABEL_57:
                    swift_bridgeObjectRelease(v26);
                    v13 = v37;
                    v3 = v38;
                    LOBYTE(v2) = v40;
                    swift_bridgeObjectRelease(v4);
                    swift_bridgeObjectRelease_n(v39, 2);
                    v4 = v26;
                    goto LABEL_58;
                  }
                  if (v30 != 3)
                    break;
                }
              }
            }
LABEL_43:
            if (++v28 == v3)
            {
              swift_bridgeObjectRelease_n(v26, 2);
              v19 = v40;
              v2 = v39;
              goto LABEL_27;
            }
          }
          v31 = 11;
          while (1)
          {
            v32 = v31 - 7;
            if (__OFADD__(v31 - 8, 1))
              break;
            if (*(_DWORD *)(v29 + 4 * v31) == v6)
              goto LABEL_57;
            ++v31;
            if (v32 == v30)
              goto LABEL_43;
          }
          __break(1u);
          break;
        }
      }
LABEL_27:
      v18 = v23;
      if (v23 == v15)
      {
        swift_bridgeObjectRelease(v38);
        swift_bridgeObjectRelease(v2);
        v5 = v36;
        v7 = v35;
        v8 = v34;
        goto LABEL_5;
      }
    }
    __break(1u);
LABEL_64:
    __break(1u);
LABEL_65:
    __break(1u);
LABEL_66:
    swift_once(&qword_100404198, sub_100191124);
  }
}

unint64_t AWDLActionFrame.Header.channel.getter()
{
  uint64_t v0;

  return *(unsigned int *)(v0 + 12) | ((unint64_t)*(unsigned __int8 *)(v0 + 16) << 32) | ((unint64_t)*(unsigned __int8 *)(v0 + 17) << 40);
}

uint64_t AWDLActionFrame.Header.channel.setter(uint64_t result)
{
  uint64_t v1;

  *(_DWORD *)(v1 + 12) = result;
  *(_BYTE *)(v1 + 16) = BYTE4(result);
  *(_BYTE *)(v1 + 17) = BYTE5(result);
  return result;
}

uint64_t Channel.channel.setter(uint64_t result)
{
  _DWORD *v1;

  *v1 = result;
  return result;
}

void *AWDLActionFrame.Header.Flags.updateHardwareTSF.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.Header.Flags.updateHardwareTSF;
}

void *AWDLActionFrame.Header.Flags.updateSynchronizationParameters.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.Header.Flags.updateSynchronizationParameters;
}

void *AWDLActionFrame.Header.Flags.updateElectionParameters.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.Header.Flags.updateElectionParameters;
}

void *AWDLActionFrame.Header.Flags.isProbeResponse.unsafeMutableAddressor()
{
  return &static AWDLActionFrame.Header.Flags.isProbeResponse;
}

_DWORD *sub_1000DDCC8@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X8>)
{
  *a2 = *result;
  return result;
}

Swift::Int sub_1000DDCD4()
{
  Swift::UInt32 *v0;
  Swift::UInt32 v1;
  _QWORD v3[9];

  v1 = *v0;
  Hasher.init(_seed:)(v3);
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

void sub_1000DDD18()
{
  Swift::UInt32 *v0;

  Hasher._combine(_:)(*v0);
}

Swift::Int sub_1000DDD40()
{
  Swift::UInt32 *v0;
  Swift::UInt32 v1;
  _QWORD v3[9];

  v1 = *v0;
  Hasher.init(_seed:)(v3);
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

_DWORD *sub_1000DDD80@<X0>(_DWORD *result@<X0>, int *a2@<X8>)
{
  _DWORD *v2;

  *a2 = *v2 | *result;
  return result;
}

_DWORD *sub_1000DDD94@<X0>(_DWORD *result@<X0>, int *a2@<X8>)
{
  _DWORD *v2;

  *a2 = *v2 & *result;
  return result;
}

_DWORD *sub_1000DDDA8@<X0>(_DWORD *result@<X0>, int *a2@<X8>)
{
  _DWORD *v2;

  *a2 = *v2 ^ *result;
  return result;
}

BOOL sub_1000DDDBC(_DWORD *a1, int *a2)
{
  _DWORD *v2;
  int v3;
  int v4;

  v3 = *a2;
  v4 = *v2 & *a2;
  if (v4 != *a2)
    *v2 |= v3;
  *a1 = v3;
  return v4 != v3;
}

_DWORD *sub_1000DDDEC@<X0>(_DWORD *result@<X0>, uint64_t a2@<X8>)
{
  _DWORD *v2;
  int v3;

  v3 = *v2 & *result;
  if (v3)
    *v2 &= ~*result;
  *(_DWORD *)a2 = v3;
  *(_BYTE *)(a2 + 4) = v3 == 0;
  return result;
}

int *sub_1000DDE18@<X0>(int *result@<X0>, uint64_t a2@<X8>)
{
  int *v2;
  int v3;
  int v4;
  int v5;

  v3 = *result;
  v4 = *v2;
  *v2 |= *result;
  v5 = v4 & v3;
  *(_DWORD *)a2 = v5;
  *(_BYTE *)(a2 + 4) = v5 == 0;
  return result;
}

_DWORD *sub_1000DDE3C(_DWORD *result)
{
  _DWORD *v1;

  *v1 |= *result;
  return result;
}

_DWORD *sub_1000DDE50(_DWORD *result)
{
  _DWORD *v1;

  *v1 &= *result;
  return result;
}

_DWORD *sub_1000DDE64(_DWORD *result)
{
  _DWORD *v1;

  *v1 ^= *result;
  return result;
}

_DWORD *sub_1000DDE78@<X0>(_DWORD *result@<X0>, int *a2@<X8>)
{
  _DWORD *v2;

  *a2 = *v2 & ~*result;
  return result;
}

BOOL sub_1000DDE8C(_DWORD *a1)
{
  _DWORD *v1;

  return (*v1 & ~*a1) == 0;
}

BOOL sub_1000DDEA0(_DWORD *a1)
{
  _DWORD *v1;

  return (*v1 & *a1) == 0;
}

BOOL sub_1000DDEB4(_DWORD *a1)
{
  _DWORD *v1;

  return (*a1 & ~*v1) == 0;
}

BOOL sub_1000DDEC8()
{
  _DWORD *v0;

  return *v0 == 0;
}

_DWORD *sub_1000DDED8(_DWORD *result)
{
  _DWORD *v1;

  *v1 &= ~*result;
  return result;
}

uint64_t AWDLActionFrame.Header.flags.getter()
{
  uint64_t v0;

  return *(unsigned int *)(v0 + 20);
}

uint64_t AWDLActionFrame.Header.flags.setter(uint64_t result)
{
  uint64_t v1;

  *(_DWORD *)(v1 + 20) = result;
  return result;
}

uint64_t AWDLActionFrame.Header.dwellTime.getter@<X0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;

  v3 = v1 + *(int *)(type metadata accessor for AWDLActionFrame.Header(0) + 32);
  v4 = type metadata accessor for DispatchTimeInterval(0);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 - 8) + 16))(a1, v3, v4);
}

uint64_t AWDLActionFrame.Header.dwellTime.setter(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;

  v3 = v1 + *(int *)(type metadata accessor for AWDLActionFrame.Header(0) + 32);
  v4 = type metadata accessor for DispatchTimeInterval(0);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 - 8) + 40))(v3, a1, v4);
}

uint64_t (*AWDLActionFrame.Header.dwellTime.modify())(_QWORD)
{
  type metadata accessor for AWDLActionFrame.Header(0);
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.Header.lifetime.getter@<X0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;

  v3 = v1 + *(int *)(type metadata accessor for AWDLActionFrame.Header(0) + 36);
  v4 = type metadata accessor for DispatchTimeInterval(0);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 - 8) + 16))(a1, v3, v4);
}

uint64_t AWDLActionFrame.Header.lifetime.setter(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;

  v3 = v1 + *(int *)(type metadata accessor for AWDLActionFrame.Header(0) + 36);
  v4 = type metadata accessor for DispatchTimeInterval(0);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 - 8) + 40))(v3, a1, v4);
}

uint64_t (*AWDLActionFrame.Header.lifetime.modify())(_QWORD)
{
  type metadata accessor for AWDLActionFrame.Header(0);
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.Header.token.getter()
{
  uint64_t v0;

  return *(unsigned int *)(v0 + *(int *)(type metadata accessor for AWDLActionFrame.Header(0) + 40));
}

uint64_t AWDLActionFrame.Header.token.setter(int a1)
{
  uint64_t v1;
  uint64_t result;

  result = type metadata accessor for AWDLActionFrame.Header(0);
  *(_DWORD *)(v1 + *(int *)(result + 40)) = a1;
  return result;
}

uint64_t (*AWDLActionFrame.Header.token.modify())(_QWORD)
{
  type metadata accessor for AWDLActionFrame.Header(0);
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.Header.rate.getter()
{
  uint64_t v0;

  return *(unsigned int *)(v0 + *(int *)(type metadata accessor for AWDLActionFrame.Header(0) + 44));
}

uint64_t AWDLActionFrame.Header.rate.setter(int a1)
{
  uint64_t v1;
  uint64_t result;

  result = type metadata accessor for AWDLActionFrame.Header(0);
  *(_DWORD *)(v1 + *(int *)(result + 44)) = a1;
  return result;
}

uint64_t (*AWDLActionFrame.Header.rate.modify())(_QWORD)
{
  type metadata accessor for AWDLActionFrame.Header(0);
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.Header.rssi.getter()
{
  uint64_t v0;

  return *(_QWORD *)(v0 + *(int *)(type metadata accessor for AWDLActionFrame.Header(0) + 48));
}

uint64_t AWDLActionFrame.Header.rssi.setter(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;

  result = type metadata accessor for AWDLActionFrame.Header(0);
  *(_QWORD *)(v1 + *(int *)(result + 48)) = a1;
  return result;
}

uint64_t (*AWDLActionFrame.Header.rssi.modify())(_QWORD)
{
  type metadata accessor for AWDLActionFrame.Header(0);
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.Header.mactime.getter()
{
  uint64_t v0;

  return *(unsigned int *)(v0 + *(int *)(type metadata accessor for AWDLActionFrame.Header(0) + 52));
}

uint64_t AWDLActionFrame.Header.mactime.setter(int a1)
{
  uint64_t v1;
  uint64_t result;

  result = type metadata accessor for AWDLActionFrame.Header(0);
  *(_DWORD *)(v1 + *(int *)(result + 52)) = a1;
  return result;
}

uint64_t (*AWDLActionFrame.Header.mactime.modify())(_QWORD)
{
  type metadata accessor for AWDLActionFrame.Header(0);
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.Header.tsf.getter()
{
  uint64_t v0;

  return *(_QWORD *)(v0 + *(int *)(type metadata accessor for AWDLActionFrame.Header(0) + 56));
}

uint64_t AWDLActionFrame.Header.tsf.setter(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;

  result = type metadata accessor for AWDLActionFrame.Header(0);
  *(_QWORD *)(v1 + *(int *)(result + 56)) = a1;
  return result;
}

uint64_t (*AWDLActionFrame.Header.tsf.modify())(_QWORD)
{
  type metadata accessor for AWDLActionFrame.Header(0);
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.Header.chainRSSIPresent.getter()
{
  uint64_t v0;

  return *(unsigned int *)(v0 + *(int *)(type metadata accessor for AWDLActionFrame.Header(0) + 60));
}

uint64_t AWDLActionFrame.Header.chainRSSIPresent.setter(int a1)
{
  uint64_t v1;
  uint64_t result;

  result = type metadata accessor for AWDLActionFrame.Header(0);
  *(_DWORD *)(v1 + *(int *)(result + 60)) = a1;
  return result;
}

uint64_t (*AWDLActionFrame.Header.chainRSSIPresent.modify())(_QWORD)
{
  type metadata accessor for AWDLActionFrame.Header(0);
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t AWDLActionFrame.Header.chainRSSI.getter()
{
  uint64_t v0;
  uint64_t v1;

  v1 = type metadata accessor for AWDLActionFrame.Header(0);
  return swift_bridgeObjectRetain(*(_QWORD *)(v0 + *(int *)(v1 + 64)));
}

void AWDLActionFrame.Header.chainRSSI.setter(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(int *)(type metadata accessor for AWDLActionFrame.Header(0) + 64);
  swift_bridgeObjectRelease(*(_QWORD *)(v1 + v3));
  *(_QWORD *)(v1 + v3) = a1;
}

uint64_t (*AWDLActionFrame.Header.chainRSSI.modify())(_QWORD)
{
  type metadata accessor for AWDLActionFrame.Header(0);
  return NANBitmap.Channel.operatingClass.getter;
}

void AWDLActionFrame.Header.hash(into:)()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  Swift::UInt8 v6;
  Swift::UInt8 v7;
  Swift::UInt8 v8;
  Swift::UInt8 v9;
  Swift::UInt8 v10;
  Swift::UInt8 v11;
  Swift::UInt8 v12;
  Swift::UInt8 v13;
  Swift::UInt8 v14;
  Swift::UInt8 v15;
  char v16;
  int v17;
  Swift::UInt v18;
  int *v19;
  void (*v20)(uint64_t *, uint64_t, uint64_t);
  uint64_t (*v21)(uint64_t *, uint64_t);
  int v22;
  int v23;
  unint64_t v24;
  Swift::UInt64 v25;
  uint64_t v26;
  uint64_t v27;
  Swift::UInt64 v28;
  BOOL v29;
  BOOL v30;
  unint64_t v31;
  uint64_t *v32;
  int v33;
  unint64_t v34;
  Swift::UInt64 v35;
  uint64_t v36;
  uint64_t v37;
  Swift::UInt64 v38;
  BOOL v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  Swift::UInt8 *v43;
  Swift::UInt8 v44;
  uint64_t v45;
  uint64_t *v46;

  v1 = type metadata accessor for DispatchTimeInterval(0);
  v2 = *(_QWORD *)(v1 - 8);
  __chkstk_darwin();
  v46 = (uint64_t *)((char *)&v45 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0));
  __chkstk_darwin();
  v5 = (uint64_t *)((char *)&v45 - v4);
  v6 = *(_BYTE *)(v0 + 1);
  v7 = *(_BYTE *)(v0 + 2);
  v8 = *(_BYTE *)(v0 + 3);
  v9 = *(_BYTE *)(v0 + 4);
  v10 = *(_BYTE *)(v0 + 5);
  Hasher._combine(_:)(*(_BYTE *)v0);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  v11 = *(_BYTE *)(v0 + 7);
  v12 = *(_BYTE *)(v0 + 8);
  v13 = *(_BYTE *)(v0 + 9);
  v14 = *(_BYTE *)(v0 + 10);
  v15 = *(_BYTE *)(v0 + 11);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 6));
  Hasher._combine(_:)(v11);
  Hasher._combine(_:)(v12);
  Hasher._combine(_:)(v13);
  Hasher._combine(_:)(v14);
  Hasher._combine(_:)(v15);
  v16 = *(_BYTE *)(v0 + 16);
  v17 = *(unsigned __int8 *)(v0 + 17);
  Hasher._combine(_:)(*(_DWORD *)(v0 + 12));
  Hasher._combine(_:)(0x801004u >> (8 * v16));
  switch(v17)
  {
    case 2:
      v18 = 0;
      goto LABEL_8;
    case 3:
      v18 = 1;
      goto LABEL_8;
    case 4:
      v18 = 3;
      goto LABEL_8;
    case 5:
      v18 = 4;
      goto LABEL_8;
    case 6:
      v18 = 5;
LABEL_8:
      Hasher._combine(_:)(v18);
      break;
    default:
      Hasher._combine(_:)(2uLL);
      Hasher._combine(_:)(v17 & 1);
      break;
  }
  Hasher._combine(_:)(*(_DWORD *)(v0 + 20));
  v19 = (int *)type metadata accessor for AWDLActionFrame.Header(0);
  v20 = *(void (**)(uint64_t *, uint64_t, uint64_t))(v2 + 16);
  v20(v5, v0 + v19[8], v1);
  v21 = *(uint64_t (**)(uint64_t *, uint64_t))(v2 + 88);
  v22 = v21(v5, v1);
  v23 = enum case for DispatchTimeInterval.seconds(_:);
  if (v22 == enum case for DispatchTimeInterval.seconds(_:))
  {
    (*(void (**)(uint64_t *, uint64_t))(v2 + 96))(v5, v1);
    v24 = 0x7FFFFFFFFFFFFFFFLL;
    if (*v5 <= 0)
      v24 = 0x8000000000000000;
    if ((unsigned __int128)(*v5 * (__int128)1000000000) >> 64 == (1000000000 * *v5) >> 63)
      v25 = 1000000000 * *v5;
    else
      v25 = v24;
    goto LABEL_24;
  }
  if (v22 == enum case for DispatchTimeInterval.milliseconds(_:))
  {
    (*(void (**)(uint64_t *, uint64_t))(v2 + 96))(v5, v1);
    v26 = *v5;
    v27 = 1000000;
LABEL_19:
    v28 = v26 * v27;
    v29 = (unsigned __int128)(v26 * (__int128)v27) >> 64 != (v26 * v27) >> 63;
    v30 = v26 <= 0;
    v31 = 0x7FFFFFFFFFFFFFFFLL;
    if (v30)
      v31 = 0x8000000000000000;
    if (v29)
      v25 = v31;
    else
      v25 = v28;
    goto LABEL_24;
  }
  if (v22 == enum case for DispatchTimeInterval.microseconds(_:))
  {
    (*(void (**)(uint64_t *, uint64_t))(v2 + 96))(v5, v1);
    v26 = *v5;
    v27 = 1000;
    goto LABEL_19;
  }
  if (v22 == enum case for DispatchTimeInterval.nanoseconds(_:))
  {
    (*(void (**)(uint64_t *, uint64_t))(v2 + 96))(v5, v1);
    v25 = *v5;
  }
  else
  {
    if (v22 != enum case for DispatchTimeInterval.never(_:))
      (*(void (**)(uint64_t *, uint64_t))(v2 + 8))(v5, v1);
    v25 = 0x7FFFFFFFFFFFFFFFLL;
  }
LABEL_24:
  Hasher._combine(_:)(v25);
  v32 = v46;
  v20(v46, v0 + v19[9], v1);
  v33 = v21(v32, v1);
  if (v33 == v23)
  {
    (*(void (**)(uint64_t *, uint64_t))(v2 + 96))(v32, v1);
    v34 = 0x7FFFFFFFFFFFFFFFLL;
    if (*v32 <= 0)
      v34 = 0x8000000000000000;
    if ((unsigned __int128)(*v32 * (__int128)1000000000) >> 64 == (1000000000 * *v32) >> 63)
      v35 = 1000000000 * *v32;
    else
      v35 = v34;
    goto LABEL_39;
  }
  if (v33 == enum case for DispatchTimeInterval.milliseconds(_:))
  {
    (*(void (**)(uint64_t *, uint64_t))(v2 + 96))(v32, v1);
    v36 = *v32;
    v37 = 1000000;
LABEL_34:
    v38 = v36 * v37;
    v39 = (unsigned __int128)(v36 * (__int128)v37) >> 64 != (v36 * v37) >> 63;
    v30 = v36 <= 0;
    v40 = 0x7FFFFFFFFFFFFFFFLL;
    if (v30)
      v40 = 0x8000000000000000;
    if (v39)
      v35 = v40;
    else
      v35 = v38;
    goto LABEL_39;
  }
  if (v33 == enum case for DispatchTimeInterval.microseconds(_:))
  {
    (*(void (**)(uint64_t *, uint64_t))(v2 + 96))(v32, v1);
    v36 = *v32;
    v37 = 1000;
    goto LABEL_34;
  }
  if (v33 == enum case for DispatchTimeInterval.nanoseconds(_:))
  {
    (*(void (**)(uint64_t *, uint64_t))(v2 + 96))(v32, v1);
    v35 = *v32;
  }
  else
  {
    if (v33 != enum case for DispatchTimeInterval.never(_:))
      (*(void (**)(uint64_t *, uint64_t))(v2 + 8))(v32, v1);
    v35 = 0x7FFFFFFFFFFFFFFFLL;
  }
LABEL_39:
  Hasher._combine(_:)(v35);
  Hasher._combine(_:)(*(_DWORD *)(v0 + v19[10]));
  Hasher._combine(_:)(*(_DWORD *)(v0 + v19[11]));
  Hasher._combine(_:)(*(_QWORD *)(v0 + v19[12]));
  Hasher._combine(_:)(*(_DWORD *)(v0 + v19[13]));
  Hasher._combine(_:)(*(_QWORD *)(v0 + v19[14]));
  Hasher._combine(_:)(*(_DWORD *)(v0 + v19[15]));
  v41 = *(_QWORD *)(v0 + v19[16]);
  Hasher._combine(_:)(*(_QWORD *)(v41 + 16));
  v42 = *(_QWORD *)(v41 + 16);
  if (v42)
  {
    v43 = (Swift::UInt8 *)(v41 + 32);
    do
    {
      v44 = *v43++;
      Hasher._combine(_:)(v44);
      --v42;
    }
    while (v42);
  }
}

Swift::Int AWDLActionFrame.Header.hashValue.getter()
{
  return sub_1000DE8A0((void (*)(_QWORD *))AWDLActionFrame.Header.hash(into:));
}

Swift::Int sub_1000DE8A0(void (*a1)(_QWORD *))
{
  _QWORD v3[9];

  Hasher.init(_seed:)(v3);
  a1(v3);
  return Hasher._finalize()();
}

Swift::Int sub_1000DE8E0(uint64_t a1, uint64_t a2)
{
  return sub_1000DE8EC(a1, a2, (void (*)(_QWORD *))AWDLActionFrame.Header.hash(into:));
}

Swift::Int sub_1000DE8EC(uint64_t a1, uint64_t a2, void (*a3)(_QWORD *))
{
  _QWORD v5[9];

  Hasher.init(_seed:)(v5);
  a3(v5);
  return Hasher._finalize()();
}

Swift::Int sub_1000DE930(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000D72EC(a1, a2, a3, (void (*)(_QWORD *))AWDLActionFrame.Header.hash(into:));
}

uint64_t sub_1000DE93C(uint64_t *a1, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  char isUniquelyReferenced_nonNull_native;
  uint64_t v14;
  uint64_t v15;

  v3 = v2;
  v6 = *v2;
  v7 = static Hasher._hash(seed:_:)(*(_QWORD *)(v6 + 40), a2);
  v8 = -1 << *(_BYTE *)(v6 + 32);
  v9 = v7 & ~v8;
  if (((*(_QWORD *)(v6 + 56 + ((v9 >> 3) & 0xFFFFFFFFFFFFF8)) >> v9) & 1) == 0)
  {
LABEL_7:
    isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v3);
    v15 = *v3;
    *v3 = 0x8000000000000000;
    sub_1000DFD04(a2, v9, isUniquelyReferenced_nonNull_native);
    v14 = *v3;
    *v3 = v15;
    swift_bridgeObjectRelease(v14);
    result = 1;
    goto LABEL_8;
  }
  v10 = *(_QWORD *)(v6 + 48);
  if (*(_QWORD *)(v10 + 8 * v9) != a2)
  {
    v11 = ~v8;
    do
    {
      v9 = (v9 + 1) & v11;
      if (((*(_QWORD *)(v6 + 56 + ((v9 >> 3) & 0xFFFFFFFFFFFFF8)) >> v9) & 1) == 0)
        goto LABEL_7;
    }
    while (*(_QWORD *)(v10 + 8 * v9) != a2);
  }
  result = 0;
LABEL_8:
  *a1 = a2;
  return result;
}

uint64_t sub_1000DEA34(_QWORD *a1, void *a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  Swift::Int v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v27;
  char v28;
  char isUniquelyReferenced_nonNull_native;
  id v30;
  uint64_t v31;
  void *v33;
  id v34;
  _QWORD v35[9];

  v3 = v2;
  v6 = *v2;
  v7 = static String._unconditionallyBridgeFromObjectiveC(_:)(a2);
  v9 = v8;
  Hasher.init(_seed:)(v35);
  swift_bridgeObjectRetain(v6);
  String.hash(into:)(v35, v7, v9);
  v10 = Hasher._finalize()();
  swift_bridgeObjectRelease(v9);
  v11 = -1 << *(_BYTE *)(v6 + 32);
  v12 = v10 & ~v11;
  if (((*(_QWORD *)(v6 + 56 + ((v12 >> 3) & 0xFFFFFFFFFFFFF8)) >> v12) & 1) == 0)
  {
LABEL_15:
    swift_bridgeObjectRelease(v6);
    isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v3);
    v35[0] = *v3;
    *v3 = 0x8000000000000000;
    v30 = a2;
    sub_1000DFE24(v30, v12, isUniquelyReferenced_nonNull_native);
    v31 = *v3;
    *v3 = v35[0];
    swift_bridgeObjectRelease(v31);
    *a1 = v30;
    return 1;
  }
  v13 = static String._unconditionallyBridgeFromObjectiveC(_:)(*(_QWORD *)(*(_QWORD *)(v6 + 48) + 8 * v12));
  v15 = v14;
  v16 = static String._unconditionallyBridgeFromObjectiveC(_:)(a2);
  if (v13 == v16 && v15 == v17)
  {
LABEL_16:
    swift_bridgeObjectRelease_n(v15, 2);
  }
  else
  {
    v19 = v17;
    v20 = _stringCompareWithSmolCheck(_:_:expecting:)(v13, v15, v16, v17, 0);
    swift_bridgeObjectRelease(v15);
    swift_bridgeObjectRelease(v19);
    if ((v20 & 1) == 0)
    {
      v21 = ~v11;
      do
      {
        v12 = (v12 + 1) & v21;
        if (((*(_QWORD *)(v6 + 56 + ((v12 >> 3) & 0xFFFFFFFFFFFFF8)) >> v12) & 1) == 0)
          goto LABEL_15;
        v22 = static String._unconditionallyBridgeFromObjectiveC(_:)(*(_QWORD *)(*(_QWORD *)(v6 + 48) + 8 * v12));
        v15 = v23;
        v24 = static String._unconditionallyBridgeFromObjectiveC(_:)(a2);
        if (v22 == v24 && v15 == v25)
          goto LABEL_16;
        v27 = v25;
        v28 = _stringCompareWithSmolCheck(_:_:expecting:)(v22, v15, v24, v25, 0);
        swift_bridgeObjectRelease(v15);
        swift_bridgeObjectRelease(v27);
      }
      while ((v28 & 1) == 0);
    }
  }

  swift_bridgeObjectRelease(v6);
  v33 = *(void **)(*(_QWORD *)(*v3 + 48) + 8 * v12);
  *a1 = v33;
  v34 = v33;
  return 0;
}

uint64_t sub_1000DEC5C(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  Swift::Int v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t (*v13)(uint64_t);
  uint64_t v14;
  uint64_t (*v15)(uint64_t);
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char v27;
  uint64_t *v29;
  char isUniquelyReferenced_nonNull_native;
  uint64_t v31;
  char *v32;
  uint64_t *v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  int v41;
  int v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;

  v34 = a1;
  v4 = *(_QWORD *)(type metadata accessor for AWDLPeer.AdvertisedService(0) - 8);
  __chkstk_darwin();
  v6 = (char *)&v32 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin();
  v8 = (char *)&v32 - v7;
  v33 = v2;
  v9 = *v2;
  Hasher.init(_seed:)(&v46);
  swift_bridgeObjectRetain(v9);
  AWDLPeer.AdvertisedService.hash(into:)((uint64_t)&v46);
  v10 = Hasher._finalize()();
  v11 = -1 << *(_BYTE *)(v9 + 32);
  v12 = v10 & ~v11;
  v39 = v9 + 56;
  if (((*(_QWORD *)(v9 + 56 + ((v12 >> 3) & 0xFFFFFFFFFFFFF8)) >> v12) & 1) == 0)
  {
    swift_bridgeObjectRelease(v9);
    goto LABEL_20;
  }
  v32 = v8;
  v36 = ~v11;
  v38 = *(_QWORD *)(v4 + 72);
  v13 = type metadata accessor for AWDLPeer.AdvertisedService;
  v37 = v9;
  do
  {
    v14 = *(_QWORD *)(v9 + 48);
    v35 = v38 * v12;
    v15 = v13;
    sub_1000637E0(v14 + v38 * v12, (uint64_t)v6, v13);
    v16 = *((_QWORD *)v6 + 1);
    v17 = *((_QWORD *)v6 + 2);
    v18 = *((_QWORD *)v6 + 3);
    v19 = *((_QWORD *)v6 + 4);
    v43 = v6[40];
    v41 = v6[41];
    v20 = *(_QWORD *)(a2 + 8);
    v21 = *(_QWORD *)(a2 + 16);
    v23 = *(_QWORD *)(a2 + 24);
    v22 = *(_QWORD *)(a2 + 32);
    v42 = *(unsigned __int8 *)(a2 + 40);
    v40 = *(unsigned __int8 *)(a2 + 41);
    v46 = v16;
    v47 = v17;
    v44 = v20;
    v45 = v21;
    v24 = sub_10001C920();
    if (StringProtocol.caseInsensitiveCompare<A>(_:)(&v44, &type metadata for String, &type metadata for String, v24, v24)|| (v46 = v18, v47 = v19, v44 = v23, v45 = v22, StringProtocol.caseInsensitiveCompare<A>(_:)(&v44, &type metadata for String, &type metadata for String, v24, v24)))
    {
LABEL_3:
      v13 = v15;
      sub_100063824((uint64_t)v6, v15);
      v9 = v37;
      goto LABEL_4;
    }
    if (v43)
      v25 = 7365749;
    else
      v25 = 7365492;
    if (v42)
      v26 = 7365749;
    else
      v26 = 7365492;
    if (v25 == v26)
    {
      swift_bridgeObjectRelease_n(0xE300000000000000, 2);
    }
    else
    {
      v27 = _stringCompareWithSmolCheck(_:_:expecting:)(v25, 0xE300000000000000, v26, 0xE300000000000000, 0);
      swift_bridgeObjectRelease_n(0xE300000000000000, 2);
      if ((v27 & 1) == 0)
        goto LABEL_3;
    }
    v13 = v15;
    sub_100063824((uint64_t)v6, v15);
    v9 = v37;
    if (v41 == v40)
    {
      swift_bridgeObjectRelease(v37);
      sub_100063824(a2, type metadata accessor for AWDLPeer.AdvertisedService);
      sub_1000637E0(*(_QWORD *)(*v33 + 48) + v35, v34, type metadata accessor for AWDLPeer.AdvertisedService);
      return 0;
    }
LABEL_4:
    v12 = (v12 + 1) & v36;
  }
  while (((*(_QWORD *)(v39 + ((v12 >> 3) & 0xFFFFFFFFFFFFF8)) >> v12) & 1) != 0);
  swift_bridgeObjectRelease(v9);
  v8 = v32;
LABEL_20:
  v29 = v33;
  isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v33);
  sub_1000637E0(a2, (uint64_t)v8, type metadata accessor for AWDLPeer.AdvertisedService);
  v46 = *v29;
  *v29 = 0x8000000000000000;
  sub_1000E0050((uint64_t)v8, v12, isUniquelyReferenced_nonNull_native);
  v31 = *v29;
  *v29 = v46;
  swift_bridgeObjectRelease(v31);
  sub_100033AC0(a2, v34, type metadata accessor for AWDLPeer.AdvertisedService);
  return 1;
}

uint64_t sub_1000DEFA0(_BYTE *a1, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  char isUniquelyReferenced_nonNull_native;
  uint64_t v14;
  uint64_t v15;

  v3 = v2;
  v6 = *v2;
  v7 = static Hasher._hash(seed:bytes:count:)(*(_QWORD *)(v6 + 40), a2, 1);
  v8 = -1 << *(_BYTE *)(v6 + 32);
  v9 = v7 & ~v8;
  if (((*(_QWORD *)(v6 + 56 + ((v9 >> 3) & 0xFFFFFFFFFFFFF8)) >> v9) & 1) == 0)
  {
LABEL_7:
    isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v3);
    v15 = *v3;
    *v3 = 0x8000000000000000;
    sub_1000E0340(a2, v9, isUniquelyReferenced_nonNull_native);
    v14 = *v3;
    *v3 = v15;
    swift_bridgeObjectRelease(v14);
    result = 1;
    goto LABEL_8;
  }
  v10 = *(_QWORD *)(v6 + 48);
  if (*(unsigned __int8 *)(v10 + v9) != a2)
  {
    v11 = ~v8;
    do
    {
      v9 = (v9 + 1) & v11;
      if (((*(_QWORD *)(v6 + 56 + ((v9 >> 3) & 0xFFFFFFFFFFFFF8)) >> v9) & 1) == 0)
        goto LABEL_7;
    }
    while (*(unsigned __int8 *)(v10 + v9) != a2);
  }
  result = 0;
LABEL_8:
  *a1 = a2;
  return result;
}

uint64_t sub_1000DF0A0(uint64_t a1)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  int64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  int64_t v17;
  unint64_t v18;
  int64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  char v24;
  unint64_t v25;
  BOOL v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;

  v2 = v1;
  v3 = *v1;
  if (*(_QWORD *)(*v1 + 24) <= a1)
    v4 = a1;
  else
    v4 = *(_QWORD *)(*v1 + 24);
  sub_100012C44(&qword_100407A70);
  result = static _SetStorage.resize(original:capacity:move:)(v3, v4, 1);
  v6 = result;
  if (*(_QWORD *)(v3 + 16))
  {
    v7 = 0;
    v8 = (uint64_t *)(v3 + 56);
    v9 = 1 << *(_BYTE *)(v3 + 32);
    v28 = -1 << v9;
    v29 = v2;
    if (v9 < 64)
      v10 = ~(-1 << v9);
    else
      v10 = -1;
    v11 = v10 & *(_QWORD *)(v3 + 56);
    v30 = 1 << *(_BYTE *)(v3 + 32);
    v12 = (unint64_t)(v9 + 63) >> 6;
    v13 = result + 56;
    while (1)
    {
      if (v11)
      {
        v15 = __clz(__rbit64(v11));
        v11 &= v11 - 1;
        v16 = v15 | (v7 << 6);
      }
      else
      {
        v17 = v7 + 1;
        if (__OFADD__(v7, 1))
        {
LABEL_41:
          __break(1u);
LABEL_42:
          __break(1u);
          return result;
        }
        if (v17 >= v12)
          goto LABEL_36;
        v18 = v8[v17];
        ++v7;
        if (!v18)
        {
          v7 = v17 + 1;
          if (v17 + 1 >= v12)
            goto LABEL_36;
          v18 = v8[v7];
          if (!v18)
          {
            v7 = v17 + 2;
            if (v17 + 2 >= v12)
              goto LABEL_36;
            v18 = v8[v7];
            if (!v18)
            {
              v19 = v17 + 3;
              if (v19 >= v12)
              {
LABEL_36:
                if (v30 >= 64)
                  bzero((void *)(v3 + 56), 8 * v12);
                else
                  *v8 = v28;
                v2 = v29;
                *(_QWORD *)(v3 + 16) = 0;
                break;
              }
              v18 = v8[v19];
              if (!v18)
              {
                while (1)
                {
                  v7 = v19 + 1;
                  if (__OFADD__(v19, 1))
                    goto LABEL_42;
                  if (v7 >= v12)
                    goto LABEL_36;
                  v18 = v8[v7];
                  ++v19;
                  if (v18)
                    goto LABEL_26;
                }
              }
              v7 = v19;
            }
          }
        }
LABEL_26:
        v11 = (v18 - 1) & v18;
        v16 = __clz(__rbit64(v18)) + (v7 << 6);
      }
      v20 = *(_QWORD *)(*(_QWORD *)(v3 + 48) + 8 * v16);
      result = static Hasher._hash(seed:_:)(*(_QWORD *)(v6 + 40), v20);
      v21 = -1 << *(_BYTE *)(v6 + 32);
      v22 = result & ~v21;
      v23 = v22 >> 6;
      if (((-1 << v22) & ~*(_QWORD *)(v13 + 8 * (v22 >> 6))) != 0)
      {
        v14 = __clz(__rbit64((-1 << v22) & ~*(_QWORD *)(v13 + 8 * (v22 >> 6)))) | v22 & 0x7FFFFFFFFFFFFFC0;
      }
      else
      {
        v24 = 0;
        v25 = (unint64_t)(63 - v21) >> 6;
        do
        {
          if (++v23 == v25 && (v24 & 1) != 0)
          {
            __break(1u);
            goto LABEL_41;
          }
          v26 = v23 == v25;
          if (v23 == v25)
            v23 = 0;
          v24 |= v26;
          v27 = *(_QWORD *)(v13 + 8 * v23);
        }
        while (v27 == -1);
        v14 = __clz(__rbit64(~v27)) + (v23 << 6);
      }
      *(_QWORD *)(v13 + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v14;
      *(_QWORD *)(*(_QWORD *)(v6 + 48) + 8 * v14) = v20;
      ++*(_QWORD *)(v6 + 16);
    }
  }
  result = swift_release(v3);
  *v2 = v6;
  return result;
}

uint64_t sub_1000DF320(uint64_t a1)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t result;
  int64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  int64_t v16;
  unint64_t v17;
  int64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  Swift::Int v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  char v27;
  unint64_t v28;
  BOOL v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  int64_t v33;
  _QWORD *v34;
  _QWORD v35[9];

  v2 = v1;
  v3 = *v1;
  if (*(_QWORD *)(*v1 + 24) <= a1)
    v4 = a1;
  else
    v4 = *(_QWORD *)(*v1 + 24);
  sub_100012C44(&qword_100407AD8);
  v5 = static _SetStorage.resize(original:capacity:move:)(v3, v4, 1);
  v6 = v5;
  if (*(_QWORD *)(v3 + 16))
  {
    v32 = v2;
    v7 = 1 << *(_BYTE *)(v3 + 32);
    v34 = (_QWORD *)(v3 + 56);
    if (v7 < 64)
      v8 = ~(-1 << v7);
    else
      v8 = -1;
    v9 = v8 & *(_QWORD *)(v3 + 56);
    v33 = (unint64_t)(v7 + 63) >> 6;
    v10 = v5 + 56;
    result = swift_retain(v3);
    v12 = 0;
    while (1)
    {
      if (v9)
      {
        v14 = __clz(__rbit64(v9));
        v9 &= v9 - 1;
        v15 = v14 | (v12 << 6);
      }
      else
      {
        v16 = v12 + 1;
        if (__OFADD__(v12, 1))
        {
LABEL_41:
          __break(1u);
LABEL_42:
          __break(1u);
          return result;
        }
        if (v16 >= v33)
          goto LABEL_36;
        v17 = v34[v16];
        ++v12;
        if (!v17)
        {
          v12 = v16 + 1;
          if (v16 + 1 >= v33)
            goto LABEL_36;
          v17 = v34[v12];
          if (!v17)
          {
            v12 = v16 + 2;
            if (v16 + 2 >= v33)
              goto LABEL_36;
            v17 = v34[v12];
            if (!v17)
            {
              v18 = v16 + 3;
              if (v18 >= v33)
              {
LABEL_36:
                swift_release(v3);
                v2 = v32;
                v31 = 1 << *(_BYTE *)(v3 + 32);
                if (v31 > 63)
                  bzero(v34, ((unint64_t)(v31 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
                else
                  *v34 = -1 << v31;
                *(_QWORD *)(v3 + 16) = 0;
                break;
              }
              v17 = v34[v18];
              if (!v17)
              {
                while (1)
                {
                  v12 = v18 + 1;
                  if (__OFADD__(v18, 1))
                    goto LABEL_42;
                  if (v12 >= v33)
                    goto LABEL_36;
                  v17 = v34[v12];
                  ++v18;
                  if (v17)
                    goto LABEL_26;
                }
              }
              v12 = v18;
            }
          }
        }
LABEL_26:
        v9 = (v17 - 1) & v17;
        v15 = __clz(__rbit64(v17)) + (v12 << 6);
      }
      v19 = *(_QWORD *)(*(_QWORD *)(v3 + 48) + 8 * v15);
      v20 = static String._unconditionallyBridgeFromObjectiveC(_:)(v19);
      v22 = v21;
      Hasher.init(_seed:)(v35);
      String.hash(into:)(v35, v20, v22);
      v23 = Hasher._finalize()();
      result = swift_bridgeObjectRelease(v22);
      v24 = -1 << *(_BYTE *)(v6 + 32);
      v25 = v23 & ~v24;
      v26 = v25 >> 6;
      if (((-1 << v25) & ~*(_QWORD *)(v10 + 8 * (v25 >> 6))) != 0)
      {
        v13 = __clz(__rbit64((-1 << v25) & ~*(_QWORD *)(v10 + 8 * (v25 >> 6)))) | v25 & 0x7FFFFFFFFFFFFFC0;
      }
      else
      {
        v27 = 0;
        v28 = (unint64_t)(63 - v24) >> 6;
        do
        {
          if (++v26 == v28 && (v27 & 1) != 0)
          {
            __break(1u);
            goto LABEL_41;
          }
          v29 = v26 == v28;
          if (v26 == v28)
            v26 = 0;
          v27 |= v29;
          v30 = *(_QWORD *)(v10 + 8 * v26);
        }
        while (v30 == -1);
        v13 = __clz(__rbit64(~v30)) + (v26 << 6);
      }
      *(_QWORD *)(v10 + ((v13 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v13;
      *(_QWORD *)(*(_QWORD *)(v6 + 48) + 8 * v13) = v19;
      ++*(_QWORD *)(v6 + 16);
    }
  }
  result = swift_release(v3);
  *v2 = v6;
  return result;
}

void sub_1000DF630(uint64_t a1)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  int64_t v14;
  unint64_t v15;
  unint64_t v16;
  int64_t v17;
  unint64_t v18;
  int64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  Swift::UInt8 v25;
  Swift::String v26;
  Swift::String v27;
  uint64_t v28;
  Swift::Int v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  char v33;
  unint64_t v34;
  BOOL v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t *v39;
  int64_t v40;
  _QWORD *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int64_t v45;
  uint64_t v46;
  _QWORD v47[9];

  v2 = v1;
  v43 = *(_QWORD *)(type metadata accessor for AWDLPeer.AdvertisedService(0) - 8);
  __chkstk_darwin();
  v5 = (char *)&v38 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  v6 = *v2;
  if (*(_QWORD *)(*v2 + 24) > a1)
    a1 = *(_QWORD *)(*v2 + 24);
  sub_100012C44((uint64_t *)&unk_10040EA80);
  v7 = static _SetStorage.resize(original:capacity:move:)(v6, a1, 1);
  v8 = v7;
  if (!*(_QWORD *)(v6 + 16))
    goto LABEL_42;
  v9 = 1 << *(_BYTE *)(v6 + 32);
  v10 = *(_QWORD *)(v6 + 56);
  v41 = (_QWORD *)(v6 + 56);
  if (v9 < 64)
    v11 = ~(-1 << v9);
  else
    v11 = -1;
  v12 = v11 & v10;
  v39 = v2;
  v40 = (unint64_t)(v9 + 63) >> 6;
  v13 = v7 + 56;
  swift_retain();
  v14 = 0;
  v42 = v6;
  while (1)
  {
    if (v12)
    {
      v45 = v14;
      v46 = (v12 - 1) & v12;
      v16 = __clz(__rbit64(v12)) | (v14 << 6);
      goto LABEL_26;
    }
    v17 = v14 + 1;
    if (__OFADD__(v14, 1))
    {
LABEL_43:
      __break(1u);
LABEL_44:
      __break(1u);
      return;
    }
    if (v17 >= v40)
      goto LABEL_38;
    v18 = v41[v17];
    v19 = v14 + 1;
    if (!v18)
    {
      v19 = v14 + 2;
      if (v14 + 2 >= v40)
        goto LABEL_38;
      v18 = v41[v19];
      if (!v18)
      {
        v19 = v14 + 3;
        if (v14 + 3 >= v40)
          goto LABEL_38;
        v18 = v41[v19];
        if (!v18)
          break;
      }
    }
LABEL_25:
    v45 = v19;
    v46 = (v18 - 1) & v18;
    v16 = __clz(__rbit64(v18)) + (v19 << 6);
LABEL_26:
    v21 = *(_QWORD *)(v6 + 48);
    v44 = *(_QWORD *)(v43 + 72);
    sub_100033AC0(v21 + v44 * v16, (uint64_t)v5, type metadata accessor for AWDLPeer.AdvertisedService);
    Hasher.init(_seed:)(v47);
    v22 = *((_QWORD *)v5 + 2);
    v23 = *((_QWORD *)v5 + 4);
    v24 = v5[40];
    v25 = v5[41];
    v26 = String.lowercased()();
    swift_bridgeObjectRetain(v22);
    swift_bridgeObjectRetain(v23);
    String.hash(into:)(v47, v26._countAndFlagsBits, v26._object);
    swift_bridgeObjectRelease(v26._object);
    v27 = String.lowercased()();
    swift_bridgeObjectRetain(v23);
    String.hash(into:)(v47, v27._countAndFlagsBits, v27._object);
    swift_bridgeObjectRelease(v27._object);
    if (v24)
      v28 = 7365749;
    else
      v28 = 7365492;
    String.hash(into:)(v47, v28, 0xE300000000000000);
    swift_bridgeObjectRelease(0xE300000000000000);
    Hasher._combine(_:)(v25);
    swift_bridgeObjectRelease(v22);
    swift_bridgeObjectRelease_n(v23, 2);
    v29 = Hasher._finalize()();
    v30 = -1 << *(_BYTE *)(v8 + 32);
    v31 = v29 & ~v30;
    v32 = v31 >> 6;
    if (((-1 << v31) & ~*(_QWORD *)(v13 + 8 * (v31 >> 6))) != 0)
    {
      v15 = __clz(__rbit64((-1 << v31) & ~*(_QWORD *)(v13 + 8 * (v31 >> 6)))) | v31 & 0x7FFFFFFFFFFFFFC0;
      v12 = v46;
    }
    else
    {
      v33 = 0;
      v34 = (unint64_t)(63 - v30) >> 6;
      v12 = v46;
      do
      {
        if (++v32 == v34 && (v33 & 1) != 0)
        {
          __break(1u);
          goto LABEL_43;
        }
        v35 = v32 == v34;
        if (v32 == v34)
          v32 = 0;
        v33 |= v35;
        v36 = *(_QWORD *)(v13 + 8 * v32);
      }
      while (v36 == -1);
      v15 = __clz(__rbit64(~v36)) + (v32 << 6);
    }
    *(_QWORD *)(v13 + ((v15 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v15;
    sub_100033AC0((uint64_t)v5, *(_QWORD *)(v8 + 48) + v15 * v44, type metadata accessor for AWDLPeer.AdvertisedService);
    ++*(_QWORD *)(v8 + 16);
    v6 = v42;
    v14 = v45;
  }
  v20 = v14 + 4;
  if (v14 + 4 < v40)
  {
    v18 = v41[v20];
    if (!v18)
    {
      while (1)
      {
        v19 = v20 + 1;
        if (__OFADD__(v20, 1))
          goto LABEL_44;
        if (v19 >= v40)
          goto LABEL_38;
        v18 = v41[v19];
        ++v20;
        if (v18)
          goto LABEL_25;
      }
    }
    v19 = v14 + 4;
    goto LABEL_25;
  }
LABEL_38:
  swift_release(v6);
  v2 = v39;
  v37 = 1 << *(_BYTE *)(v6 + 32);
  if (v37 > 63)
    bzero(v41, ((unint64_t)(v37 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
  else
    *v41 = -1 << v37;
  *(_QWORD *)(v6 + 16) = 0;
LABEL_42:
  swift_release(v6);
  *v2 = v8;
}

void sub_1000DFA70(uint64_t a1)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  int64_t v17;
  unint64_t v18;
  int64_t v19;
  unsigned __int8 v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  char v25;
  unint64_t v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t *v30;

  v2 = v1;
  v3 = *v1;
  if (*(_QWORD *)(*v1 + 24) <= a1)
    v4 = a1;
  else
    v4 = *(_QWORD *)(*v1 + 24);
  sub_100012C44((uint64_t *)&unk_100404890);
  v5 = static _SetStorage.resize(original:capacity:move:)(v3, v4, 1);
  v6 = v5;
  if (*(_QWORD *)(v3 + 16))
  {
    v30 = v2;
    v7 = 0;
    v8 = (_QWORD *)(v3 + 56);
    v9 = 1 << *(_BYTE *)(v3 + 32);
    if (v9 < 64)
      v10 = ~(-1 << v9);
    else
      v10 = -1;
    v11 = v10 & *(_QWORD *)(v3 + 56);
    v12 = (unint64_t)(v9 + 63) >> 6;
    v13 = v5 + 56;
    while (1)
    {
      if (v11)
      {
        v15 = __clz(__rbit64(v11));
        v11 &= v11 - 1;
        v16 = v15 | (v7 << 6);
      }
      else
      {
        v17 = v7 + 1;
        if (__OFADD__(v7, 1))
        {
LABEL_41:
          __break(1u);
LABEL_42:
          __break(1u);
          return;
        }
        if (v17 >= v12)
          goto LABEL_36;
        v18 = v8[v17];
        ++v7;
        if (!v18)
        {
          v7 = v17 + 1;
          if (v17 + 1 >= v12)
            goto LABEL_36;
          v18 = v8[v7];
          if (!v18)
          {
            v7 = v17 + 2;
            if (v17 + 2 >= v12)
              goto LABEL_36;
            v18 = v8[v7];
            if (!v18)
            {
              v19 = v17 + 3;
              if (v19 >= v12)
              {
LABEL_36:
                v29 = 1 << *(_BYTE *)(v3 + 32);
                if (v29 > 63)
                  bzero((void *)(v3 + 56), ((unint64_t)(v29 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
                else
                  *v8 = -1 << v29;
                v2 = v30;
                *(_QWORD *)(v3 + 16) = 0;
                break;
              }
              v18 = v8[v19];
              if (!v18)
              {
                while (1)
                {
                  v7 = v19 + 1;
                  if (__OFADD__(v19, 1))
                    goto LABEL_42;
                  if (v7 >= v12)
                    goto LABEL_36;
                  v18 = v8[v7];
                  ++v19;
                  if (v18)
                    goto LABEL_26;
                }
              }
              v7 = v19;
            }
          }
        }
LABEL_26:
        v11 = (v18 - 1) & v18;
        v16 = __clz(__rbit64(v18)) + (v7 << 6);
      }
      v20 = *(_BYTE *)(*(_QWORD *)(v3 + 48) + v16);
      v21 = static Hasher._hash(seed:bytes:count:)(*(_QWORD *)(v6 + 40), v20, 1);
      v22 = -1 << *(_BYTE *)(v6 + 32);
      v23 = v21 & ~v22;
      v24 = v23 >> 6;
      if (((-1 << v23) & ~*(_QWORD *)(v13 + 8 * (v23 >> 6))) != 0)
      {
        v14 = __clz(__rbit64((-1 << v23) & ~*(_QWORD *)(v13 + 8 * (v23 >> 6)))) | v23 & 0x7FFFFFFFFFFFFFC0;
      }
      else
      {
        v25 = 0;
        v26 = (unint64_t)(63 - v22) >> 6;
        do
        {
          if (++v24 == v26 && (v25 & 1) != 0)
          {
            __break(1u);
            goto LABEL_41;
          }
          v27 = v24 == v26;
          if (v24 == v26)
            v24 = 0;
          v25 |= v27;
          v28 = *(_QWORD *)(v13 + 8 * v24);
        }
        while (v28 == -1);
        v14 = __clz(__rbit64(~v28)) + (v24 << 6);
      }
      *(_QWORD *)(v13 + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v14;
      *(_BYTE *)(*(_QWORD *)(v6 + 48) + v14) = v20;
      ++*(_QWORD *)(v6 + 16);
    }
  }
  swift_release(v3);
  *v2 = v6;
}

uint64_t sub_1000DFD04(uint64_t result, unint64_t a2, char a3)
{
  uint64_t *v3;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;

  v5 = result;
  v6 = *(_QWORD *)(*v3 + 16);
  v7 = *(_QWORD *)(*v3 + 24);
  if (v7 > v6 && (a3 & 1) != 0)
    goto LABEL_14;
  v8 = v6 + 1;
  if ((a3 & 1) != 0)
  {
    sub_1000DF0A0(v8);
  }
  else
  {
    if (v7 > v6)
    {
      result = (uint64_t)sub_10014947C();
      goto LABEL_14;
    }
    sub_1000E0464(v8);
  }
  v9 = *v3;
  result = static Hasher._hash(seed:_:)(*(_QWORD *)(*v3 + 40), v5);
  v10 = -1 << *(_BYTE *)(v9 + 32);
  a2 = result & ~v10;
  if (((*(_QWORD *)(v9 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFF8)) >> a2) & 1) != 0)
  {
    v11 = *(_QWORD *)(v9 + 48);
    if (*(_QWORD *)(v11 + 8 * a2) == v5)
    {
LABEL_13:
      result = ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)(&type metadata for UInt64);
      __break(1u);
    }
    else
    {
      v12 = ~v10;
      while (1)
      {
        a2 = (a2 + 1) & v12;
        if (((*(_QWORD *)(v9 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFF8)) >> a2) & 1) == 0)
          break;
        if (*(_QWORD *)(v11 + 8 * a2) == v5)
          goto LABEL_13;
      }
    }
  }
LABEL_14:
  v13 = *v3;
  *(_QWORD *)(*v3 + 8 * (a2 >> 6) + 56) |= 1 << a2;
  *(_QWORD *)(*(_QWORD *)(v13 + 48) + 8 * a2) = v5;
  v14 = *(_QWORD *)(v13 + 16);
  v15 = __OFADD__(v14, 1);
  v16 = v14 + 1;
  if (v15)
    __break(1u);
  else
    *(_QWORD *)(v13 + 16) = v16;
  return result;
}

id sub_1000DFE24(id result, unint64_t a2, char a3)
{
  Swift::Int v3;
  uint64_t *v4;
  id v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  Swift::Int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;
  char v21;
  uint64_t v22;
  uint64_t v23;
  Swift::Int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v28;
  char v29;
  uint64_t v30;
  uint64_t v31;
  BOOL v32;
  uint64_t v33;
  _QWORD v34[9];

  v4 = (uint64_t *)v3;
  v6 = result;
  v7 = *(_QWORD *)(*(_QWORD *)v3 + 16);
  v8 = *(_QWORD *)(*(_QWORD *)v3 + 24);
  if (v8 > v7 && (a3 & 1) != 0)
    goto LABEL_22;
  v9 = v7 + 1;
  if ((a3 & 1) != 0)
  {
    sub_1000DF320(v9);
  }
  else
  {
    if (v8 > v7)
    {
      result = sub_100149610();
LABEL_22:
      v30 = *v4;
      *(_QWORD *)(*v4 + 8 * (a2 >> 6) + 56) |= 1 << a2;
      *(_QWORD *)(*(_QWORD *)(v30 + 48) + 8 * a2) = v6;
      v31 = *(_QWORD *)(v30 + 16);
      v32 = __OFADD__(v31, 1);
      v33 = v31 + 1;
      if (!v32)
      {
        *(_QWORD *)(v30 + 16) = v33;
        return result;
      }
      __break(1u);
      goto LABEL_25;
    }
    sub_1000E06C4(v9);
  }
  v10 = *(_QWORD *)v3;
  v11 = static String._unconditionallyBridgeFromObjectiveC(_:)(v6);
  v13 = v12;
  Hasher.init(_seed:)(v34);
  String.hash(into:)(v34, v11, v13);
  v3 = Hasher._finalize()();
  result = (id)swift_bridgeObjectRelease(v13);
  v14 = -1 << *(_BYTE *)(v10 + 32);
  a2 = v3 & ~v14;
  if (((*(_QWORD *)(v10 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFF8)) >> a2) & 1) == 0)
    goto LABEL_22;
  v15 = static String._unconditionallyBridgeFromObjectiveC(_:)(*(_QWORD *)(*(_QWORD *)(v10 + 48) + 8 * a2));
  v3 = v16;
  v17 = static String._unconditionallyBridgeFromObjectiveC(_:)(v6);
  if (v15 == v17 && v3 == v18)
  {
LABEL_25:
    swift_bridgeObjectRelease_n(v3, 2);
    goto LABEL_26;
  }
  v20 = v18;
  v21 = _stringCompareWithSmolCheck(_:_:expecting:)(v15, v3, v17, v18, 0);
  swift_bridgeObjectRelease(v3);
  result = (id)swift_bridgeObjectRelease(v20);
  if ((v21 & 1) == 0)
  {
    v22 = ~v14;
    do
    {
      a2 = (a2 + 1) & v22;
      if (((*(_QWORD *)(v10 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFF8)) >> a2) & 1) == 0)
        goto LABEL_22;
      v23 = static String._unconditionallyBridgeFromObjectiveC(_:)(*(_QWORD *)(*(_QWORD *)(v10 + 48) + 8 * a2));
      v3 = v24;
      v25 = static String._unconditionallyBridgeFromObjectiveC(_:)(v6);
      if (v23 == v25 && v3 == v26)
        goto LABEL_25;
      v28 = v26;
      v29 = _stringCompareWithSmolCheck(_:_:expecting:)(v23, v3, v25, v26, 0);
      swift_bridgeObjectRelease(v3);
      result = (id)swift_bridgeObjectRelease(v28);
    }
    while ((v29 & 1) == 0);
  }
LABEL_26:
  type metadata accessor for AWDLTrafficRegistrationService(0);
  result = (id)ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)();
  __break(1u);
  return result;
}

uint64_t sub_1000E0050(uint64_t a1, unint64_t a2, char a3)
{
  uint64_t *v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  Swift::Int v15;
  uint64_t v16;
  uint64_t (*v17)(uint64_t);
  uint64_t (*v18)(uint64_t);
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  uint64_t result;
  uint64_t v33;
  BOOL v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  int v45;
  int v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;

  v7 = type metadata accessor for AWDLPeer.AdvertisedService(0);
  v8 = *(_QWORD *)(v7 - 8);
  __chkstk_darwin();
  v10 = (char *)&v36 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  v11 = *(_QWORD *)(*v3 + 16);
  v12 = *(_QWORD *)(*v3 + 24);
  v38 = v8;
  v39 = v3;
  if (v12 > v11 && (a3 & 1) != 0)
    goto LABEL_25;
  v13 = v11 + 1;
  if ((a3 & 1) != 0)
  {
    sub_1000DF630(v13);
  }
  else
  {
    if (v12 > v11)
    {
      sub_1001497B8();
      goto LABEL_25;
    }
    sub_1000E09A0(v13);
  }
  v14 = *v3;
  Hasher.init(_seed:)(&v50);
  AWDLPeer.AdvertisedService.hash(into:)((uint64_t)&v50);
  v15 = Hasher._finalize()();
  v16 = -1 << *(_BYTE *)(v14 + 32);
  a2 = v15 & ~v16;
  v42 = v14 + 56;
  v43 = v14;
  if (((*(_QWORD *)(v14 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFF8)) >> a2) & 1) != 0)
  {
    v37 = v7;
    v41 = ~v16;
    v40 = *(_QWORD *)(v8 + 72);
    v17 = type metadata accessor for AWDLPeer.AdvertisedService;
    while (1)
    {
      v18 = v17;
      sub_1000637E0(*(_QWORD *)(v43 + 48) + v40 * a2, (uint64_t)v10, v17);
      v19 = *((_QWORD *)v10 + 1);
      v20 = *((_QWORD *)v10 + 2);
      v21 = *((_QWORD *)v10 + 3);
      v22 = *((_QWORD *)v10 + 4);
      v47 = v10[40];
      v45 = v10[41];
      v23 = *(_QWORD *)(a1 + 8);
      v24 = *(_QWORD *)(a1 + 16);
      v25 = *(_QWORD *)(a1 + 24);
      v26 = *(_QWORD *)(a1 + 32);
      v46 = *(unsigned __int8 *)(a1 + 40);
      v44 = *(unsigned __int8 *)(a1 + 41);
      v50 = v19;
      v51 = v20;
      v48 = v23;
      v49 = v24;
      v27 = sub_10001C920();
      if (StringProtocol.caseInsensitiveCompare<A>(_:)(&v48, &type metadata for String, &type metadata for String, v27, v27))
      {
        break;
      }
      v50 = v21;
      v51 = v22;
      v48 = v25;
      v49 = v26;
      if (StringProtocol.caseInsensitiveCompare<A>(_:)(&v48, &type metadata for String, &type metadata for String, v27, v27))
      {
        break;
      }
      if (v47)
        v28 = 7365749;
      else
        v28 = 7365492;
      if (v46)
        v29 = 7365749;
      else
        v29 = 7365492;
      if (v28 == v29)
      {
        swift_bridgeObjectRelease_n(0xE300000000000000, 2);
      }
      else
      {
        v30 = _stringCompareWithSmolCheck(_:_:expecting:)(v28, 0xE300000000000000, v29, 0xE300000000000000, 0);
        swift_bridgeObjectRelease_n(0xE300000000000000, 2);
        if ((v30 & 1) == 0)
          break;
      }
      v17 = v18;
      sub_100063824((uint64_t)v10, v18);
      if (v45 == v44)
      {
        ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v37);
        __break(1u);
        goto LABEL_25;
      }
LABEL_11:
      a2 = (a2 + 1) & v41;
      if (((*(_QWORD *)(v42 + ((a2 >> 3) & 0xFFFFFFFFFFFFF8)) >> a2) & 1) == 0)
        goto LABEL_25;
    }
    v17 = v18;
    sub_100063824((uint64_t)v10, v18);
    goto LABEL_11;
  }
LABEL_25:
  v31 = *v39;
  *(_QWORD *)(*v39 + 8 * (a2 >> 6) + 56) |= 1 << a2;
  result = sub_100033AC0(a1, *(_QWORD *)(v31 + 48) + *(_QWORD *)(v38 + 72) * a2, type metadata accessor for AWDLPeer.AdvertisedService);
  v33 = *(_QWORD *)(v31 + 16);
  v34 = __OFADD__(v33, 1);
  v35 = v33 + 1;
  if (v34)
    __break(1u);
  else
    *(_QWORD *)(v31 + 16) = v35;
  return result;
}

uint64_t sub_1000E0340(uint64_t result, unint64_t a2, char a3)
{
  uint64_t *v3;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;

  v5 = result;
  v6 = *(_QWORD *)(*v3 + 16);
  v7 = *(_QWORD *)(*v3 + 24);
  if (v7 > v6 && (a3 & 1) != 0)
    goto LABEL_14;
  v8 = v6 + 1;
  if ((a3 & 1) != 0)
  {
    sub_1000DFA70(v8);
  }
  else
  {
    if (v7 > v6)
    {
      result = (uint64_t)sub_1001499D8();
      goto LABEL_14;
    }
    sub_1000E0DAC(v8);
  }
  v9 = *v3;
  result = static Hasher._hash(seed:bytes:count:)(*(_QWORD *)(*v3 + 40), v5, 1);
  v10 = -1 << *(_BYTE *)(v9 + 32);
  a2 = result & ~v10;
  if (((*(_QWORD *)(v9 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFF8)) >> a2) & 1) != 0)
  {
    v11 = *(_QWORD *)(v9 + 48);
    if (*(unsigned __int8 *)(v11 + a2) == (_DWORD)v5)
    {
LABEL_13:
      result = ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)(&type metadata for UInt8);
      __break(1u);
    }
    else
    {
      v12 = ~v10;
      while (1)
      {
        a2 = (a2 + 1) & v12;
        if (((*(_QWORD *)(v9 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFF8)) >> a2) & 1) == 0)
          break;
        if (*(unsigned __int8 *)(v11 + a2) == (_DWORD)v5)
          goto LABEL_13;
      }
    }
  }
LABEL_14:
  v13 = *v3;
  *(_QWORD *)(*v3 + 8 * (a2 >> 6) + 56) |= 1 << a2;
  *(_BYTE *)(*(_QWORD *)(v13 + 48) + a2) = v5;
  v14 = *(_QWORD *)(v13 + 16);
  v15 = __OFADD__(v14, 1);
  v16 = v14 + 1;
  if (v15)
    __break(1u);
  else
    *(_QWORD *)(v13 + 16) = v16;
  return result;
}

uint64_t sub_1000E0464(uint64_t a1)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  int64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  int64_t v17;
  unint64_t v18;
  int64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  char v24;
  unint64_t v25;
  BOOL v26;
  uint64_t v27;
  uint64_t *v28;

  v2 = v1;
  v3 = *v1;
  if (*(_QWORD *)(*v1 + 24) <= a1)
    v4 = a1;
  else
    v4 = *(_QWORD *)(*v1 + 24);
  sub_100012C44(&qword_100407A70);
  result = static _SetStorage.resize(original:capacity:move:)(v3, v4, 0);
  v6 = result;
  if (!*(_QWORD *)(v3 + 16))
  {
    result = swift_release(v3);
LABEL_38:
    *v2 = v6;
    return result;
  }
  v28 = v2;
  v7 = 0;
  v8 = v3 + 56;
  v9 = 1 << *(_BYTE *)(v3 + 32);
  if (v9 < 64)
    v10 = ~(-1 << v9);
  else
    v10 = -1;
  v11 = v10 & *(_QWORD *)(v3 + 56);
  v12 = (unint64_t)(v9 + 63) >> 6;
  v13 = result + 56;
  while (1)
  {
    if (v11)
    {
      v15 = __clz(__rbit64(v11));
      v11 &= v11 - 1;
      v16 = v15 | (v7 << 6);
      goto LABEL_27;
    }
    v17 = v7 + 1;
    if (__OFADD__(v7, 1))
    {
LABEL_39:
      __break(1u);
      goto LABEL_40;
    }
    if (v17 >= v12)
      goto LABEL_36;
    v18 = *(_QWORD *)(v8 + 8 * v17);
    ++v7;
    if (!v18)
    {
      v7 = v17 + 1;
      if (v17 + 1 >= v12)
        goto LABEL_36;
      v18 = *(_QWORD *)(v8 + 8 * v7);
      if (!v18)
      {
        v7 = v17 + 2;
        if (v17 + 2 >= v12)
          goto LABEL_36;
        v18 = *(_QWORD *)(v8 + 8 * v7);
        if (!v18)
          break;
      }
    }
LABEL_26:
    v11 = (v18 - 1) & v18;
    v16 = __clz(__rbit64(v18)) + (v7 << 6);
LABEL_27:
    v20 = *(_QWORD *)(*(_QWORD *)(v3 + 48) + 8 * v16);
    result = static Hasher._hash(seed:_:)(*(_QWORD *)(v6 + 40), v20);
    v21 = -1 << *(_BYTE *)(v6 + 32);
    v22 = result & ~v21;
    v23 = v22 >> 6;
    if (((-1 << v22) & ~*(_QWORD *)(v13 + 8 * (v22 >> 6))) != 0)
    {
      v14 = __clz(__rbit64((-1 << v22) & ~*(_QWORD *)(v13 + 8 * (v22 >> 6)))) | v22 & 0x7FFFFFFFFFFFFFC0;
    }
    else
    {
      v24 = 0;
      v25 = (unint64_t)(63 - v21) >> 6;
      do
      {
        if (++v23 == v25 && (v24 & 1) != 0)
        {
          __break(1u);
          goto LABEL_39;
        }
        v26 = v23 == v25;
        if (v23 == v25)
          v23 = 0;
        v24 |= v26;
        v27 = *(_QWORD *)(v13 + 8 * v23);
      }
      while (v27 == -1);
      v14 = __clz(__rbit64(~v27)) + (v23 << 6);
    }
    *(_QWORD *)(v13 + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v14;
    *(_QWORD *)(*(_QWORD *)(v6 + 48) + 8 * v14) = v20;
    ++*(_QWORD *)(v6 + 16);
  }
  v19 = v17 + 3;
  if (v19 >= v12)
  {
LABEL_36:
    result = swift_release(v3);
    v2 = v28;
    goto LABEL_38;
  }
  v18 = *(_QWORD *)(v8 + 8 * v19);
  if (v18)
  {
    v7 = v19;
    goto LABEL_26;
  }
  while (1)
  {
    v7 = v19 + 1;
    if (__OFADD__(v19, 1))
      break;
    if (v7 >= v12)
      goto LABEL_36;
    v18 = *(_QWORD *)(v8 + 8 * v7);
    ++v19;
    if (v18)
      goto LABEL_26;
  }
LABEL_40:
  __break(1u);
  return result;
}

uint64_t sub_1000E06C4(uint64_t a1)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t result;
  int64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  int64_t v16;
  unint64_t v17;
  int64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  id v23;
  Swift::Int v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  char v28;
  unint64_t v29;
  BOOL v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  int64_t v34;
  _QWORD v35[9];

  v2 = v1;
  v3 = *v1;
  if (*(_QWORD *)(*v1 + 24) <= a1)
    v4 = a1;
  else
    v4 = *(_QWORD *)(*v1 + 24);
  sub_100012C44(&qword_100407AD8);
  v5 = static _SetStorage.resize(original:capacity:move:)(v3, v4, 0);
  v6 = v5;
  if (!*(_QWORD *)(v3 + 16))
  {
    result = swift_release(v3);
LABEL_38:
    *v2 = v6;
    return result;
  }
  v7 = 1 << *(_BYTE *)(v3 + 32);
  v32 = v2;
  v33 = v3 + 56;
  if (v7 < 64)
    v8 = ~(-1 << v7);
  else
    v8 = -1;
  v9 = v8 & *(_QWORD *)(v3 + 56);
  v34 = (unint64_t)(v7 + 63) >> 6;
  v10 = v5 + 56;
  result = swift_retain(v3);
  v12 = 0;
  while (1)
  {
    if (v9)
    {
      v14 = __clz(__rbit64(v9));
      v9 &= v9 - 1;
      v15 = v14 | (v12 << 6);
      goto LABEL_27;
    }
    v16 = v12 + 1;
    if (__OFADD__(v12, 1))
    {
LABEL_39:
      __break(1u);
      goto LABEL_40;
    }
    if (v16 >= v34)
      goto LABEL_36;
    v17 = *(_QWORD *)(v33 + 8 * v16);
    ++v12;
    if (!v17)
    {
      v12 = v16 + 1;
      if (v16 + 1 >= v34)
        goto LABEL_36;
      v17 = *(_QWORD *)(v33 + 8 * v12);
      if (!v17)
      {
        v12 = v16 + 2;
        if (v16 + 2 >= v34)
          goto LABEL_36;
        v17 = *(_QWORD *)(v33 + 8 * v12);
        if (!v17)
          break;
      }
    }
LABEL_26:
    v9 = (v17 - 1) & v17;
    v15 = __clz(__rbit64(v17)) + (v12 << 6);
LABEL_27:
    v19 = *(void **)(*(_QWORD *)(v3 + 48) + 8 * v15);
    v20 = static String._unconditionallyBridgeFromObjectiveC(_:)(v19);
    v22 = v21;
    Hasher.init(_seed:)(v35);
    v23 = v19;
    String.hash(into:)(v35, v20, v22);
    v24 = Hasher._finalize()();
    result = swift_bridgeObjectRelease(v22);
    v25 = -1 << *(_BYTE *)(v6 + 32);
    v26 = v24 & ~v25;
    v27 = v26 >> 6;
    if (((-1 << v26) & ~*(_QWORD *)(v10 + 8 * (v26 >> 6))) != 0)
    {
      v13 = __clz(__rbit64((-1 << v26) & ~*(_QWORD *)(v10 + 8 * (v26 >> 6)))) | v26 & 0x7FFFFFFFFFFFFFC0;
    }
    else
    {
      v28 = 0;
      v29 = (unint64_t)(63 - v25) >> 6;
      do
      {
        if (++v27 == v29 && (v28 & 1) != 0)
        {
          __break(1u);
          goto LABEL_39;
        }
        v30 = v27 == v29;
        if (v27 == v29)
          v27 = 0;
        v28 |= v30;
        v31 = *(_QWORD *)(v10 + 8 * v27);
      }
      while (v31 == -1);
      v13 = __clz(__rbit64(~v31)) + (v27 << 6);
    }
    *(_QWORD *)(v10 + ((v13 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v13;
    *(_QWORD *)(*(_QWORD *)(v6 + 48) + 8 * v13) = v23;
    ++*(_QWORD *)(v6 + 16);
  }
  v18 = v16 + 3;
  if (v18 >= v34)
  {
LABEL_36:
    result = swift_release_n(v3, 2);
    v2 = v32;
    goto LABEL_38;
  }
  v17 = *(_QWORD *)(v33 + 8 * v18);
  if (v17)
  {
    v12 = v18;
    goto LABEL_26;
  }
  while (1)
  {
    v12 = v18 + 1;
    if (__OFADD__(v18, 1))
      break;
    if (v12 >= v34)
      goto LABEL_36;
    v17 = *(_QWORD *)(v33 + 8 * v12);
    ++v18;
    if (v17)
      goto LABEL_26;
  }
LABEL_40:
  __break(1u);
  return result;
}

void sub_1000E09A0(uint64_t a1)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  int64_t v14;
  unint64_t v15;
  unint64_t v16;
  int64_t v17;
  unint64_t v18;
  int64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  Swift::UInt8 v25;
  Swift::String v26;
  Swift::String v27;
  uint64_t v28;
  Swift::Int v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  char v33;
  unint64_t v34;
  BOOL v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  int64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int64_t v44;
  uint64_t v45;
  _QWORD v46[9];

  v2 = v1;
  v42 = *(_QWORD *)(type metadata accessor for AWDLPeer.AdvertisedService(0) - 8);
  __chkstk_darwin();
  v5 = (char *)&v37 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  v6 = *v2;
  if (*(_QWORD *)(*v2 + 24) > a1)
    a1 = *(_QWORD *)(*v2 + 24);
  sub_100012C44((uint64_t *)&unk_10040EA80);
  v7 = static _SetStorage.resize(original:capacity:move:)(v6, a1, 0);
  v8 = v7;
  if (!*(_QWORD *)(v6 + 16))
  {
    swift_release(v6);
LABEL_40:
    *v2 = v8;
    return;
  }
  v9 = 1 << *(_BYTE *)(v6 + 32);
  v10 = *(_QWORD *)(v6 + 56);
  v38 = v2;
  v39 = v6 + 56;
  if (v9 < 64)
    v11 = ~(-1 << v9);
  else
    v11 = -1;
  v12 = v11 & v10;
  v40 = (unint64_t)(v9 + 63) >> 6;
  v13 = v7 + 56;
  swift_retain();
  v14 = 0;
  v41 = v6;
  while (1)
  {
    if (v12)
    {
      v44 = v14;
      v45 = (v12 - 1) & v12;
      v16 = __clz(__rbit64(v12)) | (v14 << 6);
      goto LABEL_26;
    }
    v17 = v14 + 1;
    if (__OFADD__(v14, 1))
    {
LABEL_41:
      __break(1u);
      goto LABEL_42;
    }
    if (v17 >= v40)
      goto LABEL_38;
    v18 = *(_QWORD *)(v39 + 8 * v17);
    v19 = v14 + 1;
    if (!v18)
    {
      v19 = v14 + 2;
      if (v14 + 2 >= v40)
        goto LABEL_38;
      v18 = *(_QWORD *)(v39 + 8 * v19);
      if (!v18)
      {
        v19 = v14 + 3;
        if (v14 + 3 >= v40)
          goto LABEL_38;
        v18 = *(_QWORD *)(v39 + 8 * v19);
        if (!v18)
          break;
      }
    }
LABEL_25:
    v44 = v19;
    v45 = (v18 - 1) & v18;
    v16 = __clz(__rbit64(v18)) + (v19 << 6);
LABEL_26:
    v21 = *(_QWORD *)(v6 + 48);
    v43 = *(_QWORD *)(v42 + 72);
    sub_1000637E0(v21 + v43 * v16, (uint64_t)v5, type metadata accessor for AWDLPeer.AdvertisedService);
    Hasher.init(_seed:)(v46);
    v22 = *((_QWORD *)v5 + 2);
    v23 = *((_QWORD *)v5 + 4);
    v24 = v5[40];
    v25 = v5[41];
    v26 = String.lowercased()();
    swift_bridgeObjectRetain(v22);
    swift_bridgeObjectRetain(v23);
    String.hash(into:)(v46, v26._countAndFlagsBits, v26._object);
    swift_bridgeObjectRelease(v26._object);
    v27 = String.lowercased()();
    swift_bridgeObjectRetain(v23);
    String.hash(into:)(v46, v27._countAndFlagsBits, v27._object);
    swift_bridgeObjectRelease(v27._object);
    if (v24)
      v28 = 7365749;
    else
      v28 = 7365492;
    String.hash(into:)(v46, v28, 0xE300000000000000);
    swift_bridgeObjectRelease(0xE300000000000000);
    Hasher._combine(_:)(v25);
    swift_bridgeObjectRelease(v22);
    swift_bridgeObjectRelease_n(v23, 2);
    v29 = Hasher._finalize()();
    v30 = -1 << *(_BYTE *)(v8 + 32);
    v31 = v29 & ~v30;
    v32 = v31 >> 6;
    if (((-1 << v31) & ~*(_QWORD *)(v13 + 8 * (v31 >> 6))) != 0)
    {
      v15 = __clz(__rbit64((-1 << v31) & ~*(_QWORD *)(v13 + 8 * (v31 >> 6)))) | v31 & 0x7FFFFFFFFFFFFFC0;
      v6 = v41;
      v12 = v45;
    }
    else
    {
      v33 = 0;
      v34 = (unint64_t)(63 - v30) >> 6;
      v6 = v41;
      v12 = v45;
      do
      {
        if (++v32 == v34 && (v33 & 1) != 0)
        {
          __break(1u);
          goto LABEL_41;
        }
        v35 = v32 == v34;
        if (v32 == v34)
          v32 = 0;
        v33 |= v35;
        v36 = *(_QWORD *)(v13 + 8 * v32);
      }
      while (v36 == -1);
      v15 = __clz(__rbit64(~v36)) + (v32 << 6);
    }
    *(_QWORD *)(v13 + ((v15 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v15;
    sub_100033AC0((uint64_t)v5, *(_QWORD *)(v8 + 48) + v15 * v43, type metadata accessor for AWDLPeer.AdvertisedService);
    ++*(_QWORD *)(v8 + 16);
    v14 = v44;
  }
  v20 = v14 + 4;
  if (v14 + 4 >= v40)
  {
LABEL_38:
    swift_release_n(v6, 2);
    v2 = v38;
    goto LABEL_40;
  }
  v18 = *(_QWORD *)(v39 + 8 * v20);
  if (v18)
  {
    v19 = v14 + 4;
    goto LABEL_25;
  }
  while (1)
  {
    v19 = v20 + 1;
    if (__OFADD__(v20, 1))
      break;
    if (v19 >= v40)
      goto LABEL_38;
    v18 = *(_QWORD *)(v39 + 8 * v19);
    ++v20;
    if (v18)
      goto LABEL_25;
  }
LABEL_42:
  __break(1u);
}

void sub_1000E0DAC(uint64_t a1)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  int64_t v17;
  unint64_t v18;
  int64_t v19;
  unsigned __int8 v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  char v25;
  unint64_t v26;
  BOOL v27;
  uint64_t v28;
  uint64_t *v29;

  v2 = v1;
  v3 = *v1;
  if (*(_QWORD *)(*v1 + 24) <= a1)
    v4 = a1;
  else
    v4 = *(_QWORD *)(*v1 + 24);
  sub_100012C44((uint64_t *)&unk_100404890);
  v5 = static _SetStorage.resize(original:capacity:move:)(v3, v4, 0);
  v6 = v5;
  if (!*(_QWORD *)(v3 + 16))
  {
    swift_release(v3);
LABEL_38:
    *v2 = v6;
    return;
  }
  v29 = v2;
  v7 = 0;
  v8 = v3 + 56;
  v9 = 1 << *(_BYTE *)(v3 + 32);
  if (v9 < 64)
    v10 = ~(-1 << v9);
  else
    v10 = -1;
  v11 = v10 & *(_QWORD *)(v3 + 56);
  v12 = (unint64_t)(v9 + 63) >> 6;
  v13 = v5 + 56;
  while (1)
  {
    if (v11)
    {
      v15 = __clz(__rbit64(v11));
      v11 &= v11 - 1;
      v16 = v15 | (v7 << 6);
      goto LABEL_27;
    }
    v17 = v7 + 1;
    if (__OFADD__(v7, 1))
    {
LABEL_39:
      __break(1u);
      goto LABEL_40;
    }
    if (v17 >= v12)
      goto LABEL_36;
    v18 = *(_QWORD *)(v8 + 8 * v17);
    ++v7;
    if (!v18)
    {
      v7 = v17 + 1;
      if (v17 + 1 >= v12)
        goto LABEL_36;
      v18 = *(_QWORD *)(v8 + 8 * v7);
      if (!v18)
      {
        v7 = v17 + 2;
        if (v17 + 2 >= v12)
          goto LABEL_36;
        v18 = *(_QWORD *)(v8 + 8 * v7);
        if (!v18)
          break;
      }
    }
LABEL_26:
    v11 = (v18 - 1) & v18;
    v16 = __clz(__rbit64(v18)) + (v7 << 6);
LABEL_27:
    v20 = *(_BYTE *)(*(_QWORD *)(v3 + 48) + v16);
    v21 = static Hasher._hash(seed:bytes:count:)(*(_QWORD *)(v6 + 40), v20, 1);
    v22 = -1 << *(_BYTE *)(v6 + 32);
    v23 = v21 & ~v22;
    v24 = v23 >> 6;
    if (((-1 << v23) & ~*(_QWORD *)(v13 + 8 * (v23 >> 6))) != 0)
    {
      v14 = __clz(__rbit64((-1 << v23) & ~*(_QWORD *)(v13 + 8 * (v23 >> 6)))) | v23 & 0x7FFFFFFFFFFFFFC0;
    }
    else
    {
      v25 = 0;
      v26 = (unint64_t)(63 - v22) >> 6;
      do
      {
        if (++v24 == v26 && (v25 & 1) != 0)
        {
          __break(1u);
          goto LABEL_39;
        }
        v27 = v24 == v26;
        if (v24 == v26)
          v24 = 0;
        v25 |= v27;
        v28 = *(_QWORD *)(v13 + 8 * v24);
      }
      while (v28 == -1);
      v14 = __clz(__rbit64(~v28)) + (v24 << 6);
    }
    *(_QWORD *)(v13 + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v14;
    *(_BYTE *)(*(_QWORD *)(v6 + 48) + v14) = v20;
    ++*(_QWORD *)(v6 + 16);
  }
  v19 = v17 + 3;
  if (v19 >= v12)
  {
LABEL_36:
    swift_release(v3);
    v2 = v29;
    goto LABEL_38;
  }
  v18 = *(_QWORD *)(v8 + 8 * v19);
  if (v18)
  {
    v7 = v19;
    goto LABEL_26;
  }
  while (1)
  {
    v7 = v19 + 1;
    if (__OFADD__(v19, 1))
      break;
    if (v7 >= v12)
      goto LABEL_36;
    v18 = *(_QWORD *)(v8 + 8 * v7);
    ++v19;
    if (v18)
      goto LABEL_26;
  }
LABEL_40:
  __break(1u);
}

uint64_t _s7CoreP2P15AWDLActionFrameV15ServiceResponseO21__derived_enum_equalsySbAE_AEtFZ_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  int EnumCaseMultiPayload;
  uint64_t v18;
  uint64_t v19;
  __int16 v20;
  __int16 v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  char v34;
  char v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  __int16 v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  __int16 v44;
  __int16 v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  __int16 v50;
  __int16 v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  __int16 v64;
  unint64_t v65;
  BOOL v66;
  uint64_t v68;
  int v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t v73;
  int *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;

  v74 = (int *)type metadata accessor for DNSRecords.SRV(0);
  __chkstk_darwin();
  v5 = (char *)&v68 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  v6 = type metadata accessor for AWDLActionFrame.ServiceResponse(0);
  __chkstk_darwin();
  v8 = (char *)&v68 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin();
  v10 = (char *)&v68 - v9;
  __chkstk_darwin();
  v12 = (char *)&v68 - v11;
  sub_100012C44(&qword_100407BA8);
  v13 = __chkstk_darwin();
  v15 = (char *)&v68 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  v16 = (uint64_t)&v15[*(int *)(v13 + 48)];
  sub_1000637E0(a1, (uint64_t)v15, type metadata accessor for AWDLActionFrame.ServiceResponse);
  sub_1000637E0(a2, v16, type metadata accessor for AWDLActionFrame.ServiceResponse);
  EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(v15, v6);
  if (EnumCaseMultiPayload)
  {
    if (EnumCaseMultiPayload == 1)
    {
      sub_1000637E0((uint64_t)v15, (uint64_t)v10, type metadata accessor for AWDLActionFrame.ServiceResponse);
      v18 = *((_QWORD *)v10 + 1);
      v74 = (int *)*((_QWORD *)v10 + 2);
      v19 = *((_QWORD *)v10 + 3);
      v20 = v10[32];
      v21 = v10[33];
      v23 = *((_QWORD *)v10 + 5);
      v22 = *((_QWORD *)v10 + 6);
      if (swift_getEnumCaseMultiPayload(v16, v6) == 1)
      {
        v72 = v23;
        v73 = v22;
        v24 = *(_QWORD *)v10;
        v25 = *(_QWORD *)v16;
        v26 = *(_QWORD *)(v16 + 8);
        v27 = *(_QWORD *)(v16 + 24);
        v71 = *(_QWORD *)(v16 + 16);
        v28 = *(unsigned __int8 *)(v16 + 32);
        v69 = *(unsigned __int8 *)(v16 + 33);
        v70 = v28;
        v30 = *(_QWORD *)(v16 + 40);
        v29 = *(_QWORD *)(v16 + 48);
        v77 = v24;
        v78 = v18;
        v75 = v25;
        v76 = v26;
        v31 = sub_10001C920();
        if (!StringProtocol.caseInsensitiveCompare<A>(_:)(&v75, &type metadata for String, &type metadata for String, v31, v31)&& sub_100106584((uint64_t)v74, v19, v20 | (v21 << 8), v71, v27, v70 | ((_WORD)v69 << 8)))
        {
          v33 = v72;
          v32 = v73;
          _s7CoreP2P6NANPMKV23__derived_struct_equalsySbAC_ACtFZ_0(v72, v73);
          v35 = v34;
          swift_bridgeObjectRelease(v27);
          swift_bridgeObjectRelease(v26);
          sub_10000E614(v30, v29);
          swift_bridgeObjectRelease(v19);
          swift_bridgeObjectRelease(v18);
          sub_10000E614(v33, v32);
          if ((v35 & 1) == 0)
            goto LABEL_29;
LABEL_28:
          sub_100063824((uint64_t)v15, type metadata accessor for AWDLActionFrame.ServiceResponse);
          return 1;
        }
        swift_bridgeObjectRelease(v27);
        swift_bridgeObjectRelease(v26);
        sub_10000E614(v30, v29);
        swift_bridgeObjectRelease(v19);
        swift_bridgeObjectRelease(v18);
        sub_10000E614(v72, v73);
        goto LABEL_29;
      }
      swift_bridgeObjectRelease(v19);
      swift_bridgeObjectRelease(v18);
      sub_10000E614(v23, v22);
    }
    else
    {
      sub_1000637E0((uint64_t)v15, (uint64_t)v8, type metadata accessor for AWDLActionFrame.ServiceResponse);
      if (swift_getEnumCaseMultiPayload(v16, v6) == 2)
      {
        sub_100033AC0(v16, (uint64_t)v5, type metadata accessor for DNSRecords.SRV);
        v41 = *(_QWORD *)v8;
        v42 = *((_QWORD *)v8 + 1);
        v43 = *((_QWORD *)v8 + 2);
        v72 = *((_QWORD *)v8 + 3);
        v73 = v43;
        v44 = v8[32];
        v45 = v8[33];
        v46 = *(_QWORD *)v5;
        v47 = *((_QWORD *)v5 + 1);
        v48 = *((_QWORD *)v5 + 2);
        v49 = *((_QWORD *)v5 + 3);
        v50 = v5[32];
        v51 = v5[33];
        v77 = v41;
        v78 = v42;
        v75 = v46;
        v76 = v47;
        v52 = sub_10001C920();
        if (!StringProtocol.caseInsensitiveCompare<A>(_:)(&v75, &type metadata for String, &type metadata for String, v52, v52)&& sub_100106584(v73, v72, v44 | (v45 << 8), v48, v49, v50 | (v51 << 8)))
        {
          v53 = type metadata accessor for NWEndpoint.Port(0);
          v54 = sub_100011DE4(&qword_100406120, (uint64_t (*)(uint64_t))&type metadata accessor for NWEndpoint.Port, (uint64_t)&protocol conformance descriptor for NWEndpoint.Port);
          dispatch thunk of RawRepresentable.rawValue.getter(&v77, v53, v54);
          dispatch thunk of RawRepresentable.rawValue.getter(&v75, v53, v54);
          if ((unsigned __int16)v77 == (unsigned __int16)v75)
          {
            if ((v55 = v74[6],
                  v56 = *(_QWORD *)&v8[v55],
                  v57 = *(_QWORD *)&v8[v55 + 8],
                  v58 = &v5[v55],
                  v59 = *((_QWORD *)v58 + 1),
                  v56 == *(_QWORD *)v58)
              && v57 == v59
              || (_stringCompareWithSmolCheck(_:_:expecting:)(v56, v57, *(_QWORD *)v58, v59, 0) & 1) != 0)
            {
              if (*(unsigned __int16 *)&v8[v74[7]] == *(unsigned __int16 *)&v5[v74[7]]
                && *(unsigned __int16 *)&v8[v74[8]] == *(unsigned __int16 *)&v5[v74[8]])
              {
                sub_100063824((uint64_t)v5, type metadata accessor for DNSRecords.SRV);
                sub_100063824((uint64_t)v8, type metadata accessor for DNSRecords.SRV);
                goto LABEL_28;
              }
            }
          }
        }
        sub_100063824((uint64_t)v5, type metadata accessor for DNSRecords.SRV);
        sub_100063824((uint64_t)v8, type metadata accessor for DNSRecords.SRV);
LABEL_29:
        sub_100063824((uint64_t)v15, type metadata accessor for AWDLActionFrame.ServiceResponse);
        return 0;
      }
      sub_100063824((uint64_t)v8, type metadata accessor for DNSRecords.SRV);
    }
  }
  else
  {
    sub_1000637E0((uint64_t)v15, (uint64_t)v12, type metadata accessor for AWDLActionFrame.ServiceResponse);
    v36 = *((_QWORD *)v12 + 1);
    v37 = *((_QWORD *)v12 + 2);
    v38 = *((_QWORD *)v12 + 3);
    v39 = v12[32];
    v40 = v12[33];
    if (!swift_getEnumCaseMultiPayload(v16, v6))
    {
      v60 = *(_QWORD *)v12;
      v61 = *(_QWORD *)v16;
      v62 = *(_QWORD *)(v16 + 8);
      v63 = *(_QWORD *)(v16 + 24);
      v74 = *(int **)(v16 + 16);
      v75 = v61;
      LODWORD(v73) = *(unsigned __int8 *)(v16 + 32);
      v64 = *(unsigned __int8 *)(v16 + 33);
      v77 = v60;
      v78 = v36;
      v76 = v62;
      v65 = sub_10001C920();
      if (StringProtocol.caseInsensitiveCompare<A>(_:)(&v75, &type metadata for String, &type metadata for String, v65, v65))
      {
        swift_bridgeObjectRelease(v63);
        swift_bridgeObjectRelease(v62);
        swift_bridgeObjectRelease(v38);
        swift_bridgeObjectRelease(v36);
      }
      else
      {
        v66 = sub_100106584(v37, v38, v39 | (v40 << 8), (uint64_t)v74, v63, v73 | (v64 << 8));
        swift_bridgeObjectRelease(v63);
        swift_bridgeObjectRelease(v62);
        swift_bridgeObjectRelease(v38);
        swift_bridgeObjectRelease(v36);
        if (v66)
          goto LABEL_28;
      }
      goto LABEL_29;
    }
    swift_bridgeObjectRelease(v38);
    swift_bridgeObjectRelease(v36);
  }
  sub_100033A84((uint64_t)v15, &qword_100407BA8);
  return 0;
}

uint64_t _s7CoreP2P15AWDLActionFrameV24SynchronizationParameterV23__derived_struct_equalsySbAE_AEtFZ_0(unsigned __int8 *a1, unsigned __int8 *a2)
{
  BOOL v2;

  if (*a1 == *a2
    && *((unsigned __int16 *)a1 + 1) == *((unsigned __int16 *)a2 + 1)
    && a1[4] == a2[4]
    && a1[5] == a2[5]
    && *((unsigned __int16 *)a1 + 3) == *((unsigned __int16 *)a2 + 3)
    && *((unsigned __int16 *)a1 + 4) == *((unsigned __int16 *)a2 + 4)
    && *((unsigned __int16 *)a1 + 5) == *((unsigned __int16 *)a2 + 5)
    && *((unsigned __int16 *)a1 + 6) == *((unsigned __int16 *)a2 + 6)
    && *((unsigned __int16 *)a1 + 7) == *((unsigned __int16 *)a2 + 7)
    && *((unsigned __int16 *)a1 + 8) == *((unsigned __int16 *)a2 + 8)
    && a1[18] == a2[18]
    && a1[19] == a2[19]
    && a1[20] == a2[20]
    && a1[21] == a2[21]
    && (*(_DWORD *)(a1 + 22) == *(_DWORD *)(a2 + 22)
      ? (v2 = *((unsigned __int16 *)a1 + 13) == *((unsigned __int16 *)a2 + 13))
      : (v2 = 0),
        v2
     && a1[28] == a2[28]
     && a1[29] == a2[29]
     && *((unsigned __int16 *)a1 + 15) == *((unsigned __int16 *)a2 + 15)
     && *((unsigned __int16 *)a1 + 16) == *((unsigned __int16 *)a2 + 16)))
  {
    return _s7CoreP2P15AWDLActionFrameV28AWDLChannelSequenceParameterV23__derived_struct_equalsySbAE_AEtFZ_0(*((_QWORD *)a1 + 5), *((_QWORD *)a2 + 5));
  }
  else
  {
    return 0;
  }
}

uint64_t _s7CoreP2P15AWDLActionFrameV6HeaderV23__derived_struct_equalsySbAE_AEtFZ_0(uint64_t a1, uint64_t a2)
{
  BOOL v5;
  int v6;
  int *v7;

  if (*(_DWORD *)a1 != *(_DWORD *)a2 || *(unsigned __int16 *)(a1 + 4) != *(unsigned __int16 *)(a2 + 4))
    return 0;
  v5 = *(_DWORD *)(a1 + 6) == *(_DWORD *)(a2 + 6) && *(unsigned __int16 *)(a1 + 10) == *(unsigned __int16 *)(a2 + 10);
  if (!v5
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || ((0x801004u >> (8 * *(_BYTE *)(a1 + 16))) & 0xFFC) != ((0x801004u >> (8 * *(_BYTE *)(a2 + 16))) & 0xFFC))
  {
    return 0;
  }
  v6 = *(unsigned __int8 *)(a2 + 17);
  switch(*(_BYTE *)(a1 + 17))
  {
    case 2:
      if (v6 != 2)
        return 0;
      break;
    case 3:
      if (v6 != 3)
        return 0;
      break;
    case 4:
      if (v6 != 4)
        return 0;
      break;
    case 5:
      if (v6 != 5)
        return 0;
      break;
    case 6:
      if (v6 != 6)
        return 0;
      break;
    default:
      if ((v6 - 2) < 5 || ((((*(_BYTE *)(a1 + 17) & 1) == 0) ^ v6) & 1) == 0)
        return 0;
      break;
  }
  if (*(_DWORD *)(a1 + 20) == *(_DWORD *)(a2 + 20)
    && (v7 = (int *)type metadata accessor for AWDLActionFrame.Header(0),
        (static DispatchTimeInterval.== infix(_:_:)(a1 + v7[8], a2 + v7[8]) & 1) != 0)
    && (static DispatchTimeInterval.== infix(_:_:)(a1 + v7[9], a2 + v7[9]) & 1) != 0
    && *(_DWORD *)(a1 + v7[10]) == *(_DWORD *)(a2 + v7[10])
    && *(_DWORD *)(a1 + v7[11]) == *(_DWORD *)(a2 + v7[11])
    && *(_QWORD *)(a1 + v7[12]) == *(_QWORD *)(a2 + v7[12])
    && *(_DWORD *)(a1 + v7[13]) == *(_DWORD *)(a2 + v7[13])
    && *(_QWORD *)(a1 + v7[14]) == *(_QWORD *)(a2 + v7[14])
    && *(_DWORD *)(a1 + v7[15]) == *(_DWORD *)(a2 + v7[15]))
  {
    return sub_1000851D0(*(_QWORD *)(a1 + v7[16]), *(_QWORD *)(a2 + v7[16]));
  }
  else
  {
    return 0;
  }
}

BOOL _s7CoreP2P15AWDLActionFrameV13RealtimeGroupV23__derived_struct_equalsySbAE_AEtFZ_0(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  unint64_t v12;

  if (*a1 != *a2)
    return 0;
  if (*(_DWORD *)(a1 + 1) != *(_DWORD *)(a2 + 1) || *(unsigned __int16 *)(a1 + 5) != *(unsigned __int16 *)(a2 + 5))
    return 0;
  v4 = *((unsigned int *)a1 + 2) | ((unint64_t)*((unsigned __int16 *)a1 + 6) << 32);
  v5 = *((unsigned int *)a2 + 2) | ((unint64_t)*((unsigned __int16 *)a2 + 6) << 32);
  v6 = v5 & 0xFF00000000;
  if ((v4 & 0xFF00000000) != 0x300000000)
  {
    if (v6 != 0x300000000
      && *((_DWORD *)a1 + 2) == *((_DWORD *)a2 + 2)
      && ((0x801004u >> ((v4 >> 29) & 0xF8)) & 0xFFC) == ((0x801004u >> ((v5 >> 29) & 0xF8)) & 0xFFC))
    {
      v11 = v5 >> 40;
      switch(v4 >> 40)
      {
        case 2uLL:
          if ((_DWORD)v11 == 2)
            goto LABEL_9;
          return 0;
        case 3uLL:
          if ((_DWORD)v11 == 3)
            goto LABEL_9;
          return 0;
        case 4uLL:
          if ((_DWORD)v11 == 4)
            goto LABEL_9;
          return 0;
        case 5uLL:
          if ((_DWORD)v11 == 5)
            goto LABEL_9;
          return 0;
        case 6uLL:
          if ((_DWORD)v11 == 6)
            goto LABEL_9;
          return 0;
        default:
          if ((v11 - 2) >= 5 && ((v4 & 0x10000000000) == 0) != ((v5 >> 40) & 1))
            goto LABEL_9;
          return 0;
      }
    }
    return 0;
  }
  if (v6 != 0x300000000)
    return 0;
LABEL_9:
  if (*((_QWORD *)a1 + 2) != *((_QWORD *)a2 + 2) || a1[24] != a2[24])
    return 0;
  v7 = *((unsigned int *)a1 + 7) | ((unint64_t)*((unsigned __int16 *)a1 + 16) << 32);
  v8 = *((unsigned int *)a2 + 7) | ((unint64_t)*((unsigned __int16 *)a2 + 16) << 32);
  v9 = v8 & 0xFF00000000;
  if ((v7 & 0xFF00000000) != 0x300000000)
  {
    if (v9 != 0x300000000
      && *((_DWORD *)a1 + 7) == *((_DWORD *)a2 + 7)
      && ((0x801004u >> ((v7 >> 29) & 0xF8)) & 0xFFC) == ((0x801004u >> ((v8 >> 29) & 0xF8)) & 0xFFC))
    {
      v12 = v8 >> 40;
      switch(v7 >> 40)
      {
        case 2uLL:
          if ((_DWORD)v12 == 2)
            return *(_DWORD *)(a1 + 34) == *(_DWORD *)(a2 + 34)
                && *((unsigned __int16 *)a1 + 19) == *((unsigned __int16 *)a2 + 19);
          return 0;
        case 3uLL:
          if ((_DWORD)v12 == 3)
            return *(_DWORD *)(a1 + 34) == *(_DWORD *)(a2 + 34)
                && *((unsigned __int16 *)a1 + 19) == *((unsigned __int16 *)a2 + 19);
          return 0;
        case 4uLL:
          if ((_DWORD)v12 == 4)
            return *(_DWORD *)(a1 + 34) == *(_DWORD *)(a2 + 34)
                && *((unsigned __int16 *)a1 + 19) == *((unsigned __int16 *)a2 + 19);
          return 0;
        case 5uLL:
          if ((_DWORD)v12 == 5)
            return *(_DWORD *)(a1 + 34) == *(_DWORD *)(a2 + 34)
                && *((unsigned __int16 *)a1 + 19) == *((unsigned __int16 *)a2 + 19);
          return 0;
        case 6uLL:
          if ((_DWORD)v12 == 6)
            return *(_DWORD *)(a1 + 34) == *(_DWORD *)(a2 + 34)
                && *((unsigned __int16 *)a1 + 19) == *((unsigned __int16 *)a2 + 19);
          return 0;
        default:
          if ((v12 - 2) >= 5 && ((v7 & 0x10000000000) == 0) != ((v8 >> 40) & 1))
            return *(_DWORD *)(a1 + 34) == *(_DWORD *)(a2 + 34)
                && *((unsigned __int16 *)a1 + 19) == *((unsigned __int16 *)a2 + 19);
          return 0;
      }
    }
    return 0;
  }
  if (v9 != 0x300000000)
    return 0;
  return *(_DWORD *)(a1 + 34) == *(_DWORD *)(a2 + 34)
      && *((unsigned __int16 *)a1 + 19) == *((unsigned __int16 *)a2 + 19);
}

BOOL _s7CoreP2P15AWDLActionFrameV17ElectionParameterV23__derived_struct_equalsySbAE_AEtFZ_0(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  BOOL v5;

  v2 = *(_DWORD *)a1 == *(_DWORD *)a2 && *(unsigned __int16 *)(a1 + 4) == *(unsigned __int16 *)(a2 + 4);
  if (v2
    && (*(_DWORD *)(a1 + 6) == *(_DWORD *)(a2 + 6)
      ? (v5 = *(unsigned __int16 *)(a1 + 10) == *(unsigned __int16 *)(a2 + 10))
      : (v5 = 0),
        v5
     && *(_DWORD *)(a1 + 12) == *(_DWORD *)(a2 + 12)
     && *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 16)
     && (sub_10014F120(*(unsigned int *)(a1 + 20) | ((unint64_t)*(unsigned __int8 *)(a1 + 24) << 32), *(unsigned int *)(a2 + 20) | ((unint64_t)*(unsigned __int8 *)(a2 + 24) << 32)) & 1) != 0&& (sub_10014F120(*(unsigned int *)(a1 + 28) | ((unint64_t)*(unsigned __int8 *)(a1 + 32) << 32), *(unsigned int *)(a2 + 28) | ((unint64_t)*(unsigned __int8 *)(a2 + 32) << 32)) & 1) != 0&& *(_DWORD *)(a1 + 36) == *(_DWORD *)(a2 + 36)&& *(_DWORD *)(a1 + 40) == *(_DWORD *)(a2 + 40)))
  {
    return *(_DWORD *)(a1 + 44) == *(_DWORD *)(a2 + 44);
  }
  else
  {
    return 0;
  }
}

BOOL sub_1000E1E28(unint64_t a1, unint64_t a2)
{
  if ((_DWORD)a1 != (_DWORD)a2
    || ((0x801004u >> ((a1 >> 29) & 0xF8)) & 0xFFC) != ((0x801004u >> ((a2 >> 29) & 0xF8)) & 0xFFC))
  {
    return 0;
  }
  switch(BYTE5(a1))
  {
    case 2:
      if (BYTE5(a2) != 2)
        return 0;
      break;
    case 3:
      if (BYTE5(a2) != 3)
        return 0;
      break;
    case 4:
      if (BYTE5(a2) != 4)
        return 0;
      break;
    case 5:
      if (BYTE5(a2) != 5)
        return 0;
      break;
    case 6:
      if (BYTE5(a2) != 6)
        return 0;
      break;
    default:
      if (BYTE5(a2) - 2 < 5 || ((a1 & 0x10000000000) == 0) == ((a2 >> 40) & 1))
        return 0;
      break;
  }
  return BYTE6(a1) == BYTE6(a2);
}

uint64_t sub_1000E1F08(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  if ((_DWORD)a1 != (_DWORD)a3
    || ((0x801004u >> ((a1 >> 29) & 0xF8)) & 0xFFC) != ((0x801004u >> ((a3 >> 29) & 0xF8)) & 0xFFC))
  {
    return 0;
  }
  switch(BYTE5(a1))
  {
    case 2:
      if (BYTE5(a3) != 2)
        return 0;
      break;
    case 3:
      if (BYTE5(a3) != 3)
        return 0;
      break;
    case 4:
      if (BYTE5(a3) != 4)
        return 0;
      break;
    case 5:
      if (BYTE5(a3) != 5)
        return 0;
      break;
    case 6:
      if (BYTE5(a3) != 6)
        return 0;
      break;
    default:
      if (BYTE5(a3) - 2 < 5 || ((a1 & 0x10000000000) == 0) == ((a3 >> 40) & 1))
        return 0;
      break;
  }
  return sub_100085D94(a2, a4);
}

BOOL _s7CoreP2P15AWDLActionFrameV18NANSynchronizationV23__derived_struct_equalsySbAE_AEtFZ_0(unsigned __int16 *a1, unsigned __int16 *a2)
{
  BOOL v2;
  BOOL v3;
  BOOL v4;

  if (*a1 == *a2
    && (*(_DWORD *)(a1 + 1) == *(_DWORD *)(a2 + 1) ? (v2 = a1[3] == a2[3]) : (v2 = 0),
        v2
     && (*((_DWORD *)a1 + 2) == *((_DWORD *)a2 + 2) ? (v3 = a1[6] == a2[6]) : (v3 = 0),
         v3
      && *((_QWORD *)a1 + 2) == *((_QWORD *)a2 + 2)
      && *((unsigned __int8 *)a1 + 24) == *((unsigned __int8 *)a2 + 24)
      && *((unsigned __int8 *)a1 + 25) == *((unsigned __int8 *)a2 + 25)
      && (*(_DWORD *)(a1 + 13) == *(_DWORD *)(a2 + 13) ? (v4 = a1[15] == a2[15]) : (v4 = 0),
          v4
       && *((unsigned __int8 *)a1 + 32) == *((unsigned __int8 *)a2 + 32)
       && *((unsigned __int8 *)a1 + 33) == *((unsigned __int8 *)a2 + 33)
       && a1[17] == a2[17]))))
  {
    return *((_DWORD *)a1 + 9) == *((_DWORD *)a2 + 9);
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1000E2118(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5, uint64_t a6, uint64_t a7, char a8)
{
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  __int128 v16;
  int v18;
  __int16 v19;
  int v20;
  __int16 v21;

  if (a1 != a5
    || WORD1(a1) != WORD1(a5)
    || BYTE4(a1) != BYTE4(a5)
    || BYTE5(a1) != BYTE5(a5))
  {
    return 0;
  }
  LOBYTE(v20) = BYTE6(a1);
  BYTE1(v20) = HIBYTE(a1);
  HIWORD(v20) = a2;
  LOBYTE(v21) = BYTE2(a2);
  HIBYTE(v21) = BYTE3(a2);
  LOBYTE(v18) = BYTE6(a5);
  BYTE1(v18) = HIBYTE(a5);
  HIWORD(v18) = a6;
  LOBYTE(v19) = BYTE2(a6);
  HIBYTE(v19) = BYTE3(a6);
  if (v20 != v18 || v21 != v19)
    return 0;
  *((_QWORD *)&v14 + 1) = a3 & 1;
  *(_QWORD *)&v14 = a2;
  v13 = v14 >> 32;
  *((_QWORD *)&v14 + 1) = a7 & 1;
  *(_QWORD *)&v14 = a6;
  if ((sub_10014F120(v13, v14 >> 32) & 1) == 0)
    return 0;
  *((_QWORD *)&v16 + 1) = a4 & 1;
  *(_QWORD *)&v16 = a3;
  v15 = v16 >> 32;
  *((_QWORD *)&v16 + 1) = a8 & 1;
  *(_QWORD *)&v16 = a7;
  return sub_10014F120(v15, v16 >> 32);
}

uint64_t sub_1000E22A0(uint64_t a1, int a2, uint64_t a3, unint64_t a4, int a5, uint64_t a6)
{
  if (a1 == a4
    && HIDWORD(a1) == HIDWORD(a4)
    && BYTE2(a1) == BYTE2(a4)
    && ((a1 & 0x100) == 0) != ((a4 >> 8) & 1)
    && a2 == a5)
  {
    return sub_100089D24(a3, a6);
  }
  else
  {
    return 0;
  }
}

uint64_t _s7CoreP2P15AWDLActionFrameV13DataPathStateV23__derived_struct_equalsySbAE_AEtFZ_0(unsigned __int16 *a1, unsigned __int16 *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  char v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  int8x16_t v24;
  uint64x2_t v25;
  int16x8_t v26;
  uint64x2_t v27;
  int64x2_t v28;
  int16x8_t v29;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  int8x16_t v37;
  uint64x2_t v38;
  int16x8_t v39;
  uint64x2_t v40;
  int64x2_t v41;
  int16x8_t v42;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  char v48;
  uint64_t result;
  unint64_t v50;
  unint64_t v51;
  int8x16_t v52;
  uint64x2_t v53;
  int16x8_t v54;
  uint64x2_t v55;
  int64x2_t v56;
  int16x8_t v57;
  uint64_t v59;
  uint64_t v60;
  char v61;
  char v62;
  uint64_t v63;
  unsigned int (*v64)(uint64_t, uint64_t, uint64_t);
  uint64_t v65;
  char v66;
  void (*v67)(char *, uint64_t);
  uint64_t v68;
  _DWORD *v69;
  char v70;
  _DWORD *v71;
  int v72;
  uint64_t v73;
  _DWORD *v74;
  char v75;
  _DWORD *v76;
  char v77;
  uint64_t v78;
  uint64_t v79;
  int *v80;
  _BYTE v81[6];
  _BYTE v82[6];

  v4 = type metadata accessor for DispatchTimeInterval(0);
  v5 = *(_QWORD *)(v4 - 8);
  __chkstk_darwin();
  v7 = (char *)&v78 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  v8 = sub_100012C44((uint64_t *)&unk_10040E1D0);
  __chkstk_darwin();
  v10 = (char *)&v78 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_100012C44(&qword_100407210);
  __chkstk_darwin();
  v12 = (char *)&v78 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin();
  v14 = (char *)&v78 - v13;
  __chkstk_darwin();
  v16 = (char *)&v78 - v15;
  v17 = *((_BYTE *)a2 + 2);
  if ((a1[1] & 1) != 0)
  {
    if (!*((_BYTE *)a2 + 2))
      return 0;
  }
  else
  {
    if (*a1 != *a2)
      v17 = 1;
    if ((v17 & 1) != 0)
      return 0;
  }
  v18 = *((unsigned int *)a1 + 1) | ((unint64_t)a1[4] << 32);
  v19 = *((unsigned int *)a2 + 1) | ((unint64_t)a2[4] << 32);
  v20 = v19 & 0xFF00000000;
  if ((v18 & 0xFF00000000) != 0x300000000)
  {
    if (v20 != 0x300000000
      && *((_DWORD *)a1 + 1) == *((_DWORD *)a2 + 1)
      && ((0x801004u >> ((v18 >> 29) & 0xF8)) & 0xFFC) == ((0x801004u >> ((v19 >> 29) & 0xF8)) & 0xFFC))
    {
      v21 = v19 >> 40;
      switch(v18 >> 40)
      {
        case 2uLL:
          if ((_DWORD)v21 != 2)
            return 0;
          goto LABEL_9;
        case 3uLL:
          if ((_DWORD)v21 != 3)
            return 0;
          goto LABEL_9;
        case 4uLL:
          if ((_DWORD)v21 != 4)
            return 0;
          goto LABEL_9;
        case 5uLL:
          if ((_DWORD)v21 != 5)
            return 0;
          goto LABEL_9;
        case 6uLL:
          if ((_DWORD)v21 != 6)
            return 0;
          goto LABEL_9;
        default:
          if ((v21 - 2) < 5 || ((v18 & 0x10000000000) == 0) == ((v19 >> 40) & 1))
            return 0;
          goto LABEL_9;
      }
    }
    return 0;
  }
  if (v20 != 0x300000000)
    return 0;
LABEL_9:
  if ((a1[8] & 1) != 0)
  {
    if (!*((_BYTE *)a2 + 16))
      return 0;
  }
  else
  {
    if ((a2[8] & 1) != 0)
      return 0;
    v22 = *(unsigned int *)(a1 + 5) | ((unint64_t)a1[7] << 32);
    v23 = *(unsigned int *)(a2 + 5) | ((unint64_t)a2[7] << 32);
    v24.i64[0] = 0xFFFFFFFFFFFFLL;
    v24.i64[1] = 0xFFFFFFFFFFFFLL;
    v25 = (uint64x2_t)vandq_s8((int8x16_t)vdupq_n_s64(v22), v24);
    v26 = (int16x8_t)vshlq_u64(v25, (uint64x2_t)xmmword_10033B100);
    v27 = (uint64x2_t)vandq_s8((int8x16_t)vdupq_n_s64(v23), v24);
    v28 = (int64x2_t)vshlq_u64(v27, (uint64x2_t)xmmword_10033B100);
    v29 = (int16x8_t)vshlq_u64(v27, (uint64x2_t)xmmword_10033B0F0);
    v82[0] = *(_DWORD *)(a1 + 5);
    *(int32x2_t *)v25.i8 = vmovn_s64((int64x2_t)vshlq_u64(v25, (uint64x2_t)xmmword_10033B0F0));
    *(int32x2_t *)v26.i8 = vmovn_s64((int64x2_t)v26);
    v26.i16[1] = v26.i16[2];
    v26.i16[2] = v25.i16[0];
    v26.i16[3] = v25.i16[2];
    *(_DWORD *)&v82[1] = vmovn_s16(v26).u32[0];
    v82[5] = BYTE5(v22);
    v81[0] = v23;
    *(int32x2_t *)v25.i8 = vmovn_s64((int64x2_t)v29);
    *(int32x2_t *)v29.i8 = vmovn_s64(v28);
    v29.i16[1] = v29.i16[2];
    v29.i16[2] = v25.i16[0];
    v29.i16[3] = v25.i16[2];
    *(_DWORD *)&v81[1] = vmovn_s16(v29).u32[0];
    v81[5] = BYTE5(v23);
    if (*(_DWORD *)v82 != *(_DWORD *)v81 || *(unsigned __int16 *)&v82[4] != *(unsigned __int16 *)&v81[4])
      return 0;
  }
  v31 = *((unsigned int *)a1 + 5) | ((unint64_t)a1[12] << 32);
  v32 = *((unsigned int *)a2 + 5) | ((unint64_t)a2[12] << 32);
  v33 = v32 & 0xFF00000000;
  if ((v31 & 0xFF00000000) != 0x300000000)
  {
    if (v33 != 0x300000000
      && *((_DWORD *)a1 + 5) == *((_DWORD *)a2 + 5)
      && ((0x801004u >> ((v31 >> 29) & 0xF8)) & 0xFFC) == ((0x801004u >> ((v32 >> 29) & 0xF8)) & 0xFFC))
    {
      v34 = v32 >> 40;
      switch(v31 >> 40)
      {
        case 2uLL:
          if ((_DWORD)v34 != 2)
            return 0;
          goto LABEL_26;
        case 3uLL:
          if ((_DWORD)v34 != 3)
            return 0;
          goto LABEL_26;
        case 4uLL:
          if ((_DWORD)v34 != 4)
            return 0;
          goto LABEL_26;
        case 5uLL:
          if ((_DWORD)v34 != 5)
            return 0;
          goto LABEL_26;
        case 6uLL:
          if ((_DWORD)v34 != 6)
            return 0;
          goto LABEL_26;
        default:
          if ((v34 - 2) < 5 || ((v31 & 0x10000000000) == 0) == ((v32 >> 40) & 1))
            return 0;
          goto LABEL_26;
      }
    }
    return 0;
  }
  if (v33 != 0x300000000)
    return 0;
LABEL_26:
  if ((a1[16] & 1) != 0)
  {
    if (!*((_BYTE *)a2 + 32))
      return 0;
  }
  else
  {
    if ((a2[16] & 1) != 0)
      return 0;
    v35 = *(unsigned int *)(a1 + 13) | ((unint64_t)a1[15] << 32);
    v36 = *(unsigned int *)(a2 + 13) | ((unint64_t)a2[15] << 32);
    v37.i64[0] = 0xFFFFFFFFFFFFLL;
    v37.i64[1] = 0xFFFFFFFFFFFFLL;
    v38 = (uint64x2_t)vandq_s8((int8x16_t)vdupq_n_s64(v35), v37);
    v39 = (int16x8_t)vshlq_u64(v38, (uint64x2_t)xmmword_10033B100);
    v40 = (uint64x2_t)vandq_s8((int8x16_t)vdupq_n_s64(v36), v37);
    v41 = (int64x2_t)vshlq_u64(v40, (uint64x2_t)xmmword_10033B100);
    v42 = (int16x8_t)vshlq_u64(v40, (uint64x2_t)xmmword_10033B0F0);
    v82[0] = *(_DWORD *)(a1 + 13);
    *(int32x2_t *)v38.i8 = vmovn_s64((int64x2_t)vshlq_u64(v38, (uint64x2_t)xmmword_10033B0F0));
    *(int32x2_t *)v39.i8 = vmovn_s64((int64x2_t)v39);
    v39.i16[1] = v39.i16[2];
    v39.i16[2] = v38.i16[0];
    v39.i16[3] = v38.i16[2];
    *(_DWORD *)&v82[1] = vmovn_s16(v39).u32[0];
    v82[5] = BYTE5(v35);
    v81[0] = v36;
    *(int32x2_t *)v38.i8 = vmovn_s64((int64x2_t)v42);
    *(int32x2_t *)v42.i8 = vmovn_s64(v41);
    v42.i16[1] = v42.i16[2];
    v42.i16[2] = v38.i16[0];
    v42.i16[3] = v38.i16[2];
    *(_DWORD *)&v81[1] = vmovn_s16(v42).u32[0];
    v81[5] = BYTE5(v36);
    if (*(_DWORD *)v82 != *(_DWORD *)v81 || *(unsigned __int16 *)&v82[4] != *(unsigned __int16 *)&v81[4])
      return 0;
  }
  v44 = *((_QWORD *)a1 + 6);
  v45 = *((_QWORD *)a2 + 6);
  if (!v44)
  {
    if (v45)
      return 0;
    goto LABEL_59;
  }
  if (!v45)
    return 0;
  v46 = *((_QWORD *)a1 + 5);
  v47 = *((_QWORD *)a2 + 5);
  if (v46 == v47 && v44 == v45
    || (v48 = _stringCompareWithSmolCheck(_:_:expecting:)(v46, v44, v47, v45, 0), result = 0, (v48 & 1) != 0))
  {
LABEL_59:
    if ((a1[31] & 1) != 0)
    {
      if (!*((_BYTE *)a2 + 62))
        return 0;
    }
    else
    {
      if ((a2[31] & 1) != 0)
        return 0;
      v50 = *((unsigned int *)a1 + 14) | ((unint64_t)a1[30] << 32);
      v51 = *((unsigned int *)a2 + 14) | ((unint64_t)a2[30] << 32);
      v52.i64[0] = 0xFFFFFFFFFFFFLL;
      v52.i64[1] = 0xFFFFFFFFFFFFLL;
      v53 = (uint64x2_t)vandq_s8((int8x16_t)vdupq_n_s64(v50), v52);
      v54 = (int16x8_t)vshlq_u64(v53, (uint64x2_t)xmmword_10033B100);
      v55 = (uint64x2_t)vandq_s8((int8x16_t)vdupq_n_s64(v51), v52);
      v56 = (int64x2_t)vshlq_u64(v55, (uint64x2_t)xmmword_10033B100);
      v57 = (int16x8_t)vshlq_u64(v55, (uint64x2_t)xmmword_10033B0F0);
      v82[0] = *((_DWORD *)a1 + 14);
      *(int32x2_t *)v53.i8 = vmovn_s64((int64x2_t)vshlq_u64(v53, (uint64x2_t)xmmword_10033B0F0));
      *(int32x2_t *)v54.i8 = vmovn_s64((int64x2_t)v54);
      v54.i16[1] = v54.i16[2];
      v54.i16[2] = v53.i16[0];
      v54.i16[3] = v53.i16[2];
      *(_DWORD *)&v82[1] = vmovn_s16(v54).u32[0];
      v82[5] = BYTE5(v50);
      v81[0] = v51;
      *(int32x2_t *)v53.i8 = vmovn_s64((int64x2_t)v57);
      *(int32x2_t *)v57.i8 = vmovn_s64(v56);
      v57.i16[1] = v57.i16[2];
      v57.i16[2] = v53.i16[0];
      v57.i16[3] = v53.i16[2];
      *(_DWORD *)&v81[1] = vmovn_s16(v57).u32[0];
      v81[5] = BYTE5(v51);
      if (*(_DWORD *)v82 != *(_DWORD *)v81 || *(unsigned __int16 *)&v82[4] != *(unsigned __int16 *)&v81[4])
        return 0;
    }
    if (*((unsigned __int8 *)a1 + 63) != *((unsigned __int8 *)a2 + 63))
      return 0;
    v59 = *((char *)a1 + 64);
    v60 = *((char *)a2 + 64);
    if (v59 == 43)
    {
      if ((_DWORD)v60 != 43)
        return 0;
    }
    else if ((_DWORD)v60 == 43 || dword_1003458A8[v59] != dword_1003458A8[v60])
    {
      return 0;
    }
    if (*((unsigned __int8 *)a1 + 65) != *((unsigned __int8 *)a2 + 65))
      return 0;
    v61 = *((_BYTE *)a2 + 68);
    if ((a1[34] & 1) != 0)
    {
      if (!*((_BYTE *)a2 + 68))
        return 0;
    }
    else
    {
      if (a1[33] != a2[33])
        v61 = 1;
      if ((v61 & 1) != 0)
        return 0;
    }
    v62 = *((_BYTE *)a2 + 76);
    if ((a1[38] & 1) != 0)
    {
      if (!*((_BYTE *)a2 + 76))
        return 0;
    }
    else
    {
      if (*((_DWORD *)a1 + 18) != *((_DWORD *)a2 + 18))
        v62 = 1;
      if ((v62 & 1) != 0)
        return 0;
    }
    if (*((unsigned __int8 *)a1 + 77) != *((unsigned __int8 *)a2 + 77)
      || *((unsigned __int8 *)a1 + 78) != *((unsigned __int8 *)a2 + 78)
      || *((unsigned __int8 *)a1 + 79) != *((unsigned __int8 *)a2 + 79)
      || *((unsigned __int8 *)a1 + 80) != *((unsigned __int8 *)a2 + 80)
      || *((unsigned __int8 *)a1 + 81) != *((unsigned __int8 *)a2 + 81)
      || *((unsigned __int8 *)a1 + 82) != *((unsigned __int8 *)a2 + 82)
      || *((unsigned __int8 *)a1 + 83) != *((unsigned __int8 *)a2 + 83)
      || *((unsigned __int8 *)a1 + 84) != *((unsigned __int8 *)a2 + 84)
      || *((unsigned __int8 *)a1 + 85) != *((unsigned __int8 *)a2 + 85)
      || *((unsigned __int8 *)a1 + 86) != *((unsigned __int8 *)a2 + 86)
      || *((unsigned __int8 *)a1 + 87) != *((unsigned __int8 *)a2 + 87)
      || *((unsigned __int8 *)a1 + 88) != *((unsigned __int8 *)a2 + 88)
      || *((unsigned __int8 *)a1 + 89) != *((unsigned __int8 *)a2 + 89)
      || *((unsigned __int8 *)a1 + 90) != *((unsigned __int8 *)a2 + 90)
      || *((unsigned __int8 *)a1 + 91) != *((unsigned __int8 *)a2 + 91)
      || *((unsigned __int8 *)a1 + 92) != *((unsigned __int8 *)a2 + 92)
      || *((unsigned __int8 *)a1 + 93) != *((unsigned __int8 *)a2 + 93)
      || *((unsigned __int8 *)a1 + 94) != *((unsigned __int8 *)a2 + 94))
    {
      return 0;
    }
    v80 = (int *)type metadata accessor for AWDLActionFrame.DataPathState(0);
    sub_1000E7054((uint64_t)a1 + v80[34], (uint64_t)v16);
    sub_1000E7054((uint64_t)a2 + v80[34], (uint64_t)v14);
    v63 = (uint64_t)&v10[*(int *)(v8 + 48)];
    sub_1000E7054((uint64_t)v16, (uint64_t)v10);
    v79 = v63;
    sub_1000E7054((uint64_t)v14, v63);
    v64 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v5 + 48);
    if (v64((uint64_t)v10, 1, v4) == 1)
    {
      sub_100033A84((uint64_t)v14, &qword_100407210);
      sub_100033A84((uint64_t)v16, &qword_100407210);
      if (v64(v79, 1, v4) == 1)
      {
        sub_100033A84((uint64_t)v10, &qword_100407210);
        goto LABEL_124;
      }
    }
    else
    {
      sub_1000E7054((uint64_t)v10, (uint64_t)v12);
      if (v64(v79, 1, v4) != 1)
      {
        (*(void (**)(char *, uint64_t, uint64_t))(v5 + 32))(v7, v79, v4);
        v65 = sub_100011DE4(&qword_10040E1E0, (uint64_t (*)(uint64_t))&type metadata accessor for DispatchTimeInterval, (uint64_t)&protocol conformance descriptor for DispatchTimeInterval);
        v66 = dispatch thunk of static Equatable.== infix(_:_:)(v12, v7, v4, v65);
        v67 = *(void (**)(char *, uint64_t))(v5 + 8);
        v67(v7, v4);
        sub_100033A84((uint64_t)v14, &qword_100407210);
        sub_100033A84((uint64_t)v16, &qword_100407210);
        v67(v12, v4);
        sub_100033A84((uint64_t)v10, &qword_100407210);
        if ((v66 & 1) == 0)
          return 0;
LABEL_124:
        v68 = v80[35];
        v69 = (_DWORD *)((char *)a1 + v68);
        v70 = *((_BYTE *)a1 + v68 + 4);
        v71 = (_DWORD *)((char *)a2 + v68);
        v72 = *((unsigned __int8 *)a2 + v68 + 4);
        if ((v70 & 1) != 0)
        {
          if (!v72)
            return 0;
        }
        else
        {
          if (*v69 != *v71)
            LOBYTE(v72) = 1;
          if ((v72 & 1) != 0)
            return 0;
        }
        v73 = v80[36];
        v74 = (_DWORD *)((char *)a1 + v73);
        v75 = *((_BYTE *)a1 + v73 + 4);
        v76 = (_DWORD *)((char *)a2 + v73);
        v77 = *((_BYTE *)a2 + v73 + 4);
        if ((v75 & 1) != 0)
        {
          if ((v77 & 1) == 0)
            return 0;
        }
        else
        {
          if (*v74 != *v76)
            v77 = 1;
          if ((v77 & 1) != 0)
            return 0;
        }
        return 1;
      }
      sub_100033A84((uint64_t)v14, &qword_100407210);
      sub_100033A84((uint64_t)v16, &qword_100407210);
      (*(void (**)(char *, uint64_t))(v5 + 8))(v12, v4);
    }
    sub_100033A84((uint64_t)v10, (uint64_t *)&unk_10040E1D0);
    return 0;
  }
  return result;
}

void _s7CoreP2P15AWDLActionFrameV13AWDLAttributeO21__derived_enum_equalsySbAE_AEtFZ_0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  _QWORD v24[17];
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v27 = a2;
  v26 = a1;
  type metadata accessor for AWDLActionFrame.DataPathState(0);
  __chkstk_darwin();
  v24[2] = (char *)v24 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0);
  type metadata accessor for AWDLActionFrame.ServiceResponse(0);
  __chkstk_darwin();
  v24[1] = (char *)v24 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v25 = type metadata accessor for AWDLActionFrame.AWDLAttribute(0);
  __chkstk_darwin();
  v24[16] = (char *)v24 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin();
  v24[15] = (char *)v24 - v5;
  __chkstk_darwin();
  v24[14] = (char *)v24 - v6;
  __chkstk_darwin();
  v24[12] = (char *)v24 - v7;
  __chkstk_darwin();
  v24[13] = (char *)v24 - v8;
  __chkstk_darwin();
  v24[11] = (char *)v24 - v9;
  __chkstk_darwin();
  v24[10] = (char *)v24 - v10;
  __chkstk_darwin();
  v24[9] = (char *)v24 - v11;
  __chkstk_darwin();
  v24[8] = (char *)v24 - v12;
  __chkstk_darwin();
  v24[6] = (char *)v24 - v13;
  __chkstk_darwin();
  v24[7] = (char *)v24 - v14;
  __chkstk_darwin();
  v24[5] = (char *)v24 - v15;
  __chkstk_darwin();
  __chkstk_darwin();
  v24[3] = (char *)v24 - v16;
  __chkstk_darwin();
  v24[4] = (char *)v24 - v17;
  __chkstk_darwin();
  __chkstk_darwin();
  __chkstk_darwin();
  __chkstk_darwin();
  __chkstk_darwin();
  __chkstk_darwin();
  sub_100012C44(&qword_100407A98);
  v18 = __chkstk_darwin();
  v20 = (char *)v24 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  v21 = (uint64_t)&v20[*(int *)(v18 + 48)];
  sub_1000637E0(v26, (uint64_t)v20, type metadata accessor for AWDLActionFrame.AWDLAttribute);
  v22 = v27;
  v27 = v21;
  sub_1000637E0(v22, v21, type metadata accessor for AWDLActionFrame.AWDLAttribute);
  v23 = (char *)sub_1000E31A4 + 4 * word_100341450[swift_getEnumCaseMultiPayload(v20, v25)];
  __asm { BR              X10 }
}

uint64_t sub_1000E31A4()
{
  unsigned __int16 *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  unsigned __int16 *v6;
  uint64_t v7;
  char v8;
  char v10;

  sub_1000637E0(v2, (uint64_t)v0, type metadata accessor for AWDLActionFrame.AWDLAttribute);
  v4 = v0[1];
  v5 = *((_QWORD *)v0 + 1);
  v6 = *(unsigned __int16 **)(v3 - 264);
  if (swift_getEnumCaseMultiPayload(v6, v1))
  {
    swift_bridgeObjectRelease(v5);
    sub_100033A84(v2, &qword_100407A98);
  }
  else
  {
    v7 = *((_QWORD *)v6 + 1);
    if (*v0 == *v6 && v4 == v6[1])
    {
      v10 = sub_1000851D0(v5, *((_QWORD *)v6 + 1));
      swift_bridgeObjectRelease(v7);
      swift_bridgeObjectRelease(v5);
      if ((v10 & 1) != 0)
      {
        sub_100063824(v2, type metadata accessor for AWDLActionFrame.AWDLAttribute);
        v8 = 1;
        return v8 & 1;
      }
    }
    else
    {
      swift_bridgeObjectRelease(*((_QWORD *)v6 + 1));
      swift_bridgeObjectRelease(v5);
    }
    sub_100063824(v2, type metadata accessor for AWDLActionFrame.AWDLAttribute);
  }
  v8 = 0;
  return v8 & 1;
}

unint64_t sub_1000E3DA0(char a1, unsigned __int8 a2)
{
  uint64_t v2;
  unsigned __int8 v4;
  unint64_t result;
  int v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  unsigned __int8 v19;
  int v20;
  int v21;

  if (a1)
  {
    if (a1 != 1)
    {
LABEL_7:
      v7 = sub_100012C84();
      v8 = swift_allocError(&type metadata for WiFiError, v7, 0, 0);
      *(_OWORD *)v9 = xmmword_100337850;
      *(_BYTE *)(v9 + 16) = 2;
      return swift_willThrow(v8);
    }
    v4 = 1;
  }
  else
  {
    v4 = 2;
  }
  result = sub_1001AA370(v4, 4uLL, 4);
  if (v2)
    return result;
  v6 = result;
  if (a2 - 4 < 3)
    goto LABEL_7;
  if (a2 == 2)
  {
    v10 = 1;
    goto LABEL_13;
  }
  if (a2 == 3)
  {
    v10 = 2;
LABEL_13:
    v11 = sub_1001AA370(v10, 2uLL, 2);
    v12 = sub_1001AA370(3u, 0, 2);
    if ((v11 & ~(_BYTE)v6) != 0)
      v13 = v11;
    else
      v13 = 0;
    v14 = v13 | v6;
    if ((v12 & ~(_BYTE)v14) != 0)
      v15 = v12;
    else
      v15 = 0;
    return v15 | v14;
  }
  v16 = sub_1001AA370(3u, 2uLL, 2);
  if ((v16 & ~(_BYTE)v6) != 0)
    v17 = v16;
  else
    v17 = 0;
  v18 = v17 | v6;
  if ((a2 & 1) != 0)
    v19 = 2;
  else
    v19 = 1;
  v20 = sub_1001AA370(v19, 0, 2);
  if ((v20 & ~(_BYTE)v18) != 0)
    v21 = v20;
  else
    v21 = 0;
  return v21 | v18;
}

uint64_t _s7CoreP2P15AWDLActionFrameV13AWDLAttributeO13AttributeTypeO8rawValueAGSgs5UInt8V_tcfC_0(unsigned __int8 a1)
{
  if (a1 > 0x23u)
    return 23;
  else
    return byte_100345954[(char)a1];
}

uint64_t _s7CoreP2P15AWDLActionFrameV13DataPathStateV30UnicastMasterIndicationOptionsO8rawValueAGSgs6UInt32V_tcfC_0(int a1)
{
  uint64_t result;

  if (a1 >= 0x200000)
  {
    if (a1 > 150994943)
    {
      if (a1 <= 234881023)
      {
        if (a1 <= 184549375)
        {
          if (a1 == 150994944)
            return 35;
          if (a1 == 167772160)
            return 36;
        }
        else
        {
          switch(a1)
          {
            case 184549376:
              return 37;
            case 201326592:
              return 38;
            case 218103808:
              return 39;
          }
        }
      }
      else if (a1 > 301989887)
      {
        switch(a1)
        {
          case 0x12000000:
            return 42;
          case 0x20000000:
            return 27;
          case 0x40000000:
            return 33;
        }
      }
      else
      {
        switch(a1)
        {
          case 234881024:
            return 40;
          case 268435456:
            return 26;
          case 285212672:
            return 41;
        }
      }
    }
    else if (a1 <= 50331647)
    {
      if (a1 < 0x800000)
      {
        if (a1 == 0x200000)
          return 19;
        if (a1 == 0x400000)
          return 20;
      }
      else
      {
        switch(a1)
        {
          case 0x800000:
            return 21;
          case 0x1000000:
            return 22;
          case 0x2000000:
            return 23;
        }
      }
    }
    else if (a1 > 83886079)
    {
      switch(a1)
      {
        case 0x5000000:
          return 31;
        case 0x6000000:
          return 32;
        case 0x8000000:
          return 3;
      }
    }
    else
    {
      switch(a1)
      {
        case 50331648:
          return 30;
        case 67108864:
          return 2;
        case 67108866:
          return 4;
      }
    }
    return 43;
  }
  if (a1 > 1023)
  {
    if (a1 < 0x8000)
    {
      if (a1 <= 4095)
      {
        if (a1 == 1024)
          return 28;
        if (a1 == 2048)
          return 29;
      }
      else
      {
        switch(a1)
        {
          case 0x1000:
            return 25;
          case 0x2000:
            return 13;
          case 0x4000:
            return 15;
        }
      }
    }
    else if (a1 >= 0x40000)
    {
      switch(a1)
      {
        case 0x40000:
          return 18;
        case 0x80000:
          return 1;
        case 0x100000:
          return 14;
      }
    }
    else
    {
      switch(a1)
      {
        case 0x8000:
          return 16;
        case 0x10000:
          return 5;
        case 0x20000:
          return 17;
      }
    }
    return 43;
  }
  if (a1 > 63)
  {
    if (a1 > 255)
    {
      if (a1 == 256)
        return 12;
      if (a1 == 512)
        return 24;
    }
    else
    {
      if (a1 == 64)
        return 10;
      if (a1 == 128)
        return 11;
    }
    return 43;
  }
  switch(a1)
  {
    case 2:
      result = 0;
      break;
    case 3:
    case 5:
    case 6:
    case 7:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
      return 43;
    case 4:
      result = 6;
      break;
    case 8:
      result = 7;
      break;
    case 16:
      result = 8;
      break;
    case 32:
      result = 9;
      break;
    default:
      if (a1 != 0x80000000)
        return 43;
      result = 34;
      break;
  }
  return result;
}

uint64_t _s7CoreP2P15AWDLActionFrameV20MultiPeerBSSSteeringV17SteeringMessageIDO8rawValueAGSgs5UInt8V_tcfC_0(uint64_t result)
{
  if (result >= 7u)
    return 7;
  else
    return result;
}

uint64_t _s7CoreP2P19NANIntervalDurationO8rawValueACSgs5UInt8V_tcfC_0(uint64_t result)
{
  if ((result & 0xFC) != 0)
    return 4;
  else
    return result;
}

uint64_t _s7CoreP2P15AWDLActionFrameV7VersionV12PlatformTypeO8rawValueAGSgs5UInt8V_tcfC_0(unsigned __int8 a1)
{
  int v1;
  uint64_t result;

  v1 = a1 - 1;
  result = 1;
  switch(v1)
  {
    case 0:
      result = 0;
      break;
    case 1:
      return result;
    case 3:
      result = 2;
      break;
    case 7:
      result = 3;
      break;
    case 15:
      result = 4;
      break;
    default:
      result = 5;
      break;
  }
  return result;
}

_QWORD *sub_1000E4354(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;
  _QWORD *v16;

  v3 = sub_100012C44(&qword_100407B38);
  v4 = *(_QWORD *)(v3 - 8);
  __chkstk_darwin();
  v6 = (char *)&v15 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = a1[3];
  v8 = a1[4];
  v9 = sub_10003259C(a1, v7);
  v10 = sub_1000E7238();
  dispatch thunk of Decoder.container<A>(keyedBy:)(&type metadata for AWDLActionFrame.SyncTreePath.CodingKeys, &type metadata for AWDLActionFrame.SyncTreePath.CodingKeys, v10, v7, v8);
  if (v1)
  {
    sub_100014430(a1);
  }
  else
  {
    v11 = sub_100012C44(&qword_100407250);
    v12 = sub_1000F093C(&qword_100407B40, (uint64_t (*)(void))sub_10003A65C, (const char *)&protocol conformance descriptor for <A> [A]);
    KeyedDecodingContainer.decode<A>(_:forKey:)(&v16, v11, v13, v3, v11, v12);
    (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
    v9 = v16;
    sub_100014430(a1);
  }
  return v9;
}

uint64_t sub_1000E4498(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unsigned __int16 v10;
  unsigned __int16 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  char v18;
  char v19;

  v3 = sub_100012C44(&qword_100407BB0);
  v4 = *(_QWORD *)(v3 - 8);
  __chkstk_darwin();
  v6 = (char *)&v15 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = a1[3];
  v8 = a1[4];
  sub_10003259C(a1, v7);
  v9 = sub_1000CC874();
  dispatch thunk of Decoder.container<A>(keyedBy:)(&type metadata for AWDLActionFrame.ServiceRequest.CodingKeys, &type metadata for AWDLActionFrame.ServiceRequest.CodingKeys, v9, v7, v8);
  if (v1)
  {
    sub_100014430(a1);
  }
  else
  {
    v19 = 0;
    v10 = KeyedDecodingContainer.decode(_:forKey:)(&v19, v3);
    v18 = 1;
    v12 = KeyedDecodingContainer.decode(_:forKey:)(&v18, v3);
    v13 = sub_100012C44(&qword_100406738);
    v16 = 2;
    v14 = sub_1000F08DC(&qword_100407B28, (uint64_t)&protocol witness table for UInt8, (const char *)&protocol conformance descriptor for <A> [A]);
    KeyedDecodingContainer.decode<A>(_:forKey:)(&v17, v13, &v16, v3, v13, v14);
    (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
    sub_100014430(a1);
    return v10 | (v12 << 16);
  }
  return v7;
}

uint64_t type metadata accessor for AWDLActionFrame.ServiceResponse(uint64_t a1)
{
  return sub_10000D69C(a1, qword_1004075F0, (uint64_t)&nominal type descriptor for AWDLActionFrame.ServiceResponse);
}

uint64_t sub_1000E4660@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint8x8_t v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int8 *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  __int16 v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t result;
  int16x8_t v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  char v39;

  v6 = sub_100012C44(&qword_100407B70);
  v7 = *(_QWORD *)(v6 - 8);
  __chkstk_darwin();
  v9 = &v19.i8[-((v8 + 15) & 0xFFFFFFFFFFFFFFF0)];
  v10 = a1[3];
  v11 = a1[4];
  sub_10003259C(a1, v10);
  v12 = sub_1000F0AB4();
  dispatch thunk of Decoder.container<A>(keyedBy:)(&type metadata for AWDLActionFrame.SynchronizationParameter.CodingKeys, &type metadata for AWDLActionFrame.SynchronizationParameter.CodingKeys, v12, v10, v11);
  if (v2)
    return sub_100014430(a1);
  LOBYTE(v38) = 0;
  v13 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38) = 1;
  v14 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38) = 2;
  v37 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38) = 3;
  v36 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38) = 4;
  v35 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38) = 5;
  v34 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38) = 6;
  v33 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38) = 7;
  v32 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38) = 8;
  v31 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38) = 9;
  v30 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38) = 10;
  v29 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38) = 11;
  v28 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38) = 12;
  v27 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38) = 13;
  v26 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  v39 = 14;
  v15 = sub_10003A65C();
  KeyedDecodingContainer.decode<A>(_:forKey:)(&v38, &type metadata for WiFiAddress, &v39, v6, &type metadata for WiFiAddress, v15);
  v3.i32[0] = v38;
  v24 = BYTE5(v38);
  v25 = BYTE4(v38);
  LOBYTE(v38) = 15;
  v23 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38) = 16;
  v22 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38) = 17;
  v21 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  LOBYTE(v38) = 18;
  v20 = KeyedDecodingContainer.decode(_:forKey:)(&v38, v6);
  v39 = 19;
  v16 = sub_1000F0AF8();
  KeyedDecodingContainer.decode<A>(_:forKey:)(&v38, &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter, &v39, v6, &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter, v16);
  (*(void (**)(__int8 *, uint64_t))(v7 + 8))(v9, v6);
  v19 = (int16x8_t)vmovl_u8(v3);
  v17 = v38;
  result = sub_100014430(a1);
  *(_BYTE *)a2 = v13;
  *(_WORD *)(a2 + 2) = v14;
  *(_BYTE *)(a2 + 4) = v37;
  *(_BYTE *)(a2 + 5) = v36;
  *(_WORD *)(a2 + 6) = v35;
  *(_WORD *)(a2 + 8) = v34;
  *(_WORD *)(a2 + 10) = v33;
  *(_WORD *)(a2 + 12) = v32;
  *(_WORD *)(a2 + 14) = v31;
  *(_WORD *)(a2 + 16) = v30;
  *(_BYTE *)(a2 + 18) = v29;
  *(_BYTE *)(a2 + 19) = v28;
  *(_BYTE *)(a2 + 20) = v27;
  *(_BYTE *)(a2 + 21) = v26;
  *(_DWORD *)(a2 + 22) = vmovn_s16(v19).u32[0];
  *(_BYTE *)(a2 + 26) = v25;
  *(_BYTE *)(a2 + 27) = v24;
  *(_BYTE *)(a2 + 28) = v23;
  *(_BYTE *)(a2 + 29) = v22;
  *(_WORD *)(a2 + 30) = v21;
  *(_WORD *)(a2 + 32) = v20;
  *(_QWORD *)(a2 + 40) = v17;
  return result;
}

unint64_t sub_1000E4B74(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unsigned __int8 v10;
  unsigned __int16 v11;
  unsigned __int8 v12;
  unint64_t v13;
  _DWORD v15[2];
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  int v21;
  char v22[8];
  uint64_t v23;

  v3 = sub_100012C44(&qword_100407B60);
  v4 = *(_QWORD *)(v3 - 8);
  __chkstk_darwin();
  v6 = (char *)v15 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = a1[3];
  v8 = a1[4];
  sub_10003259C(a1, v7);
  v9 = sub_1000F0A70();
  dispatch thunk of Decoder.container<A>(keyedBy:)(&type metadata for AWDLActionFrame.DeprecatedElectionParameter.CodingKeys, &type metadata for AWDLActionFrame.DeprecatedElectionParameter.CodingKeys, v9, v7, v8);
  if (v1)
    return sub_100014430(a1);
  LOBYTE(v23) = 0;
  v10 = KeyedDecodingContainer.decode(_:forKey:)(&v23, v3);
  LOBYTE(v23) = 1;
  v11 = KeyedDecodingContainer.decode(_:forKey:)(&v23, v3);
  LOBYTE(v23) = 2;
  v12 = KeyedDecodingContainer.decode(_:forKey:)(&v23, v3);
  LOBYTE(v23) = 3;
  v21 = KeyedDecodingContainer.decode(_:forKey:)(&v23, v3);
  v22[0] = 4;
  v13 = sub_10003A65C();
  KeyedDecodingContainer.decode<A>(_:forKey:)(&v23, &type metadata for WiFiAddress, v22, v3, &type metadata for WiFiAddress, v13);
  v19 = v23;
  v18 = BYTE1(v23);
  v17 = *(unsigned int *)((char *)&v23 + 2);
  v22[0] = 5;
  v20 = sub_1000F0810();
  KeyedDecodingContainer.decode<A>(_:forKey:)(&v23, &type metadata for AWDLElectionMetric, v22, v3, &type metadata for AWDLElectionMetric, v20);
  v16 = v23;
  v15[1] = BYTE4(v23);
  v22[0] = 6;
  KeyedDecodingContainer.decode<A>(_:forKey:)(&v23, &type metadata for AWDLElectionMetric, v22, v3, &type metadata for AWDLElectionMetric, v20);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  sub_100014430(a1);
  return v10 | ((unint64_t)v11 << 16) | ((unint64_t)v12 << 32) | ((unint64_t)v21 << 40) | (v19 << 48) | (v18 << 56);
}

uint64_t sub_1000E4E40(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  int v11;
  int v12;
  uint64_t v14;
  char v15;
  char v16;
  uint64_t v17;

  v3 = sub_100012C44(&qword_100407B30);
  v4 = *(_QWORD *)(v3 - 8);
  __chkstk_darwin();
  v6 = (char *)&v14 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = a1[3];
  v8 = a1[4];
  sub_10003259C(a1, v7);
  v9 = sub_1000E72C0();
  dispatch thunk of Decoder.container<A>(keyedBy:)(&type metadata for AWDLActionFrame.Version.CodingKeys, &type metadata for AWDLActionFrame.Version.CodingKeys, v9, v7, v8);
  if (v1)
    return sub_100014430(a1);
  v16 = 0;
  v10 = sub_1000F05F0();
  KeyedDecodingContainer.decode<A>(_:forKey:)(&v17, &type metadata for AWDLActionFrame.AWDLVersion, &v16, v3, &type metadata for AWDLActionFrame.AWDLVersion, v10);
  v11 = v17;
  v15 = 1;
  v12 = KeyedDecodingContainer.decode(_:forKey:)(&v15, v3);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  sub_100014430(a1);
  return v11 | (v12 << 8);
}

uint64_t sub_1000E4FA4(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unsigned __int8 v10;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  char v18;
  char v19;

  v3 = sub_100012C44(&qword_100407B20);
  v4 = *(_QWORD *)(v3 - 8);
  __chkstk_darwin();
  v6 = (char *)&v15 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = a1[3];
  v8 = a1[4];
  sub_10003259C(a1, v7);
  v9 = sub_1000E7348();
  dispatch thunk of Decoder.container<A>(keyedBy:)(&type metadata for AWDLActionFrame.PeerMACAddressListBloomFilter.CodingKeys, &type metadata for AWDLActionFrame.PeerMACAddressListBloomFilter.CodingKeys, v9, v7, v8);
  if (v1)
  {
    sub_100014430(a1);
  }
  else
  {
    v19 = 0;
    v10 = KeyedDecodingContainer.decode(_:forKey:)(&v19, v3);
    v18 = 1;
    v12 = KeyedDecodingContainer.decode(_:forKey:)(&v18, v3);
    v13 = sub_100012C44(&qword_100406738);
    v16 = 2;
    v14 = sub_1000F08DC(&qword_100407B28, (uint64_t)&protocol witness table for UInt8, (const char *)&protocol conformance descriptor for <A> [A]);
    KeyedDecodingContainer.decode<A>(_:forKey:)(&v17, v13, &v16, v3, v13, v14);
    (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
    sub_100014430(a1);
    return v10 | (v12 << 8);
  }
  return v7;
}

uint64_t sub_1000E5158@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint8x8_t v3;
  uint8x8_t v4;
  uint8x8_t v5;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int8 *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  unint64_t v16;
  int v17;
  int v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  int v22;
  uint64_t result;
  int16x8_t v24;
  int16x8_t v25;
  int16x8_t v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  uint64_t v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  uint64_t v39;
  char v40;

  v8 = sub_100012C44(&qword_100407B08);
  v9 = *(_QWORD *)(v8 - 8);
  __chkstk_darwin();
  v11 = &v24.i8[-((v10 + 15) & 0xFFFFFFFFFFFFFFF0)];
  v12 = a1[3];
  v13 = a1[4];
  sub_10003259C(a1, v12);
  v14 = sub_1000E738C();
  dispatch thunk of Decoder.container<A>(keyedBy:)(&type metadata for AWDLActionFrame.NANSynchronization.CodingKeys, &type metadata for AWDLActionFrame.NANSynchronization.CodingKeys, v14, v12, v13);
  if (v2)
    return sub_100014430(a1);
  LOBYTE(v39) = 0;
  v15 = KeyedDecodingContainer.decode(_:forKey:)(&v39, v8);
  v40 = 1;
  v16 = sub_10003A65C();
  KeyedDecodingContainer.decode<A>(_:forKey:)(&v39, &type metadata for WiFiAddress, &v40, v8, &type metadata for WiFiAddress, v16);
  v3.i32[0] = v39;
  v37 = v15;
  v38 = BYTE4(v39);
  v17 = BYTE5(v39);
  v40 = 2;
  KeyedDecodingContainer.decode<A>(_:forKey:)(&v39, &type metadata for WiFiAddress, &v40, v8, &type metadata for WiFiAddress, v16);
  v4.i32[0] = v39;
  v35 = BYTE4(v39);
  v36 = v17;
  v18 = BYTE5(v39);
  v40 = 3;
  v19 = sub_1000F0854();
  KeyedDecodingContainer.decode<A>(_:forKey:)(&v39, &type metadata for NANTimeSynchronizationFunction, &v40, v8, &type metadata for NANTimeSynchronizationFunction, v19);
  v34 = v18;
  v20 = v39;
  v40 = 4;
  v21 = sub_1000F0898();
  KeyedDecodingContainer.decode<A>(_:forKey:)(&v39, &type metadata for NANAttribute.MasterIndication, &v40, v8, &type metadata for NANAttribute.MasterIndication, v21);
  v32 = v20;
  v33 = v39;
  LODWORD(v20) = BYTE1(v39);
  v40 = 5;
  KeyedDecodingContainer.decode<A>(_:forKey:)(&v39, &type metadata for WiFiAddress, &v40, v8, &type metadata for WiFiAddress, v16);
  v31 = v20;
  v5.i32[0] = v39;
  LODWORD(v16) = BYTE4(v39);
  LODWORD(v20) = BYTE5(v39);
  LOBYTE(v39) = 6;
  v28 = KeyedDecodingContainer.decode(_:forKey:)(&v39, v8);
  v29 = v16;
  v30 = v20;
  LOBYTE(v39) = 7;
  v27 = KeyedDecodingContainer.decode(_:forKey:)(&v39, v8);
  LOBYTE(v39) = 8;
  LOWORD(v20) = KeyedDecodingContainer.decode(_:forKey:)(&v39, v8);
  LOBYTE(v39) = 9;
  v22 = KeyedDecodingContainer.decode(_:forKey:)(&v39, v8);
  (*(void (**)(__int8 *, uint64_t))(v9 + 8))(v11, v8);
  v24 = (int16x8_t)vmovl_u8(v3);
  v25 = (int16x8_t)vmovl_u8(v4);
  v26 = (int16x8_t)vmovl_u8(v5);
  result = sub_100014430(a1);
  *(_WORD *)a2 = v37;
  *(_DWORD *)(a2 + 2) = vmovn_s16(v24).u32[0];
  *(_BYTE *)(a2 + 6) = v38;
  *(_BYTE *)(a2 + 7) = v36;
  *(_DWORD *)(a2 + 8) = vmovn_s16(v25).u32[0];
  *(_BYTE *)(a2 + 12) = v35;
  *(_BYTE *)(a2 + 13) = v34;
  *(_QWORD *)(a2 + 16) = v32;
  *(_BYTE *)(a2 + 24) = v33;
  *(_BYTE *)(a2 + 25) = v31;
  *(_DWORD *)(a2 + 26) = vmovn_s16(v26).u32[0];
  *(_BYTE *)(a2 + 30) = v29;
  *(_BYTE *)(a2 + 31) = v30;
  *(_BYTE *)(a2 + 32) = v28;
  *(_BYTE *)(a2 + 33) = v27;
  *(_WORD *)(a2 + 34) = v20;
  *(_DWORD *)(a2 + 36) = v22;
  return result;
}

uint64_t sub_1000E5544@<X0>(_QWORD *a1@<X0>, _DWORD *a2@<X8>)
{
  uint64_t v2;
  uint8x8_t v3;
  uint8x8_t v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int8 *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  int v15;
  int v16;
  unint64_t v17;
  int v18;
  uint64_t result;
  _DWORD *v20;
  int v21;
  int16x8_t v22;
  int16x8_t v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  _DWORD *v33;
  uint64_t v34;

  v7 = sub_100012C44(&qword_100407AF8);
  v8 = *(_QWORD *)(v7 - 8);
  __chkstk_darwin();
  v10 = &v22.i8[-((v9 + 15) & 0xFFFFFFFFFFFFFFF0)];
  v11 = a1[3];
  v12 = a1[4];
  sub_10003259C(a1, v11);
  v13 = sub_1000E7494();
  dispatch thunk of Decoder.container<A>(keyedBy:)(&type metadata for AWDLActionFrame.ElectionParameter.CodingKeys, &type metadata for AWDLActionFrame.ElectionParameter.CodingKeys, v13, v11, v12);
  if (v2)
    return sub_100014430(a1);
  HIBYTE(v34) = 0;
  v14 = sub_10003A65C();
  KeyedDecodingContainer.decode<A>(_:forKey:)(&v34, &type metadata for WiFiAddress, (char *)&v34 + 7, v7, &type metadata for WiFiAddress, v14);
  v33 = a2;
  v3.i32[0] = v34;
  v15 = BYTE4(v34);
  v16 = BYTE5(v34);
  HIBYTE(v34) = 1;
  KeyedDecodingContainer.decode<A>(_:forKey:)(&v34, &type metadata for WiFiAddress, (char *)&v34 + 7, v7, &type metadata for WiFiAddress, v14);
  v31 = v15;
  v32 = v16;
  v4.i32[0] = v34;
  LOBYTE(v15) = BYTE4(v34);
  LOBYTE(v16) = BYTE5(v34);
  LOBYTE(v34) = 2;
  LODWORD(v14) = KeyedDecodingContainer.decode(_:forKey:)(&v34, v7);
  LOBYTE(v34) = 3;
  v29 = KeyedDecodingContainer.decode(_:forKey:)(&v34, v7);
  v30 = v14;
  HIBYTE(v34) = 4;
  v17 = sub_1000F0810();
  KeyedDecodingContainer.decode<A>(_:forKey:)(&v34, &type metadata for AWDLElectionMetric, (char *)&v34 + 7, v7, &type metadata for AWDLElectionMetric, v17);
  v27 = v34;
  v28 = BYTE4(v34);
  HIBYTE(v34) = 5;
  KeyedDecodingContainer.decode<A>(_:forKey:)(&v34, &type metadata for AWDLElectionMetric, (char *)&v34 + 7, v7, &type metadata for AWDLElectionMetric, v17);
  v26 = v34;
  LODWORD(v17) = BYTE4(v34);
  LOBYTE(v34) = 6;
  v24 = KeyedDecodingContainer.decode(_:forKey:)(&v34, v7);
  v25 = v17;
  LOBYTE(v34) = 7;
  LODWORD(v17) = KeyedDecodingContainer.decode(_:forKey:)(&v34, v7);
  LOBYTE(v34) = 8;
  v18 = KeyedDecodingContainer.decode(_:forKey:)(&v34, v7);
  (*(void (**)(__int8 *, uint64_t))(v8 + 8))(v10, v7);
  v22 = (int16x8_t)vmovl_u8(v3);
  v23 = (int16x8_t)vmovl_u8(v4);
  result = sub_100014430(a1);
  v20 = v33;
  *v33 = vmovn_s16(v22).u32[0];
  *((_BYTE *)v20 + 4) = v31;
  *((_BYTE *)v20 + 5) = v32;
  *(_DWORD *)((char *)v20 + 6) = vmovn_s16(v23).u32[0];
  *((_BYTE *)v20 + 10) = v15;
  *((_BYTE *)v20 + 11) = v16;
  v21 = v29;
  v20[3] = v30;
  v20[4] = v21;
  v20[5] = v27;
  *((_BYTE *)v20 + 24) = v28;
  v20[7] = v26;
  *((_BYTE *)v20 + 32) = v25;
  v20[9] = v24;
  v20[10] = v17;
  v20[11] = v18;
  return result;
}

unint64_t sub_1000E58B4(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v14;
  uint64_t v15;

  v3 = sub_100012C44(&qword_100407AE8);
  v4 = *(_QWORD *)(v3 - 8);
  __chkstk_darwin();
  v6 = (char *)&v14 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = a1[3];
  v8 = a1[4];
  v9 = (unint64_t)sub_10003259C(a1, v7);
  v10 = sub_1000E74D8();
  dispatch thunk of Decoder.container<A>(keyedBy:)(&type metadata for AWDLActionFrame.MultiPeerBSSSteering.CodingKeys, &type metadata for AWDLActionFrame.MultiPeerBSSSteering.CodingKeys, v10, v7, v8);
  if (v1)
  {
    sub_100014430(a1);
  }
  else
  {
    v11 = sub_1000F07CC();
    KeyedDecodingContainer.decode<A>(_:forKey:)(&v15, &type metadata for AWDLActionFrame.MultiPeerBSSSteering.SteeringMessageID, v12, v3, &type metadata for AWDLActionFrame.MultiPeerBSSSteering.SteeringMessageID, v11);
    (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
    v9 = v15;
    sub_100014430(a1);
  }
  return v9;
}

uint64_t sub_1000E59D4(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unsigned __int8 v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;
  char v17;
  uint64_t v18;

  v3 = sub_100012C44(&qword_100407AE0);
  v4 = *(_QWORD *)(v3 - 8);
  __chkstk_darwin();
  v6 = (char *)&v16 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = a1[3];
  v8 = a1[4];
  sub_10003259C(a1, v7);
  v9 = sub_1000E7560();
  dispatch thunk of Decoder.container<A>(keyedBy:)(&type metadata for AWDLActionFrame.Ranging.CodingKeys, &type metadata for AWDLActionFrame.Ranging.CodingKeys, v9, v7, v8);
  if (v1)
    return sub_100014430(a1);
  BYTE6(v18) = 0;
  v10 = KeyedDecodingContainer.decode(_:forKey:)((char *)&v18 + 6, v3);
  v17 = 1;
  v11 = sub_10003A65C();
  KeyedDecodingContainer.decode<A>(_:forKey:)(&v18, &type metadata for WiFiAddress, &v17, v3, &type metadata for WiFiAddress, v11);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  v12 = v18;
  v13 = BYTE1(v18);
  v14 = *(unsigned int *)((char *)&v18 + 2);
  sub_100014430(a1);
  return v10 | (unint64_t)(v12 << 8) | (v13 << 16) | (v14 << 24);
}

uint64_t sub_1000E5B4C(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int16 v19;
  _QWORD v21[3];
  uint64_t v22;
  uint64_t v23;

  v3 = a1[3];
  v4 = a1[4];
  sub_10003259C(a1, v3);
  dispatch thunk of Decoder.unkeyedContainer()(v21, v3, v4);
  if (!v1)
  {
    v5 = v22;
    v6 = v23;
    sub_100034C68((uint64_t)v21, v22);
    dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v5, v6);
    v7 = v22;
    v8 = v23;
    sub_100034C68((uint64_t)v21, v22);
    LOBYTE(v7) = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v7, v8);
    v9 = v22;
    v10 = v23;
    sub_100034C68((uint64_t)v21, v22);
    v11 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v9, v10);
    v12 = sub_1000DD8A0(v7, v11);
    if ((v12 & 0xFF00000000) != 0x300000000)
    {
      v16 = v12;
      v17 = v22;
      v18 = v23;
      sub_100034C68((uint64_t)v21, v22);
      v19 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v17, v18);
      sub_1000CB8D0(v19 << 8, (uint64_t)v21);
      sub_100014430(v21);
      sub_100014430(a1);
      return v16 & 0xFFFFFFFFFFFFLL;
    }
    v13 = sub_100012C84();
    v14 = swift_allocError(&type metadata for WiFiError, v13, 0, 0);
    *(_OWORD *)v15 = xmmword_100337850;
    *(_BYTE *)(v15 + 16) = 2;
    swift_willThrow(v14);
    sub_100014430(v21);
  }
  return sub_100014430(a1);
}

uint64_t sub_1000E5D10(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unsigned __int8 v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v16;
  char v17;
  uint64_t v18;

  v3 = sub_100012C44(&qword_100407AB0);
  v4 = *(_QWORD *)(v3 - 8);
  __chkstk_darwin();
  v6 = (char *)&v16 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = a1[3];
  v8 = a1[4];
  sub_10003259C(a1, v7);
  v9 = sub_1000E76B8();
  dispatch thunk of Decoder.container<A>(keyedBy:)(&type metadata for AWDLActionFrame.ProMode.CodingKeys, &type metadata for AWDLActionFrame.ProMode.CodingKeys, v9, v7, v8);
  if (v1)
    return sub_100014430(a1);
  HIBYTE(v18) = 0;
  v10 = KeyedDecodingContainer.decode(_:forKey:)((char *)&v18 + 7, v3);
  BYTE5(v18) = 1;
  v11 = sub_1000F06BC();
  KeyedDecodingContainer.decode<A>(_:forKey:)((uint64_t *)((char *)&v18 + 6), &type metadata for AWDLActionFrame.ProMode.Command, (char *)&v18 + 5, v3, &type metadata for AWDLActionFrame.ProMode.Command, v11);
  v12 = BYTE6(v18);
  BYTE4(v18) = 2;
  v13 = KeyedDecodingContainer.decode(_:forKey:)((char *)&v18 + 4, v3);
  v17 = 3;
  v14 = sub_1000F0700();
  KeyedDecodingContainer.decode<A>(_:forKey:)(&v18, &type metadata for AWDLActionFrame.ProMode.Flags, &v17, v3, &type metadata for AWDLActionFrame.ProMode.Flags, v14);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  sub_100014430(a1);
  return v10 | (unint64_t)(v12 << 8) | (v13 << 32);
}

uint64_t sub_1000E5EEC(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unsigned __int8 v10;
  unint64_t v11;
  int v13;
  int v14;
  uint64_t v15;
  char v16;
  uint64_t v17;

  v3 = sub_100012C44(&qword_100407AA0);
  v4 = *(_QWORD *)(v3 - 8);
  __chkstk_darwin();
  v6 = (char *)&v15 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = a1[3];
  v8 = a1[4];
  sub_10003259C(a1, v7);
  v9 = sub_1000E7784();
  dispatch thunk of Decoder.container<A>(keyedBy:)(&type metadata for AWDLActionFrame.AirDrop.CodingKeys, &type metadata for AWDLActionFrame.AirDrop.CodingKeys, v9, v7, v8);
  if (v1)
    return sub_100014430(a1);
  BYTE1(v17) = 0;
  v10 = KeyedDecodingContainer.decode(_:forKey:)((char *)&v17 + 1, v3);
  v16 = 1;
  v11 = sub_1000F0678();
  KeyedDecodingContainer.decode<A>(_:forKey:)(&v17, &type metadata for AWDLActionFrame.AirDrop.State, &v16, v3, &type metadata for AWDLActionFrame.AirDrop.State, v11);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  v13 = v17;
  sub_100014430(a1);
  if (v13)
    v14 = 256;
  else
    v14 = 0;
  return v14 & 0xFFFFFF00 | v10;
}

void sub_1000E605C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __asm { BR              X11 }
}

void sub_1000E6098(int a1@<W8>)
{
  unsigned int v1;
  uint64_t v2;

  v2 = 0;
  while (((v1 >> v2) & 1) == 0)
  {
    if (++v2 == 32)
      __asm { BR              X12 }
  }
  __asm { BR              X14 }
}

uint64_t sub_1000E6208(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD v30[3];
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;

  v3 = a1[3];
  v4 = a1[4];
  sub_10003259C(a1, v3);
  dispatch thunk of Decoder.unkeyedContainer()(v30, v3, v4);
  if (v1)
    return sub_100014430(a1);
  v5 = v31;
  v6 = v32;
  sub_100034C68((uint64_t)v30, v31);
  v7 = sub_1000F05AC();
  UnkeyedDecodingContainer.inferredDecode<A>()(v5, (uint64_t)&type metadata for AWDLActionFrame.OUIType, v6, v7);
  v8 = v31;
  v9 = v32;
  sub_100034C68((uint64_t)v30, v31);
  v10 = sub_1000F05F0();
  UnkeyedDecodingContainer.inferredDecode<A>()(v8, (uint64_t)&type metadata for AWDLActionFrame.AWDLVersion, v9, v10);
  v11 = v33;
  v12 = v31;
  v13 = v32;
  sub_100034C68((uint64_t)v30, v31);
  v14 = sub_1000F0634();
  UnkeyedDecodingContainer.inferredDecode<A>()(v12, (uint64_t)&type metadata for AWDLActionFrame.OUISubtype, v13, v14);
  v15 = v33;
  v16 = v31;
  v17 = v32;
  sub_100034C68((uint64_t)v30, v31);
  UnkeyedDecodingContainer.inferredDecode<A>()(v16, (uint64_t)&type metadata for UInt8, v17, (uint64_t)&protocol witness table for UInt8);
  v18 = v33;
  v19 = v31;
  v20 = v32;
  sub_100034C68((uint64_t)v30, v31);
  UnkeyedDecodingContainer.inferredDecode<A>()(v19, (uint64_t)&type metadata for UInt32, v20, (uint64_t)&protocol witness table for UInt32);
  v21 = v33;
  v22 = v31;
  v23 = v32;
  sub_100034C68((uint64_t)v30, v31);
  UnkeyedDecodingContainer.inferredDecode<A>()(v22, (uint64_t)&type metadata for UInt32, v23, (uint64_t)&protocol witness table for UInt32);
  v25 = v31;
  v29 = v32;
  sub_100034C68((uint64_t)v30, v31);
  v26 = type metadata accessor for AWDLActionFrame.AWDLAttribute(0);
  v27 = sub_100011DE4(&qword_100407A90, type metadata accessor for AWDLActionFrame.AWDLAttribute, (uint64_t)&protocol conformance descriptor for AWDLActionFrame.AWDLAttribute);
  UnkeyedDecodingContainer.inferredArrayDecode<A>()(v25, v26, v29, v27);
  sub_100014430(v30);
  sub_100014430(a1);
  v28 = 256;
  if (!v15)
    v28 = 0;
  return v28 | v11 | (v18 << 16) | (v21 << 32);
}

_QWORD *sub_1000E64D8(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  _QWORD v19[3];
  uint64_t v20;
  uint64_t v21;

  v3 = a1[3];
  v4 = a1[4];
  v5 = sub_10003259C(a1, v3);
  dispatch thunk of Decoder.unkeyedContainer()(v19, v3, v4);
  if (v1)
  {
    sub_100014430(a1);
  }
  else
  {
    v6 = v20;
    v7 = v21;
    sub_100034C68((uint64_t)v19, v20);
    v8 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v6, v7);
    v10 = v8;
    if ((_DWORD)v8)
    {
      v11 = v20;
      v12 = v21;
      sub_100034C68((uint64_t)v19, v20);
      v13 = sub_10007BAC0();
      dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)(&type metadata for Data, &type metadata for Data, v13, v11, v12);
      v14 = v17;
      v15 = v18;
    }
    else
    {
      v14 = 0;
      v15 = 0xC000000000000000;
    }
    sub_1000E605C(v10, v14, v15);
    v5 = v16;
    sub_10000E614(v14, v15);
    sub_100014430(v19);
    sub_100014430(a1);
  }
  return v5;
}

uint64_t sub_1000E6644@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint8x8_t v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned __int8 v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned __int8 v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t result;
  __int32 v30;
  __int16 v31;
  _QWORD v32[3];
  uint64_t v33;
  uint64_t v34;

  v6 = a1[3];
  v7 = a1[4];
  sub_10003259C(a1, v6);
  dispatch thunk of Decoder.unkeyedContainer()(v32, v6, v7);
  if (v2)
    return sub_100014430(a1);
  v8 = v33;
  v9 = v34;
  sub_100034C68((uint64_t)v32, v33);
  v10 = sub_1000F0744();
  UnkeyedDecodingContainer.inferredDecode<A>()(v8, (uint64_t)&type metadata for AWDLActionFrame.RealtimeGroup.Flags, v9, v10);
  v11 = v33;
  v12 = v34;
  sub_100034C68((uint64_t)v32, v33);
  v13 = sub_10003A65C();
  UnkeyedDecodingContainer.inferredDecode<A>()(v11, (uint64_t)&type metadata for WiFiAddress, v12, v13);
  v3.i32[0] = v30;
  v14 = v33;
  v15 = v34;
  sub_100034C68((uint64_t)v32, v33);
  v16 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v14, v15);
  v17 = sub_100192784(v16);
  v18 = v33;
  v19 = v34;
  sub_100034C68((uint64_t)v32, v33);
  LOBYTE(v18) = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v18, v19);
  v20 = v33;
  v21 = v34;
  sub_100034C68((uint64_t)v32, v33);
  v22 = sub_1000F0788();
  UnkeyedDecodingContainer.inferredDecode<A>()(v20, (uint64_t)&type metadata for AWDLActionFrame.RealtimeGroup.AdditionalFlags, v21, v22);
  v24 = v33;
  v23 = v34;
  sub_100034C68((uint64_t)v32, v33);
  v25 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v24, v23);
  v26 = sub_100192784(v25);
  v27 = v33;
  v28 = v34;
  sub_100034C68((uint64_t)v32, v33);
  UnkeyedDecodingContainer.inferredDecode<A>()(v27, (uint64_t)&type metadata for WiFiAddress, v28, v13);
  sub_100014430(v32);
  result = sub_100014430(a1);
  *(_BYTE *)a2 = v30;
  *(_DWORD *)(a2 + 1) = vmovn_s16((int16x8_t)vmovl_u8(v3)).u32[0];
  *(_WORD *)(a2 + 5) = v31;
  *(_WORD *)(a2 + 12) = WORD2(v17);
  *(_DWORD *)(a2 + 8) = v17;
  *(_QWORD *)(a2 + 16) = (char)v18;
  *(_BYTE *)(a2 + 24) = v30;
  *(_WORD *)(a2 + 32) = WORD2(v26);
  *(_DWORD *)(a2 + 28) = v26;
  *(_DWORD *)(a2 + 34) = v30;
  *(_WORD *)(a2 + 38) = v31;
  return result;
}

uint64_t sub_1000E6920(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  __int16 v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int16 v20;
  _QWORD *v21;
  _QWORD v22[3];
  uint64_t v23;
  uint64_t v24;
  unsigned __int8 v25;

  v3 = a1[3];
  v4 = a1[4];
  v5 = sub_10003259C(a1, v3);
  dispatch thunk of Decoder.unkeyedContainer()(v22, v3, v4);
  if (v1)
  {
    sub_100014430(a1);
    return (uint64_t)v5;
  }
  v6 = v23;
  v7 = v24;
  sub_100034C68((uint64_t)v22, v23);
  result = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v6, v7);
  v9 = result + 1;
  if ((v9 & 0x100) == 0)
  {
    v10 = v23;
    v11 = v24;
    sub_100034C68((uint64_t)v22, v23);
    v12 = sub_1000F0BC4();
    dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)(&type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.Encoding, &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.Encoding, v12, v10, v11);
    v13 = v25;
    v14 = v23;
    v15 = v24;
    sub_100034C68((uint64_t)v22, v23);
    dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v14, v15);
    v16 = v23;
    v17 = v24;
    sub_100034C68((uint64_t)v22, v23);
    dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v16, v17);
    v18 = v23;
    v19 = v24;
    sub_100034C68((uint64_t)v22, v23);
    dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v18, v19);
    v20 = v9 << 8;
    if ((v13 - 2) >= 2)
    {
      if (v13)
        sub_1000CBF10(v20, (uint64_t)v22);
      else
        sub_1000CBB14(v20, (uint64_t)v22);
    }
    else
    {
      v21 = sub_1000CC078(v20, (uint64_t)v22);
    }
    v5 = v21;
    sub_100014430(v22);
    sub_100014430(a1);
    return (uint64_t)v5;
  }
  __break(1u);
  return result;
}

uint64_t sub_1000E6AFC(uint64_t a1)
{
  swift_bridgeObjectRetain(*(_QWORD *)(a1 + 40));
  return a1;
}

unint64_t sub_1000E6B24()
{
  unint64_t result;

  result = qword_1004071D8;
  if (!qword_1004071D8)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLElectionMetric, &type metadata for AWDLElectionMetric);
    atomic_store(result, (unint64_t *)&qword_1004071D8);
  }
  return result;
}

unint64_t sub_1000E6B68()
{
  unint64_t result;

  result = qword_1004071E8;
  if (!qword_1004071E8)
  {
    result = swift_getWitnessTable(byte_1003452CC, &type metadata for AWDLActionFrame.ServiceParameter.SSTH.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004071E8);
  }
  return result;
}

unint64_t sub_1000E6BAC()
{
  unint64_t result;

  result = qword_1004071F8;
  if (!qword_1004071F8)
  {
    result = swift_getWitnessTable(asc_10034527C, &type metadata for AWDLActionFrame.ServiceParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004071F8);
  }
  return result;
}

unint64_t sub_1000E6BF0()
{
  unint64_t result;

  result = qword_100407200;
  if (!qword_100407200)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.ServiceParameter.Flags, &type metadata for AWDLActionFrame.ServiceParameter.Flags);
    atomic_store(result, (unint64_t *)&qword_100407200);
  }
  return result;
}

unint64_t sub_1000E6C34()
{
  unint64_t result;

  result = qword_100407208;
  if (!qword_100407208)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.ServiceParameter.SSTH, &type metadata for AWDLActionFrame.ServiceParameter.SSTH);
    atomic_store(result, (unint64_t *)&qword_100407208);
  }
  return result;
}

uint64_t sub_1000E6C78(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD v27[3];
  uint64_t v28;
  uint64_t v29;
  unsigned __int8 v30;

  type metadata accessor for String.Encoding(0);
  __chkstk_darwin();
  v4 = (char *)&v27[-1] - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v5 = a1[3];
  v6 = a1[4];
  sub_10003259C(a1, v5);
  dispatch thunk of Decoder.unkeyedContainer()(v27, v5, v6);
  if (!v1)
  {
    v7 = v28;
    v8 = v29;
    sub_100034C68((uint64_t)v27, v28);
    v9 = sub_1000F09A4();
    dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)(&type metadata for AWDLActionFrame.Arpa.Flags, &type metadata for AWDLActionFrame.Arpa.Flags, v9, v7, v8);
    v5 = v30;
    v10 = v28;
    v11 = v29;
    sub_100034C68((uint64_t)v27, v28);
    v12 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v10, v11);
    v13 = v12;
    v14 = v28;
    v15 = v29;
    sub_100034C68((uint64_t)v27, v28);
    v16 = UnkeyedDecodingContainer.decodeData(with:)(v13, v14, v15);
    v19 = v16;
    v20 = v17;
    static String.Encoding.utf8.getter(v16);
    String.init(data:encoding:)(v19, v20, v4);
    v22 = v21;
    sub_10000E614(v19, v20);
    if (v22)
    {
      sub_100014430(v27);
      sub_100014430(a1);
      return v5;
    }
    v23 = sub_100012C84();
    v24 = swift_allocError(&type metadata for WiFiError, v23, 0, 0);
    *(_OWORD *)v25 = xmmword_100337850;
    *(_BYTE *)(v25 + 16) = 2;
    swift_willThrow(v24);
    sub_100014430(v27);
  }
  sub_100014430(a1);
  return v5;
}

unint64_t sub_1000E6E74(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unsigned __int16 v16;
  _QWORD v17[3];
  uint64_t v18;
  uint64_t v19;

  v3 = a1[3];
  v4 = a1[4];
  sub_10003259C(a1, v3);
  dispatch thunk of Decoder.unkeyedContainer()(v17, v3, v4);
  if (v1)
    return sub_100014430(a1);
  v5 = v18;
  v6 = v19;
  sub_100034C68((uint64_t)v17, v18);
  v7 = sub_1000F09E8();
  UnkeyedDecodingContainer.inferredDecode<A>()(v5, (uint64_t)&type metadata for AWDLActionFrame.ServiceParameter.Flags, v6, v7);
  v8 = v18;
  v9 = v19;
  sub_100034C68((uint64_t)v17, v18);
  UnkeyedDecodingContainer.inferredDecode<A>()(v8, (uint64_t)&type metadata for UInt16, v9, (uint64_t)&protocol witness table for UInt16);
  v10 = v18;
  v11 = v19;
  sub_100034C68((uint64_t)v17, v18);
  UnkeyedDecodingContainer.inferredDecode<A>()(v10, (uint64_t)&type metadata for UInt16, v11, (uint64_t)&protocol witness table for UInt16);
  v12 = v18;
  v13 = v19;
  sub_100034C68((uint64_t)v17, v18);
  v14 = sub_1000F0A2C();
  UnkeyedDecodingContainer.inferredDecode<A>()(v12, (uint64_t)&type metadata for AWDLActionFrame.ServiceParameter.SSTH, v13, v14);
  sub_100014430(v17);
  sub_100014430(a1);
  return v16 | ((unint64_t)v16 << 16) | ((unint64_t)v16 << 32);
}

uint64_t type metadata accessor for AWDLActionFrame.DataPathState(uint64_t a1)
{
  return sub_10000D69C(a1, (uint64_t *)&unk_100407680, (uint64_t)&nominal type descriptor for AWDLActionFrame.DataPathState);
}

uint64_t sub_1000E7054(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = sub_100012C44(&qword_100407210);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 - 8) + 16))(a2, a1, v4);
  return a2;
}

uint64_t sub_1000E709C(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = sub_100012C44(&qword_100407210);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 - 8) + 40))(a2, a1, v4);
  return a2;
}

unint64_t sub_1000E70E4()
{
  unint64_t result;

  result = qword_100407218;
  if (!qword_100407218)
  {
    result = swift_getWitnessTable(byte_100345254, &type metadata for AWDLActionFrame.DataPathState.Flags);
    atomic_store(result, (unint64_t *)&qword_100407218);
  }
  return result;
}

unint64_t sub_1000E7128()
{
  unint64_t result;

  result = qword_100407220;
  if (!qword_100407220)
  {
    result = swift_getWitnessTable(byte_10034522C, &type metadata for AWDLActionFrame.DataPathState.ExtensionFlags);
    atomic_store(result, (unint64_t *)&qword_100407220);
  }
  return result;
}

unint64_t sub_1000E716C()
{
  unint64_t result;

  result = qword_100407228;
  if (!qword_100407228)
  {
    result = swift_getWitnessTable(a5, &type metadata for AWDLActionFrame.DataPathState.Flags);
    atomic_store(result, (unint64_t *)&qword_100407228);
  }
  return result;
}

unint64_t sub_1000E71B0()
{
  unint64_t result;

  result = qword_100407230;
  if (!qword_100407230)
  {
    result = swift_getWitnessTable(asc_1003451DC, &type metadata for AWDLActionFrame.DataPathState.ExtensionFlags);
    atomic_store(result, (unint64_t *)&qword_100407230);
  }
  return result;
}

unint64_t sub_1000E71F4()
{
  unint64_t result;

  result = qword_100407238;
  if (!qword_100407238)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.Arpa.Flags, &type metadata for AWDLActionFrame.Arpa.Flags);
    atomic_store(result, (unint64_t *)&qword_100407238);
  }
  return result;
}

unint64_t sub_1000E7238()
{
  unint64_t result;

  result = qword_100407248;
  if (!qword_100407248)
  {
    result = swift_getWitnessTable(byte_10034518C, &type metadata for AWDLActionFrame.SyncTreePath.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407248);
  }
  return result;
}

unint64_t sub_1000E727C()
{
  unint64_t result;

  result = qword_100407268;
  if (!qword_100407268)
  {
    result = swift_getWitnessTable(aM, &type metadata for AWDLActionFrame.AWDLVersion.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407268);
  }
  return result;
}

unint64_t sub_1000E72C0()
{
  unint64_t result;

  result = qword_100407280;
  if (!qword_100407280)
  {
    result = swift_getWitnessTable(byte_1003450EC, &type metadata for AWDLActionFrame.Version.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407280);
  }
  return result;
}

unint64_t sub_1000E7304()
{
  unint64_t result;

  result = qword_100407288;
  if (!qword_100407288)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.AWDLVersion, &type metadata for AWDLActionFrame.AWDLVersion);
    atomic_store(result, (unint64_t *)&qword_100407288);
  }
  return result;
}

unint64_t sub_1000E7348()
{
  unint64_t result;

  result = qword_100407298;
  if (!qword_100407298)
  {
    result = swift_getWitnessTable(asc_10034509C, &type metadata for AWDLActionFrame.PeerMACAddressListBloomFilter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407298);
  }
  return result;
}

unint64_t sub_1000E738C()
{
  unint64_t result;

  result = qword_1004072A8;
  if (!qword_1004072A8)
  {
    result = swift_getWitnessTable(asc_10034504C, &type metadata for AWDLActionFrame.NANSynchronization.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004072A8);
  }
  return result;
}

unint64_t sub_1000E73D0()
{
  unint64_t result;

  result = qword_1004072B0;
  if (!qword_1004072B0)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANTimeSynchronizationFunction, &type metadata for NANTimeSynchronizationFunction);
    atomic_store(result, (unint64_t *)&qword_1004072B0);
  }
  return result;
}

unint64_t sub_1000E7414()
{
  unint64_t result;

  result = qword_1004072B8;
  if (!qword_1004072B8)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANAttribute.MasterIndication, &type metadata for NANAttribute.MasterIndication);
    atomic_store(result, (unint64_t *)&qword_1004072B8);
  }
  return result;
}

uint64_t sub_1000E7458(int *a1, uint64_t a2)
{
  initializeBufferWithCopyOfBuffer for AWDLElectionMetric(a2, a1);
  return a2;
}

unint64_t sub_1000E7494()
{
  unint64_t result;

  result = qword_1004072C8;
  if (!qword_1004072C8)
  {
    result = swift_getWitnessTable(byte_100344FFC, &type metadata for AWDLActionFrame.ElectionParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004072C8);
  }
  return result;
}

unint64_t sub_1000E74D8()
{
  unint64_t result;

  result = qword_1004072D8;
  if (!qword_1004072D8)
  {
    result = swift_getWitnessTable(byte_100344FAC, &type metadata for AWDLActionFrame.MultiPeerBSSSteering.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004072D8);
  }
  return result;
}

unint64_t sub_1000E751C()
{
  unint64_t result;

  result = qword_1004072E0;
  if (!qword_1004072E0)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.MultiPeerBSSSteering.SteeringMessageID, &type metadata for AWDLActionFrame.MultiPeerBSSSteering.SteeringMessageID);
    atomic_store(result, (unint64_t *)&qword_1004072E0);
  }
  return result;
}

unint64_t sub_1000E7560()
{
  unint64_t result;

  result = qword_1004072F0;
  if (!qword_1004072F0)
  {
    result = swift_getWitnessTable(aM_0, &type metadata for AWDLActionFrame.Ranging.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004072F0);
  }
  return result;
}

unint64_t sub_1000E75A4()
{
  unint64_t result;

  result = qword_1004072F8;
  if (!qword_1004072F8)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.RealtimeGroup.Flags, &type metadata for AWDLActionFrame.RealtimeGroup.Flags);
    atomic_store(result, (unint64_t *)&qword_1004072F8);
  }
  return result;
}

uint64_t sub_1000E75E8(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = sub_100012C44((uint64_t *)&unk_10040FAF0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 - 8) + 32))(a2, a1, v4);
  return a2;
}

unint64_t sub_1000E7630()
{
  unint64_t result;

  result = qword_100407300;
  if (!qword_100407300)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.RealtimeGroup.AdditionalFlags, &type metadata for AWDLActionFrame.RealtimeGroup.AdditionalFlags);
    atomic_store(result, (unint64_t *)&qword_100407300);
  }
  return result;
}

unint64_t sub_1000E7674()
{
  unint64_t result;

  result = qword_100407310;
  if (!qword_100407310)
  {
    result = swift_getWitnessTable(byte_100344F0C, &type metadata for AWDLActionFrame.ExtendedChannelSequence.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407310);
  }
  return result;
}

unint64_t sub_1000E76B8()
{
  unint64_t result;

  result = qword_100407320;
  if (!qword_100407320)
  {
    result = swift_getWitnessTable(byte_100344EBC, &type metadata for AWDLActionFrame.ProMode.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407320);
  }
  return result;
}

unint64_t sub_1000E76FC()
{
  unint64_t result;

  result = qword_100407328;
  if (!qword_100407328)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.ProMode.Command, &type metadata for AWDLActionFrame.ProMode.Command);
    atomic_store(result, (unint64_t *)&qword_100407328);
  }
  return result;
}

unint64_t sub_1000E7740()
{
  unint64_t result;

  result = qword_100407330;
  if (!qword_100407330)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.ProMode.Flags, &type metadata for AWDLActionFrame.ProMode.Flags);
    atomic_store(result, (unint64_t *)&qword_100407330);
  }
  return result;
}

unint64_t sub_1000E7784()
{
  unint64_t result;

  result = qword_100407340;
  if (!qword_100407340)
  {
    result = swift_getWitnessTable(asc_100344E6C, &type metadata for AWDLActionFrame.AirDrop.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407340);
  }
  return result;
}

unint64_t sub_1000E77C8()
{
  unint64_t result;

  result = qword_100407348;
  if (!qword_100407348)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.AirDrop.State, &type metadata for AWDLActionFrame.AirDrop.State);
    atomic_store(result, (unint64_t *)&qword_100407348);
  }
  return result;
}

uint64_t type metadata accessor for AWDLActionFrame.AWDLAttribute(uint64_t a1)
{
  return sub_10000D69C(a1, qword_1004077B0, (uint64_t)&nominal type descriptor for AWDLActionFrame.AWDLAttribute);
}

unint64_t sub_1000E7820()
{
  unint64_t result;

  result = qword_100407350;
  if (!qword_100407350)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.AWDLAttribute.AttributeType, &type metadata for AWDLActionFrame.AWDLAttribute.AttributeType);
    atomic_store(result, (unint64_t *)&qword_100407350);
  }
  return result;
}

uint64_t sub_1000E7864(uint64_t a1)
{
  swift_bridgeObjectRelease(*(_QWORD *)(a1 + 40));
  return a1;
}

unint64_t sub_1000E788C()
{
  unint64_t result;

  result = qword_100407388;
  if (!qword_100407388)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.OUIType, &type metadata for AWDLActionFrame.OUIType);
    atomic_store(result, (unint64_t *)&qword_100407388);
  }
  return result;
}

unint64_t sub_1000E78D0()
{
  unint64_t result;

  result = qword_100407390;
  if (!qword_100407390)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.OUISubtype, &type metadata for AWDLActionFrame.OUISubtype);
    atomic_store(result, (unint64_t *)&qword_100407390);
  }
  return result;
}

unint64_t sub_1000E7914()
{
  unint64_t result;
  uint64_t v1;
  uint64_t v2;

  result = qword_1004073A0;
  if (!qword_1004073A0)
  {
    v1 = sub_100013C64(&qword_100407398);
    v2 = sub_100011DE4(&qword_1004073A8, type metadata accessor for AWDLActionFrame.AWDLAttribute, (uint64_t)&protocol conformance descriptor for AWDLActionFrame.AWDLAttribute);
    result = swift_getWitnessTable((const char *)&protocol conformance descriptor for <A> [A], v1, &v2);
    atomic_store(result, (unint64_t *)&qword_1004073A0);
  }
  return result;
}

uint64_t type metadata accessor for AWDLActionFrame.Header(uint64_t a1)
{
  return sub_10000D69C(a1, qword_100407840, (uint64_t)&nominal type descriptor for AWDLActionFrame.Header);
}

unint64_t sub_1000E79A8()
{
  unint64_t result;

  result = qword_1004073B0;
  if (!qword_1004073B0)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.OUIType, &type metadata for AWDLActionFrame.OUIType);
    atomic_store(result, (unint64_t *)&qword_1004073B0);
  }
  return result;
}

unint64_t sub_1000E79F0()
{
  unint64_t result;

  result = qword_1004073B8;
  if (!qword_1004073B8)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.OUISubtype, &type metadata for AWDLActionFrame.OUISubtype);
    atomic_store(result, (unint64_t *)&qword_1004073B8);
  }
  return result;
}

unint64_t sub_1000E7A38()
{
  unint64_t result;

  result = qword_1004073C0;
  if (!qword_1004073C0)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.ServiceRequest, &type metadata for AWDLActionFrame.ServiceRequest);
    atomic_store(result, (unint64_t *)&qword_1004073C0);
  }
  return result;
}

uint64_t sub_1000E7A7C()
{
  return sub_100011DE4(&qword_1004073C8, type metadata accessor for AWDLActionFrame.ServiceResponse, (uint64_t)&protocol conformance descriptor for AWDLActionFrame.ServiceResponse);
}

unint64_t sub_1000E7AAC()
{
  unint64_t result;

  result = qword_1004073D0;
  if (!qword_1004073D0)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.AWDLChannelSequenceParameter, &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter);
    atomic_store(result, (unint64_t *)&qword_1004073D0);
  }
  return result;
}

unint64_t sub_1000E7AF4()
{
  unint64_t result;

  result = qword_1004073D8;
  if (!qword_1004073D8)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.SynchronizationParameter, &type metadata for AWDLActionFrame.SynchronizationParameter);
    atomic_store(result, (unint64_t *)&qword_1004073D8);
  }
  return result;
}

unint64_t sub_1000E7B3C()
{
  unint64_t result;

  result = qword_1004073E0;
  if (!qword_1004073E0)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.DeprecatedElectionParameter, &type metadata for AWDLActionFrame.DeprecatedElectionParameter);
    atomic_store(result, (unint64_t *)&qword_1004073E0);
  }
  return result;
}

unint64_t sub_1000E7B84()
{
  unint64_t result;

  result = qword_1004073E8;
  if (!qword_1004073E8)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.ServiceParameter.Flags, &type metadata for AWDLActionFrame.ServiceParameter.Flags);
    atomic_store(result, (unint64_t *)&qword_1004073E8);
  }
  return result;
}

unint64_t sub_1000E7BCC()
{
  unint64_t result;

  result = qword_1004073F0;
  if (!qword_1004073F0)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.ServiceParameter.Flags, &type metadata for AWDLActionFrame.ServiceParameter.Flags);
    atomic_store(result, (unint64_t *)&qword_1004073F0);
  }
  return result;
}

unint64_t sub_1000E7C14()
{
  unint64_t result;

  result = qword_1004073F8;
  if (!qword_1004073F8)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.ServiceParameter.Flags, &type metadata for AWDLActionFrame.ServiceParameter.Flags);
    atomic_store(result, (unint64_t *)&qword_1004073F8);
  }
  return result;
}

unint64_t sub_1000E7C5C()
{
  unint64_t result;

  result = qword_100407400;
  if (!qword_100407400)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.ServiceParameter.Flags, &type metadata for AWDLActionFrame.ServiceParameter.Flags);
    atomic_store(result, (unint64_t *)&qword_100407400);
  }
  return result;
}

unint64_t sub_1000E7CA4()
{
  unint64_t result;

  result = qword_100407408;
  if (!qword_100407408)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.ServiceParameter.SSTH, &type metadata for AWDLActionFrame.ServiceParameter.SSTH);
    atomic_store(result, (unint64_t *)&qword_100407408);
  }
  return result;
}

unint64_t sub_1000E7CEC()
{
  unint64_t result;

  result = qword_100407410;
  if (!qword_100407410)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.ServiceParameter, &type metadata for AWDLActionFrame.ServiceParameter);
    atomic_store(result, (unint64_t *)&qword_100407410);
  }
  return result;
}

unint64_t sub_1000E7D34()
{
  unint64_t result;

  result = qword_100407418;
  if (!qword_100407418)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.DataPathState.UnicastMasterIndicationOptions, &type metadata for AWDLActionFrame.DataPathState.UnicastMasterIndicationOptions);
    atomic_store(result, (unint64_t *)&qword_100407418);
  }
  return result;
}

uint64_t sub_1000E7D78()
{
  return sub_100011DE4(&qword_100407420, type metadata accessor for AWDLActionFrame.DataPathState, (uint64_t)&protocol conformance descriptor for AWDLActionFrame.DataPathState);
}

unint64_t sub_1000E7DA8()
{
  unint64_t result;

  result = qword_100407428;
  if (!qword_100407428)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.Arpa.Flags, &type metadata for AWDLActionFrame.Arpa.Flags);
    atomic_store(result, (unint64_t *)&qword_100407428);
  }
  return result;
}

unint64_t sub_1000E7DF0()
{
  unint64_t result;

  result = qword_100407430;
  if (!qword_100407430)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.Arpa.Flags, &type metadata for AWDLActionFrame.Arpa.Flags);
    atomic_store(result, (unint64_t *)&qword_100407430);
  }
  return result;
}

unint64_t sub_1000E7E38()
{
  unint64_t result;

  result = qword_100407438;
  if (!qword_100407438)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.Arpa.Flags, &type metadata for AWDLActionFrame.Arpa.Flags);
    atomic_store(result, (unint64_t *)&qword_100407438);
  }
  return result;
}

unint64_t sub_1000E7E80()
{
  unint64_t result;

  result = qword_100407440;
  if (!qword_100407440)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.Arpa.Flags, &type metadata for AWDLActionFrame.Arpa.Flags);
    atomic_store(result, (unint64_t *)&qword_100407440);
  }
  return result;
}

unint64_t sub_1000E7EC8()
{
  unint64_t result;

  result = qword_100407448;
  if (!qword_100407448)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.Arpa, &type metadata for AWDLActionFrame.Arpa);
    atomic_store(result, (unint64_t *)&qword_100407448);
  }
  return result;
}

unint64_t sub_1000E7F10()
{
  unint64_t result;

  result = qword_100407450;
  if (!qword_100407450)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.SyncTreePath, &type metadata for AWDLActionFrame.SyncTreePath);
    atomic_store(result, (unint64_t *)&qword_100407450);
  }
  return result;
}

unint64_t sub_1000E7F58()
{
  unint64_t result;

  result = qword_100407458;
  if (!qword_100407458)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.AWDLVersion, &type metadata for AWDLActionFrame.AWDLVersion);
    atomic_store(result, (unint64_t *)&qword_100407458);
  }
  return result;
}

unint64_t sub_1000E7FA0()
{
  unint64_t result;

  result = qword_100407460;
  if (!qword_100407460)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.Version.PlatformType, &type metadata for AWDLActionFrame.Version.PlatformType);
    atomic_store(result, (unint64_t *)&qword_100407460);
  }
  return result;
}

unint64_t sub_1000E7FE8()
{
  unint64_t result;

  result = qword_100407468;
  if (!qword_100407468)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.Version, &type metadata for AWDLActionFrame.Version);
    atomic_store(result, (unint64_t *)&qword_100407468);
  }
  return result;
}

unint64_t sub_1000E8030()
{
  unint64_t result;

  result = qword_100407470;
  if (!qword_100407470)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.PeerMACAddressListBloomFilter, &type metadata for AWDLActionFrame.PeerMACAddressListBloomFilter);
    atomic_store(result, (unint64_t *)&qword_100407470);
  }
  return result;
}

unint64_t sub_1000E8078()
{
  unint64_t result;

  result = qword_100407478;
  if (!qword_100407478)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.NANSynchronization, &type metadata for AWDLActionFrame.NANSynchronization);
    atomic_store(result, (unint64_t *)&qword_100407478);
  }
  return result;
}

unint64_t sub_1000E80C0()
{
  unint64_t result;

  result = qword_100407480;
  if (!qword_100407480)
  {
    result = swift_getWitnessTable("]\r\n", &type metadata for AWDLActionFrame.ElectionParameter);
    atomic_store(result, (unint64_t *)&qword_100407480);
  }
  return result;
}

unint64_t sub_1000E8108()
{
  unint64_t result;

  result = qword_100407488;
  if (!qword_100407488)
  {
    result = swift_getWitnessTable("5\r\n", &type metadata for AWDLActionFrame.MultiPeerBSSSteering.SteeringMessageID);
    atomic_store(result, (unint64_t *)&qword_100407488);
  }
  return result;
}

unint64_t sub_1000E8150()
{
  unint64_t result;

  result = qword_100407490;
  if (!qword_100407490)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.MultiPeerBSSSteering, &type metadata for AWDLActionFrame.MultiPeerBSSSteering);
    atomic_store(result, (unint64_t *)&qword_100407490);
  }
  return result;
}

unint64_t sub_1000E8198()
{
  unint64_t result;

  result = qword_100407498;
  if (!qword_100407498)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.Ranging, &type metadata for AWDLActionFrame.Ranging);
    atomic_store(result, (unint64_t *)&qword_100407498);
  }
  return result;
}

unint64_t sub_1000E81E0()
{
  unint64_t result;

  result = qword_1004074A0;
  if (!qword_1004074A0)
  {
    result = swift_getWitnessTable("U\t\n", &type metadata for AWDLActionFrame.RealtimeGroup.Flags);
    atomic_store(result, (unint64_t *)&qword_1004074A0);
  }
  return result;
}

unint64_t sub_1000E8228()
{
  unint64_t result;

  result = qword_1004074A8;
  if (!qword_1004074A8)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.RealtimeGroup.Flags, &type metadata for AWDLActionFrame.RealtimeGroup.Flags);
    atomic_store(result, (unint64_t *)&qword_1004074A8);
  }
  return result;
}

unint64_t sub_1000E8270()
{
  unint64_t result;

  result = qword_1004074B0;
  if (!qword_1004074B0)
  {
    result = swift_getWitnessTable("\r\t\n", &type metadata for AWDLActionFrame.RealtimeGroup.Flags);
    atomic_store(result, (unint64_t *)&qword_1004074B0);
  }
  return result;
}

unint64_t sub_1000E82B8()
{
  unint64_t result;

  result = qword_1004074B8;
  if (!qword_1004074B8)
  {
    result = swift_getWitnessTable("-\n\n", &type metadata for AWDLActionFrame.RealtimeGroup.Flags);
    atomic_store(result, (unint64_t *)&qword_1004074B8);
  }
  return result;
}

unint64_t sub_1000E8300()
{
  unint64_t result;

  result = qword_1004074C0;
  if (!qword_1004074C0)
  {
    result = swift_getWitnessTable("5\a\n", &type metadata for AWDLActionFrame.RealtimeGroup.AdditionalFlags);
    atomic_store(result, (unint64_t *)&qword_1004074C0);
  }
  return result;
}

unint64_t sub_1000E8348()
{
  unint64_t result;

  result = qword_1004074C8;
  if (!qword_1004074C8)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.RealtimeGroup.AdditionalFlags, &type metadata for AWDLActionFrame.RealtimeGroup.AdditionalFlags);
    atomic_store(result, (unint64_t *)&qword_1004074C8);
  }
  return result;
}

unint64_t sub_1000E8390()
{
  unint64_t result;

  result = qword_1004074D0;
  if (!qword_1004074D0)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.RealtimeGroup.AdditionalFlags, &type metadata for AWDLActionFrame.RealtimeGroup.AdditionalFlags);
    atomic_store(result, (unint64_t *)&qword_1004074D0);
  }
  return result;
}

unint64_t sub_1000E83D8()
{
  unint64_t result;

  result = qword_1004074D8;
  if (!qword_1004074D8)
  {
    result = swift_getWitnessTable("\r\b\n", &type metadata for AWDLActionFrame.RealtimeGroup.AdditionalFlags);
    atomic_store(result, (unint64_t *)&qword_1004074D8);
  }
  return result;
}

unint64_t sub_1000E8420()
{
  unint64_t result;

  result = qword_1004074E0;
  if (!qword_1004074E0)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.RealtimeGroup, &type metadata for AWDLActionFrame.RealtimeGroup);
    atomic_store(result, (unint64_t *)&qword_1004074E0);
  }
  return result;
}

unint64_t sub_1000E8468()
{
  unint64_t result;

  result = qword_1004074E8;
  if (!qword_1004074E8)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.ExtendedChannelSequence, &type metadata for AWDLActionFrame.ExtendedChannelSequence);
    atomic_store(result, (unint64_t *)&qword_1004074E8);
  }
  return result;
}

unint64_t sub_1000E84B0()
{
  unint64_t result;

  result = qword_1004074F0;
  if (!qword_1004074F0)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.PreferredChannels.PreferredChannel, &type metadata for AWDLActionFrame.PreferredChannels.PreferredChannel);
    atomic_store(result, (unint64_t *)&qword_1004074F0);
  }
  return result;
}

unint64_t sub_1000E84F8()
{
  unint64_t result;

  result = qword_1004074F8;
  if (!qword_1004074F8)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.PreferredChannels, &type metadata for AWDLActionFrame.PreferredChannels);
    atomic_store(result, (unint64_t *)&qword_1004074F8);
  }
  return result;
}

unint64_t sub_1000E8540()
{
  unint64_t result;

  result = qword_100407500;
  if (!qword_100407500)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.ProMode.Command, &type metadata for AWDLActionFrame.ProMode.Command);
    atomic_store(result, (unint64_t *)&qword_100407500);
  }
  return result;
}

unint64_t sub_1000E8588()
{
  unint64_t result;

  result = qword_100407508;
  if (!qword_100407508)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.ProMode.Flags, &type metadata for AWDLActionFrame.ProMode.Flags);
    atomic_store(result, (unint64_t *)&qword_100407508);
  }
  return result;
}

unint64_t sub_1000E85D0()
{
  unint64_t result;

  result = qword_100407510;
  if (!qword_100407510)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.ProMode.Flags, &type metadata for AWDLActionFrame.ProMode.Flags);
    atomic_store(result, (unint64_t *)&qword_100407510);
  }
  return result;
}

unint64_t sub_1000E8618()
{
  unint64_t result;

  result = qword_100407518;
  if (!qword_100407518)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.ProMode.Flags, &type metadata for AWDLActionFrame.ProMode.Flags);
    atomic_store(result, (unint64_t *)&qword_100407518);
  }
  return result;
}

unint64_t sub_1000E8660()
{
  unint64_t result;

  result = qword_100407520;
  if (!qword_100407520)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.ProMode.Flags, &type metadata for AWDLActionFrame.ProMode.Flags);
    atomic_store(result, (unint64_t *)&qword_100407520);
  }
  return result;
}

unint64_t sub_1000E86A8()
{
  unint64_t result;

  result = qword_100407528;
  if (!qword_100407528)
  {
    result = swift_getWitnessTable("e", &type metadata for AWDLActionFrame.ProMode);
    atomic_store(result, (unint64_t *)&qword_100407528);
  }
  return result;
}

unint64_t sub_1000E86F0()
{
  unint64_t result;

  result = qword_100407530;
  if (!qword_100407530)
  {
    result = swift_getWitnessTable("=", &type metadata for AWDLActionFrame.AirDrop.State);
    atomic_store(result, (unint64_t *)&qword_100407530);
  }
  return result;
}

unint64_t sub_1000E8738()
{
  unint64_t result;

  result = qword_100407538;
  if (!qword_100407538)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.AirDrop, &type metadata for AWDLActionFrame.AirDrop);
    atomic_store(result, (unint64_t *)&qword_100407538);
  }
  return result;
}

unint64_t sub_1000E8780()
{
  unint64_t result;

  result = qword_100407540;
  if (!qword_100407540)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.AWDLAttribute.AttributeType, &type metadata for AWDLActionFrame.AWDLAttribute.AttributeType);
    atomic_store(result, (unint64_t *)&qword_100407540);
  }
  return result;
}

uint64_t sub_1000E87C4()
{
  return sub_100011DE4(&qword_100407548, type metadata accessor for AWDLActionFrame.AWDLAttribute, (uint64_t)&protocol conformance descriptor for AWDLActionFrame.AWDLAttribute);
}

unint64_t sub_1000E87F4()
{
  unint64_t result;

  result = qword_100407550;
  if (!qword_100407550)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame, &type metadata for AWDLActionFrame);
    atomic_store(result, (unint64_t *)&qword_100407550);
  }
  return result;
}

unint64_t sub_1000E883C()
{
  unint64_t result;

  result = qword_100407558;
  if (!qword_100407558)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.Header.Flags, &type metadata for AWDLActionFrame.Header.Flags);
    atomic_store(result, (unint64_t *)&qword_100407558);
  }
  return result;
}

unint64_t sub_1000E8884()
{
  unint64_t result;

  result = qword_100407560;
  if (!qword_100407560)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.Header.Flags, &type metadata for AWDLActionFrame.Header.Flags);
    atomic_store(result, (unint64_t *)&qword_100407560);
  }
  return result;
}

unint64_t sub_1000E88CC()
{
  unint64_t result;

  result = qword_100407568;
  if (!qword_100407568)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.Header.Flags, &type metadata for AWDLActionFrame.Header.Flags);
    atomic_store(result, (unint64_t *)&qword_100407568);
  }
  return result;
}

unint64_t sub_1000E8914()
{
  unint64_t result;

  result = qword_100407570;
  if (!qword_100407570)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.Header.Flags, &type metadata for AWDLActionFrame.Header.Flags);
    atomic_store(result, (unint64_t *)&qword_100407570);
  }
  return result;
}

uint64_t sub_1000E8958()
{
  return sub_100011DE4(&qword_100407578, type metadata accessor for AWDLActionFrame.Header, (uint64_t)&protocol conformance descriptor for AWDLActionFrame.Header);
}

uint64_t sub_1000E8988(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_BYTE *)(a1 + 1) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)(a1 + 2) = *(_BYTE *)(a2 + 2);
  *(_QWORD *)(a1 + 4) = *(_QWORD *)(a2 + 4);
  v3 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 16) = v3;
  swift_bridgeObjectRetain(v3);
  return a1;
}

uint64_t assignWithCopy for AWDLActionFrame(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_BYTE *)(a1 + 1) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)(a1 + 2) = *(_BYTE *)(a2 + 2);
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  v3 = *(_QWORD *)(a2 + 16);
  v4 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v3;
  swift_bridgeObjectRetain(v3);
  swift_bridgeObjectRelease(v4);
  return a1;
}

uint64_t assignWithTake for AWDLActionFrame(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_BYTE *)(a1 + 1) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)(a1 + 2) = *(_BYTE *)(a2 + 2);
  *(_QWORD *)(a1 + 4) = *(_QWORD *)(a2 + 4);
  v3 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  swift_bridgeObjectRelease(v3);
  return a1;
}

ValueMetadata *type metadata accessor for AWDLActionFrame()
{
  return &type metadata for AWDLActionFrame;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.OUIType()
{
  return &type metadata for AWDLActionFrame.OUIType;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.OUISubtype()
{
  return &type metadata for AWDLActionFrame.OUISubtype;
}

uint64_t initializeBufferWithCopyOfBuffer for Channel.ChannelBitmap(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  *(_DWORD *)a1 = *(_DWORD *)a2;
  v3 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 8) = v3;
  swift_bridgeObjectRetain(v3);
  return a1;
}

uint64_t assignWithCopy for AWDLActionFrame.ServiceRequest(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;

  *(_WORD *)a1 = *(_WORD *)a2;
  *(_WORD *)(a1 + 2) = *(_WORD *)(a2 + 2);
  v3 = *(_QWORD *)(a2 + 8);
  v4 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = v3;
  swift_bridgeObjectRetain(v3);
  swift_bridgeObjectRelease(v4);
  return a1;
}

uint64_t assignWithTake for AWDLActionFrame.ServiceRequest(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  *(_DWORD *)a1 = *(_DWORD *)a2;
  v3 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  swift_bridgeObjectRelease(v3);
  return a1;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.ServiceRequest()
{
  return &type metadata for AWDLActionFrame.ServiceRequest;
}

uint64_t initializeBufferWithCopyOfBuffer for AWDLActionFrame.ServiceResponse(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  int v5;
  int EnumCaseMultiPayload;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void (*v23)(uint64_t, uint64_t, uint64_t);
  uint64_t v24;
  _QWORD *v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  v5 = *(_DWORD *)(*(_QWORD *)(a3 - 8) + 80);
  if ((v5 & 0x20000) != 0)
  {
    v15 = *a2;
    *(_QWORD *)a1 = *a2;
    a1 = v15 + ((v5 + 16) & ~(unint64_t)v5);
    swift_retain();
  }
  else
  {
    EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(a2, a3);
    if (EnumCaseMultiPayload == 2)
    {
      v16 = a2[1];
      *(_QWORD *)a1 = *a2;
      *(_QWORD *)(a1 + 8) = v16;
      v17 = a2[3];
      *(_QWORD *)(a1 + 16) = a2[2];
      *(_QWORD *)(a1 + 24) = v17;
      *(_BYTE *)(a1 + 32) = *((_BYTE *)a2 + 32);
      *(_BYTE *)(a1 + 33) = *((_BYTE *)a2 + 33);
      v18 = (int *)type metadata accessor for DNSRecords.SRV(0);
      v19 = v18[5];
      v20 = a1 + v19;
      v21 = (uint64_t)a2 + v19;
      v22 = type metadata accessor for NWEndpoint.Port(0);
      v23 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v22 - 8) + 16);
      swift_bridgeObjectRetain(v16);
      swift_bridgeObjectRetain(v17);
      v23(v20, v21, v22);
      v24 = v18[6];
      v25 = (_QWORD *)(a1 + v24);
      v26 = (uint64_t *)((char *)a2 + v24);
      v27 = v26[1];
      *v25 = *v26;
      v25[1] = v27;
      *(_WORD *)(a1 + v18[7]) = *(_WORD *)((char *)a2 + v18[7]);
      *(_WORD *)(a1 + v18[8]) = *(_WORD *)((char *)a2 + v18[8]);
      swift_bridgeObjectRetain(v27);
      v12 = a1;
      v13 = a3;
      v14 = 2;
    }
    else if (EnumCaseMultiPayload == 1)
    {
      v8 = a2[1];
      *(_QWORD *)a1 = *a2;
      *(_QWORD *)(a1 + 8) = v8;
      v9 = a2[3];
      *(_QWORD *)(a1 + 16) = a2[2];
      *(_QWORD *)(a1 + 24) = v9;
      *(_BYTE *)(a1 + 32) = *((_BYTE *)a2 + 32);
      *(_BYTE *)(a1 + 33) = *((_BYTE *)a2 + 33);
      v11 = a2[5];
      v10 = a2[6];
      swift_bridgeObjectRetain(v8);
      swift_bridgeObjectRetain(v9);
      sub_100031FEC(v11, v10);
      *(_QWORD *)(a1 + 40) = v11;
      *(_QWORD *)(a1 + 48) = v10;
      v12 = a1;
      v13 = a3;
      v14 = 1;
    }
    else
    {
      v28 = a2[1];
      *(_QWORD *)a1 = *a2;
      *(_QWORD *)(a1 + 8) = v28;
      v29 = a2[3];
      *(_QWORD *)(a1 + 16) = a2[2];
      *(_QWORD *)(a1 + 24) = v29;
      *(_BYTE *)(a1 + 32) = *((_BYTE *)a2 + 32);
      *(_BYTE *)(a1 + 33) = *((_BYTE *)a2 + 33);
      swift_bridgeObjectRetain(v28);
      swift_bridgeObjectRetain(v29);
      v12 = a1;
      v13 = a3;
      v14 = 0;
    }
    swift_storeEnumTagMultiPayload(v12, v13, v14);
  }
  return a1;
}

void destroy for AWDLActionFrame.ServiceResponse(_QWORD *a1, uint64_t a2)
{
  int EnumCaseMultiPayload;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;

  EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(a1, a2);
  if (EnumCaseMultiPayload == 2)
  {
    swift_bridgeObjectRelease(a1[1]);
    swift_bridgeObjectRelease(a1[3]);
    v5 = type metadata accessor for DNSRecords.SRV(0);
    v6 = (char *)a1 + *(int *)(v5 + 20);
    v7 = type metadata accessor for NWEndpoint.Port(0);
    (*(void (**)(char *, uint64_t))(*(_QWORD *)(v7 - 8) + 8))(v6, v7);
    v4 = *(_QWORD *)((char *)a1 + *(int *)(v5 + 24) + 8);
LABEL_6:
    swift_bridgeObjectRelease(v4);
    return;
  }
  if (EnumCaseMultiPayload != 1)
  {
    if (EnumCaseMultiPayload)
      return;
    swift_bridgeObjectRelease(a1[1]);
    v4 = a1[3];
    goto LABEL_6;
  }
  swift_bridgeObjectRelease(a1[1]);
  swift_bridgeObjectRelease(a1[3]);
  sub_10000E614(a1[5], a1[6]);
}

uint64_t initializeWithCopy for AWDLActionFrame.ServiceResponse(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t EnumCaseMultiPayload;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void (*v18)(uint64_t, uint64_t, uint64_t);
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v26;

  EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(a2, a3);
  v7 = EnumCaseMultiPayload;
  if ((_DWORD)EnumCaseMultiPayload == 2)
  {
    v12 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)a1 = *(_QWORD *)a2;
    *(_QWORD *)(a1 + 8) = v12;
    v13 = *(_QWORD *)(a2 + 24);
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
    *(_QWORD *)(a1 + 24) = v13;
    *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
    *(_BYTE *)(a1 + 33) = *(_BYTE *)(a2 + 33);
    v14 = (int *)type metadata accessor for DNSRecords.SRV(0);
    v15 = v14[5];
    v26 = a1 + v15;
    v16 = a2 + v15;
    v17 = type metadata accessor for NWEndpoint.Port(0);
    v18 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v17 - 8) + 16);
    swift_bridgeObjectRetain(v12);
    swift_bridgeObjectRetain(v13);
    v18(v26, v16, v17);
    v19 = v14[6];
    v20 = (_QWORD *)(a1 + v19);
    v21 = (_QWORD *)(a2 + v19);
    v22 = v21[1];
    *v20 = *v21;
    v20[1] = v22;
    *(_WORD *)(a1 + v14[7]) = *(_WORD *)(a2 + v14[7]);
    *(_WORD *)(a1 + v14[8]) = *(_WORD *)(a2 + v14[8]);
LABEL_6:
    swift_bridgeObjectRetain(v22);
    goto LABEL_7;
  }
  if ((_DWORD)EnumCaseMultiPayload != 1)
  {
    v23 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)a1 = *(_QWORD *)a2;
    *(_QWORD *)(a1 + 8) = v23;
    v24 = *(_QWORD *)(a2 + 24);
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
    *(_QWORD *)(a1 + 24) = v24;
    *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
    *(_BYTE *)(a1 + 33) = *(_BYTE *)(a2 + 33);
    swift_bridgeObjectRetain(v23);
    v22 = v24;
    goto LABEL_6;
  }
  v8 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = v8;
  v9 = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 24) = v9;
  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
  *(_BYTE *)(a1 + 33) = *(_BYTE *)(a2 + 33);
  v11 = *(_QWORD *)(a2 + 40);
  v10 = *(_QWORD *)(a2 + 48);
  swift_bridgeObjectRetain(v8);
  swift_bridgeObjectRetain(v9);
  sub_100031FEC(v11, v10);
  *(_QWORD *)(a1 + 40) = v11;
  *(_QWORD *)(a1 + 48) = v10;
LABEL_7:
  swift_storeEnumTagMultiPayload(a1, a3, v7);
  return a1;
}

uint64_t assignWithCopy for AWDLActionFrame.ServiceResponse(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t EnumCaseMultiPayload;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void (*v18)(uint64_t, uint64_t, uint64_t);
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v26;

  if (a1 != a2)
  {
    sub_100063824(a1, type metadata accessor for AWDLActionFrame.ServiceResponse);
    EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(a2, a3);
    v7 = EnumCaseMultiPayload;
    if ((_DWORD)EnumCaseMultiPayload == 2)
    {
      *(_QWORD *)a1 = *(_QWORD *)a2;
      v12 = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a1 + 8) = v12;
      *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
      v13 = *(_QWORD *)(a2 + 24);
      *(_QWORD *)(a1 + 24) = v13;
      *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
      *(_BYTE *)(a1 + 33) = *(_BYTE *)(a2 + 33);
      v14 = (int *)type metadata accessor for DNSRecords.SRV(0);
      v15 = v14[5];
      v26 = a1 + v15;
      v16 = a2 + v15;
      v17 = type metadata accessor for NWEndpoint.Port(0);
      v18 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v17 - 8) + 16);
      swift_bridgeObjectRetain(v12);
      swift_bridgeObjectRetain(v13);
      v18(v26, v16, v17);
      v19 = v14[6];
      v20 = (_QWORD *)(a1 + v19);
      v21 = (_QWORD *)(a2 + v19);
      *v20 = *v21;
      v22 = v21[1];
      v20[1] = v22;
      *(_WORD *)(a1 + v14[7]) = *(_WORD *)(a2 + v14[7]);
      *(_WORD *)(a1 + v14[8]) = *(_WORD *)(a2 + v14[8]);
    }
    else
    {
      if ((_DWORD)EnumCaseMultiPayload == 1)
      {
        *(_QWORD *)a1 = *(_QWORD *)a2;
        v8 = *(_QWORD *)(a2 + 8);
        *(_QWORD *)(a1 + 8) = v8;
        *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
        v9 = *(_QWORD *)(a2 + 24);
        *(_QWORD *)(a1 + 24) = v9;
        *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
        *(_BYTE *)(a1 + 33) = *(_BYTE *)(a2 + 33);
        v11 = *(_QWORD *)(a2 + 40);
        v10 = *(_QWORD *)(a2 + 48);
        swift_bridgeObjectRetain(v8);
        swift_bridgeObjectRetain(v9);
        sub_100031FEC(v11, v10);
        *(_QWORD *)(a1 + 40) = v11;
        *(_QWORD *)(a1 + 48) = v10;
LABEL_8:
        swift_storeEnumTagMultiPayload(a1, a3, v7);
        return a1;
      }
      *(_QWORD *)a1 = *(_QWORD *)a2;
      v23 = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a1 + 8) = v23;
      *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
      v24 = *(_QWORD *)(a2 + 24);
      *(_QWORD *)(a1 + 24) = v24;
      *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
      *(_BYTE *)(a1 + 33) = *(_BYTE *)(a2 + 33);
      swift_bridgeObjectRetain(v23);
      v22 = v24;
    }
    swift_bridgeObjectRetain(v22);
    goto LABEL_8;
  }
  return a1;
}

_OWORD *initializeWithTake for AWDLActionFrame.ServiceResponse(_OWORD *a1, _OWORD *a2, uint64_t a3)
{
  __int128 v6;
  int *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  uint64_t v11;

  if (swift_getEnumCaseMultiPayload(a2, a3) == 2)
  {
    v6 = a2[1];
    *a1 = *a2;
    a1[1] = v6;
    *((_WORD *)a1 + 16) = *((_WORD *)a2 + 16);
    v7 = (int *)type metadata accessor for DNSRecords.SRV(0);
    v8 = v7[5];
    v9 = (char *)a1 + v8;
    v10 = (char *)a2 + v8;
    v11 = type metadata accessor for NWEndpoint.Port(0);
    (*(void (**)(char *, char *, uint64_t))(*(_QWORD *)(v11 - 8) + 32))(v9, v10, v11);
    *(_OWORD *)((char *)a1 + v7[6]) = *(_OWORD *)((char *)a2 + v7[6]);
    *(_WORD *)((char *)a1 + v7[7]) = *(_WORD *)((char *)a2 + v7[7]);
    *(_WORD *)((char *)a1 + v7[8]) = *(_WORD *)((char *)a2 + v7[8]);
    swift_storeEnumTagMultiPayload(a1, a3, 2);
  }
  else
  {
    memcpy(a1, a2, *(_QWORD *)(*(_QWORD *)(a3 - 8) + 64));
  }
  return a1;
}

_OWORD *assignWithTake for AWDLActionFrame.ServiceResponse(_OWORD *a1, _OWORD *a2, uint64_t a3)
{
  __int128 v6;
  int *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  uint64_t v11;

  if (a1 != a2)
  {
    sub_100063824((uint64_t)a1, type metadata accessor for AWDLActionFrame.ServiceResponse);
    if (swift_getEnumCaseMultiPayload(a2, a3) == 2)
    {
      v6 = a2[1];
      *a1 = *a2;
      a1[1] = v6;
      *((_WORD *)a1 + 16) = *((_WORD *)a2 + 16);
      v7 = (int *)type metadata accessor for DNSRecords.SRV(0);
      v8 = v7[5];
      v9 = (char *)a1 + v8;
      v10 = (char *)a2 + v8;
      v11 = type metadata accessor for NWEndpoint.Port(0);
      (*(void (**)(char *, char *, uint64_t))(*(_QWORD *)(v11 - 8) + 32))(v9, v10, v11);
      *(_OWORD *)((char *)a1 + v7[6]) = *(_OWORD *)((char *)a2 + v7[6]);
      *(_WORD *)((char *)a1 + v7[7]) = *(_WORD *)((char *)a2 + v7[7]);
      *(_WORD *)((char *)a1 + v7[8]) = *(_WORD *)((char *)a2 + v7[8]);
      swift_storeEnumTagMultiPayload(a1, a3, 2);
    }
    else
    {
      memcpy(a1, a2, *(_QWORD *)(*(_QWORD *)(a3 - 8) + 64));
    }
  }
  return a1;
}

uint64_t sub_1000E9370(uint64_t a1)
{
  uint64_t result;
  unint64_t v3;
  _QWORD v4[3];

  v4[0] = "\"";
  v4[1] = &unk_100343C68;
  result = type metadata accessor for DNSRecords.SRV(319);
  if (v3 <= 0x3F)
  {
    v4[2] = *(_QWORD *)(result - 8) + 64;
    swift_initEnumMetadataMultiPayload(a1, 256, 3, v4);
    return 0;
  }
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.AWDLChannelSequenceParameter()
{
  return &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter;
}

uint64_t destroy for AWDLActionFrame.SynchronizationParameter(uint64_t a1)
{
  return swift_bridgeObjectRelease(*(_QWORD *)(a1 + 40));
}

uint64_t initializeWithCopy for AWDLActionFrame.SynchronizationParameter(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_DWORD *)(a1 + 2) = *(_DWORD *)(a2 + 2);
  *(_QWORD *)(a1 + 6) = *(_QWORD *)(a2 + 6);
  *(_DWORD *)(a1 + 14) = *(_DWORD *)(a2 + 14);
  *(_DWORD *)(a1 + 18) = *(_DWORD *)(a2 + 18);
  *(_QWORD *)(a1 + 22) = *(_QWORD *)(a2 + 22);
  *(_DWORD *)(a1 + 30) = *(_DWORD *)(a2 + 30);
  v3 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 40) = v3;
  swift_bridgeObjectRetain(v3);
  return a1;
}

uint64_t assignWithCopy for AWDLActionFrame.SynchronizationParameter(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_WORD *)(a1 + 2) = *(_WORD *)(a2 + 2);
  *(_BYTE *)(a1 + 4) = *(_BYTE *)(a2 + 4);
  *(_BYTE *)(a1 + 5) = *(_BYTE *)(a2 + 5);
  *(_WORD *)(a1 + 6) = *(_WORD *)(a2 + 6);
  *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 8);
  *(_WORD *)(a1 + 10) = *(_WORD *)(a2 + 10);
  *(_WORD *)(a1 + 12) = *(_WORD *)(a2 + 12);
  *(_WORD *)(a1 + 14) = *(_WORD *)(a2 + 14);
  *(_WORD *)(a1 + 16) = *(_WORD *)(a2 + 16);
  *(_BYTE *)(a1 + 18) = *(_BYTE *)(a2 + 18);
  *(_BYTE *)(a1 + 19) = *(_BYTE *)(a2 + 19);
  *(_BYTE *)(a1 + 20) = *(_BYTE *)(a2 + 20);
  *(_BYTE *)(a1 + 21) = *(_BYTE *)(a2 + 21);
  *(_BYTE *)(a1 + 22) = *(_BYTE *)(a2 + 22);
  *(_BYTE *)(a1 + 23) = *(_BYTE *)(a2 + 23);
  *(_BYTE *)(a1 + 24) = *(_BYTE *)(a2 + 24);
  *(_BYTE *)(a1 + 25) = *(_BYTE *)(a2 + 25);
  *(_BYTE *)(a1 + 26) = *(_BYTE *)(a2 + 26);
  *(_BYTE *)(a1 + 27) = *(_BYTE *)(a2 + 27);
  *(_BYTE *)(a1 + 28) = *(_BYTE *)(a2 + 28);
  *(_BYTE *)(a1 + 29) = *(_BYTE *)(a2 + 29);
  *(_WORD *)(a1 + 30) = *(_WORD *)(a2 + 30);
  *(_WORD *)(a1 + 32) = *(_WORD *)(a2 + 32);
  v3 = *(_QWORD *)(a2 + 40);
  v4 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = v3;
  swift_bridgeObjectRetain(v3);
  swift_bridgeObjectRelease(v4);
  return a1;
}

uint64_t assignWithTake for AWDLActionFrame.SynchronizationParameter(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_DWORD *)(a1 + 2) = *(_DWORD *)(a2 + 2);
  *(_QWORD *)(a1 + 6) = *(_QWORD *)(a2 + 6);
  *(_DWORD *)(a1 + 14) = *(_DWORD *)(a2 + 14);
  *(_QWORD *)(a1 + 18) = *(_QWORD *)(a2 + 18);
  *(_DWORD *)(a1 + 26) = *(_DWORD *)(a2 + 26);
  *(_DWORD *)(a1 + 30) = *(_DWORD *)(a2 + 30);
  v3 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  swift_bridgeObjectRelease(v3);
  return a1;
}

uint64_t getEnumTagSinglePayload for AWDLActionFrame.SynchronizationParameter(uint64_t a1, int a2)
{
  unint64_t v2;

  if (!a2)
    return 0;
  if (a2 < 0 && *(_BYTE *)(a1 + 48))
    return *(_DWORD *)a1 + 0x80000000;
  v2 = *(_QWORD *)(a1 + 40);
  if (v2 >= 0xFFFFFFFF)
    LODWORD(v2) = -1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for AWDLActionFrame.SynchronizationParameter(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_QWORD *)(result + 40) = 0;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_QWORD *)result = a2 ^ 0x80000000;
    if (a3 < 0)
      *(_BYTE *)(result + 48) = 1;
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
        return result;
LABEL_8:
      *(_QWORD *)(result + 40) = (a2 - 1);
      return result;
    }
    *(_BYTE *)(result + 48) = 0;
    if (a2)
      goto LABEL_8;
  }
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.SynchronizationParameter()
{
  return &type metadata for AWDLActionFrame.SynchronizationParameter;
}

__n128 initializeWithCopy for AWDLActionFrame.DeprecatedElectionParameter(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)a2;
  *(_OWORD *)(a1 + 9) = *(_OWORD *)(a2 + 9);
  *(__n128 *)a1 = result;
  return result;
}

uint64_t getEnumTagSinglePayload for AWDLActionFrame.DeprecatedElectionParameter(uint64_t a1, int a2)
{
  if (a2 && *(_BYTE *)(a1 + 25))
    return (*(_DWORD *)a1 + 1);
  else
    return 0;
}

uint64_t storeEnumTagSinglePayload for AWDLActionFrame.DeprecatedElectionParameter(uint64_t result, int a2, int a3)
{
  char v3;

  if (a2)
  {
    *(_QWORD *)(result + 8) = 0;
    *(_QWORD *)(result + 16) = 0;
    *(_BYTE *)(result + 24) = 0;
    *(_QWORD *)result = (a2 - 1);
    if (!a3)
      return result;
    v3 = 1;
  }
  else
  {
    if (!a3)
      return result;
    v3 = 0;
  }
  *(_BYTE *)(result + 25) = v3;
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.DeprecatedElectionParameter()
{
  return &type metadata for AWDLActionFrame.DeprecatedElectionParameter;
}

uint64_t initializeWithCopy for AWDLActionFrame.ServiceParameter(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_DWORD *)(a1 + 2) = *(_DWORD *)(a2 + 2);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  v3 = *(_QWORD *)(a2 + 16);
  v4 = *(_QWORD *)(a2 + 24);
  sub_100031FEC(v3, v4);
  *(_QWORD *)(a1 + 16) = v3;
  *(_QWORD *)(a1 + 24) = v4;
  return a1;
}

uint64_t assignWithCopy for AWDLActionFrame.ServiceParameter(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_WORD *)(a1 + 2) = *(_WORD *)(a2 + 2);
  *(_WORD *)(a1 + 4) = *(_WORD *)(a2 + 4);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  v3 = *(_QWORD *)(a2 + 16);
  v4 = *(_QWORD *)(a2 + 24);
  sub_100031FEC(v3, v4);
  v5 = *(_QWORD *)(a1 + 16);
  v6 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 16) = v3;
  *(_QWORD *)(a1 + 24) = v4;
  sub_10000E614(v5, v6);
  return a1;
}

uint64_t assignWithTake for AWDLActionFrame.ServiceParameter(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_DWORD *)(a1 + 2) = *(_DWORD *)(a2 + 2);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  v4 = *(_QWORD *)(a1 + 24);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  sub_10000E614(v3, v4);
  return a1;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.ServiceParameter()
{
  return &type metadata for AWDLActionFrame.ServiceParameter;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.ServiceParameter.Flags()
{
  return &type metadata for AWDLActionFrame.ServiceParameter.Flags;
}

uint64_t sub_1000E9808(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;

  *(_DWORD *)a1 = *(_DWORD *)a2;
  v3 = *(_QWORD *)(a2 + 8);
  v4 = *(_QWORD *)(a2 + 16);
  sub_100031FEC(v3, v4);
  *(_QWORD *)(a1 + 8) = v3;
  *(_QWORD *)(a1 + 16) = v4;
  return a1;
}

uint64_t assignWithCopy for AWDLActionFrame.ServiceParameter.SSTH(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;

  *(_DWORD *)a1 = *(_DWORD *)a2;
  v3 = *(_QWORD *)(a2 + 8);
  v4 = *(_QWORD *)(a2 + 16);
  sub_100031FEC(v3, v4);
  v5 = *(_QWORD *)(a1 + 8);
  v6 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 8) = v3;
  *(_QWORD *)(a1 + 16) = v4;
  sub_10000E614(v5, v6);
  return a1;
}

uint64_t assignWithTake for AWDLActionFrame.ServiceParameter.SSTH(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;

  *(_DWORD *)a1 = *(_DWORD *)a2;
  v3 = *(_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 16);
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  sub_10000E614(v3, v4);
  return a1;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.ServiceParameter.SSTH()
{
  return &type metadata for AWDLActionFrame.ServiceParameter.SSTH;
}

_QWORD *initializeBufferWithCopyOfBuffer for AWDLActionFrame.DataPathState(uint64_t a1, uint64_t *a2, int *a3)
{
  _QWORD *v4;
  int v5;
  int v7;
  uint64_t v8;
  int v9;
  __int128 v10;
  uint64_t v11;
  void *v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int (*v16)(const void *, uint64_t, uint64_t);
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;

  v4 = (_QWORD *)a1;
  v5 = *(_DWORD *)(*((_QWORD *)a3 - 1) + 80);
  if ((v5 & 0x20000) != 0)
  {
    v18 = *a2;
    *v4 = *a2;
    v4 = (_QWORD *)(v18 + ((v5 + 16) & ~(unint64_t)v5));
    swift_retain();
  }
  else
  {
    *(_WORD *)a1 = *(_WORD *)a2;
    *(_BYTE *)(a1 + 2) = *((_BYTE *)a2 + 2);
    *(_DWORD *)(a1 + 4) = *((_DWORD *)a2 + 1);
    *(_WORD *)(a1 + 8) = *((_WORD *)a2 + 4);
    *(_DWORD *)(a1 + 10) = *(_DWORD *)((char *)a2 + 10);
    *(_DWORD *)(a1 + 13) = *(_DWORD *)((char *)a2 + 13);
    *(_WORD *)(a1 + 24) = *((_WORD *)a2 + 12);
    *(_DWORD *)(a1 + 20) = *((_DWORD *)a2 + 5);
    v7 = *(_DWORD *)((char *)a2 + 26);
    *(_DWORD *)(a1 + 29) = *(_DWORD *)((char *)a2 + 29);
    *(_DWORD *)(a1 + 26) = v7;
    v8 = a2[6];
    *(_QWORD *)(a1 + 40) = a2[5];
    *(_QWORD *)(a1 + 48) = v8;
    *(_DWORD *)(a1 + 56) = *((_DWORD *)a2 + 14);
    *(_DWORD *)(a1 + 59) = *(_DWORD *)((char *)a2 + 59);
    *(_BYTE *)(a1 + 63) = *((_BYTE *)a2 + 63);
    *(_DWORD *)(a1 + 64) = *((_DWORD *)a2 + 16);
    *(_BYTE *)(a1 + 68) = *((_BYTE *)a2 + 68);
    v9 = *((_DWORD *)a2 + 18);
    *(_BYTE *)(a1 + 76) = *((_BYTE *)a2 + 76);
    *(_DWORD *)(a1 + 72) = v9;
    v10 = *(_OWORD *)((char *)a2 + 77);
    *(_WORD *)(a1 + 93) = *(_WORD *)((char *)a2 + 93);
    v11 = a3[34];
    v12 = (void *)(a1 + v11);
    v13 = (char *)a2 + v11;
    *(_OWORD *)(a1 + 77) = v10;
    v14 = type metadata accessor for DispatchTimeInterval(0);
    v15 = *(_QWORD *)(v14 - 8);
    v16 = *(unsigned int (**)(const void *, uint64_t, uint64_t))(v15 + 48);
    swift_bridgeObjectRetain(v8);
    if (v16(v13, 1, v14))
    {
      v17 = sub_100012C44(&qword_100407210);
      memcpy(v12, v13, *(_QWORD *)(*(_QWORD *)(v17 - 8) + 64));
    }
    else
    {
      (*(void (**)(void *, char *, uint64_t))(v15 + 16))(v12, v13, v14);
      (*(void (**)(void *, _QWORD, uint64_t, uint64_t))(v15 + 56))(v12, 0, 1, v14);
    }
    v19 = a3[35];
    v20 = a3[36];
    v21 = (char *)v4 + v19;
    v22 = (uint64_t)a2 + v19;
    *(_DWORD *)v21 = *(_DWORD *)v22;
    v21[4] = *(_BYTE *)(v22 + 4);
    v23 = (char *)v4 + v20;
    v24 = (uint64_t)a2 + v20;
    *(_DWORD *)v23 = *(_DWORD *)v24;
    v23[4] = *(_BYTE *)(v24 + 4);
  }
  return v4;
}

uint64_t destroy for AWDLActionFrame.DataPathState(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;

  swift_bridgeObjectRelease(*(_QWORD *)(a1 + 48));
  v4 = a1 + *(int *)(a2 + 136);
  v5 = type metadata accessor for DispatchTimeInterval(0);
  v6 = *(_QWORD *)(v5 - 8);
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v6 + 48))(v4, 1, v5);
  if (!(_DWORD)result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 8))(v4, v5);
  return result;
}

uint64_t initializeWithCopy for AWDLActionFrame.DataPathState(uint64_t a1, uint64_t a2, int *a3)
{
  int v6;
  uint64_t v7;
  int v8;
  __int128 v9;
  uint64_t v10;
  void *v11;
  const void *v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int (*v15)(const void *, uint64_t, uint64_t);
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  *(_WORD *)a1 = *(_WORD *)a2;
  *(_BYTE *)(a1 + 2) = *(_BYTE *)(a2 + 2);
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 8);
  *(_DWORD *)(a1 + 10) = *(_DWORD *)(a2 + 10);
  *(_DWORD *)(a1 + 13) = *(_DWORD *)(a2 + 13);
  *(_WORD *)(a1 + 24) = *(_WORD *)(a2 + 24);
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 20);
  v6 = *(_DWORD *)(a2 + 26);
  *(_DWORD *)(a1 + 29) = *(_DWORD *)(a2 + 29);
  *(_DWORD *)(a1 + 26) = v6;
  v7 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 48) = v7;
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(a1 + 59) = *(_DWORD *)(a2 + 59);
  *(_BYTE *)(a1 + 63) = *(_BYTE *)(a2 + 63);
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 64);
  *(_BYTE *)(a1 + 68) = *(_BYTE *)(a2 + 68);
  v8 = *(_DWORD *)(a2 + 72);
  *(_BYTE *)(a1 + 76) = *(_BYTE *)(a2 + 76);
  *(_DWORD *)(a1 + 72) = v8;
  v9 = *(_OWORD *)(a2 + 77);
  *(_WORD *)(a1 + 93) = *(_WORD *)(a2 + 93);
  v10 = a3[34];
  v11 = (void *)(a1 + v10);
  v12 = (const void *)(a2 + v10);
  *(_OWORD *)(a1 + 77) = v9;
  v13 = type metadata accessor for DispatchTimeInterval(0);
  v14 = *(_QWORD *)(v13 - 8);
  v15 = *(unsigned int (**)(const void *, uint64_t, uint64_t))(v14 + 48);
  swift_bridgeObjectRetain(v7);
  if (v15(v12, 1, v13))
  {
    v16 = sub_100012C44(&qword_100407210);
    memcpy(v11, v12, *(_QWORD *)(*(_QWORD *)(v16 - 8) + 64));
  }
  else
  {
    (*(void (**)(void *, const void *, uint64_t))(v14 + 16))(v11, v12, v13);
    (*(void (**)(void *, _QWORD, uint64_t, uint64_t))(v14 + 56))(v11, 0, 1, v13);
  }
  v17 = a3[35];
  v18 = a3[36];
  v19 = a1 + v17;
  v20 = a2 + v17;
  *(_DWORD *)v19 = *(_DWORD *)v20;
  *(_BYTE *)(v19 + 4) = *(_BYTE *)(v20 + 4);
  v21 = a1 + v18;
  v22 = a2 + v18;
  *(_DWORD *)v21 = *(_DWORD *)v22;
  *(_BYTE *)(v21 + 4) = *(_BYTE *)(v22 + 4);
  return a1;
}

uint64_t assignWithCopy for AWDLActionFrame.DataPathState(uint64_t a1, __int16 *a2, int *a3)
{
  __int16 v6;
  int v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  void *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t (*v20)(void *, uint64_t, uint64_t);
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int *v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  int *v30;
  int v31;

  v6 = *a2;
  *(_BYTE *)(a1 + 2) = *((_BYTE *)a2 + 2);
  *(_WORD *)a1 = v6;
  v7 = *((_DWORD *)a2 + 1);
  *(_WORD *)(a1 + 8) = a2[4];
  *(_DWORD *)(a1 + 4) = v7;
  v8 = *(_DWORD *)(a2 + 5);
  *(_DWORD *)(a1 + 13) = *(_DWORD *)((char *)a2 + 13);
  *(_DWORD *)(a1 + 10) = v8;
  v9 = *((_DWORD *)a2 + 5);
  *(_WORD *)(a1 + 24) = a2[12];
  *(_DWORD *)(a1 + 20) = v9;
  v10 = *(_DWORD *)(a2 + 13);
  *(_DWORD *)(a1 + 29) = *(_DWORD *)((char *)a2 + 29);
  *(_DWORD *)(a1 + 26) = v10;
  *(_QWORD *)(a1 + 40) = *((_QWORD *)a2 + 5);
  v11 = *((_QWORD *)a2 + 6);
  v12 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 48) = v11;
  swift_bridgeObjectRetain(v11);
  swift_bridgeObjectRelease(v12);
  v13 = *((_DWORD *)a2 + 14);
  *(_DWORD *)(a1 + 59) = *(_DWORD *)((char *)a2 + 59);
  *(_DWORD *)(a1 + 56) = v13;
  *(_BYTE *)(a1 + 63) = *((_BYTE *)a2 + 63);
  *(_BYTE *)(a1 + 64) = *((_BYTE *)a2 + 64);
  *(_BYTE *)(a1 + 65) = *((_BYTE *)a2 + 65);
  LOWORD(v13) = a2[33];
  *(_BYTE *)(a1 + 68) = *((_BYTE *)a2 + 68);
  *(_WORD *)(a1 + 66) = v13;
  v14 = *((_DWORD *)a2 + 18);
  *(_BYTE *)(a1 + 76) = *((_BYTE *)a2 + 76);
  *(_DWORD *)(a1 + 72) = v14;
  *(_BYTE *)(a1 + 77) = *((_BYTE *)a2 + 77);
  *(_BYTE *)(a1 + 78) = *((_BYTE *)a2 + 78);
  *(_BYTE *)(a1 + 79) = *((_BYTE *)a2 + 79);
  *(_BYTE *)(a1 + 80) = *((_BYTE *)a2 + 80);
  *(_BYTE *)(a1 + 81) = *((_BYTE *)a2 + 81);
  *(_BYTE *)(a1 + 82) = *((_BYTE *)a2 + 82);
  *(_BYTE *)(a1 + 83) = *((_BYTE *)a2 + 83);
  *(_BYTE *)(a1 + 84) = *((_BYTE *)a2 + 84);
  *(_BYTE *)(a1 + 85) = *((_BYTE *)a2 + 85);
  *(_BYTE *)(a1 + 86) = *((_BYTE *)a2 + 86);
  *(_BYTE *)(a1 + 87) = *((_BYTE *)a2 + 87);
  *(_BYTE *)(a1 + 88) = *((_BYTE *)a2 + 88);
  *(_BYTE *)(a1 + 89) = *((_BYTE *)a2 + 89);
  *(_BYTE *)(a1 + 90) = *((_BYTE *)a2 + 90);
  *(_BYTE *)(a1 + 91) = *((_BYTE *)a2 + 91);
  *(_BYTE *)(a1 + 92) = *((_BYTE *)a2 + 92);
  *(_BYTE *)(a1 + 93) = *((_BYTE *)a2 + 93);
  *(_BYTE *)(a1 + 94) = *((_BYTE *)a2 + 94);
  v15 = a3[34];
  v16 = (void *)(a1 + v15);
  v17 = (char *)a2 + v15;
  v18 = type metadata accessor for DispatchTimeInterval(0);
  v19 = *(_QWORD *)(v18 - 8);
  v20 = *(uint64_t (**)(void *, uint64_t, uint64_t))(v19 + 48);
  v21 = v20(v16, 1, v18);
  v22 = v20(v17, 1, v18);
  if (!v21)
  {
    if (!v22)
    {
      (*(void (**)(void *, char *, uint64_t))(v19 + 24))(v16, v17, v18);
      goto LABEL_7;
    }
    (*(void (**)(void *, uint64_t))(v19 + 8))(v16, v18);
    goto LABEL_6;
  }
  if (v22)
  {
LABEL_6:
    v23 = sub_100012C44(&qword_100407210);
    memcpy(v16, v17, *(_QWORD *)(*(_QWORD *)(v23 - 8) + 64));
    goto LABEL_7;
  }
  (*(void (**)(void *, char *, uint64_t))(v19 + 16))(v16, v17, v18);
  (*(void (**)(void *, _QWORD, uint64_t, uint64_t))(v19 + 56))(v16, 0, 1, v18);
LABEL_7:
  v24 = a3[35];
  v25 = a1 + v24;
  v26 = (int *)((char *)a2 + v24);
  v27 = *v26;
  *(_BYTE *)(v25 + 4) = *((_BYTE *)v26 + 4);
  *(_DWORD *)v25 = v27;
  v28 = a3[36];
  v29 = a1 + v28;
  v30 = (int *)((char *)a2 + v28);
  v31 = *v30;
  *(_BYTE *)(v29 + 4) = *((_BYTE *)v30 + 4);
  *(_DWORD *)v29 = v31;
  return a1;
}

uint64_t initializeWithTake for AWDLActionFrame.DataPathState(uint64_t a1, uint64_t a2, int *a3)
{
  int v6;
  __int128 v7;
  uint64_t v8;
  void *v9;
  const void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  *(_WORD *)a1 = *(_WORD *)a2;
  *(_BYTE *)(a1 + 2) = *(_BYTE *)(a2 + 2);
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 8);
  *(_DWORD *)(a1 + 10) = *(_DWORD *)(a2 + 10);
  *(_DWORD *)(a1 + 13) = *(_DWORD *)(a2 + 13);
  *(_WORD *)(a1 + 24) = *(_WORD *)(a2 + 24);
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 20);
  v6 = *(_DWORD *)(a2 + 26);
  *(_DWORD *)(a1 + 29) = *(_DWORD *)(a2 + 29);
  *(_DWORD *)(a1 + 26) = v6;
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(a1 + 59) = *(_DWORD *)(a2 + 59);
  *(_BYTE *)(a1 + 63) = *(_BYTE *)(a2 + 63);
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 64);
  *(_BYTE *)(a1 + 68) = *(_BYTE *)(a2 + 68);
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
  *(_BYTE *)(a1 + 76) = *(_BYTE *)(a2 + 76);
  v7 = *(_OWORD *)(a2 + 77);
  *(_WORD *)(a1 + 93) = *(_WORD *)(a2 + 93);
  v8 = a3[34];
  v9 = (void *)(a1 + v8);
  v10 = (const void *)(a2 + v8);
  *(_OWORD *)(a1 + 77) = v7;
  v11 = type metadata accessor for DispatchTimeInterval(0);
  v12 = *(_QWORD *)(v11 - 8);
  if ((*(unsigned int (**)(const void *, uint64_t, uint64_t))(v12 + 48))(v10, 1, v11))
  {
    v13 = sub_100012C44(&qword_100407210);
    memcpy(v9, v10, *(_QWORD *)(*(_QWORD *)(v13 - 8) + 64));
  }
  else
  {
    (*(void (**)(void *, const void *, uint64_t))(v12 + 32))(v9, v10, v11);
    (*(void (**)(void *, _QWORD, uint64_t, uint64_t))(v12 + 56))(v9, 0, 1, v11);
  }
  v14 = a3[35];
  v15 = a3[36];
  v16 = a1 + v14;
  v17 = a2 + v14;
  *(_DWORD *)v16 = *(_DWORD *)v17;
  *(_BYTE *)(v16 + 4) = *(_BYTE *)(v17 + 4);
  v18 = a1 + v15;
  v19 = a2 + v15;
  *(_DWORD *)v18 = *(_DWORD *)v19;
  *(_BYTE *)(v18 + 4) = *(_BYTE *)(v19 + 4);
  return a1;
}

uint64_t assignWithTake for AWDLActionFrame.DataPathState(uint64_t a1, uint64_t a2, int *a3)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t (*v14)(void *, uint64_t, uint64_t);
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  *(_WORD *)a1 = *(_WORD *)a2;
  *(_BYTE *)(a1 + 2) = *(_BYTE *)(a2 + 2);
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 8);
  *(_DWORD *)(a1 + 10) = *(_DWORD *)(a2 + 10);
  *(_DWORD *)(a1 + 13) = *(_DWORD *)(a2 + 13);
  *(_WORD *)(a1 + 24) = *(_WORD *)(a2 + 24);
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 20);
  v6 = *(_DWORD *)(a2 + 26);
  *(_DWORD *)(a1 + 29) = *(_DWORD *)(a2 + 29);
  *(_DWORD *)(a1 + 26) = v6;
  v7 = *(_QWORD *)(a2 + 48);
  v8 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 48) = v7;
  swift_bridgeObjectRelease(v8);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(a1 + 59) = *(_DWORD *)(a2 + 59);
  *(_BYTE *)(a1 + 63) = *(_BYTE *)(a2 + 63);
  *(_BYTE *)(a1 + 64) = *(_BYTE *)(a2 + 64);
  *(_BYTE *)(a1 + 65) = *(_BYTE *)(a2 + 65);
  *(_WORD *)(a1 + 66) = *(_WORD *)(a2 + 66);
  *(_BYTE *)(a1 + 68) = *(_BYTE *)(a2 + 68);
  *(_BYTE *)(a1 + 76) = *(_BYTE *)(a2 + 76);
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
  *(_BYTE *)(a1 + 77) = *(_BYTE *)(a2 + 77);
  *(_BYTE *)(a1 + 78) = *(_BYTE *)(a2 + 78);
  *(_BYTE *)(a1 + 79) = *(_BYTE *)(a2 + 79);
  *(_BYTE *)(a1 + 80) = *(_BYTE *)(a2 + 80);
  *(_BYTE *)(a1 + 81) = *(_BYTE *)(a2 + 81);
  *(_BYTE *)(a1 + 82) = *(_BYTE *)(a2 + 82);
  *(_BYTE *)(a1 + 83) = *(_BYTE *)(a2 + 83);
  *(_BYTE *)(a1 + 84) = *(_BYTE *)(a2 + 84);
  *(_BYTE *)(a1 + 85) = *(_BYTE *)(a2 + 85);
  *(_BYTE *)(a1 + 86) = *(_BYTE *)(a2 + 86);
  *(_BYTE *)(a1 + 87) = *(_BYTE *)(a2 + 87);
  *(_BYTE *)(a1 + 88) = *(_BYTE *)(a2 + 88);
  *(_BYTE *)(a1 + 89) = *(_BYTE *)(a2 + 89);
  *(_BYTE *)(a1 + 90) = *(_BYTE *)(a2 + 90);
  *(_BYTE *)(a1 + 91) = *(_BYTE *)(a2 + 91);
  *(_BYTE *)(a1 + 92) = *(_BYTE *)(a2 + 92);
  *(_BYTE *)(a1 + 93) = *(_BYTE *)(a2 + 93);
  *(_BYTE *)(a1 + 94) = *(_BYTE *)(a2 + 94);
  v9 = a3[34];
  v10 = (void *)(a1 + v9);
  v11 = (void *)(a2 + v9);
  v12 = type metadata accessor for DispatchTimeInterval(0);
  v13 = *(_QWORD *)(v12 - 8);
  v14 = *(uint64_t (**)(void *, uint64_t, uint64_t))(v13 + 48);
  v15 = v14(v10, 1, v12);
  v16 = v14(v11, 1, v12);
  if (!v15)
  {
    if (!v16)
    {
      (*(void (**)(void *, void *, uint64_t))(v13 + 40))(v10, v11, v12);
      goto LABEL_7;
    }
    (*(void (**)(void *, uint64_t))(v13 + 8))(v10, v12);
    goto LABEL_6;
  }
  if (v16)
  {
LABEL_6:
    v17 = sub_100012C44(&qword_100407210);
    memcpy(v10, v11, *(_QWORD *)(*(_QWORD *)(v17 - 8) + 64));
    goto LABEL_7;
  }
  (*(void (**)(void *, void *, uint64_t))(v13 + 32))(v10, v11, v12);
  (*(void (**)(void *, _QWORD, uint64_t, uint64_t))(v13 + 56))(v10, 0, 1, v12);
LABEL_7:
  v18 = a3[35];
  v19 = a3[36];
  v20 = a1 + v18;
  v21 = a2 + v18;
  *(_DWORD *)v20 = *(_DWORD *)v21;
  *(_BYTE *)(v20 + 4) = *(_BYTE *)(v21 + 4);
  v22 = a1 + v19;
  v23 = a2 + v19;
  *(_DWORD *)v22 = *(_DWORD *)v23;
  *(_BYTE *)(v22 + 4) = *(_BYTE *)(v23 + 4);
  return a1;
}

uint64_t getEnumTagSinglePayload for AWDLActionFrame.DataPathState(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getEnumTagSinglePayloadGeneric(a1, a2, a3, sub_1000EA390);
}

uint64_t sub_1000EA390(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4;
  int v5;
  uint64_t v9;

  if ((_DWORD)a2 == 2147483646)
  {
    v4 = *(_QWORD *)(a1 + 48);
    if (v4 >= 0xFFFFFFFF)
      LODWORD(v4) = -1;
    v5 = v4 - 1;
    if (v5 < 0)
      v5 = -1;
    return (v5 + 1);
  }
  else
  {
    v9 = sub_100012C44(&qword_100407210);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v9 - 8) + 48))(a1 + *(int *)(a3 + 136), a2, v9);
  }
}

uint64_t storeEnumTagSinglePayload for AWDLActionFrame.DataPathState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return swift_storeEnumTagSinglePayloadGeneric(a1, a2, a3, a4, sub_1000EA428);
}

uint64_t sub_1000EA428(uint64_t result, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v7;

  v5 = result;
  if (a3 == 2147483646)
  {
    *(_QWORD *)(result + 48) = a2;
  }
  else
  {
    v7 = sub_100012C44(&qword_100407210);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v7 - 8) + 56))(v5 + *(int *)(a4 + 136), a2, a2, v7);
  }
  return result;
}

void sub_1000EA4A0(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  _QWORD v4[33];

  v4[0] = &unk_100343D10;
  v4[1] = &unk_100343D28;
  v4[2] = &unk_100343D40;
  v4[3] = &unk_100343D28;
  v4[4] = &unk_100343D40;
  v4[5] = &unk_100343D58;
  v4[6] = &unk_100343D40;
  v4[7] = &unk_100343D70;
  v4[8] = &unk_100343D88;
  v4[9] = &unk_100343D70;
  v4[10] = &unk_100343DA0;
  v4[11] = &unk_100343DB8;
  v4[12] = &unk_100343D70;
  v4[13] = &unk_100343D70;
  v4[14] = &unk_100343D70;
  v4[15] = &unk_100343D70;
  v4[16] = &unk_100343D70;
  v4[17] = &unk_100343D70;
  v4[18] = &unk_100343D70;
  v4[19] = &unk_100343D70;
  v4[20] = &unk_100343D70;
  v4[21] = &unk_100343D70;
  v4[22] = &unk_100343D70;
  v4[23] = &unk_100343D70;
  v4[24] = &unk_100343D70;
  v4[25] = &unk_100343D70;
  v4[26] = &unk_100343D70;
  v4[27] = &unk_100343D70;
  v4[28] = &unk_100343D70;
  v4[29] = &unk_100343D70;
  sub_1000EA590(319);
  if (v3 <= 0x3F)
  {
    v4[30] = *(_QWORD *)(v2 - 8) + 64;
    v4[31] = &unk_100343DB8;
    v4[32] = &unk_100343DB8;
    swift_initStructMetadata(a1, 256, 33, v4, a1 + 16);
  }
}

void sub_1000EA590(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;

  if (!qword_100407690)
  {
    v2 = type metadata accessor for DispatchTimeInterval(255);
    v3 = type metadata accessor for Optional(a1, v2);
    if (!v4)
      atomic_store(v3, (unint64_t *)&qword_100407690);
  }
}

uint64_t getEnumTagSinglePayload for AWDLActionFrame.DataPathState.UnicastMasterIndicationOptions(unsigned __int8 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0xD6)
    goto LABEL_17;
  if (a2 + 42 >= 0xFFFF00)
    v2 = 4;
  else
    v2 = 2;
  if ((a2 + 42) >> 8 < 0xFF)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 8)) - 42;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1))
        goto LABEL_17;
      return (*a1 | (v4 << 8)) - 42;
    }
    v4 = a1[1];
    if (a1[1])
      return (*a1 | (v4 << 8)) - 42;
  }
LABEL_17:
  v6 = *a1;
  v7 = v6 >= 0x2B;
  v8 = v6 - 43;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for AWDLActionFrame.DataPathState.UnicastMasterIndicationOptions(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 42 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 42) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xD6)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xD5)
    return ((uint64_t (*)(void))((char *)&loc_1000EA6C0 + 4 * byte_1003414B9[v4]))();
  *a1 = a2 + 42;
  return ((uint64_t (*)(void))((char *)sub_1000EA6F4 + 4 * byte_1003414B4[v4]))();
}

uint64_t sub_1000EA6F4(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000EA6FC(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x1000EA704);
  return result;
}

uint64_t sub_1000EA710(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x1000EA718);
  *(_BYTE *)result = a2 + 42;
  return result;
}

uint64_t sub_1000EA71C(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000EA724(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.DataPathState.UnicastMasterIndicationOptions()
{
  return &type metadata for AWDLActionFrame.DataPathState.UnicastMasterIndicationOptions;
}

uint64_t sub_1000EA744(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  v3 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 16) = v3;
  swift_bridgeObjectRetain(v3);
  return a1;
}

uint64_t assignWithCopy for AWDLActionFrame.Arpa(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  v3 = *(_QWORD *)(a2 + 16);
  v4 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v3;
  swift_bridgeObjectRetain(v3);
  swift_bridgeObjectRelease(v4);
  return a1;
}

uint64_t assignWithTake for AWDLActionFrame.Arpa(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  v3 = *(_QWORD *)(a2 + 16);
  v4 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 16) = v3;
  swift_bridgeObjectRelease(v4);
  return a1;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.Arpa()
{
  return &type metadata for AWDLActionFrame.Arpa;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.Arpa.Flags()
{
  return &type metadata for AWDLActionFrame.Arpa.Flags;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.SyncTreePath()
{
  return &type metadata for AWDLActionFrame.SyncTreePath;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.AWDLVersion()
{
  return &type metadata for AWDLActionFrame.AWDLVersion;
}

uint64_t storeEnumTagSinglePayload for AWDLActionFrame.Version(_WORD *a1, int a2, int a3)
{
  int v3;
  uint64_t v4;

  if ((a3 + 0xFFFF) <= 0xFFFEFFFF)
    v3 = 2;
  else
    v3 = 4;
  if ((a3 + 0xFFFF) < 0xFF0000)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3)
    v4 = v4;
  else
    v4 = 0;
  if (!a2)
    return ((uint64_t (*)(void))((char *)sub_1000EA8B0 + 4 * byte_1003414C3[v4]))();
  *a1 = a2 - 1;
  return ((uint64_t (*)(void))((char *)sub_1000EA890 + 4 * byte_1003414BE[v4]))();
}

uint64_t sub_1000EA890(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 2) = v1;
  return result;
}

uint64_t sub_1000EA8B0(uint64_t result)
{
  *(_BYTE *)(result + 2) = 0;
  return result;
}

uint64_t sub_1000EA8B8(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 2) = v1;
  return result;
}

uint64_t sub_1000EA8C0(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 2) = v1;
  return result;
}

uint64_t sub_1000EA8C8(uint64_t result)
{
  *(_WORD *)(result + 2) = 0;
  return result;
}

uint64_t sub_1000EA8D0(uint64_t result)
{
  *(_DWORD *)(result + 2) = 0;
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.Version()
{
  return &type metadata for AWDLActionFrame.Version;
}

uint64_t getEnumTagSinglePayload for NANInternetSharingStatistics.Requester.InternetSharingPolicyChannelState(unsigned __int8 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0xFC)
    goto LABEL_17;
  if (a2 + 4 >= 0xFFFF00)
    v2 = 4;
  else
    v2 = 2;
  if ((a2 + 4) >> 8 < 0xFF)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 8)) - 4;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1))
        goto LABEL_17;
      return (*a1 | (v4 << 8)) - 4;
    }
    v4 = a1[1];
    if (a1[1])
      return (*a1 | (v4 << 8)) - 4;
  }
LABEL_17:
  v6 = *a1;
  v7 = v6 >= 5;
  v8 = v6 - 5;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for AWDLActionFrame.Version.PlatformType(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 4 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 4) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xFC)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xFB)
    return ((uint64_t (*)(void))((char *)&loc_1000EA9C8 + 4 * byte_1003414CD[v4]))();
  *a1 = a2 + 4;
  return ((uint64_t (*)(void))((char *)sub_1000EA9FC + 4 * byte_1003414C8[v4]))();
}

uint64_t sub_1000EA9FC(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000EAA04(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x1000EAA0CLL);
  return result;
}

uint64_t sub_1000EAA18(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x1000EAA20);
  *(_BYTE *)result = a2 + 4;
  return result;
}

uint64_t sub_1000EAA24(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000EAA2C(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.Version.PlatformType()
{
  return &type metadata for AWDLActionFrame.Version.PlatformType;
}

uint64_t sub_1000EAA4C(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  *(_WORD *)a1 = *(_WORD *)a2;
  v3 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 8) = v3;
  swift_bridgeObjectRetain(v3);
  return a1;
}

uint64_t assignWithCopy for AWDLActionFrame.PeerMACAddressListBloomFilter(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_BYTE *)(a1 + 1) = *(_BYTE *)(a2 + 1);
  v3 = *(_QWORD *)(a2 + 8);
  v4 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = v3;
  swift_bridgeObjectRetain(v3);
  swift_bridgeObjectRelease(v4);
  return a1;
}

uint64_t assignWithTake for AWDLActionFrame.PeerMACAddressListBloomFilter(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  *(_WORD *)a1 = *(_WORD *)a2;
  v3 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  swift_bridgeObjectRelease(v3);
  return a1;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.PeerMACAddressListBloomFilter()
{
  return &type metadata for AWDLActionFrame.PeerMACAddressListBloomFilter;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.NANSynchronization()
{
  return &type metadata for AWDLActionFrame.NANSynchronization;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.ElectionParameter()
{
  return &type metadata for AWDLActionFrame.ElectionParameter;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.MultiPeerBSSSteering()
{
  return &type metadata for AWDLActionFrame.MultiPeerBSSSteering;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.MultiPeerBSSSteering.SteeringMessageID()
{
  return &type metadata for AWDLActionFrame.MultiPeerBSSSteering.SteeringMessageID;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.Ranging()
{
  return &type metadata for AWDLActionFrame.Ranging;
}

uint64_t getEnumTagSinglePayload for AWDLActionFrame.RealtimeGroup(uint64_t a1, unsigned int a2)
{
  int v3;
  int v4;
  int v5;

  if (!a2)
    return 0;
  if (a2 >= 0xFD && *(_BYTE *)(a1 + 40))
    return (*(_DWORD *)a1 + 253);
  if (*(unsigned __int8 *)(a1 + 12) <= 3u)
    v3 = 3;
  else
    v3 = *(unsigned __int8 *)(a1 + 12);
  v4 = v3 - 4;
  if (*(unsigned __int8 *)(a1 + 12) < 3u)
    v5 = -1;
  else
    v5 = v4;
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for AWDLActionFrame.RealtimeGroup(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFC)
  {
    *(_OWORD *)(result + 8) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_QWORD *)result = a2 - 253;
    if (a3 >= 0xFD)
      *(_BYTE *)(result + 40) = 1;
  }
  else
  {
    if (a3 >= 0xFD)
      *(_BYTE *)(result + 40) = 0;
    if (a2)
      *(_BYTE *)(result + 12) = a2 + 3;
  }
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.RealtimeGroup()
{
  return &type metadata for AWDLActionFrame.RealtimeGroup;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.RealtimeGroup.Flags()
{
  return &type metadata for AWDLActionFrame.RealtimeGroup.Flags;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.RealtimeGroup.AdditionalFlags()
{
  return &type metadata for AWDLActionFrame.RealtimeGroup.AdditionalFlags;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.ExtendedChannelSequence()
{
  return &type metadata for AWDLActionFrame.ExtendedChannelSequence;
}

uint64_t initializeBufferWithCopyOfBuffer for AWDLActionFrame.PreferredChannels(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_WORD *)(a1 + 4) = *(_WORD *)(a2 + 4);
  v3 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 8) = v3;
  swift_bridgeObjectRetain(v3);
  return a1;
}

uint64_t assignWithCopy for AWDLActionFrame.PreferredChannels(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;

  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_BYTE *)(a1 + 4) = *(_BYTE *)(a2 + 4);
  *(_BYTE *)(a1 + 5) = *(_BYTE *)(a2 + 5);
  v3 = *(_QWORD *)(a2 + 8);
  v4 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = v3;
  swift_bridgeObjectRetain(v3);
  swift_bridgeObjectRelease(v4);
  return a1;
}

uint64_t assignWithTake for AWDLActionFrame.PreferredChannels(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_WORD *)(a1 + 4) = *(_WORD *)(a2 + 4);
  v3 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  swift_bridgeObjectRelease(v3);
  return a1;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.PreferredChannels()
{
  return &type metadata for AWDLActionFrame.PreferredChannels;
}

_DWORD *initializeBufferWithCopyOfBuffer for AWDLActionFrame.PreferredChannels.PreferredChannel(_DWORD *result, int *a2)
{
  int v2;

  v2 = *a2;
  *(_DWORD *)((char *)result + 3) = *(int *)((char *)a2 + 3);
  *result = v2;
  return result;
}

uint64_t getEnumTagSinglePayload for AWDLActionFrame.PreferredChannels.PreferredChannel(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  BOOL v4;
  int v5;

  if (!a2)
    return 0;
  if (a2 >= 0xFE && *(_BYTE *)(a1 + 7))
    return (*(_DWORD *)a1 + 254);
  v3 = *(unsigned __int8 *)(a1 + 4);
  v4 = v3 >= 3;
  v5 = v3 - 3;
  if (!v4)
    v5 = -1;
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for AWDLActionFrame.PreferredChannels.PreferredChannel(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFD)
  {
    *(_BYTE *)(result + 6) = 0;
    *(_WORD *)(result + 4) = 0;
    *(_DWORD *)result = a2 - 254;
    if (a3 >= 0xFE)
      *(_BYTE *)(result + 7) = 1;
  }
  else
  {
    if (a3 >= 0xFE)
      *(_BYTE *)(result + 7) = 0;
    if (a2)
      *(_BYTE *)(result + 4) = a2 + 2;
  }
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.PreferredChannels.PreferredChannel()
{
  return &type metadata for AWDLActionFrame.PreferredChannels.PreferredChannel;
}

uint64_t getEnumTagSinglePayload for AWDLActionFrame.ProMode(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  BOOL v4;
  int v5;

  if (!a2)
    return 0;
  if (a2 >= 0xFE && *(_BYTE *)(a1 + 12))
    return (*(_DWORD *)a1 + 254);
  v3 = *(unsigned __int8 *)(a1 + 1);
  v4 = v3 >= 3;
  v5 = v3 - 3;
  if (!v4)
    v5 = -1;
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for AWDLActionFrame.ProMode(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFD)
  {
    *(_DWORD *)(result + 8) = 0;
    *(_QWORD *)result = a2 - 254;
    if (a3 >= 0xFE)
      *(_BYTE *)(result + 12) = 1;
  }
  else
  {
    if (a3 >= 0xFE)
      *(_BYTE *)(result + 12) = 0;
    if (a2)
      *(_BYTE *)(result + 1) = a2 + 2;
  }
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.ProMode()
{
  return &type metadata for AWDLActionFrame.ProMode;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.ProMode.Command()
{
  return &type metadata for AWDLActionFrame.ProMode.Command;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.ProMode.Flags()
{
  return &type metadata for AWDLActionFrame.ProMode.Flags;
}

uint64_t getEnumTagSinglePayload for AWDLActionFrame.AirDrop(unsigned __int16 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0xFF)
    goto LABEL_17;
  if (a2 + 65281 <= 0xFFFEFFFF)
    v2 = 2;
  else
    v2 = 4;
  if (a2 + 65281 < 0xFF0000)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 16)) - 65281;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = a1[1];
      if (!a1[1])
        goto LABEL_17;
      return (*a1 | (v4 << 16)) - 65281;
    }
    v4 = *((unsigned __int8 *)a1 + 2);
    if (*((_BYTE *)a1 + 2))
      return (*a1 | (v4 << 16)) - 65281;
  }
LABEL_17:
  v6 = *((unsigned __int8 *)a1 + 1);
  v7 = v6 >= 2;
  v8 = v6 - 2;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for AWDLActionFrame.AirDrop(_WORD *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 65281 <= 0xFFFEFFFF)
    v3 = 2;
  else
    v3 = 4;
  if (a3 + 65281 < 0xFF0000)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xFF)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xFE)
    return ((uint64_t (*)(void))((char *)&loc_1000EAF70 + 4 * byte_1003414D7[v4]))();
  *a1 = a2 - 255;
  return ((uint64_t (*)(void))((char *)sub_1000EAFA4 + 4 * byte_1003414D2[v4]))();
}

uint64_t sub_1000EAFA4(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 2) = v1;
  return result;
}

uint64_t sub_1000EAFAC(uint64_t result, int a2)
{
  *(_WORD *)(result + 2) = 0;
  if (a2)
    JUMPOUT(0x1000EAFB4);
  return result;
}

uint64_t sub_1000EAFC0(uint64_t result, int a2)
{
  *(_DWORD *)(result + 2) = 0;
  if (!a2)
    JUMPOUT(0x1000EAFC8);
  *(_BYTE *)(result + 1) = a2 + 1;
  return result;
}

uint64_t sub_1000EAFCC(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 2) = v1;
  return result;
}

uint64_t sub_1000EAFD4(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 2) = v1;
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.AirDrop()
{
  return &type metadata for AWDLActionFrame.AirDrop;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.AirDrop.State()
{
  return &type metadata for AWDLActionFrame.AirDrop.State;
}

char *initializeBufferWithCopyOfBuffer for AWDLActionFrame.AWDLAttribute(char *a1, char *a2, uint64_t a3)
{
  uint64_t v5;
  int v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t EnumCaseMultiPayload;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  int *v25;
  uint64_t v26;
  char *v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int (*v31)(char *, uint64_t, uint64_t);
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  char v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;
  char *v48;
  uint64_t v49;
  char *v50;
  char *v51;
  uint64_t v52;
  uint64_t v53;
  int *v54;
  uint64_t v55;
  uint64_t v56;
  void (*v57)(char *, char *, uint64_t);
  uint64_t v58;
  char *v59;
  char *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  char *v64;
  char *v65;

  v5 = *(_QWORD *)(a3 - 8);
  v6 = *(_DWORD *)(v5 + 80);
  if ((v6 & 0x20000) == 0)
  {
    switch(swift_getEnumCaseMultiPayload(a2, a3))
    {
      case 0u:
        *(_DWORD *)a1 = *(_DWORD *)a2;
        v8 = *((_QWORD *)a2 + 1);
        *((_QWORD *)a1 + 1) = v8;
        swift_bridgeObjectRetain(v8);
        swift_storeEnumTagMultiPayload(a1, a3, 0);
        return a1;
      case 1u:
        v11 = type metadata accessor for AWDLActionFrame.ServiceResponse(0);
        EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(a2, v11);
        v13 = EnumCaseMultiPayload;
        if ((_DWORD)EnumCaseMultiPayload == 2)
        {
          v52 = *((_QWORD *)a2 + 1);
          *(_QWORD *)a1 = *(_QWORD *)a2;
          *((_QWORD *)a1 + 1) = v52;
          v53 = *((_QWORD *)a2 + 3);
          *((_QWORD *)a1 + 2) = *((_QWORD *)a2 + 2);
          *((_QWORD *)a1 + 3) = v53;
          a1[32] = a2[32];
          a1[33] = a2[33];
          v54 = (int *)type metadata accessor for DNSRecords.SRV(0);
          v55 = v54[5];
          v64 = &a2[v55];
          v65 = &a1[v55];
          v56 = type metadata accessor for NWEndpoint.Port(0);
          v57 = *(void (**)(char *, char *, uint64_t))(*(_QWORD *)(v56 - 8) + 16);
          swift_bridgeObjectRetain(v52);
          swift_bridgeObjectRetain(v53);
          v57(v65, v64, v56);
          v58 = v54[6];
          v59 = &a1[v58];
          v60 = &a2[v58];
          v61 = *((_QWORD *)v60 + 1);
          *(_QWORD *)v59 = *(_QWORD *)v60;
          *((_QWORD *)v59 + 1) = v61;
          *(_WORD *)&a1[v54[7]] = *(_WORD *)&a2[v54[7]];
          *(_WORD *)&a1[v54[8]] = *(_WORD *)&a2[v54[8]];
        }
        else
        {
          if ((_DWORD)EnumCaseMultiPayload == 1)
          {
            v14 = *((_QWORD *)a2 + 1);
            *(_QWORD *)a1 = *(_QWORD *)a2;
            *((_QWORD *)a1 + 1) = v14;
            v15 = *((_QWORD *)a2 + 3);
            *((_QWORD *)a1 + 2) = *((_QWORD *)a2 + 2);
            *((_QWORD *)a1 + 3) = v15;
            a1[32] = a2[32];
            a1[33] = a2[33];
            v17 = *((_QWORD *)a2 + 5);
            v16 = *((_QWORD *)a2 + 6);
            swift_bridgeObjectRetain(v14);
            swift_bridgeObjectRetain(v15);
            sub_100031FEC(v17, v16);
            *((_QWORD *)a1 + 5) = v17;
            *((_QWORD *)a1 + 6) = v16;
LABEL_26:
            swift_storeEnumTagMultiPayload(a1, v11, v13);
            swift_storeEnumTagMultiPayload(a1, a3, 1);
            return a1;
          }
          v62 = *((_QWORD *)a2 + 1);
          *(_QWORD *)a1 = *(_QWORD *)a2;
          *((_QWORD *)a1 + 1) = v62;
          v63 = *((_QWORD *)a2 + 3);
          *((_QWORD *)a1 + 2) = *((_QWORD *)a2 + 2);
          *((_QWORD *)a1 + 3) = v63;
          a1[32] = a2[32];
          a1[33] = a2[33];
          swift_bridgeObjectRetain(v62);
          v61 = v63;
        }
        swift_bridgeObjectRetain(v61);
        goto LABEL_26;
      case 2u:
        *a1 = *a2;
        *(_DWORD *)(a1 + 2) = *(_DWORD *)(a2 + 2);
        *(_QWORD *)(a1 + 6) = *(_QWORD *)(a2 + 6);
        *(_DWORD *)(a1 + 14) = *(_DWORD *)(a2 + 14);
        *(_DWORD *)(a1 + 18) = *(_DWORD *)(a2 + 18);
        *(_QWORD *)(a1 + 22) = *(_QWORD *)(a2 + 22);
        *(_DWORD *)(a1 + 30) = *(_DWORD *)(a2 + 30);
        v18 = *((_QWORD *)a2 + 5);
        *((_QWORD *)a1 + 5) = v18;
        swift_bridgeObjectRetain(v18);
        swift_storeEnumTagMultiPayload(a1, a3, 2);
        return a1;
      case 4u:
        v19 = *(_QWORD *)a2;
        *(_QWORD *)a1 = *(_QWORD *)a2;
        swift_bridgeObjectRetain(v19);
        swift_storeEnumTagMultiPayload(a1, a3, 4);
        return a1;
      case 5u:
        *a1 = *a2;
        *(_DWORD *)(a1 + 2) = *(_DWORD *)(a2 + 2);
        *((_DWORD *)a1 + 2) = *((_DWORD *)a2 + 2);
        v21 = *((_QWORD *)a2 + 2);
        v20 = *((_QWORD *)a2 + 3);
        sub_100031FEC(v21, v20);
        *((_QWORD *)a1 + 2) = v21;
        *((_QWORD *)a1 + 3) = v20;
        swift_storeEnumTagMultiPayload(a1, a3, 5);
        return a1;
      case 6u:
        *(_WORD *)a1 = *(_WORD *)a2;
        a1[2] = a2[2];
        *((_DWORD *)a1 + 1) = *((_DWORD *)a2 + 1);
        *((_WORD *)a1 + 4) = *((_WORD *)a2 + 4);
        *(_DWORD *)(a1 + 10) = *(_DWORD *)(a2 + 10);
        *(_DWORD *)(a1 + 13) = *(_DWORD *)(a2 + 13);
        *((_WORD *)a1 + 12) = *((_WORD *)a2 + 12);
        *((_DWORD *)a1 + 5) = *((_DWORD *)a2 + 5);
        v22 = *(_DWORD *)(a2 + 26);
        *(_DWORD *)(a1 + 29) = *(_DWORD *)(a2 + 29);
        *(_DWORD *)(a1 + 26) = v22;
        v23 = *((_QWORD *)a2 + 6);
        *((_QWORD *)a1 + 5) = *((_QWORD *)a2 + 5);
        *((_QWORD *)a1 + 6) = v23;
        *((_DWORD *)a1 + 14) = *((_DWORD *)a2 + 14);
        *(_DWORD *)(a1 + 59) = *(_DWORD *)(a2 + 59);
        a1[63] = a2[63];
        *((_DWORD *)a1 + 16) = *((_DWORD *)a2 + 16);
        a1[68] = a2[68];
        v24 = *((_DWORD *)a2 + 18);
        a1[76] = a2[76];
        *((_DWORD *)a1 + 18) = v24;
        *(_OWORD *)(a1 + 77) = *(_OWORD *)(a2 + 77);
        *(_WORD *)(a1 + 93) = *(_WORD *)(a2 + 93);
        v25 = (int *)type metadata accessor for AWDLActionFrame.DataPathState(0);
        v26 = v25[34];
        v27 = &a1[v26];
        v28 = &a2[v26];
        v29 = type metadata accessor for DispatchTimeInterval(0);
        v30 = *(_QWORD *)(v29 - 8);
        v31 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v30 + 48);
        swift_bridgeObjectRetain(v23);
        if (v31(v28, 1, v29))
        {
          v32 = sub_100012C44(&qword_100407210);
          memcpy(v27, v28, *(_QWORD *)(*(_QWORD *)(v32 - 8) + 64));
        }
        else
        {
          (*(void (**)(char *, char *, uint64_t))(v30 + 16))(v27, v28, v29);
          (*(void (**)(char *, _QWORD, uint64_t, uint64_t))(v30 + 56))(v27, 0, 1, v29);
        }
        v46 = v25[35];
        v47 = &a1[v46];
        v48 = &a2[v46];
        *(_DWORD *)v47 = *(_DWORD *)v48;
        v47[4] = v48[4];
        v49 = v25[36];
        v50 = &a1[v49];
        v51 = &a2[v49];
        v50[4] = v51[4];
        *(_DWORD *)v50 = *(_DWORD *)v51;
        swift_storeEnumTagMultiPayload(a1, a3, 6);
        return a1;
      case 7u:
        *a1 = *a2;
        v33 = *((_QWORD *)a2 + 2);
        *((_QWORD *)a1 + 1) = *((_QWORD *)a2 + 1);
        *((_QWORD *)a1 + 2) = v33;
        swift_bridgeObjectRetain(v33);
        swift_storeEnumTagMultiPayload(a1, a3, 7);
        return a1;
      case 8u:
        v34 = *(_QWORD *)a2;
        *(_QWORD *)a1 = *(_QWORD *)a2;
        swift_bridgeObjectRetain(v34);
        swift_storeEnumTagMultiPayload(a1, a3, 8);
        return a1;
      case 0xAu:
        *(_WORD *)a1 = *(_WORD *)a2;
        v45 = *((_QWORD *)a2 + 1);
        *((_QWORD *)a1 + 1) = v45;
        swift_bridgeObjectRetain(v45);
        swift_storeEnumTagMultiPayload(a1, a3, 10);
        return a1;
      case 0xDu:
        v35 = *(_QWORD *)a2;
        v36 = *((_QWORD *)a2 + 1);
        v37 = *((_QWORD *)a2 + 2);
        v38 = *((_QWORD *)a2 + 3);
        v39 = *((_QWORD *)a2 + 4);
        v40 = *((_QWORD *)a2 + 5);
        v41 = a2[48];
        sub_100063C58(v35, v36, v37, v38, v39, v40, v41);
        *(_QWORD *)a1 = v35;
        *((_QWORD *)a1 + 1) = v36;
        *((_QWORD *)a1 + 2) = v37;
        *((_QWORD *)a1 + 3) = v38;
        *((_QWORD *)a1 + 4) = v39;
        *((_QWORD *)a1 + 5) = v40;
        a1[48] = v41;
        swift_storeEnumTagMultiPayload(a1, a3, 13);
        return a1;
      case 0xEu:
        *(_DWORD *)a1 = *(_DWORD *)a2;
        a1[4] = a2[4];
        v43 = *((_QWORD *)a2 + 1);
        v42 = *((_QWORD *)a2 + 2);
        sub_100031FEC(v43, v42);
        *((_QWORD *)a1 + 1) = v43;
        *((_QWORD *)a1 + 2) = v42;
        swift_storeEnumTagMultiPayload(a1, a3, 14);
        return a1;
      case 0x12u:
        *(_DWORD *)a1 = *(_DWORD *)a2;
        *((_WORD *)a1 + 2) = *((_WORD *)a2 + 2);
        v44 = *((_QWORD *)a2 + 1);
        *((_QWORD *)a1 + 1) = v44;
        swift_bridgeObjectRetain(v44);
        swift_storeEnumTagMultiPayload(a1, a3, 18);
        return a1;
      default:
        memcpy(a1, a2, *(_QWORD *)(v5 + 64));
        return a1;
    }
  }
  v9 = *(_QWORD *)a2;
  *(_QWORD *)a1 = *(_QWORD *)a2;
  a1 = (char *)(v9 + ((v6 + 16) & ~(unint64_t)v6));
  swift_retain();
  return a1;
}

void destroy for AWDLActionFrame.AWDLAttribute(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  int EnumCaseMultiPayload;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  switch(swift_getEnumCaseMultiPayload(a1, a2))
  {
    case 0u:
    case 0xAu:
    case 0x12u:
      v3 = *(_QWORD *)(a1 + 8);
      goto LABEL_17;
    case 1u:
      v4 = type metadata accessor for AWDLActionFrame.ServiceResponse(0);
      EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(a1, v4);
      if (EnumCaseMultiPayload == 2)
      {
        swift_bridgeObjectRelease(*(_QWORD *)(a1 + 8));
        swift_bridgeObjectRelease(*(_QWORD *)(a1 + 24));
        v11 = type metadata accessor for DNSRecords.SRV(0);
        v12 = a1 + *(int *)(v11 + 20);
        v13 = type metadata accessor for NWEndpoint.Port(0);
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v13 - 8) + 8))(v12, v13);
        v3 = *(_QWORD *)(a1 + *(int *)(v11 + 24) + 8);
LABEL_17:
        swift_bridgeObjectRelease(v3);
        return;
      }
      if (EnumCaseMultiPayload != 1)
      {
        if (EnumCaseMultiPayload)
          return;
        swift_bridgeObjectRelease(*(_QWORD *)(a1 + 8));
        v3 = *(_QWORD *)(a1 + 24);
        goto LABEL_17;
      }
      swift_bridgeObjectRelease(*(_QWORD *)(a1 + 8));
      swift_bridgeObjectRelease(*(_QWORD *)(a1 + 24));
      v6 = *(_QWORD *)(a1 + 40);
      v7 = *(_QWORD *)(a1 + 48);
LABEL_19:
      sub_10000E614(v6, v7);
      return;
    case 2u:
      v3 = *(_QWORD *)(a1 + 40);
      goto LABEL_17;
    case 4u:
    case 8u:
      v3 = *(_QWORD *)a1;
      goto LABEL_17;
    case 5u:
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_QWORD *)(a1 + 24);
      goto LABEL_19;
    case 6u:
      swift_bridgeObjectRelease(*(_QWORD *)(a1 + 48));
      v8 = a1 + *(int *)(type metadata accessor for AWDLActionFrame.DataPathState(0) + 136);
      v9 = type metadata accessor for DispatchTimeInterval(0);
      v10 = *(_QWORD *)(v9 - 8);
      if (!(*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v10 + 48))(v8, 1, v9))
        (*(void (**)(uint64_t, uint64_t))(v10 + 8))(v8, v9);
      return;
    case 7u:
      v3 = *(_QWORD *)(a1 + 16);
      goto LABEL_17;
    case 0xDu:
      sub_100063518(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(_BYTE *)(a1 + 48));
      return;
    case 0xEu:
      v6 = *(_QWORD *)(a1 + 8);
      v7 = *(_QWORD *)(a1 + 16);
      goto LABEL_19;
    default:
      return;
  }
}

char *initializeWithCopy for AWDLActionFrame.AWDLAttribute(char *a1, char *a2, uint64_t a3)
{
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t EnumCaseMultiPayload;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  int *v24;
  uint64_t v25;
  char *v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int (*v30)(char *, uint64_t, uint64_t);
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  char v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  char *v47;
  uint64_t v48;
  char *v49;
  char *v50;
  uint64_t v51;
  uint64_t v52;
  int *v53;
  uint64_t v54;
  uint64_t v55;
  void (*v56)(char *, char *, uint64_t);
  uint64_t v57;
  char *v58;
  char *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  char *v64;
  char *v65;

  switch(swift_getEnumCaseMultiPayload(a2, a3))
  {
    case 0u:
      *(_DWORD *)a1 = *(_DWORD *)a2;
      v6 = *((_QWORD *)a2 + 1);
      *((_QWORD *)a1 + 1) = v6;
      swift_bridgeObjectRetain(v6);
      v7 = a1;
      v8 = a3;
      v9 = 0;
      goto LABEL_24;
    case 1u:
      v10 = type metadata accessor for AWDLActionFrame.ServiceResponse(0);
      EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(a2, v10);
      v12 = EnumCaseMultiPayload;
      if ((_DWORD)EnumCaseMultiPayload == 2)
      {
        v51 = *((_QWORD *)a2 + 1);
        *(_QWORD *)a1 = *(_QWORD *)a2;
        *((_QWORD *)a1 + 1) = v51;
        v52 = *((_QWORD *)a2 + 3);
        *((_QWORD *)a1 + 2) = *((_QWORD *)a2 + 2);
        *((_QWORD *)a1 + 3) = v52;
        a1[32] = a2[32];
        a1[33] = a2[33];
        v53 = (int *)type metadata accessor for DNSRecords.SRV(0);
        v54 = v53[5];
        v64 = &a2[v54];
        v65 = &a1[v54];
        v55 = type metadata accessor for NWEndpoint.Port(0);
        v56 = *(void (**)(char *, char *, uint64_t))(*(_QWORD *)(v55 - 8) + 16);
        swift_bridgeObjectRetain(v51);
        swift_bridgeObjectRetain(v52);
        v56(v65, v64, v55);
        v57 = v53[6];
        v58 = &a1[v57];
        v59 = &a2[v57];
        v60 = *((_QWORD *)v59 + 1);
        *(_QWORD *)v58 = *(_QWORD *)v59;
        *((_QWORD *)v58 + 1) = v60;
        *(_WORD *)&a1[v53[7]] = *(_WORD *)&a2[v53[7]];
        *(_WORD *)&a1[v53[8]] = *(_WORD *)&a2[v53[8]];
      }
      else
      {
        if ((_DWORD)EnumCaseMultiPayload == 1)
        {
          v13 = *((_QWORD *)a2 + 1);
          *(_QWORD *)a1 = *(_QWORD *)a2;
          *((_QWORD *)a1 + 1) = v13;
          v14 = *((_QWORD *)a2 + 3);
          *((_QWORD *)a1 + 2) = *((_QWORD *)a2 + 2);
          *((_QWORD *)a1 + 3) = v14;
          a1[32] = a2[32];
          a1[33] = a2[33];
          v16 = *((_QWORD *)a2 + 5);
          v15 = *((_QWORD *)a2 + 6);
          swift_bridgeObjectRetain(v13);
          swift_bridgeObjectRetain(v14);
          sub_100031FEC(v16, v15);
          *((_QWORD *)a1 + 5) = v16;
          *((_QWORD *)a1 + 6) = v15;
          goto LABEL_23;
        }
        v61 = *((_QWORD *)a2 + 1);
        *(_QWORD *)a1 = *(_QWORD *)a2;
        *((_QWORD *)a1 + 1) = v61;
        v62 = *((_QWORD *)a2 + 3);
        *((_QWORD *)a1 + 2) = *((_QWORD *)a2 + 2);
        *((_QWORD *)a1 + 3) = v62;
        a1[32] = a2[32];
        a1[33] = a2[33];
        swift_bridgeObjectRetain(v61);
        v60 = v62;
      }
      swift_bridgeObjectRetain(v60);
LABEL_23:
      swift_storeEnumTagMultiPayload(a1, v10, v12);
      v7 = a1;
      v8 = a3;
      v9 = 1;
LABEL_24:
      swift_storeEnumTagMultiPayload(v7, v8, v9);
      return a1;
    case 2u:
      *a1 = *a2;
      *(_DWORD *)(a1 + 2) = *(_DWORD *)(a2 + 2);
      *(_QWORD *)(a1 + 6) = *(_QWORD *)(a2 + 6);
      *(_DWORD *)(a1 + 14) = *(_DWORD *)(a2 + 14);
      *(_DWORD *)(a1 + 18) = *(_DWORD *)(a2 + 18);
      *(_QWORD *)(a1 + 22) = *(_QWORD *)(a2 + 22);
      *(_DWORD *)(a1 + 30) = *(_DWORD *)(a2 + 30);
      v17 = *((_QWORD *)a2 + 5);
      *((_QWORD *)a1 + 5) = v17;
      swift_bridgeObjectRetain(v17);
      v7 = a1;
      v8 = a3;
      v9 = 2;
      goto LABEL_24;
    case 4u:
      v18 = *(_QWORD *)a2;
      *(_QWORD *)a1 = *(_QWORD *)a2;
      swift_bridgeObjectRetain(v18);
      v7 = a1;
      v8 = a3;
      v9 = 4;
      goto LABEL_24;
    case 5u:
      *a1 = *a2;
      *(_DWORD *)(a1 + 2) = *(_DWORD *)(a2 + 2);
      *((_DWORD *)a1 + 2) = *((_DWORD *)a2 + 2);
      v20 = *((_QWORD *)a2 + 2);
      v19 = *((_QWORD *)a2 + 3);
      sub_100031FEC(v20, v19);
      *((_QWORD *)a1 + 2) = v20;
      *((_QWORD *)a1 + 3) = v19;
      v7 = a1;
      v8 = a3;
      v9 = 5;
      goto LABEL_24;
    case 6u:
      *(_WORD *)a1 = *(_WORD *)a2;
      a1[2] = a2[2];
      *((_DWORD *)a1 + 1) = *((_DWORD *)a2 + 1);
      *((_WORD *)a1 + 4) = *((_WORD *)a2 + 4);
      *(_DWORD *)(a1 + 10) = *(_DWORD *)(a2 + 10);
      *(_DWORD *)(a1 + 13) = *(_DWORD *)(a2 + 13);
      *((_WORD *)a1 + 12) = *((_WORD *)a2 + 12);
      *((_DWORD *)a1 + 5) = *((_DWORD *)a2 + 5);
      v21 = *(_DWORD *)(a2 + 26);
      *(_DWORD *)(a1 + 29) = *(_DWORD *)(a2 + 29);
      *(_DWORD *)(a1 + 26) = v21;
      v22 = *((_QWORD *)a2 + 6);
      *((_QWORD *)a1 + 5) = *((_QWORD *)a2 + 5);
      *((_QWORD *)a1 + 6) = v22;
      *((_DWORD *)a1 + 14) = *((_DWORD *)a2 + 14);
      *(_DWORD *)(a1 + 59) = *(_DWORD *)(a2 + 59);
      a1[63] = a2[63];
      *((_DWORD *)a1 + 16) = *((_DWORD *)a2 + 16);
      a1[68] = a2[68];
      v23 = *((_DWORD *)a2 + 18);
      a1[76] = a2[76];
      *((_DWORD *)a1 + 18) = v23;
      *(_OWORD *)(a1 + 77) = *(_OWORD *)(a2 + 77);
      *(_WORD *)(a1 + 93) = *(_WORD *)(a2 + 93);
      v24 = (int *)type metadata accessor for AWDLActionFrame.DataPathState(0);
      v25 = v24[34];
      v26 = &a1[v25];
      v27 = &a2[v25];
      v28 = type metadata accessor for DispatchTimeInterval(0);
      v29 = *(_QWORD *)(v28 - 8);
      v30 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v29 + 48);
      swift_bridgeObjectRetain(v22);
      if (v30(v27, 1, v28))
      {
        v31 = sub_100012C44(&qword_100407210);
        memcpy(v26, v27, *(_QWORD *)(*(_QWORD *)(v31 - 8) + 64));
      }
      else
      {
        (*(void (**)(char *, char *, uint64_t))(v29 + 16))(v26, v27, v28);
        (*(void (**)(char *, _QWORD, uint64_t, uint64_t))(v29 + 56))(v26, 0, 1, v28);
      }
      v45 = v24[35];
      v46 = &a1[v45];
      v47 = &a2[v45];
      *(_DWORD *)v46 = *(_DWORD *)v47;
      v46[4] = v47[4];
      v48 = v24[36];
      v49 = &a1[v48];
      v50 = &a2[v48];
      v49[4] = v50[4];
      *(_DWORD *)v49 = *(_DWORD *)v50;
      v7 = a1;
      v8 = a3;
      v9 = 6;
      goto LABEL_24;
    case 7u:
      *a1 = *a2;
      v32 = *((_QWORD *)a2 + 2);
      *((_QWORD *)a1 + 1) = *((_QWORD *)a2 + 1);
      *((_QWORD *)a1 + 2) = v32;
      swift_bridgeObjectRetain(v32);
      v7 = a1;
      v8 = a3;
      v9 = 7;
      goto LABEL_24;
    case 8u:
      v33 = *(_QWORD *)a2;
      *(_QWORD *)a1 = *(_QWORD *)a2;
      swift_bridgeObjectRetain(v33);
      v7 = a1;
      v8 = a3;
      v9 = 8;
      goto LABEL_24;
    case 0xAu:
      *(_WORD *)a1 = *(_WORD *)a2;
      v44 = *((_QWORD *)a2 + 1);
      *((_QWORD *)a1 + 1) = v44;
      swift_bridgeObjectRetain(v44);
      v7 = a1;
      v8 = a3;
      v9 = 10;
      goto LABEL_24;
    case 0xDu:
      v34 = *(_QWORD *)a2;
      v35 = *((_QWORD *)a2 + 1);
      v36 = *((_QWORD *)a2 + 2);
      v37 = *((_QWORD *)a2 + 3);
      v38 = *((_QWORD *)a2 + 4);
      v39 = *((_QWORD *)a2 + 5);
      v40 = a2[48];
      sub_100063C58(v34, v35, v36, v37, v38, v39, v40);
      *(_QWORD *)a1 = v34;
      *((_QWORD *)a1 + 1) = v35;
      *((_QWORD *)a1 + 2) = v36;
      *((_QWORD *)a1 + 3) = v37;
      *((_QWORD *)a1 + 4) = v38;
      *((_QWORD *)a1 + 5) = v39;
      a1[48] = v40;
      v7 = a1;
      v8 = a3;
      v9 = 13;
      goto LABEL_24;
    case 0xEu:
      *(_DWORD *)a1 = *(_DWORD *)a2;
      a1[4] = a2[4];
      v42 = *((_QWORD *)a2 + 1);
      v41 = *((_QWORD *)a2 + 2);
      sub_100031FEC(v42, v41);
      *((_QWORD *)a1 + 1) = v42;
      *((_QWORD *)a1 + 2) = v41;
      v7 = a1;
      v8 = a3;
      v9 = 14;
      goto LABEL_24;
    case 0x12u:
      *(_DWORD *)a1 = *(_DWORD *)a2;
      *((_WORD *)a1 + 2) = *((_WORD *)a2 + 2);
      v43 = *((_QWORD *)a2 + 1);
      *((_QWORD *)a1 + 1) = v43;
      swift_bridgeObjectRetain(v43);
      v7 = a1;
      v8 = a3;
      v9 = 18;
      goto LABEL_24;
    default:
      memcpy(a1, a2, *(_QWORD *)(*(_QWORD *)(a3 - 8) + 64));
      return a1;
  }
}

char *assignWithCopy for AWDLActionFrame.AWDLAttribute(char *a1, char *a2, uint64_t a3)
{
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t EnumCaseMultiPayload;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  __int16 v22;
  int v23;
  int v24;
  int v25;
  int v26;
  uint64_t v27;
  int v28;
  int v29;
  int *v30;
  uint64_t v31;
  char *v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  unsigned int (*v36)(char *, uint64_t, uint64_t);
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  char v46;
  unint64_t v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  char *v53;
  char *v54;
  int v55;
  uint64_t v56;
  char *v57;
  char *v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  int *v62;
  uint64_t v63;
  uint64_t v64;
  void (*v65)(char *, char *, uint64_t);
  uint64_t v66;
  char *v67;
  char *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  char *v73;
  char *v74;

  if (a1 != a2)
  {
    sub_100063824((uint64_t)a1, type metadata accessor for AWDLActionFrame.AWDLAttribute);
    switch(swift_getEnumCaseMultiPayload(a2, a3))
    {
      case 0u:
        *(_WORD *)a1 = *(_WORD *)a2;
        *((_WORD *)a1 + 1) = *((_WORD *)a2 + 1);
        v6 = *((_QWORD *)a2 + 1);
        *((_QWORD *)a1 + 1) = v6;
        swift_bridgeObjectRetain(v6);
        v7 = a1;
        v8 = a3;
        v9 = 0;
        goto LABEL_25;
      case 1u:
        v10 = type metadata accessor for AWDLActionFrame.ServiceResponse(0);
        EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(a2, v10);
        v12 = EnumCaseMultiPayload;
        if ((_DWORD)EnumCaseMultiPayload == 2)
        {
          *(_QWORD *)a1 = *(_QWORD *)a2;
          v60 = *((_QWORD *)a2 + 1);
          *((_QWORD *)a1 + 1) = v60;
          *((_QWORD *)a1 + 2) = *((_QWORD *)a2 + 2);
          v61 = *((_QWORD *)a2 + 3);
          *((_QWORD *)a1 + 3) = v61;
          a1[32] = a2[32];
          a1[33] = a2[33];
          v62 = (int *)type metadata accessor for DNSRecords.SRV(0);
          v63 = v62[5];
          v73 = &a2[v63];
          v74 = &a1[v63];
          v64 = type metadata accessor for NWEndpoint.Port(0);
          v65 = *(void (**)(char *, char *, uint64_t))(*(_QWORD *)(v64 - 8) + 16);
          swift_bridgeObjectRetain(v60);
          swift_bridgeObjectRetain(v61);
          v65(v74, v73, v64);
          v66 = v62[6];
          v67 = &a1[v66];
          v68 = &a2[v66];
          *(_QWORD *)v67 = *(_QWORD *)v68;
          v69 = *((_QWORD *)v68 + 1);
          *((_QWORD *)v67 + 1) = v69;
          *(_WORD *)&a1[v62[7]] = *(_WORD *)&a2[v62[7]];
          *(_WORD *)&a1[v62[8]] = *(_WORD *)&a2[v62[8]];
        }
        else
        {
          if ((_DWORD)EnumCaseMultiPayload == 1)
          {
            *(_QWORD *)a1 = *(_QWORD *)a2;
            v13 = *((_QWORD *)a2 + 1);
            *((_QWORD *)a1 + 1) = v13;
            *((_QWORD *)a1 + 2) = *((_QWORD *)a2 + 2);
            v14 = *((_QWORD *)a2 + 3);
            *((_QWORD *)a1 + 3) = v14;
            a1[32] = a2[32];
            a1[33] = a2[33];
            v16 = *((_QWORD *)a2 + 5);
            v15 = *((_QWORD *)a2 + 6);
            swift_bridgeObjectRetain(v13);
            swift_bridgeObjectRetain(v14);
            sub_100031FEC(v16, v15);
            *((_QWORD *)a1 + 5) = v16;
            *((_QWORD *)a1 + 6) = v15;
            goto LABEL_24;
          }
          *(_QWORD *)a1 = *(_QWORD *)a2;
          v70 = *((_QWORD *)a2 + 1);
          *((_QWORD *)a1 + 1) = v70;
          *((_QWORD *)a1 + 2) = *((_QWORD *)a2 + 2);
          v71 = *((_QWORD *)a2 + 3);
          *((_QWORD *)a1 + 3) = v71;
          a1[32] = a2[32];
          a1[33] = a2[33];
          swift_bridgeObjectRetain(v70);
          v69 = v71;
        }
        swift_bridgeObjectRetain(v69);
LABEL_24:
        swift_storeEnumTagMultiPayload(a1, v10, v12);
        v7 = a1;
        v8 = a3;
        v9 = 1;
LABEL_25:
        swift_storeEnumTagMultiPayload(v7, v8, v9);
        break;
      case 2u:
        *a1 = *a2;
        *((_WORD *)a1 + 1) = *((_WORD *)a2 + 1);
        a1[4] = a2[4];
        a1[5] = a2[5];
        *((_WORD *)a1 + 3) = *((_WORD *)a2 + 3);
        *((_WORD *)a1 + 4) = *((_WORD *)a2 + 4);
        *((_WORD *)a1 + 5) = *((_WORD *)a2 + 5);
        *((_WORD *)a1 + 6) = *((_WORD *)a2 + 6);
        *((_WORD *)a1 + 7) = *((_WORD *)a2 + 7);
        *((_WORD *)a1 + 8) = *((_WORD *)a2 + 8);
        a1[18] = a2[18];
        a1[19] = a2[19];
        a1[20] = a2[20];
        a1[21] = a2[21];
        v17 = *(_DWORD *)(a2 + 22);
        *((_WORD *)a1 + 13) = *((_WORD *)a2 + 13);
        *(_DWORD *)(a1 + 22) = v17;
        a1[28] = a2[28];
        a1[29] = a2[29];
        *((_WORD *)a1 + 15) = *((_WORD *)a2 + 15);
        *((_WORD *)a1 + 16) = *((_WORD *)a2 + 16);
        v18 = *((_QWORD *)a2 + 5);
        *((_QWORD *)a1 + 5) = v18;
        swift_bridgeObjectRetain(v18);
        v7 = a1;
        v8 = a3;
        v9 = 2;
        goto LABEL_25;
      case 4u:
        v19 = *(_QWORD *)a2;
        *(_QWORD *)a1 = *(_QWORD *)a2;
        swift_bridgeObjectRetain(v19);
        v7 = a1;
        v8 = a3;
        v9 = 4;
        goto LABEL_25;
      case 5u:
        *a1 = *a2;
        *((_WORD *)a1 + 1) = *((_WORD *)a2 + 1);
        *((_WORD *)a1 + 2) = *((_WORD *)a2 + 2);
        *((_DWORD *)a1 + 2) = *((_DWORD *)a2 + 2);
        v21 = *((_QWORD *)a2 + 2);
        v20 = *((_QWORD *)a2 + 3);
        sub_100031FEC(v21, v20);
        *((_QWORD *)a1 + 2) = v21;
        *((_QWORD *)a1 + 3) = v20;
        v7 = a1;
        v8 = a3;
        v9 = 5;
        goto LABEL_25;
      case 6u:
        v22 = *(_WORD *)a2;
        a1[2] = a2[2];
        *(_WORD *)a1 = v22;
        v23 = *((_DWORD *)a2 + 1);
        *((_WORD *)a1 + 4) = *((_WORD *)a2 + 4);
        *((_DWORD *)a1 + 1) = v23;
        v24 = *(_DWORD *)(a2 + 10);
        *(_DWORD *)(a1 + 13) = *(_DWORD *)(a2 + 13);
        *(_DWORD *)(a1 + 10) = v24;
        v25 = *((_DWORD *)a2 + 5);
        *((_WORD *)a1 + 12) = *((_WORD *)a2 + 12);
        *((_DWORD *)a1 + 5) = v25;
        v26 = *(_DWORD *)(a2 + 26);
        *(_DWORD *)(a1 + 29) = *(_DWORD *)(a2 + 29);
        *(_DWORD *)(a1 + 26) = v26;
        *((_QWORD *)a1 + 5) = *((_QWORD *)a2 + 5);
        v27 = *((_QWORD *)a2 + 6);
        *((_QWORD *)a1 + 6) = v27;
        v28 = *((_DWORD *)a2 + 14);
        *(_DWORD *)(a1 + 59) = *(_DWORD *)(a2 + 59);
        *((_DWORD *)a1 + 14) = v28;
        a1[63] = a2[63];
        a1[64] = a2[64];
        a1[65] = a2[65];
        LOWORD(v28) = *((_WORD *)a2 + 33);
        a1[68] = a2[68];
        *((_WORD *)a1 + 33) = v28;
        v29 = *((_DWORD *)a2 + 18);
        a1[76] = a2[76];
        *((_DWORD *)a1 + 18) = v29;
        a1[77] = a2[77];
        a1[78] = a2[78];
        a1[79] = a2[79];
        a1[80] = a2[80];
        a1[81] = a2[81];
        a1[82] = a2[82];
        a1[83] = a2[83];
        a1[84] = a2[84];
        a1[85] = a2[85];
        a1[86] = a2[86];
        a1[87] = a2[87];
        a1[88] = a2[88];
        a1[89] = a2[89];
        a1[90] = a2[90];
        a1[91] = a2[91];
        a1[92] = a2[92];
        a1[93] = a2[93];
        a1[94] = a2[94];
        v30 = (int *)type metadata accessor for AWDLActionFrame.DataPathState(0);
        v31 = v30[34];
        v32 = &a1[v31];
        v33 = &a2[v31];
        v34 = type metadata accessor for DispatchTimeInterval(0);
        v35 = *(_QWORD *)(v34 - 8);
        v36 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v35 + 48);
        swift_bridgeObjectRetain(v27);
        if (v36(v33, 1, v34))
        {
          v37 = sub_100012C44(&qword_100407210);
          memcpy(v32, v33, *(_QWORD *)(*(_QWORD *)(v37 - 8) + 64));
        }
        else
        {
          (*(void (**)(char *, char *, uint64_t))(v35 + 16))(v32, v33, v34);
          (*(void (**)(char *, _QWORD, uint64_t, uint64_t))(v35 + 56))(v32, 0, 1, v34);
        }
        v52 = v30[35];
        v53 = &a1[v52];
        v54 = &a2[v52];
        v55 = *(_DWORD *)v54;
        v53[4] = v54[4];
        *(_DWORD *)v53 = v55;
        v56 = v30[36];
        v57 = &a1[v56];
        v58 = &a2[v56];
        v59 = *(_DWORD *)v58;
        v57[4] = v58[4];
        *(_DWORD *)v57 = v59;
        v7 = a1;
        v8 = a3;
        v9 = 6;
        goto LABEL_25;
      case 7u:
        *a1 = *a2;
        *((_QWORD *)a1 + 1) = *((_QWORD *)a2 + 1);
        v38 = *((_QWORD *)a2 + 2);
        *((_QWORD *)a1 + 2) = v38;
        swift_bridgeObjectRetain(v38);
        v7 = a1;
        v8 = a3;
        v9 = 7;
        goto LABEL_25;
      case 8u:
        v39 = *(_QWORD *)a2;
        *(_QWORD *)a1 = *(_QWORD *)a2;
        swift_bridgeObjectRetain(v39);
        v7 = a1;
        v8 = a3;
        v9 = 8;
        goto LABEL_25;
      case 0xAu:
        *a1 = *a2;
        a1[1] = a2[1];
        v51 = *((_QWORD *)a2 + 1);
        *((_QWORD *)a1 + 1) = v51;
        swift_bridgeObjectRetain(v51);
        v7 = a1;
        v8 = a3;
        v9 = 10;
        goto LABEL_25;
      case 0xDu:
        v40 = *(_QWORD *)a2;
        v41 = *((_QWORD *)a2 + 1);
        v42 = *((_QWORD *)a2 + 2);
        v43 = *((_QWORD *)a2 + 3);
        v44 = *((_QWORD *)a2 + 4);
        v45 = *((_QWORD *)a2 + 5);
        v46 = a2[48];
        sub_100063C58(v40, v41, v42, v43, v44, v45, v46);
        *(_QWORD *)a1 = v40;
        *((_QWORD *)a1 + 1) = v41;
        *((_QWORD *)a1 + 2) = v42;
        *((_QWORD *)a1 + 3) = v43;
        *((_QWORD *)a1 + 4) = v44;
        *((_QWORD *)a1 + 5) = v45;
        a1[48] = v46;
        v7 = a1;
        v8 = a3;
        v9 = 13;
        goto LABEL_25;
      case 0xEu:
        *(_WORD *)a1 = *(_WORD *)a2;
        *((_WORD *)a1 + 1) = *((_WORD *)a2 + 1);
        a1[4] = a2[4];
        v48 = *((_QWORD *)a2 + 1);
        v47 = *((_QWORD *)a2 + 2);
        sub_100031FEC(v48, v47);
        *((_QWORD *)a1 + 1) = v48;
        *((_QWORD *)a1 + 2) = v47;
        v7 = a1;
        v8 = a3;
        v9 = 14;
        goto LABEL_25;
      case 0x12u:
        v49 = *(_DWORD *)a2;
        *((_WORD *)a1 + 2) = *((_WORD *)a2 + 2);
        *(_DWORD *)a1 = v49;
        v50 = *((_QWORD *)a2 + 1);
        *((_QWORD *)a1 + 1) = v50;
        swift_bridgeObjectRetain(v50);
        v7 = a1;
        v8 = a3;
        v9 = 18;
        goto LABEL_25;
      default:
        memcpy(a1, a2, *(_QWORD *)(*(_QWORD *)(a3 - 8) + 64));
        return a1;
    }
  }
  return a1;
}

char *initializeWithTake for AWDLActionFrame.AWDLAttribute(char *a1, char *a2, uint64_t a3)
{
  int EnumCaseMultiPayload;
  uint64_t v7;
  __int128 v8;
  int *v9;
  uint64_t v10;
  char *v11;
  char *v12;
  uint64_t v13;
  int v14;
  int *v15;
  uint64_t v16;
  char *v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  char *v27;
  uint64_t v28;
  char *v29;
  char *v30;

  EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(a2, a3);
  if (EnumCaseMultiPayload == 6)
  {
    *(_WORD *)a1 = *(_WORD *)a2;
    a1[2] = a2[2];
    *((_DWORD *)a1 + 1) = *((_DWORD *)a2 + 1);
    *((_WORD *)a1 + 4) = *((_WORD *)a2 + 4);
    *(_DWORD *)(a1 + 10) = *(_DWORD *)(a2 + 10);
    *(_DWORD *)(a1 + 13) = *(_DWORD *)(a2 + 13);
    *((_WORD *)a1 + 12) = *((_WORD *)a2 + 12);
    *((_DWORD *)a1 + 5) = *((_DWORD *)a2 + 5);
    v14 = *(_DWORD *)(a2 + 26);
    *(_DWORD *)(a1 + 29) = *(_DWORD *)(a2 + 29);
    *(_DWORD *)(a1 + 26) = v14;
    *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
    *((_DWORD *)a1 + 14) = *((_DWORD *)a2 + 14);
    *(_DWORD *)(a1 + 59) = *(_DWORD *)(a2 + 59);
    a1[63] = a2[63];
    *((_DWORD *)a1 + 16) = *((_DWORD *)a2 + 16);
    a1[68] = a2[68];
    *((_DWORD *)a1 + 18) = *((_DWORD *)a2 + 18);
    a1[76] = a2[76];
    *(_OWORD *)(a1 + 77) = *(_OWORD *)(a2 + 77);
    *(_WORD *)(a1 + 93) = *(_WORD *)(a2 + 93);
    v15 = (int *)type metadata accessor for AWDLActionFrame.DataPathState(0);
    v16 = v15[34];
    v17 = &a1[v16];
    v18 = &a2[v16];
    v19 = type metadata accessor for DispatchTimeInterval(0);
    v20 = *(_QWORD *)(v19 - 8);
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v20 + 48))(v18, 1, v19))
    {
      v21 = sub_100012C44(&qword_100407210);
      memcpy(v17, v18, *(_QWORD *)(*(_QWORD *)(v21 - 8) + 64));
    }
    else
    {
      (*(void (**)(char *, char *, uint64_t))(v20 + 32))(v17, v18, v19);
      (*(void (**)(char *, _QWORD, uint64_t, uint64_t))(v20 + 56))(v17, 0, 1, v19);
    }
    v25 = v15[35];
    v26 = &a1[v25];
    v27 = &a2[v25];
    *(_DWORD *)v26 = *(_DWORD *)v27;
    v26[4] = v27[4];
    v28 = v15[36];
    v29 = &a1[v28];
    v30 = &a2[v28];
    v29[4] = v30[4];
    *(_DWORD *)v29 = *(_DWORD *)v30;
    v22 = a1;
    v23 = a3;
    v24 = 6;
    goto LABEL_12;
  }
  if (EnumCaseMultiPayload == 1)
  {
    v7 = type metadata accessor for AWDLActionFrame.ServiceResponse(0);
    if (swift_getEnumCaseMultiPayload(a2, v7) == 2)
    {
      v8 = *((_OWORD *)a2 + 1);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *((_OWORD *)a1 + 1) = v8;
      *((_WORD *)a1 + 16) = *((_WORD *)a2 + 16);
      v9 = (int *)type metadata accessor for DNSRecords.SRV(0);
      v10 = v9[5];
      v11 = &a1[v10];
      v12 = &a2[v10];
      v13 = type metadata accessor for NWEndpoint.Port(0);
      (*(void (**)(char *, char *, uint64_t))(*(_QWORD *)(v13 - 8) + 32))(v11, v12, v13);
      *(_OWORD *)&a1[v9[6]] = *(_OWORD *)&a2[v9[6]];
      *(_WORD *)&a1[v9[7]] = *(_WORD *)&a2[v9[7]];
      *(_WORD *)&a1[v9[8]] = *(_WORD *)&a2[v9[8]];
      swift_storeEnumTagMultiPayload(a1, v7, 2);
    }
    else
    {
      memcpy(a1, a2, *(_QWORD *)(*(_QWORD *)(v7 - 8) + 64));
    }
    v22 = a1;
    v23 = a3;
    v24 = 1;
LABEL_12:
    swift_storeEnumTagMultiPayload(v22, v23, v24);
    return a1;
  }
  memcpy(a1, a2, *(_QWORD *)(*(_QWORD *)(a3 - 8) + 64));
  return a1;
}

char *assignWithTake for AWDLActionFrame.AWDLAttribute(char *a1, char *a2, uint64_t a3)
{
  int EnumCaseMultiPayload;
  uint64_t v7;
  __int128 v8;
  int *v9;
  uint64_t v10;
  char *v11;
  char *v12;
  uint64_t v13;
  int v14;
  int *v15;
  uint64_t v16;
  char *v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  char *v27;
  uint64_t v28;
  char *v29;
  char *v30;

  if (a1 != a2)
  {
    sub_100063824((uint64_t)a1, type metadata accessor for AWDLActionFrame.AWDLAttribute);
    EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(a2, a3);
    if (EnumCaseMultiPayload == 6)
    {
      *(_WORD *)a1 = *(_WORD *)a2;
      a1[2] = a2[2];
      *((_DWORD *)a1 + 1) = *((_DWORD *)a2 + 1);
      *((_WORD *)a1 + 4) = *((_WORD *)a2 + 4);
      *(_DWORD *)(a1 + 10) = *(_DWORD *)(a2 + 10);
      *(_DWORD *)(a1 + 13) = *(_DWORD *)(a2 + 13);
      *((_WORD *)a1 + 12) = *((_WORD *)a2 + 12);
      *((_DWORD *)a1 + 5) = *((_DWORD *)a2 + 5);
      v14 = *(_DWORD *)(a2 + 26);
      *(_DWORD *)(a1 + 29) = *(_DWORD *)(a2 + 29);
      *(_DWORD *)(a1 + 26) = v14;
      *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
      *((_DWORD *)a1 + 14) = *((_DWORD *)a2 + 14);
      *(_DWORD *)(a1 + 59) = *(_DWORD *)(a2 + 59);
      a1[63] = a2[63];
      *((_DWORD *)a1 + 16) = *((_DWORD *)a2 + 16);
      a1[68] = a2[68];
      *((_DWORD *)a1 + 18) = *((_DWORD *)a2 + 18);
      a1[76] = a2[76];
      *(_OWORD *)(a1 + 77) = *(_OWORD *)(a2 + 77);
      *(_WORD *)(a1 + 93) = *(_WORD *)(a2 + 93);
      v15 = (int *)type metadata accessor for AWDLActionFrame.DataPathState(0);
      v16 = v15[34];
      v17 = &a1[v16];
      v18 = &a2[v16];
      v19 = type metadata accessor for DispatchTimeInterval(0);
      v20 = *(_QWORD *)(v19 - 8);
      if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v20 + 48))(v18, 1, v19))
      {
        v21 = sub_100012C44(&qword_100407210);
        memcpy(v17, v18, *(_QWORD *)(*(_QWORD *)(v21 - 8) + 64));
      }
      else
      {
        (*(void (**)(char *, char *, uint64_t))(v20 + 32))(v17, v18, v19);
        (*(void (**)(char *, _QWORD, uint64_t, uint64_t))(v20 + 56))(v17, 0, 1, v19);
      }
      v25 = v15[35];
      v26 = &a1[v25];
      v27 = &a2[v25];
      *(_DWORD *)v26 = *(_DWORD *)v27;
      v26[4] = v27[4];
      v28 = v15[36];
      v29 = &a1[v28];
      v30 = &a2[v28];
      v29[4] = v30[4];
      *(_DWORD *)v29 = *(_DWORD *)v30;
      v22 = a1;
      v23 = a3;
      v24 = 6;
      goto LABEL_13;
    }
    if (EnumCaseMultiPayload == 1)
    {
      v7 = type metadata accessor for AWDLActionFrame.ServiceResponse(0);
      if (swift_getEnumCaseMultiPayload(a2, v7) == 2)
      {
        v8 = *((_OWORD *)a2 + 1);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *((_OWORD *)a1 + 1) = v8;
        *((_WORD *)a1 + 16) = *((_WORD *)a2 + 16);
        v9 = (int *)type metadata accessor for DNSRecords.SRV(0);
        v10 = v9[5];
        v11 = &a1[v10];
        v12 = &a2[v10];
        v13 = type metadata accessor for NWEndpoint.Port(0);
        (*(void (**)(char *, char *, uint64_t))(*(_QWORD *)(v13 - 8) + 32))(v11, v12, v13);
        *(_OWORD *)&a1[v9[6]] = *(_OWORD *)&a2[v9[6]];
        *(_WORD *)&a1[v9[7]] = *(_WORD *)&a2[v9[7]];
        *(_WORD *)&a1[v9[8]] = *(_WORD *)&a2[v9[8]];
        swift_storeEnumTagMultiPayload(a1, v7, 2);
      }
      else
      {
        memcpy(a1, a2, *(_QWORD *)(*(_QWORD *)(v7 - 8) + 64));
      }
      v22 = a1;
      v23 = a3;
      v24 = 1;
LABEL_13:
      swift_storeEnumTagMultiPayload(v22, v23, v24);
      return a1;
    }
    memcpy(a1, a2, *(_QWORD *)(*(_QWORD *)(a3 - 8) + 64));
  }
  return a1;
}

uint64_t sub_1000EC8F0(uint64_t a1)
{
  uint64_t result;
  unint64_t v3;
  unint64_t v4;
  _QWORD v5[21];

  v5[0] = &unk_100343F70;
  result = type metadata accessor for AWDLActionFrame.ServiceResponse(319);
  if (v3 <= 0x3F)
  {
    v5[1] = *(_QWORD *)(result - 8) + 64;
    v5[2] = &unk_100343F88;
    v5[3] = &unk_100343FA0;
    v5[4] = (char *)&value witness table for Builtin.BridgeObject + 64;
    v5[5] = &unk_100343FB8;
    result = type metadata accessor for AWDLActionFrame.DataPathState(319);
    if (v4 <= 0x3F)
    {
      v5[6] = *(_QWORD *)(result - 8) + 64;
      v5[7] = &unk_100343FD0;
      v5[8] = (char *)&value witness table for Builtin.BridgeObject + 64;
      v5[9] = &unk_100343FE8;
      v5[10] = &unk_100343F70;
      v5[11] = &unk_100344000;
      v5[12] = &unk_100344018;
      v5[13] = &unk_100344030;
      v5[14] = &unk_100344048;
      v5[15] = &unk_100344060;
      v5[16] = &unk_100343D40;
      v5[17] = &unk_100344078;
      v5[18] = &unk_100343F70;
      v5[19] = &unk_100344090;
      v5[20] = &unk_1003440A8;
      swift_initEnumMetadataMultiPayload(a1, 256, 21, v5);
      return 0;
    }
  }
  return result;
}

uint64_t getEnumTagSinglePayload for AWDLActionFrame.AWDLAttribute.AttributeType(unsigned __int8 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0xEA)
    goto LABEL_17;
  if (a2 + 22 >= 0xFFFF00)
    v2 = 4;
  else
    v2 = 2;
  if ((a2 + 22) >> 8 < 0xFF)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 8)) - 22;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1))
        goto LABEL_17;
      return (*a1 | (v4 << 8)) - 22;
    }
    v4 = a1[1];
    if (a1[1])
      return (*a1 | (v4 << 8)) - 22;
  }
LABEL_17:
  v6 = *a1;
  v7 = v6 >= 0x17;
  v8 = v6 - 23;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for AWDLActionFrame.AWDLAttribute.AttributeType(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 22 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 22) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xEA)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xE9)
    return ((uint64_t (*)(void))((char *)&loc_1000ECB00 + 4 * byte_100341541[v4]))();
  *a1 = a2 + 22;
  return ((uint64_t (*)(void))((char *)sub_1000ECB34 + 4 * byte_10034153C[v4]))();
}

uint64_t sub_1000ECB34(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000ECB3C(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x1000ECB44);
  return result;
}

uint64_t sub_1000ECB50(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x1000ECB58);
  *(_BYTE *)result = a2 + 22;
  return result;
}

uint64_t sub_1000ECB5C(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000ECB64(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.AWDLAttribute.AttributeType()
{
  return &type metadata for AWDLActionFrame.AWDLAttribute.AttributeType;
}

_QWORD *initializeBufferWithCopyOfBuffer for AWDLActionFrame.Header(uint64_t a1, uint64_t *a2, int *a3)
{
  _QWORD *v4;
  int v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void (*v11)(uint64_t, uint64_t, uint64_t);
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v4 = (_QWORD *)a1;
  v5 = *(_DWORD *)(*((_QWORD *)a3 - 1) + 80);
  if ((v5 & 0x20000) != 0)
  {
    v17 = *a2;
    *v4 = *a2;
    v4 = (_QWORD *)(v17 + ((v5 + 16) & ~(unint64_t)v5));
    swift_retain(v17);
  }
  else
  {
    *(_DWORD *)a1 = *(_DWORD *)a2;
    *(_WORD *)(a1 + 4) = *((_WORD *)a2 + 2);
    *(_DWORD *)(a1 + 6) = *(_DWORD *)((char *)a2 + 6);
    *(_WORD *)(a1 + 10) = *((_WORD *)a2 + 5);
    *(_DWORD *)(a1 + 12) = *((_DWORD *)a2 + 3);
    *(_WORD *)(a1 + 16) = *((_WORD *)a2 + 8);
    *(_DWORD *)(a1 + 20) = *((_DWORD *)a2 + 5);
    v7 = a3[8];
    v8 = a1 + v7;
    v9 = (uint64_t)a2 + v7;
    v10 = type metadata accessor for DispatchTimeInterval(0);
    v11 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v10 - 8) + 16);
    v11(v8, v9, v10);
    v11((uint64_t)v4 + a3[9], (uint64_t)a2 + a3[9], v10);
    v12 = a3[11];
    *(_DWORD *)((char *)v4 + a3[10]) = *(_DWORD *)((char *)a2 + a3[10]);
    *(_DWORD *)((char *)v4 + v12) = *(_DWORD *)((char *)a2 + v12);
    v13 = a3[13];
    *(_QWORD *)((char *)v4 + a3[12]) = *(uint64_t *)((char *)a2 + a3[12]);
    *(_DWORD *)((char *)v4 + v13) = *(_DWORD *)((char *)a2 + v13);
    v14 = a3[15];
    *(_QWORD *)((char *)v4 + a3[14]) = *(uint64_t *)((char *)a2 + a3[14]);
    *(_DWORD *)((char *)v4 + v14) = *(_DWORD *)((char *)a2 + v14);
    v15 = a3[16];
    v16 = *(uint64_t *)((char *)a2 + v15);
    *(_QWORD *)((char *)v4 + v15) = v16;
    swift_bridgeObjectRetain(v16);
  }
  return v4;
}

uint64_t destroy for AWDLActionFrame.Header(uint64_t a1, int *a2)
{
  uint64_t v4;
  uint64_t v5;
  void (*v6)(uint64_t, uint64_t);

  v4 = a1 + a2[8];
  v5 = type metadata accessor for DispatchTimeInterval(0);
  v6 = *(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 8);
  v6(v4, v5);
  v6(a1 + a2[9], v5);
  return swift_bridgeObjectRelease(*(_QWORD *)(a1 + a2[16]));
}

uint64_t initializeWithCopy for AWDLActionFrame.Header(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void (*v10)(uint64_t, uint64_t, uint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_WORD *)(a1 + 4) = *(_WORD *)(a2 + 4);
  *(_DWORD *)(a1 + 6) = *(_DWORD *)(a2 + 6);
  *(_WORD *)(a1 + 10) = *(_WORD *)(a2 + 10);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  *(_WORD *)(a1 + 16) = *(_WORD *)(a2 + 16);
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 20);
  v6 = a3[8];
  v7 = a1 + v6;
  v8 = a2 + v6;
  v9 = type metadata accessor for DispatchTimeInterval(0);
  v10 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v9 - 8) + 16);
  v10(v7, v8, v9);
  v10(a1 + a3[9], a2 + a3[9], v9);
  v11 = a3[11];
  *(_DWORD *)(a1 + a3[10]) = *(_DWORD *)(a2 + a3[10]);
  *(_DWORD *)(a1 + v11) = *(_DWORD *)(a2 + v11);
  v12 = a3[13];
  *(_QWORD *)(a1 + a3[12]) = *(_QWORD *)(a2 + a3[12]);
  *(_DWORD *)(a1 + v12) = *(_DWORD *)(a2 + v12);
  v13 = a3[15];
  *(_QWORD *)(a1 + a3[14]) = *(_QWORD *)(a2 + a3[14]);
  *(_DWORD *)(a1 + v13) = *(_DWORD *)(a2 + v13);
  v14 = a3[16];
  v15 = *(_QWORD *)(a2 + v14);
  *(_QWORD *)(a1 + v14) = v15;
  swift_bridgeObjectRetain(v15);
  return a1;
}

uint64_t assignWithCopy for AWDLActionFrame.Header(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void (*v10)(uint64_t, uint64_t, uint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_BYTE *)(a1 + 1) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)(a1 + 2) = *(_BYTE *)(a2 + 2);
  *(_BYTE *)(a1 + 3) = *(_BYTE *)(a2 + 3);
  *(_BYTE *)(a1 + 4) = *(_BYTE *)(a2 + 4);
  *(_BYTE *)(a1 + 5) = *(_BYTE *)(a2 + 5);
  *(_BYTE *)(a1 + 6) = *(_BYTE *)(a2 + 6);
  *(_BYTE *)(a1 + 7) = *(_BYTE *)(a2 + 7);
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
  *(_BYTE *)(a1 + 9) = *(_BYTE *)(a2 + 9);
  *(_BYTE *)(a1 + 10) = *(_BYTE *)(a2 + 10);
  *(_BYTE *)(a1 + 11) = *(_BYTE *)(a2 + 11);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  *(_BYTE *)(a1 + 17) = *(_BYTE *)(a2 + 17);
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 20);
  v6 = a3[8];
  v7 = a1 + v6;
  v8 = a2 + v6;
  v9 = type metadata accessor for DispatchTimeInterval(0);
  v10 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v9 - 8) + 24);
  v10(v7, v8, v9);
  v10(a1 + a3[9], a2 + a3[9], v9);
  *(_DWORD *)(a1 + a3[10]) = *(_DWORD *)(a2 + a3[10]);
  *(_DWORD *)(a1 + a3[11]) = *(_DWORD *)(a2 + a3[11]);
  *(_QWORD *)(a1 + a3[12]) = *(_QWORD *)(a2 + a3[12]);
  *(_DWORD *)(a1 + a3[13]) = *(_DWORD *)(a2 + a3[13]);
  *(_QWORD *)(a1 + a3[14]) = *(_QWORD *)(a2 + a3[14]);
  *(_DWORD *)(a1 + a3[15]) = *(_DWORD *)(a2 + a3[15]);
  v11 = a3[16];
  v12 = *(_QWORD *)(a2 + v11);
  v13 = *(_QWORD *)(a1 + v11);
  *(_QWORD *)(a1 + v11) = v12;
  swift_bridgeObjectRetain(v12);
  swift_bridgeObjectRelease(v13);
  return a1;
}

uint64_t initializeWithTake for AWDLActionFrame.Header(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void (*v10)(uint64_t, uint64_t, uint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_WORD *)(a1 + 4) = *(_WORD *)(a2 + 4);
  *(_DWORD *)(a1 + 6) = *(_DWORD *)(a2 + 6);
  *(_WORD *)(a1 + 10) = *(_WORD *)(a2 + 10);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  *(_WORD *)(a1 + 16) = *(_WORD *)(a2 + 16);
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 20);
  v6 = a3[8];
  v7 = a1 + v6;
  v8 = a2 + v6;
  v9 = type metadata accessor for DispatchTimeInterval(0);
  v10 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v9 - 8) + 32);
  v10(v7, v8, v9);
  v10(a1 + a3[9], a2 + a3[9], v9);
  v11 = a3[11];
  *(_DWORD *)(a1 + a3[10]) = *(_DWORD *)(a2 + a3[10]);
  *(_DWORD *)(a1 + v11) = *(_DWORD *)(a2 + v11);
  v12 = a3[13];
  *(_QWORD *)(a1 + a3[12]) = *(_QWORD *)(a2 + a3[12]);
  *(_DWORD *)(a1 + v12) = *(_DWORD *)(a2 + v12);
  v13 = a3[15];
  *(_QWORD *)(a1 + a3[14]) = *(_QWORD *)(a2 + a3[14]);
  *(_DWORD *)(a1 + v13) = *(_DWORD *)(a2 + v13);
  *(_QWORD *)(a1 + a3[16]) = *(_QWORD *)(a2 + a3[16]);
  return a1;
}

uint64_t assignWithTake for AWDLActionFrame.Header(uint64_t a1, uint64_t a2, int *a3)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void (*v11)(uint64_t, uint64_t, uint64_t);
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  v6 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 12) = v6;
  *(_WORD *)(a1 + 16) = *(_WORD *)(a2 + 16);
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 20);
  v7 = a3[8];
  v8 = a1 + v7;
  v9 = a2 + v7;
  v10 = type metadata accessor for DispatchTimeInterval(0);
  v11 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v10 - 8) + 40);
  v11(v8, v9, v10);
  v11(a1 + a3[9], a2 + a3[9], v10);
  v12 = a3[11];
  *(_DWORD *)(a1 + a3[10]) = *(_DWORD *)(a2 + a3[10]);
  *(_DWORD *)(a1 + v12) = *(_DWORD *)(a2 + v12);
  v13 = a3[13];
  *(_QWORD *)(a1 + a3[12]) = *(_QWORD *)(a2 + a3[12]);
  *(_DWORD *)(a1 + v13) = *(_DWORD *)(a2 + v13);
  v14 = a3[15];
  *(_QWORD *)(a1 + a3[14]) = *(_QWORD *)(a2 + a3[14]);
  *(_DWORD *)(a1 + v14) = *(_DWORD *)(a2 + v14);
  v15 = a3[16];
  v16 = *(_QWORD *)(a1 + v15);
  *(_QWORD *)(a1 + v15) = *(_QWORD *)(a2 + v15);
  swift_bridgeObjectRelease(v16);
  return a1;
}

uint64_t getEnumTagSinglePayload for AWDLActionFrame.Header(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getEnumTagSinglePayloadGeneric(a1, a2, a3, sub_1000ED198);
}

uint64_t sub_1000ED198(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t v9;

  v6 = type metadata accessor for DispatchTimeInterval(0);
  v7 = *(_QWORD *)(v6 - 8);
  if (*(_DWORD *)(v7 + 84) == (_DWORD)a2)
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v7 + 48))(a1 + *(int *)(a3 + 32), a2, v6);
  v9 = *(_QWORD *)(a1 + *(int *)(a3 + 64));
  if (v9 >= 0xFFFFFFFF)
    LODWORD(v9) = -1;
  return (v9 + 1);
}

uint64_t storeEnumTagSinglePayload for AWDLActionFrame.Header(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return swift_storeEnumTagSinglePayloadGeneric(a1, a2, a3, a4, sub_1000ED224);
}

uint64_t sub_1000ED224(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v9;

  result = type metadata accessor for DispatchTimeInterval(0);
  v9 = *(_QWORD *)(result - 8);
  if (*(_DWORD *)(v9 + 84) == a3)
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 56))(a1 + *(int *)(a4 + 32), a2, a2, result);
  *(_QWORD *)(a1 + *(int *)(a4 + 64)) = (a2 - 1);
  return result;
}

uint64_t sub_1000ED2A0(uint64_t a1)
{
  uint64_t result;
  unint64_t v3;
  _QWORD v4[4];
  uint64_t v5;
  uint64_t v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  char *v13;

  v4[0] = &unk_1003440D8;
  v4[1] = &unk_1003440D8;
  v4[2] = &unk_1003440F0;
  v4[3] = (char *)&value witness table for Builtin.Int32 + 64;
  result = type metadata accessor for DispatchTimeInterval(319);
  if (v3 <= 0x3F)
  {
    v5 = *(_QWORD *)(result - 8) + 64;
    v6 = v5;
    v7 = (char *)&value witness table for Builtin.Int32 + 64;
    v8 = (char *)&value witness table for Builtin.Int32 + 64;
    v9 = (char *)&value witness table for Builtin.Int64 + 64;
    v10 = (char *)&value witness table for Builtin.Int32 + 64;
    v11 = (char *)&value witness table for Builtin.Int64 + 64;
    v12 = (char *)&value witness table for Builtin.Int32 + 64;
    v13 = (char *)&value witness table for Builtin.BridgeObject + 64;
    swift_initStructMetadata(a1, 256, 13, v4, a1 + 16);
    return 0;
  }
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.Header.Flags()
{
  return &type metadata for AWDLActionFrame.Header.Flags;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.AirDrop.CodingKeys()
{
  return &type metadata for AWDLActionFrame.AirDrop.CodingKeys;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.ProMode.CodingKeys()
{
  return &type metadata for AWDLActionFrame.ProMode.CodingKeys;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.ExtendedChannelSequence.CodingKeys()
{
  return &type metadata for AWDLActionFrame.ExtendedChannelSequence.CodingKeys;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.Ranging.CodingKeys()
{
  return &type metadata for AWDLActionFrame.Ranging.CodingKeys;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.MultiPeerBSSSteering.CodingKeys()
{
  return &type metadata for AWDLActionFrame.MultiPeerBSSSteering.CodingKeys;
}

uint64_t getEnumTagSinglePayload for AWDLActionFrame.ElectionParameter.CodingKeys(unsigned __int8 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0xF8)
    goto LABEL_17;
  if (a2 + 8 >= 0xFFFF00)
    v2 = 4;
  else
    v2 = 2;
  if ((a2 + 8) >> 8 < 0xFF)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 8)) - 8;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1))
        goto LABEL_17;
      return (*a1 | (v4 << 8)) - 8;
    }
    v4 = a1[1];
    if (a1[1])
      return (*a1 | (v4 << 8)) - 8;
  }
LABEL_17:
  v6 = *a1;
  v7 = v6 >= 9;
  v8 = v6 - 9;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for AWDLActionFrame.ElectionParameter.CodingKeys(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 8 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 8) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xF8)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xF7)
    return ((uint64_t (*)(void))((char *)&loc_1000ED494 + 4 * byte_10034154B[v4]))();
  *a1 = a2 + 8;
  return ((uint64_t (*)(void))((char *)sub_1000ED4C8 + 4 * byte_100341546[v4]))();
}

uint64_t sub_1000ED4C8(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000ED4D0(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x1000ED4D8);
  return result;
}

uint64_t sub_1000ED4E4(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x1000ED4ECLL);
  *(_BYTE *)result = a2 + 8;
  return result;
}

uint64_t sub_1000ED4F0(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000ED4F8(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.ElectionParameter.CodingKeys()
{
  return &type metadata for AWDLActionFrame.ElectionParameter.CodingKeys;
}

uint64_t getEnumTagSinglePayload for NANDataHostAssistRequest.Reason(unsigned __int8 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0xF7)
    goto LABEL_17;
  if (a2 + 9 >= 0xFFFF00)
    v2 = 4;
  else
    v2 = 2;
  if ((a2 + 9) >> 8 < 0xFF)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 8)) - 9;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1))
        goto LABEL_17;
      return (*a1 | (v4 << 8)) - 9;
    }
    v4 = a1[1];
    if (a1[1])
      return (*a1 | (v4 << 8)) - 9;
  }
LABEL_17:
  v6 = *a1;
  v7 = v6 >= 0xA;
  v8 = v6 - 10;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for AWDLActionFrame.NANSynchronization.CodingKeys(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 9 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 9) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xF7)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xF6)
    return ((uint64_t (*)(void))((char *)&loc_1000ED5F0 + 4 * byte_100341555[v4]))();
  *a1 = a2 + 9;
  return ((uint64_t (*)(void))((char *)sub_1000ED624 + 4 * byte_100341550[v4]))();
}

uint64_t sub_1000ED624(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000ED62C(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x1000ED634);
  return result;
}

uint64_t sub_1000ED640(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x1000ED648);
  *(_BYTE *)result = a2 + 9;
  return result;
}

uint64_t sub_1000ED64C(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000ED654(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.NANSynchronization.CodingKeys()
{
  return &type metadata for AWDLActionFrame.NANSynchronization.CodingKeys;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.PeerMACAddressListBloomFilter.CodingKeys()
{
  return &type metadata for AWDLActionFrame.PeerMACAddressListBloomFilter.CodingKeys;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.Version.CodingKeys()
{
  return &type metadata for AWDLActionFrame.Version.CodingKeys;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.AWDLVersion.CodingKeys()
{
  return &type metadata for AWDLActionFrame.AWDLVersion.CodingKeys;
}

uint64_t _s7CoreP2P15AWDLActionFrameV7OUITypeOwst_0(uint64_t a1, int a2, int a3)
{
  int v3;
  uint64_t v4;

  if ((a3 + 1) >= 0x10000)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 1) < 0x100)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3)
    v4 = v4;
  else
    v4 = 0;
  if (a2)
    return ((uint64_t (*)(void))((char *)sub_1000ED6E0 + 4 * byte_10034155A[v4]))();
  else
    return ((uint64_t (*)(void))((char *)sub_1000ED700 + 4 * byte_10034155F[v4]))();
}

_BYTE *sub_1000ED6E0(_BYTE *result, char a2)
{
  *result = a2;
  return result;
}

_BYTE *sub_1000ED700(_BYTE *result)
{
  *result = 0;
  return result;
}

_DWORD *sub_1000ED708(_DWORD *result, int a2)
{
  *result = a2;
  return result;
}

_WORD *sub_1000ED710(_WORD *result, __int16 a2)
{
  *result = a2;
  return result;
}

_WORD *sub_1000ED718(_WORD *result)
{
  *result = 0;
  return result;
}

_DWORD *sub_1000ED720(_DWORD *result)
{
  *result = 0;
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.SyncTreePath.CodingKeys()
{
  return &type metadata for AWDLActionFrame.SyncTreePath.CodingKeys;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.DataPathState.ExtensionFlags()
{
  return &type metadata for AWDLActionFrame.DataPathState.ExtensionFlags;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.DataPathState.Flags()
{
  return &type metadata for AWDLActionFrame.DataPathState.Flags;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.ServiceParameter.CodingKeys()
{
  return &type metadata for AWDLActionFrame.ServiceParameter.CodingKeys;
}

uint64_t _s7CoreP2P15AWDLActionFrameV10OUISubtypeOwst_0(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 1 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 1) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xFF)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xFE)
    return ((uint64_t (*)(void))((char *)&loc_1000ED7B8 + 4 * byte_100341569[v4]))();
  *a1 = a2 + 1;
  return ((uint64_t (*)(void))((char *)sub_1000ED7EC + 4 * byte_100341564[v4]))();
}

uint64_t sub_1000ED7EC(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000ED7F4(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x1000ED7FCLL);
  return result;
}

uint64_t sub_1000ED808(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x1000ED810);
  *(_BYTE *)result = a2 + 1;
  return result;
}

uint64_t sub_1000ED814(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000ED81C(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.ServiceParameter.SSTH.CodingKeys()
{
  return &type metadata for AWDLActionFrame.ServiceParameter.SSTH.CodingKeys;
}

uint64_t _s7CoreP2P15AWDLActionFrameV7ProModeV7CommandOwst_0(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 2 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 2) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xFE)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xFD)
    return ((uint64_t (*)(void))((char *)&loc_1000ED884 + 4 * byte_100341573[v4]))();
  *a1 = a2 + 2;
  return ((uint64_t (*)(void))((char *)sub_1000ED8B8 + 4 * byte_10034156E[v4]))();
}

uint64_t sub_1000ED8B8(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000ED8C0(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x1000ED8C8);
  return result;
}

uint64_t sub_1000ED8D4(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x1000ED8DCLL);
  *(_BYTE *)result = a2 + 2;
  return result;
}

uint64_t sub_1000ED8E0(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000ED8E8(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.ServiceRequest.CodingKeys()
{
  return &type metadata for AWDLActionFrame.ServiceRequest.CodingKeys;
}

unint64_t sub_1000ED908()
{
  unint64_t result;

  result = qword_1004078A8;
  if (!qword_1004078A8)
  {
    result = swift_getWitnessTable(aE, &type metadata for AWDLActionFrame.ServiceRequest.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004078A8);
  }
  return result;
}

unint64_t sub_1000ED950()
{
  unint64_t result;

  result = qword_1004078B0;
  if (!qword_1004078B0)
  {
    result = swift_getWitnessTable(byte_10034426C, &type metadata for AWDLActionFrame.ServiceParameter.SSTH.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004078B0);
  }
  return result;
}

unint64_t sub_1000ED998()
{
  unint64_t result;

  result = qword_1004078B8;
  if (!qword_1004078B8)
  {
    result = swift_getWitnessTable(byte_100344324, &type metadata for AWDLActionFrame.ServiceParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004078B8);
  }
  return result;
}

unint64_t sub_1000ED9E0()
{
  unint64_t result;

  result = qword_1004078C0;
  if (!qword_1004078C0)
  {
    result = swift_getWitnessTable(asc_10034437C, &type metadata for AWDLActionFrame.DataPathState.Flags);
    atomic_store(result, (unint64_t *)&qword_1004078C0);
  }
  return result;
}

unint64_t sub_1000EDA28()
{
  unint64_t result;

  result = qword_1004078C8;
  if (!qword_1004078C8)
  {
    result = swift_getWitnessTable(byte_10034434C, &type metadata for AWDLActionFrame.DataPathState.Flags);
    atomic_store(result, (unint64_t *)&qword_1004078C8);
  }
  return result;
}

unint64_t sub_1000EDA70()
{
  unint64_t result;

  result = qword_1004078D0;
  if (!qword_1004078D0)
  {
    result = swift_getWitnessTable(aE_0, &type metadata for AWDLActionFrame.DataPathState.Flags);
    atomic_store(result, (unint64_t *)&qword_1004078D0);
  }
  return result;
}

unint64_t sub_1000EDAB8()
{
  unint64_t result;

  result = qword_1004078D8;
  if (!qword_1004078D8)
  {
    result = swift_getWitnessTable(byte_1003443DC, &type metadata for AWDLActionFrame.DataPathState.Flags);
    atomic_store(result, (unint64_t *)&qword_1004078D8);
  }
  return result;
}

unint64_t sub_1000EDB00()
{
  unint64_t result;

  result = qword_1004078E0;
  if (!qword_1004078E0)
  {
    result = swift_getWitnessTable(byte_10034454C, &type metadata for AWDLActionFrame.DataPathState.ExtensionFlags);
    atomic_store(result, (unint64_t *)&qword_1004078E0);
  }
  return result;
}

unint64_t sub_1000EDB48()
{
  unint64_t result;

  result = qword_1004078E8;
  if (!qword_1004078E8)
  {
    result = swift_getWitnessTable(asc_10034451C, &type metadata for AWDLActionFrame.DataPathState.ExtensionFlags);
    atomic_store(result, (unint64_t *)&qword_1004078E8);
  }
  return result;
}

unint64_t sub_1000EDB90()
{
  unint64_t result;

  result = qword_1004078F0;
  if (!qword_1004078F0)
  {
    result = swift_getWitnessTable(byte_100344574, &type metadata for AWDLActionFrame.DataPathState.ExtensionFlags);
    atomic_store(result, (unint64_t *)&qword_1004078F0);
  }
  return result;
}

unint64_t sub_1000EDBD8()
{
  unint64_t result;

  result = qword_1004078F8;
  if (!qword_1004078F8)
  {
    result = swift_getWitnessTable(byte_1003445AC, &type metadata for AWDLActionFrame.DataPathState.ExtensionFlags);
    atomic_store(result, (unint64_t *)&qword_1004078F8);
  }
  return result;
}

unint64_t sub_1000EDC20()
{
  unint64_t result;

  result = qword_100407900;
  if (!qword_100407900)
  {
    result = swift_getWitnessTable(asc_10034477C, &type metadata for AWDLActionFrame.SyncTreePath.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407900);
  }
  return result;
}

unint64_t sub_1000EDC68()
{
  unint64_t result;

  result = qword_100407908;
  if (!qword_100407908)
  {
    result = swift_getWitnessTable(byte_100344834, &type metadata for AWDLActionFrame.AWDLVersion.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407908);
  }
  return result;
}

unint64_t sub_1000EDCB0()
{
  unint64_t result;

  result = qword_100407910;
  if (!qword_100407910)
  {
    result = swift_getWitnessTable(asc_1003448EC, &type metadata for AWDLActionFrame.Version.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407910);
  }
  return result;
}

unint64_t sub_1000EDCF8()
{
  unint64_t result;

  result = qword_100407918;
  if (!qword_100407918)
  {
    result = swift_getWitnessTable(aU_0, &type metadata for AWDLActionFrame.PeerMACAddressListBloomFilter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407918);
  }
  return result;
}

unint64_t sub_1000EDD40()
{
  unint64_t result;

  result = qword_100407920;
  if (!qword_100407920)
  {
    result = swift_getWitnessTable(byte_100344A5C, &type metadata for AWDLActionFrame.NANSynchronization.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407920);
  }
  return result;
}

unint64_t sub_1000EDD88()
{
  unint64_t result;

  result = qword_100407928;
  if (!qword_100407928)
  {
    result = swift_getWitnessTable(byte_100344B14, &type metadata for AWDLActionFrame.ElectionParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407928);
  }
  return result;
}

unint64_t sub_1000EDDD0()
{
  unint64_t result;

  result = qword_100407930;
  if (!qword_100407930)
  {
    result = swift_getWitnessTable(asc_100344BCC, &type metadata for AWDLActionFrame.MultiPeerBSSSteering.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407930);
  }
  return result;
}

unint64_t sub_1000EDE18()
{
  unint64_t result;

  result = qword_100407938;
  if (!qword_100407938)
  {
    result = swift_getWitnessTable(aU_1, &type metadata for AWDLActionFrame.Ranging.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407938);
  }
  return result;
}

unint64_t sub_1000EDE60()
{
  unint64_t result;

  result = qword_100407940;
  if (!qword_100407940)
  {
    result = swift_getWitnessTable(aM_1, &type metadata for AWDLActionFrame.ProMode.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407940);
  }
  return result;
}

unint64_t sub_1000EDEA8()
{
  unint64_t result;

  result = qword_100407948;
  if (!qword_100407948)
  {
    result = swift_getWitnessTable(byte_100344E44, &type metadata for AWDLActionFrame.AirDrop.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407948);
  }
  return result;
}

unint64_t sub_1000EDEF0()
{
  unint64_t result;

  result = qword_100407950;
  if (!qword_100407950)
  {
    result = swift_getWitnessTable(byte_100344DB4, &type metadata for AWDLActionFrame.AirDrop.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407950);
  }
  return result;
}

unint64_t sub_1000EDF38()
{
  unint64_t result;

  result = qword_100407958;
  if (!qword_100407958)
  {
    result = swift_getWitnessTable(byte_100344DDC, &type metadata for AWDLActionFrame.AirDrop.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407958);
  }
  return result;
}

unint64_t sub_1000EDF80()
{
  unint64_t result;

  result = qword_100407960;
  if (!qword_100407960)
  {
    result = swift_getWitnessTable(byte_100344CFC, &type metadata for AWDLActionFrame.ProMode.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407960);
  }
  return result;
}

unint64_t sub_1000EDFC8()
{
  unint64_t result;

  result = qword_100407968;
  if (!qword_100407968)
  {
    result = swift_getWitnessTable(aU_2, &type metadata for AWDLActionFrame.ProMode.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407968);
  }
  return result;
}

unint64_t sub_1000EE010()
{
  unint64_t result;

  result = qword_100407970;
  if (!qword_100407970)
  {
    result = swift_getWitnessTable(byte_100344CAC, &type metadata for AWDLActionFrame.ExtendedChannelSequence.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407970);
  }
  return result;
}

unint64_t sub_1000EE058()
{
  unint64_t result;

  result = qword_100407978;
  if (!qword_100407978)
  {
    result = swift_getWitnessTable(byte_100344CD4, &type metadata for AWDLActionFrame.ExtendedChannelSequence.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407978);
  }
  return result;
}

unint64_t sub_1000EE0A0()
{
  unint64_t result;

  result = qword_100407980;
  if (!qword_100407980)
  {
    result = swift_getWitnessTable(byte_100344BF4, &type metadata for AWDLActionFrame.Ranging.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407980);
  }
  return result;
}

unint64_t sub_1000EE0E8()
{
  unint64_t result;

  result = qword_100407988;
  if (!qword_100407988)
  {
    result = swift_getWitnessTable(asc_100344C1C, &type metadata for AWDLActionFrame.Ranging.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407988);
  }
  return result;
}

unint64_t sub_1000EE130()
{
  unint64_t result;

  result = qword_100407990;
  if (!qword_100407990)
  {
    result = swift_getWitnessTable(aM_2, &type metadata for AWDLActionFrame.MultiPeerBSSSteering.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407990);
  }
  return result;
}

unint64_t sub_1000EE178()
{
  unint64_t result;

  result = qword_100407998;
  if (!qword_100407998)
  {
    result = swift_getWitnessTable(a5_0, &type metadata for AWDLActionFrame.MultiPeerBSSSteering.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407998);
  }
  return result;
}

unint64_t sub_1000EE1C0()
{
  unint64_t result;

  result = qword_1004079A0;
  if (!qword_1004079A0)
  {
    result = swift_getWitnessTable(byte_100344A84, &type metadata for AWDLActionFrame.ElectionParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004079A0);
  }
  return result;
}

unint64_t sub_1000EE208()
{
  unint64_t result;

  result = qword_1004079A8;
  if (!qword_1004079A8)
  {
    result = swift_getWitnessTable(byte_100344AAC, &type metadata for AWDLActionFrame.ElectionParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004079A8);
  }
  return result;
}

unint64_t sub_1000EE250()
{
  unint64_t result;

  result = qword_1004079B0;
  if (!qword_1004079B0)
  {
    result = swift_getWitnessTable(byte_1003449CC, &type metadata for AWDLActionFrame.NANSynchronization.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004079B0);
  }
  return result;
}

unint64_t sub_1000EE298()
{
  unint64_t result;

  result = qword_1004079B8;
  if (!qword_1004079B8)
  {
    result = swift_getWitnessTable(byte_1003449F4, &type metadata for AWDLActionFrame.NANSynchronization.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004079B8);
  }
  return result;
}

unint64_t sub_1000EE2E0()
{
  unint64_t result;

  result = qword_1004079C0;
  if (!qword_1004079C0)
  {
    result = swift_getWitnessTable(aU_3, &type metadata for AWDLActionFrame.PeerMACAddressListBloomFilter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004079C0);
  }
  return result;
}

unint64_t sub_1000EE328()
{
  unint64_t result;

  result = qword_1004079C8;
  if (!qword_1004079C8)
  {
    result = swift_getWitnessTable(asc_10034493C, &type metadata for AWDLActionFrame.PeerMACAddressListBloomFilter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004079C8);
  }
  return result;
}

unint64_t sub_1000EE370()
{
  unint64_t result;

  result = qword_1004079D0;
  if (!qword_1004079D0)
  {
    result = swift_getWitnessTable(asc_10034485C, &type metadata for AWDLActionFrame.Version.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004079D0);
  }
  return result;
}

unint64_t sub_1000EE3B8()
{
  unint64_t result;

  result = qword_1004079D8;
  if (!qword_1004079D8)
  {
    result = swift_getWitnessTable(byte_100344884, &type metadata for AWDLActionFrame.Version.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004079D8);
  }
  return result;
}

unint64_t sub_1000EE400()
{
  unint64_t result;

  result = qword_1004079E0;
  if (!qword_1004079E0)
  {
    result = swift_getWitnessTable(byte_1003447A4, &type metadata for AWDLActionFrame.AWDLVersion.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004079E0);
  }
  return result;
}

unint64_t sub_1000EE448()
{
  unint64_t result;

  result = qword_1004079E8;
  if (!qword_1004079E8)
  {
    result = swift_getWitnessTable(byte_1003447CC, &type metadata for AWDLActionFrame.AWDLVersion.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004079E8);
  }
  return result;
}

unint64_t sub_1000EE490()
{
  unint64_t result;

  result = qword_1004079F0;
  if (!qword_1004079F0)
  {
    result = swift_getWitnessTable(byte_1003446EC, &type metadata for AWDLActionFrame.SyncTreePath.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004079F0);
  }
  return result;
}

unint64_t sub_1000EE4D8()
{
  unint64_t result;

  result = qword_1004079F8;
  if (!qword_1004079F8)
  {
    result = swift_getWitnessTable(byte_100344714, &type metadata for AWDLActionFrame.SyncTreePath.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_1004079F8);
  }
  return result;
}

unint64_t sub_1000EE520()
{
  unint64_t result;

  result = qword_100407A00;
  if (!qword_100407A00)
  {
    result = swift_getWitnessTable(byte_100344294, &type metadata for AWDLActionFrame.ServiceParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407A00);
  }
  return result;
}

unint64_t sub_1000EE568()
{
  unint64_t result;

  result = qword_100407A08;
  if (!qword_100407A08)
  {
    result = swift_getWitnessTable(byte_1003442BC, &type metadata for AWDLActionFrame.ServiceParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407A08);
  }
  return result;
}

unint64_t sub_1000EE5B0()
{
  unint64_t result;

  result = qword_100407A10;
  if (!qword_100407A10)
  {
    result = swift_getWitnessTable(byte_1003441DC, &type metadata for AWDLActionFrame.ServiceParameter.SSTH.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407A10);
  }
  return result;
}

unint64_t sub_1000EE5F8()
{
  unint64_t result;

  result = qword_100407A18;
  if (!qword_100407A18)
  {
    result = swift_getWitnessTable(byte_100344204, &type metadata for AWDLActionFrame.ServiceParameter.SSTH.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407A18);
  }
  return result;
}

unint64_t sub_1000EE640()
{
  unint64_t result;

  result = qword_100407A20;
  if (!qword_100407A20)
  {
    result = swift_getWitnessTable(aE_1, &type metadata for AWDLActionFrame.ServiceRequest.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407A20);
  }
  return result;
}

unint64_t sub_1000EE688()
{
  unint64_t result;

  result = qword_100407A28;
  if (!qword_100407A28)
  {
    result = swift_getWitnessTable(aM_3, &type metadata for AWDLActionFrame.ServiceRequest.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407A28);
  }
  return result;
}

uint64_t sub_1000EE6CC(uint64_t a1, unint64_t a2)
{
  unint64_t v5;
  unint64_t v7;
  char v8;

  if (a1 == 0x6574736575716572 && a2 == 0xEF74657366664F64)
  {
    v5 = 0xEF74657366664F64;
    goto LABEL_8;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6574736575716572, 0xEF74657366664F64, a1, a2, 0) & 1) != 0)
  {
    v5 = a2;
LABEL_8:
    swift_bridgeObjectRelease(v5);
    return 0;
  }
  if (a1 == 0x6574736575716572 && a2 == 0xEF6874676E654C64)
  {
    v7 = 0xEF6874676E654C64;
LABEL_14:
    swift_bridgeObjectRelease(v7);
    return 1;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6574736575716572, 0xEF6874676E654C64, a1, a2, 0) & 1) != 0)
  {
    v7 = a2;
    goto LABEL_14;
  }
  if (a1 == 7955819 && a2 == 0xE300000000000000)
  {
    swift_bridgeObjectRelease(0xE300000000000000);
    return 2;
  }
  else
  {
    v8 = _stringCompareWithSmolCheck(_:_:expecting:)(7955819, 0xE300000000000000, a1, a2, 0);
    swift_bridgeObjectRelease(a2);
    if ((v8 & 1) != 0)
      return 2;
    else
      return 3;
  }
}

uint64_t sub_1000EE850(uint64_t a1, unint64_t a2)
{
  unint64_t v5;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  char v25;

  if (a1 == 0x74696D736E617274 && a2 == 0xEF6C656E6E616843)
  {
    v5 = 0xEF6C656E6E616843;
    goto LABEL_8;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x74696D736E617274, 0xEF6C656E6E616843, a1, a2, 0) & 1) != 0)
  {
    v5 = a2;
LABEL_8:
    swift_bridgeObjectRelease(v5);
    return 0;
  }
  if (a1 == 0x6E756F436E776F64 && a2 == 0xEB00000000726574)
  {
    v7 = 0xEB00000000726574;
LABEL_14:
    swift_bridgeObjectRelease(v7);
    return 1;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6E756F436E776F64, 0xEB00000000726574, a1, a2, 0) & 1) != 0)
  {
    v7 = a2;
    goto LABEL_14;
  }
  if (a1 == 0xD000000000000011)
  {
    v8 = 0x8000000100364B50;
    if (a2 == 0x8000000100364B50)
      goto LABEL_19;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000011, 0x8000000100364B50, a1, a2, 0) & 1) != 0)
  {
    v8 = a2;
LABEL_19:
    swift_bridgeObjectRelease(v8);
    return 2;
  }
  if (a1 == 0x6D69546472617567 && a2 == 0xE900000000000065)
  {
    v9 = 0xE900000000000065;
LABEL_25:
    swift_bridgeObjectRelease(v9);
    return 3;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6D69546472617567, 0xE900000000000065, a1, a2, 0) & 1) != 0)
  {
    v9 = a2;
    goto LABEL_25;
  }
  if (a1 == 0xD000000000000018)
  {
    v10 = 0x8000000100364B70;
    if (a2 == 0x8000000100364B70)
      goto LABEL_30;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000018, 0x8000000100364B70, a1, a2, 0) & 1) != 0)
  {
    v10 = a2;
LABEL_30:
    swift_bridgeObjectRelease(v10);
    return 4;
  }
  if (a1 == 0xD000000000000011)
  {
    v11 = 0x8000000100364B90;
    if (a2 == 0x8000000100364B90)
      goto LABEL_35;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000011, 0x8000000100364B90, a1, a2, 0) & 1) != 0)
  {
    v11 = a2;
LABEL_35:
    swift_bridgeObjectRelease(v11);
    return 5;
  }
  if (a1 == 0x7367616C66 && a2 == 0xE500000000000000)
  {
    v12 = 0xE500000000000000;
LABEL_41:
    swift_bridgeObjectRelease(v12);
    return 6;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x7367616C66, 0xE500000000000000, a1, a2, 0) & 1) != 0)
  {
    v12 = a2;
    goto LABEL_41;
  }
  if (a1 == 0xD000000000000021 && a2 == 0x8000000100364BB0)
  {
    v13 = 0x8000000100364BB0;
LABEL_47:
    swift_bridgeObjectRelease(v13);
    return 7;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000021, 0x8000000100364BB0, a1, a2, 0) & 1) != 0)
  {
    v13 = a2;
    goto LABEL_47;
  }
  if (a1 == 0xD000000000000018)
  {
    v14 = 0x8000000100364BE0;
    if (a2 == 0x8000000100364BE0)
      goto LABEL_52;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000018, 0x8000000100364BE0, a1, a2, 0) & 1) != 0)
  {
    v14 = a2;
LABEL_52:
    swift_bridgeObjectRelease(v14);
    return 8;
  }
  if (a1 == 0xD000000000000018)
  {
    v15 = 0x8000000100364C00;
    if (a2 == 0x8000000100364C00)
      goto LABEL_57;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000018, 0x8000000100364C00, a1, a2, 0) & 1) != 0)
  {
    v15 = a2;
LABEL_57:
    swift_bridgeObjectRelease(v15);
    return 9;
  }
  if (a1 == 0xD000000000000011)
  {
    v16 = 0x8000000100364C20;
    if (a2 == 0x8000000100364C20)
      goto LABEL_62;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000011, 0x8000000100364C20, a1, a2, 0) & 1) != 0)
  {
    v16 = a2;
LABEL_62:
    swift_bridgeObjectRelease(v16);
    return 10;
  }
  if (a1 == 0xD00000000000001ALL && a2 == 0x8000000100364C40)
  {
    v17 = 0x8000000100364C40;
LABEL_68:
    swift_bridgeObjectRelease(v17);
    return 11;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD00000000000001ALL, 0x8000000100364C40, a1, a2, 0) & 1) != 0)
  {
    v17 = a2;
    goto LABEL_68;
  }
  if (a1 == 0xD000000000000018)
  {
    v18 = 0x8000000100364C60;
    if (a2 == 0x8000000100364C60)
      goto LABEL_73;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000018, 0x8000000100364C60, a1, a2, 0) & 1) != 0)
  {
    v18 = a2;
LABEL_73:
    swift_bridgeObjectRelease(v18);
    return 12;
  }
  if (a1 == 0xD00000000000001CLL && a2 == 0x8000000100364C80)
  {
    v19 = 0x8000000100364C80;
LABEL_79:
    swift_bridgeObjectRelease(v19);
    return 13;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD00000000000001CLL, 0x8000000100364C80, a1, a2, 0) & 1) != 0)
  {
    v19 = a2;
    goto LABEL_79;
  }
  if (a1 == 0x72657473616DLL && a2 == 0xE600000000000000)
  {
    v20 = 0xE600000000000000;
LABEL_85:
    swift_bridgeObjectRelease(v20);
    return 14;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x72657473616DLL, 0xE600000000000000, a1, a2, 0) & 1) != 0)
  {
    v20 = a2;
    goto LABEL_85;
  }
  if (a1 == 0x65636E6573657270 && a2 == 0xEC00000065646F4DLL)
  {
    v21 = 0xEC00000065646F4DLL;
LABEL_91:
    swift_bridgeObjectRelease(v21);
    return 15;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x65636E6573657270, 0xEC00000065646F4DLL, a1, a2, 0) & 1) != 0)
  {
    v21 = a2;
    goto LABEL_91;
  }
  if (a1 == 0x6465767265736572 && a2 == 0xE800000000000000)
  {
    v22 = 0xE800000000000000;
LABEL_97:
    swift_bridgeObjectRelease(v22);
    return 16;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6465767265736572, 0xE800000000000000, a1, a2, 0) & 1) != 0)
  {
    v22 = a2;
    goto LABEL_97;
  }
  if (a1 == 0x65636E6575716573 && a2 == 0xE800000000000000)
  {
    v23 = 0xE800000000000000;
LABEL_103:
    swift_bridgeObjectRelease(v23);
    return 17;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x65636E6575716573, 0xE800000000000000, a1, a2, 0) & 1) != 0)
  {
    v23 = a2;
    goto LABEL_103;
  }
  if (a1 == 0xD00000000000001FLL && a2 == 0x8000000100364CA0)
  {
    v24 = 0x8000000100364CA0;
LABEL_109:
    swift_bridgeObjectRelease(v24);
    return 18;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD00000000000001FLL, 0x8000000100364CA0, a1, a2, 0) & 1) != 0)
  {
    v24 = a2;
    goto LABEL_109;
  }
  if (a1 == 0xD000000000000018 && a2 == 0x8000000100364CC0)
  {
    swift_bridgeObjectRelease(0x8000000100364CC0);
    return 19;
  }
  else
  {
    v25 = _stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000018, 0x8000000100364CC0, a1, a2, 0);
    swift_bridgeObjectRelease(a2);
    if ((v25 & 1) != 0)
      return 19;
    else
      return 20;
  }
}

uint64_t sub_1000EEFF4(uint64_t a1, unint64_t a2)
{
  unint64_t v5;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char v12;

  if (a1 == 0x7367616C66 && a2 == 0xE500000000000000)
  {
    v5 = 0xE500000000000000;
    goto LABEL_8;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x7367616C66, 0xE500000000000000, a1, a2, 0) & 1) != 0)
  {
    v5 = a2;
LABEL_8:
    swift_bridgeObjectRelease(v5);
    return 0;
  }
  if (a1 == 0x6E6F697463656C65 && a2 == 0xEA00000000004449)
  {
    v7 = 0xEA00000000004449;
LABEL_14:
    swift_bridgeObjectRelease(v7);
    return 1;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6E6F697463656C65, 0xEA00000000004449, a1, a2, 0) & 1) != 0)
  {
    v7 = a2;
    goto LABEL_14;
  }
  if (a1 == 0x65636E6174736964 && a2 == 0xEF706F546D6F7246)
  {
    v8 = 0xEF706F546D6F7246;
LABEL_20:
    swift_bridgeObjectRelease(v8);
    return 2;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x65636E6174736964, 0xEF706F546D6F7246, a1, a2, 0) & 1) != 0)
  {
    v8 = a2;
    goto LABEL_20;
  }
  if (a1 == 0x6465767265736572 && a2 == 0xED0000646C656946)
  {
    v9 = 0xED0000646C656946;
LABEL_26:
    swift_bridgeObjectRelease(v9);
    return 3;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6465767265736572, 0xED0000646C656946, a1, a2, 0) & 1) != 0)
  {
    v9 = a2;
    goto LABEL_26;
  }
  if (a1 == 0x73736572646461 && a2 == 0xE700000000000000)
  {
    v10 = 0xE700000000000000;
LABEL_32:
    swift_bridgeObjectRelease(v10);
    return 4;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x73736572646461, 0xE700000000000000, a1, a2, 0) & 1) != 0)
  {
    v10 = a2;
    goto LABEL_32;
  }
  if (a1 == 0x657473614D706F74 && a2 == 0xEF63697274654D72)
  {
    v11 = 0xEF63697274654D72;
LABEL_38:
    swift_bridgeObjectRelease(v11);
    return 5;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x657473614D706F74, 0xEF63697274654D72, a1, a2, 0) & 1) != 0)
  {
    v11 = a2;
    goto LABEL_38;
  }
  if (a1 == 0xD000000000000012 && a2 == 0x8000000100364B30)
  {
    swift_bridgeObjectRelease(0x8000000100364B30);
    return 6;
  }
  else
  {
    v12 = _stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000012, 0x8000000100364B30, a1, a2, 0);
    swift_bridgeObjectRelease(a2);
    if ((v12 & 1) != 0)
      return 6;
    else
      return 7;
  }
}

uint64_t sub_1000EF344(uint64_t a1, unint64_t a2)
{
  unint64_t v5;
  char v7;

  if (a1 == 0x6574794268747373 && a2 == 0xEB0000000070614DLL)
  {
    v5 = 0xEB0000000070614DLL;
    goto LABEL_8;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6574794268747373, 0xEB0000000070614DLL, a1, a2, 0) & 1) != 0)
  {
    v5 = a2;
LABEL_8:
    swift_bridgeObjectRelease(v5);
    return 0;
  }
  if (a1 == 0x73736572706D6F63 && a2 == 0xEE00485453536465)
  {
    swift_bridgeObjectRelease(0xEE00485453536465);
    return 1;
  }
  else
  {
    v7 = _stringCompareWithSmolCheck(_:_:expecting:)(0x73736572706D6F63, 0xEE00485453536465, a1, a2, 0);
    swift_bridgeObjectRelease(a2);
    if ((v7 & 1) != 0)
      return 1;
    else
      return 2;
  }
}

uint64_t sub_1000EF470(uint64_t a1, unint64_t a2)
{
  unint64_t v5;
  unint64_t v7;
  unint64_t v8;
  char v9;

  if (a1 == 0x7367616C66 && a2 == 0xE500000000000000)
  {
    v5 = 0xE500000000000000;
    goto LABEL_8;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x7367616C66, 0xE500000000000000, a1, a2, 0) & 1) != 0)
  {
    v5 = a2;
LABEL_8:
    swift_bridgeObjectRelease(v5);
    return 0;
  }
  if (a1 == 0x6D69546C6C657764 && a2 == 0xE900000000000065)
  {
    v7 = 0xE900000000000065;
LABEL_14:
    swift_bridgeObjectRelease(v7);
    return 1;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6D69546C6C657764, 0xE900000000000065, a1, a2, 0) & 1) != 0)
  {
    v7 = a2;
    goto LABEL_14;
  }
  if (a1 == 0xD000000000000016)
  {
    v8 = 0x80000001003649C0;
    if (a2 == 0x80000001003649C0)
      goto LABEL_19;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000016, 0x80000001003649C0, a1, a2, 0) & 1) != 0)
  {
    v8 = a2;
LABEL_19:
    swift_bridgeObjectRelease(v8);
    return 2;
  }
  if (a1 == 1752462195 && a2 == 0xE400000000000000)
  {
    swift_bridgeObjectRelease(0xE400000000000000);
    return 3;
  }
  else
  {
    v9 = _stringCompareWithSmolCheck(_:_:expecting:)(1752462195, 0xE400000000000000, a1, a2, 0);
    swift_bridgeObjectRelease(a2);
    if ((v9 & 1) != 0)
      return 3;
    else
      return 4;
  }
}

uint64_t sub_1000EF614(uint64_t a1, unint64_t a2)
{
  unint64_t v5;
  char v7;

  if (a1 == 0x6E6F6973726576 && a2 == 0xE700000000000000)
  {
    v5 = 0xE700000000000000;
    goto LABEL_8;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6E6F6973726576, 0xE700000000000000, a1, a2, 0) & 1) != 0)
  {
    v5 = a2;
LABEL_8:
    swift_bridgeObjectRelease(v5);
    return 0;
  }
  if (a1 == 0x726F6674616C705FLL && a2 == 0xED0000657079546DLL)
  {
    swift_bridgeObjectRelease(0xED0000657079546DLL);
    return 1;
  }
  else
  {
    v7 = _stringCompareWithSmolCheck(_:_:expecting:)(0x726F6674616C705FLL, 0xED0000657079546DLL, a1, a2, 0);
    swift_bridgeObjectRelease(a2);
    if ((v7 & 1) != 0)
      return 1;
    else
      return 2;
  }
}

uint64_t sub_1000EF728(uint64_t a1, unint64_t a2)
{
  unint64_t v4;
  unint64_t v6;
  char v7;

  if (a1 == 0xD000000000000014)
  {
    v4 = 0x80000001003649E0;
    if (a2 == 0x80000001003649E0)
      goto LABEL_5;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000014, 0x80000001003649E0, a1, a2, 0) & 1) != 0)
  {
    v4 = a2;
LABEL_5:
    swift_bridgeObjectRelease(v4);
    return 0;
  }
  if (a1 == 0x746E756F63 && a2 == 0xE500000000000000)
  {
    v6 = 0xE500000000000000;
LABEL_11:
    swift_bridgeObjectRelease(v6);
    return 1;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x746E756F63, 0xE500000000000000, a1, a2, 0) & 1) != 0)
  {
    v6 = a2;
    goto LABEL_11;
  }
  if (a1 == 0x6D6F6F6C62 && a2 == 0xE500000000000000)
  {
    swift_bridgeObjectRelease(0xE500000000000000);
    return 2;
  }
  else
  {
    v7 = _stringCompareWithSmolCheck(_:_:expecting:)(0x6D6F6F6C62, 0xE500000000000000, a1, a2, 0);
    swift_bridgeObjectRelease(a2);
    if ((v7 & 1) != 0)
      return 2;
    else
      return 3;
  }
}

uint64_t sub_1000EF868(uint64_t a1, unint64_t a2)
{
  unint64_t v5;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char v15;

  if (a1 == 0x746E756F43706F68 && a2 == 0xE800000000000000)
  {
    v5 = 0xE800000000000000;
    goto LABEL_8;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x746E756F43706F68, 0xE800000000000000, a1, a2, 0) & 1) != 0)
  {
    v5 = a2;
LABEL_8:
    swift_bridgeObjectRelease(v5);
    return 0;
  }
  if (a1 == 0x6F4E656372756F73 && a2 == 0xEA00000000006564)
  {
    v7 = 0xEA00000000006564;
LABEL_14:
    swift_bridgeObjectRelease(v7);
    return 1;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6F4E656372756F73, 0xEA00000000006564, a1, a2, 0) & 1) != 0)
  {
    v7 = a2;
    goto LABEL_14;
  }
  if (a1 == 0x4972657473756C63 && a2 == 0xE900000000000044)
  {
    v8 = 0xE900000000000044;
LABEL_20:
    swift_bridgeObjectRelease(v8);
    return 2;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x4972657473756C63, 0xE900000000000044, a1, a2, 0) & 1) != 0)
  {
    v8 = a2;
    goto LABEL_20;
  }
  if (a1 == 0xD00000000000001BLL)
  {
    v9 = 0x8000000100364A00;
    if (a2 == 0x8000000100364A00)
      goto LABEL_25;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD00000000000001BLL, 0x8000000100364A00, a1, a2, 0) & 1) != 0)
  {
    v9 = a2;
LABEL_25:
    swift_bridgeObjectRelease(v9);
    return 3;
  }
  if (a1 == 0xD000000000000010)
  {
    v10 = 0x8000000100364A20;
    if (a2 == 0x8000000100364A20)
      goto LABEL_30;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000010, 0x8000000100364A20, a1, a2, 0) & 1) != 0)
  {
    v10 = a2;
LABEL_30:
    swift_bridgeObjectRelease(v10);
    return 4;
  }
  if (a1 == 0xD000000000000013 && a2 == 0x8000000100364A40)
  {
    v11 = 0x8000000100364A40;
LABEL_36:
    swift_bridgeObjectRelease(v11);
    return 5;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000013, 0x8000000100364A40, a1, a2, 0) & 1) != 0)
  {
    v11 = a2;
    goto LABEL_36;
  }
  if (a1 == 0xD000000000000018 && a2 == 0x8000000100364A60)
  {
    v12 = 0x8000000100364A60;
LABEL_42:
    swift_bridgeObjectRelease(v12);
    return 6;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000018, 0x8000000100364A60, a1, a2, 0) & 1) != 0)
  {
    v12 = a2;
    goto LABEL_42;
  }
  if (a1 == 0xD000000000000016 && a2 == 0x8000000100364A80)
  {
    v13 = 0x8000000100364A80;
LABEL_48:
    swift_bridgeObjectRelease(v13);
    return 7;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000016, 0x8000000100364A80, a1, a2, 0) & 1) != 0)
  {
    v13 = a2;
    goto LABEL_48;
  }
  if (a1 == 0xD000000000000014 && a2 == 0x8000000100364AA0)
  {
    v14 = 0x8000000100364AA0;
LABEL_54:
    swift_bridgeObjectRelease(v14);
    return 8;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000014, 0x8000000100364AA0, a1, a2, 0) & 1) != 0)
  {
    v14 = a2;
    goto LABEL_54;
  }
  if (a1 == 0xD000000000000022 && a2 == 0x8000000100364AC0)
  {
    swift_bridgeObjectRelease(0x8000000100364AC0);
    return 9;
  }
  else
  {
    v15 = _stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000022, 0x8000000100364AC0, a1, a2, 0);
    swift_bridgeObjectRelease(a2);
    if ((v15 & 1) != 0)
      return 9;
    else
      return 10;
  }
}

uint64_t sub_1000EFC48(uint64_t a1, unint64_t a2)
{
  unint64_t v5;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char v14;

  if (a1 == 0x65646F4E746F6F72 && a2 == 0xE800000000000000)
  {
    v5 = 0xE800000000000000;
    goto LABEL_8;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x65646F4E746F6F72, 0xE800000000000000, a1, a2, 0) & 1) != 0)
  {
    v5 = a2;
LABEL_8:
    swift_bridgeObjectRelease(v5);
    return 0;
  }
  if (a1 == 0x6F4E746E65726170 && a2 == 0xEA00000000006564)
  {
    v7 = 0xEA00000000006564;
LABEL_14:
    swift_bridgeObjectRelease(v7);
    return 1;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6F4E746E65726170, 0xEA00000000006564, a1, a2, 0) & 1) != 0)
  {
    v7 = a2;
    goto LABEL_14;
  }
  if (a1 == 0xD000000000000013)
  {
    v8 = 0x8000000100364AF0;
    if (a2 == 0x8000000100364AF0)
      goto LABEL_19;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000013, 0x8000000100364AF0, a1, a2, 0) & 1) != 0)
  {
    v8 = a2;
LABEL_19:
    swift_bridgeObjectRelease(v8);
    return 2;
  }
  if (a1 == 0x746E756F43706F68 && a2 == 0xE800000000000000)
  {
    v9 = 0xE800000000000000;
LABEL_25:
    swift_bridgeObjectRelease(v9);
    return 3;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x746E756F43706F68, 0xE800000000000000, a1, a2, 0) & 1) != 0)
  {
    v9 = a2;
    goto LABEL_25;
  }
  if (a1 == 0x7274654D746F6F72 && a2 == 0xEA00000000006369)
  {
    v10 = 0xEA00000000006369;
LABEL_31:
    swift_bridgeObjectRelease(v10);
    return 4;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x7274654D746F6F72, 0xEA00000000006369, a1, a2, 0) & 1) != 0)
  {
    v10 = a2;
    goto LABEL_31;
  }
  if (a1 == 0x7274654D666C6573 && a2 == 0xEA00000000006369)
  {
    v11 = 0xEA00000000006369;
LABEL_37:
    swift_bridgeObjectRelease(v11);
    return 5;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x7274654D666C6573, 0xEA00000000006369, a1, a2, 0) & 1) != 0)
  {
    v11 = a2;
    goto LABEL_37;
  }
  if (a1 == 0x6E6F697463656C65 && a2 == 0xEA00000000004449)
  {
    v12 = 0xEA00000000004449;
LABEL_43:
    swift_bridgeObjectRelease(v12);
    return 6;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6E6F697463656C65, 0xEA00000000004449, a1, a2, 0) & 1) != 0)
  {
    v12 = a2;
    goto LABEL_43;
  }
  if (a1 == 0x6E6F697463656C65 && a2 == 0xED00007367616C46)
  {
    v13 = 0xED00007367616C46;
LABEL_49:
    swift_bridgeObjectRelease(v13);
    return 7;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6E6F697463656C65, 0xED00007367616C46, a1, a2, 0) & 1) != 0)
  {
    v13 = a2;
    goto LABEL_49;
  }
  if (a1 == 0xD000000000000013 && a2 == 0x8000000100364B10)
  {
    swift_bridgeObjectRelease(0x8000000100364B10);
    return 8;
  }
  else
  {
    v14 = _stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000013, 0x8000000100364B10, a1, a2, 0);
    swift_bridgeObjectRelease(a2);
    if ((v14 & 1) != 0)
      return 8;
    else
      return 9;
  }
}

uint64_t sub_1000F0014(uint64_t a1, unint64_t a2)
{
  unint64_t v5;
  char v7;

  if (a1 == 0x7367616C66 && a2 == 0xE500000000000000)
  {
    v5 = 0xE500000000000000;
    goto LABEL_8;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x7367616C66, 0xE500000000000000, a1, a2, 0) & 1) != 0)
  {
    v5 = a2;
LABEL_8:
    swift_bridgeObjectRelease(v5);
    return 0;
  }
  if (a1 == 0x44496E656B6F74 && a2 == 0xE700000000000000)
  {
    swift_bridgeObjectRelease(0xE700000000000000);
    return 1;
  }
  else
  {
    v7 = _stringCompareWithSmolCheck(_:_:expecting:)(0x44496E656B6F74, 0xE700000000000000, a1, a2, 0);
    swift_bridgeObjectRelease(a2);
    if ((v7 & 1) != 0)
      return 1;
    else
      return 2;
  }
}

uint64_t sub_1000F00FC(uint64_t a1, unint64_t a2)
{
  unint64_t v5;
  unint64_t v7;
  unint64_t v8;
  char v9;

  if (a1 == 0x6E6F6973726576 && a2 == 0xE700000000000000)
  {
    v5 = 0xE700000000000000;
    goto LABEL_8;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6E6F6973726576, 0xE700000000000000, a1, a2, 0) & 1) != 0)
  {
    v5 = a2;
LABEL_8:
    swift_bridgeObjectRelease(v5);
    return 0;
  }
  if (a1 == 0x646E616D6D6F63 && a2 == 0xE700000000000000)
  {
    v7 = 0xE700000000000000;
LABEL_14:
    swift_bridgeObjectRelease(v7);
    return 1;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x646E616D6D6F63, 0xE700000000000000, a1, a2, 0) & 1) != 0)
  {
    v7 = a2;
    goto LABEL_14;
  }
  if (a1 == 0x737574617473 && a2 == 0xE600000000000000)
  {
    v8 = 0xE600000000000000;
LABEL_20:
    swift_bridgeObjectRelease(v8);
    return 2;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x737574617473, 0xE600000000000000, a1, a2, 0) & 1) != 0)
  {
    v8 = a2;
    goto LABEL_20;
  }
  if (a1 == 0x7367616C66 && a2 == 0xE500000000000000)
  {
    swift_bridgeObjectRelease(0xE500000000000000);
    return 3;
  }
  else
  {
    v9 = _stringCompareWithSmolCheck(_:_:expecting:)(0x7367616C66, 0xE500000000000000, a1, a2, 0);
    swift_bridgeObjectRelease(a2);
    if ((v9 & 1) != 0)
      return 3;
    else
      return 4;
  }
}

uint64_t sub_1000F02A4(uint64_t a1, unint64_t a2)
{
  unint64_t v5;
  char v7;

  if (a1 == 0x6E6F6973726576 && a2 == 0xE700000000000000)
  {
    v5 = 0xE700000000000000;
    goto LABEL_8;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x6E6F6973726576, 0xE700000000000000, a1, a2, 0) & 1) != 0)
  {
    v5 = a2;
LABEL_8:
    swift_bridgeObjectRelease(v5);
    return 0;
  }
  if (a1 == 0x6574617473 && a2 == 0xE500000000000000)
  {
    swift_bridgeObjectRelease(0xE500000000000000);
    return 1;
  }
  else
  {
    v7 = _stringCompareWithSmolCheck(_:_:expecting:)(0x6574617473, 0xE500000000000000, a1, a2, 0);
    swift_bridgeObjectRelease(a2);
    if ((v7 & 1) != 0)
      return 1;
    else
      return 2;
  }
}

unint64_t sub_1000F038C()
{
  unint64_t result;

  result = qword_100407A30;
  if (!qword_100407A30)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.AWDLAttribute.AttributeType, &type metadata for AWDLActionFrame.AWDLAttribute.AttributeType);
    atomic_store(result, (unint64_t *)&qword_100407A30);
  }
  return result;
}

unint64_t sub_1000F03D0()
{
  unint64_t result;

  result = qword_100407A38;
  if (!qword_100407A38)
  {
    result = swift_getWitnessTable("%", &type metadata for AWDLActionFrame.AirDrop.State);
    atomic_store(result, (unint64_t *)&qword_100407A38);
  }
  return result;
}

unint64_t sub_1000F0414()
{
  unint64_t result;

  result = qword_100407A40;
  if (!qword_100407A40)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.ProMode.Command, &type metadata for AWDLActionFrame.ProMode.Command);
    atomic_store(result, (unint64_t *)&qword_100407A40);
  }
  return result;
}

unint64_t sub_1000F0458()
{
  unint64_t result;

  result = qword_100407A48;
  if (!qword_100407A48)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.MultiPeerBSSSteering.SteeringMessageID, &type metadata for AWDLActionFrame.MultiPeerBSSSteering.SteeringMessageID);
    atomic_store(result, (unint64_t *)&qword_100407A48);
  }
  return result;
}

unint64_t sub_1000F049C()
{
  unint64_t result;

  result = qword_100407A50;
  if (!qword_100407A50)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.Version.PlatformType, &type metadata for AWDLActionFrame.Version.PlatformType);
    atomic_store(result, (unint64_t *)&qword_100407A50);
  }
  return result;
}

unint64_t sub_1000F04E0()
{
  unint64_t result;

  result = qword_100407A58;
  if (!qword_100407A58)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.DataPathState.UnicastMasterIndicationOptions, &type metadata for AWDLActionFrame.DataPathState.UnicastMasterIndicationOptions);
    atomic_store(result, (unint64_t *)&qword_100407A58);
  }
  return result;
}

unint64_t sub_1000F0524()
{
  unint64_t result;

  result = qword_100407A60;
  if (!qword_100407A60)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.OUISubtype, &type metadata for AWDLActionFrame.OUISubtype);
    atomic_store(result, (unint64_t *)&qword_100407A60);
  }
  return result;
}

unint64_t sub_1000F0568()
{
  unint64_t result;

  result = qword_100407A68;
  if (!qword_100407A68)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.OUIType, &type metadata for AWDLActionFrame.OUIType);
    atomic_store(result, (unint64_t *)&qword_100407A68);
  }
  return result;
}

unint64_t sub_1000F05AC()
{
  unint64_t result;

  result = qword_100407A78;
  if (!qword_100407A78)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.OUIType, &type metadata for AWDLActionFrame.OUIType);
    atomic_store(result, (unint64_t *)&qword_100407A78);
  }
  return result;
}

unint64_t sub_1000F05F0()
{
  unint64_t result;

  result = qword_100407A80;
  if (!qword_100407A80)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.AWDLVersion, &type metadata for AWDLActionFrame.AWDLVersion);
    atomic_store(result, (unint64_t *)&qword_100407A80);
  }
  return result;
}

unint64_t sub_1000F0634()
{
  unint64_t result;

  result = qword_100407A88;
  if (!qword_100407A88)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.OUISubtype, &type metadata for AWDLActionFrame.OUISubtype);
    atomic_store(result, (unint64_t *)&qword_100407A88);
  }
  return result;
}

unint64_t sub_1000F0678()
{
  unint64_t result;

  result = qword_100407AA8;
  if (!qword_100407AA8)
  {
    result = swift_getWitnessTable("\r", &type metadata for AWDLActionFrame.AirDrop.State);
    atomic_store(result, (unint64_t *)&qword_100407AA8);
  }
  return result;
}

unint64_t sub_1000F06BC()
{
  unint64_t result;

  result = qword_100407AB8;
  if (!qword_100407AB8)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.ProMode.Command, &type metadata for AWDLActionFrame.ProMode.Command);
    atomic_store(result, (unint64_t *)&qword_100407AB8);
  }
  return result;
}

unint64_t sub_1000F0700()
{
  unint64_t result;

  result = qword_100407AC0;
  if (!qword_100407AC0)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.ProMode.Flags, &type metadata for AWDLActionFrame.ProMode.Flags);
    atomic_store(result, (unint64_t *)&qword_100407AC0);
  }
  return result;
}

unint64_t sub_1000F0744()
{
  unint64_t result;

  result = qword_100407AC8;
  if (!qword_100407AC8)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.RealtimeGroup.Flags, &type metadata for AWDLActionFrame.RealtimeGroup.Flags);
    atomic_store(result, (unint64_t *)&qword_100407AC8);
  }
  return result;
}

unint64_t sub_1000F0788()
{
  unint64_t result;

  result = qword_100407AD0;
  if (!qword_100407AD0)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.RealtimeGroup.AdditionalFlags, &type metadata for AWDLActionFrame.RealtimeGroup.AdditionalFlags);
    atomic_store(result, (unint64_t *)&qword_100407AD0);
  }
  return result;
}

unint64_t sub_1000F07CC()
{
  unint64_t result;

  result = qword_100407AF0;
  if (!qword_100407AF0)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.MultiPeerBSSSteering.SteeringMessageID, &type metadata for AWDLActionFrame.MultiPeerBSSSteering.SteeringMessageID);
    atomic_store(result, (unint64_t *)&qword_100407AF0);
  }
  return result;
}

unint64_t sub_1000F0810()
{
  unint64_t result;

  result = qword_100407B00;
  if (!qword_100407B00)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLElectionMetric, &type metadata for AWDLElectionMetric);
    atomic_store(result, (unint64_t *)&qword_100407B00);
  }
  return result;
}

unint64_t sub_1000F0854()
{
  unint64_t result;

  result = qword_100407B10;
  if (!qword_100407B10)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANTimeSynchronizationFunction, &type metadata for NANTimeSynchronizationFunction);
    atomic_store(result, (unint64_t *)&qword_100407B10);
  }
  return result;
}

unint64_t sub_1000F0898()
{
  unint64_t result;

  result = qword_100407B18;
  if (!qword_100407B18)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANAttribute.MasterIndication, &type metadata for NANAttribute.MasterIndication);
    atomic_store(result, (unint64_t *)&qword_100407B18);
  }
  return result;
}

uint64_t sub_1000F08DC(unint64_t *a1, uint64_t a2, const char *a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;

  result = *a1;
  if (!result)
  {
    v7 = sub_100013C64(&qword_100406738);
    v8 = a2;
    result = swift_getWitnessTable(a3, v7, &v8);
    atomic_store(result, a1);
  }
  return result;
}

uint64_t sub_1000F093C(unint64_t *a1, uint64_t (*a2)(void), const char *a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;

  result = *a1;
  if (!result)
  {
    v7 = sub_100013C64(&qword_100407250);
    v8 = a2();
    result = swift_getWitnessTable(a3, v7, &v8);
    atomic_store(result, a1);
  }
  return result;
}

unint64_t sub_1000F09A4()
{
  unint64_t result;

  result = qword_100407B48;
  if (!qword_100407B48)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.Arpa.Flags, &type metadata for AWDLActionFrame.Arpa.Flags);
    atomic_store(result, (unint64_t *)&qword_100407B48);
  }
  return result;
}

unint64_t sub_1000F09E8()
{
  unint64_t result;

  result = qword_100407B50;
  if (!qword_100407B50)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.ServiceParameter.Flags, &type metadata for AWDLActionFrame.ServiceParameter.Flags);
    atomic_store(result, (unint64_t *)&qword_100407B50);
  }
  return result;
}

unint64_t sub_1000F0A2C()
{
  unint64_t result;

  result = qword_100407B58;
  if (!qword_100407B58)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.ServiceParameter.SSTH, &type metadata for AWDLActionFrame.ServiceParameter.SSTH);
    atomic_store(result, (unint64_t *)&qword_100407B58);
  }
  return result;
}

unint64_t sub_1000F0A70()
{
  unint64_t result;

  result = qword_100407B68;
  if (!qword_100407B68)
  {
    result = swift_getWitnessTable(byte_100345820, &type metadata for AWDLActionFrame.DeprecatedElectionParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407B68);
  }
  return result;
}

unint64_t sub_1000F0AB4()
{
  unint64_t result;

  result = qword_100407B78;
  if (!qword_100407B78)
  {
    result = swift_getWitnessTable(byte_1003457D0, &type metadata for AWDLActionFrame.SynchronizationParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407B78);
  }
  return result;
}

unint64_t sub_1000F0AF8()
{
  unint64_t result;

  result = qword_100407B80;
  if (!qword_100407B80)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLActionFrame.AWDLChannelSequenceParameter, &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter);
    atomic_store(result, (unint64_t *)&qword_100407B80);
  }
  return result;
}

unint64_t sub_1000F0B3C()
{
  unint64_t result;

  result = qword_100407B88;
  if (!qword_100407B88)
  {
    result = swift_getWitnessTable(byte_1003457A8, &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.Encoding);
    atomic_store(result, (unint64_t *)&qword_100407B88);
  }
  return result;
}

unint64_t sub_1000F0B80()
{
  unint64_t result;

  result = qword_100407B90;
  if (!qword_100407B90)
  {
    result = swift_getWitnessTable(byte_100345780, &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.NChannelOperatingClass);
    atomic_store(result, (unint64_t *)&qword_100407B90);
  }
  return result;
}

unint64_t sub_1000F0BC4()
{
  unint64_t result;

  result = qword_100407B98;
  if (!qword_100407B98)
  {
    result = swift_getWitnessTable(byte_100345758, &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.Encoding);
    atomic_store(result, (unint64_t *)&qword_100407B98);
  }
  return result;
}

unint64_t sub_1000F0C08()
{
  unint64_t result;

  result = qword_100407BA0;
  if (!qword_100407BA0)
  {
    result = swift_getWitnessTable(byte_100345730, &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.NChannelOperatingClass);
    atomic_store(result, (unint64_t *)&qword_100407BA0);
  }
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.AWDLChannelSequenceParameter.NChannelOperatingClass()
{
  return &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.NChannelOperatingClass;
}

uint64_t _s7CoreP2P15AWDLActionFrameV7ProModeV10CodingKeysOwst_0(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 3 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 3) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xFD)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xFC)
    return ((uint64_t (*)(void))((char *)&loc_1000F0CA8 + 4 * byte_10034157D[v4]))();
  *a1 = a2 + 3;
  return ((uint64_t (*)(void))((char *)sub_1000F0CDC + 4 * byte_100341578[v4]))();
}

uint64_t sub_1000F0CDC(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000F0CE4(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x1000F0CECLL);
  return result;
}

uint64_t sub_1000F0CF8(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x1000F0D00);
  *(_BYTE *)result = a2 + 3;
  return result;
}

uint64_t sub_1000F0D04(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000F0D0C(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.AWDLChannelSequenceParameter.Encoding()
{
  return &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.Encoding;
}

uint64_t getEnumTagSinglePayload for AWDLActionFrame.SynchronizationParameter.CodingKeys(unsigned __int8 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0xED)
    goto LABEL_17;
  if (a2 + 19 >= 0xFFFF00)
    v2 = 4;
  else
    v2 = 2;
  if ((a2 + 19) >> 8 < 0xFF)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 8)) - 19;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1))
        goto LABEL_17;
      return (*a1 | (v4 << 8)) - 19;
    }
    v4 = a1[1];
    if (a1[1])
      return (*a1 | (v4 << 8)) - 19;
  }
LABEL_17:
  v6 = *a1;
  v7 = v6 >= 0x14;
  v8 = v6 - 20;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for AWDLActionFrame.SynchronizationParameter.CodingKeys(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 19 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 19) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xED)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xEC)
    return ((uint64_t (*)(void))((char *)&loc_1000F0E04 + 4 * byte_100341587[v4]))();
  *a1 = a2 + 19;
  return ((uint64_t (*)(void))((char *)sub_1000F0E38 + 4 * byte_100341582[v4]))();
}

uint64_t sub_1000F0E38(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000F0E40(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x1000F0E48);
  return result;
}

uint64_t sub_1000F0E54(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x1000F0E5CLL);
  *(_BYTE *)result = a2 + 19;
  return result;
}

uint64_t sub_1000F0E60(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000F0E68(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.SynchronizationParameter.CodingKeys()
{
  return &type metadata for AWDLActionFrame.SynchronizationParameter.CodingKeys;
}

uint64_t getEnumTagSinglePayload for IEEE80211Frame.Management.ActionFrame.Category(unsigned __int8 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0xFA)
    goto LABEL_17;
  if (a2 + 6 >= 0xFFFF00)
    v2 = 4;
  else
    v2 = 2;
  if ((a2 + 6) >> 8 < 0xFF)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 8)) - 6;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1))
        goto LABEL_17;
      return (*a1 | (v4 << 8)) - 6;
    }
    v4 = a1[1];
    if (a1[1])
      return (*a1 | (v4 << 8)) - 6;
  }
LABEL_17:
  v6 = *a1;
  v7 = v6 >= 7;
  v8 = v6 - 7;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

uint64_t _s7CoreP2P15AWDLActionFrameV20MultiPeerBSSSteeringV17SteeringMessageIDOwst_0(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 6 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 6) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xFA)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xF9)
    return ((uint64_t (*)(void))((char *)&loc_1000F0F60 + 4 * byte_100341591[v4]))();
  *a1 = a2 + 6;
  return ((uint64_t (*)(void))((char *)sub_1000F0F94 + 4 * byte_10034158C[v4]))();
}

uint64_t sub_1000F0F94(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000F0F9C(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x1000F0FA4);
  return result;
}

uint64_t sub_1000F0FB0(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x1000F0FB8);
  *(_BYTE *)result = a2 + 6;
  return result;
}

uint64_t sub_1000F0FBC(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000F0FC4(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for AWDLActionFrame.DeprecatedElectionParameter.CodingKeys()
{
  return &type metadata for AWDLActionFrame.DeprecatedElectionParameter.CodingKeys;
}

unint64_t sub_1000F0FE4()
{
  unint64_t result;

  result = qword_100407BB8;
  if (!qword_100407BB8)
  {
    result = swift_getWitnessTable(byte_100345420, &type metadata for AWDLActionFrame.DeprecatedElectionParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407BB8);
  }
  return result;
}

unint64_t sub_1000F102C()
{
  unint64_t result;

  result = qword_100407BC0;
  if (!qword_100407BC0)
  {
    result = swift_getWitnessTable(asc_1003454D8, &type metadata for AWDLActionFrame.SynchronizationParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407BC0);
  }
  return result;
}

unint64_t sub_1000F1074()
{
  unint64_t result;

  result = qword_100407BC8;
  if (!qword_100407BC8)
  {
    result = swift_getWitnessTable(byte_100345578, &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.Encoding);
    atomic_store(result, (unint64_t *)&qword_100407BC8);
  }
  return result;
}

unint64_t sub_1000F10BC()
{
  unint64_t result;

  result = qword_100407BD0;
  if (!qword_100407BD0)
  {
    result = swift_getWitnessTable(asc_1003455D0, &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.NChannelOperatingClass);
    atomic_store(result, (unint64_t *)&qword_100407BD0);
  }
  return result;
}

unint64_t sub_1000F1104()
{
  unint64_t result;

  result = qword_100407BD8;
  if (!qword_100407BD8)
  {
    result = swift_getWitnessTable(byte_1003455A0, &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.NChannelOperatingClass);
    atomic_store(result, (unint64_t *)&qword_100407BD8);
  }
  return result;
}

unint64_t sub_1000F114C()
{
  unint64_t result;

  result = qword_100407BE0;
  if (!qword_100407BE0)
  {
    result = swift_getWitnessTable(byte_1003455F8, &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.NChannelOperatingClass);
    atomic_store(result, (unint64_t *)&qword_100407BE0);
  }
  return result;
}

unint64_t sub_1000F1194()
{
  unint64_t result;

  result = qword_100407BE8;
  if (!qword_100407BE8)
  {
    result = swift_getWitnessTable(aA_0, &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.NChannelOperatingClass);
    atomic_store(result, (unint64_t *)&qword_100407BE8);
  }
  return result;
}

unint64_t sub_1000F11DC()
{
  unint64_t result;

  result = qword_100407BF0;
  if (!qword_100407BF0)
  {
    result = swift_getWitnessTable(aA_1, &type metadata for AWDLActionFrame.SynchronizationParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407BF0);
  }
  return result;
}

unint64_t sub_1000F1224()
{
  unint64_t result;

  result = qword_100407BF8;
  if (!qword_100407BF8)
  {
    result = swift_getWitnessTable(asc_100345470, &type metadata for AWDLActionFrame.SynchronizationParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407BF8);
  }
  return result;
}

unint64_t sub_1000F126C()
{
  unint64_t result;

  result = qword_100407C00;
  if (!qword_100407C00)
  {
    result = swift_getWitnessTable(byte_100345390, &type metadata for AWDLActionFrame.DeprecatedElectionParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407C00);
  }
  return result;
}

unint64_t sub_1000F12B4()
{
  unint64_t result;

  result = qword_100407C08;
  if (!qword_100407C08)
  {
    result = swift_getWitnessTable(byte_1003453B8, &type metadata for AWDLActionFrame.DeprecatedElectionParameter.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407C08);
  }
  return result;
}

unint64_t sub_1000F12F8()
{
  unint64_t result;

  result = qword_100407C10;
  if (!qword_100407C10)
  {
    result = swift_getWitnessTable(asc_100345500, &type metadata for AWDLActionFrame.AWDLChannelSequenceParameter.Encoding);
    atomic_store(result, (unint64_t *)&qword_100407C10);
  }
  return result;
}

uint64_t NANAwakeDWInterval.interval.getter(char a1)
{
  return qword_100345BD8[a1];
}

CoreP2P::NANAwakeDWInterval_optional __swiftcall NANAwakeDWInterval.init(numberString:)(Swift::String numberString)
{
  void *object;
  uint64_t countAndFlagsBits;
  unint64_t v3;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  char v8;

  object = numberString._object;
  countAndFlagsBits = numberString._countAndFlagsBits;
  if (numberString._countAndFlagsBits == 48 && numberString._object == (void *)0xE100000000000000)
  {
    v3 = 0xE100000000000000;
LABEL_6:
    swift_bridgeObjectRelease(v3);
    return 0;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(48, 0xE100000000000000, numberString._countAndFlagsBits, numberString._object, 0) & 1) != 0)
  {
    v3 = (unint64_t)object;
    goto LABEL_6;
  }
  if (countAndFlagsBits == 49 && object == (void *)0xE100000000000000)
  {
    v5 = 0xE100000000000000;
LABEL_12:
    swift_bridgeObjectRelease(v5);
    return (CoreP2P::NANAwakeDWInterval_optional)1;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(49, 0xE100000000000000, countAndFlagsBits, object, 0) & 1) != 0)
  {
    v5 = (unint64_t)object;
    goto LABEL_12;
  }
  if (countAndFlagsBits == 52 && object == (void *)0xE100000000000000)
  {
    v6 = 0xE100000000000000;
LABEL_18:
    swift_bridgeObjectRelease(v6);
    return (CoreP2P::NANAwakeDWInterval_optional)2;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(52, 0xE100000000000000, countAndFlagsBits, object, 0) & 1) != 0)
  {
    v6 = (unint64_t)object;
    goto LABEL_18;
  }
  if (countAndFlagsBits == 56 && object == (void *)0xE100000000000000)
  {
    v7 = 0xE100000000000000;
LABEL_24:
    swift_bridgeObjectRelease(v7);
    return (CoreP2P::NANAwakeDWInterval_optional)3;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(56, 0xE100000000000000, countAndFlagsBits, object, 0) & 1) != 0)
  {
    v7 = (unint64_t)object;
    goto LABEL_24;
  }
  if (countAndFlagsBits == 13873 && object == (void *)0xE200000000000000)
  {
    swift_bridgeObjectRelease(0xE200000000000000);
    return (CoreP2P::NANAwakeDWInterval_optional)4;
  }
  else
  {
    v8 = _stringCompareWithSmolCheck(_:_:expecting:)(13873, 0xE200000000000000, countAndFlagsBits, object, 0);
    swift_bridgeObjectRelease(object);
    if ((v8 & 1) != 0)
      return (CoreP2P::NANAwakeDWInterval_optional)4;
    else
      return (CoreP2P::NANAwakeDWInterval_optional)5;
  }
}

void *NANAwakeDWInterval.defaultValue.unsafeMutableAddressor()
{
  return &static NANAwakeDWInterval.defaultValue;
}

uint64_t NANAwakeDWInterval.rawValue.getter(unsigned __int8 a1)
{
  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_1000F1598 + 4 * byte_100345990[a1]))(1869768058, 0xE400000000000000);
}

uint64_t sub_1000F1598()
{
  return 6647407;
}

uint64_t sub_1000F15A8()
{
  return 1920298854;
}

uint64_t sub_1000F15B4()
{
  return 0x7468676965;
}

uint64_t sub_1000F15C8()
{
  return 0x6E656574786973;
}

uint64_t sub_1000F15E0(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return sub_10003BBE4(*a1, *a2);
}

unint64_t sub_1000F15EC@<X0>(Swift::String *a1@<X0>, _BYTE *a2@<X8>)
{
  unint64_t result;

  result = _s7CoreP2P18NANAwakeDWIntervalO8rawValueACSgSS_tcfC_0(*a1);
  *a2 = result;
  return result;
}

uint64_t sub_1000F1618()
{
  unsigned __int8 *v0;

  return ((uint64_t (*)(void))((char *)sub_1000F1640 + 4 * byte_100345995[*v0]))();
}

void sub_1000F1640(_QWORD *a1@<X8>)
{
  *a1 = 6647407;
  a1[1] = 0xE300000000000000;
}

void sub_1000F1654(_QWORD *a1@<X8>)
{
  uint64_t v1;

  *a1 = 1920298854;
  a1[1] = v1;
}

void sub_1000F1664(_QWORD *a1@<X8>)
{
  *a1 = 0x7468676965;
  a1[1] = 0xE500000000000000;
}

void sub_1000F167C(_QWORD *a1@<X8>)
{
  *a1 = 0x6E656574786973;
  a1[1] = 0xE700000000000000;
}

void sub_1000F1698()
{
  unsigned __int8 *v0;
  uint64_t v1;
  _QWORD v2[9];

  v1 = *v0;
  Hasher.init(_seed:)(v2);
  __asm { BR              X9 }
}

Swift::Int sub_1000F16DC()
{
  uint64_t v1;

  String.hash(into:)(&v1, 6647407, 0xE300000000000000);
  swift_bridgeObjectRelease(0xE300000000000000);
  return Hasher._finalize()();
}

void sub_1000F174C()
{
  __asm { BR              X10 }
}

uint64_t sub_1000F1780(uint64_t a1)
{
  String.hash(into:)(a1, 6647407, 0xE300000000000000);
  return swift_bridgeObjectRelease(0xE300000000000000);
}

void sub_1000F17DC()
{
  unsigned __int8 *v0;
  uint64_t v1;
  _QWORD v2[9];

  v1 = *v0;
  Hasher.init(_seed:)(v2);
  __asm { BR              X9 }
}

Swift::Int sub_1000F181C()
{
  uint64_t v1;

  String.hash(into:)(&v1, 6647407, 0xE300000000000000);
  swift_bridgeObjectRelease(0xE300000000000000);
  return Hasher._finalize()();
}

uint64_t sub_1000F188C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000F22AC();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000F18E8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000F22AC();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

uint64_t NANAwakeDWInterval.description.getter(unsigned __int8 a1)
{
  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_1000F1960 + 4 * byte_1003459A9[a1]))(1869768058, 0xE400000000000000);
}

uint64_t sub_1000F1960()
{
  return 6647407;
}

uint64_t sub_1000F1970()
{
  return 1920298854;
}

uint64_t sub_1000F197C()
{
  return 0x7468676965;
}

uint64_t sub_1000F1990()
{
  return 0x6E656574786973;
}

uint64_t NANAwakeDWInterval.customMirror.getter(char a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _BYTE *v5;
  uint64_t v6;
  _BYTE *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _BYTE v13[15];
  char v14;

  v2 = type metadata accessor for Mirror.AncestorRepresentation(0);
  v3 = *(_QWORD *)(v2 - 8);
  __chkstk_darwin();
  v5 = &v13[-((v4 + 15) & 0xFFFFFFFFFFFFFFF0)];
  sub_100012C44((uint64_t *)&unk_1004085C0);
  __chkstk_darwin();
  v7 = &v13[-((v6 + 15) & 0xFFFFFFFFFFFFFFF0)];
  v14 = a1;
  v8 = sub_100012C44(qword_100405C70);
  v9 = swift_allocObject(v8, 80, 7);
  *(_OWORD *)(v9 + 16) = xmmword_10033A110;
  *(_QWORD *)(v9 + 32) = 0x6C61767265746E69;
  *(_QWORD *)(v9 + 40) = 0xE800000000000000;
  v10 = qword_100345BD8[a1];
  *(_QWORD *)(v9 + 72) = &type metadata for NANTimeUnit;
  *(_QWORD *)(v9 + 48) = v10;
  v11 = type metadata accessor for Mirror.DisplayStyle(0);
  (*(void (**)(_BYTE *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v11 - 8) + 56))(v7, 1, 1, v11);
  (*(void (**)(_BYTE *, _QWORD, uint64_t))(v3 + 104))(v5, enum case for Mirror.AncestorRepresentation.generated(_:), v2);
  return Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:)(&v14, v9, v7, v5, &type metadata for NANAwakeDWInterval);
}

uint64_t sub_1000F1B1C()
{
  unsigned __int8 *v0;

  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_1000F1B44 + 4 * byte_1003459AE[*v0]))(1869768058, 0xE400000000000000);
}

uint64_t sub_1000F1B44()
{
  return 6647407;
}

uint64_t sub_1000F1B54()
{
  return 1920298854;
}

uint64_t sub_1000F1B60()
{
  return 0x7468676965;
}

uint64_t sub_1000F1B74()
{
  return 0x6E656574786973;
}

uint64_t sub_1000F1B8C()
{
  char *v0;

  return NANAwakeDWInterval.customMirror.getter(*v0);
}

void NANAwakeDWPeriods.hash(into:)(uint64_t a1, char a2)
{
  __asm { BR              X10 }
}

uint64_t sub_1000F1BD8(uint64_t a1, __int16 a2)
{
  uint64_t v2;
  uint64_t v3;
  __n128 v4;

  v3 = HIBYTE(a2);
  String.hash(into:)(v2, 6647407, 0xE300000000000000);
  v4 = swift_bridgeObjectRelease(0xE300000000000000);
  return ((uint64_t (*)(__n128))((char *)sub_1000F1C54 + 4 * byte_1003459B8[v3]))(v4);
}

uint64_t sub_1000F1C54()
{
  uint64_t v0;

  String.hash(into:)(v0, 6647407, 0xE300000000000000);
  return swift_bridgeObjectRelease(0xE300000000000000);
}

void static NANAwakeDWPeriods.__derived_struct_equals(_:_:)(char a1)
{
  __asm { BR              X10 }
}

uint64_t sub_1000F1D08()
{
  unsigned __int8 v0;

  return ((uint64_t (*)(uint64_t))((char *)sub_1000F1D6C + 4 * byte_1003459C2[v0]))(6647407);
}

uint64_t sub_1000F1D6C(uint64_t a1)
{
  __int16 v1;
  __int16 v2;
  uint64_t v3;
  char v4;

  if (a1 == 6647407 && v3 == 0xE300000000000000)
  {
    swift_bridgeObjectRelease_n(0xE300000000000000, 2);
    return sub_10003BBE4(HIBYTE(v1), HIBYTE(v2));
  }
  v4 = _stringCompareWithSmolCheck(_:_:expecting:)(a1, v3, 6647407, 0xE300000000000000, 0);
  swift_bridgeObjectRelease(v3);
  swift_bridgeObjectRelease(0xE300000000000000);
  if ((v4 & 1) != 0)
    return sub_10003BBE4(HIBYTE(v1), HIBYTE(v2));
  return 0;
}

Swift::Int NANAwakeDWPeriods.hashValue.getter(char a1)
{
  _QWORD v3[9];

  Hasher.init(_seed:)(v3);
  NANAwakeDWPeriods.hash(into:)((uint64_t)v3, a1);
  return Hasher._finalize()();
}

Swift::Int sub_1000F1E84()
{
  __int16 *v0;
  __int16 v1;
  _QWORD v3[9];

  v1 = *v0;
  Hasher.init(_seed:)(v3);
  NANAwakeDWPeriods.hash(into:)((uint64_t)v3, v1);
  return Hasher._finalize()();
}

void sub_1000F1EC8(uint64_t a1)
{
  _WORD *v1;

  NANAwakeDWPeriods.hash(into:)(a1, *v1);
}

Swift::Int sub_1000F1ED0()
{
  __int16 *v0;
  __int16 v1;
  _QWORD v3[9];

  v1 = *v0;
  Hasher.init(_seed:)(v3);
  NANAwakeDWPeriods.hash(into:)((uint64_t)v3, v1);
  return Hasher._finalize()();
}

uint64_t sub_1000F1F10(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = a1[1];
  v3 = a2[1];
  if ((sub_10003BBE4(*a1, *a2) & 1) != 0)
    return sub_10003BBE4(v2, v3);
  else
    return 0;
}

unint64_t _s7CoreP2P18NANAwakeDWIntervalO8rawValueACSgSS_tcfC_0(Swift::String string)
{
  void *object;
  Swift::String v2;
  unint64_t v3;

  object = string._object;
  v2._countAndFlagsBits = string._countAndFlagsBits;
  v2._object = object;
  v3 = _findStringSwitchCase(cases:string:)((Swift::OpaquePointer)&off_1003D6180, v2);
  swift_bridgeObjectRelease(object);
  if (v3 >= 5)
    return 5;
  else
    return v3;
}

uint64_t _s7CoreP2P18NANAwakeDWIntervalO8intervalACSgAA11NANTimeUnitV_tcfC_0(uint64_t a1)
{
  uint64_t result;

  result = 0;
  switch(a1)
  {
    case 0:
      return result;
    case 1:
      result = 1;
      break;
    case 4:
      result = 2;
      break;
    case 8:
      result = 3;
      break;
    case 16:
      result = 4;
      break;
    default:
      result = 5;
      break;
  }
  return result;
}

unint64_t sub_1000F1FF4()
{
  unint64_t result;

  result = qword_100407C18;
  if (!qword_100407C18)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANAwakeDWInterval, &type metadata for NANAwakeDWInterval);
    atomic_store(result, (unint64_t *)&qword_100407C18);
  }
  return result;
}

unint64_t sub_1000F203C()
{
  unint64_t result;

  result = qword_100407C20;
  if (!qword_100407C20)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANAwakeDWPeriods, &type metadata for NANAwakeDWPeriods);
    atomic_store(result, (unint64_t *)&qword_100407C20);
  }
  return result;
}

uint64_t storeEnumTagSinglePayload for NANAwakeDWInterval(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 4 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 4) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xFC)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xFB)
    return ((uint64_t (*)(void))((char *)&loc_1000F20CC + 4 * byte_1003459DD[v4]))();
  *a1 = a2 + 4;
  return ((uint64_t (*)(void))((char *)sub_1000F2100 + 4 * byte_1003459D8[v4]))();
}

uint64_t sub_1000F2100(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000F2108(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x1000F2110);
  return result;
}

uint64_t sub_1000F211C(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x1000F2124);
  *(_BYTE *)result = a2 + 4;
  return result;
}

uint64_t sub_1000F2128(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000F2130(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for NANAwakeDWInterval()
{
  return &type metadata for NANAwakeDWInterval;
}

uint64_t getEnumTagSinglePayload for NANAwakeDWPeriods(unsigned __int16 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0xFC)
    goto LABEL_17;
  if (a2 + 65284 <= 0xFFFEFFFF)
    v2 = 2;
  else
    v2 = 4;
  if (a2 + 65284 < 0xFF0000)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 16)) - 65284;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = a1[1];
      if (!a1[1])
        goto LABEL_17;
      return (*a1 | (v4 << 16)) - 65284;
    }
    v4 = *((unsigned __int8 *)a1 + 2);
    if (*((_BYTE *)a1 + 2))
      return (*a1 | (v4 << 16)) - 65284;
  }
LABEL_17:
  v6 = *(unsigned __int8 *)a1;
  v7 = v6 >= 5;
  v8 = v6 - 5;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for NANAwakeDWPeriods(_WORD *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 65284 <= 0xFFFEFFFF)
    v3 = 2;
  else
    v3 = 4;
  if (a3 + 65284 < 0xFF0000)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xFC)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xFB)
    return ((uint64_t (*)(void))((char *)&loc_1000F222C + 4 * byte_1003459E7[v4]))();
  *a1 = a2 - 252;
  return ((uint64_t (*)(void))((char *)sub_1000F2260 + 4 * byte_1003459E2[v4]))();
}

uint64_t sub_1000F2260(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 2) = v1;
  return result;
}

uint64_t sub_1000F2268(uint64_t result, int a2)
{
  *(_WORD *)(result + 2) = 0;
  if (a2)
    JUMPOUT(0x1000F2270);
  return result;
}

uint64_t sub_1000F227C(uint64_t result, int a2)
{
  *(_DWORD *)(result + 2) = 0;
  if (!a2)
    JUMPOUT(0x1000F2284);
  *(_BYTE *)result = a2 + 4;
  return result;
}

uint64_t sub_1000F2288(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 2) = v1;
  return result;
}

uint64_t sub_1000F2290(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 2) = v1;
  return result;
}

ValueMetadata *type metadata accessor for NANAwakeDWPeriods()
{
  return &type metadata for NANAwakeDWPeriods;
}

unint64_t sub_1000F22AC()
{
  unint64_t result;

  result = qword_100407C28;
  if (!qword_100407C28)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANAwakeDWInterval, &type metadata for NANAwakeDWInterval);
    atomic_store(result, (unint64_t *)&qword_100407C28);
  }
  return result;
}

uint64_t sub_1000F22F4(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v7 = a1[5];
  v8 = swift_unownedRetain(v7);
  v10 = a1[2];
  v9 = a1[3];
  swift_unownedRetainStrong(v8);
  swift_bridgeObjectRetain_n(v9, 2);
  AppleDevice.startMonitoringEvents(on:eventHandler:)(v10, v9, a2, a3);
  swift_release(v7);
  swift_release(a1);
  swift_release(a3);
  swift_bridgeObjectRelease(v9);
  if (v3)
  {
    swift_unownedRelease(v7);
    swift_bridgeObjectRelease(v9);
  }
  return v7;
}

uint64_t _s7CoreP2P6DevicePAAE12customMirrors0E0Vvg_0(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v16;
  _QWORD *v17;

  v3 = type metadata accessor for Mirror.AncestorRepresentation(0);
  v4 = *(_QWORD *)(v3 - 8);
  __chkstk_darwin();
  v6 = (char *)&v16 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_100012C44((uint64_t *)&unk_1004085C0);
  __chkstk_darwin();
  v8 = (char *)&v16 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin();
  v10 = (char *)&v16 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v10, v1, a1);
  v17 = _swiftEmptyArrayStorage;
  v12 = type metadata accessor for Mirror.DisplayStyle(0);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v12 - 8) + 56))(v8, 1, 1, v12);
  v13 = sub_100012C44(&qword_100405B90);
  v14 = sub_1000687EC();
  (*(void (**)(char *, _QWORD, uint64_t))(v4 + 104))(v6, enum case for Mirror.AncestorRepresentation.generated(_:), v3);
  return Mirror.init<A, B>(_:children:displayStyle:ancestorRepresentation:)(v10, &v17, v8, v6, a1, v13, v14);
}

uint64_t sub_1000F2538@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2;
  uint64_t v3;

  v2 = enum case for Mirror.AncestorRepresentation.generated(_:);
  v3 = type metadata accessor for Mirror.AncestorRepresentation(0);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v3 - 8) + 104))(a1, v2, v3);
}

uint64_t sub_1000F257C(uint64_t a1, uint64_t a2)
{
  return sub_1000F25B4(a1, a2, &OBJC_IVAR____TtC7CoreP2P18AppleIO80211Driver_logger, (uint64_t)&unk_1003E39E8, (uint64_t)sub_10000888C);
}

uint64_t sub_1000F25B4(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, uint64_t a5)
{
  char *v5;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  __n128 v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char v33[24];

  v31 = a1;
  v10 = type metadata accessor for Logger(0);
  v11 = *(_QWORD *)(v10 - 8);
  v12 = *(_QWORD *)(v11 + 64);
  __chkstk_darwin();
  v13 = (char *)&v30 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = swift_beginAccess(v5 + 48, v33, 1, 0);
  if (*((_QWORD *)v5 + 8))
  {
    v15 = sub_100012C84();
    v16 = swift_allocError(&type metadata for WiFiError, v15, 0, 0);
    *(_OWORD *)v17 = xmmword_100345C00;
    *(_BYTE *)(v17 + 16) = 1;
    return swift_willThrow(v16);
  }
  else
  {
    (*(void (**)(char *, char *, uint64_t, __n128))(v11 + 16))((char *)&v30 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0), &v5[*a3], v10, v14);
    v19 = *(unsigned __int8 *)(v11 + 80);
    v30 = a5;
    v20 = (v19 + 16) & ~v19;
    v21 = (v12 + v20 + 7) & 0xFFFFFFFFFFFFFFF8;
    v22 = swift_allocObject(a4, v21 + 16, v19 | 7);
    (*(void (**)(uint64_t, char *, uint64_t))(v11 + 32))(v22 + v20, v13, v10);
    v23 = (_QWORD *)(v22 + v21);
    *v23 = v31;
    v23[1] = a2;
    swift_retain();
    swift_retain();
    v24 = v32;
    result = sub_1000F22F4(v5, v30, v22);
    if (!v24)
    {
      v27 = *((_QWORD *)v5 + 6);
      v28 = *((_QWORD *)v5 + 7);
      v29 = *((_QWORD *)v5 + 8);
      *((_QWORD *)v5 + 6) = result;
      *((_QWORD *)v5 + 7) = v25;
      *((_QWORD *)v5 + 8) = v26;
      return sub_1000B53AC(v27, v28, v29);
    }
  }
  return result;
}

uint64_t DeviceDriver.startMonitoringEvents(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t AssociatedTypeWitness;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  void (*v17)(uint64_t, uint64_t);
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  void (*v23)(uint64_t);
  char *v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t AssociatedConformanceWitness;
  void (*v35)(char *, uint64_t (*)(), uint64_t, uint64_t, uint64_t);
  char *v36;
  uint64_t v37;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  char *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  char *v53;
  char *v54;

  v48 = a2;
  v47 = a1;
  v7 = type metadata accessor for Logger(0);
  v50 = *(_QWORD *)(v7 - 8);
  v51 = v7;
  v8 = *(_QWORD *)(v50 + 64);
  __chkstk_darwin();
  v45 = (char *)&v42 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin();
  v54 = (char *)&v42 - v9;
  v44 = *(_QWORD *)(a3 - 8);
  __chkstk_darwin();
  v53 = (char *)&v42 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, a4, a3, &protocol requirements base descriptor for DeviceDriver);
  v12 = type metadata accessor for Optional(0, AssociatedTypeWitness);
  v13 = *(_QWORD *)(v12 - 8);
  __chkstk_darwin();
  v46 = (char *)&v42 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin();
  v16 = (char *)&v42 - v15;
  v17 = *(void (**)(uint64_t, uint64_t))(a4 + 64);
  v18 = v4;
  v52 = a4;
  v17(a3, a4);
  v19 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v20 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v19 + 48))(v16, 1, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t))(v13 + 8))(v16, v12);
  if (v20 == 1)
  {
    v43 = v19;
    v21 = v18;
    (*(void (**)(char *, uint64_t, uint64_t))(v44 + 16))(v53, v18, a3);
    v22 = v52;
    v23 = *(void (**)(uint64_t))(*(_QWORD *)(v52 + 8) + 8);
    v24 = v54;
    v44 = v21;
    v23(a3);
    v26 = v50;
    v25 = v51;
    v27 = v45;
    (*(void (**)(char *, char *, uint64_t))(v50 + 16))(v45, v24, v51);
    v28 = *(unsigned __int8 *)(v26 + 80);
    v29 = (v28 + 16) & ~v28;
    v30 = (v8 + v29 + 7) & 0xFFFFFFFFFFFFFFF8;
    v31 = swift_allocObject(&unk_1003E3998, v30 + 16, v28 | 7);
    (*(void (**)(uint64_t, char *, uint64_t))(v26 + 32))(v31 + v29, v27, v25);
    v32 = (_QWORD *)(v31 + v30);
    v33 = v48;
    *v32 = v47;
    v32[1] = v33;
    AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v22, a3, AssociatedTypeWitness, &protocol requirements base descriptor for DeviceDriver, &associated conformance descriptor for DeviceDriver.DeviceDriver.EventSource: DriverEventSource);
    v35 = *(void (**)(char *, uint64_t (*)(), uint64_t, uint64_t, uint64_t))(AssociatedConformanceWitness
                                                                                             + 32);
    swift_retain();
    v36 = v46;
    v37 = v49;
    v35(v53, sub_10000888C, v31, AssociatedTypeWitness, AssociatedConformanceWitness);
    if (v37)
    {
      return (*(uint64_t (**)(char *, uint64_t))(v26 + 8))(v54, v25);
    }
    else
    {
      (*(void (**)(char *, uint64_t))(v26 + 8))(v54, v25);
      (*(void (**)(char *, _QWORD, uint64_t, uint64_t))(v43 + 56))(v36, 0, 1, AssociatedTypeWitness);
      return (*(uint64_t (**)(char *, uint64_t, uint64_t))(v22 + 72))(v36, a3, v22);
    }
  }
  else
  {
    v39 = sub_100012C84();
    v40 = swift_allocError(&type metadata for WiFiError, v39, 0, 0);
    *(_OWORD *)v41 = xmmword_100345C00;
    *(_BYTE *)(v41 + 16) = 1;
    return swift_willThrow(v40);
  }
}

uint64_t DeviceDriver.init(device:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t AssociatedTypeWitness;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  uint64_t AssociatedConformanceWitness;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v26 = a4;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a3, a2, &protocol requirements base descriptor for DeviceDriver);
  v8 = *(_QWORD *)(AssociatedTypeWitness - 8);
  __chkstk_darwin();
  v10 = (char *)&v24 - v9;
  v25 = type metadata accessor for Optional(0, a2);
  v11 = *(_QWORD *)(v25 - 8);
  __chkstk_darwin();
  v13 = (char *)&v24 - v12;
  v14 = sub_10021D0D8();
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, a2, AssociatedTypeWitness, &protocol requirements base descriptor for DeviceDriver, &associated conformance descriptor for DeviceDriver.DeviceDriver.Device: Device);
  v16 = (*(uint64_t (**)(_QWORD, _QWORD, unint64_t, unint64_t, uint64_t, uint64_t))(AssociatedConformanceWitness + 72))(0, 0, 0xE000000000000000, v14 & 0xFFFFFFFFFFFCLL | 2, AssociatedTypeWitness, AssociatedConformanceWitness);
  if (v17)
  {
    v18 = v16;
    v19 = v17;
    (*(void (**)(char *, uint64_t, uint64_t))(v8 + 16))(v10, a1, AssociatedTypeWitness);
    (*(void (**)(char *, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 48))(v10, 0, v18, v19, a2, a3);
    (*(void (**)(uint64_t, uint64_t))(v8 + 8))(a1, AssociatedTypeWitness);
    v20 = *(_QWORD *)(a2 - 8);
    if (!(*(unsigned int (**)(char *, uint64_t, uint64_t))(v20 + 48))(v13, 1, a2))
    {
      v22 = v26;
      (*(void (**)(uint64_t, char *, uint64_t))(v20 + 32))(v26, v13, a2);
      v21 = 0;
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v20 + 56))(v22, v21, 1, a2);
    }
    (*(void (**)(char *, uint64_t))(v11 + 8))(v13, v25);
  }
  else
  {
    (*(void (**)(uint64_t, uint64_t))(v8 + 8))(a1, AssociatedTypeWitness);
    v20 = *(_QWORD *)(a2 - 8);
  }
  v21 = 1;
  v22 = v26;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v20 + 56))(v22, v21, 1, a2);
}

uint64_t sub_1000F2C98(uint64_t a1, uint64_t a2)
{
  return sub_1000F25B4(a1, a2, &OBJC_IVAR____TtC7CoreP2P19AppleBroadcomDriver_logger, (uint64_t)&unk_1003E39C0, (uint64_t)sub_10000888C);
}

uint64_t sub_1000F2CD8()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;

  v1 = type metadata accessor for Logger(0);
  v2 = *(_QWORD *)(v1 - 8);
  v3 = *(unsigned __int8 *)(v2 + 80);
  v4 = (v3 + 16) & ~v3;
  v5 = v3 | 7;
  v6 = (*(_QWORD *)(v2 + 64) + v4 + 7) & 0xFFFFFFFFFFFFFFF8;
  (*(void (**)(uint64_t, uint64_t))(v2 + 8))(v0 + v4, v1);
  swift_release(*(_QWORD *)(v0 + v6 + 8));
  return swift_deallocObject(v0, v6 + 16, v5);
}

uint64_t sub_1000F2D50(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;

  v3 = *(_QWORD *)(type metadata accessor for Logger(0) - 8);
  v4 = (*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80);
  v5 = v1 + ((*(_QWORD *)(v3 + 64) + v4 + 7) & 0xFFFFFFFFFFFFFFF8);
  return sub_100008890(a1, v1 + v4, *(uint64_t (**)(uint64_t))v5, *(_QWORD *)(v5 + 8));
}

uint64_t sub_1000F2DA4(uint64_t a1)
{
  uint64_t v2;

  v2 = type metadata accessor for DriverEvent(0);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v2 - 8) + 8))(a1, v2);
  return a1;
}

uint64_t sub_1000F2DE0(uint64_t a1, uint64_t a2)
{
  return sub_1000F257C(a1, a2);
}

uint64_t sub_1000F2DF4(uint64_t a1, uint64_t a2)
{
  return sub_1000F2C98(a1, a2);
}

void *NANCipherSuite.defaultValue.unsafeMutableAddressor()
{
  return &static NANCipherSuite.defaultValue;
}

uint64_t NANCipherSuite.description.getter(unsigned __int8 a1)
{
  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_1000F2E50
                                                            + 4 * asc_100345CA8[a1]))(0x312D4D43432D4B53, 0xEA00000000003832);
}

uint64_t sub_1000F2E50()
{
  return 0x322D4D43472D4B53;
}

uint64_t sub_1000F2E6C()
{
  return 0x2D484457322D4B50;
}

uint64_t sub_1000F2EA4()
{
  return 0x504D43432D4B5447;
}

uint64_t sub_1000F2EC4()
{
  return 0x504D43472D4B5447;
}

uint64_t sub_1000F2EE4()
{
  return 0x2D4E5341502D4B50;
}

_UNKNOWN **static NANCipherSuite.allCases.getter()
{
  return &off_1003D6E50;
}

uint64_t sub_1000F2F20@<X0>(char *a1@<X0>, _BYTE *a2@<X8>)
{
  uint64_t result;

  result = _s7CoreP2P14NANCipherSuiteO8rawValueACSgs5UInt8V_tcfC_0(*a1);
  *a2 = result;
  return result;
}

void sub_1000F2F48(_QWORD *a1@<X8>)
{
  *a1 = &off_1003D6E50;
}

uint64_t sub_1000F2F58(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000F3438();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000F2FB4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000F3438();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

uint64_t sub_1000F3000()
{
  unsigned __int8 *v0;

  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_1000F3038 + 4 * byte_100345CB0[*v0]))(0x312D4D43432D4B53, 0xEA00000000003832);
}

uint64_t sub_1000F3038()
{
  return 0x322D4D43472D4B53;
}

uint64_t sub_1000F3054()
{
  return 0x2D484457322D4B50;
}

uint64_t sub_1000F308C()
{
  return 0x504D43432D4B5447;
}

uint64_t sub_1000F30AC()
{
  return 0x504D43472D4B5447;
}

uint64_t sub_1000F30CC()
{
  return 0x2D4E5341502D4B50;
}

BOOL static NANCipherSuite.< infix(_:_:)(char a1, char a2)
{
  return !a1 && a2 == 1;
}

BOOL static NANCipherSuite.> infix(_:_:)(char a1, char a2)
{
  return !a2 && a1 == 1;
}

BOOL sub_1000F3120(_BYTE *a1, _BYTE *a2)
{
  return *a2 == 1 && *a1 == 0;
}

BOOL sub_1000F3138(_BYTE *a1, _BYTE *a2)
{
  return *a1 != 1 || *a2 != 0;
}

BOOL sub_1000F3150(_BYTE *a1, _BYTE *a2)
{
  return *a2 != 1 || *a1 != 0;
}

BOOL sub_1000F3168(_BYTE *a1, _BYTE *a2)
{
  return *a1 == 1 && *a2 == 0;
}

uint64_t Collection<>.strongestSupportedSharedKeySuite.getter(uint64_t a1, uint64_t a2)
{
  return sub_1000F31A8(a1, a2, (uint64_t)sub_1000F318C);
}

BOOL sub_1000F318C(unsigned __int8 *a1)
{
  return *a1 < 2u;
}

uint64_t Collection<>.strongestSupportedPublicKeySuite.getter(uint64_t a1, uint64_t a2)
{
  return sub_1000F31A8(a1, a2, (uint64_t)sub_1000F3288);
}

uint64_t sub_1000F31A8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  int v14;
  int v15;
  unsigned int v16;
  uint64_t v18;

  __chkstk_darwin(a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 16))((char *)&v18 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0), v3, a1);
  v9 = Sequence.filter(_:)(a3, 0, a1, *(_QWORD *)(a2 + 8));
  v10 = *(_QWORD *)(v9 + 16);
  if (v10)
  {
    v11 = *(unsigned __int8 *)(v9 + 32);
    v12 = v10 - 1;
    if (v12)
    {
      v13 = (unsigned __int8 *)(v9 + 33);
      do
      {
        v15 = *v13++;
        v14 = v15;
        v16 = v11;
        if ((v11 & 0xFE) == 0)
          v16 = 1;
        if (v14 == 1)
          v11 = v16;
        else
          v11 = v11;
        --v12;
      }
      while (v12);
    }
  }
  else
  {
    v11 = 8;
  }
  swift_bridgeObjectRelease(v9);
  return v11;
}

BOOL sub_1000F3288(_BYTE *a1)
{
  return (*a1 & 0xFE) == 2;
}

uint64_t NANCipherSuite.init(apiCipherSuite:)(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) >= 8)
    return 8;
  else
    return a1 - 1;
}

uint64_t InfrastructureQualityOfService.rawValue.getter(unsigned __int8 a1)
{
  return a1 + 1;
}

uint64_t _s7CoreP2P14NANCipherSuiteO8rawValueACSgs5UInt8V_tcfC_0(char a1)
{
  if (((a1 - 1) & 0xF8) != 0)
    return 8;
  else
    return (a1 - 1);
}

unint64_t sub_1000F32D8()
{
  unint64_t result;
  uint64_t v1;

  result = qword_10040E250;
  if (!qword_10040E250)
  {
    v1 = sub_100013C64((uint64_t *)&unk_10040D1F0);
    result = swift_getWitnessTable((const char *)&protocol conformance descriptor for [A], v1);
    atomic_store(result, (unint64_t *)&qword_10040E250);
  }
  return result;
}

unint64_t sub_1000F3328()
{
  unint64_t result;

  result = qword_100407C30;
  if (!qword_100407C30)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANCipherSuite, &type metadata for NANCipherSuite);
    atomic_store(result, (unint64_t *)&qword_100407C30);
  }
  return result;
}

uint64_t storeEnumTagSinglePayload for NANCipherSuite(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 7 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 7) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xF9)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xF8)
    return ((uint64_t (*)(void))((char *)&loc_1000F33B8 + 4 * byte_100345CBD[v4]))();
  *a1 = a2 + 7;
  return ((uint64_t (*)(void))((char *)sub_1000F33EC + 4 * byte_100345CB8[v4]))();
}

uint64_t sub_1000F33EC(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000F33F4(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x1000F33FCLL);
  return result;
}

uint64_t sub_1000F3408(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x1000F3410);
  *(_BYTE *)result = a2 + 7;
  return result;
}

uint64_t sub_1000F3414(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000F341C(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for NANCipherSuite()
{
  return &type metadata for NANCipherSuite;
}

unint64_t sub_1000F3438()
{
  unint64_t result;

  result = qword_100407C38;
  if (!qword_100407C38)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANCipherSuite, &type metadata for NANCipherSuite);
    atomic_store(result, (unint64_t *)&qword_100407C38);
  }
  return result;
}

_QWORD *sub_1000F347C(uint64_t a1, uint64_t a2)
{
  int64_t v3;
  _QWORD *result;
  uint64_t v5;
  char *v6;
  int v7;
  int v8;
  int v9;
  char v10;
  unint64_t v11;
  char v12;
  int v13;
  int v14;
  int v15;
  BOOL v16;
  char v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  char v21;
  char v22;
  _QWORD *v24;

  v3 = *(_QWORD *)(a1 + 16);
  result = _swiftEmptyArrayStorage;
  if (v3)
  {
    sub_1000750E8(0, v3, 0);
    v5 = a2;
    result = _swiftEmptyArrayStorage;
    v6 = (char *)(a1 + 38);
    do
    {
      v7 = *(_DWORD *)(v6 - 6);
      v8 = *(v6 - 2);
      v9 = *(v6 - 1);
      v10 = *v6;
      if (*(v6 - 2))
      {
        if (v8 != 1)
          goto LABEL_19;
        v11 = *(unsigned int *)(v5 + 8) | ((unint64_t)*(unsigned __int16 *)(v5 + 12) << 32);
        if ((v11 & 0xFF00000000) == 0x300000000)
          goto LABEL_19;
        v12 = *(_WORD *)(v5 + 12);
        v13 = BYTE5(v11);
        if (*(_DWORD *)(v5 + 8) != v7)
          goto LABEL_19;
      }
      else
      {
        v13 = *(unsigned __int8 *)(v5 + 5);
        v12 = *(_BYTE *)(v5 + 4);
        if (*(_DWORD *)v5 != v7)
          goto LABEL_19;
      }
      if (v12)
      {
        if (v12 != 1)
          goto LABEL_19;
        v14 = 16;
      }
      else
      {
        v14 = 4;
      }
      if (*(v6 - 2))
        v15 = 16;
      else
        v15 = 4;
      if (v14 == v15)
      {
        switch(v13)
        {
          case 2:
            v16 = v9 == 2;
            goto LABEL_31;
          case 3:
            v16 = v9 == 3;
            goto LABEL_31;
          case 4:
            v16 = v9 == 4;
            goto LABEL_31;
          case 5:
            v16 = v9 == 5;
            goto LABEL_31;
          case 6:
            v16 = v9 == 6;
LABEL_31:
            v17 = v16;
            break;
          default:
            v21 = v9 ^ ((v13 & 1) == 0);
            if ((v9 - 2) >= 5)
              v17 = v21;
            else
              v17 = 0;
            break;
        }
        goto LABEL_20;
      }
LABEL_19:
      v17 = 0;
LABEL_20:
      v24 = result;
      v19 = result[2];
      v18 = result[3];
      if (v19 >= v18 >> 1)
      {
        v22 = *v6;
        sub_1000750E8(v18 > 1, v19 + 1, 1);
        v10 = v22;
        v5 = a2;
        result = v24;
      }
      result[2] = v19 + 1;
      v20 = &result[v19];
      *((_DWORD *)v20 + 8) = v7;
      v6 += 8;
      *((_BYTE *)v20 + 36) = v8;
      *((_BYTE *)v20 + 37) = v9;
      *((_BYTE *)v20 + 38) = v10;
      *((_BYTE *)v20 + 39) = v17 & 1;
      --v3;
    }
    while (v3);
  }
  return result;
}

_QWORD *sub_1000F3684(uint64_t a1, uint64_t a2)
{
  int64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  char v18;
  unint64_t v19;
  char v20;
  int v21;
  int v22;
  int v23;
  BOOL v24;
  char v25;
  unint64_t v26;
  unint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  int v35;
  char v36;
  char v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v42;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2)
  {
    v42 = *(_QWORD *)(a1 + 16);
    sub_1000750E8(0, v2, 0);
    v4 = sub_10007788C(a1);
    v6 = v42;
    v5 = a1;
    v7 = 0;
    v8 = a1 + 64;
    v9 = *(_BYTE *)(a1 + 32);
    v10 = a1 + 88;
    v11 = a2;
    do
    {
      if (v4 < 0 || v4 >= 1 << v9)
      {
        __break(1u);
LABEL_51:
        __break(1u);
LABEL_52:
        __break(1u);
LABEL_53:
        __break(1u);
LABEL_54:
        __break(1u);
LABEL_55:
        __break(1u);
        JUMPOUT(0x1000F39D8);
      }
      v13 = (unint64_t)v4 >> 6;
      if ((*(_QWORD *)(v8 + 8 * ((unint64_t)v4 >> 6)) & (1 << v4)) == 0)
        goto LABEL_51;
      if (*(_DWORD *)(v5 + 36) != (_DWORD)v3)
        goto LABEL_52;
      v14 = *(_QWORD *)(v5 + 48) + 8 * v4;
      v15 = *(_DWORD *)v14;
      v16 = *(unsigned __int8 *)(v14 + 4);
      v17 = *(unsigned __int8 *)(v14 + 5);
      v18 = *(_BYTE *)(*(_QWORD *)(v5 + 56) + v4);
      if (*(_BYTE *)(v14 + 4))
      {
        if (v16 != 1)
          goto LABEL_26;
        v19 = *(unsigned int *)(v11 + 8) | ((unint64_t)*(unsigned __int16 *)(v11 + 12) << 32);
        if ((v19 & 0xFF00000000) == 0x300000000)
          goto LABEL_26;
        v20 = *(_WORD *)(v11 + 12);
        v21 = BYTE5(v19);
        if (*(_DWORD *)(v11 + 8) != v15)
          goto LABEL_26;
      }
      else
      {
        v21 = *(unsigned __int8 *)(v11 + 5);
        v20 = *(_BYTE *)(v11 + 4);
        if (*(_DWORD *)v11 != v15)
          goto LABEL_26;
      }
      if (v20)
      {
        if (v20 != 1)
          goto LABEL_26;
        v22 = 16;
      }
      else
      {
        v22 = 4;
      }
      if (v16)
        v23 = 16;
      else
        v23 = 4;
      if (v22 != v23)
      {
LABEL_26:
        v25 = 0;
        goto LABEL_27;
      }
      switch(v21)
      {
        case 2:
          v24 = v17 == 2;
          goto LABEL_45;
        case 3:
          v24 = v17 == 3;
          goto LABEL_45;
        case 4:
          v24 = v17 == 4;
          goto LABEL_45;
        case 5:
          v24 = v17 == 5;
          goto LABEL_45;
        case 6:
          v24 = v17 == 6;
LABEL_45:
          v25 = v24;
          break;
        default:
          if ((v17 - 2) < 5)
            goto LABEL_26;
          v25 = v17 ^ ((v21 & 1) == 0);
          break;
      }
LABEL_27:
      v27 = _swiftEmptyArrayStorage[2];
      v26 = _swiftEmptyArrayStorage[3];
      if (v27 >= v26 >> 1)
      {
        v39 = v8;
        v40 = v3;
        v38 = v10;
        v36 = v17;
        v37 = *(_BYTE *)(*(_QWORD *)(v5 + 56) + v4);
        v35 = v15;
        sub_1000750E8(v26 > 1, v27 + 1, 1);
        v15 = v35;
        LOBYTE(v17) = v36;
        v18 = v37;
        v10 = v38;
        v8 = v39;
        v3 = v40;
        v6 = v42;
        v5 = a1;
        v11 = a2;
      }
      _swiftEmptyArrayStorage[2] = v27 + 1;
      v28 = &_swiftEmptyArrayStorage[v27];
      *((_DWORD *)v28 + 8) = v15;
      *((_BYTE *)v28 + 36) = v16;
      *((_BYTE *)v28 + 37) = v17;
      *((_BYTE *)v28 + 38) = v18;
      *((_BYTE *)v28 + 39) = v25 & 1;
      v9 = *(_BYTE *)(v5 + 32);
      v12 = 1 << v9;
      if (v4 >= 1 << v9)
        goto LABEL_53;
      v29 = *(_QWORD *)(v8 + 8 * v13);
      if ((v29 & (1 << v4)) == 0)
        goto LABEL_54;
      if (*(_DWORD *)(v5 + 36) != (_DWORD)v3)
        goto LABEL_55;
      v30 = v29 & (-2 << (v4 & 0x3F));
      if (v30)
      {
        v12 = __clz(__rbit64(v30)) | v4 & 0xFFFFFFFFFFFFFFC0;
      }
      else
      {
        v31 = v13 + 1;
        v32 = (v12 + 63) >> 6;
        if (v13 + 1 < v32)
        {
          v33 = *(_QWORD *)(v8 + 8 * v31);
          if (!v33)
          {
            v31 = v13 + 2;
            if (v13 + 2 >= v32)
              goto LABEL_4;
            v33 = *(_QWORD *)(v8 + 8 * v31);
            if (!v33)
            {
              while (v32 - 3 != v13)
              {
                v33 = *(_QWORD *)(v10 + 8 * v13++);
                if (v33)
                {
                  v31 = v13 + 2;
                  goto LABEL_35;
                }
              }
              goto LABEL_4;
            }
          }
LABEL_35:
          v12 = __clz(__rbit64(v33)) + (v31 << 6);
        }
      }
LABEL_4:
      ++v7;
      v4 = v12;
    }
    while (v7 != v6);
  }
  return _swiftEmptyArrayStorage;
}

void *RadioResources.Priority.min.unsafeMutableAddressor()
{
  return &static RadioResources.Priority.min;
}

void *RadioResources.Priority.max.unsafeMutableAddressor()
{
  return &static RadioResources.Priority.max;
}

uint64_t static RadioResources.Priority.max.getter()
{
  return 12;
}

_UNKNOWN **static RadioResources.Priority.allCases.getter()
{
  return &off_1003D6E78;
}

unint64_t sub_1000F3A1C@<X0>(unint64_t *a1@<X0>, _BYTE *a2@<X8>)
{
  unint64_t result;

  result = _s7CoreP2P14RadioResourcesO8PriorityO8rawValueAESgSi_tcfC_0(*a1);
  *a2 = result;
  return result;
}

void sub_1000F3A44(_QWORD *a1@<X8>)
{
  *a1 = &off_1003D6E78;
}

uint64_t RadioResources.SymbolicChannel.Resolver.socialChannel(for:)(char a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  if (!a1)
    return a2 & 0xFFFFFFFFFFFFLL;
  v3 = 0x300000000;
  if (a1 == 1)
    v3 = a3;
  return v3 & 0xFFFFFFFFFFFFLL;
}

unint64_t RadioResources.PreferredChannel.init(channel:usagePreference:isEqualToSocial:)(uint64_t a1, unsigned __int8 a2, char a3)
{
  uint64_t v3;

  v3 = 0x100000000000000;
  if ((a3 & 1) == 0)
    v3 = 0;
  return v3 & 0xFFFF000000000000 | ((unint64_t)a2 << 48) | a1 & 0xFFFFFFFFFFFFLL;
}

uint64_t RadioResources.SymbolicChannel.Resolver.primaryChannel.setter(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t result;

  *(_DWORD *)v1 = a1;
  *(_BYTE *)(v1 + 4) = BYTE4(a1);
  *(_BYTE *)(v1 + 5) = BYTE5(a1);
  v2 = *(_QWORD *)(v1 + 24);
  v3 = swift_bridgeObjectRetain(v2);
  v4 = sub_1000F347C(v3, v1);
  result = swift_bridgeObjectRelease_n(v2, 2);
  *(_QWORD *)(v1 + 24) = v4;
  return result;
}

uint64_t (*RadioResources.SymbolicChannel.Resolver.primaryChannel.modify(uint64_t a1))()
{
  uint64_t v1;

  *(_QWORD *)(a1 + 8) = v1;
  return sub_1000F3B1C;
}

uint64_t NANBeacon.Metadata.channel.getter(uint64_t a1, uint64_t a2)
{
  return a2 & 0xFFFFFFFFFFFFLL;
}

uint64_t RadioResources.SymbolicChannel.Resolver.secondaryChannel.setter(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t result;

  *(_DWORD *)(v1 + 8) = a1;
  *(_WORD *)(v1 + 12) = WORD2(a1);
  v2 = *(_QWORD *)(v1 + 24);
  v3 = swift_bridgeObjectRetain(v2);
  v4 = sub_1000F347C(v3, v1);
  result = swift_bridgeObjectRelease_n(v2, 2);
  *(_QWORD *)(v1 + 24) = v4;
  return result;
}

uint64_t (*RadioResources.SymbolicChannel.Resolver.secondaryChannel.modify(uint64_t a1))()
{
  uint64_t v1;

  *(_QWORD *)(a1 + 8) = v1;
  return sub_1000F3B1C;
}

uint64_t sub_1000F3BA0(uint64_t result, char a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;

  if ((a2 & 1) == 0)
  {
    v2 = *(_QWORD *)(result + 8);
    v3 = *(_QWORD *)(v2 + 24);
    v4 = swift_bridgeObjectRetain(v3);
    v5 = sub_1000F347C(v4, v2);
    result = swift_bridgeObjectRelease_n(v3, 2);
    *(_QWORD *)(v2 + 24) = v5;
  }
  return result;
}

uint64_t RadioResources.SymbolicChannel.Resolver.infraChannel.setter(uint64_t result)
{
  uint64_t v1;

  *(_DWORD *)(v1 + 16) = result;
  *(_WORD *)(v1 + 20) = WORD2(result);
  return result;
}

uint64_t NANDataResponseReceivedEvent.attributes.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return swift_bridgeObjectRetain(a4);
}

uint64_t RadioResources.SymbolicChannel.Resolver.preferredChannels.setter(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;

  result = swift_bridgeObjectRelease(*(_QWORD *)(v1 + 24));
  *(_QWORD *)(v1 + 24) = a1;
  return result;
}

uint64_t RadioResources.SymbolicChannel.Resolver.init(primaryChannel:secondaryChannel:infraChannel:preferredChannels:)(uint64_t a1)
{
  return a1 & 0xFFFFFFFFFFFFLL;
}

Swift::Void __swiftcall RadioResources.SymbolicChannel.Resolver.update(preferredChannels:)(Swift::OpaquePointer preferredChannels)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;

  v2 = sub_1000F3684((uint64_t)preferredChannels._rawValue, v1);
  v4 = v2;
  swift_bridgeObjectRetain(v2);
  sub_1000F4B30((uint64_t *)&v4);
  swift_bridgeObjectRelease(v2);
  v3 = (uint64_t)v4;
  swift_bridgeObjectRelease(*(_QWORD *)(v1 + 24));
  *(_QWORD *)(v1 + 24) = v3;
}

uint64_t RadioResources.SymbolicChannel.Resolver.channel(for:supportsSimulatenousDualBand:on:)(uint64_t a1, char a2, char a3, unsigned __int8 a4, uint64_t a5, uint64_t a6, uint64_t a7, _QWORD *a8)
{
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  int v12;
  char *v13;
  unint64_t v14;
  unint64_t v15;
  _QWORD *v16;
  int v17;
  int v18;
  char v19;
  char v20;
  char v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v28;

  v8 = a1;
  if (!a2)
  {
    v10 = a8;
    if ((a3 & 1) == 0)
    {
      swift_bridgeObjectRetain(a8);
      goto LABEL_26;
    }
    if (a4 <= 1u)
    {
      v11 = a8[2];
      if (v11)
      {
        if (a4)
          v12 = 16;
        else
          v12 = 4;
        swift_bridgeObjectRetain(a8);
        v13 = (char *)v10 + 39;
        v28 = v12;
        while (1)
        {
          v17 = *(_DWORD *)(v13 - 7);
          v18 = *(v13 - 3);
          v19 = *(v13 - 2);
          v20 = *(v13 - 1);
          v21 = *v13;
          if (*(v13 - 3))
          {
            if (v18 == 1 && v12 == 16)
            {
LABEL_20:
              if ((swift_isUniquelyReferenced_nonNull_native(_swiftEmptyArrayStorage) & 1) == 0)
                sub_1000750E8(0, _swiftEmptyArrayStorage[2] + 1, 1);
              v15 = _swiftEmptyArrayStorage[2];
              v14 = _swiftEmptyArrayStorage[3];
              if (v15 >= v14 >> 1)
                sub_1000750E8(v14 > 1, v15 + 1, 1);
              _swiftEmptyArrayStorage[2] = v15 + 1;
              v16 = &_swiftEmptyArrayStorage[v15];
              *((_DWORD *)v16 + 8) = v17;
              *((_BYTE *)v16 + 36) = v18;
              *((_BYTE *)v16 + 37) = v19;
              *((_BYTE *)v16 + 38) = v20;
              *((_BYTE *)v16 + 39) = v21;
              v12 = v28;
            }
          }
          else if (v12 == 4)
          {
            goto LABEL_20;
          }
          v13 += 8;
          if (!--v11)
          {
            swift_bridgeObjectRelease(v10);
            v8 = a1;
            v10 = _swiftEmptyArrayStorage;
            goto LABEL_26;
          }
        }
      }
      v10 = _swiftEmptyArrayStorage;
LABEL_26:
      if (v10[2] <= v8)
      {
        __break(1u);
      }
      else if ((v8 & 0x8000000000000000) == 0)
      {
        v22 = &v10[v8];
        v23 = *((unsigned int *)v22 + 8);
        v24 = *((unsigned __int8 *)v22 + 36);
        v25 = *((unsigned __int8 *)v22 + 37);
        swift_bridgeObjectRelease(v10);
        v9 = v23 | (v24 << 32) | (v25 << 40);
        return v9 & 0xFFFFFFFFFFFFLL;
      }
      __break(1u);
    }
    __break(1u);
    JUMPOUT(0x1000F3ED4);
  }
  if (a2 != 1)
    __asm { BR              X9 }
  v9 = a1 & 0xFFFFFFFFFFFFLL;
  return v9 & 0xFFFFFFFFFFFFLL;
}

void RadioResources.SymbolicChannel.hash(into:)(uint64_t a1, Swift::UInt a2, char a3)
{
  Swift::UInt v4;

  if (a3)
  {
    if (a3 != 1)
      __asm { BR              X9 }
    Hasher._combine(_:)(4uLL);
    Hasher._combine(_:)(a2);
    Hasher._combine(_:)(0x801004u >> ((a2 >> 29) & 0xF8));
    switch(BYTE5(a2))
    {
      case 2:
        v4 = 0;
        goto LABEL_12;
      case 3:
        v4 = 1;
        goto LABEL_12;
      case 4:
        v4 = 3;
        goto LABEL_12;
      case 5:
        v4 = 4;
        goto LABEL_12;
      case 6:
        v4 = 5;
        goto LABEL_12;
      default:
        Hasher._combine(_:)(2uLL);
        Hasher._combine(_:)(BYTE5(a2) & 1);
        break;
    }
  }
  else
  {
    Hasher._combine(_:)(3uLL);
    v4 = a2;
LABEL_12:
    Hasher._combine(_:)(v4);
  }
}

Swift::Int RadioResources.SymbolicChannel.hashValue.getter(Swift::UInt a1, char a2)
{
  _QWORD v5[9];

  Hasher.init(_seed:)(v5);
  RadioResources.SymbolicChannel.hash(into:)((uint64_t)v5, a1, a2);
  return Hasher._finalize()();
}

Swift::Int sub_1000F4020()
{
  uint64_t v0;
  Swift::UInt v1;
  char v2;
  _QWORD v4[9];

  v1 = *(_QWORD *)v0;
  v2 = *(_BYTE *)(v0 + 8);
  Hasher.init(_seed:)(v4);
  RadioResources.SymbolicChannel.hash(into:)((uint64_t)v4, v1, v2);
  return Hasher._finalize()();
}

void sub_1000F406C(uint64_t a1)
{
  uint64_t v1;

  RadioResources.SymbolicChannel.hash(into:)(a1, *(_QWORD *)v1, *(_BYTE *)(v1 + 8));
}

Swift::Int sub_1000F4078()
{
  uint64_t v0;
  Swift::UInt v1;
  char v2;
  _QWORD v4[9];

  v1 = *(_QWORD *)v0;
  v2 = *(_BYTE *)(v0 + 8);
  Hasher.init(_seed:)(v4);
  RadioResources.SymbolicChannel.hash(into:)((uint64_t)v4, v1, v2);
  return Hasher._finalize()();
}

uint64_t sub_1000F40C0(uint64_t a1, uint64_t a2)
{
  return _s7CoreP2P14RadioResourcesO15SymbolicChannelO21__derived_enum_equalsySbAE_AEtFZ_0(*(_QWORD *)a1, *(_BYTE *)(a1 + 8), *(_QWORD *)a2, *(_BYTE *)(a2 + 8));
}

BOOL RadioResources.PreferredChannel.requiresExtraBandwidth.getter(uint64_t a1)
{
  return (a1 & 0xFF000000000000) == 0x1000000000000;
}

uint64_t NANDataEstablishedEvent.type.getter(unint64_t a1)
{
  return HIBYTE(a1) & 1;
}

uint64_t RadioResources.PreferredChannel.isEqualToSocial.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 7) = result;
  return result;
}

uint64_t (*RadioResources.PreferredChannel.isEqualToSocial.modify())()
{
  return NANBitmap.Channel.operatingClass.getter;
}

void RadioResources.PreferredChannel.hash(into:)(int a1, unint64_t a2)
{
  Swift::UInt v3;

  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(0x801004u >> ((a2 >> 29) & 0xF8));
  switch(BYTE5(a2))
  {
    case 2:
      v3 = 0;
      goto LABEL_8;
    case 3:
      v3 = 1;
      goto LABEL_8;
    case 4:
      v3 = 3;
      goto LABEL_8;
    case 5:
      v3 = 4;
      goto LABEL_8;
    case 6:
      v3 = 5;
LABEL_8:
      Hasher._combine(_:)(v3);
      break;
    default:
      Hasher._combine(_:)(2uLL);
      Hasher._combine(_:)(BYTE5(a2) & 1);
      break;
  }
  Hasher._combine(_:)(BYTE6(a2));
  Hasher._combine(_:)(HIBYTE(a2) & 1);
}

uint64_t static RadioResources.PreferredChannel.__derived_struct_equals(_:_:)(uint64_t a1, uint64_t a2)
{
  return sub_1000F6164(a1 & 0x1FFFFFFFFFFFFFFLL, a2 & 0x1FFFFFFFFFFFFFFLL);
}

Swift::Int RadioResources.PreferredChannel.hashValue.getter(uint64_t a1)
{
  _QWORD v3[9];

  Hasher.init(_seed:)(v3);
  RadioResources.PreferredChannel.hash(into:)((int)v3, a1 & 0x1FFFFFFFFFFFFFFLL);
  return Hasher._finalize()();
}

Swift::Int sub_1000F4210()
{
  unsigned __int8 *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  _QWORD v8[9];

  v1 = *(unsigned int *)v0;
  v2 = v0[4];
  v3 = v0[5];
  v4 = v0[6];
  v5 = v0[7];
  Hasher.init(_seed:)(v8);
  v6 = 0x100000000000000;
  if (!v5)
    v6 = 0;
  RadioResources.PreferredChannel.hash(into:)((int)v8, v6 | (v4 << 48) | (v3 << 40) | (v2 << 32) | v1);
  return Hasher._finalize()();
}

void sub_1000F428C(int a1)
{
  unsigned __int8 *v1;
  uint64_t v2;

  v2 = 0x100000000000000;
  if (!v1[7])
    v2 = 0;
  RadioResources.PreferredChannel.hash(into:)(a1, v2 | ((unint64_t)v1[6] << 48) | ((unint64_t)v1[5] << 40) | ((unint64_t)v1[4] << 32) | *(unsigned int *)v1);
}

Swift::Int sub_1000F42C0()
{
  unsigned __int8 *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  _QWORD v8[9];

  v1 = *(unsigned int *)v0;
  v2 = v0[4];
  v3 = v0[5];
  v4 = v0[6];
  v5 = v0[7];
  Hasher.init(_seed:)(v8);
  v6 = 0x100000000000000;
  if (!v5)
    v6 = 0;
  RadioResources.PreferredChannel.hash(into:)((int)v8, v6 | (v4 << 48) | (v3 << 40) | (v2 << 32) | v1);
  return Hasher._finalize()();
}

uint64_t sub_1000F4338(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;

  v2 = *(unsigned int *)a1;
  v3 = a1[4];
  v4 = a1[5];
  v5 = a1[6];
  if (a1[7])
    v6 = 0x100000000000000;
  else
    v6 = 0;
  v7 = v6 | (v5 << 48) | (v4 << 40) | (v3 << 32) | v2;
  if (a2[7])
    v8 = 0x100000000000000;
  else
    v8 = 0;
  return sub_1000F6164(v7, v8 | ((unint64_t)a2[6] << 48) | ((unint64_t)a2[5] << 40) | ((unint64_t)a2[4] << 32) | *(unsigned int *)a2);
}

uint64_t RadioSchedule.set(_:to:with:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, uint64_t a7, uint64_t a8)
{
  _QWORD v9[8];
  char v10;
  char v11;

  v9[2] = a7;
  v9[3] = a8;
  v9[4] = a1;
  v9[5] = a2;
  v9[6] = a3;
  v9[7] = a4;
  v10 = a5;
  v11 = a6;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(uint64_t), _QWORD *, uint64_t, uint64_t))(a8 + 24))(a4, a5, sub_1000F6284, v9, a7, a8);
}

uint64_t sub_1000F4428(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, uint64_t a8, uint64_t a9)
{
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  uint64_t (*v17)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t);
  uint64_t v18;

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, a9, a8, &protocol requirements base descriptor for RadioSchedule, &associated type descriptor for RadioSchedule.Map);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a9, a8, AssociatedTypeWitness, &protocol requirements base descriptor for RadioSchedule, &associated conformance descriptor for RadioSchedule.RadioSchedule.Map: RadioMap);
  v17 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t))(AssociatedConformanceWitness + 32);
  v18 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v17(a2, a3, a4, a5, a6, a7, v18, AssociatedConformanceWitness);
}

uint64_t RadioSchedule.reserve(_:with:)(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5, uint64_t a6)
{
  _QWORD v7[7];
  char v8;

  v7[2] = a5;
  v7[3] = a6;
  v7[4] = a1;
  v7[5] = a2;
  v7[6] = a3;
  v8 = a4;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(uint64_t), _QWORD *))(a6 + 24))(3, 2, sub_1000F62B8, v7);
}

uint64_t sub_1000F4588(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  uint64_t (*v15)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v16;

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, a7, a6, &protocol requirements base descriptor for RadioSchedule, &associated type descriptor for RadioSchedule.Map);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a7, a6, AssociatedTypeWitness, &protocol requirements base descriptor for RadioSchedule, &associated conformance descriptor for RadioSchedule.RadioSchedule.Map: RadioMap);
  v15 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(AssociatedConformanceWitness
                                                                                       + 24);
  v16 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v15(a2, a3, a4, a5, v16, AssociatedConformanceWitness);
}

CoreP2P::RadioResources::Priority __swiftcall RadioSchedule.inflexibleUpgrade(priority:)(CoreP2P::RadioResources::Priority priority)
{
  uint64_t v1;

  if (((*(uint64_t (**)())(v1 + 56))() & 1) != 0)
    return priority;
  else
    return 11;
}

uint64_t RadioResourceControls.update<A>(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t TupleTypeMetadata2;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  void (*v30)(char *, uint64_t, uint64_t);
  uint64_t v31;
  uint64_t v32;
  uint64_t (*v33)(char *, uint64_t, uint64_t);
  uint64_t result;
  char *v35;
  void (*v36)(char *, char *, uint64_t);
  char *v37;
  char *v38;
  char *v39;
  uint64_t v40;
  char v41;
  uint64_t v42;
  void (*v43)(char *, uint64_t);
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  void (*v47)(char *, uint64_t);
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  char *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;

  v55 = a5;
  v56 = a8;
  v57 = a1;
  v49 = a7;
  v53 = a6;
  v54 = a3;
  v58 = a2;
  v9 = type metadata accessor for UUID(0);
  v50 = *(_QWORD *)(v9 - 8);
  v51 = v9;
  v10 = __chkstk_darwin(v9);
  v52 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = __chkstk_darwin(v10);
  v14 = (char *)&v48 - v13;
  v15 = *(_QWORD *)(a4 - 8);
  v16 = __chkstk_darwin(v12);
  v18 = (char *)&v48 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  v19 = __chkstk_darwin(v16);
  v21 = (char *)&v48 - v20;
  __chkstk_darwin(v19);
  v23 = (char *)&v48 - v22;
  v24 = type metadata accessor for Optional(255, a4);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v24, v24, 0, 0);
  v26 = __chkstk_darwin(TupleTypeMetadata2);
  v28 = (char *)&v48 - v27;
  v29 = (char *)&v48 + *(int *)(v26 + 48) - v27;
  v30 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(v24 - 8) + 16);
  v30((char *)&v48 - v27, v57, v24);
  v31 = v24;
  v32 = v15;
  v30(v29, v58, v31);
  v33 = *(uint64_t (**)(char *, uint64_t, uint64_t))(v15 + 48);
  LODWORD(v15) = v33(v28, 1, a4);
  result = v33(v29, 1, a4);
  if ((_DWORD)v15 == 1)
  {
    if ((_DWORD)result == 1)
      return result;
    (*(void (**)(char *, char *, uint64_t))(v32 + 32))(v23, v29, a4);
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v55 + 8))(v23, a4, v53, v56, v54);
    return (*(uint64_t (**)(char *, uint64_t))(v32 + 8))(v23, a4);
  }
  v35 = v52;
  v36 = *(void (**)(char *, char *, uint64_t))(v32 + 32);
  if ((_DWORD)result == 1)
  {
    v36(v23, v28, a4);
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v55 + 16))(v23, a4, v53, v56, v54);
    return (*(uint64_t (**)(char *, uint64_t))(v32 + 8))(v23, a4);
  }
  v36(v21, v28, a4);
  v37 = v18;
  v36(v18, v29, a4);
  v38 = v14;
  v39 = v21;
  v40 = v56;
  dispatch thunk of Identifiable.id.getter(a4, v56);
  dispatch thunk of Identifiable.id.getter(a4, v40);
  v41 = static UUID.== infix(_:_:)(v38, v35);
  v42 = v51;
  v43 = *(void (**)(char *, uint64_t))(v50 + 8);
  v43(v35, v51);
  v43(v38, v42);
  if ((v41 & 1) != 0)
  {
    if ((dispatch thunk of static Equatable.== infix(_:_:)(v39, v37, a4, *(_QWORD *)(v49 + 8)) & 1) == 0)
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v55 + 8))(v37, a4, v53, v40, v54);
  }
  else
  {
    v44 = v55;
    v46 = v53;
    v45 = v54;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v55 + 16))(v39, a4, v53, v40, v54, v55);
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v44 + 8))(v37, a4, v46, v40, v45);
  }
  v47 = *(void (**)(char *, uint64_t))(v32 + 8);
  v47(v37, a4);
  return ((uint64_t (*)(char *, uint64_t))v47)(v39, a4);
}

uint64_t Optional<A>.update<A>(schedule:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;

  v9 = *(_QWORD *)(a2 + 16);
  v10 = *(_QWORD *)(v9 - 8);
  v11 = __chkstk_darwin(a1);
  v13 = (char *)&v19 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin(v11);
  v15 = (char *)&v19 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t))(v16 + 16))(v15, v17);
  result = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v10 + 48))(v15, 1, v9);
  if ((_DWORD)result != 1)
  {
    (*(void (**)(char *, char *, uint64_t))(v10 + 32))(v13, v15, v9);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 8))(a1, a3, a5, v9, a4);
    return (*(uint64_t (**)(char *, uint64_t))(v10 + 8))(v13, v9);
  }
  return result;
}

uint64_t sub_1000F4B14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return Optional<A>.update<A>(schedule:)(a1, a4, a2, *(_QWORD *)(a5 - 8), a3);
}

Swift::Int sub_1000F4B30(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  Swift::Int result;
  uint64_t v5[2];

  v2 = *a1;
  if ((swift_isUniquelyReferenced_nonNull_native(*a1) & 1) == 0)
    v2 = sub_1000F5FB4(v2);
  v3 = *(_QWORD *)(v2 + 16);
  v5[0] = v2 + 32;
  v5[1] = v3;
  result = sub_1000F4B98(v5);
  *a1 = v2;
  return result;
}

Swift::Int sub_1000F4B98(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t *v3;
  Swift::Int v4;
  Swift::Int result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  Swift::Int v10;
  uint64_t v11;
  char *v12;
  unint64_t v13;
  Swift::Int v14;
  Swift::Int v15;
  uint64_t v16;
  unsigned int v17;
  char v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  int v25;
  uint64_t v27;
  char v28;
  unsigned int v29;
  char v30;
  char v31;
  uint64_t v32;
  char v33;
  unsigned int v34;
  unsigned int v35;
  uint64_t v37;
  uint64_t v38;
  Swift::Int v39;
  Swift::Int v40;
  uint64_t v41;
  int v42;
  __int16 v43;
  char v44;
  char v45;
  Swift::Int v46;
  uint64_t v47;
  uint64_t v48;
  unsigned int v49;
  char v50;
  int v51;
  char v52;
  BOOL v53;
  _BOOL4 v54;
  unsigned int v55;
  int v56;
  unsigned int v57;
  Swift::Int v59;
  char v60;
  unint64_t v61;
  unint64_t v62;
  char *v63;
  char *v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  char v69;
  char *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  BOOL v76;
  unint64_t v77;
  char *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  char *v83;
  uint64_t v84;
  uint64_t v85;
  BOOL v86;
  uint64_t v87;
  char v88;
  char *v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  BOOL v93;
  uint64_t v94;
  uint64_t v95;
  char *v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  char *v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  unint64_t v104;
  char *v105;
  char *v106;
  uint64_t v107;
  char *v108;
  uint64_t v109;
  unint64_t v110;
  char *v111;
  char *v112;
  uint64_t v113;
  unint64_t v114;
  char *v115;
  uint64_t v116;
  uint64_t v117;
  char *v118;
  char *v119;
  char *v120;
  unint64_t v121;
  char *v122;
  uint64_t *v123;
  uint64_t v124;
  _QWORD *v125;
  Swift::Int v126;
  Swift::Int v127;
  Swift::Int v128;
  Swift::Int v129;
  _BOOL4 v130;
  uint64_t v131;
  char *__dst;
  BOOL v133;
  Swift::Int v134;
  uint64_t v135;
  uint64_t v136;

  v2 = v1;
  v3 = a1;
  v4 = a1[1];
  result = _minimumMergeRunLength(_:)(v4);
  if (result >= v4)
  {
    if ((v4 & 0x8000000000000000) == 0)
    {
      if (v4)
        return sub_1000F5620(0, v4, 1, v3);
      return result;
    }
    goto LABEL_229;
  }
  if (v4 >= 0)
    v6 = v4;
  else
    v6 = v4 + 1;
  if (v4 < -1)
  {
LABEL_239:
    result = _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Can't construct Array with count < 0", 36, 2, "Swift/Array.swift", 17, 2, 936, 0);
    __break(1u);
    return result;
  }
  v126 = result;
  if (v4 < 2)
  {
    v9 = _swiftEmptyArrayStorage;
    __dst = (char *)&_swiftEmptyArrayStorage[4];
    if (v4 != 1)
    {
      v13 = _swiftEmptyArrayStorage[2];
      v12 = (char *)_swiftEmptyArrayStorage;
      if (v13 < 2)
      {
LABEL_205:
        v112 = v12;
        goto LABEL_206;
      }
LABEL_193:
      v113 = *v3;
      while (1)
      {
        v114 = v13 - 2;
        if (v13 < 2)
          goto LABEL_224;
        if (!v113)
          goto LABEL_236;
        v105 = v12;
        v115 = v12 + 32;
        v116 = *(_QWORD *)&v12[16 * v114 + 32];
        v117 = *(_QWORD *)&v12[16 * v13 + 24];
        sub_1000F580C((char *)(v113 + 8 * v116), (char *)(v113 + 8 * *(_QWORD *)&v115[16 * v13 - 16]), v113 + 8 * v117, __dst);
        if (v2)
          goto LABEL_191;
        if (v117 < v116)
          goto LABEL_225;
        if ((swift_isUniquelyReferenced_nonNull_native(v105) & 1) == 0)
          v105 = sub_1000F5F78((uint64_t)v105);
        if (v114 >= *((_QWORD *)v105 + 2))
          goto LABEL_226;
        v118 = v105;
        v119 = v105 + 32;
        v120 = &v105[16 * v114 + 32];
        *(_QWORD *)v120 = v116;
        *((_QWORD *)v120 + 1) = v117;
        v121 = *((_QWORD *)v105 + 2);
        if (v13 > v121)
          goto LABEL_227;
        v12 = v118;
        memmove(&v119[16 * v13 - 16], &v119[16 * v13], 16 * (v121 - v13));
        *((_QWORD *)v12 + 2) = v121 - 1;
        v13 = v121 - 1;
        if (v121 <= 2)
          goto LABEL_205;
      }
    }
    v125 = _swiftEmptyArrayStorage;
    v135 = v1;
  }
  else
  {
    v135 = v1;
    v7 = v6 >> 1;
    v8 = static Array._allocateBufferUninitialized(minimumCapacity:)(v6 >> 1, &type metadata for RadioResources.PreferredChannel);
    *(_QWORD *)(v8 + 16) = v7;
    v125 = (_QWORD *)v8;
    __dst = (char *)(v8 + 32);
  }
  v10 = 0;
  v11 = *v3;
  v123 = v3;
  v124 = *v3 - 1;
  v12 = (char *)_swiftEmptyArrayStorage;
  v136 = *v3;
  v129 = v4;
  while (1)
  {
    v14 = v10;
    v15 = v10 + 1;
    if (v10 + 1 >= v4)
      goto LABEL_99;
    v16 = v11 + 8 * v15;
    v17 = *(_DWORD *)v16;
    v18 = *(_BYTE *)(v16 + 4);
    v19 = *(unsigned __int8 *)(v16 + 5);
    v20 = *(unsigned __int8 *)(v16 + 7);
    v21 = v11 + 8 * v10;
    v22 = *(unsigned __int8 *)(v21 + 5);
    v23 = (0x801004u >> (8 * v18));
    v24 = (0x801004u >> (8 * *(_BYTE *)(v21 + 4)));
    if (v23 == v24)
    {
      v25 = *(unsigned __int8 *)(v16 + 7);
      if (((v20 | *(unsigned __int8 *)(v21 + 7)) & 1) != 0)
        goto LABEL_29;
    }
    if (v23 < v24 || v17 < *(_DWORD *)v21)
      goto LABEL_23;
    v27 = sub_100012C44(&qword_100406E48);
    if (v22 == 2)
    {
      v25 = 0;
      v11 = v136;
    }
    else
    {
      v11 = v136;
      if (v19 == 2)
        goto LABEL_23;
      if (v22 != 3)
      {
        if (v19 == 3)
          goto LABEL_23;
        if ((v22 - 2) < 5 || (v22 & 1) != 0)
        {
          if ((v19 - 2) >= 5 && (v19 & 1) == 0)
            goto LABEL_23;
          if ((v22 - 2) < 5u || (v22 & 1) == 0)
          {
            if ((v19 - 2) >= 5u && (v19 & 1) != 0)
              goto LABEL_23;
            if (v22 != 4)
            {
              if (v19 == 4)
              {
LABEL_23:
                v25 = 1;
                goto LABEL_29;
              }
              if (v22 == 5)
              {
                v15 = v14 + 2;
                if (v14 + 2 >= v129)
                  goto LABEL_99;
                v25 = 0;
LABEL_30:
                v28 = v18;
                while (2)
                {
                  while (1)
                  {
                    v29 = v17;
                    v30 = v19;
                    v31 = v20;
                    v32 = v11 + 8 * v15;
                    v17 = *(_DWORD *)v32;
                    v33 = 8 * v28;
                    v28 = *(_BYTE *)(v32 + 4);
                    v19 = *(unsigned __int8 *)(v32 + 5);
                    LOBYTE(v20) = *(_BYTE *)(v32 + 7);
                    v34 = (0x801004u >> (8 * v28));
                    v35 = (0x801004u >> v33);
                    if (v34 != v35)
                      break;
                    if ((v20 & 1) != 0)
                      goto LABEL_46;
                    if ((v31 & 1) == 0)
                      break;
                    if ((v25 & 1) != 0)
                      goto LABEL_80;
                    if (++v15 >= v129)
                      goto LABEL_99;
                  }
                  if (v34 >= v35 && v17 >= v29)
                  {
                    if (v30 != 2)
                    {
                      if (v19 == 2)
                        goto LABEL_46;
                      if (v30 != 3)
                      {
                        if (v19 == 3)
                          goto LABEL_46;
                        if ((v30 - 2) < 5u || (v30 & 1) != 0)
                        {
                          if ((v19 - 2) >= 5 && (v19 & 1) == 0)
                            goto LABEL_46;
                          if ((v30 - 2) < 5u || (v30 & 1) == 0)
                          {
                            if ((v19 - 2) >= 5u && (v19 & 1) != 0)
                              goto LABEL_46;
                            if (v30 != 4)
                            {
                              if (v19 == 4)
                                goto LABEL_46;
                              if (v30 != 5)
                              {
                                if (v19 == 5)
                                  goto LABEL_46;
                                if (v30 != 6)
                                {
                                  if (v19 != 6)
                                    goto LABEL_237;
                                  goto LABEL_46;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    if ((v25 & 1) != 0)
                      goto LABEL_80;
                  }
                  else
                  {
LABEL_46:
                    if ((v25 & 1) == 0)
                      goto LABEL_99;
                  }
                  if (++v15 >= v129)
                    goto LABEL_79;
                  continue;
                }
              }
              if (v19 != 5)
              {
                if (v22 == 6)
                {
                  v15 = v14 + 2;
                  if (v14 + 2 >= v129)
                  {
                    v11 = v136;
                    goto LABEL_99;
                  }
                  v25 = 0;
LABEL_95:
                  v11 = v136;
                  goto LABEL_30;
                }
                if (v19 != 6)
                  goto LABEL_238;
              }
              v15 = v14 + 2;
              if (v14 + 2 >= v129)
              {
                v11 = v136;
                if (v14 < v15)
                  goto LABEL_82;
                goto LABEL_99;
              }
              v25 = 1;
              goto LABEL_95;
            }
          }
        }
      }
      v25 = 0;
    }
LABEL_29:
    v15 = v14 + 2;
    if (v14 + 2 < v129)
      goto LABEL_30;
LABEL_79:
    if (v25)
    {
LABEL_80:
      if (v15 < v14)
        goto LABEL_232;
      if (v14 < v15)
      {
LABEL_82:
        v37 = 8 * v15;
        v38 = 8 * v14;
        v39 = v15;
        v40 = v14;
        do
        {
          if (v40 != --v39)
          {
            if (!v11)
              goto LABEL_235;
            v41 = v11 + v37;
            v42 = *(_DWORD *)(v11 + v38);
            v43 = *(_WORD *)(v11 + v38 + 4);
            v44 = *(_BYTE *)(v11 + v38 + 6);
            v45 = *(_BYTE *)(v11 + v38 + 7);
            *(_QWORD *)(v11 + v38) = *(_QWORD *)(v11 + v37 - 8);
            *(_DWORD *)(v41 - 8) = v42;
            *(_WORD *)(v41 - 4) = v43;
            *(_BYTE *)(v41 - 2) = v44;
            *(_BYTE *)(v41 - 1) = v45;
          }
          ++v40;
          v37 -= 8;
          v38 += 8;
        }
        while (v40 < v39);
      }
    }
LABEL_99:
    v46 = v129;
    if (v15 >= v129)
      goto LABEL_143;
    if (__OFSUB__(v15, v14))
      goto LABEL_228;
    if (v15 - v14 >= v126)
      goto LABEL_143;
    if (__OFADD__(v14, v126))
      goto LABEL_230;
    if (v14 + v126 < v129)
      v46 = v14 + v126;
    if (v46 < v14)
      goto LABEL_231;
    if (v15 == v46)
      goto LABEL_143;
    v122 = v12;
    v47 = v124 + 8 * v15;
    v127 = v46;
    v128 = v14;
    while (2)
    {
      v48 = v11 + 8 * v15;
      v49 = *(_DWORD *)v48;
      v50 = *(_BYTE *)(v48 + 4);
      v51 = *(unsigned __int8 *)(v48 + 5);
      v52 = *(_BYTE *)(v48 + 7);
      v53 = (v51 - 2) > 4;
      v54 = (v51 - 2) < 5;
      if ((v51 & 1) != 0)
        v53 = 0;
      v133 = v53;
      if ((v51 & 1) == 0)
        v54 = 1;
      v130 = v54;
      v55 = (0x801004u >> (8 * v50));
      v131 = v47;
      while (1)
      {
        v56 = *(unsigned __int8 *)(v47 - 2);
        v57 = (0x801004u >> (8 * *(_BYTE *)(v47 - 3)));
        if (v55 == v57)
        {
          if ((v52 & 1) != 0)
            goto LABEL_139;
          if ((*(_BYTE *)v47 & 1) != 0)
            goto LABEL_109;
        }
        if (v55 < v57 || v49 < *(_DWORD *)(v47 - 7))
          goto LABEL_139;
        v59 = v15;
        v27 = sub_100012C44(&qword_100406E48);
        if (v56 == 2)
          break;
        v11 = v136;
        v15 = v59;
        if (v51 != 2)
        {
          if (v56 == 3)
            goto LABEL_109;
          if (v51 != 3)
          {
            if ((v56 - 2) >= 5 && (v56 & 1) == 0)
              goto LABEL_109;
            if (!v133)
            {
              if ((v56 - 2) >= 5u && (v56 & 1) != 0)
                goto LABEL_109;
              if (v130)
              {
                if (v56 == 4)
                  goto LABEL_109;
                if (v51 != 4)
                {
                  if (v56 == 5)
                    goto LABEL_109;
                  if (v51 != 5)
                  {
                    if (v56 == 6)
                      goto LABEL_109;
                    if (v51 != 6)
                      goto LABEL_238;
                  }
                }
              }
            }
          }
        }
LABEL_139:
        if (!v11)
          goto LABEL_233;
        v60 = *(_BYTE *)(v47 + 7);
        *(_QWORD *)(v47 + 1) = *(_QWORD *)(v47 - 7);
        *(_DWORD *)(v47 - 7) = v49;
        *(_BYTE *)(v47 - 3) = v50;
        *(_BYTE *)(v47 - 2) = v51;
        *(_BYTE *)(v47 - 1) = v60;
        *(_BYTE *)v47 = v52;
        v47 -= 8;
        if (v15 == ++v14)
          goto LABEL_109;
      }
      v11 = v136;
      v15 = v59;
LABEL_109:
      ++v15;
      v47 = v131 + 8;
      v14 = v128;
      if (v15 != v127)
        continue;
      break;
    }
    v15 = v127;
    v12 = v122;
LABEL_143:
    if (v15 < v14)
    {
LABEL_223:
      __break(1u);
LABEL_224:
      __break(1u);
LABEL_225:
      __break(1u);
LABEL_226:
      __break(1u);
LABEL_227:
      __break(1u);
LABEL_228:
      __break(1u);
LABEL_229:
      __break(1u);
LABEL_230:
      __break(1u);
LABEL_231:
      __break(1u);
LABEL_232:
      __break(1u);
LABEL_233:
      __break(1u);
LABEL_234:
      __break(1u);
LABEL_235:
      __break(1u);
LABEL_236:
      __break(1u);
LABEL_237:
      v27 = sub_100012C44(&qword_100406E48);
LABEL_238:
      _diagnoseUnexpectedEnumCase<A>(type:)(v27, v27);
      __break(1u);
      goto LABEL_239;
    }
    v134 = v15;
    if ((swift_isUniquelyReferenced_nonNull_native(v12) & 1) == 0)
      v12 = sub_1000F5C8C(0, *((_QWORD *)v12 + 2) + 1, 1, v12);
    v62 = *((_QWORD *)v12 + 2);
    v61 = *((_QWORD *)v12 + 3);
    v13 = v62 + 1;
    v11 = v136;
    v10 = v134;
    if (v62 >= v61 >> 1)
    {
      v111 = sub_1000F5C8C((char *)(v61 > 1), v62 + 1, 1, v12);
      v10 = v134;
      v11 = v136;
      v12 = v111;
    }
    *((_QWORD *)v12 + 2) = v13;
    v63 = v12 + 32;
    v64 = &v12[16 * v62 + 32];
    *(_QWORD *)v64 = v14;
    *((_QWORD *)v64 + 1) = v10;
    if (v62)
      break;
    v13 = 1;
LABEL_15:
    v4 = v129;
    if (v10 >= v129)
    {
      v2 = v135;
      v9 = v125;
      v3 = v123;
      if (v13 < 2)
        goto LABEL_205;
      goto LABEL_193;
    }
  }
  while (1)
  {
    v65 = v13 - 1;
    if (v13 >= 4)
    {
      v70 = &v63[16 * v13];
      v71 = *((_QWORD *)v70 - 8);
      v72 = *((_QWORD *)v70 - 7);
      v76 = __OFSUB__(v72, v71);
      v73 = v72 - v71;
      if (v76)
        goto LABEL_212;
      v75 = *((_QWORD *)v70 - 6);
      v74 = *((_QWORD *)v70 - 5);
      v76 = __OFSUB__(v74, v75);
      v68 = v74 - v75;
      v69 = v76;
      if (v76)
        goto LABEL_213;
      v77 = v13 - 2;
      v78 = &v63[16 * v13 - 32];
      v80 = *(_QWORD *)v78;
      v79 = *((_QWORD *)v78 + 1);
      v76 = __OFSUB__(v79, v80);
      v81 = v79 - v80;
      if (v76)
        goto LABEL_215;
      v76 = __OFADD__(v68, v81);
      v82 = v68 + v81;
      if (v76)
        goto LABEL_218;
      if (v82 >= v73)
      {
        v100 = &v63[16 * v65];
        v102 = *(_QWORD *)v100;
        v101 = *((_QWORD *)v100 + 1);
        v76 = __OFSUB__(v101, v102);
        v103 = v101 - v102;
        if (v76)
          goto LABEL_222;
        v93 = v68 < v103;
        goto LABEL_180;
      }
    }
    else
    {
      if (v13 != 3)
      {
        v94 = *((_QWORD *)v12 + 4);
        v95 = *((_QWORD *)v12 + 5);
        v76 = __OFSUB__(v95, v94);
        v87 = v95 - v94;
        v88 = v76;
        goto LABEL_174;
      }
      v67 = *((_QWORD *)v12 + 4);
      v66 = *((_QWORD *)v12 + 5);
      v76 = __OFSUB__(v66, v67);
      v68 = v66 - v67;
      v69 = v76;
    }
    if ((v69 & 1) != 0)
      goto LABEL_214;
    v77 = v13 - 2;
    v83 = &v63[16 * v13 - 32];
    v85 = *(_QWORD *)v83;
    v84 = *((_QWORD *)v83 + 1);
    v86 = __OFSUB__(v84, v85);
    v87 = v84 - v85;
    v88 = v86;
    if (v86)
      goto LABEL_217;
    v89 = &v63[16 * v65];
    v91 = *(_QWORD *)v89;
    v90 = *((_QWORD *)v89 + 1);
    v76 = __OFSUB__(v90, v91);
    v92 = v90 - v91;
    if (v76)
      goto LABEL_220;
    if (__OFADD__(v87, v92))
      goto LABEL_221;
    if (v87 + v92 >= v68)
    {
      v93 = v68 < v92;
LABEL_180:
      if (v93)
        v65 = v77;
      goto LABEL_182;
    }
LABEL_174:
    if ((v88 & 1) != 0)
      goto LABEL_216;
    v96 = &v63[16 * v65];
    v98 = *(_QWORD *)v96;
    v97 = *((_QWORD *)v96 + 1);
    v76 = __OFSUB__(v97, v98);
    v99 = v97 - v98;
    if (v76)
      goto LABEL_219;
    if (v99 < v87)
      goto LABEL_15;
LABEL_182:
    v104 = v65 - 1;
    if (v65 - 1 >= v13)
    {
      __break(1u);
LABEL_209:
      __break(1u);
LABEL_210:
      __break(1u);
LABEL_211:
      __break(1u);
LABEL_212:
      __break(1u);
LABEL_213:
      __break(1u);
LABEL_214:
      __break(1u);
LABEL_215:
      __break(1u);
LABEL_216:
      __break(1u);
LABEL_217:
      __break(1u);
LABEL_218:
      __break(1u);
LABEL_219:
      __break(1u);
LABEL_220:
      __break(1u);
LABEL_221:
      __break(1u);
LABEL_222:
      __break(1u);
      goto LABEL_223;
    }
    if (!v11)
      goto LABEL_234;
    v105 = v12;
    v106 = &v63[16 * v104];
    v107 = *(_QWORD *)v106;
    v108 = &v63[16 * v65];
    v109 = *((_QWORD *)v108 + 1);
    sub_1000F580C((char *)(v11 + 8 * *(_QWORD *)v106), (char *)(v11 + 8 * *(_QWORD *)v108), v11 + 8 * v109, __dst);
    if (v135)
      break;
    if (v109 < v107)
      goto LABEL_209;
    if (v65 > *((_QWORD *)v105 + 2))
      goto LABEL_210;
    *(_QWORD *)v106 = v107;
    *(_QWORD *)&v63[16 * v104 + 8] = v109;
    v110 = *((_QWORD *)v105 + 2);
    if (v65 >= v110)
      goto LABEL_211;
    v12 = v105;
    v13 = v110 - 1;
    memmove(&v63[16 * v65], v108 + 16, 16 * (v110 - 1 - v65));
    *((_QWORD *)v105 + 2) = v110 - 1;
    v11 = v136;
    v10 = v134;
    if (v110 <= 2)
      goto LABEL_15;
  }
  v9 = v125;
LABEL_191:
  v112 = v105;
LABEL_206:
  swift_bridgeObjectRelease(v112);
  v9[2] = 0;
  return swift_bridgeObjectRelease(v9);
}

uint64_t sub_1000F5620(uint64_t result, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  unsigned int v8;
  char v9;
  int v10;
  char v11;
  BOOL v12;
  _BOOL4 v13;
  unsigned int v14;
  uint64_t v15;
  int v16;
  unsigned int v17;
  char v19;
  uint64_t v21;
  _BOOL4 v22;
  uint64_t v23;
  BOOL v24;

  v21 = result;
  if (a3 == a2)
    return result;
  v4 = a3;
  v5 = *a4;
  v6 = *a4 + 8 * a3 - 1;
LABEL_5:
  v7 = (unsigned int *)(v5 + 8 * v4);
  v8 = *v7;
  v9 = *((_BYTE *)v7 + 4);
  v10 = *((unsigned __int8 *)v7 + 5);
  v11 = *((_BYTE *)v7 + 7);
  v12 = (v10 - 2) > 4;
  v13 = (v10 - 2) < 5;
  if ((v10 & 1) != 0)
    v12 = 0;
  v24 = v12;
  if ((v10 & 1) == 0)
    v13 = 1;
  v22 = v13;
  v14 = (0x801004u >> (8 * v9));
  v15 = v21;
  v23 = v6;
  while (1)
  {
    v16 = *(unsigned __int8 *)(v6 - 2);
    v17 = (0x801004u >> (8 * *(_BYTE *)(v6 - 3)));
    if (v14 == v17)
    {
      if ((v11 & 1) != 0)
        goto LABEL_34;
      if ((*(_BYTE *)v6 & 1) != 0)
        goto LABEL_4;
    }
    if (v14 >= v17 && v8 >= *(_DWORD *)(v6 - 7))
    {
      result = sub_100012C44(&qword_100406E48);
      if (v16 == 2)
        goto LABEL_4;
      if (v10 != 2)
      {
        if (v16 == 3)
          goto LABEL_4;
        if (v10 != 3)
        {
          if ((v16 - 2) >= 5 && (v16 & 1) == 0)
          {
LABEL_4:
            ++v4;
            v6 = v23 + 8;
            if (v4 == a2)
              return result;
            goto LABEL_5;
          }
          if (!v24)
          {
            if ((v16 - 2) >= 5u && (v16 & 1) != 0)
              goto LABEL_4;
            if (v22)
            {
              if (v16 == 4)
                goto LABEL_4;
              if (v10 != 4)
              {
                if (v16 == 5)
                  goto LABEL_4;
                if (v10 != 5)
                {
                  if (v16 == 6)
                    goto LABEL_4;
                  if (v10 != 6)
                    goto LABEL_38;
                }
              }
            }
          }
        }
      }
    }
LABEL_34:
    if (!v5)
      break;
    v19 = *(_BYTE *)(v6 + 7);
    *(_QWORD *)(v6 + 1) = *(_QWORD *)(v6 - 7);
    *(_DWORD *)(v6 - 7) = v8;
    *(_BYTE *)(v6 - 3) = v9;
    *(_BYTE *)(v6 - 2) = v10;
    *(_BYTE *)(v6 - 1) = v19;
    *(_BYTE *)v6 = v11;
    v6 -= 8;
    if (v4 == ++v15)
      goto LABEL_4;
  }
  __break(1u);
LABEL_38:
  result = _diagnoseUnexpectedEnumCase<A>(type:)(result, result);
  __break(1u);
  return result;
}

uint64_t sub_1000F580C(char *__src, char *a2, unint64_t a3, char *__dst)
{
  char *v4;
  char *v6;
  char *v7;
  int64_t v8;
  int64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  int v15;
  int v16;
  unsigned int v17;
  unsigned int v18;
  char *v20;
  uint64_t v21;
  char *v22;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  char *v32;
  int v33;
  int v34;
  char *v35;
  int v36;
  int v37;
  uint64_t result;
  char *v39;
  char *v40;
  const void *v41;
  char *v42;

  v4 = __dst;
  v6 = a2;
  v7 = __src;
  v8 = a2 - __src;
  v9 = a2 - __src + 7;
  if (a2 - __src >= 0)
    v9 = a2 - __src;
  v10 = v9 >> 3;
  v11 = a3 - (_QWORD)a2;
  v12 = a3 - (_QWORD)a2 + 7;
  if ((uint64_t)(a3 - (_QWORD)a2) >= 0)
    v12 = a3 - (_QWORD)a2;
  v13 = v12 >> 3;
  v42 = __src;
  v41 = __dst;
  if (v10 < v12 >> 3)
  {
    if (v8 >= -7)
    {
      if (__dst != __src || &__src[8 * v10] <= __dst)
        memmove(__dst, __src, 8 * v10);
      v14 = &v4[8 * v10];
      v40 = v14;
      if ((unint64_t)v6 >= a3 || v8 < 8)
        goto LABEL_94;
      while (1)
      {
        v15 = v6[5];
        v16 = v4[5];
        v17 = (0x801004u >> (8 * v6[4]));
        v18 = (0x801004u >> (8 * v4[4]));
        if (v17 == v18)
        {
          if ((v6[7] & 1) != 0)
            goto LABEL_19;
          if ((v4[7] & 1) != 0)
            goto LABEL_24;
        }
        if (v17 >= v18 && *(_DWORD *)v6 >= *(_DWORD *)v4)
        {
          v21 = sub_100012C44(&qword_100406E48);
          if (v16 == 2)
            goto LABEL_24;
          if (v15 != 2)
          {
            if (v16 == 3)
              goto LABEL_24;
            if (v15 != 3)
            {
              if ((v16 - 2) >= 5 && (v16 & 1) == 0)
              {
LABEL_24:
                if (v7 != v4)
                  *(_QWORD *)v7 = *(_QWORD *)v4;
                v4 += 8;
                v41 = v4;
                v20 = v6;
                goto LABEL_27;
              }
              if ((v15 - 2) < 5 || (v15 & 1) != 0)
              {
                if ((v16 - 2) >= 5u && (v16 & 1) != 0)
                  goto LABEL_24;
                if ((v15 - 2) < 5u || (v15 & 1) == 0)
                {
                  if (v16 == 4)
                    goto LABEL_24;
                  if (v15 != 4)
                  {
                    if (v16 == 5)
                      goto LABEL_24;
                    if (v15 != 5)
                    {
                      if (v16 == 6)
                        goto LABEL_24;
                      if (v15 != 6)
                        goto LABEL_92;
                    }
                  }
                }
              }
            }
          }
        }
LABEL_19:
        v20 = v6 + 8;
        if (v7 < v6 || v7 >= v20 || v7 != v6)
          *(_QWORD *)v7 = *(_QWORD *)v6;
LABEL_27:
        v7 += 8;
        if (v4 < v14)
        {
          v6 = v20;
          if ((unint64_t)v20 < a3)
            continue;
        }
        goto LABEL_93;
      }
    }
LABEL_95:
    result = _fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.moveInitialize with negative count", 55, 2, "Swift/UnsafePointer.swift", 25, 2, 1046, 0);
    __break(1u);
    return result;
  }
  if (v11 < -7)
    goto LABEL_95;
  if (__dst != a2 || &a2[8 * v13] <= __dst)
    memmove(__dst, a2, 8 * v13);
  v22 = &v4[8 * v13];
  v40 = v22;
  v42 = v6;
  if (v7 >= v6 || v11 < 8)
    goto LABEL_94;
  v23 = (char *)(a3 - 8);
  v24 = v6;
  v39 = v7;
  while (1)
  {
    v25 = v23 + 8;
    v26 = v22 - 8;
    v28 = *((_DWORD *)v24 - 2);
    v24 -= 8;
    v27 = v28;
    v29 = (0x801004u >> (8 * *(v22 - 4)));
    v30 = (0x801004u >> (8 * v24[4]));
    if (v29 != v30)
      goto LABEL_90;
    if ((*(v22 - 1) & 1) != 0)
      goto LABEL_62;
    if ((v24[7] & 1) == 0)
    {
LABEL_90:
      if (v29 < v30 || *((_DWORD *)v22 - 2) < v27)
        goto LABEL_62;
      v32 = v4;
      v33 = *(v22 - 3);
      v34 = v24[5];
      v35 = v22;
      v21 = sub_100012C44(&qword_100406E48);
      v22 = v35;
      v36 = v34;
      v7 = v39;
      v37 = v33;
      v4 = v32;
      if (v36 != 2)
      {
        if (v37 == 2)
          goto LABEL_62;
        if (v36 != 3)
        {
          if (v37 == 3)
            goto LABEL_62;
          if ((v36 - 2) < 5 || (v36 & 1) != 0)
          {
            if ((v37 - 2) >= 5 && (v37 & 1) == 0)
              goto LABEL_62;
            if ((v36 - 2) < 5u || (v36 & 1) == 0)
            {
              if ((v37 - 2) >= 5u && (v37 & 1) != 0)
                goto LABEL_62;
              if (v36 != 4)
              {
                if (v37 == 4)
                  goto LABEL_62;
                if (v36 != 5)
                {
                  if (v37 == 5)
                    goto LABEL_62;
                  if (v36 != 6)
                    break;
                }
              }
            }
          }
        }
      }
    }
    v40 = v26;
    if (v25 < v22 || v23 >= v22 || v25 != v22)
      *(_QWORD *)v23 = *(_QWORD *)v26;
    v24 = v6;
    v22 = v26;
    if (v6 <= v7)
      goto LABEL_94;
LABEL_73:
    v23 -= 8;
    v6 = v24;
    if (v22 <= v4)
      goto LABEL_94;
  }
  if (v37 == 6)
  {
LABEL_62:
    if (v25 != v6 || v23 >= v6)
      *(_QWORD *)v23 = *(_QWORD *)v24;
    v42 = v24;
    if (v24 <= v7)
      goto LABEL_94;
    goto LABEL_73;
  }
LABEL_92:
  _diagnoseUnexpectedEnumCase<A>(type:)(v21, v21);
  __break(1u);
LABEL_93:
  v42 = v7;
LABEL_94:
  sub_1000F5ED0((void **)&v42, &v41, &v40);
  return 1;
}

char *sub_1000F5C8C(char *result, int64_t a2, char a3, char *a4)
{
  char v5;
  unint64_t v6;
  int64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  int64_t v12;
  uint64_t v13;
  char *v14;
  char *v15;

  v5 = (char)result;
  if ((a3 & 1) != 0)
  {
    v6 = *((_QWORD *)a4 + 3);
    v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        return result;
      }
      v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
        v7 = a2;
    }
  }
  else
  {
    v7 = a2;
  }
  v8 = *((_QWORD *)a4 + 2);
  if (v7 <= v8)
    v9 = *((_QWORD *)a4 + 2);
  else
    v9 = v7;
  if (v9)
  {
    v10 = sub_100012C44(&qword_100407C68);
    v11 = (char *)swift_allocObject(v10, 16 * v9 + 32, 7);
    v12 = j__malloc_size(v11);
    v13 = v12 - 32;
    if (v12 < 32)
      v13 = v12 - 17;
    *((_QWORD *)v11 + 2) = v8;
    *((_QWORD *)v11 + 3) = 2 * (v13 >> 4);
  }
  else
  {
    v11 = (char *)_swiftEmptyArrayStorage;
  }
  v14 = v11 + 32;
  v15 = a4 + 32;
  if ((v5 & 1) != 0)
  {
    if (v11 != a4 || v14 >= &v15[16 * v8])
      memmove(v14, v15, 16 * v8);
    *((_QWORD *)a4 + 2) = 0;
  }
  else
  {
    memcpy(v14, v15, 16 * v8);
  }
  swift_bridgeObjectRelease(a4);
  return v11;
}

char *sub_1000F5D84(void **a1, const void **a2, _QWORD *a3)
{
  char *v3;
  uint64_t v4;
  char *result;
  size_t v6;

  v3 = (char *)*a2;
  v4 = *a3 - (_QWORD)v3;
  if (v4 <= -8)
  {
    result = (char *)_fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.moveInitialize with negative count", 55, 2, "Swift/UnsafePointer.swift", 25, 2, 1046, 0);
    __break(1u);
  }
  else
  {
    result = (char *)*a1;
    v6 = (v4 + (v4 < 0 ? 7uLL : 0)) & 0xFFFFFFFFFFFFFFF8;
    if (result != v3 || result >= &v3[v6])
      return (char *)memmove(result, v3, v6);
  }
  return result;
}

char *sub_1000F5E28(void **a1, const void **a2, _QWORD *a3)
{
  char *v3;
  uint64_t v4;
  uint64_t v5;
  char *result;
  uint64_t v7;
  char v9;

  v3 = (char *)*a2;
  v4 = *a3 - (_QWORD)v3;
  v5 = v4 + 31;
  if (v4 >= 0)
    v5 = *a3 - (_QWORD)v3;
  if (v4 <= -32)
  {
    v9 = 2;
    result = (char *)_fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.moveInitialize with negative count", 55, 2, "Swift/UnsafePointer.swift", 25, v9, 1046, 0);
    __break(1u);
  }
  else
  {
    result = (char *)*a1;
    v7 = v5 >> 5;
    if (result != v3 || result >= &v3[32 * v7])
      return (char *)memmove(result, v3, 32 * v7);
  }
  return result;
}

char *sub_1000F5ED0(void **a1, const void **a2, _QWORD *a3)
{
  char *v3;
  uint64_t v4;
  uint64_t v5;
  char *result;
  uint64_t v7;
  char v9;

  v3 = (char *)*a2;
  v4 = *a3 - (_QWORD)v3;
  v5 = v4 + 7;
  if (v4 >= 0)
    v5 = *a3 - (_QWORD)v3;
  if (v4 <= -8)
  {
    v9 = 2;
    result = (char *)_fatalErrorMessage(_:_:file:line:flags:)("Fatal error", 11, 2, "UnsafeMutablePointer.moveInitialize with negative count", 55, 2, "Swift/UnsafePointer.swift", 25, v9, 1046, 0);
    __break(1u);
  }
  else
  {
    result = (char *)*a1;
    v7 = v5 >> 3;
    if (result != v3 || result >= &v3[8 * v7])
      return (char *)memmove(result, v3, 8 * v7);
  }
  return result;
}

char *sub_1000F5F78(uint64_t a1)
{
  return sub_1000F5C8C(0, *(_QWORD *)(a1 + 16), 0, (char *)a1);
}

uint64_t sub_1000F5F8C(uint64_t a1)
{
  return sub_100076514(0, *(_QWORD *)(a1 + 16), 0, (char *)a1);
}

uint64_t sub_1000F5FA0(uint64_t a1)
{
  return sub_100076674(0, *(_QWORD *)(a1 + 16), 0, (char *)a1);
}

uint64_t sub_1000F5FB4(uint64_t a1)
{
  return sub_100076C1C(0, *(_QWORD *)(a1 + 16), 0, (char *)a1);
}

uint64_t _s7CoreP2P14RadioResourcesO15SymbolicChannelO21__derived_enum_equalsySbAE_AEtFZ_0(unint64_t a1, char a2, unint64_t a3, char a4)
{
  uint64_t result;

  if (!a2)
  {
    if (!a4)
      return a1 == a3;
    return 0;
  }
  if (a2 != 1)
    return ((uint64_t (*)(void))((char *)&loc_1000F6084 + 4 * byte_100345E83[a1]))();
  if (a4 != 1
    || (_DWORD)a1 != (_DWORD)a3
    || ((0x801004u >> ((a1 >> 29) & 0xF8)) & 0xFFC) != ((0x801004u >> ((a3 >> 29) & 0xF8)) & 0xFFC))
  {
    return 0;
  }
  switch(BYTE5(a1))
  {
    case 2:
      if (BYTE5(a3) != 2)
        return 0;
      result = 1;
      break;
    case 3:
      if (BYTE5(a3) != 3)
        return 0;
      result = 1;
      break;
    case 4:
      if (BYTE5(a3) != 4)
        return 0;
      result = 1;
      break;
    case 5:
      if (BYTE5(a3) != 5)
        return 0;
      result = 1;
      break;
    case 6:
      if (BYTE5(a3) != 6)
        return 0;
      result = 1;
      break;
    default:
      if (BYTE5(a3) - 2 < 5 || ((a1 & 0x10000000000) == 0) == ((a3 >> 40) & 1))
        return 0;
      result = 1;
      break;
  }
  return result;
}

uint64_t sub_1000F6164(unint64_t a1, unint64_t a2)
{
  uint64_t v2;

  if ((_DWORD)a1 != (_DWORD)a2
    || ((0x801004u >> ((a1 >> 29) & 0xF8)) & 0xFFC) != ((0x801004u >> ((a2 >> 29) & 0xF8)) & 0xFFC))
  {
    return 0;
  }
  switch(BYTE5(a1))
  {
    case 2:
      v2 = 0;
      if (BYTE5(a2) == 2)
        goto LABEL_17;
      break;
    case 3:
      v2 = 0;
      if (BYTE5(a2) == 3)
        goto LABEL_17;
      break;
    case 4:
      v2 = 0;
      if (BYTE5(a2) == 4)
        goto LABEL_17;
      break;
    case 5:
      v2 = 0;
      if (BYTE5(a2) == 5)
        goto LABEL_17;
      break;
    case 6:
      v2 = 0;
      if (BYTE5(a2) == 6)
        goto LABEL_17;
      break;
    default:
      if (BYTE5(a2) - 2 < 5)
        return 0;
      v2 = 0;
      if (((a1 & 0x10000000000) == 0) != ((a2 >> 40) & 1))
      {
LABEL_17:
        if (BYTE6(a2) == BYTE6(a1))
          v2 = ((a1 & 0x100000000000000) == 0) ^ HIBYTE(a2) & 1u;
      }
      break;
  }
  return v2;
}

unint64_t _s7CoreP2P14RadioResourcesO8PriorityO8rawValueAESgSi_tcfC_0(unint64_t result)
{
  if (result >= 0xD)
    return 13;
  return result;
}

uint64_t sub_1000F6284(uint64_t a1)
{
  uint64_t v1;

  return sub_1000F4428(a1, *(_QWORD *)(v1 + 32), *(_QWORD *)(v1 + 40), *(_QWORD *)(v1 + 48), *(_QWORD *)(v1 + 56), *(unsigned __int8 *)(v1 + 64), *(unsigned __int8 *)(v1 + 65), *(_QWORD *)(v1 + 16), *(_QWORD *)(v1 + 24));
}

uint64_t sub_1000F62B8(uint64_t a1)
{
  uint64_t v1;

  return sub_1000F4588(a1, *(_QWORD *)(v1 + 32), *(_QWORD *)(v1 + 40), *(_QWORD *)(v1 + 48), *(unsigned __int8 *)(v1 + 56), *(_QWORD *)(v1 + 16), *(_QWORD *)(v1 + 24));
}

unint64_t sub_1000F62D0()
{
  unint64_t result;

  result = qword_100407C40;
  if (!qword_100407C40)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for RadioResources.Priority, &type metadata for RadioResources.Priority);
    atomic_store(result, (unint64_t *)&qword_100407C40);
  }
  return result;
}

unint64_t sub_1000F6318()
{
  unint64_t result;
  uint64_t v1;

  result = qword_100407C48;
  if (!qword_100407C48)
  {
    v1 = sub_100013C64(&qword_100407C50);
    result = swift_getWitnessTable((const char *)&protocol conformance descriptor for [A], v1);
    atomic_store(result, (unint64_t *)&qword_100407C48);
  }
  return result;
}

unint64_t sub_1000F6368()
{
  unint64_t result;

  result = qword_100407C58;
  if (!qword_100407C58)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for RadioResources.SymbolicChannel, &type metadata for RadioResources.SymbolicChannel);
    atomic_store(result, (unint64_t *)&qword_100407C58);
  }
  return result;
}

unint64_t sub_1000F63B0()
{
  unint64_t result;

  result = qword_100407C60;
  if (!qword_100407C60)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for RadioResources.PreferredChannel, &type metadata for RadioResources.PreferredChannel);
    atomic_store(result, (unint64_t *)&qword_100407C60);
  }
  return result;
}

ValueMetadata *type metadata accessor for RadioResources()
{
  return &type metadata for RadioResources;
}

uint64_t getEnumTagSinglePayload for IEEE80211InformationElement.IEEE80211CipherSuite(unsigned __int8 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0xF4)
    goto LABEL_17;
  if (a2 + 12 >= 0xFFFF00)
    v2 = 4;
  else
    v2 = 2;
  if ((a2 + 12) >> 8 < 0xFF)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 8)) - 12;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1))
        goto LABEL_17;
      return (*a1 | (v4 << 8)) - 12;
    }
    v4 = a1[1];
    if (a1[1])
      return (*a1 | (v4 << 8)) - 12;
  }
LABEL_17:
  v6 = *a1;
  v7 = v6 >= 0xD;
  v8 = v6 - 13;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for RadioResources.Priority(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 12 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 12) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xF4)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xF3)
    return ((uint64_t (*)(void))((char *)&loc_1000F64E0 + 4 * byte_100345E96[v4]))();
  *a1 = a2 + 12;
  return ((uint64_t (*)(void))((char *)sub_1000F6514 + 4 * byte_100345E91[v4]))();
}

uint64_t sub_1000F6514(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000F651C(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x1000F6524);
  return result;
}

uint64_t sub_1000F6530(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x1000F6538);
  *(_BYTE *)result = a2 + 12;
  return result;
}

uint64_t sub_1000F653C(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000F6544(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for RadioResources.Priority()
{
  return &type metadata for RadioResources.Priority;
}

uint64_t getEnumTagSinglePayload for RadioResources.SymbolicChannel(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  int v4;

  if (!a2)
    return 0;
  if (a2 >= 0xFE && *(_BYTE *)(a1 + 9))
    return (*(_DWORD *)a1 + 254);
  v3 = *(unsigned __int8 *)(a1 + 8);
  if (v3 <= 2)
    v4 = -1;
  else
    v4 = v3 ^ 0xFF;
  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for RadioResources.SymbolicChannel(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFD)
  {
    *(_BYTE *)(result + 8) = 0;
    *(_QWORD *)result = a2 - 254;
    if (a3 >= 0xFE)
      *(_BYTE *)(result + 9) = 1;
  }
  else
  {
    if (a3 >= 0xFE)
      *(_BYTE *)(result + 9) = 0;
    if (a2)
      *(_BYTE *)(result + 8) = -(char)a2;
  }
  return result;
}

uint64_t sub_1000F65EC(uint64_t a1)
{
  if (*(unsigned __int8 *)(a1 + 8) <= 1u)
    return *(unsigned __int8 *)(a1 + 8);
  else
    return (*(_DWORD *)a1 + 2);
}

uint64_t sub_1000F6604(uint64_t result, unsigned int a2)
{
  if (a2 >= 2)
  {
    *(_QWORD *)result = a2 - 2;
    LOBYTE(a2) = 2;
  }
  *(_BYTE *)(result + 8) = a2;
  return result;
}

ValueMetadata *type metadata accessor for RadioResources.SymbolicChannel()
{
  return &type metadata for RadioResources.SymbolicChannel;
}

uint64_t destroy for NANAttribute.DeviceLink(uint64_t a1)
{
  return swift_bridgeObjectRelease(*(_QWORD *)(a1 + 24));
}

uint64_t initializeWithCopy for RadioResources.SymbolicChannel.Resolver(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_WORD *)(a1 + 4) = *(_WORD *)(a2 + 4);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_WORD *)(a1 + 12) = *(_WORD *)(a2 + 12);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_WORD *)(a1 + 20) = *(_WORD *)(a2 + 20);
  v3 = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 24) = v3;
  swift_bridgeObjectRetain(v3);
  return a1;
}

uint64_t assignWithCopy for RadioResources.SymbolicChannel.Resolver(uint64_t a1, uint64_t a2)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;

  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_BYTE *)(a1 + 4) = *(_BYTE *)(a2 + 4);
  *(_BYTE *)(a1 + 5) = *(_BYTE *)(a2 + 5);
  v3 = *(_DWORD *)(a2 + 8);
  *(_WORD *)(a1 + 12) = *(_WORD *)(a2 + 12);
  *(_DWORD *)(a1 + 8) = v3;
  v4 = *(_DWORD *)(a2 + 16);
  *(_WORD *)(a1 + 20) = *(_WORD *)(a2 + 20);
  *(_DWORD *)(a1 + 16) = v4;
  v5 = *(_QWORD *)(a2 + 24);
  v6 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = v5;
  swift_bridgeObjectRetain(v5);
  swift_bridgeObjectRelease(v6);
  return a1;
}

uint64_t assignWithTake for RadioResources.SymbolicChannel.Resolver(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_WORD *)(a1 + 4) = *(_WORD *)(a2 + 4);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_WORD *)(a1 + 12) = *(_WORD *)(a2 + 12);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_WORD *)(a1 + 20) = *(_WORD *)(a2 + 20);
  v3 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  swift_bridgeObjectRelease(v3);
  return a1;
}

uint64_t getEnumTagSinglePayload for NANDataResponseReceivedEvent(uint64_t a1, int a2)
{
  unint64_t v2;

  if (!a2)
    return 0;
  if (a2 < 0 && *(_BYTE *)(a1 + 32))
    return *(_DWORD *)a1 + 0x80000000;
  v2 = *(_QWORD *)(a1 + 24);
  if (v2 >= 0xFFFFFFFF)
    LODWORD(v2) = -1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for NANDataResponseReceivedEvent(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_QWORD *)(result + 16) = 0;
    *(_QWORD *)(result + 24) = 0;
    *(_QWORD *)result = a2 ^ 0x80000000;
    *(_QWORD *)(result + 8) = 0;
    if (a3 < 0)
      *(_BYTE *)(result + 32) = 1;
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
        return result;
LABEL_8:
      *(_QWORD *)(result + 24) = (a2 - 1);
      return result;
    }
    *(_BYTE *)(result + 32) = 0;
    if (a2)
      goto LABEL_8;
  }
  return result;
}

ValueMetadata *type metadata accessor for RadioResources.SymbolicChannel.Resolver()
{
  return &type metadata for RadioResources.SymbolicChannel.Resolver;
}

uint64_t getEnumTagSinglePayload for RadioResources.PreferredChannel(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  BOOL v4;
  int v5;

  if (!a2)
    return 0;
  if (a2 >= 0xFF && *(_BYTE *)(a1 + 8))
    return (*(_DWORD *)a1 + 255);
  v3 = *(unsigned __int8 *)(a1 + 7);
  v4 = v3 >= 2;
  v5 = (v3 + 2147483646) & 0x7FFFFFFF;
  if (!v4)
    v5 = -1;
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for RadioResources.PreferredChannel(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFE)
  {
    *(_QWORD *)result = a2 - 255;
    if (a3 >= 0xFF)
      *(_BYTE *)(result + 8) = 1;
  }
  else
  {
    if (a3 >= 0xFF)
      *(_BYTE *)(result + 8) = 0;
    if (a2)
      *(_BYTE *)(result + 7) = a2 + 1;
  }
  return result;
}

ValueMetadata *type metadata accessor for RadioResources.PreferredChannel()
{
  return &type metadata for RadioResources.PreferredChannel;
}

void NANMasterRank.hash(into:)(int a1, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;

  v2 = a2 >> 8;
  v3 = a2 >> 16;
  v4 = a2 >> 24;
  v5 = HIDWORD(a2);
  v6 = a2 >> 40;
  v7 = HIWORD(a2);
  v8 = HIBYTE(a2);
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
}

unint64_t sub_1000F6930()
{
  _BYTE *v0;
  uint64_t v1;

  v1 = 0x61466D6F646E6172;
  if (*v0 != 1)
    v1 = 0x73736572646461;
  if (*v0)
    return v1;
  else
    return 0xD000000000000010;
}

uint64_t sub_1000F6998@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;

  result = sub_1000F81B0(a1, a2);
  *a3 = result;
  return result;
}

uint64_t sub_1000F69BC(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000F7848();
  return CodingKey.description.getter(a1, v2);
}

uint64_t sub_1000F69E4(uint64_t a1)
{
  unint64_t v2;

  v2 = sub_1000F7848();
  return CodingKey.debugDescription.getter(a1, v2);
}

uint64_t NANMasterRank.encode(to:)(_QWORD *a1, unint64_t a2)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v14;
  _BYTE v15[6];
  char v16;
  char v17;

  v5 = sub_100012C44(&qword_100407C70);
  v6 = *(_QWORD *)(v5 - 8);
  __chkstk_darwin();
  v8 = &v15[-((v7 + 15) & 0xFFFFFFFFFFFFFFF0) - 8];
  v9 = a1[3];
  v10 = a1[4];
  sub_10003259C(a1, v9);
  v11 = sub_1000F7848();
  dispatch thunk of Encoder.container<A>(keyedBy:)(&type metadata for NANMasterRank.CodingKeys, &type metadata for NANMasterRank.CodingKeys, v11, v9, v10);
  v17 = 0;
  KeyedEncodingContainer.encode(_:forKey:)(a2, &v17, v5);
  if (!v2)
  {
    v16 = 1;
    KeyedEncodingContainer.encode(_:forKey:)(a2 >> 8, &v16, v5);
    v15[0] = BYTE2(a2);
    v15[1] = BYTE3(a2);
    v15[2] = BYTE4(a2);
    v15[3] = BYTE5(a2);
    v15[4] = BYTE6(a2);
    v15[5] = HIBYTE(a2);
    HIBYTE(v14) = 2;
    v12 = sub_100039C34();
    KeyedEncodingContainer.encode<A>(_:forKey:)(v15, (char *)&v14 + 7, v5, &type metadata for WiFiAddress, v12);
  }
  return (*(uint64_t (**)(_BYTE *, uint64_t))(v6 + 8))(v8, v5);
}

Swift::Int NANMasterRank.hashValue.getter(unint64_t a1)
{
  Swift::UInt8 v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD v10[9];

  v1 = a1;
  v2 = a1 >> 8;
  v3 = a1 >> 16;
  v4 = a1 >> 24;
  v5 = HIDWORD(a1);
  v6 = a1 >> 40;
  v7 = HIWORD(a1);
  v8 = HIBYTE(a1);
  Hasher.init(_seed:)(v10);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  return Hasher._finalize()();
}

unint64_t NANMasterRank.init(from:)(_QWORD *a1)
{
  return sub_1000F7A0C(a1);
}

unint64_t sub_1000F6C70@<X0>(_QWORD *a1@<X0>, unint64_t *a2@<X8>)
{
  uint64_t v2;
  unint64_t result;

  result = sub_1000F7A0C(a1);
  if (!v2)
    *a2 = result;
  return result;
}

uint64_t sub_1000F6C98(_QWORD *a1)
{
  unint64_t *v1;

  return NANMasterRank.encode(to:)(a1, *v1);
}

Swift::Int sub_1000F6CB0()
{
  Swift::UInt8 *v0;
  Swift::UInt8 v1;
  Swift::UInt8 v2;
  Swift::UInt8 v3;
  Swift::UInt8 v4;
  Swift::UInt8 v5;
  Swift::UInt8 v6;
  Swift::UInt8 v7;
  Swift::UInt8 v8;
  _QWORD v10[9];

  v1 = *v0;
  v2 = v0[1];
  v3 = v0[2];
  v4 = v0[3];
  v5 = v0[4];
  v6 = v0[5];
  v7 = v0[6];
  v8 = v0[7];
  Hasher.init(_seed:)(v10);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  return Hasher._finalize()();
}

void sub_1000F6D84()
{
  Swift::UInt8 *v0;
  Swift::UInt8 v1;
  Swift::UInt8 v2;
  Swift::UInt8 v3;
  Swift::UInt8 v4;
  Swift::UInt8 v5;
  Swift::UInt8 v6;
  Swift::UInt8 v7;

  v1 = v0[1];
  v2 = v0[2];
  v3 = v0[3];
  v4 = v0[4];
  v5 = v0[5];
  v6 = v0[6];
  v7 = v0[7];
  Hasher._combine(_:)(*v0);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
}

Swift::Int sub_1000F6E20()
{
  Swift::UInt8 *v0;
  Swift::UInt8 v1;
  Swift::UInt8 v2;
  Swift::UInt8 v3;
  Swift::UInt8 v4;
  Swift::UInt8 v5;
  Swift::UInt8 v6;
  Swift::UInt8 v7;
  Swift::UInt8 v8;
  _QWORD v10[9];

  v1 = *v0;
  v2 = v0[1];
  v3 = v0[2];
  v4 = v0[3];
  v5 = v0[4];
  v6 = v0[5];
  v7 = v0[6];
  v8 = v0[7];
  Hasher.init(_seed:)(v10);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  return Hasher._finalize()();
}

BOOL sub_1000F6EF0(uint64_t *a1, uint64_t *a2)
{
  return _s7CoreP2P13NANMasterRankV23__derived_struct_equalsySbAC_ACtFZ_0(*a1, *a2);
}

uint64_t NANRole.description.getter(char a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;

  v1 = 0x4D20726F68636E41;
  v2 = 0x72657473614DLL;
  v3 = 0x7473614D206E6F4ELL;
  if ((a1 & 1) == 0)
    v3 = 0xD000000000000013;
  if (a1 != 4)
    v2 = v3;
  if (a1 != 3)
    v1 = v2;
  if (a1 == 2)
    return 0x6974616D6F747541;
  else
    return v1;
}

void NANRole.hash(into:)(uint64_t a1, char a2)
{
  Swift::UInt v2;
  Swift::UInt8 v3;

  switch(a2)
  {
    case 2:
      v2 = 0;
      goto LABEL_7;
    case 3:
      v2 = 1;
      goto LABEL_7;
    case 4:
      v2 = 2;
LABEL_7:
      Hasher._combine(_:)(v2);
      return;
  }
  v3 = a2 & 1;
  Hasher._combine(_:)(3uLL);
  Hasher._combine(_:)(v3);
}

BOOL static NANRole.__derived_enum_equals(_:_:)(char a1, unsigned __int8 a2)
{
  switch(a1)
  {
    case 2:
      return a2 == 2;
    case 3:
      return a2 == 3;
    case 4:
      return a2 == 4;
  }
  if (a2 - 2 < 3)
    return 0;
  return (((a1 & 1) == 0) ^ a2) & 1;
}

Swift::Int NANRole.hashValue.getter(char a1)
{
  Swift::UInt v2;
  _QWORD v4[9];

  Hasher.init(_seed:)(v4);
  switch(a1)
  {
    case 2:
      v2 = 0;
      break;
    case 3:
      v2 = 1;
      break;
    case 4:
      v2 = 2;
      break;
    default:
      Hasher._combine(_:)(3uLL);
      Hasher._combine(_:)(a1 & 1);
      return Hasher._finalize()();
  }
  Hasher._combine(_:)(v2);
  return Hasher._finalize()();
}

Swift::Int sub_1000F7128()
{
  unsigned __int8 *v0;
  int v1;
  Swift::UInt v2;
  _QWORD v4[9];

  v1 = *v0;
  Hasher.init(_seed:)(v4);
  switch(v1)
  {
    case 2:
      v2 = 0;
      break;
    case 3:
      v2 = 1;
      break;
    case 4:
      v2 = 2;
      break;
    default:
      Hasher._combine(_:)(3uLL);
      Hasher._combine(_:)(v1 & 1);
      return Hasher._finalize()();
  }
  Hasher._combine(_:)(v2);
  return Hasher._finalize()();
}

void sub_1000F71BC()
{
  unsigned __int8 *v0;
  int v1;
  Swift::UInt v2;
  Swift::UInt8 v3;

  v1 = *v0;
  switch(v1)
  {
    case 2:
      v2 = 0;
      goto LABEL_7;
    case 3:
      v2 = 1;
      goto LABEL_7;
    case 4:
      v2 = 2;
LABEL_7:
      Hasher._combine(_:)(v2);
      return;
  }
  v3 = v1 & 1;
  Hasher._combine(_:)(3uLL);
  Hasher._combine(_:)(v3);
}

Swift::Int sub_1000F7228()
{
  unsigned __int8 *v0;
  int v1;
  Swift::UInt v2;
  _QWORD v4[9];

  v1 = *v0;
  Hasher.init(_seed:)(v4);
  switch(v1)
  {
    case 2:
      v2 = 0;
      break;
    case 3:
      v2 = 1;
      break;
    case 4:
      v2 = 2;
      break;
    default:
      Hasher._combine(_:)(3uLL);
      Hasher._combine(_:)(v1 & 1);
      return Hasher._finalize()();
  }
  Hasher._combine(_:)(v2);
  return Hasher._finalize()();
}

uint64_t sub_1000F72B8()
{
  unsigned __int8 *v0;
  int v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;

  v1 = *v0;
  v2 = 0x4D20726F68636E41;
  v3 = 0x72657473614DLL;
  v4 = 0x7473614D206E6F4ELL;
  if ((v1 & 1) == 0)
    v4 = 0xD000000000000013;
  if (v1 != 4)
    v3 = v4;
  if (v1 != 3)
    v2 = v3;
  if (v1 == 2)
    return 0x6974616D6F747541;
  else
    return v2;
}

BOOL sub_1000F7370(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2;
  int v3;

  v2 = *a1;
  v3 = *a2;
  switch(v2)
  {
    case 2:
      return v3 == 2;
    case 3:
      return v3 == 3;
    case 4:
      return v3 == 4;
  }
  if ((v3 - 2) < 3)
    return 0;
  return (((v2 & 1) == 0) ^ v3) & 1;
}

void *NANElectionParameters.Flags.syncToSelf.unsafeMutableAddressor()
{
  return &static NANElectionParameters.Flags.syncToSelf;
}

void *NANElectionParameters.Flags.useTSFTiming.unsafeMutableAddressor()
{
  return &static NANElectionParameters.Flags.useTSFTiming;
}

void *NANElectionParameters.Flags.anchorMasterRecordUpdate.unsafeMutableAddressor()
{
  return &static NANElectionParameters.Flags.anchorMasterRecordUpdate;
}

uint64_t NANElectionParameters.flags.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 1);
}

uint64_t NANElectionParameters.cluster.getter()
{
  uint64_t v0;

  return *(_QWORD *)(v0 + 8);
}

uint64_t NANElectionParameters.cluster.setter(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  *(_QWORD *)(v2 + 8) = result;
  *(_BYTE *)(v2 + 16) = a2;
  *(_DWORD *)(v2 + 20) = HIDWORD(a2);
  return result;
}

uint64_t NANElectionParameters.localTSF.getter()
{
  uint64_t v0;

  return *(_QWORD *)(v0 + 24);
}

uint64_t NANBeacon.Metadata.tsf.setter(uint64_t result)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 24) = result;
  return result;
}

uint64_t NANElectionParameters.rxBeaconTSF.getter()
{
  uint64_t v0;

  return *(_QWORD *)(v0 + 32);
}

uint64_t NANElectionParameters.rxBeaconTSF.setter(uint64_t result)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 32) = result;
  return result;
}

void NANElectionParameters.hash(into:)()
{
  uint64_t v0;
  Swift::UInt8 v1;
  Swift::UInt8 v2;
  Swift::UInt8 v3;
  Swift::UInt8 v4;
  Swift::UInt8 v5;
  Swift::UInt8 v6;
  Swift::UInt8 v7;
  Swift::UInt8 v8;
  Swift::UInt8 v9;
  Swift::UInt8 v10;
  Swift::UInt8 v11;
  Swift::UInt8 v12;
  Swift::UInt8 v13;
  Swift::UInt8 v14;
  Swift::UInt32 v15;
  char v16;
  char v17;

  sub_1000F7BAC((_BYTE *)v0, &v16);
  sub_1000F7BAC(&v16, &v17);
  switch(v17)
  {
    case 4:
      Hasher._combine(_:)(2uLL);
      break;
    case 3:
      Hasher._combine(_:)(1uLL);
      break;
    case 2:
      Hasher._combine(_:)(0);
      break;
    default:
      v1 = v17 & 1;
      Hasher._combine(_:)(3uLL);
      Hasher._combine(_:)(v1);
      break;
  }
  Hasher._combine(_:)(*(_BYTE *)(v0 + 1));
  v2 = *(_BYTE *)(v0 + 3);
  v3 = *(_BYTE *)(v0 + 4);
  v4 = *(_BYTE *)(v0 + 5);
  v5 = *(_BYTE *)(v0 + 6);
  v6 = *(_BYTE *)(v0 + 7);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 2));
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  v15 = *(_DWORD *)(v0 + 20);
  v7 = *(_BYTE *)(v0 + 9);
  v8 = *(_BYTE *)(v0 + 10);
  v9 = *(_BYTE *)(v0 + 11);
  v10 = *(_BYTE *)(v0 + 12);
  v11 = *(_BYTE *)(v0 + 13);
  v12 = *(_BYTE *)(v0 + 14);
  v13 = *(_BYTE *)(v0 + 15);
  v14 = *(_BYTE *)(v0 + 16);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 8));
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(v11);
  Hasher._combine(_:)(v12);
  Hasher._combine(_:)(v13);
  Hasher._combine(_:)(v14);
  Hasher._combine(_:)(v15);
  Hasher._combine(_:)(*(_QWORD *)(v0 + 24));
  Hasher._combine(_:)(*(_QWORD *)(v0 + 32));
}

Swift::Int NANElectionParameters.hashValue.getter()
{
  _QWORD v1[9];

  Hasher.init(_seed:)(v1);
  NANElectionParameters.hash(into:)();
  return Hasher._finalize()();
}

Swift::Int sub_1000F7658()
{
  __int128 *v0;
  __int128 v1;
  _QWORD v3[9];
  __int128 v4;
  __int128 v5;
  uint64_t v6;

  v1 = v0[1];
  v4 = *v0;
  v5 = v1;
  v6 = *((_QWORD *)v0 + 4);
  Hasher.init(_seed:)(v3);
  NANElectionParameters.hash(into:)();
  return Hasher._finalize()();
}

void sub_1000F76A8()
{
  NANElectionParameters.hash(into:)();
}

Swift::Int sub_1000F76E0()
{
  __int128 *v0;
  __int128 v1;
  _QWORD v3[9];
  __int128 v4;
  __int128 v5;
  uint64_t v6;

  v1 = v0[1];
  v4 = *v0;
  v5 = v1;
  v6 = *((_QWORD *)v0 + 4);
  Hasher.init(_seed:)(v3);
  NANElectionParameters.hash(into:)();
  return Hasher._finalize()();
}

BOOL sub_1000F772C(uint64_t a1, uint64_t a2)
{
  __int128 v2;
  __int128 v3;
  _OWORD v5[2];
  uint64_t v6;
  _OWORD v7[2];
  uint64_t v8;

  v2 = *(_OWORD *)(a1 + 16);
  v5[0] = *(_OWORD *)a1;
  v5[1] = v2;
  v6 = *(_QWORD *)(a1 + 32);
  v3 = *(_OWORD *)(a2 + 16);
  v7[0] = *(_OWORD *)a2;
  v7[1] = v3;
  v8 = *(_QWORD *)(a2 + 32);
  return _s7CoreP2P21NANElectionParametersV23__derived_struct_equalsySbAC_ACtFZ_0((uint64_t)v5, (uint64_t)v7);
}

BOOL _s7CoreP2P13NANMasterRankV23__derived_struct_equalsySbAC_ACtFZ_0(uint64_t a1, uint64_t a2)
{
  int v4;
  __int16 v5;
  int v6;
  __int16 v7;

  if ((unsigned __int16)a1 != (unsigned __int16)a2)
    return 0;
  LOBYTE(v6) = BYTE2(a1);
  BYTE1(v6) = BYTE3(a1);
  BYTE2(v6) = BYTE4(a1);
  HIBYTE(v6) = BYTE5(a1);
  LOBYTE(v7) = BYTE6(a1);
  HIBYTE(v7) = HIBYTE(a1);
  LOBYTE(v4) = BYTE2(a2);
  BYTE1(v4) = BYTE3(a2);
  BYTE2(v4) = BYTE4(a2);
  HIBYTE(v4) = BYTE5(a2);
  LOBYTE(v5) = BYTE6(a2);
  HIBYTE(v5) = HIBYTE(a2);
  return v6 == v4 && v7 == v5;
}

unint64_t sub_1000F7848()
{
  unint64_t result;

  result = qword_100407C78;
  if (!qword_100407C78)
  {
    result = swift_getWitnessTable(byte_100346700, &type metadata for NANMasterRank.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407C78);
  }
  return result;
}

BOOL _s7CoreP2P21NANElectionParametersV23__derived_struct_equalsySbAC_ACtFZ_0(uint64_t a1, uint64_t a2)
{
  int v4;
  _BOOL8 result;
  BOOL v6;
  char v7;
  char v8;
  unsigned __int8 v9;
  unsigned __int8 v10;

  sub_1000F7BAC((_BYTE *)a1, &v8);
  sub_1000F7BAC((_BYTE *)a2, &v7);
  sub_1000F7BAC(&v8, &v9);
  v4 = v9;
  switch(v9)
  {
    case 4u:
      sub_1000F7BAC(&v7, &v10);
      if (v10 != 4)
        return 0;
      goto LABEL_12;
    case 3u:
      sub_1000F7BAC(&v7, &v10);
      if (v10 != 3)
        return 0;
      goto LABEL_12;
    case 2u:
      sub_1000F7BAC(&v7, &v10);
      if (v10 != 2)
        return 0;
LABEL_12:
      if (*(unsigned __int8 *)(a1 + 1) == *(unsigned __int8 *)(a2 + 1))
      {
        v6 = *(_DWORD *)(a1 + 2) == *(_DWORD *)(a2 + 2)
          && *(unsigned __int16 *)(a1 + 6) == *(unsigned __int16 *)(a2 + 6);
        if (v6
          && sub_1001D1394(*(_QWORD *)(a1 + 8), *(unsigned __int8 *)(a1 + 16) | ((unint64_t)*(unsigned int *)(a1 + 20) << 32), *(_QWORD *)(a2 + 8), *(unsigned __int8 *)(a2 + 16) | ((unint64_t)*(unsigned int *)(a2 + 20) << 32))&& *(_QWORD *)(a1 + 24) == *(_QWORD *)(a2 + 24))
        {
          return *(_QWORD *)(a1 + 32) == *(_QWORD *)(a2 + 32);
        }
      }
      return 0;
  }
  sub_1000F7BAC(&v7, &v10);
  result = 0;
  if (v10 - 2 >= 3 && ((v4 ^ v10) & 1) == 0)
    goto LABEL_12;
  return result;
}

unint64_t sub_1000F7A0C(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unsigned __int8 v10;
  unsigned __int8 v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;

  v3 = sub_100012C44(&qword_100407CD0);
  v4 = *(_QWORD *)(v3 - 8);
  __chkstk_darwin();
  v6 = (char *)&v17 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = a1[3];
  v8 = a1[4];
  sub_10003259C(a1, v7);
  v9 = sub_1000F7848();
  dispatch thunk of Decoder.container<A>(keyedBy:)(&type metadata for NANMasterRank.CodingKeys, &type metadata for NANMasterRank.CodingKeys, v9, v7, v8);
  if (v1)
    return sub_100014430(a1);
  HIBYTE(v18) = 0;
  v10 = KeyedDecodingContainer.decode(_:forKey:)((char *)&v18 + 7, v3);
  BYTE6(v18) = 1;
  v11 = KeyedDecodingContainer.decode(_:forKey:)((char *)&v18 + 6, v3);
  HIBYTE(v17) = 2;
  v12 = sub_10003A65C();
  KeyedDecodingContainer.decode<A>(_:forKey:)(&v18, &type metadata for WiFiAddress, (char *)&v17 + 7, v3, &type metadata for WiFiAddress, v12);
  (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
  v13 = v18;
  v14 = BYTE1(v18);
  v15 = *(unsigned int *)((char *)&v18 + 2);
  sub_100014430(a1);
  return (v13 << 16) | (v14 << 24) | (v15 << 32) | ((unint64_t)v11 << 8) | v10;
}

_BYTE *sub_1000F7BAC(_BYTE *a1, _BYTE *a2)
{
  *a2 = *a1;
  return a2;
}

unint64_t sub_1000F7BC0()
{
  unint64_t result;

  result = qword_100407C80;
  if (!qword_100407C80)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANMasterRank, &type metadata for NANMasterRank);
    atomic_store(result, (unint64_t *)&qword_100407C80);
  }
  return result;
}

unint64_t sub_1000F7C08()
{
  unint64_t result;

  result = qword_100407C88;
  if (!qword_100407C88)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANRole, &type metadata for NANRole);
    atomic_store(result, (unint64_t *)&qword_100407C88);
  }
  return result;
}

unint64_t sub_1000F7C50()
{
  unint64_t result;

  result = qword_100407C90;
  if (!qword_100407C90)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANElectionParameters.Flags, &type metadata for NANElectionParameters.Flags);
    atomic_store(result, (unint64_t *)&qword_100407C90);
  }
  return result;
}

unint64_t sub_1000F7C98()
{
  unint64_t result;

  result = qword_100407C98;
  if (!qword_100407C98)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANElectionParameters.Flags, &type metadata for NANElectionParameters.Flags);
    atomic_store(result, (unint64_t *)&qword_100407C98);
  }
  return result;
}

unint64_t sub_1000F7CE0()
{
  unint64_t result;

  result = qword_100407CA0;
  if (!qword_100407CA0)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANElectionParameters.Flags, &type metadata for NANElectionParameters.Flags);
    atomic_store(result, (unint64_t *)&qword_100407CA0);
  }
  return result;
}

unint64_t sub_1000F7D28()
{
  unint64_t result;

  result = qword_100407CA8;
  if (!qword_100407CA8)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANElectionParameters.Flags, &type metadata for NANElectionParameters.Flags);
    atomic_store(result, (unint64_t *)&qword_100407CA8);
  }
  return result;
}

unint64_t sub_1000F7D70()
{
  unint64_t result;

  result = qword_100407CB0;
  if (!qword_100407CB0)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANElectionParameters, &type metadata for NANElectionParameters);
    atomic_store(result, (unint64_t *)&qword_100407CB0);
  }
  return result;
}

ValueMetadata *type metadata accessor for NANMasterRank()
{
  return &type metadata for NANMasterRank;
}

uint64_t getEnumTagSinglePayload for NANRole(unsigned __int8 *a1, unsigned int a2)
{
  unsigned int v2;
  unsigned int v3;
  uint64_t v4;
  uint64_t result;
  unsigned int v6;
  unsigned int v7;

  if (!a2)
    return 0;
  if (a2 < 0xFC)
  {
    v6 = *a1;
    if (v6 >= 2)
    {
      v7 = (v6 + 2147483646) & 0x7FFFFFFF;
      result = v7 - 2;
      if (v7 > 2)
        return result;
    }
    return 0;
  }
  v2 = a2 + 4;
  if (a2 + 4 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if (v2 >> 8 < 0xFF)
    v3 = 1;
  if (v2 >= 0x100)
    v4 = v3;
  else
    v4 = 0;
  return ((uint64_t (*)(void))((char *)&loc_1000F7E14 + 4 * asc_100346260[v4]))();
}

uint64_t storeEnumTagSinglePayload for NANRole(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3;
  int v4;
  uint64_t v5;

  v3 = a3 + 4;
  if (a3 + 4 >= 0xFFFF00)
    v4 = 4;
  else
    v4 = 2;
  if (v3 >> 8 < 0xFF)
    v4 = 1;
  if (v3 >= 0x100)
    LODWORD(v5) = v4;
  else
    LODWORD(v5) = 0;
  if (a3 >= 0xFC)
    v5 = v5;
  else
    v5 = 0;
  if (a2 <= 0xFB)
    return ((uint64_t (*)(void))((char *)&loc_1000F7EC0 + 4 * byte_10034626A[v5]))();
  *a1 = a2 + 4;
  return ((uint64_t (*)(void))((char *)sub_1000F7EF4 + 4 * byte_100346265[v5]))();
}

uint64_t sub_1000F7EF4(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000F7EFC(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x1000F7F04);
  return result;
}

uint64_t sub_1000F7F10(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x1000F7F18);
  *(_BYTE *)result = a2 + 4;
  return result;
}

uint64_t sub_1000F7F1C(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000F7F24(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for NANRole()
{
  return &type metadata for NANRole;
}

uint64_t getEnumTagSinglePayload for NANElectionParameters(unsigned __int8 *a1, unsigned int a2)
{
  unsigned int v3;
  int v4;

  if (!a2)
    return 0;
  if (a2 >= 0xFC && a1[40])
    return (*(_DWORD *)a1 + 252);
  v3 = *a1;
  if (v3 >= 2)
    v4 = ((v3 + 2147483646) & 0x7FFFFFFF) - 3;
  else
    v4 = -4;
  if (v4 < 0)
    v4 = -1;
  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for NANElectionParameters(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFB)
  {
    *(_OWORD *)(result + 8) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_QWORD *)result = a2 - 252;
    if (a3 >= 0xFC)
      *(_BYTE *)(result + 40) = 1;
  }
  else
  {
    if (a3 >= 0xFC)
      *(_BYTE *)(result + 40) = 0;
    if (a2)
      *(_BYTE *)result = a2 + 4;
  }
  return result;
}

ValueMetadata *type metadata accessor for NANElectionParameters()
{
  return &type metadata for NANElectionParameters;
}

ValueMetadata *type metadata accessor for NANElectionParameters.Flags()
{
  return &type metadata for NANElectionParameters.Flags;
}

uint64_t storeEnumTagSinglePayload for NANMasterRank.CodingKeys(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 2 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 2) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xFE)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xFD)
    return ((uint64_t (*)(void))((char *)&loc_1000F8058 + 4 * byte_100346274[v4]))();
  *a1 = a2 + 2;
  return ((uint64_t (*)(void))((char *)sub_1000F808C + 4 * byte_10034626F[v4]))();
}

uint64_t sub_1000F808C(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000F8094(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x1000F809CLL);
  return result;
}

uint64_t sub_1000F80A8(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x1000F80B0);
  *(_BYTE *)result = a2 + 2;
  return result;
}

uint64_t sub_1000F80B4(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000F80BC(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for NANMasterRank.CodingKeys()
{
  return &type metadata for NANMasterRank.CodingKeys;
}

unint64_t sub_1000F80DC()
{
  unint64_t result;

  result = qword_100407CB8;
  if (!qword_100407CB8)
  {
    result = swift_getWitnessTable(aY_8, &type metadata for NANMasterRank.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407CB8);
  }
  return result;
}

unint64_t sub_1000F8124()
{
  unint64_t result;

  result = qword_100407CC0;
  if (!qword_100407CC0)
  {
    result = swift_getWitnessTable(a1, &type metadata for NANMasterRank.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407CC0);
  }
  return result;
}

unint64_t sub_1000F816C()
{
  unint64_t result;

  result = qword_100407CC8;
  if (!qword_100407CC8)
  {
    result = swift_getWitnessTable(byte_100346670, &type metadata for NANMasterRank.CodingKeys);
    atomic_store(result, (unint64_t *)&qword_100407CC8);
  }
  return result;
}

uint64_t sub_1000F81B0(uint64_t a1, unint64_t a2)
{
  unint64_t v4;
  unint64_t v6;
  char v7;

  if (a1 == 0xD000000000000010)
  {
    v4 = 0x8000000100364D00;
    if (a2 == 0x8000000100364D00)
      goto LABEL_5;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0xD000000000000010, 0x8000000100364D00, a1, a2, 0) & 1) != 0)
  {
    v4 = a2;
LABEL_5:
    swift_bridgeObjectRelease(v4);
    return 0;
  }
  if (a1 == 0x61466D6F646E6172 && a2 == 0xEC000000726F7463)
  {
    v6 = 0xEC000000726F7463;
LABEL_11:
    swift_bridgeObjectRelease(v6);
    return 1;
  }
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(0x61466D6F646E6172, 0xEC000000726F7463, a1, a2, 0) & 1) != 0)
  {
    v6 = a2;
    goto LABEL_11;
  }
  if (a1 == 0x73736572646461 && a2 == 0xE700000000000000)
  {
    swift_bridgeObjectRelease(0xE700000000000000);
    return 2;
  }
  else
  {
    v7 = _stringCompareWithSmolCheck(_:_:expecting:)(0x73736572646461, 0xE700000000000000, a1, a2, 0);
    swift_bridgeObjectRelease(a2);
    if ((v7 & 1) != 0)
      return 2;
    else
      return 3;
  }
}

void *IPv4Address.any.unsafeMutableAddressor()
{
  return &static IPv4Address.any;
}

BOOL IPv4Address.isLinkLocal.getter(unsigned __int16 a1)
{
  return a1 == 65193;
}

BOOL IPv6Address.isLinkLocal.getter(__int16 a1)
{
  return (a1 & 0xC0FF) == 33022;
}

uint64_t IPv4Address.init(_:)(uint64_t a1, unint64_t a2)
{
  unsigned int v4;
  unsigned int v5;

  sub_100212DDC(a1, a2);
  v5 = v4;
  sub_10000E614(a1, a2);
  return v5;
}

uint64_t IPv6Address.init(_:scopedInterface:)(uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;

  sub_100212BD4(a1, a2);
  v5 = v4;
  sub_10000E614(a1, a2);
  return v5;
}

uint64_t IPv4Address.data.getter(int a1)
{
  _QWORD *v1;
  _BYTE *v2;
  _BYTE *v3;
  uint64_t v4;
  uint64_t v5;
  int v7;
  _QWORD v8[5];

  v7 = a1;
  v8[3] = &type metadata for UnsafeRawBufferPointer;
  v8[4] = &protocol witness table for UnsafeRawBufferPointer;
  v8[0] = &v7;
  v8[1] = v8;
  v1 = sub_10003259C(v8, (uint64_t)&type metadata for UnsafeRawBufferPointer);
  v2 = (_BYTE *)*v1;
  if (*v1 && (v3 = (_BYTE *)v1[1], v4 = v3 - v2, v3 != v2))
  {
    if (v4 <= 14)
    {
      v5 = sub_10000EC20(v2, v3);
    }
    else if ((unint64_t)v4 >= 0x7FFFFFFF)
    {
      v5 = sub_1001067F4((uint64_t)v2, (uint64_t)v3);
    }
    else
    {
      v5 = sub_10010686C((uint64_t)v2, (uint64_t)v3);
    }
  }
  else
  {
    v5 = 0;
  }
  sub_100014430(v8);
  return v5;
}

uint64_t IPv4Address.description.getter(int a1)
{
  char *v2;
  uint64_t v3;
  int v5;

  v2 = (char *)swift_slowAlloc(16, -1);
  v5 = a1;
  inet_ntop(2, &v5, v2, 0x10u);
  v3 = String.init(cString:)(v2);
  swift_slowDealloc(v2, -1, -1);
  return v3;
}

uint64_t IPv4Address.customMirror.getter(int a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v12;
  int v13;

  v2 = type metadata accessor for Mirror.AncestorRepresentation(0);
  v3 = *(_QWORD *)(v2 - 8);
  __chkstk_darwin();
  v5 = (char *)&v12 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_100012C44((uint64_t *)&unk_1004085C0);
  __chkstk_darwin();
  v7 = (char *)&v12 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = a1;
  v12 = _swiftEmptyArrayStorage;
  v8 = type metadata accessor for Mirror.DisplayStyle(0);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v8 - 8) + 56))(v7, 1, 1, v8);
  (*(void (**)(char *, _QWORD, uint64_t))(v3 + 104))(v5, enum case for Mirror.AncestorRepresentation.generated(_:), v2);
  v9 = sub_100012C44(&qword_100405B90);
  v10 = sub_100066494((unint64_t *)&qword_10040C3E0, &qword_100405B90);
  return Mirror.init<A, B>(_:children:displayStyle:ancestorRepresentation:)(&v13, &v12, v7, v5, &type metadata for IPv4Address, v9, v10);
}

void IPv4Address.hash(into:)(int a1, Swift::UInt32 a2)
{
  Hasher._combine(_:)(a2);
}

void *IPv4Address.broadcast.unsafeMutableAddressor()
{
  return &static IPv4Address.broadcast;
}

Swift::Int IPv4Address.hashValue.getter(Swift::UInt32 a1)
{
  _QWORD v3[9];

  Hasher.init(_seed:)(v3);
  Hasher._combine(_:)(a1);
  return Hasher._finalize()();
}

uint64_t sub_1000F87F4()
{
  int *v0;
  int v1;
  char *v2;
  uint64_t v3;
  int v5;

  v1 = *v0;
  v2 = (char *)swift_slowAlloc(16, -1);
  v5 = v1;
  inet_ntop(2, &v5, v2, 0x10u);
  v3 = String.init(cString:)(v2);
  swift_slowDealloc(v2, -1, -1);
  return v3;
}

uint64_t sub_1000F889C(uint64_t a1)
{
  int *v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v13;
  int v14;

  v3 = type metadata accessor for Mirror.AncestorRepresentation(0);
  v4 = *(_QWORD *)(v3 - 8);
  __chkstk_darwin();
  v6 = (char *)&v13 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_100012C44((uint64_t *)&unk_1004085C0);
  __chkstk_darwin();
  v8 = (char *)&v13 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = *v1;
  v13 = _swiftEmptyArrayStorage;
  v9 = type metadata accessor for Mirror.DisplayStyle(0);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v9 - 8) + 56))(v8, 1, 1, v9);
  (*(void (**)(char *, _QWORD, uint64_t))(v4 + 104))(v6, enum case for Mirror.AncestorRepresentation.generated(_:), v3);
  v10 = sub_100012C44(&qword_100405B90);
  v11 = sub_100066494((unint64_t *)&qword_10040C3E0, &qword_100405B90);
  return Mirror.init<A, B>(_:children:displayStyle:ancestorRepresentation:)(&v14, &v13, v8, v6, a1, v10, v11);
}

_QWORD *IPv4Address.init(from:)(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD v9[3];
  uint64_t v10;
  uint64_t v11;

  v3 = a1[3];
  v4 = a1[4];
  v5 = sub_10003259C(a1, v3);
  dispatch thunk of Decoder.singleValueContainer()(v9, v3, v4);
  if (!v1)
  {
    v6 = v10;
    v7 = v11;
    sub_10003259C(v9, v10);
    v5 = (_QWORD *)dispatch thunk of SingleValueDecodingContainer.decode(_:)(v6, v7);
    sub_100014430(v9);
  }
  sub_100014430(a1);
  return v5;
}

uint64_t IPv4Address.encode(to:)(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v8[3];
  uint64_t v9;
  uint64_t v10;

  v3 = a1[3];
  v4 = a1[4];
  sub_10003259C(a1, v3);
  dispatch thunk of Encoder.singleValueContainer()(v8, v3, v4);
  v5 = v9;
  v6 = v10;
  sub_100034C68((uint64_t)v8, v9);
  dispatch thunk of SingleValueEncodingContainer.encode(_:)(a2, v5, v6);
  return sub_100014430(v8);
}

uint64_t sub_1000F8B30@<X0>(_QWORD *a1@<X0>, _DWORD *a2@<X8>)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t result;
  _QWORD v11[3];
  uint64_t v12;
  uint64_t v13;

  v5 = a1[3];
  v6 = a1[4];
  sub_10003259C(a1, v5);
  dispatch thunk of Decoder.singleValueContainer()(v11, v5, v6);
  if (v2)
    return sub_100014430(a1);
  v7 = v12;
  v8 = v13;
  sub_10003259C(v11, v12);
  v9 = dispatch thunk of SingleValueDecodingContainer.decode(_:)(v7, v8);
  sub_100014430(v11);
  result = sub_100014430(a1);
  *a2 = v9;
  return result;
}

uint64_t sub_1000F8BEC(_QWORD *a1)
{
  unsigned int *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v8[3];
  uint64_t v9;
  uint64_t v10;

  v2 = *v1;
  v3 = a1[3];
  v4 = a1[4];
  sub_10003259C(a1, v3);
  dispatch thunk of Encoder.singleValueContainer()(v8, v3, v4);
  v5 = v9;
  v6 = v10;
  sub_100034C68((uint64_t)v8, v9);
  dispatch thunk of SingleValueEncodingContainer.encode(_:)(v2, v5, v6);
  return sub_100014430(v8);
}

uint64_t IPv6Address.address.setter(uint64_t result, uint64_t a2)
{
  _QWORD *v2;

  *v2 = result;
  v2[1] = a2;
  return result;
}

uint64_t IPv6Address.scopedInterfaceName.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  swift_bridgeObjectRetain(a4);
  return a3;
}

uint64_t IPv6Address.scopedInterfaceName.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t result;

  result = swift_bridgeObjectRelease(*(_QWORD *)(v2 + 24));
  *(_QWORD *)(v2 + 16) = a1;
  *(_QWORD *)(v2 + 24) = a2;
  return result;
}

uint64_t IPv6Address.data.getter(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  _BYTE *v3;
  _BYTE *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v8[5];
  _QWORD v9[2];
  uint64_t v10;

  v9[0] = a1;
  v9[1] = a2;
  v8[3] = &type metadata for UnsafeRawBufferPointer;
  v8[4] = &protocol witness table for UnsafeRawBufferPointer;
  v8[0] = v9;
  v8[1] = &v10;
  v2 = sub_10003259C(v8, (uint64_t)&type metadata for UnsafeRawBufferPointer);
  v3 = (_BYTE *)*v2;
  if (*v2 && (v4 = (_BYTE *)v2[1], v5 = v4 - v3, v4 != v3))
  {
    if (v5 <= 14)
    {
      v6 = sub_10000EC20(v3, v4);
    }
    else if ((unint64_t)v5 >= 0x7FFFFFFF)
    {
      v6 = sub_1001067F4((uint64_t)v3, (uint64_t)v4);
    }
    else
    {
      v6 = sub_10010686C((uint64_t)v3, (uint64_t)v4);
    }
  }
  else
  {
    v6 = 0;
  }
  sub_100014430(v8);
  return v6;
}

uint64_t IPv6Address.description.getter(uint64_t a1, unint64_t a2, uint64_t a3, void *a4)
{
  char *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  Swift::String v12;
  void *v13;
  uint64_t v14;
  Swift::String v15;
  uint64_t v16;
  uint64_t v18;
  unint64_t v19;

  v8 = (char *)swift_slowAlloc(46, -1);
  v18 = a1;
  v19 = a2;
  inet_ntop(30, &v18, v8, 0x2Eu);
  v9 = String.init(cString:)(v8);
  v11 = v10;
  if (a4)
  {
    v18 = 37;
    v19 = 0xE100000000000000;
    v12._countAndFlagsBits = a3;
    v12._object = a4;
    String.append(_:)(v12);
    v14 = v18;
    v13 = (void *)v19;
  }
  else
  {
    v14 = 0;
    v13 = (void *)0xE000000000000000;
  }
  v18 = v9;
  v19 = v11;
  swift_bridgeObjectRetain(v11);
  v15._countAndFlagsBits = v14;
  v15._object = v13;
  String.append(_:)(v15);
  swift_bridgeObjectRelease(v13);
  swift_bridgeObjectRelease(v11);
  v16 = v18;
  swift_slowDealloc(v8, -1, -1);
  return v16;
}

uint64_t IPv6Address.customMirror.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  _QWORD *v19;
  _QWORD v20[4];

  v8 = type metadata accessor for Mirror.AncestorRepresentation(0);
  v9 = *(_QWORD *)(v8 - 8);
  __chkstk_darwin();
  v11 = (char *)&v18 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_100012C44((uint64_t *)&unk_1004085C0);
  __chkstk_darwin();
  v13 = (char *)&v18 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v20[0] = a1;
  v20[1] = a2;
  v20[2] = a3;
  v20[3] = a4;
  v19 = _swiftEmptyArrayStorage;
  v14 = type metadata accessor for Mirror.DisplayStyle(0);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v14 - 8) + 56))(v13, 1, 1, v14);
  (*(void (**)(char *, _QWORD, uint64_t))(v9 + 104))(v11, enum case for Mirror.AncestorRepresentation.generated(_:), v8);
  swift_bridgeObjectRetain(a4);
  v15 = sub_100012C44(&qword_100405B90);
  v16 = sub_100066494((unint64_t *)&qword_10040C3E0, &qword_100405B90);
  return Mirror.init<A, B>(_:children:displayStyle:ancestorRepresentation:)(v20, &v19, v13, v11, &type metadata for IPv6Address, v15, v16);
}

void IPv6Address.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  __n128 v11;
  _QWORD v12[2];
  uint64_t v13;

  v12[0] = a2;
  v12[1] = a3;
  v8 = sub_1000FADC0((uint64_t)v12, (uint64_t)&v13);
  v10 = v9;
  Data.hash(into:)(a1, v8, v9, v11);
  sub_10000E614(v8, v10);
  if (a5)
  {
    Hasher._combine(_:)(1u);
    swift_bridgeObjectRetain(a5);
    String.hash(into:)(a1, a4, a5);
    swift_bridgeObjectRelease(a5);
  }
  else
  {
    Hasher._combine(_:)(0);
  }
}

unint64_t IPv6Address.multicastMACAddress.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unsigned __int8 v5;
  unsigned __int8 v6;
  unsigned __int8 v7;
  unsigned __int8 v8;
  _QWORD v10[2];
  uint64_t v11;

  v10[0] = a1;
  v10[1] = a2;
  v2 = sub_1000FADC0((uint64_t)v10, (uint64_t)&v11);
  v4 = v3;
  v5 = Data.subscript.getter(12, v2, v3);
  v6 = Data.subscript.getter(13, v2, v4);
  v7 = Data.subscript.getter(14, v2, v4);
  v8 = Data.subscript.getter(15, v2, v4);
  sub_10000E614(v2, v4);
  return ((unint64_t)v6 << 24) | ((unint64_t)v5 << 16) | ((unint64_t)v7 << 32) | ((unint64_t)v8 << 40) | 0x3333;
}

void sub_1000F923C()
{
  uint64_t v0;

  v0 = *(_QWORD *)&in6addr_any.__u6_addr32[2];
  static IPv6Address.any = *(_QWORD *)in6addr_any.__u6_addr8;
  *(_QWORD *)algn_100410458 = v0;
  qword_100410460 = 0;
  unk_100410468 = 0;
}

uint64_t *IPv6Address.any.unsafeMutableAddressor()
{
  if (qword_100403F50 != -1)
    swift_once(&qword_100403F50, sub_1000F923C);
  return &static IPv6Address.any;
}

uint64_t static IPv6Address.any.getter()
{
  uint64_t v0;

  if (qword_100403F50 != -1)
    swift_once(&qword_100403F50, sub_1000F923C);
  v0 = static IPv6Address.any;
  swift_bridgeObjectRetain(unk_100410468);
  return v0;
}

void sub_1000F930C()
{
  uint64_t v0;

  v0 = *(_QWORD *)&in6addr_any.__u6_addr32[2];
  static IPv6Address.broadcast = *(_QWORD *)in6addr_any.__u6_addr8;
  *(_QWORD *)algn_100410478 = v0;
  qword_100410480 = 0;
  unk_100410488 = 0;
}

uint64_t *IPv6Address.broadcast.unsafeMutableAddressor()
{
  if (qword_100403F58 != -1)
    swift_once(&qword_100403F58, sub_1000F930C);
  return &static IPv6Address.broadcast;
}

uint64_t static IPv6Address.broadcast.getter()
{
  uint64_t v0;

  if (qword_100403F58 != -1)
    swift_once(&qword_100403F58, sub_1000F930C);
  v0 = static IPv6Address.broadcast;
  swift_bridgeObjectRetain(unk_100410488);
  return v0;
}

Swift::Int IPv6Address.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  __n128 v11;
  _QWORD v13[9];
  _QWORD v14[2];
  uint64_t v15;

  Hasher.init(_seed:)(v13);
  v14[0] = a1;
  v14[1] = a2;
  v8 = sub_1000FADC0((uint64_t)v14, (uint64_t)&v15);
  v10 = v9;
  Data.hash(into:)(v13, v8, v9, v11);
  sub_10000E614(v8, v10);
  if (a4)
  {
    Hasher._combine(_:)(1u);
    swift_bridgeObjectRetain(a4);
    String.hash(into:)(v13, a3, a4);
    swift_bridgeObjectRelease(a4);
  }
  else
  {
    Hasher._combine(_:)(0);
  }
  return Hasher._finalize()();
}

Swift::Int sub_1000F94C8()
{
  uint64_t *v0;

  return IPv6Address.hashValue.getter(*v0, v0[1], v0[2], v0[3]);
}

void sub_1000F94D4(uint64_t a1)
{
  _QWORD *v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  __n128 v9;
  _QWORD v10[2];
  uint64_t v11;

  v3 = v1[1];
  v5 = v1[2];
  v4 = v1[3];
  v10[0] = *v1;
  v10[1] = v3;
  v6 = sub_1000FADC0((uint64_t)v10, (uint64_t)&v11);
  v8 = v7;
  Data.hash(into:)(a1, v6, v7, v9);
  sub_10000E614(v6, v8);
  if (v4)
  {
    Hasher._combine(_:)(1u);
    swift_bridgeObjectRetain(v4);
    String.hash(into:)(a1, v5, v4);
    swift_bridgeObjectRelease(v4);
  }
  else
  {
    Hasher._combine(_:)(0);
  }
}

Swift::Int sub_1000F95B4()
{
  uint64_t *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  __n128 v8;
  _QWORD v10[9];
  _QWORD v11[2];
  uint64_t v12;

  v1 = *v0;
  v2 = v0[1];
  v4 = v0[2];
  v3 = v0[3];
  Hasher.init(_seed:)(v10);
  v11[0] = v1;
  v11[1] = v2;
  v5 = sub_1000FADC0((uint64_t)v11, (uint64_t)&v12);
  v7 = v6;
  Data.hash(into:)(v10, v5, v6, v8);
  sub_10000E614(v5, v7);
  if (v3)
  {
    Hasher._combine(_:)(1u);
    swift_bridgeObjectRetain(v3);
    String.hash(into:)(v10, v4, v3);
    swift_bridgeObjectRelease(v3);
  }
  else
  {
    Hasher._combine(_:)(0);
  }
  return Hasher._finalize()();
}

uint64_t sub_1000F969C()
{
  uint64_t v0;

  return IPv6Address.description.getter(*(_QWORD *)v0, *(_QWORD *)(v0 + 8), *(_QWORD *)(v0 + 16), *(void **)(v0 + 24));
}

uint64_t sub_1000F96A8(uint64_t a1)
{
  __int128 *v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  char *v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;
  _QWORD *v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;

  v3 = type metadata accessor for Mirror.AncestorRepresentation(0);
  v4 = *(_QWORD *)(v3 - 8);
  __chkstk_darwin();
  v6 = (char *)&v16 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_100012C44((uint64_t *)&unk_1004085C0);
  __chkstk_darwin();
  v8 = (char *)&v16 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  v9 = *v1;
  v10 = *((_QWORD *)v1 + 2);
  v11 = *((_QWORD *)v1 + 3);
  v18 = v9;
  v19 = v10;
  v20 = v11;
  v17 = _swiftEmptyArrayStorage;
  v12 = type metadata accessor for Mirror.DisplayStyle(0);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v12 - 8) + 56))(v8, 1, 1, v12);
  (*(void (**)(char *, _QWORD, uint64_t))(v4 + 104))(v6, enum case for Mirror.AncestorRepresentation.generated(_:), v3);
  swift_bridgeObjectRetain(v11);
  v13 = sub_100012C44(&qword_100405B90);
  v14 = sub_100066494((unint64_t *)&qword_10040C3E0, &qword_100405B90);
  return Mirror.init<A, B>(_:children:displayStyle:ancestorRepresentation:)(&v18, &v17, v8, v6, a1, v13, v14);
}

uint64_t sub_1000F9804(uint64_t *a1, uint64_t *a2)
{
  return _s7CoreP2P11IPv6AddressV2eeoiySbAC_ACtFZ_0(*a1, a1[1], a1[2], a1[3], *a2, a2[1], a2[2], a2[3]);
}

_QWORD *IPv6Address.init(from:)(_QWORD *a1)
{
  uint64_t v1;
  _QWORD *result;
  uint64_t v3;

  result = sub_1000F9F18(a1);
  if (v1)
    return (_QWORD *)v3;
  return result;
}

uint64_t IPv6Address.encode(to:)(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  return sub_1000F9CB4(a1, a2, a3);
}

_QWORD *sub_1000F985C@<X0>(_QWORD *a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  _QWORD *result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  result = sub_1000F9F18(a1);
  if (!v2)
  {
    *a2 = result;
    a2[1] = v5;
    a2[2] = v6;
    a2[3] = v7;
  }
  return result;
}

uint64_t sub_1000F9888(_QWORD *a1)
{
  uint64_t *v1;

  return sub_1000F9CB4(a1, *v1, v1[1]);
}

uint64_t Layer3Protocol.description.getter()
{
  uint64_t countAndFlagsBits;

  countAndFlagsBits = String.uppercased()()._countAndFlagsBits;
  swift_bridgeObjectRelease(0xE300000000000000);
  return countAndFlagsBits;
}

uint64_t Layer3Protocol.rawValue.getter(char a1)
{
  if ((a1 & 1) != 0)
    return 7365749;
  else
    return 7365492;
}

void *Layer3Protocol.defaultValue.unsafeMutableAddressor()
{
  return &static Layer3Protocol.defaultValue;
}

CoreP2P::Layer3Protocol_optional __swiftcall Layer3Protocol.init(rawValue:)(Swift::String rawValue)
{
  void *object;
  Swift::String v2;
  Swift::Int v3;
  CoreP2P::Layer3Protocol_optional v4;

  object = rawValue._object;
  v2._countAndFlagsBits = rawValue._countAndFlagsBits;
  v2._object = object;
  v3 = _findStringSwitchCase(cases:string:)((Swift::OpaquePointer)&off_1003D49A0, v2);
  swift_bridgeObjectRelease(object);
  if (v3 == 1)
    v4.value = CoreP2P_Layer3Protocol_udp;
  else
    v4.value = CoreP2P_Layer3Protocol_unknownDefault;
  if (v3)
    return v4;
  else
    return 0;
}

_UNKNOWN **static Layer3Protocol.allCases.getter()
{
  return &off_1003D6EA8;
}

uint64_t sub_1000F9970(char *a1, char *a2)
{
  return sub_10003BDF0(*a1, *a2);
}

uint64_t sub_1000F997C@<X0>(uint64_t *a1@<X0>, char *a2@<X8>)
{
  Swift::String v3;
  void *v4;
  Swift::Int v5;
  uint64_t result;
  char v7;

  v3._countAndFlagsBits = *a1;
  v4 = (void *)a1[1];
  v3._object = v4;
  v5 = _findStringSwitchCase(cases:string:)((Swift::OpaquePointer)&off_1003D49A0, v3);
  result = swift_bridgeObjectRelease(v4);
  if (v5 == 1)
    v7 = 1;
  else
    v7 = 2;
  if (!v5)
    v7 = 0;
  *a2 = v7;
  return result;
}

void sub_1000F99D8(uint64_t *a1@<X8>)
{
  _BYTE *v1;
  uint64_t v2;

  if (*v1)
    v2 = 7365749;
  else
    v2 = 7365492;
  *a1 = v2;
  a1[1] = 0xE300000000000000;
}

void sub_1000F99FC(_QWORD *a1@<X8>)
{
  *a1 = &off_1003D6ED0;
}

Swift::Int sub_1000F9A0C()
{
  unsigned __int8 *v0;
  int v1;
  uint64_t v2;
  _QWORD v4[9];

  v1 = *v0;
  Hasher.init(_seed:)(v4);
  if (v1)
    v2 = 7365749;
  else
    v2 = 7365492;
  String.hash(into:)(v4, v2, 0xE300000000000000);
  swift_bridgeObjectRelease(0xE300000000000000);
  return Hasher._finalize()();
}

uint64_t sub_1000F9A6C(uint64_t a1)
{
  _BYTE *v1;
  uint64_t v2;

  if (*v1)
    v2 = 7365749;
  else
    v2 = 7365492;
  String.hash(into:)(a1, v2, 0xE300000000000000);
  return swift_bridgeObjectRelease(0xE300000000000000);
}

Swift::Int sub_1000F9AA0()
{
  unsigned __int8 *v0;
  int v1;
  uint64_t v2;
  _QWORD v4[9];

  v1 = *v0;
  Hasher.init(_seed:)(v4);
  if (v1)
    v2 = 7365749;
  else
    v2 = 7365492;
  String.hash(into:)(v4, v2, 0xE300000000000000);
  swift_bridgeObjectRelease(0xE300000000000000);
  return Hasher._finalize()();
}

uint64_t sub_1000F9AFC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000FA460();
  return RawRepresentable<>.init(from:)(a1, a2, a3, v6);
}

uint64_t sub_1000F9B58(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;

  v6 = sub_1000FA460();
  return RawRepresentable<>.encode(to:)(a1, a2, a3, v6);
}

uint64_t sub_1000F9BA4()
{
  uint64_t countAndFlagsBits;

  countAndFlagsBits = String.uppercased()()._countAndFlagsBits;
  swift_bridgeObjectRelease(0xE300000000000000);
  return countAndFlagsBits;
}

uint64_t _s7CoreP2P11IPv6AddressV2eeoiySbAC_ACtFZ_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;

  if (a1 != a5 || a2 != a6)
    return 0;
  result = (a4 | a8) == 0;
  if (a4 && a8)
  {
    if (a3 == a7 && a4 == a8)
      return 1;
    else
      return _stringCompareWithSmolCheck(_:_:expecting:)(a3, a4, a7, a8, 0);
  }
  return result;
}

uint64_t sub_1000F9CB4(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  _QWORD v14[2];
  _QWORD v15[2];
  _QWORD v16[3];
  uint64_t v17;
  uint64_t v18;

  v5 = a1[3];
  v6 = a1[4];
  sub_10003259C(a1, v5);
  dispatch thunk of Encoder.unkeyedContainer()(v16, v5, v6);
  v15[0] = a2;
  v15[1] = a3;
  v7 = sub_1000FADC0((uint64_t)v15, (uint64_t)v16);
  v9 = v8;
  v14[0] = v7;
  v14[1] = v8;
  v10 = v17;
  v11 = v18;
  sub_100034C68((uint64_t)v16, v17);
  v12 = sub_100068570();
  dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(v14, &type metadata for Data, v12, v10, v11);
  sub_10000E614(v7, v9);
  return sub_100014430(v16);
}

uint64_t _s7CoreP2P14Layer3ProtocolO8dnsLabelACSgSS_tcfC_0(uint64_t a1, unint64_t a2)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __n128 v8;
  char v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  void *v21;
  Swift::String v22;
  Swift::Int v23;
  unsigned int v24;
  BOOL v25;
  Swift::String v26;
  Swift::Int v27;

  v3 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000) == 0)
    v3 = a1 & 0xFFFFFFFFFFFFLL;
  if (!v3)
  {
    swift_bridgeObjectRelease(a2);
    return 2;
  }
  v5 = sub_1000FB724(a1, a2);
  if (!v6)
    goto LABEL_14;
  v7 = v6;
  if (v5 != 95 || v6 != 0xE100000000000000)
  {
    v10 = _stringCompareWithSmolCheck(_:_:expecting:)(v5, v6, 95, 0xE100000000000000, 0);
    v8 = swift_bridgeObjectRelease(v7);
    if ((v10 & 1) != 0)
      goto LABEL_10;
LABEL_14:
    v26._countAndFlagsBits = a1;
    v26._object = (void *)a2;
    v27 = _findStringSwitchCase(cases:string:)((Swift::OpaquePointer)&off_1003D49A0, v26);
    swift_bridgeObjectRelease(a2);
    if (v27 == 1)
      v24 = 1;
    else
      v24 = 2;
    v25 = v27 == 0;
    goto LABEL_18;
  }
  v8 = swift_bridgeObjectRelease(0xE100000000000000);
LABEL_10:
  v11 = String.index(after:)(15, a1, a2, v8);
  v12 = sub_1000FB8AC(v11, a1, a2);
  v14 = v13;
  v16 = v15;
  v18 = v17;
  swift_bridgeObjectRelease(a2);
  v19 = static String._fromSubstring(_:)(v12, v14, v16, v18);
  v21 = v20;
  swift_bridgeObjectRelease(v18);
  v22._countAndFlagsBits = v19;
  v22._object = v21;
  v23 = _findStringSwitchCase(cases:string:)((Swift::OpaquePointer)&off_1003D49A0, v22);
  swift_bridgeObjectRelease(v21);
  if (v23 == 1)
    v24 = 1;
  else
    v24 = 2;
  v25 = v23 == 0;
LABEL_18:
  if (v25)
    return 0;
  else
    return v24;
}

_QWORD *sub_1000F9F18(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v12;
  _QWORD v13[3];
  uint64_t v14;
  uint64_t v15;

  v3 = a1[3];
  v4 = a1[4];
  v5 = sub_10003259C(a1, v3);
  dispatch thunk of Decoder.unkeyedContainer()(v13, v3, v4);
  if (!v1)
  {
    v6 = v14;
    v7 = v15;
    sub_100034C68((uint64_t)v13, v14);
    v8 = UnkeyedDecodingContainer.decodeData(with:)(16, v6, v7);
    v10 = v9;
    sub_100031FEC(v8, v9);
    sub_100212BD4(v8, v10);
    v5 = v12;
    sub_10000E614(v8, v10);
    sub_10000E614(v8, v10);
    sub_100014430(v13);
  }
  sub_100014430(a1);
  return v5;
}

unint64_t sub_1000FA118()
{
  unint64_t result;

  result = qword_100407CD8;
  if (!qword_100407CD8)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for IPv4Address, &type metadata for IPv4Address);
    atomic_store(result, (unint64_t *)&qword_100407CD8);
  }
  return result;
}

unint64_t sub_1000FA160()
{
  unint64_t result;

  result = qword_100407CE0;
  if (!qword_100407CE0)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for IPv6Address, &type metadata for IPv6Address);
    atomic_store(result, (unint64_t *)&qword_100407CE0);
  }
  return result;
}

uint64_t sub_1000FA1A4()
{
  return sub_100066494(&qword_100407CE8, &qword_100407CF0);
}

unint64_t sub_1000FA1CC()
{
  unint64_t result;

  result = qword_100407CF8;
  if (!qword_100407CF8)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for Layer3Protocol, &type metadata for Layer3Protocol);
    atomic_store(result, (unint64_t *)&qword_100407CF8);
  }
  return result;
}

ValueMetadata *type metadata accessor for IPv4Address()
{
  return &type metadata for IPv4Address;
}

uint64_t initializeWithCopy for IPv6Address(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  *(_OWORD *)a1 = *(_OWORD *)a2;
  v3 = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 24) = v3;
  swift_bridgeObjectRetain(v3);
  return a1;
}

_QWORD *assignWithCopy for IPv6Address(_QWORD *a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  a1[2] = a2[2];
  v4 = a2[3];
  v5 = a1[3];
  a1[3] = v4;
  swift_bridgeObjectRetain(v4);
  swift_bridgeObjectRelease(v5);
  return a1;
}

uint64_t assignWithTake for IPv6Address(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;

  *(_OWORD *)a1 = *(_OWORD *)a2;
  v3 = *(_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 24) = v3;
  swift_bridgeObjectRelease(v4);
  return a1;
}

uint64_t getEnumTagSinglePayload for IPv6Address(uint64_t a1, unsigned int a2)
{
  unint64_t v3;
  int v4;

  if (!a2)
    return 0;
  if (a2 >= 0x7FFFFFFF && *(_BYTE *)(a1 + 32))
    return (*(_DWORD *)a1 + 0x7FFFFFFF);
  v3 = *(_QWORD *)(a1 + 24);
  if (v3 >= 0xFFFFFFFF)
    LODWORD(v3) = -1;
  v4 = v3 - 1;
  if (v4 < 0)
    v4 = -1;
  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for IPv6Address(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0x7FFFFFFE)
  {
    *(_QWORD *)(result + 16) = 0;
    *(_QWORD *)(result + 24) = 0;
    *(_QWORD *)result = a2 - 0x7FFFFFFF;
    *(_QWORD *)(result + 8) = 0;
    if (a3 >= 0x7FFFFFFF)
      *(_BYTE *)(result + 32) = 1;
  }
  else
  {
    if (a3 >= 0x7FFFFFFF)
      *(_BYTE *)(result + 32) = 0;
    if (a2)
      *(_QWORD *)(result + 24) = a2;
  }
  return result;
}

ValueMetadata *type metadata accessor for IPv6Address()
{
  return &type metadata for IPv6Address;
}

uint64_t storeEnumTagSinglePayload for Layer3Protocol(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 1 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 1) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xFF)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xFE)
    return ((uint64_t (*)(void))((char *)&loc_1000FA3E0 + 4 * byte_100346755[v4]))();
  *a1 = a2 + 1;
  return ((uint64_t (*)(void))((char *)sub_1000FA414 + 4 * byte_100346750[v4]))();
}

uint64_t sub_1000FA414(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000FA41C(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x1000FA424);
  return result;
}

uint64_t sub_1000FA430(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x1000FA438);
  *(_BYTE *)result = a2 + 1;
  return result;
}

uint64_t sub_1000FA43C(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_1000FA444(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for Layer3Protocol()
{
  return &type metadata for Layer3Protocol;
}

unint64_t sub_1000FA460()
{
  unint64_t result;

  result = qword_100407D00;
  if (!qword_100407D00)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for Layer3Protocol, &type metadata for Layer3Protocol);
    atomic_store(result, (unint64_t *)&qword_100407D00);
  }
  return result;
}

uint64_t static DNSRecords.createPeerLossRecord(for:hostname:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t result;

  v7 = a1 & 0xFFFFFFFFFFFFLL;
  swift_bridgeObjectRetain(a3);
  WiFiAddress.ipv6LinkLocalAddress.getter(v7);
  v9 = v8;
  v11 = v10;
  v13 = v12;
  v15 = v14;
  a4[3] = (uint64_t)&type metadata for DNSRecords.AAAA;
  a4[4] = (uint64_t)&protocol witness table for DNSRecords.AAAA;
  result = swift_allocObject(&unk_1003E44C0, 80, 7);
  *a4 = result;
  *(_BYTE *)(result + 16) = 27;
  *(_QWORD *)(result + 24) = a2;
  *(_QWORD *)(result + 32) = a3;
  *(_BYTE *)(result + 40) = 1;
  *(_QWORD *)(result + 48) = v9;
  *(_QWORD *)(result + 56) = v11;
  *(_QWORD *)(result + 64) = v13;
  *(_QWORD *)(result + 72) = v15;
  return result;
}

void static DNSRecords.createRecord(with:value:)(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4 >> 60 != 15)
  {
    if (qword_100403F78 != -1)
      swift_once(&qword_100403F78, sub_1001055D0);
    __asm { BR              X13 }
  }
  if (qword_100403F70 != -1)
    swift_once(&qword_100403F70, sub_1001055A8);
  __asm { BR              X13 }
}

BOOL static DNSRecords.Identifier.== infix(_:_:)(uint64_t a1, uint64_t a2, __int16 a3, uint64_t a4, uint64_t a5, __int16 a6)
{
  return sub_100106584(a1, a2, a3 & 0xFF01, a4, a5, a6 & 0xFF01);
}

uint64_t DNSRecords.TXT.keyData.getter()
{
  uint64_t v0;
  uint64_t v1;
  unint64_t v2;
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;

  v1 = *(_QWORD *)(v0 + 16);
  v2 = *(_QWORD *)(v0 + 24);
  v3 = *(_BYTE *)(v0 + 32);
  sub_100107054(*(_QWORD *)v0, *(_QWORD *)(v0 + 8));
  sub_1000FF4F4(15, v1, v2, v3 & 1);
  v5 = v4;
  v7 = v6;
  sub_1000FBDAC(v4, v6);
  sub_10000E614(v5, v7);
  return 0;
}

uint64_t DNSRecords.TXT.valueData.getter()
{
  uint64_t v0;
  uint64_t v1;

  v1 = *(_QWORD *)(v0 + 40);
  sub_100031FEC(v1, *(_QWORD *)(v0 + 48));
  return v1;
}

void DNSRecords.PTR.keyData.getter()
{
  uint64_t v0;

  sub_1000FF4F4(11, *(_QWORD *)(v0 + 16), *(_QWORD *)(v0 + 24), *(_BYTE *)(v0 + 32));
}

void DNSRecords.PTR.valueData.getter()
{
  uint64_t v0;

  sub_100106CEC(*(_QWORD *)v0, *(_QWORD *)(v0 + 8));
}

void DNSRecords.AAAA.keyData.getter()
{
  unsigned __int8 *v0;

  DNSRecords.BrowseHost.keyData.getter(*v0, *((_QWORD *)v0 + 1), *((_QWORD *)v0 + 2));
}

uint64_t DNSRecords.AAAA.valueData.getter()
{
  uint64_t v0;
  _QWORD *v1;
  _BYTE *v2;
  _BYTE *v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD v7[5];
  __int128 v8;
  uint64_t v9;

  v8 = *(_OWORD *)(v0 + 32);
  v7[3] = &type metadata for UnsafeRawBufferPointer;
  v7[4] = &protocol witness table for UnsafeRawBufferPointer;
  v7[0] = &v8;
  v7[1] = &v9;
  v1 = sub_10003259C(v7, (uint64_t)&type metadata for UnsafeRawBufferPointer);
  v2 = (_BYTE *)*v1;
  if (*v1 && (v3 = (_BYTE *)v1[1], v4 = v3 - v2, v3 != v2))
  {
    if (v4 <= 14)
    {
      v5 = sub_10000EC20(v2, v3);
    }
    else if ((unint64_t)v4 >= 0x7FFFFFFF)
    {
      v5 = sub_1001067F4((uint64_t)v2, (uint64_t)v3);
    }
    else
    {
      v5 = sub_10010686C((uint64_t)v2, (uint64_t)v3);
    }
  }
  else
  {
    v5 = 0;
  }
  sub_100014430(v7);
  return v5;
}

uint64_t DNSRecords.SRV.keyData.getter()
{
  uint64_t v0;
  uint64_t v1;
  unint64_t v2;
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;

  v1 = *(_QWORD *)(v0 + 16);
  v2 = *(_QWORD *)(v0 + 24);
  v3 = *(_BYTE *)(v0 + 32);
  sub_100107054(*(_QWORD *)v0, *(_QWORD *)(v0 + 8));
  sub_1000FF4F4(32, v1, v2, v3);
  v5 = v4;
  v7 = v6;
  sub_1000FBDAC(v4, v6);
  sub_10000E614(v5, v7);
  return 0;
}

void DNSRecords.SRV.valueData.getter()
{
  uint64_t v0;
  int *v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  __int16 v12;
  _BYTE v13[38];
  __int128 v14;

  v14 = xmmword_10033A100;
  v1 = (int *)type metadata accessor for DNSRecords.SRV(0);
  v12 = *(_WORD *)(v0 + v1[7]);
  v2 = sub_1000FADC0((uint64_t)&v12, (uint64_t)v13);
  v4 = v3;
  sub_1000FBDAC(v2, v3);
  sub_10000E614(v2, v4);
  v12 = *(_WORD *)(v0 + v1[8]);
  v5 = sub_1000FADC0((uint64_t)&v12, (uint64_t)v13);
  v7 = v6;
  sub_1000FBDAC(v5, v6);
  v8 = sub_10000E614(v5, v7);
  v12 = bswap32(NWEndpoint.Port.rawValue.getter(v8)) >> 16;
  v9 = sub_1000FADC0((uint64_t)&v12, (uint64_t)v13);
  v11 = v10;
  sub_1000FBDAC(v9, v10);
  sub_10000E614(v9, v11);
  sub_1000FEBE4(*(_QWORD *)(v0 + v1[6]), *(_QWORD *)(v0 + v1[6] + 8));
  __asm { BR              X12 }
}

uint64_t sub_1000FAC64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, __int16 a10, char a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, unint64_t a19)
{
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v20 = BYTE6(v19);
  v21 = sub_100012C44(&qword_1004066A8);
  a16 = v21;
  a17 = sub_100011770(&qword_1004066B0, &qword_1004066A8, (const char *)&protocol conformance descriptor for <A> CollectionOfOne<A>);
  LOBYTE(a13) = -64;
  a12 = *(_BYTE *)sub_10003259C(&a13, v21);
  Data._Representation.replaceSubrange(_:with:count:)(v20, v20, &a12, 1);
  v22 = sub_100014430(&a13);
  return ((uint64_t (*)(uint64_t))((char *)sub_1000FAD10 + 4 * byte_100346AFC[a19 >> 62]))(v22);
}

uint64_t sub_1000FAD10()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v5;
  _QWORD v6[3];
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = BYTE6(v0);
  v7 = v1;
  v8 = v2;
  LOBYTE(v6[0]) = 17;
  v5 = *(_BYTE *)sub_10003259C(v6, v1);
  Data._Representation.replaceSubrange(_:with:count:)(v3, v3, &v5, 1);
  sub_100014430(v6);
  return v9;
}

uint64_t NANSubscribe.Configuration.rangingMandatory.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 33);
}

uint64_t DNSRecords.AAAA.init(host:address:)@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char a4@<W3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>)
{
  *(_BYTE *)a9 = result;
  *(_QWORD *)(a9 + 8) = a2;
  *(_QWORD *)(a9 + 16) = a3;
  *(_BYTE *)(a9 + 24) = a4;
  *(_QWORD *)(a9 + 32) = a5;
  *(_QWORD *)(a9 + 40) = a6;
  *(_QWORD *)(a9 + 48) = a7;
  *(_QWORD *)(a9 + 56) = a8;
  return result;
}

uint64_t sub_1000FADC0(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  _BYTE *v3;
  _BYTE *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v8[5];

  v8[3] = &type metadata for UnsafeRawBufferPointer;
  v8[4] = &protocol witness table for UnsafeRawBufferPointer;
  v8[0] = a1;
  v8[1] = a2;
  v2 = sub_10003259C(v8, (uint64_t)&type metadata for UnsafeRawBufferPointer);
  v3 = (_BYTE *)*v2;
  if (*v2 && (v4 = (_BYTE *)v2[1], v5 = v4 - v3, v4 != v3))
  {
    if (v5 <= 14)
    {
      v6 = sub_10000EC20(v3, v4);
    }
    else if ((unint64_t)v5 >= 0x7FFFFFFF)
    {
      v6 = sub_1001067F4((uint64_t)v3, (uint64_t)v4);
    }
    else
    {
      v6 = sub_10010686C((uint64_t)v3, (uint64_t)v4);
    }
  }
  else
  {
    v6 = 0;
  }
  sub_100014430(v8);
  return v6;
}

uint64_t sub_1000FAE78(uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  _BYTE *v7;
  unint64_t v8;
  unint64_t v9;
  Swift::Int v10;
  uint64_t v11;
  __int128 v15[2];
  uint64_t v16;
  __int128 v17;
  _QWORD v18[4];

  *(_QWORD *)&v17 = a1;
  *((_QWORD *)&v17 + 1) = a2;
  swift_bridgeObjectRetain(a2);
  v2 = sub_100012C44((uint64_t *)&unk_100410240);
  if (!swift_dynamicCast(v15, &v17, &type metadata for String.UTF8View, v2, 6))
  {
    v16 = 0;
    memset(v15, 0, sizeof(v15));
    sub_100033A84((uint64_t)v15, &qword_1004066C0);
    if ((a2 & 0x1000000000000000) != 0)
      goto LABEL_20;
    if ((a2 & 0x2000000000000000) != 0)
    {
      v18[0] = a1;
      v18[1] = a2 & 0xFFFFFFFFFFFFFFLL;
      v5 = (char *)v18 + (HIBYTE(a2) & 0xF);
      v6 = v18;
    }
    else
    {
      if ((a1 & 0x1000000000000000) != 0)
      {
        v3 = (a2 & 0xFFFFFFFFFFFFFFFLL) + 32;
        v4 = a1 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        v3 = _StringObject.sharedUTF8.getter(a1, a2);
      }
      if (v3)
        v5 = (_BYTE *)(v3 + v4);
      else
        v5 = 0;
      v6 = (_BYTE *)v3;
    }
    v7 = sub_10010699C(v6, v5);
    v9 = v8;
    if (v8 >> 60 != 15)
    {
      swift_bridgeObjectRelease(a2);
      *(_QWORD *)&v15[0] = v7;
      *((_QWORD *)&v15[0] + 1) = v9;
      return *(_QWORD *)&v15[0];
    }
    if ((a2 & 0x1000000000000000) != 0)
    {
LABEL_20:
      v10 = String.UTF8View._foreignCount()();
    }
    else if ((a2 & 0x2000000000000000) != 0)
    {
      v10 = HIBYTE(a2) & 0xF;
    }
    else
    {
      v10 = a1 & 0xFFFFFFFFFFFFLL;
    }
    *(_QWORD *)&v15[0] = sub_100106A00(v10);
    *((_QWORD *)&v15[0] + 1) = v11;
    __chkstk_darwin();
    sub_10020839C();
    __asm { BR              X12 }
  }
  sub_1000641F0(v15, (uint64_t)v18);
  sub_10003259C(v18, v18[3]);
  dispatch thunk of ContiguousBytes.withUnsafeBytes<A>(_:)(sub_100106424);
  swift_bridgeObjectRelease(a2);
  v15[0] = v17;
  sub_100014430(v18);
  return *(_QWORD *)&v15[0];
}

uint64_t sub_1000FB37C(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  _BYTE *v4;
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  _QWORD v9[5];

  v9[3] = &type metadata for UnsafeMutableRawBufferPointer;
  v9[4] = &protocol witness table for UnsafeMutableRawBufferPointer;
  v9[0] = a1;
  v9[1] = a2;
  v2 = sub_10003259C(v9, (uint64_t)&type metadata for UnsafeMutableRawBufferPointer);
  v3 = *v2;
  if (*v2)
  {
    v4 = (_BYTE *)v2[1];
    v5 = (uint64_t)&v4[-v3];
    if (v4 == (_BYTE *)v3)
    {
      v3 = 0;
    }
    else if (v5 <= 14)
    {
      v3 = sub_10000EC20((_BYTE *)*v2, v4);
    }
    else
    {
      v7 = type metadata accessor for __DataStorage(0);
      swift_allocObject(v7, *(unsigned int *)(v7 + 48), *(unsigned __int16 *)(v7 + 52));
      __DataStorage.init(bytes:length:)(v3, v5);
      if ((unint64_t)v5 >= 0x7FFFFFFF)
      {
        v8 = type metadata accessor for Data.RangeReference(0);
        v3 = swift_allocObject(v8, 32, 7);
        *(_QWORD *)(v3 + 16) = 0;
        *(_QWORD *)(v3 + 24) = v5;
      }
      else
      {
        v3 = v5 << 32;
      }
    }
  }
  sub_100014430(v9);
  return v3;
}

void sub_1000FB47C(uint64_t a1, uint64_t a2)
{
  char *v2;
  _QWORD v3[5];

  v3[3] = &type metadata for Data;
  v3[4] = &protocol witness table for Data;
  v3[0] = a1;
  v3[1] = a2;
  v2 = (char *)&loc_1000FB4E0 + dword_1000FB714[sub_10003259C(v3, (uint64_t)&type metadata for Data)[1] >> 62];
  __asm { BR              X10 }
}

uint64_t sub_1000FB4F0()
{
  unint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  __int16 v7;
  char v8;
  char v9;
  char v10;
  char v11;
  uint64_t v12;
  uint64_t v13;

  v6 = v2;
  v7 = v3;
  v8 = BYTE2(v3);
  v9 = BYTE3(v3);
  v10 = BYTE4(v3);
  v11 = BYTE5(v3);
  sub_100031FEC(v1, v0);
  sub_100106424(&v6, (_BYTE *)&v6 + BYTE6(v3), &v12);
  sub_10000E614(v1, v0);
  v4 = v12;
  sub_100014430(&v13);
  return v4;
}

uint64_t sub_1000FB724(uint64_t a1, unint64_t a2)
{
  uint64_t v2;

  v2 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000) == 0)
    v2 = a1 & 0xFFFFFFFFFFFFLL;
  if (v2)
    return String.subscript.getter(15, a1, a2);
  else
    return 0;
}

void sub_1000FB764(uint64_t a1, uint64_t a2)
{
  __asm { BR              X12 }
}

uint64_t sub_1000FB7AC(unsigned __int8 a1, uint64_t a2)
{
  unsigned __int8 v2;

  if ((a2 & 0xFF000000000000) != 0)
    v2 = a1;
  else
    v2 = 0;
  return v2 | (((a2 & 0xFF000000000000) == 0) << 8);
}

unint64_t sub_1000FB8AC(unint64_t result, uint64_t a2, unint64_t a3)
{
  uint64_t v3;
  uint64_t v4;

  v3 = HIBYTE(a3) & 0xF;
  if ((a3 & 0x2000000000000000) == 0)
    v3 = a2 & 0xFFFFFFFFFFFFLL;
  if (4 * v3 < result >> 14)
  {
    __break(1u);
  }
  else
  {
    v4 = 7;
    if (((a3 >> 60) & ((a2 & 0x800000000000000) == 0)) != 0)
      v4 = 11;
    return String.subscript.getter(result, v4 | (v3 << 16), a2, a3);
  }
  return result;
}

void sub_1000FB8F8()
{
  __asm { BR              X12 }
}

uint64_t sub_1000FB948()
{
  uint64_t v0;
  char v1;
  uint64_t v2;
  char v4;
  _QWORD v5[3];
  uint64_t v6;
  uint64_t v7;

  v2 = BYTE6(v0);
  v6 = sub_100012C44(&qword_1004066A8);
  v7 = sub_100011770(&qword_1004066B0, &qword_1004066A8, (const char *)&protocol conformance descriptor for <A> CollectionOfOne<A>);
  LOBYTE(v5[0]) = v1;
  v4 = *(_BYTE *)sub_10003259C(v5, v6);
  Data._Representation.replaceSubrange(_:with:count:)(v2, v2, &v4, 1);
  return sub_100014430(v5);
}

uint64_t sub_1000FB9F8(uint64_t a1, char a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  char v7;
  uint64_t v8;
  char v9;
  __int128 v10[2];
  uint64_t v11;
  _QWORD v12[4];

  v8 = a1;
  v9 = a2;
  v6 = a1;
  v7 = a2;
  v3 = sub_100012C44(&qword_1004066B8);
  v4 = sub_100012C44((uint64_t *)&unk_100410240);
  if (!swift_dynamicCast(v10, &v6, v3, v4, 6))
  {
    v11 = 0;
    memset(v10, 0, sizeof(v10));
    sub_100033A84((uint64_t)v10, &qword_1004066C0);
    __asm { BR              X12 }
  }
  sub_1000641F0(v10, (uint64_t)v12);
  sub_10003259C(v12, v12[3]);
  __chkstk_darwin();
  dispatch thunk of ContiguousBytes.withUnsafeBytes<A>(_:)(sub_100108A5C);
  return sub_100014430(v12);
}

void sub_1000FBDAC(uint64_t a1, uint64_t a2)
{
  char *v2;
  _QWORD v3[5];

  v3[3] = &type metadata for Data;
  v3[4] = &protocol witness table for Data;
  v3[0] = a1;
  v3[1] = a2;
  v2 = (char *)&loc_1000FBE10 + dword_1000FBFB4[sub_10003259C(v3, (uint64_t)&type metadata for Data)[1] >> 62];
  __asm { BR              X10 }
}

uint64_t sub_1000FBE20()
{
  unint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  __int16 v6;
  char v7;
  char v8;
  char v9;
  char v10;
  uint64_t v11;

  v5 = v2;
  v6 = v3;
  v7 = BYTE2(v3);
  v8 = BYTE3(v3);
  v9 = BYTE4(v3);
  v10 = BYTE5(v3);
  sub_100031FEC(v1, v0);
  Data._Representation.append(contentsOf:)(&v5, (char *)&v5 + BYTE6(v3));
  return sub_100014430(&v11);
}

uint64_t sub_1000FBFC4(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  BOOL v4;
  uint64_t v5;

  v4 = __OFADD__(a1, a2);
  v5 = a1 + a2;
  if (v4)
  {
    __break(1u);
    JUMPOUT(0x1000FC024);
  }
  return ((uint64_t (*)(uint64_t))((char *)&loc_1000FBFDC + *((int *)qword_1000FC028 + (a4 >> 62))))(v5);
}

BOOL static DNSRecords.PTR.== infix(_:_:)(__int128 *a1, uint64_t a2)
{
  __int128 v4;
  unint64_t v5;
  _OWORD v8[2];

  v4 = *a1;
  v8[0] = *(_OWORD *)a2;
  v8[1] = v4;
  v5 = sub_10001C920();
  return !StringProtocol.caseInsensitiveCompare<A>(_:)(v8, &type metadata for String, &type metadata for String, v5, v5)
      && sub_100106584(*((_QWORD *)a1 + 2), *((_QWORD *)a1 + 3), *((unsigned __int8 *)a1 + 32) | (*((unsigned __int8 *)a1 + 33) << 8), *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), *(unsigned __int8 *)(a2 + 32) | (*(unsigned __int8 *)(a2 + 33) << 8));
}

uint64_t static DNSRecords.TXT.__derived_struct_equals(_:_:)(__int128 *a1, uint64_t a2)
{
  __int128 v3;
  uint64_t v4;
  char v5;
  __int16 v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  __int16 v10;
  unint64_t v11;
  char v12;
  uint64_t v14;
  _OWORD v15[2];

  v3 = *a1;
  v4 = *((_QWORD *)a1 + 3);
  v14 = *((_QWORD *)a1 + 2);
  v5 = *((_BYTE *)a1 + 32);
  v6 = *((unsigned __int8 *)a1 + 33);
  v15[0] = *(_OWORD *)a2;
  v15[1] = v3;
  v7 = *(_QWORD *)(a2 + 16);
  v8 = *(_QWORD *)(a2 + 24);
  v9 = *(_BYTE *)(a2 + 32);
  v10 = *(unsigned __int8 *)(a2 + 33);
  v11 = sub_10001C920();
  if (StringProtocol.caseInsensitiveCompare<A>(_:)(v15, &type metadata for String, &type metadata for String, v11, v11)
    || !sub_100106584(v14, v4, v5 & 1 | (v6 << 8), v7, v8, v9 & 1 | (v10 << 8)))
  {
    v12 = 0;
  }
  else
  {
    _s7CoreP2P6NANPMKV23__derived_struct_equalsySbAC_ACtFZ_0(*((_QWORD *)a1 + 5), *((_QWORD *)a1 + 6));
  }
  return v12 & 1;
}

uint64_t AWDLActionFrame.ServiceResponse.init(from:)@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _BYTE *v6;
  uint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE *v11;
  uint64_t v12;
  _BYTE *v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE *v16;
  uint64_t v17;
  uint64_t v18;
  __int16 v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned __int8 v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unsigned __int16 v36;
  unsigned __int16 v37;
  uint64_t v38;
  uint64_t v39;
  unsigned __int16 v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _BYTE v49[144];
  unint64_t v50;
  uint64_t v51;
  _BYTE *v52;
  uint64_t v53;
  _BYTE *v54;
  uint64_t v55;
  _BYTE *v56;
  _BYTE *v57;
  uint64_t v58;
  uint64_t v59;
  _QWORD *v60;
  _BYTE *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;

  v59 = a2;
  sub_100012C44(&qword_100404E70);
  __chkstk_darwin();
  v57 = &v49[-((v3 + 15) & 0xFFFFFFFFFFFFFFF0)];
  v58 = type metadata accessor for NWEndpoint.Port(0);
  v4 = *(_QWORD *)(v58 - 8);
  __chkstk_darwin();
  v6 = &v49[-((v5 + 15) & 0xFFFFFFFFFFFFFFF0)];
  type metadata accessor for String.Encoding(0);
  __chkstk_darwin();
  v8 = &v49[-((v7 + 15) & 0xFFFFFFFFFFFFFFF0)];
  v9 = type metadata accessor for AWDLActionFrame.ServiceResponse(0);
  __chkstk_darwin();
  v11 = &v49[-((v10 + 15) & 0xFFFFFFFFFFFFFFF0)];
  __chkstk_darwin();
  v13 = &v49[-v12];
  v14 = a1[3];
  v15 = a1[4];
  v60 = a1;
  sub_10003259C(a1, v14);
  v16 = v61;
  dispatch thunk of Decoder.unkeyedContainer()(&v62, v14, v15);
  if (!v16)
  {
    v53 = v4;
    v54 = v11;
    v61 = v8;
    v55 = v9;
    v56 = v13;
    v52 = v6;
    v17 = v63;
    v18 = v64;
    sub_100034C68((uint64_t)&v62, v63);
    v19 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v17, v18);
    if ((unsigned __int16)(v19 - 256) > 0xFF01u)
    {
      v23 = (unsigned __int16)(v19 - 1);
      v24 = v63;
      v25 = v64;
      sub_100034C68((uint64_t)&v62, v63);
      v26 = UnkeyedDecodingContainer.decodeData(with:)(v23, v24, v25);
      v50 = v27;
      v51 = v26;
      v28 = v63;
      v29 = v64;
      sub_100034C68((uint64_t)&v62, v63);
      v30 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v28, v29);
      if (_s7CoreP2P10DNSRecordsO10RecordTypeO8rawValueAESgs6UInt16V_tcfC_0(v30) == 65)
      {
        v31 = sub_100012C84();
        v32 = swift_allocError(&type metadata for WiFiError, v31, 0, 0);
        *(_OWORD *)v33 = xmmword_100337850;
        *(_BYTE *)(v33 + 16) = 2;
        swift_willThrow(v32);
        v42 = v50;
        v41 = v51;
      }
      else
      {
        v34 = v63;
        v35 = v64;
        sub_100034C68((uint64_t)&v62, v63);
        v36 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v34, v35);
        v37 = v36;
        v38 = v63;
        v39 = v64;
        sub_100034C68((uint64_t)&v62, v63);
        v40 = dispatch thunk of UnkeyedDecodingContainer.decode(_:)(v38, v39);
        v44 = v50;
        v45 = v51;
        if (v37 > v40 && v37 - v40 != 0xFFFF)
          __asm { BR              X9 }
        v46 = sub_100012C84();
        v47 = swift_allocError(&type metadata for WiFiError, v46, 0, 0);
        *(_QWORD *)v48 = 0;
        *(_QWORD *)(v48 + 8) = 0;
        *(_BYTE *)(v48 + 16) = 2;
        swift_willThrow(v47);
        v41 = v45;
        v42 = v44;
      }
      sub_10000E614(v41, v42);
    }
    else
    {
      v20 = sub_100012C84();
      v21 = swift_allocError(&type metadata for WiFiError, v20, 0, 0);
      *(_QWORD *)v22 = 0;
      *(_QWORD *)(v22 + 8) = 0;
      *(_BYTE *)(v22 + 16) = 2;
      swift_willThrow(v21);
    }
    sub_100014430(&v62);
  }
  return sub_100014430(v60);
}

void sub_1000FD46C()
{
  uint64_t v0;
  uint64_t v1;

  swift_bridgeObjectRelease(*(_QWORD *)(v1 - 296));
  if (!v0)
  {
    *(_QWORD *)(v1 - 272) = 0;
    JUMPOUT(0x1000FD10CLL);
  }
  __break(1u);
  JUMPOUT(0x1000FD944);
}

void sub_1000FD4B4()
{
  uint64_t v0;
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v4 = Data.subdata(in:)(0, BYTE6(v1), v2, v1);
  v6 = v5;
  swift_bridgeObjectRelease(*(_QWORD *)(v3 - 272));
  sub_10000E614(*(_QWORD *)(v3 - 240), *(_QWORD *)(v3 - 248));
  sub_10000E614(v2, v1);
  v8 = *(_QWORD *)(v3 - 216);
  v7 = *(_QWORD *)(v3 - 208);
  v9 = *(_QWORD *)(v3 - 296);
  *(_QWORD *)v8 = *(_QWORD *)(v3 - 368);
  *(_QWORD *)(v8 + 8) = v9;
  *(_QWORD *)(v8 + 16) = *(_QWORD *)(v3 - 384);
  *(_QWORD *)(v8 + 24) = v0;
  *(_BYTE *)(v8 + 32) = *(_DWORD *)(v3 - 264);
  *(_BYTE *)(v8 + 33) = 1;
  *(_QWORD *)(v8 + 40) = v4;
  *(_QWORD *)(v8 + 48) = v6;
  swift_storeEnumTagMultiPayload(v8, v7, 1);
  sub_100033AC0(v8, *(_QWORD *)(v3 - 200), type metadata accessor for AWDLActionFrame.ServiceResponse);
  JUMPOUT(0x1000FD568);
}

void AWDLActionFrame.ServiceResponse.encode(to:)(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  unint64_t v16;
  int EnumCaseMultiPayload;
  uint64_t v18;
  unint64_t v19;
  __int16 v20;
  __int16 v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  __int16 v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  unint64_t v42;
  __int16 v43;
  _QWORD *v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  _QWORD *v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  uint64_t *v73;
  unint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  unint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  _QWORD *v86;
  uint64_t v87;
  _QWORD *v88;
  uint64_t v89;
  _QWORD *v90;
  __int128 v91;
  uint64_t v92;
  unint64_t v93;
  _BYTE v94[24];
  __int128 v95;
  ValueMetadata *v96;
  unint64_t v97;

  v3 = v2;
  v4 = v1;
  v86 = a1;
  v87 = type metadata accessor for DNSRecords.SRV(0);
  __chkstk_darwin();
  v6 = (char *)&v81 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = type metadata accessor for AWDLActionFrame.ServiceResponse(0);
  __chkstk_darwin();
  v9 = (char *)&v81 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  v10 = sub_10001F11C((uint64_t)_swiftEmptyArrayStorage);
  v11 = type metadata accessor for BinaryEncoder();
  v12 = swift_allocObject(v11, 40, 7);
  v91 = xmmword_10033A100;
  *(_OWORD *)(v12 + 16) = xmmword_10033A100;
  v85 = v12 + 16;
  *(_QWORD *)(v12 + 32) = v10;
  v13 = sub_10001F11C((uint64_t)_swiftEmptyArrayStorage);
  v14 = swift_allocObject(v11, 40, 7);
  *(_OWORD *)(v14 + 16) = v91;
  v84 = v14 + 16;
  *(_QWORD *)(v14 + 32) = v13;
  v15 = (_QWORD *)swift_allocObject(&unk_1003E44E8, 56, 7);
  v15[5] = &type metadata for BinaryEncoder.UnkeyedContainer;
  v16 = sub_100079B58();
  *(_QWORD *)&v91 = v12;
  v15[2] = v12;
  v88 = v15 + 2;
  v90 = v15;
  v15[6] = v16;
  sub_100106FE8(v4, (uint64_t)v9);
  EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(v9, v7);
  if (!EnumCaseMultiPayload)
  {
    v89 = v14;
    v28 = *(_QWORD *)v9;
    v27 = *((_QWORD *)v9 + 1);
    v29 = *((_QWORD *)v9 + 2);
    v30 = *((_QWORD *)v9 + 3);
    v31 = v9[32] | (v9[33] << 8);
    v32 = v91;
    swift_retain();
    v33 = (uint64_t)v90;
    sub_100105F00(v29, v30, v31, (uint64_t)v90);
    if (v3)
    {
      swift_release(v33);
      swift_bridgeObjectRelease(v30);
      swift_bridgeObjectRelease(v27);
      swift_release(v32);
      v26 = v89;
      goto LABEL_13;
    }
    v96 = &type metadata for BinaryEncoder.UnkeyedContainer;
    v97 = v16;
    *(_QWORD *)&v95 = v89;
    v40 = v88;
    swift_beginAccess(v88, v94, 1, 0);
    swift_retain();
    sub_100014430(v40);
    sub_1000641F0(&v95, (uint64_t)v40);
    sub_10010591C(v28, v27, v33);
    swift_bridgeObjectRelease(v30);
    swift_bridgeObjectRelease(v27);
    swift_beginAccess(v40, &v95, 33, 0);
    v50 = *(_QWORD *)(v33 + 40);
    v51 = *(_QWORD *)(v33 + 48);
    sub_100034C68((uint64_t)v40, v50);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(192, v50, v51);
    swift_endAccess(&v95);
    swift_beginAccess(v40, &v95, 33, 0);
    v52 = *(_QWORD *)(v33 + 40);
    v53 = *(_QWORD *)(v33 + 48);
    sub_100034C68((uint64_t)v40, v52);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(0, v52, v53);
    swift_endAccess(&v95);
LABEL_14:
    v62 = v86[3];
    v63 = v86[4];
    sub_10003259C(v86, v62);
    dispatch thunk of Encoder.unkeyedContainer()(&v95, v62, v63);
    v64 = v88;
    swift_beginAccess(v88, &v92, 1, 0);
    sub_100014430(v64);
    sub_1000641F0(&v95, (uint64_t)v64);
    swift_beginAccess(v85, &v95, 0, 0);
    __asm { BR              X13 }
  }
  if (EnumCaseMultiPayload != 1)
  {
    sub_100033AC0((uint64_t)v9, (uint64_t)v6, type metadata accessor for DNSRecords.SRV);
    v34 = *(_QWORD *)v6;
    v35 = *((_QWORD *)v6 + 1);
    v36 = v91;
    swift_retain();
    swift_bridgeObjectRetain(v35);
    v37 = (uint64_t)v90;
    sub_10010591C(v34, v35, (uint64_t)v90);
    if (v3)
    {
      sub_100031F1C((uint64_t)v6);
      swift_release(v37);
      swift_release(v36);
      swift_release(v14);
      swift_bridgeObjectRelease(v35);
      return;
    }
    v89 = v14;
    swift_bridgeObjectRelease(v35);
    v41 = *((_QWORD *)v6 + 2);
    v42 = *((_QWORD *)v6 + 3);
    v43 = v6[32] | (v6[33] << 8);
    swift_bridgeObjectRetain(v42);
    sub_100105F00(v41, v42, v43, v37);
    swift_bridgeObjectRelease(v42);
    v96 = &type metadata for BinaryEncoder.UnkeyedContainer;
    v97 = v16;
    *(_QWORD *)&v95 = v89;
    v54 = v88;
    swift_beginAccess(v88, v94, 1, 0);
    swift_retain();
    sub_100014430(v54);
    sub_1000641F0(&v95, (uint64_t)v54);
    v55 = v87;
    v56 = *(unsigned __int16 *)&v6[*(int *)(v87 + 28)];
    swift_beginAccess(v54, &v95, 33, 0);
    v57 = *(_QWORD *)(v37 + 40);
    v58 = *(_QWORD *)(v37 + 48);
    sub_100034C68((uint64_t)v54, v57);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v56, v57, v58);
    swift_endAccess(&v95);
    v59 = *(unsigned __int16 *)&v6[*(int *)(v55 + 32)];
    swift_beginAccess(v54, &v95, 33, 0);
    v60 = *(_QWORD *)(v37 + 40);
    v61 = *(_QWORD *)(v37 + 48);
    sub_100034C68((uint64_t)v54, v60);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v59, v60, v61);
    v65 = swift_endAccess(&v95);
    LOWORD(v95) = bswap32(NWEndpoint.Port.rawValue.getter(v65)) >> 16;
    v66 = sub_1000FADC0((uint64_t)&v95, (uint64_t)&v95 + 2);
    v68 = v67;
    v92 = v66;
    v93 = v67;
    swift_beginAccess(v54, &v95, 33, 0);
    v69 = v37;
    v70 = *(_QWORD *)(v37 + 40);
    v71 = *(_QWORD *)(v37 + 48);
    sub_100034C68((uint64_t)v54, v70);
    v72 = sub_100068570();
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(&v92, &type metadata for Data, v72, v70, v71);
    swift_endAccess(&v95);
    sub_10000E614(v66, v68);
    v73 = (uint64_t *)&v6[*(int *)(v87 + 24)];
    v75 = *v73;
    v74 = v73[1];
    swift_bridgeObjectRetain(v74);
    sub_10010591C(v75, v74, v69);
    swift_bridgeObjectRelease(v74);
    v76 = (uint64_t)v88;
    swift_beginAccess(v88, &v95, 33, 0);
    v77 = *(_QWORD *)(v69 + 40);
    v78 = *(_QWORD *)(v69 + 48);
    sub_100034C68(v76, v77);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(192, v77, v78);
    swift_endAccess(&v95);
    swift_beginAccess(v76, &v95, 33, 0);
    v79 = *(_QWORD *)(v69 + 40);
    v80 = *(_QWORD *)(v69 + 48);
    sub_100034C68(v76, v79);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(12, v79, v80);
    swift_endAccess(&v95);
    sub_100031F1C((uint64_t)v6);
    goto LABEL_12;
  }
  v89 = v14;
  v18 = *(_QWORD *)v9;
  v19 = *((_QWORD *)v9 + 1);
  v83 = *((_QWORD *)v9 + 2);
  v87 = *((_QWORD *)v9 + 3);
  v20 = v9[32];
  v21 = v9[33];
  v23 = *((_QWORD *)v9 + 5);
  v22 = *((_QWORD *)v9 + 6);
  v24 = v91;
  swift_retain();
  swift_bridgeObjectRetain(v19);
  v25 = (uint64_t)v90;
  sub_10010591C(v18, v19, (uint64_t)v90);
  if (!v3)
  {
    v81 = v23;
    v82 = v22;
    swift_bridgeObjectRelease(v19);
    v38 = v87;
    swift_bridgeObjectRetain(v87);
    sub_100105F00(v83, v38, v20 | (v21 << 8), v25);
    v39 = v25;
    swift_bridgeObjectRelease(v38);
    v96 = &type metadata for BinaryEncoder.UnkeyedContainer;
    v97 = v16;
    *(_QWORD *)&v95 = v89;
    v44 = v88;
    swift_beginAccess(v88, v94, 1, 0);
    swift_retain();
    sub_100014430(v44);
    sub_1000641F0(&v95, (uint64_t)v44);
    v45 = v81;
    v46 = v82;
    v92 = v81;
    v93 = v82;
    swift_beginAccess(v44, &v95, 33, 0);
    v47 = *(_QWORD *)(v25 + 40);
    v48 = *(_QWORD *)(v25 + 48);
    sub_100034C68((uint64_t)v44, *(_QWORD *)(v39 + 40));
    sub_100031FEC(v45, v46);
    v49 = sub_100068570();
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(&v92, &type metadata for Data, v49, v47, v48);
    swift_endAccess(&v95);
    swift_bridgeObjectRelease(v87);
    swift_bridgeObjectRelease(v19);
    sub_10000E614(v45, v46);
    sub_10000E614(v45, v46);
LABEL_12:
    v32 = v91;
    goto LABEL_14;
  }
  swift_bridgeObjectRelease(v87);
  swift_bridgeObjectRelease_n(v19, 2);
  swift_release(v24);
  swift_release(v89);
  sub_10000E614(v23, v22);
  v26 = v25;
LABEL_13:
  swift_release(v26);
}

void sub_1000FEBE4(uint64_t a1, unint64_t a2)
{
  swift_bridgeObjectRetain(a2);
  sub_1000FAE78(a1, a2);
  __asm { BR              X10 }
}

uint64_t sub_1000FEC40@<X0>(int a1@<W8>)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (BYTE6(v2) < 0x40uLL)
  {
    if (!a1)
      goto LABEL_10;
    if (a1 == 1)
    {
      if (!__OFSUB__(HIDWORD(v1), (_DWORD)v1))
      {
        v3 = HIDWORD(v1) - (int)v1;
        goto LABEL_8;
      }
      __break(1u);
    }
    else
    {
      v5 = *(_QWORD *)(v1 + 16);
      v4 = *(_QWORD *)(v1 + 24);
      v3 = v4 - v5;
      if (!__OFSUB__(v4, v5))
      {
LABEL_8:
        if ((v3 & 0x8000000000000000) == 0)
        {
          if (v3 < 0x100)
          {
LABEL_10:
            sub_1000FB8F8();
            sub_100031FEC(v1, v2);
            sub_1000FBDAC(v1, v2);
            sub_10000E614(v1, v2);
            return sub_10000E614(v1, v2);
          }
          _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 3455, 0);
LABEL_16:
          __break(1u);
          JUMPOUT(0x1000FED88);
        }
LABEL_14:
        _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 3451, 0);
        goto LABEL_16;
      }
    }
    __break(1u);
    goto LABEL_14;
  }
  return sub_10000E614(v1, v2);
}

uint64_t DNSRecords.RecordType.rawValue.getter(char a1)
{
  return word_1003473D4[a1];
}

uint64_t sub_1000FEDAC()
{
  unsigned __int8 *v0;
  uint64_t v1;
  unint64_t v2;
  uint64_t v3;
  unint64_t v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;

  v1 = *((_QWORD *)v0 + 1);
  v2 = *((_QWORD *)v0 + 2);
  v3 = *((_QWORD *)v0 + 3);
  v4 = *((_QWORD *)v0 + 4);
  v5 = v0[40];
  v6 = *v0;
  sub_100107054(v1, v2);
  sub_1000FF4F4(v6, v3, v4, v5);
  v8 = v7;
  v10 = v9;
  sub_1000FBDAC(v7, v9);
  sub_10000E614(v8, v10);
  return 0;
}

uint64_t sub_1000FEE38()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 41);
}

uint64_t sub_1000FEE40()
{
  uint64_t v0;
  uint64_t v1;

  v1 = *(_QWORD *)(v0 + 24);
  swift_bridgeObjectRetain(*(_QWORD *)(v0 + 32));
  return v1;
}

uint64_t DNSRecords.Identifier.domainName.getter()
{
  return 0x6C61636F6CLL;
}

void DNSRecords.BrowseHost.keyData.getter(uint64_t a1, uint64_t a2, unint64_t a3)
{
  sub_100107054(a2, a3);
  __asm { BR              X12 }
}

uint64_t sub_1000FEF10(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, __int16 a10, char a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, unint64_t a19)
{
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v20 = BYTE6(v19);
  v21 = sub_100012C44(&qword_1004066A8);
  a16 = v21;
  a17 = sub_100011770(&qword_1004066B0, &qword_1004066A8, (const char *)&protocol conformance descriptor for <A> CollectionOfOne<A>);
  LOBYTE(a13) = -64;
  a12 = *(_BYTE *)sub_10003259C(&a13, v21);
  Data._Representation.replaceSubrange(_:with:count:)(v20, v20, &a12, 1);
  v22 = sub_100014430(&a13);
  return ((uint64_t (*)(uint64_t))((char *)sub_1000FEFBC + 4 * byte_100346B08[a19 >> 62]))(v22);
}

uint64_t sub_1000FEFBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, __int16 a10, char a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, unint64_t a19)
{
  uint64_t v19;
  uint64_t v20;
  char v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;

  v23 = BYTE6(v19);
  a16 = v20;
  a17 = v22;
  LOBYTE(a13) = 17;
  a12 = *(_BYTE *)sub_10003259C(&a13, v20);
  Data._Representation.replaceSubrange(_:with:count:)(v23, v23, &a12, 1);
  sub_100014430(&a13);
  LOWORD(a13) = word_100347352[v21];
  v24 = sub_1000FADC0((uint64_t)&a13, (uint64_t)&a13 + 2);
  v26 = v25;
  sub_1000FBDAC(v24, v25);
  v27 = sub_10000E614(v24, v26);
  return ((uint64_t (*)(uint64_t))((char *)sub_1000FF074 + 4 * byte_100346B0C[a19 >> 62]))(v27);
}

uint64_t sub_1000FF074()
{
  uint64_t v0;
  char v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char v6;
  _QWORD v7[3];
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v4 = BYTE6(v0);
  v8 = v2;
  v9 = v3;
  LOBYTE(v7[0]) = v1;
  v6 = *(_BYTE *)sub_10003259C(v7, v2);
  Data._Representation.replaceSubrange(_:with:count:)(v4, v4, &v6, 1);
  sub_100014430(v7);
  return v10;
}

void DNSRecords.BrowseHost.hash(into:)(uint64_t a1, char a2, uint64_t a3, uint64_t a4, Swift::UInt8 a5)
{
  Hasher._combine(_:)(word_1003473D4[a2]);
  swift_bridgeObjectRetain(a4);
  String.hash(into:)(a1, a3, a4);
  swift_bridgeObjectRelease(a4);
  Hasher._combine(_:)(a5);
}

BOOL static DNSRecords.BrowseHost.__derived_struct_equals(_:_:)(char a1, uint64_t a2, uint64_t a3, char a4, char a5, uint64_t a6, uint64_t a7, char a8)
{
  char v10;
  _BOOL8 result;

  if (word_1003473D4[a1] != word_1003473D4[a5])
    return 0;
  if (a2 == a6 && a3 == a7)
    return a4 == a8;
  v10 = _stringCompareWithSmolCheck(_:_:expecting:)(a2, a3, a6, a7, 0);
  result = 0;
  if ((v10 & 1) != 0)
    return a4 == a8;
  return result;
}

Swift::Int DNSRecords.BrowseHost.hashValue.getter(char a1, uint64_t a2, uint64_t a3, Swift::UInt8 a4)
{
  _QWORD v9[9];

  Hasher.init(_seed:)(v9);
  Hasher._combine(_:)(word_1003473D4[a1]);
  swift_bridgeObjectRetain(a3);
  String.hash(into:)(v9, a2, a3);
  swift_bridgeObjectRelease(a3);
  Hasher._combine(_:)(a4);
  return Hasher._finalize()();
}

Swift::Int sub_1000FF284()
{
  char *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  Swift::UInt8 v4;
  _QWORD v6[9];

  v1 = *v0;
  v2 = *((_QWORD *)v0 + 1);
  v3 = *((_QWORD *)v0 + 2);
  v4 = v0[24];
  Hasher.init(_seed:)(v6);
  Hasher._combine(_:)(word_1003473D4[v1]);
  swift_bridgeObjectRetain(v3);
  String.hash(into:)(v6, v2, v3);
  swift_bridgeObjectRelease(v3);
  Hasher._combine(_:)(v4);
  return Hasher._finalize()();
}

void sub_1000FF314(uint64_t a1)
{
  char *v1;
  uint64_t v3;
  uint64_t v4;
  Swift::UInt8 v5;

  v3 = *((_QWORD *)v1 + 1);
  v4 = *((_QWORD *)v1 + 2);
  v5 = v1[24];
  Hasher._combine(_:)(word_1003473D4[*v1]);
  swift_bridgeObjectRetain(v4);
  String.hash(into:)(a1, v3, v4);
  swift_bridgeObjectRelease(v4);
  Hasher._combine(_:)(v5);
}

Swift::Int sub_1000FF388()
{
  char *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  Swift::UInt8 v4;
  _QWORD v6[9];

  v1 = *v0;
  v2 = *((_QWORD *)v0 + 1);
  v3 = *((_QWORD *)v0 + 2);
  v4 = v0[24];
  Hasher.init(_seed:)(v6);
  Hasher._combine(_:)(word_1003473D4[v1]);
  swift_bridgeObjectRetain(v3);
  String.hash(into:)(v6, v2, v3);
  swift_bridgeObjectRelease(v3);
  Hasher._combine(_:)(v4);
  return Hasher._finalize()();
}

BOOL sub_1000FF414(char *a1, char *a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  char v11;
  _BOOL8 result;

  if (word_1003473D4[*a1] != word_1003473D4[*a2])
    return 0;
  v4 = *((_QWORD *)a1 + 1);
  v5 = *((_QWORD *)a1 + 2);
  v6 = a1[24];
  v7 = *((_QWORD *)a2 + 1);
  v8 = *((_QWORD *)a2 + 2);
  v9 = a2[24];
  if (v4 == v7 && v5 == v8)
    return v6 == v9;
  v11 = _stringCompareWithSmolCheck(_:_:expecting:)(v4, v5, v7, v8, 0);
  result = 0;
  if ((v11 & 1) != 0)
    return v6 == v9;
  return result;
}

uint64_t DNSRecords.PTR.instanceName.setter(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  uint64_t result;

  result = swift_bridgeObjectRelease(v2[1]);
  *v2 = a1;
  v2[1] = a2;
  return result;
}

uint64_t NANInternetSharingStatistics.submitted.getter(uint64_t a1, uint64_t a2, char a3)
{
  return a3 & 1;
}

uint64_t DNSRecords.Identifier.protocolType.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 16) = result & 1;
  return result;
}

uint64_t DNSRecords.Identifier.version.getter(uint64_t a1, uint64_t a2, __int16 a3)
{
  return HIBYTE(a3);
}

CoreP2P::DNSRecords::Identifier __swiftcall DNSRecords.Identifier.init(serviceName:protocolType:version:)(Swift::String serviceName, CoreP2P::Layer3Protocol protocolType, Swift::UInt8 version)
{
  __int16 v3;
  CoreP2P::DNSRecords::Identifier result;

  v3 = protocolType & 1 | (version << 8);
  result.serviceName = serviceName;
  result.protocolType = v3;
  result.version = HIBYTE(v3);
  return result;
}

void sub_1000FF4F4(uint64_t a1, uint64_t a2, unint64_t a3, char a4)
{
  sub_100107054(a2, a3);
  if ((a4 & 1) == 0)
    __asm { BR              X12 }
  __asm { BR              X12 }
}

uint64_t sub_1000FF590(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, __int16 a10, char a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, unint64_t a19)
{
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v20 = BYTE6(v19);
  v21 = sub_100012C44(&qword_1004066A8);
  a16 = v21;
  a17 = sub_100011770(&qword_1004066B0, &qword_1004066A8, (const char *)&protocol conformance descriptor for <A> CollectionOfOne<A>);
  LOBYTE(a13) = -64;
  a12 = *(_BYTE *)sub_10003259C(&a13, v21);
  Data._Representation.replaceSubrange(_:with:count:)(v20, v20, &a12, 1);
  v22 = sub_100014430(&a13);
  return ((uint64_t (*)(uint64_t))((char *)sub_1000FF6E8 + 4 * byte_100346B14[a19 >> 62]))(v22);
}

void sub_1000FF598(uint64_t a1@<X8>)
{
  uint64_t v1;
  char v2;
  _QWORD v3[3];
  uint64_t v4;
  uint64_t v5;

  v1 = a1 >> 32;
  v4 = sub_100012C44(&qword_1004066A8);
  v5 = sub_100011770(&unk_1004066B0, &qword_1004066A8, &protocol conformance descriptor for <A> CollectionOfOne<A>);
  LOBYTE(v3[0]) = -64;
  v2 = *(_BYTE *)sub_10003259C(v3, v4);
  Data._Representation.replaceSubrange(_:with:count:)(v1, v1, &v2, 1);
  sub_100014430(v3);
  __asm { BR              X12 }
}

uint64_t sub_1000FF63C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, __int16 a10, char a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, unint64_t a19)
{
  uint64_t v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;

  v23 = BYTE6(v19);
  a16 = v21;
  a17 = v22;
  LOBYTE(a13) = 12;
  a12 = *(_BYTE *)sub_10003259C(&a13, v21);
  Data._Representation.replaceSubrange(_:with:count:)(v23, v23, &a12, 1);
  sub_100014430(&a13);
  LOWORD(a13) = word_100347352[v20];
  v24 = sub_1000FADC0((uint64_t)&a13, (uint64_t)&a13 + 2);
  v26 = v25;
  sub_1000FBDAC(v24, v25);
  v27 = sub_10000E614(v24, v26);
  return ((uint64_t (*)(uint64_t))((char *)sub_1000FF7BC + 4 * byte_100346B20[a19 >> 62]))(v27);
}

uint64_t sub_1000FF644@<X0>(uint64_t a1@<X8>, int a2, __int16 a3, char a4, char a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, unint64_t a12)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v12 = a1 >> 32;
  v13 = sub_100012C44(&qword_1004066A8);
  a9 = v13;
  a10 = sub_100011770(&unk_1004066B0, &qword_1004066A8, &protocol conformance descriptor for <A> CollectionOfOne<A>);
  LOBYTE(a6) = -64;
  a5 = *(_BYTE *)sub_10003259C(&a6, v13);
  Data._Representation.replaceSubrange(_:with:count:)(v12, v12, &a5, 1);
  v14 = sub_100014430(&a6);
  return ((uint64_t (*)(uint64_t))((char *)sub_1000FF6E8 + 4 * byte_100346B14[a12 >> 62]))(v14);
}

void sub_1000FF6E8()
{
  JUMPOUT(0x1000FF71CLL);
}

void sub_1000FF6F0()
{
  JUMPOUT(0x1000FF71CLL);
}

void sub_1000FF708()
{
  JUMPOUT(0x1000FF71CLL);
}

uint64_t sub_1000FF7BC()
{
  uint64_t v0;
  __int16 v1;
  uint64_t v2;
  char v4;
  _QWORD v5[3];
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = BYTE6(v0);
  v6 = sub_100012C44(&qword_1004066A8);
  v7 = sub_100011770(&qword_1004066B0, &qword_1004066A8, (const char *)&protocol conformance descriptor for <A> CollectionOfOne<A>);
  LOBYTE(v5[0]) = HIBYTE(v1);
  v4 = *(_BYTE *)sub_10003259C(v5, v6);
  Data._Representation.replaceSubrange(_:with:count:)(v2, v2, &v4, 1);
  sub_100014430(v5);
  return v8;
}

void DNSRecords.Identifier.keyData.getter(uint64_t a1, unint64_t a2, char a3)
{
  sub_1000FF4F4(11, a1, a2, a3 & 1);
}

uint64_t DNSRecords.PTR.type.getter()
{
  return 11;
}

void __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> DNSRecords.Identifier.description.getter(uint64_t a1, uint64_t a2, char a3)
{
  Swift::String v4;
  uint64_t v5;
  unint64_t v6;
  Swift::String v7;
  Swift::String v8;

  swift_bridgeObjectRetain(a2);
  v4._countAndFlagsBits = 24366;
  v4._object = (void *)0xE200000000000000;
  String.append(_:)(v4);
  if ((a3 & 1) != 0)
    v5 = 7365749;
  else
    v5 = 7365492;
  v6 = 0xE300000000000000;
  String.append(_:)(*(Swift::String *)&v5);
  swift_bridgeObjectRelease(0xE300000000000000);
  v7._countAndFlagsBits = 46;
  v7._object = (void *)0xE100000000000000;
  String.append(_:)(v7);
  v8._countAndFlagsBits = 0x6C61636F6CLL;
  v8._object = (void *)0xE500000000000000;
  String.append(_:)(v8);
}

void DNSRecords.Identifier.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3, __int16 a4)
{
  Swift::String v6;
  uint64_t v7;

  v6 = String.lowercased()();
  String.hash(into:)(a1, v6._countAndFlagsBits, v6._object);
  swift_bridgeObjectRelease(v6._object);
  if ((a4 & 1) != 0)
    v7 = 7365749;
  else
    v7 = 7365492;
  String.hash(into:)(a1, v7, 0xE300000000000000);
  swift_bridgeObjectRelease(0xE300000000000000);
  Hasher._combine(_:)(HIBYTE(a4));
}

uint64_t sub_1000FF9B4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t result;

  sub_100016ED8((uint64_t)&off_1003D6EF8);
  v1 = v0;
  result = swift_arrayDestroy(&unk_1003D6F18, 11, &type metadata for DNSRecords.Identifier);
  static DNSRecords.Identifier.allKnownIdentifiers = v1;
  return result;
}

const char *DNSRecords.Identifier.airdrop.unsafeMutableAddressor()
{
  return "_airdrop";
}

const char *DNSRecords.Identifier.airplay.unsafeMutableAddressor()
{
  return "_airplay";
}

const char *DNSRecords.Identifier.raop.unsafeMutableAddressor()
{
  return "_raop";
}

const char *DNSRecords.Identifier.airplayP2P.unsafeMutableAddressor()
{
  return "_airplay-p2p";
}

const char *DNSRecords.Identifier.assistedDiscovery.unsafeMutableAddressor()
{
  return "_wifid";
}

void *DNSRecords.Identifier.companionLink.unsafeMutableAddressor()
{
  return &static DNSRecords.Identifier.companionLink;
}

const char *DNSRecords.Identifier.remoteDisplay.unsafeMutableAddressor()
{
  return "_rdlink";
}

const char *DNSRecords.Identifier.dfsMonitoring.unsafeMutableAddressor()
{
  return "_dfsMon";
}

const char *DNSRecords.Identifier.timeSync.unsafeMutableAddressor()
{
  return "_ieee1588";
}

const char *DNSRecords.Identifier.atpAWDLService.unsafeMutableAddressor()
{
  return "_atp";
}

const char *DNSRecords.Identifier.testAWDLService.unsafeMutableAddressor()
{
  return "_test";
}

uint64_t *DNSRecords.Identifier.allKnownIdentifiers.unsafeMutableAddressor()
{
  if (qword_100403F60 != -1)
    swift_once(&qword_100403F60, sub_1000FF9B4);
  return &static DNSRecords.Identifier.allKnownIdentifiers;
}

uint64_t static DNSRecords.Identifier.allKnownIdentifiers.getter()
{
  return sub_10006998C(&qword_100403F60, &static DNSRecords.Identifier.allKnownIdentifiers);
}

uint64_t DNSRecords.Identifier.service.getter(uint64_t a1, uint64_t a2)
{
  swift_bridgeObjectRetain(a2);
  return a1;
}

void *DNSRecords.defaultVersion.unsafeMutableAddressor()
{
  return &static DNSRecords.defaultVersion;
}

uint64_t static DNSRecords.Identifier.dfsMonitoring.getter()
{
  return 0x6E6F4D7366645FLL;
}

uint64_t static DNSRecords.Identifier.atpAWDLService.getter()
{
  return 1886675295;
}

uint64_t static DNSRecords.Identifier.testAWDLService.getter()
{
  return 0x747365745FLL;
}

uint64_t static DNSRecords.Identifier.airdrop.getter()
{
  return 0x706F72647269615FLL;
}

uint64_t static DNSRecords.Identifier.airplay.getter()
{
  return 0x79616C707269615FLL;
}

uint64_t static DNSRecords.Identifier.raop.getter()
{
  return 0x706F61725FLL;
}

uint64_t static DNSRecords.Identifier.airplayP2P.getter()
{
  return 0x79616C707269615FLL;
}

uint64_t static DNSRecords.Identifier.assistedDiscovery.getter()
{
  return 0x64696669775FLL;
}

uint64_t static DNSRecords.Identifier.companionLink.getter()
{
  return 0x696E61706D6F635FLL;
}

uint64_t static DNSRecords.Identifier.remoteDisplay.getter()
{
  return 0x6B6E696C64725FLL;
}

uint64_t static DNSRecords.Identifier.timeSync.getter()
{
  return 0x383531656565695FLL;
}

const char *DNSRecords.Identifier.googlecast.unsafeMutableAddressor()
{
  return "_googlecast";
}

uint64_t static DNSRecords.Identifier.googlecast.getter()
{
  return 0x63656C676F6F675FLL;
}

uint64_t sub_1000FFC90()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t result;

  sub_100016ED8((uint64_t)&off_1003D7020);
  v1 = v0;
  result = swift_arrayDestroy(&unk_1003D7040, 1, &type metadata for DNSRecords.Identifier);
  static DNSRecords.Identifier.deniedList = v1;
  return result;
}

uint64_t *DNSRecords.Identifier.deniedList.unsafeMutableAddressor()
{
  if (qword_100403F68 != -1)
    swift_once(&qword_100403F68, sub_1000FFC90);
  return &static DNSRecords.Identifier.deniedList;
}

uint64_t static DNSRecords.Identifier.deniedList.getter()
{
  return sub_10006998C(&qword_100403F68, &static DNSRecords.Identifier.deniedList);
}

Swift::Int DNSRecords.Identifier.hashValue.getter(uint64_t a1, uint64_t a2, __int16 a3)
{
  Swift::String v4;
  uint64_t v5;
  _QWORD v7[9];

  Hasher.init(_seed:)(v7);
  v4 = String.lowercased()();
  String.hash(into:)(v7, v4._countAndFlagsBits, v4._object);
  swift_bridgeObjectRelease(v4._object);
  if ((a3 & 1) != 0)
    v5 = 7365749;
  else
    v5 = 7365492;
  String.hash(into:)(v7, v5, 0xE300000000000000);
  swift_bridgeObjectRelease(0xE300000000000000);
  Hasher._combine(_:)(HIBYTE(a3));
  return Hasher._finalize()();
}

Swift::Int sub_1000FFDE0()
{
  uint64_t v0;
  int v1;
  Swift::UInt8 v2;
  Swift::String v3;
  uint64_t v4;
  _QWORD v6[9];

  v1 = *(unsigned __int8 *)(v0 + 16);
  v2 = *(_BYTE *)(v0 + 17);
  Hasher.init(_seed:)(v6);
  v3 = String.lowercased()();
  String.hash(into:)(v6, v3._countAndFlagsBits, v3._object);
  swift_bridgeObjectRelease(v3._object);
  if (v1)
    v4 = 7365749;
  else
    v4 = 7365492;
  String.hash(into:)(v6, v4, 0xE300000000000000);
  swift_bridgeObjectRelease(0xE300000000000000);
  Hasher._combine(_:)(v2);
  return Hasher._finalize()();
}

void sub_1000FFE90(uint64_t a1)
{
  uint64_t v1;
  int v3;
  Swift::UInt8 v4;
  Swift::String v5;
  uint64_t v6;

  v3 = *(unsigned __int8 *)(v1 + 16);
  v4 = *(_BYTE *)(v1 + 17);
  v5 = String.lowercased()();
  String.hash(into:)(a1, v5._countAndFlagsBits, v5._object);
  swift_bridgeObjectRelease(v5._object);
  if (v3)
    v6 = 7365749;
  else
    v6 = 7365492;
  String.hash(into:)(a1, v6, 0xE300000000000000);
  swift_bridgeObjectRelease(0xE300000000000000);
  Hasher._combine(_:)(v4);
}

Swift::Int sub_1000FFF18()
{
  uint64_t v0;
  int v1;
  Swift::UInt8 v2;
  Swift::String v3;
  uint64_t v4;
  _QWORD v6[9];

  v1 = *(unsigned __int8 *)(v0 + 16);
  v2 = *(_BYTE *)(v0 + 17);
  Hasher.init(_seed:)(v6);
  v3 = String.lowercased()();
  String.hash(into:)(v6, v3._countAndFlagsBits, v3._object);
  swift_bridgeObjectRelease(v3._object);
  if (v1)
    v4 = 7365749;
  else
    v4 = 7365492;
  String.hash(into:)(v6, v4, 0xE300000000000000);
  swift_bridgeObjectRelease(0xE300000000000000);
  Hasher._combine(_:)(v2);
  return Hasher._finalize()();
}

void sub_1000FFFC4()
{
  uint64_t v0;

  sub_1000FF4F4(11, *(_QWORD *)v0, *(_QWORD *)(v0 + 8), *(_BYTE *)(v0 + 16));
}

uint64_t sub_1000FFFDC()
{
  uint64_t *v0;
  uint64_t v1;

  v1 = *v0;
  swift_bridgeObjectRetain(v0[1]);
  return v1;
}

uint64_t sub_100100020()
{
  uint64_t *v0;
  int v1;
  Swift::String v2;
  uint64_t v3;
  unint64_t v4;
  Swift::String v5;
  Swift::String v6;
  uint64_t v8;

  v1 = *((unsigned __int8 *)v0 + 16);
  v8 = *v0;
  swift_bridgeObjectRetain(v0[1]);
  v2._countAndFlagsBits = 24366;
  v2._object = (void *)0xE200000000000000;
  String.append(_:)(v2);
  if (v1)
    v3 = 7365749;
  else
    v3 = 7365492;
  v4 = 0xE300000000000000;
  String.append(_:)(*(Swift::String *)&v3);
  swift_bridgeObjectRelease(0xE300000000000000);
  v5._countAndFlagsBits = 46;
  v5._object = (void *)0xE100000000000000;
  String.append(_:)(v5);
  v6._countAndFlagsBits = 0x6C61636F6CLL;
  v6._object = (void *)0xE500000000000000;
  String.append(_:)(v6);
  return v8;
}

BOOL sub_1001000B4(uint64_t a1, uint64_t a2)
{
  return sub_100106584(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), *(unsigned __int8 *)(a1 + 16) | (*(unsigned __int8 *)(a1 + 17) << 8), *(_QWORD *)a2, *(_QWORD *)(a2 + 8), *(unsigned __int8 *)(a2 + 16) | (*(unsigned __int8 *)(a2 + 17) << 8));
}

uint64_t MutableDriverProperty.name.getter()
{
  uint64_t *v0;
  uint64_t v1;

  v1 = *v0;
  swift_bridgeObjectRetain(v0[1]);
  return v1;
}

uint64_t DNSRecords.SRV.service.getter()
{
  uint64_t v0;
  uint64_t v1;

  v1 = *(_QWORD *)(v0 + 16);
  swift_bridgeObjectRetain(*(_QWORD *)(v0 + 24));
  return v1;
}

uint64_t DNSRecords.PTR.identifier.setter(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  char v4;
  unsigned int v7;
  uint64_t result;

  v4 = a3;
  v7 = a3 >> 8;
  result = swift_bridgeObjectRelease(*(_QWORD *)(v3 + 24));
  *(_QWORD *)(v3 + 16) = a1;
  *(_QWORD *)(v3 + 24) = a2;
  *(_BYTE *)(v3 + 32) = v4 & 1;
  *(_BYTE *)(v3 + 33) = v7;
  return result;
}

uint64_t DNSRecords.PTR.description.getter()
{
  __int128 *v0;
  Swift::String v1;
  void *object;
  Swift::String v3;
  uint64_t v4;
  unint64_t v5;
  Swift::String v6;
  Swift::String v7;
  Swift::String v9;
  uint64_t v10;
  Swift::String v11;
  __int16 v12;
  __int128 v13;

  v13 = *v0;
  v10 = v13;
  sub_100031ECC((uint64_t)&v13);
  v1._countAndFlagsBits = 46;
  v1._object = (void *)0xE100000000000000;
  String.append(_:)(v1);
  v11 = (Swift::String)v0[1];
  v12 = *((_WORD *)v0 + 16);
  object = v11._object;
  v9 = v11;
  sub_100031ECC((uint64_t)&v11);
  swift_bridgeObjectRetain(object);
  v3._countAndFlagsBits = 24366;
  v3._object = (void *)0xE200000000000000;
  String.append(_:)(v3);
  if ((_BYTE)v12)
    v4 = 7365749;
  else
    v4 = 7365492;
  v5 = 0xE300000000000000;
  String.append(_:)(*(Swift::String *)&v4);
  swift_bridgeObjectRelease(0xE300000000000000);
  v6._countAndFlagsBits = 46;
  v6._object = (void *)0xE100000000000000;
  String.append(_:)(v6);
  v7._countAndFlagsBits = 0x6C61636F6CLL;
  v7._object = (void *)0xE500000000000000;
  String.append(_:)(v7);
  String.append(_:)(v9);
  swift_bridgeObjectRelease(v9._object);
  sub_100031EF4((uint64_t)&v11);
  return v10;
}

uint64_t DNSRecords.PTR.hash(into:)(uint64_t a1)
{
  uint64_t v1;
  Swift::String v3;
  Swift::String v4;
  uint64_t v5;
  __int128 v7;
  Swift::UInt8 v8[16];

  v3 = String.lowercased()();
  String.hash(into:)(a1, v3._countAndFlagsBits, v3._object);
  swift_bridgeObjectRelease(v3._object);
  v7 = *(_OWORD *)(v1 + 16);
  *(_WORD *)v8 = *(_WORD *)(v1 + 32);
  v4 = String.lowercased()();
  swift_bridgeObjectRetain(*((_QWORD *)&v7 + 1));
  String.hash(into:)(a1, v4._countAndFlagsBits, v4._object);
  swift_bridgeObjectRelease(v4._object);
  if (v8[0])
    v5 = 7365749;
  else
    v5 = 7365492;
  String.hash(into:)(a1, v5, 0xE300000000000000);
  swift_bridgeObjectRelease(0xE300000000000000);
  Hasher._combine(_:)(v8[1]);
  return sub_100031EF4((uint64_t)&v7);
}

Swift::Int DNSRecords.PTR.hashValue.getter()
{
  uint64_t v0;
  Swift::String v1;
  uint64_t v2;
  Swift::String v3;
  uint64_t v4;
  _QWORD v6[9];
  __int128 v7;
  __int16 v8;

  Hasher.init(_seed:)(v6);
  v1 = String.lowercased()();
  String.hash(into:)(v6, v1._countAndFlagsBits, v1._object);
  swift_bridgeObjectRelease(v1._object);
  v7 = *(_OWORD *)(v0 + 16);
  v8 = *(_WORD *)(v0 + 32);
  v2 = *((_QWORD *)&v7 + 1);
  v3 = String.lowercased()();
  swift_bridgeObjectRetain(v2);
  String.hash(into:)(v6, v3._countAndFlagsBits, v3._object);
  swift_bridgeObjectRelease(v3._object);
  if ((_BYTE)v8)
    v4 = 7365749;
  else
    v4 = 7365492;
  String.hash(into:)(v6, v4, 0xE300000000000000);
  swift_bridgeObjectRelease(0xE300000000000000);
  Hasher._combine(_:)(HIBYTE(v8));
  sub_100031EF4((uint64_t)&v7);
  return Hasher._finalize()();
}

uint64_t sub_10010045C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  int v4;
  Swift::UInt8 v5;
  Swift::String v6;
  Swift::String v7;
  uint64_t v8;

  v3 = *(_QWORD *)(v1 + 24);
  v4 = *(unsigned __int8 *)(v1 + 32);
  v5 = *(_BYTE *)(v1 + 33);
  v6 = String.lowercased()();
  String.hash(into:)(a1, v6._countAndFlagsBits, v6._object);
  swift_bridgeObjectRelease(v6._object);
  v7 = String.lowercased()();
  swift_bridgeObjectRetain(v3);
  String.hash(into:)(a1, v7._countAndFlagsBits, v7._object);
  swift_bridgeObjectRelease(v7._object);
  if (v4)
    v8 = 7365749;
  else
    v8 = 7365492;
  String.hash(into:)(a1, v8, 0xE300000000000000);
  swift_bridgeObjectRelease(0xE300000000000000);
  Hasher._combine(_:)(v5);
  return swift_bridgeObjectRelease(v3);
}

Swift::Int sub_100100528()
{
  uint64_t v0;
  uint64_t v1;
  int v2;
  Swift::UInt8 v3;
  Swift::String v4;
  Swift::String v5;
  uint64_t v6;
  _QWORD v8[9];

  v1 = *(_QWORD *)(v0 + 24);
  v2 = *(unsigned __int8 *)(v0 + 32);
  v3 = *(_BYTE *)(v0 + 33);
  Hasher.init(_seed:)(v8);
  v4 = String.lowercased()();
  String.hash(into:)(v8, v4._countAndFlagsBits, v4._object);
  swift_bridgeObjectRelease(v4._object);
  v5 = String.lowercased()();
  swift_bridgeObjectRetain(v1);
  String.hash(into:)(v8, v5._countAndFlagsBits, v5._object);
  swift_bridgeObjectRelease(v5._object);
  if (v2)
    v6 = 7365749;
  else
    v6 = 7365492;
  String.hash(into:)(v8, v6, 0xE300000000000000);
  swift_bridgeObjectRelease(0xE300000000000000);
  Hasher._combine(_:)(v3);
  swift_bridgeObjectRelease(v1);
  return Hasher._finalize()();
}

BOOL sub_100100620(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  __int16 v5;
  __int16 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int16 v11;
  __int16 v12;
  unint64_t v13;
  _QWORD v16[4];

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  v4 = *(_QWORD *)(a1 + 24);
  v5 = *(unsigned __int8 *)(a1 + 32);
  v6 = *(unsigned __int8 *)(a1 + 33);
  v7 = *a2;
  v8 = a2[1];
  v9 = a2[2];
  v10 = a2[3];
  v11 = *((unsigned __int8 *)a2 + 32);
  v12 = *((unsigned __int8 *)a2 + 33);
  v16[2] = *(_QWORD *)a1;
  v16[3] = v2;
  v16[0] = v7;
  v16[1] = v8;
  v13 = sub_10001C920();
  return !StringProtocol.caseInsensitiveCompare<A>(_:)(v16, &type metadata for String, &type metadata for String, v13, v13)&& sub_100106584(v3, v4, v5 | (v6 << 8), v9, v10, v11 | (v12 << 8));
}

uint64_t DNSRecords.TXT.name.getter@<X0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char v5;
  char v6;

  v2 = *(_QWORD *)(v1 + 8);
  v3 = *(_QWORD *)(v1 + 16);
  v4 = *(_QWORD *)(v1 + 24);
  v5 = *(_BYTE *)(v1 + 32);
  v6 = *(_BYTE *)(v1 + 33);
  *(_QWORD *)a1 = *(_QWORD *)v1;
  *(_QWORD *)(a1 + 8) = v2;
  *(_QWORD *)(a1 + 16) = v3;
  *(_QWORD *)(a1 + 24) = v4;
  *(_BYTE *)(a1 + 32) = v5;
  *(_BYTE *)(a1 + 33) = v6;
  swift_bridgeObjectRetain(v2);
  return swift_bridgeObjectRetain(v4);
}

__n128 DNSRecords.TXT.name.setter(uint64_t a1)
{
  uint64_t v1;
  __n128 result;
  __int128 v4;

  swift_bridgeObjectRelease(*(_QWORD *)(v1 + 8));
  swift_bridgeObjectRelease(*(_QWORD *)(v1 + 24));
  result = *(__n128 *)a1;
  v4 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)v1 = *(_OWORD *)a1;
  *(_OWORD *)(v1 + 16) = v4;
  *(_WORD *)(v1 + 32) = *(_WORD *)(a1 + 32);
  return result;
}

uint64_t DNSRecords.TXT.userInfo.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t result;

  result = sub_10000E614(*(_QWORD *)(v2 + 40), *(_QWORD *)(v2 + 48));
  *(_QWORD *)(v2 + 40) = a1;
  *(_QWORD *)(v2 + 48) = a2;
  return result;
}

uint64_t DNSRecords.TXT.service.getter()
{
  uint64_t v0;
  uint64_t v1;

  v1 = *(_QWORD *)(v0 + 16);
  swift_bridgeObjectRetain(*(_QWORD *)(v0 + 24));
  return v1;
}

uint64_t DNSRecords.TXT.hash(into:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  Swift::String v6;
  Swift::UInt8 v7;
  Swift::String v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  __n128 v12;
  __int128 v14;
  __int16 v15;
  char v16;

  v2 = v1;
  v4 = *(_QWORD *)(v2 + 8);
  v14 = *(_OWORD *)(v2 + 16);
  v15 = *(_WORD *)(v2 + 32);
  v5 = *((_QWORD *)&v14 + 1);
  v6 = String.lowercased()();
  swift_bridgeObjectRetain(v4);
  sub_100031ECC((uint64_t)&v14);
  String.hash(into:)(a1, v6._countAndFlagsBits, v6._object);
  swift_bridgeObjectRelease(v6._object);
  v16 = v15;
  v7 = HIBYTE(v15);
  v8 = String.lowercased()();
  swift_bridgeObjectRetain(v5);
  String.hash(into:)(a1, v8._countAndFlagsBits, v8._object);
  swift_bridgeObjectRelease(v8._object);
  if (v16)
    v9 = 7365749;
  else
    v9 = 7365492;
  String.hash(into:)(a1, v9, 0xE300000000000000);
  swift_bridgeObjectRelease(0xE300000000000000);
  Hasher._combine(_:)(v7);
  sub_100031EF4((uint64_t)&v14);
  swift_bridgeObjectRelease(v4);
  sub_100031EF4((uint64_t)&v14);
  v11 = *(_QWORD *)(v2 + 40);
  v10 = *(_QWORD *)(v2 + 48);
  sub_100031FEC(v11, v10);
  Data.hash(into:)(a1, v11, v10, v12);
  return sub_10000E614(v11, v10);
}

Swift::Int DNSRecords.TXT.hashValue.getter()
{
  _QWORD v1[9];

  Hasher.init(_seed:)(v1);
  DNSRecords.TXT.hash(into:)((uint64_t)v1);
  return Hasher._finalize()();
}

Swift::Int sub_100100958()
{
  _QWORD v1[9];

  Hasher.init(_seed:)(v1);
  DNSRecords.TXT.hash(into:)((uint64_t)v1);
  return Hasher._finalize()();
}

uint64_t sub_100100990()
{
  uint64_t v0;
  uint64_t v1;
  unint64_t v2;
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;

  v1 = *(_QWORD *)(v0 + 16);
  v2 = *(_QWORD *)(v0 + 24);
  v3 = *(_BYTE *)(v0 + 32);
  sub_100107054(*(_QWORD *)v0, *(_QWORD *)(v0 + 8));
  sub_1000FF4F4(15, v1, v2, v3);
  v5 = v4;
  v7 = v6;
  sub_1000FBDAC(v4, v6);
  sub_10000E614(v5, v7);
  return 0;
}

uint64_t sub_100100A10(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  __int16 v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int16 v10;
  __int16 v11;
  unint64_t v12;
  char v13;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD v18[4];

  v2 = *(_QWORD *)(a1 + 8);
  v16 = *(_QWORD *)(a1 + 24);
  v17 = *(_QWORD *)(a1 + 16);
  v15 = *(unsigned __int8 *)(a1 + 32);
  v3 = *(unsigned __int8 *)(a1 + 33);
  v4 = *(_QWORD *)(a1 + 40);
  v5 = *(_QWORD *)(a1 + 48);
  v6 = *a2;
  v7 = a2[1];
  v8 = a2[2];
  v9 = a2[3];
  v10 = *((unsigned __int8 *)a2 + 32);
  v11 = *((unsigned __int8 *)a2 + 33);
  v18[2] = *(_QWORD *)a1;
  v18[3] = v2;
  v18[0] = v6;
  v18[1] = v7;
  v12 = sub_10001C920();
  if (StringProtocol.caseInsensitiveCompare<A>(_:)(v18, &type metadata for String, &type metadata for String, v12, v12)
    || !sub_100106584(v17, v16, v15 | (v3 << 8), v8, v9, v10 | (v11 << 8)))
  {
    v13 = 0;
  }
  else
  {
    _s7CoreP2P6NANPMKV23__derived_struct_equalsySbAC_ACtFZ_0(v4, v5);
  }
  return v13 & 1;
}

uint64_t DNSRecords.SRV.portNumber.getter@<X0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;

  v3 = v1 + *(int *)(type metadata accessor for DNSRecords.SRV(0) + 20);
  v4 = type metadata accessor for NWEndpoint.Port(0);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 - 8) + 16))(a1, v3, v4);
}

uint64_t DNSRecords.SRV.portNumber.setter(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;

  v3 = v1 + *(int *)(type metadata accessor for DNSRecords.SRV(0) + 20);
  v4 = type metadata accessor for NWEndpoint.Port(0);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 - 8) + 40))(v3, a1, v4);
}

uint64_t (*DNSRecords.SRV.portNumber.modify())(_QWORD)
{
  type metadata accessor for DNSRecords.SRV(0);
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t DNSRecords.SRV.hostname.getter()
{
  uint64_t v0;
  uint64_t *v1;
  uint64_t v2;

  v1 = (uint64_t *)(v0 + *(int *)(type metadata accessor for DNSRecords.SRV(0) + 24));
  v2 = *v1;
  swift_bridgeObjectRetain(v1[1]);
  return v2;
}

void DNSRecords.SRV.hostname.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v5;

  v5 = (_QWORD *)(v2 + *(int *)(type metadata accessor for DNSRecords.SRV(0) + 24));
  swift_bridgeObjectRelease(v5[1]);
  *v5 = a1;
  v5[1] = a2;
}

uint64_t (*DNSRecords.SRV.hostname.modify())(_QWORD)
{
  type metadata accessor for DNSRecords.SRV(0);
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t DNSRecords.SRV.weight.getter()
{
  uint64_t v0;

  return *(unsigned __int16 *)(v0 + *(int *)(type metadata accessor for DNSRecords.SRV(0) + 28));
}

uint64_t DNSRecords.SRV.weight.setter(__int16 a1)
{
  uint64_t v1;
  uint64_t result;

  result = type metadata accessor for DNSRecords.SRV(0);
  *(_WORD *)(v1 + *(int *)(result + 28)) = a1;
  return result;
}

uint64_t (*DNSRecords.SRV.weight.modify())(_QWORD)
{
  type metadata accessor for DNSRecords.SRV(0);
  return NANBitmap.Channel.operatingClass.getter;
}

uint64_t DNSRecords.SRV.priority.getter()
{
  uint64_t v0;

  return *(unsigned __int16 *)(v0 + *(int *)(type metadata accessor for DNSRecords.SRV(0) + 32));
}

uint64_t DNSRecords.SRV.priority.setter(__int16 a1)
{
  uint64_t v1;
  uint64_t result;

  result = type metadata accessor for DNSRecords.SRV(0);
  *(_WORD *)(v1 + *(int *)(result + 32)) = a1;
  return result;
}

uint64_t (*DNSRecords.SRV.priority.modify())(_QWORD)
{
  type metadata accessor for DNSRecords.SRV(0);
  return NANBitmap.Channel.operatingClass.getter;
}

void DNSRecords.SRV.hash(into:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  int v6;
  Swift::UInt8 v7;
  Swift::String v8;
  Swift::String v9;
  uint64_t v10;
  int *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;

  v2 = v1;
  v4 = *(_QWORD *)(v1 + 8);
  v5 = *(_QWORD *)(v1 + 24);
  v6 = *(unsigned __int8 *)(v1 + 32);
  v7 = *(_BYTE *)(v1 + 33);
  v8 = String.lowercased()();
  swift_bridgeObjectRetain(v4);
  swift_bridgeObjectRetain(v5);
  String.hash(into:)(a1, v8._countAndFlagsBits, v8._object);
  swift_bridgeObjectRelease(v8._object);
  v9 = String.lowercased()();
  swift_bridgeObjectRetain(v5);
  String.hash(into:)(a1, v9._countAndFlagsBits, v9._object);
  swift_bridgeObjectRelease(v9._object);
  if (v6)
    v10 = 7365749;
  else
    v10 = 7365492;
  String.hash(into:)(a1, v10, 0xE300000000000000);
  swift_bridgeObjectRelease(0xE300000000000000);
  Hasher._combine(_:)(v7);
  swift_bridgeObjectRelease(v4);
  swift_bridgeObjectRelease_n(v5, 2);
  v11 = (int *)type metadata accessor for DNSRecords.SRV(0);
  v12 = type metadata accessor for NWEndpoint.Port(0);
  v13 = sub_100011DE4(&qword_100406108, (uint64_t (*)(uint64_t))&type metadata accessor for NWEndpoint.Port, (uint64_t)&protocol conformance descriptor for NWEndpoint.Port);
  dispatch thunk of Hashable.hash(into:)(a1, v12, v13);
  v14 = (uint64_t *)(v2 + v11[6]);
  v15 = *v14;
  v16 = v14[1];
  swift_bridgeObjectRetain(v16);
  String.hash(into:)(a1, v15, v16);
  swift_bridgeObjectRelease(v16);
  Hasher._combine(_:)(*(_WORD *)(v2 + v11[7]));
  Hasher._combine(_:)(*(_WORD *)(v2 + v11[8]));
}

Swift::Int DNSRecords.SRV.hashValue.getter()
{
  _QWORD v1[9];

  Hasher.init(_seed:)(v1);
  DNSRecords.SRV.hash(into:)((uint64_t)v1);
  return Hasher._finalize()();
}

Swift::Int sub_100100F18()
{
  _QWORD v1[9];

  Hasher.init(_seed:)(v1);
  DNSRecords.SRV.hash(into:)((uint64_t)v1);
  return Hasher._finalize()();
}

uint64_t DNSRecords.AAAA.host.setter(char a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v4;
  uint64_t result;

  result = swift_bridgeObjectRelease(*(_QWORD *)(v4 + 16));
  *(_BYTE *)v4 = a1;
  *(_QWORD *)(v4 + 8) = a2;
  *(_QWORD *)(v4 + 16) = a3;
  *(_BYTE *)(v4 + 24) = a4;
  return result;
}

uint64_t DNSRecords.AAAA.type.getter()
{
  _BYTE *v0;
  uint64_t result;

  if (*v0 == 27)
    return 27;
  __break(1u);
  return result;
}

void DNSRecords.ARPA.hash(into:)(uint64_t a1)
{
  _OWORD *v1;
  _OWORD *v2;
  __int128 v4;
  __int128 v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  __n128 v9;
  _OWORD v10[2];
  __int128 v11;
  _OWORD v12[2];

  v2 = v1;
  *(_OWORD *)((char *)v10 + 9) = *(_OWORD *)((char *)v2 + 9);
  v10[0] = *v2;
  Hasher._combine(_:)(word_1003473D4[SLOBYTE(v10[0])]);
  swift_bridgeObjectRetain(*(_QWORD *)&v10[1]);
  String.hash(into:)(a1, *((_QWORD *)&v10[0] + 1), *(_QWORD *)&v10[1]);
  Hasher._combine(_:)(BYTE8(v10[1]));
  sub_10010702C((uint64_t)v10);
  v4 = v2[3];
  v12[0] = v2[2];
  v12[1] = v4;
  v5 = v4;
  v11 = v12[0];
  swift_bridgeObjectRetain(*((_QWORD *)&v4 + 1));
  v6 = sub_1000FADC0((uint64_t)&v11, (uint64_t)v12);
  v8 = v7;
  Data.hash(into:)(a1, v6, v7, v9);
  sub_10000E614(v6, v8);
  if (*((_QWORD *)&v5 + 1))
  {
    Hasher._combine(_:)(1u);
    swift_bridgeObjectRetain(*((_QWORD *)&v5 + 1));
    String.hash(into:)(a1, v5, *((_QWORD *)&v5 + 1));
    sub_100107208((uint64_t)v12);
    sub_100107208((uint64_t)v12);
  }
  else
  {
    Hasher._combine(_:)(0);
  }
}

uint64_t static DNSRecords.ARPA.__derived_struct_equals(_:_:)(char *a1, char *a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  BOOL v10;

  if (word_1003473D4[*a1] == word_1003473D4[*a2]
    && ((v4 = *((_QWORD *)a1 + 1),
         v5 = *((_QWORD *)a1 + 2),
         v6 = a1[24],
         v7 = *((_QWORD *)a2 + 1),
         v8 = *((_QWORD *)a2 + 2),
         v9 = a2[24],
         v4 == v7)
      ? (v10 = v5 == v8)
      : (v10 = 0),
        (v10 || (_stringCompareWithSmolCheck(_:_:expecting:)(v4, v5, v7, v8, 0) & 1) != 0) && v6 == v9))
  {
    return _s7CoreP2P11IPv6AddressV2eeoiySbAC_ACtFZ_0(*((_QWORD *)a1 + 4), *((_QWORD *)a1 + 5), *((_QWORD *)a1 + 6), *((_QWORD *)a1 + 7), *((_QWORD *)a2 + 4), *((_QWORD *)a2 + 5), *((_QWORD *)a2 + 6), *((_QWORD *)a2 + 7));
  }
  else
  {
    return 0;
  }
}

Swift::Int DNSRecords.ARPA.hashValue.getter()
{
  return sub_1000DE8A0((void (*)(_QWORD *))DNSRecords.ARPA.hash(into:));
}

Swift::Int sub_1001011B8(uint64_t a1, uint64_t a2)
{
  return sub_1000DE8EC(a1, a2, (void (*)(_QWORD *))DNSRecords.ARPA.hash(into:));
}

Swift::Int sub_1001011C8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000D72EC(a1, a2, a3, (void (*)(_QWORD *))DNSRecords.ARPA.hash(into:));
}

uint64_t sub_1001011D4()
{
  uint64_t v0;
  uint64_t v1;
  _QWORD v3[2];
  uint64_t v4;

  v1 = *(_QWORD *)(v0 + 40);
  v3[0] = *(_QWORD *)(v0 + 32);
  v3[1] = v1;
  return sub_1000FADC0((uint64_t)v3, (uint64_t)&v4);
}

uint64_t sub_100101230(char *a1, char *a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (word_1003473D4[*a1] != word_1003473D4[*a2])
    return 0;
  v4 = *((_QWORD *)a1 + 1);
  v5 = *((_QWORD *)a1 + 2);
  v6 = a1[24];
  v8 = *((_QWORD *)a1 + 4);
  v7 = *((_QWORD *)a1 + 5);
  v9 = *((_QWORD *)a1 + 6);
  v10 = *((_QWORD *)a1 + 7);
  v11 = *((_QWORD *)a2 + 1);
  v12 = *((_QWORD *)a2 + 2);
  v13 = a2[24];
  v15 = *((_QWORD *)a2 + 4);
  v14 = *((_QWORD *)a2 + 5);
  v16 = *((_QWORD *)a2 + 6);
  v17 = *((_QWORD *)a2 + 7);
  if ((v4 != v11 || v5 != v12) && (_stringCompareWithSmolCheck(_:_:expecting:)(v4, v5, v11, v12, 0) & 1) == 0)
    return 0;
  if (v6 == v13)
    return _s7CoreP2P11IPv6AddressV2eeoiySbAC_ACtFZ_0(v8, v7, v9, v10, v15, v14, v16, v17);
  else
    return 0;
}

uint64_t DNSRecords.ARPABrowse.ipv6Address.getter()
{
  uint64_t *v0;
  uint64_t v1;

  v1 = *v0;
  swift_bridgeObjectRetain(v0[3]);
  return v1;
}

uint64_t DNSRecords.ARPABrowse.ipv6Address.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v4;
  uint64_t result;

  result = swift_bridgeObjectRelease(v4[3]);
  *v4 = a1;
  v4[1] = a2;
  v4[2] = a3;
  v4[3] = a4;
  return result;
}

uint64_t NANDatapath.Configuration.serviceType.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 32) = result;
  return result;
}

uint64_t DNSRecords.ARPABrowse.keyData.getter()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;

  v4 = *(_QWORD *)(v0 + 24);
  swift_bridgeObjectRetain(v4);
  DNSRecords.ARPA.keyData.getter();
  v2 = v1;
  swift_bridgeObjectRelease(v4);
  swift_bridgeObjectRelease(0xE000000000000000);
  return v2;
}

void DNSRecords.ARPA.keyData.getter()
{
  uint64_t v0;
  __int128 v2;
  _OWORD v3[3];

  v3[2] = xmmword_10033A100;
  v2 = *(_OWORD *)(v0 + 32);
  sub_1000FADC0((uint64_t)&v2, (uint64_t)v3);
  __asm { BR              X9 }
}

uint64_t sub_1001014B4(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
  unsigned int v26;
  unint64_t v27;

  return ((uint64_t (*)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, uint64_t))((char *)&loc_100101604 + *((int *)qword_100101D18 + v26)))(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a2 >> 40, HIDWORD(a2), a2 >> 24, a2 >> 16, a2 >> 8, HIBYTE(v27),
           HIWORD(v27),
           v27 >> 40,
           HIDWORD(v27),
           v27 >> 24,
           v27 >> 16,
           v27 >> 8,
           a26);
}

uint64_t sub_100101618()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;

  if (v1)
  {
    if (__OFSUB__(v1, 1))
    {
      __break(1u);
      JUMPOUT(0x100101A60);
    }
    return ((uint64_t (*)(void))((char *)&loc_10010163C + *((int *)qword_100101D28 + v0)))();
  }
  else
  {
    sub_100107054(3567721, 0xE300000000000000);
    sub_100107054(1634759265, 0xE400000000000000);
    return ((uint64_t (*)(void))((char *)&loc_100101AA8 + *((int *)qword_100101D78 + (*(_QWORD *)(v2 - 104) >> 62))))();
  }
}

uint64_t sub_100101AB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, _BYTE *a13)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;

  v15 = BYTE6(v13);
  v16 = sub_100012C44(&qword_1004066A8);
  *(_QWORD *)(v14 - 136) = v16;
  *(_QWORD *)(v14 - 128) = sub_100011770(&qword_1004066B0, &qword_1004066A8, (const char *)&protocol conformance descriptor for <A> CollectionOfOne<A>);
  *(_BYTE *)(v14 - 160) = 0;
  *(_BYTE *)(v14 - 161) = *(_BYTE *)sub_10003259C((_QWORD *)(v14 - 160), v16);
  Data._Representation.replaceSubrange(_:with:count:)(v15, v15, v14 - 161, 1);
  sub_100014430((_QWORD *)(v14 - 160));
  if (*a13 != 11)
  {
    __break(1u);
    JUMPOUT(0x100101C80);
  }
  *(_WORD *)(v14 - 160) = 3072;
  v17 = sub_1000FADC0(v14 - 160, v14 - 158);
  v19 = v18;
  sub_1000FBDAC(v17, v18);
  v20 = sub_10000E614(v17, v19);
  return ((uint64_t (*)(uint64_t))((char *)&loc_100101BAC
                                          + *((int *)qword_100101D88 + (*(_QWORD *)(v14 - 104) >> 62))))(v20);
}

uint64_t sub_100101AD8@<X0>(uint64_t a1@<X8>, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _BYTE *a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;

  v7 = a1 >> 32;
  v8 = sub_100012C44(&qword_1004066A8);
  *(_QWORD *)(v6 - 136) = v8;
  *(_QWORD *)(v6 - 128) = sub_100011770(&unk_1004066B0, &qword_1004066A8, &protocol conformance descriptor for <A> CollectionOfOne<A>);
  *(_BYTE *)(v6 - 160) = 0;
  *(_BYTE *)(v6 - 161) = *(_BYTE *)sub_10003259C((_QWORD *)(v6 - 160), v8);
  Data._Representation.replaceSubrange(_:with:count:)(v7, v7, v6 - 161, 1);
  sub_100014430((_QWORD *)(v6 - 160));
  if (*a6 != 11)
    JUMPOUT(0x100101C7CLL);
  *(_WORD *)(v6 - 160) = 3072;
  v9 = sub_1000FADC0(v6 - 160, v6 - 158);
  v11 = v10;
  sub_1000FBDAC();
  v12 = sub_10000E614(v9, v11);
  return ((uint64_t (*)(uint64_t))((char *)&loc_100101BAC
                                          + *((int *)qword_100101D88 + (*(_QWORD *)(v6 - 104) >> 62))))(v12);
}

uint64_t sub_100101BBC()
{
  uint64_t v0;
  char v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v8;

  v6 = BYTE6(v0);
  *(_QWORD *)(v5 - 136) = v2;
  *(_QWORD *)(v5 - 128) = v3;
  *(_BYTE *)(v5 - 160) = v1;
  *(_BYTE *)(v5 - 161) = *(_BYTE *)sub_10003259C((_QWORD *)(v5 - 160), v2);
  Data._Representation.replaceSubrange(_:with:count:)(v6, v6, v5 - 161, 1);
  sub_100014430((_QWORD *)(v5 - 160));
  sub_10000E614(v4, v8);
  return *(_QWORD *)(v5 - 112);
}

void DNSRecords.ARPABrowse.hash(into:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  __n128 v9;
  __int128 v10;
  uint64_t v11;

  v2 = v1;
  v10 = *(_OWORD *)v2;
  v4 = *(_QWORD *)(v2 + 16);
  v5 = *(_QWORD *)(v2 + 24);
  swift_bridgeObjectRetain(v5);
  v6 = sub_1000FADC0((uint64_t)&v10, (uint64_t)&v11);
  v8 = v7;
  Data.hash(into:)(a1, v6, v7, v9);
  sub_10000E614(v6, v8);
  if (v5)
  {
    Hasher._combine(_:)(1u);
    swift_bridgeObjectRetain(v5);
    String.hash(into:)(a1, v4, v5);
    sub_100107208(v2);
    sub_100107208(v2);
  }
  else
  {
    Hasher._combine(_:)(0);
  }
  Hasher._combine(_:)(*(_BYTE *)(v2 + 32));
}

BOOL static DNSRecords.ARPABrowse.__derived_struct_equals(_:_:)(uint64_t a1, uint64_t a2)
{
  return (_s7CoreP2P11IPv6AddressV2eeoiySbAC_ACtFZ_0(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)a2, *(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24)) & 1) != 0&& *(unsigned __int8 *)(a1 + 32) == *(unsigned __int8 *)(a2 + 32);
}

Swift::Int DNSRecords.ARPABrowse.hashValue.getter()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  __n128 v7;
  _QWORD v9[9];
  __int128 v10;
  uint64_t v11;

  v1 = v0;
  Hasher.init(_seed:)(v9);
  v10 = *(_OWORD *)v0;
  v2 = *(_QWORD *)(v0 + 16);
  v3 = *(_QWORD *)(v0 + 24);
  swift_bridgeObjectRetain(v3);
  v4 = sub_1000FADC0((uint64_t)&v10, (uint64_t)&v11);
  v6 = v5;
  Data.hash(into:)(v9, v4, v5, v7);
  sub_10000E614(v4, v6);
  if (v3)
  {
    Hasher._combine(_:)(1u);
    swift_bridgeObjectRetain(v3);
    String.hash(into:)(v9, v2, v3);
    sub_100107208(v1);
    sub_100107208(v1);
  }
  else
  {
    Hasher._combine(_:)(0);
  }
  Hasher._combine(_:)(*(_BYTE *)(v1 + 32));
  return Hasher._finalize()();
}

uint64_t sub_100101FF0()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;

  v4 = *(_QWORD *)(v0 + 24);
  swift_bridgeObjectRetain(v4);
  DNSRecords.ARPA.keyData.getter();
  v2 = v1;
  swift_bridgeObjectRelease(v4);
  swift_bridgeObjectRelease(0xE000000000000000);
  return v2;
}

Swift::Int sub_100102070()
{
  return DNSRecords.ARPABrowse.hashValue.getter();
}

void sub_1001020A8(uint64_t a1)
{
  DNSRecords.ARPABrowse.hash(into:)(a1);
}

Swift::Int sub_1001020E0()
{
  uint64_t *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  Swift::UInt8 v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  __n128 v9;
  _QWORD v11[9];
  _QWORD v12[2];
  uint64_t v13;

  v1 = *v0;
  v2 = v0[1];
  v4 = v0[2];
  v3 = v0[3];
  v5 = *((_BYTE *)v0 + 32);
  Hasher.init(_seed:)(v11);
  v12[0] = v1;
  v12[1] = v2;
  swift_bridgeObjectRetain(v3);
  v6 = sub_1000FADC0((uint64_t)v12, (uint64_t)&v13);
  v8 = v7;
  Data.hash(into:)(v11, v6, v7, v9);
  sub_10000E614(v6, v8);
  if (v3)
  {
    Hasher._combine(_:)(1u);
    swift_bridgeObjectRetain(v3);
    String.hash(into:)(v11, v4, v3);
    swift_bridgeObjectRelease_n(v3, 2);
  }
  else
  {
    Hasher._combine(_:)(0);
  }
  Hasher._combine(_:)(v5);
  return Hasher._finalize()();
}

uint64_t sub_1001021E8(uint64_t a1, uint64_t a2)
{
  int v2;
  int v3;

  v2 = *(unsigned __int8 *)(a1 + 32);
  v3 = *(unsigned __int8 *)(a2 + 32);
  return _s7CoreP2P11IPv6AddressV2eeoiySbAC_ACtFZ_0(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)a2, *(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24)) & (v2 == v3);
}

uint64_t _s7CoreP2P10DNSRecordsO4ARPAV4hostAC10BrowseHostVvg_0()
{
  unsigned __int8 *v0;
  uint64_t v1;
  uint64_t v2;

  v1 = *((_QWORD *)v0 + 2);
  v2 = *v0;
  swift_bridgeObjectRetain(v1);
  return v2;
}

uint64_t _s7CoreP2P10DNSRecordsO4ARPAV11ipv6AddressAA04IPv6F0Vvg_0()
{
  uint64_t v0;
  uint64_t v1;

  v1 = *(_QWORD *)(v0 + 32);
  swift_bridgeObjectRetain(*(_QWORD *)(v0 + 56));
  return v1;
}

uint64_t _s7CoreP2P10DNSRecordsO4ARPAV11ipv6AddressAA04IPv6F0Vvs_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v4;
  uint64_t result;

  result = swift_bridgeObjectRelease(v4[7]);
  v4[4] = a1;
  v4[5] = a2;
  v4[6] = a3;
  v4[7] = a4;
  return result;
}

uint64_t DNSRecords.ARPA.type.getter()
{
  _BYTE *v0;
  uint64_t result;

  if (*v0 == 11)
    return 11;
  __break(1u);
  return result;
}

void DNSRecords.ARPA.valueData.getter()
{
  uint64_t v0;

  sub_100107054(*(_QWORD *)(v0 + 8), *(_QWORD *)(v0 + 16));
  __asm { BR              X12 }
}

uint64_t sub_100102374(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, __int16 a10, char a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, unint64_t a19)
{
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v20 = BYTE6(v19);
  v21 = sub_100012C44(&qword_1004066A8);
  a16 = v21;
  a17 = sub_100011770(&qword_1004066B0, &qword_1004066A8, (const char *)&protocol conformance descriptor for <A> CollectionOfOne<A>);
  LOBYTE(a13) = -64;
  a12 = *(_BYTE *)sub_10003259C(&a13, v21);
  Data._Representation.replaceSubrange(_:with:count:)(v20, v20, &a12, 1);
  v22 = sub_100014430(&a13);
  return ((uint64_t (*)(uint64_t))((char *)sub_100102420 + 4 * byte_100346B28[a19 >> 62]))(v22);
}

uint64_t sub_100102420()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v5;
  _QWORD v6[3];
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = BYTE6(v0);
  v7 = v1;
  v8 = v2;
  LOBYTE(v6[0]) = 17;
  v5 = *(_BYTE *)sub_10003259C(v6, v1);
  Data._Representation.replaceSubrange(_:with:count:)(v3, v3, &v5, 1);
  sub_100014430(v6);
  return v9;
}

void sub_1001024B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD v8[12];

  v8[11] = a6;
  v8[7] = a5;
  v6 = type metadata accessor for Data.Deallocator(0);
  v8[4] = *(_QWORD *)(v6 - 8);
  v8[5] = v6;
  __chkstk_darwin();
  v8[6] = (char *)v8 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (qword_100403F70 != -1)
    swift_once(&qword_100403F70, sub_1001055A8);
  __asm { BR              X12 }
}

void sub_1001029D8(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD v4[8];
  uint64_t v5;

  sub_100012C44(&qword_100404E70);
  __chkstk_darwin();
  v5 = type metadata accessor for NWEndpoint.Port(0);
  v4[7] = *(_QWORD *)(v5 - 8);
  __chkstk_darwin();
  v4[6] = (char *)v4 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  __asm { BR              X9 }
}

void sub_100102AB0()
{
  if (qword_100403F70 != -1)
    swift_once(&qword_100403F70, sub_1001055A8);
  __asm { BR              X12 }
}

void sub_1001037D0()
{
  uint64_t v0;
  uint64_t v1;
  char v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (v3 >> 32 >= v0)
  {
    v5 = Data.subdata(in:)(v0, v3 >> 32, v3, v1);
    v7 = v6;
    v8 = *(uint64_t **)(v4 - 256);
    v8[3] = (uint64_t)&type metadata for DNSRecords.TXT;
    v8[4] = (uint64_t)&protocol witness table for DNSRecords.TXT;
    v9 = swift_allocObject(&unk_1003E4C20, 72, 7);
    *v8 = v9;
    swift_release(*(_QWORD *)(v4 - 296));
    v10 = *(_QWORD *)(v4 - 280);
    *(_QWORD *)(v9 + 16) = *(_QWORD *)(v4 - 272);
    *(_QWORD *)(v9 + 24) = v10;
    v11 = *(_QWORD *)(v4 - 304);
    *(_QWORD *)(v9 + 32) = *(_QWORD *)(v4 - 288);
    *(_QWORD *)(v9 + 40) = v11;
    *(_BYTE *)(v9 + 48) = *(_DWORD *)(v4 - 312);
    *(_BYTE *)(v9 + 49) = v2;
    *(_QWORD *)(v9 + 56) = v5;
    *(_QWORD *)(v9 + 64) = v7;
    JUMPOUT(0x100103ADCLL);
  }
  JUMPOUT(0x100103EFCLL);
}

uint64_t sub_10010387C()
{
  uint64_t v0;
  uint64_t v1;
  unint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t result;
  uint64_t (*v18)(void);
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char v32;
  int *v33;
  _QWORD *v34;
  _QWORD *v35;
  __int128 v36;
  _QWORD *v37;
  unint64_t v38;
  uint64_t v39;

  if (v5 >> 32 < v0 || v5 >> 32 < (int)v5)
  {
    __break(1u);
    JUMPOUT(0x100103F04);
  }
  v7 = ((uint64_t (*)(uint64_t))Data._Representation.subscript.getter)(v0);
  v9 = v8;
  v10 = *(_QWORD *)(v6 - 304);
  v11 = sub_100212D04();
  *(_QWORD *)(v6 - 304) = v10;
  if (v10)
  {
    sub_10000E614(v7, v9);
    JUMPOUT(0x100102C34);
  }
  v12 = v11;
  sub_10000E614(v7, v9);
  ((void (*)(_QWORD))NWEndpoint.Port.init(rawValue:))(bswap32(v12) >> 16);
  v13 = *(_QWORD *)(v6 - 280);
  v14 = *(_QWORD *)(v6 - 272);
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v13 + 48))(v1, 1, v14) == 1)
  {
    ((void (*)(uint64_t, void *))sub_100033A84)(v1, &unk_100404E70);
    v15 = sub_100012C84();
    ((void (*)(ValueMetadata *, unint64_t, _QWORD, _QWORD))swift_allocError)(&type metadata for WiFiError, v15, 0, 0);
    *(_OWORD *)v16 = xmmword_100337850;
    *(_BYTE *)(v16 + 16) = 2;
    swift_willThrow();
    return swift_release(v4);
  }
  *(_DWORD *)(v6 - 320) = v3;
  v18 = *(uint64_t (**)(void))(v13 + 32);
  v19 = v13;
  v20 = *(_QWORD *)(v6 - 288);
  v21 = v18();
  ((void (*)(uint64_t))NWEndpoint.Port.rawValue.getter)(v21);
  v22 = sub_1000FBFC4(v0, 2, v5, v2);
  v23 = *(_QWORD *)(v6 - 304);
  v24 = (_QWORD *)((uint64_t (*)(uint64_t, unint64_t, uint64_t))sub_10010402C)(v5, v2, v22);
  if (v23)
  {
    (*(void (**)(uint64_t, uint64_t))(v19 + 8))(v20, v14);
    goto LABEL_21;
  }
  v25 = v24;
  v26 = v24[2];
  if (!v26)
    goto LABEL_17;
  v27 = v24[4];
  v28 = (_QWORD *)v24[5];
  v29 = (uint64_t)&v24[2 * v26 + 4];
  v31 = *(_QWORD *)(v29 - 16);
  v30 = *(_QWORD *)(v29 - 8);
  swift_bridgeObjectRetain(v28);
  swift_bridgeObjectRetain(v30);
  swift_bridgeObjectRelease(v25);
  if (v31 != 0x6C61636F6CLL || v30 != 0xE500000000000000)
  {
    v32 = _stringCompareWithSmolCheck(_:_:expecting:)(v31, v30, 0x6C61636F6CLL, 0xE500000000000000, 0);
    swift_bridgeObjectRelease(v30);
    if ((v32 & 1) != 0)
      goto LABEL_15;
    v24 = v28;
LABEL_17:
    swift_bridgeObjectRelease(v24);
    v38 = sub_100012C84();
    ((void (*)(ValueMetadata *, unint64_t, _QWORD, _QWORD))swift_allocError)(&type metadata for WiFiError, v38, 0, 0);
    *(_OWORD *)v39 = xmmword_100337850;
    *(_BYTE *)(v39 + 16) = 2;
    swift_willThrow();
    (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(v6 - 280) + 8))(*(_QWORD *)(v6 - 288), *(_QWORD *)(v6 - 272));
LABEL_21:
    JUMPOUT(0x100102CA8);
  }
  swift_bridgeObjectRelease(0xE500000000000000);
LABEL_15:
  ((void (*)(_QWORD, _QWORD))sub_100104C30)(*(_QWORD *)(v6 - 296), *(unsigned int *)(v6 - 324));
  v33 = (int *)type metadata accessor for DNSRecords.SRV(0);
  v34 = *(_QWORD **)(v6 - 256);
  v34[3] = v33;
  v34[4] = &protocol witness table for DNSRecords.SRV;
  v35 = sub_100033C24(v34);
  ((void (*)(char *, _QWORD, _QWORD))v18)((char *)v35 + v33[5], *(_QWORD *)(v6 - 288), *(_QWORD *)(v6 - 272));
  result = swift_release(*(_QWORD *)(v6 - 296));
  v36 = *(_OWORD *)(v6 - 152);
  *(_OWORD *)v35 = *(_OWORD *)(v6 - 168);
  *((_OWORD *)v35 + 1) = v36;
  *((_WORD *)v35 + 16) = *(_WORD *)(v6 - 136);
  v37 = (_QWORD *)((char *)v35 + v33[6]);
  *v37 = v27;
  v37[1] = v28;
  *(_WORD *)((char *)v35 + v33[7]) = *(_DWORD *)(v6 - 320);
  *(_WORD *)((char *)v35 + v33[8]) = *(_DWORD *)(v6 - 312);
  return result;
}

void sub_10010402C(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = type metadata accessor for String.Encoding(0);
  __chkstk_darwin(v3);
  __asm { BR              X10 }
}

uint64_t sub_1001040C4()
{
  uint64_t v0;
  uint64_t v1;
  unint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (v3 >= 0 && BYTE6(v2) > v3)
  {
    *(_QWORD *)(v6 - 280) = v0;
    *(_QWORD *)(v6 - 288) = v1;
    *(_QWORD *)(v6 - 136) = BYTE6(v2);
    *(_QWORD *)(v6 - 192) = v4 >> 8;
    *(_QWORD *)(v6 - 128) = _swiftEmptyArrayStorage;
    *(_QWORD *)(v6 - 208) = v4 >> 24;
    *(_QWORD *)(v6 - 200) = v4 >> 16;
    *(_QWORD *)(v6 - 184) = HIDWORD(v4);
    *(_QWORD *)(v6 - 224) = HIWORD(v4);
    *(_QWORD *)(v6 - 216) = v4 >> 40;
    *(_QWORD *)(v6 - 240) = v2 >> 8;
    *(_QWORD *)(v6 - 232) = HIBYTE(v4);
    *(_QWORD *)(v6 - 256) = v2 >> 24;
    *(_QWORD *)(v6 - 248) = v2 >> 16;
    *(_QWORD *)(v6 - 264) = HIDWORD(v2);
    *(_QWORD *)(v6 - 272) = v2 >> 40;
    *(_QWORD *)(v6 - 296) = v3;
    *(_QWORD *)(v6 - 152) = (uint64_t)v4 >> 32;
    *(_QWORD *)(v6 - 144) = v5;
    *(_QWORD *)(v6 - 168) = v5;
    *(_QWORD *)(v6 - 160) = (int)v4;
    *(_QWORD *)(v6 - 176) = v2 & 0x3FFFFFFFFFFFFFFFLL;
    __asm { BR              X9 }
  }
  v7 = sub_100012C84();
  v8 = swift_allocError(&type metadata for WiFiError, v7, 0, 0);
  *(_QWORD *)v9 = 0;
  *(_QWORD *)(v9 + 8) = 0;
  *(_BYTE *)(v9 + 16) = 2;
  swift_willThrow(v8);
  return *(_QWORD *)(v6 - 128);
}

void sub_100104C30(uint64_t a1@<X0>, char a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _BYTE v25[24];

  v6 = (uint64_t *)(a1 + 16);
  swift_beginAccess(a1 + 16, v25, 0, 0);
  v7 = *(_QWORD **)(a1 + 16);
  if (v7[2] != 4)
    goto LABEL_11;
  v8 = v7[10];
  v9 = v7[11];
  if (v8 == 0x6C61636F6CLL && v9 == 0xE500000000000000)
    goto LABEL_9;
  if ((_stringCompareWithSmolCheck(_:_:expecting:)(v8, v9, 0x6C61636F6CLL, 0xE500000000000000, 0) & 1) == 0)
    goto LABEL_11;
  v11 = v7[2];
  if (!v11)
    goto LABEL_11;
  if (v11 >= 3)
  {
LABEL_9:
    v13 = v7[4];
    v12 = v7[5];
    v14 = v7[8];
    v15 = v7[9];
    swift_bridgeObjectRetain(v12);
    swift_bridgeObjectRetain(v15);
    v16 = _s7CoreP2P14Layer3ProtocolO8dnsLabelACSgSS_tcfC_0(v14, v15);
    if (v16 == 2)
    {
      swift_bridgeObjectRelease(v12);
LABEL_11:
      v17 = sub_100012C84();
      v18 = swift_allocError(&type metadata for WiFiError, v17, 0, 0);
      *(_OWORD *)v19 = xmmword_100337850;
      *(_BYTE *)(v19 + 16) = 2;
      swift_willThrow(v18);
      return;
    }
    v20 = v16;
    swift_beginAccess(v6, &v24, 0, 0);
    v21 = *v6;
    if (*(_QWORD *)(*v6 + 16) >= 2uLL)
    {
      v23 = *(_QWORD *)(v21 + 48);
      v22 = *(_QWORD *)(v21 + 56);
      *(_QWORD *)a3 = v13;
      *(_QWORD *)(a3 + 8) = v12;
      *(_QWORD *)(a3 + 16) = v23;
      *(_QWORD *)(a3 + 24) = v22;
      *(_BYTE *)(a3 + 32) = v20 & 1;
      *(_BYTE *)(a3 + 33) = a2;
      swift_bridgeObjectRetain(v22);
      return;
    }
  }
  else
  {
    __break(1u);
  }
  __break(1u);
}

uint64_t DNSRecords.RecordType.description.getter(unsigned __int8 a1)
{
  Swift::String v1;
  void *object;
  Swift::String v3;
  Swift::String v4;
  void *v5;
  Swift::String v6;

  v1._countAndFlagsBits = sub_100104E68(a1);
  object = v1._object;
  String.append(_:)(v1);
  swift_bridgeObjectRelease(object);
  v3._countAndFlagsBits = 91;
  v3._object = (void *)0xE100000000000000;
  String.append(_:)(v3);
  v4._countAndFlagsBits = dispatch thunk of CustomStringConvertible.description.getter(&type metadata for UInt16, &protocol witness table for UInt16);
  v5 = v4._object;
  String.append(_:)(v4);
  swift_bridgeObjectRelease(v5);
  v6._countAndFlagsBits = 10077;
  v6._object = (void *)0xE200000000000000;
  String.append(_:)(v6);
  return 39;
}

uint64_t sub_100104E68(unsigned __int8 a1)
{
  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_100104E9C + 4 * word_100346B2C[a1]))(0x73736572646441, 0xE700000000000000);
}

uint64_t sub_100104E9C()
{
  return 0x7365522D414E4149;
}

unint64_t sub_100104EC0()
{
  return 0xD000000000000028;
}

BOOL sub_100105474(char *a1, char *a2)
{
  return word_1003473D4[*a1] == word_1003473D4[*a2];
}

Swift::Int sub_100105498()
{
  char *v0;
  uint64_t v1;
  _QWORD v3[9];

  v1 = *v0;
  Hasher.init(_seed:)(v3);
  Hasher._combine(_:)(word_1003473D4[v1]);
  return Hasher._finalize()();
}

void sub_1001054E4()
{
  char *v0;

  Hasher._combine(_:)(word_1003473D4[*v0]);
}

Swift::Int sub_100105518()
{
  char *v0;
  uint64_t v1;
  _QWORD v3[9];

  v1 = *v0;
  Hasher.init(_seed:)(v3);
  Hasher._combine(_:)(word_1003473D4[v1]);
  return Hasher._finalize()();
}

uint64_t sub_100105560@<X0>(unsigned __int16 *a1@<X0>, _BYTE *a2@<X8>)
{
  uint64_t result;

  result = _s7CoreP2P10DNSRecordsO10RecordTypeO8rawValueAESgs6UInt16V_tcfC_0(*a1);
  *a2 = result;
  return result;
}

void sub_100105588(_WORD *a1@<X8>)
{
  char *v1;

  *a1 = word_1003473D4[*v1];
}

uint64_t sub_1001055A0()
{
  unsigned __int8 *v0;

  return DNSRecords.RecordType.description.getter(*v0);
}

uint64_t sub_1001055A8()
{
  uint64_t result;
  uint64_t v1;

  result = sub_1001068EC((uint64_t)&off_1003D4958);
  qword_100407D08 = result;
  unk_100407D10 = v1;
  return result;
}

uint64_t sub_1001055D0()
{
  uint64_t result;
  uint64_t v1;

  result = sub_1001068EC((uint64_t)&off_1003D4930);
  qword_100407D18 = result;
  unk_100407D20 = v1;
  return result;
}

void sub_1001055F8()
{
  if (qword_100403F70 != -1)
    swift_once(&qword_100403F70, sub_1001055A8);
  __asm { BR              X10 }
}

uint64_t sub_10010591C(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  _QWORD v19[2];
  _BYTE v20[24];

  v7 = String.count.getter(a1, a2);
  if ((v7 & 0x8000000000000000) != 0)
  {
    result = _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 3451, 0);
LABEL_8:
    __break(1u);
    return result;
  }
  v8 = v7;
  if (v7 >= 0x100)
  {
    result = _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 3455, 0);
    goto LABEL_8;
  }
  v9 = a3 + 16;
  swift_beginAccess(a3 + 16, v20, 33, 0);
  v10 = *(_QWORD *)(a3 + 40);
  v11 = *(_QWORD *)(a3 + 48);
  sub_100034C68(a3 + 16, v10);
  dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v8, v10, v11);
  result = swift_endAccess(v20);
  if (!v3)
  {
    swift_bridgeObjectRetain(a2);
    v13 = sub_1000FAE78(a1, a2);
    v15 = v14;
    v19[0] = v13;
    v19[1] = v14;
    swift_beginAccess(a3 + 16, v20, 33, 0);
    v17 = *(_QWORD *)(a3 + 40);
    v16 = *(_QWORD *)(a3 + 48);
    sub_100034C68(v9, v17);
    v18 = sub_100068570();
    dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(v19, &type metadata for Data, v18, v17, v16);
    swift_endAccess(v20);
    return sub_10000E614(v13, v15);
  }
  return result;
}

uint64_t sub_100105AD8(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3;
  BOOL v5;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _BYTE v21[24];

  v5 = a1 == 0x79616C707269615FLL && a2 == 0xE800000000000000;
  if (v5
    || (_stringCompareWithSmolCheck(_:_:expecting:)(0x79616C707269615FLL, 0xE800000000000000, a1, a2, 0) & 1) != 0)
  {
    v8 = a3 + 16;
    swift_beginAccess(a3 + 16, v21, 33, 0);
    v9 = *(_QWORD *)(a3 + 40);
    v10 = *(_QWORD *)(a3 + 48);
    sub_100034C68(a3 + 16, v9);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(192, v9, v10);
    result = swift_endAccess(v21);
    if (!v3)
    {
      swift_beginAccess(a3 + 16, v21, 33, 0);
      v13 = *(_QWORD *)(a3 + 40);
      v12 = *(_QWORD *)(a3 + 48);
      sub_100034C68(v8, v13);
      v14 = 3;
LABEL_8:
      dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v14, v13, v12);
      return swift_endAccess(v21);
    }
  }
  else if (a1 == 0x706F61725FLL && a2 == 0xE500000000000000
         || (_stringCompareWithSmolCheck(_:_:expecting:)(0x706F61725FLL, 0xE500000000000000, a1, a2, 0) & 1) != 0)
  {
    v15 = a3 + 16;
    swift_beginAccess(a3 + 16, v21, 33, 0);
    v16 = *(_QWORD *)(a3 + 40);
    v17 = *(_QWORD *)(a3 + 48);
    sub_100034C68(a3 + 16, v16);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(192, v16, v17);
    result = swift_endAccess(v21);
    if (!v3)
    {
      swift_beginAccess(a3 + 16, v21, 33, 0);
      v13 = *(_QWORD *)(a3 + 40);
      v12 = *(_QWORD *)(a3 + 48);
      sub_100034C68(v15, v13);
      v14 = 6;
      goto LABEL_8;
    }
  }
  else if (a1 == 0x706F72647269615FLL && a2 == 0xE800000000000000
         || (_stringCompareWithSmolCheck(_:_:expecting:)(0x706F72647269615FLL, 0xE800000000000000, a1, a2, 0) & 1) != 0)
  {
    v18 = a3 + 16;
    swift_beginAccess(a3 + 16, v21, 33, 0);
    v19 = *(_QWORD *)(a3 + 40);
    v20 = *(_QWORD *)(a3 + 48);
    sub_100034C68(a3 + 16, v19);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(192, v19, v20);
    if (!v3)
    {
      swift_endAccess(v21);
      swift_beginAccess(a3 + 16, v21, 33, 0);
      v13 = *(_QWORD *)(a3 + 40);
      v12 = *(_QWORD *)(a3 + 48);
      sub_100034C68(v18, v13);
      v14 = 9;
      goto LABEL_8;
    }
    return swift_endAccess(v21);
  }
  else
  {
    return sub_10010591C(a1, a2, a3);
  }
  return result;
}

uint64_t sub_100105DB0(char a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE v13[24];

  v4 = a2 + 16;
  if ((a1 & 1) != 0)
  {
    swift_beginAccess(v4, v13, 33, 0);
    v11 = *(_QWORD *)(a2 + 40);
    v12 = *(_QWORD *)(a2 + 48);
    sub_100034C68(v4, v11);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(192, v11, v12);
    result = swift_endAccess(v13);
    if (v2)
      return result;
    swift_beginAccess(v4, v13, 33, 0);
    v9 = *(_QWORD *)(a2 + 40);
    v8 = *(_QWORD *)(a2 + 48);
    sub_100034C68(v4, v9);
    v10 = 11;
  }
  else
  {
    swift_beginAccess(v4, v13, 33, 0);
    v5 = *(_QWORD *)(a2 + 40);
    v6 = *(_QWORD *)(a2 + 48);
    sub_100034C68(v4, v5);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(192, v5, v6);
    result = swift_endAccess(v13);
    if (v2)
      return result;
    swift_beginAccess(v4, v13, 33, 0);
    v9 = *(_QWORD *)(a2 + 40);
    v8 = *(_QWORD *)(a2 + 48);
    sub_100034C68(v4, v9);
    v10 = 10;
  }
  dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v10, v9, v8);
  return swift_endAccess(v13);
}

uint64_t sub_100105F00(uint64_t a1, unint64_t a2, __int16 a3, uint64_t a4)
{
  uint64_t v4;
  __int16 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  int v34;

  v9 = a3 & 0xFF01;
  if (sub_100106584(0x79616C707269615FLL, 0xE800000000000000, 256, a1, a2, a3 & 0xFF01)
    || (v34 = a3 & 1,
        v30 = 0x79616C707269615FLL,
        v31 = 0xE800000000000000,
        v32 = a1,
        v33 = a2,
        v17 = sub_10001C920(),
        !StringProtocol.caseInsensitiveCompare<A>(_:)(&v32, &type metadata for String, &type metadata for String, v17, v17))&& (v34|| (_stringCompareWithSmolCheck(_:_:expecting:)(7365749, 0xE300000000000000, 7365492, 0xE300000000000000, 0) & 1) != 0)&& HIBYTE(a3) == 1)
  {
    v10 = a4 + 16;
    swift_beginAccess(a4 + 16, &v30, 33, 0);
    v11 = *(_QWORD *)(a4 + 40);
    v12 = *(_QWORD *)(a4 + 48);
    sub_100034C68(a4 + 16, v11);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(192, v11, v12);
    result = swift_endAccess(&v30);
    if (v4)
      return result;
    swift_beginAccess(a4 + 16, &v30, 33, 0);
    v15 = *(_QWORD *)(a4 + 40);
    v14 = *(_QWORD *)(a4 + 48);
    sub_100034C68(v10, v15);
    v16 = 1;
    goto LABEL_29;
  }
  if (sub_100106584(0x706F61725FLL, 0xE500000000000000, 256, a1, a2, v9))
  {
    v18 = a4 + 16;
    swift_beginAccess(a4 + 16, &v30, 33, 0);
    v19 = *(_QWORD *)(a4 + 40);
    v20 = *(_QWORD *)(a4 + 48);
    sub_100034C68(a4 + 16, v19);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(192, v19, v20);
    if (!v4)
    {
      swift_endAccess(&v30);
      swift_beginAccess(a4 + 16, &v30, 33, 0);
      v15 = *(_QWORD *)(a4 + 40);
      v14 = *(_QWORD *)(a4 + 48);
      sub_100034C68(v18, v15);
      v16 = 4;
LABEL_29:
      dispatch thunk of UnkeyedEncodingContainer.encode(_:)(v16, v15, v14);
      return swift_endAccess(&v30);
    }
    return swift_endAccess(&v30);
  }
  v30 = 0x706F61725FLL;
  v31 = 0xE500000000000000;
  v32 = a1;
  v33 = a2;
  if (!StringProtocol.caseInsensitiveCompare<A>(_:)(&v32, &type metadata for String, &type metadata for String, v17, v17)&& (v34|| (_stringCompareWithSmolCheck(_:_:expecting:)(7365749, 0xE300000000000000, 7365492, 0xE300000000000000, 0) & 1) != 0)&& HIBYTE(a3) == 1)
  {
    v24 = a4 + 16;
    swift_beginAccess(a4 + 16, &v30, 33, 0);
    v25 = *(_QWORD *)(a4 + 40);
    v26 = *(_QWORD *)(a4 + 48);
    sub_100034C68(a4 + 16, v25);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(192, v25, v26);
    if (!v4)
    {
      swift_endAccess(&v30);
      swift_beginAccess(a4 + 16, &v30, 33, 0);
      v15 = *(_QWORD *)(a4 + 40);
      v14 = *(_QWORD *)(a4 + 48);
      sub_100034C68(v24, v15);
      v16 = 5;
      goto LABEL_29;
    }
    return swift_endAccess(&v30);
  }
  if (sub_100106584(0x706F72647269615FLL, 0xE800000000000000, 256, a1, a2, v9))
  {
    v21 = a4 + 16;
    swift_beginAccess(a4 + 16, &v30, 33, 0);
    v22 = *(_QWORD *)(a4 + 40);
    v23 = *(_QWORD *)(a4 + 48);
    sub_100034C68(a4 + 16, v22);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(192, v22, v23);
    if (!v4)
    {
      swift_endAccess(&v30);
      swift_beginAccess(a4 + 16, &v30, 33, 0);
      v15 = *(_QWORD *)(a4 + 40);
      v14 = *(_QWORD *)(a4 + 48);
      sub_100034C68(v21, v15);
      v16 = 7;
      goto LABEL_29;
    }
    return swift_endAccess(&v30);
  }
  v30 = 0x706F72647269615FLL;
  v31 = 0xE800000000000000;
  v32 = a1;
  v33 = a2;
  if (!StringProtocol.caseInsensitiveCompare<A>(_:)(&v32, &type metadata for String, &type metadata for String, v17, v17)&& (v34|| (_stringCompareWithSmolCheck(_:_:expecting:)(7365749, 0xE300000000000000, 7365492, 0xE300000000000000, 0) & 1) != 0)&& HIBYTE(a3) == 1)
  {
    v27 = a4 + 16;
    swift_beginAccess(a4 + 16, &v30, 33, 0);
    v28 = *(_QWORD *)(a4 + 40);
    v29 = *(_QWORD *)(a4 + 48);
    sub_100034C68(a4 + 16, v28);
    dispatch thunk of UnkeyedEncodingContainer.encode(_:)(192, v28, v29);
    if (!v4)
    {
      swift_endAccess(&v30);
      swift_beginAccess(a4 + 16, &v30, 33, 0);
      v15 = *(_QWORD *)(a4 + 40);
      v14 = *(_QWORD *)(a4 + 48);
      sub_100034C68(v27, v15);
      v16 = 8;
      goto LABEL_29;
    }
    return swift_endAccess(&v30);
  }
  result = sub_100105AD8(a1, a2, a4);
  if (!v4)
    return sub_100105DB0(v34, a4);
  return result;
}

_BYTE *sub_100106424@<X0>(_BYTE *result@<X0>, _BYTE *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (!result)
    goto LABEL_4;
  v4 = a2 - result;
  if (a2 == result)
  {
    result = 0;
LABEL_4:
    v5 = 0xC000000000000000;
    goto LABEL_5;
  }
  if (v4 <= 14)
  {
    result = (_BYTE *)sub_10000EC20(result, a2);
    v5 = v7 & 0xFFFFFFFFFFFFFFLL;
  }
  else if ((unint64_t)v4 >= 0x7FFFFFFF)
  {
    result = (_BYTE *)sub_1001067F4((uint64_t)result, (uint64_t)a2);
    v5 = v8 | 0x8000000000000000;
  }
  else
  {
    result = (_BYTE *)sub_10010686C((uint64_t)result, (uint64_t)a2);
    v5 = v6 | 0x4000000000000000;
  }
LABEL_5:
  *a3 = result;
  a3[1] = v5;
  return result;
}

_QWORD *sub_100106498(_QWORD *(*a1)(uint64_t *__return_ptr, uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *result;
  uint64_t v6;

  if (a3)
  {
    result = a1(&v6, a3, a4 - a3);
    if (v4)
      return result;
    return (_QWORD *)v6;
  }
  result = a1(&v6, 0, 0);
  if (!v4)
    return (_QWORD *)v6;
  return result;
}

uint64_t sub_1001064FC@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  char v9;
  uint64_t v10;

  if (result)
  {
    v5 = result;
    v8 = *a3;
    v7 = a3[1];
    swift_bridgeObjectRetain(v7);
    result = _StringGuts.copyUTF8(into:)(v5, a2, v8, v7);
    if ((v9 & 1) == 0)
    {
      v10 = result;
      result = swift_bridgeObjectRelease(v7);
      *a4 = 0;
      a4[1] = 0xE000000000000000;
      a4[2] = 15;
      a4[3] = v10;
      return result;
    }
  }
  else
  {
    __break(1u);
  }
  __break(1u);
  return result;
}

BOOL sub_100106584(uint64_t a1, uint64_t a2, __int16 a3, uint64_t a4, uint64_t a5, __int16 a6)
{
  unint64_t v8;
  _BOOL8 result;
  uint64_t v10;
  uint64_t v11;
  char v12;
  _QWORD v13[4];

  v13[2] = a1;
  v13[3] = a2;
  v13[0] = a4;
  v13[1] = a5;
  v8 = sub_10001C920();
  if (StringProtocol.caseInsensitiveCompare<A>(_:)(v13, &type metadata for String, &type metadata for String, v8, v8))
    return 0;
  if ((a3 & 1) != 0)
    v10 = 7365749;
  else
    v10 = 7365492;
  if ((a6 & 1) != 0)
    v11 = 7365749;
  else
    v11 = 7365492;
  if (v10 == v11)
  {
    swift_bridgeObjectRelease_n(0xE300000000000000, 2);
  }
  else
  {
    v12 = _stringCompareWithSmolCheck(_:_:expecting:)(v10, 0xE300000000000000, v11, 0xE300000000000000, 0);
    swift_bridgeObjectRelease_n(0xE300000000000000, 2);
    result = 0;
    if ((v12 & 1) == 0)
      return result;
  }
  return HIBYTE(a3) == (unsigned __int16)(a6 & 0xFF00) >> 8;
}

BOOL _s7CoreP2P10DNSRecordsO3SRVV23__derived_struct_equalsySbAE_AEtFZ_0(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  __int16 v6;
  __int16 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int16 v12;
  __int16 v13;
  unint64_t v14;
  int *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  char v23;
  _BOOL8 result;
  uint64_t v25;
  _QWORD v26[2];
  _QWORD v27[2];

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 24);
  v25 = *(_QWORD *)(a1 + 16);
  v6 = *(unsigned __int8 *)(a1 + 32);
  v7 = *(unsigned __int8 *)(a1 + 33);
  v8 = *a2;
  v9 = a2[1];
  v10 = a2[2];
  v11 = a2[3];
  v12 = *((unsigned __int8 *)a2 + 32);
  v13 = *((unsigned __int8 *)a2 + 33);
  v27[0] = *(_QWORD *)a1;
  v27[1] = v4;
  v26[0] = v8;
  v26[1] = v9;
  v14 = sub_10001C920();
  if (StringProtocol.caseInsensitiveCompare<A>(_:)(v26, &type metadata for String, &type metadata for String, v14, v14))
    return 0;
  if (!sub_100106584(v25, v5, v6 | (v7 << 8), v10, v11, v12 | (v13 << 8)))
    return 0;
  v15 = (int *)type metadata accessor for DNSRecords.SRV(0);
  v16 = type metadata accessor for NWEndpoint.Port(0);
  v17 = sub_100011DE4(&qword_100406120, (uint64_t (*)(uint64_t))&type metadata accessor for NWEndpoint.Port, (uint64_t)&protocol conformance descriptor for NWEndpoint.Port);
  dispatch thunk of RawRepresentable.rawValue.getter(v27, v16, v17);
  dispatch thunk of RawRepresentable.rawValue.getter(v26, v16, v17);
  if (LOWORD(v27[0]) != LOWORD(v26[0]))
    return 0;
  v18 = v15[6];
  v19 = *(_QWORD *)(a1 + v18);
  v20 = *(_QWORD *)(a1 + v18 + 8);
  v21 = (uint64_t *)((char *)a2 + v18);
  v22 = v21[1];
  if (v19 == *v21 && v20 == v22
    || (v23 = _stringCompareWithSmolCheck(_:_:expecting:)(v19, v20, *v21, v22, 0), result = 0, (v23 & 1) != 0))
  {
    if (*(unsigned __int16 *)(a1 + v15[7]) == *(unsigned __int16 *)((char *)a2 + v15[7]))
      return *(unsigned __int16 *)(a1 + v15[8]) == *(unsigned __int16 *)((char *)a2 + v15[8]);
    return 0;
  }
  return result;
}

uint64_t sub_1001067F4(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  uint64_t v6;

  if (a1)
    v3 = a2 - a1;
  else
    v3 = 0;
  v4 = type metadata accessor for __DataStorage(0);
  swift_allocObject(v4, *(unsigned int *)(v4 + 48), *(unsigned __int16 *)(v4 + 52));
  result = __DataStorage.init(bytes:length:)(a1, v3);
  if (v3 < 0)
  {
    __break(1u);
  }
  else
  {
    v6 = type metadata accessor for Data.RangeReference(0);
    result = swift_allocObject(v6, 32, 7);
    *(_QWORD *)(result + 16) = 0;
    *(_QWORD *)(result + 24) = v3;
  }
  return result;
}

uint64_t sub_10010686C(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t result;

  if (a1)
    v3 = a2 - a1;
  else
    v3 = 0;
  v4 = type metadata accessor for __DataStorage(0);
  swift_allocObject(v4, *(unsigned int *)(v4 + 48), *(unsigned __int16 *)(v4 + 52));
  result = __DataStorage.init(bytes:length:)(a1, v3);
  if (v3 < (uint64_t)0xFFFFFFFF80000000)
  {
    __break(1u);
    goto LABEL_9;
  }
  if (v3 > 0x7FFFFFFF)
  {
LABEL_9:
    __break(1u);
    goto LABEL_10;
  }
  if ((v3 & 0x80000000) == 0)
    return v3 << 32;
LABEL_10:
  __break(1u);
  return result;
}

uint64_t sub_1001068EC(uint64_t a1)
{
  _QWORD *v2;
  _BYTE *v3;
  _BYTE *v4;
  uint64_t v5;
  uint64_t v7;
  _QWORD v8[3];
  uint64_t v9;
  uint64_t v10;

  v9 = sub_100012C44(&qword_100406738);
  v10 = sub_100011770((unint64_t *)&qword_100407E08, &qword_100406738, (const char *)&protocol conformance descriptor for <A> [A]);
  v8[0] = a1;
  v2 = sub_10003259C(v8, v9);
  v3 = (_BYTE *)(*v2 + 32);
  v4 = &v3[*(_QWORD *)(*v2 + 16)];
  swift_bridgeObjectRetain(a1);
  sub_100106424(v3, v4, &v7);
  v5 = v7;
  sub_100014430(v8);
  return v5;
}

_BYTE *sub_10010699C(_BYTE *result, _BYTE *a2)
{
  uint64_t v2;

  if (result)
  {
    v2 = a2 - result;
    if (a2 == result)
    {
      return 0;
    }
    else if (v2 <= 14)
    {
      return (_BYTE *)sub_10000EC20(result, a2);
    }
    else if ((unint64_t)v2 >= 0x7FFFFFFF)
    {
      return (_BYTE *)sub_1001067F4((uint64_t)result, (uint64_t)a2);
    }
    else
    {
      return (_BYTE *)sub_10010686C((uint64_t)result, (uint64_t)a2);
    }
  }
  return result;
}

uint64_t sub_100106A00(uint64_t result)
{
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    v1 = result;
    if (result <= 14)
    {
      if (result < 0)
        __break(1u);
      else
        return 0;
    }
    else
    {
      v2 = type metadata accessor for __DataStorage(0);
      swift_allocObject(v2, *(unsigned int *)(v2 + 48), *(unsigned __int16 *)(v2 + 52));
      __DataStorage.init(length:)(v1);
      if (v1 >= 0x7FFFFFFF)
      {
        v3 = type metadata accessor for Data.RangeReference(0);
        result = swift_allocObject(v3, 32, 7);
        *(_QWORD *)(result + 16) = 0;
        *(_QWORD *)(result + 24) = v1;
      }
      else
      {
        return v1 << 32;
      }
    }
  }
  return result;
}

uint64_t _s7CoreP2P10DNSRecordsO10RecordTypeO8rawValueAESgs6UInt16V_tcfC_0(unsigned __int16 a1)
{
  int v1;
  uint64_t result;

  v1 = a1 - 1;
  result = 1;
  switch(v1)
  {
    case 0:
      result = 0;
      break;
    case 1:
      return result;
    case 2:
      result = 2;
      break;
    case 3:
      result = 3;
      break;
    case 4:
      result = 4;
      break;
    case 5:
      result = 5;
      break;
    case 6:
      result = 6;
      break;
    case 7:
      result = 7;
      break;
    case 8:
      result = 8;
      break;
    case 9:
      result = 9;
      break;
    case 10:
      result = 10;
      break;
    case 11:
      result = 11;
      break;
    case 12:
      result = 12;
      break;
    case 13:
      result = 13;
      break;
    case 14:
      result = 14;
      break;
    case 15:
      result = 15;
      break;
    case 16:
      result = 16;
      break;
    case 17:
      result = 17;
      break;
    case 18:
      result = 18;
      break;
    case 19:
      result = 19;
      break;
    case 20:
      result = 20;
      break;
    case 21:
      result = 21;
      break;
    case 22:
      result = 22;
      break;
    case 23:
      result = 23;
      break;
    case 24:
      result = 24;
      break;
    case 25:
      result = 25;
      break;
    case 26:
      result = 26;
      break;
    case 27:
      result = 27;
      break;
    case 28:
      result = 28;
      break;
    case 29:
      result = 29;
      break;
    case 30:
      result = 30;
      break;
    case 31:
      result = 31;
      break;
    case 32:
      result = 32;
      break;
    case 33:
      result = 33;
      break;
    case 34:
      result = 34;
      break;
    case 35:
      result = 35;
      break;
    case 36:
      result = 36;
      break;
    case 37:
      result = 37;
      break;
    case 38:
      result = 38;
      break;
    case 39:
      result = 39;
      break;
    case 40:
      result = 40;
      break;
    case 41:
      result = 41;
      break;
    case 42:
      result = 42;
      break;
    case 43:
      result = 43;
      break;
    case 44:
      result = 44;
      break;
    case 45:
      result = 45;
      break;
    case 46:
      result = 46;
      break;
    case 47:
      result = 47;
      break;
    case 48:
      result = 48;
      break;
    case 49:
      result = 49;
      break;
    case 50:
      result = 50;
      break;
    case 54:
      result = 51;
      break;
    case 63:
      result = 52;
      break;
    case 64:
      result = 53;
      break;
    case 98:
      result = 54;
      break;
    case 99:
      result = 55;
      break;
    case 100:
      result = 56;
      break;
    case 101:
      result = 57;
      break;
    case 102:
      result = 58;
      break;
    case 248:
      result = 59;
      break;
    case 249:
      result = 60;
      break;
    case 250:
      result = 61;
      break;
    case 251:
      result = 62;
      break;
    case 252:
      result = 63;
      break;
    case 253:
      result = 64;
      break;
    default:
      result = 65;
      break;
  }
  return result;
}

uint64_t sub_100106CD4(char a1)
{
  if ((a1 - 1) >= 0xEu)
    return 14;
  else
    return (a1 - 1);
}

void sub_100106CEC(uint64_t a1, unint64_t a2)
{
  sub_100107054(a1, a2);
  if (qword_100403F70 != -1)
    swift_once(&qword_100403F70, sub_1001055A8);
  __asm { BR              X12 }
}

uint64_t sub_100106FC4()
{
  uint64_t v0;

  sub_100014430((_QWORD *)(v0 + 16));
  return swift_deallocObject(v0, 56, 7);
}

uint64_t sub_100106FE8(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = type metadata accessor for AWDLActionFrame.ServiceResponse(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 - 8) + 16))(a2, a1, v4);
  return a2;
}

uint64_t sub_10010702C(uint64_t a1)
{
  swift_bridgeObjectRelease(*(_QWORD *)(a1 + 16));
  return a1;
}

void sub_100107054(uint64_t a1, unint64_t a2)
{
  swift_bridgeObjectRetain(a2);
  sub_1000FAE78(a1, a2);
  __asm { BR              X10 }
}

uint64_t sub_1001070B0@<X0>(int a1@<W8>)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (BYTE6(v2) < 0x40uLL)
  {
    if (!a1)
      goto LABEL_10;
    if (a1 == 1)
    {
      if (!__OFSUB__(HIDWORD(v1), (_DWORD)v1))
      {
        v3 = HIDWORD(v1) - (int)v1;
        goto LABEL_8;
      }
      __break(1u);
    }
    else
    {
      v5 = *(_QWORD *)(v1 + 16);
      v4 = *(_QWORD *)(v1 + 24);
      v3 = v4 - v5;
      if (!__OFSUB__(v4, v5))
      {
LABEL_8:
        if ((v3 & 0x8000000000000000) == 0)
        {
          if (v3 < 0x100)
          {
LABEL_10:
            sub_1000FB8F8();
            sub_100031FEC(v1, v2);
            sub_1000FBDAC(v1, v2);
            sub_10000E614(v1, v2);
            return sub_10000E614(v1, v2);
          }
          _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 3455, 0);
LABEL_16:
          __break(1u);
          JUMPOUT(0x1001071F8);
        }
LABEL_14:
        _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 3451, 0);
        goto LABEL_16;
      }
    }
    __break(1u);
    goto LABEL_14;
  }
  return sub_10000E614(v1, v2);
}

uint64_t sub_100107208(uint64_t a1)
{
  swift_bridgeObjectRelease(*(_QWORD *)(a1 + 24));
  return a1;
}

unint64_t sub_100107234()
{
  unint64_t result;

  result = qword_100407D28;
  if (!qword_100407D28)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for DNSRecords.BrowseHost, &type metadata for DNSRecords.BrowseHost);
    atomic_store(result, (unint64_t *)&qword_100407D28);
  }
  return result;
}

unint64_t sub_10010727C()
{
  unint64_t result;

  result = qword_1004102D0;
  if (!qword_1004102D0)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for DNSRecords.Identifier, &type metadata for DNSRecords.Identifier);
    atomic_store(result, (unint64_t *)&qword_1004102D0);
  }
  return result;
}

unint64_t sub_1001072C4()
{
  unint64_t result;

  result = qword_100407D30;
  if (!qword_100407D30)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for DNSRecords.PTR, &type metadata for DNSRecords.PTR);
    atomic_store(result, (unint64_t *)&qword_100407D30);
  }
  return result;
}

unint64_t sub_10010730C()
{
  unint64_t result;

  result = qword_100407D38;
  if (!qword_100407D38)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for DNSRecords.TXT, &type metadata for DNSRecords.TXT);
    atomic_store(result, (unint64_t *)&qword_100407D38);
  }
  return result;
}

uint64_t sub_100107350()
{
  return sub_100011DE4(&qword_100407D40, type metadata accessor for DNSRecords.SRV, (uint64_t)&protocol conformance descriptor for DNSRecords.SRV);
}

unint64_t sub_100107380()
{
  unint64_t result;

  result = qword_100407D48;
  if (!qword_100407D48)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for DNSRecords.AAAA, &type metadata for DNSRecords.AAAA);
    atomic_store(result, (unint64_t *)&qword_100407D48);
  }
  return result;
}

unint64_t sub_1001073C8()
{
  unint64_t result;

  result = qword_100407D50;
  if (!qword_100407D50)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for DNSRecords.ARPABrowse, &type metadata for DNSRecords.ARPABrowse);
    atomic_store(result, (unint64_t *)&qword_100407D50);
  }
  return result;
}

unint64_t sub_100107410()
{
  unint64_t result;

  result = qword_100407D58;
  if (!qword_100407D58)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for DNSRecords.ARPA, &type metadata for DNSRecords.ARPA);
    atomic_store(result, (unint64_t *)&qword_100407D58);
  }
  return result;
}

unint64_t sub_100107458()
{
  unint64_t result;

  result = qword_100407D60;
  if (!qword_100407D60)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for DNSRecords.RecordType, &type metadata for DNSRecords.RecordType);
    atomic_store(result, (unint64_t *)&qword_100407D60);
  }
  return result;
}

ValueMetadata *type metadata accessor for DNSRecords()
{
  return &type metadata for DNSRecords;
}

uint64_t initializeWithCopy for DNSRecords.BrowseHost(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  v3 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 16) = v3;
  *(_BYTE *)(a1 + 24) = *(_BYTE *)(a2 + 24);
  swift_bridgeObjectRetain(v3);
  return a1;
}

uint64_t assignWithCopy for DNSRecords.BrowseHost(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  v4 = *(_QWORD *)(a2 + 16);
  v5 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v4;
  swift_bridgeObjectRetain(v4);
  swift_bridgeObjectRelease(v5);
  *(_BYTE *)(a1 + 24) = *(_BYTE *)(a2 + 24);
  return a1;
}

__n128 initializeWithTake for DNSRecords.BrowseHost(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)a2;
  *(_OWORD *)(a1 + 9) = *(_OWORD *)(a2 + 9);
  *(__n128 *)a1 = result;
  return result;
}

uint64_t assignWithTake for DNSRecords.BrowseHost(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  v4 = *(_QWORD *)(a2 + 16);
  v5 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 16) = v4;
  swift_bridgeObjectRelease(v5);
  *(_BYTE *)(a1 + 24) = *(_BYTE *)(a2 + 24);
  return a1;
}

uint64_t getEnumTagSinglePayload for DNSRecords.BrowseHost(uint64_t a1, int a2)
{
  unint64_t v2;

  if (!a2)
    return 0;
  if (a2 < 0 && *(_BYTE *)(a1 + 25))
    return *(_DWORD *)a1 + 0x80000000;
  v2 = *(_QWORD *)(a1 + 16);
  if (v2 >= 0xFFFFFFFF)
    LODWORD(v2) = -1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for DNSRecords.BrowseHost(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_QWORD *)(result + 8) = 0;
    *(_QWORD *)(result + 16) = 0;
    *(_BYTE *)(result + 24) = 0;
    *(_QWORD *)result = a2 ^ 0x80000000;
    if (a3 < 0)
      *(_BYTE *)(result + 25) = 1;
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
        return result;
LABEL_8:
      *(_QWORD *)(result + 16) = (a2 - 1);
      return result;
    }
    *(_BYTE *)(result + 25) = 0;
    if (a2)
      goto LABEL_8;
  }
  return result;
}

ValueMetadata *type metadata accessor for DNSRecords.BrowseHost()
{
  return &type metadata for DNSRecords.BrowseHost;
}

uint64_t sub_10010763C(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = v3;
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  *(_BYTE *)(a1 + 17) = *(_BYTE *)(a2 + 17);
  swift_bridgeObjectRetain(v3);
  return a1;
}

uint64_t assignWithCopy for DNSRecords.Identifier(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  v4 = *(_QWORD *)(a2 + 8);
  v5 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = v4;
  swift_bridgeObjectRetain(v4);
  swift_bridgeObjectRelease(v5);
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  *(_BYTE *)(a1 + 17) = *(_BYTE *)(a2 + 17);
  return a1;
}

__n128 initializeWithTake for NANBloomFilter(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  a1[1].n128_u16[0] = a2[1].n128_u16[0];
  *a1 = result;
  return result;
}

uint64_t assignWithTake for DNSRecords.Identifier(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *(_QWORD *)(a2 + 8);
  v5 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = v4;
  swift_bridgeObjectRelease(v5);
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  *(_BYTE *)(a1 + 17) = *(_BYTE *)(a2 + 17);
  return a1;
}

uint64_t getEnumTagSinglePayload for DNSRecords.Identifier(uint64_t a1, int a2)
{
  unint64_t v2;

  if (!a2)
    return 0;
  if (a2 < 0 && *(_BYTE *)(a1 + 18))
    return *(_DWORD *)a1 + 0x80000000;
  v2 = *(_QWORD *)(a1 + 8);
  if (v2 >= 0xFFFFFFFF)
    LODWORD(v2) = -1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for DNSRecords.Identifier(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_WORD *)(result + 16) = 0;
    *(_QWORD *)result = a2 ^ 0x80000000;
    *(_QWORD *)(result + 8) = 0;
    if (a3 < 0)
      *(_BYTE *)(result + 18) = 1;
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
        return result;
LABEL_8:
      *(_QWORD *)(result + 8) = (a2 - 1);
      return result;
    }
    *(_BYTE *)(result + 18) = 0;
    if (a2)
      goto LABEL_8;
  }
  return result;
}

ValueMetadata *type metadata accessor for DNSRecords.Identifier()
{
  return &type metadata for DNSRecords.Identifier;
}

uint64_t destroy for DNSRecords.PTR(uint64_t a1)
{
  swift_bridgeObjectRelease(*(_QWORD *)(a1 + 8));
  return swift_bridgeObjectRelease(*(_QWORD *)(a1 + 24));
}

uint64_t initializeWithCopy for DNSRecords.PTR(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = v3;
  v4 = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 24) = v4;
  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
  *(_BYTE *)(a1 + 33) = *(_BYTE *)(a2 + 33);
  swift_bridgeObjectRetain(v3);
  swift_bridgeObjectRetain(v4);
  return a1;
}

uint64_t assignWithCopy for DNSRecords.PTR(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  v4 = *(_QWORD *)(a2 + 8);
  v5 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = v4;
  swift_bridgeObjectRetain(v4);
  swift_bridgeObjectRelease(v5);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  v6 = *(_QWORD *)(a2 + 24);
  v7 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = v6;
  swift_bridgeObjectRetain(v6);
  swift_bridgeObjectRelease(v7);
  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
  *(_BYTE *)(a1 + 33) = *(_BYTE *)(a2 + 33);
  return a1;
}

__n128 initializeWithTake for DNSRecords.PTR(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)a2;
  v3 = *(_OWORD *)(a2 + 16);
  *(_WORD *)(a1 + 32) = *(_WORD *)(a2 + 32);
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

uint64_t assignWithTake for DNSRecords.PTR(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v4 = *(_QWORD *)(a2 + 8);
  v5 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = v4;
  swift_bridgeObjectRelease(v5);
  v6 = *(_QWORD *)(a2 + 24);
  v7 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 24) = v6;
  swift_bridgeObjectRelease(v7);
  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
  *(_BYTE *)(a1 + 33) = *(_BYTE *)(a2 + 33);
  return a1;
}

uint64_t getEnumTagSinglePayload for DNSRecords.PTR(uint64_t a1, int a2)
{
  unint64_t v2;

  if (!a2)
    return 0;
  if (a2 < 0 && *(_BYTE *)(a1 + 34))
    return *(_DWORD *)a1 + 0x80000000;
  v2 = *(_QWORD *)(a1 + 8);
  if (v2 >= 0xFFFFFFFF)
    LODWORD(v2) = -1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for DNSRecords.PTR(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_QWORD *)(result + 16) = 0;
    *(_QWORD *)(result + 24) = 0;
    *(_WORD *)(result + 32) = 0;
    *(_QWORD *)result = a2 ^ 0x80000000;
    *(_QWORD *)(result + 8) = 0;
    if (a3 < 0)
      *(_BYTE *)(result + 34) = 1;
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
        return result;
LABEL_8:
      *(_QWORD *)(result + 8) = (a2 - 1);
      return result;
    }
    *(_BYTE *)(result + 34) = 0;
    if (a2)
      goto LABEL_8;
  }
  return result;
}

ValueMetadata *type metadata accessor for DNSRecords.PTR()
{
  return &type metadata for DNSRecords.PTR;
}

uint64_t destroy for DNSRecords.TXT(_QWORD *a1)
{
  swift_bridgeObjectRelease(a1[1]);
  swift_bridgeObjectRelease(a1[3]);
  return sub_10000E614(a1[5], a1[6]);
}

uint64_t initializeWithCopy for DNSRecords.TXT(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;

  v3 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = v3;
  v4 = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 24) = v4;
  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
  *(_BYTE *)(a1 + 33) = *(_BYTE *)(a2 + 33);
  v5 = *(_QWORD *)(a2 + 40);
  v6 = *(_QWORD *)(a2 + 48);
  swift_bridgeObjectRetain(v3);
  swift_bridgeObjectRetain(v4);
  sub_100031FEC(v5, v6);
  *(_QWORD *)(a1 + 40) = v5;
  *(_QWORD *)(a1 + 48) = v6;
  return a1;
}

uint64_t assignWithCopy for DNSRecords.TXT(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  v4 = *(_QWORD *)(a2 + 8);
  v5 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = v4;
  swift_bridgeObjectRetain(v4);
  swift_bridgeObjectRelease(v5);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  v6 = *(_QWORD *)(a2 + 24);
  v7 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = v6;
  swift_bridgeObjectRetain(v6);
  swift_bridgeObjectRelease(v7);
  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
  *(_BYTE *)(a1 + 33) = *(_BYTE *)(a2 + 33);
  v9 = *(_QWORD *)(a2 + 40);
  v8 = *(_QWORD *)(a2 + 48);
  sub_100031FEC(v9, v8);
  v10 = *(_QWORD *)(a1 + 40);
  v11 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 40) = v9;
  *(_QWORD *)(a1 + 48) = v8;
  sub_10000E614(v10, v11);
  return a1;
}

__n128 initializeWithTake for DNSRecords.TXT(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;
  __int128 v4;

  result = *(__n128 *)a2;
  v3 = *(_OWORD *)(a2 + 16);
  v4 = *(_OWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 16) = v3;
  *(_OWORD *)(a1 + 32) = v4;
  *(__n128 *)a1 = result;
  return result;
}

uint64_t assignWithTake for DNSRecords.TXT(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;

  v4 = *(_QWORD *)(a2 + 8);
  v5 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = v4;
  swift_bridgeObjectRelease(v5);
  v6 = *(_QWORD *)(a2 + 24);
  v7 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 24) = v6;
  swift_bridgeObjectRelease(v7);
  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
  *(_BYTE *)(a1 + 33) = *(_BYTE *)(a2 + 33);
  v8 = *(_QWORD *)(a1 + 40);
  v9 = *(_QWORD *)(a1 + 48);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  sub_10000E614(v8, v9);
  return a1;
}

uint64_t getEnumTagSinglePayload for DNSRecords.TXT(uint64_t a1, int a2)
{
  unint64_t v2;

  if (!a2)
    return 0;
  if (a2 < 0 && *(_BYTE *)(a1 + 56))
    return *(_DWORD *)a1 + 0x80000000;
  v2 = *(_QWORD *)(a1 + 8);
  if (v2 >= 0xFFFFFFFF)
    LODWORD(v2) = -1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for DNSRecords.TXT(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_QWORD *)result = a2 ^ 0x80000000;
    if (a3 < 0)
      *(_BYTE *)(result + 56) = 1;
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
        return result;
LABEL_8:
      *(_QWORD *)(result + 8) = (a2 - 1);
      return result;
    }
    *(_BYTE *)(result + 56) = 0;
    if (a2)
      goto LABEL_8;
  }
  return result;
}

ValueMetadata *type metadata accessor for DNSRecords.TXT()
{
  return &type metadata for DNSRecords.TXT;
}

_QWORD *initializeBufferWithCopyOfBuffer for DNSRecords.SRV(uint64_t a1, uint64_t *a2, int *a3)
{
  _QWORD *v4;
  int v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void (*v14)(uint64_t, uint64_t, uint64_t);
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;

  v4 = (_QWORD *)a1;
  v5 = *(_DWORD *)(*((_QWORD *)a3 - 1) + 80);
  if ((v5 & 0x20000) != 0)
  {
    v20 = *a2;
    *v4 = *a2;
    v4 = (_QWORD *)(v20 + ((v5 + 16) & ~(unint64_t)v5));
    swift_retain(v20);
  }
  else
  {
    v7 = a2[1];
    *(_QWORD *)a1 = *a2;
    *(_QWORD *)(a1 + 8) = v7;
    v8 = a2[2];
    v9 = a2[3];
    *(_BYTE *)(a1 + 32) = *((_BYTE *)a2 + 32);
    *(_BYTE *)(a1 + 33) = *((_BYTE *)a2 + 33);
    v10 = a3[5];
    v11 = a1 + v10;
    v12 = (uint64_t)a2 + v10;
    *(_QWORD *)(a1 + 16) = v8;
    *(_QWORD *)(a1 + 24) = v9;
    v13 = type metadata accessor for NWEndpoint.Port(0);
    v14 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v13 - 8) + 16);
    swift_bridgeObjectRetain(v7);
    swift_bridgeObjectRetain(v9);
    v14(v11, v12, v13);
    v15 = a3[6];
    v16 = a3[7];
    v17 = (_QWORD *)((char *)v4 + v15);
    v18 = (uint64_t *)((char *)a2 + v15);
    v19 = v18[1];
    *v17 = *v18;
    v17[1] = v19;
    *(_WORD *)((char *)v4 + v16) = *(_WORD *)((char *)a2 + v16);
    *(_WORD *)((char *)v4 + a3[8]) = *(_WORD *)((char *)a2 + a3[8]);
    swift_bridgeObjectRetain(v19);
  }
  return v4;
}

uint64_t destroy for DNSRecords.SRV(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;

  swift_bridgeObjectRelease(*(_QWORD *)(a1 + 8));
  swift_bridgeObjectRelease(*(_QWORD *)(a1 + 24));
  v4 = a1 + *(int *)(a2 + 20);
  v5 = type metadata accessor for NWEndpoint.Port(0);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 8))(v4, v5);
  return swift_bridgeObjectRelease(*(_QWORD *)(a1 + *(int *)(a2 + 24) + 8));
}

uint64_t initializeWithCopy for DNSRecords.SRV(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void (*v13)(uint64_t, uint64_t, uint64_t);
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;

  v6 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = v6;
  v7 = *(_QWORD *)(a2 + 16);
  v8 = *(_QWORD *)(a2 + 24);
  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
  *(_BYTE *)(a1 + 33) = *(_BYTE *)(a2 + 33);
  v9 = a3[5];
  v10 = a1 + v9;
  v11 = a2 + v9;
  *(_QWORD *)(a1 + 16) = v7;
  *(_QWORD *)(a1 + 24) = v8;
  v12 = type metadata accessor for NWEndpoint.Port(0);
  v13 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v12 - 8) + 16);
  swift_bridgeObjectRetain(v6);
  swift_bridgeObjectRetain(v8);
  v13(v10, v11, v12);
  v14 = a3[6];
  v15 = a3[7];
  v16 = (_QWORD *)(a1 + v14);
  v17 = (_QWORD *)(a2 + v14);
  v18 = v17[1];
  *v16 = *v17;
  v16[1] = v18;
  *(_WORD *)(a1 + v15) = *(_WORD *)(a2 + v15);
  *(_WORD *)(a1 + a3[8]) = *(_WORD *)(a2 + a3[8]);
  swift_bridgeObjectRetain(v18);
  return a1;
}

uint64_t assignWithCopy for DNSRecords.SRV(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  v6 = *(_QWORD *)(a2 + 8);
  v7 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = v6;
  swift_bridgeObjectRetain(v6);
  swift_bridgeObjectRelease(v7);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  v8 = *(_QWORD *)(a2 + 24);
  v9 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = v8;
  swift_bridgeObjectRetain(v8);
  swift_bridgeObjectRelease(v9);
  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
  *(_BYTE *)(a1 + 33) = *(_BYTE *)(a2 + 33);
  v10 = a3[5];
  v11 = a1 + v10;
  v12 = a2 + v10;
  v13 = type metadata accessor for NWEndpoint.Port(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v13 - 8) + 24))(v11, v12, v13);
  v14 = a3[6];
  v15 = (_QWORD *)(a1 + v14);
  v16 = (_QWORD *)(a2 + v14);
  *v15 = *v16;
  v17 = v16[1];
  v18 = v15[1];
  v15[1] = v17;
  swift_bridgeObjectRetain(v17);
  swift_bridgeObjectRelease(v18);
  *(_WORD *)(a1 + a3[7]) = *(_WORD *)(a2 + a3[7]);
  *(_WORD *)(a1 + a3[8]) = *(_WORD *)(a2 + a3[8]);
  return a1;
}

uint64_t initializeWithTake for DNSRecords.SRV(uint64_t a1, uint64_t a2, int *a3)
{
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v6 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v6;
  *(_WORD *)(a1 + 32) = *(_WORD *)(a2 + 32);
  v7 = a3[5];
  v8 = a1 + v7;
  v9 = a2 + v7;
  v10 = type metadata accessor for NWEndpoint.Port(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v10 - 8) + 32))(v8, v9, v10);
  v11 = a3[7];
  *(_OWORD *)(a1 + a3[6]) = *(_OWORD *)(a2 + a3[6]);
  *(_WORD *)(a1 + v11) = *(_WORD *)(a2 + v11);
  *(_WORD *)(a1 + a3[8]) = *(_WORD *)(a2 + a3[8]);
  return a1;
}

uint64_t assignWithTake for DNSRecords.SRV(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v6 = *(_QWORD *)(a2 + 8);
  v7 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = v6;
  swift_bridgeObjectRelease(v7);
  v8 = *(_QWORD *)(a2 + 24);
  v9 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 24) = v8;
  swift_bridgeObjectRelease(v9);
  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
  *(_BYTE *)(a1 + 33) = *(_BYTE *)(a2 + 33);
  v10 = a3[5];
  v11 = a1 + v10;
  v12 = a2 + v10;
  v13 = type metadata accessor for NWEndpoint.Port(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v13 - 8) + 40))(v11, v12, v13);
  v14 = a3[6];
  v15 = (_QWORD *)(a1 + v14);
  v16 = (uint64_t *)(a2 + v14);
  v18 = *v16;
  v17 = v16[1];
  v19 = v15[1];
  *v15 = v18;
  v15[1] = v17;
  swift_bridgeObjectRelease(v19);
  v20 = a3[8];
  *(_WORD *)(a1 + a3[7]) = *(_WORD *)(a2 + a3[7]);
  *(_WORD *)(a1 + v20) = *(_WORD *)(a2 + v20);
  return a1;
}

uint64_t getEnumTagSinglePayload for DNSRecords.SRV(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getEnumTagSinglePayloadGeneric(a1, a2, a3, sub_1001080A4);
}

uint64_t sub_1001080A4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4;
  uint64_t v8;

  if ((_DWORD)a2 == 0x7FFFFFFF)
  {
    v4 = *(_QWORD *)(a1 + 8);
    if (v4 >= 0xFFFFFFFF)
      LODWORD(v4) = -1;
    return (v4 + 1);
  }
  else
  {
    v8 = type metadata accessor for NWEndpoint.Port(0);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v8 - 8) + 48))(a1 + *(int *)(a3 + 20), a2, v8);
  }
}

uint64_t storeEnumTagSinglePayload for DNSRecords.SRV(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return swift_storeEnumTagSinglePayloadGeneric(a1, a2, a3, a4, sub_10010812C);
}

uint64_t sub_10010812C(uint64_t result, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v7;

  v5 = result;
  if (a3 == 0x7FFFFFFF)
  {
    *(_QWORD *)(result + 8) = (a2 - 1);
  }
  else
  {
    v7 = type metadata accessor for NWEndpoint.Port(0);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v7 - 8) + 56))(v5 + *(int *)(a4 + 20), a2, a2, v7);
  }
  return result;
}

uint64_t sub_1001081A0(uint64_t a1)
{
  uint64_t result;
  unint64_t v3;
  _QWORD v4[5];

  v4[0] = "\"";
  result = type metadata accessor for NWEndpoint.Port(319);
  if (v3 <= 0x3F)
  {
    v4[1] = *(_QWORD *)(result - 8) + 64;
    v4[2] = &unk_100347300;
    v4[3] = (char *)&value witness table for Builtin.Int16 + 64;
    v4[4] = (char *)&value witness table for Builtin.Int16 + 64;
    swift_initStructMetadata(a1, 256, 5, v4, a1 + 16);
    return 0;
  }
  return result;
}

__n128 initializeWithTake for NANAttribute.DatapathExtension(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;
  __int128 v4;

  result = *(__n128 *)a2;
  v3 = *(_OWORD *)(a2 + 16);
  v4 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 48) = v4;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

ValueMetadata *type metadata accessor for DNSRecords.AAAA()
{
  return &type metadata for DNSRecords.AAAA;
}

uint64_t initializeWithCopy for DNSRecords.ARPABrowse(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  *(_OWORD *)a1 = *(_OWORD *)a2;
  v3 = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 24) = v3;
  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
  swift_bridgeObjectRetain(v3);
  return a1;
}

uint64_t assignWithCopy for DNSRecords.ARPABrowse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v4 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = v4;
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  v5 = *(_QWORD *)(a2 + 24);
  v6 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = v5;
  swift_bridgeObjectRetain(v5);
  swift_bridgeObjectRelease(v6);
  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
  return a1;
}

__n128 initializeWithTake for AWDLSoftErrorReport(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)a2;
  v3 = *(_OWORD *)(a2 + 16);
  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

uint64_t assignWithTake for DNSRecords.ARPABrowse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;

  *(_OWORD *)a1 = *(_OWORD *)a2;
  v4 = *(_QWORD *)(a2 + 24);
  v5 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 24) = v4;
  swift_bridgeObjectRelease(v5);
  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
  return a1;
}

uint64_t getEnumTagSinglePayload for DNSRecords.ARPABrowse(uint64_t a1, unsigned int a2)
{
  unint64_t v3;
  int v4;

  if (!a2)
    return 0;
  if (a2 >= 0x7FFFFFFF && *(_BYTE *)(a1 + 33))
    return (*(_DWORD *)a1 + 0x7FFFFFFF);
  v3 = *(_QWORD *)(a1 + 24);
  if (v3 >= 0xFFFFFFFF)
    LODWORD(v3) = -1;
  v4 = v3 - 1;
  if (v4 < 0)
    v4 = -1;
  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for DNSRecords.ARPABrowse(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0x7FFFFFFE)
  {
    *(_QWORD *)(result + 16) = 0;
    *(_QWORD *)(result + 24) = 0;
    *(_BYTE *)(result + 32) = 0;
    *(_QWORD *)result = a2 - 0x7FFFFFFF;
    *(_QWORD *)(result + 8) = 0;
    if (a3 >= 0x7FFFFFFF)
      *(_BYTE *)(result + 33) = 1;
  }
  else
  {
    if (a3 >= 0x7FFFFFFF)
      *(_BYTE *)(result + 33) = 0;
    if (a2)
      *(_QWORD *)(result + 24) = a2;
  }
  return result;
}

ValueMetadata *type metadata accessor for DNSRecords.ARPABrowse()
{
  return &type metadata for DNSRecords.ARPABrowse;
}

uint64_t _s7CoreP2P10DNSRecordsO4AAAAVwxx_0(uint64_t a1)
{
  swift_bridgeObjectRelease(*(_QWORD *)(a1 + 16));
  return swift_bridgeObjectRelease(*(_QWORD *)(a1 + 56));
}

uint64_t _s7CoreP2P10DNSRecordsO4AAAAVwcp_0(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  v3 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 16) = v3;
  *(_BYTE *)(a1 + 24) = *(_BYTE *)(a2 + 24);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  v4 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 56) = v4;
  swift_bridgeObjectRetain(v3);
  swift_bridgeObjectRetain(v4);
  return a1;
}

uint64_t _s7CoreP2P10DNSRecordsO4AAAAVwca_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  v4 = *(_QWORD *)(a2 + 16);
  v5 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v4;
  swift_bridgeObjectRetain(v4);
  swift_bridgeObjectRelease(v5);
  *(_BYTE *)(a1 + 24) = *(_BYTE *)(a2 + 24);
  v6 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v6;
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  v7 = *(_QWORD *)(a2 + 56);
  v8 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 56) = v7;
  swift_bridgeObjectRetain(v7);
  swift_bridgeObjectRelease(v8);
  return a1;
}

uint64_t _s7CoreP2P10DNSRecordsO4AAAAVwta_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  v4 = *(_QWORD *)(a2 + 16);
  v5 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 16) = v4;
  swift_bridgeObjectRelease(v5);
  *(_BYTE *)(a1 + 24) = *(_BYTE *)(a2 + 24);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  v6 = *(_QWORD *)(a2 + 56);
  v7 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 56) = v6;
  swift_bridgeObjectRelease(v7);
  return a1;
}

uint64_t _s7CoreP2P10DNSRecordsO4AAAAVwet_0(uint64_t a1, int a2)
{
  unint64_t v2;

  if (!a2)
    return 0;
  if (a2 < 0 && *(_BYTE *)(a1 + 64))
    return *(_DWORD *)a1 + 0x80000000;
  v2 = *(_QWORD *)(a1 + 16);
  if (v2 >= 0xFFFFFFFF)
    LODWORD(v2) = -1;
  return (v2 + 1);
}

uint64_t sub_1001085D4(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_QWORD *)(result + 56) = 0;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_QWORD *)result = a2 ^ 0x80000000;
    if (a3 < 0)
      *(_BYTE *)(result + 64) = 1;
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
        return result;
LABEL_8:
      *(_QWORD *)(result + 16) = (a2 - 1);
      return result;
    }
    *(_BYTE *)(result + 64) = 0;
    if (a2)
      goto LABEL_8;
  }
  return result;
}

ValueMetadata *type metadata accessor for DNSRecords.ARPA()
{
  return &type metadata for DNSRecords.ARPA;
}

uint64_t getEnumTagSinglePayload for DNSRecords.RecordType(unsigned __int8 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0xC0)
    goto LABEL_17;
  if (a2 + 64 >= 0xFFFF00)
    v2 = 4;
  else
    v2 = 2;
  if ((a2 + 64) >> 8 < 0xFF)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 8)) - 64;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1))
        goto LABEL_17;
      return (*a1 | (v4 << 8)) - 64;
    }
    v4 = a1[1];
    if (a1[1])
      return (*a1 | (v4 << 8)) - 64;
  }
LABEL_17:
  v6 = *a1;
  v7 = v6 >= 0x41;
  v8 = v6 - 65;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for DNSRecords.RecordType(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 64 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 64) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xC0)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xBF)
    return ((uint64_t (*)(void))((char *)&loc_100108710 + 4 * byte_100346CB1[v4]))();
  *a1 = a2 + 64;
  return ((uint64_t (*)(void))((char *)sub_100108744 + 4 * byte_100346CAC[v4]))();
}

uint64_t sub_100108744(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_10010874C(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x100108754);
  return result;
}

uint64_t sub_100108760(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x100108768);
  *(_BYTE *)result = a2 + 64;
  return result;
}

uint64_t sub_10010876C(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_100108774(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for DNSRecords.RecordType()
{
  return &type metadata for DNSRecords.RecordType;
}

uint64_t destroy for DNSRecords.Browse(uint64_t a1)
{
  swift_bridgeObjectRelease(*(_QWORD *)(a1 + 16));
  return swift_bridgeObjectRelease(*(_QWORD *)(a1 + 32));
}

uint64_t initializeWithCopy for DNSRecords.Browse(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  v3 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 16) = v3;
  v4 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 32) = v4;
  *(_BYTE *)(a1 + 40) = *(_BYTE *)(a2 + 40);
  *(_BYTE *)(a1 + 41) = *(_BYTE *)(a2 + 41);
  swift_bridgeObjectRetain(v3);
  swift_bridgeObjectRetain(v4);
  return a1;
}

uint64_t assignWithCopy for DNSRecords.Browse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  v4 = *(_QWORD *)(a2 + 16);
  v5 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v4;
  swift_bridgeObjectRetain(v4);
  swift_bridgeObjectRelease(v5);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  v6 = *(_QWORD *)(a2 + 32);
  v7 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = v6;
  swift_bridgeObjectRetain(v6);
  swift_bridgeObjectRelease(v7);
  *(_BYTE *)(a1 + 40) = *(_BYTE *)(a2 + 40);
  *(_BYTE *)(a1 + 41) = *(_BYTE *)(a2 + 41);
  return a1;
}

__n128 initializeWithTake for NANAttribute.PairingBootstrapping(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)a2;
  v3 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 26) = *(_OWORD *)(a2 + 26);
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

uint64_t assignWithTake for DNSRecords.Browse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  v4 = *(_QWORD *)(a2 + 16);
  v5 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 16) = v4;
  swift_bridgeObjectRelease(v5);
  v6 = *(_QWORD *)(a2 + 32);
  v7 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 32) = v6;
  swift_bridgeObjectRelease(v7);
  *(_BYTE *)(a1 + 40) = *(_BYTE *)(a2 + 40);
  *(_BYTE *)(a1 + 41) = *(_BYTE *)(a2 + 41);
  return a1;
}

uint64_t getEnumTagSinglePayload for DNSRecords.Browse(uint64_t a1, int a2)
{
  unint64_t v2;

  if (!a2)
    return 0;
  if (a2 < 0 && *(_BYTE *)(a1 + 42))
    return *(_DWORD *)a1 + 0x80000000;
  v2 = *(_QWORD *)(a1 + 16);
  if (v2 >= 0xFFFFFFFF)
    LODWORD(v2) = -1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for DNSRecords.Browse(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_WORD *)(result + 40) = 0;
    *(_QWORD *)result = a2 ^ 0x80000000;
    if (a3 < 0)
      *(_BYTE *)(result + 42) = 1;
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
        return result;
LABEL_8:
      *(_QWORD *)(result + 16) = (a2 - 1);
      return result;
    }
    *(_BYTE *)(result + 42) = 0;
    if (a2)
      goto LABEL_8;
  }
  return result;
}

ValueMetadata *type metadata accessor for DNSRecords.Browse()
{
  return &type metadata for DNSRecords.Browse;
}

_QWORD *sub_1001089A4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v3;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v12[4];
  _QWORD v13[2];

  v5 = *(uint64_t **)(v3 + 16);
  v7 = *v5;
  v6 = v5[1];
  v13[0] = v7;
  v13[1] = v6;
  v12[2] = v13;
  result = sub_100106498((_QWORD *(*)(uint64_t *__return_ptr, uint64_t, uint64_t))sub_100108A00, (uint64_t)v12, a1, a2);
  *a3 = result;
  a3[1] = v9;
  a3[2] = v10;
  a3[3] = v11;
  return result;
}

uint64_t sub_100108A00@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v3;

  return sub_1001064FC(a1, a2, *(uint64_t **)(v3 + 16), a3);
}

uint64_t sub_100108A1C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  char v7;
  uint64_t v8;
  uint64_t v9;

  result = sub_100108A74(a1, a2, *(_QWORD *)(v3 + 16), **(_QWORD **)(v3 + 32), *(_BYTE *)(*(_QWORD *)(v3 + 32) + 8));
  if (!v4)
  {
    *(_QWORD *)a3 = result;
    *(_BYTE *)(a3 + 8) = v7;
    *(_QWORD *)(a3 + 16) = v8;
    *(_QWORD *)(a3 + 24) = v9;
  }
  return result;
}

uint64_t sub_100108A5C(uint64_t a1, uint64_t a2)
{
  return sub_100209404(a1, a2);
}

uint64_t sub_100108A74(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t v5;

  if (!result)
    return a4;
  if (!__OFSUB__(a2 - result, a3))
  {
    sub_1001807E8((uint64_t)&v5, (_BYTE *)(result + a3), a2 - result - a3, a4, a5);
    return v5;
  }
  __break(1u);
  return result;
}

uint64_t sub_100108AE8()
{
  uint64_t v0;

  swift_bridgeObjectRelease(*(_QWORD *)(v0 + 16));
  return swift_deallocObject(v0, 24, 7);
}

uint64_t sub_100108B0C()
{
  uint64_t v0;

  swift_bridgeObjectRelease(*(_QWORD *)(v0 + 32));
  swift_bridgeObjectRelease(*(_QWORD *)(v0 + 48));
  return swift_deallocObject(v0, 58, 7);
}

uint64_t sub_100108B38()
{
  uint64_t v0;

  swift_bridgeObjectRelease(*(_QWORD *)(v0 + 40));
  return swift_deallocObject(v0, 49, 7);
}

uint64_t sub_100108B5C()
{
  uint64_t v0;

  swift_bridgeObjectRelease(*(_QWORD *)(v0 + 32));
  return swift_deallocObject(v0, 41, 7);
}

uint64_t sub_100108B80()
{
  _QWORD *v0;

  swift_bridgeObjectRelease(v0[3]);
  swift_bridgeObjectRelease(v0[5]);
  sub_10000E614(v0[7], v0[8]);
  return swift_deallocObject(v0, 72, 7);
}

uint64_t sub_100108BB8()
{
  uint64_t v0;

  swift_bridgeObjectRelease(*(_QWORD *)(v0 + 32));
  swift_bridgeObjectRelease(*(_QWORD *)(v0 + 72));
  return swift_deallocObject(v0, 80, 7);
}

uint64_t sub_100108BE4()
{
  uint64_t v0;

  swift_bridgeObjectRelease(*(_QWORD *)(v0 + 24));
  swift_bridgeObjectRelease(*(_QWORD *)(v0 + 40));
  return swift_deallocObject(v0, 50, 7);
}

uint64_t AWDLIdleActivity.init(durationSinceLastUnicastTx:durationSinceLastUnicastRx:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  void (*v9)(uint64_t, uint64_t, uint64_t);

  v6 = type metadata accessor for DispatchTimeInterval(0);
  v9 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v6 - 8) + 32);
  v9(a3, a1, v6);
  v7 = a3 + *(int *)(type metadata accessor for AWDLIdleActivity(0) + 20);
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v9)(v7, a2, v6);
}

uint64_t type metadata accessor for AWDLIdleActivity(uint64_t a1)
{
  return sub_10000D69C(a1, qword_100407F60, (uint64_t)&nominal type descriptor for AWDLIdleActivity);
}

void __swiftcall NANDataResponseReceivedEvent.init(datapathID:publishID:initiatorDataAddress:responderDataAddress:responderManagementAddress:attributes:)(CoreP2P::NANDataResponseReceivedEvent *__return_ptr retstr, Swift::UInt8 datapathID, Swift::UInt8 publishID, CoreP2P::WiFiAddress *initiatorDataAddress, CoreP2P::WiFiAddress *responderDataAddress, CoreP2P::WiFiAddress *responderManagementAddress, Swift::OpaquePointer attributes)
{
  ;
}

unint64_t _s7CoreP2P27NANDataRequestReceivedEventV10datapathID07publishH026initiatorManagementAddress0j4DataL010attributesACs5UInt8V_AjA04WiFiL0VALSayAA12NANAttributeOGtcfC_0(unsigned __int8 a1, unsigned __int8 a2, uint64_t a3)
{
  return a1 | ((unint64_t)a2 << 8) | (a3 << 16);
}

void __swiftcall NANDataEstablishedEvent.init(datapathID:initiatorDataAddress:type:responderDataAddress:)(CoreP2P::NANDataEstablishedEvent *__return_ptr retstr, Swift::UInt8 datapathID, CoreP2P::WiFiAddress *initiatorDataAddress, CoreP2P::NANDatapath::DatapathType type, CoreP2P::WiFiAddress *responderDataAddress)
{
  ;
}

unint64_t NANDataTerminationEvent.init(datapathID:initiatorDataAddress:type:reason:)(unsigned __int8 a1, uint64_t a2, char a3)
{
  return a1 | ((a2 & 0xFFFFFFFFFFFFLL) << 8) | ((unint64_t)(a3 & 1) << 56);
}

unint64_t NANDataHostAssistRequest.init(datapathID:publishID:initiatorManagementAddress:initiatorDataAddress:frameType:reason:)(unsigned __int8 a1, unsigned __int8 a2, uint64_t a3)
{
  return a1 | ((unint64_t)a2 << 8) | (a3 << 16);
}

unint64_t _s7CoreP2P24NANFollowUpReceivedEventV15localInstanceID04peerhI00J7Address4rssi10attributesACs5UInt8V_AjA04WiFiK0VAA4RSSIVSayAA12NANAttributeOGtcfC_0(unsigned __int8 a1, unsigned __int8 a2, uint64_t a3)
{
  return a1 | ((unint64_t)a2 << 8) | (a3 << 16);
}

void __swiftcall NANFollowUpTransferCompleteEvent.init(localInstanceID:peerInstanceID:peerAddress:status:)(CoreP2P::NANFollowUpTransferCompleteEvent *__return_ptr retstr, Swift::UInt8 localInstanceID, Swift::UInt8 peerInstanceID, CoreP2P::WiFiAddress *peerAddress, CoreP2P::NANTransferCompleteStatus status)
{
  ;
}

uint64_t NANOOBActionFrameReceivedEvent.init(peerAddress:localAddress:actionFrame:)@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, char a3@<W2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  *(_WORD *)a7 = result;
  *(_BYTE *)(a7 + 2) = BYTE2(result);
  *(_BYTE *)(a7 + 3) = BYTE3(result);
  *(_BYTE *)(a7 + 4) = BYTE4(result);
  *(_BYTE *)(a7 + 5) = BYTE5(result);
  *(_WORD *)(a7 + 6) = a2;
  *(_BYTE *)(a7 + 8) = BYTE2(a2);
  *(_BYTE *)(a7 + 9) = BYTE3(a2);
  *(_BYTE *)(a7 + 10) = BYTE4(a2);
  *(_BYTE *)(a7 + 11) = BYTE5(a2);
  *(_BYTE *)(a7 + 16) = a3;
  *(_QWORD *)(a7 + 24) = a4;
  *(_QWORD *)(a7 + 32) = a5;
  *(_QWORD *)(a7 + 40) = a6;
  return result;
}

CoreP2P::NANOOBActionFrameTrasmitStatus __swiftcall NANOOBActionFrameTrasmitStatus.init(token:result:reason:)(Swift::UInt16 token, CoreP2P::NANOOBActionFrameTrasmitStatus::Result result, CoreP2P::NANOOBActionFrameTrasmitStatus::Reason reason)
{
  return (CoreP2P::NANOOBActionFrameTrasmitStatus)((result << 16) | (reason << 24) | token);
}

uint64_t AWDLSoftAPChannelChangedEvent.init(enabled:channel:)(char a1, int a2)
{
  uint64_t v3;

  LOBYTE(v3) = a1;
  HIDWORD(v3) = a2;
  return v3;
}

void DriverEvent.shortDescription.getter()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  char *v3;
  uint64_t (*v4)(_QWORD);
  char *v5;
  uint64_t v6;

  type metadata accessor for DriverEvent.AWDL(0);
  __chkstk_darwin();
  v1 = type metadata accessor for DriverEvent(0);
  __chkstk_darwin();
  v3 = (char *)&v6 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_1000637E0(v0, (uint64_t)v3, v4);
  v5 = (char *)sub_100108EF4 + 4 * byte_100347460[swift_getEnumCaseMultiPayload(v3, v1)];
  __asm { BR              X10 }
}

uint64_t sub_100108EF4()
{
  uint64_t v0;
  const void *v1;
  uint64_t v2;
  uint64_t v3;

  sub_100063888(v1, (void *)(v0 + 8));
  DriverEvent.NAN.shortDescription.getter();
  v3 = v2;
  sub_100112DC4(v0 + 8, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, __int16))sub_100063114);
  return v3;
}

void sub_1001090B8()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  *(_QWORD *)(v1 + 8) = &type metadata for InfraAssociationStartEvent;
  v8 = v0;
  v9 = sub_100012C44(&qword_100407E20);
  String.init<A>(describing:)(v1 + 8, v9);
  sub_1000131C4(v8, v5, v6, v3, v4, v2, v7);
  JUMPOUT(0x100109090);
}

void sub_1001090C4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  *(_QWORD *)(v1 + 8) = &type metadata for InfraAssociationJoinStatus;
  v8 = v0;
  v9 = sub_100012C44(&qword_100407E20);
  String.init<A>(describing:)(v1 + 8, v9);
  sub_1000131C4(v8, v5, v6, v3, v4, v2, v7);
  JUMPOUT(0x100109090);
}

void sub_100109124()
{
  JUMPOUT(0x100109090);
}

void sub_100109178()
{
  uint64_t v0;
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  BOOL v7;

  if (v5 | v4 | v0 | v2 | v3)
    v6 = 0;
  else
    v6 = v1 == 0;
  if (!v6)
  {
    if (v1)
      v7 = 0;
    else
      v7 = v0 == 1;
    if (v7 && (v5 | v4 | v2 | v3) == 0)
      JUMPOUT(0x10010916CLL);
  }
  JUMPOUT(0x100109090);
}

void NANClusterChangeEvent.hash(into:)(int a1, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;

  v2 = a2 >> 8;
  v3 = a2 >> 16;
  v4 = a2 >> 24;
  v5 = HIDWORD(a2);
  v6 = a2 >> 40;
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
}

BOOL static NANClusterChangeEvent.__derived_struct_equals(_:_:)(uint64_t a1, uint64_t a2)
{
  __int16 v4;
  __int16 v5;

  LOBYTE(v5) = BYTE4(a1);
  HIBYTE(v5) = BYTE5(a1);
  LOBYTE(v4) = BYTE4(a2);
  HIBYTE(v4) = BYTE5(a2);
  return (_DWORD)a1 == (_DWORD)a2 && v5 == v4;
}

Swift::Int NANClusterChangeEvent.hashValue.getter(unint64_t a1)
{
  Swift::UInt8 v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD v8[9];

  v1 = a1;
  v2 = a1 >> 8;
  v3 = a1 >> 16;
  v4 = a1 >> 24;
  v5 = HIDWORD(a1);
  v6 = a1 >> 40;
  Hasher.init(_seed:)(v8);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  return Hasher._finalize()();
}

Swift::Int sub_1001093D4()
{
  Swift::UInt8 *v0;
  Swift::UInt8 v1;
  Swift::UInt8 v2;
  Swift::UInt8 v3;
  Swift::UInt8 v4;
  Swift::UInt8 v5;
  Swift::UInt8 v6;
  _QWORD v8[9];

  v1 = *v0;
  v2 = v0[1];
  v3 = v0[2];
  v4 = v0[3];
  v5 = v0[4];
  v6 = v0[5];
  Hasher.init(_seed:)(v8);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  return Hasher._finalize()();
}

void sub_100109480()
{
  Swift::UInt8 *v0;
  Swift::UInt8 v1;
  Swift::UInt8 v2;
  Swift::UInt8 v3;
  Swift::UInt8 v4;
  Swift::UInt8 v5;

  v1 = v0[1];
  v2 = v0[2];
  v3 = v0[3];
  v4 = v0[4];
  v5 = v0[5];
  Hasher._combine(_:)(*v0);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
}

Swift::Int sub_1001094FC()
{
  Swift::UInt8 *v0;
  Swift::UInt8 v1;
  Swift::UInt8 v2;
  Swift::UInt8 v3;
  Swift::UInt8 v4;
  Swift::UInt8 v5;
  Swift::UInt8 v6;
  _QWORD v8[9];

  v1 = *v0;
  v2 = v0[1];
  v3 = v0[2];
  v4 = v0[3];
  v5 = v0[4];
  v6 = v0[5];
  Hasher.init(_seed:)(v8);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  return Hasher._finalize()();
}

BOOL sub_1001095A4(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)a1 == *(_DWORD *)a2 && *(unsigned __int16 *)(a1 + 4) == *(unsigned __int16 *)(a2 + 4);
}

void NANRoleChangeEvent.hash(into:)(uint64_t a1, char a2, Swift::UInt a3)
{
  Swift::UInt v4;
  Swift::UInt8 v5;

  switch(a2)
  {
    case 2:
      v4 = 0;
      break;
    case 3:
      v4 = 1;
      break;
    case 4:
      v4 = 2;
      break;
    default:
      v5 = a2 & 1;
      Hasher._combine(_:)(3uLL);
      Hasher._combine(_:)(v5);
      goto LABEL_9;
  }
  Hasher._combine(_:)(v4);
LABEL_9:
  Hasher._combine(_:)(a3);
}

BOOL static NANRoleChangeEvent.__derived_struct_equals(_:_:)(char a1, uint64_t a2, unsigned __int8 a3, uint64_t a4)
{
  switch(a1)
  {
    case 2:
      if (a3 != 2)
        return 0;
      return a2 == a4;
    case 3:
      if (a3 != 3)
        return 0;
      return a2 == a4;
    case 4:
      if (a3 == 4)
        return a2 == a4;
      break;
    default:
      if (a3 - 2 >= 3 && ((a1 & 1) == 0) != (a3 & 1))
        return a2 == a4;
      break;
  }
  return 0;
}

Swift::Int NANRoleChangeEvent.hashValue.getter(char a1, Swift::UInt a2)
{
  Swift::UInt v4;
  _QWORD v6[9];

  Hasher.init(_seed:)(v6);
  switch(a1)
  {
    case 2:
      v4 = 0;
      break;
    case 3:
      v4 = 1;
      break;
    case 4:
      v4 = 2;
      break;
    default:
      Hasher._combine(_:)(3uLL);
      Hasher._combine(_:)(a1 & 1);
      goto LABEL_9;
  }
  Hasher._combine(_:)(v4);
LABEL_9:
  Hasher._combine(_:)(a2);
  return Hasher._finalize()();
}

Swift::Int sub_1001097B0()
{
  uint64_t v0;

  return NANRoleChangeEvent.hashValue.getter(*(_BYTE *)v0, *(_QWORD *)(v0 + 8));
}

void sub_1001097BC()
{
  unsigned __int8 *v0;
  int v1;
  Swift::UInt v2;
  Swift::UInt v3;
  Swift::UInt8 v4;

  v1 = *v0;
  v2 = *((_QWORD *)v0 + 1);
  switch(v1)
  {
    case 2:
      v3 = 0;
      break;
    case 3:
      v3 = 1;
      break;
    case 4:
      v3 = 2;
      break;
    default:
      v4 = v1 & 1;
      Hasher._combine(_:)(3uLL);
      Hasher._combine(_:)(v4);
      goto LABEL_9;
  }
  Hasher._combine(_:)(v3);
LABEL_9:
  Hasher._combine(_:)(v2);
}

Swift::Int sub_10010983C()
{
  unsigned __int8 *v0;
  int v1;
  Swift::UInt v2;
  Swift::UInt v3;
  _QWORD v5[9];

  v1 = *v0;
  v2 = *((_QWORD *)v0 + 1);
  Hasher.init(_seed:)(v5);
  switch(v1)
  {
    case 2:
      v3 = 0;
      break;
    case 3:
      v3 = 1;
      break;
    case 4:
      v3 = 2;
      break;
    default:
      Hasher._combine(_:)(3uLL);
      Hasher._combine(_:)(v1 & 1);
      goto LABEL_9;
  }
  Hasher._combine(_:)(v3);
LABEL_9:
  Hasher._combine(_:)(v2);
  return Hasher._finalize()();
}

BOOL sub_1001098E4(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2;
  int v3;

  v2 = *a1;
  v3 = *a2;
  switch(v2)
  {
    case 2:
      if (v3 != 2)
        return 0;
      return *((_QWORD *)a1 + 1) == *((_QWORD *)a2 + 1);
    case 3:
      if (v3 != 3)
        return 0;
      return *((_QWORD *)a1 + 1) == *((_QWORD *)a2 + 1);
    case 4:
      if (v3 == 4)
        return *((_QWORD *)a1 + 1) == *((_QWORD *)a2 + 1);
      break;
    default:
      if ((v3 - 2) >= 3 && ((v2 & 1) == 0) != (v3 & 1))
        return *((_QWORD *)a1 + 1) == *((_QWORD *)a2 + 1);
      break;
  }
  return 0;
}

uint64_t static NANFollowUpReceivedEvent.__derived_struct_equals(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return sub_100110500(a1, a2, a3, a4, a5, a6) & 1;
}

uint64_t sub_10010998C()
{
  _QWORD *v0;

  return NANFollowUpReceivedEvent.hashValue.getter(*v0, v0[1], v0[2]);
}

uint64_t sub_100109998(int a1)
{
  _QWORD *v1;

  return NANFollowUpReceivedEvent.hash(into:)(a1, *v1);
}

uint64_t sub_1001099A4(uint64_t *a1, uint64_t *a2)
{
  return sub_100110500(*a1, a1[1], a1[2], *a2, a2[1], a2[2]) & 1;
}

uint64_t sub_1001099DC(uint64_t a1, uint64_t a2)
{
  return sub_10010A370(a1, a2, (uint64_t (*)(_QWORD, unint64_t, _QWORD))NANDataRequestReceivedEvent.hashValue.getter);
}

uint64_t sub_1001099E8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_10010A394(a1, a2, a3, (uint64_t (*)(uint64_t, _QWORD, unint64_t, _QWORD))NANDataRequestReceivedEvent.hash(into:));
}

unint64_t NANDataResponseReceivedEvent.responderManagementAddress.getter(uint64_t a1, uint64_t a2, unsigned int a3)
{
  return ((unint64_t)HIBYTE(a3) << 40) | ((unint64_t)BYTE2(a3) << 32) | (a3 << 16) & 0xFF000000 | (a3 << 16) & 0xFF0000 | HIWORD(a2);
}

double NANDataResponseReceivedEvent.hash(into:)(int a1, unint64_t a2, unint64_t a3, unsigned int a4, uint64_t a5)
{
  Swift::UInt8 v6;
  Swift::UInt8 v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  Swift::UInt v13;
  double result;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  Swift::UInt8 v18[8];
  Swift::UInt8 v19[8];
  Swift::UInt8 v20[8];
  Swift::UInt8 v21[8];
  Swift::UInt8 v22[8];
  Swift::UInt8 v23[8];
  Swift::UInt8 v24[8];
  Swift::UInt8 v25[8];
  Swift::UInt8 v26[8];
  Swift::UInt8 v27[4];
  Swift::UInt8 v28[4];
  unsigned int v29;

  v6 = a4;
  v7 = a3;
  v8 = a2 >> 8;
  v9 = a2 >> 16;
  v10 = a2 >> 24;
  v11 = HIDWORD(a2);
  v12 = a2 >> 40;
  *(_QWORD *)v18 = HIWORD(a2);
  *(_QWORD *)v19 = HIBYTE(a2);
  *(_QWORD *)v20 = a3 >> 8;
  *(_QWORD *)v21 = a3 >> 16;
  *(_QWORD *)v22 = a3 >> 24;
  *(_QWORD *)v23 = HIDWORD(a3);
  *(_QWORD *)v24 = a3 >> 40;
  *(_QWORD *)v25 = HIWORD(a3);
  *(_QWORD *)v26 = HIBYTE(a3);
  *(_DWORD *)v27 = a4 >> 8;
  *(_DWORD *)v28 = HIWORD(a4);
  v29 = HIBYTE(a4);
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(v11);
  Hasher._combine(_:)(v12);
  Hasher._combine(_:)(v18[0]);
  Hasher._combine(_:)(v19[0]);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v20[0]);
  Hasher._combine(_:)(v21[0]);
  Hasher._combine(_:)(v22[0]);
  Hasher._combine(_:)(v23[0]);
  Hasher._combine(_:)(v24[0]);
  Hasher._combine(_:)(v25[0]);
  Hasher._combine(_:)(v26[0]);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v27[0]);
  Hasher._combine(_:)(v28[0]);
  Hasher._combine(_:)(v29);
  v13 = *(_QWORD *)(a5 + 16);
  Hasher._combine(_:)(v13);
  if (v13)
  {
    v15 = *(_QWORD *)(type metadata accessor for NANAttribute(0) - 8);
    v16 = a5 + ((*(unsigned __int8 *)(v15 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v15 + 80));
    v17 = *(_QWORD *)(v15 + 72);
    swift_bridgeObjectRetain(a5);
    do
    {
      NANAttribute.hash(into:)();
      v16 += v17;
      --v13;
    }
    while (v13);
    *(_QWORD *)&result = swift_bridgeObjectRelease(a5).n128_u64[0];
  }
  return result;
}

Swift::Int NANDataResponseReceivedEvent.hashValue.getter(unint64_t a1, unint64_t a2, unsigned int a3, uint64_t a4)
{
  Swift::UInt8 v5;
  Swift::UInt8 v6;
  Swift::UInt8 v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  Swift::UInt v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  Swift::UInt8 v18[8];
  Swift::UInt8 v19[8];
  Swift::UInt8 v20[8];
  Swift::UInt8 v21[8];
  Swift::UInt8 v22[8];
  Swift::UInt8 v23[8];
  Swift::UInt8 v24[8];
  Swift::UInt8 v25[8];
  Swift::UInt8 v26[8];
  Swift::UInt8 v27[4];
  Swift::UInt8 v28[4];
  Swift::UInt8 v29[4];
  _QWORD v30[10];

  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = a1 >> 8;
  v9 = a1 >> 16;
  v10 = a1 >> 24;
  v11 = HIDWORD(a1);
  v12 = a1 >> 40;
  *(_QWORD *)v18 = HIWORD(a1);
  *(_QWORD *)v19 = HIBYTE(a1);
  *(_QWORD *)v20 = a2 >> 8;
  *(_QWORD *)v21 = a2 >> 16;
  *(_QWORD *)v22 = a2 >> 24;
  *(_QWORD *)v23 = HIDWORD(a2);
  *(_QWORD *)v24 = a2 >> 40;
  *(_QWORD *)v25 = HIWORD(a2);
  *(_QWORD *)v26 = HIBYTE(a2);
  *(_DWORD *)v27 = a3 >> 8;
  *(_DWORD *)v28 = HIWORD(a3);
  *(_DWORD *)v29 = HIBYTE(a3);
  Hasher.init(_seed:)(v30);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(v11);
  Hasher._combine(_:)(v12);
  Hasher._combine(_:)(v18[0]);
  Hasher._combine(_:)(v19[0]);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v20[0]);
  Hasher._combine(_:)(v21[0]);
  Hasher._combine(_:)(v22[0]);
  Hasher._combine(_:)(v23[0]);
  Hasher._combine(_:)(v24[0]);
  Hasher._combine(_:)(v25[0]);
  Hasher._combine(_:)(v26[0]);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v27[0]);
  Hasher._combine(_:)(v28[0]);
  Hasher._combine(_:)(v29[0]);
  v13 = *(_QWORD *)(a4 + 16);
  Hasher._combine(_:)(v13);
  if (v13)
  {
    v14 = *(_QWORD *)(type metadata accessor for NANAttribute(0) - 8);
    v15 = a4 + ((*(unsigned __int8 *)(v14 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80));
    v16 = *(_QWORD *)(v14 + 72);
    swift_bridgeObjectRetain(a4);
    do
    {
      NANAttribute.hash(into:)();
      v15 += v16;
      --v13;
    }
    while (v13);
    swift_bridgeObjectRelease(a4);
  }
  return Hasher._finalize()();
}

Swift::Int sub_100109DFC()
{
  uint64_t v0;

  return NANDataResponseReceivedEvent.hashValue.getter(*(_QWORD *)v0, *(_QWORD *)(v0 + 8), *(_DWORD *)(v0 + 16), *(_QWORD *)(v0 + 24));
}

double sub_100109E0C(int a1)
{
  uint64_t v1;

  return NANDataResponseReceivedEvent.hash(into:)(a1, *(_QWORD *)v1, *(_QWORD *)(v1 + 8), *(_DWORD *)(v1 + 16), *(_QWORD *)(v1 + 24));
}

Swift::Int sub_100109E1C()
{
  uint64_t v0;
  uint64_t v1;
  Swift::UInt8 v2;
  Swift::UInt8 v3;
  Swift::UInt8 v4;
  Swift::UInt8 v5;
  Swift::UInt8 v6;
  Swift::UInt8 v7;
  Swift::UInt8 v8;
  Swift::UInt8 v9;
  Swift::UInt v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  Swift::UInt8 v15;
  Swift::UInt8 v16;
  Swift::UInt8 v17;
  Swift::UInt8 v18;
  Swift::UInt8 v19;
  Swift::UInt8 v20;
  Swift::UInt8 v21;
  Swift::UInt8 v22;
  Swift::UInt8 v23;
  Swift::UInt8 v24;
  Swift::UInt8 v25;
  Swift::UInt8 v26;
  _QWORD v27[9];

  v1 = *(_QWORD *)(v0 + 24);
  v2 = *(_BYTE *)v0;
  v3 = *(_BYTE *)(v0 + 1);
  v4 = *(_BYTE *)(v0 + 2);
  v5 = *(_BYTE *)(v0 + 3);
  v6 = *(_BYTE *)(v0 + 4);
  v7 = *(_BYTE *)(v0 + 5);
  v8 = *(_BYTE *)(v0 + 6);
  v9 = *(_BYTE *)(v0 + 7);
  v15 = *(_BYTE *)(v0 + 8);
  v16 = *(_BYTE *)(v0 + 9);
  v17 = *(_BYTE *)(v0 + 10);
  v18 = *(_BYTE *)(v0 + 11);
  v19 = *(_BYTE *)(v0 + 12);
  v20 = *(_BYTE *)(v0 + 13);
  v21 = *(_BYTE *)(v0 + 14);
  v22 = *(_BYTE *)(v0 + 15);
  v23 = *(_BYTE *)(v0 + 16);
  v24 = *(_BYTE *)(v0 + 17);
  v25 = *(_BYTE *)(v0 + 18);
  v26 = *(_BYTE *)(v0 + 19);
  Hasher.init(_seed:)(v27);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v15);
  Hasher._combine(_:)(v16);
  Hasher._combine(_:)(v17);
  Hasher._combine(_:)(v18);
  Hasher._combine(_:)(v19);
  Hasher._combine(_:)(v20);
  Hasher._combine(_:)(v21);
  Hasher._combine(_:)(v22);
  Hasher._combine(_:)(v23);
  Hasher._combine(_:)(v24);
  Hasher._combine(_:)(v25);
  Hasher._combine(_:)(v26);
  v10 = *(_QWORD *)(v1 + 16);
  Hasher._combine(_:)(v10);
  if (v10)
  {
    v11 = *(_QWORD *)(type metadata accessor for NANAttribute(0) - 8);
    v12 = v1 + ((*(unsigned __int8 *)(v11 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v11 + 80));
    v13 = *(_QWORD *)(v11 + 72);
    swift_bridgeObjectRetain(v1);
    do
    {
      NANAttribute.hash(into:)();
      v12 += v13;
      --v10;
    }
    while (v10);
    swift_bridgeObjectRelease(v1);
  }
  return Hasher._finalize()();
}

uint64_t sub_10010A020(uint64_t a1, uint64_t a2)
{
  return static NANDataResponseReceivedEvent.__derived_struct_equals(_:_:)(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), *(unsigned int *)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)a2, *(_QWORD *)(a2 + 8), *(unsigned int *)(a2 + 16), *(_QWORD *)(a2 + 24));
}

double _s7CoreP2P27NANDataRequestReceivedEventV4hash4intoys6HasherVz_tF_0(int a1, unint64_t a2, unint64_t a3, uint64_t a4)
{
  Swift::UInt8 v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  Swift::UInt v12;
  double result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  Swift::UInt8 v17[8];
  Swift::UInt8 v18[8];
  Swift::UInt8 v19[8];
  Swift::UInt8 v20[8];
  Swift::UInt8 v21[8];
  Swift::UInt8 v22[8];

  v5 = a3;
  v6 = a2 >> 8;
  v7 = a2 >> 16;
  v8 = a2 >> 24;
  v9 = HIDWORD(a2);
  v10 = a2 >> 40;
  v11 = HIWORD(a2);
  *(_QWORD *)v17 = HIBYTE(a2);
  *(_QWORD *)v18 = a3 >> 8;
  *(_QWORD *)v19 = a3 >> 16;
  *(_QWORD *)v20 = a3 >> 24;
  *(_QWORD *)v21 = HIDWORD(a3);
  *(_QWORD *)v22 = a3 >> 40;
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(v11);
  Hasher._combine(_:)(v17[0]);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v18[0]);
  Hasher._combine(_:)(v19[0]);
  Hasher._combine(_:)(v20[0]);
  Hasher._combine(_:)(v21[0]);
  Hasher._combine(_:)(v22[0]);
  v12 = *(_QWORD *)(a4 + 16);
  Hasher._combine(_:)(v12);
  if (v12)
  {
    v14 = *(_QWORD *)(type metadata accessor for NANAttribute(0) - 8);
    v15 = a4 + ((*(unsigned __int8 *)(v14 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80));
    v16 = *(_QWORD *)(v14 + 72);
    swift_bridgeObjectRetain(a4);
    do
    {
      NANAttribute.hash(into:)();
      v15 += v16;
      --v12;
    }
    while (v12);
    *(_QWORD *)&result = swift_bridgeObjectRelease(a4).n128_u64[0];
  }
  return result;
}

uint64_t static NANDataConfirmReceivedEvent.__derived_struct_equals(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return sub_100110390(a1, a2 & 0xFFFFFFFFFFFFLL, a3, a4, a5 & 0xFFFFFFFFFFFFLL, a6) & 1;
}

Swift::Int _s7CoreP2P27NANDataRequestReceivedEventV9hashValueSivg_0(unint64_t a1, unint64_t a2, uint64_t a3)
{
  Swift::UInt8 v4;
  Swift::UInt8 v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  Swift::UInt8 v12;
  uint64_t v13;
  Swift::UInt v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  Swift::UInt8 v19[8];
  Swift::UInt8 v20[8];
  Swift::UInt8 v21[8];
  Swift::UInt8 v22[8];
  Swift::UInt8 v23[8];
  Swift::UInt8 v24[8];
  _QWORD v25[9];

  v4 = a2;
  v5 = a1;
  v6 = a1 >> 8;
  v7 = a1 >> 16;
  v8 = a1 >> 24;
  v9 = HIDWORD(a1);
  v10 = a1 >> 40;
  v11 = HIWORD(a1);
  *(_QWORD *)v19 = HIBYTE(a1);
  *(_QWORD *)v20 = a2 >> 8;
  *(_QWORD *)v21 = a2 >> 16;
  *(_QWORD *)v22 = a2 >> 24;
  *(_QWORD *)v23 = HIDWORD(a2);
  *(_QWORD *)v24 = a2 >> 40;
  Hasher.init(_seed:)(v25);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  v12 = v8;
  v13 = a3;
  Hasher._combine(_:)(v12);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(v11);
  Hasher._combine(_:)(v19[0]);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v20[0]);
  Hasher._combine(_:)(v21[0]);
  Hasher._combine(_:)(v22[0]);
  Hasher._combine(_:)(v23[0]);
  Hasher._combine(_:)(v24[0]);
  v14 = *(_QWORD *)(a3 + 16);
  Hasher._combine(_:)(v14);
  if (v14)
  {
    v15 = *(_QWORD *)(type metadata accessor for NANAttribute(0) - 8);
    v16 = a3 + ((*(unsigned __int8 *)(v15 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v15 + 80));
    v17 = *(_QWORD *)(v15 + 72);
    swift_bridgeObjectRetain(v13);
    do
    {
      NANAttribute.hash(into:)();
      v16 += v17;
      --v14;
    }
    while (v14);
    swift_bridgeObjectRelease(v13);
  }
  return Hasher._finalize()();
}

uint64_t sub_10010A370(uint64_t a1, uint64_t a2, uint64_t (*a3)(_QWORD, unint64_t, _QWORD))
{
  uint64_t v3;

  return a3(*(_QWORD *)v3, *(unsigned int *)(v3 + 8) | ((unint64_t)*(unsigned __int8 *)(v3 + 12) << 32) | ((unint64_t)*(unsigned __int8 *)(v3 + 13) << 40), *(_QWORD *)(v3 + 16));
}

uint64_t sub_10010A394(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, _QWORD, unint64_t, _QWORD))
{
  uint64_t v4;

  return a4(a1, *(_QWORD *)v4, *(unsigned int *)(v4 + 8) | ((unint64_t)*(unsigned __int8 *)(v4 + 12) << 32) | ((unint64_t)*(unsigned __int8 *)(v4 + 13) << 40), *(_QWORD *)(v4 + 16));
}

Swift::Int sub_10010A3B8()
{
  uint64_t v0;
  uint64_t v1;
  Swift::UInt8 v2;
  Swift::UInt8 v3;
  Swift::UInt8 v4;
  Swift::UInt8 v5;
  Swift::UInt8 v6;
  Swift::UInt8 v7;
  Swift::UInt8 v8;
  Swift::UInt8 v9;
  Swift::UInt8 v10;
  uint64_t v11;
  Swift::UInt v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  Swift::UInt8 v17;
  Swift::UInt8 v18;
  Swift::UInt8 v19;
  Swift::UInt8 v20;
  Swift::UInt8 v21;
  Swift::UInt8 v22;
  _QWORD v23[9];

  v1 = *(_QWORD *)(v0 + 16);
  v2 = *(_BYTE *)v0;
  v3 = *(_BYTE *)(v0 + 1);
  v4 = *(_BYTE *)(v0 + 2);
  v5 = *(_BYTE *)(v0 + 3);
  v6 = *(_BYTE *)(v0 + 4);
  v7 = *(_BYTE *)(v0 + 5);
  v8 = *(_BYTE *)(v0 + 6);
  v9 = *(_BYTE *)(v0 + 7);
  v17 = *(_BYTE *)(v0 + 8);
  v18 = *(_BYTE *)(v0 + 9);
  v19 = *(_BYTE *)(v0 + 10);
  v20 = *(_BYTE *)(v0 + 11);
  v21 = *(_BYTE *)(v0 + 12);
  v22 = *(_BYTE *)(v0 + 13);
  Hasher.init(_seed:)(v23);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  v10 = v7;
  v11 = v1;
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v17);
  Hasher._combine(_:)(v18);
  Hasher._combine(_:)(v19);
  Hasher._combine(_:)(v20);
  Hasher._combine(_:)(v21);
  Hasher._combine(_:)(v22);
  v12 = *(_QWORD *)(v1 + 16);
  Hasher._combine(_:)(v12);
  if (v12)
  {
    v13 = *(_QWORD *)(type metadata accessor for NANAttribute(0) - 8);
    v14 = v1 + ((*(unsigned __int8 *)(v13 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v13 + 80));
    v15 = *(_QWORD *)(v13 + 72);
    swift_bridgeObjectRetain(v11);
    do
    {
      NANAttribute.hash(into:)();
      v14 += v15;
      --v12;
    }
    while (v12);
    swift_bridgeObjectRelease(v11);
  }
  return Hasher._finalize()();
}

uint64_t sub_10010A554(uint64_t a1, uint64_t a2)
{
  return sub_100110390(*(_QWORD *)a1, *(unsigned int *)(a1 + 8) | ((unint64_t)*(unsigned __int8 *)(a1 + 12) << 32) | ((unint64_t)*(unsigned __int8 *)(a1 + 13) << 40), *(_QWORD *)(a1 + 16), *(_QWORD *)a2, *(unsigned int *)(a2 + 8) | ((unint64_t)*(unsigned __int8 *)(a2 + 12) << 32) | ((unint64_t)*(unsigned __int8 *)(a2 + 13) << 40), *(_QWORD *)(a2 + 16)) & 1;
}

void NANDataEstablishedEvent.hash(into:)(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;

  v6 = a2 >> 8;
  v7 = a2 >> 16;
  v8 = a2 >> 24;
  v9 = HIDWORD(a2);
  v10 = a2 >> 40;
  v11 = HIWORD(a2);
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(v11);
  if ((a2 & 0x100000000000000) != 0)
    v12 = 0x73616369746C756DLL;
  else
    v12 = 0x74736163696E75;
  if ((a2 & 0x100000000000000) != 0)
    v13 = 0xE900000000000074;
  else
    v13 = 0xE700000000000000;
  String.hash(into:)(a1, v12, v13);
  swift_bridgeObjectRelease(v13);
  Hasher._combine(_:)(a3);
  Hasher._combine(_:)(BYTE1(a3));
  Hasher._combine(_:)(BYTE2(a3));
  Hasher._combine(_:)(BYTE3(a3));
  Hasher._combine(_:)(BYTE4(a3));
  Hasher._combine(_:)(BYTE5(a3));
}

BOOL static NANDataEstablishedEvent.__derived_struct_equals(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_10010F214(a1 & 0x1FFFFFFFFFFFFFFLL, a2 & 0xFFFFFFFFFFFFLL, a3 & 0x1FFFFFFFFFFFFFFLL, a4 & 0xFFFFFFFFFFFFLL);
}

Swift::Int NANDataEstablishedEvent.hashValue.getter(unint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  _QWORD v13[9];

  v4 = a1 >> 8;
  v5 = a1 >> 16;
  v6 = a1 >> 24;
  v7 = HIDWORD(a1);
  v8 = a1 >> 40;
  v9 = HIWORD(a1);
  Hasher.init(_seed:)(v13);
  Hasher._combine(_:)(a1);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  if ((a1 & 0x100000000000000) != 0)
    v10 = 0x73616369746C756DLL;
  else
    v10 = 0x74736163696E75;
  if ((a1 & 0x100000000000000) != 0)
    v11 = 0xE900000000000074;
  else
    v11 = 0xE700000000000000;
  String.hash(into:)(v13, v10, v11);
  swift_bridgeObjectRelease(v11);
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(BYTE1(a2));
  Hasher._combine(_:)(BYTE2(a2));
  Hasher._combine(_:)(BYTE3(a2));
  Hasher._combine(_:)(BYTE4(a2));
  Hasher._combine(_:)(BYTE5(a2));
  return Hasher._finalize()();
}

Swift::Int sub_10010A850()
{
  unsigned int *v0;
  uint64_t v1;

  v1 = 0x100000000000000;
  if (!*((_BYTE *)v0 + 7))
    v1 = 0;
  return NANDataEstablishedEvent.hashValue.getter(*v0 | ((unint64_t)*((unsigned __int8 *)v0 + 4) << 32) | ((unint64_t)*((unsigned __int8 *)v0 + 5) << 40) | ((unint64_t)*((unsigned __int8 *)v0 + 6) << 48) | v1, v0[2] | ((unint64_t)*((unsigned __int8 *)v0 + 12) << 32) | ((unint64_t)*((unsigned __int8 *)v0+ 13) << 40));
}

void sub_10010A898(uint64_t a1)
{
  unsigned int *v1;
  uint64_t v2;

  v2 = 0x100000000000000;
  if (!*((_BYTE *)v1 + 7))
    v2 = 0;
  NANDataEstablishedEvent.hash(into:)(a1, *v1 | ((unint64_t)*((unsigned __int8 *)v1 + 4) << 32) | ((unint64_t)*((unsigned __int8 *)v1 + 5) << 40) | ((unint64_t)*((unsigned __int8 *)v1 + 6) << 48) | v2, v1[2] | ((unint64_t)*((unsigned __int8 *)v1 + 12) << 32) | ((unint64_t)*((unsigned __int8 *)v1 + 13) << 40));
}

Swift::Int sub_10010A8E0()
{
  unsigned int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[9];

  v1 = *v0;
  v2 = *((unsigned __int8 *)v0 + 4);
  v3 = *((unsigned __int8 *)v0 + 5);
  v4 = *((unsigned __int8 *)v0 + 6);
  v5 = *((unsigned __int8 *)v0 + 7);
  v6 = v0[2];
  v7 = *((unsigned __int8 *)v0 + 12);
  v8 = *((unsigned __int8 *)v0 + 13);
  Hasher.init(_seed:)(v11);
  v9 = 0x100000000000000;
  if (!v5)
    v9 = 0;
  NANDataEstablishedEvent.hash(into:)((uint64_t)v11, v1 | (v2 << 32) | (v3 << 40) | (v4 << 48) | v9, v6 | (v7 << 32) | (v8 << 40));
  return Hasher._finalize()();
}

BOOL sub_10010A974(unsigned int *a1, unsigned int *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v2 = *((unsigned __int8 *)a1 + 6);
  v3 = a1[2];
  v4 = *((unsigned __int8 *)a1 + 12);
  v5 = *((unsigned __int8 *)a1 + 13);
  v6 = *a1 | ((unint64_t)*((unsigned __int8 *)a1 + 4) << 32) | ((unint64_t)*((unsigned __int8 *)a1 + 5) << 40);
  if (*((_BYTE *)a1 + 7))
    v7 = 0x100000000000000;
  else
    v7 = 0;
  v8 = v6 | (v2 << 48) | v7;
  if (*((_BYTE *)a2 + 7))
    v9 = 0x100000000000000;
  else
    v9 = 0;
  return sub_10010F214(v8, v3 | (v4 << 32) | (v5 << 40), *a2 | ((unint64_t)*((unsigned __int8 *)a2 + 4) << 32) | ((unint64_t)*((unsigned __int8 *)a2 + 5) << 40) | ((unint64_t)*((unsigned __int8 *)a2 + 6) << 48) | v9, a2[2] | ((unint64_t)*((unsigned __int8 *)a2 + 12) << 32) | ((unint64_t)*((unsigned __int8 *)a2+ 13) << 40));
}

void NANDataTerminationEvent.hash(into:)(uint64_t a1, unint64_t a2, Swift::UInt a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;

  v6 = a2 >> 8;
  v7 = a2 >> 16;
  v8 = a2 >> 24;
  v9 = HIDWORD(a2);
  v10 = a2 >> 40;
  v11 = HIWORD(a2);
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(v11);
  if ((a2 & 0x100000000000000) != 0)
    v12 = 0x73616369746C756DLL;
  else
    v12 = 0x74736163696E75;
  if ((a2 & 0x100000000000000) != 0)
    v13 = 0xE900000000000074;
  else
    v13 = 0xE700000000000000;
  String.hash(into:)(a1, v12, v13);
  swift_bridgeObjectRelease(v13);
  Hasher._combine(_:)(a3);
}

BOOL static NANDataTerminationEvent.__derived_struct_equals(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_10010FDC8(a1 & 0x1FFFFFFFFFFFFFFLL, a2, a3 & 0x1FFFFFFFFFFFFFFLL, a4);
}

Swift::Int NANDataTerminationEvent.hashValue.getter(unint64_t a1, Swift::UInt a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  _QWORD v13[9];

  v4 = a1 >> 8;
  v5 = a1 >> 16;
  v6 = a1 >> 24;
  v7 = HIDWORD(a1);
  v8 = a1 >> 40;
  v9 = HIWORD(a1);
  Hasher.init(_seed:)(v13);
  Hasher._combine(_:)(a1);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  if ((a1 & 0x100000000000000) != 0)
    v10 = 0x73616369746C756DLL;
  else
    v10 = 0x74736163696E75;
  if ((a1 & 0x100000000000000) != 0)
    v11 = 0xE900000000000074;
  else
    v11 = 0xE700000000000000;
  String.hash(into:)(v13, v10, v11);
  swift_bridgeObjectRelease(v11);
  Hasher._combine(_:)(a2);
  return Hasher._finalize()();
}

Swift::Int sub_10010AC10()
{
  unsigned int *v0;
  uint64_t v1;

  v1 = 0x100000000000000;
  if (!*((_BYTE *)v0 + 7))
    v1 = 0;
  return NANDataTerminationEvent.hashValue.getter(*v0 | ((unint64_t)*((unsigned __int8 *)v0 + 4) << 32) | ((unint64_t)*((unsigned __int8 *)v0 + 5) << 40) | ((unint64_t)*((unsigned __int8 *)v0 + 6) << 48) | v1, *((_QWORD *)v0 + 1));
}

void sub_10010AC48(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  int v4;
  Swift::UInt v5;
  Swift::UInt8 v6;
  Swift::UInt8 v7;
  Swift::UInt8 v8;
  Swift::UInt8 v9;
  Swift::UInt8 v10;
  Swift::UInt8 v11;
  uint64_t v12;
  unint64_t v13;

  v2 = v1;
  v4 = *(unsigned __int8 *)(v2 + 7);
  v5 = *(_QWORD *)(v2 + 8);
  v6 = *(_BYTE *)(v2 + 1);
  v7 = *(_BYTE *)(v2 + 2);
  v8 = *(_BYTE *)(v2 + 3);
  v9 = *(_BYTE *)(v2 + 4);
  v10 = *(_BYTE *)(v2 + 5);
  v11 = *(_BYTE *)(v2 + 6);
  Hasher._combine(_:)(*(_BYTE *)v2);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(v11);
  if (v4)
    v12 = 0x73616369746C756DLL;
  else
    v12 = 0x74736163696E75;
  if (v4)
    v13 = 0xE900000000000074;
  else
    v13 = 0xE700000000000000;
  String.hash(into:)(a1, v12, v13);
  swift_bridgeObjectRelease(v13);
  Hasher._combine(_:)(v5);
}

Swift::Int sub_10010AD34()
{
  uint64_t v0;
  int v1;
  Swift::UInt v2;
  Swift::UInt8 v3;
  Swift::UInt8 v4;
  Swift::UInt8 v5;
  Swift::UInt8 v6;
  Swift::UInt8 v7;
  Swift::UInt8 v8;
  Swift::UInt8 v9;
  uint64_t v10;
  unint64_t v11;
  _QWORD v13[9];

  v1 = *(unsigned __int8 *)(v0 + 7);
  v2 = *(_QWORD *)(v0 + 8);
  v3 = *(_BYTE *)v0;
  v4 = *(_BYTE *)(v0 + 1);
  v5 = *(_BYTE *)(v0 + 2);
  v6 = *(_BYTE *)(v0 + 3);
  v7 = *(_BYTE *)(v0 + 4);
  v8 = *(_BYTE *)(v0 + 5);
  v9 = *(_BYTE *)(v0 + 6);
  Hasher.init(_seed:)(v13);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  if (v1)
    v10 = 0x73616369746C756DLL;
  else
    v10 = 0x74736163696E75;
  if (v1)
    v11 = 0xE900000000000074;
  else
    v11 = 0xE700000000000000;
  String.hash(into:)(v13, v10, v11);
  swift_bridgeObjectRelease(v11);
  Hasher._combine(_:)(v2);
  return Hasher._finalize()();
}

BOOL sub_10010AE54(unsigned int *a1, unsigned int *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;

  v2 = *((_QWORD *)a1 + 1);
  v3 = 0x100000000000000;
  if (*((_BYTE *)a1 + 7))
    v4 = 0x100000000000000;
  else
    v4 = 0;
  v5 = *a1 | ((unint64_t)*((unsigned __int8 *)a1 + 4) << 32) | ((unint64_t)*((unsigned __int8 *)a1 + 5) << 40) | ((unint64_t)*((unsigned __int8 *)a1 + 6) << 48) | v4;
  if (!*((_BYTE *)a2 + 7))
    v3 = 0;
  return sub_10010FDC8(v5, v2, *a2 | ((unint64_t)*((unsigned __int8 *)a2 + 4) << 32) | ((unint64_t)*((unsigned __int8 *)a2 + 5) << 40) | ((unint64_t)*((unsigned __int8 *)a2 + 6) << 48) | v3, *((_QWORD *)a2 + 1));
}

unint64_t NANDataHostAssistRequest.frameType.getter(uint64_t a1, unint64_t a2)
{
  return HIWORD(a2);
}

unint64_t NANDataHostAssistRequest.reason.getter(uint64_t a1, unint64_t a2)
{
  return HIBYTE(a2);
}

void NANDataHostAssistRequest.hash(into:)(int a1, unint64_t a2, unint64_t a3)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  int v11;
  Swift::UInt8 v12;
  Swift::UInt8 v13[8];
  Swift::UInt8 v14[8];
  Swift::UInt8 v15[8];
  Swift::UInt8 v16[8];
  Swift::UInt8 v17[8];

  v4 = a2 >> 8;
  v5 = a2 >> 16;
  v6 = a2 >> 24;
  v7 = HIDWORD(a2);
  v8 = a2 >> 40;
  v9 = HIWORD(a2);
  v10 = HIBYTE(a2);
  *(_QWORD *)v13 = a3 >> 8;
  *(_QWORD *)v14 = a3 >> 16;
  *(_QWORD *)v15 = a3 >> 24;
  *(_QWORD *)v16 = HIDWORD(a3);
  *(_QWORD *)v17 = a3 >> 40;
  v11 = BYTE6(a3);
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(a3);
  Hasher._combine(_:)(v13[0]);
  Hasher._combine(_:)(v14[0]);
  Hasher._combine(_:)(v15[0]);
  Hasher._combine(_:)(v16[0]);
  Hasher._combine(_:)(v17[0]);
  if (v11 == 15)
  {
    v12 = 0;
LABEL_6:
    Hasher._combine(_:)(v12);
    goto LABEL_7;
  }
  Hasher._combine(_:)(1u);
  if (v11 != 14)
  {
    Hasher._combine(_:)(1uLL);
    v12 = byte_1003488AC[SBYTE6(a3)];
    goto LABEL_6;
  }
  Hasher._combine(_:)(0);
LABEL_7:
  Hasher._combine(_:)(HIBYTE(a3));
}

Swift::Int NANDataHostAssistRequest.hashValue.getter(unint64_t a1, unint64_t a2)
{
  Swift::UInt8 v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  int v10;
  Swift::UInt8 v11;
  Swift::UInt8 v13[8];
  Swift::UInt8 v14[8];
  Swift::UInt8 v15[8];
  Swift::UInt8 v16[8];
  Swift::UInt8 v17[8];
  Swift::UInt8 v18[8];
  _QWORD v19[9];

  v3 = a1;
  v4 = a1 >> 8;
  v5 = a1 >> 16;
  v6 = a1 >> 24;
  v7 = HIDWORD(a1);
  v8 = a1 >> 40;
  v9 = HIWORD(a1);
  *(_QWORD *)v13 = HIBYTE(a1);
  *(_QWORD *)v14 = a2 >> 8;
  *(_QWORD *)v15 = a2 >> 16;
  *(_QWORD *)v16 = a2 >> 24;
  *(_QWORD *)v17 = HIDWORD(a2);
  *(_QWORD *)v18 = a2 >> 40;
  v10 = BYTE6(a2);
  Hasher.init(_seed:)(v19);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v13[0]);
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v14[0]);
  Hasher._combine(_:)(v15[0]);
  Hasher._combine(_:)(v16[0]);
  Hasher._combine(_:)(v17[0]);
  Hasher._combine(_:)(v18[0]);
  if (v10 == 15)
  {
    v11 = 0;
LABEL_6:
    Hasher._combine(_:)(v11);
    goto LABEL_7;
  }
  Hasher._combine(_:)(1u);
  if (v10 != 14)
  {
    Hasher._combine(_:)(1uLL);
    v11 = byte_1003488AC[SBYTE6(a2)];
    goto LABEL_6;
  }
  Hasher._combine(_:)(0);
LABEL_7:
  Hasher._combine(_:)(HIBYTE(a2));
  return Hasher._finalize()();
}

Swift::Int sub_10010B1D0()
{
  unint64_t *v0;

  return NANDataHostAssistRequest.hashValue.getter(*v0, v0[1]);
}

void sub_10010B1D8(int a1)
{
  unint64_t *v1;

  NANDataHostAssistRequest.hash(into:)(a1, *v1, v1[1]);
}

Swift::Int sub_10010B1E0()
{
  unint64_t *v0;
  unint64_t v1;
  unint64_t v2;
  _QWORD v4[9];

  v1 = *v0;
  v2 = v0[1];
  Hasher.init(_seed:)(v4);
  NANDataHostAssistRequest.hash(into:)((int)v4, v1, v2);
  return Hasher._finalize()();
}

BOOL sub_10010B224(uint64_t a1, uint64_t *a2)
{
  return _s7CoreP2P24NANDataHostAssistRequestV23__derived_struct_equalsySbAC_ACtFZ_0(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), *a2, a2[1]);
}

void NANPublishTerminatedEvent.hash(into:)(int a1, Swift::UInt8 a2, Swift::UInt a3)
{
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(a3);
}

BOOL static NANPublishTerminatedEvent.__derived_struct_equals(_:_:)(char a1, uint64_t a2, char a3, uint64_t a4)
{
  return a1 == a3 && a2 == a4;
}

Swift::Int _s7CoreP2P27NANSubscribeTerminatedEventV9hashValueSivg_0(Swift::UInt8 a1, Swift::UInt a2)
{
  _QWORD v5[9];

  Hasher.init(_seed:)(v5);
  Hasher._combine(_:)(a1);
  Hasher._combine(_:)(a2);
  return Hasher._finalize()();
}

Swift::Int sub_10010B2E8()
{
  uint64_t v0;
  Swift::UInt v1;
  Swift::UInt8 v2;
  _QWORD v4[9];

  v1 = *(_QWORD *)(v0 + 8);
  v2 = *(_BYTE *)v0;
  Hasher.init(_seed:)(v4);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

void sub_10010B344()
{
  uint64_t v0;
  Swift::UInt v1;

  v1 = *(_QWORD *)(v0 + 8);
  Hasher._combine(_:)(*(_BYTE *)v0);
  Hasher._combine(_:)(v1);
}

Swift::Int sub_10010B380()
{
  uint64_t v0;
  Swift::UInt v1;
  Swift::UInt8 v2;
  _QWORD v4[9];

  v1 = *(_QWORD *)(v0 + 8);
  v2 = *(_BYTE *)v0;
  Hasher.init(_seed:)(v4);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

BOOL sub_10010B3D8(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2 && *((_QWORD *)a1 + 1) == *((_QWORD *)a2 + 1);
}

uint64_t NANFollowUpReceivedEvent.serviceInfo.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  char *v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t i;
  uint64_t v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;

  type metadata accessor for NANAttribute(0);
  __chkstk_darwin();
  v5 = (char *)&v34 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin();
  __chkstk_darwin();
  v7 = (char *)&v34 - v6;
  v8 = __chkstk_darwin();
  v12 = (char *)&v34 - v11;
  v13 = *(_QWORD *)(a3 + 16);
  if (v13)
  {
    v34 = v10;
    v35 = v8;
    v14 = a3 + ((*(unsigned __int8 *)(v9 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80));
    v15 = *(_QWORD *)(v9 + 72);
    swift_bridgeObjectRetain(a3);
    v16 = v14;
    v17 = v13;
    while (1)
    {
      sub_1000637E0(v16, (uint64_t)v7, type metadata accessor for NANAttribute);
      NANAttribute.attributeType.getter();
      if (v18 == 14)
        break;
      sub_100063824((uint64_t)v7, type metadata accessor for NANAttribute);
      v16 += v15;
      if (!--v17)
      {
        swift_bridgeObjectRelease(a3);
        v19 = v35;
        goto LABEL_10;
      }
    }
    swift_bridgeObjectRelease(a3);
    sub_100033AC0((uint64_t)v7, (uint64_t)v12, type metadata accessor for NANAttribute);
    v19 = v35;
    if (swift_getEnumCaseMultiPayload(v12, v35) == 14)
      return *((_QWORD *)v12 + 2);
    sub_100063824((uint64_t)v12, type metadata accessor for NANAttribute);
LABEL_10:
    result = swift_bridgeObjectRetain(a3);
    for (i = 0; ; ++i)
    {
      v23 = i + 1;
      if (__OFADD__(i, 1))
      {
        __break(1u);
        return result;
      }
      sub_1000637E0(v14, (uint64_t)v5, type metadata accessor for NANAttribute);
      NANAttribute.attributeType.getter();
      if (v24 == 3)
        break;
      result = sub_100063824((uint64_t)v5, type metadata accessor for NANAttribute);
      v14 += v15;
      if (v23 == v13)
      {
        swift_bridgeObjectRelease(a3);
        return 4;
      }
    }
    swift_bridgeObjectRelease(a3);
    v25 = v34;
    sub_100033AC0((uint64_t)v5, v34, type metadata accessor for NANAttribute);
    if (swift_getEnumCaseMultiPayload(v25, v19) == 3)
    {
      v26 = *(_QWORD *)v25;
      v27 = *(_QWORD *)(v25 + 8);
      v28 = *(_QWORD *)(v25 + 24);
      v29 = *(_QWORD *)(v25 + 32);
      v30 = *(_QWORD *)(v25 + 40);
      v31 = *(unsigned __int16 *)(v25 + 48) | (*(unsigned __int8 *)(v25 + 50) << 16);
      v20 = *(_QWORD *)(v25 + 56);
      v32 = *(_QWORD *)(v25 + 64);
      v33 = *(_QWORD *)(v25 + 72);
      sub_100111B7C(v20, v32, v33);
      sub_10000E614(v26, v27);
      swift_bridgeObjectRelease(v28);
      sub_100111B98(v29, v30, v31);
      sub_100111BBC(v20, v32, v33);
      return v20;
    }
    sub_100063824(v25, type metadata accessor for NANAttribute);
  }
  return 4;
}

uint64_t NANFollowUpReceivedEvent.followUpMessage.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v5 = NANFollowUpReceivedEvent.serviceInfo.getter(a1, a2, a3);
  if (v5 == 4)
    return 0;
  v6 = v3;
  v7 = v4;
  if (v5 != 2
    || (sub_100031FEC(v3, v4), _s7CoreP2P25NANGenericServiceProtocolVyACSg10Foundation4DataVcfC_0(v6, v7),
                               (v9 = v8) == 0))
  {
    sub_100111B7C(v5, v6, v7);
    _s7CoreP2P25NANGenericServiceProtocolVyACSg10Foundation4DataVcfC_0(v6, v7);
    v9 = v10;
    swift_bridgeObjectRelease(0);
  }
  sub_100111BBC(v5, v6, v7);
  return v9;
}

double _s7CoreP2P24NANFollowUpReceivedEventV4hash4intoys6HasherVz_tF_0(int a1, unint64_t a2, Swift::UInt a3, uint64_t a4)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  Swift::UInt v12;
  double result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v5 = a2 >> 8;
  v6 = a2 >> 16;
  v7 = a2 >> 24;
  v8 = HIDWORD(a2);
  v9 = a2 >> 40;
  v10 = HIWORD(a2);
  v11 = HIBYTE(a2);
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(v11);
  Hasher._combine(_:)(a3);
  v12 = *(_QWORD *)(a4 + 16);
  Hasher._combine(_:)(v12);
  if (v12)
  {
    v14 = *(_QWORD *)(type metadata accessor for NANAttribute(0) - 8);
    v15 = a4 + ((*(unsigned __int8 *)(v14 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80));
    v16 = *(_QWORD *)(v14 + 72);
    swift_bridgeObjectRetain(a4);
    do
    {
      NANAttribute.hash(into:)();
      v15 += v16;
      --v12;
    }
    while (v12);
    *(_QWORD *)&result = swift_bridgeObjectRelease(a4).n128_u64[0];
  }
  return result;
}

Swift::Int _s7CoreP2P24NANFollowUpReceivedEventV9hashValueSivg_0(unint64_t a1, Swift::UInt a2, uint64_t a3)
{
  Swift::UInt8 v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  Swift::UInt v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD v18[9];

  v4 = a1;
  v5 = a1 >> 8;
  v6 = a1 >> 16;
  v7 = a1 >> 24;
  v8 = HIDWORD(a1);
  v9 = a1 >> 40;
  v10 = HIWORD(a1);
  v11 = HIBYTE(a1);
  Hasher.init(_seed:)(v18);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(v11);
  Hasher._combine(_:)(a2);
  v12 = *(_QWORD *)(a3 + 16);
  Hasher._combine(_:)(v12);
  if (v12)
  {
    v13 = *(_QWORD *)(type metadata accessor for NANAttribute(0) - 8);
    v14 = a3 + ((*(unsigned __int8 *)(v13 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v13 + 80));
    v15 = *(_QWORD *)(v13 + 72);
    swift_bridgeObjectRetain(a3);
    do
    {
      NANAttribute.hash(into:)();
      v14 += v15;
      --v12;
    }
    while (v12);
    swift_bridgeObjectRelease(a3);
  }
  return Hasher._finalize()();
}

Swift::Int sub_10010B9E4()
{
  uint64_t v0;
  uint64_t v1;
  Swift::UInt8 v2;
  Swift::UInt8 v3;
  Swift::UInt8 v4;
  Swift::UInt8 v5;
  Swift::UInt8 v6;
  Swift::UInt8 v7;
  Swift::UInt8 v8;
  Swift::UInt8 v9;
  Swift::UInt v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  Swift::UInt v15;
  _QWORD v16[9];

  v1 = *(_QWORD *)(v0 + 16);
  v15 = *(_QWORD *)(v0 + 8);
  v2 = *(_BYTE *)v0;
  v3 = *(_BYTE *)(v0 + 1);
  v4 = *(_BYTE *)(v0 + 2);
  v5 = *(_BYTE *)(v0 + 3);
  v6 = *(_BYTE *)(v0 + 4);
  v7 = *(_BYTE *)(v0 + 5);
  v8 = *(_BYTE *)(v0 + 6);
  v9 = *(_BYTE *)(v0 + 7);
  Hasher.init(_seed:)(v16);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v15);
  v10 = *(_QWORD *)(v1 + 16);
  Hasher._combine(_:)(v10);
  if (v10)
  {
    v11 = *(_QWORD *)(type metadata accessor for NANAttribute(0) - 8);
    v12 = v1 + ((*(unsigned __int8 *)(v11 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v11 + 80));
    v13 = *(_QWORD *)(v11 + 72);
    swift_bridgeObjectRetain(v1);
    do
    {
      NANAttribute.hash(into:)();
      v12 += v13;
      --v10;
    }
    while (v10);
    swift_bridgeObjectRelease(v1);
  }
  return Hasher._finalize()();
}

uint64_t NANTransferCompleteStatus.apiError.getter(char a1)
{
  if (a1)
    return 7;
  else
    return 0;
}

BOOL NANTransferCompleteStatus.shouldRetry.getter(char a1)
{
  return a1 != 3 && a1 != 0;
}

uint64_t NANTransferCompleteStatus.description.getter(unsigned __int8 a1)
{
  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_10010BB78 + 4 * byte_100347471[a1]))(0x73736563637573, 0xE700000000000000);
}

uint64_t sub_10010BB78()
{
  return 0x756F2064656D6974;
}

uint64_t sub_10010BB94()
{
  return 0x646570706F7264;
}

unint64_t sub_10010BBA8()
{
  return 0xD000000000000010;
}

uint64_t sub_10010BBC4()
{
  unsigned __int8 *v0;

  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_10010BBF4 + 4 * byte_100347475[*v0]))(0x73736563637573, 0xE700000000000000);
}

uint64_t sub_10010BBF4()
{
  return 0x756F2064656D6974;
}

uint64_t sub_10010BC10()
{
  return 0x646570706F7264;
}

unint64_t sub_10010BC24()
{
  return 0xD000000000000010;
}

void NANFollowUpTransferCompleteEvent.hash(into:)(int a1, unint64_t a2, unsigned __int8 a3)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;

  v4 = a2 >> 8;
  v5 = a2 >> 16;
  v6 = a2 >> 24;
  v7 = HIDWORD(a2);
  v8 = a2 >> 40;
  v9 = HIWORD(a2);
  v10 = HIBYTE(a2);
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(a3);
}

Swift::Int NANFollowUpTransferCompleteEvent.hashValue.getter(unint64_t a1, unsigned __int8 a2)
{
  Swift::UInt8 v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD v12[9];

  v3 = a1;
  v4 = a1 >> 8;
  v5 = a1 >> 16;
  v6 = a1 >> 24;
  v7 = HIDWORD(a1);
  v8 = a1 >> 40;
  v9 = HIWORD(a1);
  v10 = HIBYTE(a1);
  Hasher.init(_seed:)(v12);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(a2);
  return Hasher._finalize()();
}

Swift::Int sub_10010BDCC()
{
  Swift::UInt8 *v0;
  Swift::UInt v1;
  Swift::UInt8 v2;
  Swift::UInt8 v3;
  Swift::UInt8 v4;
  Swift::UInt8 v5;
  Swift::UInt8 v6;
  Swift::UInt8 v7;
  Swift::UInt8 v8;
  Swift::UInt8 v9;
  _QWORD v11[9];

  v1 = v0[8];
  v2 = *v0;
  v3 = v0[1];
  v4 = v0[2];
  v5 = v0[3];
  v6 = v0[4];
  v7 = v0[5];
  v8 = v0[6];
  v9 = v0[7];
  Hasher.init(_seed:)(v11);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

void sub_10010BEB0()
{
  Swift::UInt8 *v0;
  Swift::UInt v1;
  Swift::UInt8 v2;
  Swift::UInt8 v3;
  Swift::UInt8 v4;
  Swift::UInt8 v5;
  Swift::UInt8 v6;
  Swift::UInt8 v7;
  Swift::UInt8 v8;

  v1 = v0[8];
  v2 = v0[1];
  v3 = v0[2];
  v4 = v0[3];
  v5 = v0[4];
  v6 = v0[5];
  v7 = v0[6];
  v8 = v0[7];
  Hasher._combine(_:)(*v0);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v1);
}

Swift::Int sub_10010BF58()
{
  Swift::UInt8 *v0;
  Swift::UInt v1;
  Swift::UInt8 v2;
  Swift::UInt8 v3;
  Swift::UInt8 v4;
  Swift::UInt8 v5;
  Swift::UInt8 v6;
  Swift::UInt8 v7;
  Swift::UInt8 v8;
  Swift::UInt8 v9;
  _QWORD v11[9];

  v1 = v0[8];
  v2 = *v0;
  v3 = v0[1];
  v4 = v0[2];
  v5 = v0[3];
  v6 = v0[4];
  v7 = v0[5];
  v8 = v0[6];
  v9 = v0[7];
  Hasher.init(_seed:)(v11);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

BOOL sub_10010C038(uint64_t a1, uint64_t a2)
{
  return _s7CoreP2P32NANFollowUpTransferCompleteEventV23__derived_struct_equalsySbAC_ACtFZ_0(*(_QWORD *)a1, *(_BYTE *)(a1 + 8), *(_QWORD *)a2, *(_BYTE *)(a2 + 8));
}

unint64_t NANDataManagementFrameTransferCompleteEvent.frameType.getter(unint64_t a1)
{
  return HIBYTE(a1);
}

uint64_t NANDataManagementFrameTransferCompleteEvent.init(datapathID:initiatorDataAddress:frameType:status:)(unsigned __int8 a1, uint64_t a2, uint64_t a3)
{
  return a1 | ((a2 & 0xFFFFFFFFFFFFLL) << 8) | (a3 << 56);
}

void NANDataManagementFrameTransferCompleteEvent.hash(into:)(int a1, unint64_t a2, unsigned __int8 a3)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;

  v5 = a2 >> 8;
  v6 = a2 >> 16;
  v7 = a2 >> 24;
  v8 = HIDWORD(a2);
  v9 = a2 >> 40;
  v10 = HIWORD(a2);
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  if (HIBYTE(a2) == 14)
  {
    Hasher._combine(_:)(0);
  }
  else
  {
    Hasher._combine(_:)(1uLL);
    Hasher._combine(_:)(byte_1003488AC[(uint64_t)a2 >> 56]);
  }
  Hasher._combine(_:)(a3);
}

Swift::Int NANDataManagementFrameTransferCompleteEvent.hashValue.getter(unint64_t a1, unsigned __int8 a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD v11[9];

  v4 = a1 >> 8;
  v5 = a1 >> 16;
  v6 = a1 >> 24;
  v7 = HIDWORD(a1);
  v8 = a1 >> 40;
  v9 = HIWORD(a1);
  Hasher.init(_seed:)(v11);
  Hasher._combine(_:)(a1);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  if (HIBYTE(a1) == 14)
  {
    Hasher._combine(_:)(0);
  }
  else
  {
    Hasher._combine(_:)(1uLL);
    Hasher._combine(_:)(byte_1003488AC[(uint64_t)a1 >> 56]);
  }
  Hasher._combine(_:)(a2);
  return Hasher._finalize()();
}

Swift::Int sub_10010C250()
{
  uint64_t v0;

  return NANDataManagementFrameTransferCompleteEvent.hashValue.getter(*(_QWORD *)v0, *(_BYTE *)(v0 + 8));
}

void sub_10010C25C()
{
  Swift::UInt8 *v0;
  uint64_t v1;
  Swift::UInt v2;
  Swift::UInt8 v3;
  Swift::UInt8 v4;
  Swift::UInt8 v5;
  Swift::UInt8 v6;
  Swift::UInt8 v7;
  Swift::UInt8 v8;

  v1 = (char)v0[7];
  v2 = v0[8];
  v3 = v0[1];
  v4 = v0[2];
  v5 = v0[3];
  v6 = v0[4];
  v7 = v0[5];
  v8 = v0[6];
  Hasher._combine(_:)(*v0);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  if (v1 == 14)
  {
    Hasher._combine(_:)(0);
  }
  else
  {
    Hasher._combine(_:)(1uLL);
    Hasher._combine(_:)(byte_1003488AC[v1]);
  }
  Hasher._combine(_:)(v2);
}

Swift::Int sub_10010C328()
{
  Swift::UInt8 *v0;
  uint64_t v1;
  Swift::UInt v2;
  Swift::UInt8 v3;
  Swift::UInt8 v4;
  Swift::UInt8 v5;
  Swift::UInt8 v6;
  Swift::UInt8 v7;
  Swift::UInt8 v8;
  Swift::UInt8 v9;
  _QWORD v11[9];

  v1 = (char)v0[7];
  v2 = v0[8];
  v3 = *v0;
  v4 = v0[1];
  v5 = v0[2];
  v6 = v0[3];
  v7 = v0[4];
  v8 = v0[5];
  v9 = v0[6];
  Hasher.init(_seed:)(v11);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  if (v1 == 14)
  {
    Hasher._combine(_:)(0);
  }
  else
  {
    Hasher._combine(_:)(1uLL);
    Hasher._combine(_:)(byte_1003488AC[v1]);
  }
  Hasher._combine(_:)(v2);
  return Hasher._finalize()();
}

BOOL sub_10010C430(uint64_t a1, uint64_t a2)
{
  return _s7CoreP2P43NANDataManagementFrameTransferCompleteEventV23__derived_struct_equalsySbAC_ACtFZ_0(*(_QWORD *)a1, *(_BYTE *)(a1 + 8), *(_QWORD *)a2, *(_BYTE *)(a2 + 8));
}

uint64_t NANOOBActionFrameTrasmitStatus.reason.getter(unsigned int a1)
{
  return HIBYTE(a1);
}

void NANOOBActionFrameTrasmitStatus.hash(into:)(int a1, unsigned int a2)
{
  unsigned __int8 v2;
  Swift::UInt v3;

  v2 = BYTE2(a2);
  v3 = HIBYTE(a2);
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
}

BOOL static NANOOBActionFrameTrasmitStatus.__derived_struct_equals(_:_:)(unsigned int a1, int a2)
{
  return ((a2 ^ a1) & 0xFF0000) == 0 && (unsigned __int16)a1 == (unsigned __int16)a2 && (a2 ^ a1) >> 24 == 0;
}

Swift::Int NANOOBActionFrameTrasmitStatus.hashValue.getter(unsigned int a1)
{
  Swift::UInt v2;
  _QWORD v4[9];

  v2 = HIBYTE(a1);
  Hasher.init(_seed:)(v4);
  Hasher._combine(_:)(a1);
  Hasher._combine(_:)(BYTE2(a1));
  Hasher._combine(_:)(v2);
  return Hasher._finalize()();
}

Swift::Int sub_10010C520()
{
  uint64_t v0;
  Swift::UInt v1;
  Swift::UInt v2;
  Swift::UInt16 v3;
  _QWORD v5[9];

  v1 = *(unsigned __int8 *)(v0 + 2);
  v2 = *(unsigned __int8 *)(v0 + 3);
  v3 = *(_WORD *)v0;
  Hasher.init(_seed:)(v5);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  return Hasher._finalize()();
}

void sub_10010C58C()
{
  uint64_t v0;
  Swift::UInt v1;
  Swift::UInt v2;

  v1 = *(unsigned __int8 *)(v0 + 2);
  v2 = *(unsigned __int8 *)(v0 + 3);
  Hasher._combine(_:)(*(_WORD *)v0);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
}

Swift::Int sub_10010C5D4()
{
  uint64_t v0;
  Swift::UInt v1;
  Swift::UInt v2;
  Swift::UInt16 v3;
  _QWORD v5[9];

  v1 = *(unsigned __int8 *)(v0 + 2);
  v2 = *(unsigned __int8 *)(v0 + 3);
  v3 = *(_WORD *)v0;
  Hasher.init(_seed:)(v5);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v1);
  Hasher._combine(_:)(v2);
  return Hasher._finalize()();
}

BOOL sub_10010C63C(unsigned __int16 *a1, unsigned __int16 *a2)
{
  return *a1 == *a2
      && *((unsigned __int8 *)a1 + 2) == *((unsigned __int8 *)a2 + 2)
      && *((unsigned __int8 *)a1 + 3) == *((unsigned __int8 *)a2 + 3);
}

uint64_t NANOOBActionFrameReceivedEvent.actionFrame.getter()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = *(_QWORD *)(v0 + 24);
  v2 = *(_QWORD *)(v0 + 32);
  v3 = *(_QWORD *)(v0 + 40);
  v4 = *(unsigned __int8 *)(v0 + 16);
  sub_100063D24(v1, v2, v3);
  return v4;
}

BOOL NANOOBActionFrameReceivedEvent.isSecure.getter()
{
  uint64_t v0;

  return *(_BYTE *)(v0 + 16) == 4;
}

void NANOOBActionFrameReceivedEvent.hash(into:)()
{
  uint64_t v0;
  uint64_t *v1;
  Swift::UInt8 v2;
  Swift::UInt8 v3;
  Swift::UInt8 v4;
  Swift::UInt8 v5;
  Swift::UInt8 v6;
  Swift::UInt8 v7;
  Swift::UInt8 v8;
  Swift::UInt8 v9;
  Swift::UInt8 v10;
  Swift::UInt8 v11;
  __int128 v12;
  unint64_t v13;
  Swift::UInt32 v14;
  uint64_t v15;
  Swift::UInt8 v16;
  Swift::UInt v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  Swift::UInt v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  _OWORD v27[2];
  __n128 v28;
  __n128 v29;
  uint64_t v30;
  __n128 v31;
  char v32;
  char v33;

  v1 = (uint64_t *)v0;
  v2 = *(_BYTE *)(v0 + 1);
  v3 = *(_BYTE *)(v0 + 2);
  v4 = *(_BYTE *)(v0 + 3);
  v5 = *(_BYTE *)(v0 + 4);
  v6 = *(_BYTE *)(v0 + 5);
  Hasher._combine(_:)(*(_BYTE *)v0);
  Hasher._combine(_:)(v2);
  Hasher._combine(_:)(v3);
  Hasher._combine(_:)(v4);
  Hasher._combine(_:)(v5);
  Hasher._combine(_:)(v6);
  v7 = *(_BYTE *)(v0 + 7);
  v8 = *(_BYTE *)(v0 + 8);
  v9 = *(_BYTE *)(v0 + 9);
  v10 = *(_BYTE *)(v0 + 10);
  v11 = *(_BYTE *)(v0 + 11);
  Hasher._combine(_:)(*(_BYTE *)(v0 + 6));
  Hasher._combine(_:)(v7);
  Hasher._combine(_:)(v8);
  Hasher._combine(_:)(v9);
  Hasher._combine(_:)(v10);
  Hasher._combine(_:)(v11);
  v12 = *(_OWORD *)(v0 + 32);
  v27[0] = *(_OWORD *)(v0 + 16);
  v27[1] = v12;
  Hasher._combine(_:)(0x7F7E0907060504uLL >> (8 * LOBYTE(v27[0])));
  sub_100112BE4((__n128 *)((char *)v27 + 8), &v28);
  sub_100112BE4(&v28, &v29);
  v13 = v29.n128_u64[0];
  if (v29.n128_u32[0] >> 30)
  {
    if (v29.n128_u32[0] >> 30 != 1)
    {
      Hasher._combine(_:)(0);
      sub_100112C4C((uint64_t *)v0);
LABEL_17:
      sub_100112C4C(v1);
      return;
    }
    v29.n128_u64[0] &= 0xFFFFFFFF3FFFFFFFLL;
    v14 = v29.n128_u32[2];
    v15 = v30;
    Hasher._combine(_:)(2uLL);
    Hasher._combine(_:)(8u);
    Hasher._combine(_:)(v13);
    if ((v13 & 0x100) != 0)
      v16 = 3;
    else
      v16 = 0;
    Hasher._combine(_:)(v16);
    Hasher._combine(_:)(BYTE2(v13));
    Hasher._combine(_:)(HIDWORD(v13));
    Hasher._combine(_:)(v14);
    v17 = *(_QWORD *)(v15 + 16);
    Hasher._combine(_:)(v17);
    if (v17)
    {
      v18 = *(_QWORD *)(type metadata accessor for AWDLActionFrame.AWDLAttribute(0) - 8);
      v19 = v15 + ((*(unsigned __int8 *)(v18 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v18 + 80));
      sub_100112C20(v1);
      v20 = *(_QWORD *)(v18 + 72);
      do
      {
        AWDLActionFrame.AWDLAttribute.hash(into:)();
        v19 += v20;
        --v17;
      }
      while (v17);
      goto LABEL_17;
    }
  }
  else
  {
    v29.n128_u64[0] &= 0xFFFFFFFF3FFFFFFFLL;
    v31 = v29;
    Hasher._combine(_:)(1uLL);
    sub_100112C78(&v31, &v32);
    sub_100112C78(&v32, &v33);
    v21 = v33;
    if (v33 == 14)
    {
      Hasher._combine(_:)(0);
    }
    else
    {
      Hasher._combine(_:)(1uLL);
      Hasher._combine(_:)(byte_1003488AC[v21]);
    }
    v22 = v31.n128_u64[1];
    v23 = *(_QWORD *)(v31.n128_u64[1] + 16);
    Hasher._combine(_:)(v23);
    if (v23)
    {
      v24 = *(_QWORD *)(type metadata accessor for NANAttribute(0) - 8);
      v25 = v22 + ((*(unsigned __int8 *)(v24 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v24 + 80));
      sub_100112C20(v1);
      v26 = *(_QWORD *)(v24 + 72);
      do
      {
        NANAttribute.hash(into:)();
        v25 += v26;
        --v23;
      }
      while (v23);
      goto LABEL_17;
    }
  }
}

Swift::Int NANOOBActionFrameReceivedEvent.hashValue.getter()
{
  _QWORD v1[9];

  Hasher.init(_seed:)(v1);
  NANOOBActionFrameReceivedEvent.hash(into:)();
  return Hasher._finalize()();
}

Swift::Int sub_10010C9C0()
{
  __int128 *v0;
  __int128 v1;
  _QWORD v3[9];
  __int128 v4;
  __int128 v5;
  __int128 v6;

  v1 = v0[1];
  v4 = *v0;
  v5 = v1;
  v6 = v0[2];
  Hasher.init(_seed:)(v3);
  NANOOBActionFrameReceivedEvent.hash(into:)();
  return Hasher._finalize()();
}

void sub_10010CA10()
{
  NANOOBActionFrameReceivedEvent.hash(into:)();
}

Swift::Int sub_10010CA48()
{
  __int128 *v0;
  __int128 v1;
  _QWORD v3[9];
  __int128 v4;
  __int128 v5;
  __int128 v6;

  v1 = v0[1];
  v4 = *v0;
  v5 = v1;
  v6 = v0[2];
  Hasher.init(_seed:)(v3);
  NANOOBActionFrameReceivedEvent.hash(into:)();
  return Hasher._finalize()();
}

uint64_t sub_10010CA94(_OWORD *a1, __int128 *a2)
{
  __int128 v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  _OWORD v7[3];
  _OWORD v8[3];

  v2 = a1[1];
  v7[0] = *a1;
  v7[1] = v2;
  v3 = *a2;
  v4 = a2[1];
  v7[2] = a1[2];
  v8[0] = v3;
  v5 = a2[2];
  v8[1] = v4;
  v8[2] = v5;
  return static NANOOBActionFrameReceivedEvent.__derived_struct_equals(_:_:)(v7, v8) & 1;
}

uint64_t NANDiscoveryWindowStartEvent.expectedTSF.setter(uint64_t result)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = result;
  return result;
}

uint64_t NANBeacon.Metadata.rate.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

uint64_t NANDiscoveryWindowStartEvent.channel.setter(uint64_t result)
{
  uint64_t v1;

  *(_DWORD *)(v1 + 24) = result;
  *(_BYTE *)(v1 + 28) = BYTE4(result);
  *(_BYTE *)(v1 + 29) = BYTE5(result);
  return result;
}

void NANDiscoveryWindowStartEvent.hash(into:)(int a1, Swift::UInt a2, Swift::UInt64 a3, Swift::UInt64 a4, unint64_t a5)
{
  Swift::UInt v8;

  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(a3);
  Hasher._combine(_:)(a4);
  Hasher._combine(_:)(a5);
  Hasher._combine(_:)(0x801004u >> ((a5 >> 29) & 0xF8));
  switch(BYTE5(a5))
  {
    case 2:
      v8 = 0;
      goto LABEL_8;
    case 3:
      v8 = 1;
      goto LABEL_8;
    case 4:
      v8 = 3;
      goto LABEL_8;
    case 5:
      v8 = 4;
      goto LABEL_8;
    case 6:
      v8 = 5;
LABEL_8:
      Hasher._combine(_:)(v8);
      break;
    default:
      Hasher._combine(_:)(2uLL);
      Hasher._combine(_:)(BYTE5(a5) & 1);
      break;
  }
}

uint64_t static NANDiscoveryWindowStartEvent.__derived_struct_equals(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_10010FF54(a1, a2, a3, a4 & 0xFFFFFFFFFFFFLL, a5, a6, a7, a8 & 0xFFFFFFFFFFFFLL);
}

Swift::Int NANDiscoveryWindowStartEvent.hashValue.getter(Swift::UInt a1, Swift::UInt64 a2, Swift::UInt64 a3, uint64_t a4)
{
  _QWORD v9[9];

  Hasher.init(_seed:)(v9);
  NANDiscoveryWindowStartEvent.hash(into:)((int)v9, a1, a2, a3, a4 & 0xFFFFFFFFFFFFLL);
  return Hasher._finalize()();
}

Swift::Int sub_10010CC3C()
{
  uint64_t v0;
  Swift::UInt v1;
  Swift::UInt64 v2;
  Swift::UInt64 v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v8[9];

  v1 = *(_QWORD *)v0;
  v2 = *(_QWORD *)(v0 + 8);
  v3 = *(_QWORD *)(v0 + 16);
  v4 = *(unsigned int *)(v0 + 24);
  v5 = *(unsigned __int8 *)(v0 + 28);
  v6 = *(unsigned __int8 *)(v0 + 29);
  Hasher.init(_seed:)(v8);
  NANDiscoveryWindowStartEvent.hash(into:)((int)v8, v1, v2, v3, v4 | (v5 << 32) | (v6 << 40));
  return Hasher._finalize()();
}

void sub_10010CCB0(int a1)
{
  uint64_t v1;

  NANDiscoveryWindowStartEvent.hash(into:)(a1, *(_QWORD *)v1, *(_QWORD *)(v1 + 8), *(_QWORD *)(v1 + 16), *(unsigned int *)(v1 + 24) | ((unint64_t)*(unsigned __int8 *)(v1 + 28) << 32) | ((unint64_t)*(unsigned __int8 *)(v1 + 29) << 40));
}

Swift::Int sub_10010CCD0()
{
  uint64_t v0;
  Swift::UInt v1;
  Swift::UInt64 v2;
  Swift::UInt64 v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v8[9];

  v1 = *(_QWORD *)v0;
  v2 = *(_QWORD *)(v0 + 8);
  v3 = *(_QWORD *)(v0 + 16);
  v4 = *(unsigned int *)(v0 + 24);
  v5 = *(unsigned __int8 *)(v0 + 28);
  v6 = *(unsigned __int8 *)(v0 + 29);
  Hasher.init(_seed:)(v8);
  NANDiscoveryWindowStartEvent.hash(into:)((int)v8, v1, v2, v3, v4 | (v5 << 32) | (v6 << 40));
  return Hasher._finalize()();
}

uint64_t sub_10010CD40(uint64_t a1, uint64_t a2)
{
  return sub_10010FF54(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), *(unsigned int *)(a1 + 24) | ((unint64_t)*(unsigned __int8 *)(a1 + 28) << 32) | ((unint64_t)*(unsigned __int8 *)(a1 + 29) << 40), *(_QWORD *)a2, *(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24) | ((unint64_t)*(unsigned __int8 *)(a2 + 28) << 32) | ((unint64_t)*(unsigned __int8 *)(a2 + 29) << 40));
}

unint64_t AWDLSoftAPChannelChangedEvent.channel.getter(unint64_t a1, unsigned __int16 a2)
{
  return HIDWORD(a1) | ((unint64_t)a2 << 32);
}

void AWDLSoftAPChannelChangedEvent.hash(into:)(uint64_t a1, unint64_t a2, unsigned __int16 a3)
{
  unint64_t v3;
  Swift::UInt8 v4;

  v3 = HIDWORD(a2) | ((unint64_t)a3 << 32);
  Hasher._combine(_:)(a2 & 1);
  if ((v3 & 0xFF00000000) == 0x300000000)
  {
    v4 = 0;
LABEL_3:
    Hasher._combine(_:)(v4);
  }
  else
  {
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(v3);
    Hasher._combine(_:)(0x801004u >> ((v3 >> 29) & 0xF8));
    switch(v3 >> 40)
    {
      case 2uLL:
        Hasher._combine(_:)(0);
        break;
      case 3uLL:
        Hasher._combine(_:)(1uLL);
        break;
      case 4uLL:
        Hasher._combine(_:)(3uLL);
        break;
      case 5uLL:
        Hasher._combine(_:)(4uLL);
        break;
      case 6uLL:
        Hasher._combine(_:)(5uLL);
        break;
      default:
        Hasher._combine(_:)(2uLL);
        v4 = BYTE5(v3) & 1;
        goto LABEL_3;
    }
  }
}

uint64_t static AWDLSoftAPChannelChangedEvent.__derived_struct_equals(_:_:)(uint64_t a1, unsigned __int16 a2, uint64_t a3, unsigned __int16 a4)
{
  unint64_t v4;
  uint64_t v6;

  LODWORD(v6) = a3;
  LOBYTE(v6) = a1 & 1;
  HIDWORD(v6) = HIDWORD(a1);
  v4 = v6;
  LOBYTE(v6) = a3 & 1;
  HIDWORD(v6) = HIDWORD(a3);
  return sub_10011005C(v4, a2, v6, a4);
}

Swift::Int AWDLSoftAPChannelChangedEvent.hashValue.getter(unint64_t a1, unsigned __int16 a2)
{
  char v2;
  unint64_t v4;
  unint64_t v6;
  _QWORD v7[9];

  v2 = a1;
  v7[0] = a1;
  v4 = HIDWORD(a1);
  Hasher.init(_seed:)(v7);
  LOBYTE(v6) = v2 & 1;
  HIDWORD(v6) = v4;
  AWDLSoftAPChannelChangedEvent.hash(into:)((uint64_t)v7, v6, a2);
  return Hasher._finalize()();
}

Swift::Int sub_10010CF40()
{
  char *v0;
  char v1;
  unsigned __int16 v2;
  int v3;
  unint64_t v5;
  _QWORD v6[9];

  v1 = *v0;
  v2 = *((_WORD *)v0 + 4);
  v3 = *((_DWORD *)v0 + 1);
  Hasher.init(_seed:)(v6);
  LOBYTE(v5) = v1;
  HIDWORD(v5) = v3;
  AWDLSoftAPChannelChangedEvent.hash(into:)((uint64_t)v6, v5, v2);
  return Hasher._finalize()();
}

void sub_10010CFA0(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;

  HIDWORD(v2) = *(_DWORD *)(v1 + 4);
  AWDLSoftAPChannelChangedEvent.hash(into:)(a1, v2, *(_WORD *)(v1 + 8));
}

Swift::Int sub_10010CFBC()
{
  char *v0;
  char v1;
  unsigned __int16 v2;
  int v3;
  unint64_t v5;
  _QWORD v6[9];

  v1 = *v0;
  v2 = *((_WORD *)v0 + 4);
  v3 = *((_DWORD *)v0 + 1);
  Hasher.init(_seed:)(v6);
  LOBYTE(v5) = v1;
  HIDWORD(v5) = v3;
  AWDLSoftAPChannelChangedEvent.hash(into:)((uint64_t)v6, v5, v2);
  return Hasher._finalize()();
}

uint64_t sub_10010D018(uint64_t a1, uint64_t a2)
{
  unsigned __int16 v2;
  unint64_t v3;
  uint64_t v5;

  v2 = *(_WORD *)(a1 + 8);
  HIDWORD(v5) = *(_DWORD *)(a1 + 4);
  v3 = v5;
  LOBYTE(v5) = *(_BYTE *)a2;
  HIDWORD(v5) = *(_DWORD *)(a2 + 4);
  return sub_10011005C(v3, v2, v5, *(_WORD *)(a2 + 8));
}

unint64_t AWDLSoftErrorReport.description.getter()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v5;
  _QWORD v6[4];
  char v7;

  sub_100061504(v0, (uint64_t)v6);
  v1 = v6[0];
  v2 = v6[1];
  if ((v7 & 1) != 0)
    v3 = 978474068;
  else
    v3 = 977556808;
  v5 = v3 & 0xFFFF0000FFFFFFFFLL | 0x2000000000;
  String.append(_:)(*(Swift::String *)&v1);
  return v5;
}

uint64_t AWDLSoftErrorReport.hash(into:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v12[4];
  char v13;

  v2 = v1;
  sub_100061504(v2, (uint64_t)v12);
  v4 = v12[0];
  v5 = v12[1];
  if ((v13 & 1) != 0)
  {
    v6 = v12[2];
    v7 = v12[3];
    Hasher._combine(_:)(1uLL);
    String.hash(into:)(a1, v4, v5);
    v8 = a1;
    v9 = v6;
    v10 = v7;
  }
  else
  {
    Hasher._combine(_:)(0);
    v8 = a1;
    v9 = v4;
    v10 = v5;
  }
  return String.hash(into:)(v8, v9, v10);
}

Swift::Int AWDLSoftErrorReport.hashValue.getter()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v8[9];
  _QWORD v9[4];
  char v10;

  Hasher.init(_seed:)(v8);
  sub_100061504(v0, (uint64_t)v9);
  v1 = v9[0];
  v2 = v9[1];
  if ((v10 & 1) != 0)
  {
    v3 = v9[2];
    v4 = v9[3];
    Hasher._combine(_:)(1uLL);
    String.hash(into:)(v8, v1, v2);
    v5 = v3;
    v6 = v4;
  }
  else
  {
    Hasher._combine(_:)(0);
    v5 = v1;
    v6 = v2;
  }
  String.hash(into:)(v8, v5, v6);
  return Hasher._finalize()();
}

Swift::Int sub_10010D1F4()
{
  uint64_t *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD v9[9];

  v1 = *v0;
  v2 = v0[1];
  v3 = v0[2];
  v4 = v0[3];
  v5 = *((_BYTE *)v0 + 32);
  Hasher.init(_seed:)(v9);
  if ((v5 & 1) != 0)
  {
    Hasher._combine(_:)(1uLL);
    String.hash(into:)(v9, v1, v2);
    v6 = v3;
    v7 = v4;
  }
  else
  {
    Hasher._combine(_:)(0);
    v6 = v1;
    v7 = v2;
  }
  String.hash(into:)(v9, v6, v7);
  return Hasher._finalize()();
}

uint64_t sub_10010D290(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = *v1;
  v4 = v1[1];
  if ((v1[4] & 1) != 0)
  {
    v6 = v1[2];
    v5 = v1[3];
    Hasher._combine(_:)(1uLL);
    String.hash(into:)(a1, v3, v4);
    v7 = a1;
    v8 = v6;
    v9 = v5;
  }
  else
  {
    Hasher._combine(_:)(0);
    v7 = a1;
    v8 = v3;
    v9 = v4;
  }
  return String.hash(into:)(v7, v8, v9);
}

Swift::Int sub_10010D310()
{
  uint64_t *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD v9[9];

  v1 = *v0;
  v2 = v0[1];
  v3 = v0[2];
  v4 = v0[3];
  v5 = *((_BYTE *)v0 + 32);
  Hasher.init(_seed:)(v9);
  if ((v5 & 1) != 0)
  {
    Hasher._combine(_:)(1uLL);
    String.hash(into:)(v9, v1, v2);
    v6 = v3;
    v7 = v4;
  }
  else
  {
    Hasher._combine(_:)(0);
    v6 = v1;
    v7 = v2;
  }
  String.hash(into:)(v9, v6, v7);
  return Hasher._finalize()();
}

unint64_t sub_10010D3A8()
{
  uint64_t v0;
  uint64_t v1;
  unint64_t v3;

  if ((*(_BYTE *)(v0 + 32) & 1) != 0)
    v1 = 978474068;
  else
    v1 = 977556808;
  v3 = v1 & 0xFFFF0000FFFFFFFFLL | 0x2000000000;
  String.append(_:)(*(Swift::String *)v0);
  return v3;
}

uint64_t sub_10010D400(uint64_t a1, uint64_t a2)
{
  _BYTE v4[40];
  _BYTE v5[40];

  sub_100061504(a1, (uint64_t)v4);
  sub_100061504(a2, (uint64_t)v5);
  return _s7CoreP2P19AWDLSoftErrorReportO21__derived_enum_equalsySbAC_ACtFZ_0((uint64_t)v4, (uint64_t)v5) & 1;
}

uint64_t NANInternetSharingStatistics.Requester.dhcpDelay.getter@<X0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  uint64_t v3;

  v3 = type metadata accessor for DispatchTimeInterval(0);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v3 - 8) + 16))(a1, v1, v3);
}

uint64_t AWDLIdleActivity.durationSinceLastUnicastRx.getter@<X0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;

  v3 = v1 + *(int *)(type metadata accessor for AWDLIdleActivity(0) + 20);
  v4 = type metadata accessor for DispatchTimeInterval(0);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 - 8) + 16))(a1, v3, v4);
}

void AWDLIdleActivity.hash(into:)()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t *v6;
  void (*v7)(char *, uint64_t, uint64_t);
  uint64_t (*v8)(uint64_t *, uint64_t);
  int v9;
  int v10;
  unint64_t v11;
  Swift::UInt64 v12;
  uint64_t v13;
  uint64_t v14;
  Swift::UInt64 v15;
  BOOL v16;
  BOOL v17;
  unint64_t v18;
  uint64_t v19;
  int v20;
  unint64_t v21;
  Swift::UInt64 v22;
  uint64_t v23;
  uint64_t v24;
  Swift::UInt64 v25;
  BOOL v26;
  unint64_t v27;
  uint64_t v28;

  v1 = type metadata accessor for DispatchTimeInterval(0);
  v2 = *(_QWORD *)(v1 - 8);
  __chkstk_darwin();
  v4 = (uint64_t *)((char *)&v28 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0));
  __chkstk_darwin();
  v6 = (uint64_t *)((char *)&v28 - v5);
  v7 = *(void (**)(char *, uint64_t, uint64_t))(v2 + 16);
  v7((char *)&v28 - v5, v0, v1);
  v8 = *(uint64_t (**)(uint64_t *, uint64_t))(v2 + 88);
  v9 = v8(v6, v1);
  v10 = enum case for DispatchTimeInterval.seconds(_:);
  if (v9 == enum case for DispatchTimeInterval.seconds(_:))
  {
    (*(void (**)(uint64_t *, uint64_t))(v2 + 96))(v6, v1);
    v11 = 0x7FFFFFFFFFFFFFFFLL;
    if (*v6 <= 0)
      v11 = 0x8000000000000000;
    if ((unsigned __int128)(*v6 * (__int128)1000000000) >> 64 == (1000000000 * *v6) >> 63)
      v12 = 1000000000 * *v6;
    else
      v12 = v11;
    goto LABEL_16;
  }
  if (v9 == enum case for DispatchTimeInterval.milliseconds(_:))
  {
    (*(void (**)(uint64_t *, uint64_t))(v2 + 96))(v6, v1);
    v13 = *v6;
    v14 = 1000000;
LABEL_11:
    v15 = v13 * v14;
    v16 = (unsigned __int128)(v13 * (__int128)v14) >> 64 != (v13 * v14) >> 63;
    v17 = v13 <= 0;
    v18 = 0x7FFFFFFFFFFFFFFFLL;
    if (v17)
      v18 = 0x8000000000000000;
    if (v16)
      v12 = v18;
    else
      v12 = v15;
    goto LABEL_16;
  }
  if (v9 == enum case for DispatchTimeInterval.microseconds(_:))
  {
    (*(void (**)(uint64_t *, uint64_t))(v2 + 96))(v6, v1);
    v13 = *v6;
    v14 = 1000;
    goto LABEL_11;
  }
  if (v9 == enum case for DispatchTimeInterval.nanoseconds(_:))
  {
    (*(void (**)(uint64_t *, uint64_t))(v2 + 96))(v6, v1);
    v12 = *v6;
  }
  else
  {
    if (v9 != enum case for DispatchTimeInterval.never(_:))
      (*(void (**)(uint64_t *, uint64_t))(v2 + 8))(v6, v1);
    v12 = 0x7FFFFFFFFFFFFFFFLL;
  }
LABEL_16:
  Hasher._combine(_:)(v12);
  v19 = type metadata accessor for AWDLIdleActivity(0);
  v7((char *)v4, v0 + *(int *)(v19 + 20), v1);
  v20 = v8(v4, v1);
  if (v20 == v10)
  {
    (*(void (**)(uint64_t *, uint64_t))(v2 + 96))(v4, v1);
    v21 = 0x7FFFFFFFFFFFFFFFLL;
    if (*v4 <= 0)
      v21 = 0x8000000000000000;
    if ((unsigned __int128)(*v4 * (__int128)1000000000) >> 64 == (1000000000 * *v4) >> 63)
      v22 = 1000000000 * *v4;
    else
      v22 = v21;
    goto LABEL_31;
  }
  if (v20 == enum case for DispatchTimeInterval.milliseconds(_:))
  {
    (*(void (**)(uint64_t *, uint64_t))(v2 + 96))(v4, v1);
    v23 = *v4;
    v24 = 1000000;
LABEL_26:
    v25 = v23 * v24;
    v26 = (unsigned __int128)(v23 * (__int128)v24) >> 64 != (v23 * v24) >> 63;
    v17 = v23 <= 0;
    v27 = 0x7FFFFFFFFFFFFFFFLL;
    if (v17)
      v27 = 0x8000000000000000;
    if (v26)
      v22 = v27;
    else
      v22 = v25;
    goto LABEL_31;
  }
  if (v20 == enum case for DispatchTimeInterval.microseconds(_:))
  {
    (*(void (**)(uint64_t *, uint64_t))(v2 + 96))(v4, v1);
    v23 = *v4;
    v24 = 1000;
    goto LABEL_26;
  }
  if (v20 == enum case for DispatchTimeInterval.nanoseconds(_:))
  {
    (*(void (**)(uint64_t *, uint64_t))(v2 + 96))(v4, v1);
    v22 = *v4;
  }
  else
  {
    if (v20 != enum case for DispatchTimeInterval.never(_:))
      (*(void (**)(uint64_t *, uint64_t))(v2 + 8))(v4, v1);
    v22 = 0x7FFFFFFFFFFFFFFFLL;
  }
LABEL_31:
  Hasher._combine(_:)(v22);
}

uint64_t static AWDLIdleActivity.__derived_struct_equals(_:_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  if ((static DispatchTimeInterval.== infix(_:_:)(a1, a2) & 1) == 0)
    return 0;
  v4 = *(int *)(type metadata accessor for AWDLIdleActivity(0) + 20);
  return static DispatchTimeInterval.== infix(_:_:)(a1 + v4, a2 + v4);
}

Swift::Int AWDLIdleActivity.hashValue.getter()
{
  _QWORD v1[9];

  Hasher.init(_seed:)(v1);
  AWDLIdleActivity.hash(into:)();
  return Hasher._finalize()();
}

Swift::Int sub_10010D89C()
{
  _QWORD v1[9];

  Hasher.init(_seed:)(v1);
  AWDLIdleActivity.hash(into:)();
  return Hasher._finalize()();
}

uint64_t sub_10010D8D4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((((uint64_t (*)(void))static DispatchTimeInterval.== infix(_:_:))() & 1) != 0)
    return static DispatchTimeInterval.== infix(_:_:)(a1 + *(int *)(a3 + 20), a2 + *(int *)(a3 + 20));
  else
    return 0;
}

void DriverEvent.NAN.peerAttributes.getter()
{
  const void *v0;
  char *v1;
  _BYTE v2[368];
  _BYTE v3[368];
  _BYTE v4[368];

  sub_100063888(v0, v2);
  sub_100063888(v2, v4);
  sub_100063888(v0, v3);
  v1 = (char *)sub_10010D984 + 4 * byte_100347483[sub_100112CB4((uint64_t)v3)];
  __asm { BR              X10 }
}

uint64_t sub_10010D984()
{
  uint64_t v1;

  NANBitmap.Channel.operatingClass.getter(&v1);
  return 0;
}

uint64_t sub_10010DA48(const void *a1, const void *a2)
{
  char v3;
  _BYTE v5[368];
  _BYTE v6[368];

  sub_100063888(a1, v5);
  sub_100063888(a2, v6);
  _s7CoreP2P11DriverEventO3NANO21__derived_enum_equalsySbAE_AEtFZ_0(v5);
  return v3 & 1;
}

uint64_t sub_10010DA98(__int128 *a1, __int128 *a2)
{
  char v3;
  __int128 v5[3];
  _OWORD v6[3];

  sub_100112DAC(a1, v5);
  sub_100112DAC(a2, v6);
  _s7CoreP2P11DriverEventO5InfraO21__derived_enum_equalsySbAE_AEtFZ_0(v5);
  return v3 & 1;
}

void DriverEvent.NAN.shortDescription.getter()
{
  const void *v0;
  char *v1;
  _BYTE v2[376];

  sub_100063888(v0, v2);
  v1 = (char *)sub_10010DB2C + 4 * byte_100347499[sub_100112CB4((uint64_t)v2)];
  __asm { BR              X10 }
}

uint64_t sub_10010DB2C()
{
  uint64_t v0;
  ValueMetadata *v2;
  uint64_t v3;

  NANBitmap.Channel.operatingClass.getter(&v3);
  v2 = &type metadata for NANRoleChangeEvent;
  v0 = sub_100012C44(&qword_100407E20);
  return String.init<A>(describing:)(&v2, v0);
}

void sub_10010DC48(uint64_t a1, ...)
{
  va_list va;

  va_start(va, a1);
  NANBitmap.Channel.operatingClass.getter(va);
  JUMPOUT(0x10010DC34);
}

void DriverEvent.NAN.description.getter()
{
  const void *v0;
  char *v1;
  _BYTE v2[368];
  _BYTE v3[368];
  _BYTE v4[368];

  sub_100063888(v0, v2);
  sub_100063888(v2, v4);
  sub_100063888(v0, v3);
  v1 = (char *)sub_10010DD00 + 4 * word_1003474B0[sub_100112CB4((uint64_t)v3)];
  __asm { BR              X10 }
}

uint64_t sub_10010DD00()
{
  uint64_t v0;
  __int16 v2;
  uint64_t v3;
  int v4;
  __int16 v5;

  v0 = NANBitmap.Channel.operatingClass.getter(&v3);
  v2 = *(_WORD *)(v0 + 4);
  v4 = *(_DWORD *)v0;
  v5 = v2;
  return String.init<A>(describing:)(&v4, &type metadata for NANClusterChangeEvent);
}

void sub_10010E0FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unint64_t a10, __int128 a11, __int128 a12, __int128 a13, __int128 a14, __int128 a15, __int128 a16, __int128 a17, __int128 a18, __int128 a19, __int128 a20,__int128 a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46)
{
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  __int16 v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  Swift::String v55;
  void *object;
  Swift::String v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  Swift::String v63;
  Swift::String v64;

  v48 = NANBitmap.Channel.operatingClass.getter(&STACK[0x460]);
  *(_OWORD *)&STACK[0x650] = *(_OWORD *)(v48 + 128);
  *(_OWORD *)&STACK[0x660] = *(_OWORD *)(v48 + 144);
  *(_OWORD *)&STACK[0x670] = *(_OWORD *)(v48 + 160);
  *(_OWORD *)&STACK[0x680] = *(_OWORD *)(v48 + 176);
  *(_OWORD *)&STACK[0x610] = *(_OWORD *)(v48 + 64);
  *(_OWORD *)&STACK[0x620] = *(_OWORD *)(v48 + 80);
  *(_OWORD *)&STACK[0x630] = *(_OWORD *)(v48 + 96);
  *(_OWORD *)&STACK[0x640] = *(_OWORD *)(v48 + 112);
  *(_OWORD *)&STACK[0x5D0] = *(_OWORD *)v48;
  *(_OWORD *)&STACK[0x5E0] = *(_OWORD *)(v48 + 16);
  *(_OWORD *)&STACK[0x5F0] = *(_OWORD *)(v48 + 32);
  *(_OWORD *)&STACK[0x600] = *(_OWORD *)(v48 + 48);
  v49 = *(_QWORD *)(v48 + 192);
  v50 = *(_DWORD *)(v48 + 200);
  v51 = *(_WORD *)(v48 + 204);
  v52 = *(_QWORD *)(v48 + 208);
  v53 = *(_QWORD *)(v48 + 216);
  a9 = 0;
  a10 = 0xE000000000000000;
  sub_100063888(&STACK[0x740], &a46);
  v54 = NANBitmap.Channel.operatingClass.getter(&a46);
  sub_100063940(v54);
  DriverEvent.NAN.shortDescription.getter();
  object = v55._object;
  String.append(_:)(v55);
  swift_bridgeObjectRelease(object);
  v57._countAndFlagsBits = 40;
  v57._object = (void *)0xE100000000000000;
  String.append(_:)(v57);
  v58 = *(_OWORD *)&STACK[0x660];
  a19 = *(_OWORD *)&STACK[0x650];
  a20 = v58;
  a21 = *(_OWORD *)&STACK[0x670];
  *(__int128 *)((char *)&a21 + 9) = *(_OWORD *)(v47 + 169);
  v59 = *(_OWORD *)&STACK[0x620];
  a15 = *(_OWORD *)&STACK[0x610];
  a16 = v59;
  v60 = *(_OWORD *)&STACK[0x640];
  a17 = *(_OWORD *)&STACK[0x630];
  a18 = v60;
  v61 = *(_OWORD *)&STACK[0x5E0];
  a11 = *(_OWORD *)&STACK[0x5D0];
  a12 = v61;
  v62 = *(_OWORD *)&STACK[0x600];
  a13 = *(_OWORD *)&STACK[0x5F0];
  a14 = v62;
  _print_unlocked<A, B>(_:_:)(&a11, &a9, &type metadata for IEEE80211Frame, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
  v63._countAndFlagsBits = 32;
  v63._object = (void *)0xE100000000000000;
  String.append(_:)(v63);
  *(_QWORD *)&a11 = v49;
  DWORD2(a11) = v50;
  WORD6(a11) = v51;
  *(_QWORD *)&a12 = v52;
  *((_QWORD *)&a12 + 1) = v53;
  _print_unlocked<A, B>(_:_:)(&a11, &a9, &type metadata for NANBeacon.Metadata, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
  v64._countAndFlagsBits = 41;
  v64._object = (void *)0xE100000000000000;
  String.append(_:)(v64);
  sub_100112DC4(v46, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, __int16))sub_100063114);
  JUMPOUT(0x10010E0D4);
}

void sub_10010E29C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57)
{
  const void *v57;
  _QWORD *v58;

  v57 = (const void *)NANBitmap.Channel.operatingClass.getter(&STACK[0x460]);
  memcpy(&STACK[0x5D0], v57, 0x169uLL);
  memcpy(&a11, &STACK[0x5D0], 0x169uLL);
  sub_100063888(&STACK[0x740], &a57);
  v58 = (_QWORD *)NANBitmap.Channel.operatingClass.getter(&a57);
  sub_100112CBC(v58);
  JUMPOUT(0x10010E0C8);
}

void sub_10010E2EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57)
{
  uint64_t v57;
  uint64_t v58;
  _QWORD *v59;

  v58 = *(_QWORD *)NANBitmap.Channel.operatingClass.getter(&STACK[0x460]);
  sub_100063888(&STACK[0x740], &a57);
  v59 = (_QWORD *)NANBitmap.Channel.operatingClass.getter(&a57);
  swift_bridgeObjectRetain(*v59);
  Array.description.getter(v58, &type metadata for Channel);
  sub_100112DC4(v57, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, __int16))sub_100063114);
  JUMPOUT(0x10010E0D4);
}

void sub_10010E340()
{
  NANBitmap.Channel.operatingClass.getter(&STACK[0x460]);
  JUMPOUT(0x10010E0D4);
}

void sub_10010E390()
{
  const void *v0;
  uint64_t v1;

  sub_100063888(v0, &v1);
  DriverEvent.NAN.description.getter();
}

void DriverEvent.AWDL.shortDescription.getter()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  char *v3;
  uint64_t (*v4)(_QWORD);
  char *v5;
  uint64_t v6;

  v1 = type metadata accessor for DriverEvent.AWDL(0);
  __chkstk_darwin();
  v3 = (char *)&v6 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_1000637E0(v0, (uint64_t)v3, v4);
  v5 = (char *)sub_10010E474 + 4 * byte_1003474DC[swift_getEnumCaseMultiPayload(v3, v1)];
  __asm { BR              X11 }
}

uint64_t sub_10010E474()
{
  return 0x656D69746C616572;
}

void DriverEvent.AWDL.description.getter()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  char *v3;
  uint64_t (*v4)(_QWORD);
  char *v5;
  uint64_t v6;

  type metadata accessor for AWDLIdleActivity(0);
  __chkstk_darwin();
  type metadata accessor for AWDLActionFrame.Header(0);
  __chkstk_darwin();
  v1 = type metadata accessor for DriverEvent.AWDL(0);
  __chkstk_darwin();
  v3 = (char *)&v6 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_1000637E0(v0, (uint64_t)v3, v4);
  v5 = (char *)sub_10010E720 + 4 * byte_1003474EA[swift_getEnumCaseMultiPayload(v3, v1)];
  __asm { BR              X10 }
}

uint64_t sub_10010E720()
{
  unsigned __int8 *v0;
  uint64_t v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  Swift::String v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  Swift::String v9;

  v2 = *v0;
  DriverEvent.AWDL.shortDescription.getter();
  *(_QWORD *)(v1 - 128) = v3;
  *(_QWORD *)(v1 - 120) = v4;
  v5._countAndFlagsBits = 40;
  v5._object = (void *)0xE100000000000000;
  String.append(_:)(v5);
  if (v2)
    v6 = 0x64657472617473;
  else
    v6 = 0x6465646E65;
  if (v2)
    v7 = 0xE700000000000000;
  else
    v7 = 0xE500000000000000;
  v8 = v7;
  String.append(_:)(*(Swift::String *)&v6);
  swift_bridgeObjectRelease(v7);
  v9._countAndFlagsBits = 41;
  v9._object = (void *)0xE100000000000000;
  String.append(_:)(v9);
  return *(_QWORD *)(v1 - 128);
}

void DriverEvent.Infra.shortDescription.getter()
{
  __int128 *v0;
  __int128 v1;

  sub_100112DAC(v0, &v1);
  __asm { BR              X12 }
}

uint64_t sub_10010EB44()
{
  uint64_t v0;
  ValueMetadata *v2;

  v2 = &type metadata for InfraScanCompleteEvent;
  v0 = sub_100012C44(&qword_100407E20);
  return String.init<A>(describing:)(&v2, v0);
}

void DriverEvent.Infra.description.getter()
{
  __int128 *v0;
  __int128 v1;
  __int128 v2;

  sub_100112DAC(v0, &v1);
  sub_100112DAC(v0, &v2);
  __asm { BR              X10 }
}

uint64_t sub_10010ED1C()
{
  __int16 v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  Swift::String v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void *v9;
  Swift::String v10;
  uint64_t v12;
  uint64_t v13;

  DriverEvent.Infra.shortDescription.getter();
  v2 = v1;
  v12 = v3;
  v13 = v1;
  swift_bridgeObjectRetain(v1);
  v4._countAndFlagsBits = 32;
  v4._object = (void *)0xE100000000000000;
  String.append(_:)(v4);
  swift_bridgeObjectRelease(v2);
  v6 = v12;
  v5 = v13;
  LOWORD(v12) = v0;
  v7 = String.init<A>(describing:)(&v12, &type metadata for IEEE80211StatusAndReason);
  v9 = v8;
  v12 = v6;
  v13 = v5;
  swift_bridgeObjectRetain(v5);
  v10._countAndFlagsBits = v7;
  v10._object = v9;
  String.append(_:)(v10);
  swift_bridgeObjectRelease(v5);
  swift_bridgeObjectRelease(v9);
  return v12;
}

void sub_10010EEA4()
{
  uint64_t v0;

  if ((v0 & 0xFF00000000) != 0x300000000)
    Channel.description.getter(v0 & 0xFFFFFFFFFFFFLL);
  JUMPOUT(0x10010EE88);
}

void sub_10010EFA4()
{
  __int128 *v0;
  _OWORD v1[3];

  sub_100112DAC(v0, v1);
  DriverEvent.Infra.description.getter();
}

uint64_t DriverEvent.SystemState.description.getter(char a1)
{
  if ((a1 & 1) != 0)
    return 0x656B617720646964;
  else
    return 0x656C73206C6C6977;
}

uint64_t sub_10010F014()
{
  _BYTE *v0;

  if (*v0)
    return 0x656B617720646964;
  else
    return 0x656C73206C6C6977;
}

uint64_t type metadata accessor for DriverEvent.AWDL(uint64_t a1)
{
  return sub_10000D69C(a1, qword_1004080B0, (uint64_t)&nominal type descriptor for DriverEvent.AWDL);
}

void DriverEvent.description.getter()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  char *v3;
  uint64_t (*v4)(_QWORD);
  char *v5;
  uint64_t v6;

  type metadata accessor for DriverEvent.AWDL(0);
  __chkstk_darwin();
  v1 = type metadata accessor for DriverEvent(0);
  __chkstk_darwin();
  v3 = (char *)&v6 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_1000637E0(v0, (uint64_t)v3, v4);
  v5 = (char *)sub_10010F12C + 4 * byte_10034751A[swift_getEnumCaseMultiPayload(v3, v1)];
  __asm { BR              X10 }
}

void sub_10010F12C()
{
  DriverEvent.shortDescription.getter();
}

BOOL sub_10010F214(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _BOOL8 result;
  BOOL v8;
  uint64_t v9;
  unint64_t v10;
  BOOL v11;
  uint64_t v12;
  unint64_t v13;
  char v14;
  int v16;
  int v17;
  __int16 v18;
  __int16 v19;
  int v20;
  int v21;
  __int16 v22;
  __int16 v23;

  if (a1 != a3)
    return 0;
  LOBYTE(v20) = BYTE1(a1);
  BYTE1(v20) = BYTE2(a1);
  BYTE2(v20) = BYTE3(a1);
  HIBYTE(v20) = BYTE4(a1);
  LOBYTE(v22) = BYTE5(a1);
  HIBYTE(v22) = BYTE6(a1);
  LOBYTE(v16) = BYTE1(a3);
  BYTE1(v16) = BYTE2(a3);
  BYTE2(v16) = BYTE3(a3);
  HIBYTE(v16) = BYTE4(a3);
  LOBYTE(v18) = BYTE5(a3);
  HIBYTE(v18) = BYTE6(a3);
  if (v20 != v16 || v22 != v18)
    return 0;
  v8 = (a1 & 0x100000000000000) == 0;
  if ((a1 & 0x100000000000000) != 0)
    v9 = 0x73616369746C756DLL;
  else
    v9 = 0x74736163696E75;
  if (v8)
    v10 = 0xE700000000000000;
  else
    v10 = 0xE900000000000074;
  v11 = (a3 & 0x100000000000000) == 0;
  if ((a3 & 0x100000000000000) != 0)
    v12 = 0x73616369746C756DLL;
  else
    v12 = 0x74736163696E75;
  if (v11)
    v13 = 0xE700000000000000;
  else
    v13 = 0xE900000000000074;
  if (v9 == v12 && v10 == v13)
  {
    swift_bridgeObjectRelease_n(v10, 2);
  }
  else
  {
    v14 = _stringCompareWithSmolCheck(_:_:expecting:)(v9, v10, v12, v13, 0);
    swift_bridgeObjectRelease(v10);
    swift_bridgeObjectRelease(v13);
    result = 0;
    if ((v14 & 1) == 0)
      return result;
  }
  LOWORD(v21) = a2;
  BYTE2(v21) = BYTE2(a2);
  HIBYTE(v21) = BYTE3(a2);
  LOBYTE(v23) = BYTE4(a2);
  HIBYTE(v23) = BYTE5(a2);
  LOWORD(v17) = a4;
  BYTE2(v17) = BYTE2(a4);
  HIBYTE(v17) = BYTE3(a4);
  LOBYTE(v19) = BYTE4(a4);
  HIBYTE(v19) = BYTE5(a4);
  return v21 == v17 && v23 == v19;
}

BOOL _s7CoreP2P24NANDataHostAssistRequestV23__derived_struct_equalsySbAC_ACtFZ_0(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  int v7;
  int v8;
  __int16 v9;
  __int16 v10;
  int v11;
  int v12;
  __int16 v13;
  __int16 v14;

  if ((unsigned __int16)a1 != (unsigned __int16)a3)
    return 0;
  LOBYTE(v11) = BYTE2(a1);
  BYTE1(v11) = BYTE3(a1);
  BYTE2(v11) = BYTE4(a1);
  HIBYTE(v11) = BYTE5(a1);
  LOBYTE(v13) = BYTE6(a1);
  HIBYTE(v13) = HIBYTE(a1);
  LOBYTE(v7) = BYTE2(a3);
  BYTE1(v7) = BYTE3(a3);
  BYTE2(v7) = BYTE4(a3);
  HIBYTE(v7) = BYTE5(a3);
  LOBYTE(v9) = BYTE6(a3);
  HIBYTE(v9) = HIBYTE(a3);
  if (v11 != v7 || v13 != v9)
    return 0;
  LOWORD(v12) = a2;
  BYTE2(v12) = BYTE2(a2);
  HIBYTE(v12) = BYTE3(a2);
  LOBYTE(v14) = BYTE4(a2);
  HIBYTE(v14) = BYTE5(a2);
  LOWORD(v8) = a4;
  BYTE2(v8) = BYTE2(a4);
  HIBYTE(v8) = BYTE3(a4);
  LOBYTE(v10) = BYTE4(a4);
  HIBYTE(v10) = BYTE5(a4);
  if (v12 != v8 || v14 != v10)
    return 0;
  if (BYTE6(a2) != 15)
  {
    if (BYTE6(a4) != 15)
    {
      if (BYTE6(a2) == 14)
      {
        if (BYTE6(a4) == 14)
          return (a4 ^ a2) >> 56 == 0;
      }
      else if (BYTE6(a4) != 14 && byte_1003488AC[SBYTE6(a2)] == byte_1003488AC[SBYTE6(a4)])
      {
        return (a4 ^ a2) >> 56 == 0;
      }
    }
    return 0;
  }
  if (BYTE6(a4) != 15)
    return 0;
  return (a4 ^ a2) >> 56 == 0;
}

void _s7CoreP2P11DriverEventO5InfraO21__derived_enum_equalsySbAE_AEtFZ_0(__int128 *a1)
{
  __int128 v1;

  sub_100112DAC(a1, &v1);
  __asm { BR              X10 }
}

uint64_t sub_10010F634()
{
  __int128 *v0;
  char v1;
  char v2;
  __int128 v4;
  char v5;

  sub_100112DAC(v0, &v4);
  if (v5)
    v2 = 0;
  else
    v2 = ((v1 & 1) == 0) ^ v4;
  return v2 & 1;
}

uint64_t _s7CoreP2P19AWDLSoftErrorReportO21__derived_enum_equalsySbAC_ACtFZ_0(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  char v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  _QWORD v23[4];
  char v24;

  sub_100061504(a1, (uint64_t)v23);
  v3 = v23[0];
  v4 = v23[1];
  if ((v24 & 1) == 0)
  {
    sub_100061504(a2, (uint64_t)&v18);
    if ((v22 & 1) == 0)
    {
      v14 = v18;
      v15 = v19;
      if (v3 != v18 || v4 != v19)
      {
        v12 = v3;
        v13 = v4;
        goto LABEL_18;
      }
LABEL_19:
      v11 = 1;
      return v11 & 1;
    }
    goto LABEL_12;
  }
  v5 = v23[2];
  v6 = v23[3];
  sub_100061504(a2, (uint64_t)&v18);
  if (v22 != 1)
  {
LABEL_12:
    v11 = 0;
    return v11 & 1;
  }
  v7 = v20;
  v8 = v21;
  v9 = v3 == v18 && v4 == v19;
  if (v9 || (v10 = _stringCompareWithSmolCheck(_:_:expecting:)(v3, v4, v18, v19, 0), v11 = 0, (v10 & 1) != 0))
  {
    if (v5 != v7 || v6 != v8)
    {
      v12 = v5;
      v13 = v6;
      v14 = v7;
      v15 = v8;
LABEL_18:
      v11 = _stringCompareWithSmolCheck(_:_:expecting:)(v12, v13, v14, v15, 0);
      return v11 & 1;
    }
    goto LABEL_19;
  }
  return v11 & 1;
}

BOOL sub_10010FDC8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _BOOL8 result;
  BOOL v8;
  uint64_t v9;
  unint64_t v10;
  BOOL v11;
  uint64_t v12;
  unint64_t v13;
  char v14;
  int v15;
  __int16 v16;
  int v17;
  __int16 v18;

  if (a1 != a3)
    return 0;
  LOBYTE(v17) = BYTE1(a1);
  BYTE1(v17) = BYTE2(a1);
  BYTE2(v17) = BYTE3(a1);
  HIBYTE(v17) = BYTE4(a1);
  LOBYTE(v18) = BYTE5(a1);
  HIBYTE(v18) = BYTE6(a1);
  LOBYTE(v15) = BYTE1(a3);
  BYTE1(v15) = BYTE2(a3);
  BYTE2(v15) = BYTE3(a3);
  HIBYTE(v15) = BYTE4(a3);
  LOBYTE(v16) = BYTE5(a3);
  HIBYTE(v16) = BYTE6(a3);
  if (v17 != v15 || v18 != v16)
    return 0;
  v8 = (a1 & 0x100000000000000) == 0;
  if ((a1 & 0x100000000000000) != 0)
    v9 = 0x73616369746C756DLL;
  else
    v9 = 0x74736163696E75;
  if (v8)
    v10 = 0xE700000000000000;
  else
    v10 = 0xE900000000000074;
  v11 = (a3 & 0x100000000000000) == 0;
  if ((a3 & 0x100000000000000) != 0)
    v12 = 0x73616369746C756DLL;
  else
    v12 = 0x74736163696E75;
  if (v11)
    v13 = 0xE700000000000000;
  else
    v13 = 0xE900000000000074;
  if (v9 == v12 && v10 == v13)
  {
    swift_bridgeObjectRelease_n(v10, 2);
    return a2 == a4;
  }
  v14 = _stringCompareWithSmolCheck(_:_:expecting:)(v9, v10, v12, v13, 0);
  swift_bridgeObjectRelease(v10);
  swift_bridgeObjectRelease(v13);
  result = 0;
  if ((v14 & 1) != 0)
    return a2 == a4;
  return result;
}

uint64_t sub_10010FF54(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t a8)
{
  uint64_t result;

  result = 0;
  if (a1 == a5 && a2 == a6 && a3 == a7)
  {
    if ((_DWORD)a4 == (_DWORD)a8
      && ((0x801004u >> ((a4 >> 29) & 0xF8)) & 0xFFC) == ((0x801004u >> ((a8 >> 29) & 0xF8)) & 0xFFC))
    {
      switch(BYTE5(a4))
      {
        case 2:
          if (BYTE5(a8) != 2)
            return 0;
          result = 1;
          break;
        case 3:
          if (BYTE5(a8) != 3)
            return 0;
          result = 1;
          break;
        case 4:
          if (BYTE5(a8) != 4)
            return 0;
          result = 1;
          break;
        case 5:
          if (BYTE5(a8) != 5)
            return 0;
          result = 1;
          break;
        case 6:
          if (BYTE5(a8) != 6)
            return 0;
          result = 1;
          break;
        default:
          if (BYTE5(a8) - 2 < 5 || ((a4 & 0x10000000000) == 0) == ((a8 >> 40) & 1))
            return 0;
          result = 1;
          break;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_10011005C(unint64_t a1, unsigned __int16 a2, uint64_t a3, unsigned __int16 a4)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;

  if (((a1 ^ a3) & 1) == 0)
  {
    v4 = HIDWORD(a1) | ((unint64_t)a2 << 32);
    v5 = HIDWORD(a3) | ((unint64_t)a4 << 32);
    v6 = v5 & 0xFF00000000;
    if ((v4 & 0xFF00000000) == 0x300000000)
    {
      if (v6 == 0x300000000)
        return 1;
    }
    else if (v6 != 0x300000000
           && HIDWORD(a1) == HIDWORD(a3)
           && ((0x801004u >> ((v4 >> 29) & 0xF8)) & 0xFFC) == ((0x801004u >> ((v5 >> 29) & 0xF8)) & 0xFFC))
    {
      switch(BYTE5(v4))
      {
        case 2:
          return BYTE5(v5) == 2;
        case 3:
          return BYTE5(v5) == 3;
        case 4:
          return BYTE5(v5) == 4;
        case 5:
          return BYTE5(v5) == 5;
        case 6:
          return BYTE5(v5) == 6;
        default:
          return BYTE5(v5) - 2 >= 5 && ((v4 & 0x10000000000) == 0) != ((v5 >> 40) & 1);
      }
    }
  }
  return 0;
}

BOOL _s7CoreP2P32NANFollowUpTransferCompleteEventV23__derived_struct_equalsySbAC_ACtFZ_0(uint64_t a1, char a2, uint64_t a3, char a4)
{
  int v7;
  __int16 v8;
  int v9;
  __int16 v10;

  if ((unsigned __int16)a1 != (unsigned __int16)a3)
    return 0;
  LOBYTE(v9) = BYTE2(a1);
  BYTE1(v9) = BYTE3(a1);
  BYTE2(v9) = BYTE4(a1);
  HIBYTE(v9) = BYTE5(a1);
  LOBYTE(v10) = BYTE6(a1);
  HIBYTE(v10) = HIBYTE(a1);
  LOBYTE(v7) = BYTE2(a3);
  BYTE1(v7) = BYTE3(a3);
  BYTE2(v7) = BYTE4(a3);
  HIBYTE(v7) = BYTE5(a3);
  LOBYTE(v8) = BYTE6(a3);
  HIBYTE(v8) = HIBYTE(a3);
  return v9 == v7 && v10 == v8 && a2 == a4;
}

BOOL _s7CoreP2P43NANDataManagementFrameTransferCompleteEventV23__derived_struct_equalsySbAC_ACtFZ_0(uint64_t a1, char a2, uint64_t a3, char a4)
{
  unint64_t v6;
  int v7;
  __int16 v8;
  int v9;
  __int16 v10;

  if (a1 != a3)
    return 0;
  LOBYTE(v9) = BYTE1(a1);
  BYTE1(v9) = BYTE2(a1);
  BYTE2(v9) = BYTE3(a1);
  HIBYTE(v9) = BYTE4(a1);
  LOBYTE(v10) = BYTE5(a1);
  HIBYTE(v10) = BYTE6(a1);
  LOBYTE(v7) = BYTE1(a3);
  BYTE1(v7) = BYTE2(a3);
  BYTE2(v7) = BYTE3(a3);
  HIBYTE(v7) = BYTE4(a3);
  LOBYTE(v8) = BYTE5(a3);
  HIBYTE(v8) = BYTE6(a3);
  if (v9 != v7 || v10 != v8)
    return 0;
  v6 = a3 & 0xFF00000000000000;
  if (HIBYTE(a1) != 14)
  {
    if (v6 != 0xE00000000000000 && byte_1003488AC[a1 >> 56] == byte_1003488AC[a3 >> 56])
      return a2 == a4;
    return 0;
  }
  if (v6 != 0xE00000000000000)
    return 0;
  return a2 == a4;
}

uint64_t sub_100110390(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v9;
  int v10;
  __int16 v11;
  __int16 v12;
  int v13;
  int v14;
  __int16 v15;
  __int16 v16;

  if ((unsigned __int16)a1 != (unsigned __int16)a4)
    return 0;
  LOBYTE(v13) = BYTE2(a1);
  BYTE1(v13) = BYTE3(a1);
  BYTE2(v13) = BYTE4(a1);
  HIBYTE(v13) = BYTE5(a1);
  LOBYTE(v15) = BYTE6(a1);
  HIBYTE(v15) = HIBYTE(a1);
  LOBYTE(v9) = BYTE2(a4);
  BYTE1(v9) = BYTE3(a4);
  BYTE2(v9) = BYTE4(a4);
  HIBYTE(v9) = BYTE5(a4);
  LOBYTE(v11) = BYTE6(a4);
  HIBYTE(v11) = HIBYTE(a4);
  if (v13 != v9 || v15 != v11)
    return 0;
  LOWORD(v14) = a2;
  BYTE2(v14) = BYTE2(a2);
  HIBYTE(v14) = BYTE3(a2);
  LOBYTE(v16) = BYTE4(a2);
  HIBYTE(v16) = BYTE5(a2);
  LOWORD(v10) = a5;
  BYTE2(v10) = BYTE2(a5);
  HIBYTE(v10) = BYTE3(a5);
  LOBYTE(v12) = BYTE4(a5);
  HIBYTE(v12) = BYTE5(a5);
  if (v14 == v10 && v16 == v12)
    return _s7CoreP2P21NANInformationElementV23__derived_struct_equalsySbAC_ACtFZ_0(a3, a6);
  else
    return 0;
}

uint64_t sub_100110500(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  BOOL v6;
  int v8;
  __int16 v9;
  int v10;
  __int16 v11;

  if ((unsigned __int16)a1 != (unsigned __int16)a4)
    return 0;
  LOBYTE(v10) = BYTE2(a1);
  BYTE1(v10) = BYTE3(a1);
  BYTE2(v10) = BYTE4(a1);
  HIBYTE(v10) = BYTE5(a1);
  LOBYTE(v11) = BYTE6(a1);
  HIBYTE(v11) = HIBYTE(a1);
  LOBYTE(v8) = BYTE2(a4);
  BYTE1(v8) = BYTE3(a4);
  BYTE2(v8) = BYTE4(a4);
  HIBYTE(v8) = BYTE5(a4);
  LOBYTE(v9) = BYTE6(a4);
  HIBYTE(v9) = HIBYTE(a4);
  v6 = v10 == v8 && v11 == v9;
  if (v6 && a2 == a5)
    return _s7CoreP2P21NANInformationElementV23__derived_struct_equalsySbAC_ACtFZ_0(a3, a6);
  else
    return 0;
}

void _s7CoreP2P11DriverEventO21__derived_enum_equalsySbAC_ACtFZ_0(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  char *v9;
  _QWORD v10[2];
  uint64_t v11;

  v11 = a2;
  type metadata accessor for DriverEvent.AWDL(0);
  __chkstk_darwin();
  v10[1] = (char *)v10 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v4 = type metadata accessor for DriverEvent(0);
  __chkstk_darwin();
  __chkstk_darwin();
  __chkstk_darwin();
  __chkstk_darwin();
  __chkstk_darwin();
  sub_100012C44(&qword_1004080E8);
  v5 = __chkstk_darwin();
  v7 = (char *)v10 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  v8 = (uint64_t)&v7[*(int *)(v5 + 48)];
  sub_1000637E0(a1, (uint64_t)v7, type metadata accessor for DriverEvent);
  sub_1000637E0(v11, v8, type metadata accessor for DriverEvent);
  v9 = (char *)sub_1001107A0 + 4 * byte_100347544[swift_getEnumCaseMultiPayload(v7, v4)];
  __asm { BR              X10 }
}

uint64_t sub_1001107A0()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  const void *v3;
  const void *v4;
  char v5;
  char v6;

  sub_1000637E0(v1, (uint64_t)v4, type metadata accessor for DriverEvent);
  sub_100063888(v4, (void *)(v0 + 24));
  if (swift_getEnumCaseMultiPayload(v3, v2))
  {
    sub_100112DC4(v0 + 24, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, __int16))sub_100063114);
    sub_100033A84(v1, &qword_1004080E8);
    v5 = 0;
  }
  else
  {
    sub_100063888(v3, (void *)(v0 + 392));
    _s7CoreP2P11DriverEventO3NANO21__derived_enum_equalsySbAE_AEtFZ_0((const void *)(v0 + 24));
    v5 = v6;
    sub_100112DC4(v0 + 392, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, __int16))sub_100063114);
    sub_100112DC4(v0 + 24, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, __int16))sub_100063114);
    sub_100063824(v1, type metadata accessor for DriverEvent);
  }
  return v5 & 1;
}

void _s7CoreP2P11DriverEventO4AWDLO21__derived_enum_equalsySbAE_AEtFZ_0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  _QWORD v17[11];
  uint64_t v18;
  char *v19;

  v18 = a1;
  v19 = (char *)a2;
  v17[0] = type metadata accessor for AWDLIdleActivity(0);
  __chkstk_darwin();
  v17[2] = (char *)v17 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0);
  v17[1] = type metadata accessor for AWDLStatistics.LowLatencyStatistics(0);
  __chkstk_darwin();
  v17[3] = (char *)v17 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  type metadata accessor for AWDLActionFrame.Header(0);
  __chkstk_darwin();
  v17[5] = (char *)v17 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin();
  v17[4] = (char *)v17 - v5;
  v6 = type metadata accessor for DriverEvent.AWDL(0);
  __chkstk_darwin();
  v17[9] = (char *)v17 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  __chkstk_darwin();
  v17[8] = (char *)v17 - v8;
  __chkstk_darwin();
  v17[7] = (char *)v17 - v9;
  __chkstk_darwin();
  __chkstk_darwin();
  v17[6] = (char *)v17 - v10;
  __chkstk_darwin();
  __chkstk_darwin();
  v17[10] = (char *)v17 - v11;
  __chkstk_darwin();
  __chkstk_darwin();
  __chkstk_darwin();
  sub_100012C44(&qword_1004080F0);
  v12 = __chkstk_darwin();
  v14 = (char *)v17 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = (uint64_t)&v14[*(int *)(v12 + 48)];
  sub_1000637E0(v18, (uint64_t)v14, type metadata accessor for DriverEvent.AWDL);
  v18 = v15;
  sub_1000637E0((uint64_t)v19, v15, type metadata accessor for DriverEvent.AWDL);
  v19 = v14;
  v16 = (char *)sub_100110D14 + 4 * word_10034754A[swift_getEnumCaseMultiPayload(v14, v6)];
  __asm { BR              X10 }
}

uint64_t sub_100110D14()
{
  uint64_t v0;
  _BYTE *v1;
  uint64_t v2;
  uint64_t v3;
  _BYTE *v4;
  char v5;
  char v6;

  v3 = *(_QWORD *)(v0 + 96);
  sub_1000637E0(v3, (uint64_t)v1, type metadata accessor for DriverEvent.AWDL);
  v4 = *(_BYTE **)(v0 + 88);
  if (swift_getEnumCaseMultiPayload(v4, v2))
  {
    sub_100033A84(v3, &qword_1004080F0);
    v6 = 0;
  }
  else
  {
    v5 = *v1 ^ *v4;
    sub_100063824(v3, type metadata accessor for DriverEvent.AWDL);
    v6 = v5 ^ 1;
  }
  return v6 & 1;
}

uint64_t _s7CoreP2P30NANOOBActionFrameReceivedEventV23__derived_struct_equalsySbAC_ACtFZ_0(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  BOOL v3;

  v2 = *(_DWORD *)a1 == *(_DWORD *)a2 && *(unsigned __int16 *)(a1 + 4) == *(unsigned __int16 *)(a2 + 4);
  if (v2
    && (*(_DWORD *)(a1 + 6) == *(_DWORD *)(a2 + 6)
      ? (v3 = *(unsigned __int16 *)(a1 + 10) == *(unsigned __int16 *)(a2 + 10))
      : (v3 = 0),
        v3))
  {
    return _s7CoreP2P14IEEE80211FrameV10ManagementO06ActionD0V23__derived_struct_equalsySbAG_AGtFZ_0(*(_BYTE *)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(_BYTE *)(a2 + 16), *(_QWORD *)(a2 + 24), *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 40));
  }
  else
  {
    return 0;
  }
}

uint64_t _s7CoreP2P28NANDataResponseReceivedEventV23__derived_struct_equalsySbAC_ACtFZ_0(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, uint64_t a8)
{
  BOOL v9;
  BOOL v10;
  int v12;
  int v13;
  __int128 v14;
  __int16 v15;
  __int16 v16;
  int v17;
  int v18;
  __int16 v19;
  __int16 v20;

  if ((unsigned __int16)a1 != (unsigned __int16)a5)
    return 0;
  LOBYTE(v17) = BYTE2(a1);
  BYTE1(v17) = BYTE3(a1);
  BYTE2(v17) = BYTE4(a1);
  HIBYTE(v17) = BYTE5(a1);
  LOBYTE(v19) = BYTE6(a1);
  HIBYTE(v19) = HIBYTE(a1);
  LOBYTE(v12) = BYTE2(a5);
  BYTE1(v12) = BYTE3(a5);
  BYTE2(v12) = BYTE4(a5);
  HIBYTE(v12) = BYTE5(a5);
  LOBYTE(v15) = BYTE6(a5);
  HIBYTE(v15) = HIBYTE(a5);
  if (v17 != v12 || v19 != v15)
    return 0;
  LOWORD(v18) = a2;
  BYTE2(v18) = BYTE2(a2);
  HIBYTE(v18) = BYTE3(a2);
  LOBYTE(v20) = BYTE4(a2);
  HIBYTE(v20) = BYTE5(a2);
  LOWORD(v13) = a6;
  BYTE2(v13) = BYTE2(a6);
  HIBYTE(v13) = BYTE3(a6);
  LOBYTE(v16) = BYTE4(a6);
  HIBYTE(v16) = BYTE5(a6);
  v9 = v18 == v13 && v20 == v16;
  if (v9
    && ((BYTE6(v14) = BYTE6(a2),
         BYTE7(v14) = HIBYTE(a2),
         DWORD2(v14) = a3,
         LOBYTE(v14) = BYTE6(a6),
         BYTE1(v14) = HIBYTE(a6),
         *(_DWORD *)((char *)&v14 + 2) = a7,
         *(_DWORD *)((char *)&v14 + 6) == (_DWORD)v14)
      ? (v10 = HIWORD(a3) == HIWORD(a7))
      : (v10 = 0),
        v10))
  {
    return _s7CoreP2P21NANInformationElementV23__derived_struct_equalsySbAC_ACtFZ_0(a4, a8);
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100111B7C(uint64_t result, uint64_t a2, unint64_t a3)
{
  if (result != 4)
    return sub_100031FEC(a2, a3);
  return result;
}

uint64_t sub_100111B98(uint64_t result, unint64_t a2, uint64_t a3)
{
  if (BYTE2(a3) != 255)
    return sub_100111BB0(result, a2, a3, BYTE2(a3) & 1);
  return result;
}

uint64_t sub_100111BB0(uint64_t result, unint64_t a2, uint64_t a3, char a4)
{
  if ((a4 & 1) != 0)
    return sub_10000E614(result, a2);
  else
    return swift_bridgeObjectRelease(result);
}

uint64_t sub_100111BBC(uint64_t result, uint64_t a2, unint64_t a3)
{
  if (result != 4)
    return sub_10000E614(a2, a3);
  return result;
}

void _s7CoreP2P11DriverEventO3NANO21__derived_enum_equalsySbAE_AEtFZ_0(const void *a1)
{
  char *v1;
  _BYTE v2[368];

  sub_100063888(a1, v2);
  v1 = (char *)sub_100111C44 + 4 * word_10034756C[sub_100112CB4((uint64_t)v2)];
  __asm { BR              X10 }
}

BOOL sub_100111C44()
{
  const void *v0;
  uint64_t v1;
  uint64_t v2;
  _BYTE v6[368];
  uint64_t v7;
  int v8;
  __int16 v9;

  v1 = NANBitmap.Channel.operatingClass.getter(&v7);
  v8 = *(_DWORD *)v1;
  v9 = *(_WORD *)(v1 + 4);
  sub_100063888(v0, v6);
  if (sub_100112CB4((uint64_t)v6))
  {
    return 0;
  }
  else
  {
    v2 = NANBitmap.Channel.operatingClass.getter(v6);
    return v8 == *(_DWORD *)v2 && v9 == *(_WORD *)(v2 + 4);
  }
}

__n128 *sub_100112BE4(__n128 *a1, __n128 *a2)
{
  initializeWithTake for NANServiceInfo(a2, a1);
  return a2;
}

uint64_t *sub_100112C20(uint64_t *a1)
{
  sub_100063D24(a1[3], a1[4], a1[5]);
  return a1;
}

uint64_t *sub_100112C4C(uint64_t *a1)
{
  sub_1000632E8(a1[3], a1[4], a1[5]);
  return a1;
}

_BYTE *sub_100112C78(_BYTE *a1, _BYTE *a2)
{
  initializeBufferWithCopyOfBuffer for Bandwidth(a2, a1);
  return a2;
}

uint64_t sub_100112CB4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 361);
}

_QWORD *sub_100112CBC(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v2 = a1[29];
  v3 = a1[30];
  v4 = a1[31];
  v5 = a1[32];
  v6 = a1[33];
  v7 = a1[34];
  v8 = a1[35];
  v9 = a1[36];
  v10 = a1[37];
  v12 = a1[38];
  v13 = a1[39];
  v14 = a1[40];
  v15 = a1[41];
  v16 = a1[42];
  swift_bridgeObjectRetain(a1[44]);
  swift_bridgeObjectRetain(v2);
  swift_bridgeObjectRetain(v3);
  swift_bridgeObjectRetain(v4);
  swift_bridgeObjectRetain(v5);
  swift_bridgeObjectRetain(v6);
  swift_bridgeObjectRetain(v7);
  swift_bridgeObjectRetain(v8);
  swift_bridgeObjectRetain(v9);
  swift_bridgeObjectRetain(v10);
  swift_bridgeObjectRetain(v12);
  swift_bridgeObjectRetain(v13);
  swift_bridgeObjectRetain(v14);
  swift_bridgeObjectRetain(v15);
  swift_bridgeObjectRetain(v16);
  return a1;
}

_OWORD *sub_100112DAC(__int128 *a1, _OWORD *a2)
{
  __int128 v2;
  __int128 v3;

  v2 = *a1;
  v3 = a1[1];
  *(_OWORD *)((char *)a2 + 26) = *(__int128 *)((char *)a1 + 26);
  *a2 = v2;
  a2[1] = v3;
  return a2;
}

uint64_t sub_100112DC4(uint64_t a1, void (*a2)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, __int16))
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int16 v11;

  v11 = *(_WORD *)(a1 + 360);
  v9 = *(_OWORD *)(a1 + 320);
  v10 = *(_OWORD *)(a1 + 336);
  v7 = *(_OWORD *)(a1 + 288);
  v8 = *(_OWORD *)(a1 + 304);
  v5 = *(_OWORD *)(a1 + 256);
  v6 = *(_OWORD *)(a1 + 272);
  v4 = *(_OWORD *)(a1 + 224);
  a2(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), *(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 112), *(_QWORD *)(a1 + 120), *(_QWORD *)(a1 + 128), *(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 144),
    *(_QWORD *)(a1 + 152),
    *(_QWORD *)(a1 + 160),
    *(_QWORD *)(a1 + 168),
    *(_QWORD *)(a1 + 176),
    *(_QWORD *)(a1 + 184),
    *(_QWORD *)(a1 + 192),
    *(_QWORD *)(a1 + 200),
    *(_QWORD *)(a1 + 208),
    *(_QWORD *)(a1 + 216),
    v4,
    *((_QWORD *)&v4 + 1),
    *(_QWORD *)(a1 + 240),
    *(_QWORD *)(a1 + 248),
    v5,
    *((_QWORD *)&v5 + 1),
    v6,
    *((_QWORD *)&v6 + 1),
    v7,
    *((_QWORD *)&v7 + 1),
    v8,
    *((_QWORD *)&v8 + 1),
    v9,
    *((_QWORD *)&v9 + 1),
    v10,
    *((_QWORD *)&v10 + 1),
    *(_QWORD *)(a1 + 352),
    v11);
  return a1;
}

uint64_t sub_100112E60(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46,char a47)
{
  uint64_t v47;

  switch(a47)
  {
    case 2:
    case 3:
    case 5:
    case 7:
    case 13:
      result = a3;
      goto LABEL_3;
    case 6:
      result = a4;
      goto LABEL_3;
    case 16:
      return sub_100063D24(a4, a5, a6);
    case 18:
      LOBYTE(v47) = a24;
      return sub_1000639BC(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22,
               a23,
               v47,
               (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_100063A48);
    case 19:
      swift_bridgeObjectRetain(a45);
      swift_bridgeObjectRetain(a30);
      swift_bridgeObjectRetain(a31);
      swift_bridgeObjectRetain(a32);
      swift_bridgeObjectRetain(a33);
      swift_bridgeObjectRetain(a34);
      swift_bridgeObjectRetain(a35);
      swift_bridgeObjectRetain(a36);
      swift_bridgeObjectRetain(a37);
      swift_bridgeObjectRetain(a38);
      swift_bridgeObjectRetain(a39);
      swift_bridgeObjectRetain(a40);
      swift_bridgeObjectRetain(a41);
      swift_bridgeObjectRetain(a42);
      result = a43;
      goto LABEL_3;
    case 20:
LABEL_3:
      result = swift_bridgeObjectRetain(result);
      break;
    default:
      return result;
  }
  return result;
}

unint64_t sub_100113038()
{
  unint64_t result;

  result = qword_100407E28;
  if (!qword_100407E28)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANClusterChangeEvent, &type metadata for NANClusterChangeEvent);
    atomic_store(result, (unint64_t *)&qword_100407E28);
  }
  return result;
}

unint64_t sub_100113080()
{
  unint64_t result;

  result = qword_100407E30;
  if (!qword_100407E30)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANRoleChangeEvent, &type metadata for NANRoleChangeEvent);
    atomic_store(result, (unint64_t *)&qword_100407E30);
  }
  return result;
}

unint64_t sub_1001130C8()
{
  unint64_t result;

  result = qword_100407E38;
  if (!qword_100407E38)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANDiscoveryResultEvent, &type metadata for NANDiscoveryResultEvent);
    atomic_store(result, (unint64_t *)&qword_100407E38);
  }
  return result;
}

unint64_t sub_100113110()
{
  unint64_t result;

  result = qword_100407E40;
  if (!qword_100407E40)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANPublishRepliedEvent, &type metadata for NANPublishRepliedEvent);
    atomic_store(result, (unint64_t *)&qword_100407E40);
  }
  return result;
}

unint64_t sub_100113158()
{
  unint64_t result;

  result = qword_100407E48;
  if (!qword_100407E48)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANDataRequestReceivedEvent, &type metadata for NANDataRequestReceivedEvent);
    atomic_store(result, (unint64_t *)&qword_100407E48);
  }
  return result;
}

unint64_t sub_1001131A0()
{
  unint64_t result;

  result = qword_100407E50;
  if (!qword_100407E50)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANDataResponseReceivedEvent, &type metadata for NANDataResponseReceivedEvent);
    atomic_store(result, (unint64_t *)&qword_100407E50);
  }
  return result;
}

unint64_t sub_1001131E8()
{
  unint64_t result;

  result = qword_100407E58;
  if (!qword_100407E58)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANDataConfirmReceivedEvent, &type metadata for NANDataConfirmReceivedEvent);
    atomic_store(result, (unint64_t *)&qword_100407E58);
  }
  return result;
}

unint64_t sub_100113230()
{
  unint64_t result;

  result = qword_100407E60;
  if (!qword_100407E60)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANDataEstablishedEvent, &type metadata for NANDataEstablishedEvent);
    atomic_store(result, (unint64_t *)&qword_100407E60);
  }
  return result;
}

unint64_t sub_100113278()
{
  unint64_t result;

  result = qword_100407E68;
  if (!qword_100407E68)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANDataTerminationEvent, &type metadata for NANDataTerminationEvent);
    atomic_store(result, (unint64_t *)&qword_100407E68);
  }
  return result;
}

unint64_t sub_1001132C0()
{
  unint64_t result;

  result = qword_100407E70;
  if (!qword_100407E70)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANDataHostAssistRequest.Reason, &type metadata for NANDataHostAssistRequest.Reason);
    atomic_store(result, (unint64_t *)&qword_100407E70);
  }
  return result;
}

unint64_t sub_100113308()
{
  unint64_t result;

  result = qword_100407E78;
  if (!qword_100407E78)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANDataHostAssistRequest, &type metadata for NANDataHostAssistRequest);
    atomic_store(result, (unint64_t *)&qword_100407E78);
  }
  return result;
}

unint64_t sub_100113350()
{
  unint64_t result;

  result = qword_100407E80;
  if (!qword_100407E80)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANSubscribeTerminatedEvent, &type metadata for NANSubscribeTerminatedEvent);
    atomic_store(result, (unint64_t *)&qword_100407E80);
  }
  return result;
}

unint64_t sub_100113398()
{
  unint64_t result;

  result = qword_100407E88;
  if (!qword_100407E88)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANPublishTerminatedEvent, &type metadata for NANPublishTerminatedEvent);
    atomic_store(result, (unint64_t *)&qword_100407E88);
  }
  return result;
}

unint64_t sub_1001133E0()
{
  unint64_t result;

  result = qword_100407E90;
  if (!qword_100407E90)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANFollowUpReceivedEvent, &type metadata for NANFollowUpReceivedEvent);
    atomic_store(result, (unint64_t *)&qword_100407E90);
  }
  return result;
}

unint64_t sub_100113428()
{
  unint64_t result;

  result = qword_100407E98;
  if (!qword_100407E98)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANTransferCompleteStatus, &type metadata for NANTransferCompleteStatus);
    atomic_store(result, (unint64_t *)&qword_100407E98);
  }
  return result;
}

unint64_t sub_100113470()
{
  unint64_t result;

  result = qword_100407EA0;
  if (!qword_100407EA0)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANFollowUpTransferCompleteEvent, &type metadata for NANFollowUpTransferCompleteEvent);
    atomic_store(result, (unint64_t *)&qword_100407EA0);
  }
  return result;
}

unint64_t sub_1001134B8()
{
  unint64_t result;

  result = qword_100407EA8;
  if (!qword_100407EA8)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANDataManagementFrameTransferCompleteEvent, &type metadata for NANDataManagementFrameTransferCompleteEvent);
    atomic_store(result, (unint64_t *)&qword_100407EA8);
  }
  return result;
}

unint64_t sub_100113500()
{
  unint64_t result;

  result = qword_100407EB0;
  if (!qword_100407EB0)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for WatchdogResetStatus, &type metadata for WatchdogResetStatus);
    atomic_store(result, (unint64_t *)&qword_100407EB0);
  }
  return result;
}

unint64_t sub_100113548()
{
  unint64_t result;

  result = qword_100407EB8;
  if (!qword_100407EB8)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANOOBActionFrameTrasmitStatus.Reason, &type metadata for NANOOBActionFrameTrasmitStatus.Reason);
    atomic_store(result, (unint64_t *)&qword_100407EB8);
  }
  return result;
}

unint64_t sub_100113590()
{
  unint64_t result;

  result = qword_100407EC0;
  if (!qword_100407EC0)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANOOBActionFrameTrasmitStatus.Result, &type metadata for NANOOBActionFrameTrasmitStatus.Result);
    atomic_store(result, (unint64_t *)&qword_100407EC0);
  }
  return result;
}

unint64_t sub_1001135D8()
{
  unint64_t result;

  result = qword_100407EC8;
  if (!qword_100407EC8)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANOOBActionFrameTrasmitStatus, &type metadata for NANOOBActionFrameTrasmitStatus);
    atomic_store(result, (unint64_t *)&qword_100407EC8);
  }
  return result;
}

unint64_t sub_100113620()
{
  unint64_t result;

  result = qword_100407ED0;
  if (!qword_100407ED0)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANOOBActionFrameReceivedEvent, &type metadata for NANOOBActionFrameReceivedEvent);
    atomic_store(result, (unint64_t *)&qword_100407ED0);
  }
  return result;
}

unint64_t sub_100113668()
{
  unint64_t result;

  result = qword_100407ED8;
  if (!qword_100407ED8)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for NANDiscoveryWindowStartEvent, &type metadata for NANDiscoveryWindowStartEvent);
    atomic_store(result, (unint64_t *)&qword_100407ED8);
  }
  return result;
}

unint64_t sub_1001136B0()
{
  unint64_t result;

  result = qword_100407EE0;
  if (!qword_100407EE0)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLThreadCoexistenceEvent, &type metadata for AWDLThreadCoexistenceEvent);
    atomic_store(result, (unint64_t *)&qword_100407EE0);
  }
  return result;
}

unint64_t sub_1001136F8()
{
  unint64_t result;

  result = qword_100407EE8;
  if (!qword_100407EE8)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLSoftAPChannelChangedEvent, &type metadata for AWDLSoftAPChannelChangedEvent);
    atomic_store(result, (unint64_t *)&qword_100407EE8);
  }
  return result;
}

unint64_t sub_100113740()
{
  unint64_t result;

  result = qword_100407EF0;
  if (!qword_100407EF0)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLSoftErrorReport, &type metadata for AWDLSoftErrorReport);
    atomic_store(result, (unint64_t *)&qword_100407EF0);
  }
  return result;
}

unint64_t sub_100113788()
{
  unint64_t result;
  uint64_t v1;

  result = qword_100407EF8;
  if (!qword_100407EF8)
  {
    v1 = type metadata accessor for AWDLIdleActivity(255);
    result = swift_getWitnessTable(protocol conformance descriptor for AWDLIdleActivity, v1);
    atomic_store(result, (unint64_t *)&qword_100407EF8);
  }
  return result;
}

unint64_t sub_1001137D4()
{
  unint64_t result;

  result = qword_100407F00;
  if (!qword_100407F00)
  {
    result = swift_getWitnessTable(protocol conformance descriptor for DriverEvent.SystemState, &type metadata for DriverEvent.SystemState);
    atomic_store(result, (unint64_t *)&qword_100407F00);
  }
  return result;
}

ValueMetadata *type metadata accessor for NANClusterChangeEvent()
{
  return &type metadata for NANClusterChangeEvent;
}

uint64_t getEnumTagSinglePayload for NANRoleChangeEvent(unsigned __int8 *a1, unsigned int a2)
{
  unsigned int v3;
  int v4;

  if (!a2)
    return 0;
  if (a2 >= 0xFC && a1[16])
    return (*(_DWORD *)a1 + 252);
  v3 = *a1;
  if (v3 >= 2)
    v4 = ((v3 + 2147483646) & 0x7FFFFFFF) - 3;
  else
    v4 = -4;
  if (v4 < 0)
    v4 = -1;
  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for NANRoleChangeEvent(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFB)
  {
    *(_QWORD *)result = a2 - 252;
    *(_QWORD *)(result + 8) = 0;
    if (a3 >= 0xFC)
      *(_BYTE *)(result + 16) = 1;
  }
  else
  {
    if (a3 >= 0xFC)
      *(_BYTE *)(result + 16) = 0;
    if (a2)
      *(_BYTE *)result = a2 + 4;
  }
  return result;
}

ValueMetadata *type metadata accessor for NANRoleChangeEvent()
{
  return &type metadata for NANRoleChangeEvent;
}

ValueMetadata *type metadata accessor for NANDiscoveryResultEvent()
{
  return &type metadata for NANDiscoveryResultEvent;
}

ValueMetadata *type metadata accessor for NANPublishRepliedEvent()
{
  return &type metadata for NANPublishRepliedEvent;
}

ValueMetadata *type metadata accessor for NANDataRequestReceivedEvent()
{
  return &type metadata for NANDataRequestReceivedEvent;
}

uint64_t initializeWithCopy for NANDataResponseReceivedEvent(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  *(_WORD *)a1 = *(_WORD *)a2;
  *(_DWORD *)(a1 + 2) = *(_DWORD *)(a2 + 2);
  *(_WORD *)(a1 + 6) = *(_WORD *)(a2 + 6);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_WORD *)(a1 + 12) = *(_WORD *)(a2 + 12);
  *(_DWORD *)(a1 + 14) = *(_DWORD *)(a2 + 14);
  *(_WORD *)(a1 + 18) = *(_WORD *)(a2 + 18);
  v3 = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 24) = v3;
  swift_bridgeObjectRetain(v3);
  return a1;
}

uint64_t assignWithCopy for NANDataResponseReceivedEvent(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_BYTE *)(a1 + 1) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)(a1 + 2) = *(_BYTE *)(a2 + 2);
  *(_BYTE *)(a1 + 3) = *(_BYTE *)(a2 + 3);
  *(_BYTE *)(a1 + 4) = *(_BYTE *)(a2 + 4);
  *(_BYTE *)(a1 + 5) = *(_BYTE *)(a2 + 5);
  *(_BYTE *)(a1 + 6) = *(_BYTE *)(a2 + 6);
  *(_BYTE *)(a1 + 7) = *(_BYTE *)(a2 + 7);
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
  *(_BYTE *)(a1 + 9) = *(_BYTE *)(a2 + 9);
  *(_BYTE *)(a1 + 10) = *(_BYTE *)(a2 + 10);
  *(_BYTE *)(a1 + 11) = *(_BYTE *)(a2 + 11);
  *(_BYTE *)(a1 + 12) = *(_BYTE *)(a2 + 12);
  *(_BYTE *)(a1 + 13) = *(_BYTE *)(a2 + 13);
  *(_BYTE *)(a1 + 14) = *(_BYTE *)(a2 + 14);
  *(_BYTE *)(a1 + 15) = *(_BYTE *)(a2 + 15);
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  *(_BYTE *)(a1 + 17) = *(_BYTE *)(a2 + 17);
  *(_BYTE *)(a1 + 18) = *(_BYTE *)(a2 + 18);
  *(_BYTE *)(a1 + 19) = *(_BYTE *)(a2 + 19);
  v3 = *(_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = v3;
  swift_bridgeObjectRetain(v3);
  swift_bridgeObjectRelease(v4);
  return a1;
}

uint64_t assignWithTake for NANDataResponseReceivedEvent(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  v3 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  swift_bridgeObjectRelease(v3);
  return a1;
}

ValueMetadata *type metadata accessor for NANDataResponseReceivedEvent()
{
  return &type metadata for NANDataResponseReceivedEvent;
}

uint64_t _s7CoreP2P27NANDataRequestReceivedEventVwCP_0(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  *(_WORD *)a1 = *(_WORD *)a2;
  *(_DWORD *)(a1 + 2) = *(_DWORD *)(a2 + 2);
  *(_WORD *)(a1 + 6) = *(_WORD *)(a2 + 6);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_WORD *)(a1 + 12) = *(_WORD *)(a2 + 12);
  v3 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 16) = v3;
  swift_bridgeObjectRetain(v3);
  return a1;
}

uint64_t _s7CoreP2P27NANDataRequestReceivedEventVwca_0(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_BYTE *)(a1 + 1) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)(a1 + 2) = *(_BYTE *)(a2 + 2);
  *(_BYTE *)(a1 + 3) = *(_BYTE *)(a2 + 3);
  *(_BYTE *)(a1 + 4) = *(_BYTE *)(a2 + 4);
  *(_BYTE *)(a1 + 5) = *(_BYTE *)(a2 + 5);
  *(_BYTE *)(a1 + 6) = *(_BYTE *)(a2 + 6);
  *(_BYTE *)(a1 + 7) = *(_BYTE *)(a2 + 7);
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
  *(_BYTE *)(a1 + 9) = *(_BYTE *)(a2 + 9);
  *(_BYTE *)(a1 + 10) = *(_BYTE *)(a2 + 10);
  *(_BYTE *)(a1 + 11) = *(_BYTE *)(a2 + 11);
  *(_BYTE *)(a1 + 12) = *(_BYTE *)(a2 + 12);
  *(_BYTE *)(a1 + 13) = *(_BYTE *)(a2 + 13);
  v3 = *(_QWORD *)(a2 + 16);
  v4 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v3;
  swift_bridgeObjectRetain(v3);
  swift_bridgeObjectRelease(v4);
  return a1;
}

uint64_t _s7CoreP2P27NANDataRequestReceivedEventVwta_0(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_WORD *)(a1 + 12) = *(_WORD *)(a2 + 12);
  v3 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  swift_bridgeObjectRelease(v3);
  return a1;
}

ValueMetadata *type metadata accessor for NANDataConfirmReceivedEvent()
{
  return &type metadata for NANDataConfirmReceivedEvent;
}

uint64_t getEnumTagSinglePayload for NANDataEstablishedEvent(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  BOOL v4;
  int v5;

  if (!a2)
    return 0;
  if (a2 >= 0xFF && *(_BYTE *)(a1 + 14))
    return (*(_DWORD *)a1 + 255);
  v3 = *(unsigned __int8 *)(a1 + 7);
  v4 = v3 >= 2;
  v5 = v3 - 2;
  if (!v4)
    v5 = -1;
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for NANDataEstablishedEvent(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFE)
  {
    *(_WORD *)(result + 12) = 0;
    *(_DWORD *)(result + 8) = 0;
    *(_QWORD *)result = a2 - 255;
    if (a3 >= 0xFF)
      *(_BYTE *)(result + 14) = 1;
  }
  else
  {
    if (a3 >= 0xFF)
      *(_BYTE *)(result + 14) = 0;
    if (a2)
      *(_BYTE *)(result + 7) = a2 + 1;
  }
  return result;
}

ValueMetadata *type metadata accessor for NANDataEstablishedEvent()
{
  return &type metadata for NANDataEstablishedEvent;
}

uint64_t getEnumTagSinglePayload for NANDataTerminationEvent(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  BOOL v4;
  int v5;

  if (!a2)
    return 0;
  if (a2 >= 0xFF && *(_BYTE *)(a1 + 16))
    return (*(_DWORD *)a1 + 255);
  v3 = *(unsigned __int8 *)(a1 + 7);
  v4 = v3 >= 2;
  v5 = v3 - 2;
  if (!v4)
    v5 = -1;
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for NANDataTerminationEvent(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFE)
  {
    *(_QWORD *)result = a2 - 255;
    *(_QWORD *)(result + 8) = 0;
    if (a3 >= 0xFF)
      *(_BYTE *)(result + 16) = 1;
  }
  else
  {
    if (a3 >= 0xFF)
      *(_BYTE *)(result + 16) = 0;
    if (a2)
      *(_BYTE *)(result + 7) = a2 + 1;
  }
  return result;
}

ValueMetadata *type metadata accessor for NANDataTerminationEvent()
{
  return &type metadata for NANDataTerminationEvent;
}

uint64_t getEnumTagSinglePayload for NANDataHostAssistRequest(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  BOOL v4;
  int v5;

  if (!a2)
    return 0;
  if (a2 >= 0xF7 && *(_BYTE *)(a1 + 16))
    return (*(_DWORD *)a1 + 247);
  v3 = *(unsigned __int8 *)(a1 + 15);
  v4 = v3 >= 0xA;
  v5 = v3 - 10;
  if (!v4)
    v5 = -1;
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for NANDataHostAssistRequest(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xF6)
  {
    *(_QWORD *)result = a2 - 247;
    *(_QWORD *)(result + 8) = 0;
    if (a3 >= 0xF7)
      *(_BYTE *)(result + 16) = 1;
  }
  else
  {
    if (a3 >= 0xF7)
      *(_BYTE *)(result + 16) = 0;
    if (a2)
      *(_BYTE *)(result + 15) = a2 + 9;
  }
  return result;
}

ValueMetadata *type metadata accessor for NANDataHostAssistRequest()
{
  return &type metadata for NANDataHostAssistRequest;
}

uint64_t storeEnumTagSinglePayload for NANDataHostAssistRequest.Reason(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 9 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 9) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xF7)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xF6)
    return ((uint64_t (*)(void))((char *)&loc_100113E10 + 4 * byte_1003475CD[v4]))();
  *a1 = a2 + 9;
  return ((uint64_t (*)(void))((char *)sub_100113E44 + 4 * byte_1003475C8[v4]))();
}

uint64_t sub_100113E44(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_100113E4C(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x100113E54);
  return result;
}

uint64_t sub_100113E60(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x100113E68);
  *(_BYTE *)result = a2 + 9;
  return result;
}

uint64_t sub_100113E6C(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

