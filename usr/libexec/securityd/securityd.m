BOOL sub_1000043D4(uint64_t a1, const __CFArray *a2, uint64_t a3, __CFString **a4, uint64_t a5)
{
  _BOOL8 v6;
  __CFString *v11;
  __CFString *v12;
  char v13;
  char v14;
  _QWORD v16[11];
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  char v20;

  v17 = 0;
  v18 = &v17;
  v19 = 0x2000000000;
  v20 = 1;
  if (*(_QWORD *)(a1 + 64))
  {
    v6 = sub_100019F20(-50, a4, CFSTR("value ref not supported by queries"));
  }
  else
  {
    v11 = sub_100012D6C(a1, a2);
    *((_BYTE *)v18 + 24) = v11 != 0;
    if (v11)
    {
      v12 = v11;
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 0x40000000;
      v16[2] = sub_1000233AC;
      v16[3] = &unk_1002DF748;
      v16[6] = &v17;
      v16[7] = a1;
      v16[8] = a2;
      v16[9] = a4;
      v16[10] = a3;
      v16[4] = &stru_1002DF6F8;
      v16[5] = a5;
      v13 = sub_10001E3C4(a3, (uint64_t)v11, (CFTypeRef *)a4, (uint64_t)v16);
      if (*((_BYTE *)v18 + 24))
        v14 = v13;
      else
        v14 = 0;
      *((_BYTE *)v18 + 24) = v14;
      CFRelease(v12);
      v6 = *((_BYTE *)v18 + 24) != 0;
    }
    else
    {
      v6 = 0;
    }
  }
  _Block_object_dispose(&v17, 8);
  return v6;
}

__CFString ***sub_100004514(__CFString ***result)
{
  __CFString ***v1;
  CFTypeRef *v2;
  const __CFString *v3;
  CFTypeID v4;

  if (result)
  {
    v1 = result;
    v2 = sub_100012504(result[2], kSecAttrAccessGroup, 0);
    result = (__CFString ***)sub_100019204(v1, (uint64_t)v2, 0);
    if (result)
    {
      v3 = (const __CFString *)result;
      v4 = CFGetTypeID(result);
      if (v4 == CFStringGetTypeID())
        return (__CFString ***)(CFStringCompare(v3, kSOSInternalAccessGroup, 0) == kCFCompareEqualTo);
      else
        return 0;
    }
  }
  return result;
}

const void *sub_1000045A0(_QWORD **a1, __CFString **a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  CFTypeID v7;

  v4 = sub_10001E6A8(a1[2], 16, a2);
  if (!v4)
    return 0;
  v5 = sub_100019204(a1, v4, a2);
  v6 = v5;
  if (v5)
  {
    v7 = CFGetTypeID(v5);
    if (v7 != CFDataGetTypeID())
      sub_10003060C(1, (CFTypeRef *)a2, CFSTR("persistent ref %@ is not a data"), v6);
  }
  else
  {
    sub_10003060C(1, (CFTypeRef *)a2, CFSTR("persistent ref %@ is not a data"), 0);
  }
  return v6;
}

void sub_100004640(uint64_t a1, void *a2)
{
  uint64_t v2;
  id v3;
  id v4;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = sub_100006D8C(a2);
  v4 = (id)objc_claimAutoreleasedReturnValue(v3);
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v4);

}

const void *sub_100004688(const void *a1)
{
  const void *v1;
  CFTypeID v2;

  if (!a1)
    return 0;
  v1 = a1;
  v2 = CFGetTypeID(a1);
  if (v2 != CFBooleanGetTypeID())
    return 0;
  return v1;
}

uint64_t sub_1000046C4(void *a1, uint64_t a2, __CFString **a3)
{
  const __CFDictionary *v5;
  _QWORD v7[2];
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  void *values[5];
  void *keys[5];

  keys[0] = (void *)kSecClass;
  keys[1] = (void *)kSecReturnData;
  keys[2] = (void *)kSecMatchLimit;
  keys[3] = (void *)kSecAttrSubject;
  keys[4] = (void *)kSecAttrSynchronizable;
  values[0] = (void *)kSecClassCertificate;
  values[1] = kCFBooleanTrue;
  values[2] = (void *)kSecMatchLimitAll;
  values[3] = a1;
  values[4] = (void *)kSecAttrSynchronizableAny;
  v5 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 5, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v11 = 0;
  v7[0] = 0;
  v8 = 0u;
  v9 = 0u;
  v10 = 0u;
  v7[1] = a2;
  LOBYTE(v8) = 1;
  sub_1000109C4(v5, (uint64_t)v7, &v11, a3);
  CFRelease(v5);
  return v11;
}

const void *sub_100004804(void *a1, const char *a2, __CFString **a3)
{
  CFTypeRef v5;
  const void *v6;
  CFTypeID v7;
  CFStringRef v8;

  v5 = sub_10000FF08(a1, a2, a3);
  v6 = v5;
  if (v5)
  {
    v7 = CFGetTypeID(v5);
    if (v7 != CFArrayGetTypeID())
    {
      v8 = CFCopyTypeIDDescription(v7);
      sub_100019F20(-50, a3, CFSTR("object for key %s not array but %@"), a2, v8);
      if (v8)
        CFRelease(v8);
      CFRelease(v6);
      return 0;
    }
  }
  return v6;
}

void sub_100004898(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4;
  id v5;
  id v6;
  id v7;

  v4 = *(_QWORD *)(a1 + 32);
  v5 = a2;
  v6 = sub_100006D8C(a3);
  v7 = (id)objc_claimAutoreleasedReturnValue(v6);
  (*(void (**)(uint64_t, id, id))(v4 + 16))(v4, v5, v7);

}

CFDataRef sub_1000048FC(void *a1, const char *a2, __CFString **a3)
{
  const UInt8 *data;
  CFDataRef result;
  size_t length;

  length = 0;
  data = (const UInt8 *)xpc_dictionary_get_data(a1, a2, &length);
  if (data)
  {
    if ((length & 0x8000000000000000) != 0)
    {
      sub_100019F20(-50, a3, CFSTR("too large data for key %s"), a2);
    }
    else
    {
      result = CFDataCreate(kCFAllocatorDefault, data, length);
      if (result)
        return result;
      sub_100019F20(-50, a3, CFSTR("failed to create data for key %s"), a2);
    }
  }
  else
  {
    sub_100019F20(-50, a3, CFSTR("no data for key %s"), a2);
  }
  return 0;
}

uint64_t sub_100004988(const void *a1, const void *a2, _QWORD *a3, __CFString **a4)
{
  uint64_t result;
  const __CFDate *v8;
  CFAbsoluteTime AbsoluteTime;
  const __CFData *v10;
  const __CFData *v11;
  uint64_t v12;

  result = (uint64_t)sub_100019204(a2, (uint64_t)a3, a4);
  if (result)
  {
    v8 = (const __CFDate *)result;
    result = (uint64_t)sub_100019204(a1, (uint64_t)a3, a4);
    if (result)
    {
      result = CFDateCompare((CFDateRef)result, v8, 0);
      if (result != 1)
      {
        AbsoluteTime = CFDateGetAbsoluteTime(v8);
        v10 = CFDateCreate(kCFAllocatorDefault, AbsoluteTime + 0.001);
        if (v10)
        {
          v11 = v10;
          v12 = sub_10001A56C((uint64_t)a1, a3, v10, a4);
          CFRelease(v11);
          return v12;
        }
        else
        {
          return 1;
        }
      }
    }
  }
  return result;
}

void sub_100004A58(const void *a1, const void *a2, __CFString **a3)
{
  const __CFDictionary *v6;
  const __CFBoolean *Value;
  __CFString *v8;
  __CFString *v9;
  CFDataRef v10;
  CFTypeID v11;
  const void *UUIDBasedPersistentRef;
  CFDataRef v13;
  CFDictionaryRef v14;
  CFDataRef theData;
  CFDictionaryRef theDict;
  CFTypeRef cf;

  if (CFEqual(a1, kSecValueData))
  {
    sub_1000065B0(a2, (uint64_t)a3);
  }
  else if (CFEqual(a1, kSecValuePersistentRef))
  {
    theDict = 0;
    cf = 0;
    theData = 0;
    if (_SecItemParsePersistentRef(a2, &cf, a3 + 9, &theData, &theDict))
    {
      sub_1000117E0(a3, cf, a3 + 5);
      v6 = theDict;
      if (theDict)
      {
        Value = (const __CFBoolean *)CFDictionaryGetValue(theDict, kSecAttrTokenID);
        sub_100012178(kSecAttrTokenID, Value, (uint64_t)a3);
        v8 = (__CFString *)CFDictionaryGetValue(v6, kSecAttrTokenOID);
        v9 = a3[30];
        if (v9 != v8)
        {
          if (!v8 || (CFRetain(v8), (v9 = a3[30]) != 0))
            CFRelease(v9);
          a3[30] = v8;
        }
      }
      if (theData)
      {
        if (CFDataGetLength(theData) == 16)
        {
          v10 = theData;
          if (theData)
          {
            v11 = CFGetTypeID(theData);
            if (v11 == CFDataGetTypeID())
            {
              CFRetain(v10);
              a3[10] = (__CFString *)v10;
              if (a3[1])
              {
                UUIDBasedPersistentRef = (const void *)_SecItemCreateUUIDBasedPersistentRef((*a3)->isa, v10, 0);
                CFDictionarySetValue((CFMutableDictionaryRef)a3[1], kSecValuePersistentRef, UUIDBasedPersistentRef);
                if (UUIDBasedPersistentRef)
                  CFRelease(UUIDBasedPersistentRef);
              }
            }
            else
            {
              sub_100019F20(-50, a3 + 5, CFSTR("set_uuid_persistent_ref: value %@ is not type data"), v10);
            }
          }
          else
          {
            sub_100019F20(-50, a3 + 5, CFSTR("set_uuid_persistent_ref: value %@ is not type data"), 0);
          }
        }
        v13 = theData;
        if (theData)
        {
          theData = 0;
          CFRelease(v13);
        }
      }
      v14 = theDict;
      if (theDict)
      {
        theDict = 0;
        CFRelease(v14);
      }
    }
    else
    {
      sub_100019F20(-50, a3 + 5, CFSTR("add_value: value %@ is not a valid persitent ref"), a2);
    }
  }
  else
  {
    sub_100019F20(-50, a3 + 5, CFSTR("add_value: unknown key %@"), a1);
  }
}

void sub_100004C7C(uint64_t a1, const void *a2)
{
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 32), a2);
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 40), a2);
}

BOOL sub_100004CAC(uint64_t a1)
{
  uint64_t v1;
  __CFString **v2;
  uint64_t v4;
  const __CFDictionary *v5;
  uint64_t v6;
  const void **v7;
  const void **v8;
  uint64_t v9;
  uint64_t *v10;
  CFAbsoluteTime Current;
  const __CFData *v12;
  uint64_t v13;
  _BOOL4 v14;
  _BOOL4 v15;
  BOOL v16;
  _BOOL8 v17;
  _QWORD v18[10];
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  char v22;

  v1 = *(_QWORD *)(a1 + 40);
  v2 = *(__CFString ***)(a1 + 64);
  if (*(_QWORD *)(v1 + 24) != *(_QWORD *)(v1 + 16))
    return sub_100019F20(-50, v2, CFSTR("match not supported in attributes to update"));
  if (*(_QWORD *)(v1 + 64))
    return sub_100019F20(-50, v2, CFSTR("value ref not supported in attributes to update"));
  v4 = *(_QWORD *)(a1 + 32);
  v5 = *(const __CFDictionary **)(a1 + 48);
  v6 = *(_QWORD *)(a1 + 56);
  if (*(_QWORD *)(v1 + 72) && *(_QWORD *)(v1 + 32))
    return sub_100019F20(-50, v2, CFSTR("attributes to update illegal; both row_id and other attributes can't be updated at the same time"));
  if (*(_QWORD *)(v1 + 240) && *(_QWORD *)(v1 + 32) != 1)
    return sub_100019F20(-50, v2, CFSTR("attributes to update illegal; both token persistent ref and other attributes can't be updated at the same time"));
  if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 48), kSecAttrSharingGroup))
    return sub_100019F20(-50, v2, CFSTR("Cannot change SharingGroup using this API"));
  v19 = 0;
  v20 = &v19;
  v21 = 0x2000000000;
  v22 = 1;
  v7 = (const void **)sub_1000114E8(*(_QWORD *)v1, 0, v5, 0, v2);
  if (v7)
  {
    v8 = v7;
    CFDictionaryApplyFunction(v5, (CFDictionaryApplierFunction)sub_100004F30, v7);
    if ((sub_100011460((uint64_t)v8, (CFErrorRef *)v2) & 1) != 0)
    {
      v9 = *((_QWORD *)*v8 + 2);
      if (v9)
      {
        v10 = (uint64_t *)((char *)*v8 + 24);
        do
        {
          if (*(_DWORD *)(v9 + 8) == 6)
          {
            Current = CFAbsoluteTimeGetCurrent();
            v12 = CFDateCreate(0, Current);
            sub_10001BDCC((CFTypeRef *)v9, v12, (uint64_t)v8);
            if (v12)
              CFRelease(v12);
          }
          v13 = *v10++;
          v9 = v13;
        }
        while (v13);
      }
      v18[0] = _NSConcreteStackBlock;
      v18[1] = 0x40000000;
      v18[2] = sub_1000230E8;
      v18[3] = &unk_1002DF798;
      v18[4] = &v19;
      v18[5] = v1;
      v18[6] = v6;
      v18[7] = v4;
      v18[8] = v2;
      v18[9] = v8;
      v14 = sub_10001AC94(v4, 2, (CFTypeRef *)v2, (uint64_t)v18);
      if (*((_BYTE *)v20 + 24))
        v15 = v14;
      else
        v15 = 0;
      *((_BYTE *)v20 + 24) = v15;
      if (v15 && !*(_BYTE *)(v1 + 113))
      {
        v16 = sub_100019F20(-25300, v2, CFSTR("No items updated"));
        *((_BYTE *)v20 + 24) = v16;
      }
    }
    else
    {
      *((_BYTE *)v20 + 24) = 0;
    }
    if (sub_100011108(v8, (CFErrorRef *)v2))
    {
      v17 = *((unsigned __int8 *)v20 + 24) != 0;
    }
    else
    {
      v17 = 0;
      *((_BYTE *)v20 + 24) = 0;
    }
  }
  else
  {
    v17 = 0;
  }
  _Block_object_dispose(&v19, 8);
  return v17;
}

void sub_100004F30(CFTypeRef cf, const void *a2, uint64_t a3)
{
  __CFString **v3;
  CFTypeID v7;
  NSObject *v8;
  CFTypeRef v9;
  uint8_t buf[16];

  v3 = (__CFString **)(a3 + 40);
  if (!*(_QWORD *)(a3 + 40))
  {
    if (cf)
    {
      v7 = CFGetTypeID(cf);
      if (v7 == CFStringGetTypeID())
      {
        if (a2)
        {
          if (CFEqual(cf, CFSTR("musr")))
          {
            v8 = sub_10000EF14("item");
            if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "update_applier: refusing to update musr", buf, 2u);
            }
          }
          else if (CFEqual(cf, kSecValueData))
          {
            sub_1000065B0(a2, a3);
          }
          else
          {
            sub_100012178(cf, (const __CFBoolean *)a2, a3);
          }
        }
        else
        {
          sub_100019F20(-50, v3, CFSTR("update_applier: key %@ has NULL value"), cf);
        }
        return;
      }
      v9 = cf;
    }
    else
    {
      v9 = 0;
    }
    sub_100019F20(-50, v3, CFSTR("update_applier: unknown key type %@"), v9);
  }
}

CFStringRef sub_100005080(uint64_t a1)
{
  const char *v2;
  const char *v3;

  sub_100005100();
  v2 = "ro";
  if (!*(_BYTE *)(a1 + 24))
    v2 = "rw";
  if (*(_QWORD *)(a1 + 64))
    v3 = "open";
  else
    v3 = "closed";
  return CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("<SecDbConnection %s %s>"), v2, v3);
}

uint64_t sub_100005100()
{
  _QWORD block[5];

  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_10002FC58;
  block[3] = &unk_1002DB0F8;
  block[4] = &qword_100340D48;
  if (qword_100340D40 != -1)
    dispatch_once(&qword_100340D40, block);
  return qword_100340D48;
}

uint64_t sub_10000517C(_QWORD **a1, _QWORD **a2, uint64_t a3, CFBooleanRef a4, int a5, __CFString **a6)
{
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  const void *v15;
  BOOL v16;
  char v17;
  unsigned __int8 v18;
  char v19;
  uint64_t *v20;
  BOOL v21;
  __CFError *v22;
  CFErrorDomain Domain;
  CFDictionaryRef *v24;
  const void **v25;
  BOOL v26;
  BOOL v27;
  char v28;
  char v29;
  CFTypeRef *v30;
  __CFString *v31;
  char v32;
  CFStringRef **v33;
  CFStringRef **v34;
  const __CFData *v35;
  int v36;
  uint64_t v37;
  _QWORD v39[10];
  uint64_t v40;
  CFTypeRef *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t *v45;
  uint64_t v46;
  char v47;

  v44 = 0;
  v45 = &v44;
  v46 = 0x2000000000;
  v47 = 1;
  v40 = 0;
  v41 = (CFTypeRef *)&v40;
  v42 = 0x2000000000;
  v43 = 0;
  v12 = sub_10001E6A8(a1[2], 10, a6);
  v13 = sub_100019204(a1, v12, a6);
  v14 = sub_10001E6A8(a2[2], 10, a6);
  v15 = sub_100019204(a2, v14, a6);
  if (v13)
    v16 = v15 == 0;
  else
    v16 = 1;
  v17 = !v16;
  *((_BYTE *)v45 + 24) = v17;
  if (!v16 && CFEqual(v13, v15))
  {
    v18 = sub_100023550(a2, a1, a6);
    *((_BYTE *)v45 + 24) = v18;
    v19 = 1;
    goto LABEL_18;
  }
  if (a4 && kCFBooleanFalse)
  {
    if (!CFEqual(a4, kCFBooleanFalse))
    {
LABEL_15:
      if (sub_10000BD64())
        sub_10001BACC(a2, a5, a6);
    }
  }
  else if (kCFBooleanFalse != a4)
  {
    goto LABEL_15;
  }
  v19 = 0;
LABEL_18:
  v20 = v45;
  if (*((_BYTE *)v45 + 24))
  {
    v21 = sub_100007BB0((__CFString ***)a1, (CFStringRef **)a2, a3, v41 + 3, (uint64_t)&stru_1002DE7D0);
    v20 = v45;
  }
  else
  {
    v21 = 0;
  }
  *((_BYTE *)v20 + 24) = v21;
  v22 = (__CFError *)v41[3];
  if (v22)
  {
    if (CFErrorGetCode(v22) == 19)
    {
      Domain = CFErrorGetDomain((CFErrorRef)v41[3]);
      if (CFEqual(CFSTR("com.apple.utilities.sqlite3"), Domain))
      {
        v24 = (CFDictionaryRef *)sub_1001165F8(a2, a6);
        *((_BYTE *)v45 + 24) = v24 != 0;
        if (v24)
        {
          v25 = (const void **)v24;
          v39[0] = _NSConcreteStackBlock;
          v39[1] = 0x40000000;
          v39[2] = sub_1001175C8;
          v39[3] = &unk_1002DE8B8;
          v39[6] = a6;
          v39[7] = a2;
          v39[8] = a1;
          v39[9] = a3;
          v39[4] = &v44;
          v39[5] = &v40;
          v26 = sub_10001E280(v24, a3, (CFTypeRef *)a6, 0, &stru_1002DE810, 0, 0, (uint64_t)v39);
          if (*((_BYTE *)v45 + 24))
            v27 = v26;
          else
            v27 = 0;
          *((_BYTE *)v45 + 24) = v27;
          v28 = sub_100011108(v25, (CFErrorRef *)a6);
          if (*((_BYTE *)v45 + 24))
            v29 = v28;
          else
            v29 = 0;
          *((_BYTE *)v45 + 24) = v29;
        }
      }
    }
    v30 = v41;
    v31 = (__CFString *)v41[3];
    v20 = v45;
    if (v31)
    {
      *((_BYTE *)v45 + 24) = 0;
      if (a6 && !*a6)
      {
        *a6 = v31;
        v30[3] = 0;
      }
      else
      {
        CFRelease(v31);
        v20 = v45;
      }
    }
  }
  if (*((_BYTE *)v20 + 24))
    v32 = v19;
  else
    v32 = 1;
  if ((v32 & 1) == 0)
  {
    if (a4 && kCFBooleanFalse)
    {
      if (CFEqual(a4, kCFBooleanFalse))
        goto LABEL_52;
    }
    else if (kCFBooleanFalse == a4)
    {
      goto LABEL_52;
    }
    v33 = (CFStringRef **)sub_10011770C((uint64_t)a1, a4, 0, a6);
    *((_BYTE *)v45 + 24) = v33 != 0;
    if (v33)
    {
      v34 = v33;
      v35 = CFUUIDCreate(kCFAllocatorDefault);
      v36 = sub_10001BA44((uint64_t)v34, kSecAttrPersistentReference, v35, a6);
      if (v36)
      {
        sub_100116454((uint64_t)v34, a6);
        LOBYTE(v36) = sub_10001DD08(v34, a3, a6);
      }
      *((_BYTE *)v45 + 24) = v36;
      if (v35)
        CFRelease(v35);
      CFRelease(v34);
    }
  }
LABEL_52:
  v37 = *((unsigned __int8 *)v45 + 24);
  _Block_object_dispose(&v40, 8);
  _Block_object_dispose(&v44, 8);
  return v37;
}

uint64_t sub_100005520(_QWORD *a1)
{
  uint64_t v2;
  NSObject *v3;
  id v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  NSErrorUserInfoKey v14;
  id v15;

  if (*(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 40))
  {
LABEL_2:
    v2 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
    v3 = objc_claimAutoreleasedReturnValue(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v11 = *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 40);
      v12 = 138543362;
      v13 = v11;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Failed to provision user: %{public}@", (uint8_t *)&v12, 0xCu);
    }
    goto LABEL_4;
  }
  if (objc_msgSend(*(id *)(*(_QWORD *)(a1[6] + 8) + 40), "count"))
  {
    if (!*(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 40))
    {
      v14 = NSMultipleUnderlyingErrorsKey;
      v5 = objc_msgSend(*(id *)(*(_QWORD *)(a1[6] + 8) + 40), "copy");
      v15 = v5;
      v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v15, &v14, 1));
      v7 = objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("KCSharingErrorDomain"), 33, v6));
      v8 = *(_QWORD *)(a1[5] + 8);
      v9 = *(void **)(v8 + 40);
      *(_QWORD *)(v8 + 40) = v7;

    }
    goto LABEL_2;
  }
  v10 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
  v3 = objc_claimAutoreleasedReturnValue(v10);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v12) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Provisioned user.", (uint8_t *)&v12, 2u);
  }
LABEL_4:

  return (*(uint64_t (**)(void))(a1[4] + 16))();
}

void sub_1000056FC(uint64_t a1, _QWORD **a2)
{
  uint64_t v4;
  uint64_t v5;
  const void *v6;
  const void *v7;
  const __CFString *v8;
  const __CFString *v9;
  CFTypeID v10;
  NSObject *v11;
  _QWORD *v12;
  const __CFData *v13;
  const __CFData *v14;
  _QWORD *v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  CFTypeRef v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  CFTypeRef v23;
  uint64_t v24;
  __CFError *v25;
  CFErrorRef *v26;
  CFErrorRef v27;
  char v28;
  int v29;
  unsigned __int8 v30;
  uint64_t v31;
  const __CFBoolean *v32;
  uint64_t v33;
  CFTypeRef cf;
  uint8_t buf[4];
  uint64_t v36;
  __int16 v37;
  uint64_t v38;
  __int16 v39;
  CFTypeRef v40;

  cf = 0;
  v4 = *(_QWORD *)(a1 + 40);
  if (*(_QWORD *)(v4 + 240))
  {
    v5 = sub_10001E6A8(a2[2], 1, 0);
    v6 = sub_100019204(a2, v5, 0);
    v4 = *(_QWORD *)(a1 + 40);
    v7 = *(const void **)(v4 + 240);
    if (v7)
    {
      if (!sub_10012E5B8(v7, (uint64_t)v6))
        return;
      v4 = *(_QWORD *)(a1 + 40);
    }
  }
  if (*(_BYTE *)(v4 + 116))
  {
    v8 = (const __CFString *)sub_10000C1D0(a2, kSecAttrSharingGroup);
    if (v8)
    {
      v9 = v8;
      v10 = CFGetTypeID(v8);
      if (v10 == CFStringGetTypeID())
      {
        if (CFStringCompare(v9, kSecAttrSharingGroupNone, 0))
        {
          v11 = sub_10000EF14("SecError");
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Cannot update shared item for unentitled client", buf, 2u);
          }
          return;
        }
      }
    }
  }
  v12 = (_QWORD *)sub_10001E6A8(a2[2], 7, 0);
  v13 = (const __CFData *)sub_100019204(a2, (uint64_t)v12, 0);
  v14 = v13;
  if (v13)
    CFRetain(v13);
  v15 = sub_1000070C4((uint64_t)a2, *(const __CFDictionary **)(*(_QWORD *)(a1 + 48) + 8), (__CFString **)&cf);
  sub_10001A56C((uint64_t)a2, v12, v14, 0);
  if (v14)
    CFRelease(v14);
  if (SecErrorGetOSStatus(cf) == -26275)
  {
    v16 = sub_10000EF14("SecWarning");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      v17 = ***(_QWORD ***)(a1 + 40);
      v18 = sub_1001163AC(a2, 0);
      *(_DWORD *)buf = 138412802;
      v36 = v17;
      v37 = 2048;
      v38 = v18;
      v39 = 2112;
      v40 = cf;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "deleting corrupt %@,rowid=%lld %@", buf, 0x20u);
    }
    v19 = cf;
    if (cf)
    {
      cf = 0;
      CFRelease(v19);
    }
    if ((sub_10001E4C0((CFStringRef **)a2, *(_QWORD *)(a1 + 56), 0, 0, &cf) & 1) == 0)
    {
      v20 = sub_10000EF14("SecError");
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        v21 = ***(_QWORD ***)(a1 + 40);
        v22 = sub_1001163AC(a2, 0);
        *(_DWORD *)buf = 138412802;
        v36 = v21;
        v37 = 2048;
        v38 = v22;
        v39 = 2112;
        v40 = cf;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "failed to delete corrupt %@,rowid=%lld %@", buf, 0x20u);
      }
      v23 = cf;
      if (cf)
      {
        cf = 0;
        CFRelease(v23);
      }
    }
    if (!v15)
      return;
LABEL_58:
    CFRelease(v15);
    return;
  }
  if (v15)
  {
    v24 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 136);
    if (v24)
      sub_10001D9C4((uint64_t)v15, v24, (__CFString **)&cf);
  }
  v25 = (__CFError *)cf;
  v26 = *(CFErrorRef **)(a1 + 64);
  if (cf && v26)
  {
    if (*v26)
    {
      if (CFErrorGetCode(*v26) != -25330)
        goto LABEL_38;
      v27 = *v26;
      if (*v26)
      {
        *v26 = 0;
        CFRelease(v27);
LABEL_38:
        if (*v26)
          goto LABEL_39;
      }
    }
    v28 = 0;
    *v26 = v25;
    goto LABEL_42;
  }
  if (cf)
  {
    if (!v26)
    {
LABEL_39:
      CFRelease(v25);
      v28 = 0;
      goto LABEL_42;
    }
    goto LABEL_38;
  }
  v28 = 1;
LABEL_42:
  if (!v15)
    v28 = 0;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v28;
  if (v15)
  {
    v29 = sub_10000BC78(a2);
    v30 = sub_10000BF78(a2);
    v31 = *(_QWORD *)(a1 + 56);
    v32 = *(const __CFBoolean **)(*(_QWORD *)(a1 + 40) + 96);
    if (!v32)
    {
      if (v29 && !sub_10001DA80(a2))
        v32 = 0;
      else
        v32 = kCFBooleanFalse;
    }
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = sub_10000517C(a2, (_QWORD **)v15, v31, v32, *(unsigned __int8 *)(*(_QWORD *)(a1 + 40) + 154), *(__CFString ***)(a1 + 64));
    if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
      goto LABEL_58;
    v33 = *(_QWORD *)(a1 + 40);
    *(_BYTE *)(v33 + 113) = 1;
    if ((v29 & 1) == 0)
    {
      if (!sub_10000BC78((_QWORD **)v15))
      {
LABEL_55:
        if ((v30 & 1) != 0 || sub_10000BF78(v15))
          *(_BYTE *)(*(_QWORD *)(a1 + 40) + 115) = 1;
        goto LABEL_58;
      }
      v33 = *(_QWORD *)(a1 + 40);
    }
    *(_BYTE *)(v33 + 114) = 1;
    goto LABEL_55;
  }
}

BOOL sub_100005B80(const __CFDictionary *a1, const __CFDictionary *a2, uint64_t a3, __CFString **a4)
{
  CFArrayRef *v8;
  CFArrayRef *v9;
  CFIndex Count;
  CFIndex v11;
  const __CFString *Value;
  const __CFString *v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  CFDictionaryRef v21;
  CFDictionaryRef v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  const void *v26;
  uint64_t v28;
  CFBooleanRef v29;
  const __CFString *v30;
  CFBooleanRef v31;
  int v32;
  int v33;
  int v34;
  int v35;
  const __CFString *v36;
  const __CFString *v37;
  NSObject *v38;
  const __CFString *v39;
  const void *ValueAtIndex;
  uint64_t v41;
  _QWORD v42[8];
  uint8_t buf[4];
  const __CFString *v44;
  CFRange v45;

  if (!sub_10001120C(a1, 1, a4) || !sub_10001120C(a2, 2, a4))
    return 0;
  v8 = sub_10001CBCC((CFArrayRef *)a3);
  if (!v8)
    return sub_100019F20(-34018, a4, CFSTR("Client has neither %@ entitlements"), CFSTR("application-identifier nor keychain-access-groups"));
  v9 = v8;
  Count = CFArrayGetCount((CFArrayRef)v8);
  if (!Count)
  {
    CFRelease(v9);
    return sub_100019F20(-34018, a4, CFSTR("Client has neither %@ entitlements"), CFSTR("application-identifier nor keychain-access-groups"));
  }
  v11 = Count;
  Value = (const __CFString *)CFDictionaryGetValue(a1, kSecAttrAccessGroup);
  if (!Value || (v13 = Value, (sub_100014DCC((const __CFArray *)v9, Value, a3) & 1) != 0))
  {
    kdebug_trace(726794320, 0, 0, 0, 0);
    if (sub_10001CCAC())
    {
      ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v9, 0);
      v41 = 0;
      v39 = CFSTR("AccessGroup");
      v21 = sub_10012E96C(0, v14, v15, v16, v17, v18, v19, v20, (uint64_t)CFSTR("operation"), (uint64_t)CFSTR("update"));
      if (v21)
      {
        v22 = v21;
        sub_10001CD10(CFSTR("SecItem"), v21);
        CFRelease(v22);
      }
    }
    v45.location = 0;
    v45.length = v11;
    if (CFArrayContainsValue((CFArrayRef)v9, v45, CFSTR("*")))
    {
      CFRelease(v9);
      v9 = 0;
    }
    v23 = sub_1000112B0(a1, *(const void **)(a3 + 24), -1, a3, a4);
    if (!v23)
    {
      v28 = 0;
LABEL_74:
      if (v9)
        CFRelease(v9);
      kdebug_trace(726794324, 0, 0, 0, 0);
      return v28;
    }
    v24 = v23;
    v25 = *(_DWORD *)(v23 + 192);
    if (v25 == 2 || v25 == 1 && *(_BYTE *)(a3 + 36))
    {
      v26 = *(const void **)(v23 + 128);
      if (v26)
      {
        *(_QWORD *)(v24 + 128) = 0;
        CFRelease(v26);
      }
      *(_QWORD *)(v24 + 128) = CFDataCreateWithBytesNoCopy(0, byte_10024957C, 16, kCFAllocatorNull);
    }
    else
    {
      *(_DWORD *)(v23 + 192) = 0;
    }
    sub_100012018(v24, v9);
    if (!*(_BYTE *)(a3 + 44))
      goto LABEL_41;
    if ((sub_100139198(a3) & 1) == 0)
    {
      v30 = CFSTR("App clips are not permitted to use access groups other than application identifier");
LABEL_39:
      v32 = -34020;
      goto LABEL_65;
    }
    if (!*(_BYTE *)(a3 + 44))
      goto LABEL_41;
    v29 = (CFBooleanRef)CFDictionaryGetValue(a1, kSecAttrSynchronizable);
    if (v29 && kCFBooleanTrue)
    {
      if (!CFEqual(v29, kCFBooleanTrue))
        goto LABEL_35;
    }
    else if (v29 != kCFBooleanTrue)
    {
LABEL_35:
      v31 = (CFBooleanRef)CFDictionaryGetValue(a2, kSecAttrSynchronizable);
      if (kCFBooleanTrue && v31)
      {
        if (CFEqual(v31, kCFBooleanTrue))
          goto LABEL_38;
      }
      else if (v31 == kCFBooleanTrue)
      {
        goto LABEL_38;
      }
LABEL_41:
      v33 = *(_DWORD *)(v24 + 192);
      if (v33)
      {
        if (!*(_BYTE *)(a3 + 16))
        {
          v30 = CFSTR("client doesn't have entitlement for system keychain");
          goto LABEL_59;
        }
        if (v33 == 2 && sub_100139520(a2))
        {
          v30 = CFSTR("Can't update a system keychain (always) item with synchronizable");
LABEL_64:
          v32 = -50;
LABEL_65:
          if (sub_100019F20(v32, a4, v30))
          {
LABEL_66:
            v42[0] = _NSConcreteStackBlock;
            v42[1] = 0x40000000;
            v42[2] = sub_1000231C8;
            v42[3] = &unk_1002E7F20;
            v42[4] = a4;
            v42[5] = v24;
            v42[6] = a2;
            v42[7] = v9;
            v35 = sub_100011A30(1, 1, 0, (uint64_t)a4, (uint64_t)v42);
LABEL_73:
            v28 = sub_10001CAF8(v24, v35, (CFErrorRef *)a4);
            goto LABEL_74;
          }
LABEL_72:
          v35 = 0;
          goto LABEL_73;
        }
      }
      if (*(_DWORD *)(v24 + 196) && !*(_BYTE *)(a3 + 17))
      {
        v30 = CFSTR("client doesn't have entitlement for syncbubble keychain");
      }
      else
      {
        if (*(_QWORD *)(v24 + 88))
        {
          v30 = CFSTR("use item list not supported");
          goto LABEL_64;
        }
        v34 = *(_DWORD *)(v24 + 48);
        if ((v34 & 1) != 0)
        {
          v30 = CFSTR("return data not supported by update");
          goto LABEL_64;
        }
        if ((v34 & 2) != 0)
        {
          v30 = CFSTR("return attributes not supported by update");
          goto LABEL_64;
        }
        if ((v34 & 4) != 0)
        {
          v30 = CFSTR("return ref not supported by update");
          goto LABEL_64;
        }
        if ((v34 & 8) != 0)
        {
          v30 = CFSTR("return persistent ref not supported by update");
          goto LABEL_64;
        }
        if (!*(_BYTE *)(v24 + 116) || !CFDictionaryContainsKey(*(CFDictionaryRef *)(v24 + 8), kSecAttrSharingGroup))
        {
          v36 = (const __CFString *)CFDictionaryGetValue(a2, kSecAttrAccessGroup);
          if (!v36)
            goto LABEL_66;
          v37 = v36;
          if ((sub_100014DCC((const __CFArray *)v9, v36, a3) & 1) != 0)
            goto LABEL_66;
          v38 = sub_10000EF14("SecError");
          if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138412290;
            v44 = v37;
            _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "Cannot update keychain item to access group %@", buf, 0xCu);
          }
          if (sub_100019F20(-34018, a4, CFSTR("Client explicitly specifies access group %@ but is only entitled for %@"), v37, v9, v39, ValueAtIndex, v41))
          {
            goto LABEL_66;
          }
          goto LABEL_72;
        }
        v30 = CFSTR("can't update shared items without Keychain Sharing client entitlement");
      }
LABEL_59:
      v32 = -34018;
      goto LABEL_65;
    }
LABEL_38:
    v30 = CFSTR("App clips are not permitted to make items synchronizable");
    goto LABEL_39;
  }
  sub_100019F20(-34018, a4, CFSTR("Client explicitly specifies access group %@ but is only entitled for %@"), v13, v9);
  CFRelease(v9);
  return 0;
}

id sub_1000060C8(id a1, NSError *a2, NSString *a3)
{
  NSError *v4;
  NSError *v5;
  void *v6;
  unsigned int v7;
  __CFString *v8;
  void *v9;
  void *v10;
  NSString *v11;

  v4 = a2;
  if (-[NSString isEqualToString:](a3, "isEqualToString:", NSLocalizedDescriptionKey))
  {
    v5 = v4;
    v6 = (void *)objc_claimAutoreleasedReturnValue(-[NSError domain](v5, "domain"));
    v7 = objc_msgSend(v6, "isEqualToString:", CFSTR("KCSharingErrorDomain"));

    if (v7)
    {
      v8 = 0;
      switch(-[NSError code](v5, "code"))
      {
        case 1:
          v9 = (void *)objc_claimAutoreleasedReturnValue(-[NSError userInfo](v5, "userInfo"));
          v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("KCSharingInvalidAttribute")));
          v11 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Item has invalid attributes: %@"), v10);
          goto LABEL_24;
        case 2:
          v9 = (void *)objc_claimAutoreleasedReturnValue(-[NSError userInfo](v5, "userInfo"));
          v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("KCSharingErrorRecordType")));
          v11 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Unknown record type '%@'"), v10);
          goto LABEL_24;
        case 3:
          v8 = CFSTR("Failed to decode local entry data blob");
          break;
        case 4:
          v8 = CFSTR("Failed to decode remote item blob");
          break;
        case 5:
          v8 = CFSTR("Credential and sidecar sharing groups don't match");
          break;
        case 7:
          v8 = CFSTR("Can't parse sharing group from record ID");
          break;
        case 8:
          v8 = CFSTR("Can't create entry from deletion");
          break;
        case 9:
          v8 = CFSTR("Entry doesn't exist");
          break;
        case 0xDLL:
          v8 = CFSTR("Can't decode item from share entry");
          break;
        case 0xELL:
          v9 = (void *)objc_claimAutoreleasedReturnValue(-[NSError userInfo](v5, "userInfo"));
          v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "objectForKeyedSubscript:", NSMultipleUnderlyingErrorsKey));
          v11 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Group sharing sync failed for reasons: %@"), v10);
          goto LABEL_24;
        case 0xFLL:
          v8 = CFSTR("Operation not allowed");
          break;
        case 0x12:
          v9 = (void *)objc_claimAutoreleasedReturnValue(-[NSError userInfo](v5, "userInfo"));
          v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("underlyingErrors")));
          v11 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Operation failed for reasons: %@"), v10);
          goto LABEL_24;
        case 0x13:
          v8 = CFSTR("Failed to decode shared passkey user entity");
          break;
        case 0x14:
          v8 = CFSTR("The requested functionality is not fully implemented yet");
          break;
        case 0x15:
          v8 = CFSTR("Can't decode share from item entry");
          break;
        case 0x16:
          v9 = (void *)objc_claimAutoreleasedReturnValue(-[NSError userInfo](v5, "userInfo"));
          v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("KCSharingMissingAttribute")));
          v11 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Item is missing attribute '%@'"), v10);
LABEL_24:
          v8 = (__CFString *)objc_claimAutoreleasedReturnValue(v11);

          break;
        case 0x22:
          v8 = CFSTR("Local and remote shared groups are out of sync");
          break;
        case 0x23:
          v8 = CFSTR("Can't complete operation because the keychain is locked");
          break;
        case 0x24:
          v8 = CFSTR("The Internet connection appears to be offline.");
          break;
        case 0x25:
          v8 = CFSTR("An operation of this type is already enqueued");
          break;
        default:
          break;
      }
    }
    else
    {
      v8 = 0;
    }

  }
  else
  {
    v8 = 0;
  }

  return v8;
}

void sub_10000638C(uint64_t a1)
{
  uint64_t v1;
  const void *v2;
  const void *v4;
  _QWORD *v5;
  const void *v6;
  uint64_t v7;
  NSObject *v8;
  CFTypeRef v9;
  CFTypeRef v10;
  CFTypeRef cf;
  uint8_t buf[4];
  const void *v13;
  __int16 v14;
  CFTypeRef v15;

  v1 = *(_QWORD *)(a1 + 40);
  if (v1)
  {
    v2 = *(const void **)(v1 + 16);
    if (v2)
    {
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = CFDictionaryGetValue((CFDictionaryRef)qword_1003411B0, *(const void **)(v1 + 16));
      if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
      {
        v4 = *(const void **)(a1 + 40);
        v5 = malloc_type_calloc(1uLL, 0x30uLL, 0xA0040C7E57C1AuLL);
        *v5 = sub_10012A6A8;
        v5[1] = sub_10012A6B8;
        v5[2] = nullsub_26;
        v5[3] = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, 0);
        v5[4] = dispatch_queue_create("dsf queue", 0);
        if (v4)
          CFRetain(v4);
        v5[5] = v4;
        v6 = (const void *)((uint64_t (*)(_QWORD *))*v5)(v5);
        cf = 0;
        v7 = ((uint64_t (*)(_QWORD *, const void *, CFTypeRef *))v5[1])(v5, v6, &cf);
        if (!v7)
        {
          v8 = sub_10000EF14("SecError");
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138412546;
            v13 = v6;
            v14 = 2112;
            v15 = cf;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "create_datasource %@ failed %@", buf, 0x16u);
          }
        }
        v9 = cf;
        if (cf)
        {
          cf = 0;
          CFRelease(v9);
        }
        if (v7)
          (*(void (**)(uint64_t, CFTypeRef *))(v7 + 72))(v7, &cf);
        v10 = cf;
        if (cf)
        {
          cf = 0;
          CFRelease(v10);
        }
        if (v6)
          CFRelease(v6);
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v5;
        CFDictionaryAddValue((CFMutableDictionaryRef)qword_1003411B0, v2, *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
      }
    }
  }
}

void sub_1000065B0(const void *a1, uint64_t a2)
{
  CFTypeID v4;
  __CFDictionary *v5;

  v4 = CFGetTypeID(a1);
  if (v4 == CFDataGetTypeID())
  {
    *(_QWORD *)(a2 + 56) = a1;
    v5 = *(__CFDictionary **)(a2 + 8);
    if (v5)
      CFDictionarySetValue(v5, kSecValueData, a1);
  }
  else
  {
    sub_100019F20(-50, (__CFString **)(a2 + 40), CFSTR("set_data: value %@ is not type data"), a1);
  }
}

void sub_10000663C(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;

  v2 = (const void *)a1[6];
  if (v2)
    CFRelease(v2);
  v3 = (const void *)a1[7];
  if (v3)
    CFRelease(v3);
  v4 = (const void *)a1[9];
  if (v4)
    CFRelease(v4);
  v5 = (const void *)a1[8];
  if (v5)
    CFRelease(v5);
}

unint64_t sub_100006690(const __CFAllocator *a1, CFMutableArrayRef *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5)
{
  int v9;
  CFMutableArrayRef Mutable;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  void *v15;
  void *value;
  unint64_t v18;

  if (!a4)
  {
    sub_100032660(-6, CFSTR("com.apple.security.cfder.error"), 0, a3, a5, CFSTR("null input"));
    return 0;
  }
  v9 = (int)a1;
  Mutable = CFArrayCreateMutable(a1, 0, &kCFTypeArrayCallBacks);
  v18 = 0xAAAAAAAAAAAAAAAALL;
  v11 = ccder_decode_sequence_tl(&v18, a4, a5);
  if (!v11)
  {
    sub_100032660(-1, CFSTR("com.apple.security.cfder.error"), 0, a3, v12, CFSTR("tag/length decode failed"));
LABEL_11:
    if (Mutable)
      CFRelease(Mutable);
    return 0;
  }
  v13 = v11;
  while (v13 < v18)
  {
    value = 0;
    v14 = sub_100020974(v9, (int)&value, (int)a3);
    if (!v14)
      goto LABEL_11;
    v13 = v14;
    v15 = value;
    CFArrayAppendValue(Mutable, value);
    if (v15)
      CFRelease(v15);
  }
  *a2 = Mutable;
  return v13;
}

void sub_100006830(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  int v10;
  id v11;

  v5 = a2;
  v6 = a3;
  v7 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
  v8 = objc_claimAutoreleasedReturnValue(v7);
  v9 = v8;
  if (v6)
  {
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v10 = 138543362;
      v11 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to fetch current current identifier from CloudKit: %{public}@", (uint8_t *)&v10, 0xCu);
    }
  }
  else if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    v10 = 138543362;
    v11 = v5;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Fetched current user identifier from CloudKit: %{public}@", (uint8_t *)&v10, 0xCu);
  }

  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_100006958(uint64_t a1, void *a2, void *a3)
{
  id v5;
  void *v6;
  void *v7;
  unsigned __int8 v8;
  id v9;
  uint64_t v10;
  NSObject *v11;
  id v12;
  uint8_t buf[4];
  id v14;

  v5 = a3;
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a2, "recordName"));
  if (v6)
  {
    v7 = *(void **)(a1 + 32);
    v12 = 0;
    v8 = objc_msgSend(v7, "updateCurrentUserMetadataForKey:toValue:withError:", CFSTR("currentUserIdentifier"), v6, &v12);
    v9 = v12;
    if ((v8 & 1) == 0)
    {
      v10 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
      v11 = objc_claimAutoreleasedReturnValue(v10);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138543362;
        v14 = v9;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Failed to update currentUserMetadata after fetching current user identifier: %{public}@", buf, 0xCu);
      }

    }
  }
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

}

void sub_100006A84(id a1, void *a2)
{
  _QWORD handler[5];

  if (xpc_get_type(a2) == (xpc_type_t)&_xpc_type_connection)
  {
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 0x40000000;
    handler[2] = sub_1000084E8;
    handler[3] = &unk_1002DABC0;
    handler[4] = a2;
    xpc_connection_set_event_handler((xpc_connection_t)a2, handler);
    xpc_connection_resume((xpc_connection_t)a2);
  }
}

void sub_100006B04(id a1, __OpaqueSecDbConnection *a2, unint64_t a3, unint64_t a4, __CFArray *a5)
{
  id v5;
  NSObject *v6;
  const char *v7;
  id v8;
  _QWORD v10[6];
  CFRange v11;

  if (a3)
  {
    if (a4 == 4)
    {
      v8 = sub_10000BDF4(CFSTR("ckks"), 0);
      v6 = objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v10[0]) = 0;
        v7 = "Ignoring kSecDbKCSharingTransaction notification";
        goto LABEL_11;
      }
LABEL_7:

      return;
    }
    if (a4 == 3)
    {
      v5 = sub_10000BDF4(CFSTR("ckks"), 0);
      v6 = objc_claimAutoreleasedReturnValue(v5);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v10[0]) = 0;
        v7 = "Ignoring kSecDbCKKSTransaction notification";
LABEL_11:
        _os_log_debug_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, v7, (uint8_t *)v10, 2u);
        goto LABEL_7;
      }
      goto LABEL_7;
    }
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_100009AD0;
    v10[3] = &unk_1002DCC80;
    v10[4] = a2;
    v10[5] = a4;
    v11.length = CFArrayGetCount(a5);
    v11.location = 0;
    CFArrayApplyFunction(a5, v11, (CFArrayApplierFunction)sub_1000B3BAC, v10);
  }
}

id sub_100006D8C(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  id v6;
  id v7;
  id v8;
  uint64_t v9;
  void *i;
  uint64_t v11;
  void *v12;
  void *v13;
  id v14;
  id v15;
  void *v16;
  void *v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  _BYTE v26[128];

  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "userInfo"));
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", NSMultipleUnderlyingErrorsKey));

    if (v4)
    {
      v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", objc_msgSend(v4, "count")));
      v22 = 0u;
      v23 = 0u;
      v24 = 0u;
      v25 = 0u;
      v6 = v4;
      v7 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v22, v26, 16);
      if (v7)
      {
        v8 = v7;
        v9 = *(_QWORD *)v23;
        do
        {
          for (i = 0; i != v8; i = (char *)i + 1)
          {
            if (*(_QWORD *)v23 != v9)
              objc_enumerationMutation(v6);
            v11 = sub_100006D8C(*(_QWORD *)(*((_QWORD *)&v22 + 1) + 8 * (_QWORD)i));
            v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
            objc_msgSend(v5, "addObject:", v12, (_QWORD)v22);

          }
          v8 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v22, v26, 16);
        }
        while (v8);
      }

      v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "userInfo"));
      v14 = objc_msgSend(v13, "mutableCopy");

      v15 = objc_msgSend(v5, "copy");
      objc_msgSend(v14, "setObject:forKeyedSubscript:", v15, NSMultipleUnderlyingErrorsKey);

      v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "domain"));
      v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", v16, objc_msgSend(v2, "code"), v14));

      v18 = CKXPCSuitableError(v17);
      v19 = (void *)objc_claimAutoreleasedReturnValue(v18);

    }
    else
    {
      v20 = CKXPCSuitableError(v2);
      v19 = (void *)objc_claimAutoreleasedReturnValue(v20);
    }

  }
  else
  {
    v19 = 0;
  }

  return v19;
}

void sub_100006FBC(_QWORD *a1)
{
  uint64_t v2;
  void *v3;
  void *v4;
  id v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  id v9;
  os_log_t v10;
  uint64_t v11;
  void *v12;
  id v13;

  if (!qword_100341090)
  {
    v2 = objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
    v3 = (void *)qword_100341090;
    qword_100341090 = v2;

  }
  v4 = (void *)a1[5];
  if (a1[4])
    v5 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "stringByAppendingFormat:", CFSTR("-%@"), a1[4]));
  else
    v5 = v4;
  v13 = v5;
  v6 = objc_claimAutoreleasedReturnValue(objc_msgSend((id)qword_100341090, "objectForKeyedSubscript:", v5));
  v7 = *(_QWORD *)(a1[6] + 8);
  v8 = *(void **)(v7 + 40);
  *(_QWORD *)(v7 + 40) = v6;

  if (!*(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 40))
  {
    v9 = objc_retainAutorelease(v13);
    v10 = os_log_create("com.apple.security.ckks", (const char *)objc_msgSend(v9, "cStringUsingEncoding:", 4));
    v11 = *(_QWORD *)(a1[6] + 8);
    v12 = *(void **)(v11 + 40);
    *(_QWORD *)(v11 + 40) = v10;

    objc_msgSend((id)qword_100341090, "setObject:forKeyedSubscript:", *(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 40), v9);
  }

}

const void *sub_1000070C4(uint64_t a1, const __CFDictionary *a2, __CFString **a3)
{
  const __CFAllocator *v6;
  const void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *i;
  unsigned int v11;
  BOOL v12;
  int v13;
  uint64_t v15;
  void *v16;
  void *value;

  v6 = CFGetAllocator((CFTypeRef)a1);
  v7 = (const void *)sub_10001E8EC(v6, *(_QWORD *)(a1 + 16), *(_DWORD *)(a1 + 28), *(_QWORD *)(a1 + 32));
  sub_10001D97C((uint64_t)v7, *(CFTypeRef *)(a1 + 56));
  v8 = *(_QWORD *)(a1 + 16);
  v9 = *(_QWORD *)(v8 + 16);
  if (!v9)
    return v7;
  for (i = (uint64_t *)(v8 + 24); ; ++i)
  {
    v11 = *(_DWORD *)(v9 + 8);
    v12 = v11 > 0xA;
    v13 = (1 << v11) & 0x6C0;
    if (!v12 && v13 != 0)
      goto LABEL_7;
    value = 0;
    if (CFDictionaryGetValueIfPresent(a2, *(const void **)v9, (const void **)&value))
      break;
    v16 = (void *)sub_100019204((const void *)a1, v9, a3);
    value = v16;
    if (!v16)
      goto LABEL_15;
LABEL_14:
    if ((sub_10001A56C((uint64_t)v7, (_QWORD *)v9, (const __CFData *)v16, a3) & 1) == 0)
      goto LABEL_15;
LABEL_7:
    v15 = *i;
    v9 = v15;
    if (!v15)
      return v7;
  }
  v16 = value;
  if (value)
    goto LABEL_14;
  sub_100019F20(-50, a3, CFSTR("NULL value in dictionary"));
  v16 = value;
  if (value)
    goto LABEL_14;
LABEL_15:
  if (v7)
    CFRelease(v7);
  return 0;
}

void sub_1000071F4(uint64_t a1)
{
  id *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  CKKSCuttlefishAdapter *v7;
  void *v8;
  CKKSCuttlefishAdapter *v9;
  void *v10;
  uint64_t v11;
  CKKSAccountStateTracker *v12;
  void *v13;
  id v14;
  unsigned int v15;
  id *v16;
  id v17;
  uint64_t v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  OTCuttlefishContext *v24;
  void *v25;
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  id v30;
  id v31;
  id v32;
  void *v33;
  OTCuttlefishContext *v34;
  uint64_t v35;
  void *v36;
  uint64_t v37;
  void *v38;
  CKKSKeychainView *v39;
  __int128 v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  CKKSKeychainView *v47;
  OTCuttlefishContext *v48;
  void *v49;
  void *v50;
  CKKSCuttlefishAdapter *v51;
  void *v52;

  v2 = (id *)(a1 + 40);
  v52 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@-%@"), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40)));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "contexts"));
  v4 = objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", v52));
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 120) + 8);
  v6 = *(void **)(v5 + 40);
  *(_QWORD *)(v5 + 40) = v4;

  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 8) + 40) && *(_BYTE *)(a1 + 128))
  {
    v7 = [CKKSCuttlefishAdapter alloc];
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "cuttlefishXPCConnection"));
    v9 = -[CKKSCuttlefishAdapter initWithConnection:](v7, "initWithConnection:", v8);

    v10 = *(void **)(a1 + 56);
    if (v10)
    {
      v11 = objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "makeCKContainer"));
      v12 = [CKKSAccountStateTracker alloc];
      v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "cloudKitClassDependencies"));
      v14 = -[CKKSAccountStateTracker init:nsnotificationCenterClass:](v12, "init:nsnotificationCenterClass:", v11, objc_msgSend(v13, "nsnotificationCenterClass"));

    }
    else
    {
      v14 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "accountStateTracker"));
      v11 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "cloudKitContainer"));
    }
    v51 = v9;
    if (qword_1003412C8 != -1)
      dispatch_once(&qword_1003412C8, &stru_1002E7860);
    v49 = (void *)v11;
    v50 = v14;
    if (byte_1003412C0
      || objc_msgSend(*(id *)(a1 + 32), "isEqualToString:", CFSTR("com.apple.security.keychain"))
      && objc_msgSend(*v2, "isEqualToString:", CFSTR("defaultContext")))
    {
      v15 = objc_msgSend(*(id *)(a1 + 40), "isEqualToString:", CFSTR("defaultContext"));
      v16 = (id *)off_1002E93F8;
      if (!v15)
        v16 = (id *)(a1 + 40);
      v17 = *v16;
      v47 = [CKKSKeychainView alloc];
      v18 = *(_QWORD *)(a1 + 56);
      v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "lockStateTracker"));
      v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "reachabilityTracker"));
      v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "savedTLKNotifier"));
      v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "cloudKitClassDependencies"));
      v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "personaAdapter"));
      v39 = -[CKKSKeychainView initWithContainer:contextID:activeAccount:accountTracker:lockStateTracker:reachabilityTracker:savedTLKNotifier:cloudKitClassDependencies:personaAdapter:accountsAdapter:cuttlefishAdapter:](v47, "initWithContainer:contextID:activeAccount:accountTracker:lockStateTracker:reachabilityTracker:savedTLKNotifier:cloudKitClassDependencies:personaAdapter:accountsAdapter:cuttlefishAdapter:", v11, v17, v18, v14, v19, v20, v21, v22, v23, *(_QWORD *)(a1 + 64), v51);

    }
    else
    {
      v39 = 0;
    }
    v24 = [OTCuttlefishContext alloc];
    v46 = *(_QWORD *)(a1 + 32);
    v48 = v24;
    v45 = *(_QWORD *)(a1 + 40);
    v44 = *(_QWORD *)(a1 + 56);
    v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "cuttlefishXPCConnection"));
    v42 = *(_QWORD *)(a1 + 64);
    v43 = *(_QWORD *)(a1 + 72);
    v41 = *(_QWORD *)(a1 + 80);
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "personaAdapter"));
    v40 = *(_OWORD *)(a1 + 88);
    v27 = *(_QWORD *)(a1 + 104);
    v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "reachabilityTracker"));
    v29 = *(_QWORD *)(a1 + 112);
    v30 = objc_msgSend(*(id *)(a1 + 48), "apsConnectionClass");
    v31 = objc_msgSend(*(id *)(a1 + 48), "escrowRequestClass");
    v32 = objc_msgSend(*(id *)(a1 + 48), "notifierClass");
    v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "cdpd"));
    v34 = -[OTCuttlefishContext initWithContainerName:contextID:activeAccount:cuttlefish:ckksAccountSync:sosAdapter:accountsAdapter:authKitAdapter:personaAdapter:tooManyPeersAdapter:tapToRadarAdapter:lockStateTracker:reachabilityTracker:accountStateTracker:deviceInformationAdapter:apsConnectionClass:escrowRequestClass:notifierClass:cdpd:](v48, "initWithContainerName:contextID:activeAccount:cuttlefish:ckksAccountSync:sosAdapter:accountsAdapter:authKitAdapter:personaAdapter:tooManyPeersAdapter:tapToRadarAdapter:lockStateTracker:reachabilityTracker:accountStateTracker:deviceInformationAdapter:apsConnectionClass:escrowRequestClass:notifierClass:cdpd:", v46, v45, v44, v25, v39, v43, v42, v41, v26, v40, v27, v28, v50, v29, v30,
            v31,
            v32,
            v33);
    v35 = *(_QWORD *)(*(_QWORD *)(a1 + 120) + 8);
    v36 = *(void **)(v35 + 40);
    *(_QWORD *)(v35 + 40) = v34;

    v37 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 8) + 40);
    v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "contexts"));
    objc_msgSend(v38, "setObject:forKeyedSubscript:", v37, v52);

  }
}

void sub_100007610(uint64_t a1)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = CFDictionaryGetValue((CFDictionaryRef)qword_100341158, **(const void ***)(a1 + 40));
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = CFStringCreateWithFormat(0, 0, CFSTR("#%@"), **(_QWORD **)(a1 + 40));
    CFDictionarySetValue((CFMutableDictionaryRef)qword_100341158, **(const void ***)(a1 + 40), *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
    CFRelease(*(CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  }
}

void sub_1000076C4(const void *a1, const __CFString *a2, uint64_t a3)
{
  CFTypeID v6;
  CFTypeID v7;
  const void *v8;
  CFTypeID v9;
  SInt32 Value;
  CFTypeID v11;
  const CFBooleanRef *v12;
  CFTypeID v13;
  BOOL v14;
  uint64_t v15;
  __CFString **v16;
  uint64_t v17;
  int v18;
  CFTypeID v19;
  uint64_t v20;
  uint64_t v21;

  if (CFEqual(a1, CFSTR("u_ItemList")))
  {
    *(_QWORD *)(a3 + 88) = a2;
    return;
  }
  if (!CFEqual(a1, kSecUseTombstones))
  {
    if (CFEqual(a1, kSecUseCredentialReference))
    {
      v7 = CFGetTypeID(a2);
      if (v7 == CFDataGetTypeID())
      {
        if (*(const __CFString **)(a3 + 144) != a2)
        {
          CFRetain(a2);
          v8 = *(const void **)(a3 + 144);
          if (v8)
            CFRelease(v8);
          *(_QWORD *)(a3 + 144) = a2;
        }
      }
      else
      {
        sub_100019F20(-50, (__CFString **)(a3 + 40), CFSTR("add_use: value %@ for key %@ is not CFData"), a2, a1);
      }
      return;
    }
    if (CFEqual(a1, kSecUseAuthenticationUI))
    {
      v13 = CFGetTypeID(a2);
      if (v13 == CFStringGetTypeID())
      {
        if (kSecUseAuthenticationUISkip)
          v14 = CFEqual(kSecUseAuthenticationUISkip, a2) != 0;
        else
          v14 = 0;
        *(_BYTE *)(a3 + 152) = v14;
      }
      else
      {
        sub_100019F20(-50, (__CFString **)(a3 + 40), CFSTR("add_use: value %@ for key %@ is not CFString"), a2, a1);
      }
      return;
    }
    v15 = kSecUseSystemKeychain;
    if (CFEqual(a1, kSecUseSystemKeychain))
    {
      *(_DWORD *)(a3 + 120) = dword_1003414E0;
      if (*(_DWORD *)(a3 + 192) == 2)
      {
        v16 = (__CFString **)(a3 + 40);
        v20 = kSecUseSystemKeychainAlways;
        v21 = v15;
LABEL_29:
        sub_100019F20(-50, v16, CFSTR("add_use: can't specify both %@ and %@"), v20, v21);
        return;
      }
      v18 = 1;
    }
    else
    {
      if (qword_1003412E8 != -1)
        dispatch_once(&qword_1003412E8, &stru_1002E78C0);
      if (!byte_1003412E0 || (v17 = kSecUseSystemKeychainAlways, !CFEqual(a1, kSecUseSystemKeychainAlways)))
      {
        if (CFEqual(a1, kSecUseSyncBubbleKeychain))
        {
          v19 = CFGetTypeID(a2);
          if (v19 == CFNumberGetTypeID()
            && CFNumberGetValue((CFNumberRef)a2, kCFNumberSInt32Type, (void *)(a3 + 196))
            && *(int *)(a3 + 196) >= 1)
          {
            *(_DWORD *)(a3 + 120) = dword_1003414E0;
          }
          else
          {
            sub_100019F20(-50, (__CFString **)(a3 + 40), CFSTR("add_use: value %@ for key %@ is not valid uid"), a2, a1);
          }
        }
        else
        {
          sub_100019F20(-50, (__CFString **)(a3 + 40), CFSTR("add_use: unknown key %@"), a1);
        }
        return;
      }
      if (*(_DWORD *)(a3 + 192) == 1)
      {
        v16 = (__CFString **)(a3 + 40);
        v20 = v15;
        v21 = v17;
        goto LABEL_29;
      }
      *(_DWORD *)(a3 + 120) = dword_1003414E0;
      v18 = 2;
    }
    *(_DWORD *)(a3 + 192) = v18;
    return;
  }
  v6 = CFGetTypeID(a2);
  if (v6 == CFBooleanGetTypeID())
  {
    *(_QWORD *)(a3 + 96) = a2;
    return;
  }
  v9 = CFGetTypeID(a2);
  if (v9 == CFNumberGetTypeID())
  {
    Value = CFBooleanGetValue((CFBooleanRef)a2);
  }
  else
  {
    v11 = CFGetTypeID(a2);
    if (v11 != CFStringGetTypeID())
    {
      sub_100019F20(-50, (__CFString **)(a3 + 40), CFSTR("add_use: value %@ for key %@ is neither CFBoolean nor CFNumber"), a2, a1);
      return;
    }
    Value = CFStringGetIntValue(a2);
  }
  v12 = &kCFBooleanTrue;
  if (!Value)
    v12 = &kCFBooleanFalse;
  *(CFBooleanRef *)(a3 + 96) = *v12;
}

const __CFString *sub_100007A58(uint64_t a1, sqlite3_stmt *a2)
{
  uint64_t v4;
  uint64_t v5;
  __CFString **v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  _QWORD *v11;
  __CFData *v12;
  int v13;
  _BYTE *v14;
  uint64_t v15;
  _BYTE *v16;
  _QWORD *v17;
  const __CFString *result;
  const __CFString *v19;
  _BYTE *v20;

  v4 = *(_QWORD *)(a1 + 48);
  v5 = *(_QWORD *)(a1 + 56);
  v6 = *(__CFString ***)(a1 + 64);
  v7 = *(_QWORD *)(a1 + 32);
  v8 = *(_QWORD *)(v5 + 16);
  v9 = *(_BYTE **)(v8 + 16);
  if (v9)
  {
    LODWORD(v10) = 0;
    v11 = (_QWORD *)(v8 + 24);
    while (1)
    {
      if ((v9[16] & 2) != 0)
      {
        v12 = sub_100010724((CFMutableDictionaryRef *)v5, v9, v6);
        if (!v12)
          goto LABEL_10;
        v10 = (v10 + 1);
        v13 = sub_100013544(a2, v10, (const __CFString *)v12, (CFTypeRef *)v6);
        CFRelease(v12);
        if (!v13)
          break;
      }
      v14 = (_BYTE *)*v11++;
      v9 = v14;
      if (!v14)
        goto LABEL_9;
    }
    LODWORD(v12) = 0;
  }
  else
  {
    LODWORD(v10) = 0;
LABEL_9:
    LODWORD(v12) = 1;
  }
LABEL_10:
  v15 = *(_QWORD *)(v4 + 16);
  v16 = *(_BYTE **)(v15 + 16);
  if (v16)
  {
    v17 = (_QWORD *)(v15 + 24);
    do
    {
      if ((*(unsigned int (**)(uint64_t, _BYTE *))(v7 + 16))(v7, v16))
      {
        result = (const __CFString *)sub_100010724((CFMutableDictionaryRef *)v4, v16, v6);
        if (!result)
          goto LABEL_19;
        v19 = result;
        v10 = (v10 + 1);
        LODWORD(v12) = v12 & sub_100013544(a2, v10, result, (CFTypeRef *)v6);
        CFRelease(v19);
        if ((_DWORD)v12 != 1)
          goto LABEL_18;
      }
      v20 = (_BYTE *)*v17++;
      v16 = v20;
    }
    while (v20);
  }
  if ((v12 & 1) == 0)
  {
LABEL_18:
    result = 0;
    goto LABEL_19;
  }
  result = (const __CFString *)sub_100019C40(*(_QWORD *)(a1 + 72), a2, *(CFTypeRef **)(a1 + 64), 0);
LABEL_19:
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = (_BYTE)result;
  return result;
}

BOOL sub_100007BB0(__CFString ***a1, CFStringRef **a2, uint64_t a3, CFTypeRef *a4, uint64_t a5)
{
  const __CFData *v10;
  const __CFUUID *v11;
  const __CFData *v12;
  const void *v13;
  const __CFAllocator *v14;
  __CFString *Mutable;
  CFStringRef *v16;
  CFStringRef v17;
  int v18;
  const __CFString **v19;
  const __CFString *isa;
  const __CFString *v21;
  __CFString **v22;
  const __CFString **v23;
  const __CFString ***v24;
  const __CFString **v25;
  char v26;
  char v27;
  NSObject *v28;
  NSObject *v29;
  _BOOL8 v30;
  _QWORD v32[10];
  CFUUIDBytes bytes;
  uint64_t v34;
  BOOL v35;
  _BYTE cf[12];
  __int16 v37;
  uint64_t v38;

  v10 = (const __CFData *)sub_10000C1D0(a1, kSecAttrPersistentReference);
  if (!v10 || CFDataGetLength(v10) != 16)
  {
    v11 = CFUUIDCreate(kCFAllocatorDefault);
    bytes = CFUUIDGetUUIDBytes(v11);
    v12 = CFDataCreate(kCFAllocatorDefault, &bytes.byte0, 16);
    *(_QWORD *)cf = 0;
    sub_10001D918((uint64_t)a2, v12, (__CFString **)cf);
    if (v11)
      CFRelease(v11);
    if (v12)
      CFRelease(v12);
    v13 = *(const void **)cf;
    if (*(_QWORD *)cf)
    {
      *(_QWORD *)cf = 0;
      CFRelease(v13);
    }
  }
  v14 = CFGetAllocator(a2);
  Mutable = CFStringCreateMutable(v14, 0);
  CFStringAppend(Mutable, CFSTR("UPDATE "));
  CFStringAppend(Mutable, *a2[2]);
  CFStringAppend(Mutable, CFSTR(" SET "));
  v16 = a2[2];
  v17 = v16[2];
  if (v17)
  {
    v18 = 0;
    v19 = v16 + 3;
    do
    {
      if (((uint64_t)v17->data & 2) != 0)
      {
        isa = (const __CFString *)v17->isa;
        if (v18)
          CFStringAppend(Mutable, CFSTR(","));
        CFStringAppend(Mutable, isa);
        CFStringAppend(Mutable, CFSTR("=?"));
        v18 = 1;
      }
      v21 = *v19++;
      v17 = v21;
    }
    while (v21);
  }
  bytes.byte0 = 1;
  v22 = a1[2];
  v23 = (const __CFString **)v22[2];
  if (v23)
  {
    v24 = (const __CFString ***)(v22 + 3);
    do
    {
      if ((*(unsigned int (**)(uint64_t, const __CFString **))(a5 + 16))(a5, v23))
        sub_100013150(Mutable, *v23, &bytes);
      v25 = *v24++;
      v23 = v25;
    }
    while (v25);
  }
  *(_QWORD *)&bytes.byte0 = 0;
  *(_QWORD *)&bytes.byte8 = &bytes;
  v34 = 0x2000000000;
  v35 = Mutable != 0;
  if (!Mutable)
    goto LABEL_32;
  v32[0] = _NSConcreteStackBlock;
  v32[1] = 0x40000000;
  v32[2] = sub_100007A58;
  v32[3] = &unk_1002DE750;
  v32[6] = a1;
  v32[7] = a2;
  v32[4] = a5;
  v32[5] = &bytes;
  v32[8] = a4;
  v32[9] = a3;
  v26 = sub_10001E3C4(a3, (uint64_t)Mutable, a4, (uint64_t)v32);
  v27 = *(_BYTE *)(*(_QWORD *)&bytes.byte8 + 24) ? v26 : 0;
  *(_BYTE *)(*(_QWORD *)&bytes.byte8 + 24) = v27;
  CFRelease(Mutable);
  if (*(_BYTE *)(*(_QWORD *)&bytes.byte8 + 24))
  {
    if ((sub_100004514(a1) & 1) == 0)
    {
      v28 = sub_10000EF14("item");
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)cf = 138478083;
        *(_QWORD *)&cf[4] = a1;
        v37 = 2112;
        v38 = a3;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "replaced %{private}@ in %@", cf, 0x16u);
      }
      v29 = sub_10000EF14("item");
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)cf = 138478083;
        *(_QWORD *)&cf[4] = a2;
        v37 = 2112;
        v38 = a3;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "    with %{private}@ in %@", cf, 0x16u);
      }
    }
    sub_1000104AC(a3, (uint64_t)a1, (CFArrayRef)a2);
    v30 = *(_BYTE *)(*(_QWORD *)&bytes.byte8 + 24) != 0;
  }
  else
  {
LABEL_32:
    v30 = 0;
  }
  _Block_object_dispose(&bytes, 8);
  return v30;
}

BOOL sub_100007F38(id a1, const SecDbAttr *a2)
{
  return a2->var1 == 8;
}

void sub_100007F48(CFTypeRef cf2, const void *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  CFTypeID v8;
  CFTypeID v9;
  CFMutableArrayRef Mutable;
  __CFArray *v11;
  CFIndex Count;
  CFIndex v13;
  CFIndex i;
  const void *ValueAtIndex;
  CFTypeID TypeID;
  const void *v17;
  const void *v18;
  uint64_t v19;
  CFTypeID v20;
  uint64_t v21;
  void *v22;
  const void *v23;
  CFTypeID v24;
  const void *v25;
  __CFArray *v26;
  CFTypeID v27;
  CFAbsoluteTime Current;
  CFDateRef v29;
  __CFString **v30;
  const __CFString *v31;
  CFTypeID v32;
  CFTypeID v33;
  CFTypeID v34;
  CFTypeID v35;

  v6 = *(_QWORD *)(a3 + 16) - 1;
  *(_QWORD *)(a3 + 16) = v6;
  v7 = a3 + 16 * v6;
  *(_QWORD *)(v7 + 264) = cf2;
  *(_QWORD *)(v7 + 272) = a2;
  if (!CFEqual(kSecMatchLimit, cf2))
  {
    if (CFEqual(kSecMatchIssuers, cf2))
    {
      v9 = CFGetTypeID(a2);
      if (v9 == CFArrayGetTypeID())
      {
        Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        if (!Mutable)
          return;
        v11 = Mutable;
        Count = CFArrayGetCount((CFArrayRef)a2);
        if (Count >= 1)
        {
          v13 = Count;
          for (i = 0; i != v13; ++i)
          {
            ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a2, i);
            TypeID = CFDataGetTypeID();
            if (TypeID == CFGetTypeID(ValueAtIndex))
            {
              v17 = (const void *)SecDistinguishedNameCopyNormalizedContent(ValueAtIndex);
              if (v17)
              {
                v18 = v17;
                CFArrayAppendValue(v11, v17);
                CFRelease(v18);
              }
            }
          }
        }
        if (CFArrayGetCount(v11) >= 1)
        {
          *(_QWORD *)(a3 + 176) = v11;
          return;
        }
        goto LABEL_25;
      }
    }
    if (CFEqual(kSecMatchPolicy, cf2))
    {
      v20 = CFGetTypeID(a2);
      if (v20 == CFArrayGetTypeID())
      {
        v21 = _CFXPCCreateXPCObjectFromCFObject(a2);
        if (v21)
        {
          v22 = (void *)v21;
          v11 = (__CFArray *)SecPolicyXPCArrayCopyArray(v21, a3 + 40);
          xpc_release(v22);
          if (!v11)
            return;
          if (CFArrayGetCount(v11) == 1)
          {
            v23 = CFArrayGetValueAtIndex(v11, 0);
            v24 = CFGetTypeID(v23);
            if (v24 == SecPolicyGetTypeID())
            {
              v25 = CFArrayGetValueAtIndex(v11, 0);
              sub_100120C0C(a3, v25);
LABEL_25:
              v26 = v11;
LABEL_32:
              CFRelease(v26);
              return;
            }
          }
          CFRelease(v11);
          v31 = CFSTR("unsupported array of policies");
        }
        else
        {
          v31 = CFSTR("unsupported kSecMatchPolicy object in query");
        }
        v30 = (__CFString **)(a3 + 40);
      }
      else
      {
        v30 = (__CFString **)(a3 + 40);
        v31 = CFSTR("unsupported value for kSecMatchPolicy attribute");
      }
    }
    else if (CFEqual(kSecMatchValidOnDate, cf2))
    {
      v27 = CFGetTypeID(a2);
      if (v27 == CFNullGetTypeID())
      {
        Current = CFAbsoluteTimeGetCurrent();
        v29 = CFDateCreate(kCFAllocatorDefault, Current);
        sub_100120C54(a3, v29);
        v26 = v29;
        goto LABEL_32;
      }
      v33 = CFGetTypeID(a2);
      if (v33 == CFDateGetTypeID())
      {
        sub_100120C54(a3, a2);
        return;
      }
      v30 = (__CFString **)(a3 + 40);
      v31 = CFSTR("unsupported value for kSecMatchValidOnDate attribute");
    }
    else if (CFEqual(kSecMatchTrustedOnly, cf2))
    {
      v32 = CFGetTypeID(a2);
      if (v32 == CFBooleanGetTypeID())
      {
        sub_100120C9C(a3, a2);
        return;
      }
      v30 = (__CFString **)(a3 + 40);
      v31 = CFSTR("unsupported value for kSecMatchTrustedOnly attribute");
    }
    else if (CFEqual(kSecMatchHostOrSubdomainOfHost, cf2))
    {
      v34 = CFGetTypeID(a2);
      if (v34 == CFStringGetTypeID())
      {
        sub_100120CE0(a3, a2);
        return;
      }
      v30 = (__CFString **)(a3 + 40);
      v31 = CFSTR("unsupported value for kSecMatchHostOrSubdomainOfHost attribute");
    }
    else
    {
      if (!CFEqual(kSecMatchEmailAddressIfPresent, cf2))
        return;
      v35 = CFGetTypeID(a2);
      if (v35 == CFStringGetTypeID())
      {
        sub_100120D24(a3, a2);
        return;
      }
      v30 = (__CFString **)(a3 + 40);
      v31 = CFSTR("unsupported value for kSecMatchEmailAddressIfPresent attribute");
    }
    sub_100019F20(-50, v30, v31);
    return;
  }
  v8 = CFGetTypeID(a2);
  if (v8 != CFNumberGetTypeID())
  {
    if (CFEqual(kSecMatchLimitAll, a2))
    {
      v19 = -1;
    }
    else
    {
      if (!CFEqual(kSecMatchLimitOne, a2))
      {
        sub_100019F20(-50, (__CFString **)(a3 + 40), CFSTR("unsupported match limit %@"), a2);
        return;
      }
      v19 = 1;
    }
    *(_QWORD *)(a3 + 104) = v19;
    return;
  }
  if (!CFNumberGetValue((CFNumberRef)a2, kCFNumberCFIndexType, (void *)(a3 + 104)))
    sub_100019F20(-50, (__CFString **)(a3 + 40), CFSTR("failed to convert match limit %@ to CFIndex"), a2);
}

_QWORD *sub_100008460(const void *a1, const void *a2, uint64_t a3)
{
  if (CFEqual(a1, kSecClass))
    return sub_1000117E0((_QWORD *)a3, a2, (__CFString **)(a3 + 40));
  else
    return (_QWORD *)sub_100019F20(-50, (__CFString **)(a3 + 40), CFSTR("add_class: key %@ is not %@"), a1, kSecClass);
}

void sub_1000084E8(uint64_t a1, xpc_object_t object)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
    sub_10000C3CC(*(_xpc_connection_s **)(a1 + 32), object);
}

uint64_t sub_100008534(uint64_t a1, CFCalendarRef calendar)
{
  uint64_t result;

  result = CFCalendarComposeAbsoluteTime(calendar, (CFAbsoluteTime *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), "yMdHms", *(unsigned int *)(a1 + 48), *(unsigned int *)(a1 + 52), *(unsigned int *)(a1 + 56), *(unsigned int *)(a1 + 60), *(unsigned int *)(a1 + 64), *(unsigned int *)(a1 + 68));
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (_DWORD)result != 0;
  return result;
}

uint64_t sub_10000864C(uint64_t a1, CFCalendarRef calendar)
{
  uint64_t result;

  result = CFCalendarDecomposeAbsoluteTime(calendar, *(CFAbsoluteTime *)(a1 + 40), "yMdHms", *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88));
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (_DWORD)result != 0;
  return result;
}

void sub_1000088F0(uint64_t a1)
{
  NSObject *v2;
  CFIndex Count;
  CFIndex v4;
  uint64_t v5;
  const __CFArray *v6;
  unint64_t v7;
  unint64_t v8;
  CFIndex v9;
  NSObject *v11;
  const char *v12;
  const char *v13;
  NSObject *v14;
  uint32_t v15;
  NSObject *v16;
  const char *v17;
  int v18;
  int v19;
  const char *v20;
  __int16 v21;
  int v22;

  if (!*(_BYTE *)(*(_QWORD *)(a1 + 32) + 48))
  {
    Count = CFArrayGetCount(*(CFArrayRef *)(*(_QWORD *)(a1 + 40) + 48));
    v4 = CFArrayGetCount(*(CFArrayRef *)(*(_QWORD *)(a1 + 40) + 40)) + Count;
    v5 = 48;
    if (!*(_BYTE *)(a1 + 48))
      v5 = 40;
    v6 = *(const __CFArray **)(*(_QWORD *)(a1 + 40) + v5);
    v7 = CFArrayGetCount(v6);
    if (*(_BYTE *)(a1 + 48))
      v8 = 5;
    else
      v8 = 1;
    v9 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 40) + 166);
    if (v7 < v8 && v4 < v9)
    {
      CFArrayAppendValue(v6, *(const void **)(a1 + 32));
      return;
    }
    if (v9 < 6)
    {
      v16 = sub_10000EF14("dbconn");
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        return;
      v17 = "ro";
      if (!*(_BYTE *)(a1 + 48))
        v17 = "rw";
      v18 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 40) + 166);
      v19 = 136315394;
      v20 = v17;
      v21 = 1024;
      v22 = v18;
      v13 = "releasing %s connection rather than storing in size %d cache";
      v14 = v16;
      v15 = 18;
    }
    else
    {
      v11 = sub_10000EF14("SecError");
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        return;
      if (*(_BYTE *)(a1 + 48))
        v12 = "ro";
      else
        v12 = "rw";
      v19 = 136315138;
      v20 = v12;
      v13 = "dbconn: did not expect to run out of room in the %s cache when releasing connection";
      v14 = v11;
      v15 = 12;
    }
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v13, (uint8_t *)&v19, v15);
    return;
  }
  v2 = sub_10000EF14("SecWarning");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v19) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SecDbConnectionRelease: IO failure reported in connection, throwing away currently idle caches", (uint8_t *)&v19, 2u);
  }
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(*(_QWORD *)(a1 + 40) + 40));
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(*(_QWORD *)(a1 + 40) + 48));
}

void sub_100008B98(uint64_t a1)
{
  uint64_t v2;
  CFTypeRef *v3;
  uint64_t *v4;
  const __CFString *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  CFTypeRef v9;
  NSObject *v10;
  int v11;
  NSObject *v12;
  CFIndex v13;
  int *v14;
  uint64_t v15;
  uint64_t v16;
  const __CFArray *v17;
  uint64_t v18;
  const void *ValueAtIndex;
  const void *v20;
  NSObject *v21;
  CFErrorDomain Domain;
  int Code;
  BOOL v25;
  uint64_t v26;
  uint64_t v27;
  NSObject *v28;
  NSObject *v29;
  CFTypeRef v30;
  unsigned __int8 v31;
  CFTypeRef cf[5];
  CFTypeRef v33;
  CFTypeRef *v34;
  uint64_t v35;
  char v36;
  __int128 buf;
  uint64_t (*v38)(uint64_t);
  void *v39;
  CFTypeRef *v40;

  v2 = *(_QWORD *)(a1 + 64);
  if (*(_BYTE *)(v2 + 128))
    goto LABEL_22;
  v4 = *(uint64_t **)(a1 + 72);
  v3 = *(CFTypeRef **)(a1 + 80);
  v5 = *(const __CFString **)(v2 + 16);
  v33 = 0;
  v34 = &v33;
  v35 = 0x2000000000;
  v36 = 1;
  cf[0] = _NSConcreteStackBlock;
  cf[1] = (CFTypeRef)0x40000000;
  cf[2] = sub_100031F08;
  cf[3] = &unk_1002DB6C0;
  cf[4] = &v33;
  *(_QWORD *)&buf = _NSConcreteStackBlock;
  *((_QWORD *)&buf + 1) = 0x40000000;
  v38 = sub_1000104A0;
  v39 = &unk_1002DB170;
  v40 = cf;
  sub_1000137F8(v5, (uint64_t)&buf);
  v6 = *((unsigned __int8 *)v34 + 24);
  _Block_object_dispose(&v33, 8);
  if (v6)
  {
    v31 = 0;
    v7 = sub_100031600(v2, 0);
    if (v7)
    {
      v8 = v7;
      cf[0] = 0;
      if ((sub_1000316F8(v7, (uint64_t)&v31, (uint64_t)cf) & 1) != 0)
      {
        v9 = cf[0];
        if (cf[0])
        {
          cf[0] = 0;
          CFRelease(v9);
        }
        if (v4)
          *v4 = v8;
        v10 = sub_10000EF14("#SecDB");
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          LOWORD(buf) = 0;
          _os_log_debug_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "#SecDB starting maintenance", (uint8_t *)&buf, 2u);
        }
        if (*(_BYTE *)(v8 + 40))
          goto LABEL_12;
        v26 = *(_QWORD *)(v8 + 16);
        v27 = *(_QWORD *)(v26 + 136);
        if (v27)
        {
          v33 = 0;
          *(_BYTE *)(v26 + 144) = 0;
          v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, CFTypeRef *))(v27 + 16))(v27, v26, v8, v31, v26 + 144, &v33);
          *(_BYTE *)(v2 + 128) = v11;
          if ((v11 & 1) == 0)
          {
            v28 = sub_10000EF14("SecError");
            if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(buf) = 138412290;
              *(_QWORD *)((char *)&buf + 4) = v33;
              _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "opened block failed: %@", (uint8_t *)&buf, 0xCu);
            }
          }
          if (!v3 || *(_BYTE *)(v8 + 40) || *v3)
          {
            if (v33)
            {
              v29 = sub_10000EF14("SecError");
              if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(buf) = 138412290;
                *(_QWORD *)((char *)&buf + 4) = v33;
                _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "opened block failed: error (%@) is being released and lost", (uint8_t *)&buf, 0xCu);
              }
              v30 = v33;
              if (v33)
              {
                v33 = 0;
                CFRelease(v30);
              }
            }
          }
          else
          {
            *v3 = v33;
          }
          if (*(_BYTE *)(v8 + 40))
LABEL_12:
            v11 = sub_1000311E4(v8, 0, v3);
        }
        else
        {
          v11 = 0;
        }
        v12 = sub_10000EF14("#SecDB");
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        {
          LOWORD(buf) = 0;
          _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "#SecDB ending maintenance", (uint8_t *)&buf, 2u);
          if (!v11)
          {
LABEL_16:
            CFRelease((CFTypeRef)v8);
            if (v4)
              *v4 = 0;
            goto LABEL_20;
          }
        }
        else if (!v11)
        {
          goto LABEL_16;
        }
        CFArrayAppendValue(*(CFMutableArrayRef *)(v2 + 40), (const void *)v8);
        goto LABEL_16;
      }
      v21 = sub_10000EF14("SecError");
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138412290;
        *(CFTypeRef *)((char *)&buf + 4) = cf[0];
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Unable to create database: %@", (uint8_t *)&buf, 0xCu);
      }
      if (cf[0])
      {
        Domain = CFErrorGetDomain((CFErrorRef)cf[0]);
        if (CFEqual(Domain, CFSTR("com.apple.utilities.sqlite3")))
        {
          Code = CFErrorGetCode((CFErrorRef)cf[0]);
          v25 = Code == 11 || Code == 26;
          *(_BYTE *)(v8 + 40) = v25;
        }
      }
      LOBYTE(v11) = 0;
      if (!v3 || *(_BYTE *)(v8 + 40))
        goto LABEL_20;
      if (!*v3)
      {
        LOBYTE(v11) = 0;
        *v3 = cf[0];
        goto LABEL_20;
      }
    }
  }
  else
  {
    v13 = *__error();
    v14 = __error();
    sub_100032660(v13, kCFErrorDomainPOSIX, 0, v3, v15, CFSTR("Unable to process corruption marker: %{darwin.errno}d"), *v14);
  }
  LOBYTE(v11) = 0;
LABEL_20:
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = v11;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v11;
  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24))
    return;
  v2 = *(_QWORD *)(a1 + 64);
LABEL_22:
  v16 = 48;
  if (!*(_BYTE *)(a1 + 88))
    v16 = 40;
  v17 = *(const __CFArray **)(v2 + v16);
  if (CFArrayGetCount(v17) && !*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24))
  {
    v18 = *(_QWORD *)(a1 + 32);
    ValueAtIndex = CFArrayGetValueAtIndex(v17, 0);
    if ((*(unsigned int (**)(uint64_t, const void *))(v18 + 16))(v18, ValueAtIndex))
    {
      v20 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24);
      if (v20)
        CFRetain(v20);
    }
    CFArrayRemoveValueAtIndex(v17, 0);
  }
}

BOOL sub_10000907C(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;

  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a2;
  v2 = *(_QWORD **)(a1 + 40);
  if (v2)
    *v2 = a2;
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) != 0;
}

uint64_t sub_100009678(const void *a1, CFTypeRef cf, uint64_t a3)
{
  CFTypeID v6;
  int v7;
  uint64_t result;
  int v9;
  int v10;
  int v11;

  v6 = CFGetTypeID(cf);
  if (v6 != CFBooleanGetTypeID())
    return sub_100019F20(-50, (__CFString **)(a3 + 40), CFSTR("add_return: value %@ is not CFBoolean"), cf);
  v7 = CFEqual(cf, kCFBooleanTrue);
  result = CFEqual(a1, kSecReturnData);
  if ((_DWORD)result)
  {
    v9 = 1;
  }
  else
  {
    result = CFEqual(a1, kSecReturnAttributes);
    if ((_DWORD)result)
    {
      v9 = 2;
    }
    else
    {
      result = CFEqual(a1, kSecReturnRef);
      if ((_DWORD)result)
      {
        v9 = 4;
      }
      else
      {
        result = CFEqual(a1, kSecReturnPersistentRef);
        if (!(_DWORD)result)
          return sub_100019F20(-50, (__CFString **)(a3 + 40), CFSTR("add_return: unknown key %@"), a1);
        v9 = 8;
      }
    }
  }
  v10 = *(_DWORD *)(a3 + 48);
  if ((v10 & v9) != 0 && !v7)
  {
    v11 = v10 ^ v9;
LABEL_17:
    *(_DWORD *)(a3 + 48) = v11;
    return result;
  }
  if ((v10 & v9) == 0 && v7)
  {
    v11 = v10 | v9;
    goto LABEL_17;
  }
  return result;
}

void sub_1000097B0(const __CFString *cf, const __CFBoolean *a2, __CFString **a3)
{
  __CFString **v3;
  CFTypeID v7;
  CFIndex Length;
  int CharacterAtIndex;

  v3 = a3 + 5;
  if (a3[5])
    return;
  if (!cf)
  {
    sub_100019F20(-50, a3 + 5, CFSTR("applier: NULL key"));
    return;
  }
  if (!a2)
  {
    sub_100019F20(-50, v3, CFSTR("applier: key %@ has NULL value"), cf);
    return;
  }
  v7 = CFGetTypeID(cf);
  if (v7 != CFStringGetTypeID())
  {
    if (v7 != CFNumberGetTypeID())
    {
      sub_100019F20(-50, v3, CFSTR("applier: key %@ neither string nor number"), cf);
      return;
    }
LABEL_13:
    sub_100012178(cf, a2, (uint64_t)a3);
    return;
  }
  Length = CFStringGetLength(cf);
  if (Length == 4)
    goto LABEL_13;
  if (Length < 2)
  {
    sub_100019F20(-50, v3, CFSTR("applier: key %@ invalid length"), cf);
  }
  else
  {
    CharacterAtIndex = CFStringGetCharacterAtIndex(cf, 0);
    switch(CharacterAtIndex)
    {
      case 'm':
        sub_100007F48(cf, a2, (uint64_t)a3);
        break;
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 's':
      case 't':
        goto LABEL_19;
      case 'r':
        sub_100009678(cf, a2, (uint64_t)a3);
        break;
      case 'u':
        sub_1000076C4(cf, (const __CFString *)a2, (uint64_t)a3);
        break;
      case 'v':
        sub_100004A58(cf, a2, a3);
        break;
      default:
        if (CharacterAtIndex != 102)
        {
          if (CharacterAtIndex == 99)
            sub_100008460(cf, a2, (uint64_t)a3);
          else
LABEL_19:
            sub_100019F20(-50, v3, CFSTR("applier: key %@ invalid"), cf);
        }
        break;
    }
  }
}

uint64_t sub_1000099C8(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)a3)
  {
    result = sub_100020E9C(result, a2, *(_QWORD *)(a3 + 16));
    if (result)
      *(_QWORD *)(a3 + 8) += result;
    else
      *(_BYTE *)a3 = 0;
  }
  return result;
}

uint64_t sub_100009A0C(const __CFData *a1, const __CFData *a2)
{
  CFIndex Length;
  CFIndex v5;
  unint64_t v6;
  size_t v7;
  const UInt8 *BytePtr;
  const UInt8 *v9;
  int v10;
  uint64_t v12;
  uint64_t v13;

  Length = CFDataGetLength(a1);
  v5 = CFDataGetLength(a2);
  v6 = v5;
  if (Length < 0 || v5 < 0)
  {
    if (Length >= v5)
      v12 = 0;
    else
      v12 = -1;
    if (Length <= v5)
      return v12;
    else
      return 1;
  }
  else
  {
    if (Length >= v5)
      v7 = v5;
    else
      v7 = Length;
    BytePtr = CFDataGetBytePtr(a1);
    v9 = CFDataGetBytePtr(a2);
    v10 = memcmp(BytePtr, v9, v7);
    if (v10 <= 0 && (v10 || Length <= v6))
    {
      LODWORD(v13) = v10 == 0;
      if (Length >= v6)
        LODWORD(v13) = 0;
      if (v10 < 0)
        v13 = 1;
      else
        v13 = v13;
      return v13 << 63 >> 63;
    }
    else
    {
      return 1;
    }
  }
}

void sub_100009AD0(uint64_t a1, const __CFArray *a2)
{
  void *v4;
  void *v5;
  void *v6;
  id v7;
  NSObject *v8;
  __int128 v9;
  uint8_t buf[4];
  const __CFArray *v11;

  v9 = 0uLL;
  v4 = objc_autoreleasePoolPush();
  sub_100009FB8(a2, (CFTypeID *)&v9 + 1, (const __CFArray **)&v9);
  objc_autoreleasePoolPop(v4);
  if (v9 == 0)
  {
    v7 = sub_10000BDF4(CFSTR("ckks"), 0);
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      v11 = a2;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "SecDbEvent gave us garbage: %@", buf, 0xCu);
    }

  }
  else
  {
    v5 = objc_autoreleasePoolPush();
    v6 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSViewManager manager](CKKSViewManager, "manager"));
    objc_msgSend(v6, "handleKeychainEventDbConnection:source:added:deleted:", *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), v9);

    objc_autoreleasePoolPop(v5);
  }
}

void sub_100009BF0(id a1, __OpaqueSecDbConnection *a2, unint64_t a3, unint64_t a4, __CFArray *a5)
{
  unsigned int v6;
  __CFArray *v7;
  id v8;
  __int128 v9;
  id v10;
  char v11;
  uint64_t v12;
  void *i;
  const __CFArray *v14;
  BOOL v15;
  id v16;
  void *v17;
  uint64_t v18;
  NSObject *v19;
  NSObject *v20;
  const char *v21;
  id v22;
  uint64_t v23;
  id v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  NSObject *v28;
  id v29;
  void *v30;
  uint64_t v31;
  void *v32;
  void *v33;
  void *v34;
  __int128 v35;
  const __CFArray *v36;
  const __CFArray *v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  uint8_t buf[4];
  const __CFArray *v43;
  __int16 v44;
  const __CFArray *v45;
  _BYTE v46[128];

  if (!a3)
    return;
  if (a4 != 1)
    return;
  if (!objc_opt_class(CKDatabase))
    return;
  v6 = atomic_load((unsigned int *)&unk_100340ED0);
  if (v6 > 1)
    return;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v7 = a5;
  v8 = -[__CFArray countByEnumeratingWithState:objects:count:](v7, "countByEnumeratingWithState:objects:count:", &v38, v46, 16);
  if (!v8)
  {
LABEL_42:

    return;
  }
  v10 = v8;
  v11 = 0;
  v12 = *(_QWORD *)v39;
  *(_QWORD *)&v9 = 138477827;
  v35 = v9;
  while (2)
  {
    for (i = 0; i != v10; i = (char *)i + 1)
    {
      if (*(_QWORD *)v39 != v12)
        objc_enumerationMutation(v7);
      v14 = *(const __CFArray **)(*((_QWORD *)&v38 + 1) + 8 * (_QWORD)i);
      v36 = 0;
      v37 = 0;
      sub_100009FB8(v14, (CFTypeID *)&v37, &v36);
      if (v37)
        v15 = v36 == 0;
      else
        v15 = 1;
      if (v15)
      {
        if (v37 || !v36)
        {
          if (!v37 || v36)
          {
            v19 = objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler", v35));
            v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "void KCSharingRegisterForDatabaseEvents(SecDbRef)_block_invoke"));
            -[NSObject handleFailureInFunction:file:lineNumber:description:](v19, "handleFailureInFunction:file:lineNumber:description:", v32, CFSTR("KCSharingSupport.m"), 112, CFSTR("Database event should have old item, new item, or both"));

            goto LABEL_36;
          }
          v29 = sub_10000A078(v37);
          v30 = (void *)objc_claimAutoreleasedReturnValue(v29);

          if (!v30)
            continue;
          v31 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
          v19 = objc_claimAutoreleasedReturnValue(v31);
          if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
LABEL_34:
            v11 = 1;
LABEL_36:

            continue;
          }
          *(_DWORD *)buf = v35;
          v43 = v37;
          v20 = v19;
          v21 = "KCSharing-relevant delete for oldItem=%{private}@";
        }
        else
        {
          v16 = sub_10000A078(v36);
          v17 = (void *)objc_claimAutoreleasedReturnValue(v16);

          if (!v17)
            continue;
          v18 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
          v19 = objc_claimAutoreleasedReturnValue(v18);
          if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            goto LABEL_34;
          *(_DWORD *)buf = v35;
          v43 = v36;
          v20 = v19;
          v21 = "KCSharing-relevant insert for newItem=%{private}@";
        }
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v21, buf, 0xCu);
        goto LABEL_34;
      }
      v22 = sub_10000A078(v37);
      v23 = objc_claimAutoreleasedReturnValue(v22);
      v24 = sub_10000A078(v36);
      v25 = objc_claimAutoreleasedReturnValue(v24);
      v26 = (void *)v25;
      if (v23 | v25)
      {
        if (!v23 || !v25 || !objc_msgSend((id)v23, "isEqual:", v25))
        {
          v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler", v35));
          v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "void KCSharingRegisterForDatabaseEvents(SecDbRef)_block_invoke"));
          objc_msgSend(v33, "handleFailureInFunction:file:lineNumber:description:", v34, CFSTR("KCSharingSupport.m"), 88, CFSTR("Sharing group shouldn't change in update event"));

          goto LABEL_42;
        }
        v27 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
        v28 = objc_claimAutoreleasedReturnValue(v27);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138478083;
          v43 = v37;
          v44 = 2113;
          v45 = v36;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "KCSharing-relevant update for oldItem=%{private}@ to newItem=%{private}@", buf, 0x16u);
        }

        v11 = 1;
      }

    }
    v10 = -[__CFArray countByEnumeratingWithState:objects:count:](v7, "countByEnumeratingWithState:objects:count:", &v38, v46, 16);
    if (v10)
      continue;
    break;
  }

  if ((v11 & 1) != 0)
  {
    v7 = (__CFArray *)objc_claimAutoreleasedReturnValue(+[KCSharingSyncController sharedInstance](KCSharingSyncController, "sharedInstance"));
    -[__CFArray processDatabaseModifications](v7, "processDatabaseModifications");
    goto LABEL_42;
  }
}

CFTypeID sub_100009FB8(const __CFArray *a1, CFTypeID *a2, const __CFArray **a3)
{
  const __CFArray *v5;
  CFTypeID v6;
  CFTypeID result;

  v5 = a1;
  v6 = CFGetTypeID(a1);
  result = CFArrayGetTypeID();
  if (v6 == result)
  {
    result = CFArrayGetCount(v5);
    if (result == 2)
    {
      if (a2)
      {
        result = (CFTypeID)CFArrayGetValueAtIndex(v5, 0);
        *a2 = result;
      }
      if (a3)
      {
        result = (CFTypeID)CFArrayGetValueAtIndex(v5, 1);
        v5 = (const __CFArray *)result;
LABEL_18:
        *a3 = v5;
      }
    }
    else
    {
      if (result == 1)
      {
        if (a2)
        {
          result = (CFTypeID)CFArrayGetValueAtIndex(v5, 0);
          *a2 = result;
        }
      }
      else if (a2)
      {
        *a2 = 0;
      }
      if (a3)
      {
        v5 = 0;
        goto LABEL_18;
      }
    }
  }
  else
  {
    if (a2)
      *a2 = 0;
    if (a3)
      goto LABEL_18;
  }
  return result;
}

id sub_10000A078(_QWORD *a1)
{
  uint64_t v2;
  void *v3;
  const __CFSet *v4;
  const __CFDictionary *v5;
  void *v6;
  void *v7;
  uint64_t v9;

  v2 = kSecAttrSharingGroup;
  v9 = kSecAttrSharingGroup;
  v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v9, 1));
  v4 = (const __CFSet *)objc_claimAutoreleasedReturnValue(+[NSSet setWithArray:](NSSet, "setWithArray:", v3));
  v5 = sub_10000A15C(a1, v4, 0);
  v6 = (void *)objc_claimAutoreleasedReturnValue(v5);

  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectForKeyedSubscript:", v2));
  return v7;
}

const __CFDictionary *sub_10000A15C(_QWORD *a1, const __CFSet *a2, _QWORD *a3)
{
  CFMutableDictionaryRef Mutable;
  uint64_t v7;
  const void **v8;
  const void ***v9;
  const void *v10;
  const void *v11;
  const void **v12;
  CFDictionaryRef Copy;
  CFDictionaryRef v14;
  const __CFDictionary *v15;
  id v16;
  id v18;

  v18 = 0;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v7 = a1[2];
  v8 = *(const void ***)(v7 + 16);
  if (v8)
  {
    v9 = (const void ***)(v7 + 24);
    do
    {
      if (CFSetContainsValue(a2, *v8))
      {
        v10 = sub_100019204(a1, (uint64_t)v8, (__CFString **)&v18);
        if (!v10)
        {
          if (Mutable)
          {
            v14 = 0;
LABEL_13:
            CFRelease(Mutable);
            if (v14)
              goto LABEL_14;
          }
LABEL_15:
          v16 = v18;
          if (a3)
          {
            v15 = 0;
            *a3 = v18;
            v18 = 0;
          }
          else
          {
            if (v18)
            {
              v18 = 0;
              CFRelease(v16);
            }
            v15 = 0;
          }
          goto LABEL_20;
        }
        v11 = v10;
        if (!CFEqual(kCFNull, v10))
          CFDictionarySetValue(Mutable, *v8, v11);
      }
      v12 = *v9++;
      v8 = v12;
    }
    while (v12);
  }
  Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, Mutable);
  v14 = Copy;
  if (Mutable)
    goto LABEL_13;
  if (!Copy)
    goto LABEL_15;
LABEL_14:
  v15 = v14;
LABEL_20:

  return v15;
}

void sub_10000AB24(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10000AFC8(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_10000BC1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
  _Block_object_dispose(&a55, 8);
  _Block_object_dispose(&a47, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10000BC78(_QWORD **a1)
{
  uint64_t v2;
  uint64_t result;
  char v4;

  v4 = -86;
  v2 = sub_10001E6A8(a1[2], 11, 0);
  LODWORD(result) = sub_10000BCD4(a1, v2, (BOOL *)&v4, 0);
  if (v4)
    return result;
  else
    return 0;
}

BOOL sub_10000BCD4(const void *a1, uint64_t a2, BOOL *a3, __CFString **a4)
{
  const __CFNumber *v5;
  const __CFNumber *v6;
  CFTypeID v7;
  BOOL v8;
  char valuePtr;

  v5 = (const __CFNumber *)sub_100019204(a1, a2, a4);
  v6 = v5;
  if (v5)
  {
    valuePtr = -86;
    v7 = CFGetTypeID(v5);
    v8 = v7 == CFNumberGetTypeID() && CFNumberGetValue(v6, kCFNumberCharType, &valuePtr) && valuePtr == 1;
    *a3 = v8;
  }
  return v6 != 0;
}

uint64_t sub_10000BD64()
{
  id v1;
  NSObject *v2;
  uint8_t v3[16];

  if (objc_opt_class(CKDatabase))
    return byte_100341040;
  v1 = sub_10000BDF4(CFSTR("ckks"), 0);
  v2 = objc_claimAutoreleasedReturnValue(v1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "CloudKit.framework appears to not be linked. Cannot enable CKKS (on pain of crash).", v3, 2u);
  }

  return 0;
}

id sub_10000BDF4(void *a1, void *a2)
{
  id v3;
  id v4;
  id v5;
  NSObject *v6;
  id v7;
  id v8;
  id v9;
  _QWORD block[4];
  id v12;
  id v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t, uint64_t);
  void (*v19)(uint64_t);
  id v20;

  v3 = a1;
  v4 = a2;
  v15 = 0;
  v16 = &v15;
  v17 = 0x3032000000;
  v18 = sub_1000CE990;
  v19 = sub_1000CE9A0;
  v5 = &_os_log_disabled;
  v20 = &_os_log_disabled;
  if (qword_100341088 != -1)
    dispatch_once(&qword_100341088, &stru_1002DD458);
  v6 = qword_100341080;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100006FBC;
  block[3] = &unk_1002EAC48;
  v12 = v4;
  v13 = v3;
  v14 = &v15;
  v7 = v3;
  v8 = v4;
  dispatch_sync(v6, block);
  v9 = (id)v16[5];

  _Block_object_dispose(&v15, 8);
  return v9;
}

const void *sub_10000BF78(_QWORD *a1)
{
  const void *result;
  CFTypeID v2;

  result = sub_10000C1D0(a1, kSecAttrSharingGroup);
  if (result)
  {
    v2 = CFGetTypeID(result);
    return (const void *)(v2 == CFStringGetTypeID());
  }
  return result;
}

const void *sub_10000C1D0(_QWORD *a1, CFTypeRef cf2)
{
  const __CFDictionary *v4;
  const void *result;
  uint64_t v6;
  CFTypeRef *v7;
  CFTypeRef **v8;
  CFTypeRef *v9;

  if (!a1 || !cf2 || (v4 = (const __CFDictionary *)a1[6]) == 0 || (result = CFDictionaryGetValue(v4, cf2)) == 0)
  {
    v6 = a1[2];
    v7 = *(CFTypeRef **)(v6 + 16);
    if (v7)
    {
      v8 = (CFTypeRef **)(v6 + 24);
      while (!CFEqual(*v7, cf2))
      {
        v9 = *v8++;
        v7 = v9;
        if (!v9)
          return 0;
      }
      return sub_100019204(a1, (uint64_t)v7, 0);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL sub_10000C25C(CFStringRef **a1, uint64_t a2, CFTypeRef *a3, uint64_t a4)
{
  _BOOL8 v6;
  NSObject *v7;
  int v9;
  CFStringRef **v10;
  __int16 v11;
  uint64_t v12;

  v6 = sub_10001E020(a1, a2, a3, a4);
  if (v6)
  {
    v7 = sub_10000EF14("item");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 138478083;
      v10 = a1;
      v11 = 2112;
      v12 = a2;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "deleted %{private}@ from %@", (uint8_t *)&v9, 0x16u);
    }
    sub_1000104AC(a2, (uint64_t)a1, 0);
  }
  return v6;
}

BOOL sub_10000C334(unsigned int a1, __SecTask *a2, __CFString **a3)
{
  _BOOL4 v6;
  const __CFString *v7;

  v6 = sub_10000FA3C(a2, CFSTR("com.apple.private.keychain.deny"));
  if (v6)
  {
    if (a1 > 0x87)
      v7 = CFSTR("Unknown xpc operation");
    else
      v7 = off_1002E9940[a1];
    sub_100019F20(-25291, a3, CFSTR("%@: %@ has entitlement %@"), v7, a2, CFSTR("com.apple.private.keychain.deny"));
  }
  return !v6;
}

void sub_10000C3CC(_xpc_connection_s *a1, xpc_object_t object)
{
  xpc_type_t type;
  uint64_t v5;
  NSObject *v6;
  CFTypeRef v7;
  xpc_object_t v8;
  xpc_object_t reply_with_format;
  CFDataRef v10;
  const void *v11;
  CFTypeRef v12;
  const void *v13;
  uint64_t uint64;
  uid_t euid;
  NSObject *v16;
  const char *v17;
  void *v18;
  int64_t v19;
  const __CFString *v20;
  const __CFDictionary *v21;
  const __CFDictionary *Mutable;
  _BOOL4 v23;
  const __CFDictionary *v24;
  const __CFString *v25;
  __CFString **v26;
  void *v27;
  uint64_t v28;
  const __CFString *v29;
  const __CFDictionary *v30;
  const __CFDictionary *v31;
  const __CFDictionary *v32;
  const __CFDictionary *v33;
  BOOL v34;
  const __CFDictionary *v35;
  char v36;
  const void *v37;
  const void *v38;
  int v39;
  char v40;
  char v41;
  CFTypeRef v42;
  uint64_t v43;
  const __CFData *v44;
  int v45;
  int v46;
  BOOL v47;
  int *v48;
  int v49;
  int v50;
  CFDataRef v51;
  CFDataRef v52;
  CFDataRef v53;
  CFTypeRef v54;
  const __CFString *v55;
  const __CFString *v56;
  CFDataRef v57;
  const __CFDictionary *v58;
  CFDataRef v59;
  CFDataRef v60;
  const void *v61;
  BOOL v62;
  const __CFDictionary *v63;
  const __CFString *v64;
  _BOOL4 v65;
  const __CFString *v66;
  CFStringRef v67;
  CFStringRef v68;
  int v69;
  CFStringRef v70;
  const __CFData *v71;
  CFStringRef v72;
  char v73;
  const void *v74;
  CFStringRef v75;
  CFStringRef v76;
  CFDataRef v77;
  CFDataRef v78;
  CFDataRef v79;
  CFDataRef v80;
  char v81;
  const __CFDictionary *v82;
  const __CFString *v83;
  const __CFData *v84;
  _BOOL4 v85;
  _BOOL4 v86;
  CFDataRef v87;
  void *v88;
  BOOL v89;
  unsigned int v90;
  char v91;
  const __CFDictionary *v92;
  const __CFString *v93;
  const __CFDictionary *v94;
  void *v95;
  BOOL v96;
  _QWORD *v97;
  CFTypeRef *v98;
  Block_layout *v99;
  _QWORD *v100;
  xpc_object_t v101;
  BOOL v102;
  void *v103;
  xpc_object_t v104;
  uint64_t ArrayOfPeerInfoWithXPCObject;
  xpc_object_t v106;
  uint64_t v107;
  const void *v108;
  const void *v109;
  int int64;
  const __CFString *v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  __CFData *v115;
  const UInt8 *BytePtr;
  size_t Length;
  uint64_t v118;
  CFDataRef v119;
  uint64_t v120;
  const void *v121;
  void *v122;
  char v123;
  BOOL v124;
  const void *v125;
  CFDataRef v126;
  uint64_t v127;
  uint64_t v128;
  const void *v129;
  void *v130;
  int v131;
  CFDataRef v132;
  CFDataRef v133;
  char v134;
  uint64_t v135;
  uint64_t v136;
  void *v137;
  _BOOL4 v138;
  const UInt8 *v139;
  size_t v140;
  void *v141;
  BOOL v142;
  unsigned int v143;
  const __CFArray *v144;
  CFStringRef v145;
  const __CFString *v146;
  char v147;
  const __CFString *v148;
  int v149;
  const __CFString *v150;
  int v151;
  int v152;
  const __CFData *v153;
  const __CFData *v154;
  const __CFDictionary *v155;
  CFBooleanRef v156;
  const __CFDictionary *v157;
  const __CFString *v158;
  const __CFString *v159;
  uint64_t v160;
  uint64_t v161;
  CFDataRef v162;
  const void *v163;
  const void *v164;
  uint64_t v165;
  CFDataRef v166;
  CFDataRef v167;
  const void *v168;
  const void *v169;
  BOOL v170;
  __SecTask *v171;
  __CFString **v172;
  unsigned int v173;
  void *v174;
  void *v175;
  const __CFDictionary *v176;
  CFStringRef v177;
  const __CFString *v178;
  const __CFString *v179;
  BOOL v180;
  const __CFString *v181;
  const void *v182;
  CFTypeRef v183;
  __CFError *v184;
  CFErrorDomain Domain;
  NSObject *v186;
  const __CFString *v187;
  const __CFString *v188;
  CFTypeRef v189;
  const char *v190;
  CFTypeRef v191;
  CFDataRef v192;
  CFDataRef v193;
  CFDataRef v194;
  CFDataRef v195;
  char v196;
  int v197;
  BOOL v198;
  __CFString **v199;
  CFDataRef v200;
  CFDataRef v201;
  _QWORD v202[6];
  _QWORD v203[6];
  _QWORD v204[6];
  _QWORD v205[6];
  BOOL value;
  CFDataRef v207;
  CFDataRef theData;
  CFTypeRef cf;
  UInt8 bytes[16];
  __int128 v211;
  __int128 v212;
  __int128 v213;
  __int128 v214;
  __int128 v215;
  uint64_t v216;
  CFTypeRef *v217;
  uint64_t v218;
  uint64_t v219;
  _BYTE buf[32];
  int v221;

  type = xpc_get_type(object);
  v216 = 0;
  v217 = (CFTypeRef *)&v216;
  v218 = 0x2000000000;
  v219 = 0;
  v214 = 0u;
  v215 = 0u;
  v212 = 0u;
  v213 = 0u;
  DWORD1(v213) = xpc_connection_get_euid(a1);
  BYTE12(v214) = 0;
  BYTE9(v215) = 0;
  if (type != (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_100032660(1, CFSTR("com.apple.security.xpc"), 0, v217 + 3, v5, CFSTR("Messages expect to be xpc dictionary, got: %@"), object);
    v6 = sub_10000EF14("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v7 = v217[3];
      *(_DWORD *)buf = 138412546;
      *(_QWORD *)&buf[4] = v212;
      *(_WORD *)&buf[12] = 2112;
      *(_QWORD *)&buf[14] = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%@: returning error: %@", buf, 0x16u);
    }
    v8 = sub_100010350((__CFError *)v217[3]);
    reply_with_format = (xpc_object_t)xpc_create_reply_with_format(object, "{%string: %value}", "error", v8);
    v10 = 0;
    v11 = 0;
LABEL_5:
    if (!reply_with_format)
      goto LABEL_7;
    goto LABEL_6;
  }
  reply_with_format = xpc_dictionary_create_reply(object);
  uint64 = xpc_dictionary_get_uint64(object, "operation");
  *(_OWORD *)bytes = 0u;
  v211 = 0u;
  xpc_connection_get_audit_token(a1, bytes);
  v10 = CFDataCreate(kCFAllocatorDefault, bytes, 32);
  euid = xpc_connection_get_euid(a1);
  *(_OWORD *)buf = *(_OWORD *)bytes;
  *(_OWORD *)&buf[16] = v211;
  if ((sub_10000F094((uint64_t)&v212, euid, buf) & 1) != 0)
  {
    if (uint64 == 30)
      v11 = sub_10000FAA8((__SecTask *)v212, CFSTR("com.apple.developer.associated-domains"));
    else
      v11 = 0;
    v16 = sub_10000EF14("serverxpc");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      if (uint64 > 0x87)
        v20 = CFSTR("Unknown xpc operation");
      else
        v20 = off_1002E9940[uint64];
      *(_DWORD *)buf = 138412802;
      *(_QWORD *)&buf[4] = v212;
      *(_WORD *)&buf[12] = 2112;
      *(_QWORD *)&buf[14] = v20;
      *(_WORD *)&buf[22] = 2048;
      *(_QWORD *)&buf[24] = uint64;
      _os_log_debug_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "XPC [%@] operation: %@ (%llu)", buf, 0x20u);
    }
    switch(uint64)
    {
      case 0uLL:
        if (sub_10000C334(0, (__SecTask *)v212, (__CFString **)v217 + 3))
        {
          v21 = (const __CFDictionary *)sub_10000FE74(object, "query", (__CFString **)v217 + 3);
          if (v21)
          {
            Mutable = v21;
            if ((CFDictionaryGetValue(v21, kSecAttrDeriveSyncIDFromItemAttributes)
               || CFDictionaryGetValue(Mutable, kSecAttrPCSPlaintextServiceIdentifier)
               || CFDictionaryGetValue(Mutable, kSecAttrPCSPlaintextPublicKey)
               || CFDictionaryGetValue(Mutable, kSecAttrPCSPlaintextPublicIdentity))
              && !sub_1000237E0(0, (__SecTask *)v212, CFSTR("com.apple.private.ckks.plaintextfields"), (__CFString **)v217 + 3)|| (CFDictionaryGetValue(Mutable, kSecDataInetExtraNotes)|| CFDictionaryGetValue(Mutable, kSecDataInetExtraHistory)|| CFDictionaryGetValue(Mutable, kSecDataInetExtraClientDefined0)|| CFDictionaryGetValue(Mutable, kSecDataInetExtraClientDefined1)|| CFDictionaryGetValue(Mutable, kSecDataInetExtraClientDefined2)|| CFDictionaryGetValue(Mutable, kSecDataInetExtraClientDefined3))&& !sub_1000237E0(0, (__SecTask *)v212, CFSTR("com.apple.private.keychain.inet_expansion_fields"), (__CFString **)v217 + 3))
            {
              *(_QWORD *)buf = 0;
              goto LABEL_407;
            }
            if (CFDictionaryGetValue(Mutable, kSecAttrSysBound))
            {
              v23 = sub_1000237E0(0, (__SecTask *)v212, CFSTR("com.apple.private.keychain.sysbound"), (__CFString **)v217 + 3);
              *(_QWORD *)buf = 0;
              if (!v23)
                goto LABEL_407;
            }
            else
            {
              *(_QWORD *)buf = 0;
            }
            if (sub_10001C1F0(Mutable, (uint64_t)&v212, (uint64_t)buf, (__CFString **)v217 + 3))
            {
              v25 = *(const __CFString **)buf;
              if (*(_QWORD *)buf)
              {
                v26 = (__CFString **)(v217 + 3);
                v27 = reply_with_format;
                v28 = 0;
                goto LABEL_61;
              }
            }
            goto LABEL_407;
          }
        }
        goto LABEL_409;
      case 1uLL:
        if (sub_10000C334(0, (__SecTask *)v212, (__CFString **)v217 + 3))
        {
          v24 = (const __CFDictionary *)sub_10000FE74(object, "query", (__CFString **)v217 + 3);
          if (v24)
          {
            Mutable = v24;
            *(_QWORD *)buf = 0;
            if (sub_1000109C4(v24, (uint64_t)&v212, (uint64_t *)buf, (__CFString **)v217 + 3))
            {
              v25 = *(const __CFString **)buf;
              if (*(_QWORD *)buf)
              {
                v26 = (__CFString **)(v217 + 3);
                v27 = reply_with_format;
                v28 = 1;
LABEL_61:
                sub_100010098(v27, "status", v25, v28, v26);
                v29 = *(const __CFString **)buf;
                if (*(_QWORD *)buf)
                {
                  *(_QWORD *)buf = 0;
                  goto LABEL_406;
                }
              }
            }
            goto LABEL_407;
          }
        }
        goto LABEL_409;
      case 2uLL:
        if (sub_10000C334(2u, (__SecTask *)v212, (__CFString **)v217 + 3))
        {
          v30 = (const __CFDictionary *)sub_10000FE74(object, "query", (__CFString **)v217 + 3);
          if (v30)
          {
            v31 = v30;
            v32 = (const __CFDictionary *)sub_10000FE74(object, "attributesToUpdate", (__CFString **)v217 + 3);
            if (!v32)
              goto LABEL_462;
            v33 = v32;
            if ((!CFDictionaryGetValue(v31, kSecAttrDeriveSyncIDFromItemAttributes)
               && !CFDictionaryGetValue(v33, kSecAttrPCSPlaintextServiceIdentifier)
               && !CFDictionaryGetValue(v33, kSecAttrPCSPlaintextPublicKey)
               && !CFDictionaryGetValue(v33, kSecAttrPCSPlaintextPublicIdentity)
               || sub_1000237E0(2u, (__SecTask *)v212, CFSTR("com.apple.private.ckks.plaintextfields"), (__CFString **)v217 + 3))&& (!CFDictionaryGetValue(v33, kSecDataInetExtraNotes)&& !CFDictionaryGetValue(v33, kSecDataInetExtraHistory)&& !CFDictionaryGetValue(v33, kSecDataInetExtraClientDefined0)&& !CFDictionaryGetValue(v33, kSecDataInetExtraClientDefined1)&& !CFDictionaryGetValue(v33, kSecDataInetExtraClientDefined2)&& !CFDictionaryGetValue(v33, kSecDataInetExtraClientDefined3)|| sub_1000237E0(2u, (__SecTask *)v212, CFSTR("com.apple.private.keychain.inet_expansion_fields"), (__CFString **)v217 + 3))&& (!CFDictionaryGetValue(v31, kSecAttrSysBound)|| sub_1000237E0(2u, (__SecTask *)v212,
                    CFSTR("com.apple.private.keychain.sysbound"),
                    (__CFString **)v217 + 3)))
            {
              v34 = sub_100005B80(v31, v33, (uint64_t)&v212, (__CFString **)v217 + 3);
              xpc_dictionary_set_BOOL(reply_with_format, "status", v34);
            }
            goto LABEL_368;
          }
        }
        goto LABEL_409;
      case 3uLL:
        if (sub_10000C334(0, (__SecTask *)v212, (__CFString **)v217 + 3))
        {
          v35 = (const __CFDictionary *)sub_10000FE74(object, "query", (__CFString **)v217 + 3);
          if (v35)
          {
            Mutable = v35;
            v36 = sub_10001C730(v35, (uint64_t)&v212, (__CFString **)v217 + 3);
            goto LABEL_343;
          }
        }
        goto LABEL_409;
      case 7uLL:
        v37 = sub_10000FB48((__SecTask *)v212);
        if (!v37 || (v38 = v37, v39 = CFEqual(v37, CFSTR("com.apple.purplebuddy")), CFRelease(v38), !v39))
        {
          if (!sub_1000237E0(7u, (__SecTask *)v212, CFSTR("com.apple.private.security.delete.all"), (__CFString **)v217 + 3))goto LABEL_377;
        }
        v40 = sub_10013AA78((uint64_t)(v217 + 3));
        goto LABEL_318;
      case 9uLL:
        if (!sub_1000237E0(9u, (__SecTask *)v212, CFSTR("restore-keychain"), (__CFString **)v217 + 3))
          goto LABEL_409;
        *(_QWORD *)buf = 0;
        cf = 0;
        if (!sub_1001802B0(object, "keybag", buf, (__CFString **)v217 + 3))
          goto LABEL_409;
        if (sub_1001802B0(object, "password", &cf, (__CFString **)v217 + 3))
        {
          v41 = xpc_dictionary_get_BOOL(object, "emcsbackup");
          v31 = *(const __CFDictionary **)buf;
          v42 = cf;
          v43 = sub_10013C194((uint64_t)&v212, *(uint64_t *)buf, (uint64_t)cf, v41, (uint64_t *)v217 + 3);
          if (v43)
          {
            v44 = (const __CFData *)v43;
            v45 = sub_10018018C(object);
            if (v45 < 0)
            {
              sub_10017FF9C(reply_with_format, "status", v44, (__CFString **)v217 + 3);
            }
            else
            {
              v46 = v45;
              v198 = sub_10002B044(v45, v44);
              if (close(v46))
                v47 = 0;
              else
                v47 = v198;
              if (!v47)
              {
                v199 = (__CFString **)(v217 + 3);
                v48 = __error();
                sub_100019F20(-36, v199, CFSTR("Failed to write backup file: %d"), *v48);
              }
              xpc_dictionary_set_BOOL(reply_with_format, "status", v47);
            }
            CFRelease(v44);
          }
          if (v42)
            CFRelease(v42);
        }
        else
        {
          v31 = *(const __CFDictionary **)buf;
        }
        goto LABEL_461;
      case 0xAuLL:
        if (!sub_1000237E0(0xAu, (__SecTask *)v212, CFSTR("restore-keychain"), (__CFString **)v217 + 3))
          goto LABEL_409;
        *(_QWORD *)buf = 0;
        cf = 0;
        v49 = sub_10018018C(object);
        v50 = v49;
        if (v49 == -1)
          v51 = sub_1000048FC(object, "backup", (__CFString **)v217 + 3);
        else
          v51 = sub_10002B0B4(v49, (const UInt8 **)buf, (CFIndex *)&cf);
        v192 = v51;
        if (v51)
        {
          v193 = sub_1000048FC(object, "keybag", (__CFString **)v217 + 3);
          if (v193)
          {
            v194 = v193;
            theData = 0;
            if (sub_1001802B0(object, "password", &theData, (__CFString **)v217 + 3))
            {
              v195 = theData;
              v196 = sub_10013C770((uint64_t)v192, (uint64_t)&v212, (uint64_t)v194, (uint64_t)theData, (__CFString **)v217 + 3);
              xpc_dictionary_set_BOOL(reply_with_format, "status", v196);
              if (v195)
                CFRelease(v195);
            }
            CFRelease(v194);
          }
          CFRelease(v192);
        }
        if (v50 == -1)
          goto LABEL_449;
        v197 = v50;
        goto LABEL_448;
      case 0xBuLL:
        if (!sub_1000237E0(0xBu, (__SecTask *)v212, CFSTR("restore-keychain"), (__CFString **)v217 + 3))
          goto LABEL_409;
        *(_QWORD *)buf = 0;
        if (!sub_100180320(object, buf, (__CFString **)v217 + 3))
          goto LABEL_409;
        v52 = sub_1000048FC(object, "keybag", (__CFString **)v217 + 3);
        if (!v52)
          goto LABEL_137;
        v53 = v52;
        cf = 0;
        if (sub_1001802B0(object, "password", &cf, (__CFString **)v217 + 3))
        {
          v54 = cf;
          v55 = (const __CFString *)sub_10013CFE8(*(const void **)buf, v53, cf, (__CFString **)v217 + 3);
          if (v55)
          {
            v56 = v55;
            sub_100010098(reply_with_format, "status", v55, 0, (__CFString **)v217 + 3);
            CFRelease(v56);
          }
          if (v54)
            CFRelease(v54);
        }
        v57 = v53;
        goto LABEL_136;
      case 0xCuLL:
        if (!sub_1000237E0(0xCu, (__SecTask *)v212, CFSTR("restore-keychain"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v58 = (const __CFDictionary *)sub_10000FE74(object, "backup", (__CFString **)v217 + 3);
        if (!v58)
          goto LABEL_409;
        v31 = v58;
        v59 = sub_1000048FC(object, "keybag", (__CFString **)v217 + 3);
        if (!v59)
          goto LABEL_462;
        v60 = v59;
        *(_QWORD *)buf = 0;
        if (sub_1001802B0(object, "password", buf, (__CFString **)v217 + 3))
        {
          v61 = *(const void **)buf;
          v62 = sub_10013D83C(v31, v60, *(const void **)buf, (__CFString **)v217 + 3);
          xpc_dictionary_set_BOOL(reply_with_format, "status", v62);
          if (v61)
            CFRelease(v61);
        }
        v63 = v60;
        goto LABEL_369;
      case 0xDuLL:
        if (!sub_1000237E0(0xDu, (__SecTask *)v212, CFSTR("restore-keychain"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v64 = (const __CFString *)sub_100123608(v217 + 3);
        if (!v64)
          goto LABEL_409;
        goto LABEL_167;
      case 0xEuLL:
        if (!sub_1000237E0(0xEu, (__SecTask *)v212, CFSTR("restore-keychain"), (__CFString **)v217 + 3))
          goto LABEL_409;
        *(_QWORD *)buf = 0;
        v65 = sub_100180414(object, "cfstring", buf, (__CFString **)v217 + 3);
        Mutable = *(const __CFDictionary **)buf;
        if (!v65)
          goto LABEL_384;
        v66 = (const __CFString *)sub_1001236DC(*(uint64_t *)buf, v217 + 3);
        sub_100180044((uint64_t)reply_with_format, v66, (__CFString **)v217 + 3);
        if (!v66)
          goto LABEL_384;
        goto LABEL_382;
      case 0xFuLL:
        if (sub_1000237E0(0xFu, (__SecTask *)v212, CFSTR("restore-keychain"), (__CFString **)v217 + 3))
        {
          v67 = sub_100180388(object, "backup", (__CFString **)v217 + 3);
          if (v67)
          {
            v68 = v67;
            v69 = sub_1001231D8((uint64_t)v67, v217 + 3);
            CFRelease(v68);
            xpc_dictionary_set_fd(reply_with_format, "status", v69);
            if (v69 != -1)
              close(v69);
          }
          else
          {
            xpc_dictionary_set_fd(reply_with_format, "status", -1);
          }
        }
        goto LABEL_409;
      case 0x10uLL:
        if (!sub_1000237E0(0x10u, (__SecTask *)v212, CFSTR("restore-keychain"), (__CFString **)v217 + 3))
          goto LABEL_409;
        *(_QWORD *)buf = 0;
        if (!sub_1001802B0(object, "keybag", buf, (__CFString **)v217 + 3))
          goto LABEL_137;
        cf = 0;
        if (!sub_1001802B0(object, "data", &cf, (__CFString **)v217 + 3))
          goto LABEL_137;
        v70 = sub_100180388(object, "backup", (__CFString **)v217 + 3);
        v71 = (const __CFData *)cf;
        if (v70)
        {
          v72 = v70;
          v73 = sub_10012345C((uint64_t)v70, *(uint64_t *)buf, (uint64_t)cf, v217 + 3);
          CFRelease(v72);
          xpc_dictionary_set_BOOL(reply_with_format, "status", v73);
        }
        if (!v71)
          goto LABEL_137;
        v57 = v71;
LABEL_136:
        CFRelease(v57);
LABEL_137:
        v74 = *(const void **)buf;
        if (!*(_QWORD *)buf)
          goto LABEL_409;
        goto LABEL_408;
      case 0x11uLL:
        if (!sub_1000237E0(0x11u, (__SecTask *)v212, CFSTR("restore-keychain"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v75 = sub_100180388(object, "backup", (__CFString **)v217 + 3);
        if (!v75)
          goto LABEL_374;
        v76 = v75;
        *(_QWORD *)buf = 0;
        if (sub_100180414(object, "digest", buf, (__CFString **)v217 + 3))
        {
          v77 = sub_1000048FC(object, "keybag", (__CFString **)v217 + 3);
          if (v77)
          {
            v78 = v77;
            v200 = sub_1000048FC(object, "password", (__CFString **)v217 + 3);
            if (v200)
            {
              v79 = sub_1000048FC(object, "data", (__CFString **)v217 + 3);
              if (v79)
              {
                v80 = v79;
                v81 = sub_10012388C((int)v79, *(uint64_t *)buf, (uint64_t)v78, v200, (uint64_t)v79, v217 + 3);
                CFRelease(v80);
              }
              else
              {
                v81 = 0;
              }
              CFRelease(v200);
            }
            else
            {
              v81 = 0;
            }
            CFRelease(v78);
          }
          else
          {
            v81 = 0;
          }
          if (*(_QWORD *)buf)
            CFRelease(*(CFTypeRef *)buf);
        }
        else
        {
          v81 = 0;
        }
        goto LABEL_468;
      case 0x12uLL:
        if (!-[OTSOSActualAdapter sosEnabled]_0())
        {
          Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
          sub_100010098(reply_with_format, "status", (const __CFString *)Mutable, 0, (__CFString **)v217 + 3);
          goto LABEL_384;
        }
        v82 = (const __CFDictionary *)sub_10000FE74(object, "query", (__CFString **)v217 + 3);
        if (!v82)
          goto LABEL_409;
        Mutable = v82;
        v83 = (const __CFString *)sub_10013CD80((uint64_t)v82);
        sub_100010098(reply_with_format, "status", v83, 0, (__CFString **)v217 + 3);
LABEL_404:
        if (v83)
        {
LABEL_405:
          v29 = v83;
LABEL_406:
          CFRelease(v29);
        }
        goto LABEL_407;
      case 0x15uLL:
        *(_QWORD *)buf = 0;
        if (!sub_1001802B0(object, "publicPeerId", buf, (__CFString **)v217 + 3))
          goto LABEL_409;
        Mutable = *(const __CFDictionary **)buf;
        v84 = sub_10015451C(*(const __CFData **)buf, (uint64_t)(v217 + 3));
        if (!v84)
          goto LABEL_384;
        v66 = (const __CFString *)v84;
        sub_10017FF9C(reply_with_format, "status", v84, (__CFString **)v217 + 3);
        goto LABEL_382;
      case 0x16uLL:
        *(_QWORD *)buf = 0;
        theData = 0;
        cf = 0;
        v207 = 0;
        value = 0;
        if (!sub_1001802B0(object, "otrsess", buf, (__CFString **)v217 + 3))
          goto LABEL_409;
        v85 = sub_1001802B0(object, "data", &cf, (__CFString **)v217 + 3);
        Mutable = *(const __CFDictionary **)buf;
        if (!v85)
          goto LABEL_384;
        v66 = (const __CFString *)cf;
        v86 = sub_100154714(*(uint64_t *)buf, (uint64_t)cf, &theData, &v207, &value);
        if (v86)
        {
          v201 = theData;
          sub_10017FF9C(reply_with_format, "otrsess", theData, (__CFString **)v217 + 3);
          v87 = v207;
          sub_10017FF9C(reply_with_format, "data", v207, (__CFString **)v217 + 3);
          xpc_dictionary_set_BOOL(reply_with_format, "otrrdy", value);
          if (v201)
          {
            theData = 0;
            CFRelease(v201);
          }
          if (v87)
          {
            v207 = 0;
            CFRelease(v87);
          }
        }
        v88 = reply_with_format;
        v89 = v86;
        goto LABEL_200;
      case 0x1CuLL:
        if (!sub_1000237E0(0x1Cu, (__SecTask *)v212, CFSTR("keychain-sync-updates"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v90 = sub_10020D080((CFErrorRef *)v217 + 3);
        goto LABEL_234;
      case 0x1DuLL:
        v91 = xpc_dictionary_get_BOOL(object, "force");
        v40 = sub_10013DE3C(v91, (uint64_t)&v212, (uint64_t)(v217 + 3));
        goto LABEL_318;
      case 0x1EuLL:
        v92 = (const __CFDictionary *)sub_10000FE74(object, "query", (__CFString **)v217 + 3);
        if (!v92)
          goto LABEL_409;
        Mutable = v92;
        *(_QWORD *)buf = 0;
        if ((_QWORD)v212)
          v83 = (const __CFString *)sub_10000FB48((__SecTask *)v212);
        else
          v83 = 0;
        if (sub_10013B4B4(Mutable, (uint64_t)&v212, bytes, (uint64_t)v83, (uint64_t)v11, (uint64_t *)buf, (__CFString **)v217 + 3))
        {
          if (*(_QWORD *)buf)
          {
            sub_100010098(reply_with_format, "status", *(const __CFString **)buf, 0, (__CFString **)v217 + 3);
            v182 = *(const void **)buf;
            if (*(_QWORD *)buf)
            {
              *(_QWORD *)buf = 0;
              CFRelease(v182);
            }
          }
        }
        goto LABEL_404;
      case 0x1FuLL:
        v64 = (const __CFString *)sub_100147154();
        if (!v64)
          goto LABEL_409;
LABEL_167:
        Mutable = (const __CFDictionary *)v64;
        sub_100010098(reply_with_format, "status", v64, 0, (__CFString **)v217 + 3);
        goto LABEL_407;
      case 0x20uLL:
        v93 = (const __CFString *)sub_10000FF08(object, "query", (__CFString **)v217 + 3);
        if (!v93)
          goto LABEL_300;
        Mutable = (const __CFDictionary *)v93;
        sub_10014720C(v93, (__CFString **)v217 + 3);
        goto LABEL_172;
      case 0x21uLL:
        v94 = (const __CFDictionary *)sub_10000FF08(object, "query", (__CFString **)v217 + 3);
        if (!v94)
          goto LABEL_300;
        Mutable = v94;
        sub_1001472A4((uint64_t)v94, (uint64_t)(v217 + 3));
LABEL_172:
        v95 = reply_with_format;
        v96 = 1;
        goto LABEL_345;
      case 0x22uLL:
        if (!sub_1000237E0(0x22u, (__SecTask *)v212, CFSTR("keychain-sync-updates"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v40 = sub_10020C1F4(v217 + 3);
        goto LABEL_318;
      case 0x23uLL:
      case 0x24uLL:
      case 0x25uLL:
      case 0x27uLL:
      case 0x28uLL:
      case 0x29uLL:
      case 0x2AuLL:
      case 0x2BuLL:
        v17 = "error";
        v18 = reply_with_format;
        v19 = -4;
        goto LABEL_34;
      case 0x2CuLL:
        if (!sub_1000237E0(0x2Cu, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v205[0] = _NSConcreteStackBlock;
        v205[1] = 0x40000000;
        v205[2] = sub_10002B15C;
        v205[3] = &unk_1002DABE8;
        v205[4] = &v216;
        v205[5] = reply_with_format;
        v97 = v205;
        goto LABEL_181;
      case 0x2DuLL:
        if (sub_1000237E0(0x2Du, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
        {
          v204[0] = _NSConcreteStackBlock;
          v204[1] = 0x40000000;
          v204[2] = sub_10002B250;
          v204[3] = &unk_1002DAC10;
          v204[4] = &v216;
          v204[5] = reply_with_format;
          sub_10002B294(object, (uint64_t)v204);
        }
        goto LABEL_409;
      case 0x2EuLL:
        if (!sub_1000237E0(0x2Eu, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v203[0] = _NSConcreteStackBlock;
        v203[1] = 0x40000000;
        v203[2] = sub_10002B320;
        v203[3] = &unk_1002DAC38;
        v203[4] = &v216;
        v203[5] = reply_with_format;
        v97 = v203;
LABEL_181:
        sub_10002B1A4(object, (uint64_t)v97);
        goto LABEL_409;
      case 0x2FuLL:
        if (!sub_1000237E0(0x2Fu, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v40 = sub_1002054CC(v217 + 3);
        goto LABEL_318;
      case 0x30uLL:
        if (!sub_1000237E0(0x30u, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v98 = v217 + 3;
        v99 = &stru_1002ECEC0;
        goto LABEL_250;
      case 0x31uLL:
        if (!sub_1000237E0(0x31u, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v19 = (int)sub_1002057F4(v217 + 3);
        goto LABEL_235;
      case 0x32uLL:
        if (!sub_1000237E0(0x32u, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v40 = sub_100205928(v217 + 3);
        goto LABEL_318;
      case 0x33uLL:
        if (!sub_1000237E0(0x33u, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v40 = sub_10020686C(v217 + 3);
        goto LABEL_318;
      case 0x34uLL:
        if (!sub_1000237E0(0x34u, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v40 = sub_100207024(v217 + 3);
        goto LABEL_318;
      case 0x35uLL:
        if (!sub_1000237E0(0x35u, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v40 = sub_100207614(v217 + 3);
        goto LABEL_318;
      case 0x36uLL:
        if (sub_1000237E0(0x36u, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
        {
          v202[0] = _NSConcreteStackBlock;
          v202[1] = 0x40000000;
          v202[2] = sub_10002B368;
          v202[3] = &unk_1002DAC60;
          v202[4] = &v216;
          v202[5] = reply_with_format;
          sub_10002B3AC(object, (uint64_t)v202);
        }
        goto LABEL_409;
      case 0x37uLL:
        if (!sub_1000237E0(0x37u, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v66 = (const __CFString *)sub_10002B420(object, "enabledViews");
        Mutable = (const __CFDictionary *)sub_10002B420(object, "disabledViews");
        v89 = sub_100202FB8((uint64_t)v66, (uint64_t)Mutable);
        v88 = reply_with_format;
LABEL_200:
        xpc_dictionary_set_BOOL(v88, "status", v89);
        if (!v66)
          goto LABEL_384;
        goto LABEL_382;
      case 0x38uLL:
        if (!sub_1000237E0(0x38u, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v40 = sub_100207B48(v217 + 3);
        goto LABEL_318;
      case 0x39uLL:
        if (!sub_1000237E0(0x39u, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v100 = v217 + 3;
        v101 = xpc_dictionary_get_value(object, "peer-infos");
        Mutable = (const __CFDictionary *)CreateArrayOfPeerInfoWithXPCObject(v101, v100);
        v102 = sub_100207DF8((uint64_t)Mutable, v217 + 3);
        v103 = reply_with_format;
        goto LABEL_379;
      case 0x3AuLL:
        if (!sub_1000237E0(0x3Au, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        sub_1002080A4();
        goto LABEL_300;
      case 0x3BuLL:
        if (!sub_1000237E0(0x3Bu, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v40 = sub_100208254(v217 + 3);
        goto LABEL_318;
      case 0x3DuLL:
        if (!sub_1000237E0(0x3Du, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v104 = xpc_dictionary_get_value(object, "peer-infos");
        ArrayOfPeerInfoWithXPCObject = CreateArrayOfPeerInfoWithXPCObject(v104, v217 + 3);
        if (!ArrayOfPeerInfoWithXPCObject)
          goto LABEL_358;
        Mutable = (const __CFDictionary *)ArrayOfPeerInfoWithXPCObject;
        v36 = sub_10020A680(ArrayOfPeerInfoWithXPCObject, v217 + 3);
        goto LABEL_343;
      case 0x3EuLL:
        if (!sub_1000237E0(0x3Eu, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v106 = xpc_dictionary_get_value(object, "peer-infos");
        v107 = CreateArrayOfPeerInfoWithXPCObject(v106, v217 + 3);
        if (!v107)
          goto LABEL_358;
        Mutable = (const __CFDictionary *)v107;
        v36 = sub_10020A9DC(v107, v217 + 3);
        goto LABEL_343;
      case 0x3FuLL:
        if (!sub_1000237E0(0x3Fu, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v108 = (const void *)sub_1002087EC(v217 + 3);
        goto LABEL_240;
      case 0x40uLL:
        if (!sub_1000237E0(0x40u, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v108 = (const void *)sub_100208CC0(v217 + 3);
        goto LABEL_240;
      case 0x41uLL:
        if (!sub_1000237E0(0x41u, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v40 = sub_10020908C(v217 + 3);
        goto LABEL_318;
      case 0x42uLL:
        if (!sub_1000237E0(0x42u, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v108 = (const void *)sub_1002093D4(v217 + 3);
        goto LABEL_240;
      case 0x43uLL:
        if (!sub_1000237E0(0x43u, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v108 = (const void *)sub_10020AD3C(v217 + 3);
        goto LABEL_240;
      case 0x44uLL:
        if (!sub_1000237E0(0x44u, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v108 = (const void *)sub_10020AE48(v217 + 3);
        goto LABEL_240;
      case 0x45uLL:
        if (sub_1000237E0(0x45u, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
        {
          v109 = (const void *)sub_100208B34(v217 + 3);
          sub_10002B578(reply_with_format, v109);
        }
        goto LABEL_409;
      case 0x46uLL:
        if (!sub_1000237E0(0x46u, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v90 = sub_10020C034(v217 + 3);
        goto LABEL_234;
      case 0x47uLL:
        if (!sub_1000237E0(0x47u, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        int64 = xpc_dictionary_get_int64(object, "reason");
        *(_QWORD *)buf = _NSConcreteStackBlock;
        *(_QWORD *)&buf[8] = 3221225472;
        *(_QWORD *)&buf[16] = sub_10020C19C;
        *(_QWORD *)&buf[24] = &unk_1002ECD88;
        v221 = int64;
        v90 = sub_100202B4C(v217 + 3, buf);
LABEL_234:
        v19 = v90;
LABEL_235:
        v17 = "status";
        v18 = reply_with_format;
LABEL_34:
        xpc_dictionary_set_int64(v18, v17, v19);
        goto LABEL_409;
      case 0x48uLL:
        if (!sub_1000237E0(0x48u, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v108 = (const void *)sub_10020952C(v217 + 3);
        goto LABEL_240;
      case 0x49uLL:
        if (!sub_1000237E0(0x49u, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v108 = (const void *)sub_100209638(v217 + 3);
LABEL_240:
        sub_10002B514(reply_with_format, v108, (uint64_t)(v217 + 3));
        goto LABEL_409;
      case 0x4AuLL:
        if (!sub_1000237E0(0x4Au, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v111 = (const __CFString *)sub_1002099CC(v217 + 3);
        if (!v111)
          goto LABEL_409;
        Mutable = (const __CFDictionary *)v111;
        v115 = sub_10001A474(v111, v217 + 3, v112, v113, v114);
        if (!v115)
          goto LABEL_407;
        v83 = (const __CFString *)v115;
        BytePtr = CFDataGetBytePtr(v115);
        Length = CFDataGetLength((CFDataRef)v83);
        xpc_dictionary_set_data(reply_with_format, "status", BytePtr, Length);
        goto LABEL_405;
      case 0x4BuLL:
        if (!sub_1000237E0(0x4Bu, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v118 = sub_10020B2AC(v217 + 3);
        if (!v118)
          goto LABEL_409;
        goto LABEL_263;
      case 0x4CuLL:
        if (!sub_1000237E0(0x4Cu, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v98 = v217 + 3;
        v99 = &stru_1002ECF30;
LABEL_250:
        v40 = sub_100202B4C(v98, v99);
        goto LABEL_318;
      case 0x4DuLL:
        if (!sub_1000237E0(0x4Du, (__SecTask *)v212, CFSTR("restore-keychain"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v119 = sub_1000048FC(object, "newPublicBackupKey", (__CFString **)v217 + 3);
        if (!v119)
          goto LABEL_409;
        Mutable = v119;
        v120 = sub_10020B604((uint64_t)v119, v217 + 3);
        if (!v120)
          goto LABEL_407;
        v121 = (const void *)v120;
        v83 = (const __CFString *)SOSPeerInfoCopyEncodedData(v120, kCFAllocatorDefault, v217 + 3);
        CFRelease(v121);
        if (!v83)
          goto LABEL_407;
        v122 = (void *)_CFXPCCreateXPCObjectFromCFObject(v83);
        xpc_dictionary_set_value(reply_with_format, "status", v122);
        xpc_release(v122);
        goto LABEL_405;
      case 0x4EuLL:
        if (!sub_1000237E0(0x4Eu, (__SecTask *)v212, CFSTR("restore-keychain"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v31 = sub_1000048FC(object, "keybag", (__CFString **)v217 + 3);
        v123 = xpc_dictionary_get_BOOL(object, "includeV0");
        if (!v31)
          goto LABEL_358;
        v124 = sub_10020BAF0((uint64_t)v31, v123, v217 + 3);
        goto LABEL_273;
      case 0x4FuLL:
        if (!sub_1000237E0(0x4Fu, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v40 = sub_100209A6C(v217 + 3);
        goto LABEL_318;
      case 0x51uLL:
        if (!sub_1000237E0(0x51u, (__SecTask *)v212, CFSTR("com.apple.private.keychain.circle.join"), (__CFString **)v217 + 3))goto LABEL_409;
        v118 = sub_10020DA64(v217 + 3);
        if (!v118)
          goto LABEL_409;
LABEL_263:
        v125 = (const void *)v118;
        Mutable = (const __CFDictionary *)SOSPeerInfoCopyEncodedData(v118, kCFAllocatorDefault, v217 + 3);
        CFRelease(v125);
        if (!Mutable)
          goto LABEL_409;
        goto LABEL_291;
      case 0x52uLL:
        if (!sub_1000237E0(0x52u, (__SecTask *)v212, CFSTR("com.apple.private.keychain.circle.join"), (__CFString **)v217 + 3))goto LABEL_409;
        v126 = sub_10002B5D4(object, (uint64_t)(v217 + 3));
        if (!v126)
          goto LABEL_409;
        Mutable = v126;
        v127 = SOSPeerInfoCreateFromData(kCFAllocatorDefault, v217 + 3, v126);
        if (!v127)
          goto LABEL_407;
        v83 = (const __CFString *)v127;
        v128 = sub_10020DE28(v127, v217 + 3);
        if (v128)
        {
          v129 = (const void *)v128;
          v130 = (void *)_CFXPCCreateXPCObjectFromCFObject(v128);
          xpc_dictionary_set_value(reply_with_format, "status", v130);
          xpc_release(v130);
          CFRelease(v129);
        }
        goto LABEL_405;
      case 0x53uLL:
        if (!sub_1000237E0(0x53u, (__SecTask *)v212, CFSTR("com.apple.private.keychain.circle.join"), (__CFString **)v217 + 3))goto LABEL_409;
        v31 = sub_10002B5D4(object, (uint64_t)(v217 + 3));
        v131 = xpc_dictionary_get_uint64(object, "version");
        if (!v31)
          goto LABEL_409;
        v124 = sub_10020F170((uint64_t)v31, v131, v217 + 3);
LABEL_273:
        xpc_dictionary_set_BOOL(reply_with_format, "status", v124);
        goto LABEL_462;
      case 0x54uLL:
        if (!sub_1000237E0(0x54u, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v40 = sub_10020DDA4(v217 + 3);
        goto LABEL_318;
      case 0x55uLL:
        if (!sub_1000237E0(0x55u, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v40 = sub_10020672C(v217 + 3);
        goto LABEL_318;
      case 0x57uLL:
        if (!sub_1000237E0(0x57u, (__SecTask *)v212, CFSTR("restore-keychain"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v132 = sub_1000048FC(object, "RecoveryPublicKey", (__CFString **)v217 + 3);
        if (!v132)
          goto LABEL_409;
        Mutable = v132;
        buf[0] = 0;
        v133 = CFDataCreate(kCFAllocatorDefault, buf, 1);
        if (CFEqual(Mutable, v133))
        {
          CFRelease(Mutable);
          Mutable = 0;
        }
        if (v133)
          CFRelease(v133);
        v134 = sub_10020FB80((uint64_t)Mutable, v217 + 3);
        xpc_dictionary_set_BOOL(reply_with_format, "status", v134);
        goto LABEL_384;
      case 0x58uLL:
        if (!sub_1000237E0(0x58u, (__SecTask *)v212, CFSTR("restore-keychain"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v135 = SOSCCCopyRecoveryPublicKey(v217 + 3);
        if (!v135)
          goto LABEL_409;
        goto LABEL_290;
      case 0x59uLL:
        if (!sub_1000237E0(0x59u, (__SecTask *)v212, CFSTR("com.apple.private.keychain.circle.join"), (__CFString **)v217 + 3))goto LABEL_409;
        v136 = xpc_dictionary_get_uint64(object, "flags");
        v135 = sub_10020E180(v136, v217 + 3);
        if (!v135)
          goto LABEL_409;
LABEL_290:
        Mutable = (const __CFDictionary *)v135;
LABEL_291:
        v137 = (void *)_CFXPCCreateXPCObjectFromCFObject(Mutable);
        xpc_dictionary_set_value(reply_with_format, "status", v137);
        xpc_release(v137);
        goto LABEL_407;
      case 0x5AuLL:
        v138 = xpc_dictionary_get_BOOL(object, "sosCompatibilityMode");
        v40 = sub_100210E20(v138, v217 + 3);
        goto LABEL_318;
      case 0x5BuLL:
        v40 = sub_10021172C(v217 + 3);
        goto LABEL_318;
      case 0x5CuLL:
        v40 = sub_100211664();
        goto LABEL_318;
      case 0x5DuLL:
        if (!sub_1000237E0(0x5Du, (__SecTask *)v212, CFSTR("keychain-cloud-circle"), (__CFString **)v217 + 3))
          goto LABEL_409;
        sub_100211D8C(v217 + 3);
        goto LABEL_300;
      case 0x5EuLL:
        if (*((_QWORD *)&v213 + 1))
        {
          v139 = CFDataGetBytePtr(*((CFDataRef *)&v213 + 1));
          v140 = CFDataGetLength(*((CFDataRef *)&v213 + 1));
          xpc_dictionary_set_data(reply_with_format, "musr", v139, v140);
        }
        xpc_dictionary_set_BOOL(reply_with_format, "system-keychain", v213);
        xpc_dictionary_set_BOOL(reply_with_format, "syncbubble-keychain", SBYTE1(v213));
        xpc_dictionary_set_BOOL(reply_with_format, "network-extension", SBYTE2(v213));
        goto LABEL_300;
      case 0x5FuLL:
        if (!sub_1000237E0(0x5Fu, (__SecTask *)v212, CFSTR("com.apple.private.syncbubble-keychain"), (__CFString **)v217 + 3))goto LABEL_409;
        v143 = xpc_dictionary_get_int64(object, "uid");
        v144 = (const __CFArray *)sub_100004804(object, "services", (__CFString **)v217 + 3);
        Mutable = v144;
        if (v143 && v144)
        {
          v36 = sub_10013E874(v144, v143, (uint64_t)&v212, (__CFString **)v217 + 3);
LABEL_343:
          v96 = v36;
LABEL_344:
          v95 = reply_with_format;
LABEL_345:
          xpc_dictionary_set_BOOL(v95, "status", v96);
          goto LABEL_407;
        }
        v103 = reply_with_format;
        v102 = 0;
LABEL_379:
        xpc_dictionary_set_BOOL(v103, "status", v102);
        if (Mutable)
          goto LABEL_407;
        goto LABEL_409;
      case 0x60uLL:
        if (!sub_1000237E0(0x60u, (__SecTask *)v212, CFSTR("com.apple.private.migrate-musr-system-keychain"), (__CFString **)v217 + 3))goto LABEL_409;
        v40 = sub_10013F4A8((uint64_t)&v212, (uint64_t)(v217 + 3));
        goto LABEL_318;
      case 0x61uLL:
        if (!sub_1000237E0(0x61u, (__SecTask *)v212, CFSTR("com.apple.private.migrate-musr-system-keychain"), (__CFString **)v217 + 3))goto LABEL_409;
        v40 = sub_10013FD80((uint64_t)&v212, (uint64_t)(v217 + 3));
        goto LABEL_318;
      case 0x62uLL:
        if (!sub_10000C334(0x62u, (__SecTask *)v212, (__CFString **)v217 + 3)
          || !sub_1000237E0(0x62u, (__SecTask *)v212, CFSTR("com.apple.private.keychain.allow-update-tokens"), (__CFString **)v217 + 3))
        {
          goto LABEL_409;
        }
        v145 = sub_100180388(object, "cfstring", (__CFString **)v217 + 3);
        v146 = (const __CFString *)sub_100004804(object, "cfarray", (__CFString **)v217 + 3);
        Mutable = (const __CFDictionary *)sub_100004804(object, "query", (__CFString **)v217 + 3);
        if (v145)
        {
          v147 = sub_10013A6C0((uint64_t)v145, (uint64_t)v146, (uint64_t)Mutable, (uint64_t)&v212, (__CFString **)v217 + 3);
          xpc_dictionary_set_BOOL(reply_with_format, "status", v147);
          CFRelease(v145);
        }
        if (!v146)
          goto LABEL_384;
        v148 = v146;
        goto LABEL_383;
      case 0x63uLL:
        if (!sub_1000237E0(0x63u, (__SecTask *)v212, CFSTR("com.apple.private.migrate-musr-system-keychain"), (__CFString **)v217 + 3))goto LABEL_409;
        v149 = xpc_dictionary_get_int64(object, "uid");
        if (v149)
        {
          v40 = sub_10013FF7C(v149, (uint64_t)(v217 + 3));
LABEL_318:
          v142 = v40;
        }
        else
        {
LABEL_377:
          v142 = 0;
        }
        v141 = reply_with_format;
        goto LABEL_320;
      case 0x67uLL:
        if (sub_1000237E0(0x67u, (__SecTask *)v212, CFSTR("com.apple.private.uninstall.deletion"), (__CFString **)v217 + 3)&& (v150 = (const __CFString *)sub_100004804(object, "accessGroups", (__CFString **)v217 + 3)) != 0)
        {
          v76 = v150;
          v81 = sub_10013AFB8(v150, (uint64_t)&v212, v217 + 3);
LABEL_468:
          CFRelease(v76);
        }
        else
        {
LABEL_374:
          v81 = 0;
        }
        v141 = reply_with_format;
        v142 = v81;
        goto LABEL_320;
      case 0x68uLL:
        if (!sub_1000237E0(0x68u, (__SecTask *)v212, CFSTR("restore-keychain"), (__CFString **)v217 + 3))
          goto LABEL_409;
        *(_QWORD *)buf = 0;
        cf = 0;
        v151 = sub_10018018C(object);
        if (v151 == -1)
          goto LABEL_409;
        v152 = v151;
        v153 = sub_10002B0B4(v151, (const UInt8 **)buf, (CFIndex *)&cf);
        if (v153)
        {
          v154 = v153;
          v31 = (const __CFDictionary *)sub_10013CCA4(v153, (CFErrorRef *)v217 + 3);
          if (v31)
            sub_100180044((uint64_t)reply_with_format, (const __CFString *)v31, (__CFString **)v217 + 3);
          CFRelease(v154);
          close(v152);
          if (*(_QWORD *)buf)
            munmap(*(void **)buf, (size_t)cf);
LABEL_461:
          if (v31)
          {
LABEL_462:
            v74 = v31;
            goto LABEL_408;
          }
        }
        else
        {
          v197 = v152;
LABEL_448:
          close(v197);
LABEL_449:
          if (*(_QWORD *)buf)
            munmap(*(void **)buf, (size_t)cf);
        }
        goto LABEL_409;
      case 0x69uLL:
        v155 = (const __CFDictionary *)sub_100004804(object, "cfarray", (__CFString **)v217 + 3);
        if (!v155)
          goto LABEL_409;
        Mutable = v155;
        v156 = (CFBooleanRef)sub_10020F704((uint64_t)v155, v217 + 3);
        if (!v156)
          goto LABEL_407;
        v96 = v156 != kCFBooleanFalse;
        goto LABEL_344;
      case 0x6AuLL:
        if (!sub_1000237E0(0x6Au, (__SecTask *)v212, CFSTR("keychain-sync-updates"), (__CFString **)v217 + 3))
          goto LABEL_409;
        v66 = (const __CFString *)sub_1001801E0(object, "cfset", (__CFString **)v217 + 3);
        v157 = (const __CFDictionary *)sub_1001801E0(object, "cfset2", (__CFString **)v217 + 3);
        Mutable = v157;
        if (v66 && v157)
        {
          v158 = (const __CFString *)sub_10020C4D0((uint64_t)v66, (uint64_t)v157, (uint64_t)(v217 + 3));
          if (v158)
          {
            v159 = v158;
            sub_100010098(reply_with_format, "status", v158, 0, (__CFString **)v217 + 3);
            CFRelease(v159);
          }
        }
        else if (!v66)
        {
          goto LABEL_384;
        }
LABEL_382:
        v148 = v66;
LABEL_383:
        CFRelease(v148);
LABEL_384:
        if (!Mutable)
          goto LABEL_409;
LABEL_407:
        v74 = Mutable;
        goto LABEL_408;
      case 0x6BuLL:
        v160 = sub_10002B650(object, v217 + 3);
        if (!v160)
          goto LABEL_409;
        Mutable = (const __CFDictionary *)v160;
        v36 = sub_1002107F0(v160, v217 + 3);
        goto LABEL_343;
      case 0x6CuLL:
        v161 = sub_10002B650(object, v217 + 3);
        if (!v161)
          goto LABEL_409;
        Mutable = (const __CFDictionary *)v161;
        v36 = sub_100210B3C(v161, v217 + 3);
        goto LABEL_343;
      case 0x6DuLL:
        if (!sub_1000237E0(0x6Du, (__SecTask *)v212, CFSTR("com.apple.private.keychain.certificates"), (__CFString **)v217 + 3))goto LABEL_409;
        v162 = sub_1000048FC(object, "normIssuer", (__CFString **)v217 + 3);
        v163 = sub_100004804(object, "accessGroups", (__CFString **)v217 + 3);
        v164 = v163;
        if (v162 && v163)
        {
          v165 = sub_1000046C4(v162, (uint64_t)v163, (__CFString **)v217 + 3);
        }
        else
        {
          v165 = 0;
          v181 = 0;
          if (!v162)
            goto LABEL_388;
        }
        CFRelease(v162);
        v181 = (const __CFString *)v165;
LABEL_388:
        if (v164)
          CFRelease(v164);
        if (v181)
        {
          sub_100010098(reply_with_format, "status", v181, 0, (__CFString **)v217 + 3);
          v74 = v181;
LABEL_408:
          CFRelease(v74);
        }
        goto LABEL_409;
      case 0x6EuLL:
        if (!sub_1000237E0(0x6Eu, (__SecTask *)v212, CFSTR("com.apple.private.keychain.certificates"), (__CFString **)v217 + 3))
        {
          v180 = 0;
          goto LABEL_398;
        }
        v166 = sub_1000048FC(object, "normIssuer", (__CFString **)v217 + 3);
        v167 = sub_1000048FC(object, "serialNum", (__CFString **)v217 + 3);
        v168 = sub_100004804(object, "accessGroups", (__CFString **)v217 + 3);
        v169 = v168;
        if (v166 && v167 && v168)
        {
          v170 = sub_100140114(v166, v167, (uint64_t)v168, (__CFString **)v217 + 3);
        }
        else
        {
          v170 = 0;
          v180 = 0;
          if (!v166)
            goto LABEL_394;
        }
        v180 = v170;
        CFRelease(v166);
LABEL_394:
        if (v167)
          CFRelease(v167);
        if (v169)
          CFRelease(v169);
LABEL_398:
        v141 = reply_with_format;
        v142 = v180;
        goto LABEL_320;
      case 0x6FuLL:
        v171 = (__SecTask *)v212;
        v172 = (__CFString **)(v217 + 3);
        v173 = 111;
        goto LABEL_357;
      case 0x70uLL:
        v171 = (__SecTask *)v212;
        v172 = (__CFString **)(v217 + 3);
        v173 = 112;
LABEL_357:
        if (sub_1000237E0(v173, v171, CFSTR("com.apple.private.keychain.backuptableops"), v172))
          goto LABEL_358;
        goto LABEL_409;
      case 0x72uLL:
        if (!sub_1000237E0(0x72u, (__SecTask *)v212, CFSTR("com.apple.private.keychain.keychaincontrol"), (__CFString **)v217 + 3))goto LABEL_409;
        v174 = (void *)sub_10007840C();
        if (v174)
        {
          v175 = v174;
          xpc_dictionary_set_value(reply_with_format, "endpoint", v174);
          xpc_dictionary_set_BOOL(reply_with_format, "status", 1);
          xpc_release(v175);
        }
        else
        {
LABEL_358:
          v141 = reply_with_format;
          v142 = 0;
LABEL_320:
          xpc_dictionary_set_BOOL(v141, "status", v142);
        }
LABEL_409:
        v183 = v217[3];
        if (!v183)
        {
          v8 = 0;
          goto LABEL_5;
        }
        if (SecErrorGetOSStatus(v183) == -25300)
          goto LABEL_431;
        v184 = (__CFError *)v217[3];
        if (!v184 || CFErrorGetCode((CFErrorRef)v217[3]) != 2)
          goto LABEL_419;
        Domain = CFErrorGetDomain(v184);
        if (Domain && kSOSErrorDomain)
        {
          if (CFEqual(Domain, kSOSErrorDomain))
            goto LABEL_431;
        }
        else if (Domain == (CFErrorDomain)kSOSErrorDomain)
        {
          goto LABEL_431;
        }
LABEL_419:
        if (SecErrorGetOSStatus(v217[3]) == -25330)
        {
          v186 = sub_10000EF14("SecWarning");
          if (!os_log_type_enabled(v186, OS_LOG_TYPE_DEFAULT))
            goto LABEL_431;
          if (uint64 > 0x87)
            v187 = CFSTR("Unknown xpc operation");
          else
            v187 = off_1002E9940[uint64];
          v189 = v217[3];
          *(_DWORD *)buf = 138412802;
          *(_QWORD *)&buf[4] = v212;
          *(_WORD *)&buf[12] = 2112;
          *(_QWORD *)&buf[14] = v187;
          *(_WORD *)&buf[22] = 2112;
          *(_QWORD *)&buf[24] = v189;
          v190 = "Authentication is needed %@ %@ %@";
        }
        else
        {
          v186 = sub_10000EF14("SecError");
          if (!os_log_type_enabled(v186, OS_LOG_TYPE_DEFAULT))
            goto LABEL_431;
          if (uint64 > 0x87)
            v188 = CFSTR("Unknown xpc operation");
          else
            v188 = off_1002E9940[uint64];
          v191 = v217[3];
          *(_DWORD *)buf = 138412802;
          *(_QWORD *)&buf[4] = v212;
          *(_WORD *)&buf[12] = 2112;
          *(_QWORD *)&buf[14] = v188;
          *(_WORD *)&buf[22] = 2112;
          *(_QWORD *)&buf[24] = v191;
          v190 = "%@ %@ %@";
        }
        _os_log_impl((void *)&_mh_execute_header, v186, OS_LOG_TYPE_DEFAULT, v190, buf, 0x20u);
LABEL_431:
        v8 = sub_100010350((__CFError *)v217[3]);
        if (!reply_with_format)
          goto LABEL_5;
        xpc_dictionary_set_value(reply_with_format, "error", v8);
        break;
      case 0x83uLL:
        if (!sub_10000C334(0x83u, (__SecTask *)v212, (__CFString **)v217 + 3))
          goto LABEL_409;
        if (!BYTE9(v215))
          goto LABEL_409;
        v176 = (const __CFDictionary *)sub_10000FE74(object, "query", (__CFString **)v217 + 3);
        if (!v176)
          goto LABEL_409;
        v31 = v176;
        v177 = sub_100180388(object, "sharingGroup", (__CFString **)v217 + 3);
        if (v177)
        {
          v33 = (const __CFDictionary *)v177;
          v178 = (const __CFString *)sub_100139630(v31, v177, (uint64_t)&v212, (__CFString **)v217 + 3);
          if (v178)
          {
            v179 = v178;
            sub_100010098(reply_with_format, "status", v178, 0, (__CFString **)v217 + 3);
            CFRelease(v179);
          }
LABEL_368:
          v63 = v33;
LABEL_369:
          CFRelease(v63);
        }
        goto LABEL_462;
      case 0x84uLL:
        if (!sub_10000C334(0x84u, (__SecTask *)v212, (__CFString **)v217 + 3)
          || !sub_1000237E0(0x84u, (__SecTask *)v212, CFSTR("com.apple.private.keychain.allow-delete-on-sign-out"), (__CFString **)v217 + 3)|| !sub_10013A164((uint64_t)&v212, (uint64_t)(v217 + 3)))
        {
          goto LABEL_409;
        }
LABEL_300:
        v141 = reply_with_format;
        v142 = 1;
        goto LABEL_320;
      default:
        goto LABEL_409;
    }
LABEL_6:
    xpc_connection_send_message(a1, reply_with_format);
    xpc_release(reply_with_format);
LABEL_7:
    if (v8)
      xpc_release(v8);
    v12 = v217[3];
    if (v12)
      CFRelease(v12);
    if (*((_QWORD *)&v212 + 1))
      CFRelease(*((CFTypeRef *)&v212 + 1));
    if (*((_QWORD *)&v213 + 1))
      CFRelease(*((CFTypeRef *)&v213 + 1));
    if ((_QWORD)v212)
      CFRelease((CFTypeRef)v212);
    v13 = (const void *)v215;
    if ((_QWORD)v215)
    {
      *(_QWORD *)&v215 = 0;
      CFRelease(v13);
    }
    if (v11)
      CFRelease(v11);
    if (v10)
      CFRelease(v10);
    goto LABEL_29;
  }
  if (v10)
    CFRelease(v10);
  xpc_connection_send_message(a1, reply_with_format);
  xpc_release(reply_with_format);
LABEL_29:
  _Block_object_dispose(&v216, 8);
}

const void *sub_10000EF14(const char *a1)
{
  const __CFString *v2;
  const void *v3;

  pthread_mutex_lock(&stru_10033F040);
  pthread_mutex_unlock(&stru_10033F040);
  if (!a1)
    return sub_10000EF90(0);
  v2 = CFStringCreateWithCString(kCFAllocatorDefault, a1, 0x600u);
  v3 = sub_10000EF90(v2);
  if (v2)
    CFRelease(v2);
  return v3;
}

const void *sub_10000EF90(const __CFString *a1)
{
  const __CFString *v1;
  const __CFDictionary *Mutable;
  const void *Value;
  _QWORD v5[5];
  _QWORD v6[5];

  if (a1)
    v1 = a1;
  else
    v1 = CFSTR("logging");
  os_unfair_lock_lock_with_options(&unk_100340D20, 0x10000);
  Mutable = (const __CFDictionary *)qword_100340D28;
  if (!qword_100340D28)
  {
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, 0);
    qword_100340D28 = (uint64_t)Mutable;
  }
  Value = CFDictionaryGetValue(Mutable, v1);
  if (!Value)
  {
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 0x40000000;
    v5[2] = sub_10002FC1C;
    v5[3] = &unk_1002DB038;
    v5[4] = v1;
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000;
    v6[2] = sub_1000104A0;
    v6[3] = &unk_1002DB170;
    v6[4] = v5;
    sub_1000137F8(v1, (uint64_t)v6);
    Value = CFDictionaryGetValue((CFDictionaryRef)qword_100340D28, v1);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_100340D20);
  return Value;
}

uint64_t sub_10000F094(uint64_t a1, int a2, _OWORD *a3)
{
  uint64_t v3;
  void *v6;
  int v7;
  unsigned int v8;
  const void *v9;
  NSObject *v10;
  _BOOL4 v11;
  unsigned int v12;
  unsigned int v13;
  __int128 v14;
  __SecTask *v15;
  _BOOL4 v16;
  const __CFArray *v17;
  const __CFArray *v18;
  const void *v19;
  const __CFArray *v20;
  __CFArray *Mutable;
  NSObject *v22;
  CFIndex FirstIndexOfValue;
  CFIndex v24;
  _BOOL4 v25;
  const void *v26;
  NSObject *v27;
  const __CFArray *v28;
  __CFArray *v29;
  uint64_t v30;
  __SecTask *v31;
  uint64_t CodeSignStatus;
  uint64_t v33;
  int v34;
  CFStringRef v35;
  CFStringRef v36;
  audit_token_t *v37;
  const void *v38;
  NSObject *v39;
  NSObject *v40;
  const void *v41;
  NSObject *v42;
  const char *v43;
  NSObject *v44;
  uint32_t v45;
  const void *v46;
  const void *v47;
  __SecTask *v48;
  const void *v49;
  const void *v50;
  const void *v51;
  const void *v52;
  NSObject *v53;
  const void *v54;
  NSObject *v55;
  const void *v56;
  BOOL v57;
  int v59;
  CFStringRef v60;
  audit_token_t bytes;
  __int128 *p_buf;
  CFStringRef v63;
  __int128 buf;
  uint64_t v65;
  char v66;
  CFRange v67;
  CFRange v68;
  CFRange v69;
  CFRange v70;
  CFRange v71;
  CFRange v72;

  v3 = a1;
  if (a1)
  {
    v6 = objc_autoreleasePoolPush();
    *(_DWORD *)(v3 + 20) = a2;
    *(_QWORD *)(v3 + 24) = 0;
    if (qword_100340CF8 != -1)
      dispatch_once(&qword_100340CF8, &stru_1002DAD80);
    if (byte_100340D00 == 1)
    {
      *(_QWORD *)&buf = 0;
      *(_BYTE *)(v3 + 36) = byte_100340D00;
      v7 = MKBForegroundUserSessionID(&buf);
      *(_DWORD *)(v3 + 40) = v7;
      if ((v7 + 1) <= 1)
      {
        sub_10003429C(CFSTR("Execution has encountered an unexpected state"), 0x53C0000Eu);
        v7 = 0;
        *(_DWORD *)(v3 + 40) = 0;
      }
      v8 = *(_DWORD *)(v3 + 20);
      v9 = sub_10000EF14("serverxpc");
      v10 = objc_claimAutoreleasedReturnValue(v9);
      v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG);
      if (v8 < 0x1F6 || v7 == v8)
      {
        if (v11)
        {
          LOWORD(bytes.val[0]) = 0;
          _os_log_debug_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "securityd client: active user", (uint8_t *)&bytes, 2u);
        }

        v13 = *(_DWORD *)(v3 + 40);
        *(_QWORD *)bytes.val = 0x104B57A5353A5AA7;
        bytes.val[2] = -1803342146;
        bytes.val[3] = bswap32(v13);
        *(_QWORD *)(v3 + 24) = CFDataCreate(0, (const UInt8 *)&bytes, 16);
        *(_DWORD *)(v3 + 20) = *(_DWORD *)(v3 + 40);
      }
      else
      {
        if (v11)
        {
          LOWORD(bytes.val[0]) = 0;
          _os_log_debug_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "securityd client: sync bubble user", (uint8_t *)&bytes, 2u);
        }

        v12 = *(_DWORD *)(v3 + 20);
        *(_QWORD *)bytes.val = 0x114EC8A39FAB1A82;
        bytes.val[2] = -397635414;
        bytes.val[3] = bswap32(v12);
        *(_QWORD *)(v3 + 24) = CFDataCreate(0, (const UInt8 *)&bytes, 16);
      }
      *(_DWORD *)(v3 + 32) = dword_1003414E0;
    }
    else
    {
      sub_10000FBDC(v3);
    }
    v14 = a3[1];
    *(_OWORD *)bytes.val = *a3;
    *(_OWORD *)&bytes.val[4] = v14;
    v15 = SecTaskCreateWithAuditToken(kCFAllocatorDefault, &bytes);
    *(_QWORD *)v3 = v15;
    v16 = sub_10000FA3C(v15, CFSTR("com.apple.developer.on-demand-install-capable"));
    v17 = (const __CFArray *)sub_10000FAA8(v15, CFSTR("keychain-access-groups"));
    v18 = (const __CFArray *)sub_10000FAA8(v15, CFSTR("com.apple.security.application-groups"));
    v19 = sub_10000FB48(v15);
    v20 = (const __CFArray *)sub_10000FAA8(v15, CFSTR("com.apple.developer.associated-application-identifier"));
    Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
    if (v17)
    {
      v70.length = CFArrayGetCount(v17);
      v70.location = 0;
      CFArrayAppendArray(Mutable, v17, v70);
    }
    if (v20)
    {
      v71.length = CFArrayGetCount(v20);
      v71.location = 0;
      CFArrayAppendArray(Mutable, v20, v71);
    }
    if (v19)
      CFArrayAppendValue(Mutable, v19);
    if (v18)
    {
      if (v16)
      {
        v22 = sub_10000EF14("entitlements");
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          bytes.val[0] = 138412290;
          *(_QWORD *)&bytes.val[1] = CFSTR("com.apple.security.application-groups");
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Ignoring \"%@\" because client is API-restricted", (uint8_t *)&bytes, 0xCu);
        }
      }
      else
      {
        v72.length = CFArrayGetCount(v18);
        v72.location = 0;
        CFArrayAppendArray(Mutable, v18, v72);
      }
    }
    v67.length = CFArrayGetCount(Mutable);
    v67.location = 0;
    FirstIndexOfValue = CFArrayGetFirstIndexOfValue(Mutable, v67, kSecAttrAccessGroupToken);
    if (FirstIndexOfValue != -1)
    {
      v24 = FirstIndexOfValue;
      if (!_os_feature_enabled_impl("CryptoTokenKit", "UseTokens"))
      {
        v40 = sub_10000EF14("SecWarning");
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(bytes.val[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "Keychain access group com.apple.token ignored, feature not available", (uint8_t *)&bytes, 2u);
        }
        CFArrayRemoveValueAtIndex(Mutable, v24);
        if (!v20)
        {
LABEL_33:
          if (v19)
            CFRelease(v19);
          if (v17)
            CFRelease(v17);
          if (v18)
            CFRelease(v18);
          *(_QWORD *)(v3 + 8) = Mutable;
          *(_QWORD *)(v3 + 48) = sub_10000FB48(*(__SecTask **)v3);
          v25 = sub_10000FA3C(*(__SecTask **)v3, CFSTR("com.apple.developer.on-demand-install-capable"));
          *(_BYTE *)(v3 + 44) = v25;
          if (v25)
          {
            v26 = sub_10000EF14("serverxpc");
            v27 = objc_claimAutoreleasedReturnValue(v26);
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
            {
              LOWORD(bytes.val[0]) = 0;
              _os_log_debug_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEBUG, "securityd client: app clip (API restricted)", (uint8_t *)&bytes, 2u);
            }

          }
          *(_BYTE *)(v3 + 57) = sub_10000FA3C(*(__SecTask **)v3, CFSTR("com.apple.private.keychain.kcsharing.client"));
          *(_BYTE *)(v3 + 16) = sub_10000FA3C(*(__SecTask **)v3, CFSTR("com.apple.private.system-keychain"));
          *(_BYTE *)(v3 + 18) = sub_10000FA3C(*(__SecTask **)v3, CFSTR("com.apple.developer.networking.networkextension"));
          *(_BYTE *)(v3 + 19) = sub_10000FA3C(*(__SecTask **)v3, CFSTR("com.apple.networkextension.keychain"));
          if (*(_BYTE *)(v3 + 36))
            *(_BYTE *)(v3 + 17) = sub_10000FA3C(*(__SecTask **)v3, CFSTR("com.apple.private.syncbubble-keychain"));
          v28 = *(const __CFArray **)(v3 + 8);
          if (!v28)
            goto LABEL_91;
          v68.length = CFArrayGetCount(v28);
          v68.location = 0;
          if (!CFArrayContainsValue(*(CFArrayRef *)(v3 + 8), v68, CFSTR("*")))
            goto LABEL_91;
          v29 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
          if (SecIsInternalRelease(v29, v30))
            CFArrayAppendValue(v29, CFSTR("com.apple.security-cli"));
          v31 = *(__SecTask **)v3;
          if (*(_QWORD *)v3)
          {
            CodeSignStatus = SecTaskGetCodeSignStatus(*(SecTaskRef *)v3);
            v34 = CodeSignStatus;
            if ((CodeSignStatus & 0xC000001) == 0x4000001)
            {
LABEL_51:
              v35 = SecTaskCopySigningIdentifier(v31, 0);
              v36 = v35;
              if (!v29)
              {
                v52 = sub_10000EF14("serverxpc");
                v53 = objc_claimAutoreleasedReturnValue(v52);
                if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG))
                {
                  LODWORD(buf) = 138412290;
                  *(_QWORD *)((char *)&buf + 4) = v36;
                  _os_log_debug_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEBUG, "Client %@ is valid platform binary", (uint8_t *)&buf, 0xCu);
                }

                if (v36)
                  CFRelease(v36);
                goto LABEL_91;
              }
              if (v35)
              {
                *(_QWORD *)&buf = 0;
                *((_QWORD *)&buf + 1) = &buf;
                v65 = 0x2020000000;
                v66 = 0;
                *(_QWORD *)bytes.val = _NSConcreteStackBlock;
                *(_QWORD *)&bytes.val[2] = 3221225472;
                *(_QWORD *)&bytes.val[4] = sub_10002B854;
                *(_QWORD *)&bytes.val[6] = &unk_1002EC5E8;
                p_buf = &buf;
                v63 = v35;
                v37 = &bytes;
                v69.length = CFArrayGetCount(v29);
                v69.location = 0;
                CFArrayApplyFunction(v29, v69, (CFArrayApplierFunction)sub_10002B894, v37);

                if (*(_BYTE *)(*((_QWORD *)&buf + 1) + 24))
                {
                  v38 = sub_10000EF14("serverxpc");
                  v39 = objc_claimAutoreleasedReturnValue(v38);
                  if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
                  {
                    v59 = 138412290;
                    v60 = v36;
                    _os_log_debug_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEBUG, "client %@ is eligible platform binary", (uint8_t *)&v59, 0xCu);
                  }
                }
                else
                {
                  v56 = sub_10000EF14("SecError");
                  v39 = objc_claimAutoreleasedReturnValue(v56);
                  if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
                  {
                    v59 = 138412290;
                    v60 = v36;
                    _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "serverxpc: client %@ is not eligible", (uint8_t *)&v59, 0xCu);
                  }
                }

                CFRelease(v36);
                v57 = *(_BYTE *)(*((_QWORD *)&buf + 1) + 24) == 0;
                _Block_object_dispose(&buf, 8);
                CFRelease(v29);
                if (!v57)
                {
LABEL_91:
                  v3 = 1;
LABEL_92:
                  objc_autoreleasePoolPop(v6);
                  return v3;
                }
LABEL_72:
                v48 = *(__SecTask **)v3;
                if (*(_QWORD *)v3)
                {
                  *(_QWORD *)v3 = 0;
                  CFRelease(v48);
                }
                v49 = *(const void **)(v3 + 8);
                if (v49)
                {
                  *(_QWORD *)(v3 + 8) = 0;
                  CFRelease(v49);
                }
                v50 = *(const void **)(v3 + 24);
                if (v50)
                {
                  *(_QWORD *)(v3 + 24) = 0;
                  CFRelease(v50);
                }
                v51 = *(const void **)(v3 + 48);
                if (v51)
                {
                  *(_QWORD *)(v3 + 48) = 0;
                  CFRelease(v51);
                }
                v3 = 0;
                goto LABEL_92;
              }
              v54 = sub_10000EF14("SecError");
              v55 = objc_claimAutoreleasedReturnValue(v54);
              if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf) = 0;
                _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "serverxpc: client has no codesign identifier", (uint8_t *)&buf, 2u);
              }

LABEL_71:
              CFRelease(v29);
              goto LABEL_72;
            }
            if (SecIsInternalRelease(CodeSignStatus, v33))
            {
              if ((v34 & 0x1C000000) == 0x14000000)
                goto LABEL_51;
              v46 = sub_10000EF14("SecError");
              v42 = objc_claimAutoreleasedReturnValue(v46);
              if (!os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
              {
LABEL_70:

                if (!v29)
                  goto LABEL_72;
                goto LABEL_71;
              }
              LODWORD(buf) = 67109120;
              DWORD1(buf) = v34;
              v43 = "serverxpc: client is not a platform binary: 0x%08x";
            }
            else
            {
              v47 = sub_10000EF14("SecError");
              v42 = objc_claimAutoreleasedReturnValue(v47);
              if (!os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
                goto LABEL_70;
              LODWORD(buf) = 67109120;
              DWORD1(buf) = v34;
              v43 = "serverxpc: client is not a platform binary: 0x%08x";
            }
            v44 = v42;
            v45 = 8;
          }
          else
          {
            v41 = sub_10000EF14("SecError");
            v42 = objc_claimAutoreleasedReturnValue(v41);
            if (!os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
              goto LABEL_70;
            LOWORD(buf) = 0;
            v43 = "serverxpc: Client task is null, cannot verify platformness";
            v44 = v42;
            v45 = 2;
          }
          _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, v43, (uint8_t *)&buf, v45);
          goto LABEL_70;
        }
LABEL_32:
        CFRelease(v20);
        goto LABEL_33;
      }
      CFArrayRemoveValueAtIndex(Mutable, v24);
      CFArrayAppendValue(Mutable, kSecAttrAccessGroupToken);
    }
    if (!v20)
      goto LABEL_33;
    goto LABEL_32;
  }
  return v3;
}

void sub_10000FA18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_10000FA3C(__SecTask *a1, const __CFString *a2)
{
  CFTypeRef v2;
  const void *v3;
  CFTypeID TypeID;
  _BOOL8 v5;

  v2 = SecTaskCopyValueForEntitlement(a1, a2, 0);
  if (!v2)
    return 0;
  v3 = v2;
  TypeID = CFBooleanGetTypeID();
  v5 = TypeID == CFGetTypeID(v3) && CFBooleanGetValue((CFBooleanRef)v3) != 0;
  CFRelease(v3);
  return v5;
}

const void *sub_10000FAA8(__SecTask *a1, const __CFString *a2)
{
  CFTypeRef v2;
  const void *v3;
  CFTypeID v4;
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;
  const void *ValueAtIndex;
  CFTypeID v9;

  v2 = SecTaskCopyValueForEntitlement(a1, a2, 0);
  v3 = v2;
  if (v2)
  {
    v4 = CFGetTypeID(v2);
    if (v4 != CFArrayGetTypeID())
    {
LABEL_8:
      CFRelease(v3);
      return 0;
    }
    Count = CFArrayGetCount((CFArrayRef)v3);
    if (Count >= 1)
    {
      v6 = Count;
      v7 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v3, v7);
        v9 = CFGetTypeID(ValueAtIndex);
        if (v9 != CFStringGetTypeID())
          break;
        if (v6 == ++v7)
          return v3;
      }
      goto LABEL_8;
    }
  }
  return v3;
}

const void *sub_10000FB48(__SecTask *a1)
{
  const void *result;

  result = sub_10000FB8C(a1, CFSTR("application-identifier"));
  if (!result)
    return sub_10000FB8C(a1, CFSTR("com.apple.application-identifier"));
  return result;
}

const void *sub_10000FB8C(__SecTask *a1, const __CFString *a2)
{
  CFTypeRef v2;
  const void *v3;
  CFTypeID v4;

  v2 = SecTaskCopyValueForEntitlement(a1, a2, 0);
  v3 = v2;
  if (v2)
  {
    v4 = CFGetTypeID(v2);
    if (v4 != CFStringGetTypeID())
    {
      CFRelease(v3);
      return 0;
    }
  }
  return v3;
}

uint64_t sub_10000FBDC(uint64_t a1)
{
  void *v2;
  const void *v3;
  void *v4;
  void *v5;
  const void *v6;
  NSObject *v7;
  const void *v8;
  NSObject *v9;
  void *v10;
  id v11;
  int v12;
  const void *v13;
  NSObject *v14;
  void *v15;
  uint64_t v16;
  void *v18;
  uint64_t v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  void *v23;

  if (a1)
  {
    v2 = objc_autoreleasePoolPush();
    if (!*(_BYTE *)(a1 + 56))
    {
      v3 = *(const void **)(a1 + 24);
      if (v3)
      {
        *(_QWORD *)(a1 + 24) = 0;
        CFRelease(v3);
      }
    }
    v4 = (void *)objc_claimAutoreleasedReturnValue(+[UMUserManager sharedManager](UMUserManager, "sharedManager"));
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "currentPersona"));

    if (v5 && objc_msgSend(v5, "userPersonaType") == (id)2)
    {
      v6 = sub_10000EF14("serverxpc");
      v7 = objc_claimAutoreleasedReturnValue(v6);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "userPersonaNickName"));
        *(_DWORD *)buf = 134218242;
        v21 = a1;
        v22 = 2112;
        v23 = v18;
        _os_log_debug_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "securityd client(%p): persona user %@", buf, 0x16u);

      }
      v8 = sub_10000EF14("serverxpc");
      v9 = objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "userPersonaUniqueString"));
        *(_DWORD *)buf = 134218242;
        v21 = a1;
        v22 = 2112;
        v23 = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "securityd client(%p): persona uuid %@", buf, 0x16u);

      }
      v11 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "userPersonaUniqueString", 0xAAAAAAAAAAAAAAAALL, 0xAAAAAAAAAAAAAAAALL)));
      v12 = uuid_parse((const char *)objc_msgSend(v11, "UTF8String"), (unsigned __int8 *)&v19);

      if (v12)
      {
        v13 = sub_10000EF14("serverxpc");
        v14 = objc_claimAutoreleasedReturnValue(v13);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "userPersonaUniqueString"));
          *(_DWORD *)buf = 134218242;
          v21 = a1;
          v22 = 2112;
          v23 = v15;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "securityd client(%p):  uuid %@ didn't parse setting to null", buf, 0x16u);

        }
        v16 = 0;
        *(_QWORD *)(a1 + 24) = 0;
        goto LABEL_18;
      }
      *(_QWORD *)(a1 + 24) = CFDataCreate(0, (const UInt8 *)&v19, 16);
    }
    v16 = 1;
LABEL_18:

    objc_autoreleasePoolPop(v2);
    return v16;
  }
  return 0;
}

const void *sub_10000FE74(void *a1, const char *a2, __CFString **a3)
{
  CFTypeRef v5;
  const void *v6;
  CFTypeID v7;
  CFStringRef v8;

  v5 = sub_10000FF08(a1, a2, a3);
  v6 = v5;
  if (v5)
  {
    v7 = CFGetTypeID(v5);
    if (v7 != CFDictionaryGetTypeID())
    {
      v8 = CFCopyTypeIDDescription(v7);
      sub_100019F20(-50, a3, CFSTR("object for key %s not dictionary but %@"), a2, v8);
      if (v8)
        CFRelease(v8);
      CFRelease(v6);
      return 0;
    }
  }
  return v6;
}

CFTypeRef sub_10000FF08(void *a1, const char *a2, __CFString **a3)
{
  const UInt8 *data;
  const UInt8 *v6;
  unsigned __int8 *v7;
  const __CFAllocator *v8;
  __CFString *v9;
  NSObject *v10;
  __CFString *v11;
  CFTypeRef v12;
  size_t length;
  CFTypeRef cf;
  uint8_t buf[4];
  __CFString *v17;

  length = 0;
  cf = 0;
  data = (const UInt8 *)xpc_dictionary_get_data(a1, a2, &length);
  if (data)
  {
    v6 = data;
    v7 = (unsigned __int8 *)&data[length];
    v8 = (const __CFAllocator *)SecCFAllocatorZeroize();
    if (sub_100020974(v8, (CFBooleanRef *)&cf, (CFTypeRef *)a3, v6, (uint64_t)v7) == v7)
    {
      v12 = cf;
    }
    else
    {
      v9 = (__CFString *)CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("trailing garbage after der decoded object for key %s"), a2);
      sub_100019F20(-50, a3, CFSTR("%@"), v9);
      if (a3)
      {
        v10 = sub_10000EF14("SecError");
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          v11 = *a3;
          *(_DWORD *)buf = 138412290;
          v17 = v11;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "xpc: %@", buf, 0xCu);
        }
      }
      sub_10003429C(v9, 0x53C00002u);
      if (v9)
        CFRelease(v9);
      if (cf)
        CFRelease(cf);
      v12 = 0;
    }
    cc_clear(length, v6);
  }
  else
  {
    sub_100019F20(-50, a3, CFSTR("no object for key %s"), a2);
    return 0;
  }
  return v12;
}

size_t sub_100010098(void *a1, const char *a2, const __CFString *a3, uint64_t a4, __CFString **a5)
{
  size_t result;
  size_t v11;
  UInt8 *v12;
  unint64_t v13;
  const void *v14;

  if (!a3)
    return sub_100019F20(-50, a5, CFSTR("object for key %s is NULL"), a2);
  result = sub_1000212A4(a3, (CFTypeRef *)a5, (uint64_t)a3, a4, (uint64_t)a5);
  if (result)
  {
    v11 = result;
    v12 = (UInt8 *)malloc_type_malloc(result, 0x91A96E61uLL);
    v13 = (unint64_t)&v12[v11];
    v14 = (const void *)sub_100020FA0(a3, (CFTypeRef *)a5, a4, v12, v13);
    if (v14 && v13 > (unint64_t)v14)
    {
      xpc_dictionary_set_data(a1, a2, v14, v13 - (_QWORD)v14);
      free(v12);
      return 1;
    }
    else
    {
      free(v12);
      return 0;
    }
  }
  return result;
}

uint64_t sub_10001017C(const __CFDictionary *a1, uint64_t a2)
{
  __int128 v3;
  uint64_t v4;

  v3 = xmmword_100248F20;
  LOBYTE(v3) = 1;
  v4 = a2;
  CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)sub_1000099C8, &v3);
  if ((_BYTE)v3)
    return ccder_sizeof(0x2000000000000011, *((_QWORD *)&v3 + 1));
  else
    return 0;
}

uint64_t sub_1000101DC(const __CFDictionary *a1, CFTypeRef *a2, char a3, uint64_t a4, uint64_t a5)
{
  CFMutableArrayRef Mutable;
  CFIndex Count;
  uint64_t v12;
  unint64_t v13;
  const __CFData *ValueAtIndex;
  CFIndex Length;
  const UInt8 *BytePtr;
  uint64_t result;
  uint64_t v18;
  _QWORD v19[4];
  CFRange v20;

  Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  v19[0] = 0xAAAAAAAAAAAAAA01;
  v19[1] = a2;
  BYTE1(v19[0]) = a3;
  v19[2] = Mutable;
  v19[3] = 0;
  CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)sub_100020468, v19);
  if (!LOBYTE(v19[0]))
  {
    if (Mutable)
      CFRelease(Mutable);
    return 0;
  }
  v20.length = CFArrayGetCount(Mutable);
  v20.location = 0;
  CFArraySortValues(Mutable, v20, (CFComparatorFunction)sub_100009A0C, 0);
  Count = CFArrayGetCount(Mutable);
  v12 = a5;
  if (Count >= 1)
  {
    v13 = Count + 1;
    v12 = a5;
    do
    {
      ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(Mutable, v13 - 2);
      Length = CFDataGetLength(ValueAtIndex);
      BytePtr = CFDataGetBytePtr(ValueAtIndex);
      v12 = ccder_encode_body(Length, BytePtr, a4, v12);
      --v13;
    }
    while (v13 > 1);
  }
  if (Mutable)
    CFRelease(Mutable);
  result = ccder_encode_constructed_tl(0x2000000000000011, a5, a4, v12);
  if (!result)
  {
    sub_100032660(-7, CFSTR("com.apple.security.cfder.error"), 0, a2, v18, CFSTR("ccder failed to encode"));
    return 0;
  }
  return result;
}

xpc_object_t sub_100010350(__CFError *a1)
{
  xpc_object_t v2;
  const __CFString *Domain;
  int64_t Code;
  const __CFString *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;
  size_t v10;
  UInt8 *v11;
  unint64_t v12;
  const void *v13;
  _QWORD v15[6];
  _QWORD v16[5];

  v2 = xpc_dictionary_create(0, 0, 0);
  Domain = CFErrorGetDomain(a1);
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 0x40000000;
  v15[2] = sub_100010490;
  v15[3] = &unk_1002DBA08;
  v15[4] = v2;
  v15[5] = "domain";
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 0x40000000;
  v16[2] = sub_1000104A0;
  v16[3] = &unk_1002DB170;
  v16[4] = v15;
  sub_1000137F8(Domain, (uint64_t)v16);
  Code = CFErrorGetCode(a1);
  xpc_dictionary_set_int64(v2, "code", Code);
  v5 = (const __CFString *)CFErrorCopyUserInfo(a1);
  v9 = sub_1000212A4(v5, 0, v6, v7, v8);
  if (v9)
  {
    v10 = v9;
    v11 = (UInt8 *)malloc_type_malloc(v9, 0x4ABABCFuLL);
    v12 = (unint64_t)&v11[v10];
    v13 = (const void *)sub_100020FA0(v5, 0, 0, v11, v12);
    if (v13)
      xpc_dictionary_set_data(v2, "userinfo", v13, v12 - (_QWORD)v13);
    free(v11);
  }
  CFRelease(v5);
  return v2;
}

void sub_100010490(uint64_t a1, char *string)
{
  xpc_dictionary_set_string(*(xpc_object_t *)(a1 + 32), *(const char **)(a1 + 40), string);
}

uint64_t sub_1000104A0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_1000104AC(uint64_t a1, uint64_t a2, CFArrayRef a3)
{
  uint64_t v6;
  os_unfair_lock_s *v7;
  uint64_t v8;
  const __CFAllocator *v9;
  CFIndex v10;
  NSObject *v11;
  __int128 v12;

  v6 = *(_QWORD *)(a1 + 16);
  v7 = (os_unfair_lock_s *)(v6 + 148);
  os_unfair_lock_lock((os_unfair_lock_t)(v6 + 148));
  v8 = *(_QWORD *)(v6 + 152);
  os_unfair_lock_unlock(v7);
  if (!v8)
    return;
  if (a2 && a3)
  {
    *(_QWORD *)&v12 = a2;
    *((_QWORD *)&v12 + 1) = a3;
    v9 = kCFAllocatorDefault;
    v10 = 2;
  }
  else
  {
    if (!a2)
    {
      if (!a3)
        return;
      CFRetain(a3);
      goto LABEL_8;
    }
    *(_QWORD *)&v12 = a2;
    v9 = kCFAllocatorDefault;
    v10 = 1;
  }
  a3 = CFArrayCreate(v9, (const void **)&v12, v10, &kCFTypeArrayCallBacks);
  if (!a3)
    return;
LABEL_8:
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 72), a3);
  CFRelease(a3);
  if (!*(_BYTE *)(a1 + 25))
  {
    v11 = sub_10000EF14("SecError");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v12) = 138412290;
      *(_QWORD *)((char *)&v12 + 4) = a1;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "db %@ changed outside txn", (uint8_t *)&v12, 0xCu);
    }
    sub_10001B168(a1, 2);
  }
}

const __CFString *sub_10001061C(_QWORD *a1, sqlite3_stmt *pStmt)
{
  __CFString **v4;
  uint64_t v5;
  uint64_t v6;
  _BYTE *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  const __CFString *result;
  const __CFString *v12;
  int v13;
  _BYTE *v14;
  __CFString **v15;
  _QWORD **v16;
  sqlite3_int64 insert_rowid;

  v5 = a1[6];
  v4 = (__CFString **)a1[7];
  v6 = *(_QWORD *)(v5 + 16);
  v7 = *(_BYTE **)(v6 + 16);
  if (v7)
  {
    LODWORD(v8) = 0;
    v9 = a1[4];
    v10 = (_QWORD *)(v6 + 24);
    while (1)
    {
      if ((*(unsigned int (**)(uint64_t, _BYTE *))(v9 + 16))(v9, v7))
      {
        result = (const __CFString *)sub_100010724((CFMutableDictionaryRef *)v5, v7, v4);
        if (!result)
          goto LABEL_11;
        v12 = result;
        v8 = (v8 + 1);
        v13 = sub_100013544(pStmt, v8, result, (CFTypeRef *)v4);
        CFRelease(v12);
        if (!v13)
          break;
      }
      v14 = (_BYTE *)*v10++;
      v7 = v14;
      if (!v14)
      {
        v4 = (__CFString **)a1[7];
        goto LABEL_8;
      }
    }
    result = 0;
  }
  else
  {
LABEL_8:
    result = (const __CFString *)sub_100019C40(a1[8], pStmt, (CFTypeRef *)v4, 0);
    if ((_DWORD)result)
    {
      v15 = (__CFString **)a1[7];
      v16 = (_QWORD **)a1[6];
      insert_rowid = sqlite3_last_insert_rowid(*(sqlite3 **)(a1[8] + 64));
      result = (const __CFString *)sub_10001D87C(v16, insert_rowid, v15);
    }
  }
LABEL_11:
  *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) = (_BYTE)result;
  return result;
}

__CFData *sub_100010724(CFMutableDictionaryRef *a1, _BYTE *a2, __CFString **a3)
{
  const void *v6;
  __CFData *Value;
  __CFData *v8;
  const __CFNull *v9;

  v6 = (const void *)sub_1000107E4(a2);
  if ((~*((_DWORD *)a2 + 4) & 0xALL) != 0 || (Value = (__CFData *)CFDictionaryGetValue(a1[6], v6)) == 0)
  {
    v9 = (const __CFNull *)sub_100019204(a1, (uint64_t)a2, a3);
    if (v9)
    {
      v8 = sub_1000108B4((uint64_t)a2, v9, a3);
      if (v8 && (a2[16] & 8) != 0)
        CFDictionarySetValue(a1[6], v6, v8);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v8 = Value;
    CFRetain(Value);
  }
  return v8;
}

uint64_t sub_1000107E4(_BYTE *a1)
{
  uint64_t v2;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  unint64_t v8;

  if ((a1[16] & 8) == 0)
    return *(_QWORD *)a1;
  if (qword_100341150 != -1)
    dispatch_once(&qword_100341150, &stru_1002DEA70);
  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0xAAAAAAAAAAAAAAAALL;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_100007610;
  v4[3] = &unk_1002DEA98;
  v4[4] = &v5;
  v4[5] = a1;
  dispatch_sync((dispatch_queue_t)qword_100341160, v4);
  v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

__CFData *sub_1000108B4(uint64_t a1, const __CFNull *a2, __CFString **a3)
{
  CFNullRef v5;
  const __CFString *v6;
  __CFData *v7;
  const __CFData *v9;
  const __CFString *v10;

  if (a2)
    v5 = a2;
  else
    v5 = kCFNull;
  if (CFEqual(v5, kCFNull) && (*(_BYTE *)(a1 + 16) & 1) != 0)
  {
    v6 = (const __CFString *)sub_100019FB0(a1, a3);
    if (!v6)
      return 0;
  }
  else
  {
    v6 = (const __CFString *)CFRetain(v5);
  }
  if ((*(_BYTE *)(a1 + 16) & 8) == 0 || CFEqual(v6, kCFNull))
    return (__CFData *)v6;
  v9 = sub_10001264C(v6);
  if (v9)
  {
    v10 = (const __CFString *)v9;
    v7 = sub_100019B60(v9);
    if (v6)
      CFRelease(v6);
    v6 = v10;
  }
  else
  {
    sub_100019F20(-26276, a3, CFSTR("failed to get attribute %@ data"), *(_QWORD *)a1);
    v7 = 0;
    if (!v6)
      return v7;
  }
  CFRelease(v6);
  return v7;
}

BOOL sub_1000109B8(id a1, const SecDbAttr *a2)
{
  return (LOBYTE(a2->var2) >> 1) & 1;
}

BOOL sub_1000109C4(const __CFDictionary *a1, uint64_t a2, uint64_t *a3, __CFString **a4)
{
  const __CFArray *v8;
  CFIndex Count;
  CFIndex v10;
  const void *Value;
  char v13;
  const __CFString *v14;
  __CFArray *MutableCopy;
  CFDataRef v16;
  uint64_t v17;
  uint64_t v18;
  const __CFString *v19;
  __CFString *v20;
  unsigned int v21;
  const void *v22;
  unsigned int v23;
  uint64_t v24;
  const void *v25;
  unsigned int v26;
  CFDataRef v27;
  _DWORD *v28;
  int v29;
  const void *v30;
  const __CFString *v31;
  int v32;
  int v33;
  int v34;
  __CFString **v35;
  __CFString **v36;
  __CFString **v37;
  const __CFData *v38;
  CFDataRef theData;
  const __CFArray *v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t v48;
  void *values;
  uint64_t v50;
  void *v51;
  void *v52;
  uint64_t *v53;
  uint64_t *v54;
  const __CFArray *v55;
  CFDataRef v56;
  CFRange v57;
  CFRange v58;

  if (!sub_10001120C(a1, 1, a4))
    return 0;
  v8 = *(const __CFArray **)(a2 + 8);
  if (!v8)
    return sub_100019F20(-34018, a4, CFSTR("Client has neither %@ entitlements"), CFSTR("application-identifier nor keychain-access-groups"));
  CFRetain(*(CFTypeRef *)(a2 + 8));
  Count = CFArrayGetCount(v8);
  if (!Count)
  {
    CFRelease(v8);
    return sub_100019F20(-34018, a4, CFSTR("Client has neither %@ entitlements"), CFSTR("application-identifier nor keychain-access-groups"));
  }
  v10 = Count;
  kdebug_trace(726794336, 0, 0, 0, 0);
  if (*(_BYTE *)(a2 + 19))
  {
    Value = CFDictionaryGetValue(a1, kSecValuePersistentRef);
    theData = 0;
    v40 = 0;
    v38 = 0;
    if (Value)
    {
      if (_SecItemParsePersistentRef(Value, &v40, &v38, &theData, 0))
      {
        if (theData && CFDataGetLength(theData) == 16)
        {
          v45 = 0;
          v46 = &v45;
          v47 = 0x2000000000;
          v48 = 0;
          v41 = 0;
          v42 = &v41;
          v43 = 0x2000000000;
          v44 = 0;
          values = _NSConcreteStackBlock;
          v50 = 0x40000000;
          v51 = sub_100138F98;
          v52 = &unk_1002E88A0;
          v55 = v40;
          v56 = theData;
        }
        else
        {
          v45 = 0;
          v46 = &v45;
          v47 = 0x2000000000;
          v48 = 0;
          v41 = 0;
          v42 = &v41;
          v43 = 0x2000000000;
          v44 = 0;
          values = _NSConcreteStackBlock;
          v50 = 0x40000000;
          v51 = sub_100139098;
          v52 = &unk_1002E8918;
          v55 = v40;
          v56 = v38;
        }
        v53 = &v41;
        v54 = &v45;
        v13 = sub_100011A30(0, 1, 0, (uint64_t)&v44, (uint64_t)&values);
        v14 = (const __CFString *)v46[3];
        if ((v13 & 1) == 0 && v14)
        {
          v46[3] = 0;
          CFRelease(v14);
          v14 = 0;
        }
        _Block_object_dispose(&v41, 8);
        _Block_object_dispose(&v45, 8);
        if (v14)
        {
          if (CFStringHasSuffix(v14, kSecNetworkExtensionAccessGroupSuffix))
          {
            v57.location = 0;
            v57.length = v10;
            if (!CFArrayContainsValue(v8, v57, v14))
            {
              MutableCopy = CFArrayCreateMutableCopy(0, 0, v8);
              CFArrayAppendValue(MutableCopy, v14);
              CFRelease(v8);
              v8 = MutableCopy;
            }
          }
          CFRelease(v14);
        }
      }
      v16 = theData;
      if (theData)
      {
        theData = 0;
        CFRelease(v16);
      }
    }
  }
  v58.location = 0;
  v58.length = v10;
  if (CFArrayContainsValue(v8, v58, CFSTR("*")) && v8)
  {
    CFRelease(v8);
    v8 = 0;
  }
  v17 = sub_1000112B0(a1, *(const void **)(a2 + 24), 1, a2, a4);
  if (!v17)
  {
    v24 = 0;
    if (!v8)
      goto LABEL_76;
    goto LABEL_75;
  }
  v18 = v17;
  v19 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(v17 + 8), kSecAttrAccessGroup);
  if (!v19)
  {
LABEL_32:
    v21 = *(_DWORD *)(v18 + 196);
    if (v21)
    {
      if (*(_BYTE *)(a2 + 36))
      {
        v22 = *(const void **)(v18 + 128);
        if (v22)
        {
          *(_QWORD *)(v18 + 128) = 0;
          CFRelease(v22);
          v21 = *(_DWORD *)(v18 + 196);
        }
        values = (void *)0x114EC8A39FAB1A82;
        v23 = bswap32(v21);
        LODWORD(v50) = -397635414;
LABEL_48:
        HIDWORD(v50) = v23;
        v27 = CFDataCreate(0, (const UInt8 *)&values, 16);
LABEL_54:
        *(_QWORD *)(v18 + 128) = v27;
LABEL_56:
        sub_100012018(v18, v8);
        if (*(_BYTE *)(a2 + 44) && (sub_100139198(a2) & 1) == 0)
        {
          v32 = sub_100019F20(-34020, a4, CFSTR("App clips are not permitted to use access groups other than application identifier"));
        }
        else
        {
          if (*(_DWORD *)(v18 + 192))
          {
            if (!*(_BYTE *)(a2 + 16))
            {
              v31 = CFSTR("client doesn't have entitlement for system keychain");
              goto LABEL_71;
            }
            if (*(_DWORD *)(v18 + 196))
            {
              if (*(_BYTE *)(a2 + 17))
              {
                v31 = CFSTR("can't do both system and syncbubble keychain");
LABEL_71:
                v33 = -34018;
                goto LABEL_72;
              }
LABEL_70:
              v31 = CFSTR("client doesn't have entitlement for syncbubble keychain");
              goto LABEL_71;
            }
          }
          else if (*(_DWORD *)(v18 + 196) && !*(_BYTE *)(a2 + 17))
          {
            goto LABEL_70;
          }
          if (*(_QWORD *)(v18 + 88))
          {
            v31 = CFSTR("use item list unsupported");
LABEL_68:
            v33 = -50;
LABEL_72:
            v32 = sub_100019F20(v33, a4, v31);
            goto LABEL_73;
          }
          if (*(_QWORD *)(v18 + 176))
          {
            v35 = *(__CFString ***)v18;
            if (v35 != (__CFString **)sub_1000119B8((uint64_t)CFSTR("cert"), &qword_100341260, (uint64_t)&unk_100341258)
              && *(__CFString ***)v18 != &off_1002E3A00)
            {
              v31 = CFSTR("unsupported match attribute");
LABEL_91:
              v33 = -4;
              goto LABEL_72;
            }
          }
          if (*(_QWORD *)(v18 + 248))
          {
            v36 = *(__CFString ***)v18;
            if (v36 != (__CFString **)sub_1000119B8((uint64_t)CFSTR("inet"), &qword_100341250, (uint64_t)&unk_100341248))
            {
              v31 = CFSTR("unsupported kSecMatchHostOrSubdomainOfHost attribute");
              goto LABEL_91;
            }
          }
          if (*(_QWORD *)(v18 + 208))
          {
            v37 = *(__CFString ***)v18;
            if (v37 != (__CFString **)sub_1000119B8((uint64_t)CFSTR("cert"), &qword_100341260, (uint64_t)&unk_100341258)
              && *(__CFString ***)v18 != &off_1002E3A00)
            {
              v31 = CFSTR("unsupported kSecMatchPolicy attribute");
              goto LABEL_91;
            }
          }
          if (!a3 && *(_DWORD *)(v18 + 48))
          {
            v31 = CFSTR("missing pointer");
            goto LABEL_68;
          }
          if (*(_BYTE *)(v18 + 116) && CFDictionaryContainsKey(*(CFDictionaryRef *)(v18 + 8), kSecAttrSharingGroup))
          {
            v31 = CFSTR("can't copy shared items without Keychain Sharing client entitlement");
            goto LABEL_71;
          }
          if (*(_QWORD *)(v18 + 40))
          {
            v34 = 0;
LABEL_74:
            v24 = sub_100011108((const void **)v18, (CFErrorRef *)a4) & v34;
            if (!v8)
            {
LABEL_76:
              kdebug_trace(726794340, 0, 0, 0, 0);
              return v24;
            }
LABEL_75:
            CFRelease(v8);
            goto LABEL_76;
          }
          values = _NSConcreteStackBlock;
          v50 = 0x40000000;
          v51 = sub_100013DAC;
          v52 = &unk_1002E8828;
          v53 = (uint64_t *)v18;
          v54 = a3;
          v55 = v8;
          v56 = (CFDataRef)a4;
          v32 = sub_100011A30(0, 1, 0, (uint64_t)a4, (uint64_t)&values);
        }
LABEL_73:
        v34 = v32;
        goto LABEL_74;
      }
    }
    else if (*(_BYTE *)(a2 + 36))
    {
      if (*(_BYTE *)(a2 + 18))
      {
        v25 = *(const void **)(v18 + 128);
        if (v25)
        {
          *(_QWORD *)(v18 + 128) = 0;
          CFRelease(v25);
        }
        v26 = *(_DWORD *)(a2 + 20);
        values = (void *)0x9A460A992EBEC436;
        v23 = bswap32(v26);
        LODWORD(v50) = -1542878804;
        goto LABEL_48;
      }
      v28 = (_DWORD *)(v18 + 192);
      v29 = *(_DWORD *)(v18 + 192);
      if (v29 == 1)
      {
LABEL_51:
        v30 = *(const void **)(v18 + 128);
        if (v30)
        {
          *(_QWORD *)(v18 + 128) = 0;
          CFRelease(v30);
        }
        v27 = CFDataCreateWithBytesNoCopy(0, byte_10024957C, 16, kCFAllocatorNull);
        goto LABEL_54;
      }
LABEL_50:
      if (v29 != 2)
      {
        *v28 = 0;
        goto LABEL_56;
      }
      goto LABEL_51;
    }
    v28 = (_DWORD *)(v18 + 192);
    v29 = *(_DWORD *)(v18 + 192);
    goto LABEL_50;
  }
  v20 = (__CFString *)v19;
  if (sub_100014DCC(v8, v19, a2))
  {
    values = v20;
    if (v8)
      CFRelease(v8);
    v8 = CFArrayCreate(0, (const void **)&values, 1, &kCFTypeArrayCallBacks);
    goto LABEL_32;
  }
  sub_100019F20(-34018, a4, CFSTR("Client explicitly specifies access group %@ but is only entitled for %@"), v20, v8);
  if (v8)
    CFRelease(v8);
  sub_100011108((const void **)v18, 0);
  return 0;
}

uint64_t sub_100011108(const void **a1, CFErrorRef *a2)
{
  uint64_t v3;
  uint64_t v4;
  const void **v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const void *v21;

  v3 = sub_100011460((uint64_t)a1, a2);
  v4 = (uint64_t)a1[4];
  if (v4 >= 1)
  {
    v5 = a1 + 34;
    do
    {
      v7 = *v5;
      v5 += 2;
      v6 = v7;
      if (v7)
        CFRelease(v6);
      --v4;
    }
    while (v4);
  }
  v8 = a1[1];
  if (v8)
    CFRelease(v8);
  v9 = a1[16];
  if (v9)
    CFRelease(v9);
  v10 = a1[21];
  if (v10)
    CFRelease(v10);
  v11 = a1[22];
  if (v11)
    CFRelease(v11);
  v12 = a1[17];
  if (v12)
    CFRelease(v12);
  v13 = a1[18];
  if (v13)
    CFRelease(v13);
  v14 = a1[23];
  if (v14)
    CFRelease(v14);
  v15 = a1[26];
  if (v15)
    CFRelease(v15);
  v16 = a1[27];
  if (v16)
    CFRelease(v16);
  v17 = a1[29];
  if (v17)
    CFRelease(v17);
  v18 = a1[30];
  if (v18)
    CFRelease(v18);
  v19 = a1[10];
  if (v19)
    CFRelease(v19);
  v20 = a1[31];
  if (v20)
    CFRelease(v20);
  v21 = a1[28];
  if (v21)
    CFRelease(v21);
  free(a1);
  return v3;
}

uint64_t sub_10001120C(const __CFDictionary *a1, uint64_t a2, __CFString **a3)
{
  const __CFString *v6;

  if (CFDictionaryContainsKey(a1, CFSTR("clip")))
  {
    v6 = CFSTR("Non-API attributes present in query");
    return sub_100019F20(-50, a3, v6);
  }
  if (CFDictionaryContainsKey(a1, kSecAttrSharingGroup))
  {
    if (sub_100139520(a1))
    {
      v6 = CFSTR("Can't query the synced keychain with a sharing group");
      return sub_100019F20(-50, a3, v6);
    }
    if (a2 == 2)
    {
      v6 = CFSTR("Can't update an item's sharing group");
      return sub_100019F20(-50, a3, v6);
    }
  }
  return 1;
}

uint64_t sub_1000112B0(const __CFDictionary *a1, const void *a2, uint64_t a3, uint64_t a4, __CFString **a5)
{
  const void *Value;
  const void *v11;
  CFTypeID v12;
  const void *v13;
  const void *v14;
  CFTypeID v15;
  __CFString **v16;
  _QWORD *v17;
  uint64_t v18;
  const void *v20;

  v20 = 0;
  Value = CFDictionaryGetValue(a1, kSecClass);
  if (Value && (v11 = Value, v12 = CFGetTypeID(Value), v12 == CFStringGetTypeID()))
  {
    v20 = v11;
  }
  else
  {
    v13 = CFDictionaryGetValue(a1, kSecValuePersistentRef);
    if (!v13
      || (v14 = v13, v15 = CFGetTypeID(v13), v15 != CFDataGetTypeID())
      || (_SecItemParsePersistentRef(v14, &v20, 0, 0, 0), (v11 = v20) == 0))
    {
LABEL_10:
      sub_100019F20(-50, a5, CFSTR("query missing class name"));
      goto LABEL_11;
    }
  }
  v16 = sub_100011884(v11);
  if (v16)
    goto LABEL_12;
  if (!v20)
    goto LABEL_10;
  sub_100019F20(-25306, a5, CFSTR("can't find class named: %@"), v20);
LABEL_11:
  v16 = 0;
LABEL_12:
  v17 = sub_1000114E8((uint64_t)v16, a2, a1, a4, a5);
  v18 = (uint64_t)v17;
  if (v17)
  {
    v17[13] = a3;
    CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)sub_1000097B0, v17);
    if ((sub_100011460(v18, (CFErrorRef *)a5) & 1) != 0)
    {
      if (!*(_BYTE *)(v18 + 112) && !*(_QWORD *)(v18 + 72) && !*(_QWORD *)(v18 + 80) && !*(_QWORD *)(v18 + 240))
        sub_100012178(kSecAttrSynchronizable, kCFBooleanFalse, v18);
    }
    else
    {
      sub_100011108((const void **)v18, (CFErrorRef *)a5);
      return 0;
    }
  }
  return v18;
}

uint64_t sub_100011460(uint64_t a1, CFErrorRef *a2)
{
  __CFError *v3;
  CFErrorRef v4;
  uint64_t result;

  v3 = *(__CFError **)(a1 + 40);
  *(_QWORD *)(a1 + 40) = 0;
  if (a2 && v3)
  {
    if (*a2)
    {
      if (CFErrorGetCode(*a2) != -25330)
        goto LABEL_9;
      v4 = *a2;
      if (*a2)
      {
        *a2 = 0;
        CFRelease(v4);
LABEL_9:
        if (*a2)
          goto LABEL_10;
      }
    }
    result = 0;
    *a2 = v3;
    return result;
  }
  if (v3)
  {
    if (!a2)
    {
LABEL_10:
      CFRelease(v3);
      return 0;
    }
    goto LABEL_9;
  }
  return 1;
}

_QWORD *sub_1000114E8(uint64_t a1, const void *a2, CFDictionaryRef theDict, uint64_t a4, __CFString **a5)
{
  const void *v8;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const void **v20;
  const void ***v21;
  const void **v22;
  NSObject *v23;
  _QWORD *v24;
  _QWORD *v26;
  __CFDictionary *Mutable;
  int v28;
  uint64_t v29;
  __int16 v30;
  int v31;

  if (!a1)
  {
    if (a5 && !*a5)
      sub_100019F20(-50, a5, CFSTR("Missing class"));
    return 0;
  }
  v8 = a2;
  if (!a2)
  {
    if (qword_100341188 != -1)
      dispatch_once(&qword_100341188, &stru_1002DED08);
    v8 = (const void *)qword_100341190;
  }
  if (!*(_QWORD *)(a1 + 16))
    goto LABEL_10;
  v10 = 0;
  while (*(_QWORD *)(a1 + 24 + 8 * v10++))
    ;
  if (!v10)
  {
LABEL_10:
    v12 = sub_1000119B8((uint64_t)CFSTR("cert"), &qword_100341260, (uint64_t)&unk_100341258);
    if (*(_QWORD *)(v12 + 16))
    {
      v13 = 0;
      do
        v14 = v13 + 1;
      while (*(_QWORD *)(v12 + 24 + 8 * v13++));
    }
    else
    {
      v14 = 0;
    }
    v16 = sub_1000119B8((uint64_t)CFSTR("keys"), &qword_100341270, (uint64_t)&unk_100341268);
    if (*(_QWORD *)(v16 + 16))
    {
      v17 = 0;
      do
        v18 = v17 + 1;
      while (*(_QWORD *)(v16 + 24 + 8 * v17++));
    }
    else
    {
      v18 = 0;
    }
    v10 = v18 + v14;
  }
  if (theDict)
  {
    v10 += CFDictionaryGetCount(theDict);
    v20 = *(const void ***)(a1 + 16);
    if (v20)
    {
      v21 = (const void ***)(a1 + 24);
      do
      {
        v10 -= CFDictionaryContainsKey(theDict, *v20) != 0;
        v22 = *v21++;
        v20 = v22;
      }
      while (v22);
    }
  }
  if (v10 >= 129)
  {
    if (a5 && !*a5)
    {
      v23 = sub_10000EF14("SecError");
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        v28 = 134218240;
        v29 = v10;
        v30 = 1024;
        v31 = 128;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "key_count: %ld, QUERY_KEY_LIMIT: %d", (uint8_t *)&v28, 0x12u);
      }
      sub_100019F20(-50, a5, CFSTR("Past query key limit"));
    }
    return 0;
  }
  v26 = malloc_type_calloc(1uLL, 16 * v10 + 264, 0x2301482uLL);
  if (!v26)
  {
    if (a5 && !*a5)
      sub_100019F20(-108, a5, CFSTR("Out of memory"));
    return 0;
  }
  v24 = v26;
  v26[32] = v10;
  v26[16] = CFRetain(v8);
  *((_BYTE *)v24 + 154) = 0;
  *((_DWORD *)v24 + 30) = dword_1003414E0;
  *v24 = a1;
  v24[2] = v10;
  v24[3] = v10;
  Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v24[1] = Mutable;
  if (a4)
  {
    if (*(_BYTE *)(a4 + 44))
      CFDictionaryAddValue(Mutable, CFSTR("clip"), kCFBooleanTrue);
    *((_BYTE *)v24 + 116) = *(_BYTE *)(a4 + 57) ^ 1;
  }
  return v24;
}

_QWORD *sub_1000117E0(_QWORD *result, CFTypeRef cf, __CFString **a3)
{
  _QWORD *v5;
  CFTypeID v6;
  int v7;

  if (cf
    && (v5 = result, v6 = CFGetTypeID(cf), result = (_QWORD *)CFStringGetTypeID(), (_QWORD *)v6 == result)
    && (result = sub_100011884(cf)) != 0
    && (!*v5 || (_QWORD *)*v5 == result))
  {
    *v5 = result;
  }
  else if (a3 && !*a3)
  {
    if (cf)
      v7 = -25306;
    else
      v7 = -50;
    return (_QWORD *)sub_100019F20(v7, a3, CFSTR("can find class named: %@"), cf);
  }
  return result;
}

__CFString **sub_100011884(const void *a1)
{
  CFTypeID v2;
  const __CFString *v3;
  dispatch_once_t *v4;
  void *v5;

  v2 = CFGetTypeID(a1);
  if (v2 != CFStringGetTypeID())
    return 0;
  if (CFEqual(a1, kSecClassGenericPassword))
  {
    v3 = CFSTR("genp");
    v4 = (dispatch_once_t *)&unk_100341240;
    v5 = &unk_100341238;
    return (__CFString **)sub_1000119B8((uint64_t)v3, v4, (uint64_t)v5);
  }
  if (CFEqual(a1, kSecClassInternetPassword))
  {
    v3 = CFSTR("inet");
    v4 = (dispatch_once_t *)&unk_100341250;
    v5 = &unk_100341248;
    return (__CFString **)sub_1000119B8((uint64_t)v3, v4, (uint64_t)v5);
  }
  if (CFEqual(a1, kSecClassCertificate))
  {
    v3 = CFSTR("cert");
    v4 = (dispatch_once_t *)&unk_100341260;
    v5 = &unk_100341258;
    return (__CFString **)sub_1000119B8((uint64_t)v3, v4, (uint64_t)v5);
  }
  if (CFEqual(a1, kSecClassKey))
  {
    v3 = CFSTR("keys");
    v4 = (dispatch_once_t *)&unk_100341270;
    v5 = &unk_100341268;
    return (__CFString **)sub_1000119B8((uint64_t)v3, v4, (uint64_t)v5);
  }
  if (CFEqual(a1, kSecClassIdentity))
    return &off_1002E3A00;
  else
    return 0;
}

uint64_t sub_1000119B8(uint64_t a1, dispatch_once_t *predicate, uint64_t a3)
{
  _QWORD v5[6];

  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_100132614;
  v5[3] = &unk_1002E7800;
  v5[4] = a3;
  v5[5] = a1;
  if (*predicate != -1)
    dispatch_once(predicate, v5);
  return *(_QWORD *)a3;
}

uint64_t sub_100011A30(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v10;
  uint64_t *v11;
  uint64_t *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD v17[6];
  _QWORD v18[6];
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  char v22;
  uint64_t v23;

  v6 = a4;
  if (a3 && sub_100011C40(a4) != a3)
  {
    v19 = 0;
    v20 = &v19;
    v21 = 0x2000000000;
    v22 = 0;
    if (a1)
    {
      v18[0] = _NSConcreteStackBlock;
      v18[1] = 0x40000000;
      v18[2] = sub_10013836C;
      v18[3] = &unk_1002E7CC0;
      v18[4] = a5;
      v18[5] = &v19;
      v23 = 0;
      sub_100011CD4(a3, 0, &v23, v6);
      v10 = v23;
      if (v23)
      {
        sub_10013836C((uint64_t)v18);
LABEL_16:
        sub_100011F24(v10);
      }
    }
    else
    {
      v17[0] = _NSConcreteStackBlock;
      v17[1] = 0x40000000;
      v17[2] = sub_1001383A0;
      v17[3] = &unk_1002E7CE8;
      v17[4] = a5;
      v17[5] = &v19;
      v23 = 0;
      sub_100011CD4(a3, 1, &v23, v6);
      v10 = v23;
      if (v23)
      {
        sub_1001383A0((uint64_t)v17);
        goto LABEL_16;
      }
    }
    v6 = *((_BYTE *)v20 + 24) != 0;
    _Block_object_dispose(&v19, 8);
    return v6;
  }
  off_100340C18();
  if (*v11)
    return (*(uint64_t (**)(uint64_t))(a5 + 16))(a5);
  v13 = v11;
  v14 = a1 ^ 1;
  if ((v14 & 1) == 0 && a2)
  {
    v15 = sub_100011C40(0);
    sub_10001A338(v15);
  }
  v16 = sub_100011C40(v6);
  if (!v16)
  {
    if (!v6)
      return v6;
    if (!*(_QWORD *)v6)
      sub_100019F20(-25316, (__CFString **)v6, CFSTR("failed to get a db handle"));
    return 0;
  }
  if (!sub_100011CD4(v16, v14, v13, v6))
    return 0;
  v6 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 16))(a5, *v13);
  sub_100011F24(*v13);
  *v13 = 0;
  return v6;
}

uint64_t sub_100011C40(uint64_t a1)
{
  _QWORD block[5];

  if (qword_100341328 != -1)
    dispatch_once(&qword_100341328, &stru_1002E87A8);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_10002291C;
  block[3] = &unk_1002E8808;
  block[4] = a1;
  dispatch_sync((dispatch_queue_t)qword_100341330, block);
  return qword_100341310;
}

BOOL sub_100011CD4(uint64_t a1, int a2, _QWORD *a3, uint64_t a4)
{
  NSObject *v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;
  char v12;
  const void *v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  _BOOL8 v17;
  _QWORD v19[7];
  char v20;
  _QWORD block[11];
  char v22;
  _QWORD v23[2];
  BOOL (*v24)(uint64_t, uint64_t);
  void *v25;
  uint64_t *v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  char v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  char v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;

  CFRetain((CFTypeRef)a1);
  if (a2)
    dispatch_semaphore_wait(*(dispatch_semaphore_t *)(a1 + 120), 0xFFFFFFFFFFFFFFFFLL);
  else
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
  v36 = 0;
  v37 = &v36;
  v38 = 0x2000000000;
  v39 = 0;
  v32 = 0;
  v33 = &v32;
  v34 = 0x2000000000;
  v35 = 1;
  v28 = 0;
  v29 = &v28;
  v30 = 0x2000000000;
  v31 = 0;
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 0x40000000;
  v24 = sub_10000907C;
  v25 = &unk_1002DB498;
  v26 = &v36;
  v27 = a3;
  v8 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100008B98;
  block[3] = &unk_1002DB4C0;
  block[8] = a1;
  block[9] = a3;
  block[10] = a4;
  v22 = a2;
  block[6] = &v28;
  block[7] = &v36;
  block[4] = v23;
  block[5] = &v32;
  dispatch_sync(v8, block);
  v9 = v37;
  if (*((_BYTE *)v33 + 24))
  {
    if (!v37[3])
    {
      v20 = 0;
      v10 = sub_100031600(a1, a2);
      v11 = ((uint64_t (*)(_QWORD *, uint64_t))v24)(v23, v10);
      v9 = v37;
      if (v11)
      {
        v12 = sub_1000316F8(v37[3], (uint64_t)&v20, a4);
        v9 = v37;
        if ((v12 & 1) == 0)
        {
          v13 = (const void *)v37[3];
          if (v13)
          {
            v37[3] = 0;
            CFRelease(v13);
            v9 = v37;
          }
        }
      }
    }
  }
  v14 = v9[3];
  if (v14 && !*((_BYTE *)v29 + 24) && *(_QWORD *)(*(_QWORD *)(v14 + 16) + 136) && !*(_BYTE *)(v14 + 24))
  {
    v16 = *(NSObject **)(a1 + 24);
    v19[0] = _NSConcreteStackBlock;
    v19[1] = 0x40000000;
    v19[2] = sub_100023040;
    v19[3] = &unk_1002DB4E8;
    v19[4] = &v36;
    v19[5] = a1;
    v19[6] = a4;
    dispatch_sync(v16, v19);
    v9 = v37;
  }
  if (a3)
    *a3 = v9[3];
  v15 = v9[3];
  if (!v15)
  {
    if (a2)
      dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 120));
    else
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
    CFRelease((CFTypeRef)a1);
    v15 = v37[3];
  }
  v17 = v15 != 0;
  _Block_object_dispose(&v28, 8);
  _Block_object_dispose(&v32, 8);
  _Block_object_dispose(&v36, 8);
  return v17;
}

void sub_100011F24(uint64_t a1)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  NSObject *v5;
  _QWORD block[6];
  char v7;
  uint8_t buf[16];

  if (a1)
  {
    v2 = *(_QWORD *)(a1 + 16);
    v3 = *(unsigned __int8 *)(a1 + 24);
    v4 = *(NSObject **)(v2 + 24);
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = sub_1000088F0;
    block[3] = &unk_1002DB508;
    block[4] = a1;
    block[5] = v2;
    v7 = v3;
    dispatch_sync(v4, block);
    if (v3)
      dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v2 + 120));
    else
      pthread_mutex_unlock((pthread_mutex_t *)(v2 + 56));
    CFRelease((CFTypeRef)a1);
    CFRelease((CFTypeRef)v2);
  }
  else
  {
    v5 = sub_10000EF14("SecError");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "SecDbConnectionRelease called with NULL dbconn", buf, 2u);
    }
  }
}

void sub_100012018(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3;

  v3 = *(CFTypeRef *)(a1 + 184);
  if (v3 != cf)
  {
    if (!cf || (CFRetain(cf), (v3 = *(CFTypeRef *)(a1 + 184)) != 0))
      CFRelease(v3);
    *(_QWORD *)(a1 + 184) = cf;
  }
}

uint64_t sub_100012060(uint64_t a1, uint64_t a2, CFTypeRef *a3, uint64_t a4, __CFString **a5)
{
  const __CFData *v8;
  const void *v10;
  _BOOL8 v11;
  _QWORD v12[3];
  CFTypeRef cf;
  unint64_t v14;

  v12[0] = a2;
  v12[1] = a4;
  v12[2] = a1;
  cf = 0;
  v8 = *(const __CFData **)(a2 + 80);
  if (v8 && CFDataGetLength(v8) == 16 && *(_QWORD *)(a2 + 32))
    return sub_100019F20(-50, a5, CFSTR("attributes to query illegal; both persistent ref and other attributes can't be searched at the same time"));
  if (*(_QWORD *)(a2 + 240) && *(_QWORD *)(a2 + 32) != 1)
    return sub_100019F20(-50, a5, CFSTR("attributes to query illegal; both token persistent ref and other attributes can't be searched at the same time"));
  v10 = (const void *)kSecAttrTombstone;
  if (!CFDictionaryContainsKey(*(CFDictionaryRef *)(a2 + 8), kSecAttrTombstone))
    sub_100012178(v10, kCFBooleanFalse, a2);
  v14 = 0xAAAAAAAA00000000;
  v11 = sub_100012878((uint64_t)sub_100014080, (uint64_t)v12, a5);
  if (a3 && v11)
  {
    *a3 = cf;
    return 1;
  }
  else if (cf)
  {
    CFRelease(cf);
  }
  return v11;
}

void sub_100012178(const void *a1, const __CFBoolean *a2, uint64_t a3)
{
  CFTypeRef *v6;
  CFTypeRef *v7;
  int v8;
  const void *Value;
  const void *v10;
  const void *v11;
  uint64_t v12;
  const void *v13;
  const void *v14;

  if (CFEqual(a1, kSecAttrDeriveSyncIDFromItemAttributes))
  {
    *(_BYTE *)(a3 + 154) = CFBooleanGetValue(a2) != 0;
  }
  else if (CFEqual(a1, CFSTR("persistref")))
  {
    if (a2)
      CFRetain(a2);
    *(_QWORD *)(a3 + 80) = a2;
  }
  else
  {
    v6 = sub_100012504(*(__CFString ***)a3, a1, (__CFString **)(a3 + 40));
    if (v6)
    {
      v7 = v6;
      sub_1000122D8(v6, a2, a3);
      v8 = *((_DWORD *)v7 + 2);
      if (v8 == 15)
      {
        Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 8), *v7);
        if (Value)
        {
          v10 = (const void *)SecAccessControlCreateFromData(kCFAllocatorDefault, Value, a3 + 40);
          if (v10)
          {
            v11 = v10;
            sub_100018FC0(a3, v10);
            CFRelease(v11);
          }
        }
        v8 = *((_DWORD *)v7 + 2);
      }
      if (v8 == 14)
      {
        v12 = SecAccessControlCreate(kCFAllocatorDefault, a3 + 40);
        if (v12)
        {
          v13 = (const void *)v12;
          v14 = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 8), *v7);
          if (v14 && SecAccessControlSetProtection(v13, v14, a3 + 40))
            sub_100018FC0(a3, v13);
          CFRelease(v13);
        }
      }
    }
  }
}

void sub_1000122D8(_QWORD *a1, const __CFData *a2, uint64_t a3)
{
  __CFString *v6;
  __CFString *Mutable;
  __CFDictionary *v8;
  const __CFData *v9;
  const UInt8 *BytePtr;
  uint64_t Length;
  UInt8 *MutableBytePtr;
  uint64_t v13;
  const void *v14;
  uint64_t v15;

  if (!CFEqual((CFTypeRef)*a1, kSecAttrSynchronizable)
    || (*(_BYTE *)(a3 + 112) = 1, !CFEqual(a2, kSecAttrSynchronizableAny)))
  {
    switch(*((_DWORD *)a1 + 2))
    {
      case 0:
      case 0xF:
        v6 = (__CFString *)sub_1000127F4(a2);
        goto LABEL_11;
      case 1:
        v6 = (__CFString *)sub_10001264C((const __CFString *)a2);
        goto LABEL_11;
      case 2:
      case 0xE:
        v6 = (__CFString *)sub_100013F48((const __CFString *)a2);
        goto LABEL_11;
      case 3:
      case 0xB:
      case 0xC:
        v6 = (__CFString *)sub_100012708(a2);
        goto LABEL_11;
      case 4:
      case 5:
      case 6:
        v6 = (__CFString *)sub_10001A8DC(a2);
        goto LABEL_11;
      case 7:
        v6 = (__CFString *)sub_10001A880(a2);
        goto LABEL_11;
      case 0x10:
        v6 = (__CFString *)sub_10001A920(a2);
LABEL_11:
        Mutable = v6;
        if (!v6)
          goto LABEL_21;
        v8 = *(__CFDictionary **)(a3 + 8);
        if (v8)
        {
          if (*((_DWORD *)a1 + 2) != 7)
            CFDictionarySetValue(v8, (const void *)*a1, Mutable);
        }
        if ((a1[2] & 8) == 0)
          goto LABEL_18;
        v9 = sub_10001264C(Mutable);
        CFRelease(Mutable);
        if (v9)
        {
          Mutable = (__CFString *)CFDataCreateMutable(0, 20);
          CFDataSetLength((CFMutableDataRef)Mutable, 20);
          BytePtr = CFDataGetBytePtr(v9);
          Length = CFDataGetLength(v9);
          MutableBytePtr = CFDataGetMutableBytePtr((CFMutableDataRef)Mutable);
          CCDigest(8, BytePtr, Length, MutableBytePtr);
          CFRelease(v9);
LABEL_18:
          if (*((_DWORD *)a1 + 2) == 15)
          {
            if (!Mutable)
              return;
LABEL_25:
            CFRelease(Mutable);
            return;
          }
          v13 = *(_QWORD *)(a3 + 32);
          if (v13 + 1 < *(_QWORD *)(a3 + 256))
          {
            v14 = (const void *)*a1;
            *(_QWORD *)(a3 + 32) = v13 + 1;
            v15 = a3 + 16 * v13;
            *(_QWORD *)(v15 + 264) = v14;
            *(_QWORD *)(v15 + 272) = Mutable;
            return;
          }
          sub_100019F20(-26276, (__CFString **)(a3 + 40), CFSTR("q_pairs overflow"));
          if (Mutable)
            goto LABEL_25;
        }
        else
        {
          sub_100019F20(-26276, (__CFString **)(a3 + 40), CFSTR("failed to get attribute %@ data"), *a1);
        }
        break;
      default:
LABEL_21:
        sub_100019F20(-50, (__CFString **)(a3 + 40), CFSTR("attribute %@: value: %@ failed to convert"), *a1, a2);
        return;
    }
  }
}

CFTypeRef *sub_100012504(__CFString **a1, const void *a2, __CFString **a3)
{
  uint64_t v5;
  uint64_t v6;
  CFTypeID v7;
  CFTypeRef *v8;
  CFTypeRef **v9;
  CFTypeRef *v10;

  while (a1 == &off_1002E3A00)
  {
    v5 = sub_1000119B8((uint64_t)CFSTR("cert"), &qword_100341260, (uint64_t)&unk_100341258);
    v6 = sub_100012504(v5, a2, 0);
    if (v6)
      return (CFTypeRef *)v6;
    a1 = (__CFString **)sub_1000119B8((uint64_t)CFSTR("keys"), &qword_100341270, (uint64_t)&unk_100341268);
  }
  if (!a2)
    goto LABEL_11;
  v7 = CFGetTypeID(a2);
  if (v7 != CFStringGetTypeID())
    goto LABEL_11;
  v8 = (CFTypeRef *)a1[2];
  if (!v8)
  {
LABEL_10:
    if (CFEqual(kSecUseDataProtectionKeychain, a2))
      return 0;
LABEL_11:
    sub_100019F20(-25303, a3, CFSTR("attribute %@ not found in class %@"), a2, *a1);
    return 0;
  }
  v9 = (CFTypeRef **)(a1 + 3);
  while (!CFEqual(*v8, a2))
  {
    v10 = *v9++;
    v8 = v10;
    if (!v10)
      goto LABEL_10;
  }
  return v8;
}

CFDataRef sub_10001264C(const __CFString *a1)
{
  CFTypeID v2;
  int valuePtr;

  v2 = CFGetTypeID(a1);
  if (v2 == CFDataGetTypeID())
    return CFDataCreateCopy(0, (CFDataRef)a1);
  if (v2 == CFStringGetTypeID())
    return CFStringCreateExternalRepresentation(0, a1, 0x8000100u, 0);
  if (v2 != CFNumberGetTypeID())
    return 0;
  valuePtr = -1431655766;
  CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt32Type, &valuePtr);
  return CFDataCreate(0, (const UInt8 *)&valuePtr, 4);
}

CFNumberRef sub_100012708(const __CFBoolean *a1)
{
  const __CFBoolean *v1;
  CFTypeID v2;
  char *p_valuePtr;
  CFStringRef v4;
  int v5;
  uint64_t valuePtr;

  v1 = a1;
  v2 = CFGetTypeID(a1);
  if (v2 != CFNumberGetTypeID())
  {
    if (v2 == CFBooleanGetTypeID())
    {
      HIDWORD(valuePtr) = CFBooleanGetValue(v1);
      p_valuePtr = (char *)&valuePtr + 4;
    }
    else
    {
      if (v2 != CFStringGetTypeID())
        return 0;
      LODWORD(valuePtr) = CFStringGetIntValue((CFStringRef)v1);
      v4 = CFStringCreateWithFormat(0, 0, CFSTR("%ld"), (int)valuePtr, valuePtr);
      v5 = CFEqual(v4, v1);
      CFRelease(v4);
      if (!v5)
        return (CFNumberRef)CFStringCreateCopy(0, (CFStringRef)v1);
      p_valuePtr = (char *)&valuePtr;
    }
    return CFNumberCreate(0, kCFNumberSInt32Type, p_valuePtr);
  }
  CFRetain(v1);
  return v1;
}

CFStringRef sub_1000127F4(const __CFData *a1)
{
  const __CFData *v1;
  CFTypeID v2;

  v1 = a1;
  v2 = CFGetTypeID(a1);
  if (v2 == CFDataGetTypeID())
    return (CFStringRef)CFDataCreateCopy(0, v1);
  if (v2 == CFStringGetTypeID())
    return CFStringCreateCopy(0, (CFStringRef)v1);
  if (v2 != CFNumberGetTypeID())
    return 0;
  CFRetain(v1);
  return (CFStringRef)v1;
}

BOOL sub_100012878(uint64_t a1, uint64_t a2, __CFString **a3)
{
  uint64_t v4;
  uint64_t v8;
  const __CFArray *v9;
  CFMutableArrayRef Mutable;
  __CFString *v11;
  int v12;
  _BOOL8 v13;
  _QWORD v14[11];

  v4 = *(_QWORD *)a2;
  if (*(_QWORD *)(*(_QWORD *)a2 + 64))
    return sub_100019F20(-50, a3, CFSTR("value ref not supported by queries"));
  v9 = *(const __CFArray **)(a2 + 8);
  v8 = *(_QWORD *)(a2 + 16);
  if (*(_QWORD *)(v4 + 104) == 1)
    Mutable = 0;
  else
    Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  *(_QWORD *)(a2 + 24) = Mutable;
  v11 = sub_100012D6C(v4, v9);
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000;
  v14[2] = sub_100013CE0;
  v14[3] = &unk_1002DFB20;
  v14[4] = v4;
  v14[5] = v9;
  v14[6] = a3;
  v14[7] = v8;
  v14[8] = a1;
  v14[9] = a2;
  v14[10] = a2;
  v12 = sub_1000129F0(v8, v11, (CFTypeRef *)a3, (uint64_t)v14);
  CFRelease(v11);
  v13 = 0;
  if (sub_100011460(v4, (CFErrorRef *)a3) && v12)
  {
    if (*(_DWORD *)(a2 + 32))
    {
      return 1;
    }
    else
    {
      v13 = sub_100019F20(-25300, a3, CFSTR("no matching items found"));
      if (*(_BYTE *)(v4 + 200))
        sub_1000345CC(CFSTR("ItemNotFound"), 0x53C00008u);
    }
  }
  return v13;
}

unint64_t sub_1000129F0(uint64_t a1, const __CFString *cf, CFTypeRef *a3, uint64_t a4)
{
  const __CFString *v6;
  unint64_t v8;
  int v9;
  CFStringRef v11;

  v6 = cf;
  CFRetain(cf);
  v8 = 1;
  if (v6)
  {
    do
    {
      v11 = 0;
      if ((v8 & 1) != 0)
      {
        v8 = (unint64_t)sub_100012AE8(a1, v6, &v11, a3);
        if (v8)
        {
          if (a4)
            v9 = (*(uint64_t (**)(uint64_t, unint64_t))(a4 + 16))(a4, v8);
          else
            v9 = sub_100019F20(-50, (__CFString **)a3, CFSTR("SecDbWithSQL perform block missing"));
          v8 = v9 & sub_100012D08((sqlite3_stmt *)v8, a3);
        }
      }
      else
      {
        sub_10003060C(1, a3, CFSTR("Error with unexecuted sql remaining %@"), v6);
        v8 = 0;
      }
      CFRelease(v6);
      v6 = v11;
    }
    while (v11);
  }
  return v8;
}

sqlite3_stmt *sub_100012AE8(uint64_t a1, const __CFString *a2, CFStringRef *a3, CFTypeRef *a4)
{
  sqlite3_stmt *v7;
  const __CFAllocator *v8;
  CFStringRef v9;
  CFStringRef v10;
  CFRange v12;
  _QWORD v13[8];
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;

  v12.location = 0;
  v12.length = 0;
  v14 = 0;
  v15 = &v14;
  v16 = 0x2000000000;
  v17 = 0;
  if (a2)
  {
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000;
    v13[2] = sub_100012C0C;
    v13[3] = &unk_1002DB770;
    v13[4] = &v14;
    v13[5] = a1;
    v13[6] = a4;
    v13[7] = &v12;
    sub_1000137F8(a2, (uint64_t)v13);
    v7 = (sqlite3_stmt *)v15[3];
  }
  else
  {
    v7 = 0;
  }
  _Block_object_dispose(&v14, 8);
  if (v12.length >= 1)
  {
    v8 = CFGetAllocator(a2);
    v9 = CFStringCreateWithSubstring(v8, a2, v12);
    v10 = v9;
    if (a3)
    {
      *a3 = v9;
    }
    else
    {
      sub_10003060C(2, a4, CFSTR("prepare_v2: %@ unused sql: %@"), a2, v9);
      if (v10)
        CFRelease(v10);
      sub_100012D08(v7, a4);
      return 0;
    }
  }
  return v7;
}

uint64_t sub_100012C0C(_QWORD *a1, char *zSql, unint64_t nByte)
{
  CFTypeRef *v6;
  uint64_t v7;
  sqlite3 *v8;
  uint64_t result;
  sqlite3_stmt *v10;
  int i;
  _QWORD *v12;
  uint64_t v13;
  char *v15;
  sqlite3_stmt *ppStmt;

  v15 = 0;
  v7 = a1[5];
  v6 = (CFTypeRef *)a1[6];
  v8 = *(sqlite3 **)(v7 + 64);
  if (nByte >> 31)
  {
    result = sub_100030654(18, *(sqlite3 **)(v7 + 64), v6, CFSTR("prepare_v2: sql bigger than INT_MAX"));
LABEL_3:
    v10 = 0;
  }
  else
  {
    for (i = 0; ; ++i)
    {
      ppStmt = 0;
      result = sqlite3_prepare_v2(v8, zSql, nByte, &ppStmt, (const char **)&v15);
      if (!(_DWORD)result)
        break;
      result = sub_100030AE8(v7, result, (uint64_t)CFSTR("preparev2"), i, v6);
      if ((result & 1) == 0)
        goto LABEL_3;
    }
    v10 = ppStmt;
  }
  *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = v10;
  v12 = (_QWORD *)a1[7];
  if (v12)
  {
    v13 = v15 - zSql;
    if (v15 > zSql && v15 < &zSql[nByte])
    {
      *v12 = v13;
      v12[1] = nByte - v13;
    }
  }
  return result;
}

BOOL sub_100012D08(sqlite3_stmt *a1, CFTypeRef *a2)
{
  sqlite3 *v4;
  uint64_t v5;

  v4 = sqlite3_db_handle(a1);
  v5 = sqlite3_finalize(a1);
  return !(_DWORD)v5 || sub_100030654(v5, v4, a2, CFSTR("finalize: %p"), a1);
}

__CFString *sub_100012D6C(uint64_t a1, const __CFArray *a2)
{
  __CFString *Mutable;
  const __CFData *v5;
  const __CFString *v6;
  const __CFString *v7;
  const __CFData *v8;
  char v10;

  Mutable = CFStringCreateMutable(0, 0);
  v5 = *(const __CFData **)(a1 + 80);
  if (*(__CFString ***)a1 == &off_1002E3A00)
  {
    if (v5 && CFDataGetLength(v5) == 16)
      v7 = CFSTR("SELECT crowid, certdata, certpersistref, rowid, data, persistref FROM (SELECT cert.rowid AS crowid, cert.labl AS labl, cert.issr AS issr, cert.slnr AS slnr, cert.skid AS skid, cert.tkid AS tkid, keys.*,cert.data AS certdata, cert.persistref AS certpersistref FROM keys, cert WHERE keys.priv == 1 AND cert.pkhh == keys.klbl");
    else
      v7 = CFSTR("SELECT crowid, certdata, rowid, data FROM (SELECT cert.rowid AS crowid, cert.labl AS labl, cert.issr AS issr, cert.slnr AS slnr, cert.skid AS skid, cert.tkid AS tkid, keys.*,cert.data AS certdata FROM keys, cert WHERE keys.priv == 1 AND cert.pkhh == keys.klbl");
    CFStringAppend(Mutable, v7);
    sub_100013218(Mutable, CFSTR("cert.agrp"), a2, 0);
    sub_10001302C(Mutable, (uint64_t)CFSTR("crowid"), *(_QWORD *)(a1 + 72), 0);
    CFStringAppend(Mutable, CFSTR(")"));
    v10 = 1;
    sub_100013100(Mutable, a1, &v10);
    sub_100013088(Mutable, a1, &v10);
    v8 = *(const __CFData **)(a1 + 80);
    if (v8 && CFDataGetLength(v8) == 16)
    {
      sub_100013190(Mutable, &v10);
      CFStringAppend(Mutable, CFSTR("certpersistref = ?"));
    }
    sub_100013218(Mutable, CFSTR("agrp"), a2, &v10);
    sub_1000131DC(Mutable, *(_BYTE *)(a1 + 153), &v10);
  }
  else
  {
    if (v5 && CFDataGetLength(v5) == 16)
    {
      v6 = CFSTR("SELECT rowid, data, agrp, persistref FROM ");
    }
    else if ((*(_BYTE *)(a1 + 48) & 8) != 0)
    {
      v6 = CFSTR("SELECT rowid, data, agrp, persistref FROM ");
    }
    else
    {
      v6 = CFSTR("SELECT rowid, data, agrp FROM ");
    }
    CFStringAppend(Mutable, v6);
    CFStringAppend(Mutable, **(CFStringRef **)a1);
    sub_100012F64(Mutable, a1, a2);
  }
  if (!*(_QWORD *)(a1 + 176)
    && !*(_QWORD *)(a1 + 208)
    && !*(_QWORD *)(a1 + 216)
    && !*(_QWORD *)(a1 + 232)
    && !*(_QWORD *)(a1 + 240)
    && *(_QWORD *)(a1 + 104) != -1)
  {
    CFStringAppendFormat(Mutable, 0, CFSTR(" LIMIT %ld"), *(_QWORD *)(a1 + 104));
  }
  return Mutable;
}

void sub_100012F64(__CFString *a1, uint64_t a2, const __CFArray *a3)
{
  const __CFData *v6;
  char v7;

  v7 = 1;
  sub_10001302C(a1, (uint64_t)CFSTR("ROWID"), *(_QWORD *)(a2 + 72), &v7);
  sub_100013100(a1, a2, &v7);
  sub_100013088(a1, a2, &v7);
  v6 = *(const __CFData **)(a2 + 80);
  if (v6 && CFDataGetLength(v6) == 16)
  {
    sub_100013190(a1, &v7);
    CFStringAppend(a1, CFSTR("persistref = ?"));
  }
  sub_100013218(a1, CFSTR("agrp"), a3, &v7);
  sub_1000131DC(a1, *(_BYTE *)(a2 + 153), &v7);
}

void sub_10001302C(__CFString *a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  if (a3 >= 1)
  {
    sub_100013190(a1, a4);
    CFStringAppendFormat(a1, 0, CFSTR("%@=%lld"), a2, a3);
  }
}

void sub_100013088(__CFString *a1, uint64_t a2, _BYTE *a3)
{
  const __CFString *v5;
  const void *v6;

  sub_100013190(a1, a3);
  if ((sub_100013B14(*(const __CFData **)(a2 + 128), 0) & 1) != 0)
  {
    v5 = CFSTR("(musr = ? OR musr = ?)");
  }
  else
  {
    if (sub_100013AB8(*(CFTypeRef *)(a2 + 128)))
      return;
    v6 = *(const void **)(a2 + 128);
    if (v6)
    {
      CFGetTypeID(v6);
      CFNullGetTypeID();
    }
    v5 = CFSTR("musr = ?");
  }
  CFStringAppend(a1, v5);
}

void sub_100013100(__CFString *a1, uint64_t a2, _BYTE *a3)
{
  uint64_t v3;
  const __CFString **v6;
  const __CFString *v7;

  v3 = *(_QWORD *)(a2 + 32);
  if (v3 >= 1)
  {
    v6 = (const __CFString **)(a2 + 264);
    do
    {
      v7 = *v6;
      v6 += 2;
      sub_100013150(a1, v7, a3);
      --v3;
    }
    while (v3);
  }
}

void sub_100013150(__CFString *a1, const __CFString *a2, _BYTE *a3)
{
  sub_100013190(a1, a3);
  CFStringAppend(a1, a2);
  CFStringAppend(a1, CFSTR("=?"));
}

void sub_100013190(__CFString *a1, _BYTE *a2)
{
  if (a2 && *a2)
  {
    CFStringAppend(a1, CFSTR(" WHERE "));
    *a2 = 0;
  }
  else
  {
    CFStringAppend(a1, CFSTR(" AND "));
  }
}

void sub_1000131DC(__CFString *a1, char a2, _BYTE *a3)
{
  if (a2)
  {
    sub_100013190(a1, a3);
    CFStringAppend(a1, CFSTR("clip = 0"));
  }
}

void sub_100013218(__CFString *a1, const __CFString *a2, CFArrayRef theArray, _BYTE *a4)
{
  CFIndex Count;
  uint64_t v8;
  uint64_t v9;

  if (theArray)
  {
    Count = CFArrayGetCount(theArray);
    if (Count)
    {
      v8 = Count;
      sub_100013190(a1, a4);
      CFStringAppend(a1, a2);
      CFStringAppend(a1, CFSTR(" IN (?"));
      if (v8 >= 2)
      {
        v9 = v8 - 1;
        do
        {
          CFStringAppend(a1, CFSTR(",?"));
          --v9;
        }
        while (v9);
      }
      CFStringAppend(a1, CFSTR(")"));
    }
  }
}

uint64_t sub_1000132C4(sqlite3_stmt *a1, uint64_t a2, const __CFArray *a3, _DWORD *a4, CFTypeRef *a5)
{
  uint64_t v10;
  uint64_t v11;
  const __CFString **v12;
  uint64_t v13;
  const __CFString *v14;
  uint64_t v15;
  const __CFString *v16;
  int v17;
  char v18;
  const void *v19;
  CFTypeID v20;
  const __CFString *v21;
  uint64_t result;
  char v23;
  const __CFData *v24;
  unsigned int v25;
  UInt8 bytes[8];
  int v27;
  unsigned int v28;

  v10 = *a4;
  v11 = *(_QWORD *)(a2 + 32);
  if (v11 >= 1)
  {
    v12 = (const __CFString **)(a2 + 272);
    do
    {
      v13 = v10;
      v10 = (v10 + 1);
      v14 = *v12;
      v12 += 2;
      if ((sub_100013544(a1, v13, v14, a5) & 1) == 0)
        goto LABEL_20;
    }
    while (--v11);
  }
  v25 = -1431655766;
  if (!sub_100013B14(*(const __CFData **)(a2 + 128), &v25))
  {
    if (sub_100013AB8(*(CFTypeRef *)(a2 + 128)))
    {
      *(_DWORD *)bytes = v10;
      goto LABEL_25;
    }
    v19 = *(const void **)(a2 + 128);
    if (v19)
    {
      v20 = CFGetTypeID(v19);
      if (v20 == CFNullGetTypeID())
      {
        if (qword_100341188 != -1)
          dispatch_once(&qword_100341188, &stru_1002DED08);
        v21 = (const __CFString *)qword_100341190;
      }
      else
      {
        v21 = *(const __CFString **)(a2 + 128);
      }
    }
    else
    {
      v21 = 0;
    }
    LODWORD(v15) = v10 + 1;
    v23 = sub_100013544(a1, v10, v21, a5);
    *(_DWORD *)bytes = v10 + 1;
    if ((v23 & 1) != 0)
    {
      v10 = (v10 + 1);
      goto LABEL_25;
    }
LABEL_29:
    result = 0;
    LODWORD(v10) = v15;
    goto LABEL_30;
  }
  if (qword_100341178 != -1)
    dispatch_once(&qword_100341178, &stru_1002DECC8);
  v15 = (v10 + 1);
  if ((sub_100013544(a1, v10, (const __CFString *)qword_100341180, a5) & 1) == 0)
    goto LABEL_29;
  *(_QWORD *)bytes = 0x104B57A5353A5AA7;
  v27 = -1803342146;
  v28 = bswap32(v25);
  v16 = (const __CFString *)CFDataCreate(0, bytes, 16);
  v10 = (v10 + 2);
  v17 = sub_100013544(a1, v15, v16, a5);
  v18 = v17;
  if (v16)
  {
    CFRelease(v16);
    *(_DWORD *)bytes = v10;
    if ((v18 & 1) != 0)
      goto LABEL_25;
LABEL_20:
    result = 0;
    goto LABEL_30;
  }
  *(_DWORD *)bytes = v10;
  if (!v17)
    goto LABEL_20;
LABEL_25:
  v24 = *(const __CFData **)(a2 + 80);
  if (v24
    && CFDataGetLength(v24) == 16
    && (result = sub_100013544(a1, v10, *(const __CFString **)(a2 + 80), a5), *(_DWORD *)bytes = v10 + 1,
                                                                              !(_DWORD)result))
  {
    LODWORD(v10) = v10 + 1;
  }
  else
  {
    result = sub_100013C1C(a1, a3, (int *)bytes, a5);
    LODWORD(v10) = *(_DWORD *)bytes;
  }
LABEL_30:
  *a4 = v10;
  return result;
}

uint64_t sub_100013544(sqlite3_stmt *a1, uint64_t a2, const __CFString *cf, CFTypeRef *a4)
{
  uint64_t *v4;
  CFTypeID v9;
  uint64_t v10;
  CFIndex Length;
  unint64_t v13;
  const UInt8 *BytePtr;
  BOOL v15;
  double AbsoluteTime;
  uint64_t v17;
  int Value;
  uint64_t v19;
  int v20;
  BOOL v21;
  CFStringRef v22;
  double valuePtr;
  _QWORD v24[7];
  int v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  char v29;

  v4 = &v26;
  v26 = 0;
  v27 = &v26;
  v28 = 0x2000000000;
  v29 = 0;
  if (!cf)
    goto LABEL_4;
  v9 = CFGetTypeID(cf);
  if (v9 == CFNullGetTypeID())
  {
    v4 = v27;
LABEL_4:
    *((_BYTE *)v4 + 24) = 1;
    goto LABEL_5;
  }
  if (v9 == CFStringGetTypeID())
  {
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 0x40000000;
    v24[2] = sub_1000138EC;
    v24[3] = &unk_1002DB558;
    v24[4] = &v26;
    v24[5] = a1;
    v25 = a2;
    v24[6] = a4;
    sub_1000137F8(cf, (uint64_t)v24);
    goto LABEL_5;
  }
  if (v9 == CFDataGetTypeID())
  {
    Length = CFDataGetLength((CFDataRef)cf);
    if (Length)
    {
      v13 = Length;
      BytePtr = CFDataGetBytePtr((CFDataRef)cf);
      v15 = sub_100013BA4(a1, a2, BytePtr, v13, a4);
    }
    else
    {
      v19 = sqlite3_bind_text(a1, a2, "", 0, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
      v15 = sub_100013978(v19, a1, a4, CFSTR("bind_text[%d]"), a2);
    }
    goto LABEL_16;
  }
  if (v9 == CFDateGetTypeID())
  {
    AbsoluteTime = CFDateGetAbsoluteTime((CFDateRef)cf);
    v17 = sqlite3_bind_double(a1, a2, AbsoluteTime);
    v15 = sub_100013978(v17, a1, a4, CFSTR("bind_double[%d]"), a2);
LABEL_16:
    *((_BYTE *)v27 + 24) = v15;
    goto LABEL_5;
  }
  if (v9 == CFBooleanGetTypeID())
  {
    Value = CFBooleanGetValue((CFBooleanRef)cf);
    v15 = sub_10003221C(a1, a2, Value, a4);
    goto LABEL_16;
  }
  if (v9 == CFNumberGetTypeID())
  {
    if (CFNumberIsFloatType((CFNumberRef)cf))
    {
      valuePtr = NAN;
      v20 = CFNumberGetValue((CFNumberRef)cf, kCFNumberDoubleType, &valuePtr);
      v21 = sub_1000321CC(a1, a2, a4, valuePtr);
    }
    else
    {
      valuePtr = -3.72066208e-103;
      v20 = CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt64Type, &valuePtr);
      if (!v20)
        goto LABEL_26;
      v21 = sub_100013A68(a1, a2, *(sqlite3_int64 *)&valuePtr, a4);
    }
    *((_BYTE *)v27 + 24) = v21;
LABEL_26:
    if (!v20)
    {
      sub_10003060C(2, a4, CFSTR("bind CFNumberGetValue failed for %@"), cf);
      *((_BYTE *)v27 + 24) = 0;
    }
    goto LABEL_5;
  }
  if (a4)
  {
    v22 = CFCopyTypeIDDescription(v9);
    sub_10003060C(20, a4, CFSTR("bind unsupported type %@"), v22);
    if (v22)
      CFRelease(v22);
  }
LABEL_5:
  v10 = *((unsigned __int8 *)v27 + 24);
  _Block_object_dispose(&v26, 8);
  return v10;
}

void sub_1000137F8(const __CFString *a1, uint64_t a2)
{
  const char *CStringPtr;
  const char *v5;
  size_t v6;
  CFIndex Length;
  _QWORD v8[9];
  CFIndex usedBufLen;
  CFRange v10;

  CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
  if (CStringPtr)
  {
    v5 = CStringPtr;
    v6 = strlen(CStringPtr);
    (*(void (**)(uint64_t, const char *, size_t))(a2 + 16))(a2, v5, v6);
  }
  else
  {
    usedBufLen = 0;
    Length = CFStringGetLength(a1);
    v10.location = 0;
    v10.length = Length;
    CFStringGetBytes(a1, v10, 0x8000100u, 0, 0, 0, 0, &usedBufLen);
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 0x40000000;
    v8[2] = sub_100018F4C;
    v8[3] = &unk_1002DB148;
    v8[6] = 0;
    v8[7] = Length;
    v8[8] = usedBufLen;
    v8[4] = a2;
    v8[5] = a1;
    sub_100018DF8(usedBufLen + 1, (uint64_t)v8);
  }
}

BOOL sub_1000138EC(uint64_t a1, char *a2, unint64_t a3)
{
  uint64_t v4;
  CFTypeRef *v5;
  sqlite3_stmt *v6;
  _BOOL8 result;
  uint64_t v8;

  v4 = *(unsigned int *)(a1 + 56);
  v6 = *(sqlite3_stmt **)(a1 + 40);
  v5 = *(CFTypeRef **)(a1 + 48);
  if (a3 >> 31)
  {
    result = sub_100013978(18, v6, v5, CFSTR("bind_text[%d]: text bigger than INT_MAX"), *(unsigned int *)(a1 + 56));
  }
  else
  {
    v8 = sqlite3_bind_text(*(sqlite3_stmt **)(a1 + 40), v4, a2, a3, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
    result = sub_100013978(v8, v6, v5, CFSTR("bind_text[%d]"), v4);
  }
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

BOOL sub_100013978(uint64_t a1, sqlite3_stmt *a2, CFTypeRef *a3, CFStringRef format, ...)
{
  CFStringRef v7;
  sqlite3 *v8;
  const char *v9;
  uint64_t v10;
  const char *v11;
  uint64_t v13;
  va_list va;

  va_start(va, format);
  if ((_DWORD)a1 && a3)
  {
    v7 = CFStringCreateWithFormatAndArguments(kCFAllocatorDefault, 0, format, va);
    v8 = sqlite3_db_handle(a2);
    v9 = sqlite3_sql(a2);
    v10 = sqlite3_extended_errcode(v8);
    v11 = sqlite3_errmsg(v8);
    if ((_DWORD)v10 == (_DWORD)a1)
      sub_10003060C(a1, a3, CFSTR("%@: [%d] %s sql: %s"), v7, a1, v11, v9, v13, va);
    else
      sub_10003060C(a1, a3, CFSTR("%@: [%d->%d] %s sql: %s"), v7, a1, v10, v11, v9, va);
    if (v7)
      CFRelease(v7);
  }
  return (_DWORD)a1 == 0;
}

BOOL sub_100013A68(sqlite3_stmt *a1, uint64_t a2, sqlite3_int64 a3, CFTypeRef *a4)
{
  uint64_t v7;

  v7 = sqlite3_bind_int64(a1, a2, a3);
  return sub_100013978(v7, a1, a4, CFSTR("bind_int64[%d]"), a2);
}

BOOL sub_100013AB8(CFTypeRef cf1)
{
  if (qword_100341198 != -1)
    dispatch_once(&qword_100341198, &stru_1002DED48);
  return CFEqual(cf1, (CFTypeRef)qword_1003411A0) != 0;
}

uint64_t sub_100013B14(const __CFData *a1, _DWORD *a2)
{
  const UInt8 *BytePtr;
  _BOOL8 v5;

  if (CFDataGetLength(a1) != 16)
    return 0;
  BytePtr = CFDataGetBytePtr(a1);
  v5 = (*(_QWORD *)BytePtr ^ 0x9A460A992EBEC436 | *((unsigned int *)BytePtr + 2) ^ 0xA40989ACLL) == 0;
  if (a2 && !(*(_QWORD *)BytePtr ^ 0x9A460A992EBEC436 | *((unsigned int *)BytePtr + 2) ^ 0xA40989ACLL))
  {
    *a2 = bswap32(*((_DWORD *)BytePtr + 3));
    return 1;
  }
  return v5;
}

BOOL sub_100013BA4(sqlite3_stmt *a1, uint64_t a2, const void *a3, unint64_t a4, CFTypeRef *a5)
{
  uint64_t v9;

  if (a4 >> 31)
    return sub_100013978(18, a1, a5, CFSTR("bind_blob[%d]: blob bigger than INT_MAX"), a2);
  v9 = sqlite3_bind_blob(a1, a2, a3, a4, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
  return sub_100013978(v9, a1, a5, CFSTR("bind_blob[%d]"), a2);
}

BOOL sub_100013C1C(sqlite3_stmt *a1, CFArrayRef theArray, int *a3, CFTypeRef *a4)
{
  int v5;
  CFIndex Count;
  CFIndex v10;
  BOOL v11;
  CFIndex v12;
  CFIndex v13;
  uint64_t v14;
  const __CFString *ValueAtIndex;

  v5 = *a3;
  if (theArray && (Count = CFArrayGetCount(theArray), Count >= 1))
  {
    v10 = Count;
    v11 = 0;
    v12 = 0;
    do
    {
      v13 = v12;
      v14 = (v5 + v12);
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v12);
      if ((sub_100013544(a1, v14, ValueAtIndex, a4) & 1) == 0)
        break;
      v12 = v13 + 1;
      v11 = v13 + 1 >= v10;
    }
    while (v10 != v13 + 1);
    v5 += v13 + 1;
  }
  else
  {
    v11 = 1;
  }
  *a3 = v5;
  return v11;
}

uint64_t sub_100013CE0(uint64_t a1, sqlite3_stmt *a2)
{
  __CFString ***v4;
  uint64_t result;
  uint64_t v6;
  CFTypeRef *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[9];
  int v11;

  v11 = 1;
  v4 = *(__CFString ****)(a1 + 32);
  if (*v4 == &off_1002E3A00)
  {
    result = sub_100013C1C(a2, *(CFArrayRef *)(a1 + 40), &v11, *(CFTypeRef **)(a1 + 48));
    if (!(_DWORD)result)
      return result;
    v4 = *(__CFString ****)(a1 + 32);
  }
  result = sub_1000132C4(a2, (uint64_t)v4, *(const __CFArray **)(a1 + 40), &v11, *(CFTypeRef **)(a1 + 48));
  if ((_DWORD)result)
  {
    v7 = *(CFTypeRef **)(a1 + 48);
    v6 = *(_QWORD *)(a1 + 56);
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 0x40000000;
    v10[2] = sub_100013FD8;
    v10[3] = &unk_1002DFB00;
    v8 = *(_QWORD *)(a1 + 72);
    v10[4] = *(_QWORD *)(a1 + 64);
    v10[5] = a2;
    v9 = *(_QWORD *)(a1 + 32);
    v10[6] = v8;
    v10[7] = v9;
    v10[8] = *(_QWORD *)(a1 + 80);
    sub_100013DC0(v6, a2, v7, (uint64_t)v10);
    return 1;
  }
  return result;
}

uint64_t sub_100013DAC(uint64_t a1, uint64_t a2)
{
  return sub_100012060(a2, *(_QWORD *)(a1 + 32), *(CFTypeRef **)(a1 + 40), *(_QWORD *)(a1 + 48), *(__CFString ***)(a1 + 56));
}

uint64_t sub_100013DC0(uint64_t a1, sqlite3_stmt *pStmt, CFTypeRef *a3, uint64_t a4)
{
  uint64_t i;
  NSObject *v9;
  const char *v10;
  uint64_t v11;
  const char *v12;
  uint8_t buf[4];
  const char *v15;

  for (i = 0; ; i = (i + 1))
  {
    if (*(_BYTE *)(a1 + 24) && !sqlite3_stmt_readonly(pStmt))
    {
      v9 = sub_10000EF14("SecError");
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        v10 = sqlite3_sql(pStmt);
        *(_DWORD *)buf = 136315138;
        v15 = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "SecDbForEach: SecDbConnection is readonly but we're about to write: %s", buf, 0xCu);
      }
    }
    v11 = sqlite3_step(pStmt);
    if ((_DWORD)v11 != 100)
      break;
    if (a4)
    {
      if (((*(uint64_t (**)(uint64_t, uint64_t))(a4 + 16))(a4, i) & 1) == 0)
        return 0;
    }
    else
    {
      v12 = sqlite3_sql(pStmt);
      sub_10003060C(100, a3, CFSTR("step[%d]: %s returned SQLITE_ROW with NULL row block"), i, v12);
    }
  }
  if ((_DWORD)v11 == 101)
    return 1;
  sub_100030C9C(a1, v11, a3, CFSTR("SecDbForEach step[%d]"), i);
  return 0;
}

CFStringRef sub_100013F48(const __CFString *a1)
{
  CFTypeID v2;

  v2 = CFGetTypeID(a1);
  if (v2 == CFStringGetTypeID())
    return CFStringCreateCopy(0, a1);
  if (v2 == CFDataGetTypeID())
    return CFStringCreateFromExternalRepresentation(0, (CFDataRef)a1, 0x8000100u);
  if (v2 == CFUUIDGetTypeID())
    return CFUUIDCreateString(0, (CFUUIDRef)a1);
  return 0;
}

uint64_t sub_100013FD8(uint64_t a1)
{
  uint64_t v2;
  __CFError *v3;
  CFIndex Code;
  _BOOL4 v5;
  BOOL v6;
  const void *v7;
  uint64_t v8;

  (*(void (**)(_QWORD, _QWORD))(a1 + 32))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48));
  v2 = *(_QWORD *)(a1 + 56);
  v3 = *(__CFError **)(v2 + 40);
  if (v3)
  {
    Code = CFErrorGetCode(v3);
    v5 = Code == -25330;
    v2 = *(_QWORD *)(a1 + 56);
    if (*(_BYTE *)(v2 + 152))
      v6 = Code == -25330;
    else
      v6 = 0;
    if (v6)
    {
      v7 = *(const void **)(v2 + 40);
      if (v7)
      {
        *(_QWORD *)(v2 + 40) = 0;
        CFRelease(v7);
        v2 = *(_QWORD *)(a1 + 56);
      }
      v5 = 1;
    }
  }
  else
  {
    v5 = 0;
  }
  v8 = *(_QWORD *)(v2 + 104);
  if (v8 != -1 && v8 <= *(int *)(*(_QWORD *)(a1 + 64) + 32))
    return 0;
  if (*(_QWORD *)(v2 + 40))
    return v5;
  return 1;
}

void sub_100014080(sqlite3_stmt *a1, uint64_t a2)
{
  const void ***v4;
  int v5;
  sqlite3_int64 v6;
  CFDictionaryRef *v7;
  int v8;
  CFDictionaryRef v9;
  const void **v10;
  const void *Value;
  const __CFData *v12;
  const __CFArray *v13;
  sqlite3_stmt *v14;
  uint64_t v15;
  int v16;
  int OSStatus;
  int v18;
  NSObject *v19;
  const void *v20;
  const void **v21;
  CFStringRef Copy;
  const void *v23;
  const void *v24;
  const __CFData *v25;
  __CFString *Mutable;
  const UInt8 *BytePtr;
  CFIndex Length;
  unint64_t v29;
  unsigned int v30;
  const void *v31;
  const void *v32;
  const __CFString *v33;
  const __CFString *v34;
  CFTypeID v35;
  const __CFData *v36;
  __CFDictionary *v37;
  void *v38;
  int v39;
  const void *v40;
  uint64_t UUIDBasedPersistentRef;
  NSObject *v42;
  const void *v43;
  const void **v44;
  const char *v45;
  NSObject *v46;
  NSObject *v47;
  const void *v48;
  const void **v49;
  NSObject *v50;
  CFDataRef PersistentRef;
  NSObject *v52;
  CFDictionaryRef v53;
  uint64_t i;
  NSObject *v55;
  uint64_t (**v56)(const void *, const void *, _BYTE *);
  const void *v57;
  const void **v58;
  uint64_t (**v59)(const void *, const void *, _BYTE *);
  const void *v60;
  const void *v61;
  CFDictionaryRef theDict;
  _BYTE buf[24];
  __int128 v64;
  CFStringRef v65;
  sqlite3_int64 v66;

  v4 = *(const void ****)a2;
  v5 = *(_DWORD *)(*(_QWORD *)a2 + 48);
  v6 = sqlite3_column_int64(a1, 0);
  theDict = 0;
  v7 = (CFDictionaryRef *)(v4 + 5);
  while ((sub_100014B3C(a1, (uint64_t)v4, 1, *(const __CFArray **)(a2 + 8), &theDict, 0, 0, (__CFString **)v4 + 5) & 1) != 0)
  {
    if (!theDict)
    {
      *((_DWORD *)v4 + 12) = v5;
      return;
    }
    if (!CFDictionaryContainsKey(theDict, kSecAttrTokenID) || (v8 = *((_DWORD *)v4 + 12), (v8 & 1) != 0))
    {
      v10 = v4[30];
      if (v10)
      {
        Value = CFDictionaryGetValue(theDict, kSecValueData);
        if (!sub_10012E5B8(v10, (uint64_t)Value))
          goto LABEL_99;
      }
      if (*v4 != (const void **)&off_1002E3A00)
        goto LABEL_45;
      *(_QWORD *)buf = 0;
      v12 = (const __CFData *)v4[10];
      if (v12 && CFDataGetLength(v12) == 16)
      {
        v13 = *(const __CFArray **)(a2 + 8);
        v14 = a1;
        v15 = (uint64_t)v4;
        v16 = 4;
      }
      else
      {
        v13 = *(const __CFArray **)(a2 + 8);
        v14 = a1;
        v15 = (uint64_t)v4;
        v16 = 3;
      }
      if (!sub_100014B3C(v14, v15, v16, v13, (CFDictionaryRef *)buf, 0, 0, (__CFString **)v4 + 5)
        || !*(_QWORD *)buf)
      {
        goto LABEL_99;
      }
      v31 = CFDictionaryGetValue(theDict, kSecValueData);
      if (v31)
      {
        CFDictionarySetValue(*(CFMutableDictionaryRef *)buf, CFSTR("certdata"), v31);
        CFDictionaryRemoveValue(theDict, kSecValueData);
      }
      v32 = CFDictionaryGetValue(theDict, kSecAttrTokenID);
      if (v32)
      {
        CFDictionarySetValue(*(CFMutableDictionaryRef *)buf, CFSTR("certtkid"), v32);
        CFDictionaryRemoveValue(theDict, kSecAttrTokenID);
      }
      CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)sub_10012E630, *(void **)buf);
      CFRelease(theDict);
      theDict = *(CFDictionaryRef *)buf;
LABEL_45:
      if (*((_BYTE *)v4 + 116))
      {
        v33 = (const __CFString *)CFDictionaryGetValue(theDict, kSecAttrSharingGroup);
        if (v33)
        {
          v34 = v33;
          v35 = CFGetTypeID(v33);
          if (v35 == CFStringGetTypeID())
          {
            if (CFStringCompare(v34, kSecAttrSharingGroupNone, 0))
              goto LABEL_99;
          }
        }
      }
      if (!sub_100014EE8(*(_QWORD *)(a2 + 16), (uint64_t)v4, *(_QWORD *)(a2 + 8), theDict))
        goto LABEL_99;
      v36 = (const __CFData *)CFDictionaryGetValue(theDict, kSecAttrPersistentReference);
      v37 = theDict;
      v38 = (void *)CFDictionaryGetValue(theDict, kSecValueData);
      v39 = *((_DWORD *)v4 + 12);
      if ((v39 & 8) != 0)
      {
        if (v36 && CFDataGetLength(v36) == 16)
        {
          UUIDBasedPersistentRef = _SecItemCreateUUIDBasedPersistentRef(**v4, v36, v37);
        }
        else
        {
          v50 = sub_10000EF14("pref");
          if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 134217984;
            *(_QWORD *)&buf[4] = v6;
            _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "handle_result: Creating old persistent ref for %llu", buf, 0xCu);
          }
          UUIDBasedPersistentRef = _SecItemCreatePersistentRef(**v4, v6, v37);
        }
        v40 = (const void *)UUIDBasedPersistentRef;
        v39 = *((_DWORD *)v4 + 12);
      }
      else
      {
        v40 = 0;
      }
      switch(v39)
      {
        case 8:
          if (v36 && CFDataGetLength(v36) == 16)
          {
            PersistentRef = (CFDataRef)_SecItemCreateUUIDBasedPersistentRef(**v4, v36, v37);
          }
          else
          {
            v52 = sub_10000EF14("pref");
            if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 134217984;
              *(_QWORD *)&buf[4] = v6;
              _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "handle_result: Creating old persistent ref for %llu", buf, 0xCu);
            }
            PersistentRef = (CFDataRef)_SecItemCreatePersistentRef(**v4, v6, v37);
          }
          break;
        case 1:
          if (v38)
          {
            CFRetain(v38);
            v37 = (__CFDictionary *)v38;
            if (v40)
              goto LABEL_88;
            goto LABEL_89;
          }
          PersistentRef = CFDataCreate(kCFAllocatorDefault, 0, 0);
          break;
        case 0:
          v37 = kCFNull;
          if (!v40)
            goto LABEL_89;
LABEL_88:
          CFRelease(v40);
          goto LABEL_89;
        default:
          if ((v39 & 4) != 0)
          {
            CFDictionarySetValue(v37, kSecClass, **v4);
            goto LABEL_140;
          }
          if ((v39 & 2) == 0)
          {
            if (v38)
              CFRetain(v38);
            CFDictionaryRemoveAllValues(v37);
            if (v38 && ((_DWORD)v4[6] & 1) != 0)
            {
              CFDictionarySetValue(v37, kSecValueData, v38);
              goto LABEL_139;
            }
            if (v38)
LABEL_139:
              CFRelease(v38);
LABEL_140:
            if (((_BYTE)v4[6] & 8) != 0 && v40)
              CFDictionarySetValue(v37, kSecValuePersistentRef, v40);
            CFRetain(v37);
            if (v40)
              goto LABEL_88;
LABEL_89:
            if (v37)
            {
              if (v37 != kCFNull)
              {
                if (v4[13] == (const void **)1)
                {
                  *(_QWORD *)(a2 + 24) = v37;
                  goto LABEL_95;
                }
                CFArrayAppendValue(*(CFMutableArrayRef *)(a2 + 24), v37);
              }
              CFRelease(v37);
LABEL_95:
              ++*(_DWORD *)(a2 + 32);
            }
            if (CFDictionaryContainsKey(theDict, kSecAttrPersistentReference) && ((_BYTE)v4[6] & 2) != 0)
              CFDictionaryRemoveValue(theDict, kSecAttrPersistentReference);
LABEL_99:
            v53 = theDict;
            *((_DWORD *)v4 + 12) = v5;
            if (v53)
LABEL_100:
              CFRelease(v53);
            return;
          }
          if ((v39 & 1) == 0)
            CFDictionaryRemoveValue(v37, kSecValueData);
          v56 = (uint64_t (**)(const void *, const void *, _BYTE *))(*v4)[2];
          if (!v56)
          {
LABEL_137:
            CFDictionaryRemoveValue(v37, kSecAttrUUID);
            goto LABEL_140;
          }
          v57 = 0;
          v58 = *v4 + 3;
          while (2)
          {
            if (((_BYTE)v56[2] & 0x10) != 0 && !CFDictionaryGetValue(v37, *v56) && v56[3])
            {
              v60 = 0;
              *(_QWORD *)buf = 0;
              if (!v57)
              {
                v57 = sub_10001E9E8((uint64_t)*v4, v37, dword_1003414E0, (__CFString **)buf);
                v60 = *(const void **)buf;
              }
              if (v60 || !v57)
                goto LABEL_133;
              if (*((_DWORD *)v56 + 2) != 7 || ((_BYTE)v4[6] & 1) != 0)
              {
                v61 = (const void *)v56[3](v57, v56, buf);
                v60 = *(const void **)buf;
                if (!*(_QWORD *)buf && v61)
                {
                  CFDictionarySetValue(v37, *v56, v61);
                  goto LABEL_132;
                }
                if (v61)
                {
LABEL_132:
                  CFRelease(v61);
                  v60 = *(const void **)buf;
                }
LABEL_133:
                if (v60)
                {
                  *(_QWORD *)buf = 0;
                  CFRelease(v60);
                }
              }
            }
            v59 = (uint64_t (**)(const void *, const void *, _BYTE *))*v58++;
            v56 = v59;
            if (!v59)
            {
              if (v57)
                CFRelease(v57);
              goto LABEL_137;
            }
            continue;
          }
      }
      v37 = PersistentRef;
      if (!v40)
        goto LABEL_89;
      goto LABEL_88;
    }
    *((_DWORD *)v4 + 12) = v8 | 1;
    v9 = theDict;
    if (theDict)
    {
      theDict = 0;
      CFRelease(v9);
    }
  }
  OSStatus = SecErrorGetOSStatus(*v7);
  v18 = OSStatus;
  if (OSStatus > -25331)
  {
    if (OSStatus == -25330)
    {
      v42 = sub_10000EF14("SecWarning");
      if (!os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
        return;
      v43 = **v4;
      v44 = v4[5];
      *(_DWORD *)buf = 138413058;
      *(_QWORD *)&buf[4] = v43;
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v6;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v64) = -25330;
      WORD2(v64) = 2112;
      *(_QWORD *)((char *)&v64 + 6) = v44;
      v45 = "Authentication is needed for %@,rowid=%lld (%d): %@";
      v46 = v42;
      goto LABEL_59;
    }
    if (OSStatus == -25308)
    {
      if (qword_100341228 != -1)
        dispatch_once(&qword_100341228, &stru_1002DFB60);
      dispatch_source_merge_data((dispatch_source_t)qword_100341230, 1uLL);
      return;
    }
LABEL_57:
    v47 = sub_10000EF14("SecError");
    if (!os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
      return;
    v48 = **v4;
    v49 = v4[5];
    *(_DWORD *)buf = 138413058;
    *(_QWORD *)&buf[4] = v48;
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = v6;
    *(_WORD *)&buf[22] = 1024;
    LODWORD(v64) = v18;
    WORD2(v64) = 2112;
    *(_QWORD *)((char *)&v64 + 6) = v49;
    v45 = "decode %@,rowid=%lld failed (%d): %@";
    v46 = v47;
LABEL_59:
    _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, v45, buf, 0x26u);
    return;
  }
  if (OSStatus == -34018)
    goto LABEL_111;
  if (OSStatus != -26275)
    goto LABEL_57;
  v19 = sub_10000EF14("SecWarning");
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    v20 = **v4;
    v21 = v4[5];
    *(_DWORD *)buf = 138412802;
    *(_QWORD *)&buf[4] = v20;
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = v6;
    *(_WORD *)&buf[22] = 2112;
    *(_QWORD *)&v64 = v21;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "ignoring corrupt %@,rowid=%lld %@", buf, 0x20u);
  }
  Copy = CFStringCreateCopy(kCFAllocatorDefault, (CFStringRef)**v4);
  v23 = (const void *)sub_100011C40(0);
  if (v23)
  {
    v24 = v23;
    CFRetain(v23);
    CFRetain(Copy);
    *(_QWORD *)buf = _NSConcreteStackBlock;
    *(_QWORD *)&buf[8] = 0x40000000;
    *(_QWORD *)&buf[16] = sub_100138C7C;
    *(_QWORD *)&v64 = &unk_1002E7D58;
    *((_QWORD *)&v64 + 1) = v24;
    v65 = Copy;
    v66 = v6;
    if (qword_100341338 != -1)
      dispatch_once(&qword_100341338, &stru_1002E87E8);
    dispatch_async((dispatch_queue_t)qword_100341340, buf);
  }
  if (Copy)
    CFRelease(Copy);
  v25 = sub_100014E94(a1, 1);
  Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
  if (Mutable)
  {
    BytePtr = CFDataGetBytePtr(v25);
    Length = CFDataGetLength(v25);
    if ((Length & 0x8000000000000000) == 0)
    {
      v29 = Length;
      CFStringAppendFormat(Mutable, 0, CFSTR("%04lx:"), Length);
      if (v29 > 8)
      {
        *(_QWORD *)buf = 0;
        CNCRC(60, BytePtr + 8, v29 - 8, buf);
        for (i = 0; i != 8; ++i)
          CFStringAppendFormat(Mutable, 0, CFSTR("%02X"), BytePtr[i]);
        CFStringAppendFormat(Mutable, 0, CFSTR("...|%08llx"), *(_QWORD *)buf);
      }
      else
      {
        for (; v29; --v29)
        {
          v30 = *BytePtr++;
          CFStringAppendFormat(Mutable, 0, CFSTR("%02X"), v30);
        }
      }
    }
    v55 = sub_10000EF14("item");
    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)&buf[4] = Mutable;
      _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "corrupted edata=%@", buf, 0xCu);
    }
  }
  if (v25)
    CFRelease(v25);
  if (Mutable)
    CFRelease(Mutable);
LABEL_111:
  v53 = *v7;
  if (*v7)
  {
    *v7 = 0;
    goto LABEL_100;
  }
}

uint64_t sub_100014B3C(sqlite3_stmt *a1, uint64_t a2, int a3, const __CFArray *a4, CFDictionaryRef *a5, _QWORD *a6, _DWORD *a7, __CFString **a8)
{
  const __CFData *v14;
  const __CFData *v15;
  uint64_t v16;
  uint64_t v17;
  const void *v18;
  const __CFString *Value;
  const void *v20;
  NSObject *v21;
  const void *v22;
  const void *v23;
  CFDictionaryRef v24;
  CFTypeRef v25;
  CFTypeRef v26;
  unsigned int v28;
  CFTypeRef cf;
  uint8_t buf[4];
  const void *v31;
  __int16 v32;
  const __CFArray *v33;

  v14 = sub_100014E94(a1, a3);
  if (!v14)
    return 0;
  v15 = v14;
  cf = 0;
  v28 = 0;
  if ((*(_BYTE *)(a2 + 48) & 5) != 0
    || *(_QWORD *)(a2 + 208)
    || *(_QWORD *)(a2 + 216)
    || (v16 = *(_QWORD *)(a2 + 232)) != 0)
  {
    LOBYTE(v16) = 1;
  }
  if (sub_1000171E0(*(unsigned int *)(a2 + 120), 0, CFSTR("od"), &cf, *(const __CFData **)(a2 + 144), v14, *(_QWORD *)a2, *(const __CFString **)(a2 + 184), (const void **)a5, &v28, v16, a7, a8))
  {
    if (v28 > 1)
    {
      v18 = (const void *)SecAccessControlCopyData(cf);
      Value = (const __CFString *)CFDictionaryGetValue(*a5, kSecAttrAccessGroup);
      if ((sub_100014DCC(a4, Value, 0) & 1) != 0)
      {
        if (v28 >= 4)
          CFDictionarySetValue(*a5, kSecAttrAccessControl, v18);
        v17 = 1;
      }
      else
      {
        v20 = sub_10000EF14("SecError");
        v21 = objc_claimAutoreleasedReturnValue(v20);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          v22 = CFDictionaryGetValue(*a5, kSecAttrAccessGroup);
          *(_DWORD *)buf = 138412546;
          v31 = v22;
          v32 = 2112;
          v33 = a4;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "item's accessGroup '%@' not in %@", buf, 0x16u);
        }

        v23 = CFDictionaryGetValue(*a5, kSecAttrAccessGroup);
        sub_100019F20(-34018, a8, CFSTR("item's access group '%@' not in %@"), v23, a4);
        v24 = *a5;
        if (*a5)
        {
          *a5 = 0;
          CFRelease(v24);
        }
        v17 = 0;
      }
      goto LABEL_20;
    }
    sub_100019F20(-26275, a8, CFSTR("version is unexpected: %d"), v28);
  }
  v17 = 0;
  v18 = 0;
LABEL_20:
  v25 = cf;
  if (a6)
  {
    if (cf)
    {
      CFRetain(cf);
      v26 = cf;
    }
    else
    {
      v26 = 0;
    }
    *a6 = v25;
    v25 = v26;
  }
  if (v25)
    CFRelease(v25);
  if (v18)
    CFRelease(v18);
  CFRelease(v15);
  return v17;
}

uint64_t sub_100014DCC(const __CFArray *a1, const __CFString *cf, uint64_t a3)
{
  CFTypeID v6;
  CFIndex Count;
  CFIndex v8;
  CFRange v10;
  CFRange v11;

  if (!a1)
    return 1;
  if (cf)
  {
    v6 = CFGetTypeID(cf);
    if (v6 == CFStringGetTypeID())
    {
      Count = CFArrayGetCount(a1);
      if (Count)
      {
        v8 = Count;
        v10.location = 0;
        v10.length = Count;
        if (CFArrayContainsValue(a1, v10, cf))
          return 1;
        v11.location = 0;
        v11.length = v8;
        if (CFArrayContainsValue(a1, v11, CFSTR("*"))
          || a3 && *(_BYTE *)(a3 + 19) && CFStringHasSuffix(cf, kSecNetworkExtensionAccessGroupSuffix))
        {
          return 1;
        }
      }
    }
  }
  return 0;
}

CFDataRef sub_100014E94(sqlite3_stmt *a1, int a2)
{
  const UInt8 *v4;
  int v5;

  v4 = (const UInt8 *)sqlite3_column_blob(a1, a2);
  v5 = sqlite3_column_bytes(a1, a2);
  return CFDataCreateWithBytesNoCopy(0, v4, v5, kCFAllocatorNull);
}

unint64_t sub_100014EE8(uint64_t a1, uint64_t a2, uint64_t a3, CFDictionaryRef theDict)
{
  const void *Value;
  __CFString **v9;
  SecCertificateRef v10;
  __CFString **v11;
  SecCertificateRef v12;
  void *v13;
  const void *v14;
  CFArrayRef v15;
  CFTypeID v16;
  const __CFDictionary *v17;
  const __CFDictionary *v18;
  const void *v19;
  const void *v20;
  _BOOL4 v21;
  __CFString **v23;
  __CFString **v24;
  int v25;
  CFArrayRef v26;
  SecPolicyRef BasicX509;
  _BOOL4 v29;
  __CFString **v30;
  const __CFString *v31;
  CFTypeID v32;
  CFIndex Count;
  CFIndex v34;
  CFIndex v35;
  BOOL v36;
  const __CFString *ValueAtIndex;
  __CFString **v38;
  unint64_t HasSuffix;
  const __CFDate *v40;
  double AbsoluteTime;
  double v42;
  double v43;
  NSObject *v44;
  const char *v45;
  const __CFString *v46;
  const __CFString *v47;
  CFTypeID v48;
  CFMutableStringRef Mutable;
  SecTrustResultType result;
  SecTrustRef trust;
  void *values[2];

  if (*(_QWORD *)(a2 + 176))
  {
    Value = CFDictionaryGetValue(theDict, kSecAttrIssuer);
    if (!sub_1001387D4(a1, a3, *(const void **)(a2 + 128), Value, *(const __CFArray **)(a2 + 176), 10))
      return 0;
  }
  if (!*(_QWORD *)(a2 + 208))
    goto LABEL_6;
  if (*(__CFString ***)a2 == &off_1002E3A00)
  {
    v11 = &off_1002E3A00;
  }
  else
  {
    v9 = *(__CFString ***)a2;
    if (v9 != (__CFString **)sub_1000119B8((uint64_t)CFSTR("cert"), &qword_100341260, (uint64_t)&unk_100341258))
    {
LABEL_6:
      v10 = 0;
      goto LABEL_36;
    }
    v11 = *(__CFString ***)a2;
  }
  v12 = sub_100138A64(v11, theDict);
  if (!v12)
    return 0;
  v10 = v12;
  v13 = *(void **)(a2 + 208);
  v14 = *(const void **)(a2 + 216);
  trust = 0;
  values[0] = v12;
  if (!v13)
    goto LABEL_108;
  result = -1431655766;
  v15 = CFArrayCreate(0, (const void **)values, 1, &kCFTypeArrayCallBacks);
  if (SecTrustCreateWithCertificates(v15, v13, &trust)
    || v14 && (v16 = CFGetTypeID(v14), v16 == CFDateGetTypeID()) && SecTrustSetVerifyDate(trust, (CFDateRef)v14))
  {
    v21 = 0;
    goto LABEL_30;
  }
  v17 = SecPolicyCopyProperties((SecPolicyRef)v13);
  v18 = v17;
  if (v17)
  {
    v19 = CFDictionaryGetValue(v17, kSecPolicyOid);
    if (v19)
    {
      v20 = v19;
      if (CFEqual(v19, kSecPolicyAppleX509Basic) || CFEqual(v20, kSecPolicyAppleRevocation))
      {
        if (SecTrustEvaluate(trust, &result))
        {
          v21 = 0;
LABEL_29:
          CFRelease(v18);
          goto LABEL_30;
        }
        goto LABEL_22;
      }
    }
  }
  if (!SecTrustEvaluateLeafOnly(trust, &result))
  {
LABEL_22:
    v21 = result == kSecTrustResultUnspecified || result == kSecTrustResultProceed;
    if (v18)
      goto LABEL_29;
    goto LABEL_30;
  }
  v21 = 0;
  if (v18)
    goto LABEL_29;
LABEL_30:
  if (v15)
    CFRelease(v15);
  if (trust)
  {
    CFRelease(trust);
    if (!v21)
      goto LABEL_108;
  }
  else if (!v21)
  {
    goto LABEL_108;
  }
LABEL_36:
  if (*(_QWORD *)(a2 + 216))
  {
    if (*(__CFString ***)a2 == &off_1002E3A00
      || (v23 = *(__CFString ***)a2,
          v23 == (__CFString **)sub_1000119B8((uint64_t)CFSTR("cert"), &qword_100341260, (uint64_t)&unk_100341258)))
    {
      if (!v10)
      {
        v10 = sub_100138A64(*(__CFString ***)a2, theDict);
        if (!v10)
          return 0;
      }
      v40 = *(const __CFDate **)(a2 + 216);
      if (!v40)
        goto LABEL_108;
      AbsoluteTime = CFDateGetAbsoluteTime(v40);
      v42 = SecCertificateNotValidBefore(v10);
      SecCertificateNotValidAfter(v10);
      if (v42 == 0.0 || v43 == 0.0 || v42 == v43)
      {
        v44 = sub_10000EF14("FilterWithDate");
        if (!os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
          goto LABEL_108;
        LOWORD(values[0]) = 0;
        v45 = "certificate cannot operate";
      }
      else if (AbsoluteTime >= v42)
      {
        if (AbsoluteTime <= v43)
          goto LABEL_39;
        v44 = sub_10000EF14("FilterWithDate");
        if (!os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
          goto LABEL_108;
        LOWORD(values[0]) = 0;
        v45 = "certificate expired";
      }
      else
      {
        v44 = sub_10000EF14("FilterWithDate");
        if (!os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
          goto LABEL_108;
        LOWORD(values[0]) = 0;
        v45 = "certificate is not valid yet";
      }
      _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, v45, (uint8_t *)values, 2u);
      goto LABEL_108;
    }
  }
LABEL_39:
  if (*(_QWORD *)(a2 + 232))
  {
    if (*(__CFString ***)a2 == &off_1002E3A00
      || (v24 = *(__CFString ***)a2,
          v24 == (__CFString **)sub_1000119B8((uint64_t)CFSTR("cert"), &qword_100341260, (uint64_t)&unk_100341258)))
    {
      if (!v10)
      {
        v10 = sub_100138A64(*(__CFString ***)a2, theDict);
        if (!v10)
          return 0;
      }
      v25 = CFBooleanGetValue(*(CFBooleanRef *)(a2 + 232));
      values[0] = v10;
      if (v25)
      {
        v26 = CFArrayCreate(0, (const void **)values, 1, &kCFTypeArrayCallBacks);
        trust = 0;
        BasicX509 = SecPolicyCreateBasicX509();
        v29 = BasicX509
           && !SecTrustCreateWithCertificates(v26, BasicX509, &trust)
           && (result = -1431655766, !SecTrustEvaluate(trust, &result))
           && (result == kSecTrustResultUnspecified || result == kSecTrustResultProceed);
        if (trust)
          CFRelease(trust);
        if (BasicX509)
          CFRelease(BasicX509);
        if (v26)
          CFRelease(v26);
        if (!v29)
          goto LABEL_108;
      }
    }
  }
  if (*(_QWORD *)(a2 + 224))
  {
    if (*(__CFString ***)a2 == &off_1002E3A00
      || (v30 = *(__CFString ***)a2,
          v30 == (__CFString **)sub_1000119B8((uint64_t)CFSTR("cert"), &qword_100341260, (uint64_t)&unk_100341258)))
    {
      if (v10 || (v10 = sub_100138A64(*(__CFString ***)a2, theDict)) != 0)
      {
        v31 = *(const __CFString **)(a2 + 224);
        if (v31)
        {
          v32 = CFGetTypeID(*(CFTypeRef *)(a2 + 224));
          if (v32 == CFStringGetTypeID())
          {
            values[0] = 0;
            if (!SecCertificateCopyEmailAddresses(v10, (CFArrayRef *)values))
            {
              if (values[0])
              {
                Count = CFArrayGetCount((CFArrayRef)values[0]);
                if (Count >= 1)
                {
                  v34 = Count;
                  v35 = 0;
                  v36 = 1;
                  do
                  {
                    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)values[0], v35);
                    if (ValueAtIndex && CFStringCompare(v31, ValueAtIndex, 1uLL) == kCFCompareEqualTo)
                      break;
                    v36 = ++v35 < v34;
                  }
                  while (v34 != v35);
                  if (values[0])
                  {
                    CFRelease(values[0]);
                    if (v36)
                      goto LABEL_77;
                  }
                  else if (v36)
                  {
                    goto LABEL_77;
                  }
                  HasSuffix = 0;
LABEL_80:
                  if (!v10)
                    return HasSuffix;
                  goto LABEL_109;
                }
                if (values[0])
                  CFRelease(values[0]);
              }
            }
          }
        }
LABEL_108:
        HasSuffix = 0;
LABEL_109:
        CFRelease(v10);
        return HasSuffix;
      }
      return 0;
    }
  }
LABEL_77:
  if (!*(_QWORD *)(a2 + 248)
    || (v38 = *(__CFString ***)a2,
        v38 != (__CFString **)sub_1000119B8((uint64_t)CFSTR("inet"), &qword_100341250, (uint64_t)&unk_100341248)))
  {
LABEL_79:
    HasSuffix = 1;
    goto LABEL_80;
  }
  v46 = (const __CFString *)CFDictionaryGetValue(theDict, kSecAttrServer);
  if (!v46)
    return 0;
  v47 = v46;
  v48 = CFGetTypeID(v46);
  if (v48 != CFStringGetTypeID())
    return 0;
  HasSuffix = *(_QWORD *)(a2 + 248);
  if (HasSuffix)
  {
    if (CFEqual(v47, (CFTypeRef)HasSuffix))
      goto LABEL_79;
    Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
    CFStringAppend(Mutable, CFSTR("."));
    CFStringAppend(Mutable, (CFStringRef)HasSuffix);
    HasSuffix = CFStringHasSuffix(v47, Mutable);
    if (Mutable)
      CFRelease(Mutable);
    if ((_DWORD)HasSuffix)
      goto LABEL_79;
  }
  return HasSuffix;
}

BOOL sub_10001567C(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, const void *a6, _DWORD *a7, CFDataRef theData, char a9, __CFString **a10)
{
  int v18;
  UInt8 *MutableBytePtr;
  uint64_t v20;
  NSObject *v21;
  UInt8 *v22;
  NSObject *v23;
  uint64_t v24;
  UInt8 *v25;
  const void *v26;
  int v27;
  int v28;
  int v29;
  BOOL v30;
  const char *v31;
  int v33;
  size_t v34;
  int length[3];

  v18 = CFDataGetLength(theData);
  length[0] = v18;
  if (CFEqual(a1, CFSTR("oe")))
  {
    MutableBytePtr = CFDataGetMutableBytePtr(theData);
    if (a9)
    {
      v34 = v18;
      v20 = sub_100026368(a2, a6, a5, MutableBytePtr, &v34);
      if ((_DWORD)v20)
      {
        v21 = sub_10000EF14("SecError");
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          length[1] = 67109120;
          length[2] = v20;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "ks_crypt: aks_kc_backup_wrap_key returned %d", (uint8_t *)&length[1], 8u);
        }
      }
      else
      {
        length[0] = v34;
        if (a7)
          *a7 = a4;
      }
      goto LABEL_20;
    }
    v24 = sub_10001A9D8(a6, a5, a4, a2, MutableBytePtr, length, a7);
LABEL_19:
    v20 = v24;
    goto LABEL_20;
  }
  if (!CFEqual(a1, CFSTR("od")))
  {
    if (!CFEqual(a1, CFSTR("odel")))
    {
      v20 = 3758097090;
      goto LABEL_37;
    }
    v25 = CFDataGetMutableBytePtr(theData);
    v26 = a6;
    v27 = a5;
    v28 = a4;
    v29 = a2;
    goto LABEL_18;
  }
  v22 = CFDataGetMutableBytePtr(theData);
  if (!a3)
  {
    v26 = a6;
    v27 = a5;
    v28 = a4;
    v29 = a2;
    v25 = v22;
LABEL_18:
    v24 = sub_100015A80(v26, v27, v28, v29, v25, length);
    goto LABEL_19;
  }
  v34 = v18;
  v23 = sub_10000EF14("ks_crypt");
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(length[1]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "have a backup_keypair, attempting to use", (uint8_t *)&length[1], 2u);
  }
  v20 = sub_100026250(a3, a6, a5, v22, &v34);
  if (!(_DWORD)v20)
    length[0] = v34;
LABEL_20:
  if ((int)v20 > -536870161)
  {
    switch((_DWORD)v20)
    {
      case 0xE00002F0:
        return sub_100019F20(-25291, a10, CFSTR("ks_crypt: %x failed to '%@' item (class %d, bag: %d) No key available for class."), 3758097136, a1, a4, a2);
      case 0xE007C013:
        return sub_100019F20(-26275, a10, CFSTR("ks_crypt: %x failed to '%@' item (class %d, bag: %d) Item can't be decrypted on this device, ever, so drop the item."), v20, a1, a4, a2);
      case 0:
        CFDataSetLength(theData, length[0]);
        return 1;
    }
    goto LABEL_37;
  }
  if ((_DWORD)v20 == -536870212)
    return sub_100019F20(-26275, a10, CFSTR("ks_crypt: %x failed to '%@' item (class %d, bag: %d) Item can't be decrypted on this device, ever, so drop the item."), v20, a1, a4, a2);
  if ((_DWORD)v20 != -536870207 && (_DWORD)v20 != -536870174)
  {
LABEL_37:
    if (!CFEqual(a1, CFSTR("od")) && !CFEqual(a1, CFSTR("odel")))
      return sub_100019F20(-25291, a10, CFSTR("ks_crypt: %x failed to '%@' item (class %d, bag: %d)"), v20, a1, a4, a2);
    v34 = 0;
    *(_QWORD *)&length[1] = 0;
    v33 = sub_100146360(a2, (const UInt8 *)a6, a5, (uint64_t *)&v34, (CFTypeRef *)&length[1], a10);
    if (*(_QWORD *)&length[1])
      CFRelease(*(CFTypeRef *)&length[1]);
    sub_100024478((uint64_t *)&v34);
    if (!v33)
      return sub_100019F20(-25291, a10, CFSTR("ks_crypt: %x failed to '%@' item (class %d, bag: %d)"), v20, a1, a4, a2);
    return sub_100019F20(-26275, a10, CFSTR("ks_crypt: %x failed to '%@' item (class %d, bag: %d) Item can't be decrypted on this device, ever, so drop the item."), v20, a1, a4, a2);
  }
  v30 = (_DWORD)a4 == 10 || (_DWORD)a4 == 7;
  v31 = "";
  if (v30)
    v31 = " (hibernation?)";
  return sub_100019F20(-25308, a10, CFSTR("ks_crypt: %x failed to '%@' item (class %d, bag: %d) Access to item attempted while keychain is locked%s."), v20, a1, a4, a2, v31);
}

uint64_t sub_100015A80(const void *a1, int a2, int a3, int a4, void *a5, int *a6)
{
  uint64_t v12;
  mach_port_t v13;
  size_t v15;
  uint64_t input[2];

  v12 = 3758097084;
  v13 = sub_100015BC4();
  if (v13)
  {
    v12 = 3758097090;
    if (a1)
    {
      if (a5)
      {
        if (a6)
        {
          input[0] = a4;
          input[1] = a3;
          v15 = *a6;
          v12 = IOConnectCallMethod(v13, 0xBu, input, 2u, a1, a2, 0, 0, a5, &v15);
          if (!(_DWORD)v12)
            *a6 = v15;
        }
      }
    }
  }
  else
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_unwrap_key", ":", 877, "", 0, "", "");
  }
  return v12;
}

uint64_t sub_100015BC4()
{
  uint64_t result;

  if (qword_100340CA0 != -1)
    dispatch_once(&qword_100340CA0, &stru_1002DAA98);
  dispatch_sync((dispatch_queue_t)qword_100340CA8, &stru_1002DAA58);
  result = dword_100340C98;
  if (!dword_100340C98)
  {
    syslog(3, "failed to open connection to %s\n", "AppleKeyStore");
    return dword_100340C98;
  }
  return result;
}

id sub_100016534(const __CFData *a1)
{
  void *v1;
  uint64_t v2;
  void *v3;
  id v4;

  v1 = (void *)sub_100016590(0, a1, 0);
  v2 = objc_opt_class(NSDictionary);
  if ((objc_opt_isKindOfClass(v1, v2) & 1) != 0)
    v3 = v1;
  else
    v3 = 0;
  v4 = v3;

  return v4;
}

CFTypeRef sub_100016590(const __CFAllocator *a1, CFDataRef theData, CFTypeRef *a3)
{
  const UInt8 *BytePtr;
  CFIndex Length;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  uint64_t v10;
  CFTypeRef result;
  CFTypeRef cf;

  cf = 0;
  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  v8 = (unsigned __int8 *)&BytePtr[Length];
  v9 = sub_100020974(a1, (CFBooleanRef *)&cf, a3, BytePtr, (uint64_t)&BytePtr[Length]);
  if (!v9 || v9 == v8)
    return cf;
  sub_100032660(-1, CFSTR("com.apple.security.cfder.error"), 0, a3, v10, CFSTR("trailing garbage after plist item"));
  result = cf;
  if (cf)
  {
    CFRelease(cf);
    return 0;
  }
  return result;
}

void sub_100016AC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  uint64_t v33;

  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a29, 8);
  _Block_object_dispose(&a33, 8);
  _Block_object_dispose((const void *)(v33 - 144), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000171E0(uint64_t a1, uint64_t a2, char *a3, _QWORD *a4, const __CFData *a5, const __CFData *a6, uint64_t a7, const __CFString *a8, const void **a9, unsigned int *a10, char a11, _DWORD *a12, __CFString **a13)
{
  unsigned int *v17;
  const void **v18;
  __CFData *Mutable;
  unint64_t Length;
  const UInt8 *BytePtr;
  uint64_t v22;
  __CFData *v23;
  __CFDictionary *v24;
  __CFData *v25;
  unsigned int v26;
  const UInt8 *v27;
  unsigned int *v28;
  int v29;
  unsigned int v30;
  void *v31;
  uint64_t v32;
  unint64_t v33;
  void *v34;
  SecDbKeychainItemV7 *v35;
  id v36;
  void *v37;
  id v38;
  id v39;
  unsigned int v40;
  const void *v41;
  void *v42;
  const __CFString *v43;
  unint64_t v44;
  unint64_t v45;
  __CFString **v46;
  unsigned int v47;
  uint64_t v48;
  const void *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unsigned int v53;
  uint64_t v54;
  const __CFString *v55;
  void *v56;
  id v57;
  const UInt8 *v58;
  uint64_t v59;
  const void *v60;
  char v61;
  const void *Protection;
  unsigned int v63;
  id v64;
  const void *v65;
  NSObject *v66;
  unint64_t v67;
  unsigned int v68;
  unint64_t v69;
  unint64_t v70;
  __CFString **v71;
  unint64_t v72;
  __CFData *v73;
  char *v74;
  UInt8 *v75;
  rsize_t v76;
  rsize_t v77;
  const void *v78;
  __CFDictionary *v79;
  const __CFData *v80;
  __CFString **v82;
  _BOOL8 v83;
  char *v84;
  uint64_t v85;
  char *v86;
  const UInt8 *v87;
  char *v88;
  __CFData *v89;
  char *v90;
  uint64_t v91;
  size_t v92;
  char *v93;
  const UInt8 *v94;
  char *v95;
  const UInt8 *v96;
  CFIndex v97;
  UInt8 *MutableBytePtr;
  uint64_t v99;
  const UInt8 *v100;
  size_t v101;
  UInt8 *dataOut;
  uint64_t v103;
  __CFDictionary *v104;
  const void *v105;
  NSObject *v106;
  __CFString *v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  void *v111;
  unsigned int v112;
  char *dataOutAvailable;
  unsigned int *v114;
  const void **v115;
  const __CFData *v116;
  const __CFString *v117;
  char *v118;
  uint64_t v119;
  __CFString **v120;
  _QWORD *v121;
  CFTypeRef v122;
  _QWORD context[5];
  uint64_t v124;
  id v125;
  id v126;
  id v127;
  id v128;
  uint64_t v129;
  const __CFData *v130;
  __CFDictionary *v131;
  uint8_t buf[8];
  __int16 v133;
  __CFString *v134;

  v117 = a8;
  v116 = a5;
  v121 = a4;
  v118 = a3;
  v18 = a9;
  v17 = a10;
  Mutable = CFDataCreateMutable(0, 32);
  CFDataSetLength(Mutable, 32);
  if (a9)
    *a9 = 0;
  if (a10)
    *a10 = 0;
  v130 = 0;
  v131 = 0;
  v129 = 0;
  Length = CFDataGetLength(a6);
  BytePtr = CFDataGetBytePtr(a6);
  if (Length <= 3)
  {
    v22 = sub_100019F20(-26275, a13, CFSTR("ks_decrypt_data: Check for underflow (length)"));
    v23 = 0;
    v24 = 0;
    v122 = 0;
    v25 = 0;
    v26 = 0;
    goto LABEL_83;
  }
  v27 = BytePtr;
  v120 = a13;
  v115 = a9;
  v114 = a10;
  v28 = (unsigned int *)(BytePtr + 4);
  v29 = *(_DWORD *)BytePtr;
  v30 = *(_DWORD *)BytePtr & 0x7FFFFFFF;
  if (*(int *)BytePtr < 0)
    v31 = &unk_100249570;
  else
    v31 = 0;
  if (v29 < 0)
    v32 = 12;
  else
    v32 = 0;
  v33 = Length - 4;
  v119 = *(_DWORD *)BytePtr & 0x7FFFFFFF;
  if (v30 >= 7)
  {
    dataOutAvailable = (char *)objc_autoreleasePoolPush();
    v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", v28, v33));
    v128 = 0;
    v35 = -[SecDbKeychainItemV7 initWithData:decryptionKeybag:error:]([SecDbKeychainItemV7 alloc], "initWithData:decryptionKeybag:error:", v34, a1, &v128);
    v36 = v128;
    if (a12)
      *a12 = -[SecDbKeychainItemV7 keyclass](v35, "keyclass");
    v127 = v36;
    v37 = (void *)objc_claimAutoreleasedReturnValue(-[SecDbKeychainItemV7 metadataAttributesWithError:](v35, "metadataAttributesWithError:", &v127));
    v38 = v127;

    v39 = objc_msgSend(v37, "mutableCopy");
    v40 = 0;
    v24 = 0;
    v18 = v115;
    v41 = 0;
    if (!v39 || v38)
      goto LABEL_78;
    v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v39, "objectForKeyedSubscript:", CFSTR("SecAccessControl")));
    v41 = (const void *)SecAccessControlCreateFromData(0, v42, v120);
    objc_msgSend(v39, "removeObjectForKey:", CFSTR("SecAccessControl"));
    if (CFEqual(CFSTR("odel"), v118))
    {
      v126 = 0;
      v40 = -[SecDbKeychainItemV7 deleteWithAcmContext:accessControl:callerAccessGroups:keyDiversify:error:](v35, "deleteWithAcmContext:accessControl:callerAccessGroups:keyDiversify:error:", v116, v41, v117, (_DWORD)v119 != 7, &v126);
      v38 = v126;
      if (!v40)
      {
LABEL_62:
        v24 = 0;
LABEL_77:

LABEL_78:
        v122 = v41;
        if (v120 && !v40)
          *v120 = (__CFString *)v38;

        objc_autoreleasePoolPop(dataOutAvailable);
        v23 = 0;
        v25 = 0;
        v22 = v40 != 0;
        v17 = v114;
        goto LABEL_82;
      }
    }
    else if ((a11 & 1) != 0 || SecAccessControlGetConstraints(v41))
    {
      v125 = 0;
      v56 = (void *)objc_claimAutoreleasedReturnValue(-[SecDbKeychainItemV7 secretAttributesWithAcmContext:accessControl:callerAccessGroups:keyDiversify:error:](v35, "secretAttributesWithAcmContext:accessControl:callerAccessGroups:keyDiversify:error:", v116, v41, v117, (_DWORD)v119 != 7, &v125));
      v57 = v125;
      v38 = v57;
      if (v56)
      {
        if (a11)
          objc_msgSend(v39, "addEntriesFromDictionary:", v56);
        v40 = 1;
      }
      else
      {
        v64 = objc_msgSend(v57, "code");
        v40 = 0;
        if ((_DWORD)v119 == 8 && v64 == (id)-26275)
        {
          v65 = sub_10000EF14("SecError");
          v66 = objc_claimAutoreleasedReturnValue(v65);
          if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)&buf[4] = 8;
            _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "ks_decrypt_data failed to decrypt secretdata: version %u mismatch with content", buf, 8u);
          }

          v40 = 0;
        }
      }

      v18 = v115;
      if (!v40)
        goto LABEL_62;
    }
    else
    {
      v38 = 0;
    }
    v24 = (__CFDictionary *)v39;
    v40 = 1;
    goto LABEL_77;
  }
  if (v30 - 4 > 2)
  {
    if (v33 <= 3)
    {
      v43 = CFSTR("ks_decrypt_data: Check for underflow (keyclass)");
      goto LABEL_28;
    }
    v112 = *v28;
    v47 = (v112 & 0x1F) - 6;
    if (v47 <= 6 && (v48 = *(_QWORD *)*(&off_1002DEBB0 + v47)) != 0)
    {
      LODWORD(dataOutAvailable) = v30 - 4;
      v110 = v32;
      v111 = v31;
      v49 = (const void *)SecAccessControlCreate(kCFAllocatorDefault, v120);
      if (v49)
      {
        v122 = v49;
        if ((SecAccessControlSetProtection(v49, v48, v120) & 1) != 0)
        {
          v22 = (uint64_t)(v27 + 8);
          v45 = Length - 8;
          v17 = v114;
          goto LABEL_38;
        }
        v83 = sub_100019F20(-26275, v120, CFSTR("ks_decrypt_data: SecAccessControlSetProtection failed"));
LABEL_117:
        v22 = v83;
        v23 = 0;
        v24 = 0;
        goto LABEL_30;
      }
      v43 = CFSTR("ks_decrypt_data: SecAccessControlCreate failed");
    }
    else
    {
      v43 = CFSTR("ks_decrypt_data: invalid keyclass detected");
    }
    v46 = v120;
    goto LABEL_29;
  }
  if (v33 <= 3)
  {
    v43 = CFSTR("ks_decrypt_data: Check for underflow (prot_length)");
LABEL_28:
    v46 = v120;
LABEL_29:
    v22 = sub_100019F20(-26275, v46, v43);
    v23 = 0;
    v24 = 0;
    v122 = 0;
LABEL_30:
    v25 = 0;
LABEL_31:
    v17 = v114;
LABEL_32:
    v18 = v115;
LABEL_82:
    v26 = v119;
    goto LABEL_83;
  }
  v44 = *v28;
  v45 = Length - 8 - v44;
  if (Length - 8 < v44)
  {
    v43 = CFSTR("ks_decrypt_data: Check for underflow (prot)");
    goto LABEL_28;
  }
  LODWORD(dataOutAvailable) = v30 - 4;
  v110 = v32;
  v111 = v31;
  v58 = &BytePtr[v44 + 8];
  *(_QWORD *)buf = 0;
  sub_100020974(0, (CFBooleanRef *)buf, 0, BytePtr + 8, (uint64_t)v58);
  v23 = *(__CFData **)buf;
  v17 = v114;
  if (!*(_QWORD *)buf)
  {
    v22 = sub_100019F20(-26275, v120, CFSTR("ks_decrypt_data: invalid ACL"));
    v24 = 0;
    v122 = 0;
LABEL_115:
    v25 = 0;
    goto LABEL_32;
  }
  v109 = (uint64_t)v58;
  v59 = SecAccessControlCreate(0, 0);
  if (!v59)
  {
    v23 = 0;
    v24 = 0;
    v122 = 0;
    v25 = 0;
    v22 = 1;
    goto LABEL_31;
  }
  v60 = (const void *)v59;
  v61 = SecAccessControlSetProtection(v59, v23, 0);
  CFRelease(v23);
  v122 = v60;
  if ((v61 & 1) == 0)
  {
    sub_100019F20(-26275, v120, CFSTR("ks_decrypt_data: invalid ACL"));
    v23 = 0;
    v24 = 0;
    v25 = 0;
    goto LABEL_74;
  }
  Protection = (const void *)SecAccessControlGetProtection(v60);
  v63 = sub_10001D720(Protection, v120);
  if (!v63)
  {
    v83 = sub_100019F20(-26275, v120, CFSTR("ks_decrypt_data: invalid ACL"));
    goto LABEL_117;
  }
  v112 = v63;
  v17 = v114;
  v22 = v109;
LABEL_38:
  v53 = dataOutAvailable;
  v124 = 0;
  if ((v119 - 2) >= 5)
  {
    if (!(_DWORD)v119)
    {
      v67 = CFDataGetLength(Mutable) + 8;
      v70 = v45 - v67;
      if (v45 >= v67)
      {
        v71 = v120;
LABEL_119:
        if (v70 > 0xF)
        {
          if ((v70 & 0xF) == 0)
          {
            dataOutAvailable = (char *)v70;
            v109 = v22;
            LODWORD(v22) = 1;
            goto LABEL_126;
          }
          v55 = CFSTR("ks_decrypt_data: invalid length on CBC data");
        }
        else
        {
          v55 = CFSTR("ks_decrypt_data: Check for underflow (CBC check)");
        }
        v82 = v71;
        goto LABEL_114;
      }
LABEL_112:
      v55 = CFSTR("ks_decrypt_data: Check for underflow (wrapped_key/taglen)");
      goto LABEL_113;
    }
    v54 = 0;
    if ((_DWORD)v119 != 1)
    {
      v22 = sub_100019F20(-26275, v120, CFSTR("ks_decrypt_data: invalid version %d"), v119);
      v23 = 0;
      v24 = 0;
      v25 = 0;
      v26 = 0;
      goto LABEL_140;
    }
  }
  else
  {
    v54 = 16;
    v124 = 16;
  }
  if (v45 <= 3)
  {
    v55 = CFSTR("ks_decrypt_data: Check for underflow (wrapped_key_size)");
LABEL_113:
    v82 = v120;
LABEL_114:
    v22 = sub_100019F20(-26275, v82, v55);
    v23 = 0;
    v24 = 0;
    goto LABEL_115;
  }
  v68 = *(_DWORD *)v22;
  v22 += 4;
  v67 = v68;
  v69 = v54 + v68;
  v70 = v45 - 4 - v69;
  if (v45 - 4 < v69)
    goto LABEL_112;
  v71 = v120;
  if (v119 <= 1)
    goto LABEL_119;
  v109 = v22;
  dataOutAvailable = (char *)v70;
  if (v53 > 2)
  {
    LODWORD(v22) = 0;
LABEL_126:
    v84 = v118;
    v118 = (char *)v67;
    v23 = 0;
    if (!sub_10001567C(v84, a1, a2, v112, v67, (const void *)v109, 0, Mutable, 0, v71))
    {
      v22 = 0;
      v24 = 0;
      v25 = 0;
      goto LABEL_32;
    }
    v26 = v119;
    goto LABEL_132;
  }
  if (v117)
  {
    v72 = v67;
    v73 = sub_10011C9C0(v117, (CFTypeRef *)v120, v50, v51, v52);
    v67 = v72;
    v23 = v73;
    v74 = v118;
    if (!v73)
    {
      v24 = 0;
      v25 = 0;
      v22 = 0;
      goto LABEL_32;
    }
  }
  else
  {
    v23 = 0;
    v74 = v118;
  }
  v85 = a1;
  v118 = (char *)v67;
  v26 = v119;
  if (!sub_10011CA58(v85, a7, (const UInt8 *)v109, v67, (uint64_t)v122, v119, &v131, &v129, (CFTypeRef *)&v130, v120))
  {
    v24 = 0;
    v25 = 0;
    v22 = 0;
    goto LABEL_140;
  }
  if (CFEqual(v74, CFSTR("od")))
  {
    v22 = 0;
    if ((sub_100146B00(v129, v130, Mutable, v116, v23, (uint64_t)v122, v120) & 1) != 0)
    {
LABEL_132:
      if (v29 < 0)
      {
        v87 = CFDataGetBytePtr(a6);
        v86 = (char *)(v109 - (_QWORD)v87);
      }
      else
      {
        v86 = 0;
        v87 = 0;
      }
      v88 = dataOutAvailable;
      v89 = CFDataCreateMutable(0, (CFIndex)dataOutAvailable);
      v25 = v89;
      if (v89)
      {
        v90 = &v118[v109];
        CFDataSetLength(v89, (CFIndex)dataOutAvailable);
        if (v124)
        {
          v117 = (const __CFString *)&v108;
          __chkstk_darwin(v91);
          v93 = (char *)&v108 - ((v92 + 15) & 0xFFFFFFFFFFFFFFF0);
          memset(v93, 170, v92);
          v94 = CFDataGetBytePtr(Mutable);
          v118 = v86;
          v95 = v90;
          v96 = v94;
          v97 = CFDataGetLength(Mutable);
          MutableBytePtr = CFDataGetMutableBytePtr(v25);
          v99 = CCCryptorGCM(1, 0, v96, v97, v111, v110, v87, v118, v95, v88, MutableBytePtr, v93, &v124);
          if ((_DWORD)v99)
          {
            v22 = sub_100019F20(-26275, v120, CFSTR("ks_decrypt_data: CCCryptorGCM failed: %d"), v99);
            v17 = v114;
            v18 = v115;
            v26 = v119;
LABEL_153:
            v24 = 0;
            goto LABEL_83;
          }
          v18 = v115;
          v26 = v119;
          if (v124 != 16)
          {
            v22 = sub_100019F20(-26276, v120, CFSTR("ks_decrypt_data: CCCryptorGCM expected: 16 got: %ld byte tag"), v124);
            v17 = v114;
            goto LABEL_153;
          }
          if (timingsafe_bcmp(v93, &dataOutAvailable[(_QWORD)v95], 0x10uLL))
          {
            v22 = sub_100019F20(-26275, v120, CFSTR("ks_decrypt_data: CCCryptorGCM computed tag not same as tag in blob"));
            v17 = v114;
            goto LABEL_153;
          }
        }
        else
        {
          *(_QWORD *)buf = 0xAAAAAAAAAAAAAAAALL;
          v100 = CFDataGetBytePtr(Mutable);
          v101 = CFDataGetLength(Mutable);
          dataOut = CFDataGetMutableBytePtr(v25);
          v103 = CCCrypt(1u, 0, 1u, v100, v101, 0, v90, (size_t)dataOutAvailable, dataOut, (size_t)dataOutAvailable, (size_t *)buf);
          v18 = v115;
          if ((_DWORD)v103)
          {
            v22 = sub_100019F20(-26275, v120, CFSTR("ks_decrypt_data: CCCrypt failed: %d"), v103);
            v24 = 0;
            v17 = v114;
            goto LABEL_83;
          }
          CFDataSetLength(v25, *(CFIndex *)buf);
        }
        v17 = v114;
        if ((_DWORD)v22)
        {
          v24 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          CFDictionaryAddValue(v24, CFSTR("v_Data"), v25);
        }
        else
        {
          if (v26 == 2)
            v104 = (__CFDictionary *)sub_10011CDF4(v25, (CFErrorRef *)v120);
          else
            v104 = (__CFDictionary *)sub_10011CE2C(v25, (CFTypeRef *)v120);
          v24 = v104;
        }
        if (v24)
        {
          v22 = 1;
          if (v26 >= 4 && v131)
          {
            context[0] = _NSConcreteStackBlock;
            context[1] = 3221225472;
            context[2] = sub_10011CF2C;
            context[3] = &unk_1002ECD08;
            context[4] = v24;
            CFDictionaryApplyFunction(v131, (CFDictionaryApplierFunction)sub_10011C8D8, context);
          }
          goto LABEL_83;
        }
        v105 = sub_10000EF14("SecError");
        v106 = objc_claimAutoreleasedReturnValue(v105);
        if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
        {
          v107 = (__CFString *)v120;
          if (v120)
            v107 = *v120;
          *(_DWORD *)buf = 67109378;
          *(_DWORD *)&buf[4] = v119;
          v133 = 2112;
          v134 = v107;
          _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_DEFAULT, "decode v%d failed: %@", buf, 0x12u);
        }

        v24 = 0;
LABEL_74:
        v22 = 0;
        goto LABEL_31;
      }
      v22 = sub_100019F20(-26275, v120, CFSTR("ks_decrypt_data: failed to allocate data for plain text"));
      v24 = 0;
LABEL_140:
      v18 = v115;
      goto LABEL_83;
    }
LABEL_155:
    v24 = 0;
    v25 = 0;
    goto LABEL_140;
  }
  if (!CFEqual(v74, CFSTR("odel")))
  {
    v22 = sub_100019F20(-26276, v120, CFSTR("ks_decrypt_data: invalid operation"));
    goto LABEL_155;
  }
  v18 = v115;
  if (sub_100146D5C(v129, v116, v23, (uint64_t)v122, (CFErrorRef *)v120))
  {
    v24 = v131;
    if (v131)
      CFRetain(v131);
    v25 = 0;
    v22 = 1;
  }
  else
  {
    v24 = 0;
    v25 = 0;
    v22 = 0;
  }
LABEL_83:
  v75 = CFDataGetMutableBytePtr(Mutable);
  v76 = CFDataGetLength(Mutable);
  v77 = CFDataGetLength(Mutable);
  memset_s(v75, v76, 0, v77);
  if (Mutable)
    CFRelease(Mutable);
  if (v25)
    CFRelease(v25);
  if (v121)
  {
    *v121 = v122;
  }
  else if (v122)
  {
    CFRelease(v122);
  }
  if ((_DWORD)v22)
  {
    if (v18)
    {
      v78 = *v18;
      if (*v18 != v24)
      {
        if (!v24 || (CFRetain(v24), (v78 = *v18) != 0))
          CFRelease(v78);
        *v18 = v24;
      }
    }
    if (v17)
      *v17 = v26;
  }
  if (v24)
    CFRelease(v24);
  v79 = v131;
  if (v131)
  {
    v131 = 0;
    CFRelease(v79);
  }
  if (v23)
    CFRelease(v23);
  v80 = v130;
  if (v130)
  {
    v130 = 0;
    CFRelease(v80);
  }
  if (v129)
    sub_100024478(&v129);
  return v22;
}

void sub_1000180EC(uint64_t a1)
{
  void *v1;
  unsigned int v3;
  void *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  id v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  char v14;
  _QWORD v15[5];
  id v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  char v21;

  v3 = +[SecDbKeychainMetadataKeyStore cachingEnabled](SecDbKeychainMetadataKeyStore, "cachingEnabled");
  if (v3)
  {
    v4 = *(void **)(*(_QWORD *)(a1 + 32) + 24);
    v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(a1 + 80)));
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "objectForKeyedSubscript:", v1));
  }
  else
  {
    v5 = 0;
  }
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40), v5);
  if (v3)
  {

  }
  v6 = *(_QWORD *)(a1 + 48);
  if (!*(_QWORD *)(*(_QWORD *)(v6 + 8) + 40))
  {
    v7 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24;
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 3221225472;
    v15[2] = sub_1001BBCCC;
    v15[3] = &unk_1002EADD0;
    v8 = *(_QWORD *)(a1 + 32);
    v9 = *(void **)(a1 + 40);
    v17 = v6;
    v15[4] = v8;
    v19 = *(_QWORD *)(a1 + 80);
    v10 = v9;
    v20 = *(_BYTE *)(a1 + 88);
    v11 = *(_QWORD *)(a1 + 72);
    v16 = v10;
    v18 = v11;
    v21 = v3;
    v12 = sub_100011A30(1, 0, 0, v7, (uint64_t)v15);
    v13 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
    if (*(_BYTE *)(v13 + 24))
      v14 = v12;
    else
      v14 = 0;
    *(_BYTE *)(v13 + 24) = v14;

  }
}

const __CFData *sub_100018CF8(const __CFData *result)
{
  const __CFData *v1;
  const UInt8 *BytePtr;

  if (result)
  {
    v1 = result;
    if (CFDataGetLength(result) != 16)
      return 0;
    BytePtr = CFDataGetBytePtr(v1);
    if (*(_QWORD *)BytePtr == 0xAC4C81CC5CAE23F6 && *((_QWORD *)BytePtr + 1) == 0x1135313F01F0D48ALL)
      return 0;
    if (*(_QWORD *)BytePtr == 0x104B57A5353A5AA7 && *((_DWORD *)BytePtr + 2) == -1803342146)
      return 0;
    return (const __CFData *)((*(_QWORD *)BytePtr != 0x114EC8A39FAB1A82 || *((_DWORD *)BytePtr + 2) != -397635414)
                           && (*(_QWORD *)BytePtr != 0x9A460A992EBEC436 || *((_DWORD *)BytePtr + 2) != -1542878804));
  }
  return result;
}

void sub_100018DF8(size_t size, uint64_t a2)
{
  void *v4;
  uint64_t v5;

  if (size)
  {
    if (size > 0x800)
    {
      v4 = malloc_type_malloc(size, 0x9C1A2F70uLL);
      (*(void (**)(uint64_t, size_t, void *))(a2 + 16))(a2, size, v4);
      if (v4)
        free(v4);
    }
    else
    {
      __chkstk_darwin();
      memset((char *)&v5 - ((size + 15) & 0xFFFFFFFFFFFFFFF0), 170, size);
      (*(void (**)(uint64_t, size_t, char *))(a2 + 16))(a2, size, (char *)&v5 - ((size + 15) & 0xFFFFFFFFFFFFFFF0));
    }
  }
  else
  {
    (*(void (**)(uint64_t, _QWORD, _QWORD))(a2 + 16))(a2, 0, 0);
  }
}

uint64_t sub_100018F4C(uint64_t result, int a2, UInt8 *buffer)
{
  uint64_t v4;
  const __CFString *v5;
  CFIndex v6;
  CFIndex usedBufLen;
  CFRange v8;

  if (buffer)
  {
    v4 = result;
    v5 = *(const __CFString **)(result + 40);
    v8 = *(CFRange *)(v4 + 48);
    v6 = *(_QWORD *)(v4 + 64);
    usedBufLen = 0xAAAAAAAAAAAAAAAALL;
    CFStringGetBytes(v5, v8, 0x8000100u, 0, 0, buffer, v6, &usedBufLen);
    buffer[usedBufLen] = 0;
    return (*(uint64_t (**)(void))(*(_QWORD *)(v4 + 32) + 16))();
  }
  return result;
}

void sub_100018FC0(uint64_t a1, CFTypeRef cf)
{
  const void *v3;
  const void *Protection;
  __CFString **v5;
  const __CFString *v6;

  v3 = *(const void **)(a1 + 136);
  if (!v3)
  {
    *(_QWORD *)(a1 + 136) = CFRetain(cf);
    Protection = (const void *)SecAccessControlGetProtection();
    if (Protection)
    {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 8), kSecAttrAccessible, Protection);
      return;
    }
    v5 = (__CFString **)(a1 + 40);
    v6 = CFSTR("kSecAccessControl missing protection");
    goto LABEL_8;
  }
  if (!CFEqual(v3, cf))
  {
    v5 = (__CFString **)(a1 + 40);
    v6 = CFSTR("conflicting kSecAccess and kSecAccessControl attributes");
LABEL_8:
    sub_100019F20(-50, v5, v6);
  }
}

__CFDictionary *sub_10001904C(_QWORD *a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  __CFDictionary *Mutable;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *i;
  uint64_t v12;
  const void *v13;
  const void *v14;
  _QWORD *v15;
  NSObject *v16;
  const __CFString *v18;
  uint8_t buf[4];
  const __CFString *v21;

  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v9 = a1[2];
  v10 = *(_QWORD **)(v9 + 16);
  if (!v10)
    return Mutable;
  for (i = (_QWORD *)(v9 + 24); ; ++i)
  {
    v12 = v10[2];
    if ((a2 & ~v12) == 0)
    {
      if ((v12 & a3) != 0)
        return Mutable;
      v13 = sub_100019204(a1, (uint64_t)v10, a4);
      if (!v13)
        goto LABEL_17;
      v14 = v13;
      if (!CFEqual(kCFNull, v13))
      {
        CFDictionarySetValue(Mutable, (const void *)*v10, v14);
        goto LABEL_10;
      }
      if ((*((_BYTE *)v10 + 17) & 0x10) != 0)
        break;
    }
LABEL_10:
    v15 = (_QWORD *)*i;
    v10 = v15;
    if (!v15)
      return Mutable;
  }
  sub_100019F20(-26275, a4, CFSTR("attribute %@ has NULL value"), *v10);
  v16 = sub_10000EF14("SecError");
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    if (a4)
      v18 = *a4;
    else
      v18 = CFSTR("error == NULL");
    *(_DWORD *)buf = 138412290;
    v21 = v18;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%@", buf, 0xCu);
  }
LABEL_17:
  if (Mutable)
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

const void *sub_100019204(const void *a1, uint64_t a2, __CFString **a3)
{
  unint64_t v6;
  void *v7;
  CFDataRef v8;
  CFDataRef v9;

  if (!a2)
    return 0;
  v6 = *(_QWORD *)(a2 + 16);
  if ((v6 & 0x20A0) != 0 && !sub_1000192F4((uint64_t)a1, (v6 >> 5) & 1, a3))
    return 0;
  v7 = (void *)sub_1000198E0((uint64_t)a1, (const void **)a2);
  if (v7)
    return v7;
  v8 = sub_1000199CC(a1, a2);
  if (!v8)
    return 0;
  v9 = v8;
  v7 = kCFNull;
  if (CFEqual(kCFNull, v8))
  {
    CFRelease(v9);
    return v7;
  }
  sub_10001A56C((uint64_t)a1, (_QWORD *)a2, v9, a3);
  CFRelease(v9);
  return sub_1000198E0((uint64_t)a1, (const void **)a2);
}

BOOL sub_1000192F4(uint64_t a1, int a2, __CFString **a3)
{
  int v3;
  int v4;
  const void **v9;
  const __CFData *v10;
  const __CFData *Value;
  const void *v12;
  uint64_t v13;
  const void *v14;
  CFTypeID v15;
  _BOOL4 v16;
  CFTypeID v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  int v22;
  const void *v23;
  const void *v24;
  CFTypeID v25;
  const CFStringRef *v26;
  const __CFData *v27;
  uint64_t v28;
  CFStringRef v29;
  const __CFNumber *v30;
  const __CFNumber *v31;
  CFTypeID v32;
  int v33;
  const void *v34;
  const void *v35;
  const void *Protection;
  const void *v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  int v41;
  CFTypeID v42;
  const void *v43;
  const void *v44;
  CFTypeID v45;
  unsigned int v46;
  CFTypeRef cf;
  CFDictionaryRef theDict;
  int valuePtr;

  v3 = *(_DWORD *)(a1 + 40);
  if (v3 == 6)
    v4 = a2;
  else
    v4 = 0;
  if (v3 == 1 || v4 != 0)
  {
    v9 = (const void **)sub_10001E6A8(*(_QWORD **)(a1 + 16), 9, a3);
    if (v9)
    {
      v10 = (const __CFData *)sub_1000198E0(a1, v9);
      if (!v10)
        return sub_100019F20(-26276, a3, CFSTR("state= encrypted but edata is NULL"));
      *(_DWORD *)(a1 + 40) = 3;
      cf = 0;
      theDict = 0;
      v46 = 0;
      if (!sub_1000171E0(*(unsigned int *)(a1 + 28), *(_QWORD *)(a1 + 32), *(char **)(a1 + 64), &cf, *(const __CFData **)(a1 + 56), v10, *(_QWORD *)(a1 + 16), *(const __CFString **)(a1 + 72), (const void **)&theDict, &v46, a2, 0, a3))goto LABEL_52;
      if (v46 > 1)
      {
        if (theDict)
        {
          v22 = sub_10001A4F4(a1, theDict, a3);
LABEL_24:
          v16 = v22;
          goto LABEL_48;
        }
      }
      else
      {
        Value = (const __CFData *)CFDictionaryGetValue(theDict, CFSTR("v_Data"));
        if (sub_10001BA44(a1, CFSTR("v_Data"), Value, a3))
        {
          v12 = (const void *)sub_10000C1D0(a1, kSecAttrAccessGroup);
          v13 = sub_10000C1D0(a1, kSecAttrAccessible);
          if (!v12)
            goto LABEL_19;
          v14 = (const void *)v13;
          v15 = CFGetTypeID(v12);
          v16 = 1;
          if (v15 != CFStringGetTypeID() || !v14)
          {
LABEL_48:
            v34 = sub_10001D188((_QWORD **)a1, a3);
            if (v34)
            {
              v35 = v34;
              Protection = (const void *)SecAccessControlGetProtection(v34);
              v37 = (const void *)SecAccessControlGetProtection(cf);
              if (!CFEqual(Protection, v37))
              {
                v38 = SecAccessControlGetProtection(v35);
                v39 = SecAccessControlGetProtection(cf);
                v16 = sub_100019F20(-26275, a3, CFSTR("ACL protection doesn't match the one in blob (%@ : %@)"), v38, v39);
              }
              CFRelease(v35);
              goto LABEL_53;
            }
LABEL_52:
            v16 = 0;
LABEL_53:
            v40 = sub_10001D9C4(a1, (uint64_t)cf, 0);
            if (theDict)
              CFRelease(theDict);
            if (cf)
              CFRelease(cf);
            if (a2)
              v41 = 2;
            else
              v41 = 6;
            v20 = v40 & v16;
            if ((v40 & v16) == 0)
              v41 = 1;
            *(_DWORD *)(a1 + 40) = v41;
            return v20 & 1;
          }
          v17 = CFGetTypeID(v14);
          if (v17 != CFStringGetTypeID())
            goto LABEL_19;
          v18 = *(_QWORD *)(a1 + 16);
          if (v18 == sub_1000119B8((uint64_t)CFSTR("genp"), &qword_100341240, (uint64_t)&unk_100341238)
            && CFEqual(v14, kSecAttrAccessibleAlwaysPrivate))
          {
            v23 = (const void *)sub_10000C1D0(a1, kSecAttrService);
            if (!v23)
              goto LABEL_19;
            v24 = v23;
            v25 = CFGetTypeID(v23);
            if (v25 != CFStringGetTypeID() || !CFEqual(v12, CFSTR("apple")))
              goto LABEL_19;
            if (CFEqual(v24, CFSTR("AirPort")))
            {
LABEL_30:
              v26 = &kSecAttrAccessibleAfterFirstUnlock;
LABEL_34:
              v27 = (const __CFData *)*v26;
              v28 = a1;
              v29 = kSecAttrAccessible;
LABEL_35:
              v22 = sub_10001BA44(v28, v29, v27, a3);
              goto LABEL_24;
            }
            if (!CFEqual(v24, CFSTR("com.apple.airplay.password")))
            {
              if (CFEqual(v24, CFSTR("YouTube")))
              {
                if (sub_10001BA44(a1, kSecAttrAccessible, (const __CFData *)kSecAttrAccessibleWhenUnlocked, a3))
                {
                  v27 = (const __CFData *)CFSTR("com.apple.youtube.credentials");
                  v28 = a1;
                  v29 = kSecAttrAccessGroup;
                  goto LABEL_35;
                }
                goto LABEL_47;
              }
              v43 = (const void *)sub_10000C1D0(a1, kSecAttrDescription);
              if (v43)
              {
                v44 = v43;
                v45 = CFGetTypeID(v43);
                if (v45 == CFStringGetTypeID()
                  && (CFEqual(v44, CFSTR("IPSec Shared Secret")) || CFEqual(v44, CFSTR("PPP Password"))))
                {
                  goto LABEL_30;
                }
              }
LABEL_19:
              v16 = 1;
              goto LABEL_48;
            }
          }
          else
          {
            v19 = *(_QWORD *)(a1 + 16);
            if (v19 != sub_1000119B8((uint64_t)CFSTR("inet"), &qword_100341250, (uint64_t)&unk_100341248)
              || !CFEqual(v14, kSecAttrAccessibleAlwaysPrivate))
            {
              goto LABEL_19;
            }
            if (!CFEqual(v12, CFSTR("PrintKitAccessGroup")))
            {
              if (!CFEqual(v12, CFSTR("apple")))
                goto LABEL_19;
              v30 = (const __CFNumber *)sub_10000C1D0(a1, kSecAttrProtocol);
              if (!v30)
                goto LABEL_19;
              v31 = v30;
              v32 = CFGetTypeID(v30);
              if (v32 == CFNumberGetTypeID())
              {
                valuePtr = -1431655766;
                CFNumberGetValue(v31, kCFNumberSInt32Type, &valuePtr);
                if (valuePtr > 2020635749)
                {
                  if (valuePtr > 2020832359)
                  {
                    if (valuePtr == 2020832370)
                      goto LABEL_33;
                    v33 = 2020832360;
                  }
                  else
                  {
                    if (valuePtr == 2020635750)
                      goto LABEL_33;
                    v33 = 2020635752;
                  }
                }
                else if (valuePtr > 1752462199)
                {
                  if (valuePtr == 1752462200)
                    goto LABEL_33;
                  v33 = 1920234360;
                }
                else
                {
                  if (valuePtr == 1718907000)
                    goto LABEL_33;
                  v33 = 1752461432;
                }
                if (valuePtr != v33)
                  goto LABEL_19;
              }
              else
              {
                v42 = CFGetTypeID(v31);
                if (v42 != CFStringGetTypeID()
                  || !CFEqual(v31, kSecAttrProtocolHTTPProxy)
                  && !CFEqual(v31, kSecAttrProtocolHTTPSProxy)
                  && !CFEqual(v31, kSecAttrProtocolRTSPProxy)
                  && !CFEqual(v31, kSecAttrProtocolFTPProxy))
                {
                  goto LABEL_19;
                }
              }
            }
          }
LABEL_33:
          v26 = &kSecAttrAccessibleWhenUnlocked;
          goto LABEL_34;
        }
      }
LABEL_47:
      v16 = 0;
      goto LABEL_48;
    }
  }
  v20 = 1;
  return v20 & 1;
}

const void *sub_1000198E0(uint64_t a1, const void **a2)
{
  uint64_t v2;
  NSObject *v4;
  const char *v5;
  uint8_t *v6;
  _BOOL4 v7;
  __int16 v8;
  uint8_t buf[2];
  __int16 v10;

  if (a1)
  {
    v2 = *(_QWORD *)(a1 + 48);
    if (a2 && v2)
      return CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 48), *a2);
    v4 = sub_10000EF14("SecError");
    v7 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (v2)
    {
      if (v7)
      {
        v8 = 0;
        v5 = "secitem: desc is nil!";
        v6 = (uint8_t *)&v8;
        goto LABEL_12;
      }
    }
    else if (v7)
    {
      *(_WORD *)buf = 0;
      v5 = "secitem: item->attributes is nil!";
      v6 = buf;
      goto LABEL_12;
    }
  }
  else
  {
    v4 = sub_10000EF14("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v10 = 0;
      v5 = "secitem: item is nil!";
      v6 = (uint8_t *)&v10;
LABEL_12:
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v5, v6, 2u);
    }
  }
  return 0;
}

CFDataRef sub_1000199CC(const void *a1, uint64_t a2)
{
  uint64_t (*v2)(void);
  CFDataRef result;
  const __CFString *v4;
  int v5;
  uint64_t v6;
  const __CFAllocator *v7;
  CFAllocatorRef v8;
  double Current;
  const __CFAllocator *v10;
  const __CFAllocator *v11;
  int valuePtr;

  v2 = *(uint64_t (**)(void))(a2 + 24);
  if (v2)
    return (CFDataRef)v2();
  v4 = 0;
  v5 = *(_DWORD *)(a2 + 8);
  switch(v5)
  {
    case 0:
    case 2:
    case 14:
    case 15:
      v6 = *(_QWORD *)(a2 + 16);
      if ((v6 & 0x1000) == 0)
        goto LABEL_13;
      if ((v6 & 0x400) != 0)
      {
        v4 = CFSTR("0");
        goto LABEL_19;
      }
      if (v5 && (v6 & 0x800) != 0)
      {
        v4 = &stru_1002EE888;
        goto LABEL_19;
      }
      goto LABEL_13;
    case 1:
      v6 = *(_QWORD *)(a2 + 16);
LABEL_13:
      if ((~(_WORD)v6 & 0x1800) == 0)
        goto LABEL_14;
      goto LABEL_18;
    case 3:
    case 11:
    case 12:
      if ((*(_BYTE *)(a2 + 17) & 0x10) == 0)
        goto LABEL_18;
      valuePtr = 0;
      v7 = CFGetAllocator(a1);
      v4 = (const __CFString *)CFNumberCreate(v7, kCFNumberSInt32Type, &valuePtr);
      goto LABEL_19;
    case 4:
      if ((~*(_DWORD *)(a2 + 16) & 0x1400) != 0)
        goto LABEL_18;
      v10 = kCFAllocatorDefault;
      Current = 0.0;
      return CFDateCreate(v10, Current);
    case 5:
    case 6:
      v8 = CFGetAllocator(a1);
      Current = CFAbsoluteTimeGetCurrent();
      v10 = v8;
      return CFDateCreate(v10, Current);
    case 8:
    case 13:
LABEL_18:
      v4 = (const __CFString *)kCFNull;
      goto LABEL_19;
    case 16:
LABEL_14:
      v11 = CFGetAllocator(a1);
      return CFDataCreate(v11, 0, 0);
    default:
LABEL_19:
      result = (CFDataRef)v4;
      break;
  }
  return result;
}

__CFData *sub_100019B00(const __CFAllocator *a1, CFIndex *a2, uint64_t a3, uint64_t a4)
{
  __CFData *Mutable;
  UInt8 *MutableBytePtr;

  Mutable = CFDataCreateMutable(a1, *a2);
  CFDataSetLength(Mutable, *a2);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  ccdigest(a2, a3, a4, MutableBytePtr);
  return Mutable;
}

__CFData *sub_100019B60(const __CFData *a1)
{
  CFIndex Length;
  const __CFAllocator *v3;
  const UInt8 *BytePtr;
  CFIndex *v5;

  Length = CFDataGetLength(a1);
  v3 = CFGetAllocator(a1);
  BytePtr = CFDataGetBytePtr(a1);
  v5 = (CFIndex *)ccsha1_di();
  return sub_100019B00(v3, v5, Length, (uint64_t)BytePtr);
}

uint64_t sub_100019BB8(_QWORD *a1, sqlite3_stmt *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  char v8;
  _QWORD v10[6];

  v3 = a1[6];
  v4 = *(_QWORD *)(a1[5] + 8);
  v10[0] = _NSConcreteStackBlock;
  v10[2] = sub_100019EE0;
  v10[3] = &unk_1002DB420;
  v5 = a1[7];
  v10[1] = 0x40000000;
  v10[4] = v3;
  v10[5] = a2;
  v6 = sub_100019C40(v5, a2, (CFTypeRef *)(v4 + 24), (uint64_t)v10);
  v7 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v7 + 24))
    v8 = v6;
  else
    v8 = 0;
  *(_BYTE *)(v7 + 24) = v8;
  return 1;
}

uint64_t sub_100019C40(uint64_t a1, sqlite3_stmt *pStmt, CFTypeRef *a3, uint64_t a4)
{
  uint64_t result;
  _QWORD *v9;
  void *v10;
  _QWORD v11[2];
  uint64_t (*v12)(uint64_t);
  void *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  char v19;

  while (1)
  {
    while (1)
    {
      result = sub_100019D70(a1, pStmt, (int)a3);
      if ((_DWORD)result == 1)
        break;
      if (!(_DWORD)result)
        return result;
      if ((_DWORD)result == 2)
        return 1;
    }
    if (!a4)
      break;
    v16 = 0;
    v17 = &v16;
    v18 = 0x2000000000;
    v19 = 0;
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000;
    v12 = sub_100019EC8;
    v13 = &unk_1002DB470;
    v14 = a4;
    v15 = &v16;
    v9 = v11;
    v10 = objc_autoreleasePoolPush();
    v12((uint64_t)v9);
    objc_autoreleasePoolPop(v10);

    LODWORD(v9) = *((unsigned __int8 *)v17 + 24);
    _Block_object_dispose(&v16, 8);
    if ((_DWORD)v9)
      return 1;
  }
  sub_10003060C(1, a3, CFSTR("SecDbStep SQLITE_ROW returned without a row handler"));
  return 0;
}

uint64_t sub_100019D70(uint64_t a1, sqlite3_stmt *pStmt, int a3)
{
  int v6;
  NSObject *v7;
  const char *v8;
  int v9;
  char v10;
  uint8_t buf[4];
  const char *v13;

  v6 = 0;
  while (1)
  {
    if (*(_BYTE *)(a1 + 24) && !sqlite3_stmt_readonly(pStmt))
    {
      v7 = sub_10000EF14("SecError");
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        v8 = sqlite3_sql(pStmt);
        *(_DWORD *)buf = 136315138;
        v13 = v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "_SecDbStep: SecDbConnection is readonly but we're about to write: %s", buf, 0xCu);
      }
    }
    v9 = sqlite3_step(pStmt);
    if (v9 == 100)
      return 1;
    if (v9 == 101)
      break;
    v10 = sub_100030AE8(a1, v9, (int)CFSTR("step"), v6++, a3);
    if ((v10 & 1) == 0)
      return 0;
  }
  sqlite3_reset(pStmt);
  return 2;
}

uint64_t sub_100019EC8(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
}

uint64_t sub_100019EE0(uint64_t a1, _BYTE *a2)
{
  uint64_t result;

  result = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 40), 0);
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  *a2 = 1;
  return result;
}

BOOL sub_100019F20(int a1, __CFString **a2, CFStringRef format, ...)
{
  CFTypeRef v5;
  CFTypeRef cf;
  va_list va;

  va_start(va, format);
  if (a1)
  {
    cf = 0;
    if (a2)
    {
      sub_10001A09C(a1, kCFErrorDomainOSStatus, *a2, &cf, format, va);
      *a2 = (__CFString *)cf;
    }
    else
    {
      sub_10001A09C(a1, kCFErrorDomainOSStatus, 0, &cf, format, va);
      v5 = cf;
      if (cf)
      {
        cf = 0;
        CFRelease(v5);
      }
    }
  }
  return a1 == 0;
}

CFDataRef sub_100019FB0(uint64_t a1, __CFString **a2)
{
  CFNumberRef v2;
  CFDataRef result;
  double Current;
  const __CFAllocator *v5;
  int valuePtr;

  v2 = (CFNumberRef)&stru_1002EE888;
  switch(*(_DWORD *)(a1 + 8))
  {
    case 0:
    case 1:
    case 0x10:
      return CFDataCreate(kCFAllocatorDefault, 0, 0);
    case 2:
    case 0xE:
    case 0xF:
      goto LABEL_8;
    case 3:
    case 0xB:
    case 0xC:
      valuePtr = 0;
      v2 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
      goto LABEL_8;
    case 4:
      v5 = kCFAllocatorDefault;
      Current = 0.0;
      goto LABEL_6;
    case 5:
    case 6:
      Current = CFAbsoluteTimeGetCurrent();
      v5 = kCFAllocatorDefault;
LABEL_6:
      result = CFDateCreate(v5, Current);
      break;
    default:
      sub_100019F20(-26276, a2, CFSTR("attr %@ has no default value"), *(_QWORD *)a1);
      v2 = 0;
LABEL_8:
      result = v2;
      break;
  }
  return result;
}

void sub_10001A09C(CFIndex a1, const __CFString *a2, __CFString *cf, CFTypeRef *a4, CFStringRef format, va_list arguments)
{
  const __CFString *v10;
  const __CFDictionary *v11;
  const __CFString *Value;
  _BOOL4 v13;
  CFIndex Code;
  const __CFString *Domain;
  CFComparisonResult v16;
  _BOOL4 v18;
  __CFString *v19;
  const __CFString *v20;
  const __CFDictionary *v21;
  const __CFDictionary *v22;
  const void *v23;
  const __CFNumber *v24;
  CFNumberRef v25;
  __CFDictionary *Mutable;
  __CFDictionary *v27;
  uint64_t v28;
  uint64_t valuePtr;

  if (!a4)
    return;
  if (*a4)
  {
    if (cf)
    {
      if (*a4 != cf)
        CFRelease(cf);
    }
    return;
  }
  v10 = CFStringCreateWithFormatAndArguments(0, 0, format, arguments);
  v28 = 0;
  if (!cf)
    goto LABEL_28;
  v11 = CFErrorCopyUserInfo((CFErrorRef)cf);
  Value = (const __CFString *)CFDictionaryGetValue(v11, kCFErrorDescriptionKey);
  if (Value)
  {
    v13 = CFStringCompare(v10, Value, 0) == kCFCompareEqualTo;
    if (!v11)
      goto LABEL_10;
    goto LABEL_9;
  }
  v13 = 0;
  if (v11)
LABEL_9:
    CFRelease(v11);
LABEL_10:
  Code = CFErrorGetCode((CFErrorRef)cf);
  Domain = CFErrorGetDomain((CFErrorRef)cf);
  v16 = CFStringCompare(a2, Domain, 0);
  v18 = Code == a1 && v16 == kCFCompareEqualTo && v13;
  v19 = cf;
  if (v18)
    goto LABEL_17;
  v21 = CFErrorCopyUserInfo((CFErrorRef)cf);
  if (v21)
  {
    v22 = v21;
    v23 = (const void *)kSOSCountKey;
    if (CFDictionaryContainsKey(v21, kSOSCountKey) == 1)
    {
      v24 = (const __CFNumber *)CFDictionaryGetValue(v22, v23);
      if (v24)
      {
        valuePtr = 0;
        CFNumberGetValue(v24, kCFNumberLongType, &valuePtr);
        if (valuePtr > 199)
        {
          CFRelease(v22);
          v19 = cf;
LABEL_17:
          CFRetain(v19);
          *a4 = cf;
          CFRelease(cf);
          if (!v10)
            return;
          v20 = v10;
          goto LABEL_42;
        }
        v28 = valuePtr + 1;
      }
    }
    CFRelease(v22);
  }
LABEL_28:
  v25 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongType, &v28);
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v27 = Mutable;
  if (cf)
    CFDictionaryAddValue(Mutable, kCFErrorUnderlyingErrorKey, cf);
  if (v25)
    CFDictionaryAddValue(v27, kSOSCountKey, v25);
  if (v10)
    CFDictionaryAddValue(v27, kCFErrorDescriptionKey, v10);
  *a4 = CFErrorCreate(kCFAllocatorDefault, a2, a1, v27);
  if (v25)
    CFRelease(v25);
  if (v10)
    CFRelease(v10);
  if (v27)
    CFRelease(v27);
  if (cf)
  {
    v20 = cf;
LABEL_42:
    CFRelease(v20);
  }
}

uint64_t sub_10001A338(uint64_t a1)
{
  uint64_t v2;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  if (qword_1003411B8 != -1)
    dispatch_once(&qword_1003411B8, &stru_1002DF068);
  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10000638C;
  v4[3] = &unk_1002DF090;
  v4[4] = &v5;
  v4[5] = a1;
  dispatch_sync((dispatch_queue_t)qword_1003411A8, v4);
  v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

__CFDictionary *sub_10001A3F4(_QWORD *a1, uint64_t a2, __CFString **a3)
{
  __CFDictionary *result;
  __CFDictionary *v4;
  __CFData *v5;

  result = sub_10001A42C(a1, a2, a3);
  if (result)
  {
    v4 = result;
    v5 = sub_100019B60(result);
    CFRelease(v4);
    return v5;
  }
  return result;
}

__CFDictionary *sub_10001A42C(_QWORD *a1, uint64_t a2, __CFString **a3)
{
  __CFDictionary *result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __CFDictionary *v8;
  __CFData *v9;

  result = sub_10001904C(a1, a2, 0, a3);
  if (result)
  {
    v8 = result;
    v9 = sub_10001A474((const __CFString *)result, (CFTypeRef *)a3, v5, v6, v7);
    CFRelease(v8);
    return v9;
  }
  return result;
}

__CFData *sub_10001A474(const __CFString *a1, CFTypeRef *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  CFIndex v7;
  __CFData *Mutable;
  UInt8 *MutableBytePtr;

  v7 = sub_1000212A4(a1, a2, a3, a4, a5);
  Mutable = CFDataCreateMutable(0, v7);
  CFDataSetLength(Mutable, v7);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  if (!sub_100020FA0(a1, a2, 0, MutableBytePtr, (unint64_t)&MutableBytePtr[v7]) && Mutable)
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

uint64_t sub_10001A4F4(uint64_t a1, CFDictionaryRef theDict, __CFString **a3)
{
  uint64_t v3;
  const void **v4;
  const void ***i;
  const __CFData *Value;
  uint64_t result;
  const void **v11;

  v3 = *(_QWORD *)(a1 + 16);
  v4 = *(const void ***)(v3 + 16);
  if (!v4)
    return 1;
  for (i = (const void ***)(v3 + 24); ; ++i)
  {
    Value = (const __CFData *)CFDictionaryGetValue(theDict, *v4);
    if (Value)
    {
      result = sub_10001A56C(a1, v4, Value, a3);
      if (!(_DWORD)result)
        break;
    }
    v11 = *i;
    v4 = v11;
    if (!v11)
      return 1;
  }
  return result;
}

uint64_t sub_10001A56C(uint64_t a1, _QWORD *a2, const __CFData *a3, __CFString **a4)
{
  const __CFData *v7;
  uint64_t (*v8)(uint64_t, _QWORD *, const __CFData *, __CFString **);
  uint64_t result;
  const __CFData *v10;
  CFDataRef v11;
  CFDataRef v12;
  int v13;
  const __CFData *v14;
  const void *Value;
  int v16;
  const void *v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  __CFDictionary *v24;
  const void *v25;
  __CFDictionary *v26;

  if (!a2)
    return 0;
  if (a3)
    v7 = a3;
  else
    v7 = kCFNull;
  v8 = (uint64_t (*)(uint64_t, _QWORD *, const __CFData *, __CFString **))a2[4];
  if (v8)
    return v8(a1, a2, v7, a4);
  if ((a2[2] & 0x2080) == 0 || (result = sub_1000192F4(a1, 1, a4), (_DWORD)result))
  {
    switch(*((_DWORD *)a2 + 2))
    {
      case 0:
      case 0xF:
        v10 = (const __CFData *)sub_1000127F4(v7);
        goto LABEL_22;
      case 1:
      case 0xA:
        v10 = sub_10001264C((const __CFString *)v7);
        goto LABEL_22;
      case 2:
      case 0xE:
        v10 = (const __CFData *)sub_100013F48((const __CFString *)v7);
        goto LABEL_22;
      case 3:
      case 8:
      case 0xB:
      case 0xC:
        v10 = sub_100012708(v7);
        goto LABEL_22;
      case 4:
      case 5:
      case 6:
        v10 = (const __CFData *)sub_10001A8DC(v7);
        goto LABEL_22;
      case 7:
        v10 = sub_10001A880(v7);
        goto LABEL_22;
      case 9:
        v11 = sub_10001264C((const __CFString *)v7);
        if (v11)
        {
          v12 = v11;
          if (*(_DWORD *)(a1 + 40) == 4)
            v13 = 2;
          else
            v13 = 1;
          *(_DWORD *)(a1 + 40) = v13;
LABEL_23:
          Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 48), (const void *)*a2);
          if (Value)
          {
            v16 = CFEqual(Value, v12);
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 48), (const void *)*a2, v12);
            CFRelease(v12);
            if (!v16)
              goto LABEL_34;
            return 1;
          }
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 48), (const void *)*a2, v12);
          CFRelease(v12);
LABEL_34:
          v19 = a2[2];
          if ((v19 & 0x100) != 0)
          {
            v20 = sub_10001E6A8(*(_QWORD **)(a1 + 16), 7, 0);
            sub_10001A56C(a1, v20, kCFNull, 0);
            v19 = a2[2];
          }
          if ((v19 & 1) != 0)
          {
            v21 = sub_10001E6A8(*(_QWORD **)(a1 + 16), 10, 0);
            sub_10001A56C(a1, v21, kCFNull, 0);
            v19 = a2[2];
          }
          if ((v19 & 0x2080) != 0)
          {
            v22 = *(_DWORD *)(a1 + 40);
            if (v22 == 2 || v22 == 6 && (v19 & 0x20) == 0)
            {
              v23 = sub_10001E6A8(*(_QWORD **)(a1 + 16), 9, 0);
              sub_10001A56C(a1, v23, kCFNull, 0);
              v19 = a2[2];
            }
          }
          if ((v19 & 8) == 0)
            return 1;
          v24 = *(__CFDictionary **)(a1 + 48);
          v25 = (const void *)sub_1000107E4(a2);
          v26 = v24;
          goto LABEL_46;
        }
        if (!v7 || CFEqual(kCFNull, v7))
        {
          *(_DWORD *)(a1 + 40) = 0;
LABEL_30:
          if (!v7)
            goto LABEL_32;
        }
        if (CFEqual(kCFNull, v7))
        {
LABEL_32:
          v17 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 48), (const void *)*a2);
          if (!v17)
          {
            v26 = *(__CFDictionary **)(a1 + 48);
            v25 = (const void *)*a2;
LABEL_46:
            CFDictionaryRemoveValue(v26, v25);
            return 1;
          }
          v18 = CFEqual(v17, kCFNull);
          CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 48), (const void *)*a2);
          if (v18)
            return 1;
          goto LABEL_34;
        }
        sub_100019F20(-50, a4, CFSTR("attribute %@: value: %@ failed to convert"), *a2, v7);
        break;
      case 0xD:
        v14 = (const __CFData *)sub_100004688(v7);
        if (!v14)
          goto LABEL_30;
        v12 = v14;
        CFRetain(v14);
        goto LABEL_23;
      case 0x10:
        v10 = sub_10001A920(v7);
LABEL_22:
        v12 = v10;
        if (v10)
          goto LABEL_23;
        goto LABEL_30;
      default:
        goto LABEL_30;
    }
    return 0;
  }
  return result;
}

CFDataRef sub_10001A880(const void *a1)
{
  CFTypeID v2;
  const __CFAllocator *v3;

  v2 = CFGetTypeID(a1);
  if (v2 != CFDataGetTypeID() || CFDataGetLength((CFDataRef)a1) != 20)
    return 0;
  v3 = CFGetAllocator(a1);
  return CFDataCreateCopy(v3, (CFDataRef)a1);
}

const void *sub_10001A8DC(const void *a1)
{
  const void *v1;
  CFTypeID v2;

  v1 = a1;
  v2 = CFGetTypeID(a1);
  if (v2 != CFDateGetTypeID())
    return 0;
  CFRetain(v1);
  return v1;
}

CFDataRef sub_10001A920(const void *a1)
{
  CFTypeID v2;
  CFUUIDBytes v4;

  v2 = CFGetTypeID(a1);
  if (v2 == CFDataGetTypeID())
  {
    if ((CFDataGetLength((CFDataRef)a1) & 0xFFFFFFFFFFFFFFEFLL) == 0)
      return CFDataCreateCopy(0, (CFDataRef)a1);
  }
  else
  {
    if (v2 == CFNullGetTypeID())
      return CFDataCreate(0, 0, 0);
    if (v2 == CFUUIDGetTypeID())
    {
      v4 = CFUUIDGetUUIDBytes((CFUUIDRef)a1);
      return CFDataCreate(0, &v4.byte0, 16);
    }
  }
  return 0;
}

uint64_t sub_10001A9D8(const void *a1, int a2, int a3, int a4, void *a5, int *a6, _DWORD *a7)
{
  uint64_t v14;
  mach_port_t v15;
  uint64_t v16;
  size_t v18;
  uint32_t outputCnt;
  uint64_t output;
  uint64_t input[2];

  v14 = 3758097084;
  v15 = sub_100015BC4();
  if (v15)
  {
    v14 = 3758097090;
    if (a1 && a5 && a6)
    {
      input[0] = a4;
      input[1] = a3;
      output = 0;
      outputCnt = 1;
      v18 = *a6;
      v16 = IOConnectCallMethod(v15, 0xAu, input, 2u, a1, a2, &output, &outputCnt, a5, &v18);
      if ((_DWORD)v16)
      {
        return v16;
      }
      else
      {
        *a6 = v18;
        v14 = 0;
        if (a7)
          *a7 = output;
      }
    }
  }
  else
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_wrap_key", ":", 848, "", 0, "", "");
  }
  return v14;
}

BOOL sub_10001AB40(uint64_t a1, uint64_t a2)
{
  CFTypeRef *v2;
  _QWORD v4[5];
  __int128 v5;
  CFTypeRef *v6;

  v2 = *(CFTypeRef **)(a1 + 32);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10001BC34;
  v4[3] = &unk_1002E7F40;
  v4[4] = a2;
  v5 = *(_OWORD *)(a1 + 40);
  v6 = v2;
  return sub_10001AC0C(a2, 2, v2, (uint64_t)v4);
}

BOOL sub_10001ABA8(_QWORD *a1, uint64_t a2)
{
  CFTypeRef *v2;
  _QWORD v4[8];

  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10001BC44;
  v4[3] = &unk_1002E7DC8;
  v2 = (CFTypeRef *)a1[4];
  v4[4] = a1[5];
  v4[5] = a2;
  v4[6] = a1[6];
  v4[7] = v2;
  return sub_10001AC0C(a2, 2, v2, (uint64_t)v4);
}

BOOL sub_10001AC0C(uint64_t a1, uint64_t a2, CFTypeRef *a3, uint64_t a4)
{
  _BOOL8 v4;
  _QWORD v6[6];
  _QWORD v7[3];
  char v8;

  v7[0] = 0;
  v7[1] = v7;
  v7[2] = 0x2000000000;
  v8 = 1;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = sub_10001AEDC;
  v6[3] = &unk_1002DF670;
  v6[4] = a4;
  v6[5] = v7;
  v4 = sub_10001AC94(a1, a2, a3, (uint64_t)v6);
  _Block_object_dispose(v7, 8);
  return v4;
}

BOOL sub_10001AC94(uint64_t a1, uint64_t a2, CFTypeRef *a3, uint64_t a4)
{
  NSObject *v5;
  _BOOL4 v6;
  const __CFString *v9;
  uint64_t v10;
  NSObject *v11;
  char v13;
  _QWORD block[5];
  uint8_t buf[8];
  uint64_t v16;
  void (*v17)(uint64_t);
  void *v18;
  _QWORD *v19;
  uint64_t *v20;
  uint64_t v21;
  CFTypeRef *v22;
  char v23;
  _QWORD v24[3];
  char v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  char v29;

  v13 = 1;
  if (*(_BYTE *)(a1 + 25))
  {
    (*(void (**)(uint64_t, char *))(a4 + 16))(a4, &v13);
    if (!v13)
    {
      v5 = sub_10000EF14("#SecDB");
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)buf = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "#SecDB nested transaction asked to not be committed", buf, 2u);
      }
    }
    v6 = 1;
  }
  else
  {
    v9 = CFSTR("BEGIN EXCLUSIVE");
    switch(a2)
    {
      case 2:
        goto LABEL_13;
      case 3:
        v9 = CFSTR("BEGIN");
        goto LABEL_13;
      case 4:
        *(_QWORD *)(a1 + 32) = 0;
        goto LABEL_13;
      case 5:
        v10 = 3;
        goto LABEL_12;
      case 6:
        v10 = 4;
LABEL_12:
        *(_QWORD *)(a1 + 32) = v10;
LABEL_13:
        if (sqlite3_get_autocommit(*(sqlite3 **)(a1 + 64)) && (sub_10001B41C(a1, v9, a3) & 1) == 0)
          goto LABEL_17;
        *(_BYTE *)(a1 + 25) = 1;
        (*(void (**)(uint64_t, char *))(a4 + 16))(a4, &v13);
        v26 = 0;
        v27 = &v26;
        v28 = 0x2000000000;
        v29 = 1;
        v24[0] = 0;
        v24[1] = v24;
        v24[2] = 0x2000000000;
        v25 = 0;
        *(_QWORD *)buf = _NSConcreteStackBlock;
        v16 = 0x40000000;
        v17 = sub_10001AF18;
        v18 = &unk_1002DB620;
        v23 = v13;
        v19 = v24;
        v20 = &v26;
        v21 = a1;
        v22 = a3;
        if (*(_BYTE *)(a1 + 24))
        {
          sub_10001AF18((uint64_t)buf);
        }
        else
        {
          v11 = *(NSObject **)(*(_QWORD *)(a1 + 16) + 32);
          block[0] = _NSConcreteStackBlock;
          block[1] = 0x40000000;
          block[2] = sub_100023034;
          block[3] = &unk_1002DB648;
          block[4] = buf;
          dispatch_barrier_sync(v11, block);
        }
        v6 = *((_BYTE *)v27 + 24) != 0;
        _Block_object_dispose(v24, 8);
        _Block_object_dispose(&v26, 8);
        break;
      default:
        sub_10003060C(1, a3, CFSTR("invalid transaction type %d"), a2);
LABEL_17:
        v6 = 0;
        break;
    }
  }
  return v13 && v6;
}

uint64_t sub_10001AEDC(uint64_t a1, _BYTE *a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  *a2 = result;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = result;
  return result;
}

void sub_10001AF18(uint64_t a1)
{
  int v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  double v11;
  int v12;
  int v13;
  NSObject *v14;
  char *errmsg;
  char *sql;
  uint8_t buf[4];
  int v18;
  __int16 v19;
  char *v20;

  v2 = *(unsigned __int8 *)(a1 + 64);
  v3 = *(_QWORD *)(a1 + 48);
  if (v2)
  {
    if (!*(_BYTE *)(v3 + 24))
    {
      sub_10001B168(v3, 1);
      v3 = *(_QWORD *)(a1 + 48);
    }
    v4 = sub_10001B41C(v3, CFSTR("END"), *(CFTypeRef **)(a1 + 56));
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v4;
  }
  else
  {
    v5 = sub_10001B41C(v3, CFSTR("ROLLBACK"), *(CFTypeRef **)(a1 + 56));
    v4 = 0;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v5;
  }
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v4;
  v6 = *(_QWORD *)(a1 + 48);
  *(_BYTE *)(v6 + 25) = 0;
  if (!*(_BYTE *)(v6 + 24))
  {
    sub_10001B168(v6, 2 * *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
    v6 = *(_QWORD *)(a1 + 48);
  }
  *(_QWORD *)(v6 + 32) = 1;
  if (*(_BYTE *)(a1 + 64))
  {
    if (*(_BYTE *)(*(_QWORD *)(v6 + 16) + 165))
    {
      if (!*(_BYTE *)(v6 + 24))
      {
        v7 = sub_10001B28C(v6, CFSTR("pragma page_count"), -1);
        if (v7 >= 1)
        {
          v8 = v7;
          v9 = sub_10001B28C(v6, CFSTR("pragma freelist_count"), -1);
          if ((v9 & 0x80000000) == 0)
          {
            LODWORD(v10) = v9;
            v11 = (double)(v8 - (uint64_t)v9) / (double)v8;
            if (v9 >> 13 || v11 <= 0.85)
            {
              if (v11 >= 0.4)
                v10 = (uint64_t)((double)v9 * 0.2);
              sql = 0;
              asprintf(&sql, "pragma incremental_vacuum(%d)", v10);
              if (sql)
              {
                errmsg = 0;
                v12 = sqlite3_exec(*(sqlite3 **)(v6 + 64), sql, 0, 0, &errmsg);
                if (v12)
                {
                  v13 = v12;
                  v14 = sub_10000EF14("SecError");
                  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 67109378;
                    v18 = v13;
                    v19 = 2082;
                    v20 = errmsg;
                    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "incremental_vacuum failed with: (%d) %{public}s", buf, 0x12u);
                  }
                }
                sqlite3_free(errmsg);
                free(sql);
              }
            }
          }
        }
      }
    }
  }
}

void sub_10001B168(uint64_t a1, uint64_t a2)
{
  const void *v4;
  uint64_t v5;
  os_unfair_lock_s *v6;
  const __CFArray *v7;
  const __CFArray *Copy;
  _QWORD context[7];
  CFRange v10;

  v4 = *(const void **)(a1 + 72);
  if (CFArrayGetCount((CFArrayRef)v4))
  {
    v5 = *(_QWORD *)(a1 + 16);
    v6 = (os_unfair_lock_s *)(v5 + 148);
    os_unfair_lock_lock((os_unfair_lock_t)(v5 + 148));
    v7 = *(const __CFArray **)(v5 + 152);
    if (v7)
    {
      Copy = CFArrayCreateCopy(kCFAllocatorDefault, v7);
      os_unfair_lock_unlock(v6);
      if (Copy)
      {
        *(_QWORD *)(a1 + 72) = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        context[0] = _NSConcreteStackBlock;
        context[1] = 0x40000000;
        context[2] = sub_100023018;
        context[3] = &unk_1002DB790;
        context[4] = a1;
        context[5] = a2;
        context[6] = v4;
        v10.length = CFArrayGetCount(Copy);
        v10.location = 0;
        CFArrayApplyFunction(Copy, v10, (CFArrayApplierFunction)sub_1000315EC, context);
        if (v4)
          CFRelease(v4);
        CFRelease(Copy);
      }
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 148));
    }
  }
}

uint64_t sub_10001B28C(uint64_t a1, const __CFString *a2, int a3)
{
  char v4;
  char v5;
  NSObject *v6;
  uint64_t v7;
  const void *v8;
  uint64_t v9;
  _QWORD v11[8];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  CFTypeRef v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  char v23;
  uint8_t buf[4];
  const __CFString *v25;
  __int16 v26;
  uint64_t v27;

  v20 = 0;
  v21 = &v20;
  v22 = 0x2000000000;
  v23 = 1;
  v16 = 0;
  v17 = &v16;
  v18 = 0x2000000000;
  v19 = a3;
  v12 = 0;
  v13 = &v12;
  v14 = 0x2000000000;
  v15 = 0;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  v11[2] = sub_100019BB8;
  v11[3] = &unk_1002DB448;
  v11[4] = &v20;
  v11[5] = &v12;
  v11[6] = &v16;
  v11[7] = a1;
  v4 = sub_1000129F0(a1, a2, &v15, (uint64_t)v11);
  if (*((_BYTE *)v21 + 24))
    v5 = v4;
  else
    v5 = 0;
  *((_BYTE *)v21 + 24) = v5;
  if ((v5 & 1) == 0)
  {
    v6 = sub_10000EF14("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v7 = v13[3];
      *(_DWORD *)buf = 138412546;
      v25 = a2;
      v26 = 2112;
      v27 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "SecDBGetInteger [%@] failed: %@", buf, 0x16u);
    }
  }
  v8 = (const void *)v13[3];
  if (v8)
  {
    v13[3] = 0;
    CFRelease(v8);
  }
  v9 = *((unsigned int *)v17 + 6);
  _Block_object_dispose(&v12, 8);
  _Block_object_dispose(&v16, 8);
  _Block_object_dispose(&v20, 8);
  return v9;
}

uint64_t sub_10001B41C(uint64_t a1, const __CFString *cf, CFTypeRef *a3)
{
  const __CFString *v4;
  sqlite3_stmt *v6;
  int v7;
  CFStringRef v9;

  v4 = cf;
  CFRetain(cf);
  if (!v4)
    return 1;
  LOBYTE(v6) = 1;
  do
  {
    v9 = 0;
    if ((v6 & 1) != 0)
    {
      v6 = sub_100012AE8(a1, v4, &v9, a3);
      if (v6)
      {
        do
          v7 = sub_100019D70(a1, v6, (int)a3);
        while (v7 == 1);
        v6 = (sqlite3_stmt *)((v7 != 0) & sub_100012D08(v6, a3));
      }
    }
    else
    {
      sub_10003060C(1, a3, CFSTR("Error with unexecuted sql remaining %@"), v4);
      v6 = 0;
    }
    CFRelease(v4);
    v4 = v9;
  }
  while (v9);
  return (uint64_t)v6;
}

BOOL sub_10001B508(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  const void *v8;
  _BOOL4 v9;
  _BOOL4 v10;
  uint64_t *v11;
  _BOOL4 v12;
  _BOOL8 v13;
  _QWORD v15[9];
  _QWORD v16[7];
  _QWORD v17[6];
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  char v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  char v25;

  v22 = 0;
  v23 = &v22;
  v24 = 0x2000000000;
  v25 = 1;
  v18 = 0;
  v19 = &v18;
  v20 = 0x2000000000;
  v21 = 0;
  v8 = (const void *)kSecAttrTombstone;
  if (!CFDictionaryContainsKey(*(CFDictionaryRef *)(a2 + 8), kSecAttrTombstone))
    sub_100012178(v8, kCFBooleanFalse, a2);
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 0x40000000;
  v17[2] = sub_10001ED0C;
  v17[3] = &unk_1002DF7F8;
  v17[4] = a2;
  v17[5] = a3;
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 0x40000000;
  v16[2] = sub_10001EF80;
  v16[3] = &unk_1002DF818;
  v16[4] = a2;
  v16[5] = a3;
  v16[6] = a4;
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 0x40000000;
  v15[2] = sub_10001BF4C;
  v15[3] = &unk_1002DF840;
  v15[6] = a2;
  v15[7] = a4;
  v15[4] = &v18;
  v15[5] = &v22;
  v15[8] = a1;
  v9 = sub_10001E280((CFDictionaryRef *)a2, a1, a4, 0, &stru_1002DF7D8, (uint64_t)v17, (uint64_t)v16, (uint64_t)v15);
  if (*((_BYTE *)v23 + 24))
    v10 = v9;
  else
    v10 = 0;
  *((_BYTE *)v23 + 24) = v10;
  if (!v10)
    goto LABEL_12;
  v11 = v19;
  if (*(_BYTE *)(a2 + 113) || *((_BYTE *)v19 + 24))
    goto LABEL_11;
  v12 = sub_100019F20(-25300, (__CFString **)a4, CFSTR("Delete failed to delete anything"));
  *((_BYTE *)v23 + 24) = v12;
  if (!v12)
  {
LABEL_12:
    v13 = 0;
    goto LABEL_13;
  }
  v11 = v19;
LABEL_11:
  v13 = *((unsigned __int8 *)v11 + 24) == 0;
LABEL_13:
  _Block_object_dispose(&v18, 8);
  _Block_object_dispose(&v22, 8);
  return v13;
}

uint64_t sub_10001B6D8(uint64_t a1, uint64_t a2, CFDataRef *a3, __CFString **a4)
{
  uint64_t v5;
  _QWORD **v10;
  _QWORD **v11;
  const __CFData *v12;
  const __CFData *v13;
  int v14;
  uint64_t v15;
  const __CFData *v16;
  const __CFData *v17;
  const void *v18;
  NSObject *v19;
  char v20;
  int v21;
  int v22;
  int v23;
  CFErrorDomain Domain;
  __CFString *v25;
  CFErrorDomain v26;
  uint64_t v27;
  const void *v28;
  __CFString *v29;
  uint8_t buf[8];
  uint64_t v31;
  void (*v32)(uint64_t, _QWORD **, uint64_t *);
  void *v33;
  _QWORD **v34;
  char v35;
  char v36;

  if (*(_QWORD *)(a2 + 24) == *(_QWORD *)(a2 + 16) && !*(_QWORD *)(a2 + 88))
  {
    v10 = (_QWORD **)sub_10001E9E8(*(_QWORD *)a2, *(const __CFDictionary **)(a2 + 8), dword_1003414E0, a4);
    if (!v10)
      return 0;
    v11 = v10;
    if (sub_10001DA80(v10))
    {
      if (*(_QWORD *)(a2 + 96))
        v12 = *(const __CFData **)(a2 + 96);
      else
        v12 = kCFBooleanTrue;
      sub_10001A56C((uint64_t)v11, &off_1002DFE78, v12, 0);
    }
    v13 = *(const __CFData **)(a2 + 56);
    if (v13)
      v14 = sub_10001BA44((uint64_t)v11, CFSTR("v_Data"), v13, a4);
    else
      v14 = 1;
    v15 = *(_QWORD *)(a2 + 72);
    if (v15)
      v14 = sub_10001D87C(v11, v15, a4);
    v16 = *(const __CFData **)(a2 + 80);
    if (v16)
      v14 = sub_10001D918((uint64_t)v11, v16, a4);
    v17 = *(const __CFData **)(a2 + 128);
    if (v17)
      v14 = sub_10001BA44((uint64_t)v11, CFSTR("musr"), v17, a4);
    sub_10001D97C((uint64_t)v11, *(CFTypeRef *)(a2 + 144));
    if (sub_10000BD64())
    {
      sub_10001BACC(v11, *(unsigned __int8 *)(a2 + 154), a4);
      if (*(_QWORD *)(a2 + 160))
      {
        v18 = sub_100019204(v11, (uint64_t)&off_1002E9538, a4);
        if (v18)
        {
          sub_1000B3BC0((uint64_t)v18, *(void **)(a2 + 160));
        }
        else
        {
          v19 = sub_10000EF14("SecError");
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Couldn't fetch UUID from item; can't call callback",
              buf,
              2u);
          }
        }
      }
    }
    if (v14)
    {
      v20 = *(_BYTE *)(a2 + 154);
      *(_QWORD *)buf = _NSConcreteStackBlock;
      v31 = 0x40000000;
      v32 = sub_100117088;
      v33 = &unk_1002DE728;
      v34 = v11;
      v35 = v20;
      v36 = 0;
      v21 = sub_10001DADC((uint64_t)v11, a1, a4, (uint64_t)buf);
      v22 = v21;
      if (a3 && v21)
      {
        v23 = *(_DWORD *)(a2 + 48);
        if (v23)
          *a3 = sub_1000235AC((uint64_t)v11, v23, a4);
        goto LABEL_50;
      }
    }
    else
    {
      v22 = 0;
    }
    if (a4 && (v22 & 1) == 0 && *a4)
    {
      Domain = CFErrorGetDomain((CFErrorRef)*a4);
      if (CFEqual(Domain, CFSTR("com.apple.utilities.sqlite3")) && CFErrorGetCode((CFErrorRef)*a4) == 19)
      {
        v25 = *a4;
        if (*a4)
        {
          *a4 = 0;
          CFRelease(v25);
        }
        sub_100019F20(-25299, a4, CFSTR("duplicate item %@"), v11);
        goto LABEL_54;
      }
      v26 = CFErrorGetDomain((CFErrorRef)*a4);
      if (CFEqual(v26, kCFErrorDomainOSStatus))
      {
        if (CFErrorGetCode((CFErrorRef)*a4) == -26275)
        {
          v27 = sub_10001E6A8(v11[2], 14, a4);
          v28 = sub_100019204(v11, v27, a4);
          if (v28)
          {
            if (CFEqual(v28, kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly))
            {
              v29 = *a4;
              if (*a4)
              {
                *a4 = 0;
                CFRelease(v29);
              }
              sub_100019F20(-25293, a4, CFSTR("authentication failed"));
              goto LABEL_54;
            }
          }
        }
      }
    }
    if (v22)
    {
LABEL_50:
      v5 = 1;
      *(_BYTE *)(a2 + 113) = 1;
      if (sub_10000BC78(v11))
        *(_BYTE *)(a2 + 114) = 1;
      if (sub_10000BF78(v11))
        *(_BYTE *)(a2 + 115) = 1;
      goto LABEL_55;
    }
LABEL_54:
    v5 = 0;
LABEL_55:
    CFRelease(v11);
    return v5;
  }
  return 1;
}

uint64_t sub_10001BA44(uint64_t a1, CFTypeRef cf2, const __CFData *a3, __CFString **a4)
{
  uint64_t v4;
  CFTypeRef *v5;
  CFTypeRef **v10;
  CFTypeRef *v11;

  v4 = *(_QWORD *)(a1 + 16);
  v5 = *(CFTypeRef **)(v4 + 16);
  if (!v5)
    return 0;
  v10 = (CFTypeRef **)(v4 + 24);
  while (!CFEqual(*v5, cf2))
  {
    v11 = *v10++;
    v5 = v11;
    if (!v11)
      return 0;
  }
  return sub_10001A56C(a1, v5, a3, a4);
}

void sub_10001BACC(_QWORD *a1, int a2, __CFString **a3)
{
  __CFDictionary *v5;
  __CFDictionary *v6;
  __CFData *v7;
  const __CFData *v8;
  UInt8 buffer[16];
  CFRange v10;

  if (a1)
  {
    if (!a2)
      goto LABEL_13;
    v5 = sub_10001A42C(a1, 1, a3);
    if (v5)
    {
      v6 = v5;
      v7 = sub_100032878(v5);
      CFRelease(v6);
    }
    else
    {
      v7 = 0;
    }
    if (CFDataGetLength(v7) < 16)
    {
      v8 = 0;
      if (!v7)
        goto LABEL_11;
    }
    else
    {
      memset(buffer, 170, sizeof(buffer));
      v10.location = 0;
      v10.length = 16;
      CFDataGetBytes(v7, v10, buffer);
      v8 = CFUUIDCreateWithBytes(0, buffer[0], buffer[1], buffer[2], buffer[3], buffer[4], buffer[5], buffer[6], buffer[7], buffer[8], buffer[9], buffer[10], buffer[11], buffer[12], buffer[13], buffer[14], buffer[15]);
      if (!v7)
      {
LABEL_11:
        if (v8)
        {
          sub_10001BA44((uint64_t)a1, kSecAttrUUID, v8, a3);
LABEL_14:
          CFRelease(v8);
          return;
        }
LABEL_13:
        v8 = CFUUIDCreate(0);
        sub_10001BA44((uint64_t)a1, kSecAttrUUID, v8, a3);
        if (!v8)
          return;
        goto LABEL_14;
      }
    }
    CFRelease(v7);
    goto LABEL_11;
  }
}

BOOL sub_10001BC34(uint64_t a1)
{
  return sub_10001B508(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(CFTypeRef **)(a1 + 56));
}

uint64_t sub_10001BC44(uint64_t a1)
{
  sub_10001BC70(*(CFDictionaryRef **)(a1 + 32));
  return sub_10001B6D8(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32), *(CFDataRef **)(a1 + 48), *(__CFString ***)(a1 + 56));
}

void sub_10001BC70(CFDictionaryRef *a1)
{
  CFAbsoluteTime Current;
  const __CFData *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  CFDateRef v9;
  const __CFData *v10;
  uint64_t v11;
  int valuePtr;

  Current = CFAbsoluteTimeGetCurrent();
  v3 = CFDateCreate(0, Current);
  v4 = *((_QWORD *)*a1 + 2);
  if (v4)
  {
    v5 = (uint64_t *)((char *)*a1 + 24);
    do
    {
      v6 = *(_QWORD *)(v4 + 16);
      if ((v6 & 2) != 0)
      {
        if ((*(_DWORD *)(v4 + 8) - 5) > 1)
        {
          if ((v6 & 0x1000) == 0 || CFDictionaryContainsKey(a1[1], *(const void **)v4))
            goto LABEL_18;
          v7 = *(_QWORD *)(v4 + 16);
          if ((v7 & 0x400) != 0)
          {
            if (*(_DWORD *)(v4 + 8) == 4)
            {
              v9 = CFDateCreate(kCFAllocatorDefault, 0.0);
            }
            else
            {
              valuePtr = 0;
              v9 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
            }
          }
          else
          {
            if ((v7 & 0x800) == 0)
              goto LABEL_18;
            v8 = *(_DWORD *)(v4 + 8);
            if (v8 != 16 && v8 != 1)
            {
              CFRetain(&stru_1002EE888);
              v10 = (const __CFData *)&stru_1002EE888;
LABEL_17:
              sub_1000122D8((_QWORD *)v4, v10, (uint64_t)a1);
              CFRelease(v10);
              goto LABEL_18;
            }
            v9 = CFDataCreate(kCFAllocatorDefault, 0, 0);
          }
          v10 = v9;
          if (v9)
            goto LABEL_17;
        }
        else
        {
          sub_10001BDCC((CFTypeRef *)v4, v3, (uint64_t)a1);
        }
      }
LABEL_18:
      v11 = *v5++;
      v4 = v11;
    }
    while (v11);
  }
  if (v3)
    CFRelease(v3);
}

void sub_10001BDCC(CFTypeRef *a1, const __CFData *a2, uint64_t a3)
{
  uint64_t v6;
  CFTypeRef *v7;
  const void *v8;
  uint64_t v9;
  uint64_t v10;

  if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a3 + 8), *a1) && *(uint64_t *)(a3 + 32) >= 1)
  {
    v6 = 0;
    v7 = (CFTypeRef *)(a3 + 280);
    while (!CFEqual(*a1, *(v7 - 2)))
    {
      ++v6;
      v7 += 2;
      if (v6 >= *(_QWORD *)(a3 + 32))
        goto LABEL_13;
    }
    v8 = *(const void **)(a3 + 16 * v6 + 272);
    if (v8)
      CFRelease(v8);
    v9 = *(_QWORD *)(a3 + 32);
    *(_QWORD *)(a3 + 32) = v9 - 1;
    if (v6 < v9 - 1)
    {
      v10 = ~v6 + v9;
      do
      {
        *((_OWORD *)v7 - 1) = *(_OWORD *)v7;
        v7 += 2;
        --v10;
      }
      while (v10);
    }
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a3 + 8), *a1);
  }
LABEL_13:
  sub_1000122D8(a1, a2, a3);
}

void sub_10001BEA4(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  const void *v5;
  const void *v6;

  v2 = sub_10001E594(kCFAllocatorDefault, **(_QWORD ***)(a1 + 48), *(sqlite3_stmt **)(a1 + 56), *(_DWORD *)(*(_QWORD *)(a1 + 48) + 120), *(_QWORD *)(a1 + 32));
  if (v2)
  {
    v3 = (_QWORD *)v2;
    v4 = *(_QWORD *)(a1 + 48);
    v5 = *(const void **)(v4 + 144);
    v6 = *(const void **)(v2 + 56);
    if (v6 != v5)
    {
      if (!v5 || (CFRetain(*(CFTypeRef *)(v4 + 144)), (v6 = (const void *)v3[7]) != 0))
        CFRelease(v6);
      v3[7] = v5;
    }
    (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
    CFRelease(v3);
  }
}

void sub_10001BF4C(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  CFErrorRef *v7;
  BOOL v8;
  CFErrorRef v9;
  const __CFString *v10;
  const __CFString *v11;
  CFTypeID v12;
  NSObject *v13;
  _QWORD *v14;
  const __CFData *v15;
  const __CFData *v16;
  int v17;
  unsigned int v18;
  uint64_t v19;
  const __CFBoolean *v20;
  _BYTE *v21;
  uint8_t v22[8];
  CFErrorRef err;

  if (*(_QWORD *)(*(_QWORD *)(a1 + 48) + 240))
  {
    v4 = sub_10001E6A8(*(_QWORD **)(a2 + 16), 1, 0);
    v5 = sub_100019204((const void *)a2, v4, 0);
    v6 = *(const void **)(*(_QWORD *)(a1 + 48) + 240);
    if (v6)
    {
      if (!sub_10012E5B8(v6, (uint64_t)v5))
        return;
    }
  }
  *(_QWORD *)(a2 + 64) = CFSTR("odel");
  v7 = *(CFErrorRef **)(a1 + 56);
  err = 0;
  v8 = sub_1000192F4(a2, 1, (__CFString **)&err);
  v9 = err;
  if (!v8 && err)
  {
    if (CFErrorGetCode(err) == -25330)
    {
      if (v7)
        *v7 = err;
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
      return;
    }
    v9 = err;
  }
  if (v9)
    CFRelease(v9);
  if (*(_BYTE *)(*(_QWORD *)(a1 + 48) + 116)
    && (v10 = (const __CFString *)sub_10000C1D0((_QWORD *)a2, kSecAttrSharingGroup)) != 0
    && (v11 = v10, v12 = CFGetTypeID(v10), v12 == CFStringGetTypeID())
    && CFStringCompare(v11, kSecAttrSharingGroupNone, 0))
  {
    v13 = sub_10000EF14("SecError");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v22 = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Cannot delete shared item for unentitled client", v22, 2u);
    }
  }
  else
  {
    v14 = (_QWORD *)sub_10001E6A8(*(_QWORD **)(a2 + 16), 7, 0);
    v15 = (const __CFData *)sub_100019204((const void *)a2, (uint64_t)v14, 0);
    if (v15)
    {
      v16 = v15;
      CFRetain(v15);
      v17 = sub_10000BC78((_QWORD **)a2);
      v18 = sub_10000BF78((_QWORD *)a2);
      sub_10001A56C(a2, v14, v16, 0);
      CFRelease(v16);
    }
    else
    {
      v17 = sub_10000BC78((_QWORD **)a2);
      v18 = sub_10000BF78((_QWORD *)a2);
      sub_10001A56C(a2, v14, 0, 0);
    }
    v19 = *(_QWORD *)(a1 + 64);
    v20 = *(const __CFBoolean **)(*(_QWORD *)(a1 + 48) + 96);
    if (!v20)
    {
      if (v17 && !sub_10001DA80((_QWORD **)a2))
        v20 = 0;
      else
        v20 = kCFBooleanFalse;
    }
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = sub_10001E4C0((CFStringRef **)a2, v19, v20, *(unsigned __int8 *)(*(_QWORD *)(a1 + 48) + 155), *(CFTypeRef **)(a1 + 56));
    if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24))
    {
      v21 = *(_BYTE **)(a1 + 48);
      v21[113] = 1;
      if (v17)
        v21[114] = 1;
      if (v18)
        v21[115] = 1;
    }
  }
}

BOOL sub_10001C1F0(const __CFDictionary *a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  CFArrayRef *v8;
  CFArrayRef *v9;
  CFIndex Count;
  CFIndex v11;
  uint64_t v12;
  uint64_t v13;
  const __CFString *Value;
  _BOOL4 v15;
  uint64_t v16;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  CFDictionaryRef v25;
  CFDictionaryRef v26;
  int v27;
  const void *v28;
  const __CFData *v29;
  const void *v30;
  const __CFBoolean *v31;
  const __CFBoolean *v32;
  CFBooleanRef v33;
  const __CFString *v34;
  int v35;
  int v36;
  int v37;
  int v38;
  _QWORD v39[7];
  CFRange v40;

  if (sub_10001120C(a1, 0, a4))
  {
    v8 = sub_10001CBCC((CFArrayRef *)a2);
    if (v8)
    {
      v9 = v8;
      Count = CFArrayGetCount((CFArrayRef)v8);
      if (Count)
      {
        v11 = Count;
        kdebug_trace(726794312, 0, 0, 0, 0);
        v12 = sub_1000112B0(a1, *(const void **)(a2 + 24), 0, a2, a4);
        if (!v12)
        {
          v16 = 0;
          goto LABEL_64;
        }
        v13 = v12;
        Value = (const __CFString *)CFDictionaryGetValue(a1, kSecAttrAccessGroup);
        v40.location = 0;
        v40.length = v11;
        if (CFArrayContainsValue((CFArrayRef)v9, v40, CFSTR("*")))
        {
          CFRelease(v9);
          v9 = 0;
        }
        if (Value)
        {
          if ((sub_100014DCC((const __CFArray *)v9, Value, a2) & 1) == 0)
          {
            v15 = sub_100019F20(-34018, a4, CFSTR("Client explicitly specifies access group %@ but is only entitled for %@"), Value, v9);
            goto LABEL_16;
          }
        }
        else
        {
          Value = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 8), 0);
          sub_100012178(kSecAttrAccessGroup, (const __CFBoolean *)Value, v13);
        }
        v15 = 1;
LABEL_16:
        if (sub_10001CCAC())
        {
          v25 = sub_10012E96C(0, v18, v19, v20, v21, v22, v23, v24, (uint64_t)CFSTR("operation"), (uint64_t)CFSTR("add"));
          if (v25)
          {
            v26 = v25;
            sub_10001CD10(CFSTR("SecItem"), v25);
            CFRelease(v26);
          }
        }
        v27 = *(_DWORD *)(v13 + 192);
        if (v27 == 2 || v27 == 1 && *(_BYTE *)(a2 + 36))
        {
          v28 = *(const void **)(v13 + 128);
          if (v28)
          {
            *(_QWORD *)(v13 + 128) = 0;
            CFRelease(v28);
          }
          v29 = CFDataCreateWithBytesNoCopy(0, byte_10024957C, 16, kCFAllocatorNull);
          *(_QWORD *)(v13 + 128) = v29;
        }
        else
        {
          *(_DWORD *)(v13 + 192) = 0;
          v29 = *(const __CFData **)(v13 + 128);
        }
        sub_1000122D8(&off_1002E7D78, v29, v13);
        if (!v15)
        {
          v35 = 0;
          goto LABEL_63;
        }
        sub_10001C690((uint64_t *)v13, Value);
        v30 = CFDictionaryGetValue(a1, CFSTR("f_ckkscallback"));
        if (v30)
        {
          *(_BYTE *)(v13 + 154) = 1;
          *(_QWORD *)(v13 + 160) = v30;
        }
        v31 = sub_10001CDC8();
        sub_100012178(CFSTR("persistref"), v31, v13);
        v32 = *(const __CFBoolean **)(v13 + 80);
        if (v32 != v31)
        {
          if (!v31 || (CFRetain(v31), (v32 = *(const __CFBoolean **)(v13 + 80)) != 0))
            CFRelease(v32);
          *(_QWORD *)(v13 + 80) = v31;
        }
        if (v31)
          CFRelease(v31);
        if (*(_BYTE *)(a2 + 44))
        {
          if ((sub_100139198(a2) & 1) == 0)
          {
            v34 = CFSTR("App clips are not permitted to use access groups other than application identifier");
            goto LABEL_45;
          }
          if (*(_BYTE *)(a2 + 44))
          {
            v33 = (CFBooleanRef)CFDictionaryGetValue(a1, kSecAttrSynchronizable);
            if (v33 && kCFBooleanTrue)
            {
              if (CFEqual(v33, kCFBooleanTrue))
              {
LABEL_42:
                v34 = CFSTR("App clips are not permitted to add synchronizable items to the keychain");
LABEL_45:
                v36 = -34020;
LABEL_61:
                v38 = sub_100019F20(v36, a4, v34);
                goto LABEL_62;
              }
            }
            else if (v33 == kCFBooleanTrue)
            {
              goto LABEL_42;
            }
          }
        }
        v37 = *(_DWORD *)(v13 + 192);
        if (v37)
        {
          if (!*(_BYTE *)(a2 + 16))
          {
            v34 = CFSTR("client doesn't have entitlement for system keychain");
            goto LABEL_60;
          }
          if (v37 == 2 && sub_100139520(a1))
          {
            v34 = CFSTR("Can't store system keychain (always) and synchronizable");
LABEL_57:
            v36 = -50;
            goto LABEL_61;
          }
        }
        if (*(_DWORD *)(v13 + 196) && !*(_BYTE *)(a2 + 17))
        {
          v34 = CFSTR("client doesn't have entitlement for syncbubble keychain");
        }
        else
        {
          if (*(_QWORD *)(v13 + 72) || *(_QWORD *)(v13 + 240))
          {
            v34 = CFSTR("q_row_id");
            goto LABEL_57;
          }
          if (!*(_BYTE *)(v13 + 116) || !CFDictionaryContainsKey(*(CFDictionaryRef *)(v13 + 8), kSecAttrSharingGroup))
          {
            if (*(_QWORD *)(v13 + 40))
            {
              v35 = 1;
LABEL_63:
              v16 = sub_10001CAF8(v13, v35, (CFErrorRef *)a4);
              if (!v9)
              {
LABEL_65:
                kdebug_trace(726794316, 0, 0, 0, 0);
                return v16;
              }
LABEL_64:
              CFRelease(v9);
              goto LABEL_65;
            }
            v39[0] = _NSConcreteStackBlock;
            v39[1] = 0x40000000;
            v39[2] = sub_10001ABA8;
            v39[3] = &unk_1002E7DE8;
            v39[4] = a4;
            v39[5] = v13;
            v39[6] = a3;
            v38 = sub_100011A30(1, 1, 0, (uint64_t)a4, (uint64_t)v39);
LABEL_62:
            v35 = v38;
            goto LABEL_63;
          }
          v34 = CFSTR("can't add shared item without Keychain Sharing client entitlement");
        }
LABEL_60:
        v36 = -34018;
        goto LABEL_61;
      }
      CFRelease(v9);
    }
    return sub_100019F20(-34018, a4, CFSTR("Client has neither %@ entitlements"), CFSTR("application-identifier nor keychain-access-groups"));
  }
  return 0;
}

void sub_10001C690(uint64_t *a1, CFTypeRef cf1)
{
  const __CFBoolean **v3;
  uint64_t v4;
  uint64_t v5;

  if (!a1[17])
  {
    if (CFEqual(cf1, CFSTR("com.apple.apsd")))
    {
      v3 = (const __CFBoolean **)&kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate;
    }
    else
    {
      v4 = *a1;
      v5 = sub_1000119B8((uint64_t)CFSTR("cert"), &qword_100341260, (uint64_t)&unk_100341258);
      v3 = (const __CFBoolean **)&kSecAttrAccessibleWhenUnlocked;
      if (v4 == v5)
        v3 = (const __CFBoolean **)&kSecAttrAccessibleAlwaysPrivate;
    }
    sub_100012178(kSecAttrAccessible, *v3, (uint64_t)a1);
  }
}

BOOL sub_10001C730(const __CFDictionary *a1, uint64_t a2, __CFString **a3)
{
  CFArrayRef *v6;
  CFArrayRef *v7;
  CFIndex Count;
  CFIndex v9;
  const __CFString *Value;
  const __CFString *v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  CFDictionaryRef v19;
  CFDictionaryRef v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  const void *v24;
  uint64_t v26;
  const __CFString *v27;
  int v28;
  int v29;
  _QWORD v30[7];
  CFRange v31;

  if (!sub_10001120C(a1, 3, a3))
    return 0;
  v6 = sub_10001CBCC((CFArrayRef *)a2);
  if (!v6)
    return sub_100019F20(-34018, a3, CFSTR("Client has neither %@ entitlements"), CFSTR("application-identifier nor keychain-access-groups"));
  v7 = v6;
  Count = CFArrayGetCount((CFArrayRef)v6);
  if (!Count)
  {
    CFRelease(v7);
    return sub_100019F20(-34018, a3, CFSTR("Client has neither %@ entitlements"), CFSTR("application-identifier nor keychain-access-groups"));
  }
  v9 = Count;
  Value = (const __CFString *)CFDictionaryGetValue(a1, kSecAttrAccessGroup);
  if (!Value || (v11 = Value, (sub_100014DCC((const __CFArray *)v7, Value, a2) & 1) != 0))
  {
    kdebug_trace(726794328, 0, 0, 0, 0);
    if (sub_10001CCAC())
    {
      CFArrayGetValueAtIndex((CFArrayRef)v7, 0);
      v19 = sub_10012E96C(0, v12, v13, v14, v15, v16, v17, v18, (uint64_t)CFSTR("operation"), (uint64_t)CFSTR("delete"));
      if (v19)
      {
        v20 = v19;
        sub_10001CD10(CFSTR("SecItem"), v19);
        CFRelease(v20);
      }
    }
    v31.location = 0;
    v31.length = v9;
    if (CFArrayContainsValue((CFArrayRef)v7, v31, CFSTR("*")))
    {
      CFRelease(v7);
      v7 = 0;
    }
    v21 = sub_1000112B0(a1, *(const void **)(a2 + 24), -1, a2, a3);
    if (!v21)
    {
      v26 = 0;
LABEL_45:
      if (v7)
        CFRelease(v7);
      kdebug_trace(726794332, 0, 0, 0, 0);
      return v26;
    }
    v22 = v21;
    v23 = *(_DWORD *)(v21 + 192);
    if (v23 == 2 || v23 == 1 && *(_BYTE *)(a2 + 36))
    {
      v24 = *(const void **)(v21 + 128);
      if (v24)
      {
        *(_QWORD *)(v22 + 128) = 0;
        CFRelease(v24);
      }
      *(_QWORD *)(v22 + 128) = CFDataCreateWithBytesNoCopy(0, byte_10024957C, 16, kCFAllocatorNull);
    }
    else
    {
      *(_DWORD *)(v21 + 192) = 0;
    }
    sub_100012018(v22, v7);
    if (*(_BYTE *)(a2 + 44) && (sub_100139198(a2) & 1) == 0)
    {
      v28 = sub_100019F20(-34020, a3, CFSTR("App clips are not permitted to use access groups other than application identifier"));
LABEL_44:
      v26 = sub_10001CAF8(v22, v28, (CFErrorRef *)a3);
      goto LABEL_45;
    }
    if (*(_DWORD *)(v22 + 192) && !*(_BYTE *)(a2 + 16))
    {
      v27 = CFSTR("client doesn't have entitlement for system keychain");
    }
    else if (*(_DWORD *)(v22 + 196) && !*(_BYTE *)(a2 + 17))
    {
      v27 = CFSTR("client doesn't have entitlement for syncbubble keychain");
    }
    else
    {
      if (*(_QWORD *)(v22 + 104) != -1)
      {
        v27 = CFSTR("match limit not supported by delete");
LABEL_42:
        v29 = -50;
        goto LABEL_43;
      }
      if (*(_QWORD *)(v22 + 24) != *(_QWORD *)(v22 + 16))
      {
        v27 = CFSTR("match not supported by delete");
        goto LABEL_42;
      }
      if (*(_QWORD *)(v22 + 64))
      {
        v27 = CFSTR("value ref not supported by delete");
        goto LABEL_42;
      }
      if (*(_QWORD *)(v22 + 72) && *(_QWORD *)(v22 + 32))
      {
        v27 = CFSTR("rowid and other attributes are mutually exclusive");
        goto LABEL_42;
      }
      if (*(_QWORD *)(v22 + 240) && *(_QWORD *)(v22 + 32) != 1)
      {
        v27 = CFSTR("token persistent ref and other attributes are mutually exclusive");
        goto LABEL_42;
      }
      if (!*(_BYTE *)(v22 + 116) || !CFDictionaryContainsKey(*(CFDictionaryRef *)(v22 + 8), kSecAttrSharingGroup))
      {
        v30[0] = _NSConcreteStackBlock;
        v30[1] = 0x40000000;
        v30[2] = sub_10001AB40;
        v30[3] = &unk_1002E7F60;
        v30[4] = a3;
        v30[5] = v22;
        v30[6] = v7;
        v28 = sub_100011A30(1, 1, 0, (uint64_t)a3, (uint64_t)v30);
        goto LABEL_44;
      }
      v27 = CFSTR("can't delete shared items without Keychain Sharing client entitlement");
    }
    v29 = -34018;
LABEL_43:
    v28 = sub_100019F20(v29, a3, v27);
    goto LABEL_44;
  }
  sub_100019F20(-34018, a3, CFSTR("Client explicitly specifies access group %@ but is only entitled for %@"), v11, v7);
  CFRelease(v7);
  return 0;
}

uint64_t sub_10001CAF8(uint64_t a1, int a2, CFErrorRef *a3)
{
  if (a2 && !*(_QWORD *)(a1 + 40))
  {
    if (*(_BYTE *)(a1 + 114) || *(_BYTE *)(a1 + 113) && !sub_10001CB70(*(CFTypeRef *)(a1 + 128)))
      sub_100133374();
    if (*(_BYTE *)(a1 + 115))
      sub_100133324();
  }
  return sub_100011108((const void **)a1, a3) & a2;
}

BOOL sub_10001CB70(CFTypeRef cf1)
{
  if (qword_100341188 != -1)
    dispatch_once(&qword_100341188, &stru_1002DED08);
  return CFEqual(cf1, (CFTypeRef)qword_100341190) != 0;
}

CFArrayRef *sub_10001CBCC(CFArrayRef *a1)
{
  CFArrayRef *MutableCopy;
  const __CFArray *v2;
  CFIndex FirstIndexOfValue;
  CFIndex i;
  CFRange v6;
  CFRange v7;
  CFRange v8;

  MutableCopy = a1;
  if (a1)
  {
    v2 = a1[1];
    if (v2)
    {
      v6.length = CFArrayGetCount(v2);
      v6.location = 0;
      if (CFArrayContainsValue(MutableCopy[1], v6, kSecAttrAccessGroupToken))
      {
        MutableCopy = (CFArrayRef *)CFArrayCreateMutableCopy(kCFAllocatorDefault, 0, MutableCopy[1]);
        v7.length = CFArrayGetCount((CFArrayRef)MutableCopy);
        v7.location = 0;
        FirstIndexOfValue = CFArrayGetFirstIndexOfValue((CFArrayRef)MutableCopy, v7, kSecAttrAccessGroupToken);
        if (FirstIndexOfValue != -1)
        {
          for (i = FirstIndexOfValue;
                i != -1;
                i = CFArrayGetFirstIndexOfValue((CFArrayRef)MutableCopy, v8, kSecAttrAccessGroupToken))
          {
            CFArrayRemoveValueAtIndex((CFMutableArrayRef)MutableCopy, i);
            v8.length = CFArrayGetCount((CFArrayRef)MutableCopy);
            v8.location = 0;
          }
        }
      }
      else
      {
        MutableCopy = (CFArrayRef *)MutableCopy[1];
        if (MutableCopy)
          CFRetain(MutableCopy);
      }
    }
    else
    {
      return 0;
    }
  }
  return MutableCopy;
}

BOOL sub_10001CCAC()
{
  __CFString *v0;
  _BOOL8 v1;

  v0 = CFSTR("SecItem");
  v1 = sub_10001CD70() && off_100340DC8(77, CFSTR("SecItem")) != 0;

  return v1;
}

void sub_10001CD10(void *a1, void *a2)
{
  id v3;
  id v4;

  v4 = a1;
  v3 = a2;
  if (sub_10001CD70())
    off_100340DD0(77, v4, v3, 0);

}

BOOL sub_10001CD70()
{
  if (qword_100340DE0 != -1)
    dispatch_once(&qword_100340DE0, &stru_1002DB7B0);
  dispatch_source_merge_data((dispatch_source_t)qword_100340DE8, 1uLL);
  return qword_100340DF0 != 0;
}

CFDataRef sub_10001CDC8()
{
  const __CFUUID *v0;
  CFDataRef v1;
  CFUUIDBytes v3;

  v0 = CFUUIDCreate(kCFAllocatorDefault);
  v3 = CFUUIDGetUUIDBytes(v0);
  v1 = CFDataCreate(kCFAllocatorDefault, &v3.byte0, 16);
  if (v0)
    CFRelease(v0);
  return v1;
}

__CFDictionary *sub_10001CE2C(_QWORD *a1, uint64_t a2, __CFString **a3)
{
  return sub_10001A3F4(a1, 256, a3);
}

__CFData *sub_10001CE34(uint64_t a1, uint64_t a2, __CFString **a3)
{
  __CFDictionary *v5;
  __CFDictionary *v6;
  __CFDictionary *v7;
  __CFDictionary *v8;
  const void *v9;
  __CFDictionary *v10;
  __CFDictionary *v11;
  const void *v12;
  NSObject *v13;
  CFErrorDomain Domain;
  const void *v16;
  NSObject *v17;
  const __CFString *v18;
  const __CFString *v19;
  const __CFString *v20;
  const __CFString *v21;
  const __CFString *v22;
  _QWORD context[6];
  __CFData *v24;
  uint8_t buf[4];
  const __CFString *v26;
  __int16 v27;
  const __CFString *v28;
  __int16 v29;
  const __CFString *v30;
  __int16 v31;
  const __CFString *v32;

  v24 = 0;
  v5 = sub_10001904C((_QWORD *)a1, 32, 0, a3);
  v6 = sub_10001904C((_QWORD *)a1, 128, 0, a3);
  v7 = sub_10001904C((_QWORD *)a1, 0x2000, 0, a3);
  v8 = v7;
  if (v5 && v6 && v7)
  {
    v9 = sub_10001D188((_QWORD **)a1, a3);
    v10 = sub_10001A3F4((_QWORD *)a1, 256, a3);
    v11 = v10;
    if (v9 && v10)
    {
      CFDictionarySetValue(v8, kSecAttrSHA1, v10);
      context[0] = _NSConcreteStackBlock;
      context[1] = 3221225472;
      context[2] = sub_100004C7C;
      context[3] = &unk_1002DEB50;
      context[4] = v6;
      context[5] = v8;
      CFDictionaryApplyFunction(v5, (CFDictionaryApplierFunction)sub_10011C8D8, context);
      if (sub_10001D40C((const __CFData *)*(unsigned int *)(a1 + 28), (uint64_t)v9, *(const __CFData **)(a1 + 56), v5, v6, v8, &v24, 1, 0, a3))
      {
        *(_DWORD *)(a1 + 40) = 4;
LABEL_36:
        CFRelease(v9);
        goto LABEL_37;
      }
      if (a3 && *a3 && CFErrorGetCode((CFErrorRef)*a3) == -25330)
      {
        Domain = CFErrorGetDomain((CFErrorRef)*a3);
        if (Domain && kCFErrorDomainOSStatus)
        {
          if (CFEqual(Domain, kCFErrorDomainOSStatus))
            goto LABEL_36;
        }
        else if (Domain == kCFErrorDomainOSStatus)
        {
          goto LABEL_36;
        }
      }
      v16 = sub_10000EF14("SecCritical");
      v17 = objc_claimAutoreleasedReturnValue(v16);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        if (a3)
          v18 = *a3;
        else
          v18 = &stru_1002EE888;
        *(_DWORD *)buf = 138412290;
        v26 = v18;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "ks_encrypt_data (db): failed: %@", buf, 0xCu);
      }

      goto LABEL_36;
    }
    if (v10)
LABEL_37:
      CFRelease(v11);
  }
  else
  {
    if (!v5 && !v6 && !v7)
      return v24;
    if (dword_10033F080 == -1)
    {
      v12 = sub_10000EF14("SecEmergency");
      v13 = objc_claimAutoreleasedReturnValue(v12);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
      {
        v19 = CFSTR("missing");
        if (v5)
          v20 = CFSTR("present");
        else
          v20 = CFSTR("missing");
        if (v6)
          v21 = CFSTR("present");
        else
          v21 = CFSTR("missing");
        if (v8)
          v19 = CFSTR("present");
        if (a3)
          v22 = *a3;
        else
          v22 = CFSTR("no error pointer");
        *(_DWORD *)buf = 138413058;
        v26 = v20;
        v27 = 2112;
        v28 = v21;
        v29 = 2112;
        v30 = v19;
        v31 = 2112;
        v32 = v22;
        _os_log_fault_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_FAULT, "SecDbKeychainItemCopyEncryptedData: not all plists are present: secretStuff: %@, attributes: %@, auth_attributes: %@ : %@", buf, 0x2Au);
      }

    }
    if (!v5)
    {
      if (!v6)
        goto LABEL_17;
      goto LABEL_16;
    }
  }
  CFRelease(v5);
  if (v6)
LABEL_16:
    CFRelease(v6);
LABEL_17:
  if (v8)
    CFRelease(v8);
  return v24;
}

const void *sub_10001D188(_QWORD **a1, __CFString **a2)
{
  uint64_t v4;
  const void *v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  const void *v9;
  const void *v10;
  const void *v12;
  CFAllocatorRef v13;
  uint64_t v14;
  const void *v15;
  CFAllocatorRef v16;
  uint64_t v17;
  const __CFData *Protection;
  const void *v19;
  const void *v20;
  const void *v21;
  NSObject *v22;
  _QWORD *v23;
  const void *v24;
  int v26;
  const __CFData *v27;
  __int16 v28;
  const void *v29;

  v4 = sub_10001E6A8(a1[2], 15, a2);
  v5 = (const void *)sub_100019204(a1, v4, a2);
  v6 = sub_10001E6A8(a1[2], 14, a2);
  v7 = sub_100019204(a1, v6, a2);
  if (v5)
    v8 = v7 == 0;
  else
    v8 = 1;
  if (v8)
    return 0;
  v10 = (const void *)v7;
  if (!CFEqual(v5, kCFNull))
  {
    v13 = CFGetAllocator(a1);
    v14 = SecAccessControlCreateFromData(v13, v5, a2);
    if (v14)
    {
      v12 = (const void *)v14;
      if (CFEqual(v10, kCFNull))
      {
        v15 = 0;
        goto LABEL_22;
      }
LABEL_13:
      v16 = CFGetAllocator(a1);
      v17 = SecAccessControlCreate(v16, a2);
      v15 = (const void *)v17;
      if (!v17 || !SecAccessControlSetProtection(v17, v10, a2))
      {
        v24 = 0;
        v9 = 0;
        if (!v12)
        {
LABEL_24:
          if (!v15)
            return v9;
          goto LABEL_27;
        }
LABEL_23:
        CFRelease(v12);
        v9 = v24;
        goto LABEL_24;
      }
      if (!v12)
      {
        CFRetain(v15);
        v9 = v15;
LABEL_27:
        CFRelease(v15);
        return v9;
      }
      Protection = (const __CFData *)SecAccessControlGetProtection(v12);
      v19 = (const void *)SecAccessControlGetProtection(v15);
      v20 = v19;
      if (!Protection || !v19 || !CFEqual(Protection, v19))
      {
        v21 = sub_10000EF14("SecError");
        v22 = objc_claimAutoreleasedReturnValue(v21);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          v26 = 138412546;
          v27 = Protection;
          v28 = 2112;
          v29 = v20;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "SecDbItemCopyAccessControl accc %@ != pdmn %@, setting pdmn to accc value", (uint8_t *)&v26, 0x16u);
        }

        sub_10003429C(CFSTR("Corrupted item on decrypt accc != pdmn"), 0x53C00002u);
        v23 = (_QWORD *)sub_10001E6A8(a1[2], 14, a2);
        if (!sub_10001A56C((uint64_t)a1, v23, Protection, a2))
        {
          v24 = 0;
          goto LABEL_23;
        }
      }
LABEL_22:
      CFRetain(v12);
      v24 = v12;
      goto LABEL_23;
    }
    return 0;
  }
  v12 = 0;
  v9 = 0;
  if (!CFEqual(v10, kCFNull))
    goto LABEL_13;
  return v9;
}

BOOL sub_10001D40C(const __CFData *a1, uint64_t a2, const __CFData *a3, CFDictionaryRef theDict, void *a5, const __CFDictionary *a6, __CFData **a7, int a8, char a9, __CFString **a10)
{
  CFIndex Count;
  CFIndex v20;
  __CFData *MutableCopy;
  _BOOL8 v22;
  const void *Protection;
  uint64_t v24;
  uint64_t v25;
  id v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  SecDbKeychainItemV7 *v31;
  void *v32;
  id v33;
  void *v34;
  id v35;
  id v36;
  char *v37;
  id v38;
  __CFData **v40;
  void *v41;
  id v42;
  _QWORD context[5];

  if (dword_1003414E0 == (_DWORD)a1 && a9 == 0)
  {
    Protection = (const void *)SecAccessControlGetProtection(a2);
    v24 = sub_10001D720(Protection, a10);
    if ((_DWORD)v24)
    {
      v25 = v24;
      v40 = a7;
      v41 = objc_autoreleasePoolPush();
      if (a5)
        v26 = objc_msgSend(a5, "mutableCopy");
      else
        v26 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
      v27 = v26;
      objc_msgSend(v26, "addEntriesFromDictionary:", a6);
      v28 = (void *)SecAccessControlCopyData(a2);
      objc_msgSend(v27, "setObject:forKeyedSubscript:", v28, CFSTR("SecAccessControl"));

      v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](NSUUID, "UUID"));
      v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v29, "UUIDString"));

      v31 = -[SecDbKeychainItemV7 initWithSecretAttributes:metadataAttributes:tamperCheck:keyclass:]([SecDbKeychainItemV7 alloc], "initWithSecretAttributes:metadataAttributes:tamperCheck:keyclass:", theDict, v27, v30, v25);
      v42 = 0;
      v32 = (void *)objc_claimAutoreleasedReturnValue(-[SecDbKeychainItemV7 encryptedBlobWithKeybag:accessControl:acmContext:error:](v31, "encryptedBlobWithKeybag:accessControl:acmContext:error:", a1, a2, a3, &v42));
      v33 = v42;
      v34 = v33;
      v22 = v32 != 0;
      if (v32)
      {
        v35 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithLength:](NSMutableData, "dataWithLength:", (char *)objc_msgSend(v32, "length") + 4)));
        *(_DWORD *)objc_msgSend(v35, "mutableBytes") = 8;
        v36 = objc_retainAutorelease(v35);
        v37 = (char *)objc_msgSend(v36, "mutableBytes") + 4;
        v38 = objc_retainAutorelease(v32);
        memcpy(v37, objc_msgSend(v38, "bytes"), (size_t)objc_msgSend(v38, "length"));
        *v40 = (__CFData *)v36;
      }
      else if (a10)
      {
        *a10 = (__CFString *)v33;
      }

      objc_autoreleasePoolPop(v41);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    if ((a9 & 1) == 0)
    {
      if (qword_100341168 != -1)
        dispatch_once(&qword_100341168, &stru_1002DEB70);
      dispatch_source_merge_data((dispatch_source_t)qword_100341170, 1uLL);
    }
    Count = CFDictionaryGetCount(theDict);
    v20 = CFDictionaryGetCount((CFDictionaryRef)a5);
    MutableCopy = CFDictionaryCreateMutableCopy(0, v20 + Count, (CFDictionaryRef)a5);
    context[0] = _NSConcreteStackBlock;
    context[1] = 3221225472;
    context[2] = sub_10011C8F0;
    context[3] = &unk_1002ECD08;
    context[4] = MutableCopy;
    CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)sub_10011C8D8, context);
    v22 = sub_10011C114(a1, a2, a3, MutableCopy, a6, a7, a8, a9, (CFTypeRef *)a10);
    if (MutableCopy)
      CFRelease(MutableCopy);
  }
  return v22;
}

uint64_t sub_10001D720(const void *a1, __CFString **a2)
{
  CFTypeID v4;

  if (!a1)
  {
    sub_100019F20(-50, a2, CFSTR("accessible attribute %@ not a string"), 0);
    return 0;
  }
  v4 = CFGetTypeID(a1);
  if (v4 != CFStringGetTypeID())
  {
    sub_100019F20(-50, a2, CFSTR("accessible attribute %@ not a string"), a1);
    return 0;
  }
  if (CFEqual(a1, kSecAttrAccessibleWhenUnlocked))
    return 6;
  if (CFEqual(a1, kSecAttrAccessibleAfterFirstUnlock))
    return 7;
  if (CFEqual(a1, kSecAttrAccessibleAlwaysPrivate))
    return 8;
  if (CFEqual(a1, kSecAttrAccessibleWhenUnlockedThisDeviceOnly))
    return 9;
  if (CFEqual(a1, kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly))
    return 10;
  if (CFEqual(a1, kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate))
    return 11;
  if (!CFEqual(a1, kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly))
  {
    sub_100019F20(-50, a2, CFSTR("accessible attribute %@ unknown"), a1);
    return 0;
  }
  return 12;
}

uint64_t sub_10001D87C(_QWORD **a1, uint64_t a2, __CFString **a3)
{
  uint64_t v6;
  _QWORD *v7;
  const __CFAllocator *v8;
  const __CFData *v9;
  const __CFData *v10;
  uint64_t v11;
  uint64_t valuePtr;

  v6 = sub_10001E6A8(a1[2], 8, a3);
  if (!v6)
    return 1;
  v7 = (_QWORD *)v6;
  valuePtr = a2;
  v8 = CFGetAllocator(a1);
  v9 = CFNumberCreate(v8, kCFNumberSInt64Type, &valuePtr);
  if (!v9)
    return 0;
  v10 = v9;
  v11 = sub_10001A56C((uint64_t)a1, v7, v9, a3);
  CFRelease(v10);
  return v11;
}

uint64_t sub_10001D918(uint64_t a1, const __CFData *a2, __CFString **a3)
{
  _QWORD *v6;

  v6 = (_QWORD *)sub_10001E6A8(*(_QWORD **)(a1 + 16), 16, a3);
  if (a2 && v6)
    return sub_10001A56C(a1, v6, a2, a3);
  else
    return 1;
}

void sub_10001D97C(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3;

  v3 = *(CFTypeRef *)(a1 + 56);
  if (v3 != cf)
  {
    if (!cf || (CFRetain(cf), (v3 = *(CFTypeRef *)(a1 + 56)) != 0))
      CFRelease(v3);
    *(_QWORD *)(a1 + 56) = cf;
  }
}

uint64_t sub_10001D9C4(uint64_t a1, uint64_t a2, __CFString **a3)
{
  _QWORD *v6;
  uint64_t result;
  const __CFData *v8;
  _QWORD *v9;
  uint64_t v10;

  if (*(_DWORD *)(a1 + 40) == 2)
  {
    v6 = (_QWORD *)sub_10001E6A8(*(_QWORD **)(a1 + 16), 9, a3);
    result = sub_10001A56C(a1, v6, kCFNull, a3);
    if (!a2)
      return result;
  }
  else
  {
    result = 1;
    if (!a2)
      return result;
  }
  if ((_DWORD)result)
  {
    *(_DWORD *)(a1 + 40) = 0;
    v8 = (const __CFData *)SecAccessControlCopyData(a2);
    v9 = (_QWORD *)sub_10001E6A8(*(_QWORD **)(a1 + 16), 15, a3);
    v10 = sub_10001A56C(a1, v9, v8, a3);
    CFRelease(v8);
    return v10;
  }
  return result;
}

uint64_t sub_10001DA80(_QWORD **a1)
{
  uint64_t v2;
  uint64_t result;
  char v4;

  v4 = -86;
  v2 = sub_10001E6A8(a1[2], 12, 0);
  LODWORD(result) = sub_10000BCD4(a1, v2, (BOOL *)&v4, 0);
  if (v4)
    return result;
  else
    return 0;
}

uint64_t sub_10001DADC(uint64_t a1, uint64_t a2, __CFString **a3, uint64_t a4)
{
  int v8;
  __CFString *v9;
  __CFString *v10;
  unsigned int v11;
  __CFError *v12;
  CFErrorDomain Domain;
  CFDictionaryRef *v14;
  CFDictionaryRef *v15;
  const __CFDictionary *v16;
  CFDictionaryRef v17;
  char v18;
  char v19;
  uint64_t v20;
  _QWORD v22[10];
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  char v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  __CFString *v30;

  v27 = 0;
  v28 = &v27;
  v29 = 0x2000000000;
  v30 = 0;
  v23 = 0;
  v24 = &v23;
  v25 = 0x2000000000;
  v26 = -86;
  v26 = sub_10001DD08((CFStringRef **)a1, a2, &v30);
  if (!*((_BYTE *)v24 + 24))
  {
    v12 = (__CFError *)v28[3];
    if (v12)
    {
      if (CFErrorGetCode(v12) == 19)
      {
        Domain = CFErrorGetDomain((CFErrorRef)v28[3]);
        if (CFEqual(CFSTR("com.apple.utilities.sqlite3"), Domain))
        {
          v14 = (CFDictionaryRef *)sub_1001165F8((_QWORD *)a1, a3);
          if (v14)
          {
            v15 = v14;
            v16 = *(const __CFDictionary **)(a1 + 56);
            v17 = v14[18];
            if (v17 != v16)
            {
              if (!v16 || (CFRetain(*(CFTypeRef *)(a1 + 56)), (v17 = v15[18]) != 0))
                CFRelease(v17);
              v15[18] = v16;
            }
            v22[0] = _NSConcreteStackBlock;
            v22[1] = 0x40000000;
            v22[2] = sub_100116680;
            v22[3] = &unk_1002DE708;
            v22[4] = a4;
            v22[5] = &v23;
            v22[6] = &v27;
            v22[7] = a3;
            v22[8] = a1;
            v22[9] = a2;
            sub_10001E280(v15, a2, (CFTypeRef *)a3, 0, &stru_1002DE6A0, 0, 0, (uint64_t)v22);
            sub_10001D97C(a1, v15[18]);
            v18 = sub_100011108((const void **)v15, (CFErrorRef *)a3);
            if (*((_BYTE *)v24 + 24))
              v19 = v18;
            else
              v19 = 0;
            *((_BYTE *)v24 + 24) = v19;
          }
        }
      }
    }
  }
  v8 = *((unsigned __int8 *)v24 + 24);
  v9 = (__CFString *)v28[3];
  if (a3 && v9)
  {
    if (*a3)
    {
      if (CFErrorGetCode((CFErrorRef)*a3) != -25330)
        goto LABEL_10;
      v10 = *a3;
      if (*a3)
      {
        *a3 = 0;
        CFRelease(v10);
LABEL_10:
        if (*a3)
          goto LABEL_11;
      }
    }
    v11 = 0;
    *a3 = v9;
    goto LABEL_27;
  }
  if (v9)
  {
    if (!a3)
    {
LABEL_11:
      CFRelease(v9);
      v11 = 0;
      goto LABEL_27;
    }
    goto LABEL_10;
  }
  v11 = 1;
LABEL_27:
  if (v8)
    v20 = v11;
  else
    v20 = 0;
  _Block_object_dispose(&v23, 8);
  _Block_object_dispose(&v27, 8);
  return v20;
}

BOOL sub_10001DD08(CFStringRef **a1, uint64_t a2, __CFString **a3)
{
  const __CFAllocator *v6;
  __CFString *Mutable;
  CFStringRef *v8;
  CFStringRef v9;
  uint64_t v10;
  int v11;
  const __CFString **v12;
  const __CFString *isa;
  const __CFString *v14;
  unint64_t v15;
  _BOOL8 v16;
  char v17;
  char v18;
  NSObject *v19;
  NSObject *v20;
  __CFString *v21;
  _QWORD v23[9];
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  BOOL v27;
  uint8_t buf[4];
  CFStringRef **v29;
  __int16 v30;
  __CFString *v31;

  if (!sub_1000192F4((uint64_t)a1, 1, a3))
    return 0;
  v6 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v6, 0);
  CFStringAppend(Mutable, CFSTR("INSERT INTO "));
  CFStringAppend(Mutable, *a1[2]);
  CFStringAppend(Mutable, CFSTR("("));
  v8 = a1[2];
  v9 = v8[2];
  if (v9)
  {
    v10 = 0;
    v11 = 0;
    v12 = v8 + 3;
    do
    {
      if (((uint64_t)v9->data & 2) != 0)
      {
        isa = (const __CFString *)v9->isa;
        if (v11)
          CFStringAppend(Mutable, CFSTR(","));
        ++v10;
        CFStringAppend(Mutable, isa);
        v11 = 1;
      }
      v14 = *v12++;
      v9 = v14;
    }
    while (v14);
    CFStringAppend(Mutable, CFSTR(")VALUES(?"));
    if (v10 >= 2)
    {
      v15 = v10 + 1;
      do
      {
        CFStringAppend(Mutable, CFSTR(",?"));
        --v15;
      }
      while (v15 > 2);
    }
  }
  else
  {
    CFStringAppend(Mutable, CFSTR(")VALUES(?"));
  }
  CFStringAppend(Mutable, CFSTR(")"));
  v24 = 0;
  v25 = &v24;
  v26 = 0x2000000000;
  v27 = Mutable != 0;
  if (!Mutable)
    goto LABEL_33;
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 0x40000000;
  v23[2] = sub_10001061C;
  v23[3] = &unk_1002DE660;
  v23[6] = a1;
  v23[7] = a3;
  v23[4] = &stru_1002DE638;
  v23[5] = &v24;
  v23[8] = a2;
  v17 = sub_10001E3C4(a2, (uint64_t)Mutable, (CFTypeRef *)a3, (uint64_t)v23);
  v18 = *((_BYTE *)v25 + 24) ? v17 : 0;
  *((_BYTE *)v25 + 24) = v18;
  CFRelease(Mutable);
  if (*((_BYTE *)v25 + 24))
  {
    v19 = sub_10000EF14("item");
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138477827;
      v29 = a1;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "inserted %{private}@", buf, 0xCu);
    }
    sub_1000104AC(a2, 0, (CFArrayRef)a1);
  }
  else
  {
LABEL_33:
    if ((sub_100004514((__CFString ***)a1) & 1) == 0)
    {
      v20 = sub_10000EF14("item");
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        if (a3)
          v21 = *a3;
        else
          v21 = 0;
        *(_DWORD *)buf = 138478083;
        v29 = a1;
        v30 = 2112;
        v31 = v21;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "insert failed for item %{private}@ with %@", buf, 0x16u);
      }
    }
  }
  v16 = *((_BYTE *)v25 + 24) != 0;
  _Block_object_dispose(&v24, 8);
  return v16;
}

BOOL sub_10001E020(CFStringRef **a1, uint64_t a2, CFTypeRef *a3, uint64_t a4)
{
  const __CFAllocator *v8;
  __CFString *Mutable;
  CFStringRef *v10;
  const __CFString **v11;
  const __CFString ***v12;
  const __CFString **v13;
  char v14;
  char v15;
  _BOOL8 v16;
  _QWORD v18[9];
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  BOOL v22;

  v8 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v8, 0);
  CFStringAppend(Mutable, CFSTR("DELETE FROM "));
  CFStringAppend(Mutable, *a1[2]);
  LOBYTE(v19) = 1;
  v10 = a1[2];
  v11 = (const __CFString **)v10[2];
  if (v11)
  {
    v12 = (const __CFString ***)(v10 + 3);
    do
    {
      if ((*(unsigned int (**)(uint64_t, const __CFString **))(a4 + 16))(a4, v11))
        sub_100013150(Mutable, *v11, &v19);
      v13 = *v12++;
      v11 = v13;
    }
    while (v13);
  }
  v19 = 0;
  v20 = &v19;
  v21 = 0x2000000000;
  v22 = Mutable != 0;
  if (Mutable)
  {
    v18[0] = _NSConcreteStackBlock;
    v18[1] = 0x40000000;
    v18[2] = sub_10001E18C;
    v18[3] = &unk_1002DEAC0;
    v18[6] = a1;
    v18[7] = a3;
    v18[4] = a4;
    v18[5] = &v19;
    v18[8] = a2;
    v14 = sub_10001E3C4(a2, (uint64_t)Mutable, a3, (uint64_t)v18);
    if (*((_BYTE *)v20 + 24))
      v15 = v14;
    else
      v15 = 0;
    *((_BYTE *)v20 + 24) = v15;
    CFRelease(Mutable);
    v16 = *((_BYTE *)v20 + 24) != 0;
  }
  else
  {
    v16 = 0;
  }
  _Block_object_dispose(&v19, 8);
  return v16;
}

const __CFString *sub_10001E18C(_QWORD *a1, sqlite3_stmt *pStmt)
{
  __CFString **v4;
  uint64_t v5;
  uint64_t v6;
  _BYTE *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  const __CFString *result;
  const __CFString *v12;
  int v13;
  _BYTE *v14;

  v5 = a1[6];
  v4 = (__CFString **)a1[7];
  v6 = *(_QWORD *)(v5 + 16);
  v7 = *(_BYTE **)(v6 + 16);
  if (v7)
  {
    LODWORD(v8) = 0;
    v9 = a1[4];
    v10 = (_QWORD *)(v6 + 24);
    while (1)
    {
      if ((*(unsigned int (**)(uint64_t, _BYTE *))(v9 + 16))(v9, v7))
      {
        result = (const __CFString *)sub_100010724((CFMutableDictionaryRef *)v5, v7, v4);
        if (!result)
          goto LABEL_9;
        v12 = result;
        v8 = (v8 + 1);
        v13 = sub_100013544(pStmt, v8, result, (CFTypeRef *)v4);
        CFRelease(v12);
        if (!v13)
          break;
      }
      v14 = (_BYTE *)*v10++;
      v7 = v14;
      if (!v14)
      {
        v4 = (__CFString **)a1[7];
        goto LABEL_8;
      }
    }
    result = 0;
  }
  else
  {
LABEL_8:
    result = (const __CFString *)sub_100019C40(a1[8], pStmt, (CFTypeRef *)v4, 0);
  }
LABEL_9:
  *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) = (_BYTE)result;
  return result;
}

BOOL sub_10001E270(id a1, const SecDbAttr *a2)
{
  return a2->var1 == 8;
}

BOOL sub_10001E280(CFDictionaryRef *a1, uint64_t a2, CFTypeRef *a3, Block_layout *a4, Block_layout *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  Block_layout *v13;
  Block_layout *v14;
  __CFString *v15;
  __CFString *v16;
  char v17;
  char v18;
  _BOOL8 v19;
  _QWORD v21[12];
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  char v25;

  v22 = 0;
  v23 = &v22;
  v24 = 0x2000000000;
  v25 = 1;
  if (a4)
    v13 = a4;
  else
    v13 = &stru_1002DE9A0;
  if (a5)
    v14 = a5;
  else
    v14 = &stru_1002DE9E0;
  v15 = sub_10001EA54(a1, (uint64_t)v13, (uint64_t)v14, a6);
  if (v15)
  {
    v16 = v15;
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 0x40000000;
    v21[2] = sub_10001E428;
    v21[3] = &unk_1002DEA30;
    v21[8] = &v22;
    v21[9] = a1;
    v21[4] = v14;
    v21[5] = a7;
    v21[10] = a3;
    v21[11] = a2;
    v21[6] = v13;
    v21[7] = a8;
    v17 = sub_10001E3C4(a2, (uint64_t)v15, a3, (uint64_t)v21);
    if (*((_BYTE *)v23 + 24))
      v18 = v17;
    else
      v18 = 0;
    *((_BYTE *)v23 + 24) = v18;
    CFRelease(v16);
    v19 = *((_BYTE *)v23 + 24) != 0;
  }
  else
  {
    v19 = 0;
    *((_BYTE *)v23 + 24) = 0;
  }
  _Block_object_dispose(&v22, 8);
  return v19;
}

uint64_t sub_10001E3C4(uint64_t a1, uint64_t a2, CFTypeRef *a3, uint64_t a4)
{
  uint64_t result;
  sqlite3_stmt *v7;

  result = sub_100012AE8(a1, a2, 0, a3);
  if (result)
  {
    v7 = (sqlite3_stmt *)result;
    (*(void (**)(uint64_t, uint64_t))(a4 + 16))(a4, result);
    return sub_100012D08(v7, a3);
  }
  return result;
}

uint64_t sub_10001E428(uint64_t a1, sqlite3_stmt *a2)
{
  uint64_t result;
  uint64_t v5;
  CFTypeRef *v6;
  _QWORD v7[4];
  __int128 v8;
  uint64_t v9;
  sqlite3_stmt *v10;
  CFTypeRef *v11;

  result = sub_10001ED30(*(CFDictionaryRef **)(a1 + 72), a2, *(__CFString ***)(a1 + 80), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
  if ((_DWORD)result)
  {
    v6 = *(CFTypeRef **)(a1 + 80);
    v5 = *(_QWORD *)(a1 + 88);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 0x40000000;
    v7[2] = sub_10001BEA4;
    v7[3] = &unk_1002DEA08;
    v9 = *(_QWORD *)(a1 + 72);
    v10 = a2;
    v11 = v6;
    v8 = *(_OWORD *)(a1 + 48);
    result = sub_100019C40(v5, a2, v6, (uint64_t)v7);
  }
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24) = result;
  return result;
}

CFStringRef **sub_10001E4C0(CFStringRef **a1, uint64_t a2, CFBooleanRef cf1, int a4, CFTypeRef *a5)
{
  CFStringRef **result;
  CFStringRef **v11;
  _BOOL8 v12;

  if (cf1 && kCFBooleanFalse)
  {
    if (CFEqual(cf1, kCFBooleanFalse))
      return (CFStringRef **)sub_10000C25C(a1, a2, a5, (uint64_t)&stru_1002DE938);
  }
  else if (kCFBooleanFalse == cf1)
  {
    return (CFStringRef **)sub_10000C25C(a1, a2, a5, (uint64_t)&stru_1002DE938);
  }
  result = (CFStringRef **)sub_10011770C((uint64_t)a1, cf1, a4, (__CFString **)a5);
  if (result)
  {
    v11 = result;
    v12 = sub_100007BB0((__CFString ***)a1, result, a2, a5, (uint64_t)&stru_1002DE8F8);
    CFRelease(v11);
    return (CFStringRef **)v12;
  }
  return result;
}

uint64_t sub_10001E594(const __CFAllocator *a1, _QWORD *a2, sqlite3_stmt *a3, int a4, uint64_t a5)
{
  uint64_t v9;
  _BYTE *v10;
  int v11;
  uint64_t i;
  void *v13;
  const void *v14;
  __CFDictionary *v15;
  const void *v16;
  const void **v17;

  v9 = sub_10001E8EC(a1, (uint64_t)a2, a4, 0);
  v10 = (_BYTE *)a2[2];
  if (!v10)
    return v9;
  v11 = 0;
  for (i = 3; ; ++i)
  {
    if (!(*(unsigned int (**)(uint64_t, _BYTE *))(a5 + 16))(a5, v10))
      goto LABEL_6;
    v13 = sub_10001E710(a1, a3, (uint64_t)v10, v11);
    if (!v13)
      break;
    v14 = v13;
    ++v11;
    v15 = *(__CFDictionary **)(v9 + 48);
    v16 = (const void *)sub_1000107E4(v10);
    CFDictionarySetValue(v15, v16, v14);
    CFRelease(v14);
LABEL_6:
    v17 = (const void **)sub_10001E6A8(a2, 9, 0);
    if (v17 && CFDictionaryGetValue(*(CFDictionaryRef *)(v9 + 48), *v17))
      *(_DWORD *)(v9 + 40) = 1;
    v10 = (_BYTE *)a2[i];
    if (!v10)
      return v9;
  }
  if (v9)
  {
    CFRelease((CFTypeRef)v9);
    return 0;
  }
  return v9;
}

uint64_t sub_10001E6A8(_QWORD *a1, uint64_t a2, __CFString **a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;

  v3 = a1[2];
  if (!v3)
    goto LABEL_7;
  v4 = 0;
  v5 = a1 + 3;
  do
  {
    if (*(_DWORD *)(v3 + 8) == (_DWORD)a2)
      v4 = v3;
    v6 = *v5++;
    v3 = v6;
  }
  while (v6);
  if (!v4)
  {
LABEL_7:
    sub_100019F20(-26276, a3, CFSTR("Can't find attribute of kind %d in class %@"), a2, *a1);
    return 0;
  }
  return v4;
}

void *sub_10001E710(const __CFAllocator *a1, sqlite3_stmt *a2, uint64_t a3, int iCol)
{
  void *result;
  double v9;
  const __CFAllocator *v10;
  CFNumberType v11;
  double valuePtr;

  result = 0;
  switch(*(_DWORD *)(a3 + 8))
  {
    case 0:
    case 3:
      switch(sqlite3_column_type(a2, iCol))
      {
        case 1:
          goto LABEL_5;
        case 2:
          valuePtr = sqlite3_column_double(a2, iCol);
          v10 = a1;
          v11 = kCFNumberDoubleType;
          goto LABEL_10;
        case 3:
          goto LABEL_6;
        case 4:
          goto LABEL_2;
        case 5:
          result = kCFNull;
          break;
        default:
          result = 0;
          break;
      }
      break;
    case 1:
    case 7:
    case 9:
    case 0xA:
    case 0x10:
LABEL_2:
      result = sub_10001E898(a1, a2, iCol);
      break;
    case 2:
    case 0xE:
LABEL_6:
      result = (void *)sub_10011621C(a1, a2, iCol, *(_QWORD *)(a3 + 16));
      break;
    case 4:
    case 5:
    case 6:
      v9 = sqlite3_column_double(a2, iCol);
      result = CFDateCreate(a1, v9);
      break;
    case 8:
      valuePtr = COERCE_DOUBLE(sqlite3_column_int64(a2, iCol));
      v10 = a1;
      v11 = kCFNumberSInt64Type;
LABEL_10:
      result = CFNumberCreate(v10, v11, &valuePtr);
      break;
    case 0xB:
    case 0xC:
LABEL_5:
      result = sub_1001161BC(a1, a2, iCol);
      break;
    default:
      return result;
  }
  return result;
}

BOOL sub_10001E880(id a1, const SecDbAttr *a2)
{
  int var1;

  var1 = a2->var1;
  return (var1 & 0xFFFFFFFE) == 8 || var1 == 16;
}

CFDataRef sub_10001E898(const __CFAllocator *a1, sqlite3_stmt *a2, int iCol)
{
  const UInt8 *v6;
  CFIndex v7;

  v6 = (const UInt8 *)sqlite3_column_blob(a2, iCol);
  v7 = sqlite3_column_bytes(a2, iCol);
  return CFDataCreate(a1, v6, v7);
}

uint64_t sub_10001E8EC(const __CFAllocator *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t Instance;
  _QWORD block[5];

  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100115500;
  block[3] = &unk_1002DE618;
  block[4] = &qword_100341148;
  if (qword_100341140 != -1)
    dispatch_once(&qword_100341140, block);
  Instance = _CFRuntimeCreateInstance(a1, qword_100341148, 64, 0);
  *(_QWORD *)(Instance + 16) = a2;
  *(_QWORD *)(Instance + 48) = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  *(_DWORD *)(Instance + 28) = a3;
  *(_QWORD *)(Instance + 32) = a4;
  *(_DWORD *)(Instance + 40) = 0;
  *(_QWORD *)(Instance + 64) = CFSTR("od");
  return Instance;
}

const void *sub_10001E9E8(uint64_t a1, const __CFDictionary *a2, int a3, __CFString **a4)
{
  uint64_t v6;
  const void *v7;

  v6 = sub_10001E8EC(kCFAllocatorDefault, a1, a3, 0);
  v7 = (const void *)v6;
  if (v6 && (sub_10001A4F4(v6, a2, a4) & 1) == 0)
  {
    CFRelease(v7);
    return 0;
  }
  return v7;
}

__CFString *sub_10001EA54(CFDictionaryRef *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __CFString *Mutable;
  const __CFString **v9;
  int v10;
  const __CFString ***v11;
  const __CFString *v12;
  const __CFString **v13;
  const void **v14;
  const void ***v15;
  const __CFArray *Value;
  const __CFArray *v17;
  CFTypeID v18;
  CFIndex Count;
  uint64_t v20;
  CFIndex v21;
  CFNullRef ValueAtIndex;
  const __CFString *v23;
  const __CFString *v24;
  __CFString *v25;
  const void **v26;
  const __CFString *v27;
  __CFString *v28;
  uint64_t v29;
  char v31;

  Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
  CFStringAppend(Mutable, CFSTR("SELECT "));
  v9 = (const __CFString **)*((_QWORD *)*a1 + 2);
  if (!v9)
  {
    if (((_BYTE)a1[6] & 8) == 0)
      goto LABEL_13;
    goto LABEL_12;
  }
  v10 = 0;
  v11 = (const __CFString ***)((char *)*a1 + 24);
  do
  {
    if ((*(unsigned int (**)(uint64_t, const __CFString **))(a2 + 16))(a2, v9))
    {
      v12 = *v9;
      if (v10)
        CFStringAppend(Mutable, CFSTR(","));
      CFStringAppend(Mutable, v12);
      v10 = 1;
    }
    v13 = *v11++;
    v9 = v13;
  }
  while (v13);
  if (((_BYTE)a1[6] & 8) != 0)
  {
    if (v10)
      CFStringAppend(Mutable, CFSTR(","));
LABEL_12:
    CFStringAppend(Mutable, CFSTR("persistref"));
  }
LABEL_13:
  CFStringAppend(Mutable, CFSTR(" FROM "));
  CFStringAppend(Mutable, *(CFStringRef *)*a1);
  v31 = 1;
  v14 = (const void **)*((_QWORD *)*a1 + 2);
  if (v14)
  {
    v15 = (const void ***)((char *)*a1 + 24);
    do
    {
      if ((*(unsigned int (**)(uint64_t, const void **))(a3 + 16))(a3, v14))
      {
        Value = (const __CFArray *)CFDictionaryGetValue(a1[1], *v14);
        if (!Value || (v17 = Value, v18 = CFGetTypeID(Value), v18 != CFArrayGetTypeID()))
        {
          v24 = (const __CFString *)*v14;
          v25 = Mutable;
LABEL_25:
          sub_100013150(v25, v24, &v31);
          goto LABEL_26;
        }
        Count = CFArrayGetCount(v17);
        v20 = Count - 1;
        if (Count >= 1)
        {
          v21 = Count;
          ValueAtIndex = (CFNullRef)CFArrayGetValueAtIndex(v17, 0);
          if (ValueAtIndex && kCFNull)
          {
            if (!CFEqual(ValueAtIndex, kCFNull))
              goto LABEL_29;
          }
          else if (ValueAtIndex != kCFNull)
          {
LABEL_29:
            v27 = (const __CFString *)*v14;
            if (v21 != 1)
            {
              sub_100013190(Mutable, &v31);
              CFStringAppend(Mutable, v27);
              CFStringAppend(Mutable, CFSTR(" IN ("));
              v28 = Mutable;
              v29 = v21;
LABEL_33:
              sub_100116330(v28, v29);
              goto LABEL_26;
            }
            v25 = Mutable;
            v24 = (const __CFString *)*v14;
            goto LABEL_25;
          }
          v23 = (const __CFString *)*v14;
          sub_100013190(Mutable, &v31);
          CFStringAppend(Mutable, v23);
          if (v20 != 1)
          {
            CFStringAppend(Mutable, CFSTR(" NOT IN ("));
            v28 = Mutable;
            v29 = v20;
            goto LABEL_33;
          }
          CFStringAppend(Mutable, CFSTR("!=?"));
        }
      }
LABEL_26:
      v26 = *v15++;
      v14 = v26;
    }
    while (v26);
  }
  if (a4)
    (*(void (**)(uint64_t, __CFString *, char *))(a4 + 16))(a4, Mutable, &v31);
  return Mutable;
}

BOOL sub_10001ECF4(id a1, const SecDbAttr *a2)
{
  int var1;

  var1 = a2->var1;
  return (var1 - 7) < 3 || var1 == 16;
}

uint64_t sub_10001ED0C(uint64_t a1, __CFString *a2)
{
  sub_100012F64(a2, *(_QWORD *)(a1 + 32), *(const __CFArray **)(a1 + 40));
  return 1;
}

uint64_t sub_10001ED30(CFDictionaryRef *a1, sqlite3_stmt *a2, __CFString **a3, uint64_t a4, uint64_t a5)
{
  const void **v7;
  const void ***v11;
  const __CFArray *Value;
  const __CFArray *v13;
  CFTypeID v14;
  uint64_t Count;
  CFNullRef ValueAtIndex;
  _BOOL4 v17;
  int v18;
  uint64_t v19;
  sqlite3_stmt *v20;
  uint64_t v21;
  const __CFNull *v22;
  int v23;
  CFRange v24;
  const void **v25;
  uint64_t v26;
  _QWORD context[10];
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  char v36;

  v33 = 0;
  v34 = &v33;
  v35 = 0x2000000000;
  v36 = 1;
  v29 = 0;
  v30 = &v29;
  v31 = 0x2000000000;
  v32 = 0;
  v7 = (const void **)*((_QWORD *)*a1 + 2);
  if (v7)
  {
    v11 = (const void ***)((char *)*a1 + 24);
    do
    {
      if ((*(unsigned int (**)(uint64_t, const void **))(a4 + 16))(a4, v7))
      {
        Value = (const __CFArray *)CFDictionaryGetValue(a1[1], *v7);
        if (!Value)
        {
          v18 = *((_DWORD *)v30 + 6);
          *((_DWORD *)v30 + 6) = v18 + 1;
          v19 = (uint64_t)a1;
          v20 = a2;
          v21 = (uint64_t)v7;
          v22 = 0;
          goto LABEL_12;
        }
        v13 = Value;
        v14 = CFGetTypeID(Value);
        if (v14 != CFArrayGetTypeID())
        {
          v18 = *((_DWORD *)v30 + 6);
          *((_DWORD *)v30 + 6) = v18 + 1;
          v19 = (uint64_t)a1;
          v20 = a2;
          v21 = (uint64_t)v7;
          v22 = v13;
LABEL_12:
          v23 = sub_100116944(v19, v20, v18, v21, v22, a3);
          *((_BYTE *)v34 + 24) = v23;
          if (!v23)
            break;
          goto LABEL_18;
        }
        Count = CFArrayGetCount(v13);
        if (Count < 1)
        {
          v24.location = 0;
        }
        else
        {
          ValueAtIndex = (CFNullRef)CFArrayGetValueAtIndex(v13, 0);
          if (ValueAtIndex && kCFNull)
            v17 = CFEqual(ValueAtIndex, kCFNull) != 0;
          else
            v17 = ValueAtIndex == kCFNull;
          Count -= v17;
          v24.location = v17;
        }
        context[0] = _NSConcreteStackBlock;
        context[1] = 0x40000000;
        context[2] = sub_1001168E0;
        context[3] = &unk_1002DE960;
        context[6] = a1;
        context[7] = a2;
        context[4] = &v33;
        context[5] = &v29;
        context[8] = v7;
        context[9] = a3;
        v24.length = Count;
        CFArrayApplyFunction(v13, v24, (CFArrayApplierFunction)sub_100116930, context);
        if (!*((_BYTE *)v34 + 24))
          break;
      }
LABEL_18:
      v25 = *v11++;
      v7 = v25;
    }
    while (v25);
  }
  if (a5)
  {
    ++*((_DWORD *)v30 + 6);
    (*(void (**)(uint64_t, sqlite3_stmt *))(a5 + 16))(a5, a2);
  }
  v26 = *((unsigned __int8 *)v34 + 24);
  _Block_object_dispose(&v29, 8);
  _Block_object_dispose(&v33, 8);
  return v26;
}

BOOL sub_10001EF78(id a1, const SecDbAttr *a2)
{
  return 0;
}

uint64_t sub_10001EF80(uint64_t a1, sqlite3_stmt *a2, int a3)
{
  int v4;

  v4 = a3;
  return sub_1000132C4(a2, *(_QWORD *)(a1 + 32), *(const __CFArray **)(a1 + 40), &v4, *(CFTypeRef **)(a1 + 48));
}

__CFDictionary *sub_100020460(_QWORD *a1, uint64_t a2, __CFString **a3)
{
  return sub_10001A3F4(a1, 1, a3);
}

void sub_100020468(const __CFString *a1, const __CFString *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  CFIndex v8;
  CFIndex v9;
  __CFData *Mutable;
  UInt8 *MutableBytePtr;
  UInt8 *v12;
  CFTypeRef *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  CFRange v19;

  if (*(_BYTE *)a3)
  {
    v8 = sub_100020E9C(a1, a2, *(CFTypeRef **)(a3 + 8), a4, a5);
    if (!v8)
    {
      *(_BYTE *)a3 = 0;
      return;
    }
    v9 = v8;
    Mutable = CFDataCreateMutable(*(CFAllocatorRef *)(a3 + 24), v8);
    CFDataSetLength(Mutable, v9);
    MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    v12 = &MutableBytePtr[v9];
    v13 = *(CFTypeRef **)(a3 + 8);
    v14 = *(unsigned __int8 *)(a3 + 1);
    v15 = sub_100020FA0(a2, v13, v14, MutableBytePtr, v12);
    v16 = sub_100020FA0(a1, v13, v14, MutableBytePtr, v15);
    v17 = ccder_encode_constructed_tl(0x2000000000000010, v12, MutableBytePtr, v16);
    if (v17)
    {
      v19.length = v17 - (_QWORD)MutableBytePtr;
      v19.location = 0;
      CFDataDeleteBytes(Mutable, v19);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 16), Mutable);
      if (!Mutable)
        return;
    }
    else
    {
      sub_100032660(-7, CFSTR("com.apple.security.cfder.error"), 0, v13, v18, CFSTR("ccder failed to encode"));
      *(_BYTE *)a3 = 0;
      if (!Mutable)
        return;
    }
    CFRelease(Mutable);
  }
}

uint64_t sub_1000205A8(const __CFString *a1, CFTypeRef *a2, UInt8 *a3, uint64_t a4, uint64_t a5)
{
  CFIndex Length;
  uint64_t v10;
  CFIndex v11;
  uint64_t v12;
  uint64_t result;
  uint64_t v14;
  CFIndex usedBufLen;
  CFRange v16;

  if (a4)
  {
    Length = CFStringGetLength(a1);
    usedBufLen = 0;
    v16.location = 0;
    v16.length = Length;
    if (CFStringGetBytes(a1, v16, 0x8000100u, 0, 0, a3, a4 - (_QWORD)a3, &usedBufLen) == Length)
    {
      v11 = usedBufLen;
      v12 = ccder_encode_body(usedBufLen, a3, a3, a4);
      result = ccder_encode_tl(12, v11, a3, v12);
      if (result)
        return result;
      sub_100032660(-7, CFSTR("com.apple.security.cfder.error"), 0, a2, v14, CFSTR("ccder failed to encode"));
    }
    else
    {
      sub_100032660(-5, CFSTR("com.apple.security.cfder.error"), 0, a2, v10, CFSTR("String extraction failed"));
    }
  }
  else
  {
    sub_100032660(-6, CFSTR("com.apple.security.cfder.error"), 0, a2, a5, CFSTR("null input"));
  }
  return 0;
}

uint64_t sub_1000206B0(const __CFData *a1, CFTypeRef *a2, uint64_t a3, uint64_t a4)
{
  CFIndex Length;
  const UInt8 *BytePtr;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  Length = CFDataGetLength(a1);
  BytePtr = CFDataGetBytePtr(a1);
  v10 = ccder_encode_body(Length, BytePtr, a3, a4);
  v12 = ccder_encode_tl(4, Length, a3, v10);
  if (!v12)
    sub_100032660(-7, CFSTR("com.apple.security.cfder.error"), 0, a2, v11, CFSTR("ccder failed to encode"));
  return v12;
}

unint64_t sub_10002074C(const __CFAllocator *a1, CFMutableDictionaryRef *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  CFMutableDictionaryRef Mutable;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  void *v16;
  unint64_t v17;
  unint64_t v19;
  void *value;
  void *key;
  uint64_t v22;

  if (a4)
  {
    v19 = 0;
    v9 = ccder_decode_constructed_tl(0x2000000000000011, &v19, a4, a5);
    if (v9)
    {
      Mutable = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        v12 = v19;
        if (v9 >= v19)
        {
          v17 = v9;
          if (v9 != v19)
          {
LABEL_26:
            CFRelease(Mutable);
            return v17;
          }
        }
        else
        {
          while (1)
          {
            v22 = 0;
            if (!ccder_decode_constructed_tl(0x2000000000000010, &v22, v9, v12))
            {
              sub_100032660(-1, CFSTR("com.apple.security.cfder.error"), 0, a3, v13, CFSTR("Unknown data encoding, expected CCDER_CONSTRUCTED_SEQUENCE"));
              goto LABEL_24;
            }
            value = 0;
            key = 0;
            sub_100020974((int)a1, (int)&key, (int)a3);
            v14 = sub_100020974((int)a1, (int)&value, (int)a3);
            v15 = key;
            if (!v14)
              break;
            v9 = v14;
            v16 = value;
            CFDictionaryAddValue(Mutable, key, value);
            if (v15)
              CFRelease(v15);
            if (v16)
              CFRelease(v16);
            v12 = v19;
            if (v9 >= v19)
              goto LABEL_25;
          }
          if (key)
            CFRelease(key);
          if (value)
            CFRelease(value);
LABEL_24:
          v9 = 0;
          v12 = v19;
LABEL_25:
          v17 = v9;
          v9 = v12;
          if (v17 != v12)
            goto LABEL_26;
        }
        goto LABEL_18;
      }
      sub_100032660(-3, CFSTR("com.apple.security.cfder.error"), 0, a3, v10, CFSTR("Failed to create dictionary"));
      v9 = 0;
      if (!v19)
LABEL_18:
        *a2 = Mutable;
    }
    else
    {
      sub_100032660(-1, CFSTR("com.apple.security.cfder.error"), 0, a3, v8, CFSTR("Unknown data encoding, expected CCDER_CONSTRUCTED_SET"));
    }
  }
  else
  {
    sub_100032660(-6, CFSTR("com.apple.security.cfder.error"), 0, a3, a5, CFSTR("null input"));
    return 0;
  }
  return v9;
}

unsigned __int8 *sub_100020974(const __CFAllocator *a1, CFBooleanRef *a2, CFTypeRef *a3, const UInt8 *a4, uint64_t a5)
{
  uint64_t v10;
  unint64_t v11;
  const __CFString *v12;
  CFIndex v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const UInt8 *v17;
  const UInt8 *v18;
  CFIndex v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  signed int v27;
  CFDataRef v29;
  CFStringRef v30;
  CFDateRef v31;
  uint64_t v32;
  CFAbsoluteTime at;
  int v34[2];
  CFIndex numBytes;

  if (!a4)
  {
    sub_100032660(-6, CFSTR("com.apple.security.cfder.error"), 0, a3, a5, CFSTR("null input"));
    return 0;
  }
  v32 = 0xAAAAAAAAAAAAAAAALL;
  if (!ccder_decode_tag(&v32, a4, a5))
  {
    v12 = CFSTR("invalid tag");
    goto LABEL_8;
  }
  if (v32 <= 17)
  {
    switch(v32)
    {
      case 1:
        return sub_100021808(a2, a3, (uint64_t)a4, a5);
      case 2:
        return (unsigned __int8 *)sub_1000218B0(a1, a2, a3, (uint64_t)a4, a5);
      case 3:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
        goto LABEL_28;
      case 4:
        return (unsigned __int8 *)sub_100021480(a1, a2, a3, (uint64_t)a4, a5);
      case 5:
        return (unsigned __int8 *)sub_100032FF4(a2, a3, (uint64_t)a4, a5);
      case 12:
        return (unsigned __int8 *)sub_100020DA8(a1, (CFStringRef *)a2, a3, (uint64_t)a4, a5);
      default:
        if (v32 != 0xC000000000000011)
          goto LABEL_28;
        v11 = sub_1000330CC(a1, (CFTypeRef *)a2, a3, (uint64_t)a4, a5);
        break;
    }
    return (unsigned __int8 *)v11;
  }
  if (v32 > 0x200000000000000FLL)
  {
    if (v32 == 0x2000000000000010)
      return (unsigned __int8 *)sub_100006690(a1, a2, a3, (uint64_t)a4, a5);
    if (v32 == 0x2000000000000011)
      return (unsigned __int8 *)sub_10002074C(a1, a2, a3, (uint64_t)a4, a5);
    if (v32 != 0x6000000000000010)
      goto LABEL_28;
    numBytes = 0;
    v15 = ccder_decode_tl(0x6000000000000010, &numBytes, a4, a5);
    if (v15)
    {
      v16 = v15;
      if (a5 - v15 >= numBytes)
      {
        v29 = CFDataCreate(a1, a4, v15 + numBytes - (_QWORD)a4);
        *a2 = v29;
        if (v29)
          return (unsigned __int8 *)(v16 + numBytes);
        v12 = CFSTR("Failed to create CoreEntitlements data");
        goto LABEL_50;
      }
    }
    v12 = CFSTR("Unknown CoreEntitlements encoding");
    goto LABEL_8;
  }
  if (v32 == 18)
  {
    numBytes = 0;
    v17 = (const UInt8 *)ccder_decode_tl(18, &numBytes, a4, a5);
    if (v17)
    {
      v18 = v17;
      if (a5 - (uint64_t)v17 >= numBytes)
      {
        v30 = CFStringCreateWithBytes(a1, v17, numBytes, 0x8000100u, 0);
        *a2 = (CFBooleanRef)v30;
        if (v30)
          return (unsigned __int8 *)&v18[numBytes];
        v12 = CFSTR("Numeric string allocation failed");
        goto LABEL_50;
      }
    }
    v12 = CFSTR("Unknown numeric string encoding");
LABEL_8:
    v13 = -1;
LABEL_9:
    sub_100032660(v13, CFSTR("com.apple.security.cfder.error"), 0, a3, v10, v12);
    return 0;
  }
  if (v32 != 23)
  {
    if (v32 == 24)
      return (unsigned __int8 *)sub_100021A6C(a1, a2, a3, (uint64_t)a4, a5);
LABEL_28:
    sub_100032660(-2, CFSTR("com.apple.security.cfder.error"), 0, a3, v10, CFSTR("Unsupported DER Type"));
    return 0;
  }
  *(_QWORD *)v34 = a5;
  v19 = ccder_decode_constructed_tl(23, v34, a4, a5);
  at = 0.0;
  v20 = *(_QWORD *)v34;
  numBytes = v19;
  v23 = sub_100022064((unsigned __int8 **)&numBytes, *(unint64_t *)v34, a3, v21, v22);
  v27 = sub_100022064((unsigned __int8 **)&numBytes, v20, a3, v24, v25) + 10 * v23;
  if (v27 > 49)
  {
    if (v27 > 0x45)
    {
      v27 += 1900;
    }
    else
    {
      sub_100032660(-1, CFSTR("com.apple.security.cfder.error"), 0, a3, v26, CFSTR("Invalid universal time year between 50 and 70"));
      numBytes = 0;
    }
  }
  else
  {
    v27 += 2000;
  }
  v14 = sub_100021BC8(&at, a3, v27, (unsigned __int8 *)numBytes, v20);
  if (v14)
  {
    v31 = CFDateCreate(a1, at);
    *a2 = v31;
    if (!v31)
    {
      v12 = CFSTR("Failed to create utc date");
LABEL_50:
      v13 = -3;
      goto LABEL_9;
    }
  }
  return (unsigned __int8 *)v14;
}

const UInt8 *sub_100020DA8(const __CFAllocator *a1, CFStringRef *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5)
{
  const UInt8 *v9;
  uint64_t v10;
  const UInt8 *v11;
  CFStringRef v13;
  uint64_t v14;
  CFIndex numBytes;

  if (a4)
  {
    numBytes = 0;
    v9 = (const UInt8 *)ccder_decode_tl(12, &numBytes, a4, a5);
    if (v9 && (v11 = v9, a5 - (uint64_t)v9 >= numBytes))
    {
      v13 = CFStringCreateWithBytes(a1, v9, numBytes, 0x8000100u, 0);
      *a2 = v13;
      if (v13)
        return &v11[numBytes];
      sub_100032660(-3, CFSTR("com.apple.security.cfder.error"), 0, a3, v14, CFSTR("String allocation failed"));
    }
    else
    {
      sub_100032660(-1, CFSTR("com.apple.security.cfder.error"), 0, a3, v10, CFSTR("Unknown string encoding"));
    }
  }
  else
  {
    sub_100032660(-6, CFSTR("com.apple.security.cfder.error"), 0, a3, a5, CFSTR("null input"));
  }
  return 0;
}

uint64_t sub_100020E9C(const __CFString *a1, const __CFString *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v7 = sub_1000212A4(a1, a3, (uint64_t)a3, a4, a5);
  if (v7)
  {
    v11 = v7;
    v12 = sub_1000212A4(a2, a3, v8, v9, v10);
    if (v12)
      return ccder_sizeof(0x2000000000000010, v12 + v11);
  }
  sub_100032660(-6, CFSTR("com.apple.security.cfder.error"), 0, a3, v10, CFSTR("null input"));
  return 0;
}

uint64_t sub_100020F24(const __CFString *a1)
{
  CFIndex Length;
  CFIndex MaximumSizeForEncoding;
  CFIndex v4;
  CFIndex usedBufLen;
  CFRange v7;

  Length = CFStringGetLength(a1);
  MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  usedBufLen = 0;
  v7.location = 0;
  v7.length = Length;
  if (CFStringGetBytes(a1, v7, 0x8000100u, 0, 0, 0, MaximumSizeForEncoding, &usedBufLen) == Length)
    v4 = usedBufLen;
  else
    v4 = 0;
  return ccder_sizeof(12, v4);
}

uint64_t sub_100020FA0(const __CFString *a1, CFTypeRef *a2, uint64_t a3, UInt8 *a4, unint64_t a5)
{
  CFTypeID v10;
  CFIndex Count;
  uint64_t v12;
  unint64_t v13;
  const void *ValueAtIndex;
  uint64_t v15;
  unint64_t v16;
  UInt8 *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  double AbsoluteTime;
  uint64_t v25;
  uint64_t v26;
  Boolean Value;

  if (!a1)
  {
    sub_100032660(-5, CFSTR("com.apple.security.cfder.error"), 0, a2, a5, CFSTR("Null CFType"));
    return 0;
  }
  v10 = CFGetTypeID(a1);
  if (CFArrayGetTypeID() == v10)
  {
    Count = CFArrayGetCount((CFArrayRef)a1);
    v12 = a5;
    if (Count >= 1)
    {
      v13 = Count + 1;
      v12 = a5;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, v13 - 2);
        v12 = sub_100020FA0(ValueAtIndex, a2, a3, a4, v12);
        --v13;
      }
      while (v13 > 1);
    }
    v15 = 0x2000000000000010;
    v16 = a5;
    v17 = a4;
    v18 = v12;
    goto LABEL_7;
  }
  if (CFBooleanGetTypeID() == v10)
  {
    Value = CFBooleanGetValue((CFBooleanRef)a1);
    v22 = ccder_encode_body(1, &Value, a4, a5);
    v19 = ccder_encode_tl(1, 1, a4, v22);
LABEL_12:
    v21 = v19;
    if (!v19)
      sub_100032660(-7, CFSTR("com.apple.security.cfder.error"), 0, a2, v20, CFSTR("ccder failed to encode"));
    return v21;
  }
  if (CFDataGetTypeID() == v10)
    return sub_1000206B0((const __CFData *)a1, a2, (uint64_t)a4, a5);
  if (CFDateGetTypeID() == v10)
  {
    AbsoluteTime = CFDateGetAbsoluteTime((CFDateRef)a1);
    v18 = sub_100022108(a2, a3, (uint64_t)a4, a5, AbsoluteTime);
    v15 = 24;
    v16 = a5;
    v17 = a4;
LABEL_7:
    v19 = ccder_encode_constructed_tl(v15, v16, v17, v18);
    goto LABEL_12;
  }
  if (CFDictionaryGetTypeID() == v10)
    return sub_1000101DC((const __CFDictionary *)a1, a2, a3, (uint64_t)a4, a5);
  if (CFSetGetTypeID() == v10)
    return sub_1000332E8((const __CFSet *)a1, a2, a3, (uint64_t)a4, a5);
  if (CFStringGetTypeID() == v10)
    return sub_1000205A8(a1, a2, a4, a5, v25);
  if (CFNumberGetTypeID() == v10)
    return sub_1000216B4((const __CFNumber *)a1, a2, (uint64_t)a4, a5);
  if (CFNullGetTypeID() != v10)
  {
    sub_100032660(-5, CFSTR("com.apple.security.cfder.error"), 0, a2, v26, CFSTR("Unsupported CFType"));
    return 0;
  }
  return sub_100033070(a2, (uint64_t)a4, a5);
}

uint64_t sub_1000212A4(const __CFString *a1, CFTypeRef *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  CFTypeID v7;
  CFIndex Count;
  uint64_t v9;
  unint64_t v10;
  const void *ValueAtIndex;
  uint64_t v13;
  uint64_t v14;
  CFIndex Length;
  uint64_t v16;

  if (!a1)
  {
    sub_100032660(-5, CFSTR("com.apple.security.cfder.error"), 0, a2, a5, CFSTR("Null CFType"));
    return 0;
  }
  v7 = CFGetTypeID(a1);
  if (CFArrayGetTypeID() == v7)
  {
    Count = CFArrayGetCount((CFArrayRef)a1);
    if (Count < 1)
    {
      v9 = 0;
    }
    else
    {
      v9 = 0;
      v10 = Count + 1;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, v10 - 2);
        v9 += sub_1000212A4(ValueAtIndex, a2);
        --v10;
      }
      while (v10 > 1);
    }
    v13 = 0x2000000000000010;
    v14 = v9;
    return ccder_sizeof(v13, v14);
  }
  if (CFBooleanGetTypeID() == v7)
  {
    v13 = 1;
    v14 = 1;
    return ccder_sizeof(v13, v14);
  }
  if (CFDataGetTypeID() == v7)
  {
    Length = CFDataGetLength((CFDataRef)a1);
    return ccder_sizeof_raw_octet_string(Length);
  }
  if (CFDateGetTypeID() == v7)
  {
    CFDateGetAbsoluteTime((CFDateRef)a1);
    v14 = sub_100021644();
    v13 = 24;
    return ccder_sizeof(v13, v14);
  }
  if (CFDictionaryGetTypeID() == v7)
    return sub_10001017C((const __CFDictionary *)a1, (uint64_t)a2);
  if (CFSetGetTypeID() == v7)
    return sub_100033244((const __CFSet *)a1, (uint64_t)a2);
  if (CFStringGetTypeID() == v7)
    return sub_100020F24(a1);
  if (CFNumberGetTypeID() != v7)
  {
    if (CFNullGetTypeID() == v7)
    {
      v13 = 5;
      v14 = 0;
      return ccder_sizeof(v13, v14);
    }
    sub_100032660(-5, CFSTR("com.apple.security.cfder.error"), 0, a2, v16, CFSTR("Unsupported CFType"));
    return 0;
  }
  return sub_100021568((const __CFNumber *)a1, a2);
}

const UInt8 *sub_100021480(const __CFAllocator *a1, CFDataRef *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5)
{
  const UInt8 *v9;
  uint64_t v10;
  const UInt8 *v11;
  CFDataRef v13;
  uint64_t v14;
  CFIndex length;

  if (a4)
  {
    length = 0;
    v9 = (const UInt8 *)ccder_decode_tl(4, &length, a4, a5);
    if (v9 && (v11 = v9, a5 - (uint64_t)v9 >= length))
    {
      v13 = CFDataCreate(a1, v9, length);
      *a2 = v13;
      if (v13)
        return &v11[length];
      sub_100032660(-3, CFSTR("com.apple.security.cfder.error"), 0, a3, v14, CFSTR("Failed to create data"));
    }
    else
    {
      sub_100032660(-1, CFSTR("com.apple.security.cfder.error"), 0, a3, v10, CFSTR("Unknown data encoding"));
    }
  }
  else
  {
    sub_100032660(-6, CFSTR("com.apple.security.cfder.error"), 0, a3, a5, CFSTR("null input"));
  }
  return 0;
}

uint64_t sub_100021568(const __CFNumber *a1, CFTypeRef *a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t valuePtr;

  valuePtr = 0xAAAAAAAAAAAAAAAALL;
  if (CFNumberGetValue(a1, kCFNumberLongLongType, &valuePtr))
  {
    v4 = HIBYTE(valuePtr);
    if ((HIBYTE(valuePtr) + 1) > 1u)
    {
      v10 = 8;
    }
    else
    {
      v5 = 9;
      v6 = 48;
      v7 = 1;
      while ((unint64_t)(v5 - 2) >= 2)
      {
        v8 = valuePtr >> v6;
        --v5;
        v6 -= 8;
        if ((_DWORD)v4 != v8)
        {
          v7 = v5 - 1;
          goto LABEL_10;
        }
      }
      v5 = 2;
LABEL_10:
      if ((((valuePtr >> (8 * v7 - 8)) ^ v4) & 0x80) != 0)
        v10 = v5;
      else
        v10 = v7;
    }
    return ccder_sizeof(2, v10);
  }
  else
  {
    sub_100032660(-4, CFSTR("com.apple.security.cfder.error"), 0, a2, v3, CFSTR("Unable to get number from data"));
    return 0;
  }
}

uint64_t sub_100021644()
{
  uint64_t v0;
  int64_t v1;
  int64_t v2;
  unint64_t v4;
  int v5;
  int v6;

  v5 = -1431655766;
  v6 = -1431655766;
  v4 = 0xAAAAAAAAAAAAAAAALL;
  v0 = __dtoa(0, 0, &v6, &v5, &v4);
  v1 = v4 - v0;
  __freedtoa();
  v2 = v1 - v6;
  if (v1 < v6)
    v2 = 0;
  if (v2)
    return v2 + 16;
  else
    return 15;
}

uint64_t sub_1000216B4(const __CFNumber *a1, CFTypeRef *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t result;
  uint64_t v17;
  uint64_t valuePtr;

  valuePtr = 0xAAAAAAAAAAAAAAAALL;
  if (!CFNumberGetValue(a1, kCFNumberLongLongType, &valuePtr))
  {
    sub_100032660(-4, CFSTR("com.apple.security.cfder.error"), 0, a2, v7, CFSTR("Unable to get number from data"));
    return 0;
  }
  v8 = valuePtr;
  v9 = HIBYTE(valuePtr);
  if ((HIBYTE(valuePtr) + 1) > 1u)
  {
    v14 = 8;
    if (!a4)
      goto LABEL_22;
  }
  else
  {
    v10 = 9;
    v11 = 48;
    v12 = 1;
    while ((unint64_t)(v10 - 2) >= 2)
    {
      v13 = valuePtr >> v11;
      --v10;
      v11 -= 8;
      if ((_DWORD)v9 != v13)
      {
        v12 = v10 - 1;
        goto LABEL_11;
      }
    }
    v10 = 2;
LABEL_11:
    if ((((valuePtr >> (8 * v12 - 8)) ^ v9) & 0x80) != 0)
      v14 = v10;
    else
      v14 = v12;
    if (!a4)
      goto LABEL_22;
  }
  if (a4 - a3 < (uint64_t)v14)
  {
LABEL_22:
    sub_100032660(-3, CFSTR("com.apple.security.cfder.error"), 0, a2, v7, CFSTR("Unknown size"));
    return 0;
  }
  if (v14 <= 1)
    v15 = 1;
  else
    v15 = v14;
  do
  {
    *(_BYTE *)--a4 = v8;
    v8 >>= 8;
    --v15;
  }
  while (v15);
  valuePtr = v8;
  result = ccder_encode_tl(2, v14, a3, a4);
  if (!result)
  {
    sub_100032660(-7, CFSTR("com.apple.security.cfder.error"), 0, a2, v17, CFSTR("ccder failed to encode"));
    return 0;
  }
  return result;
}

unsigned __int8 *sub_100021808(CFBooleanRef *a1, CFTypeRef *a2, uint64_t a3, uint64_t a4)
{
  unsigned __int8 *v7;
  uint64_t v8;
  BOOL v9;
  unsigned __int8 *result;
  int v11;
  const CFBooleanRef *v12;
  uint64_t v13;

  v13 = 0;
  v7 = (unsigned __int8 *)ccder_decode_tl(1, &v13, a3, a4);
  if (v7 && (a4 - (uint64_t)v7 >= 1 ? (v9 = v13 == 1) : (v9 = 0), v9))
  {
    v11 = *v7;
    result = v7 + 1;
    if (v11)
      v12 = &kCFBooleanTrue;
    else
      v12 = &kCFBooleanFalse;
    *a1 = *v12;
  }
  else
  {
    sub_100032660(-1, CFSTR("com.apple.security.cfder.error"), 0, a2, v8, CFSTR("Unknown BOOLean encoding"));
    return 0;
  }
  return result;
}

char *sub_1000218B0(const __CFAllocator *a1, CFNumberRef *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5)
{
  unsigned __int8 *v9;
  uint64_t v10;
  char *v11;
  int8x8_t v13;
  unsigned __int8 *v14;
  unsigned int v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  int8x16_t v20;
  int64x2_t v21;
  int64x2_t v22;
  uint64x2_t v23;
  int64x2_t v24;
  int8x16_t v25;
  int8x16_t v26;
  CFNumberRef v27;
  uint64_t v28;
  int8x8_t v29;
  unint64_t v30;

  v30 = 0;
  v9 = (unsigned __int8 *)ccder_decode_tl(2, &v30, a4, a5);
  if (v9 && (v11 = (char *)v9, a5 - (uint64_t)v9 >= (uint64_t)v30))
  {
    if (v30 < 9)
    {
      v29 = 0;
      if (v30)
      {
        v13 = 0;
        v14 = v9;
        do
        {
          v15 = *v14++;
          v13 = (int8x8_t)(v15 | (*(_QWORD *)&v13 << 8));
          v29 = v13;
        }
        while (v14 < &v9[v30]);
        if ((char)*v9 < 0)
        {
          if (v30 != 8)
          {
            if (8 - v30 <= 1)
              v16 = 1;
            else
              v16 = 8 - v30;
            v17 = (v16 - 1) & 0xFFFFFFFFFFFFFFFELL;
            v18 = v16 - 1;
            v19 = (v16 + 1) & 0xFFFFFFFFFFFFFFFELL;
            v20 = (int8x16_t)(unint64_t)v13;
            v21 = (int64x2_t)xmmword_100248F30;
            v22 = vdupq_n_s64(0x40uLL);
            v23.i64[0] = 255;
            v23.i64[1] = 255;
            v24 = vdupq_n_s64(2uLL);
            do
            {
              v25 = v20;
              v20 = vorrq_s8(v20, (int8x16_t)vshlq_u64(v23, (uint64x2_t)vsubq_s64(v22, vshlq_n_s64(v21, 3uLL))));
              v21 = vaddq_s64(v21, v24);
              v19 -= 2;
            }
            while (v19);
            v26 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v17), (int8x16_t)xmmword_100248F40), (uint64x2_t)vdupq_lane_s64(v18, 0)), v25, v20);
            v13 = vorr_s8(*(int8x8_t *)v26.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL));
          }
          v29 = v13;
        }
      }
      v27 = CFNumberCreate(a1, kCFNumberLongLongType, &v29);
      *a2 = v27;
      if (v27)
        return &v11[v30];
      sub_100032660(-3, CFSTR("com.apple.security.cfder.error"), 0, a3, v28, CFSTR("Number allocation failed"), *(_QWORD *)&v29);
    }
    else
    {
      sub_100032660(-4, CFSTR("com.apple.security.cfder.error"), 0, a3, v10, CFSTR("Number too large"), *(_QWORD *)&v29);
    }
  }
  else
  {
    sub_100032660(-1, CFSTR("com.apple.security.cfder.error"), 0, a3, v10, CFSTR("Unknown number encoding"), *(_QWORD *)&v29);
  }
  return 0;
}

unint64_t sub_100021A6C(const __CFAllocator *a1, CFDateRef *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  CFDateRef v11;
  uint64_t v12;
  CFAbsoluteTime at;
  int v15[2];

  *(_QWORD *)v15 = a5;
  v8 = ccder_decode_constructed_tl(24, v15, a4, a5);
  at = 0.0;
  v10 = sub_100021B14(&at, a3, v8, *(unint64_t *)v15, v9);
  if (v10)
  {
    v11 = CFDateCreate(a1, at);
    *a2 = v11;
    if (!v11)
    {
      sub_100032660(-3, CFSTR("com.apple.security.cfder.error"), 0, a3, v12, CFSTR("Failed to create date"));
      return 0;
    }
  }
  return v10;
}

unint64_t sub_100021B14(double *a1, CFTypeRef *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  int v19[2];

  *(_QWORD *)v19 = a3;
  v8 = sub_100022064((unsigned __int8 **)v19, a4, a2, a4, a5);
  v11 = sub_100022064((unsigned __int8 **)v19, a4, a2, v9, v10) + 10 * v8;
  v14 = sub_100022064((unsigned __int8 **)v19, a4, a2, v12, v13);
  v17 = sub_100022064((unsigned __int8 **)v19, a4, a2, v15, v16) + 10 * v14 + 100 * v11;
  return sub_100021BC8(a1, a2, v17, *(unsigned __int8 **)v19, a4);
}

unint64_t sub_100021BC8(double *a1, CFTypeRef *a2, unsigned int a3, unsigned __int8 *a4, unint64_t a5)
{
  unint64_t v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  unsigned __int8 *v34;
  unsigned __int8 *v35;
  double v36;
  int v37;
  unsigned __int8 *v38;
  const __CFString *v39;
  int v40;
  CFIndex v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  int v45;
  int v46;
  double v47;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  double v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  unsigned __int8 *v69;
  _QWORD v70[6];
  unsigned int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  uint64_t v76;
  int v77;
  double *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t *v82;
  uint64_t v83;
  char v84;
  _DWORD v85[3];

  v5 = a5;
  v69 = a4;
  v66 = sub_100022064(&v69, a5, a2, (uint64_t)a4, a5);
  v65 = sub_100022064(&v69, v5, a2, v7, v8);
  v64 = sub_100022064(&v69, v5, a2, v9, v10);
  v13 = sub_100022064(&v69, v5, a2, v11, v12);
  v16 = sub_100022064(&v69, v5, a2, v14, v15);
  v19 = sub_100022064(&v69, v5, a2, v17, v18);
  v22 = sub_100022064(&v69, v5, a2, v20, v21);
  v25 = sub_100022064(&v69, v5, a2, v23, v24);
  v28 = sub_100022064(&v69, v5, a2, v26, v27);
  v33 = sub_100022064(&v69, v5, a2, v29, v30);
  v34 = 0;
  v35 = v69;
  v36 = NAN;
  if (v69 && (unint64_t)v69 < v5)
  {
    v37 = *v69;
    if (v37 == 46)
    {
      v38 = v69 + 1;
      if ((unint64_t)(v69 + 1) < v5)
      {
        v37 = *v38;
        if ((v37 - 58) < 0xFFFFFFF6)
        {
          v39 = CFSTR("fraction without digits");
LABEL_14:
          v41 = -1;
LABEL_23:
          sub_100032660(v41, CFSTR("com.apple.security.cfder.error"), 0, a2, v32, v39);
          v34 = 0;
          goto LABEL_24;
        }
        v42 = 0;
        v43 = v5 - (_QWORD)v69 - 2;
        v44 = 1;
        while (v43)
        {
          v45 = v37;
          if (v44 < 0x1999999999999999)
          {
            v44 *= 10;
            v42 = (v37 - 48) + 10 * v42;
          }
          v46 = *++v38;
          v37 = v46;
          --v43;
          if ((v46 - 58) < 0xFFFFFFF6)
          {
            if (v45 == 48)
            {
              v39 = CFSTR("fraction ends in 0");
              goto LABEL_14;
            }
            v36 = (double)(unint64_t)v42 / (double)v44;
            v35 = v38;
            goto LABEL_8;
          }
        }
      }
      v39 = CFSTR("overflow");
      v41 = -8;
      goto LABEL_23;
    }
    v36 = 0.0;
LABEL_8:
    if ((unint64_t)v35 < v5)
    {
      v34 = v35 + 1;
      v69 = v35 + 1;
      switch(v37)
      {
        case 'Z':
          v47 = 0.0;
          goto LABEL_25;
        case '-':
          v40 = -60;
          break;
        case '+':
          v40 = 60;
          break;
        default:
          goto LABEL_24;
      }
      v63 = v40;
      v54 = sub_100022064(&v69, v5, a2, v31, v32);
      v62 = sub_100022064(&v69, v5, a2, v55, v56) + 10 * v54;
      v59 = sub_100022064(&v69, v5, a2, v57, v58);
      v47 = (double)(int)((sub_100022064(&v69, v5, a2, v60, v61) + 10 * v59 + 60 * v62) * v63);
      v34 = v69;
      if (!v69)
        return 0;
      goto LABEL_25;
    }
    v39 = CFSTR("Unexpected end of datetime");
    goto LABEL_14;
  }
LABEL_24:
  sub_100032660(-1, CFSTR("com.apple.security.cfder.error"), 0, a2, v32, CFSTR("Invalid datetime character"));
  v47 = NAN;
  if (!v34)
    return 0;
LABEL_25:
  if (v34 != (unsigned __int8 *)v5)
  {
    sub_100032660(-1, CFSTR("com.apple.security.cfder.error"), 0, a2, v32, CFSTR("trailing garbage at end of datetime"));
    return 0;
  }
  v49 = (v13 + 10 * v64);
  v50 = (v19 + 10 * v16);
  v51 = (v25 + 10 * v22);
  v85[0] = 0;
  if ((sub_1000227B4(a3, (v65 + 10 * v66), v49, v50, v51, (v33 + 10 * v28), v85, (__CFString **)a2) & 1) != 0)
  {
    v81 = 0;
    v82 = &v81;
    v83 = 0x2000000000;
    v84 = 0;
    v77 = 0;
    v78 = (double *)((char *)&v76 + 4);
    v79 = 0x2000000000;
    v80 = 0;
    v70[0] = _NSConcreteStackBlock;
    v70[1] = 0x40000000;
    v70[2] = sub_100008534;
    v70[3] = &unk_1002DB2D0;
    v70[4] = &v81;
    v70[5] = (char *)&v76 + 4;
    v71 = a3;
    v72 = v65 + 10 * v66;
    v73 = v49;
    v74 = v50;
    v75 = v51;
    v76 = (v33 + 10 * v28);
    sub_100022728((uint64_t)v70);
    if (*((_BYTE *)v82 + 24))
    {
      v53 = v78[3] - v47;
    }
    else
    {
      sub_100032660(-1, CFSTR("com.apple.security.cfder.error"), 0, a2, v52, CFSTR("Failed to encode date from components"));
      v53 = NAN;
    }
    _Block_object_dispose((char *)&v76 + 4, 8);
    _Block_object_dispose(&v81, 8);
    *a1 = v53;
    *a1 = v36 + v53;
  }
  else
  {
    v5 = 0;
    *a1 = NAN;
  }
  return v5;
}

uint64_t sub_100022064(unsigned __int8 **a1, unint64_t a2, CFTypeRef *a3, uint64_t a4, uint64_t a5)
{
  unsigned __int8 *v7;
  int v8;
  int v9;

  v7 = *a1;
  if (*a1)
  {
    if ((unint64_t)v7 >= a2)
    {
      sub_100032660(-1, CFSTR("com.apple.security.cfder.error"), 0, a3, a5, CFSTR("Unexpected end of datetime"));
      *a1 = 0;
    }
    else
    {
      v9 = *v7;
      v8 = v9;
      *a1 = v7 + 1;
      if (((v9 << 24) - 956301313) > 0xF6FFFFFE)
        return (v8 - 48);
    }
  }
  sub_100032660(-1, CFSTR("com.apple.security.cfder.error"), 0, a3, a5, CFSTR("Not a decimal digit"));
  *a1 = 0;
  return 0xFFFFFFFFLL;
}

unint64_t sub_100022108(CFTypeRef *a1, int a2, uint64_t a3, unint64_t a4, double a5)
{
  uint64_t v10;
  int v11;
  __CFString *v12;
  NSObject *v13;
  const char *v14;
  CFErrorRef v15;
  unint64_t v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  unint64_t v26;
  _BYTE *v27;
  char v28;
  uint64_t v29;
  CFTypeRef *v30;
  int v31;
  int v32;
  uint64_t v33;
  size_t v34;
  void *v35;
  int v36;
  NSObject *v37;
  CFTypeRef v38;
  uint64_t v39;
  unint64_t v40;
  unsigned int v41;
  unint64_t v42;
  int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  CFErrorRef err;
  CFErrorRef *p_err;
  uint64_t v51;
  char v52;
  int v53;
  int v54;
  _BYTE buf[24];
  void *v56;
  CFErrorRef *v57;
  double v58;
  char *v59;
  uint64_t *v60;
  char *v61;
  uint64_t *v62;
  char *v63;
  uint64_t *v64;

  v47 = 0;
  v48 = 0;
  v46 = 0;
  err = 0;
  p_err = &err;
  v51 = 0x2000000000;
  v52 = -86;
  *(_QWORD *)buf = _NSConcreteStackBlock;
  *(_QWORD *)&buf[8] = 0x40000000;
  *(_QWORD *)&buf[16] = sub_10000864C;
  v56 = &unk_1002DB2F8;
  v57 = &err;
  v58 = a5;
  v59 = (char *)&v48 + 4;
  v60 = &v48;
  v61 = (char *)&v47 + 4;
  v62 = &v47;
  v63 = (char *)&v46 + 4;
  v64 = &v46;
  sub_100022728((uint64_t)buf);
  if (*((_BYTE *)p_err + 24))
  {
    _Block_object_dispose(&err, 8);
  }
  else
  {
    sub_100032660(-1, CFSTR("com.apple.security.cfder.error"), 0, a1, v10, CFSTR("Failed to encode date."));
    v11 = *((unsigned __int8 *)p_err + 24);
    _Block_object_dispose(&err, 8);
    if (!v11)
    {
      v37 = sub_10000EF14("SecError");
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        if (a1)
          v38 = *a1;
        else
          v38 = 0;
        *(_DWORD *)buf = 138412290;
        *(_QWORD *)&buf[4] = v38;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "der: unable to encode date: %@", buf, 0xCu);
      }
      return 0;
    }
  }
  err = 0;
  if ((sub_1000227B4(HIDWORD(v48), v48, HIDWORD(v47), v47, HIDWORD(v46), v46, 0, (__CFString **)&err) & 1) == 0)
  {
    v12 = (__CFString *)CFErrorCopyDescription(err);
    sub_10003429C(v12, 0x53C00002u);
    if (v12)
      CFRelease(v12);
    v13 = sub_10000EF14("SecError");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      v14 = "continuing";
      if (a2)
        v14 = "setting default value";
      *(_DWORD *)buf = 138412546;
      *(_QWORD *)&buf[4] = err;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = v14;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "der: invalid date: %@; %s", buf, 0x16u);
    }
    v15 = err;
    if (err)
    {
      err = 0;
      CFRelease(v15);
    }
    if (a2)
    {
      v48 = 0x7D100000001;
      HIDWORD(v47) = 1;
      HIDWORD(v46) = 1;
    }
  }
  if (a3 + 1 <= a4)
  {
    *(_BYTE *)(a4 - 1) = 90;
    v16 = a4 - 1;
  }
  else
  {
    v16 = 0;
  }
  v18 = v48;
  v17 = HIDWORD(v48);
  v19 = HIDWORD(v47);
  v45 = v47;
  v20 = v46;
  v21 = HIDWORD(v46);
  v53 = -1431655766;
  v54 = -1431655766;
  *(_QWORD *)buf = 0xAAAAAAAAAAAAAAAALL;
  v22 = __dtoa(0, 0, &v54, &v53, buf);
  v23 = v22;
  v24 = v54;
  v25 = *(_QWORD *)buf;
  if (a5 < 0.0)
  {
    v26 = v22 + (v54 & ~(v54 >> 31));
    if (v26 < *(_QWORD *)buf)
    {
      v27 = (_BYTE *)(*(_QWORD *)buf - 1);
      for (*v27 = 106 - *(_BYTE *)(*(_QWORD *)buf - 1); (unint64_t)v27 > v26; *v27 = 105 - v28)
        v28 = *--v27;
    }
    v24 = v54;
    v25 = *(_QWORD *)buf;
  }
  v29 = v25 - v22;
  if (v25 - v23 > v24)
  {
    if ((v24 & 0x80000000) == 0)
    {
      v16 = ccder_encode_body(v29 - v24, v23 + v24, a3, v16);
LABEL_31:
      if (a3 + 1 <= v16)
        *(_BYTE *)--v16 = 46;
      else
        v16 = 0;
      goto LABEL_38;
    }
    v44 = v19;
    v30 = a1;
    v31 = v18;
    v32 = v17;
    v33 = ccder_encode_body(v29, v23, a3, v16);
    v34 = -(uint64_t)v54;
    v35 = (void *)ccder_encode_body_nocopy(v34, a3, v33);
    v16 = (unint64_t)v35;
    if (v35)
    {
      if (a5 >= 0.0)
        v36 = 48;
      else
        v36 = 57;
      memset(v35, v36, v34);
      v17 = v32;
      v18 = v31;
      a1 = v30;
      v19 = v44;
      goto LABEL_31;
    }
    v17 = v32;
    v18 = v31;
    a1 = v30;
    v19 = v44;
  }
LABEL_38:
  __freedtoa(v23);
  if (v16)
  {
    v40 = a3 + 2;
    if (a3 + 2 <= v16)
    {
      *(_BYTE *)(v16 - 2) = v20 / 10 + 48;
      *(_BYTE *)(v16 - 1) = v20 % 10 + 48;
      if (v40 <= v16 - 2)
      {
        *(_BYTE *)(v16 - 4) = v21 / 10 + 48;
        *(_BYTE *)(v16 - 3) = v21 % 10 + 48;
        if (v40 <= v16 - 4)
        {
          *(_BYTE *)(v16 - 6) = v45 / 10 + 48;
          *(_BYTE *)(v16 - 5) = v45 % 10 + 48;
          if (v40 <= v16 - 6)
          {
            *(_BYTE *)(v16 - 8) = v19 / 10 + 48;
            *(_BYTE *)(v16 - 7) = v19 % 10 + 48;
            if (v40 <= v16 - 8)
            {
              *(_BYTE *)(v16 - 10) = v18 / 10 + 48;
              *(_BYTE *)(v16 - 9) = v18 % 10 + 48;
              if (v40 <= v16 - 10)
              {
                v41 = (((103 * (v17 % 100)) >> 15) & 1) + ((103 * (v17 % 100)) >> 10);
                *(_BYTE *)(v16 - 12) = v41 + 48;
                *(_BYTE *)(v16 - 11) = v17 % 100 - 10 * v41 + 48;
                if (v40 <= v16 - 12)
                {
                  *(_BYTE *)(v16 - 14) = v17 / 1000 + 48;
                  v42 = v16 - 14;
                  *(_BYTE *)(v42 + 1) = v17 / 100 % 10 + 48;
                  return v42;
                }
              }
            }
          }
        }
      }
    }
  }
  sub_100032660(-7, CFSTR("com.apple.security.cfder.error"), 0, a1, v39, CFSTR("ccder failed to encode"));
  return 0;
}

void sub_100022728(uint64_t a1)
{
  _QWORD block[5];

  if (qword_100340D70 != -1)
    dispatch_once(&qword_100340D70, &stru_1002DB240);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_1000228C8;
  block[3] = &unk_1002DB120;
  block[4] = a1;
  dispatch_sync((dispatch_queue_t)qword_100340D78, block);
}

uint64_t sub_1000227B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, _DWORD *a7, __CFString **a8)
{
  _BOOL8 v8;
  unint64_t v9;
  unint64_t v10;

  if ((a1 & 3) != 0)
  {
    v8 = 0;
  }
  else
  {
    HIDWORD(v9) = -1030792151 * a1 + 85899344;
    LODWORD(v9) = HIDWORD(v9);
    if ((v9 >> 2) <= 0x28F5C28)
    {
      HIDWORD(v10) = -1030792151 * a1 + 85899344;
      LODWORD(v10) = HIDWORD(v10);
      v8 = (v10 >> 4) < 0xA3D70B;
    }
    else
    {
      v8 = 1;
    }
  }
  if (a7)
    *a7 = v8;
  if ((int)a6 <= 61
    && (int)a5 <= 59
    && (int)a4 <= 23
    && (a2 - 13) >= 0xFFFFFFF4
    && (a3 - 32) >= 0xFFFFFFE1
    && ((_DWORD)a2 != 2 || (v8 | 0x1C) >= a3)
    && ((_DWORD)a2 == 2 || dword_1002494C0[a2] - dword_1002494C0[(a2 - 1)] >= (int)a3))
  {
    return 1;
  }
  sub_100019F20(-1, a8, CFSTR("Invalid date: %i, %i, %i, %i, %i, %i, %i"), a1, a2, a3, a4, a5, a6, v8);
  return 0;
}

uint64_t sub_1000228C8(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  if (qword_100340D80 != -1)
    dispatch_once(&qword_100340D80, &stru_1002DB280);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v1 + 16))(v1, qword_100340D88);
}

void sub_10002291C(uint64_t a1)
{
  _QWORD *v2;
  const void *v3;
  const __CFString *v4;
  int v5;
  const __CFString *v6;
  _BOOL4 v7;
  const __CFURL *v8;
  const __CFURL *v9;
  const __CFString *v10;
  NSObject *v11;
  const char *CStringPtr;
  const char *v13;
  uint64_t Instance;
  NSObject *v15;
  CFStringRef Copy;
  NSObject *v17;
  const __CFString *v18;
  pthread_mutexattr_t *v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  void **aBlock;
  uint64_t v24;
  uint64_t (*v25)(uint64_t, uint8_t *, uint64_t, int, _BYTE *, CFTypeRef *);
  void *v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD v32[5];
  _QWORD v33[5];
  pthread_mutexattr_t v34;
  _BYTE buf[24];
  void *v36;
  uint64_t *v37;

  if (!qword_100341310)
  {
    if (qword_100340D90 != -1)
      dispatch_once(&qword_100340D90, &stru_1002DB338);
    v2 = *(_QWORD **)(a1 + 32);
    v3 = (const void *)qword_100341310;
    qword_100341310 = 0;
    if (os_variant_is_recovery("securityd"))
    {
      v4 = CFSTR("keychain-recovery-2.db");
      v5 = 1;
    }
    else
    {
      if (qword_100341370 != -1)
        dispatch_once(&qword_100341370, &stru_1002E8DB0);
      if (byte_100341368)
        v6 = CFSTR("keychain-2.db");
      else
        v6 = CFSTR("keychain-2-debug.db");
      if (qword_100340E20 != -1)
        dispatch_once(&qword_100340E20, &stru_1002DB938);
      v7 = byte_100340E18 == 0;
      syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", byte_100340E18);
      v5 = v7;
      v4 = v6;
    }
    v8 = sub_1000340F0(v5, (uint64_t)v4);
    v9 = v8;
    if (v8)
    {
      v10 = CFURLCopyFileSystemPath(v8, kCFURLPOSIXPathStyle);
      CFRelease(v9);
    }
    else
    {
      v10 = 0;
    }
    v11 = sub_10000EF14("__SecKeychainCopyPath");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      if (v10)
      {
        CStringPtr = CFStringGetCStringPtr(v10, 0x8000100u);
        v13 = "<unknown>";
        if (CStringPtr)
          v13 = CStringPtr;
      }
      else
      {
        v13 = "<null>";
      }
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v13;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "path: %s", buf, 0xCu);
    }
    if (v10)
    {
      v28 = 0;
      v29 = &v28;
      v30 = 0x2000000000;
      v31 = 0;
      aBlock = _NSConcreteStackBlock;
      v24 = 0x40000000;
      v25 = sub_100134708;
      v26 = &unk_1002E7B88;
      v27 = &v28;
      *(_QWORD *)buf = _NSConcreteStackBlock;
      *(_QWORD *)&buf[8] = 0x40000000;
      *(_QWORD *)&buf[16] = sub_10003082C;
      v36 = &unk_1002DB3B8;
      v37 = &qword_100340DA0;
      if (qword_100340D98 != -1)
        dispatch_once(&qword_100340D98, buf);
      Instance = _CFRuntimeCreateInstance(kCFAllocatorDefault, qword_100340DA0, 160, 0);
      if (Instance)
      {
        if (getenv("__OSINSTALL_ENVIRONMENT"))
        {
          v15 = sub_10000EF14("#SecDB");
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)buf = 0;
            _os_log_debug_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "SecDB: running from installer", buf, 2u);
          }
          Copy = CFSTR("file::memory:?cache=shared");
        }
        else
        {
          Copy = CFStringCreateCopy(kCFAllocatorDefault, v10);
        }
        *(_QWORD *)(Instance + 16) = Copy;
        v33[0] = _NSConcreteStackBlock;
        v33[1] = 0x40000000;
        v33[2] = sub_100030A10;
        v33[3] = &unk_1002DB3D8;
        v33[4] = Instance;
        *(_QWORD *)buf = _NSConcreteStackBlock;
        *(_QWORD *)&buf[8] = 0x40000000;
        *(_QWORD *)&buf[16] = sub_1000104A0;
        v36 = &unk_1002DB170;
        v37 = v33;
        sub_1000137F8(v10, (uint64_t)buf);
        v18 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@-commit"), v10, aBlock, v24, v25, v26, v27, v28);
        v32[0] = _NSConcreteStackBlock;
        v32[1] = 0x40000000;
        v32[2] = sub_100030A40;
        v32[3] = &unk_1002DB3F8;
        v32[4] = Instance;
        *(_QWORD *)buf = _NSConcreteStackBlock;
        *(_QWORD *)&buf[8] = 0x40000000;
        *(_QWORD *)&buf[16] = sub_1000104A0;
        v36 = &unk_1002DB170;
        v37 = v32;
        sub_1000137F8(v18, (uint64_t)buf);
        if (v18)
          CFRelease(v18);
        *(_QWORD *)(Instance + 40) = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        *(_QWORD *)(Instance + 48) = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        v34.__sig = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)v34.__opaque = 0xAAAAAAAAAAAAAAAALL;
        if (pthread_mutexattr_init(&v34) || (v19 = &v34, pthread_mutexattr_setpolicy_np(&v34, 1)))
        {
          v20 = sub_10000EF14("SecCritical");
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "SecDb: SecDbCreate failed to create attributes for the write mutex; fairness properties are no longer present",
              buf,
              2u);
          }
          v19 = 0;
        }
        if (pthread_mutex_init((pthread_mutex_t *)(Instance + 56), v19))
        {
          v21 = sub_10000EF14("SecCritical");
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "SecDb: SecDbCreate failed to init the write mutex, this will end badly", buf, 2u);
          }
        }
        pthread_mutexattr_destroy(&v34);
        *(_QWORD *)(Instance + 120) = dispatch_semaphore_create(5);
        *(_BYTE *)(Instance + 128) = 0;
        *(_QWORD *)(Instance + 136) = _Block_copy(&aBlock);
        *(_BYTE *)(Instance + 144) = 0;
        *(_DWORD *)(Instance + 148) = 0;
        *(_QWORD *)(Instance + 152) = 0;
        *(_WORD *)(Instance + 160) = 384;
        *(_DWORD *)(Instance + 162) = 16843009;
        *(_BYTE *)(Instance + 166) = 6;
        *(_QWORD *)(Instance + 168) = 0;
        *(_QWORD *)(Instance + 168) = _Block_copy(&stru_1002E7BC8);
      }
      if (v2)
        *v2 = v29[3];
      _Block_object_dispose(&v28, 8);
      qword_100341310 = Instance;
      CFRelease(v10);
    }
    else
    {
      v17 = sub_10000EF14("SecError");
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "no keychain path available", buf, 2u);
      }
    }
    if (v3)
    {
      v22 = sub_10000EF14("SecError");
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412546;
        *(_QWORD *)&buf[4] = v3;
        *(_WORD *)&buf[12] = 2112;
        *(_QWORD *)&buf[14] = qword_100341310;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "replaced %@ with %@", buf, 0x16u);
      }
      CFRelease(v3);
    }
  }
}

void sub_100022F64(uint64_t a1)
{
  void *v2;
  id v3;
  void *v4;

  v2 = (void *)qword_1003414D0;
  if (!qword_1003414D0)
  {
    v3 = objc_msgSend(objc_alloc(*(Class *)(a1 + 40)), "_init");
    v4 = (void *)qword_1003414D0;
    qword_1003414D0 = (uint64_t)v3;

    v2 = (void *)qword_1003414D0;
  }
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), v2);
}

void sub_100022FD8(id a1)
{
  if (!dword_100340C98)
    dword_100340C98 = sub_10002538C("IOService:/IOResources/AppleKeyStore", "AppleKeyStore");
}

uint64_t sub_100023018(_QWORD *a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))(a2 + 16))(a2, a1[4], a1[5], *(_QWORD *)(a1[4] + 32), a1[6]);
}

uint64_t sub_100023034(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_100023040(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  _BYTE *v4;

  v1 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 16);
  if (*(_BYTE *)(v1 + 144))
  {
    *(_BYTE *)(v1 + 144) = 0;
    if (((*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24)
                                                       + 16)
                                           + 136)
                               + 16))() & 1) == 0)
    {
      v3 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v4 = *(_BYTE **)(v3 + 24);
      if (!v4[40]
        || (sub_1000311E4((uint64_t)v4, 0, *(CFTypeRef **)(a1 + 48)) & 1) == 0
        && (v3 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), (v4 = *(_BYTE **)(v3 + 24)) != 0))
      {
        *(_QWORD *)(v3 + 24) = 0;
        CFRelease(v4);
      }
    }
  }
}

BOOL sub_1000230E8(_QWORD *a1, _BYTE *a2)
{
  const void *v4;
  const __CFArray *v5;
  uint64_t v6;
  __CFString **v7;
  uint64_t v8;
  _BOOL8 result;
  uint64_t v10;
  BOOL v11;
  _QWORD v12[9];

  v4 = (const void *)kSecAttrTombstone;
  if (!CFDictionaryContainsKey(*(CFDictionaryRef *)(a1[5] + 8), kSecAttrTombstone))
    sub_100012178(v4, kCFBooleanFalse, a1[5]);
  v5 = (const __CFArray *)a1[6];
  v6 = a1[7];
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  v12[2] = sub_1000056FC;
  v12[3] = &unk_1002DF770;
  v7 = (__CFString **)a1[8];
  v12[6] = a1[9];
  v12[7] = v6;
  v8 = a1[5];
  v12[4] = a1[4];
  v12[5] = v8;
  v12[8] = v7;
  result = sub_1000043D4(v8, v5, v6, v7, (uint64_t)v12);
  v10 = *(_QWORD *)(a1[4] + 8);
  if (*(_BYTE *)(v10 + 24))
    v11 = result;
  else
    v11 = 0;
  *(_BYTE *)(v10 + 24) = v11;
  if (!*(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24))
    *a2 = 0;
  return result;
}

BOOL sub_1000231C8(uint64_t a1, uint64_t a2)
{
  CFTypeRef *v2;
  _QWORD v4[5];
  __int128 v5;
  uint64_t v6;
  CFTypeRef *v7;

  v2 = *(CFTypeRef **)(a1 + 32);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_100004CAC;
  v4[3] = &unk_1002E7F00;
  v4[4] = a2;
  v5 = *(_OWORD *)(a1 + 40);
  v6 = *(_QWORD *)(a1 + 56);
  v7 = v2;
  return sub_10001AC0C(a2, 2, v2, (uint64_t)v4);
}

void sub_100023234(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const void *v6;
  NSObject *v7;
  const char **v8;
  const char *v9;
  const void **v10;
  const void *v11;
  int v12;
  const char *v13;

  v2 = sub_10001E594(kCFAllocatorDefault, **(_QWORD ***)(a1 + 48), *(sqlite3_stmt **)(a1 + 56), *(_DWORD *)(*(_QWORD *)(a1 + 48) + 120), *(_QWORD *)(a1 + 32));
  if (v2)
  {
    v3 = v2;
    v4 = *(_QWORD *)(a1 + 48);
    v5 = *(_QWORD *)(v4 + 144);
    *(_QWORD *)(v4 + 144) = 0;
    v6 = *(const void **)(v2 + 56);
    if (v6)
      CFRelease(v6);
    *(_QWORD *)(v3 + 56) = v5;
    if (sub_100014EE8(*(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 80), *(CFDictionaryRef *)(v3 + 48)))(*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
    CFRelease((CFTypeRef)v3);
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = *(const char ***)(a1 + 64);
      if (v8)
        v9 = *v8;
      else
        v9 = "no error";
      v12 = 138412290;
      v13 = v9;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "failed to create item from stmt: %@", (uint8_t *)&v12, 0xCu);
    }
    v10 = *(const void ***)(a1 + 64);
    if (v10)
    {
      v11 = *v10;
      if (*v10)
      {
        *v10 = 0;
        CFRelease(v11);
      }
    }
  }
}

uint64_t sub_1000233AC(uint64_t result, sqlite3_stmt *a2)
{
  uint64_t v3;
  uint64_t v4;
  char v5;
  uint64_t v6;
  char v7;
  uint64_t v8;
  CFTypeRef *v9;
  uint64_t v10;
  _QWORD v11[4];
  __int128 v12;
  uint64_t v13;
  sqlite3_stmt *v14;
  CFTypeRef *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;

  v3 = result;
  v18 = 1;
  if (**(__CFString ****)(result + 56) == &off_1002E3A00)
  {
    result = sub_100013C1C(a2, *(CFArrayRef *)(result + 64), &v18, *(CFTypeRef **)(result + 72));
    v4 = *(_QWORD *)(*(_QWORD *)(v3 + 48) + 8);
    if (*(_BYTE *)(v4 + 24))
      v5 = result;
    else
      v5 = 0;
    *(_BYTE *)(v4 + 24) = v5;
  }
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v3 + 48) + 8) + 24))
  {
    result = sub_1000132C4(a2, *(_QWORD *)(v3 + 56), *(const __CFArray **)(v3 + 64), &v18, *(CFTypeRef **)(v3 + 72));
    v6 = *(_QWORD *)(*(_QWORD *)(v3 + 48) + 8);
    if (*(_BYTE *)(v6 + 24))
      v7 = result;
    else
      v7 = 0;
    *(_BYTE *)(v6 + 24) = v7;
    if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v3 + 48) + 8) + 24))
    {
      v9 = *(CFTypeRef **)(v3 + 72);
      v8 = *(_QWORD *)(v3 + 80);
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 0x40000000;
      v11[2] = sub_100023234;
      v11[3] = &unk_1002DF720;
      v10 = *(_QWORD *)(v3 + 64);
      v13 = *(_QWORD *)(v3 + 56);
      v14 = a2;
      v15 = v9;
      v16 = v8;
      v17 = v10;
      v12 = *(_OWORD *)(v3 + 32);
      return sub_100019C40(v8, a2, v9, (uint64_t)v11);
    }
  }
  return result;
}

CFDateRef sub_1000234BC(int a1, uint64_t a2, __CFString **a3)
{
  int v3;
  double Current;
  const __CFAllocator *v5;

  v3 = *(_DWORD *)(a2 + 8);
  if ((v3 - 5) < 2)
  {
    Current = CFAbsoluteTimeGetCurrent();
    v5 = kCFAllocatorDefault;
    return CFDateCreate(v5, Current);
  }
  if (v3 == 4)
  {
    v5 = kCFAllocatorDefault;
    Current = 0.0;
    return CFDateCreate(v5, Current);
  }
  sub_100019F20(-26276, a3, CFSTR("attr %@ has no default value"), *(_QWORD *)a2);
  return 0;
}

_QWORD *sub_100023550(_QWORD **a1, const void *a2, __CFString **a3)
{
  _QWORD *result;

  result = (_QWORD *)sub_10001E6A8(a1[2], 6, a3);
  if (result)
    return (_QWORD *)sub_100004988(a1, a2, result, a3);
  return result;
}

CFDataRef sub_1000235AC(uint64_t a1, int a2, __CFString **a3)
{
  char v5;
  __CFDictionary *v6;
  const void *v7;
  __CFDictionary *v9;
  const __CFAllocator *v10;
  __CFDictionary *Mutable;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  const void *v15;
  const void *v16;
  uint64_t v17;
  const void *v18;
  const void *UUIDBasedPersistentRef;

  if (a2 == 8)
  {
    v7 = sub_1000045A0((_QWORD **)a1, a3);
    return (CFDataRef)_SecItemCreateUUIDBasedPersistentRef(**(_QWORD **)(a1 + 16), v7, *(_QWORD *)(a1 + 48));
  }
  v5 = a2;
  if (a2 == 1)
  {
    v9 = (__CFDictionary *)sub_10000C1D0((_QWORD *)a1, kSecValueData);
    if (!v9)
      return CFDataCreate(kCFAllocatorDefault, 0, 0);
    v6 = v9;
    CFRetain(v9);
  }
  else if (a2)
  {
    v10 = CFGetAllocator((CFTypeRef)a1);
    Mutable = CFDictionaryCreateMutable(v10, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    v6 = Mutable;
    if ((v5 & 4) != 0)
      CFDictionarySetValue(Mutable, kSecClass, **(const void ***)(a1 + 16));
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_QWORD *)(v12 + 16);
    if (v13)
    {
      v14 = (uint64_t *)(v12 + 24);
      do
      {
        if ((*(_QWORD *)(v13 + 16) & ((16 * ((v5 & 6) != 0)) | (32 * ((v5 & 5) != 0)))) != 0)
        {
          v15 = sub_100019204((const void *)a1, v13, a3);
          if (!v15)
          {
            if (v6)
            {
              CFRelease(v6);
              v6 = 0;
            }
            break;
          }
          v16 = v15;
          if (!CFEqual(kCFNull, v15))
            CFDictionarySetValue(v6, *(const void **)v13, v16);
        }
        v17 = *v14++;
        v13 = v17;
      }
      while (v17);
    }
    CFDictionaryRemoveValue(v6, kSecAttrUUID);
    if ((v5 & 8) != 0)
    {
      v18 = sub_1000045A0((_QWORD **)a1, a3);
      UUIDBasedPersistentRef = (const void *)_SecItemCreateUUIDBasedPersistentRef(**(_QWORD **)(a1 + 16), v18, *(_QWORD *)(a1 + 48));
      CFDictionarySetValue(v6, kSecValuePersistentRef, UUIDBasedPersistentRef);
      if (UUIDBasedPersistentRef)
        CFRelease(UUIDBasedPersistentRef);
    }
  }
  else
  {
    return kCFNull;
  }
  return v6;
}

BOOL sub_1000237E0(unsigned int a1, __SecTask *a2, const __CFString *a3, __CFString **a4)
{
  _BOOL8 v8;
  const __CFString *v9;

  v8 = sub_10000FA3C(a2, a3);
  if (!v8)
  {
    if (a1 > 0x87)
      v9 = CFSTR("Unknown xpc operation");
    else
      v9 = off_1002E9940[a1];
    sub_100019F20(-34018, a4, CFSTR("%@: %@ lacks entitlement %@"), v9, a2, a3);
  }
  return v8;
}

uint64_t sub_100023874(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(_QWORD, void *, unint64_t *, unint64_t *, uint64_t), _QWORD *a5, unint64_t a6, _QWORD *a7, _QWORD *a8)
{
  _QWORD *v14;
  size_t v15;
  uint64_t v16;
  size_t v17;
  char *v18;
  uint64_t v19;
  unsigned int v20;
  BOOL v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  unint64_t *v29;
  int v30;
  unsigned int v31;
  BOOL v32;
  _QWORD *v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t *v41;
  _QWORD *v42;
  unint64_t *v43;
  uint64_t v44;
  unint64_t v45;
  _QWORD *v46;
  uint64_t v47;
  _OWORD __s[4];

  v46 = a5;
  v44 = a1;
  memset(__s, 0, sizeof(__s));
  v14 = (_QWORD *)ccaes_cbc_decrypt_mode();
  __chkstk_darwin(v14);
  v47 = (uint64_t)&v38 - v15;
  bzero((char *)&v38 - v15, v15);
  __chkstk_darwin(v16);
  v18 = (char *)&v38 - v17;
  bzero((char *)&v38 - v17, v17);
  v19 = 0xFFFFFFFFLL;
  if (HIDWORD(a6))
    goto LABEL_33;
  v40 = a3;
  v20 = a6 >> 3;
  if ((a6 >> 3) - 6 < 0xFFFFFFFC)
    goto LABEL_33;
  v41 = &v38;
  v42 = a8;
  v39 = a7;
  v45 = a6;
  if (!a4)
  {
    v21 = (a2 & 0xFFFFFFFFFFFFFFF7) == 0x10 || a2 == 32;
    if (!v21 || !a8 || *a8 < a6 - 8)
    {
      memset_s(__s, 0x40uLL, 0, 0x40uLL);
      goto LABEL_34;
    }
    cccbc_init(v14, v47, a2, v44);
    goto LABEL_15;
  }
  if (a8 && *v42 >= v45 - 8)
  {
LABEL_15:
    *(_QWORD *)&__s[0] = *v46;
    v22 = v20 - 1;
    if (v20 != 1)
    {
      v23 = (_QWORD *)__s + 1;
      v24 = v46 + 1;
      v25 = v20 - 1;
      do
      {
        v26 = *v24++;
        *v23 = v26;
        v23 += 2;
        --v25;
      }
      while (v25);
    }
    v27 = 6 * v20 - 6;
    LODWORD(v44) = 1 - v20;
    v28 = 5;
    v43 = (unint64_t *)&__s[v20 - 2];
    do
    {
      LODWORD(v46) = v28;
      if (v45 >= 0x10)
      {
        v29 = v43;
        v30 = v22;
        v31 = v27;
        do
        {
          *v29 = *(_QWORD *)&__s[v30 % v22] ^ bswap64(v31);
          if (a4)
          {
            if ((a4(0, &unk_1003416E0, v29, v29, 16) & 1) == 0)
              goto LABEL_6;
          }
          else
          {
            cccbc_clear_iv(v18, v14[1]);
            sub_100026D0C((uint64_t)v14, v47, (uint64_t)v18, 0x10uLL);
          }
          --v31;
          v29 -= 2;
          v32 = __OFSUB__(v30--, 1);
        }
        while (!((v30 < 0) ^ v32 | (v30 == 0)));
      }
      v28 = (_DWORD)v46 - 1;
      v27 += v44;
    }
    while ((_DWORD)v46);
    if (*(_QWORD *)&__s[0] == v40)
    {
      v33 = v39;
      if ((_DWORD)v22)
      {
        v34 = (uint64_t *)__s + 1;
        v35 = v22;
        do
        {
          v36 = *v34;
          v34 += 2;
          *v33++ = v36;
          --v35;
        }
        while (v35);
      }
      v19 = 0;
      *v42 = (8 * v22);
    }
    else
    {
      v19 = 0xFFFFFFFFLL;
    }
LABEL_33:
    memset_s(__s, 0x40uLL, 0, 0x40uLL);
    if (a4)
      return v19;
LABEL_34:
    cc_clear(*v14, v47);
    return v19;
  }
LABEL_6:
  memset_s(__s, 0x40uLL, 0, 0x40uLL);
  return 0xFFFFFFFFLL;
}

uint64_t sub_100023BD0(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t (*a4)(_QWORD, void *, unint64_t *, unint64_t *, uint64_t), _QWORD *a5, unsigned int a6, _QWORD *a7, _DWORD *a8)
{
  uint64_t v9;
  uint64_t v11;

  v11 = *a8;
  v9 = sub_100023874(a1, a2, a3, a4, a5, a6, a7, &v11);
  sub_100026C7C(HIDWORD(v11) == 0, 261, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/aeskeywrap.c");
  *a8 = v11;
  return v9;
}

uint64_t sub_100023C38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, _QWORD *a7, _QWORD *a8)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  size_t v19;
  void *v20;

  v20 = 0;
  if (a1
    && (v15 = a1 + a2, sub_100026E64(a1, a1 + a2) == a2)
    && sub_10002771C(&v20, (uint64_t)off_10033EB30, a1, v15)
    || a3 && sub_100026E64(a3, a3 + a4) == a4 && sub_10002771C(&v20, (uint64_t)off_10033EB18, a3, a3 + a4)
    || a5 && sub_100027898(&v20, (uint64_t)off_10033EB28, a5, a6)
    || (v18 = 0, v19 = 0, sub_100027558(&v20, &v18, &v19)))
  {
    v16 = 0xFFFFFFFFLL;
  }
  else
  {
    v16 = 0;
    *a7 = v18;
    *a8 = v19;
  }
  sub_10002713C(&v20);
  return v16;
}

void *sub_100023D74(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  void *v5;

  v4 = calloc(8uLL, 1uLL);
  v5 = v4;
  if (v4)
  {
    *v4 = 0;
    if (a1)
    {
      if (sub_100027450((uint64_t)v4, a1, a1 + a2))
      {
        memset_s(v5, 8uLL, 0, 8uLL);
        free(v5);
        return 0;
      }
    }
  }
  return v5;
}

void *sub_100023DF4(int a1, int a2)
{
  void **v2;
  void *result;
  void **v4;
  void *v5;
  BOOL v6;

  switch(a1)
  {
    case 1:
      v2 = (void **)&off_10033EB30;
      goto LABEL_28;
    case 2:
      v2 = (void **)&off_10033EB18;
      goto LABEL_28;
    case 3:
      v2 = (void **)&off_10033EB28;
      goto LABEL_28;
    case 4:
      v2 = (void **)&off_10033EB38;
      goto LABEL_28;
    case 5:
      v2 = (void **)&off_10033EB00;
      goto LABEL_28;
    case 6:
      v2 = (void **)&off_10033EC48;
      goto LABEL_28;
    case 7:
      v2 = (void **)&off_10033EC40;
      goto LABEL_28;
    case 8:
      v4 = (void **)&off_10033EC58;
      goto LABEL_30;
    case 9:
      v4 = (void **)&off_10033EC60;
      goto LABEL_30;
    case 10:
      v2 = (void **)&off_10033EC70;
      goto LABEL_28;
    case 11:
      v2 = (void **)&off_10033EC78;
      goto LABEL_28;
    case 12:
      v2 = (void **)&off_10033EC80;
      goto LABEL_28;
    case 13:
      v2 = (void **)&off_10033EC88;
      goto LABEL_28;
    case 14:
      v2 = (void **)&off_10033EC90;
      goto LABEL_28;
    case 15:
      v2 = (void **)&off_10033EC50;
      goto LABEL_28;
    case 16:
      v4 = (void **)&off_10033EB98;
      goto LABEL_30;
    case 17:
      v2 = (void **)&off_10033EBA8;
      goto LABEL_28;
    case 18:
      v4 = (void **)&off_10033EBB0;
      goto LABEL_30;
    case 19:
      v5 = off_10033EBC0;
      v6 = a2 == 3;
      goto LABEL_31;
    case 20:
      v4 = (void **)&off_10033EBC8;
      goto LABEL_30;
    case 21:
      v2 = (void **)&off_10033EBD0;
      goto LABEL_28;
    case 22:
      v4 = (void **)&off_10033EBB8;
      goto LABEL_30;
    case 23:
      v4 = (void **)&off_10033EBA0;
      goto LABEL_30;
    case 24:
      v2 = (void **)&off_10033EC98;
      goto LABEL_28;
    case 25:
      v2 = (void **)&off_10033ECA8;
LABEL_28:
      v5 = *v2;
      v6 = a2 == 2;
      goto LABEL_31;
    case 26:
      v4 = (void **)&off_10033EC68;
LABEL_30:
      v5 = *v4;
      v6 = a2 == 1;
LABEL_31:
      if (v6)
        result = v5;
      else
        result = 0;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

uint64_t sub_100023F74(_QWORD *a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unsigned __int8 *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v14[2];
  uint64_t v15;

  v8 = 3758097090;
  v9 = (unsigned __int8 *)sub_100023DF4(a2, 2);
  if (!v9)
    return v8;
  v10 = (uint64_t)v9;
  if (sub_1000271B4(a1, v9))
    return v8;
  if (!a3)
    return 0;
  v11 = 0x2000000000000010;
  if (a2 != 1)
  {
    if (a2 == 2)
    {
      v11 = 0x2000000000000011;
      goto LABEL_7;
    }
    if (sub_100027898(a1, v10, a3, a4))
      return v8;
    return 0;
  }
LABEL_7:
  v12 = a3 + a4;
  v14[0] = a3;
  v14[1] = v12;
  v15 = 0;
  if (ccder_blob_decode_tag(v14, &v15) && v15 == v11 && !sub_10002771C(a1, v10, a3, v12))
    return 0;
  return v8;
}

uint64_t sub_100024070(void ***a1)
{
  uint64_t result;
  void **v3;

  result = 3758097090;
  if (a1)
  {
    v3 = *a1;
    if (*a1)
    {
      *a1 = 0;
      sub_10002713C(v3);
      memset_s(v3, 8uLL, 0, 8uLL);
      free(v3);
      return 0;
    }
  }
  return result;
}

uint64_t sub_1000240CC(int a1, int a2, unsigned int a3, uint64_t a4, uint64_t a5, void ***a6)
{
  uint64_t v12;
  void *v13;
  void **v14;
  void *v15;
  void **v16;
  uint64_t v17;
  char *v18;
  size_t v19;
  void *v21;
  uint64_t v22;
  void *v23;
  void *v24;
  size_t v25;
  void *v26;
  size_t v27;

  v12 = 3758097090;
  v13 = off_10033EB78;
  v14 = (void **)calloc(8uLL, 1uLL);
  *v14 = 0;
  sub_100027888(v14, (uint64_t)off_10033EAE8, (uint64_t)v13);
  v26 = 0;
  v27 = 0;
  v24 = 0;
  v25 = 0;
  if (!a6)
    goto LABEL_14;
  v15 = calloc(0x50uLL, 1uLL);
  v23 = v15;
  if (!v15)
  {
    v12 = 3758604298;
    goto LABEL_14;
  }
  v16 = (void **)v15;
  memset_s(v15, 0x50uLL, 0, 0x50uLL);
  if (a4 && sub_100027450((uint64_t)v14, a4, a4 + a5)
    || sub_100027A04(v14, (uint64_t)off_10033EAF8, a2)
    || sub_100027A04(v14, (uint64_t)off_10033EB48, a3)
    || sub_100027558(v14, &v26, &v27))
  {
LABEL_17:
    sub_100024478((uint64_t *)&v23);
    goto LABEL_14;
  }
  v17 = sub_1000249D4(a1, v26, v27, &v24, &v25);
  if ((_DWORD)v17)
  {
    v12 = v17;
    goto LABEL_17;
  }
  v18 = (char *)v24;
  v19 = v25;
  *v16 = v24;
  v16[1] = (void *)v19;
  *((_DWORD *)v16 + 10) = a1;
  v16[2] = &v18[v19];
  v21 = 0;
  v22 = 0;
  if (sub_100026F9C((uint64_t)off_10033EB58, &v21, &v22, (uint64_t)v18, (uint64_t)&v18[v19]))
    v16[4] = v21;
  if (sub_100026F9C((uint64_t)off_10033EB18, &v21, &v22, (uint64_t)*v16, (uint64_t)v16[2]))
    v16[3] = v21;
  v12 = 0;
  *a6 = v16;
  v24 = 0;
  v25 = 0;
LABEL_14:
  sub_10002713C(v14);
  memset_s(v14, 8uLL, 0, 8uLL);
  free(v14);
  memset_s(v26, v27, 0, v27);
  free(v26);
  memset_s(v24, v25, 0, v25);
  free(v24);
  return v12;
}

uint64_t sub_1000242F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6, size_t *a7)
{
  uint64_t v14;
  void *v15;
  void **v16;
  void *__s;
  rsize_t __n;

  v14 = 3758097090;
  v15 = off_10033EB60;
  v16 = (void **)calloc(8uLL, 1uLL);
  *v16 = 0;
  sub_100027888(v16, (uint64_t)off_10033EAE8, (uint64_t)v15);
  __s = 0;
  __n = 0;
  if (!sub_100024CE0(a1, v16, a2, a3))
  {
    sub_1000271B4(v16, (unsigned __int8 *)off_10033EB00);
    sub_1000271B4(v16, (unsigned __int8 *)off_10033EB58);
    if (!sub_100027898(v16, (uint64_t)off_10033EB00, a4, a5)
      && !sub_10002771C(v16, (uint64_t)off_10033EB58, *(_QWORD *)a1, *(_QWORD *)(a1 + 16))
      && !sub_100027558(v16, &__s, &__n))
    {
      v14 = sub_1000249D4(*(_DWORD *)(a1 + 40), __s, __n, a6, a7);
    }
  }
  sub_10002713C(v16);
  memset_s(v16, 8uLL, 0, 8uLL);
  free(v16);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v14;
}

uint64_t sub_100024478(uint64_t *a1)
{
  uint64_t v1;
  void *v2;
  void *v3;

  v1 = *a1;
  if (!*a1)
    return 3758097090;
  *a1 = 0;
  if (*(_QWORD *)v1)
  {
    memset_s(*(void **)v1, *(_QWORD *)(v1 + 8), 0, *(_QWORD *)(v1 + 8));
    free(*(void **)v1);
  }
  v2 = *(void **)(v1 + 48);
  if (v2)
  {
    memset_s(v2, *(_QWORD *)(v1 + 56), 0, *(_QWORD *)(v1 + 56));
    free(*(void **)(v1 + 48));
  }
  v3 = *(void **)(v1 + 64);
  if (v3)
  {
    memset_s(v3, *(_QWORD *)(v1 + 72), 0, *(_QWORD *)(v1 + 72));
    free(*(void **)(v1 + 64));
  }
  memset_s((void *)v1, 0x50uLL, 0, 0x50uLL);
  free((void *)v1);
  return 0;
}

uint64_t sub_100024528(int a1, const void *a2, size_t a3, uint64_t *a4)
{
  uint64_t v4;
  void *v9;
  uint64_t v10;
  void *v12;

  v4 = 3758097090;
  if (a2)
  {
    if (a3)
    {
      if (sub_100026E64((uint64_t)a2, (uint64_t)a2 + a3) == a3)
      {
        v4 = 3758604298;
        v9 = calloc(0x50uLL, 1uLL);
        v12 = v9;
        if (v9)
        {
          v10 = (uint64_t)v9;
          memset_s(v9, 0x50uLL, 0, 0x50uLL);
          *(_DWORD *)(v10 + 40) = a1;
          if (sub_100024BAC(v10, a2, a3))
          {
            sub_100024478((uint64_t *)&v12);
          }
          else
          {
            v4 = 0;
            *a4 = v10;
          }
        }
      }
    }
  }
  return v4;
}

uint64_t sub_1000245EC(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, size_t a5, _QWORD *a6, size_t *a7)
{
  uint64_t v14;
  void *v15;
  void **v16;
  uint64_t v17;
  int v18;
  void *v20;
  size_t v21;
  void *__s;
  rsize_t __n;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;

  v14 = 3758097090;
  v15 = off_10033EB68;
  v16 = (void **)calloc(8uLL, 1uLL);
  *v16 = 0;
  sub_100027888(v16, (uint64_t)off_10033EAE8, (uint64_t)v15);
  __s = 0;
  __n = 0;
  v20 = a4;
  v21 = a5;
  if (a4)
  {
    if (a5)
    {
      v17 = (uint64_t)a4 + a5;
      if (sub_100026E64((uint64_t)a4, (uint64_t)a4 + a5) == a5)
      {
        v18 = sub_100024D68(a1);
        if (!v18)
        {
          v27 = 0;
          v28 = 0;
          v25 = 0;
          v26 = 0;
          v24 = 0;
          if (!sub_100026F9C((uint64_t)off_10033EB20, &v24, &v25, (uint64_t)a4, v17)
            || !sub_100026F9C((uint64_t)off_10033EB10, &v26, &v27, (uint64_t)a4, v17)
            || sub_10002771C(&v28, (uint64_t)off_10033EB00, v26, v17)
            || sub_10002771C(&v28, (uint64_t)off_10033EB20, v24, v17)
            || sub_100027558(&v28, &v20, &v21))
          {
            sub_10002713C(&v28);
            goto LABEL_19;
          }
          sub_10002713C(&v28);
        }
        if (!sub_100024CE0(a1, v16, a2, a3))
        {
          sub_1000271B4(v16, (unsigned __int8 *)off_10033EB00);
          sub_1000271B4(v16, (unsigned __int8 *)off_10033EB58);
          if (!sub_10002771C(v16, (uint64_t)off_10033EB00, (uint64_t)v20, (uint64_t)v20 + v21)
            && !sub_10002771C(v16, (uint64_t)off_10033EB58, *(_QWORD *)a1, *(_QWORD *)(a1 + 16))
            && !sub_100027558(v16, &__s, &__n))
          {
            v14 = sub_1000249D4(*(_DWORD *)(a1 + 40), __s, __n, a6, a7);
          }
        }
        if (!v18)
        {
          memset_s(v20, v21, 0, v21);
          free(v20);
        }
      }
    }
  }
LABEL_19:
  sub_10002713C(v16);
  memset_s(v16, 8uLL, 0, 8uLL);
  free(v16);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v14;
}

uint64_t sub_10002487C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  void *v7;
  void **v8;
  void *v10;
  rsize_t __smax;
  void *__s;
  rsize_t __n;

  v6 = 3758097090;
  v7 = off_10033EB70;
  v8 = (void **)calloc(8uLL, 1uLL);
  *v8 = 0;
  sub_100027888(v8, (uint64_t)off_10033EAE8, (uint64_t)v7);
  __s = 0;
  __n = 0;
  v10 = 0;
  __smax = 0;
  if (!sub_100024CE0(a1, v8, a2, a3))
  {
    sub_1000271B4(v8, (unsigned __int8 *)off_10033EB58);
    if (!sub_10002771C(v8, (uint64_t)off_10033EB58, *(_QWORD *)a1, *(_QWORD *)(a1 + 16))
      && !sub_100027558(v8, &__s, &__n))
    {
      v6 = sub_1000249D4(*(_DWORD *)(a1 + 40), __s, __n, &v10, &__smax);
    }
  }
  sub_10002713C(v8);
  memset_s(v8, 8uLL, 0, 8uLL);
  free(v8);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  if (v10)
  {
    memset_s(v10, __smax, 0, __smax);
    free(v10);
  }
  return v6;
}

uint64_t sub_1000249D4(int a1, const void *a2, size_t a3, _QWORD *a4, size_t *a5)
{
  mach_port_t v10;
  mach_port_t v11;
  uint64_t v12;
  void *v13;
  size_t __count;
  uint64_t input;
  _BYTE __src[32768];

  v10 = sub_100015BC4();
  if (v10)
  {
    if (a2)
    {
      v11 = v10;
      v12 = 3758097090;
      if (sub_100026E64((uint64_t)a2, (uint64_t)a2 + a3) == a3)
      {
        bzero(__src, 0x8000uLL);
        __count = 0x8000;
        input = a1;
        v12 = IOConnectCallMethod(v11, 0x2Bu, &input, 1u, a2, a3, 0, 0, __src, &__count);
        if (!(_DWORD)v12 && a4 && a5)
        {
          v13 = calloc(__count, 1uLL);
          *a4 = v13;
          if (v13)
          {
            memcpy(v13, __src, __count);
            v12 = 0;
            *a5 = __count;
          }
          else
          {
            v12 = 3758097085;
          }
        }
      }
    }
    else
    {
      v12 = 3758097090;
    }
  }
  else
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "_aks_operation", ":", 457, "", 0, "", "");
    v12 = 3758097084;
  }
  memset_s(__src, 0x8000uLL, 0, 0x8000uLL);
  return v12;
}

uint64_t sub_100024BAC(uint64_t a1, const void *a2, size_t a3)
{
  void *v6;
  void *v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;

  v10 = 0;
  v11 = 0;
  if (!sub_100026F9C((uint64_t)off_10033EB58, &v10, &v11, (uint64_t)a2, (uint64_t)a2 + a3))
    return 3758097090;
  if (*(_QWORD *)a1)
  {
    memset_s(*(void **)a1, *(_QWORD *)(a1 + 8), 0, *(_QWORD *)(a1 + 8));
    free(*(void **)a1);
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
  }
  v6 = calloc(a3, 1uLL);
  *(_QWORD *)a1 = v6;
  *(_QWORD *)(a1 + 8) = a3;
  if (!v6)
    return 3758604298;
  memcpy(v6, a2, a3);
  v7 = *(void **)a1;
  v8 = *(_QWORD *)a1 + *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = v8;
  if (sub_100026F9C((uint64_t)off_10033EB58, &v10, &v11, (uint64_t)v7, v8))
    *(_QWORD *)(a1 + 32) = v10;
  if ((sub_100026F9C((uint64_t)off_10033EB18, &v10, &v11, *(_QWORD *)a1, *(_QWORD *)(a1 + 16)) & 1) != 0
    || (result = sub_100026F9C((uint64_t)off_10033EB08, &v10, &v11, *(_QWORD *)a1, *(_QWORD *)(a1 + 16)), (_DWORD)result))
  {
    result = 0;
    *(_QWORD *)(a1 + 24) = v10;
  }
  return result;
}

uint64_t sub_100024CE0(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v8;

  v4 = 3758604298;
  if (a1)
  {
    v8 = *(_QWORD *)(a1 + 48);
    if ((!v8 || !sub_100027450((uint64_t)a2, v8, v8 + *(_QWORD *)(a1 + 56)))
      && (!a3 || !sub_100027450((uint64_t)a2, a3, a3 + a4)))
    {
      sub_1000271B4(a2, (unsigned __int8 *)off_10033EB18);
      return 0;
    }
  }
  return v4;
}

uint64_t sub_100024D68(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;

  v1 = *(_QWORD *)(a1 + 32);
  if (!v1)
    return 0;
  v4 = 0;
  v5 = 0;
  result = sub_100026F9C((uint64_t)off_10033EB50, &v4, &v5, v1, *(_QWORD *)(a1 + 16));
  if ((_DWORD)result)
    return sub_100027068(v4, *(_QWORD *)(a1 + 16));
  return result;
}

uint64_t sub_100024DCC(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;
  uint64_t v3;
  uint64_t v4;

  v1 = *(_QWORD *)(a1 + 32);
  if (!v1)
    return 0;
  v3 = 0;
  v4 = 0;
  result = sub_100026F9C((uint64_t)off_10033EB48, &v3, &v4, v1, *(_QWORD *)(a1 + 16));
  if ((_DWORD)result)
    return sub_100027068(v3, v3 + v4);
  return result;
}

uint64_t sub_100024E28(uint64_t *a1, _QWORD *a2)
{
  uint64_t v2;
  int v5;
  uint64_t v6;
  _QWORD *v8;
  uint64_t v9;
  size_t v10;
  char *v11;
  size_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;

  v20 = 0;
  v19 = 0;
  v2 = a1[4];
  if (!v2)
    return 0;
  v17 = 0;
  v18 = 0;
  if (sub_100026F9C((uint64_t)off_10033EB40, &v17, &v18, v2, a1[2]))
  {
    *(_QWORD *)&v16 = v17;
    *((_QWORD *)&v16 + 1) = v17 + v18;
    sub_1000270D0(&v16, 4, &v20, &v19);
  }
  v5 = sub_100024DCC((uint64_t)a1);
  if ((v5 - 7) < 2)
  {
    v6 = ccec_cp_384();
    goto LABEL_9;
  }
  if ((v5 - 4) <= 1)
  {
    v6 = ccec_cp_256();
LABEL_9:
    v8 = (_QWORD *)v6;
    if (v6)
    {
      v9 = j__cczp_bitlen(v6);
      if (v20 == (unint64_t)(v9 + 7) >> 3)
      {
        if (v19 && !a1[8])
        {
          __chkstk_darwin(v9);
          v11 = (char *)&v15 - v10;
          bzero((char *)&v15 - v10, v10);
          ccec_compact_import_pub(v8, v20, v19, v11);
          v12 = (2 * sub_100026CEC()) | 1;
          v13 = calloc(v12, 1uLL);
          a1[8] = (uint64_t)v13;
          a1[9] = v12;
          if (v13)
            ccec_export_pub(v11, v13);
          cc_clear(24 * *v8 + 16, v11);
        }
        v14 = a1[9];
        v19 = a1[8];
        v20 = v14;
      }
    }
  }
  *a2 = v20;
  return v19;
}

uint64_t sub_100024FF8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6, size_t *a7)
{
  uint64_t v14;
  void *v15;
  void **v16;
  void *__s;
  rsize_t __n;

  v14 = 3758097090;
  v15 = off_10033EB80;
  v16 = (void **)calloc(8uLL, 1uLL);
  *v16 = 0;
  sub_100027888(v16, (uint64_t)off_10033EAE8, (uint64_t)v15);
  __s = 0;
  __n = 0;
  if (!sub_100024CE0(a1, v16, a2, a3))
  {
    sub_1000271B4(v16, (unsigned __int8 *)off_10033EB00);
    sub_1000271B4(v16, (unsigned __int8 *)off_10033EB58);
    if (!sub_100027898(v16, (uint64_t)off_10033EB00, a4, a5)
      && !sub_10002771C(v16, (uint64_t)off_10033EB58, *(_QWORD *)a1, *(_QWORD *)(a1 + 16))
      && !sub_100027558(v16, &__s, &__n))
    {
      v14 = sub_1000249D4(*(_DWORD *)(a1 + 40), __s, __n, a6, a7);
    }
  }
  sub_10002713C(v16);
  memset_s(v16, 8uLL, 0, 8uLL);
  free(v16);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v14;
}

uint64_t sub_100025178(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6, size_t *a7)
{
  uint64_t v14;
  void *v15;
  void **v16;
  void *__s;
  rsize_t __n;

  v14 = 3758097090;
  v15 = off_10033EB88;
  v16 = (void **)calloc(8uLL, 1uLL);
  *v16 = 0;
  sub_100027888(v16, (uint64_t)off_10033EAE8, (uint64_t)v15);
  __s = 0;
  __n = 0;
  if (!sub_100024CE0(a1, v16, a2, a3))
  {
    sub_1000271B4(v16, (unsigned __int8 *)off_10033EB00);
    sub_1000271B4(v16, (unsigned __int8 *)off_10033EB58);
    if (!sub_10002771C(v16, (uint64_t)off_10033EB00, a4, a4 + a5)
      && !sub_10002771C(v16, (uint64_t)off_10033EB58, *(_QWORD *)a1, *(_QWORD *)(a1 + 16))
      && !sub_100027558(v16, &__s, &__n))
    {
      v14 = sub_1000249D4(*(_DWORD *)(a1 + 40), __s, __n, a6, a7);
    }
  }
  sub_10002713C(v16);
  memset_s(v16, 8uLL, 0, 8uLL);
  free(v16);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v14;
}

uint64_t sub_1000252F8(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;

  result = *a1;
  *a2 = a1[1];
  return result;
}

uint64_t sub_100025304(uint64_t a1, uint64_t *a2)
{
  *a2 = sub_100026E64(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 16));
  return *(_QWORD *)(a1 + 24);
}

void sub_100025338(void *a1, rsize_t __n)
{
  memset_s(a1, __n, 0, __n);
  free(a1);
}

void sub_100025364(id a1)
{
  qword_100340CA8 = (uint64_t)dispatch_queue_create("aks-client-queue", 0);
}

uint64_t sub_10002538C(char *path, const char *a2)
{
  io_service_t v3;
  io_object_t v4;
  kern_return_t v5;
  const __CFDictionary *v6;
  io_service_t MatchingService;
  io_object_t v8;
  uint64_t result;
  kern_return_t v10;
  io_connect_t connect;

  connect = 0;
  v3 = IORegistryEntryFromPath(kIOMasterPortDefault, path);
  if (!v3 || (v4 = v3, v5 = IOServiceOpen(v3, mach_task_self_, 0, &connect), IOObjectRelease(v4), v5))
  {
    v6 = IOServiceMatching(a2);
    MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v6);
    if (MatchingService)
    {
      v8 = MatchingService;
      IOServiceOpen(MatchingService, mach_task_self_, 0, &connect);
      IOObjectRelease(v8);
    }
  }
  result = connect;
  if (connect)
  {
    v10 = IOConnectCallMethod(connect, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    result = connect;
    if (v10)
    {
      IOServiceClose(connect);
      return 0;
    }
  }
  return result;
}

uint64_t sub_100025480(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  int v4;
  uint64_t result;
  __int128 v6;

  *(_QWORD *)&v6 = a1;
  *((_QWORD *)&v6 + 1) = a1 + a2;
  if (!ccder_blob_decode_range(&v6, 0x2000000000000010, &v6)
    || !sub_100027E7C(&v6, 0x8000000000000000, a3)
    || !sub_1000272C8(&v6, 0x8000000000000001, a3 + 1, 16)
    || !sub_1000272C8(&v6, 0x8000000000000002, a3 + 3, 40)
    || !sub_1000272C8(&v6, 0x8000000000000003, a3 + 8, 16))
  {
    return 4294967277;
  }
  v4 = sub_100027E7C(&v6, 0x8000000000000004, a3 + 10);
  result = 4294967277;
  if (v4)
  {
    if ((_QWORD)v6 == *((_QWORD *)&v6 + 1))
      return 0;
    else
      return 4294967277;
  }
  return result;
}

uint64_t sub_10002555C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v12;
  _OWORD __s[2];

  memset(__s, 0, sizeof(__s));
  v12 = 32;
  if (*(_QWORD *)a1)
  {
    v10 = 4294967284;
  }
  else
  {
    v8 = ccsha256_di(a1);
    if (j__ccpbkdf2_hmac(v8, a3, a2, 16, a1 + 64, *(_QWORD *)(a1 + 80), 32, __s))
      goto LABEL_9;
    v9 = sub_100023BD0((uint64_t)__s, 0x20u, 0xA6A6A6A6A6A6A6A6, 0, (_QWORD *)(a1 + 24), 0x28u, (_QWORD *)a4, &v12);
    if ((_DWORD)v9)
    {
      v10 = v9;
      goto LABEL_8;
    }
    if (v12 != 32)
    {
LABEL_9:
      v10 = 4294967286;
    }
    else
    {
      cccurve25519_make_pub(a4 + 32, a4);
      if (uuid_compare((const unsigned __int8 *)(a1 + 8), (const unsigned __int8 *)(a4 + 32)))
        v10 = 4294967272;
      else
        v10 = 0;
    }
  }
LABEL_8:
  memset_s(__s, 0x20uLL, 0, 0x20uLL);
  return v10;
}

uint64_t sub_100025694(void **a1)
{
  if (!a1)
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)a1 != 1634431856)
    return 0xFFFFFFFFLL;
  free(a1[1]);
  free(a1);
  return 0;
}

uint64_t sub_1000256EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v9;

  if (!a1)
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)a1 != 1634431856 || !a2 && a3)
    return 0xFFFFFFFFLL;
  result = 0xFFFFFFFFLL;
  if (a4 && (*(_DWORD *)(a1 + 24) - 4) >= 0xFFFFFFFD)
  {
    v9 = ccsha256_di(0xFFFFFFFFLL);
    if (ccpbkdf2_hmac(v9, a3, a2, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 8), *(unsigned int *)(a1 + 4), 32, a4))return 0xFFFFFFFFLL;
    else
      return 0;
  }
  return result;
}

uint64_t sub_10002578C(int a1, uint64_t *a2)
{
  uint64_t result;
  uint64_t v5;
  mach_port_t v6;
  mach_port_t v7;
  CFMutableDictionaryRef Mutable;
  _BYTE *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  void *v14;
  int v15;
  __int128 v16;
  uint64_t v17;
  void **v18;
  size_t v19;
  void *v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  void *v26;
  __int128 v27;
  __int128 v28;
  uint64_t input;
  _BYTE outputStruct[32768];

  if (!a2)
    return 0;
  result = (uint64_t)calloc(0x20uLL, 1uLL);
  if (!result)
    return result;
  v5 = result;
  *(_DWORD *)result = 1634431856;
  v6 = sub_100015BC4();
  if (!v6)
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "_get_prederived_configuration", ":", 384, "", 0, "", "");
LABEL_16:
    sub_100025694((void **)v5);
    return 0;
  }
  v7 = v6;
  bzero(outputStruct, 0x8000uLL);
  v19 = 0x8000;
  input = a1;
  if (IOConnectCallMethod(v7, 0x1Fu, &input, 1u, 0, 0, 0, 0, outputStruct, &v19) || v19 > 0x8000)
    goto LABEL_16;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v9 = &outputStruct[v19];
  v22 = 0u;
  v24 = 0u;
  v25 = 0;
  v21 = 0u;
  v27 = 0u;
  v28 = 0u;
  v20 = off_10033EC20;
  v23 = (unint64_t)off_10033EC28;
  v26 = off_10033EC30;
  v16 = xmmword_100248E20;
  v17 = 0;
  v18 = &v20;
  sub_100026EC8((uint64_t)outputStruct, (uint64_t)&outputStruct[v19], (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_100026D18, (uint64_t)&v16);
  v10 = *((_QWORD *)&v23 + 1);
  v11 = v27;
  v12 = ccder_decode_tl(4, v5 + 16, v21, v9);
  if (v12)
  {
    v13 = (const void *)v12;
    v14 = calloc(*(_QWORD *)(v5 + 16), 1uLL);
    *(_QWORD *)(v5 + 8) = v14;
    if (!v14)
    {
      v15 = 0;
      if (!Mutable)
        goto LABEL_11;
      goto LABEL_10;
    }
    memcpy(v14, v13, *(_QWORD *)(v5 + 16));
    *(_DWORD *)(v5 + 4) = sub_100027068(v10, (uint64_t)v9);
    *(_DWORD *)(v5 + 24) = sub_100027068(v11, (uint64_t)v9);
  }
  v15 = 1;
  if (Mutable)
LABEL_10:
    CFRelease(Mutable);
LABEL_11:
  if (!v15 || !*(_QWORD *)(v5 + 16))
    goto LABEL_16;
  *a2 = v5;
  return 1;
}

uint64_t sub_100025A4C(int a1, uint64_t a2, int a3, _DWORD *a4)
{
  BOOL v4;
  BOOL v5;
  uint64_t v7;
  _OWORD v9[2];

  memset(v9, 0, sizeof(v9));
  if (a3)
    v4 = a2 == 0;
  else
    v4 = 0;
  v5 = v4 || a4 == 0;
  if (v5 || *a4 != 1634431856 || sub_1000256EC((uint64_t)a4, a2, a3, (uint64_t)v9))
    v7 = 0xFFFFFFFFLL;
  else
    v7 = sub_100025B14(a1, (uint64_t)v9, 32);
  memset_s(v9, 0x20uLL, 0, 0x20uLL);
  return v7;
}

uint64_t sub_100025B14(int a1, uint64_t a2, int a3)
{
  mach_port_t v6;
  uint64_t input[3];

  v6 = sub_100015BC4();
  if (v6)
  {
    input[0] = a1;
    input[1] = a2;
    input[2] = a3;
    return IOConnectCallMethod(v6, 0xCu, input, 3u, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_unlock_bag", ":", 807, "", 0, "", "");
    return 3758097084;
  }
}

uint64_t sub_100025C10(const void *a1, int a2, _DWORD *a3)
{
  uint64_t v6;
  mach_port_t v7;
  uint32_t outputCnt;
  uint64_t output;

  v6 = 3758097084;
  v7 = sub_100015BC4();
  if (v7)
  {
    v6 = 3758097090;
    if (a1)
    {
      if (a3)
      {
        output = 0;
        outputCnt = 1;
        v6 = IOConnectCallMethod(v7, 6u, 0, 0, a1, a2, &output, &outputCnt, 0, 0);
        if (!(_DWORD)v6)
          *a3 = output;
      }
    }
  }
  else
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_load_bag", ":", 574, "", 0, "", "");
  }
  return v6;
}

uint64_t sub_100025D28(int a1)
{
  mach_port_t v2;
  uint64_t input;

  v2 = sub_100015BC4();
  if (v2)
  {
    input = a1;
    return IOConnectCallMethod(v2, 4u, &input, 1u, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_unload_bag", ":", 612, "", 0, "", "");
    return 3758097084;
  }
}

uint64_t sub_100025E0C(int a1, _OWORD *a2)
{
  uint64_t v4;
  mach_port_t v5;
  size_t v7;
  uint64_t input;
  __int128 outputStruct;

  v4 = 3758097084;
  v7 = 16;
  v5 = sub_100015BC4();
  if (v5)
  {
    if (a2)
    {
      outputStruct = 0uLL;
      input = a1;
      v4 = IOConnectCallMethod(v5, 0x17u, &input, 1u, 0, 0, 0, 0, &outputStruct, &v7);
      if (!(_DWORD)v4)
        *a2 = outputStruct;
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_get_bag_uuid", ":", 729, "", 0, "", "");
  }
  return v4;
}

uint64_t sub_100025F30(int a1, _DWORD *a2)
{
  uint64_t v4;
  mach_port_t v5;
  uint32_t outputCnt;
  uint64_t output;
  uint64_t input;

  v4 = 3758097084;
  v5 = sub_100015BC4();
  if (v5)
  {
    if (a2)
    {
      output = 0;
      input = a1;
      outputCnt = 1;
      v4 = IOConnectCallMethod(v5, 7u, &input, 1u, 0, 0, &output, &outputCnt, 0, 0);
      if (!(_DWORD)v4)
        *a2 = output;
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_get_lock_state", ":", 824, "", 0, "", "");
  }
  return v4;
}

uint64_t sub_100026048(int a1, _DWORD *a2)
{
  uint64_t v4;
  mach_port_t v5;
  uint32_t outputCnt;
  uint64_t output;
  uint64_t input;

  v4 = 3758097084;
  v5 = sub_100015BC4();
  if (v5)
  {
    if (a2)
    {
      output = 0;
      input = a1;
      outputCnt = 1;
      v4 = IOConnectCallMethod(v5, 0xEu, &input, a1 != 0, 0, 0, &output, &outputCnt, 0, 0);
      if (!(_DWORD)v4)
        *a2 = output;
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_get_system", ":", 922, "", 0, "", "");
  }
  return v4;
}

uint64_t sub_100026164(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _OWORD *a5)
{
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  _OWORD v13[5];
  uint64_t v14;
  __int128 __s;
  __int128 v16;
  __int128 v17;
  __int128 v18;

  v17 = 0u;
  v18 = 0u;
  __s = 0u;
  v16 = 0u;
  v14 = 0;
  memset(v13, 0, sizeof(v13));
  v8 = sub_100025480(a1, a2, v13);
  if ((_DWORD)v8)
  {
    v9 = v8;
  }
  else
  {
    v9 = sub_10002555C((uint64_t)v13, a3, a4, (uint64_t)&__s);
    if (!(_DWORD)v9)
    {
      v10 = v16;
      *a5 = __s;
      a5[1] = v10;
      v11 = v18;
      a5[2] = v17;
      a5[3] = v11;
    }
  }
  memset_s(v13, 0x58uLL, 0, 0x58uLL);
  memset_s(&__s, 0x40uLL, 0, 0x40uLL);
  return sub_100026C60(v9);
}

uint64_t sub_100026250(uint64_t a1, const void *a2, size_t a3, void *a4, size_t *a5)
{
  uint64_t v10;
  mach_port_t v11;
  uint64_t input[2];

  v10 = 3758097084;
  v11 = sub_100015BC4();
  if (v11)
  {
    v10 = 3758097090;
    if (a2 && a4)
    {
      input[0] = a1;
      input[1] = 64;
      return IOConnectCallMethod(v11, 0x82u, input, 2u, a2, a3, 0, 0, a4, a5);
    }
  }
  else
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_kc_backup_unwrap_key", ":", 1193, "", 0, "", "");
  }
  return v10;
}

uint64_t sub_100026368(int a1, const void *a2, size_t a3, void *a4, size_t *a5)
{
  uint64_t v10;
  mach_port_t v11;
  uint64_t input;

  v10 = 3758097084;
  v11 = sub_100015BC4();
  if (v11)
  {
    v10 = 3758097090;
    if (a2 && a4)
    {
      input = a1;
      return IOConnectCallMethod(v11, 0x81u, &input, 1u, a2, a3, 0, 0, a4, a5);
    }
  }
  else
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_kc_backup_wrap_key", ":", 1212, "", 0, "", "");
  }
  return v10;
}

uint64_t sub_100026480(int a1, unsigned __int8 *a2)
{
  uint64_t v4;
  mach_port_t v5;
  uint64_t v6;
  size_t v8;
  unsigned __int8 src[8];
  uint64_t v10;
  uint64_t input;

  v4 = 3758097084;
  v5 = sub_100015BC4();
  if (v5)
  {
    if (a2)
    {
      v10 = 0;
      input = a1;
      v8 = 16;
      *(_QWORD *)src = 0;
      v6 = IOConnectCallMethod(v5, 0x84u, &input, 1u, 0, 0, 0, 0, src, &v8);
      if ((_DWORD)v6)
      {
        return v6;
      }
      else if (v8 == 16)
      {
        uuid_copy(a2, src);
        return 0;
      }
      else
      {
        return 3758604298;
      }
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_kc_backup_get_uuid", ":", 1253, "", 0, "", "");
  }
  return v4;
}

uint64_t sub_1000265C4(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5, _OWORD *a6)
{
  int v7;
  int v9;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  void **v17;

  v17 = 0;
  if (a5)
  {
    v7 = a4;
    v9 = a2;
    *a5 = -1;
    v11 = sub_100026164((uint64_t)a1, a2, a3, a4, a6);
    if (!v11)
    {
      fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s Unwrapped DER backup bag%s\n", "aks", "", "", "", "aks_kc_backup_open_keybag", ":", 1302, "", 0, "", "");
      v15 = 0;
      goto LABEL_9;
    }
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s Failed to unwrap backup bag as DER: 0x%08x%s\n", "aks", "", "", "", "aks_kc_backup_open_keybag", ":", 1290, "", 0, "", v11, "");
    v12 = sub_100025C10(a1, v9, a5);
    if ((_DWORD)v12)
    {
      v15 = v12;
      fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s Failed to load in-kernel backup bag: 0x%08x%s\n", "aks", "", "", "", "aks_kc_backup_open_keybag", ":", 1292, "", 0, "", v12, "");
    }
    else
    {
      v13 = sub_10002578C(*a5, (uint64_t *)&v17);
      v14 = *a5;
      if (v13)
      {
        v15 = sub_100025A4C(v14, a3, v7, v17);
        if (!(_DWORD)v15)
          goto LABEL_9;
        fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s Failed to unlock in-kernel backup bag with prederived secret: 0x%08x%s\n", "aks", "", "", "", "aks_kc_backup_open_keybag", ":");
      }
      else
      {
        v15 = sub_100025B14(v14, a3, v7);
        if (!(_DWORD)v15)
          goto LABEL_9;
        fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s Failed to unlock in-kernel backup bag: 0x%08x%s\n", "aks", "", "", "", "aks_kc_backup_open_keybag", ":");
      }
    }
  }
  else
  {
    v15 = 3758097090;
  }
  if (*a5 != -1)
  {
    sub_100025D28(*a5);
    *a5 = -1;
  }
LABEL_9:
  sub_100025694(v17);
  return v15;
}

uint64_t sub_1000267F0(int a1, unsigned int a2, uint64_t a3)
{
  mach_port_t v3;
  uint64_t input[3];

  input[0] = a2;
  input[1] = a3;
  input[2] = a1;
  v3 = sub_100015BC4();
  if (v3)
    return IOConnectCallMethod(v3, 0x1Au, input, 3u, 0, 0, 0, 0, 0, 0);
  fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_assert_hold", ":", 1654, "", 0, "", "");
  return 3758097084;
}

uint64_t sub_1000268D0(int a1, unsigned int a2)
{
  mach_port_t v2;
  uint64_t input[2];

  input[0] = a2;
  input[1] = a1;
  v2 = sub_100015BC4();
  if (v2)
    return IOConnectCallMethod(v2, 0x1Bu, input, 2u, 0, 0, 0, 0, 0, 0);
  fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_assert_drop", ":", 1672, "", 0, "", "");
  return 3758097084;
}

uint64_t sub_1000269AC(int a1, unsigned int a2, _DWORD *a3)
{
  mach_port_t v6;
  uint64_t result;
  uint32_t outputCnt;
  uint64_t output;
  uint64_t input[2];

  v6 = sub_100015BC4();
  if (v6)
  {
    input[0] = a1;
    input[1] = a2;
    output = 0;
    outputCnt = 1;
    result = IOConnectCallMethod(v6, 0x28u, input, 2u, 0, 0, &output, &outputCnt, 0, 0);
    if (a3)
    {
      if (!(_DWORD)result)
        *a3 = output;
    }
  }
  else
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_generation", ":", 1781, "", 0, "", "");
    return 3758097084;
  }
  return result;
}

uint64_t sub_100026AC0(int a1, uint64_t a2)
{
  return sub_100026ACC(a1, 0x11u, a2);
}

uint64_t sub_100026ACC(int a1, uint32_t a2, uint64_t a3)
{
  uint64_t v5;
  mach_port_t v6;
  mach_port_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  int v12[2];
  __int128 __s;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  int v18;
  _BYTE outputStruct[4096];
  uint64_t input;

  input = a1;
  *(_QWORD *)v12 = 4096;
  v5 = 3758097084;
  v18 = 0;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  __s = 0u;
  v6 = sub_100015BC4();
  if (v6)
  {
    if (a3)
    {
      v7 = v6;
      bzero(outputStruct, 0x1000uLL);
      v8 = IOConnectCallMethod(v7, a2, &input, 1u, 0, 0, 0, 0, outputStruct, (size_t *)v12);
      if ((_DWORD)v8)
      {
        return v8;
      }
      else
      {
        v5 = 0;
        if (!sub_100027C18((uint64_t)outputStruct, v12[0], (char *)&__s))
        {
          v9 = v16;
          *(_OWORD *)(a3 + 32) = v15;
          *(_OWORD *)(a3 + 48) = v9;
          *(_WORD *)(a3 + 64) = v17;
          v10 = v14;
          *(_OWORD *)a3 = __s;
          *(_OWORD *)(a3 + 16) = v10;
        }
      }
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "_get_device_state", ":", 2224, "", 0, "", "");
  }
  return v5;
}

uint64_t sub_100026C60(uint64_t result)
{
  if ((_DWORD)result == 0 || result >= 0xFFFFFFDA)
    return dword_100248E30[(int)result + 38];
  return result;
}

uint64_t sub_100026C7C(uint64_t result, int a2, const char *a3)
{
  if ((result & 1) == 0)
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s failed REQUIRE condition (%s:%d)\n%s\n", "aks", "", "", "", "REQUIRE_func", ":", 1047, "", 0, "", a3, a2, "");
    abort();
  }
  return result;
}

unint64_t sub_100026CEC()
{
  return (unint64_t)(cczp_bitlen() + 7) >> 3;
}

uint64_t sub_100026D0C(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  return cccbc_update(a1, a2, a3, a4 >> 4);
}

uint64_t sub_100026D18(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  _BOOL4 v12;
  char v13;
  char v14;
  _QWORD *v15;

  if (*(_QWORD *)(a5 + 8) >= *(_QWORD *)a5)
  {
    v14 = 0;
  }
  else
  {
    v9 = 0;
    v10 = 0;
    v11 = (uint64_t)a1 + a2;
    while (1)
    {
      v12 = sub_100026DFC(*(const void **)(*(_QWORD *)(a5 + 24) + v9), *(_QWORD *)(*(_QWORD *)(a5 + 24) + v9)+ *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a5 + 24) + v9) + 1)+ 2, a1, v11);
      if (v12)
        break;
      ++v10;
      v9 += 40;
      if (v10 >= *(_QWORD *)a5)
        goto LABEL_10;
    }
    v15 = (_QWORD *)(*(_QWORD *)(a5 + 24) + v9);
    if (v15[1])
    {
      v13 = 0;
      *(_BYTE *)(a5 + 16) = 1;
    }
    else
    {
      ++*(_QWORD *)(a5 + 8);
      v15[1] = a3;
      v15[2] = a3 + a4;
      v15[3] = a3;
      v15[4] = a3 + a4;
      v13 = 1;
    }
LABEL_10:
    v14 = v13 | !v12;
  }
  return v14 & 1;
}

BOOL sub_100026DFC(const void *a1, uint64_t a2, const void *a3, uint64_t a4)
{
  size_t v7;

  v7 = sub_100026E64((uint64_t)a1, a2);
  return v7 == sub_100026E64((uint64_t)a3, a4) && memcmp(a1, a3, v7) == 0;
}

uint64_t sub_100026E64(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD v6[2];

  v6[0] = a1;
  v6[1] = a2;
  v4 = 0;
  v5 = 0;
  if (ccder_blob_decode_tag(v6, &v5) && ccder_blob_decode_len(v6, &v4))
    return v6[0] + v4 - a1;
  else
    return 0;
}

uint64_t sub_100026EC8(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a4)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[2];

  v11[0] = a1;
  v11[1] = a2;
  v9 = 0;
  v10 = 0;
  v8 = 0;
  result = ccder_blob_decode_range(v11, 0x2000000000000011, v11);
  if ((_DWORD)result)
  {
    if (ccder_blob_decode_sequence_tl(v11, &v9))
    {
      while (1)
      {
        v7 = v9;
        result = ccder_blob_decode_tl(&v9, 12, &v8);
        if (!(_DWORD)result)
          break;
        if (v9 - v7 != 2)
          return 0;
        result = a3(v7, v10 - v7, v9 + v8, v10 - (v9 + v8), a4);
        if (!(_DWORD)result)
          return result;
        v11[0] = v10;
        if ((ccder_blob_decode_sequence_tl(v11, &v9) & 1) == 0)
          return 1;
      }
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t sub_100026F9C(uint64_t a1, _QWORD *a2, _QWORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v12 = 0;
  v13 = 0;
  v10 = a1;
  v11 = 0;
  if (a1)
  {
    sub_100026EC8(a4, a5, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_100027008, (uint64_t)&v10);
    if (a2)
    {
      if (a3)
      {
        v7 = v11;
        v8 = v12;
        *a2 = v11;
        *a3 = v8 - v7;
      }
    }
  }
  return v13;
}

BOOL sub_100027008(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _BOOL4 v8;

  v8 = sub_100026DFC(*(const void **)a5, *(_QWORD *)a5 + *(unsigned __int8 *)(*(_QWORD *)a5 + 1) + 2, a1, (uint64_t)a1 + a2);
  if (v8)
  {
    *(_BYTE *)(a5 + 24) = 1;
    *(_QWORD *)(a5 + 8) = a3;
    *(_QWORD *)(a5 + 16) = a3 + a4;
  }
  return !v8;
}

uint64_t sub_100027068(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unsigned __int8 *v3;
  uint64_t result;
  unsigned int v5;
  _QWORD v6[2];
  uint64_t v7;

  v7 = 0;
  v6[0] = a1;
  v6[1] = a2;
  if (!ccder_blob_decode_tl(v6, 2, &v7))
    return 0;
  v2 = v7;
  if ((unint64_t)(v7 - 9) < 0xFFFFFFFFFFFFFFF8)
    return 0;
  v3 = (unsigned __int8 *)v6[0];
  result = (uint64_t)*(char *)v6[0] >> 7;
  do
  {
    v5 = *v3++;
    result = v5 | (unint64_t)(result << 8);
    --v2;
  }
  while (v2);
  return result;
}

double sub_1000270D0(__int128 *a1, uint64_t a2, _DWORD *a3, _QWORD *a4)
{
  double result;
  int v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;

  v11 = *a1;
  v9 = 0;
  v10 = 0;
  if (ccder_blob_decode_range(&v11, a2, &v9))
  {
    v8 = v9;
    *a4 = v9;
    *a3 = v10 - v8;
    result = *(double *)&v11;
    *a1 = v11;
  }
  return result;
}

uint64_t sub_10002713C(void **a1)
{
  void *v2;
  void *v3;

  if (!a1)
    return 0xFFFFFFFFLL;
  while (1)
  {
    v2 = *a1;
    if (!*a1)
      break;
    v3 = (void *)*((_QWORD *)v2 + 1);
    *a1 = *(void **)v2;
    if (v3)
    {
      memset_s(v3, *((_QWORD *)v2 + 2), 0, *((_QWORD *)v2 + 2));
      free(*((void **)v2 + 1));
    }
    memset_s(v2, 0x18uLL, 0, 0x18uLL);
    free(v2);
  }
  return 0;
}

uint64_t sub_1000271B4(_QWORD *a1, unsigned __int8 *a2)
{
  _QWORD **v2;
  uint64_t result;
  uint64_t v4;
  _QWORD *i;
  void *v6;

  if (!a1)
    return 0xFFFFFFFFLL;
  v2 = (_QWORD **)a1;
  result = (uint64_t)sub_100027248(a1, a2);
  if (result)
  {
    v4 = result;
    for (i = *v2; i != (_QWORD *)result; i = (_QWORD *)*i)
      v2 = (_QWORD **)i;
    *v2 = *(_QWORD **)result;
    v6 = *(void **)(result + 8);
    if (v6)
    {
      memset_s(v6, *(_QWORD *)(v4 + 16), 0, *(_QWORD *)(v4 + 16));
      free(*(void **)(v4 + 8));
    }
    memset_s((void *)v4, 0x18uLL, 0, 0x18uLL);
    free((void *)v4);
    return 0;
  }
  return result;
}

_QWORD *sub_100027248(_QWORD *a1, unsigned __int8 *a2)
{
  _QWORD *v2;
  uint64_t v4;
  const void *v6;
  uint64_t v7;

  if (!a1)
    return 0;
  v6 = 0;
  v7 = 0;
  v2 = (_QWORD *)*a1;
  if (*a1)
  {
    do
    {
      v4 = v2[1] + v2[2];
      v6 = (const void *)v2[1];
      v7 = v4;
      if (ccder_blob_decode_sequence_tl(&v6, &v6) && sub_100026DFC(a2, (uint64_t)&a2[a2[1] + 2], v6, v7))
        break;
      v2 = (_QWORD *)*v2;
    }
    while (v2);
  }
  return v2;
}

uint64_t sub_1000272C8(__int128 *a1, uint64_t a2, void *a3, int a4)
{
  __int128 v8;
  const void *v9;
  uint64_t v10;
  __int128 v11;

  v11 = *a1;
  v9 = 0;
  v10 = 0;
  if ((ccder_blob_decode_range(&v11, a2, &v9) & 1) == 0)
    return 0;
  v8 = v11;
  if (a3)
  {
    if ((_DWORD)v10 - (_DWORD)v9 == a4)
    {
      memcpy(a3, v9, (v10 - (_DWORD)v9));
      goto LABEL_5;
    }
    return 0;
  }
LABEL_5:
  *a1 = v8;
  return 1;
}

uint64_t sub_100027354(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD v4[2];
  unint64_t v5;

  v2 = a1;
  v4[1] = a2;
  v5 = 0;
  v4[0] = a1;
  if ((ccder_blob_decode_tl(v4, 12, &v5) & 1) == 0)
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s bad 1%s\n", "aks", "", "", "", "der_key_validate");
    return 0;
  }
  if (v5 >= 0x11)
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s bad 2%s\n", "aks", "", "", "", "der_key_validate");
    return 0;
  }
  return v2;
}

uint64_t sub_100027450(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
    return sub_100026EC8(a2, a3, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_10002748C, a1)- 1;
  else
    return 4294967285;
}

uint64_t sub_10002748C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  unsigned __int8 *v8;
  uint64_t v9;

  v8 = (unsigned __int8 *)sub_100027354(a1, a1 + a2);
  if (v8)
  {
    v9 = (uint64_t)v8;
    if (!sub_1000271B4(a5, v8) && !sub_10002771C(a5, v9, a3, a3 + a4))
      return 1;
  }
  fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s fail%s\n", "aks", "", "", "", "_merge_dict_cb", ":", 647, "", 0, "", "");
  return 0;
}

uint64_t sub_100027558(_QWORD *a1, _QWORD *a2, size_t *a3)
{
  uint64_t v3;
  _QWORD *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  rsize_t v11;
  char *v12;
  char *v13;
  _QWORD *v14;
  char *v15;
  size_t v16;
  char *v17;
  void *v18;
  unint64_t v19;
  char *v20;
  char *v22;
  char v23;
  char *v25;
  char *v26;

  v3 = 0xFFFFFFFFLL;
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        v7 = (_QWORD *)*a1;
        if (*a1)
        {
          v8 = 0;
          v9 = 0;
          v10 = 0;
          do
          {
            v10 += v7[2];
            v7 = (_QWORD *)*v7;
            v9 -= 16;
            --v8;
          }
          while (v7);
          if (v8 >= 0xF000000000000001 && (v11 = -v9, (v12 = (char *)calloc(-v9, 1uLL)) != 0))
          {
            v13 = v12;
            v14 = (_QWORD *)*a1;
            if (*a1)
            {
              v15 = v12;
              do
              {
                *(_OWORD *)v15 = *(_OWORD *)(v14 + 1);
                v15 += 16;
                v14 = (_QWORD *)*v14;
              }
              while (v14);
            }
            qsort(v12, -(uint64_t)v8, 0x10uLL, (int (__cdecl *)(const void *, const void *))sub_100027F04);
            v16 = ccder_sizeof(0x2000000000000011, v10);
            v17 = (char *)calloc(v16, 1uLL);
            v18 = v17;
            if (v17)
            {
              v25 = v17;
              v26 = &v17[v16];
              v19 = v8 - 1;
              v20 = &v13[-v9 - 8];
              while (!__CFADD__(v19++, 1))
              {
                v22 = v20 - 16;
                v23 = ccder_blob_encode_body(&v25, *(_QWORD *)v20, *((_QWORD *)v20 - 1));
                v20 = v22;
                if ((v23 & 1) == 0)
                  goto LABEL_16;
              }
              if (!ccder_blob_encode_tl(&v25, 0x2000000000000011, v10) || v25 != v26)
              {
LABEL_16:
                v3 = 0xFFFFFFFFLL;
                goto LABEL_20;
              }
              v3 = 0;
              *a2 = v18;
              *a3 = v16;
              v18 = 0;
            }
            else
            {
              v3 = 4294967279;
            }
LABEL_20:
            memset_s(v13, v11, 0, v11);
            free(v13);
            if (v18)
            {
              memset_s(v18, v16, 0, v16);
              free(v18);
            }
          }
          else
          {
            return 0xFFFFFFFFLL;
          }
        }
      }
    }
  }
  return v3;
}

uint64_t sub_10002771C(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  unint64_t v9;
  unint64_t v10;
  size_t v11;
  char *v12;
  char *v13;
  char *v14;
  int v15;
  char *v16;
  int v17;
  char *v18;
  _QWORD *v20;
  _QWORD *v21;
  char *v22;
  char *v23;
  char *v24;
  char *v25;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 && a3 && a4)
  {
    v9 = sub_100026E64(a3, a4);
    if (v9 <= a4 - a3)
    {
      v10 = v9;
      v11 = ccder_sizeof(0x2000000000000010, v9 + *(unsigned __int8 *)(a2 + 1) + 2);
      v12 = (char *)calloc(v11, 1uLL);
      if (!v12)
        return 4294967279;
      v13 = v12;
      v14 = &v12[v11];
      v22 = v12;
      v23 = &v12[v11];
      if (ccder_blob_encode_body(&v22, v10, a3))
      {
        v24 = v13;
        v25 = v23;
        v15 = ccder_blob_encode_body(&v24, *(unsigned __int8 *)(a2 + 1) + 2, a2);
        v16 = v25;
        if (!v15)
          v16 = 0;
        v24 = v13;
        v25 = v16;
        v17 = ccder_blob_encode_tl(&v24, 0x2000000000000010, v14 - v16);
        v18 = v25;
        if (!v17)
          v18 = 0;
        if (v18 && v18 == v13)
        {
          v20 = calloc(0x18uLL, 1uLL);
          if (v20)
          {
            v21 = v20;
            result = 0;
            v21[1] = v13;
            v21[2] = v11;
            *v21 = *a1;
            *a1 = v21;
            return result;
          }
        }
      }
      memset_s(v13, v11, 0, v11);
      free(v13);
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t sub_100027888(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  return sub_10002771C(a1, a2, a3, a3 + *(unsigned __int8 *)(a3 + 1) + 2);
}

uint64_t sub_100027898(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  size_t v11;
  char *v12;
  char *v13;
  char *v14;
  int v15;
  char *v16;
  int v17;
  char *v18;
  BOOL v19;
  _QWORD *v20;
  _QWORD *v21;
  char *v22;
  char *v23;
  char *v24;
  char *v25;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 && a3)
  {
    v9 = *(unsigned __int8 *)(a2 + 1);
    v10 = ccder_sizeof(4, a4);
    v11 = ccder_sizeof(0x2000000000000010, v9 + v10 + 2);
    v12 = (char *)calloc(v11, 1uLL);
    if (v12)
    {
      v13 = v12;
      v14 = &v12[v11];
      v22 = v12;
      v23 = &v12[v11];
      if (!ccder_blob_encode_body(&v22, a4, a3) || !ccder_blob_encode_tl(&v22, 4, a4))
        goto LABEL_19;
      v24 = v13;
      v25 = v23;
      v15 = ccder_blob_encode_body(&v24, *(unsigned __int8 *)(a2 + 1) + 2, a2);
      v16 = v25;
      if (!v15)
        v16 = 0;
      v24 = v13;
      v25 = v16;
      v17 = ccder_blob_encode_tl(&v24, 0x2000000000000010, v14 - v16);
      v18 = v25;
      if (!v17)
        v18 = 0;
      v19 = v18 && v18 == v13;
      if (v19 && (v20 = calloc(0x18uLL, 1uLL)) != 0)
      {
        v21 = v20;
        result = 0;
        v21[1] = v13;
        v21[2] = v11;
        *v21 = *a1;
        *a1 = v21;
      }
      else
      {
LABEL_19:
        memset_s(v13, v11, 0, v11);
        free(v13);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      return 4294967279;
    }
  }
  return result;
}

uint64_t sub_100027A04(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  size_t v15;
  char *v16;
  char *v17;
  uint64_t v18;
  int v19;
  char *v20;
  int v21;
  char *v22;
  BOOL v23;
  _QWORD *v24;
  _QWORD *v25;
  char *v26;
  char *v27;
  char *v28;
  char *v29;
  uint64_t v30;

  v3 = a3;
  v6 = HIBYTE(a3);
  if ((HIBYTE(a3) + 1) > 1u)
  {
    v11 = 8;
  }
  else
  {
    v7 = 9;
    v8 = 48;
    v9 = 1;
    while ((unint64_t)(v7 - 2) >= 2)
    {
      v10 = a3 >> v8;
      --v7;
      v8 -= 8;
      if ((_DWORD)v6 != v10)
      {
        v9 = v7 - 1;
        goto LABEL_8;
      }
    }
    v7 = 2;
LABEL_8:
    if ((((a3 >> (8 * v9 - 8)) ^ v6) & 0x80) != 0)
      v11 = v7;
    else
      v11 = v9;
  }
  v30 = 0;
  result = 0xFFFFFFFFLL;
  if (a1 && a2)
  {
    v13 = *(unsigned __int8 *)(a2 + 1);
    v14 = ccder_sizeof(2, v11);
    v15 = ccder_sizeof(0x2000000000000010, v13 + v14 + 2);
    v16 = (char *)calloc(v15, 1uLL);
    if (v16)
    {
      v17 = v16;
      v18 = v11;
      do
      {
        *((_BYTE *)&v30 + v18 - 1) = v3;
        v3 >>= 8;
        --v18;
      }
      while (v18);
      v26 = v16;
      v27 = &v16[v15];
      if ((ccder_blob_encode_body(&v26, v11, &v30) & 1) == 0 || !ccder_blob_encode_tl(&v26, 2, v11))
        goto LABEL_30;
      v28 = v17;
      v29 = v27;
      v19 = ccder_blob_encode_body(&v28, *(unsigned __int8 *)(a2 + 1) + 2, a2);
      v20 = v29;
      if (!v19)
        v20 = 0;
      v28 = v17;
      v29 = v20;
      v21 = ccder_blob_encode_tl(&v28, 0x2000000000000010, &v17[v15] - v20);
      v22 = v29;
      if (!v21)
        v22 = 0;
      v23 = v22 && v22 == v17;
      if (v23 && (v24 = calloc(0x18uLL, 1uLL)) != 0)
      {
        v25 = v24;
        result = 0;
        v25[1] = v17;
        v25[2] = v15;
        *v25 = *a1;
        *a1 = v25;
      }
      else
      {
LABEL_30:
        memset_s(v17, v15, 0, v15);
        free(v17);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      return 4294967279;
    }
  }
  return result;
}

uint64_t sub_100027C18(uint64_t a1, unsigned int a2, char *__s)
{
  uint64_t result;
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  void **v10;
  void *v11;
  uint64_t v12[57];
  __int128 v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;

  result = 0xFFFFFFFFLL;
  if (a2 && a1)
  {
    if (__s)
    {
      memset_s(__s, 0x54uLL, 0, 0x54uLL);
      bzero(v12, 0x228uLL);
      v11 = off_10033EBD8;
      v12[4] = (uint64_t)off_10033EBE0;
      v12[9] = (uint64_t)off_10033EBE8;
      v12[14] = (uint64_t)off_10033EBF0;
      v12[19] = (uint64_t)off_10033EBF8;
      v12[24] = (uint64_t)off_10033EC00;
      v12[29] = (uint64_t)off_10033EC08;
      v12[34] = (uint64_t)off_10033EC10;
      v12[39] = (uint64_t)off_10033EC18;
      v12[44] = (uint64_t)off_10033EAF0;
      v12[49] = (uint64_t)off_10033EB90;
      v12[54] = (uint64_t)off_10033EC38;
      v14 = off_10033ECA0;
      v17 = off_10033ECB0;
      v8 = xmmword_100248ED0;
      v9 = 0;
      v10 = &v11;
      sub_100026EC8(a1, a1 + a2, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_100026D18, (uint64_t)&v8);
      *(_DWORD *)__s = sub_100027068(v12[0], v12[1]);
      *((_DWORD *)__s + 1) = sub_100027068(v12[5], v12[6]);
      *((_QWORD *)__s + 1) = sub_100027068(v12[10], v12[11]);
      *((_DWORD *)__s + 4) = sub_100027068(v12[15], v12[16]);
      *((_DWORD *)__s + 5) = sub_100027068(v12[20], v12[21]);
      *(_QWORD *)(__s + 26) = sub_100027068(v12[35], v12[36]);
      *(_QWORD *)(__s + 34) = sub_100027068(v12[40], v12[41]);
      *(_DWORD *)(__s + 42) = sub_100027068(v12[45], v12[46]);
      *(_DWORD *)(__s + 46) = sub_100027068(v12[50], v12[51]);
      sub_1000272C8(&v13, 4, __s + 50, 16);
      __s[66] = sub_100027068(v12[25], v12[26]);
      __s[67] = sub_100027068(v12[30], v12[31]);
      *(_QWORD *)(__s + 68) = sub_100027068(v15, v16);
      v7 = sub_100027068(v18, v19);
      result = 0;
      *(_QWORD *)(__s + 76) = v7;
    }
  }
  return result;
}

uint64_t sub_100027E7C(__int128 *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  uint64_t v9;

  v9 = 0;
  if (a3)
    *a3 = 0;
  v8 = *a1;
  v6 = 0;
  v7 = 0;
  result = ccder_blob_decode_range(&v8, a2, &v6);
  if ((_DWORD)result)
  {
    if (ccn_read_uint(1, &v9, v7 - v6))
    {
      return 0;
    }
    else
    {
      *a1 = v8;
      if (a3)
        *a3 = v9;
      return 1;
    }
  }
  return result;
}

uint64_t sub_100027F04(_QWORD *a1, void **a2)
{
  uint64_t v2;
  char *v3;
  const void *v4;
  unint64_t v6;
  unint64_t v7;
  size_t v8;
  int v9;
  int v11;
  void *__s2[2];
  _QWORD v13[2];
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;

  v2 = *a1 + a1[1];
  v13[0] = *a1;
  v13[1] = v2;
  v3 = (char *)a2[1] + (_QWORD)*a2;
  __s2[0] = *a2;
  __s2[1] = v3;
  if (!ccder_blob_decode_sequence_tl(v13, v13))
    return 4294967293;
  if (!ccder_blob_decode_sequence_tl(__s2, __s2))
    return 4294967293;
  v17 = 0;
  v15 = 0;
  v16 = 0;
  v14 = 0;
  if (!ccder_blob_decode_tag(v13, &v17))
    return 4294967293;
  if (!ccder_blob_decode_len(v13, &v16))
    return 4294967293;
  v4 = (const void *)v13[0];
  if (!v13[0]
    || !ccder_blob_decode_tag(__s2, &v15)
    || !ccder_blob_decode_len(__s2, &v14)
    || !__s2[0])
  {
    return 4294967293;
  }
  if (v17 > v15)
    return 1;
  if (v15 > v17)
    return 0xFFFFFFFFLL;
  v6 = v16;
  v7 = v14;
  v8 = v16 >= v14 ? v14 : v16;
  v9 = memcmp(v4, __s2[0], v8);
  if (v9 > 0 || !v9 && v6 > v7)
    return 1;
  v11 = v9 < 0 || v6 < v7;
  return (v11 << 31 >> 31);
}

void *acm_mem_alloc_data(size_t size)
{
  void *result;

  result = malloc_type_calloc(1uLL, size, 0xCB62F0E9uLL);
  if (result)
    qword_100340CB8 += size;
  return result;
}

void acm_mem_free_data(void *a1, rsize_t __n)
{
  uint64_t v4;

  if (a1)
  {
    memset_s(a1, __n, 0, __n);
    free(a1);
    v4 = qword_100340CB8 - __n;
    if (qword_100340CB8 < __n)
      v4 = 0;
    qword_100340CB8 = v4;
  }
}

void *acm_mem_alloc(size_t size)
{
  void *result;

  result = malloc_type_calloc(1uLL, size, 0xDB9956F0uLL);
  if (result)
    qword_100340CC0 += size;
  return result;
}

void acm_mem_free(void *a1, rsize_t __n)
{
  uint64_t v4;

  if (a1)
  {
    memset_s(a1, __n, 0, __n);
    free(a1);
    v4 = qword_100340CC0 - __n;
    if (qword_100340CC0 < __n)
      v4 = 0;
    qword_100340CC0 = v4;
  }
}

const char *acm_mem_alloc_info(const char *result, const void *a2, uint64_t a3, const char *a4, int a5, const char *a6)
{
  const char *v6;
  const char *v7;
  const char *v8;

  if (a2)
    qword_100340CB0 += a3;
  if (gACMLoggingLevel <= 0x1Eu)
  {
    v6 = "NULL";
    if (result)
      v7 = result;
    else
      v7 = "NULL";
    if (a4)
      v8 = a4;
    else
      v8 = "NULL";
    if (a6)
      v6 = a6;
    return (const char *)printf("%s: %s: mem: type=%s ptr=%p size=%u (total=%u raw=%u data=%u types=%u) %s:%d (%s).\n", "ACM", "acm_mem_alloc_info", v7, a2, a3, qword_100340CB0, 0, qword_100340CB8, qword_100340CC0, v8, a5, v6);
  }
  return result;
}

const char *acm_mem_free_info(const char *result, const void *a2, unint64_t a3, const char *a4, int a5, const char *a6)
{
  uint64_t v6;
  const char *v7;
  const char *v8;
  const char *v9;

  if (a2)
  {
    v6 = qword_100340CB0 - a3;
    if (qword_100340CB0 < a3)
      v6 = 0;
    qword_100340CB0 = v6;
  }
  if (gACMLoggingLevel <= 0x1Eu)
  {
    v7 = "NULL";
    if (result)
      v8 = result;
    else
      v8 = "NULL";
    if (a4)
      v9 = a4;
    else
      v9 = "NULL";
    if (a6)
      v7 = a6;
    return (const char *)printf("%s: %s: mem: type=%s ptr=%p size=%u (total=%u raw=%u data=%u types=%u) %s:%d (%s).\n", "ACM", "acm_mem_free_info", v8, a2, a3, qword_100340CB0, 0, qword_100340CB8, qword_100340CC0, v9, a5, v7);
  }
  return result;
}

uint64_t sub_1000282A0(uint64_t *a1, int a2, char a3, const void *a4, size_t a5, void *a6, size_t *a7)
{
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  int v18;
  const char *v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  uint64_t v23;

  if (byte_10033ECB9 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    v18 = 136315394;
    v19 = "ACMLib";
    v20 = 2080;
    v21 = "ioKitTransport";
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: called.\n", (uint8_t *)&v18, 0x16u);
  }
  if (a1)
  {
    v14 = sub_1000288CC();
    v15 = 70;
    if ((_DWORD)v14)
    {
      v16 = v14;
    }
    else
    {
      v16 = sub_100028AAC(*a1, a2, a3, a4, a5, a6, a7);
      if ((_DWORD)v16)
        v15 = 70;
      else
        v15 = 10;
    }
  }
  else
  {
    v15 = 70;
    v16 = 4294967293;
  }
  if (v15 >= byte_10033ECB9 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    v18 = 136315650;
    v19 = "ACMLib";
    v20 = 2080;
    v21 = "ioKitTransport";
    v22 = 2048;
    v23 = (int)v16;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: returning, err = %ld.\n", (uint8_t *)&v18, 0x20u);
  }
  return v16;
}

_DWORD *ACMContextCreateWithExternalForm(_OWORD *a1, uint64_t a2)
{
  _DWORD *v4;
  int v5;
  unsigned int v6;
  uint64_t v8;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  _DWORD *v14;

  if (byte_10033ECB9 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    v10 = "ACMLib";
    v11 = 2080;
    v12 = "ACMContextCreateWithExternalForm";
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: called.\n", buf, 0x16u);
  }
  v8 = 0;
  v4 = LibCall_ACMContextCreateWithExternalForm((uint64_t (*)(uint64_t, uint64_t, _QWORD, _OWORD *, uint64_t, _QWORD *, uint64_t *))sub_1000282A0, (uint64_t)&v8, a1, a2, &byte_10033ECB9, 1);
  if (v4)
  {
    if (byte_10033ECB9 <= 0x28u && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
    {
      v5 = v4[4];
      *(_DWORD *)buf = 136315650;
      v10 = "ACMLib";
      v11 = 2080;
      v12 = "ACMContextCreateWithExternalForm";
      v13 = 1024;
      LODWORD(v14) = v5;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: CS[%u] acquired.\n", buf, 0x1Cu);
    }
    v6 = 30;
  }
  else
  {
    sub_100029084();
    v6 = 70;
  }
  if (v6 >= byte_10033ECB9 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315650;
    v10 = "ACMLib";
    v11 = 2080;
    v12 = "ACMContextCreateWithExternalForm";
    v13 = 2048;
    v14 = v4;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: returning, -> ctx = %p.\n", buf, 0x20u);
  }
  return v4;
}

uint64_t ACMContextDelete(_DWORD *a1, int a2)
{
  unsigned int v4;
  int v5;
  const char *v6;
  uint64_t v7;
  unsigned int v8;
  _DWORD *v10;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  _QWORD v16[2];

  v4 = byte_10033ECB9;
  if (byte_10033ECB9 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    v12 = "ACMLib";
    v13 = 2080;
    v14 = "ACMContextDelete";
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: called.\n", buf, 0x16u);
    v4 = byte_10033ECB9;
  }
  if (a1 && v4 <= 0x28 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    v5 = a1[4];
    v6 = "deleted";
    *(_DWORD *)buf = 136315906;
    v12 = "ACMLib";
    v14 = "ACMContextDelete";
    v13 = 2080;
    if (a2)
      v6 = "destroyed";
    v15 = 1024;
    LODWORD(v16[0]) = v5;
    WORD2(v16[0]) = 2080;
    *(_QWORD *)((char *)v16 + 6) = v6;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: CS[%u] %s.\n", buf, 0x26u);
  }
  v10 = a1;
  v7 = LibCall_ACMContextDelete((void (*)(uint64_t, uint64_t, _QWORD, void *, uint64_t, _QWORD, _QWORD))sub_1000282A0, (uint64_t)&v10, a1, a2);
  if ((_DWORD)v7)
    v8 = 70;
  else
    v8 = 10;
  if (v8 >= byte_10033ECB9 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315650;
    v12 = "ACMLib";
    v13 = 2080;
    v14 = "ACMContextDelete";
    v15 = 2048;
    v16[0] = (int)v7;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: returning, err = %ld.\n", buf, 0x20u);
  }
  return v7;
}

uint64_t sub_1000288CC()
{
  uint64_t v0;
  const __CFDictionary *v1;
  io_service_t MatchingService;
  io_object_t v3;
  unsigned int v4;
  int v6;
  const char *v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  uint64_t v11;

  if (byte_10033ECB9 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    v6 = 136315394;
    v7 = "ACMLib";
    v8 = 2080;
    v9 = "init";
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: called.\n", (uint8_t *)&v6, 0x16u);
  }
  if ((byte_100340CCC & 1) != 0)
  {
    v0 = 0;
  }
  else
  {
    v1 = IOServiceMatching("AppleCredentialManager");
    MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v1);
    if (!MatchingService)
    {
      v4 = 70;
      v0 = 4294967291;
      goto LABEL_10;
    }
    v3 = MatchingService;
    v0 = IOServiceOpen(MatchingService, mach_task_self_, 0, (io_connect_t *)&dword_100340CC8);
    if ((_DWORD)v0)
    {
      v4 = 70;
      goto LABEL_10;
    }
    IOObjectRelease(v3);
    byte_100340CCC = 1;
  }
  v4 = 10;
LABEL_10:
  if (v4 >= byte_10033ECB9 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    v6 = 136315650;
    v7 = "ACMLib";
    v8 = 2080;
    v9 = "init";
    v10 = 2048;
    v11 = (int)v0;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: returning, err = %ld.\n", (uint8_t *)&v6, 0x20u);
  }
  return v0;
}

uint64_t sub_100028AAC(uint64_t a1, int a2, char a3, const void *a4, size_t a5, void *a6, size_t *a7)
{
  _BYTE *v14;
  void *v15;
  size_t v16;
  uint64_t v17;
  uint64_t v18;
  rsize_t v19;
  unsigned int v20;
  size_t v22;
  size_t inputStructCnt;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  _BYTE v29[10];
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;

  if (byte_10033ECB9 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    v25 = "ACMLib";
    v26 = 2080;
    v27 = "performCommand";
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: called.\n", buf, 0x16u);
  }
  inputStructCnt = 0;
  v14 = LibCall_BuildCommand(a2, 0, a3, a4, a5, &inputStructCnt);
  if (v14)
  {
    v15 = v14;
    if (!a6 && a7)
    {
      v18 = 4294967293;
    }
    else
    {
      if (a7)
        v16 = *a7;
      else
        v16 = 0;
      v22 = v16;
      v17 = IOConnectCallStructMethod(dword_100340CC8, 0, v14, inputStructCnt, a6, &v22);
      v18 = v17;
      if (a1)
        LODWORD(a1) = *(_DWORD *)(a1 + 16);
      if ((_DWORD)v17)
      {
        if (byte_10033ECB9 <= 0x46u
          && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136316418;
          v25 = "ACMLib";
          v26 = 2080;
          v27 = "performCommand";
          v28 = 1024;
          *(_DWORD *)v29 = a2;
          *(_WORD *)&v29[4] = 1024;
          *(_DWORD *)&v29[6] = a1;
          v30 = 1024;
          v31 = v18;
          v32 = 1024;
          v33 = v18;
          _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: cmd(%u) on CS[%u] -> err 0x%x (%d).\n", buf, 0x2Eu);
        }
      }
      else
      {
        if (byte_10033ECB9 <= 0x28u
          && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136315906;
          v25 = "ACMLib";
          v26 = 2080;
          v27 = "performCommand";
          v28 = 1024;
          *(_DWORD *)v29 = a2;
          *(_WORD *)&v29[4] = 1024;
          *(_DWORD *)&v29[6] = a1;
          _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: cmd(%u) on CS[%u] -> ok.\n", buf, 0x22u);
        }
        v18 = 0;
        if (a7)
          *a7 = v22;
      }
    }
    v19 = inputStructCnt;
    acm_mem_free_info("<data>", v15, inputStructCnt, "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/ACMLib/ACMLib.c", 134, "performCommand");
    acm_mem_free_data(v15, v19);
    if ((_DWORD)v18)
      v20 = 70;
    else
      v20 = 10;
  }
  else
  {
    v20 = 70;
    v18 = 4294967291;
  }
  if (v20 >= byte_10033ECB9 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315650;
    v25 = "ACMLib";
    v26 = 2080;
    v27 = "performCommand";
    v28 = 2048;
    *(_QWORD *)v29 = (int)v18;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: returning, err = %ld.\n", buf, 0x20u);
  }
  return v18;
}

uint64_t ACMContextRemovePassphraseCredentialsByPurposeAndScope(_OWORD *a1, int a2, int a3)
{
  uint64_t v6;
  _OWORD *v7;
  uint64_t v8;
  unsigned int v9;
  int v11;
  const char *v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  uint64_t v16;

  if (byte_10033ECB9 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    v11 = 136315394;
    v12 = "ACMLib";
    v13 = 2080;
    v14 = "ACMContextRemovePassphraseCredentialsByPurposeAndScope";
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: called.\n", (uint8_t *)&v11, 0x16u);
  }
  if (a1 || a3 == 2)
  {
    v6 = sub_1000288CC();
    if ((_DWORD)v6)
    {
      v8 = v6;
      v9 = 70;
    }
    else
    {
      v7 = acm_mem_alloc_data(0x18uLL);
      acm_mem_alloc_info("<data>", v7, 24, "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/ACMLib/ACMLib.c", 492, "ACMContextRemovePassphraseCredentialsByPurposeAndScope");
      if (v7)
      {
        if (a1)
        {
          *v7 = *a1;
        }
        else
        {
          *(_QWORD *)v7 = 0;
          *((_QWORD *)v7 + 1) = 0;
        }
        *((_DWORD *)v7 + 4) = a2;
        *((_DWORD *)v7 + 5) = a3;
        v8 = sub_100028AAC((uint64_t)a1, 16, 0, v7, 0x18uLL, 0, 0);
        acm_mem_free_info("<data>", v7, 0x18uLL, "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/ACMLib/ACMLib.c", 513, "ACMContextRemovePassphraseCredentialsByPurposeAndScope");
        acm_mem_free_data(v7, 0x18uLL);
        if ((_DWORD)v8)
          v9 = 70;
        else
          v9 = 10;
      }
      else
      {
        v9 = 70;
        v8 = 4294967292;
      }
    }
  }
  else
  {
    v9 = 70;
    v8 = 4294967293;
  }
  if (v9 >= byte_10033ECB9 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    v11 = 136315650;
    v12 = "ACMLib";
    v13 = 2080;
    v14 = "ACMContextRemovePassphraseCredentialsByPurposeAndScope";
    v15 = 2048;
    v16 = (int)v8;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: returning, err = %ld.\n", (uint8_t *)&v11, 0x20u);
  }
  return v8;
}

void sub_100029084()
{
  unsigned __int8 v0;
  unsigned int v1;
  uint32_t outputCnt;
  uint64_t output;
  uint8_t buf[4];
  const char *v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  int v9;

  if (byte_10033ECB9 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    v5 = "ACMLib";
    v6 = 2080;
    v7 = "updateLogLevelFromKext";
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: called.\n", buf, 0x16u);
  }
  output = 0;
  outputCnt = 1;
  if (IOConnectCallScalarMethod(dword_100340CC8, 2u, 0, 0, &output, &outputCnt))
    goto LABEL_8;
  v0 = output;
  v1 = output;
  byte_10033ECB9 = output;
  if (output <= 0x1EuLL && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315650;
    v5 = "ACMLib";
    v6 = 2080;
    v7 = "updateLogLevelFromKext";
    v8 = 1024;
    v9 = v0;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: log level set to %d.\n", buf, 0x1Cu);
LABEL_8:
    v1 = byte_10033ECB9;
  }
  if (v1 <= 0xA && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    v5 = "ACMLib";
    v6 = 2080;
    v7 = "updateLogLevelFromKext";
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: returning.\n", buf, 0x16u);
  }
}

_BYTE *LibCall_BuildCommand(char a1, char a2, char a3, const void *a4, size_t a5, _QWORD *a6)
{
  _BYTE *v12;
  BOOL v13;

  if (gACMLoggingLevel <= 0xAu)
    printf("%s: %s: called.\n", "ACM", "LibCall_BuildCommand");
  v12 = 0;
  if (a5)
    v13 = a4 == 0;
  else
    v13 = 0;
  if (!v13 && a6)
  {
    if (a5 >= 0xFFFFFFFFFFFFFFF8)
    {
      v12 = 0;
    }
    else
    {
      v12 = acm_mem_alloc_data(a5 + 8);
      acm_mem_alloc_info("<data>", v12, a5 + 8, "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c", 22, "LibCall_BuildCommand");
      if (v12)
      {
        *a6 = a5 + 8;
        *(_DWORD *)v12 = 1396920900;
        v12[4] = a1;
        v12[5] = a2;
        v12[6] = a3;
        if (a5)
          memcpy(v12 + 8, a4, a5);
      }
    }
  }
  if (gACMLoggingLevel <= 0xAu)
    printf("%s: %s: returning.\n", "ACM", "LibCall_BuildCommand");
  return v12;
}

_DWORD *LibCall_ACMContextCreateWithExternalForm(uint64_t (*a1)(uint64_t, uint64_t, _QWORD, _OWORD *, uint64_t, _QWORD *, uint64_t *), uint64_t a2, _OWORD *a3, uint64_t a4, _BYTE *a5, int a6)
{
  _DWORD *v12;
  unsigned int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  uint64_t v20;
  _QWORD v21[2];

  if (gACMLoggingLevel <= 0xAu)
    printf("%s: %s: called.\n", "ACM", "LibCall_ACMContextCreateWithExternalForm");
  v12 = 0;
  v13 = 70;
  v14 = -3;
  if (a1 && a3 && a4 == 16)
  {
    memset(v21, 0, 9);
    if (a6)
    {
      v20 = 9;
      v15 = a1(a2, 37, 0, a3, 16, v21, &v20);
      if (!v15)
      {
        if (v20 == 9)
        {
          v14 = 0;
          goto LABEL_19;
        }
        v14 = -5;
        goto LABEL_28;
      }
      v14 = v15;
      if (v15 != -3)
        goto LABEL_28;
    }
    v20 = 5;
    v16 = a1(a2, 18, 0, a3, 16, v21, &v20);
    if (v20 == 5)
      v17 = 0;
    else
      v17 = -5;
    if (v16)
      v14 = v16;
    else
      v14 = v17;
    if (!v16 && v20 == 5)
    {
LABEL_19:
      if (LODWORD(v21[0]))
      {
        v12 = acm_mem_alloc(0x14uLL);
        acm_mem_alloc_info("ACMHandleWithPayload", v12, 20, "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c", 128, "LibCall_ACMContextCreateWithExternalForm");
        if (!v12)
        {
          v13 = 70;
          v14 = -4;
          goto LABEL_31;
        }
        v18 = *(_DWORD *)((char *)v21 + 5);
        *(_OWORD *)v12 = *a3;
        v12[4] = v18;
        if (a5)
          *a5 = BYTE4(v21[0]);
        if (v14)
        {
          acm_mem_free_info("ACMHandleWithPayload", v12, 0x14uLL, "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c", 147, "LibCall_ACMContextCreateWithExternalForm");
          acm_mem_free(v12, 0x14uLL);
LABEL_29:
          v13 = 70;
          goto LABEL_31;
        }
      }
      else
      {
        v12 = 0;
      }
      goto LABEL_30;
    }
LABEL_28:
    v12 = 0;
    if (v14)
      goto LABEL_29;
LABEL_30:
    v14 = 0;
    v13 = 10;
  }
LABEL_31:
  if (v13 >= gACMLoggingLevel)
    printf("%s: %s: returning, err = %ld.\n", "ACM", "LibCall_ACMContextCreateWithExternalForm", v14);
  return v12;
}

uint64_t LibCall_ACMContextDelete(void (*a1)(uint64_t, uint64_t, _QWORD, void *, uint64_t, _QWORD, _QWORD), uint64_t a2, void *a3, int a4)
{
  uint64_t v8;
  unsigned int v9;

  if (gACMLoggingLevel <= 0xAu)
    printf("%s: %s: called.\n", "ACM", "LibCall_ACMContextDelete");
  if (a1 && a3)
  {
    if (a4)
      a1(a2, 2, 0, a3, 16, 0, 0);
    goto LABEL_7;
  }
  if (a3)
  {
LABEL_7:
    acm_mem_free_info("ACMHandleWithPayload", a3, 0x14uLL, "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c", 172, "LibCall_ACMContextDelete");
    acm_mem_free(a3, 0x14uLL);
    v8 = 0;
    v9 = 10;
    goto LABEL_8;
  }
  v9 = 70;
  v8 = 4294967293;
LABEL_8:
  if (v9 >= gACMLoggingLevel)
    printf("%s: %s: returning, err = %ld.\n", "ACM", "LibCall_ACMContextDelete", (int)v8);
  return v8;
}

BOOL sub_100029728(id a1, __OpaqueSecDbConnection *a2)
{
  NSObject *v2;
  uint8_t v4[16];

  v2 = sub_10000EF14("keychain");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Keychain initialized!", v4, 2u);
  }
  return 1;
}

void sub_100029B1C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100029CF4(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100029E4C(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_10002A058(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  void *v17;
  id *v18;

  objc_destroyWeak(v18);
  objc_destroyWeak(&location);
  objc_sync_exit(v17);
  _Unwind_Resume(a1);
}

void sub_10002A09C(uint64_t a1, void *a2, void *a3)
{
  id v5;
  _QWORD *WeakRetained;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  id v11;

  v11 = a2;
  v5 = a3;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    if (objc_msgSend(v11, "isEqualToString:", CFSTR("allowed-runtime"))
      && (v7 = objc_opt_class(NSNumber), (objc_opt_isKindOfClass(v5, v7) & 1) != 0))
    {
      WeakRetained[4] = objc_msgSend(v5, "longValue");
    }
    else if (objc_msgSend(v11, "isEqualToString:", CFSTR("reset-period"))
           && (v8 = objc_opt_class(NSNumber), (objc_opt_isKindOfClass(v5, v8) & 1) != 0))
    {
      WeakRetained[5] = objc_msgSend(v5, "longValue");
    }
    else if (objc_msgSend(v11, "isEqualToString:", CFSTR("check-period"))
           && (v9 = objc_opt_class(NSNumber), (objc_opt_isKindOfClass(v5, v9) & 1) != 0))
    {
      WeakRetained[6] = objc_msgSend(v5, "longValue");
    }
    else if (objc_msgSend(v11, "isEqualToString:", CFSTR("graceful-exit-time"))
           && (v10 = objc_opt_class(NSNumber), (objc_opt_isKindOfClass(v5, v10) & 1) != 0))
    {
      WeakRetained[8] = objc_msgSend(v5, "longValue");
    }
    else
    {
      objc_msgSend(*(id *)(a1 + 32), "addObject:", v11);
    }
  }

}

void sub_10002A204(uint64_t a1)
{
  id WeakRetained;
  id v2;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v2 = WeakRetained;
    objc_msgSend(WeakRetained, "runWatchdog");
    WeakRetained = v2;
  }

}

void sub_10002A234(id a1)
{
  const void *v1;
  NSObject *v2;
  uint8_t v3[16];

  v1 = sub_10000EF14("SecCritical");
  v2 = objc_claimAutoreleasedReturnValue(v1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SecWatchdog: watchdog has failed to exit securityd/secd gracefully - exiting ungracefully", v3, 2u);
  }

  exit(1);
}

void sub_10002A298(id a1)
{
  kern_return_t v1;
  uint64_t v2;
  mach_timebase_info info;

  info = (mach_timebase_info)0xAAAAAAAAAAAAAAAALL;
  v1 = mach_timebase_info(&info);
  if (v1)
  {
    _os_assumes_log(v1);
    v2 = 1;
  }
  else
  {
    v2 = info.numer / info.denom;
  }
  qword_100340CE8 = v2;
}

void sub_10002A394(uint64_t a1)
{
  id v1;
  void *v2;

  v1 = objc_alloc_init(*(Class *)(a1 + 32));
  v2 = (void *)qword_100340CD0;
  qword_100340CD0 = (uint64_t)v1;

}

uint64_t start()
{
  malloc_zone_t *zone;
  NSObject *v1;
  NSObject *v2;
  NSObject *v3;
  id v4;
  const void *v5;
  NSObject *v6;
  void *v7;
  void *v8;
  const void *v9;
  NSObject *v10;
  int v11;
  NSObject *global_queue;
  NSObject *v13;
  CFTypeRef v14;
  id v15;
  _xpc_connection_s *mach_service;
  _xpc_connection_s *v17;
  const void *v18;
  NSObject *v19;
  void *v20;
  void *v21;
  id v22;
  NSObject *v24;
  CFTypeRef cf[5];
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  int v29;
  uint8_t v30[4];
  int v31;
  __int128 buf;
  void (*v33)(uint64_t, void *);
  void *v34;
  uint64_t *v35;

  zone = malloc_create_zone(0, 0);
  malloc_set_zone_name(zone, "ICU");
  LODWORD(cf[0]) = 0;
  u_setMemoryFunctions(zone, &malloc_zone_malloc, &malloc_zone_realloc, &malloc_zone_free, cf);
  if (LODWORD(cf[0]))
  {
    v1 = sub_10000EF14("SecError");
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 67109120;
      DWORD1(buf) = cf[0];
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Could not set up ICU malloc zone; err = %i",
        (uint8_t *)&buf,
        8u);
    }
  }
  +[NSError _setFileNameLocalizationEnabled:](NSError, "_setFileNameLocalizationEnabled:", 0);
  if (!sub_100033B04())
    goto LABEL_14;
  if (qword_100340E20 != -1)
    dispatch_once(&qword_100340E20, &stru_1002DB938);
  if (byte_100340E18)
    goto LABEL_14;
  if (qword_100340E10 != -1)
    dispatch_once(&qword_100340E10, &stru_1002DB8F8);
  if (byte_100340E0C == 1)
  {
    v2 = sub_10000EF14("keychain_handle");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "using system keychain handle", (uint8_t *)&buf, 2u);
    }
    dword_1003414E0 = -6;
  }
  else
  {
LABEL_14:
    v3 = sub_10000EF14("keychain_handle");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "using normal handle", (uint8_t *)&buf, 2u);
    }
  }
  if (qword_100340E20 != -1)
    dispatch_once(&qword_100340E20, &stru_1002DB938);
  if (byte_100340E18)
  {
    v26 = 0;
    v27 = &v26;
    v28 = 0x2020000000;
    v29 = -67585;
    v4 = objc_msgSend(objc_alloc((Class)NSXPCConnection), "initWithServiceName:", CFSTR("com.apple.security.KeychainDBMover"));
    v5 = sub_10000EF14("SecKeychainMoveUserDb");
    v6 = objc_claimAutoreleasedReturnValue(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(_QWORD *)((char *)&buf + 4) = v4;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "moverCxn: %@", (uint8_t *)&buf, 0xCu);
    }

    v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSXPCInterface interfaceWithProtocol:](NSXPCInterface, "interfaceWithProtocol:", &OBJC_PROTOCOL___KeychainDBMoverProtocol));
    objc_msgSend(v4, "setRemoteObjectInterface:", v7);

    objc_msgSend(v4, "resume");
    *(_QWORD *)&buf = _NSConcreteStackBlock;
    *((_QWORD *)&buf + 1) = 3221225472;
    v33 = sub_10002EB4C;
    v34 = &unk_1002DAF78;
    v35 = &v26;
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "synchronousRemoteObjectProxyWithErrorHandler:", &buf));
    cf[0] = _NSConcreteStackBlock;
    cf[1] = (CFTypeRef)3221225472;
    cf[2] = sub_10002EC1C;
    cf[3] = &unk_1002DAF78;
    cf[4] = &v26;
    objc_msgSend(v8, "moveUserDbWithReply:", cf);

    objc_msgSend(v4, "invalidate");
    v9 = sub_10000EF14("SecKeychainMoveUserDb");
    v10 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      v11 = *((_DWORD *)v27 + 6);
      *(_DWORD *)v30 = 67109120;
      v31 = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "returning %d", v30, 8u);
    }

    _Block_object_dispose(&v26, 8);
  }
  signal(15, (void (__cdecl *)(int))1);
  global_queue = dispatch_get_global_queue(25, 0);
  qword_100340CF0 = (uint64_t)dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_signal, 0xFuLL, 0, global_queue);
  dispatch_source_set_event_handler((dispatch_source_t)qword_100340CF0, &stru_1002DAB60);
  dispatch_activate((dispatch_object_t)qword_100340CF0);
  byte_1003410A8 = 1;
  byte_100341208 = 1;
  byte_100341040 = 1;
  if (qword_100341380 != -1)
    dispatch_once(&qword_100341380, &stru_1002E8E88);
  if (qword_100340D90 != -1)
    dispatch_once(&qword_100340D90, &stru_1002DB338);
  gSecurityd = off_10033ECC0;
  qword_10033EF68 = (uint64_t)sub_100029724;
  qword_10033EF78 = -[LocalSecuritydXPCServer initWithSecurityClient:fakeEntitlements:]([LocalSecuritydXPCServer alloc], "initWithSecurityClient:fakeEntitlements:", SecSecurityClientGet(), &__NSDictionary0__struct);
  qword_10033EF70 = (uint64_t)sub_10000FBDC;
  cf[0] = 0;
  if (!sub_100011A30(0, 1, 0, (uint64_t)cf, (uint64_t)&stru_1002DAAD8) || cf[0])
  {
    v13 = sub_10000EF14("SecError");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(CFTypeRef *)((char *)&buf + 4) = cf[0];
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Couldn't bring up keychain: %@", (uint8_t *)&buf, 0xCu);
    }
    v14 = cf[0];
    if (cf[0])
    {
      cf[0] = 0;
      CFRelease(v14);
    }
  }
  v15 = +[SecdWatchdog watchdog](SecdWatchdog, "watchdog");
  mach_service = xpc_connection_create_mach_service("com.apple.securityd", 0, 1uLL);
  if (!mach_service)
  {
    v24 = sub_10000EF14("SecCritical");
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = "com.apple.securityd";
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "security failed to register xpc listener for %s, exiting", (uint8_t *)&buf, 0xCu);
    }
    abort();
  }
  v17 = mach_service;
  xpc_connection_set_event_handler(mach_service, &stru_1002DABA0);
  xpc_connection_resume(v17);
  xpc_activity_register("com.apple.securityd.daily", XPC_ACTIVITY_CHECK_IN, &stru_1002DACA0);
  xpc_activity_register("com.apple.securityd.entropyhealth", XPC_ACTIVITY_CHECK_IN, &stru_1002DACE0);
  xpc_activity_register("com.apple.securityd.prng", XPC_ACTIVITY_CHECK_IN, &stru_1002DAD20);
  xpc_activity_register("com.apple.securityd.kcsharing.resync", XPC_ACTIVITY_CHECK_IN, &stru_1002DAD60);
  if (qword_100340D10 != -1)
    dispatch_once(&qword_100340D10, &stru_1002DAF98);
  if (qword_1003416C8 != -1)
    dispatch_once(&qword_1003416C8, &stru_1002ED9D8);
  if (qword_100340F88 != -1)
    dispatch_once(&qword_100340F88, &stru_1002DC9B8);
  if (qword_100341210 != -1)
    dispatch_once(&qword_100341210, &stru_1002DF648);
  if (qword_100340F50 != -1)
    dispatch_once(&qword_100340F50, &stru_1002DC590);
  v18 = sub_10000EF14("keychainitemupgrade");
  v19 = objc_claimAutoreleasedReturnValue(v18);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "performing KeychainItemUpgradeRequestServerInitialize", (uint8_t *)&buf, 2u);
  }

  v20 = (void *)objc_claimAutoreleasedReturnValue(+[KeychainItemUpgradeRequestServer server](KeychainItemUpgradeRequestServer, "server"));
  v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "controller"));
  objc_msgSend(v21, "triggerKeychainItemUpdateRPC:", &stru_1002E8DD0);

  v22 = +[KCSharingXPCListenerDelegate sharedInstance](KCSharingXPCListenerDelegate, "sharedInstance");
  CFRunLoopRun();
  return 0;
}

void sub_10002ABB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10002ABD8(id a1, _xpc_activity_s *a2)
{
  unsigned int v2;
  uint64_t v3;
  NSObject *v4;
  void *v5;
  uint8_t v6[16];

  if (xpc_activity_get_state(a2) == 2)
  {
    if (objc_opt_class(CKDatabase))
    {
      v2 = atomic_load((unsigned int *)&unk_100340ED0);
      if (v2 <= 1)
      {
        v3 = KCSharingLogObject(CFSTR("KCSharingPerformResync"));
        v4 = objc_claimAutoreleasedReturnValue(v3);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v6 = 0;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Requesting resync", v6, 2u);
        }

        v5 = (void *)objc_claimAutoreleasedReturnValue(+[KCSharingSyncController sharedInstance](KCSharingSyncController, "sharedInstance"));
        objc_msgSend(v5, "resyncFromRPC:completion:", 0, &stru_1002E8F68);

      }
    }
  }
}

void sub_10002ACA0(id a1, _xpc_activity_s *a2)
{
  int v2;
  int v3;
  int v4;
  NSObject *v5;
  const char *v6;
  int v7;
  NSObject *v8;
  uint32_t v9;
  char *v10;
  size_t v11;
  uint64_t v12;
  NSObject *v13;
  size_t v14;
  ssize_t v15;
  int v16;
  size_t __nbyte;
  void **v18;
  uint8_t buf[4];
  size_t v20;

  if (xpc_activity_get_state(a2) != 2)
    return;
  v18 = 0;
  v2 = open("/dev/random", 1);
  if (v2 == -1)
  {
    v5 = sub_10000EF14("SecError");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v7 = *__error();
      *(_DWORD *)buf = 67109120;
      LODWORD(v20) = v7;
      v6 = "failed to open /dev/random (%d)";
      goto LABEL_8;
    }
  }
  else
  {
    v3 = sub_1000240CC(-1, 13, 4u, 0, 0, &v18);
    if (!v3)
    {
      __nbyte = 0;
      v10 = (char *)sub_100024E28((uint64_t *)v18, &__nbyte);
      v11 = __nbyte;
      v12 = ccec_cp_256();
      if (v11 > (((unint64_t)(cczp_bitlen(v12) + 7) >> 2) | 1))
      {
        v13 = sub_10000EF14("SecError");
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          goto LABEL_10;
        *(_DWORD *)buf = 134217984;
        v20 = __nbyte;
        v6 = "invalid pub key (%zu)";
        v8 = v13;
        v9 = 12;
        goto LABEL_9;
      }
      v14 = __nbyte;
      if (!__nbyte)
        goto LABEL_10;
      while (1)
      {
        v15 = write(v2, v10, v14);
        if (v15 == -1)
          break;
        v10 += v15;
        v14 = __nbyte - v15;
        __nbyte -= v15;
        if (!__nbyte)
          goto LABEL_10;
      }
      v5 = sub_10000EF14("SecError");
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        goto LABEL_10;
      v16 = *__error();
      *(_DWORD *)buf = 67109120;
      LODWORD(v20) = v16;
      v6 = "failed to write /dev/random (%d)";
LABEL_8:
      v8 = v5;
      v9 = 8;
LABEL_9:
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v6, buf, v9);
      goto LABEL_10;
    }
    v4 = v3;
    v5 = sub_10000EF14("SecError");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      LODWORD(v20) = v4;
      v6 = "failed to create refkey (%d)";
      goto LABEL_8;
    }
  }
LABEL_10:
  if (v18)
    sub_100024478((uint64_t *)&v18);
  if ((v2 & 0x80000000) == 0)
    close(v2);
}

void sub_10002AF00(id a1, _xpc_activity_s *a2)
{
  if (xpc_activity_get_state(a2) == 2)
    SecCoreAnalyticsSendKernEntropyAnalytics();
}

void sub_10002AF28(id a1, _xpc_activity_s *a2)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  unsigned int v6;
  uint64_t v7;
  NSObject *v8;
  void *v9;
  uint8_t v10[16];

  if (xpc_activity_get_state(a2) == 2)
  {
    v2 = objc_autoreleasePoolPush();
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSViewManager manager](CKKSViewManager, "manager"));
    objc_msgSend(v3, "xpc24HrNotification");

    objc_autoreleasePoolPop(v2);
    v4 = objc_autoreleasePoolPush();
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[OTManager manager](OTManager, "manager"));
    objc_msgSend(v5, "xpc24HrNotification");

    objc_autoreleasePoolPop(v4);
    if (objc_opt_class(CKDatabase))
    {
      v6 = atomic_load((unsigned int *)&unk_100340ED0);
      if (v6 <= 1)
      {
        v7 = KCSharingLogObject(CFSTR("KCSharingPerformMaintenance"));
        v8 = objc_claimAutoreleasedReturnValue(v7);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v10 = 0;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Requesting maintenance", v10, 2u);
        }

        v9 = (void *)objc_claimAutoreleasedReturnValue(+[KCSharingSyncController sharedInstance](KCSharingSyncController, "sharedInstance"));
        objc_msgSend(v9, "performMaintenanceWithCompletion:", &stru_1002E8F48);

      }
    }
  }
}

BOOL sub_10002B044(int a1, CFDataRef theData)
{
  size_t Length;
  const UInt8 *BytePtr;
  size_t v6;
  ssize_t v7;

  Length = CFDataGetLength(theData);
  BytePtr = CFDataGetBytePtr(theData);
  do
  {
    v6 = Length;
    if (!Length)
      break;
    v7 = write(a1, BytePtr, Length);
    Length -= v7;
    BytePtr += v7;
  }
  while (v7 > 0);
  return v6 == 0;
}

CFDataRef sub_10002B0B4(int a1, const UInt8 **a2, CFIndex *a3)
{
  timespec v6;
  off_t st_size;
  const UInt8 *v8;
  stat v10;

  v6.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v6.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v10.st_blksize = v6;
  *(timespec *)v10.st_qspare = v6;
  v10.st_birthtimespec = v6;
  *(timespec *)&v10.st_size = v6;
  v10.st_mtimespec = v6;
  v10.st_ctimespec = v6;
  *(timespec *)&v10.st_uid = v6;
  v10.st_atimespec = v6;
  *(timespec *)&v10.st_dev = v6;
  if (fstat(a1, &v10) < 0)
    return 0;
  st_size = v10.st_size;
  *a3 = v10.st_size;
  v8 = (const UInt8 *)mmap(0, st_size, 1, 1, a1, 0);
  *a2 = v8;
  if (v8 == (const UInt8 *)-1)
    return 0;
  else
    return CFDataCreateWithBytesNoCopy(0, v8, *a3, kCFAllocatorNull);
}

void sub_10002B15C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void *v4;
  char v5;

  v4 = *(void **)(a1 + 40);
  v5 = sub_100203908(a2, a3, a4, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  xpc_dictionary_set_BOOL(v4, "status", v5);
}

void sub_10002B1A4(void *a1, uint64_t a2)
{
  const char *v4;
  const UInt8 *v5;
  const char *v6;

  v4 = sub_10002B6E4(a1, "userlabel");
  v5 = sub_10002B71C(a1);
  v6 = sub_10002B6E4(a1, "dsid");
  if (v4 && v5)
  {
    (*(void (**)(uint64_t, const char *, const UInt8 *, const char *))(a2 + 16))(a2, v4, v5, v6);
  }
  else if (!v4)
  {
    goto LABEL_6;
  }
  CFRelease(v4);
LABEL_6:
  if (v5)
    CFRelease(v5);
  if (v6)
    CFRelease(v6);
}

void sub_10002B250(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v3;
  char v4;

  v3 = *(void **)(a1 + 40);
  v4 = sub_100204A84(a2, a3, 0, (uint64_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  xpc_dictionary_set_BOOL(v3, "status", v4);
}

void sub_10002B294(void *a1, uint64_t a2)
{
  const char *v4;
  const UInt8 *v5;
  const UInt8 *v6;
  BOOL v7;

  v4 = sub_10002B6E4(a1, "userlabel");
  v5 = sub_10002B71C(a1);
  v6 = v5;
  if (v4)
    v7 = v5 == 0;
  else
    v7 = 1;
  if (v7)
  {
    if (!v4)
    {
      if (!v5)
        return;
      goto LABEL_8;
    }
  }
  else
  {
    (*(void (**)(uint64_t, const char *, const UInt8 *))(a2 + 16))(a2, v4, v5);
  }
  CFRelease(v4);
  if (v6)
LABEL_8:
    CFRelease(v6);
}

void sub_10002B320(uint64_t a1, uint64_t a2, uint64_t a3, os_signpost_id_t a4)
{
  void *v4;
  char v5;

  v4 = *(void **)(a1 + 40);
  v5 = sub_100204A84(a2, a3, a4, (uint64_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  xpc_dictionary_set_BOOL(v4, "status", v5);
}

void sub_10002B368(uint64_t a1, uint64_t a2, int a3)
{
  void *v3;
  int64_t v4;

  v3 = *(void **)(a1 + 40);
  v4 = (int)sub_100202D4C(a2, a3, (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  xpc_dictionary_set_int64(v3, "status", v4);
}

void sub_10002B3AC(void *a1, uint64_t a2)
{
  const char *v4;
  int64_t int64;

  v4 = sub_10002B6E4(a1, "viewname");
  int64 = xpc_dictionary_get_int64(a1, "viewactioncode");
  if (v4)
  {
    (*(void (**)(uint64_t, const char *, int64_t))(a2 + 16))(a2, v4, int64);
    CFRelease(v4);
  }
}

void *sub_10002B420(void *a1, const char *a2)
{
  xpc_object_t value;
  void *v3;
  uint64_t v4;
  char *bytes_ptr;
  size_t length;
  CFTypeRef v7;
  CFTypeRef v9;
  CFTypeRef cf;

  v9 = 0;
  value = xpc_dictionary_get_value(a1, a2);
  v3 = value;
  if (!value)
    return v3;
  cf = 0;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_data)
  {
    sub_100032660(1, CFSTR("com.apple.security.xpc"), 0, &v9, v4, CFSTR("xpcSetDER not data, got %@"), v3);
LABEL_6:
    v3 = 0;
    goto LABEL_8;
  }
  bytes_ptr = (char *)xpc_data_get_bytes_ptr(v3);
  length = xpc_data_get_length(v3);
  if ((char *)sub_1000330CC(kCFAllocatorDefault, &cf, &v9, (uint64_t)bytes_ptr, (uint64_t)&bytes_ptr[length]) != &bytes_ptr[length])
  {
    sub_100019F20(-26275, (__CFString **)&v9, CFSTR("trailing garbage at end of SecAccessControl data"));
    if (cf)
      CFRelease(cf);
    goto LABEL_6;
  }
  v3 = (void *)cf;
LABEL_8:
  v7 = v9;
  if (v9)
  {
    v9 = 0;
    CFRelease(v7);
  }
  return v3;
}

void sub_10002B514(void *a1, const void *a2, uint64_t a3)
{
  void *XPCObjectWithArrayOfPeerInfo;
  void *v6;

  if (a2)
  {
    XPCObjectWithArrayOfPeerInfo = (void *)CreateXPCObjectWithArrayOfPeerInfo(a2, a3);
    if (XPCObjectWithArrayOfPeerInfo)
    {
      v6 = XPCObjectWithArrayOfPeerInfo;
      xpc_dictionary_set_value(a1, "status", XPCObjectWithArrayOfPeerInfo);
      xpc_release(v6);
    }
    CFRelease(a2);
  }
}

void sub_10002B578(void *a1, const void *a2)
{
  void *v4;

  if (a2)
  {
    v4 = (void *)_CFXPCCreateXPCObjectFromCFObject(a2);
    xpc_dictionary_set_value(a1, "status", v4);
    xpc_release(v4);
    CFRelease(a2);
  }
}

CFDataRef sub_10002B5D4(void *a1, uint64_t a2)
{
  const UInt8 *data;
  CFDataRef result;
  const __CFString *v5;
  size_t length;

  length = 0;
  data = (const UInt8 *)xpc_dictionary_get_data(a1, "data", &length);
  if (!data)
  {
    v5 = CFSTR("missing CFDataRef info");
LABEL_6:
    SOSCreateError(1034, v5, 0, a2);
    return 0;
  }
  result = CFDataCreate(0, data, length);
  if (!result)
  {
    v5 = CFSTR("could not allocate CFDataRef info");
    goto LABEL_6;
  }
  return result;
}

uint64_t sub_10002B650(void *a1, CFTypeRef *a2)
{
  char *data;
  char *v5;
  size_t length;

  length = 0;
  data = (char *)xpc_dictionary_get_data(a1, "peer-info", &length);
  v5 = data;
  sub_10003268C(data != 0, a2, CFSTR("No data for key %s"), "peer-info");
  if (data)
    return SOSPeerInfoCreateFromDER(kCFAllocatorDefault, a2, &v5, &data[length]);
  else
    return 0;
}

const char *sub_10002B6E4(void *a1, const char *a2)
{
  const char *result;

  result = xpc_dictionary_get_string(a1, a2);
  if (result)
    return (const char *)CFStringCreateWithCString(kCFAllocatorDefault, result, 0x8000100u);
  return result;
}

const UInt8 *sub_10002B71C(void *a1)
{
  const UInt8 *result;
  size_t length;

  length = 0;
  result = (const UInt8 *)xpc_dictionary_get_data(a1, "password", &length);
  if (result)
    return (const UInt8 *)CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, result, length, kCFAllocatorNull);
  return result;
}

void sub_10002B770(id a1)
{
  NSObject *v1;
  uint8_t v2[16];

  v1 = sub_10000EF14("signal");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "SIGTERM, exiting when clean ✌️", v2, 2u);
  }
  xpc_transaction_exit_clean();
}

void sub_10002B7D8(id a1)
{
  const __CFDictionary *v1;
  const __CFDictionary *v2;
  void *value;

  v1 = (const __CFDictionary *)MKBUserTypeDeviceMode(0, 0);
  value = 0;
  if (v1)
  {
    v2 = v1;
    if (CFDictionaryGetValueIfPresent(v1, kMKBDeviceModeKey, (const void **)&value))
    {
      if (CFEqual(value, kMKBDeviceModeMultiUser))
        byte_100340D00 = 1;
    }
    CFRelease(v2);
  }
}

uint64_t sub_10002B854(uint64_t a1, CFTypeRef cf1)
{
  uint64_t result;

  result = CFEqual(cf1, *(CFTypeRef *)(a1 + 40));
  if ((_DWORD)result)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  return result;
}

uint64_t sub_10002B894(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_10002D6C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  _Block_object_dispose(&a28, 8);
  _Block_object_dispose(&a32, 8);
  _Unwind_Resume(a1);
}

void sub_10002D8E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10002DBE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_10002E0DC(id a1, __OpaqueSecDbConnection *a2)
{
  return 1;
}

BOOL sub_10002E0E4(uint64_t a1, uint64_t a2)
{
  CFTypeRef *v3;
  uint64_t v4;

  v3 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  v4 = sqlite3_wal_checkpoint_v2(*(sqlite3 **)(a2 + 64), 0, 1, 0, 0);
  return sub_100030C9C(a2, v4, v3, CFSTR("wal_checkpoint(FULL)"));
}

BOOL sub_10002E138(uint64_t a1, uint64_t a2)
{
  return sub_10012F100(a2, *(_QWORD *)(a1 + 32), 0, (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
}

BOOL sub_10002E154(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  __CFString **v3;
  uint64_t v4;
  _BOOL8 v5;
  __int128 v7;
  uint64_t v8;
  CFTypeRef cf;
  unint64_t v10;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v3 = (__CFString **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  cf = 0;
  v10 = 0xAAAAAAAA00000000;
  v7 = *(_OWORD *)(a1 + 48);
  v8 = a2;
  v4 = v7;
  *(_QWORD *)(v7 + 104) = -1;
  sub_100012178(kSecAttrTombstone, kCFBooleanFalse, v4);
  v5 = sub_100012878((uint64_t)sub_10012E734, (uint64_t)&v7, v3);
  if (v5)
  {
    *(_QWORD *)(v2 + 24) = cf;
  }
  else if (cf)
  {
    CFRelease(cf);
  }
  return v5;
}

void sub_10002E1F8(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v4;
  id v5;
  uint64_t v6;
  id v7;

  v4 = *(_QWORD *)(a1 + 32);
  v5 = a2;
  v6 = CKXPCSuitableError(a3);
  v7 = (id)objc_claimAutoreleasedReturnValue(v6);
  (*(void (**)(uint64_t, id, id))(v4 + 16))(v4, v5, v7);

}

void sub_10002E25C(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v4;
  id v5;
  uint64_t v6;
  id v7;

  v4 = *(_QWORD *)(a1 + 32);
  v5 = a2;
  v6 = CKXPCSuitableError(a3);
  v7 = (id)objc_claimAutoreleasedReturnValue(v6);
  (*(void (**)(uint64_t, id, id))(v4 + 16))(v4, v5, v7);

}

void sub_10002E2C0(_QWORD *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  void *v7;
  void (*v8)(void);
  const void *v9;
  NSObject *v10;
  uint64_t v11;
  _QWORD *v12;
  const void *v13;
  int v14;
  uint64_t v15;
  __int16 v16;
  void *v17;

  v5 = a2;
  v6 = a3;
  v7 = v6;
  if (!v5 || v6)
  {
    v9 = sub_10000EF14("ckkscurrent");
    v10 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      v11 = a1[4];
      v14 = 138412546;
      v15 = v11;
      v16 = 2112;
      v17 = v7;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "CKKS didn't find a PCS Identity for (%@): %@", (uint8_t *)&v14, 0x16u);
    }

    v8 = *(void (**)(void))(a1[5] + 16);
  }
  else
  {
    v8 = *(void (**)(void))(a1[5] + 16);
  }
  v8();
  if (qword_1003412C8 != -1)
    dispatch_once(&qword_1003412C8, &stru_1002E7860);
  if (byte_1003412C0)
  {
    v12 = (_QWORD *)a1[6];
    v13 = (const void *)v12[3];
    if (v13)
    {
      v12[3] = 0;
      CFRelease(v13);
      v12 = (_QWORD *)a1[6];
    }
    free(v12);
  }

}

void sub_10002E420(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v4;
  id v5;
  uint64_t v6;
  id v7;

  v4 = *(_QWORD *)(a1 + 32);
  v5 = a2;
  v6 = CKXPCSuitableError(a3);
  v7 = (id)objc_claimAutoreleasedReturnValue(v6);
  (*(void (**)(uint64_t, id, id))(v4 + 16))(v4, v5, v7);

}

void sub_10002E484(_QWORD *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  void *v7;
  void (*v8)(void);
  const void *v9;
  NSObject *v10;
  uint64_t v11;
  _QWORD *v12;
  const void *v13;
  int v14;
  uint64_t v15;
  __int16 v16;
  void *v17;

  v5 = a2;
  v6 = a3;
  v7 = v6;
  if (!v5 || v6)
  {
    v9 = sub_10000EF14("ckkscurrent");
    v10 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      v11 = a1[4];
      v14 = 138412546;
      v15 = v11;
      v16 = 2112;
      v17 = v7;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "CKKS didn't find a current item for (%@): %@", (uint8_t *)&v14, 0x16u);
    }

    v8 = *(void (**)(void))(a1[5] + 16);
  }
  else
  {
    v8 = *(void (**)(void))(a1[5] + 16);
  }
  v8();
  if (qword_1003412C8 != -1)
    dispatch_once(&qword_1003412C8, &stru_1002E7860);
  if (byte_1003412C0)
  {
    v12 = (_QWORD *)a1[6];
    v13 = (const void *)v12[3];
    if (v13)
    {
      v12[3] = 0;
      CFRelease(v13);
      v12 = (_QWORD *)a1[6];
    }
    free(v12);
  }

}

void sub_10002E5E4(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  uint64_t v6;
  id v7;
  id v8;
  uint64_t v9;
  id v10;

  v6 = *(_QWORD *)(a1 + 32);
  v7 = a3;
  v8 = a2;
  v9 = CKXPCSuitableError(a4);
  v10 = (id)objc_claimAutoreleasedReturnValue(v9);
  (*(void (**)(uint64_t, id, id, id))(v6 + 16))(v6, v8, v7, v10);

}

void sub_10002E65C(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  const void *v7;
  NSObject *v8;
  NSObject *v9;
  void *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  id v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  _QWORD *v19;
  const void *v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  _QWORD v24[4];
  id v25;
  id v26;
  uint64_t v27;
  uint8_t buf[4];
  uint64_t v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  void *v33;
  __int16 v34;
  id v35;

  v5 = a2;
  v6 = a3;
  v7 = sub_10000EF14("ckkscurrent");
  v8 = objc_claimAutoreleasedReturnValue(v7);
  v9 = v8;
  if (!v5 || v6)
  {
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v16 = *(_QWORD *)(a1 + 32);
      v17 = *(_QWORD *)(a1 + 40);
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "uuid"));
      *(_DWORD *)buf = 138413058;
      v29 = v16;
      v30 = 2112;
      v31 = v17;
      v32 = 2112;
      v33 = v18;
      v34 = 2112;
      v35 = v6;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "CKKS didn't find a current item for (%@,%@): %@ %@", buf, 0x2Au);

    }
    (*(void (**)(void))(*(_QWORD *)(a1 + 56) + 16))();
    if (qword_1003412C8 != -1)
      dispatch_once(&qword_1003412C8, &stru_1002E7860);
    if (byte_1003412C0)
    {
      v19 = *(_QWORD **)(a1 + 64);
      v20 = (const void *)v19[3];
      if (v20)
      {
        v19[3] = 0;
        CFRelease(v20);
        v19 = *(_QWORD **)(a1 + 64);
      }
      free(v19);
    }
  }
  else
  {
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      v21 = *(_QWORD *)(a1 + 32);
      v22 = *(_QWORD *)(a1 + 40);
      v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "uuid"));
      *(_DWORD *)buf = 138412802;
      v29 = v21;
      v30 = 2112;
      v31 = v22;
      v32 = 2112;
      v33 = v23;
      _os_log_debug_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "CKKS believes current item UUID for (%@,%@) is %@. Looking up persistent ref...", buf, 0x20u);

    }
    v10 = *(void **)(a1 + 48);
    v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "uuid"));
    v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@,%@"), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40)));
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 3221225472;
    v24[2] = sub_10002E910;
    v24[3] = &unk_1002DAE20;
    v13 = *(_QWORD *)(a1 + 64);
    v26 = *(id *)(a1 + 56);
    v14 = v5;
    v15 = *(_QWORD *)(a1 + 64);
    v25 = v14;
    v27 = v15;
    objc_msgSend(v10, "findItemPersistentRefByUUID:extraLoggingString:client:complete:", v11, v12, v13, v24);

  }
}

void sub_10002E910(_QWORD *a1, void *a2, void *a3)
{
  uint64_t v5;
  void *v6;
  id v7;
  id v8;
  void *v9;
  _QWORD *v10;
  const void *v11;

  v6 = (void *)a1[4];
  v5 = a1[5];
  v7 = a3;
  v8 = a2;
  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "modificationDate"));
  (*(void (**)(uint64_t, id, void *, id))(v5 + 16))(v5, v8, v9, v7);

  if (qword_1003412C8 != -1)
    dispatch_once(&qword_1003412C8, &stru_1002E7860);
  if (byte_1003412C0)
  {
    v10 = (_QWORD *)a1[6];
    v11 = (const void *)v10[3];
    if (v11)
    {
      v10[3] = 0;
      CFRelease(v11);
      v10 = (_QWORD *)a1[6];
    }
    free(v10);
  }
}

void sub_10002E9EC(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  id v4;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = CKXPCSuitableError(a2);
  v4 = (id)objc_claimAutoreleasedReturnValue(v3);
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v4);

}

void sub_10002EA34(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  id v4;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = CKXPCSuitableError(a2);
  v4 = (id)objc_claimAutoreleasedReturnValue(v3);
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v4);

}

void sub_10002EA7C(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  uint64_t v6;
  id v7;
  id v8;
  uint64_t v9;
  id v10;

  v6 = *(_QWORD *)(a1 + 32);
  v7 = a3;
  v8 = a2;
  v9 = CKXPCSuitableError(a4);
  v10 = (id)objc_claimAutoreleasedReturnValue(v9);
  (*(void (**)(uint64_t, id, id, id))(v6 + 16))(v6, v8, v7, v10);

}

id sub_10002EAF4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  uint64_t v6;
  void *v7;

  v5 = *(void **)(a1 + 32);
  v6 = CKXPCSuitableError(a3);
  v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
  objc_msgSend(v5, "callCallback:error:", a2, v7);

  return objc_msgSend(*(id *)(a1 + 40), "setTransaction:", 0);
}

void sub_10002EB4C(uint64_t a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  id v7;

  v3 = a2;
  v4 = sub_10000EF14("SecError");
  v5 = objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = 138412290;
    v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "SecKeychainMoveUserDb: remote object failed with error: %@", (uint8_t *)&v6, 0xCu);
  }

  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = objc_msgSend(v3, "code");
}

void sub_10002EC1C(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  const void *v5;
  NSObject *v6;
  int v7;
  void *v8;

  v3 = a2;
  v4 = v3;
  if (v3)
  {
    v5 = sub_10000EF14("SecError");
    v6 = objc_claimAutoreleasedReturnValue(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v7 = 138412290;
      v8 = v4;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "SecKeychainMoveUserDb: replied with error: %@", (uint8_t *)&v7, 0xCu);
    }

    LODWORD(v3) = objc_msgSend(v4, "code");
  }
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (_DWORD)v3;

}

void sub_10002F238(id a1)
{
  void *v1;
  SecuritydXPCServerListener *v2;
  void *v3;

  v1 = objc_autoreleasePoolPush();
  v2 = objc_alloc_init(SecuritydXPCServerListener);
  v3 = (void *)qword_100340D08;
  qword_100340D08 = (uint64_t)v2;

  objc_autoreleasePoolPop(v1);
}

void sub_10002F278(id a1)
{
  qword_100340D30 = (uint64_t)dispatch_queue_create("security scope control", (dispatch_queue_attr_t)&_dispatch_queue_attr_concurrent);
}

uint64_t sub_10002F2A4(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_10002F2B8(uint64_t a1)
{
  const __CFArray *v1;
  _QWORD context[5];
  CFRange v3;

  v1 = (const __CFArray *)qword_100340D18;
  context[0] = _NSConcreteStackBlock;
  context[1] = 0x40000000;
  context[2] = sub_10002F338;
  context[3] = &unk_1002DAFD8;
  context[4] = *(_QWORD *)(a1 + 32);
  v3.length = CFArrayGetCount((CFArrayRef)qword_100340D18);
  v3.location = 0;
  CFArrayApplyFunction(v1, v3, (CFArrayApplierFunction)sub_10002F2A4, context);
}

void sub_10002F338(uint64_t a1, CFTypeRef cf)
{
  CFTypeID v4;
  CFMutableArrayRef v5;
  CFTypeID v6;
  CFMutableDictionaryRef Mutable;
  _QWORD context[5];

  if (!cf)
    goto LABEL_8;
  v4 = CFGetTypeID(cf);
  if (v4 != CFSetGetTypeID())
  {
    v6 = CFGetTypeID(cf);
    if (v6 == CFDictionaryGetTypeID())
    {
      Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      context[0] = _NSConcreteStackBlock;
      context[1] = 0x40000000;
      context[2] = sub_10002F4F8;
      context[3] = &unk_1002DAFB8;
      context[4] = Mutable;
      CFDictionaryApplyFunction((CFDictionaryRef)cf, (CFDictionaryApplierFunction)sub_10002F574, context);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), Mutable);
      return;
    }
LABEL_8:
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), kCFNull);
    return;
  }
  v5 = sub_10002F46C((const __CFSet *)cf);
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), v5);
  if (v5)
    CFRelease(v5);
}

CFMutableArrayRef sub_10002F46C(const __CFSet *a1)
{
  CFMutableArrayRef Mutable;
  _QWORD context[5];

  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  context[0] = _NSConcreteStackBlock;
  context[1] = 0x40000000;
  context[2] = sub_10002F58C;
  context[3] = &unk_1002DB098;
  context[4] = Mutable;
  CFSetApplyFunction(a1, (CFSetApplierFunction)sub_10002F2A4, context);
  return Mutable;
}

void sub_10002F4F8(uint64_t a1, const void *a2, CFTypeRef cf)
{
  CFTypeID v6;
  CFMutableArrayRef v7;

  if (cf)
  {
    v6 = CFGetTypeID(cf);
    if (v6 == CFSetGetTypeID())
    {
      v7 = sub_10002F46C((const __CFSet *)cf);
      CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 32), a2, v7);
      if (v7)
        CFRelease(v7);
    }
  }
}

uint64_t sub_10002F574(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void sub_10002F58C(uint64_t a1, const void *a2)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), a2);
}

void sub_10002F594(const __CFDictionary *a1, int a2)
{
  const __CFDictionary *Mutable;
  _QWORD context[5];

  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  context[0] = _NSConcreteStackBlock;
  context[1] = 0x40000000;
  context[2] = sub_10002F658;
  context[3] = &unk_1002DB018;
  context[4] = Mutable;
  CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)sub_10002F574, context);
  if (CFDictionaryGetCount(Mutable) >= 1)
    sub_10002F848(a2, (uint64_t)Mutable);
  if (Mutable)
    CFRelease(Mutable);
}

void sub_10002F658(uint64_t a1, const __CFNumber *cf, const __CFString *a3)
{
  CFNumberRef v4;
  CFTypeID v6;
  int v7;
  CFTypeID v8;
  CFTypeID v9;
  __CFSet *v10;
  __CFSet *v11;
  int valuePtr;

  v4 = cf;
  if (cf)
  {
    v6 = CFGetTypeID(cf);
    if (v6 == CFStringGetTypeID())
    {
      if (CFEqual(v4, CFSTR("Emergency")))
      {
        v7 = 0;
LABEL_22:
        valuePtr = v7;
        v4 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
        goto LABEL_23;
      }
      if (CFEqual(v4, CFSTR("Alert")))
      {
        v7 = 1;
        goto LABEL_22;
      }
      if (CFEqual(v4, CFSTR("Critical")))
      {
        v7 = 2;
        goto LABEL_22;
      }
      if (CFEqual(v4, CFSTR("Error")))
      {
        v7 = 3;
        goto LABEL_22;
      }
      if (CFEqual(v4, CFSTR("Warning")))
      {
        v7 = 4;
        goto LABEL_22;
      }
      if (CFEqual(v4, CFSTR("Notice")))
      {
        v7 = 5;
        goto LABEL_22;
      }
      if (CFEqual(v4, CFSTR("Info")))
      {
        v7 = 6;
        goto LABEL_22;
      }
      if (CFEqual(v4, CFSTR("Debug")))
      {
        v7 = 7;
        goto LABEL_22;
      }
    }
    else
    {
      v8 = CFGetTypeID(v4);
      if (v8 == CFNumberGetTypeID())
      {
        CFRetain(v4);
        if (a3)
          goto LABEL_24;
        goto LABEL_29;
      }
    }
    v4 = 0;
    if (a3)
      goto LABEL_24;
LABEL_29:
    if (!v4)
      return;
    goto LABEL_30;
  }
LABEL_23:
  if (!a3)
    goto LABEL_29;
LABEL_24:
  v9 = CFGetTypeID(a3);
  if (v9 != CFStringGetTypeID())
    goto LABEL_29;
  v10 = sub_10002F9C0(a3);
  v11 = v10;
  if (v4 && v10)
  {
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 32), v4, v10);
    CFRelease(v4);
    v4 = v11;
LABEL_30:
    CFRelease(v4);
    return;
  }
  if (v4)
    CFRelease(v4);
  v4 = v11;
  if (v11)
    goto LABEL_30;
}

void sub_10002F848(int a1, uint64_t a2)
{
  _QWORD v2[5];
  int v3;

  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000;
  v2[2] = sub_10002F8CC;
  v2[3] = &unk_1002DB0D8;
  v3 = a1;
  v2[4] = a2;
  if (qword_100340D38 != -1)
    dispatch_once(&qword_100340D38, &stru_1002DB078);
  dispatch_barrier_sync((dispatch_queue_t)qword_100340D30, v2);
}

void sub_10002F8CC(uint64_t a1)
{
  __CFArray *Mutable;
  CFNullRef v3;
  int v4;
  const __CFArray *v5;
  CFIndex CountOfValue;
  const void *v7;
  CFRange v8;

  Mutable = (__CFArray *)qword_100340D18;
  if (qword_100340D18)
  {
    v3 = kCFNull;
  }
  else
  {
    Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 4, &kCFTypeArrayCallBacks);
    v3 = kCFNull;
    v4 = 5;
    do
    {
      CFArrayAppendValue(Mutable, kCFNull);
      --v4;
    }
    while (v4);
    qword_100340D18 = (uint64_t)Mutable;
  }
  CFArraySetValueAtIndex(Mutable, *(int *)(a1 + 40), *(const void **)(a1 + 32));
  v5 = (const __CFArray *)qword_100340D18;
  v8.length = CFArrayGetCount((CFArrayRef)qword_100340D18);
  v8.location = 0;
  CountOfValue = CFArrayGetCountOfValue(v5, v8, v3);
  if (CountOfValue == CFArrayGetCount(v5))
  {
    v7 = (const void *)qword_100340D18;
    if (qword_100340D18)
    {
      qword_100340D18 = 0;
      CFRelease(v7);
    }
  }
}

__CFSet *sub_10002F9C0(const __CFString *a1)
{
  __CFSet *Mutable;
  int HasPrefix;
  CFIndex Length;
  CFStringRef v5;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v7;
  _QWORD context[5];
  CFRange v10;
  CFRange v11;

  Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  HasPrefix = CFStringHasPrefix(a1, CFSTR("-"));
  if (HasPrefix)
  {
    Length = CFStringGetLength(CFSTR("-"));
    v11.length = CFStringGetLength(a1) - 1;
    v11.location = Length;
    v5 = CFStringCreateWithSubstring(kCFAllocatorDefault, a1, v11);
    a1 = v5;
  }
  else
  {
    v5 = 0;
  }
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(kCFAllocatorDefault, a1, CFSTR(","));
  v7 = ArrayBySeparatingStrings;
  if (ArrayBySeparatingStrings)
  {
    context[0] = _NSConcreteStackBlock;
    context[1] = 0x40000000;
    context[2] = sub_10002FB50;
    context[3] = &unk_1002DB0B8;
    context[4] = Mutable;
    v10.length = CFArrayGetCount(ArrayBySeparatingStrings);
    v10.location = 0;
    CFArrayApplyFunction(v7, v10, (CFArrayApplierFunction)sub_10002F2A4, context);
  }
  CFSetRemoveValue(Mutable, CFSTR("none"));
  CFSetRemoveValue(Mutable, &stru_1002EE888);
  if (CFSetContainsValue(Mutable, CFSTR("all")))
  {
    CFSetRemoveAllValues(Mutable);
    if (HasPrefix)
      goto LABEL_11;
  }
  else if (!HasPrefix)
  {
    goto LABEL_11;
  }
  CFSetSetValue(Mutable, CFSTR("-"));
LABEL_11:
  if (v7)
    CFRelease(v7);
  if (v5)
    CFRelease(v5);
  return Mutable;
}

void sub_10002FB50(uint64_t a1, const __CFString *cf)
{
  CFTypeID v4;
  __CFString *MutableCopy;

  if (cf)
  {
    v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID())
    {
      MutableCopy = CFStringCreateMutableCopy(kCFAllocatorDefault, 0, cf);
      CFStringTrimWhitespace(MutableCopy);
      CFSetSetValue(*(CFMutableSetRef *)(a1 + 32), MutableCopy);
      if (MutableCopy)
        CFRelease(MutableCopy);
    }
  }
}

void sub_10002FBD8(const __CFString *a1, int a2)
{
  __CFSet *v3;

  v3 = sub_10002F9C0(a1);
  sub_10002F848(a2, (uint64_t)v3);
  if (v3)
    CFRelease(v3);
}

void sub_10002FC1C(uint64_t a1, const char *a2)
{
  __CFDictionary *v2;
  const void *v3;
  os_log_t v4;

  v2 = (__CFDictionary *)qword_100340D28;
  v3 = *(const void **)(a1 + 32);
  v4 = os_log_create("com.apple.securityd", a2);
  CFDictionaryAddValue(v2, v3, v4);
}

CFDictionaryRef sub_10002FC58(uint64_t a1)
{
  CFDictionaryRef result;
  void *values;
  void *keys;

  values = kCFBooleanTrue;
  keys = CFSTR("debug");
  result = CFDictionaryCreate(kCFAllocatorDefault, (const void **)&keys, (const void **)&values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  **(_QWORD **)(a1 + 32) = result;
  return result;
}

void sub_10002FCF4(const __CFArray *a1, CFStringRef theString, const __CFString *a3, uint64_t a4)
{
  const void *v7;
  _QWORD v8[6];
  _QWORD v9[4];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  CFMutableStringRef MutableCopy;
  CFRange v14;

  if (a1)
  {
    v10 = 0;
    v11 = &v10;
    v12 = 0x2000000000;
    MutableCopy = (CFMutableStringRef)0xAAAAAAAAAAAAAAAALL;
    MutableCopy = CFStringCreateMutableCopy(kCFAllocatorDefault, 0, theString);
    v9[0] = 0;
    v9[1] = v9;
    v9[2] = 0x2000000000;
    v9[3] = &stru_1002EE888;
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 0x40000000;
    v8[2] = sub_10002FE50;
    v8[3] = &unk_1002DB200;
    v8[4] = &v10;
    v8[5] = v9;
    v14.length = CFArrayGetCount(a1);
    v14.location = 0;
    CFArrayApplyFunction(a1, v14, (CFArrayApplierFunction)sub_10002FEB0, v8);
    CFStringAppend((CFMutableStringRef)v11[3], a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 16))(a4, v11[3]);
    v7 = (const void *)v11[3];
    if (v7)
    {
      v11[3] = 0;
      CFRelease(v7);
    }
    _Block_object_dispose(v9, 8);
    _Block_object_dispose(&v10, 8);
  }
  else
  {
    (*(void (**)(uint64_t, const __CFString *))(a4 + 16))(a4, CFSTR("null"));
  }
}

void sub_10002FE50(uint64_t a1, uint64_t a2)
{
  CFStringAppendFormat(*(CFMutableStringRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), 0, CFSTR("%@%@"), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), a2);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = CFSTR(", ");
}

uint64_t sub_10002FEB0(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_10002FEC4(const __CFSet *a1, uint64_t a2)
{
  CFIndex Count;
  CFMutableArrayRef Mutable;
  CFRange v6;

  if (a1)
  {
    Count = CFSetGetCount(a1);
    Mutable = CFArrayCreateMutable(0, Count, &kCFTypeArrayCallBacks);
    CFSetApplyFunction(a1, (CFSetApplierFunction)sub_10002FF98, Mutable);
    v6.length = CFArrayGetCount(Mutable);
    v6.location = 0;
    CFArraySortValues(Mutable, v6, (CFComparatorFunction)&_CFStringCompare, 0);
    sub_10002FCF4(Mutable, CFSTR("{("), CFSTR(")}"), a2);
    if (Mutable)
      CFRelease(Mutable);
  }
  else
  {
    (*(void (**)(uint64_t, const __CFString *))(a2 + 16))(a2, CFSTR("null"));
  }
}

void sub_10002FF98(const __CFString *a1, __CFArray *a2)
{
  CFTypeID v4;
  __CFArray *v5;
  const __CFString *v6;
  CFStringRef v7;
  CFStringRef v8;

  v4 = CFGetTypeID(a1);
  if (v4 == CFStringGetTypeID())
  {
    v5 = a2;
    v6 = a1;
  }
  else
  {
    v7 = CFCopyDescription(a1);
    if (v7)
    {
      v8 = v7;
      CFArrayAppendValue(a2, v7);
      CFRelease(v8);
      return;
    }
    v6 = CFSTR("null");
    v5 = a2;
  }
  CFArrayAppendValue(v5, v6);
}

void sub_10003001C(id a1)
{
  const __CFTimeZone *v1;

  qword_100340D88 = (uint64_t)CFCalendarCreateWithIdentifier(kCFAllocatorDefault, kCFGregorianCalendar);
  v1 = CFTimeZoneCreateWithTimeIntervalFromGMT(kCFAllocatorDefault, 0.0);
  CFCalendarSetTimeZone((CFCalendarRef)qword_100340D88, v1);
  if (v1)
    CFRelease(v1);
}

void sub_10003008C(id a1)
{
  qword_100340D78 = (uint64_t)dispatch_queue_create("ZuluCalendar", 0);
}

CFStringRef sub_1000300B4(const __CFString *a1, const __CFCharacterSet *a2)
{
  CFIndex Length;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  uint64_t v7;
  CFIndex v8;
  __int128 v9;
  uint64_t v10;
  const __CFString *v11;
  uint64_t v12;
  CFIndex v13;
  UniChar v14;
  CFIndex v15;
  uint64_t v17;
  uint64_t v18;
  CFIndex v19;
  CFIndex v20;
  CFIndex v21;
  CFIndex v22;
  uint64_t v23;
  uint64_t v24;
  CFIndex v25;
  UniChar v26;
  CFIndex v27;
  uint64_t v28;
  CFIndex v29;
  CFIndex v30;
  CFIndex v31;
  _OWORD v33[8];
  CFStringRef theString;
  const UniChar *v35;
  const char *v36;
  uint64_t v37;
  CFIndex v38;
  CFIndex v39;
  CFIndex v40;
  CFRange v41;
  CFRange v42;
  CFRange v43;

  Length = CFStringGetLength(a1);
  theString = a1;
  v37 = 0;
  v38 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  v35 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  v39 = 0;
  v40 = 0;
  v36 = CStringPtr;
  if (Length < 1)
    return &stru_1002EE888;
  v7 = 0;
  v8 = 0;
  *(_QWORD *)&v9 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v33[6] = v9;
  v33[7] = v9;
  v33[4] = v9;
  v33[5] = v9;
  v33[2] = v9;
  v33[3] = v9;
  v10 = 64;
  v11 = &stru_1002EE888;
  v33[0] = v9;
  v33[1] = v9;
  while (1)
  {
    v12 = (unint64_t)v8 >= 4 ? 4 : v8;
    v13 = v38;
    if (v38 <= v8)
    {
      v14 = 0;
    }
    else if (v35)
    {
      v14 = v35[v8 + v37];
    }
    else if (v36)
    {
      v14 = v36[v37 + v8];
    }
    else
    {
      v15 = v39;
      if (v40 <= v8 || v39 > v8)
      {
        v17 = v12 + v7;
        v18 = v10 - v12;
        v19 = v8 - v12;
        v20 = v19 + 64;
        if (v19 + 64 >= v38)
          v20 = v38;
        v39 = v19;
        v40 = v20;
        if (v38 >= v18)
          v13 = v18;
        v41.length = v13 + v17;
        v41.location = v19 + v37;
        CFStringGetCharacters(theString, v41, (UniChar *)v33);
        v15 = v39;
      }
      v14 = *((_WORD *)v33 + v8 - v15);
    }
    if (!CFCharacterSetIsCharacterMember(a2, v14))
      break;
    ++v8;
    --v7;
    ++v10;
    if (Length == v8)
      return v11;
  }
  v21 = -Length;
  v22 = Length + 64;
  v23 = 1;
  while (1)
  {
    v24 = (unint64_t)Length >= 5 ? 5 : Length;
    if (Length < 2)
      break;
    v25 = v38;
    if (v38 >= Length)
    {
      if (v35)
      {
        v26 = v35[Length - 1 + v37];
      }
      else if (v36)
      {
        v26 = v36[v37 - 1 + Length];
      }
      else
      {
        if (v40 < Length || (v27 = v39, v39 >= Length))
        {
          v28 = v24 + v21;
          v29 = v22 - v24;
          v30 = Length - v24;
          v31 = v30 + 64;
          if (v30 + 64 >= v38)
            v31 = v38;
          v39 = v30;
          v40 = v31;
          if (v38 >= v29)
            v25 = v29;
          v42.length = v25 + v28;
          v42.location = v30 + v37;
          CFStringGetCharacters(theString, v42, (UniChar *)v33);
          v27 = v39;
        }
        v26 = *((_WORD *)&v33[-1] + Length - v27 + 7);
      }
    }
    else
    {
      v26 = 0;
    }
    ++v21;
    --v22;
    --Length;
    if (!CFCharacterSetIsCharacterMember(a2, v26))
    {
      v23 = Length + 1;
      break;
    }
  }
  v43.length = v23 - v8;
  v43.location = v8;
  return CFStringCreateWithSubstring(0, a1, v43);
}

void sub_100030360(uint64_t a1)
{
  const __CFLocale *v2;

  v2 = CFLocaleCopyCurrent();
  **(_QWORD **)(a1 + 32) = CFDateFormatterCreate(kCFAllocatorDefault, v2, kCFDateFormatterNoStyle, kCFDateFormatterNoStyle);
  CFDateFormatterSetFormat(**(CFDateFormatterRef **)(a1 + 32), CFSTR("yyyy-MM-dd HH:mm"));
  if (v2)
    CFRelease(v2);
}

dispatch_queue_t sub_1000303D0(uint64_t a1)
{
  dispatch_queue_t result;

  result = dispatch_queue_create("Date Formatting", 0);
  **(_QWORD **)(a1 + 32) = result;
  return result;
}

void sub_100030404(uint64_t a1, double a2)
{
  const void *v3;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  void **block;
  uint64_t v10;
  void *v11;
  void *v12;
  uint64_t *v13;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_100030530;
  v4[3] = &unk_1002DB1D8;
  v4[4] = &v5;
  *(double *)&v4[5] = a2;
  block = _NSConcreteStackBlock;
  v10 = 0x40000000;
  v11 = sub_1000303D0;
  v12 = &unk_1002DB1B0;
  v13 = &qword_100340D68;
  if (qword_100340D60 != -1)
    dispatch_once(&qword_100340D60, &block);
  block = _NSConcreteStackBlock;
  v10 = 0x40000000;
  v11 = sub_10003056C;
  v12 = &unk_1002DB2A8;
  v13 = v4;
  dispatch_sync((dispatch_queue_t)qword_100340D68, &block);
  (*(void (**)(uint64_t, uint64_t))(a1 + 16))(a1, v6[3]);
  v3 = (const void *)v6[3];
  if (v3)
  {
    v6[3] = 0;
    CFRelease(v3);
  }
  _Block_object_dispose(&v5, 8);
}

CFStringRef sub_100030530(uint64_t a1, __CFDateFormatter *a2)
{
  CFStringRef result;

  result = CFDateFormatterCreateStringWithAbsoluteTime(kCFAllocatorDefault, a2, *(CFAbsoluteTime *)(a1 + 40));
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t sub_10003056C(uint64_t a1)
{
  uint64_t v1;
  _QWORD block[5];

  v1 = *(_QWORD *)(a1 + 32);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100030360;
  block[3] = &unk_1002DB190;
  block[4] = &qword_100340D58;
  if (qword_100340D50 != -1)
    dispatch_once(&qword_100340D50, block);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v1 + 16))(v1, qword_100340D58);
}

void sub_1000305FC()
{
  exit(1);
}

void sub_10003060C(int a1, CFTypeRef *a2, CFStringRef format, ...)
{
  __CFString *v4;
  va_list va;

  va_start(va, format);
  if (a2)
  {
    v4 = (__CFString *)*a2;
    *a2 = 0;
    sub_10001A09C(a1, CFSTR("com.apple.utilities.sqlite3"), v4, a2, format, va);
  }
}

BOOL sub_100030654(uint64_t a1, sqlite3 *a2, CFTypeRef *a3, CFStringRef format, ...)
{
  CFStringRef v7;
  uint64_t v8;
  void *v9;
  const void *v10;
  uint64_t v11;
  const char *v12;
  uint64_t v14;
  va_list va;

  va_start(va, format);
  if ((_DWORD)a1 && a3)
  {
    v7 = CFStringCreateWithFormatAndArguments(kCFAllocatorDefault, 0, format, va);
    if ((_DWORD)a1 == 14)
    {
      v8 = sqlite3_system_errno(a2);
      v9 = (void *)CFStringCreateWithFormat(0, 0, CFSTR("%d"), v8);
    }
    else
    {
      v9 = (void *)CFRetain(&stru_1002EE888);
    }
    v10 = v9;
    v11 = sqlite3_extended_errcode(a2);
    v12 = sqlite3_errmsg(a2);
    if ((_DWORD)v11 == (_DWORD)a1)
      sub_10003060C(a1, a3, CFSTR("%@: [%d]%@ %s"), v7, a1, v10, v12, v14, va);
    else
      sub_10003060C(a1, a3, CFSTR("%@: [%d->%d]%@ %s"), v7, a1, v11, v10, v12, va);
    if (v7)
      CFRelease(v7);
    if (v10)
      CFRelease(v10);
  }
  return (_DWORD)a1 == 0;
}

void sub_100030774(id a1)
{
  int v1;
  int v2;
  NSObject *v3;
  uint8_t buf[4];
  int v5;

  v1 = sqlite3_config(16, nullsub_25, 0);
  if (v1)
  {
    v2 = v1;
    v3 = sub_10000EF14("SecWarning");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      v5 = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Could not set up sqlite global error logging to syslog: %d", buf, 8u);
    }
  }
}

uint64_t sub_10003082C(uint64_t a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass(&unk_1002DB358);
  **(_QWORD **)(a1 + 32) = result;
  return result;
}

void sub_10003085C(uint64_t a1)
{
  const void *v2;
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;
  const void *v7;
  const void *v8;
  _QWORD block[5];

  v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    *(_QWORD *)(a1 + 16) = 0;
    CFRelease(v2);
  }
  v3 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_1000309C4;
  block[3] = &unk_1002DB5F8;
  block[4] = a1;
  dispatch_sync(v3, block);
  v4 = *(NSObject **)(a1 + 24);
  if (v4)
  {
    dispatch_release(v4);
    *(_QWORD *)(a1 + 24) = 0;
  }
  v5 = *(NSObject **)(a1 + 32);
  if (v5)
  {
    dispatch_release(v5);
    *(_QWORD *)(a1 + 32) = 0;
  }
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 56));
  v6 = *(NSObject **)(a1 + 120);
  if (v6)
  {
    dispatch_release(v6);
    *(_QWORD *)(a1 + 120) = 0;
  }
  v7 = *(const void **)(a1 + 136);
  if (v7)
  {
    _Block_release(v7);
    *(_QWORD *)(a1 + 136) = 0;
  }
  v8 = *(const void **)(a1 + 152);
  if (v8)
  {
    *(_QWORD *)(a1 + 152) = 0;
    CFRelease(v8);
  }
}

CFStringRef sub_100030930(uint64_t a1)
{
  return CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("<SecDb path:%@ connections: %@>"), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 48));
}

CFStringRef sub_100030974(uint64_t a1)
{
  sub_100005100();
  return CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("<SecDb path:%@ connections: %@>"), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 48));
}

void sub_1000309C4(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  const void *v4;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(const void **)(v2 + 40);
  if (v3)
  {
    *(_QWORD *)(v2 + 40) = 0;
    CFRelease(v3);
    v2 = *(_QWORD *)(a1 + 32);
  }
  v4 = *(const void **)(v2 + 48);
  if (v4)
  {
    *(_QWORD *)(v2 + 48) = 0;
    CFRelease(v4);
  }
}

dispatch_queue_t sub_100030A10(uint64_t a1, char *label)
{
  dispatch_queue_t result;

  result = dispatch_queue_create(label, 0);
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24) = result;
  return result;
}

dispatch_queue_t sub_100030A40(uint64_t a1, char *label)
{
  dispatch_queue_t result;

  result = dispatch_queue_create(label, (dispatch_queue_attr_t)&_dispatch_queue_attr_concurrent);
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 32) = result;
  return result;
}

void sub_100030A78(uint64_t a1, const void *a2)
{
  os_unfair_lock_s *v4;
  void *v5;
  __CFArray *Mutable;

  v4 = (os_unfair_lock_s *)(a1 + 148);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 148));
  v5 = _Block_copy(a2);
  Mutable = *(__CFArray **)(a1 + 152);
  if (!Mutable)
  {
    Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
    *(_QWORD *)(a1 + 152) = Mutable;
  }
  CFArrayAppendValue(Mutable, v5);
  _Block_release(v5);
  os_unfair_lock_unlock(v4);
}

BOOL sub_100030AE8(uint64_t a1, uint64_t a2, uint64_t a3, int a4, CFTypeRef *a5)
{
  int v10;
  int v11;
  NSObject *v12;
  _BOOL4 v13;
  uint8_t buf[4];
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;

  if (a2 - 5 > 1)
    return sub_100030C9C(a1, a2, a5, CFSTR("%@"), a3);
  if (a4 > 4)
  {
    v10 = 250;
    v11 = 250 * a4 - 820;
  }
  else
  {
    v10 = dword_1002494F4[a4];
    v11 = dword_100249508[a4];
  }
  v12 = sub_10000EF14("#SecDB");
  v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG);
  if (v11 > 299999)
  {
    if (v13)
    {
      *(_DWORD *)buf = 67109120;
      v16 = v11;
      _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "sqlite busy/locked: too long: %d ms, giving up", buf, 8u);
    }
    return sub_100030C9C(a1, a2, a5, CFSTR("%@"), a3);
  }
  if (v13)
  {
    *(_DWORD *)buf = 67109632;
    v16 = a2;
    v17 = 1024;
    v18 = a4;
    v19 = 1024;
    v20 = v11;
    _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "sqlite busy/locked: %d ntries: %d totaltimeout: %d", buf, 0x14u);
  }
  j__sqlite3_sleep(v10);
  return 1;
}

BOOL sub_100030C9C(uint64_t a1, uint64_t a2, CFTypeRef *a3, CFStringRef format, ...)
{
  CFStringRef v7;
  __CFString *v8;
  NSObject *v9;
  unsigned int v10;
  BOOL v11;
  __CFError *v12;
  CFIndex Code;
  NSObject *v14;
  uint64_t v15;
  const char *v16;
  NSObject *v17;
  uint32_t v18;
  NSObject *v19;
  int v20;
  NSObject *v21;
  _BOOL4 v22;
  const char *v23;
  const void *v24;
  int v25;
  NSObject *v26;
  _BOOL4 v27;
  const char *v28;
  NSObject *v29;
  uint32_t v30;
  NSObject *v31;
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  CFTypeRef v37;
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  char v41;
  uint64_t v42;
  uint64_t *v43;
  uint64_t v44;
  char v45;
  uint8_t v46[4];
  uint64_t v47;
  __int128 buf;
  uint64_t (*v49)(uint64_t, sqlite3_stmt *);
  void *v50;
  uint64_t *v51;
  uint64_t *v52;
  uint64_t *v53;
  uint64_t v54;
  va_list va;

  va_start(va, format);
  if (!(_DWORD)a2 || (_DWORD)a2 == 101)
    return !(_DWORD)a2 || (_DWORD)a2 == 101;
  if (a3)
  {
    va_copy((va_list)buf, va);
    v7 = CFStringCreateWithFormatAndArguments(kCFAllocatorDefault, 0, format, va);
    sub_100030654(a2, *(sqlite3 **)(a1 + 64), a3, CFSTR("%@"), v7);
    CFRelease(v7);
  }
  *(_BYTE *)(a1 + 48) |= (_DWORD)a2 == 10;
  if (*(_BYTE *)(a1 + 40))
  {
    v8 = (__CFString *)CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("SQL DB %@ is corrupted already. Corruption error was: %d (previously %d)"), format, *(_QWORD *)(*(_QWORD *)(a1 + 16) + 16), a2, *(unsigned int *)(a1 + 44));
    v9 = sub_10000EF14("SecError");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(_QWORD *)((char *)&buf + 4) = v8;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%@", (uint8_t *)&buf, 0xCu);
    }
    if (CFEqual(*(CFTypeRef *)(*(_QWORD *)(a1 + 16) + 16), CFSTR("/Library/Keychains/keychain-2.db")))
    {
      v10 = 1405092101;
    }
    else if (CFEqual(*(CFTypeRef *)(*(_QWORD *)(a1 + 16) + 16), CFSTR("/Library/Keychains/ocspcache.sqlite3")))
    {
      v10 = 1405092357;
    }
    else if (CFEqual(*(CFTypeRef *)(*(_QWORD *)(a1 + 16) + 16), CFSTR("/Library/Keychains/TrustStore.sqlite3")))
    {
      v10 = 1405092613;
    }
    else if (CFEqual(*(CFTypeRef *)(*(_QWORD *)(a1 + 16) + 16), CFSTR("/Library/Keychains/caissuercache.sqlite3")))
    {
      v10 = 1405092869;
    }
    else
    {
      v10 = 1405091845;
    }
    sub_10003429C(v8, v10);
    if (v8)
      CFRelease(v8);
    if ((_DWORD)a2 == 26 || (_DWORD)a2 == 11)
    {
      v31 = sub_10000EF14("SecError");
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        v28 = "SecDbConnectionCheckCode detected corruption twice: going to handle corrupt DB";
        v29 = v31;
        v30 = 2;
        goto LABEL_49;
      }
      goto LABEL_50;
    }
    return !(_DWORD)a2 || (_DWORD)a2 == 101;
  }
  v11 = (_DWORD)a2 == 11;
  if ((_DWORD)a2 == 26)
    v11 = 1;
  *(_BYTE *)(a1 + 40) = v11;
  if ((_DWORD)a2 != 26 && (_DWORD)a2 != 11)
    return !(_DWORD)a2 || (_DWORD)a2 == 101;
  *(_DWORD *)(a1 + 44) = a2;
  v42 = 0;
  v43 = &v42;
  v44 = 0x2000000000;
  v45 = 0;
  v38 = 0;
  v39 = &v38;
  v40 = 0x2000000000;
  v41 = 0;
  v34 = 0;
  v35 = &v34;
  v36 = 0x2000000000;
  v37 = 0;
  *(_QWORD *)&buf = _NSConcreteStackBlock;
  *((_QWORD *)&buf + 1) = 0x40000000;
  v49 = sub_1000312F8;
  v50 = &unk_1002DB698;
  v51 = &v34;
  v52 = &v38;
  v53 = &v42;
  v54 = a1;
  sub_10001E3C4(a1, (uint64_t)CFSTR("PRAGMA integrity_check"), &v37, (uint64_t)&buf);
  if (!*((_BYTE *)v43 + 24))
  {
    v12 = (__CFError *)v35[3];
    if (!v12)
    {
      *((_BYTE *)v39 + 24) = 1;
      v19 = sub_10000EF14("#SecDB");
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        goto LABEL_26;
      *(_WORD *)v46 = 0;
      v16 = "#SecDB warning: failed to run integrity check due to corruption";
      v17 = v19;
      v18 = 2;
      goto LABEL_58;
    }
    Code = CFErrorGetCode(v12);
    if (Code == 26 || Code == 11)
      *((_BYTE *)v39 + 24) = 1;
    v14 = sub_10000EF14("#SecDB");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      v15 = v35[3];
      *(_DWORD *)v46 = 138543362;
      v47 = v15;
      v16 = "#SecDB warning error %{public}@ when running integrity check";
      v17 = v14;
      v18 = 12;
LABEL_58:
      _os_log_debug_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, v16, v46, v18);
    }
  }
LABEL_26:
  if (*((_BYTE *)v39 + 24))
  {
    v20 = *((unsigned __int8 *)v43 + 24);
    v21 = sub_10000EF14("SecError");
    v22 = os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
    if (v20)
    {
      if (v22)
      {
        *(_WORD *)v46 = 0;
        v23 = "SecDBCheckCorrupted ran integrity_check, and that didn't return ok";
LABEL_32:
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, v23, v46, 2u);
      }
    }
    else if (v22)
    {
      *(_WORD *)v46 = 0;
      v23 = "SecDBCheckCorrupted failed to run integrity check";
      goto LABEL_32;
    }
  }
  v24 = (const void *)v35[3];
  if (v24)
  {
    v35[3] = 0;
    CFRelease(v24);
  }
  v25 = *((unsigned __int8 *)v39 + 24);
  _Block_object_dispose(&v34, 8);
  _Block_object_dispose(&v38, 8);
  _Block_object_dispose(&v42, 8);
  *(_BYTE *)(a1 + 40) = v25;
  v26 = sub_10000EF14("SecError");
  v27 = os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT);
  if (v25)
  {
    if (v27)
    {
      LODWORD(buf) = 67109120;
      DWORD1(buf) = a2;
      v28 = "operation returned code: %d integrity check=fail";
      v29 = v26;
      v30 = 8;
LABEL_49:
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, v28, (uint8_t *)&buf, v30);
    }
LABEL_50:
    sub_1000311E4(a1, a2, a3);
    return !(_DWORD)a2 || (_DWORD)a2 == 101;
  }
  if (v27)
  {
    LODWORD(buf) = 67109120;
    DWORD1(buf) = a2;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "operation returned code: %d: integrity check=pass", (uint8_t *)&buf, 8u);
  }
  return !(_DWORD)a2 || (_DWORD)a2 == 101;
}

uint64_t sub_1000311E4(uint64_t a1, uint64_t __errnum, CFTypeRef *a3)
{
  uint64_t v3;
  CFIndex v7;
  char *v8;
  uint64_t v9;
  const __CFString *v11;
  NSObject *v12;
  uint8_t buf[8];
  uint64_t v14;
  uint64_t (*v15)(uint64_t);
  void *v16;
  Block_layout *v17;

  v3 = *(_QWORD *)(a1 + 16);
  if (*(_BYTE *)(v3 + 163))
  {
    v11 = *(const __CFString **)(v3 + 16);
    *(_QWORD *)buf = _NSConcreteStackBlock;
    v14 = 0x40000000;
    v15 = sub_1000104A0;
    v16 = &unk_1002DB170;
    v17 = &stru_1002DB748;
    sub_1000137F8(v11, (uint64_t)buf);
    v12 = sub_10000EF14("SecWarning");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "SecDbHandleCorrupt: killing self so that successor might cleanly delete corrupt db", buf, 2u);
    }
    sub_1000305FC();
  }
  v7 = (int)__errnum;
  v8 = strerror(__errnum);
  sub_100032660(v7, kCFErrorDomainPOSIX, 0, a3, v9, CFSTR("SecDbHandleCorrupt not allowed to repair, handled error: [%d] %s"), __errnum, v8);
  *(_BYTE *)(a1 + 40) = 0;
  return 0;
}

uint64_t sub_1000312F8(uint64_t a1, sqlite3_stmt *a2)
{
  uint64_t v2;
  CFTypeRef *v3;
  _QWORD v5[4];
  __int128 v6;
  sqlite3_stmt *v7;

  v2 = *(_QWORD *)(a1 + 56);
  v3 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_100031364;
  v5[3] = &unk_1002DB670;
  v7 = a2;
  v6 = *(_OWORD *)(a1 + 40);
  return sub_100019C40(v2, a2, v3, (uint64_t)v5);
}

void sub_100031364(uint64_t a1)
{
  const unsigned __int8 *v2;
  const unsigned __int8 *v3;
  NSObject *v4;
  const char *v5;
  int v6;
  const char *v7;

  v2 = sqlite3_column_text(*(sqlite3_stmt **)(a1 + 48), 0);
  v3 = v2;
  if (!v2 || strncasecmp((const char *)v2, "ok", 3uLL))
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
    v4 = sub_10000EF14("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5 = "NULL";
      if (v3)
        v5 = (const char *)v3;
      v6 = 136315138;
      v7 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "SecDBCheckCorrupted integrity_check returned %s", (uint8_t *)&v6, 0xCu);
    }
  }
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
}

void sub_100031468(id a1, const char *a2)
{
  NSObject *v3;
  FILE *v4;
  NSObject *v5;
  int v6;
  stat v7;
  uint8_t buf[4];
  _BYTE v9[14];
  char __b[1025];

  memset(__b, 170, sizeof(__b));
  snprintf(__b, 0x401uLL, "%s-iscorrupt", a2);
  memset(&v7, 0, sizeof(v7));
  if (!stat(__b, &v7))
  {
    v3 = sub_10000EF14("SecError");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)v9 = __b;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "SecDbHandleCorrupt: Tried to write corruption marker %s but one already exists", buf, 0xCu);
    }
  }
  v4 = fopen(__b, "w");
  if (v4)
  {
    fclose(v4);
  }
  else
  {
    v5 = sub_10000EF14("SecError");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *__error();
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)v9 = v6;
      *(_WORD *)&v9[4] = 2082;
      *(_QWORD *)&v9[6] = __b;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "SecDbHandleCorrupt: Unable (%{darwin.errno}d) to create corruption marker %{public}s", buf, 0x12u);
    }
  }
}

uint64_t sub_1000315EC(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_100031600(uint64_t a1, char a2)
{
  uint64_t Instance;
  uint64_t v5;
  _QWORD block[5];

  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100031D20;
  block[3] = &unk_1002DB5D8;
  block[4] = &qword_100340DB0;
  if (qword_100340DA8 != -1)
    dispatch_once(&qword_100340DA8, block);
  Instance = _CFRuntimeCreateInstance(kCFAllocatorDefault, qword_100340DB0, 64, 0);
  v5 = Instance;
  if (Instance)
  {
    *(_QWORD *)(Instance + 16) = a1;
    *(_BYTE *)(Instance + 24) = a2;
    *(_BYTE *)(Instance + 25) = 0;
    *(_QWORD *)(Instance + 32) = 2;
    *(_BYTE *)(Instance + 40) = 0;
    *(_DWORD *)(Instance + 44) = 0;
    *(_BYTE *)(Instance + 48) = 0;
    *(_QWORD *)(Instance + 56) = 0;
    *(_QWORD *)(Instance + 64) = 0;
    *(_QWORD *)(Instance + 72) = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  }
  return v5;
}

uint64_t sub_1000316F8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const __CFString *v3;
  uint64_t v4;
  _QWORD v6[8];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  char v10;
  _QWORD v11[5];

  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 1;
  v3 = *(const __CFString **)(*(_QWORD *)(a1 + 16) + 16);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = sub_1000317B8;
  v6[3] = &unk_1002DB6E8;
  v6[4] = &v7;
  v6[5] = a1;
  v6[6] = a2;
  v6[7] = a3;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  v11[2] = sub_1000104A0;
  v11[3] = &unk_1002DB170;
  v11[4] = v6;
  sub_1000137F8(v3, (uint64_t)v11);
  v4 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_1000317B8(uint64_t a1, char *filename)
{
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  char *v8;
  char *v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v13;
  CFIndex v14;
  CFTypeRef *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  _BYTE *v20;

  v4 = *(_QWORD *)(a1 + 40);
  if (*(_BYTE *)(*(_QWORD *)(v4 + 16) + 162))
  {
    if (*(_BYTE *)(v4 + 24))
      v5 = 4194305;
    else
      v5 = 4194306;
  }
  else
  {
    v5 = 4194305;
  }
  if (*(_QWORD *)(a1 + 48))
    v6 = sub_1000319D8(v4, filename, v5, 0);
  else
    v6 = 0;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v6;
  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (!*(_BYTE *)(v7 + 24))
  {
    *(_BYTE *)(v7 + 24) = 1;
    if (*(_QWORD *)(a1 + 48))
    {
      v8 = dirname(filename);
      if (v8)
      {
        v9 = v8;
        v10 = *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 16) + 160);
        v11 = mkpath_np(v8, (v10 >> 2) & 0x49 | v10);
        if ((_DWORD)v11 && (_DWORD)v11 != 17)
        {
          v13 = v11;
          v14 = (int)v11;
          v15 = *(CFTypeRef **)(a1 + 56);
          v16 = strerror(v11);
          sub_100032660(v14, kCFErrorDomainPOSIX, 0, v15, v17, CFSTR("mkpath_np %s: [%d] %s"), v9, v13, v16);
          *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
        }
      }
    }
    v18 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    if (*(_BYTE *)(v18 + 24))
    {
      v19 = sub_1000319D8(*(_QWORD *)(a1 + 40), filename, 4194310, *(CFTypeRef **)(a1 + 56));
      v18 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    }
    else
    {
      v19 = 0;
    }
    *(_BYTE *)(v18 + 24) = v19;
    if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    {
      chmod(filename, *(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 16) + 160));
      v20 = *(_BYTE **)(a1 + 48);
      if (v20)
        *v20 = 1;
    }
  }
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    if (qword_100340DB8 != -1)
      dispatch_once(&qword_100340DB8, &stru_1002DB728);
    if (dword_100340DC0)
      sqlite3_trace_v2(*(sqlite3 **)(*(_QWORD *)(a1 + 40) + 64), dword_100340DC0, (int (__cdecl *)(unsigned int, void *, void *, void *))sub_100031B5C, *(void **)(a1 + 40));
  }
}

BOOL sub_1000319D8(uint64_t a1, char *filename, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  sqlite3 *v13;
  sqlite3_stmt *ppStmt;
  sqlite3 *ppDb;

  v8 = *(_QWORD *)(a1 + 16);
  v9 = *(unsigned __int8 *)(v8 + 164);
  v10 = *(unsigned __int8 *)(v8 + 165);
  ppDb = 0;
  v11 = sqlite3_open_v2(filename, &ppDb, a3, 0);
  if ((_DWORD)v11)
  {
    if (ppDb)
    {
      sub_100030654(v11, ppDb, a4, CFSTR("open_v2 \"%s\" 0x%X"), filename, a3);
      sqlite3_close(ppDb);
      ppDb = 0;
    }
    else
    {
      sub_10003060C(v11, a4, CFSTR("open_v2 \"%s\" 0x%X"), filename, a3);
    }
    goto LABEL_16;
  }
  if ((a3 & 2) == 0)
    goto LABEL_16;
  if (v10)
  {
    ppStmt = 0;
    if (!sqlite3_prepare_v2(ppDb, "PRAGMA auto_vacuum", -1, &ppStmt, 0))
    {
      if (sqlite3_step(ppStmt) == 100)
      {
        v12 = sqlite3_column_int(ppStmt, 0);
        sqlite3_finalize(ppStmt);
        if (v12 == 2)
          goto LABEL_13;
      }
      else
      {
        sqlite3_finalize(ppStmt);
      }
    }
    sqlite3_exec(ppDb, "PRAGMA auto_vacuum = incremental", 0, 0, 0);
    sqlite3_exec(ppDb, "VACUUM", 0, 0, 0);
  }
LABEL_13:
  if (v9)
    sqlite3_exec(ppDb, "PRAGMA journal_mode = WAL", 0, 0, 0);
  sqlite3_busy_timeout(ppDb, 5000);
LABEL_16:
  v13 = ppDb;
  *(_QWORD *)(a1 + 64) = ppDb;
  return v13 != 0;
}

uint64_t sub_100031B5C()
{
  return 0;
}

void sub_100031B64(id a1)
{
  NSObject *v1;
  _DWORD v2[2];

  if (sub_100031C48())
    dword_100340DC0 = 2;
  if (sub_100031C48())
    dword_100340DC0 = 1;
  if (sub_100031C48())
    dword_100340DC0 = 4;
  v1 = sub_10000EF14("#SecDB");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
  {
    v2[0] = 67109120;
    v2[1] = dword_100340DC0;
    _os_log_debug_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "sqlDb: sql trace mask: 0x%08x", (uint8_t *)v2, 8u);
  }
}

uint64_t sub_100031C48()
{
  uint64_t v0;
  const __CFBoolean *v1;
  const __CFBoolean *v2;
  CFTypeID v3;
  BOOL v4;
  CFTypeID v5;
  int valuePtr;

  if (!csr_check(16))
  {
    v1 = (const __CFBoolean *)CFPreferencesCopyValue(CFSTR("SQLProfile"), CFSTR("com.apple.security"), kCFPreferencesAnyUser, kCFPreferencesAnyHost);
    if (v1)
    {
      v2 = v1;
      v3 = CFGetTypeID(v1);
      if (v3 == CFBooleanGetTypeID())
      {
        v4 = CFBooleanGetValue(v2) == 0;
      }
      else
      {
        v5 = CFGetTypeID(v2);
        if (v5 != CFNumberGetTypeID())
        {
          v0 = 0;
LABEL_12:
          CFRelease(v2);
          return v0;
        }
        valuePtr = 0;
        CFNumberGetValue(v2, kCFNumberSInt32Type, &valuePtr);
        v4 = valuePtr == 0;
      }
      v0 = !v4;
      goto LABEL_12;
    }
  }
  return 0;
}

uint64_t sub_100031D20(uint64_t a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass(&unk_1002DB578);
  **(_QWORD **)(a1 + 32) = result;
  return result;
}

void sub_100031D50(uint64_t a1)
{
  sqlite3 *v2;
  int v3;
  const void *v4;
  const void *v5;
  NSObject *v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  int v10;
  uint8_t buf[4];
  int v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  const char *v16;

  v2 = *(sqlite3 **)(a1 + 64);
  if (v2 && (v3 = sqlite3_close(v2)) != 0)
  {
    v10 = v3;
    v6 = sub_10000EF14("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v7 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 16);
      v8 = sqlite3_errmsg(*(sqlite3 **)(a1 + 64));
      *(_DWORD *)buf = 67109634;
      v12 = v10;
      v13 = 2112;
      v14 = v7;
      v15 = 2080;
      v16 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "failed to close database connection (%d) for %@: %s", buf, 0x1Cu);
    }
    v9 = _os_assert_log(0);
    _os_crash(v9);
    __break(1u);
  }
  else
  {
    *(_QWORD *)(a1 + 16) = 0;
    v4 = *(const void **)(a1 + 72);
    if (v4)
    {
      *(_QWORD *)(a1 + 72) = 0;
      CFRelease(v4);
    }
    v5 = *(const void **)(a1 + 56);
    if (v5)
    {
      *(_QWORD *)(a1 + 56) = 0;
      CFRelease(v5);
    }
  }
}

CFStringRef sub_100031E94(uint64_t a1)
{
  const char *v1;
  const char *v2;

  v1 = "ro";
  if (!*(_BYTE *)(a1 + 24))
    v1 = "rw";
  if (*(_QWORD *)(a1 + 64))
    v2 = "open";
  else
    v2 = "closed";
  return CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("<SecDbConnection %s %s>"), v1, v2);
}

void sub_100031F08(uint64_t a1, const std::__fs::filesystem::path *a2)
{
  NSObject *v4;
  int v5;
  const char *v6;
  NSObject *v7;
  uint32_t v8;
  NSObject *v9;
  std::error_code *v10;
  std::error_code *v11;
  NSObject *v12;
  int v13;
  const char *v14;
  NSObject *v15;
  uint32_t v16;
  NSObject *v17;
  NSObject *v18;
  int v19;
  stat v20;
  uint8_t buf[4];
  _BYTE v22[14];
  _BYTE __b[1025];

  memset(__b, 170, sizeof(__b));
  snprintf(__b, 0x401uLL, "%s-iscorrupt", (const char *)a2);
  memset(&v20, 0, sizeof(v20));
  if (!stat(__b, &v20))
  {
    v9 = sub_10000EF14("SecWarning");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)v22 = __b;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "SecDbSecDbProcessCorruptionMarker: found corruption marker %s", buf, 0xCu);
    }
    if (remove((const std::__fs::filesystem::path *)__b, v10))
    {
      v12 = sub_10000EF14("SecError");
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        v13 = *__error();
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)v22 = v13;
        v14 = "SecDbSecDbProcessCorruptionMarker: Unable (%{darwin.errno}d) to delete corruption marker";
        v15 = v12;
        v16 = 8;
LABEL_10:
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, v14, buf, v16);
      }
    }
    else
    {
      if (!remove(a2, v11) || *__error() == 2)
      {
        v17 = sub_10000EF14("SecWarning");
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          return;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)v22 = a2;
        v6 = "SecDbSecDbProcessCorruptionMarker: deleted corrupt db %{public}s";
        v7 = v17;
        v8 = 12;
        goto LABEL_16;
      }
      v18 = sub_10000EF14("SecError");
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        v19 = *__error();
        *(_DWORD *)buf = 67109378;
        *(_DWORD *)v22 = v19;
        *(_WORD *)&v22[4] = 2082;
        *(_QWORD *)&v22[6] = a2;
        v14 = "SecDbSecDbProcessCorruptionMarker: Unable (%{darwin.errno}d) to delete db %{public}s";
        v15 = v18;
        v16 = 18;
        goto LABEL_10;
      }
    }
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
    return;
  }
  if (*__error() != 2)
  {
    v4 = sub_10000EF14("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5 = *__error();
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)v22 = v5;
      v6 = "SecDbSecDbProcessCorruptionMarker: Unable to check for corruption marker: %{darwin.errno}d";
      v7 = v4;
      v8 = 8;
LABEL_16:
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v6, buf, v8);
    }
  }
}

uint64_t sub_1000321C0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

BOOL sub_1000321CC(sqlite3_stmt *a1, uint64_t a2, CFTypeRef *a3, double a4)
{
  uint64_t v7;

  v7 = sqlite3_bind_double(a1, a2, a4);
  return sub_100013978(v7, a1, a3, CFSTR("bind_double[%d]"), a2);
}

BOOL sub_10003221C(sqlite3_stmt *a1, uint64_t a2, int a3, CFTypeRef *a4)
{
  uint64_t v7;

  v7 = sqlite3_bind_int(a1, a2, a3);
  return sub_100013978(v7, a1, a4, CFSTR("bind_int[%d]"), a2);
}

void sub_10003226C(id a1)
{
  NSObject *v1;
  void *v2;
  NSObject *v3;
  _QWORD *context;
  const void *v5;
  NSObject *v6;
  const __CFURL *v7;
  const __CFURL *v8;
  void *FunctionPointerForName;
  uint8_t v10[16];

  v1 = sub_1000327DC("PowerLog enabled", 86400);
  v2 = (void *)qword_100340DE8;
  qword_100340DE8 = (uint64_t)v1;

  v3 = qword_100340DE8;
  context = dispatch_get_context((dispatch_object_t)qword_100340DE8);
  context[2] = _Block_copy(&stru_1002DB7D0);
  dispatch_activate(v3);
  v5 = sub_10000EF14("PLsetup");
  v6 = objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v10 = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Setting up PowerLog", v10, 2u);
  }

  v7 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, CFSTR("/System/Library/PrivateFrameworks/PowerLog.framework"), kCFURLPOSIXPathStyle, 1u);
  if (v7)
  {
    v8 = v7;
    qword_100340DF0 = (uint64_t)CFBundleCreate(kCFAllocatorDefault, v7);
    CFRelease(v8);
    if (qword_100340DF0)
    {
      off_100340DC8 = (uint64_t (*)(_QWORD, _QWORD))CFBundleGetFunctionPointerForName((CFBundleRef)qword_100340DF0, CFSTR("PLShouldLogRegisteredEvent"));
      off_100340DD0 = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD))CFBundleGetFunctionPointerForName((CFBundleRef)qword_100340DF0, CFSTR("PLLogRegisteredEvent"));
      FunctionPointerForName = CFBundleGetFunctionPointerForName((CFBundleRef)qword_100340DF0, CFSTR("PLLogTimeSensitiveRegisteredEvent"));
      qword_100340DD8 = (uint64_t)FunctionPointerForName;
      if (!off_100340DC8 || !off_100340DD0 || !FunctionPointerForName)
      {
        CFRelease((CFTypeRef)qword_100340DF0);
        qword_100340DF0 = 0;
      }
    }
  }
}

void sub_1000323E0(id a1)
{
  const void *v1;
  NSObject *v2;
  const char *v3;
  int v4;
  const char *v5;

  v1 = sub_10000EF14("PLsetup");
  v2 = objc_claimAutoreleasedReturnValue(v1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (qword_100340DF0)
      v3 = "enabled";
    else
      v3 = "fault";
    v4 = 136315138;
    v5 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PowerLog %s", (uint8_t *)&v4, 0xCu);
  }

}

uint64_t sub_1000324A4(BOOL *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  _BYTE *v6;
  uint64_t v7;

  if (!a2)
    return 0;
  v7 = 0;
  result = ccder_decode_tl(1, &v7, a2, a3);
  if (result)
  {
    v6 = (_BYTE *)result;
    result = 0;
    if (a3 - (uint64_t)v6 >= 1 && v7 == 1)
    {
      if (a1)
        *a1 = *v6 != 0;
      return (uint64_t)(v6 + 1);
    }
  }
  return result;
}

BOOL sub_10003252C(int a1, CFTypeRef *a2, CFStringRef format, ...)
{
  __CFString *v5;
  va_list va;

  va_start(va, format);
  if (a1 && a2)
  {
    v5 = (__CFString *)*a2;
    *a2 = 0;
    sub_10001A09C(a1, kCFErrorDomainMach, v5, a2, format, va);
  }
  return a1 == 0;
}

BOOL sub_100032590(int a1, CFTypeRef *a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  CFIndex v12;
  __CFString *v13;
  CFStringRef v14;
  char *v15;
  uint64_t v16;

  if (a1)
  {
    if (a2)
    {
      v12 = *__error();
      v13 = (__CFString *)*a2;
      *a2 = 0;
      v14 = CFStringCreateWithFormatAndArguments(kCFAllocatorDefault, 0, a3, &a9);
      v15 = strerror(v12);
      sub_100032660(v12, kCFErrorDomainPOSIX, v13, a2, v16, CFSTR("%@: [%d] %s"), v14, v12, v15, &a9);
      if (v14)
        CFRelease(v14);
    }
  }
  return a1 == 0;
}

void sub_100032660(CFIndex a1, const __CFString *a2, __CFString *a3, CFTypeRef *a4, uint64_t a5, CFStringRef format, ...)
{
  va_list va;

  va_start(va, format);
  sub_10001A09C(a1, a2, a3, a4, format, va);
}

uint64_t sub_10003268C(uint64_t a1, CFTypeRef *a2, CFStringRef format, ...)
{
  __CFString *v5;
  va_list va;

  va_start(va, format);
  if (a2 && (a1 & 1) == 0)
  {
    v5 = (__CFString *)*a2;
    *a2 = 0;
    sub_10001A09C(-50, kCFErrorDomainOSStatus, v5, a2, format, va);
  }
  return a1;
}

BOOL sub_1000326EC(uint64_t a1, CFTypeRef *a2, CFStringRef format, ...)
{
  __CFString *v5;
  va_list va;

  va_start(va, format);
  if (!a1 && a2)
  {
    v5 = (__CFString *)*a2;
    *a2 = 0;
    sub_10001A09C(-108, kCFErrorDomainOSStatus, v5, a2, format, va);
  }
  return a1 != 0;
}

void sub_100032750(uint64_t a1)
{
  uint64_t v2;
  dispatch_time_t v3;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2)
    (*(void (**)(void))(v2 + 16))();
  dispatch_suspend(*(dispatch_object_t *)(a1 + 8));
  v3 = dispatch_time(0, 1000000000 * *(_QWORD *)(a1 + 24));
  dispatch_after_f(v3, *(dispatch_queue_t *)a1, *(void **)(a1 + 8), (dispatch_function_t)&_dispatch_resume);
}

void sub_1000327A8(uint64_t a1)
{
  const void *v2;

  dispatch_release(*(dispatch_object_t *)a1);
  v2 = *(const void **)(a1 + 16);
  if (v2)
    _Block_release(v2);
  free((void *)a1);
}

NSObject *sub_1000327DC(const char *a1, uint64_t a2)
{
  NSObject *v3;
  NSObject *v4;
  _QWORD *v5;

  v3 = dispatch_queue_create(a1, 0);
  v4 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_data_add, 0, 0, v3);
  v5 = malloc_type_malloc(0x20uLL, 0x10A0040A7A12BA5uLL);
  *v5 = v3;
  v5[1] = v4;
  v5[2] = 0;
  v5[3] = a2;
  dispatch_set_context(v4, v5);
  dispatch_source_set_event_handler_f(v4, (dispatch_function_t)sub_100032750);
  dispatch_set_finalizer_f(v4, (dispatch_function_t)sub_1000327A8);
  return v4;
}

__CFData *sub_100032878(const __CFData *a1)
{
  CFIndex Length;
  const __CFAllocator *v3;
  const UInt8 *BytePtr;
  CFIndex *v5;

  Length = CFDataGetLength(a1);
  v3 = CFGetAllocator(a1);
  BytePtr = CFDataGetBytePtr(a1);
  v5 = (CFIndex *)ccsha256_di(BytePtr);
  return sub_100019B00(v3, v5, Length, (uint64_t)BytePtr);
}

void sub_100032A34(uint64_t a1, void *a2)
{
  uint64_t v3;
  id v4;
  void *v5;
  unint64_t v6;
  uint64_t v7;
  id v8;

  v8 = a2;
  v3 = objc_opt_class(NSString);
  if ((objc_opt_isKindOfClass(v8, v3) & 1) != 0)
    v4 = v8;
  else
    v4 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "description"));
  v5 = v4;
  v6 = *(_QWORD *)(a1 + 40);
  if (v6 && v6 < (unint64_t)objc_msgSend(v4, "length"))
  {
    v7 = objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "substringToIndex:", *(_QWORD *)(a1 + 40)));

    v5 = (void *)v7;
  }
  objc_msgSend(*(id *)(a1 + 32), "insertObject:atIndex:", v5, 0);

}

void sub_100032B9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_100032BB4(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  id result;

  result = objc_msgSend(*(id *)(a1 + 32), "containsObject:", a2);
  if ((result & 1) == 0)
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
    *a3 = 1;
  }
  return result;
}

void sub_100032D08(uint64_t a1, void *a2, void *a3)
{
  void *v5;
  id v6;
  void *v7;
  uint64_t v8;
  char isKindOfClass;
  void *v10;
  uint64_t v11;
  id v12;

  v5 = *(void **)(a1 + 32);
  v6 = a3;
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a2, "stringByAppendingString:", CFSTR(":")));
  objc_msgSend(v5, "addObject:", v7);

  v8 = objc_opt_class(NSArray);
  isKindOfClass = objc_opt_isKindOfClass(v6, v8);
  v10 = *(void **)(a1 + 32);
  if ((isKindOfClass & 1) != 0)
    v11 = objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "componentsJoinedByString:", CFSTR(" ")));
  else
    v11 = objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@"), v6));
  v12 = (id)v11;

  objc_msgSend(v10, "addObject:", v12);
}

uint64_t sub_100032FF4(CFNullRef *a1, CFTypeRef *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;

  v8 = 0;
  result = ccder_decode_tl(5, &v8, a3, a4);
  if (!result || v8)
  {
    sub_100032660(-1, CFSTR("com.apple.security.cfder.error"), 0, a2, v7, CFSTR("Unknown null encoding"));
    return 0;
  }
  else
  {
    *a1 = kCFNull;
  }
  return result;
}

uint64_t sub_100033070(CFTypeRef *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;

  v5 = ccder_encode_tl(5, 0, a2, a3);
  if (!v5)
    sub_100032660(-7, CFSTR("com.apple.security.cfder.error"), 0, a1, v4, CFSTR("ccder failed to encode"));
  return v5;
}

unint64_t sub_1000330CC(const __CFAllocator *a1, CFTypeRef *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  __CFSet *Mutable;
  BOOL v12;
  void *v13;
  void *value;
  unint64_t v16;

  if (!a4)
  {
    sub_100032660(-6, CFSTR("com.apple.security.cfder.error"), 0, a3, a5, CFSTR("null input"));
    return 0;
  }
  v16 = 0;
  v9 = ccder_decode_constructed_tl(0xC000000000000011, &v16, a4, a5);
  if (!v9)
  {
    sub_100032660(-1, CFSTR("com.apple.security.cfder.error"), 0, a3, v8, CFSTR("Unknown data encoding, expected CCDER_CONSTRUCTED_CFSET"));
    return v9;
  }
  Mutable = CFSetCreateMutable(a1, 0, &kCFTypeSetCallBacks);
  if (Mutable)
  {
    v12 = v9 == v16;
    if (v9 < v16)
    {
      do
      {
        value = 0;
        v9 = sub_100020974((int)a1, (int)&value, (int)a3);
        v13 = value;
        if (v9)
          CFSetAddValue(Mutable, value);
        if (v13)
          CFRelease(v13);
      }
      while (v9 && v9 < v16);
      v12 = v9 == v16;
    }
    if (!v12)
    {
      CFRelease(Mutable);
      return v9;
    }
  }
  else
  {
    sub_100032660(-3, CFSTR("com.apple.security.cfder.error"), 0, a3, v10, CFSTR("Failed to create set"));
    v9 = 0;
    if (v16)
      return v9;
  }
  if (*a2)
    CFRelease(*a2);
  *a2 = Mutable;
  return v9;
}

uint64_t sub_100033244(const __CFSet *a1, uint64_t a2)
{
  __int128 v3;
  uint64_t v4;

  v3 = xmmword_100248F20;
  LOBYTE(v3) = 1;
  v4 = a2;
  CFSetApplyFunction(a1, (CFSetApplierFunction)sub_1000332A4, &v3);
  if ((_BYTE)v3)
    return ccder_sizeof(0xC000000000000011, *((_QWORD *)&v3 + 1));
  else
    return 0;
}

uint64_t sub_1000332A4(uint64_t result, uint64_t a2)
{
  if (*(_BYTE *)a2)
  {
    result = sub_1000212A4(result, *(_QWORD *)(a2 + 16));
    if (result)
      *(_QWORD *)(a2 + 8) += result;
    else
      *(_BYTE *)a2 = 0;
  }
  return result;
}

uint64_t sub_1000332E8(const __CFSet *a1, CFTypeRef *a2, char a3, uint64_t a4, uint64_t a5)
{
  CFMutableArrayRef Mutable;
  CFIndex Count;
  uint64_t v12;
  unint64_t v13;
  const __CFData *ValueAtIndex;
  CFIndex Length;
  const UInt8 *BytePtr;
  uint64_t result;
  uint64_t v18;
  _QWORD v19[4];
  CFRange v20;

  Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  v19[0] = 0xAAAAAAAAAAAAAA01;
  v19[1] = a2;
  BYTE1(v19[0]) = a3;
  v19[2] = Mutable;
  v19[3] = 0;
  CFSetApplyFunction(a1, (CFSetApplierFunction)sub_10003345C, v19);
  if (!LOBYTE(v19[0]))
  {
    if (Mutable)
      CFRelease(Mutable);
    return 0;
  }
  v20.length = CFArrayGetCount(Mutable);
  v20.location = 0;
  CFArraySortValues(Mutable, v20, (CFComparatorFunction)sub_100033530, 0);
  Count = CFArrayGetCount(Mutable);
  v12 = a5;
  if (Count >= 1)
  {
    v13 = Count + 1;
    v12 = a5;
    do
    {
      ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(Mutable, v13 - 2);
      Length = CFDataGetLength(ValueAtIndex);
      BytePtr = CFDataGetBytePtr(ValueAtIndex);
      v12 = ccder_encode_body(Length, BytePtr, a4, v12);
      --v13;
    }
    while (v13 > 1);
  }
  if (Mutable)
    CFRelease(Mutable);
  result = ccder_encode_constructed_tl(0xC000000000000011, a5, a4, v12);
  if (!result)
  {
    sub_100032660(-7, CFSTR("com.apple.security.cfder.error"), 0, a2, v18, CFSTR("ccder failed to encode"));
    return 0;
  }
  return result;
}

void sub_10003345C(const __CFString *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  CFIndex v7;
  CFIndex v8;
  __CFData *Mutable;
  UInt8 *MutableBytePtr;
  uint64_t v11;
  CFRange v12;

  if (*(_BYTE *)a2)
  {
    v7 = sub_1000212A4(a1, *(CFTypeRef **)(a2 + 8), a3, a4, a5);
    if (!v7)
    {
      *(_BYTE *)a2 = 0;
      return;
    }
    v8 = v7;
    Mutable = CFDataCreateMutable(*(CFAllocatorRef *)(a2 + 24), v7);
    CFDataSetLength(Mutable, v8);
    MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    v11 = sub_100020FA0(a1, *(_QWORD *)(a2 + 8), *(unsigned __int8 *)(a2 + 1), MutableBytePtr, &MutableBytePtr[v8]);
    if (v11)
    {
      v12.length = v11 - (_QWORD)MutableBytePtr;
      v12.location = 0;
      CFDataDeleteBytes(Mutable, v12);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a2 + 16), Mutable);
      if (!Mutable)
        return;
    }
    else
    {
      *(_BYTE *)a2 = 0;
      if (!Mutable)
        return;
    }
    CFRelease(Mutable);
  }
}

uint64_t sub_100033530(const __CFData *a1, const __CFData *a2)
{
  CFIndex Length;
  CFIndex v5;
  unint64_t v6;
  size_t v7;
  const UInt8 *BytePtr;
  const UInt8 *v9;
  int v10;
  uint64_t v12;
  uint64_t v13;

  Length = CFDataGetLength(a1);
  v5 = CFDataGetLength(a2);
  v6 = v5;
  if (Length < 0 || v5 < 0)
  {
    if (Length >= v5)
      v12 = 0;
    else
      v12 = -1;
    if (Length <= v5)
      return v12;
    else
      return 1;
  }
  else
  {
    if (Length >= v5)
      v7 = v5;
    else
      v7 = Length;
    BytePtr = CFDataGetBytePtr(a1);
    v9 = CFDataGetBytePtr(a2);
    v10 = memcmp(BytePtr, v9, v7);
    if (v10 <= 0 && (v10 || Length <= v6))
    {
      LODWORD(v13) = v10 == 0;
      if (Length >= v6)
        LODWORD(v13) = 0;
      if (v10 < 0)
        v13 = 1;
      else
        v13 = v13;
      return v13 << 63 >> 63;
    }
    else
    {
      return 1;
    }
  }
}

uint64_t sub_1000335F4()
{
  _QWORD block[5];

  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100033670;
  block[3] = &unk_1002DB868;
  block[4] = &qword_100340E00;
  if (qword_100340DF8 != -1)
    dispatch_once(&qword_100340DF8, block);
  return qword_100340E00;
}

dispatch_queue_t sub_100033670(uint64_t a1)
{
  dispatch_queue_t result;

  result = dispatch_queue_create("AKS Lock Assertion Queue", 0);
  **(_QWORD **)(a1 + 32) = result;
  return result;
}

BOOL sub_1000336A4(int a1, CFTypeRef *a2)
{
  NSObject *v4;
  _BOOL8 v5;
  _QWORD block[6];
  int v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  int v12;

  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = 0;
  v4 = sub_1000335F4();
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_10003375C;
  block[3] = &unk_1002DB890;
  block[4] = &v9;
  block[5] = 60;
  v8 = a1;
  dispatch_sync(v4, block);
  v5 = sub_10003252C(*((_DWORD *)v10 + 6), a2, CFSTR("Kern return error"));
  _Block_object_dispose(&v9, 8);
  return v5;
}

uint64_t sub_10003375C(uint64_t result)
{
  uint64_t v1;
  NSObject *v2;
  uint64_t v3;
  int v4;
  uint64_t v5;

  v1 = result;
  if (!dword_100340E08)
  {
    v2 = sub_10000EF14("lockassertions");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      v3 = *(_QWORD *)(v1 + 40);
      v4 = 134217984;
      v5 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Requesting lock assertion for %lld seconds", (uint8_t *)&v4, 0xCu);
    }
    result = sub_1000267F0(*(_DWORD *)(v1 + 48), 0, *(_QWORD *)(v1 + 40));
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v1 + 32) + 8) + 24) = result;
  }
  if (!*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v1 + 32) + 8) + 24))
    ++dword_100340E08;
  return result;
}

BOOL sub_10003384C(int a1, CFTypeRef *a2)
{
  NSObject *v4;
  _BOOL8 v5;
  _QWORD v7[5];
  int v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  int v12;

  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = 0;
  v4 = sub_1000335F4();
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_100033900;
  v7[3] = &unk_1002DB8B8;
  v7[4] = &v9;
  v8 = a1;
  dispatch_sync(v4, v7);
  v5 = sub_10003252C(*((_DWORD *)v10 + 6), a2, CFSTR("Kern return error"));
  _Block_object_dispose(&v9, 8);
  return v5;
}

uint64_t sub_100033900(uint64_t result)
{
  int v1;
  uint64_t v2;
  NSObject *v3;
  uint8_t v4[16];

  v1 = dword_100340E08;
  if (dword_100340E08)
  {
    --dword_100340E08;
    if (v1 == 1)
    {
      v2 = result;
      v3 = sub_10000EF14("lockassertions");
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v4 = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Dropping lock assertion", v4, 2u);
      }
      result = sub_1000268D0(*(_DWORD *)(v2 + 40), 0);
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 32) + 8) + 24) = result;
    }
  }
  return result;
}

BOOL sub_100033998(int a1, CFTypeRef *a2, uint64_t a3)
{
  _BOOL8 result;

  result = sub_1000336A4(a1, a2);
  if (result)
  {
    (*(void (**)(uint64_t))(a3 + 16))(a3);
    return sub_10003384C(a1, a2);
  }
  return result;
}

void sub_1000339F0(int a1, uint64_t a2)
{
  CFTypeRef v4;
  NSObject *v5;
  CFTypeRef v6;
  CFTypeRef cf;
  uint8_t buf[4];
  int v9;
  __int16 v10;
  CFTypeRef v11;

  cf = 0;
  if (sub_1000336A4(a1, &cf))
  {
    (*(void (**)(uint64_t))(a2 + 16))(a2);
    sub_10003384C(a1, &cf);
    v4 = cf;
    if (cf)
    {
      cf = 0;
      CFRelease(v4);
    }
  }
  else
  {
    v5 = sub_10000EF14("secaks");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109378;
      v9 = a1;
      v10 = 2112;
      v11 = cf;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "SecAKSDoWithKeybagLockAssertionSoftly: failed to get assertion for %d proceeding bravely: %@", buf, 0x12u);
    }
    v6 = cf;
    if (cf)
    {
      cf = 0;
      CFRelease(v6);
    }
    (*(void (**)(uint64_t))(a2 + 16))(a2);
  }
}

uint64_t sub_100033B04()
{
  if (qword_100340E30 != -1)
    dispatch_once(&qword_100340E30, &stru_1002DB978);
  if ((byte_100340E28 & 1) != 0)
    return 1;
  if (qword_100340E40 != -1)
    dispatch_once(&qword_100340E40, &stru_1002DB9B8);
  return byte_100340E38;
}

void sub_100033B80(id a1)
{
  NSObject *v1;
  size_t __len;
  uint8_t buf[4];
  int v4;
  char __big[1024];

  __len = 1023;
  bzero(__big, 0x400uLL);
  if (!sysctlbyname("kern.bootargs", __big, &__len, 0, 0) && strnstr(__big, "-apfs_shared_datavolume", __len))
    byte_100340E38 = 1;
  v1 = sub_10000EF14("eapfs");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    v4 = byte_100340E38;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "eapfs boot-arg set to %{BOOL}d", buf, 8u);
  }
}

void sub_100033C7C(id a1)
{
  io_registry_entry_t v1;
  io_object_t v2;
  CFTypeRef CFProperty;
  NSObject *v4;
  _DWORD v5[2];

  v1 = IORegistryEntryFromPath(kIOMainPortDefault, "IODeviceTree:/filesystems");
  if (v1)
  {
    v2 = v1;
    CFProperty = IORegistryEntryCreateCFProperty(v1, CFSTR("e-apfs"), kCFAllocatorDefault, 0);
    if (CFProperty)
    {
      CFRelease(CFProperty);
      byte_100340E28 = 1;
    }
    IOObjectRelease(v2);
  }
  v4 = sub_10000EF14("eapfs");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5[0] = 67109120;
    v5[1] = byte_100340E28;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "eapfs IODT set to %{BOOL}d", (uint8_t *)v5, 8u);
  }
}

void sub_100033D78(id a1)
{
  void *v1;
  void *v2;
  uint64_t v3;
  const void *v4;
  const void **v5;
  void *v6;
  void *v7;
  CFTypeRef *v8;
  void *v9;
  NSObject *v10;
  char *v11;
  void *value;
  uint8_t buf[8];
  uint8_t *v14;
  uint64_t v15;
  void *v16;

  *(_QWORD *)buf = 0;
  v14 = buf;
  v15 = 0x2000000000;
  v1 = off_100340E48;
  v16 = off_100340E48;
  if (!off_100340E48)
  {
    v2 = (void *)sub_100033F5C();
    v1 = dlsym(v2, "MKBUserTypeDeviceMode");
    *((_QWORD *)v14 + 3) = v1;
    off_100340E48 = v1;
  }
  _Block_object_dispose(buf, 8);
  if (!v1)
  {
LABEL_18:
    v11 = dlerror();
    abort_report_np("%s", v11);
    sub_100033F5C();
    return;
  }
  v3 = ((uint64_t (*)(_QWORD, _QWORD))v1)(0, 0);
  if (v3)
  {
    v4 = (const void *)v3;
    value = 0;
    *(_QWORD *)buf = 0;
    v14 = buf;
    v15 = 0x2000000000;
    v5 = (const void **)qword_100340E58;
    v16 = (void *)qword_100340E58;
    if (!qword_100340E58)
    {
      v6 = (void *)sub_100033F5C();
      v5 = (const void **)dlsym(v6, "kMKBDeviceModeKey");
      *((_QWORD *)v14 + 3) = v5;
      qword_100340E58 = (uint64_t)v5;
    }
    _Block_object_dispose(buf, 8);
    if (v5)
    {
      if (!CFDictionaryGetValueIfPresent((CFDictionaryRef)v4, *v5, (const void **)&value))
      {
LABEL_14:
        CFRelease(v4);
        return;
      }
      v7 = value;
      *(_QWORD *)buf = 0;
      v14 = buf;
      v15 = 0x2000000000;
      v8 = (CFTypeRef *)qword_100340E60;
      v16 = (void *)qword_100340E60;
      if (!qword_100340E60)
      {
        v9 = (void *)sub_100033F5C();
        v8 = (CFTypeRef *)dlsym(v9, "kMKBDeviceModeSharedIPad");
        *((_QWORD *)v14 + 3) = v8;
        qword_100340E60 = (uint64_t)v8;
      }
      _Block_object_dispose(buf, 8);
      if (v8)
      {
        if (CFEqual(v7, *v8))
          byte_100340E0C = 1;
        goto LABEL_14;
      }
    }
    goto LABEL_18;
  }
  v10 = sub_10000EF14("edumode");
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Cannot determine because deviceMode is NULL", buf, 2u);
  }
}

uint64_t sub_100033F5C()
{
  uint64_t v0;
  char *v1;
  char *v3;
  __int128 v4;
  uint64_t v5;

  v3 = 0;
  if (!qword_100340E50)
  {
    v4 = off_1002DB9D8;
    v5 = 0;
    qword_100340E50 = _sl_dlopen(&v4, &v3);
    v1 = v3;
    v0 = qword_100340E50;
    if (qword_100340E50)
    {
      if (!v3)
        return v0;
    }
    else
    {
      v1 = (char *)abort_report_np("%s", v3);
    }
    free(v1);
    return v0;
  }
  return qword_100340E50;
}

void sub_10003401C(id a1)
{
  NSObject *v1;
  const char *v2;
  int v3;
  const char *v4;

  byte_100340E18 = _os_feature_enabled_impl("Security", "SeparateUserKeychain");
  v1 = sub_10000EF14("keychain");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_100340E18)
      v2 = "enabled";
    else
      v2 = "disabled";
    v3 = 136315138;
    v4 = v2;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "SeparateUserKeychain set via feature flag to %s", (uint8_t *)&v3, 0xCu);
  }
}

CFURLRef sub_1000340F0(int a1, uint64_t a2)
{
  CFURLRef v3;
  const __CFURL *v4;
  const __CFString *Copy;
  const __CFString *v6;
  CFURLRef v7;

  if (a1)
    v3 = CFURLCreateWithFileSystemPath(0, CFSTR("/"), kCFURLPOSIXPathStyle, 1u);
  else
    v3 = CFCopyHomeDirectoryURL();
  v4 = v3;
  if (a2)
    Copy = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@/%@"), CFSTR("Library/Keychains"), a2);
  else
    Copy = CFStringCreateCopy(kCFAllocatorDefault, CFSTR("Library/Keychains"));
  v6 = Copy;
  if (v4 && Copy)
  {
    v7 = CFURLCreateCopyAppendingPathComponent(kCFAllocatorDefault, v4, Copy, a2 == 0);
    CFRelease(v6);
LABEL_13:
    CFRelease(v4);
    return v7;
  }
  if (Copy)
    CFRelease(Copy);
  v7 = 0;
  if (v4)
    goto LABEL_13;
  return v7;
}

void sub_1000341DC(uint64_t a1, uint64_t a2)
{
  CFURLRef v4;
  const __CFURL *v5;
  UInt8 __b[1024];

  syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0);
  v4 = sub_1000340F0(1, a1);
  if (v4)
  {
    v5 = v4;
    memset(__b, 170, sizeof(__b));
    CFURLGetFileSystemRepresentation(v5, 0, __b, 1024);
    (*(void (**)(uint64_t, UInt8 *))(a2 + 16))(a2, __b);
    CFRelease(v5);
  }
}

void sub_10003429C(void *a1, unsigned int a2)
{
  const void *v4;
  NSObject *v5;
  int v6;
  uint64_t v7;
  id v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  _BYTE buf[24];
  void *v14;

  v4 = sub_10000EF14("SecError");
  v5 = objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412546;
    *(_QWORD *)&buf[4] = a1;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = a2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Simulating crash, reason: %@, code=%08x", buf, 0x12u);
  }

  v6 = dword_10033F080;
  if (dword_10033F080 != -1)
    goto LABEL_4;
  if (!qword_100340E68)
  {
    *(_OWORD *)buf = off_1002DB9F0;
    *(_QWORD *)&buf[16] = 0;
    qword_100340E68 = _sl_dlopen(buf, 0);
  }
  if (!qword_100340E68)
  {
    v6 = dword_10033F080;
LABEL_4:
    dword_10033F080 = v6 + 1;
    return;
  }
  v7 = getpid();
  v8 = a1;
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  *(_QWORD *)&buf[16] = 0x2020000000;
  v9 = off_100340E70;
  v14 = off_100340E70;
  if (!off_100340E70)
  {
    v10 = sub_1000344C8();
    v9 = dlsym(v10, "SimulateCrash");
    *(_QWORD *)(*(_QWORD *)&buf[8] + 24) = v9;
    off_100340E70 = v9;
  }
  _Block_object_dispose(buf, 8);
  if (!v9)
  {
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "BOOL soft_SimulateCrash(pid_t, mach_exception_data_type_t, NSString *__strong)"));
    objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, CFSTR("simulate_crash.m"), 22, CFSTR("%s"), dlerror());

    __break(1u);
  }
  ((void (*)(uint64_t, _QWORD, id))v9)(v7, a2, v8);

}

void sub_1000344A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *sub_1000344C8()
{
  void *v0;
  void *v1;
  void *v3;
  void *v4;
  __int128 v5;
  uint64_t v6;

  v4 = 0;
  if (!qword_100340E68)
  {
    v5 = off_1002DB9F0;
    v6 = 0;
    qword_100340E68 = _sl_dlopen(&v5, &v4);
  }
  v0 = (void *)qword_100340E68;
  if (!qword_100340E68)
  {
    v0 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "void *CrashReporterSupportLibrary(void)"));
    objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("simulate_crash.m"), 18, CFSTR("%s"), v4);

    __break(1u);
    goto LABEL_7;
  }
  v1 = v4;
  if (v4)
LABEL_7:
    free(v1);
  return v0;
}

void sub_1000345CC(void *a1, unsigned int a2)
{
  const void *v4;
  NSObject *v5;
  id v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  _BYTE buf[24];
  void *v12;

  v4 = sub_10000EF14("SecError");
  v5 = objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412546;
    *(_QWORD *)&buf[4] = a1;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = a2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "stackshot report, reason: %@, code=%08x", buf, 0x12u);
  }

  if (dword_10033F080 == -1)
    goto LABEL_7;
  if (!qword_100340E68)
  {
    *(_OWORD *)buf = off_1002DB9F0;
    *(_QWORD *)&buf[16] = 0;
    qword_100340E68 = _sl_dlopen(buf, 0);
  }
  if (!qword_100340E68)
  {
LABEL_7:
    if (!qword_100340E68)
    {
      *(_OWORD *)buf = off_1002DB9F0;
      *(_QWORD *)&buf[16] = 0;
      qword_100340E68 = _sl_dlopen(buf, 0);
    }
    if (qword_100340E68)
    {
      v6 = a1;
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = buf;
      *(_QWORD *)&buf[16] = 0x2020000000;
      v7 = off_100340E78;
      v12 = off_100340E78;
      if (!off_100340E78)
      {
        v8 = sub_1000344C8();
        v7 = dlsym(v8, "WriteStackshotReport");
        *(_QWORD *)(*(_QWORD *)&buf[8] + 24) = v7;
        off_100340E78 = v7;
      }
      _Block_object_dispose(buf, 8);
      if (!v7)
      {
        v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
        v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "BOOL soft_WriteStackshotReport(NSString *__strong, mach_exception_data_type_t)"));
        objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, CFSTR("simulate_crash.m"), 25, CFSTR("%s"), dlerror());

        __break(1u);
      }
      ((void (*)(id, _QWORD))v7)(v6, a2);

    }
  }
}

void sub_1000347E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100035690(id a1)
{
  KeychainItemUpgradeRequestServer *v1;
  KeychainItemUpgradeRequestServer *v2;
  void *v3;
  id v4;

  v1 = [KeychainItemUpgradeRequestServer alloc];
  v4 = (id)objc_claimAutoreleasedReturnValue(+[CKKSLockStateTracker globalTracker](CKKSLockStateTracker, "globalTracker"));
  v2 = -[KeychainItemUpgradeRequestServer initWithLockStateTracker:](v1, "initWithLockStateTracker:", v4);
  v3 = (void *)qword_100340E80;
  qword_100340E80 = (uint64_t)v2;

}

void sub_100035878(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1000359E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100035B50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100035CD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100035EF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1000360B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  _Block_object_dispose(&a22, 8);
  _Block_object_dispose(&a26, 8);
  _Unwind_Resume(a1);
}

void sub_10003621C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1000364A8(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 168), 8);
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_100036614(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100036798(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10003691C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100036A88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100036BF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100036EC0(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 168), 8);
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_10003706C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100037298(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  uint64_t v28;

  _Block_object_dispose(&a28, 8);
  _Block_object_dispose((const void *)(v28 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_10003741C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1000375DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100037774(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1000378F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100037AA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100037C3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100037DD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100037FE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  uint64_t v26;

  _Block_object_dispose(&a26, 8);
  _Block_object_dispose((const void *)(v26 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_100038168(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100038314(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10003854C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 168), 8);
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_1000386D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100038868(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100038A08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100038B74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100038CF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100038E84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100038FF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10003919C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100039368(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  uint64_t v13;
  va_list va;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a12);
  va_start(va, a12);
  v13 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1000394EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100039670(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100039830(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  uint64_t v13;
  va_list va;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a12);
  va_start(va, a12);
  v13 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10003999C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100039B14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100039C80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100039E34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  uint64_t v13;
  va_list va;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a12);
  va_start(va, a12);
  v13 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100039FB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10003A130(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10003A3FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 168), 8);
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_10003A594(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10003A700(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10003A86C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10003A9D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10003AC24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10003AD90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10003AEFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10003B080(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10003B204(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10003B240(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper fetchPCSIdentityByPublicKeyWithSpecificUser:pcsservices:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper fetchPCSIdentityByPublicKeyWithSpecificUser:pcsservices:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003B3FC(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper fetchCurrentItemWithSpecificUser:items:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper fetchCurrentItemWithSpecificUser:items:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003B5B8(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper octagonContainsDistrustedRecoveryKeysWithSpecificUser:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper octagonContainsDistrustedRecoveryKeysWithSpecificUser:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003B770(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper fetchTrustedPeerCountWithSpecificUser:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper fetchTrustedPeerCountWithSpecificUser:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003B928(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper preflightRecoverOctagonUsingRecoveryKey:recoveryKey:salt:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper preflightRecoverOctagonUsingRecoveryKey:recoveryKey:salt:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003BAE0(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper performATOPRVActionsWithSpecificUser:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper performATOPRVActionsWithSpecificUser:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003BC94(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper removeRecoveryKey:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper removeRecoveryKey:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003BE4C(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper isRecoveryKeySet:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper isRecoveryKeySet:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003C004(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper recoverTLKSharesForInheritorWithSpecificUser:crk:tlkShares:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper recoverTLKSharesForInheritorWithSpecificUser:crk:tlkShares:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003C1C0(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      *(_DWORD *)buf = 136315650;
      v10 = "-[CuttlefishXPCWrapper prepareInheritancePeerWithSpecificUser:epoch:machineID:bottleSalt:bottleID:modelID:de"
            "viceName:serialNumber:osVersion:policyVersion:policySecrets:syncUserControllableViews:secureElementIdentity:"
            "signingPrivKeyPersistentRef:encPrivKeyPersistentRef:crk:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", buf, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315394;
      v10 = "-[CuttlefishXPCWrapper prepareInheritancePeerWithSpecificUser:epoch:machineID:bottleSalt:bottleID:modelID:de"
            "viceName:serialNumber:osVersion:policyVersion:policySecrets:syncUserControllableViews:secureElementIdentity:"
            "signingPrivKeyPersistentRef:encPrivKeyPersistentRef:crk:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", buf, 0x16u);
    }

    (*(void (**)(_QWORD, _QWORD))(a1[5] + 16))(a1[5], 0);
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003C390(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper fetchAccountSettingsWithSpecificUser:forceFetch:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper fetchAccountSettingsWithSpecificUser:forceFetch:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003C548(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper fetchRecoverableTLKSharesWithSpecificUser:peerID:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper fetchRecoverableTLKSharesWithSpecificUser:peerID:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003C700(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper resetAccountCDPContentsWithSpecificUser:idmsTargetContext:idmsCuttlefishPassword:noti"
            "fyIdMS:internalAccount:demoAccount:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper resetAccountCDPContentsWithSpecificUser:idmsTargetContext:idmsCuttlefishPassword:noti"
            "fyIdMS:internalAccount:demoAccount:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003C8B4(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper removeEscrowCacheWithSpecificUser:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper removeEscrowCacheWithSpecificUser:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003CA68(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper fetchViableEscrowRecordsWithSpecificUser:source:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper fetchViableEscrowRecordsWithSpecificUser:source:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003CC20(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper getSupportAppInfoWithSpecificUser:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper getSupportAppInfoWithSpecificUser:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003CDD8(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper requestHealthCheckWithSpecificUser:requiresEscrowCheck:repair:knownFederations:flowID"
            ":deviceSessionID:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper requestHealthCheckWithSpecificUser:requiresEscrowCheck:repair:knownFederations:flowID"
            ":deviceSessionID:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003CF90(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper findCustodianRecoveryKeyWithSpecificUser:uuid:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper findCustodianRecoveryKeyWithSpecificUser:uuid:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003D148(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper removeCustodianRecoveryKeyWithSpecificUser:uuid:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper removeCustodianRecoveryKeyWithSpecificUser:uuid:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003D2FC(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper createCustodianRecoveryKeyWithSpecificUser:recoveryKey:salt:ckksKeys:uuid:kind:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper createCustodianRecoveryKeyWithSpecificUser:recoveryKey:salt:ckksKeys:uuid:kind:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003D4B8(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper setRecoveryKeyWithSpecificUser:recoveryKey:salt:ckksKeys:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper setRecoveryKeyWithSpecificUser:recoveryKey:salt:ckksKeys:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003D670(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper fetchTrustStateWithSpecificUser:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper fetchTrustStateWithSpecificUser:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003D82C(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper fetchCurrentPolicyWithSpecificUser:modelIDOverride:isInheritedAccount:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper fetchCurrentPolicyWithSpecificUser:modelIDOverride:isInheritedAccount:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003D9E8(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper fetchPolicyDocumentsWithSpecificUser:versions:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper fetchPolicyDocumentsWithSpecificUser:versions:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003DBA0(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper fetchEscrowContentsWithSpecificUser:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper fetchEscrowContentsWithSpecificUser:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003DD60(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper fetchViableBottlesWithSpecificUser:source:flowID:deviceSessionID:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper fetchViableBottlesWithSpecificUser:source:flowID:deviceSessionID:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003DF1C(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper updateTLKsWithSpecificUser:ckksKeys:tlkShares:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper updateTLKsWithSpecificUser:ckksKeys:tlkShares:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003E0D4(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper setPreapprovedKeysWithSpecificUser:preapprovedKeys:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper setPreapprovedKeysWithSpecificUser:preapprovedKeys:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003E28C(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper updateWithSpecificUser:forceRefetch:deviceName:serialNumber:osVersion:policyVersion:p"
            "olicySecrets:syncUserControllableViews:secureElementIdentity:walrusSetting:webAccess:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper updateWithSpecificUser:forceRefetch:deviceName:serialNumber:osVersion:policyVersion:p"
            "olicySecrets:syncUserControllableViews:secureElementIdentity:walrusSetting:webAccess:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003E448(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper attemptPreapprovedJoinWithSpecificUser:ckksKeys:tlkShares:preapprovedKeys:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper attemptPreapprovedJoinWithSpecificUser:ckksKeys:tlkShares:preapprovedKeys:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003E608(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper preflightPreapprovedJoinWithSpecificUser:preapprovedKeys:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper preflightPreapprovedJoinWithSpecificUser:preapprovedKeys:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003E7C0(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper joinWithSpecificUser:voucherData:voucherSig:ckksKeys:tlkShares:preapprovedKeys:flowID"
            ":deviceSessionID:canSendMetrics:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper joinWithSpecificUser:voucherData:voucherSig:ckksKeys:tlkShares:preapprovedKeys:flowID"
            ":deviceSessionID:canSendMetrics:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003E980(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper vouchWithRerollWithSpecificUser:oldPeerID:tlkShares:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper vouchWithRerollWithSpecificUser:oldPeerID:tlkShares:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003EB44(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper vouchWithCustodianRecoveryKeyWithSpecificUser:crk:tlkShares:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper vouchWithCustodianRecoveryKeyWithSpecificUser:crk:tlkShares:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003ED08(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper vouchWithRecoveryKeyWithSpecificUser:recoveryKey:salt:tlkShares:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper vouchWithRecoveryKeyWithSpecificUser:recoveryKey:salt:tlkShares:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003EECC(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper preflightVouchWithCustodianRecoveryKeyWithSpecificUser:crk:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper preflightVouchWithCustodianRecoveryKeyWithSpecificUser:crk:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003F088(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper preflightVouchWithRecoveryKeyWithSpecificUser:recoveryKey:salt:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper preflightVouchWithRecoveryKeyWithSpecificUser:recoveryKey:salt:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003F244(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper vouchWithBottleWithSpecificUser:bottleID:entropy:bottleSalt:tlkShares:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper vouchWithBottleWithSpecificUser:bottleID:entropy:bottleSalt:tlkShares:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003F408(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper preflightVouchWithBottleWithSpecificUser:bottleID:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper preflightVouchWithBottleWithSpecificUser:bottleID:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003F5C8(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper vouchWithSpecificUser:peerID:permanentInfo:permanentInfoSig:stableInfo:stableInfoSig:"
            "ckksKeys:flowID:deviceSessionID:canSendMetrics:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper vouchWithSpecificUser:peerID:permanentInfo:permanentInfoSig:stableInfo:stableInfoSig:"
            "ckksKeys:flowID:deviceSessionID:canSendMetrics:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003F784(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper establishWithSpecificUser:ckksKeys:tlkShares:preapprovedKeys:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper establishWithSpecificUser:ckksKeys:tlkShares:preapprovedKeys:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003F944(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper prepareWithSpecificUser:epoch:machineID:bottleSalt:bottleID:modelID:deviceName:serial"
            "Number:osVersion:policyVersion:policySecrets:syncUserControllableViews:secureElementIdentity:setting:signing"
            "PrivKeyPersistentRef:encPrivKeyPersistentRef:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper prepareWithSpecificUser:epoch:machineID:bottleSalt:bottleID:modelID:deviceName:serial"
            "Number:osVersion:policyVersion:policySecrets:syncUserControllableViews:secureElementIdentity:setting:signing"
            "PrivKeyPersistentRef:encPrivKeyPersistentRef:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003FB10(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper fetchEgoEpochWithSpecificUser:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper fetchEgoEpochWithSpecificUser:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003FCC8(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper fetchAllowedMachineIDsWithSpecificUser:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper fetchAllowedMachineIDsWithSpecificUser:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10003FE80(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper handleRemovedMachineIDsDueToUnknownReasonsWithSpecificUser:machineIDs:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper handleRemovedMachineIDsDueToUnknownReasonsWithSpecificUser:machineIDs:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_100040034(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper handleEvictedMachineIDsWithSpecificUser:machineIDs:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper handleEvictedMachineIDsWithSpecificUser:machineIDs:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_1000401E8(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper markTrustedDeviceListFetchFailed:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper markTrustedDeviceListFetchFailed:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_10004039C(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper setAllowedMachineIDsWithSpecificUser:allowedMachineIDs:userInitiatedRemovals:evictedR"
            "emovals:unknownReasonRemovals:honorIDMSListChanges:version:flowID:deviceSessionID:canSendMetrics:altDSID:tru"
            "stedDeviceHash:deletedDeviceHash:trustedDevicesUpdateTimestamp:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper setAllowedMachineIDsWithSpecificUser:allowedMachineIDs:userInitiatedRemovals:evictedR"
            "emovals:unknownReasonRemovals:honorIDMSListChanges:version:flowID:deviceSessionID:canSendMetrics:altDSID:tru"
            "stedDeviceHash:deletedDeviceHash:trustedDevicesUpdateTimestamp:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_100040554(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper localResetWithSpecificUser:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper localResetWithSpecificUser:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_100040708(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper resetWithSpecificUser:resetReason:idmsTargetContext:idmsCuttlefishPassword:notifyIdMS"
            ":internalAccount:demoAccount:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper resetWithSpecificUser:resetReason:idmsTargetContext:idmsCuttlefishPassword:notifyIdMS"
            ":internalAccount:demoAccount:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_1000408BC(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper trustStatusWithSpecificUser:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper trustStatusWithSpecificUser:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_100040A74(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper distrustPeerIDsWithSpecificUser:peerIDs:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper distrustPeerIDsWithSpecificUser:peerIDs:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_100040C28(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper departByDistrustingSelfWithSpecificUser:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper departByDistrustingSelfWithSpecificUser:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_100040DDC(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[6] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper dumpWithSpecificUser:reply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper dumpWithSpecificUser:reply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);

}

void sub_100040F94(_QWORD *a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD v12[3];

  v3 = a2;
  if (*(int *)(*(_QWORD *)(a1[5] + 8) + 24) <= 4
    && objc_msgSend((id)objc_opt_class(a1[4]), "retryable:", v3))
  {
    v4 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
      v9 = 136315650;
      v10 = "-[CuttlefishXPCWrapper pingWithReply:]_block_invoke";
      v11 = 1024;
      LODWORD(v12[0]) = v6;
      WORD2(v12[0]) = 2112;
      *(_QWORD *)((char *)v12 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v9, 0x1Cu);
    }

    *(_BYTE *)(*(_QWORD *)(a1[6] + 8) + 24) = 1;
  }
  else
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315394;
      v10 = "-[CuttlefishXPCWrapper pingWithReply:]_block_invoke";
      v11 = 2112;
      v12[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v9, 0x16u);
    }

  }
  ++*(_DWORD *)(*(_QWORD *)(a1[5] + 8) + 24);

}

void sub_1000416A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000418DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000419F8(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  id WeakRetained;
  const void *v11;
  NSObject *v12;
  void *v13;
  void *v14;
  void *v15;
  id v16;
  id v17;
  const void *v18;
  NSObject *v19;
  const void *v20;
  NSObject *v21;
  void *v22;
  void *v23;
  void *v24;
  unsigned int v25;
  const void *v26;
  NSObject *v27;
  void *v28;
  OctagonPendingFlag *v29;
  void *v30;
  void *v31;
  const void *v32;
  NSObject *v33;
  void *v34;
  void *v35;
  void *v36;
  id v37;
  void *v38;
  id v39;
  _QWORD v40[4];
  id v41;
  uint8_t buf[4];
  id v43;
  __int16 v44;
  void *v45;

  v7 = a2;
  v8 = a3;
  v9 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (v8 && !v9)
  {
    v11 = sub_10000EF14("octagon-ckks");
    v12 = objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "viewList"));
      *(_DWORD *)buf = 138412546;
      v43 = v8;
      v44 = 2112;
      v45 = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Received syncing policy %@ with view list: %@", buf, 0x16u);

    }
    v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "stateHolder"));
    v40[0] = _NSConcreteStackBlock;
    v40[1] = 3221225472;
    v40[2] = sub_100041E70;
    v40[3] = &unk_1002EAF10;
    v16 = v8;
    v41 = v16;
    v39 = 0;
    objc_msgSend(v15, "persistAccountChanges:error:", v40, &v39);
    v17 = v39;

    if (v17)
    {
      v18 = sub_10000EF14("SecError");
      v19 = objc_claimAutoreleasedReturnValue(v18);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v43 = v17;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "octagon: failed to save policy+views: %@", buf, 0xCu);
      }

      objc_msgSend(WeakRetained, "setError:", v17);
    }
    else
    {
      v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
      v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v34, "ckks"));
      objc_msgSend(v35, "setCurrentSyncingPolicy:", v16);

      v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
      v37 = objc_msgSend(v36, "notifierClass");
      objc_msgSend(v37, "post:", OTUserControllableViewStatusChanged);

      v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "intendedState"));
      objc_msgSend(WeakRetained, "setNextState:", v38);

    }
LABEL_21:

    goto LABEL_22;
  }
  v20 = sub_10000EF14("SecError");
  v21 = objc_claimAutoreleasedReturnValue(v20);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    v43 = v9;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "octagon-ckks: setting user-controllable views status errored: %@", buf, 0xCu);
  }

  objc_msgSend(WeakRetained, "setError:", v9);
  v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
  v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "lockStateTracker"));
  v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
  v25 = objc_msgSend(v23, "isLockedError:", v24);

  if (v25)
  {
    v26 = sub_10000EF14("octagon-ckks");
    v27 = objc_claimAutoreleasedReturnValue(v26);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
      *(_DWORD *)buf = 138412290;
      v43 = v28;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Updating user-controllable view status failed because of lock state, will retry once unlocked: %@", buf, 0xCu);

    }
    v29 = -[OctagonPendingFlag initWithFlag:conditions:]([OctagonPendingFlag alloc], "initWithFlag:conditions:", CFSTR("attempt_ucv_upgrade"), 1);
    v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "flagHandler"));
    objc_msgSend(v31, "handlePendingFlag:", v29);

  }
  if (((unint64_t)objc_msgSend(v7, "peerStatus") & 0x24) != 0)
  {
    v32 = sub_10000EF14("octagon-ckks");
    v33 = objc_claimAutoreleasedReturnValue(v32);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "Updating user-controllable view status failed because our self peer is excluded or missing", buf, 2u);
    }

    v17 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "peerMissingState"));
    objc_msgSend(WeakRetained, "setNextState:", v17);
    goto LABEL_21;
  }
LABEL_22:

}

id sub_100041E70(uint64_t a1, void *a2)
{
  id v3;

  v3 = a2;
  objc_msgSend(v3, "setTPSyncingPolicy:", *(_QWORD *)(a1 + 32));
  return v3;
}

void sub_100041EA0(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v6;
  id WeakRetained;
  const void *v8;
  NSObject *v9;
  _BOOL4 v10;
  void *v11;
  uint8_t buf[4];
  id v13;

  v6 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v8 = sub_10000EF14("octagon-ckks");
  v9 = objc_claimAutoreleasedReturnValue(v8);
  v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    if (v10)
    {
      *(_DWORD *)buf = 138412290;
      v13 = v6;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Determining peers' user-controllable views policy failed: %@", buf, 0xCu);
    }

    objc_msgSend(WeakRetained, "setError:", v6);
  }
  else
  {
    if (v10)
    {
      if (a3 >= 4)
        v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("(unknown: %i)"), a3));
      else
        v11 = *(&off_1002DBA70 + a3);
      *(_DWORD *)buf = 138412290;
      v13 = v11;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Retrieved peers' user-controllable views policy as: %@", buf, 0xCu);

    }
    objc_msgSend(WeakRetained, "performWithStatus:", a3);
  }

}

void sub_1000462D0(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 96));
  _Unwind_Resume(a1);
}

void sub_100046480(uint64_t a1)
{
  id WeakRetained;
  void *v3;
  void *i;
  void *v5;
  void *v6;
  const void *v7;
  NSObject *v8;
  void *v9;
  NSObject *v10;
  void *v11;
  void *v12;
  void *v13;
  id v14;
  void *v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  void *v20;
  void *v21;
  id v22;
  id v23;
  uint64_t v24;
  void *k;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  unsigned __int8 v32;
  const void *v33;
  NSObject *v34;
  void *v35;
  const void *v36;
  NSObject *v37;
  void *v38;
  void *v39;
  const void *v40;
  NSObject *v41;
  void *v42;
  id v43;
  id v44;
  uint64_t v45;
  void *j;
  void *v47;
  const void *v48;
  NSObject *v49;
  void *v50;
  unsigned int v51;
  const void *v52;
  NSObject *v53;
  void *v54;
  unsigned int v55;
  void *v56;
  unsigned int v57;
  void *v58;
  unsigned int v59;
  void *v60;
  unsigned int v61;
  void *v62;
  void *v63;
  id obj;
  uint64_t v65;
  id v66;
  void *v67;
  void *v68;
  id v69;
  void *v70;
  uint64_t v71;
  void *v72;
  id v73;
  uint64_t v74;
  id v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  id v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  uint8_t buf[4];
  _BYTE v94[10];
  NSObject *v95;
  unsigned int v96;
  _BYTE v97[128];
  _BYTE v98[128];
  _BYTE v99[128];
  _BYTE v100[128];

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v68 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
  v67 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
  v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
  v62 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](NSMutableSet, "set"));
  v89 = 0u;
  v90 = 0u;
  v91 = 0u;
  v92 = 0u;
  obj = *(id *)(a1 + 32);
  v70 = WeakRetained;
  v66 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v89, v100, 16);
  if (v66)
  {
    v65 = *(_QWORD *)v90;
    do
    {
      for (i = 0; i != v66; i = (char *)i + 1)
      {
        if (*(_QWORD *)v90 != v65)
          objc_enumerationMutation(obj);
        v5 = *(void **)(*((_QWORD *)&v89 + 1) + 8 * (_QWORD)i);
        v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "error"));

        v72 = v5;
        if (!v6)
        {
          v87 = 0u;
          v88 = 0u;
          v85 = 0u;
          v86 = 0u;
          v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "keysets"));
          v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "allKeys"));

          v69 = v16;
          v73 = objc_msgSend(v16, "countByEnumeratingWithState:objects:count:", &v85, v99, 16);
          if (!v73)
            goto LABEL_51;
          v63 = i;
          v71 = *(_QWORD *)v86;
          while (1)
          {
            v17 = 0;
            do
            {
              if (*(_QWORD *)v86 != v71)
                objc_enumerationMutation(v69);
              v74 = v17;
              v18 = *(_QWORD *)(*((_QWORD *)&v85 + 1) + 8 * v17);
              v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "keysets"));
              v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "objectForKeyedSubscript:", v18));

              v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "viewFilter"));
              if (!v21)
              {
LABEL_29:
                v80 = 0;
                v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "asKeychainBackedSet:", &v80));
                v34 = v80;
                if (v35)
                {
                  v36 = sub_10000EF14("octagon-ckks");
                  v37 = objc_claimAutoreleasedReturnValue(v36);
                  if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 138412290;
                    *(_QWORD *)v94 = v20;
                    _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "Have proposed keys: %@", buf, 0xCu);
                  }

                  v38 = v68;
                  v39 = v35;
                  goto LABEL_37;
                }
                if (v20)
                {
                  v40 = sub_10000EF14("octagon-ckks");
                  v41 = objc_claimAutoreleasedReturnValue(v40);
                  if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 138412546;
                    *(_QWORD *)v94 = v20;
                    *(_WORD *)&v94[8] = 2112;
                    v95 = v34;
                    _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "Unable to convert proposed keys: %@ %@", buf, 0x16u);
                  }

                  v38 = v67;
                  v39 = v20;
LABEL_37:
                  objc_msgSend(v38, "addObject:", v39);
                }
                v78 = 0u;
                v79 = 0u;
                v76 = 0u;
                v77 = 0u;
                v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "pendingTLKShares"));
                v43 = objc_msgSend(v42, "countByEnumeratingWithState:objects:count:", &v76, v97, 16);
                if (v43)
                {
                  v44 = v43;
                  v45 = *(_QWORD *)v77;
                  do
                  {
                    for (j = 0; j != v44; j = (char *)j + 1)
                    {
                      if (*(_QWORD *)v77 != v45)
                        objc_enumerationMutation(v42);
                      v47 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((_QWORD *)&v76 + 1)
                                                                                         + 8 * (_QWORD)j), "share"));
                      objc_msgSend(v3, "addObject:", v47);

                    }
                    v44 = objc_msgSend(v42, "countByEnumeratingWithState:objects:count:", &v76, v97, 16);
                  }
                  while (v44);
                }

                v48 = sub_10000EF14("octagon-ckks");
                v49 = objc_claimAutoreleasedReturnValue(v48);
                if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
                {
                  v50 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "pendingTLKShares"));
                  v51 = objc_msgSend(v50, "count");
                  *(_DWORD *)buf = 67109120;
                  *(_DWORD *)v94 = v51;
                  _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "Have %u pending tlk shares", buf, 8u);

                }
                goto LABEL_48;
              }
              v83 = 0u;
              v84 = 0u;
              v81 = 0u;
              v82 = 0u;
              v75 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "viewFilter"));
              v22 = objc_msgSend(v75, "countByEnumeratingWithState:objects:count:", &v81, v98, 16);
              if (v22)
              {
                v23 = v22;
                v24 = *(_QWORD *)v82;
                while (2)
                {
                  for (k = 0; k != v23; k = (char *)k + 1)
                  {
                    if (*(_QWORD *)v82 != v24)
                      objc_enumerationMutation(v75);
                    v26 = *(void **)(*((_QWORD *)&v81 + 1) + 8 * (_QWORD)k);
                    v27 = v20;
                    v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "zoneID"));
                    v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "zoneName"));
                    v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "zoneID"));
                    v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "zoneName"));
                    v32 = objc_msgSend(v29, "isEqualToString:", v31);

                    if ((v32 & 1) != 0)
                    {

                      v20 = v27;
                      goto LABEL_29;
                    }
                    v20 = v27;
                  }
                  v23 = objc_msgSend(v75, "countByEnumeratingWithState:objects:count:", &v81, v98, 16);
                  if (v23)
                    continue;
                  break;
                }
              }

              v33 = sub_10000EF14("octagon-ckks");
              v34 = objc_claimAutoreleasedReturnValue(v33);
              if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 138412290;
                *(_QWORD *)v94 = v20;
                _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Skipping keys: %@", buf, 0xCu);
              }
LABEL_48:
              WeakRetained = v70;

              v17 = v74 + 1;
              v5 = v72;
            }
            while ((id)(v74 + 1) != v73);
            v73 = objc_msgSend(v69, "countByEnumeratingWithState:objects:count:", &v85, v99, 16);
            if (!v73)
            {
              i = v63;
LABEL_51:
              v11 = v69;
LABEL_53:

              goto LABEL_54;
            }
          }
        }
        v7 = sub_10000EF14("octagon-ckks");
        v8 = objc_claimAutoreleasedReturnValue(v7);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "intendedZoneIDs"));
          v10 = objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "error"));
          *(_DWORD *)buf = 138412546;
          *(_QWORD *)v94 = v9;
          *(_WORD *)&v94[8] = 2112;
          v95 = v10;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "No keys for %@: %@", buf, 0x16u);

        }
        v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "error"));
        v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "domain"));
        if ((objc_msgSend(v12, "isEqualToString:", CFSTR("CKKSResultOperationError")) & 1) == 0)
        {

          goto LABEL_53;
        }
        v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "error"));
        v14 = objc_msgSend(v13, "code");

        if (v14 == (id)3)
        {
          v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "intendedZoneIDs"));
          objc_msgSend(v62, "unionSet:", v11);
          goto LABEL_53;
        }
LABEL_54:
        ;
      }
      v66 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v89, v100, 16);
    }
    while (v66);
  }

  objc_msgSend(WeakRetained, "setViewKeySets:", v68);
  objc_msgSend(WeakRetained, "setIncompleteKeySets:", v67);
  objc_msgSend(WeakRetained, "setPendingTLKShares:", v3);
  objc_msgSend(WeakRetained, "setZonesTimedOutWithoutKeysets:", v62);
  v52 = sub_10000EF14("octagon-ckks");
  v53 = objc_claimAutoreleasedReturnValue(v52);
  if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
  {
    v54 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "viewKeySets"));
    v55 = objc_msgSend(v54, "count");
    v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "incompleteKeySets"));
    v57 = objc_msgSend(v56, "count");
    v58 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v70, "pendingTLKShares"));
    v59 = objc_msgSend(v58, "count");
    v60 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v70, "zonesTimedOutWithoutKeysets"));
    v61 = objc_msgSend(v60, "count");
    *(_DWORD *)buf = 67109888;
    *(_DWORD *)v94 = v55;
    *(_WORD *)&v94[4] = 1024;
    *(_DWORD *)&v94[6] = v57;
    WeakRetained = v70;
    LOWORD(v95) = 1024;
    *(_DWORD *)((char *)&v95 + 2) = v59;
    HIWORD(v95) = 1024;
    v96 = v61;
    _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "Fetched %d key sets, %d broken key sets, %d pendingTLKShares, and %d views timing out", buf, 0x1Au);

  }
}

void sub_100046F2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  id *v15;

  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10004701C(uint64_t a1, void *a2)
{
  id v3;
  id WeakRetained;
  const void *v5;
  NSObject *v6;
  _BOOL4 v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  id v14;
  const void *v15;
  NSObject *v16;
  _BOOL4 v17;
  void *v18;
  id v19;
  uint8_t buf[4];
  id v21;
  __int16 v22;
  void *v23;
  __int16 v24;
  id v25;

  v3 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v5 = sub_10000EF14("octagon");
  v6 = objc_claimAutoreleasedReturnValue(v5);
  v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v7)
    {
      v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "containerName"));
      v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
      v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "contextID"));
      *(_DWORD *)buf = 138412802;
      v21 = v9;
      v22 = 2112;
      v23 = v11;
      v24 = 2112;
      v25 = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Unable to reset local cuttlefish for (%@,%@): %@", buf, 0x20u);

    }
    objc_msgSend(WeakRetained, "setError:", v3);
  }
  else
  {
    if (v7)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Successfully reset local cuttlefish", buf, 2u);
    }

    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "stateHolder"));
    v19 = 0;
    objc_msgSend(v13, "persistAccountChanges:error:", &stru_1002DBB10, &v19);
    v14 = v19;

    v15 = sub_10000EF14("octagon");
    v16 = objc_claimAutoreleasedReturnValue(v15);
    v17 = os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
    if (v14)
    {
      if (v17)
      {
        *(_DWORD *)buf = 138412290;
        v21 = v14;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Error resetting local account state: %@", buf, 0xCu);
      }
    }
    else
    {
      if (v17)
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Successfully reset local account state", buf, 2u);
      }

      v16 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "intendedState"));
      objc_msgSend(WeakRetained, "setNextState:", v16);
    }

  }
  v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishedOp"));
  objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v18);

}

OTAccountMetadataClassC *__cdecl sub_1000472AC(id a1, OTAccountMetadataClassC *a2)
{
  OTAccountMetadataClassC *v2;

  v2 = a2;
  -[OTAccountMetadataClassC setTrustState:](v2, "setTrustState:", 0);
  -[OTAccountMetadataClassC setPeerID:](v2, "setPeerID:", 0);
  -[OTAccountMetadataClassC setSyncingPolicy:](v2, "setSyncingPolicy:", 0);
  -[OTAccountMetadataClassC setVoucher:](v2, "setVoucher:", 0);
  -[OTAccountMetadataClassC setVoucherSignature:](v2, "setVoucherSignature:", 0);
  -[OTAccountMetadataClassC setTlkSharesForVouchedIdentitys:](v2, "setTlkSharesForVouchedIdentitys:", 0);
  -[OTAccountMetadataClassC setIsInheritedAccount:](v2, "setIsInheritedAccount:", 0);
  -[OTAccountMetadataClassC setWarmedEscrowCache:](v2, "setWarmedEscrowCache:", 0);
  -[OTAccountMetadataClassC setWarnedTooManyPeers:](v2, "setWarnedTooManyPeers:", 0);
  return v2;
}

void sub_100048338(id a1)
{
  uint64_t v1;
  void *v2;
  _QWORD v3[38];
  _QWORD v4[38];

  v3[0] = CFSTR("ready");
  v3[1] = CFSTR("error");
  v4[0] = &off_100309E18;
  v4[1] = &off_100309E30;
  v3[2] = CFSTR("initializing");
  v3[3] = CFSTR("initialized");
  v4[2] = &off_100309E48;
  v4[3] = &off_100309E60;
  v3[4] = CFSTR("fetchcomplete");
  v3[5] = CFSTR("unhealthy");
  v4[4] = &off_100309E78;
  v4[5] = &off_100309E90;
  v3[6] = CFSTR("needrefetch");
  v3[7] = CFSTR("fetching");
  v4[6] = &off_100309EA8;
  v4[7] = &off_100309EC0;
  v3[8] = CFSTR("resetzone");
  v3[9] = CFSTR("resetlocal");
  v4[8] = &off_100309ED8;
  v4[9] = &off_100309EF0;
  v3[10] = CFSTR("loggedout");
  v3[11] = CFSTR("zonecreationfailed");
  v4[10] = &off_100309F08;
  v4[11] = &off_100309F20;
  v3[12] = CFSTR("waitfortrust");
  v3[13] = CFSTR("process_key_hierarchy");
  v4[12] = &off_100309F38;
  v4[13] = &off_100309F50;
  v3[14] = CFSTR("check_zone_hierarchies");
  v3[15] = CFSTR("become_ready");
  v4[14] = &off_100309F68;
  v4[15] = &off_100309F80;
  v3[16] = CFSTR("lose_trust");
  v3[17] = CFSTR("tlkmissing");
  v4[16] = &off_100309F98;
  v4[17] = &off_100309FB0;
  v3[18] = CFSTR("wait_for_ck_account_status");
  v3[19] = CFSTR("begin_fetch");
  v4[18] = &off_100309FC8;
  v4[19] = &off_100309FE0;
  v3[20] = CFSTR("fixup_fetch_cip");
  v3[21] = CFSTR("fixup_fetch_tlkshares");
  v4[20] = &off_100309FF8;
  v4[21] = &off_10030A010;
  v3[22] = CFSTR("fixup_local_reload");
  v3[23] = CFSTR("fixup_resave_cdse");
  v4[22] = &off_10030A028;
  v4[23] = &off_10030A040;
  v3[24] = CFSTR("fixup_delete_tombstones");
  v3[25] = CFSTR("heal_tlk_shares");
  v4[24] = &off_10030A058;
  v4[25] = &off_10030A070;
  v3[26] = CFSTR("healtlksharesfailed");
  v3[27] = CFSTR("provide_key_hieararchy");
  v4[26] = &off_10030A088;
  v4[27] = &off_10030A0A0;
  v3[28] = CFSTR("provide_key_hieararchy_untrusted");
  v3[29] = CFSTR("process_incoming_queue");
  v4[28] = &off_10030A0B8;
  v4[29] = &off_10030A0D0;
  v3[30] = CFSTR("class_a_incoming_items_remaining");
  v3[31] = CFSTR("scan_local_items");
  v4[30] = &off_10030A0E8;
  v4[31] = &off_10030A100;
  v3[32] = CFSTR("reencrypt_outgoing_items");
  v3[33] = CFSTR("process_outgoing_queue");
  v4[32] = &off_10030A118;
  v4[33] = &off_10030A130;
  v3[34] = CFSTR("process_outgoing_queue_failed");
  v3[35] = CFSTR("handle_all_views");
  v4[34] = &off_10030A148;
  v4[35] = &off_10030A160;
  v3[36] = CFSTR("zone_creation_failed_due_to_network_error");
  v3[37] = CFSTR("zone_deletion_failed_due_to_network_error");
  v4[36] = &off_10030A178;
  v4[37] = &off_10030A190;
  v1 = objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v4, v3, 38));
  v2 = (void *)qword_100340E90;
  qword_100340E90 = v1;

}

void sub_1000486C0(id a1)
{
  void *v1;
  uint64_t v2;
  void *v3;
  _QWORD v4[23];

  v4[0] = CFSTR("fetch_requested");
  v4[1] = CFSTR("key_process_requested");
  v4[2] = CFSTR("trusted_peers_changed");
  v4[3] = CFSTR("dropped_items");
  v4[4] = CFSTR("ck_account_logged_in");
  v4[5] = CFSTR("ck_account_logged_out");
  v4[6] = CFSTR("ck_zone_missing");
  v4[7] = CFSTR("ck_change_token_expired");
  v4[8] = CFSTR("process_incoming_queue");
  v4[9] = CFSTR("process_outgoing_queue");
  v4[10] = CFSTR("item_reencryption_needed");
  v4[11] = CFSTR("trusted_operation_begin");
  v4[12] = CFSTR("trusted_operation_end");
  v4[13] = CFSTR("device_unlocked");
  v4[14] = CFSTR("fetch_complete");
  v4[15] = CFSTR("24_hr_notification");
  v4[16] = CFSTR("key_set");
  v4[17] = CFSTR("check_queues");
  v4[18] = CFSTR("policy_fresh");
  v4[19] = CFSTR("oqo_token");
  v4[20] = CFSTR("new_priority_views");
  v4[21] = CFSTR("zone_creation");
  v4[22] = CFSTR("zone_deletion");
  v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v4, 23));
  v2 = objc_claimAutoreleasedReturnValue(+[NSSet setWithArray:](NSSet, "setWithArray:", v1));
  v3 = (void *)qword_100340EA0;
  qword_100340EA0 = v2;

}

void sub_100049280(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10004935C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100049434(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100049518(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000495FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100049760(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100049B5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100049FCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10004A128(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10004A2B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10004A474(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_10004A484(uint64_t a1)
{

}

void sub_10004A48C(uint64_t a1, uint64_t a2)
{
  void *v2;
  void *v3;
  id v4;

  v2 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  v4 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "fromDatabaseRow:", a2));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "memoizeOriginalSelfWhereClause"));
  objc_msgSend(v2, "addObject:", v3);

}

void sub_10004A4E8(uint64_t a1, uint64_t a2)
{
  void *v2;
  void *v3;
  id v4;

  v2 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  v4 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "fromDatabaseRow:", a2));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "memoizeOriginalSelfWhereClause"));
  objc_msgSend(v2, "addObject:", v3);

}

void sub_10004A544(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  void *v5;
  id v6;

  v6 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "fromDatabaseRow:", a2));
  v3 = objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "memoizeOriginalSelfWhereClause"));
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v5 = *(void **)(v4 + 40);
  *(_QWORD *)(v4 + 40) = v3;

}

BOOL sub_10004A59C(uint64_t a1, uint64_t a2)
{
  _BOOL8 v3;
  id v4;
  NSObject *v5;
  CFTypeRef v6;
  _QWORD v8[4];
  id v9;
  CFTypeRef cf;
  uint8_t buf[4];
  CFTypeRef v12;

  cf = 0;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_10004A6C4;
  v8[3] = &unk_1002DBDE0;
  v9 = *(id *)(a1 + 32);
  v3 = sub_10001AC0C(a2, 5, &cf, (uint64_t)v8);
  if (cf)
  {
    v4 = sub_10000BDF4(CFSTR("ckkssql"), 0);
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      v12 = cf;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "error performing database transaction, major problems ahead: %@", buf, 0xCu);
    }

    v6 = cf;
    if (cf)
    {
      cf = 0;
      CFRelease(v6);
    }
  }

  return v3;
}

BOOL sub_10004A6C4()
{
  _BYTE *v0;
  _BYTE *v1;
  _BYTE *v2;
  _BYTE *v3;
  char v4;
  uint64_t v5;
  int v6;

  off_100340BB8();
  v1 = v0;
  *v0 = 1;
  off_100340BD0();
  v3 = v2;
  *v2 = v4;
  v6 = (*(uint64_t (**)(void))(*(_QWORD *)(v5 + 32) + 16))();
  *v3 = 0;
  *v1 = 0;
  return v6 == 1;
}

uint64_t sub_10004A730(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;
  void *v6;
  id v7;
  id v8;
  id v9;
  uint64_t v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  id v16;
  uint64_t v17;
  uint64_t v18;
  CFTypeRef *v19;
  id v20;
  uint64_t v21;
  _QWORD v23[4];
  id v24;
  id v25;
  id v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  _BYTE v34[128];

  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 80), "quotedString:", *(_QWORD *)(a1 + 32)));
  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 80), "quotedString:", *(_QWORD *)(a1 + 40)));
  v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
  v30 = 0u;
  v31 = 0u;
  v32 = 0u;
  v33 = 0u;
  v7 = *(id *)(a1 + 48);
  v8 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v30, v34, 16);
  if (v8)
  {
    v9 = v8;
    v10 = *(_QWORD *)v31;
    do
    {
      v11 = 0;
      do
      {
        if (*(_QWORD *)v31 != v10)
          objc_enumerationMutation(v7);
        v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 80), "quotedString:", *(_QWORD *)(*((_QWORD *)&v30 + 1) + 8 * (_QWORD)v11)));
        objc_msgSend(v6, "addObject:", v12);

        v11 = (char *)v11 + 1;
      }
      while (v9 != v11);
      v9 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v30, v34, 16);
    }
    while (v9);
  }

  v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "componentsJoinedByString:", CFSTR(", ")));
  v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "stringByAppendingFormat:", CFSTR(", %@"), v4));

  v15 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSSQLDatabaseObject makeWhereClause:](CKKSSQLDatabaseObject, "makeWhereClause:", *(_QWORD *)(a1 + 56)));
  v16 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("SELECT %@ FROM %@%@"), v14, v5, v15);
  v17 = *(_QWORD *)(a1 + 80);
  v18 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8);
  v23[0] = _NSConcreteStackBlock;
  v23[2] = sub_10004A9AC;
  v23[3] = &unk_1002DBD68;
  v19 = (CFTypeRef *)(v18 + 24);
  v23[1] = 3221225472;
  v28 = v17;
  v20 = *(id *)(a1 + 56);
  v21 = *(_QWORD *)(a1 + 72);
  v24 = v20;
  v27 = v21;
  v29 = a2;
  v25 = *(id *)(a1 + 48);
  v26 = *(id *)(a1 + 64);
  sub_10001E3C4(a2, (uint64_t)v16, v19, (uint64_t)v23);

  return 1;
}

void sub_10004A9AC(uint64_t a1, sqlite3_stmt *a2)
{
  uint64_t v4;
  CFTypeRef *v5;
  _QWORD v6[4];
  id v7;
  id v8;
  sqlite3_stmt *v9;

  objc_msgSend(*(id *)(a1 + 64), "bindWhereClause:whereDict:cferror:", a2, *(_QWORD *)(a1 + 32), *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24);
  v4 = *(_QWORD *)(a1 + 72);
  v5 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_10004AA74;
  v6[3] = &unk_1002DBD40;
  v7 = *(id *)(a1 + 40);
  v9 = a2;
  v8 = *(id *)(a1 + 48);
  sub_100019C40(v4, a2, v5, (uint64_t)v6);

}

void sub_10004AA74(_QWORD *a1)
{
  void *v2;
  uint64_t v3;
  _QWORD v4[6];
  _QWORD v5[5];
  id v6;

  v5[0] = 0;
  v5[1] = v5;
  v5[2] = 0x3032000000;
  v5[3] = sub_10004A474;
  v5[4] = sub_10004A484;
  v6 = (id)0xAAAAAAAAAAAAAAAALL;
  v6 = objc_alloc_init((Class)NSMutableDictionary);
  v2 = (void *)a1[4];
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_10004AB58;
  v4[3] = &unk_1002DBD18;
  v3 = a1[6];
  v4[4] = v5;
  v4[5] = v3;
  objc_msgSend(v2, "enumerateObjectsUsingBlock:", v4);
  (*(void (**)(void))(a1[5] + 16))();
  _Block_object_dispose(v5, 8);

}

void sub_10004AB40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10004AB58(uint64_t a1, void *a2, int a3)
{
  sqlite3_stmt *v5;
  id v6;
  const unsigned __int8 *v7;
  CKKSSQLResult *v8;
  uint64_t v9;
  id v10;
  id v11;

  v5 = *(sqlite3_stmt **)(a1 + 40);
  v6 = a2;
  v7 = sqlite3_column_text(v5, a3);
  v8 = [CKKSSQLResult alloc];
  if (v7)
    v9 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v7));
  else
    v9 = 0;
  v11 = (id)v9;
  v10 = -[CKKSSQLResult init:](v8, "init:", v9);
  objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), "setObject:forKeyedSubscript:", v10, v6);

  if (v7)
}

uint64_t sub_10004AC28(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  __CFString *v8;
  id v9;
  CFTypeRef *v10;
  id v11;
  uint64_t v12;
  _QWORD v14[4];
  id v15;
  id v16;
  id v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "componentsJoinedByString:", CFSTR(", ")));
  v5 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSSQLDatabaseObject makeWhereClause:](CKKSSQLDatabaseObject, "makeWhereClause:", *(_QWORD *)(a1 + 40)));
  v6 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSSQLDatabaseObject groupByClause:](CKKSSQLDatabaseObject, "groupByClause:", *(_QWORD *)(a1 + 48)));
  v7 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSSQLDatabaseObject orderByClause:](CKKSSQLDatabaseObject, "orderByClause:", *(_QWORD *)(a1 + 56)));
  if (*(uint64_t *)(a1 + 88) < 1)
    v8 = &stru_1002EE888;
  else
    v8 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR(" LIMIT %lu"), *(_QWORD *)(a1 + 88)));
  v9 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("SELECT %@ FROM %@%@%@%@%@;"),
         v4,
         *(_QWORD *)(a1 + 64),
         v5,
         v6,
         v7,
         v8);
  v10 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 24);
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  v14[2] = sub_10004ADE0;
  v14[3] = &unk_1002DBD68;
  v19 = *(_QWORD *)(a1 + 96);
  v11 = *(id *)(a1 + 40);
  v12 = *(_QWORD *)(a1 + 80);
  v15 = v11;
  v18 = v12;
  v20 = a2;
  v16 = *(id *)(a1 + 32);
  v17 = *(id *)(a1 + 72);
  sub_10001E3C4(a2, (uint64_t)v9, v10, (uint64_t)v14);

  return 1;
}

void sub_10004ADE0(uint64_t a1, sqlite3_stmt *a2)
{
  uint64_t v4;
  CFTypeRef *v5;
  _QWORD v6[4];
  id v7;
  id v8;
  sqlite3_stmt *v9;

  objc_msgSend(*(id *)(a1 + 64), "bindWhereClause:whereDict:cferror:", a2, *(_QWORD *)(a1 + 32), *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24);
  v4 = *(_QWORD *)(a1 + 72);
  v5 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_10004AEA8;
  v6[3] = &unk_1002DBD40;
  v7 = *(id *)(a1 + 40);
  v9 = a2;
  v8 = *(id *)(a1 + 48);
  sub_100019C40(v4, a2, v5, (uint64_t)v6);

}

void sub_10004AEA8(_QWORD *a1)
{
  void *v2;
  uint64_t v3;
  _QWORD v4[6];
  _QWORD v5[5];
  id v6;

  v5[0] = 0;
  v5[1] = v5;
  v5[2] = 0x3032000000;
  v5[3] = sub_10004A474;
  v5[4] = sub_10004A484;
  v6 = (id)0xAAAAAAAAAAAAAAAALL;
  v6 = objc_alloc_init((Class)NSMutableDictionary);
  v2 = (void *)a1[4];
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_10004AF8C;
  v4[3] = &unk_1002DBD18;
  v3 = a1[6];
  v4[4] = v5;
  v4[5] = v3;
  objc_msgSend(v2, "enumerateObjectsUsingBlock:", v4);
  (*(void (**)(void))(a1[5] + 16))();
  _Block_object_dispose(v5, 8);

}

void sub_10004AF74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10004AF8C(uint64_t a1, void *a2, int a3)
{
  sqlite3_stmt *v5;
  id v6;
  const unsigned __int8 *v7;
  CKKSSQLResult *v8;
  uint64_t v9;
  id v10;
  id v11;

  v5 = *(sqlite3_stmt **)(a1 + 40);
  v6 = a2;
  v7 = sqlite3_column_text(v5, a3);
  v8 = [CKKSSQLResult alloc];
  if (v7)
    v9 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v7));
  else
    v9 = 0;
  v11 = (id)v9;
  v10 = -[CKKSSQLResult init:](v8, "init:", v9);
  objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), "setObject:forKeyedSubscript:", v10, v6);

  if (v7)
}

uint64_t sub_10004B05C(uint64_t a1, uint64_t a2)
{
  void *v4;
  id v5;
  uint64_t v6;
  uint64_t v7;
  CFTypeRef *v8;
  id v9;
  uint64_t v10;
  _QWORD v12[4];
  id v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v4 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSSQLDatabaseObject makeWhereClause:](CKKSSQLDatabaseObject, "makeWhereClause:", *(_QWORD *)(a1 + 32)));
  v5 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("DELETE FROM %@%@;"),
         *(_QWORD *)(a1 + 40),
         v4);
  v6 = *(_QWORD *)(a1 + 56);
  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
  v12[0] = _NSConcreteStackBlock;
  v12[2] = sub_10004B148;
  v12[3] = &unk_1002DBCC8;
  v8 = (CFTypeRef *)(v7 + 24);
  v12[1] = 3221225472;
  v15 = v6;
  v9 = *(id *)(a1 + 32);
  v10 = *(_QWORD *)(a1 + 48);
  v13 = v9;
  v14 = v10;
  v16 = a2;
  sub_10001E3C4(a2, (uint64_t)v5, v8, (uint64_t)v12);

  return 1;
}

uint64_t sub_10004B148(uint64_t a1, sqlite3_stmt *a2)
{
  objc_msgSend(*(id *)(a1 + 48), "bindWhereClause:whereDict:cferror:", a2, *(_QWORD *)(a1 + 32), *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  return sub_100019C40(*(_QWORD *)(a1 + 56), a2, (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), (uint64_t)&stru_1002DBCA0);
}

void sub_10004B1A0(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  unsigned int v16;
  void *v17;
  void *v18;
  id v19;
  id v20;
  uint64_t v21;
  void *v22;
  sqlite3_stmt *v23;
  uint64_t v24;
  __CFString *v25;
  sqlite3_stmt *v26;
  uint64_t v27;
  __CFString *v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  _BYTE v33[128];

  v3 = a2;
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:", v3));
  v5 = objc_opt_class(v4);
  if (v5 == objc_opt_class(CKKSSQLWhereValue))
  {

    goto LABEL_15;
  }
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:", v3));
  v7 = objc_opt_class(v6);
  v8 = objc_opt_class(CKKSSQLWhereNullOrValue);

  if (v7 == v8)
  {
LABEL_15:
    v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:", v3));
    v23 = *(sqlite3_stmt **)(a1 + 48);
    v24 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
    v25 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "value"));
    sub_100013544(v23, v24, v25, *(CFTypeRef **)(a1 + 56));

    ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
LABEL_16:

    goto LABEL_17;
  }
  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:", v3));
  v10 = objc_opt_class(v9);
  v11 = objc_opt_class(CKKSSQLWhereColumn);

  if (v10 != v11)
  {
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:", v3));
    v13 = objc_opt_class(v12);
    v14 = objc_opt_class(NSNull);

    if (v13 != v14)
    {
      v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:", v3));
      v16 = objc_msgSend(v15, "isMemberOfClass:", objc_opt_class(CKKSSQLWhereIn));

      if (!v16)
      {
        v26 = *(sqlite3_stmt **)(a1 + 48);
        v27 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
        v28 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:", v3));
        sub_100013544(v26, v27, v28, *(CFTypeRef **)(a1 + 56));

        ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
        goto LABEL_17;
      }
      v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:", v3));
      v29 = 0u;
      v30 = 0u;
      v31 = 0u;
      v32 = 0u;
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "values", 0));
      v19 = objc_msgSend(v18, "countByEnumeratingWithState:objects:count:", &v29, v33, 16);
      if (v19)
      {
        v20 = v19;
        v21 = *(_QWORD *)v30;
        do
        {
          v22 = 0;
          do
          {
            if (*(_QWORD *)v30 != v21)
              objc_enumerationMutation(v18);
            sub_100013544(*(sqlite3_stmt **)(a1 + 48), *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), *(const __CFString **)(*((_QWORD *)&v29 + 1) + 8 * (_QWORD)v22), *(CFTypeRef **)(a1 + 56));
            ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
            v22 = (char *)v22 + 1;
          }
          while (v20 != v22);
          v20 = objc_msgSend(v18, "countByEnumeratingWithState:objects:count:", &v29, v33, 16);
        }
        while (v20);
      }

      goto LABEL_16;
    }
  }
LABEL_17:

}

void sub_10004B4A0(uint64_t a1, void *a2)
{
  void *v3;
  int v4;
  id v5;
  const __CFString *v6;

  v3 = *(void **)(a1 + 32);
  v4 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  v5 = a2;
  if (v4)
    v6 = CFSTR(", ");
  else
    v6 = CFSTR(" ORDER BY ");
  objc_msgSend(v3, "appendFormat:", v6);
  objc_msgSend(*(id *)(a1 + 32), "appendFormat:", CFSTR("%@"), v5);

  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
}

void sub_10004B528(uint64_t a1, void *a2)
{
  void *v3;
  int v4;
  id v5;
  const __CFString *v6;

  v3 = *(void **)(a1 + 32);
  v4 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  v5 = a2;
  if (v4)
    v6 = CFSTR(", ");
  else
    v6 = CFSTR(" GROUP BY ");
  objc_msgSend(v3, "appendFormat:", v6);
  objc_msgSend(*(id *)(a1 + 32), "appendFormat:", CFSTR("%@"), v5);

  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
}

void sub_10004B5B0(uint64_t a1, void *a2, void *a3)
{
  __CFString *v5;
  id v6;
  const __CFString *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  char *v12;
  const __CFString *v13;
  id v14;
  void *v15;
  unint64_t v16;
  const __CFString *v17;
  const __CFString *v18;
  char *v19;
  const __CFString *v20;
  void *v21;
  void *v22;
  void *v23;
  char *v24;
  char *v25;
  uint64_t v26;
  void *v27;
  id v28;
  const __CFString *v29;
  __CFString *v30;
  uint64_t v31;
  const __CFString *v32;
  __CFString *v33;
  const __CFString *v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  _BYTE v39[128];

  v5 = a2;
  v6 = a3;
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24))
    v7 = CFSTR(" AND ");
  else
    v7 = CFSTR(" WHERE ");
  objc_msgSend(*(id *)(a1 + 32), "appendFormat:", v7);
  v8 = objc_opt_class(v6);
  if (v8 == objc_opt_class(CKKSSQLWhereValue))
  {
    v11 = *(void **)(a1 + 32);
    v12 = (char *)objc_msgSend(v6, "sqlOp");
    if ((unint64_t)(v12 - 2) > 2)
      v13 = CFSTR("=");
    else
      v13 = off_1002DBE50[(_QWORD)(v12 - 2)];
    v30 = v5;
    v32 = v13;
    v18 = CFSTR("%@%@(?)");
    goto LABEL_32;
  }
  v9 = objc_opt_class(v6);
  if (v9 == objc_opt_class(CKKSSQLWhereColumn))
  {
    v14 = v6;
    v15 = *(void **)(a1 + 32);
    v16 = (unint64_t)objc_msgSend(v14, "sqlOp") - 2;
    if (v16 > 2)
      v17 = CFSTR("=");
    else
      v17 = off_1002DBE50[v16];
    v28 = objc_msgSend(v14, "columnName");
    v29 = CFSTR("parentKeyUUID");
    if (v28 == (id)1)
      v29 = CFSTR("uuid");
    objc_msgSend(v15, "appendFormat:", CFSTR("%@%@%@"), v5, v17, v29);
LABEL_29:

    goto LABEL_33;
  }
  v10 = objc_opt_class(v6);
  if (v10 == objc_opt_class(CKKSSQLWhereNullOrValue))
  {
    v11 = *(void **)(a1 + 32);
    v19 = (char *)objc_msgSend(v6, "sqlOp");
    if ((unint64_t)(v19 - 2) > 2)
      v20 = CFSTR("=");
    else
      v20 = off_1002DBE50[(_QWORD)(v19 - 2)];
    v33 = v5;
    v34 = v20;
    v30 = v5;
    v32 = v5;
    v18 = CFSTR("(%@ is NULL OR (%@ IS NOT NULL AND %@%@(?)))");
LABEL_32:
    objc_msgSend(v11, "appendFormat:", v18, v30, v32, v33, v34);
    goto LABEL_33;
  }
  if (!objc_msgSend(v6, "isMemberOfClass:", objc_opt_class(NSNull)))
  {
    if (!objc_msgSend(v6, "isMemberOfClass:", objc_opt_class(CKKSSQLWhereIn)))
    {
      objc_msgSend(*(id *)(a1 + 32), "appendFormat:", CFSTR("%@=(?)"), v5, v31, v33, v34);
      goto LABEL_33;
    }
    v14 = v6;
    v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "values"));
    v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", objc_msgSend(v21, "count")));

    v37 = 0u;
    v38 = 0u;
    v35 = 0u;
    v36 = 0u;
    v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "values"));
    v24 = (char *)objc_msgSend(v23, "countByEnumeratingWithState:objects:count:", &v35, v39, 16);
    if (v24)
    {
      v25 = v24;
      v26 = *(_QWORD *)v36;
      while (1)
      {
        if (*(_QWORD *)v36 != v26)
          objc_enumerationMutation(v23);
        objc_msgSend(v22, "addObject:", CFSTR("?"));
        if (!--v25)
        {
          v25 = (char *)objc_msgSend(v23, "countByEnumeratingWithState:objects:count:", &v35, v39, 16);
          if (!v25)
            break;
        }
      }
    }

    v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "componentsJoinedByString:", CFSTR(", ")));
    objc_msgSend(*(id *)(a1 + 32), "appendFormat:", CFSTR("%@ IN (%@)"), v5, v27);

    goto LABEL_29;
  }
  objc_msgSend(*(id *)(a1 + 32), "appendFormat:", CFSTR("%@ is NULL"), v5, v31, v33, v34);
LABEL_33:
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;

}

uint64_t sub_10004B930(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;
  id v6;
  void *v7;
  id v8;
  unint64_t v9;
  const __CFString *v10;
  void *v11;
  id v12;
  id v13;
  CFTypeRef *v14;
  id v15;
  uint64_t v16;
  _QWORD v18[4];
  id v19;
  uint64_t v20;
  uint64_t v21;

  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "allKeys"));
  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "componentsJoinedByString:", CFSTR(", ")));

  v6 = objc_alloc_init((Class)NSMutableString);
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "allKeys"));
  v8 = objc_msgSend(v7, "count");

  if (v8)
  {
    v9 = 0;
    do
    {
      if (v9)
        v10 = CFSTR(",?");
      else
        v10 = CFSTR("?");
      objc_msgSend(v6, "appendString:", v10);
      ++v9;
      v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "allKeys"));
      v12 = objc_msgSend(v11, "count");

    }
    while (v9 < (unint64_t)v12);
  }
  v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("INSERT OR REPLACE into %@ (%@) VALUES (%@);"),
          *(_QWORD *)(a1 + 40),
          v5,
          v6);
  v14 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472;
  v18[2] = sub_10004BABC;
  v18[3] = &unk_1002DBBE0;
  v15 = *(id *)(a1 + 32);
  v16 = *(_QWORD *)(a1 + 48);
  v19 = v15;
  v20 = v16;
  v21 = a2;
  sub_10001E3C4(a2, (uint64_t)v13, v14, (uint64_t)v18);

  return 1;
}

void sub_10004BABC(uint64_t a1, sqlite3_stmt *a2)
{
  void *v4;
  id v5;
  uint64_t v6;
  _QWORD v7[4];
  id v8;
  uint64_t v9;
  sqlite3_stmt *v10;

  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "allKeys"));
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_10004BB6C;
  v7[3] = &unk_1002DBB78;
  v10 = a2;
  v5 = *(id *)(a1 + 32);
  v6 = *(_QWORD *)(a1 + 40);
  v8 = v5;
  v9 = v6;
  objc_msgSend(v4, "enumerateObjectsUsingBlock:", v7);

  sub_100019C40(*(_QWORD *)(a1 + 48), a2, (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), (uint64_t)&stru_1002DBBB8);
}

void sub_10004BB6C(uint64_t a1, uint64_t a2, int a3)
{
  sqlite3_stmt *v4;
  uint64_t v5;
  __CFString *v6;

  v4 = *(sqlite3_stmt **)(a1 + 48);
  v5 = (a3 + 1);
  v6 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:", a2));
  sub_100013544(v4, v5, v6, (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));

}

BOOL sub_10004CE48(uint64_t a1, void *a2, void *a3)
{
  id v5;
  double v6;
  _BOOL8 v7;

  v5 = a3;
  if (objc_msgSend(a2, "hasPrefix:", CFSTR("G:")))
  {
    objc_msgSend(*(id *)(a1 + 32), "timeIntervalSinceDate:", v5);
    v7 = v6 > 0.0;
  }
  else
  {
    v7 = 0;
  }

  return v7;
}

BOOL sub_10004CEB0(uint64_t a1)
{
  double v2;

  objc_msgSend(*(id *)(a1 + 32), "timeIntervalSinceDate:");
  return v2 > (double)*(int *)(a1 + 40);
}

id sub_10004CEEC(void *a1)
{
  id v1;
  void *v2;
  unsigned int v3;
  void *v4;
  void *v5;

  v1 = a1;
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "zoneName"));
  v3 = objc_msgSend(v2, "hasPrefix:", CFSTR("group-"));

  if (v3)
  {
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "zoneName"));
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "substringFromIndex:", objc_msgSend(CFSTR("group-"), "length")));

  }
  else
  {
    v5 = 0;
  }

  return v5;
}

void sub_10004CF7C(void *a1, void *a2)
{
  id v3;
  void *v4;
  id v5;

  v3 = a1;
  v5 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(a2, "displayName"));
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "encryptedValues"));

  objc_msgSend(v4, "setObject:forKeyedSubscript:", v5, CFSTR("displayName"));
}

id sub_10004CFE8(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  id v7;
  void *v8;
  id v9;
  uint64_t v10;
  id v11;
  unint64_t v12;
  uint64_t v13;
  void *v14;
  void *v15;
  id v16;
  id v18;

  v1 = a1;
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "userIdentity"));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "lookupInfo"));

  v18 = objc_alloc((Class)KCSharingParticipant);
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "userIdentity"));
  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "userRecordID"));
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "recordName"));
  v7 = sub_10004D178(v3);
  v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
  v9 = v1;
  if (objc_msgSend(v9, "role") == (id)1)
    v10 = 2;
  else
    v10 = objc_msgSend(v9, "role") == (id)2 || objc_msgSend(v9, "permission") == (id)3;

  v11 = objc_msgSend(v9, "isCurrentUser");
  v12 = (unint64_t)objc_msgSend(v9, "acceptanceStatus") - 1;
  if (v12 > 3)
    v13 = 0;
  else
    v13 = qword_100249550[v12];
  v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "invitationToken"));

  v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "sharingInvitationData"));
  v16 = objc_msgSend(v18, "initWithParticipantID:handle:permissionLevel:isCurrentUser:inviteStatus:sharingInvitationData:", v6, v8, v10, v11, v13, v15);

  return v16;
}

id sub_10004D178(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  void *v4;
  id v5;
  id v6;
  void *v7;
  id v8;

  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "emailAddress"));
    v4 = v3;
    if (v3)
    {
      v5 = v3;
    }
    else
    {
      v6 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "phoneNumber"));
      v7 = v6;
      if (v6)
      {
        if (objc_msgSend(v6, "hasPrefix:", CFSTR("+")))
          v8 = v7;
        else
          v8 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(CFSTR("+"), "stringByAppendingString:", v7));
        v5 = v8;
      }
      else
      {
        v5 = 0;
      }

    }
  }
  else
  {
    v5 = 0;
  }

  return v5;
}

id sub_10004D234(void *a1)
{
  id v1;
  NSObject *v2;
  void *v3;
  id v4;
  id v5;
  uint64_t v6;
  void *i;
  id v8;
  void *v9;
  void *v10;
  void *v11;
  id v12;
  void *v13;
  id v14;
  NSObject *v15;
  void *v16;
  void *v17;
  id v18;
  uint64_t v19;
  uint64_t v20;
  void *v22;
  void *v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint8_t buf[4];
  void *v29;
  _BYTE v30[128];

  v1 = a1;
  if (v1)
  {
    v2 = objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
    v24 = 0u;
    v25 = 0u;
    v26 = 0u;
    v27 = 0u;
    v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "participants", 0));
    v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v24, v30, 16);
    if (v4)
    {
      v5 = v4;
      v6 = *(_QWORD *)v25;
      do
      {
        for (i = 0; i != v5; i = (char *)i + 1)
        {
          if (*(_QWORD *)v25 != v6)
            objc_enumerationMutation(v3);
          v8 = sub_10004CFE8(*(void **)(*((_QWORD *)&v24 + 1) + 8 * (_QWORD)i));
          v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
          -[NSObject addObject:](v2, "addObject:", v9);

        }
        v5 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v24, v30, 16);
      }
      while (v5);
    }

    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "recordID"));
    v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "zoneID"));
    v12 = sub_10004CEEC(v11);
    v13 = (void *)objc_claimAutoreleasedReturnValue(v12);

    if (v13)
    {
      v14 = objc_alloc((Class)KCSharingGroup);
      v15 = objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "encryptedValues"));
      v16 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject objectForKeyedSubscript:](v15, "objectForKeyedSubscript:", CFSTR("displayName")));
      v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "URL"));
      v18 = objc_msgSend(v14, "initWithGroupID:participants:displayName:shareURL:", v13, v2, v16, v17);

    }
    else
    {
      v20 = KCSharingLogObject(CFSTR("KCSharingRecord"));
      v15 = objc_claimAutoreleasedReturnValue(v20);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "recordID"));
        v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "zoneID"));
        *(_DWORD *)buf = 138412290;
        v29 = v23;
        _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Zone ID \"%@\" did not contain KCSharingGroupID", buf, 0xCu);

      }
      v18 = 0;
    }

  }
  else
  {
    v19 = KCSharingLogObject(CFSTR("KCSharingRecord"));
    v2 = objc_claimAutoreleasedReturnValue(v19);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "Can't create a KCSharingGroup without a CKShare", buf, 2u);
    }
    v18 = 0;
  }

  return v18;
}

_QWORD *sub_10004D4E8(_QWORD *result, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;

  if (result)
  {
    v3 = result;
    result = (id)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("KCSharingErrorDomain"), a2, a3));
    *v3 = result;
  }
  return result;
}

BOOL sub_10004D530(void *a1)
{
  id v1;
  void *v2;
  _BOOL8 v3;

  v1 = a1;
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "domain"));
  if (objc_msgSend(v2, "isEqualToString:", CFSTR("KCSharingErrorDomain")))
    v3 = objc_msgSend(v1, "code") == (id)8;
  else
    v3 = 0;

  return v3;
}

void sub_10004D598(_QWORD *a1, uint64_t a2, void *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  id v12;
  id v13;
  id v14;
  void *v15;
  id v16;
  NSErrorUserInfoKey v17;
  id v18;

  if (a1)
  {
    v17 = NSLocalizedDescriptionKey;
    v12 = a4;
    v13 = a3;
    v14 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:arguments:", v12, &a9);

    v18 = v14;
    v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v18, &v17, 1));
    v16 = objc_msgSend(v15, "mutableCopy");

    objc_msgSend(v16, "setObject:forKeyedSubscript:", v13, NSUnderlyingErrorKey);
    *a1 = (id)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("KCSharingErrorDomain"), a2, v16));

  }
}

void sub_10004E8D8(uint64_t a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  unsigned int v6;
  _DWORD v7[2];
  __int16 v8;
  id v9;

  v3 = a2;
  v4 = sub_10000EF14("escrowrequest");
  v5 = objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = objc_msgSend(*(id *)(a1 + 32), "numberOfRecordsUploaded");
    v7[0] = 67109378;
    v7[1] = v6;
    v8 = 2112;
    v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Uploaded %d records with error %@", (uint8_t *)v7, 0x12u);
  }

  (*(void (**)(_QWORD, id, id))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), objc_msgSend(*(id *)(a1 + 32), "numberOfRecordsUploaded"), v3);
}

void sub_10004EB44(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10004EE24(uint64_t a1, uint64_t a2, void *a3)
{
  const void *v4;
  NSObject *v5;
  void *v6;
  uint8_t v7[16];

  v4 = sub_10000EF14("octagon");
  v5 = objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v7 = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Notified that the device name has changed", v7, 2u);
  }

  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a3, "deviceNameUpdateListeners"));
  objc_msgSend(v6, "iterateListeners:", &stru_1002DBED0);

}

void sub_10004EEB4(id a1, OTDeviceInformationNameUpdateListener *a2)
{
  -[OTDeviceInformationNameUpdateListener deviceNameUpdated](a2, "deviceNameUpdated");
}

void sub_10004EEBC(id a1)
{
  uint64_t v1;
  void *v2;
  utsname __b;

  memset(&__b, 170, sizeof(__b));
  uname(&__b);
  v1 = objc_claimAutoreleasedReturnValue(+[NSString stringWithCString:encoding:](NSString, "stringWithCString:encoding:", __b.machine, 4));
  v2 = (void *)qword_100340EB0;
  qword_100340EB0 = v1;

}

void sub_10004F320(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 128));
  _Unwind_Resume(a1);
}

void sub_10004F740(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10004F87C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10004FB10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100050488(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  id *v22;
  uint64_t v23;

  objc_destroyWeak(v22);
  _Block_object_dispose(&a22, 8);
  objc_destroyWeak((id *)(v23 - 56));
  _Unwind_Resume(a1);
}

uint64_t sub_1000507D4(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_1000507E4(uint64_t a1)
{

}

void sub_1000507EC(uint64_t a1)
{
  CKKSCondition *v2;
  void *v3;
  id v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;

  v2 = [CKKSCondition alloc];
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "octagonInformationInitialized"));
  v4 = -[CKKSCondition initToChain:](v2, "initToChain:", v3);
  objc_msgSend(*(id *)(a1 + 32), "setOctagonInformationInitialized:", v4);

  v5 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "octagonInformationInitialized"));
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  v7 = *(void **)(v6 + 40);
  *(_QWORD *)(v6 + 40) = v5;

}

void sub_100050870(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, void *a6)
{
  id v9;
  id v10;
  NSObject *v11;
  uint64_t v12;
  id v13;
  id v14;
  id WeakRetained;
  _QWORD block[4];
  id v17;
  id v18;
  id v19;
  uint64_t v20;
  uint64_t v21;

  v9 = a3;
  v10 = a6;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v11 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "queue"));
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100050950;
  block[3] = &unk_1002DBF48;
  v17 = v10;
  v18 = WeakRetained;
  v12 = *(_QWORD *)(a1 + 32);
  v19 = v9;
  v20 = v12;
  v21 = a2;
  v13 = v9;
  v14 = v10;
  dispatch_sync(v11, block);

}

id sub_100050950(uint64_t a1)
{
  uint64_t v2;
  id v3;
  NSObject *v4;
  NSObject *v5;
  void *v6;
  OTCliqueStatusWrapper *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  OTCliqueStatusWrapper *v12;
  int v14;
  void *v15;
  __int16 v16;
  uint64_t v17;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = sub_10000BDF4(CFSTR("ckksaccount"), 0);
  v4 = objc_claimAutoreleasedReturnValue(v3);
  v5 = v4;
  if (v2)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v6 = *(void **)(a1 + 32);
      v14 = 138412290;
      v15 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "error getting octagon status: %@", (uint8_t *)&v14, 0xCu);
    }

    v7 = [OTCliqueStatusWrapper alloc];
    v8 = -1;
  }
  else
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v9 = OTCliqueStatusToString(*(_QWORD *)(a1 + 64));
      v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
      v11 = *(_QWORD *)(a1 + 48);
      v14 = 138412546;
      v15 = v10;
      v16 = 2112;
      v17 = v11;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Caching octagon status as (%@, %@)", (uint8_t *)&v14, 0x16u);

    }
    v7 = [OTCliqueStatusWrapper alloc];
    v8 = *(_QWORD *)(a1 + 64);
  }
  v12 = -[OTCliqueStatusWrapper initWithStatus:](v7, "initWithStatus:", v8);
  objc_msgSend(*(id *)(a1 + 40), "setOctagonStatus:", v12);

  objc_msgSend(*(id *)(a1 + 40), "setOctagonPeerID:", *(_QWORD *)(a1 + 48));
  return objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 40), "fulfill");
}

void sub_100050BEC(uint64_t a1)
{
  void *v2;
  void *v3;
  uint64_t v4;
  __int128 v5;
  NSObject *v6;
  void *v7;
  void *v8;
  id v9;
  NSObject *v10;
  NSObject *v11;
  uint64_t v12;
  __int128 v13;
  _QWORD block[4];
  id v15;
  _BYTE location[24];

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "ckChangeListeners"));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "keyEnumerator"));

  v4 = objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "nextObject"));
  if (v4)
  {
    v6 = v4;
    *(_QWORD *)&v5 = 138412290;
    v13 = v5;
    do
    {
      v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "ckChangeListeners", v13));
      v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKey:", v6));

      v9 = sub_10000BDF4(CFSTR("ckksaccountblock"), 0);
      v10 = objc_claimAutoreleasedReturnValue(v9);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)location = v13;
        *(_QWORD *)&location[4] = v8;
        _os_log_debug_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "Starting blocking for listener %@", location, 0xCu);
      }

      *(_QWORD *)location = 0xAAAAAAAAAAAAAAAALL;
      objc_initWeak((id *)location, v8);
      v11 = *(NSObject **)(a1 + 40);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_100050DC4;
      block[3] = &unk_1002EB598;
      objc_copyWeak(&v15, (id *)location);
      dispatch_group_async(v11, v6, block);
      objc_destroyWeak(&v15);
      objc_destroyWeak((id *)location);

      v12 = objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "nextObject"));
      v6 = v12;
    }
    while (v12);
  }

}

void sub_100050DC4(uint64_t a1)
{
  id WeakRetained;
  id v2;
  NSObject *v3;
  int v4;
  id v5;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v2 = sub_10000BDF4(CFSTR("ckksaccountblock"), 0);
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    v4 = 138412290;
    v5 = WeakRetained;
    _os_log_debug_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "Done blocking for listener %@", (uint8_t *)&v4, 0xCu);
  }

}

void sub_100050E80(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  v2 = *(_QWORD *)(a1 + 32);
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "currentCKAccountInfo"));
  objc_msgSend(WeakRetained, "cloudkitAccountStateChange:to:", v2, v3);

}

intptr_t sub_100050ED8(uint64_t a1)
{
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_100050EE0(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id *v7;
  id WeakRetained;
  void *v9;
  NSObject *v10;
  id v11;
  NSObject *v12;
  _QWORD block[4];
  id v14;
  id v15;
  id v16;
  uint8_t buf[16];

  v5 = a2;
  v6 = a3;
  v7 = (id *)(a1 + 32);
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v9 = WeakRetained;
  if (WeakRetained)
  {
    v10 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "queue"));
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100051024;
    block[3] = &unk_1002EB5C0;
    objc_copyWeak(&v16, v7);
    v14 = v5;
    v15 = v6;
    dispatch_async(v10, block);

    objc_destroyWeak(&v16);
  }
  else
  {
    v11 = sub_10000BDF4(CFSTR("ckks-sos"), 0);
    v12 = objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Received fetchCirclePeerID callback with null AccountStateTracker", buf, 2u);
    }

  }
}

void sub_100051024(uint64_t a1)
{
  id WeakRetained;
  uint64_t v3;
  void *v4;
  void *v5;
  unsigned int v6;
  id v7;
  NSObject *v8;
  id v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  int v14;
  uint64_t v15;
  __int16 v16;
  uint64_t v17;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  v3 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "currentCircleStatus"));
  if (v3
    && (v4 = (void *)v3,
        v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "currentCircleStatus")),
        v6 = objc_msgSend(v5, "status"),
        v5,
        v4,
        !v6))
  {
    v9 = sub_10000BDF4(CFSTR("ckks-sos"), 0);
    v10 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      v11 = *(_QWORD *)(a1 + 32);
      v12 = *(_QWORD *)(a1 + 40);
      v14 = 138412546;
      v15 = v11;
      v16 = 2112;
      v17 = v12;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Circle peerID is: %@ %@", (uint8_t *)&v14, 0x16u);
    }

    objc_msgSend(WeakRetained, "setAccountCirclePeerID:", *(_QWORD *)(a1 + 32));
    objc_msgSend(WeakRetained, "setAccountCirclePeerIDError:", *(_QWORD *)(a1 + 40));
    v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "accountCirclePeerIDInitialized"));
    objc_msgSend(v13, "fulfill");

  }
  else
  {
    v7 = sub_10000BDF4(CFSTR("ckks-sos"), 0);
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v14) = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Out of circle but still received a fetchCirclePeerID callback", (uint8_t *)&v14, 2u);
    }

    objc_msgSend(WeakRetained, "setAccountCirclePeerID:", 0);
    objc_msgSend(WeakRetained, "setAccountCirclePeerIDError:", 0);
  }

}

intptr_t sub_1000511D0(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  void *v4;
  unsigned __int8 v5;
  id v6;
  NSObject *v7;
  uint64_t v8;
  void *v9;
  void *v10;
  int v12;
  uint64_t v13;

  v2 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "currentCircleStatus"));
  if (!v2
    || (v3 = (void *)v2,
        v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "currentCircleStatus")),
        v5 = objc_msgSend(v4, "isEqual:", *(_QWORD *)(a1 + 40)),
        v4,
        v3,
        (v5 & 1) == 0))
  {
    v6 = sub_10000BDF4(CFSTR("ckks-sos"), 0);
    v7 = objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = *(_QWORD *)(a1 + 40);
      v12 = 138412290;
      v13 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "moving to circle status: %@", (uint8_t *)&v12, 0xCu);
    }

    objc_msgSend(*(id *)(a1 + 32), "setCurrentCircleStatus:", *(_QWORD *)(a1 + 40));
    if (!objc_msgSend(*(id *)(a1 + 40), "status"))
    {
      v9 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
      v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](NSDate, "date"));
      objc_msgSend(v9, "setDateProperty:forKey:", v10, CFSTR("lastInCircle"));

    }
    objc_msgSend(*(id *)(a1 + 32), "_onqueueUpdateCirclePeerID:", *(_QWORD *)(a1 + 40));
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 48));
}

void sub_10005132C(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id *v7;
  id WeakRetained;
  void *v9;
  NSObject *v10;
  id v11;
  NSObject *v12;
  _QWORD block[4];
  id v14;
  id v15;
  id v16;
  uint8_t buf[16];

  v5 = a2;
  v6 = a3;
  v7 = (id *)(a1 + 32);
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v9 = WeakRetained;
  if (WeakRetained)
  {
    v10 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "queue"));
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100051470;
    block[3] = &unk_1002EB5C0;
    objc_copyWeak(&v16, v7);
    v14 = v5;
    v15 = v6;
    dispatch_async(v10, block);

    objc_destroyWeak(&v16);
  }
  else
  {
    v11 = sub_10000BDF4(CFSTR("ckksaccount"), 0);
    v12 = objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Received fetchCurrentDeviceIDWithCompletionHandler callback with null AccountStateTracker", buf, 2u);
    }

  }
}

void sub_100051470(uint64_t a1)
{
  id WeakRetained;
  void *v3;
  id v4;
  id v5;
  NSObject *v6;
  NSObject *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  int v15;
  void *v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  uint64_t v20;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "currentCKAccountInfo"));
  v4 = objc_msgSend(v3, "accountStatus");

  v5 = sub_10000BDF4(CFSTR("ckksaccount"), 0);
  v6 = objc_claimAutoreleasedReturnValue(v5);
  v7 = v6;
  if (v4 == (id)1)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "container"));
      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "options"));
      v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "accountOverrideInfo"));
      v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "altDSID"));
      v12 = *(_QWORD *)(a1 + 32);
      v13 = *(_QWORD *)(a1 + 40);
      v15 = 138412802;
      v16 = v11;
      v17 = 2112;
      v18 = v12;
      v19 = 2112;
      v20 = v13;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "CloudKit deviceID is(altDSID: %@): %@ %@", (uint8_t *)&v15, 0x20u);

    }
    objc_msgSend(WeakRetained, "setCkdeviceID:", *(_QWORD *)(a1 + 32));
    objc_msgSend(WeakRetained, "setCkdeviceIDError:", *(_QWORD *)(a1 + 40));
    v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "ckdeviceIDInitialized"));
    objc_msgSend(v14, "fulfill");

  }
  else
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v15) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Logged back out but still received a fetchCurrentDeviceIDWithCompletionHandler callback", (uint8_t *)&v15, 2u);
    }

    objc_msgSend(WeakRetained, "setCkdeviceID:", 0);
    objc_msgSend(WeakRetained, "setCkdeviceIDError:", 0);
  }

}

void sub_100051644(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id WeakRetained;
  void *v8;
  id v9;
  NSObject *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  NSObject *v16;
  _QWORD block[5];
  id v18;
  id v19;
  uint8_t buf[4];
  void *v21;
  __int16 v22;
  id v23;

  v5 = a2;
  v6 = a3;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v8 = WeakRetained;
  if (v6)
  {
    v9 = sub_10000BDF4(CFSTR("ckksaccount"), 0);
    v10 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "container"));
      v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "options"));
      v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "accountOverrideInfo"));
      v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "altDSID"));
      *(_DWORD *)buf = 138412546;
      v21 = v14;
      v22 = 2112;
      v23 = v6;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "error getting account info(altDSID: %@): %@", buf, 0x16u);

    }
    v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "fetchCKAccountStatusScheduler"));
    objc_msgSend(v15, "trigger");

    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
  }
  else
  {
    v16 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "queue"));
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100051828;
    block[3] = &unk_1002E94C8;
    block[4] = v8;
    v18 = v5;
    v19 = *(id *)(a1 + 32);
    dispatch_sync(v16, block);

  }
}

id sub_100051828(uint64_t a1)
{
  id v2;
  NSObject *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  uint64_t v8;
  int v10;
  void *v11;
  __int16 v12;
  uint64_t v13;

  objc_msgSend(*(id *)(a1 + 32), "setFirstCKAccountFetch:", 1);
  v2 = sub_10000BDF4(CFSTR("ckksaccount"), 0);
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "container"));
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "options"));
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "accountOverrideInfo"));
    v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "altDSID"));
    v8 = *(_QWORD *)(a1 + 40);
    v10 = 138412546;
    v11 = v7;
    v12 = 2112;
    v13 = v8;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "received CK Account info(altDSID: %@): %@", (uint8_t *)&v10, 0x16u);

  }
  return objc_msgSend(*(id *)(a1 + 32), "_onqueueUpdateAccountState:deliveredSemaphore:", *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48));
}

void sub_100051950(id *a1)
{
  void *v2;
  void *v3;
  uint64_t v4;
  id v5;
  char v6;
  uint64_t v7;
  id v8;
  const char *v9;
  dispatch_queue_attr_t v10;
  NSObject *v11;
  dispatch_queue_t v12;
  void *v13;
  id v14;
  NSObject *v15;
  id v16;
  NSObject *v17;
  dispatch_group_t v18;
  NSObject *v19;
  NSObject *v20;
  id v21;
  NSObject *v22;
  id v23;
  id v24;
  void *v25;
  _QWORD block[4];
  id v27;
  uint8_t buf[4];
  id v29;
  __int16 v30;
  void *v31;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "ckChangeListeners"));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "objectEnumerator"));

  v4 = objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "nextObject"));
  if (v4)
  {
    v5 = (id)v4;
    v6 = 0;
    do
    {
      v6 |= v5 == a1[5];
      v7 = objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "nextObject"));

      v5 = (id)v7;
    }
    while (v7);
  }
  else
  {
    v6 = 0;
  }
  if (a1[5] && (v6 & 1) == 0)
  {
    v8 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("ck-account-state-%@"), a1[5])));
    v9 = (const char *)objc_msgSend(v8, "UTF8String");
    v10 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    v11 = objc_claimAutoreleasedReturnValue(v10);
    v12 = dispatch_queue_create(v9, v11);

    v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "ckChangeListeners"));
    objc_msgSend(v13, "setObject:forKey:", a1[5], v12);

    v14 = sub_10000BDF4(CFSTR("ckksaccount-ck"), 0);
    v15 = objc_claimAutoreleasedReturnValue(v14);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      v23 = a1[5];
      *(_DWORD *)buf = 138412290;
      v29 = v23;
      _os_log_debug_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "adding a new listener: %@", buf, 0xCu);
    }

    if (objc_msgSend(a1[4], "firstCKAccountFetch"))
    {
      v16 = sub_10000BDF4(CFSTR("ckksaccount-ck"), 0);
      v17 = objc_claimAutoreleasedReturnValue(v16);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        v24 = a1[5];
        v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "currentCKAccountInfo"));
        *(_DWORD *)buf = 138412546;
        v29 = v24;
        v30 = 2112;
        v31 = v25;
        _os_log_debug_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "notifying new listener %@ of current state %@", buf, 0x16u);

      }
      v18 = dispatch_group_create();
      if (v18)
      {
        v19 = v18;
        objc_msgSend(a1[4], "_onqueueDeliverCurrentCloudKitState:listenerQueue:oldStatus:group:", a1[5], v12, 0, v18);
        v20 = objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "queue"));
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_100051C90;
        block[3] = &unk_1002EC350;
        v27 = a1[6];
        dispatch_group_notify(v19, v20, block);

LABEL_20:
        goto LABEL_21;
      }
      v21 = sub_10000BDF4(CFSTR("ckksaccount-ck"), 0);
      v22 = objc_claimAutoreleasedReturnValue(v21);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Unable to get dispatch group.", buf, 2u);
      }

    }
    dispatch_semaphore_signal((dispatch_semaphore_t)a1[6]);
    goto LABEL_20;
  }
  dispatch_semaphore_signal((dispatch_semaphore_t)a1[6]);
LABEL_21:

}

intptr_t sub_100051C90(uint64_t a1)
{
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_100051C98(uint64_t a1)
{
  id v1;
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v1 = objc_msgSend(WeakRetained, "notifyCircleChange:", 0);

}

void sub_100051CD0(uint64_t a1)
{
  void *v1;
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v1 = objc_autoreleasePoolPush();
    objc_msgSend(WeakRetained, "performInitialDispatches");
    objc_autoreleasePoolPop(v1);
  }

}

void sub_100051D1C(uint64_t a1)
{
  id v2;
  NSObject *v3;
  id WeakRetained;
  id v5;
  uint8_t v6[16];

  v2 = sub_10000BDF4(CFSTR("ckksaccount"), 0);
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)v6 = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "Retrying CK account state fetch", v6, 2u);
  }

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v5 = objc_msgSend(WeakRetained, "notifyCKAccountStatusChange:", 0);

}

void sub_1000521A4(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  void *v4;
  CFTypeRef v5;

  v5 = 0;
  v2 = (void *)sub_10020B190(&v5);
  v3 = *(_QWORD *)(a1 + 32);
  v4 = (void *)v5;
  (*(void (**)(void))(v3 + 16))();

}

void sub_1000523AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000524B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v7 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_10005277C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  _Block_object_dispose(&a23, 8);
  _Block_object_dispose(&a29, 8);
  _Unwind_Resume(a1);
}

void sub_100052884(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

NSDictionary *__cdecl sub_100053C3C(id a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
  v2 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "datePropertyForKey:", CFSTR("ERSPending")));

  if (v3)
  {
    v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", +[CKKSAnalytics fuzzyDaysSinceDate:](CKKSAnalytics, "fuzzyDaysSinceDate:", v3)));
    objc_msgSend(v1, "setObject:forKeyedSubscript:", v4, CFSTR("ERSPending"));

  }
  return (NSDictionary *)v1;
}

intptr_t sub_100053CE8(uint64_t a1, char a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = a2;
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

uint64_t sub_100053CFC(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_100053D0C(uint64_t a1)
{

}

void sub_100053D14(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  void *v10;
  id v11;

  v5 = a2;
  v6 = a3;
  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v8 = *(void **)(v7 + 40);
  *(_QWORD *)(v7 + 40) = v5;
  v11 = v5;

  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  v10 = *(void **)(v9 + 40);
  *(_QWORD *)(v9 + 40) = v6;

}

void sub_100053D88(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  void *v10;
  id v11;

  v5 = a2;
  v6 = a3;
  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v8 = *(void **)(v7 + 40);
  *(_QWORD *)(v7 + 40) = v5;
  v11 = v5;

  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  v10 = *(void **)(v9 + 40);
  *(_QWORD *)(v9 + 40) = v6;

}

void sub_100053DFC(uint64_t a1, void *a2)
{
  id v4;

  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), a2);
  v4 = a2;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));

}

void sub_100053E94(id a1)
{
  EscrowRequestServer *v1;
  void *v2;
  EscrowRequestServer *v3;
  void *v4;

  v1 = [EscrowRequestServer alloc];
  v2 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSLockStateTracker globalTracker](CKKSLockStateTracker, "globalTracker"));
  v3 = -[EscrowRequestServer initWithLockStateTracker:](v1, "initWithLockStateTracker:", v2);
  v4 = (void *)qword_100340EC0;
  qword_100340EC0 = (uint64_t)v3;

  objc_msgSend((id)qword_100340EC0, "setupAnalytics");
}

void sub_100054C34(id a1, NSError *a2)
{
  NSError *v2;
  const void *v3;
  NSObject *v4;
  _BOOL4 v5;
  const char *v6;
  NSObject *v7;
  uint32_t v8;
  int v9;
  NSError *v10;

  v2 = a2;
  v3 = sub_10000EF14("octagon");
  v4 = objc_claimAutoreleasedReturnValue(v3);
  v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v5)
    {
      v9 = 138412290;
      v10 = v2;
      v6 = "Created TTR with error: %@";
      v7 = v4;
      v8 = 12;
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v9, v8);
    }
  }
  else if (v5)
  {
    LOWORD(v9) = 0;
    v6 = "Created TTR successfully";
    v7 = v4;
    v8 = 2;
    goto LABEL_6;
  }

}

void sub_100054F4C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  id v10;
  NSObject *v11;
  NSObject *v12;
  void *v13;
  int v14;
  id v15;

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = sub_10000BDF4(CFSTR("ckks-cuttlefish"), 0);
  v11 = objc_claimAutoreleasedReturnValue(v10);
  v12 = v11;
  if (v9)
  {
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v14 = 138412290;
      v15 = v9;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "error fetching pcs identity: %@", (uint8_t *)&v14, 0xCu);
    }
  }
  else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v13 = *(void **)(a1 + 32);
    v14 = 138412290;
    v15 = v13;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "fetched pcs identities for the following services: %@", (uint8_t *)&v14, 0xCu);
  }

  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
}

void sub_1000550B0(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  id v10;
  NSObject *v11;
  NSObject *v12;
  void *v13;
  int v14;
  id v15;

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = sub_10000BDF4(CFSTR("ckks-cuttlefish"), 0);
  v11 = objc_claimAutoreleasedReturnValue(v10);
  v12 = v11;
  if (v9)
  {
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v14 = 138412290;
      v15 = v9;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "error fetching current item: %@", (uint8_t *)&v14, 0xCu);
    }
  }
  else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v13 = *(void **)(a1 + 32);
    v14 = 138412290;
    v15 = v13;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "fetched current items for CIPs: %@", (uint8_t *)&v14, 0xCu);
  }

  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
}

void sub_1000557B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000558D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000559F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100055D10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100055DFC(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_100055E0C(uint64_t a1)
{

}

void sub_100055E14(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  v2 = objc_claimAutoreleasedReturnValue(+[CKKSPeerProviderState createFromProvider:](CKKSPeerProviderState, "createFromProvider:", *(_QWORD *)(a1 + 32)));
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  v4 = *(void **)(v3 + 40);
  *(_QWORD *)(v3 + 40) = v2;

}

void sub_100055E54(uint64_t a1)
{
  void *v2;
  _QWORD v3[5];

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "peerChangeListeners"));
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100055EC8;
  v3[3] = &unk_1002DC780;
  v3[4] = *(_QWORD *)(a1 + 32);
  objc_msgSend(v2, "iterateListeners:", v3);

}

id sub_100055EC8(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "trustedPeerSetChanged:", *(_QWORD *)(a1 + 32));
}

void sub_100055ED4(uint64_t a1)
{
  void *v2;
  _QWORD v3[5];

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "peerChangeListeners"));
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100055F48;
  v3[3] = &unk_1002DC780;
  v3[4] = *(_QWORD *)(a1 + 32);
  objc_msgSend(v2, "iterateListeners:", v3);

}

id sub_100055F48(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "selfPeerChanged:", *(_QWORD *)(a1 + 32));
}

void sub_100055F54(uint64_t a1)
{
  id v2;

  v2 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "peerChangeListeners"));
  objc_msgSend(v2, "registerListener:", *(_QWORD *)(a1 + 40));

}

void sub_100055F94(uint64_t a1)
{
  void *v2;
  void *v3;
  uint64_t v4;
  void *v5;
  _QWORD v6[6];
  id v7;
  id location;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t (*v12)(uint64_t, uint64_t);
  void (*v13)(uint64_t);
  id v14;

  v9 = 0;
  v10 = &v9;
  v11 = 0x3032000000;
  v12 = sub_100055DFC;
  v13 = sub_100055E0C;
  v14 = 0;
  location = (id)0xAAAAAAAAAAAAAAAALL;
  objc_initWeak(&location, *(id *)(a1 + 32));
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "cuttlefishXPCWrapper"));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "specificUser"));
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_1000560F8;
  v6[3] = &unk_1002DC018;
  objc_copyWeak(&v7, &location);
  v4 = *(_QWORD *)(a1 + 40);
  v6[4] = &v9;
  v6[5] = v4;
  objc_msgSend(v2, "fetchTrustStateWithSpecificUser:reply:", v3, v6);

  if (*(_QWORD *)(a1 + 48))
  {
    v5 = (void *)v10[5];
    if (v5)
      **(_QWORD **)(a1 + 48) = objc_retainAutorelease(v5);
  }
  objc_destroyWeak(&v7);
  objc_destroyWeak(&location);
  _Block_object_dispose(&v9, 8);

}

void sub_1000560C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location, char a17)
{
  id *v17;

  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Block_object_dispose(&a17, 8);
  _Unwind_Resume(a1);
}

void sub_1000560F8(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6;
  id v7;
  id WeakRetained;
  const void *v9;
  NSObject *v10;
  void *v11;
  uint64_t v12;
  id v13;
  id v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  id v18;
  id v19;
  uint64_t v20;
  void *i;
  uint64_t v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  CKKSActualPeer *v28;
  void *v29;
  void *v30;
  CKKSActualPeer *v31;
  id v32;
  void *v33;
  id v34;
  id obj;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  uint8_t v40[128];
  uint8_t buf[4];
  void *v42;
  __int16 v43;
  id v44;

  v6 = a3;
  v7 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (v7)
  {
    v9 = sub_10000EF14("octagon");
    v10 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "specificUser"));
      *(_DWORD *)buf = 138412546;
      v42 = v11;
      v43 = 2112;
      v44 = v7;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Unable to fetch trusted peers for (%@): %@", buf, 0x16u);

    }
    v12 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v13 = v7;
    v14 = *(id *)(v12 + 40);
    *(_QWORD *)(v12 + 40) = v13;
  }
  else
  {
    v15 = objc_claimAutoreleasedReturnValue(+[NSMutableSet set](NSMutableSet, "set"));
    v16 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v17 = *(void **)(v16 + 40);
    *(_QWORD *)(v16 + 40) = v15;

    v38 = 0u;
    v39 = 0u;
    v36 = 0u;
    v37 = 0u;
    v14 = v6;
    v18 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v36, v40, 16);
    if (v18)
    {
      v19 = v18;
      v32 = WeakRetained;
      v33 = 0;
      v34 = v6;
      obj = v14;
      v20 = *(_QWORD *)v37;
      do
      {
        for (i = 0; i != v19; i = (char *)i + 1)
        {
          v22 = a1;
          if (*(_QWORD *)v37 != v20)
            objc_enumerationMutation(obj);
          v23 = *(void **)(*((_QWORD *)&v36 + 1) + 8 * (_QWORD)i);
          v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v23, "signingSPKI", v32, v33, v34));
          v25 = (void *)objc_claimAutoreleasedReturnValue(+[_SFECPublicKey keyWithSubjectPublicKeyInfo:](_SFECPublicKey, "keyWithSubjectPublicKeyInfo:", v24));

          v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v23, "encryptionSPKI"));
          v27 = (void *)objc_claimAutoreleasedReturnValue(+[_SFECPublicKey keyWithSubjectPublicKeyInfo:](_SFECPublicKey, "keyWithSubjectPublicKeyInfo:", v26));

          v28 = [CKKSActualPeer alloc];
          v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v23, "peerID"));
          v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v23, "viewList"));
          v31 = -[CKKSActualPeer initWithPeerID:encryptionPublicKey:signingPublicKey:viewList:](v28, "initWithPeerID:encryptionPublicKey:signingPublicKey:viewList:", v29, v27, v25, v30);

          a1 = v22;
          objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(v22 + 40) + 8) + 40), "addObject:", v31);

        }
        v14 = obj;
        v19 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v36, v40, 16);
      }
      while (v19);
      v7 = v33;
      v6 = v34;
      WeakRetained = v32;
    }
  }

}

void sub_1000563C0(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  id v7;
  BOOL v8;
  const void *v9;
  NSObject *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  OctagonSelfPeer *v15;
  void *v16;
  OctagonSelfPeer *v17;
  CKKSSelves *v18;
  void *v19;
  CKKSSelves *v20;
  uint64_t v21;
  void *v22;
  uint8_t buf[16];
  id v24;
  id v25;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "peerID"));

  if (v2)
  {
    v3 = *(void **)(a1 + 32);
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "peerID"));
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("signing-key %@"), v4));
    v25 = 0;
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "fetchIdentity:error:", v5, &v25));
    v7 = v25;

    if (v6)
      v8 = v7 == 0;
    else
      v8 = 0;
    if (v8)
    {
      v11 = *(void **)(a1 + 32);
      v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "peerID"));
      v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("encryption-key %@"), v12));
      v24 = 0;
      v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "fetchIdentity:error:", v13, &v24));
      v7 = v24;

      if (!v14 || v7)
      {
        if (*(_QWORD *)(a1 + 48))
          **(_QWORD **)(a1 + 48) = objc_retainAutorelease(v7);
      }
      else
      {
        v15 = [OctagonSelfPeer alloc];
        v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "peerID"));
        v17 = -[OctagonSelfPeer initWithPeerID:signingIdentity:encryptionIdentity:](v15, "initWithPeerID:signingIdentity:encryptionIdentity:", v16, v6, v14);

        v18 = [CKKSSelves alloc];
        v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSSet set](NSSet, "set"));
        v20 = -[CKKSSelves initWithCurrent:allSelves:](v18, "initWithCurrent:allSelves:", v17, v19);
        v21 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
        v22 = *(void **)(v21 + 40);
        *(_QWORD *)(v21 + 40) = v20;

      }
    }
    else if (*(_QWORD *)(a1 + 48))
    {
      v7 = objc_retainAutorelease(v7);
      **(_QWORD **)(a1 + 48) = v7;
    }

  }
  else
  {
    v9 = sub_10000EF14("octagon-ckks");
    v10 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "No peer ID; therefore no identity", buf, 2u);
    }

    if (*(_QWORD *)(a1 + 48))
      **(_QWORD **)(a1 + 48) = (id)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:description:](NSError, "errorWithDomain:code:description:", CFSTR("com.apple.security.octagon"), 5, CFSTR("no peer ID present")));
  }
}

void sub_100056650(uint64_t a1)
{
  void *v2;
  void *v3;
  char *v4;
  const void *v5;
  NSObject *v6;
  uint64_t v7;
  void *v8;
  void *v9;
  id v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  int v14;
  uint64_t v15;
  __int16 v16;
  void *v17;

  v2 = (void *)objc_claimAutoreleasedReturnValue(+[_SFKeychainManager defaultOverCommitManager](_SFKeychainManager, "defaultOverCommitManager"));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "identityForIdentifier:", *(_QWORD *)(a1 + 32)));
  v4 = (char *)objc_msgSend(v3, "resultType");
  if ((unint64_t)(v4 - 1) >= 2)
  {
    if (!v4)
    {
      v11 = objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "value"));
      v12 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
      v13 = *(void **)(v12 + 40);
      *(_QWORD *)(v12 + 40) = v11;

    }
    v10 = 0;
  }
  else
  {
    v5 = sub_10000EF14("octagon-ckks");
    v6 = objc_claimAutoreleasedReturnValue(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v7 = *(_QWORD *)(a1 + 32);
      v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "error"));
      v14 = 138412546;
      v15 = v7;
      v16 = 2112;
      v17 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Unable to fetch identity '%@' from keychain: %@", (uint8_t *)&v14, 0x16u);

    }
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "error"));
    v10 = v9;
    if (*(_QWORD *)(a1 + 48) && v9)
    {
      v10 = objc_retainAutorelease(v9);
      **(_QWORD **)(a1 + 48) = v10;
    }
  }

}

void sub_10005723C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,id location)
{
  id *v23;

  objc_destroyWeak(v23);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10005755C(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id WeakRetained;
  const void *v8;
  NSObject *v9;
  void *v10;
  const void *v11;
  NSObject *v12;
  int v13;
  id v14;

  v5 = a2;
  v6 = a3;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (v6)
  {
    v8 = sub_10000EF14("SecError");
    v9 = objc_claimAutoreleasedReturnValue(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      v13 = 138412290;
      v14 = v6;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "octagon-health: error: %@", (uint8_t *)&v13, 0xCu);
    }

    objc_msgSend(WeakRetained, "setError:", v6);
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishOp"));
    objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v10);

  }
  else
  {
    v11 = sub_10000EF14("octagon-health");
    v12 = objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      v13 = 138412290;
      v14 = v5;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "cuttlefish came back with these suggestions: %@", (uint8_t *)&v13, 0xCu);
    }

    objc_msgSend(WeakRetained, "handleRepairSuggestions:", v5);
  }

}

void sub_100057F04(uint64_t a1)
{
  void *v2;
  void *v3;
  id v4;

  v4 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "getEvent"));
  v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *(unsigned __int8 *)(a1 + 48)));
  objc_msgSend(v4, "setObject:forKeyedSubscript:", v2, CFSTR("didSucceed"));

  objc_msgSend(v4, "populateUnderlyingErrorsStartingWithRootError:", *(_QWORD *)(a1 + 40));
  v3 = (void *)objc_claimAutoreleasedReturnValue(+[SecurityAnalyticsReporterRTC rtcAnalyticsReporter](SecurityAnalyticsReporterRTC, "rtcAnalyticsReporter"));
  objc_msgSend(v3, "sendEvent:", v4);

}

void sub_100057F98(id a1)
{
  void *v1;
  id v2;
  void *v3;
  void *v4;
  id v5;
  uint64_t v6;
  void *v7;
  void **v8;
  uint64_t v9;
  void (*v10)(uint64_t);
  void *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;

  v13 = 0;
  v14 = &v13;
  v15 = 0x2050000000;
  v1 = (void *)qword_100340EE8;
  v16 = qword_100340EE8;
  if (!qword_100340EE8)
  {
    v8 = _NSConcreteStackBlock;
    v9 = 3221225472;
    v10 = sub_100058124;
    v11 = &unk_1002EBE60;
    v12 = &v13;
    sub_100058124((uint64_t)&v8);
    v1 = (void *)v14[3];
  }
  v2 = objc_retainAutorelease(v1);
  _Block_object_dispose(&v13, 8);
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "analyticsTransportRTCWithClientType:clientBundleId:clientName:", &off_10030AF58, CFSTR("com.apple.securityd"), CFSTR("com.apple.aaa.dnu")));
  v13 = 0;
  v14 = &v13;
  v15 = 0x2050000000;
  v4 = (void *)qword_100340EF8;
  v16 = qword_100340EF8;
  if (!qword_100340EF8)
  {
    v8 = _NSConcreteStackBlock;
    v9 = 3221225472;
    v10 = sub_1000581E8;
    v11 = &unk_1002EBE60;
    v12 = &v13;
    sub_1000581E8((uint64_t)&v8);
    v4 = (void *)v14[3];
  }
  v5 = objc_retainAutorelease(v4);
  _Block_object_dispose(&v13, 8);
  v6 = objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "analyticsReporterWithTransport:", v3));
  v7 = (void *)qword_100340ED8;
  qword_100340ED8 = v6;

}

void sub_100058108(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100058124(uint64_t a1)
{
  void *v2;
  void *v3;

  sub_1000582AC();
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = objc_getClass("AAFAnalyticsTransportRTC");
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    qword_100340EE8 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Class getAAFAnalyticsTransportRTCClass(void)_block_invoke"));
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("SecurityAnalyticsReporterRTC.m"), 30, CFSTR("Unable to find class %s"), "AAFAnalyticsTransportRTC");

    __break(1u);
  }
}

void sub_1000581E8(uint64_t a1)
{
  void *v2;
  void *v3;

  sub_1000582AC();
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = objc_getClass("AAFAnalyticsReporter");
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    qword_100340EF8 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Class getAAFAnalyticsReporterClass(void)_block_invoke"));
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("SecurityAnalyticsReporterRTC.m"), 31, CFSTR("Unable to find class %s"), "AAFAnalyticsReporter");

    __break(1u);
  }
}

void sub_1000582AC()
{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  __int128 v4;
  uint64_t v5;

  v3 = 0;
  if (!qword_100340EF0)
  {
    v4 = off_1002DC0A8;
    v5 = 0;
    qword_100340EF0 = _sl_dlopen(&v4, &v3);
  }
  if (!qword_100340EF0)
  {
    v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "void *AAAFoundationLibrary(void)"));
    objc_msgSend(v1, "handleFailureInFunction:file:lineNumber:description:", v2, CFSTR("SecurityAnalyticsReporterRTC.m"), 29, CFSTR("%s"), v3);

    __break(1u);
    goto LABEL_7;
  }
  v0 = v3;
  if (v3)
LABEL_7:
    free(v0);
}

void sub_1000589E0(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 112));
  _Unwind_Resume(a1);
}

void sub_100058CB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  id *v18;

  objc_destroyWeak(v18);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000592C4(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_100059BFC(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Unwind_Resume(a1);
}

void sub_10005AC38(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,__int128 buf)
{
  id v35;
  const void *v36;
  NSObject *v37;

  if (a2 == 1)
  {
    v35 = objc_begin_catch(a1);
    v36 = sub_10000EF14("SecError");
    v37 = objc_claimAutoreleasedReturnValue(v36);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(_QWORD *)((char *)&buf + 4) = v35;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "TrustedPeersHelperSetupProtocol failed, continuing, but you might crash later: %@", (uint8_t *)&buf, 0xCu);
    }

    objc_exception_throw(objc_retainAutorelease(v35));
  }
  _Unwind_Resume(a1);
}

void sub_10005B124(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10005D7EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10005DB68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10005DE90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10005E5BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_list va;

  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10005ECC8(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 56));
  _Unwind_Resume(a1);
}

void sub_100065080(uint64_t a1, void *a2)
{
  void *v3;
  id v4;

  v3 = *(void **)(a1 + 32);
  v4 = a2;
  objc_msgSend(v3, "stopWithEvent:result:", CFSTR("OctagonEventReroll"), v4);
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

}

void sub_1000650D8(uint64_t a1, char a2, void *a3)
{
  id v5;
  const void *v6;
  NSObject *v7;
  const char *v8;
  NSObject *v9;
  uint32_t v10;
  const void *v11;
  int v12;
  id v13;

  v5 = a3;
  if (v5 || (a2 & 1) == 0)
  {
    v11 = sub_10000EF14("SecError");
    v7 = objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v12 = 138412290;
      v13 = v5;
      v8 = "octagon-remove-recovery-key: failed to remove recovery key: %@";
      v9 = v7;
      v10 = 12;
      goto LABEL_7;
    }
  }
  else
  {
    v6 = sub_10000EF14("octagon-remove-recovery-key");
    v7 = objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v12) = 0;
      v8 = "removed recovery key";
      v9 = v7;
      v10 = 2;
LABEL_7:
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v12, v10);
    }
  }

  (*(void (**)(_QWORD, id))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), v5);
}

void sub_1000651F8(uint64_t a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  const void *v6;
  int v7;
  id v8;

  v3 = a2;
  if (v3)
  {
    v4 = sub_10000EF14("SecError");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v7 = 138412290;
      v8 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "octagon-recover-with-recovery-key: failed to join with recovery key: %@", (uint8_t *)&v7, 0xCu);
    }
  }
  else
  {
    v6 = sub_10000EF14("octagon-recover-with-recovery-key");
    v5 = objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7) = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "successfully joined with recovery key", (uint8_t *)&v7, 2u);
    }
  }

  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_100065324(uint64_t a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  const void *v6;
  int v7;
  id v8;

  v3 = a2;
  if (v3)
  {
    v4 = sub_10000EF14("SecError");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v7 = 138412290;
      v8 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "octagon-reset-account-cdp-contents: error resetting account cdp contents: %@", (uint8_t *)&v7, 0xCu);
    }
  }
  else
  {
    v6 = sub_10000EF14("octagon-reset-account-cdp-contents");
    v5 = objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7) = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "successfully reset account cdp contents", (uint8_t *)&v7, 2u);
    }
  }

  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_100065450(uint64_t a1, int a2, void *a3)
{
  __CFString *v5;
  const void *v6;
  NSObject *v7;
  void (*v8)(void);
  const void *v9;
  NSObject *v10;
  const __CFString *v11;
  int v12;
  const __CFString *v13;

  v5 = a3;
  if (v5)
  {
    v6 = sub_10000EF14("SecError");
    v7 = objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v12 = 138412290;
      v13 = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "octagon-user-controllable-views: error fetching status: %@", (uint8_t *)&v12, 0xCu);
    }

    v8 = *(void (**)(void))(*(_QWORD *)(a1 + 32) + 16);
  }
  else
  {
    v9 = sub_10000EF14("octagon-user-controllable-views");
    v10 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      v11 = CFSTR("paused");
      if (a2)
        v11 = CFSTR("enabled");
      v12 = 138412290;
      v13 = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "successfully fetched status as: %@", (uint8_t *)&v12, 0xCu);
    }

    v8 = *(void (**)(void))(*(_QWORD *)(a1 + 32) + 16);
  }
  v8();

}

void sub_1000655AC(uint64_t a1, int a2, void *a3)
{
  __CFString *v5;
  const void *v6;
  NSObject *v7;
  void (*v8)(void);
  const void *v9;
  NSObject *v10;
  const __CFString *v11;
  int v12;
  const __CFString *v13;

  v5 = a3;
  if (v5)
  {
    v6 = sub_10000EF14("SecError");
    v7 = objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v12 = 138412290;
      v13 = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "octagon-user-controllable-views: error setting status: %@", (uint8_t *)&v12, 0xCu);
    }

    v8 = *(void (**)(void))(*(_QWORD *)(a1 + 32) + 16);
  }
  else
  {
    v9 = sub_10000EF14("octagon-user-controllable-views");
    v10 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      v11 = CFSTR("paused");
      if (a2)
        v11 = CFSTR("enabled");
      v12 = 138412290;
      v13 = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "successfully set status to: %@", (uint8_t *)&v12, 0xCu);
    }

    v8 = *(void (**)(void))(*(_QWORD *)(a1 + 32) + 16);
  }
  v8();

}

void sub_100065708(uint64_t a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  const void *v6;
  int v7;
  id v8;

  v3 = a2;
  if (v3)
  {
    v4 = sub_10000EF14("SecError");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v7 = 138412290;
      v8 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "octagon-remove-escrow-cache: error invalidating escrow cache: %@", (uint8_t *)&v7, 0xCu);
    }
  }
  else
  {
    v6 = sub_10000EF14("octagon-remove-escrow-caches");
    v5 = objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7) = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "successfully invalidated escrow cache", (uint8_t *)&v7, 2u);
    }
  }

  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_100065834(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  const void *v7;
  NSObject *v8;
  const void *v9;
  int v10;
  id v11;

  v5 = a2;
  v6 = a3;
  if (v6)
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v10 = 138412290;
      v11 = v6;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon-fetch-escrow-records: error fetching records: %@", (uint8_t *)&v10, 0xCu);
    }
  }
  else
  {
    v9 = sub_10000EF14("octagon-fetch-escrow-records");
    v8 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v10) = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "successfully fetched records", (uint8_t *)&v10, 2u);
    }
  }

  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_100065978(uint64_t a1, void *a2)
{
  __CFString *v3;
  const void *v4;
  NSObject *v5;
  const __CFString *v6;
  int v7;
  const __CFString *v8;

  v3 = a2;
  v4 = sub_10000EF14("octagon-ckks");
  v5 = objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = CFSTR("no error");
    if (v3)
      v6 = v3;
    v7 = 138412290;
    v8 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "refetch-ckks-policy result: %@", (uint8_t *)&v7, 0xCu);
  }

  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t sub_100065A54(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t sub_100065A60(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_100065A6C(id a1, TrustedPeersHelperHealthCheckResult *a2, NSError *a3)
{
  NSError *v3;
  const void *v4;
  NSObject *v5;
  const char *v6;
  NSObject *v7;
  uint32_t v8;
  const void *v9;
  int v10;
  NSError *v11;

  v3 = a3;
  if (v3)
  {
    v4 = sub_10000EF14("SecError");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v10 = 138412290;
      v11 = v3;
      v6 = "octagon: error attempting to check octagon health: %@";
      v7 = v5;
      v8 = 12;
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v10, v8);
    }
  }
  else
  {
    v9 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v10) = 0;
      v6 = "health check success";
      v7 = v5;
      v8 = 2;
      goto LABEL_6;
    }
  }

}

void sub_100065B68(uint64_t a1, void *a2, void *a3)
{
  void *v5;
  id v6;
  id v7;

  v5 = *(void **)(a1 + 32);
  v6 = a3;
  v7 = a2;
  objc_msgSend(v5, "stopWithEvent:result:", CFSTR("OctagonActivityRecreateInheritanceKey"), v6);
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

}

void sub_100065BDC(uint64_t a1, void *a2, void *a3)
{
  void *v5;
  id v6;
  id v7;

  v5 = *(void **)(a1 + 32);
  v6 = a3;
  v7 = a2;
  objc_msgSend(v5, "stopWithEvent:result:", CFSTR("OctagonEventRecreateInheritanceKey"), v6);
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

}

void sub_100065C50(uint64_t a1, uint64_t a2, void *a3)
{
  void *v4;
  id v5;

  v4 = *(void **)(a1 + 32);
  v5 = a3;
  objc_msgSend(v4, "stopWithEvent:result:", CFSTR("OctagonEventCheckInheritanceKey"), v5);
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

}

void sub_100065CB8(uint64_t a1, void *a2)
{
  void *v3;
  id v4;

  v3 = *(void **)(a1 + 32);
  v4 = a2;
  objc_msgSend(v3, "stopWithEvent:result:", CFSTR("OctagonEventRemoveInheritanceKey"), v4);
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

}

void sub_100065D10(uint64_t a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  const char *v6;
  NSObject *v7;
  uint32_t v8;
  const void *v9;
  int v10;
  id v11;

  v3 = a2;
  if (v3)
  {
    v4 = sub_10000EF14("SecError");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v10 = 138412290;
      v11 = v3;
      v6 = "octagon, preflight join with inheritance key failed: %@";
      v7 = v5;
      v8 = 12;
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v10, v8);
    }
  }
  else
  {
    v9 = sub_10000EF14("octagon-inheritance");
    v5 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v10) = 0;
      v6 = "preflight join with inheritance key succeeded";
      v7 = v5;
      v8 = 2;
      goto LABEL_6;
    }
  }

  objc_msgSend(*(id *)(a1 + 32), "stopWithEvent:result:", CFSTR("OctagonEventPreflightInheritanceKey"), v3);
  (*(void (**)(_QWORD, id))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), v3);

}

void sub_100065E3C(uint64_t a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  const char *v6;
  NSObject *v7;
  uint32_t v8;
  const void *v9;
  int v10;
  id v11;

  v3 = a2;
  if (v3)
  {
    v4 = sub_10000EF14("SecError");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v10 = 138412290;
      v11 = v3;
      v6 = "octagon, join with inheritance key failed: %@";
      v7 = v5;
      v8 = 12;
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v10, v8);
    }
  }
  else
  {
    v9 = sub_10000EF14("octagon-inheritance");
    v5 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v10) = 0;
      v6 = "join with inheritance key succeeded";
      v7 = v5;
      v8 = 2;
      goto LABEL_6;
    }
  }

  objc_msgSend(*(id *)(a1 + 32), "stopWithEvent:result:", CFSTR("OctagonEventJoinInheritanceKey"), v3);
  (*(void (**)(_QWORD, id))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), v3);

}

void sub_100065F68(uint64_t a1, void *a2)
{
  void *v3;
  id v4;

  v3 = *(void **)(a1 + 32);
  v4 = a2;
  objc_msgSend(v3, "stopWithEvent:result:", CFSTR("OctagonEventStoreInheritanceKey"), v4);
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

}

void sub_100065FC0(uint64_t a1, void *a2, void *a3)
{
  void *v5;
  id v6;
  id v7;

  v5 = *(void **)(a1 + 32);
  v6 = a3;
  v7 = a2;
  objc_msgSend(v5, "stopWithEvent:result:", CFSTR("OctagonEventGenerateInheritanceKey"), v6);
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

}

void sub_100066034(uint64_t a1, void *a2, void *a3)
{
  void *v5;
  id v6;
  id v7;

  v5 = *(void **)(a1 + 32);
  v6 = a3;
  v7 = a2;
  objc_msgSend(v5, "stopWithEvent:result:", CFSTR("OctagonEventCreateInheritanceKey"), v6);
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

}

void sub_1000660A8(uint64_t a1, uint64_t a2, void *a3)
{
  void *v4;
  id v5;

  v4 = *(void **)(a1 + 32);
  v5 = a3;
  objc_msgSend(v4, "stopWithEvent:result:", CFSTR("OctagonEventCheckCustodianRecoveryKey"), v5);
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

}

void sub_100066110(uint64_t a1, void *a2)
{
  void *v3;
  id v4;

  v3 = *(void **)(a1 + 32);
  v4 = a2;
  objc_msgSend(v3, "stopWithEvent:result:", CFSTR("OctagonEventRemoveCustodianRecoveryKey"), v4);
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

}

void sub_100066168(uint64_t a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  const char *v6;
  NSObject *v7;
  uint32_t v8;
  const void *v9;
  int v10;
  id v11;

  v3 = a2;
  if (v3)
  {
    v4 = sub_10000EF14("SecError");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v10 = 138412290;
      v11 = v3;
      v6 = "octagon, preflight join with custodian recovery key failed: %@";
      v7 = v5;
      v8 = 12;
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v10, v8);
    }
  }
  else
  {
    v9 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v10) = 0;
      v6 = "preflight join with custodian recovery key succeeded";
      v7 = v5;
      v8 = 2;
      goto LABEL_6;
    }
  }

  objc_msgSend(*(id *)(a1 + 32), "stopWithEvent:result:", CFSTR("OctagonEventPreflightCustodianRecoveryKey"), v3);
  (*(void (**)(_QWORD, id))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), v3);

}

void sub_100066294(uint64_t a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  const char *v6;
  NSObject *v7;
  uint32_t v8;
  const void *v9;
  int v10;
  id v11;

  v3 = a2;
  if (v3)
  {
    v4 = sub_10000EF14("SecError");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v10 = 138412290;
      v11 = v3;
      v6 = "octagon, join with custodian recovery key failed: %@";
      v7 = v5;
      v8 = 12;
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v10, v8);
    }
  }
  else
  {
    v9 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v10) = 0;
      v6 = "join with custodian recovery key succeeded";
      v7 = v5;
      v8 = 2;
      goto LABEL_6;
    }
  }

  objc_msgSend(*(id *)(a1 + 32), "stopWithEvent:result:", CFSTR("OctagonEventJoinCustodianRecoveryKey"), v3);
  (*(void (**)(_QWORD, id))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), v3);

}

void sub_1000663C0(uint64_t a1, void *a2, void *a3)
{
  void *v5;
  id v6;
  id v7;

  v5 = *(void **)(a1 + 32);
  v6 = a3;
  v7 = a2;
  objc_msgSend(v5, "stopWithEvent:result:", CFSTR("OctagonEventCreateCustodianRecoveryKey2"), v6);
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

}

void sub_100066434(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  unsigned int v6;
  unsigned __int8 v7;
  const void *v8;
  NSObject *v9;
  _BOOL4 v10;
  void *v11;
  void *v12;
  id v13;
  uint64_t v14;
  const void *v15;
  NSObject *v16;
  void *v17;
  const __CFString *v18;
  const void *v19;
  NSObject *v20;
  void (*v21)(void);
  _QWORD v22[4];
  id v23;
  uint64_t v24;
  id v25;
  id v26;
  id v27;
  uint8_t buf[4];
  void *v29;

  v3 = a2;
  v4 = v3;
  if (!v3)
  {
    v19 = sub_10000EF14("octagon");
    v20 = objc_claimAutoreleasedReturnValue(v19);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "join with recovery key succeeded", buf, 2u);
    }

    objc_msgSend(*(id *)(a1 + 40), "stopWithEvent:result:", CFSTR("OctagonEventJoinRecoveryKey"), 0);
    v21 = *(void (**)(void))(*(_QWORD *)(a1 + 72) + 16);
    goto LABEL_19;
  }
  if (objc_msgSend(v3, "code") != (id)34 && objc_msgSend(v4, "code") != (id)32
    || (v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "domain")),
        v6 = objc_msgSend(v5, "isEqualToString:", CFSTR("com.apple.security.trustedpeers.container")),
        v5,
        !v6))
  {
    v15 = sub_10000EF14("SecError");
    v16 = objc_claimAutoreleasedReturnValue(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v29 = v4;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "octagon, join with recovery key failed: %@", buf, 0xCu);
    }

    v17 = *(void **)(a1 + 40);
    v18 = CFSTR("OctagonEventJoinRecoveryKeyFailed");
    goto LABEL_18;
  }
  v7 = objc_msgSend(*(id *)(a1 + 32), "isFullPeer");
  v8 = sub_10000EF14("SecError");
  v9 = objc_claimAutoreleasedReturnValue(v8);
  v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  if ((v7 & 1) == 0)
  {
    if (v10)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "octagon: recovery key is not enrolled in octagon, and current device can't set recovery keys", buf, 2u);
    }

    v17 = *(void **)(a1 + 40);
    v18 = CFSTR("OctagonEventJoinRecoveryKeyCircleResetFailed");
LABEL_18:
    objc_msgSend(v17, "stopWithEvent:result:", v18, v4);
    v21 = *(void (**)(void))(*(_QWORD *)(a1 + 72) + 16);
LABEL_19:
    v21();
    goto LABEL_20;
  }
  if (v10)
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "octagon, recovery key is not enrolled in octagon, resetting octagon circle", buf, 2u);
  }

  v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "loggerClass"), "logger"));
  objc_msgSend(v11, "logResultForEvent:hardFailure:result:", CFSTR("OctagonEventJoinRecoveryKeyCircleReset"), 0, v4);

  v22[0] = _NSConcreteStackBlock;
  v22[1] = 3221225472;
  v22[2] = sub_100066740;
  v22[3] = &unk_1002DD218;
  v12 = *(void **)(a1 + 48);
  v23 = *(id *)(a1 + 40);
  v13 = *(id *)(a1 + 72);
  v14 = *(_QWORD *)(a1 + 32);
  v27 = v13;
  v24 = v14;
  v25 = *(id *)(a1 + 56);
  v26 = *(id *)(a1 + 64);
  objc_msgSend(v12, "rpcResetAndEstablish:idmsTargetContext:idmsCuttlefishPassword:notifyIdMS:accountSettings:reply:", 5, 0, 0, 0, 0, v22);

LABEL_20:
}

void sub_100066740(uint64_t a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  const void *v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  _QWORD v11[4];
  id v12;
  id v13;
  uint8_t buf[16];

  v3 = a2;
  if (v3)
  {
    v4 = sub_10000EF14("SecError");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "octagon, failed to reset octagon", buf, 2u);
    }

    objc_msgSend(*(id *)(a1 + 32), "stopWithEvent:result:", CFSTR("OctagonEventJoinRecoveryKeyCircleResetFailed"), v3);
    (*(void (**)(void))(*(_QWORD *)(a1 + 64) + 16))();
  }
  else
  {
    v6 = sub_10000EF14("octagon");
    v7 = objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "attempting enrolling recovery key", buf, 2u);
    }

    v8 = *(_QWORD *)(a1 + 48);
    v9 = *(_QWORD *)(a1 + 56);
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    v11[2] = sub_1000668B0;
    v11[3] = &unk_1002DE4E0;
    v10 = *(void **)(a1 + 40);
    v12 = *(id *)(a1 + 32);
    v13 = *(id *)(a1 + 64);
    objc_msgSend(v10, "createRecoveryKey:recoveryKey:reply:", v8, v9, v11);

  }
}

void sub_1000668B0(uint64_t a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  void (*v6)(void);
  const void *v7;
  NSObject *v8;
  int v9;
  id v10;

  v3 = a2;
  if (v3)
  {
    v4 = sub_10000EF14("SecError");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 138412290;
      v10 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "octagon, failed to enroll new recovery key: %@", (uint8_t *)&v9, 0xCu);
    }

    objc_msgSend(*(id *)(a1 + 32), "stopWithEvent:result:", CFSTR("OctagonEventJoinRecoveryKeyEnrollFailed"), v3);
    v6 = *(void (**)(void))(*(_QWORD *)(a1 + 40) + 16);
  }
  else
  {
    v7 = sub_10000EF14("octagon");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v9) = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "successfully enrolled recovery key", (uint8_t *)&v9, 2u);
    }

    objc_msgSend(*(id *)(a1 + 32), "stopWithEvent:result:", CFSTR("OctagonEventRecoveryKey"), 0);
    v6 = *(void (**)(void))(*(_QWORD *)(a1 + 40) + 16);
  }
  v6();

}

void sub_100066A04(uint64_t a1, void *a2)
{
  void *v3;
  id v4;

  v3 = *(void **)(a1 + 32);
  v4 = a2;
  objc_msgSend(v3, "stopWithEvent:result:", CFSTR("OctagonEventRecoveryKey"), v4);
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

}

void sub_100066A5C(id a1)
{
  uint64_t v1;
  void *v2;
  _QWORD v3[8];

  v3[0] = OTCliqueCDPContextTypeNone;
  v3[1] = OTCliqueCDPContextTypeSignIn;
  v3[2] = OTCliqueCDPContextTypeRepair;
  v3[3] = OTCliqueCDPContextTypeFinishPasscodeChange;
  v3[4] = OTCliqueCDPContextTypeRecoveryKeyGenerate;
  v3[5] = OTCliqueCDPContextTypeRecoveryKeyNew;
  v3[6] = OTCliqueCDPContextTypeUpdatePasscode;
  v3[7] = OTCliqueCDPContextTypeConfirmPasscodeCyrus;
  v1 = objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v3, 8));
  v2 = (void *)qword_100340F08;
  qword_100340F08 = v1;

}

id sub_100066B38(uint64_t a1)
{
  const void *v1;
  NSObject *v2;
  void *v3;
  id v4;
  const void *v5;
  NSObject *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  const void *v15;
  NSObject *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  id v28;
  const void *v29;
  NSObject *v30;
  void *v31;
  id v32;
  id v33;
  const void *v34;
  NSObject *v35;
  void *v36;
  id v37;
  void *v38;
  uint64_t v39;
  void *v40;
  _UNKNOWN **v41;
  const void *v42;
  NSObject *v43;
  void *v44;
  void *v45;
  const void *v46;
  NSObject *v47;
  void *v48;
  void *v49;
  void *v50;
  void *v51;
  uint64_t v52;
  id v53;
  uint64_t v54;
  void *i;
  void *v56;
  void *v57;
  uint64_t v58;
  id v59;
  uint64_t v60;
  void *j;
  const void *v62;
  NSObject *v63;
  void *v64;
  void *v65;
  NSObject *v66;
  const void *v67;
  void *v68;
  void *v69;
  id v70;
  uint64_t v71;
  void *k;
  uint64_t v73;
  void *v74;
  void *v75;
  void *v76;
  void *v77;
  void *v78;
  void *v79;
  void *v80;
  void *v81;
  id v82;
  id v83;
  id v84;
  void *v85;
  const void *v86;
  NSObject *v87;
  const void *v88;
  void *v89;
  void *v90;
  void *v91;
  uint64_t v92;
  void *v93;
  void *v94;
  uint64_t v95;
  void *v96;
  void *v97;
  uint64_t v98;
  void *v99;
  void *v100;
  void *v101;
  void *v102;
  id v103;
  void *v104;
  void *v105;
  NSObject *v107;
  void *v108;
  void *v109;
  void *v110;
  void *v111;
  void *v112;
  id v113;
  id v114;
  id WeakRetained;
  void *v116;
  void *v117;
  id obj;
  id obja;
  id v120;
  id v121;
  id v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  id v135;
  id v136;
  id v137;
  id v138;
  id v139;
  uint64_t v140;
  uint64_t *v141;
  uint64_t v142;
  uint64_t v143;
  _BYTE v144[128];
  _BYTE v145[128];
  uint8_t v146[128];
  _BYTE buf[24];
  void *v148;
  uint64_t *v149;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v116 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "contextForContainerName:contextID:", CFSTR("com.apple.security.keychain"), CFSTR("defaultContext")));
  v1 = sub_10000EF14("octagon-analytics");
  v2 = objc_claimAutoreleasedReturnValue(v1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412546;
    *(_QWORD *)&buf[4] = CFSTR("com.apple.security.keychain");
    *(_WORD *)&buf[12] = 2112;
    *(_QWORD *)&buf[14] = CFSTR("defaultContext");
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Reporting analytics for container: %@, context: %@", buf, 0x16u);
  }

  v120 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "sosAdapter"));
  v139 = 0;
  v4 = objc_msgSend(v3, "circleStatus:", &v139);
  v114 = v139;

  if (v114)
  {
    v5 = sub_10000EF14("octagon-analytics");
    v6 = objc_claimAutoreleasedReturnValue(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)&buf[4] = v114;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Error fetching SOS status: %@", buf, 0xCu);
    }

  }
  v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v4));
  objc_msgSend(v120, "setObject:forKeyedSubscript:", v7, CFSTR("OASOSStatus"));

  v8 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  v112 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "datePropertyForKey:", CFSTR("OctagonEventUpgradePreflightPreapprovedJoin")));

  v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", +[CKKSAnalytics fuzzyDaysSinceDate:](CKKSAnalytics, "fuzzyDaysSinceDate:", v112)));
  objc_msgSend(v120, "setObject:forKeyedSubscript:", v9, CFSTR("OALastPPJ"));

  v10 = (void *)objc_claimAutoreleasedReturnValue(+[OTStates OctagonStateMap](OTStates, "OctagonStateMap"));
  v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v116, "stateMachine"));
  v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "currentState"));
  v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "objectForKeyedSubscript:", v12));
  objc_msgSend(v120, "setObject:forKeyedSubscript:", v13, CFSTR("OASMState"));

  v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v116, "accountMetadataStore"));
  v138 = 0;
  v117 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "loadOrCreateAccountMetadata:", &v138));
  v113 = v138;

  if (v117 && !v113)
    goto LABEL_12;
  v15 = sub_10000EF14("octagon-analytics");
  v16 = objc_claimAutoreleasedReturnValue(v15);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    *(_QWORD *)&buf[4] = v113;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Error fetching Octagon metadata: %@", buf, 0xCu);
  }

  if (v117)
  {
LABEL_12:
    v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", objc_msgSend(v117, "icloudAccountState")));
    objc_msgSend(v120, "setObject:forKeyedSubscript:", v17, CFSTR("OAiC"));

    v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", objc_msgSend(v117, "cdpState")));
    objc_msgSend(v120, "setObject:forKeyedSubscript:", v18, CFSTR("OACDPStatus"));

    v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", objc_msgSend(v117, "trustState")));
    objc_msgSend(v120, "setObject:forKeyedSubscript:", v19, CFSTR("OATrust"));

  }
  else
  {
    objc_msgSend(v120, "setObject:forKeyedSubscript:", 0, CFSTR("OAiC"));
    objc_msgSend(v120, "setObject:forKeyedSubscript:", 0, CFSTR("OACDPStatus"));
    objc_msgSend(v120, "setObject:forKeyedSubscript:", 0, CFSTR("OATrust"));
  }
  v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v117, "getTPSyncingPolicy"));
  v111 = v20;
  if (v20)
  {
    v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", objc_msgSend(v20, "syncUserControllableViewsAsBoolean")));
    objc_msgSend(v120, "setObject:forKeyedSubscript:", v21, CFSTR("OAUserViewsSyncing"));

  }
  else
  {
    objc_msgSend(v120, "setObject:forKeyedSubscript:", 0, CFSTR("OAUserViewsSyncing"));
  }
  v110 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v116, "currentMemoizedLastHealthCheck"));
  v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", +[CKKSAnalytics fuzzyDaysSinceDate:](CKKSAnalytics, "fuzzyDaysSinceDate:", v110)));
  objc_msgSend(v120, "setObject:forKeyedSubscript:", v22, CFSTR("OAHealthCheck"));

  v23 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  v109 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v23, "datePropertyForKey:", CFSTR("OALastKSR")));

  v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", +[CKKSAnalytics fuzzyDaysSinceDate:](CKKSAnalytics, "fuzzyDaysSinceDate:", v109)));
  objc_msgSend(v120, "setObject:forKeyedSubscript:", v24, CFSTR("OALastKSR"));

  if (v117 && objc_msgSend(v117, "icloudAccountState") == 2)
  {
    v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", objc_msgSend(v117, "attemptedJoin")));
    objc_msgSend(v120, "setObject:forKeyedSubscript:", v25, CFSTR("OAAttemptedJoin"));

    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v116, "authKitAdapter"));
    v137 = 0;
    v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "machineID:flowID:deviceSessionID:canSendMetrics:error:", 0, 0, 0, 0, &v137));
    v28 = v137;

    if (v28)
    {
      v29 = sub_10000EF14("octagon-analytics");
      v30 = objc_claimAutoreleasedReturnValue(v29);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        *(_QWORD *)&buf[4] = v113;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "Error fetching machine ID: %@", buf, 0xCu);
      }

    }
    v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v27 != 0));
    objc_msgSend(v120, "setObject:forKeyedSubscript:", v31, CFSTR("OAMIDPresent"));

    if (v27)
    {
      v136 = 0;
      v32 = objc_msgSend(v116, "machineIDOnMemoizedList:error:", v27, &v136);
      v33 = v136;
      if (v33)
      {
        v34 = sub_10000EF14("octagon-analytics");
        v35 = objc_claimAutoreleasedReturnValue(v34);
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          *(_QWORD *)&buf[4] = v33;
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "Error fetching 'mid on list': %@", buf, 0xCu);
        }
      }
      else
      {
        v35 = objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v32));
        objc_msgSend(v120, "setObject:forKeyedSubscript:", v35, CFSTR("OAMIDOnList"));
      }

      v135 = 0;
      v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v116, "egoPeerStatus:", &v135));
      v37 = v135;
      obj = v37;
      if (!v36 || v37)
      {
        v67 = sub_10000EF14("octagon-analytics");
        v66 = objc_claimAutoreleasedReturnValue(v67);
        if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          *(_QWORD *)&buf[4] = obj;
          _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "Error fetching how many peers have our MID: %@", buf, 0xCu);
        }
      }
      else
      {
        v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v36, "peerCountsByMachineID"));
        v39 = objc_claimAutoreleasedReturnValue(objc_msgSend(v38, "objectForKeyedSubscript:", v27));
        v40 = (void *)v39;
        v41 = &off_10030A310;
        if (v39)
          v41 = (_UNKNOWN **)v39;
        v107 = v41;

        v42 = sub_10000EF14("octagon-metrics");
        v43 = objc_claimAutoreleasedReturnValue(v42);
        if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412546;
          *(_QWORD *)&buf[4] = v27;
          *(_WORD *)&buf[12] = 2112;
          *(_QWORD *)&buf[14] = v107;
          _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "Number of peers with machineID (%@): %@", buf, 0x16u);
        }

        objc_msgSend(v120, "setObject:forKeyedSubscript:", v107, CFSTR("OAPeersWithMID"));
        v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v36, "egoPeerMachineID"));
        v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", objc_msgSend(v27, "isEqualToString:", v44)));
        objc_msgSend(v120, "setObject:forKeyedSubscript:", v45, CFSTR("OAMIDMatchesCurrentMID"));

        v46 = sub_10000EF14("octagon-metrics");
        v47 = objc_claimAutoreleasedReturnValue(v46);
        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
        {
          v48 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v120, "objectForKeyedSubscript:", CFSTR("OAMIDMatchesCurrentMID")));
          v49 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v36, "egoPeerMachineID"));
          *(_DWORD *)buf = 138412802;
          *(_QWORD *)&buf[4] = v48;
          *(_WORD *)&buf[12] = 2112;
          *(_QWORD *)&buf[14] = v27;
          *(_WORD *)&buf[22] = 2112;
          v148 = v49;
          _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "MID match (current vs Octagon peer): %@, %@, %@", buf, 0x20u);

        }
        v133 = 0u;
        v134 = 0u;
        v131 = 0u;
        v132 = 0u;
        v50 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v36, "peerCountsByMachineID"));
        v51 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v50, "allValues"));

        v52 = 0;
        v53 = objc_msgSend(v51, "countByEnumeratingWithState:objects:count:", &v131, v146, 16);
        if (v53)
        {
          v54 = *(_QWORD *)v132;
          do
          {
            for (i = 0; i != v53; i = (char *)i + 1)
            {
              if (*(_QWORD *)v132 != v54)
                objc_enumerationMutation(v51);
              v52 += (uint64_t)objc_msgSend(*(id *)(*((_QWORD *)&v131 + 1) + 8 * (_QWORD)i), "longValue");
            }
            v53 = objc_msgSend(v51, "countByEnumeratingWithState:objects:count:", &v131, v146, 16);
          }
          while (v53);
        }

        v129 = 0u;
        v130 = 0u;
        v127 = 0u;
        v128 = 0u;
        v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v36, "viablePeerCountsByModelID"));
        v57 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v56, "allValues"));

        v58 = 0;
        v59 = objc_msgSend(v57, "countByEnumeratingWithState:objects:count:", &v127, v145, 16);
        if (v59)
        {
          v60 = *(_QWORD *)v128;
          do
          {
            for (j = 0; j != v59; j = (char *)j + 1)
            {
              if (*(_QWORD *)v128 != v60)
                objc_enumerationMutation(v57);
              v58 += (uint64_t)objc_msgSend(*(id *)(*((_QWORD *)&v127 + 1) + 8 * (_QWORD)j), "longValue");
            }
            v59 = objc_msgSend(v57, "countByEnumeratingWithState:objects:count:", &v127, v145, 16);
          }
          while (v59);
        }

        v62 = sub_10000EF14("octagon-metrics");
        v63 = objc_claimAutoreleasedReturnValue(v62);
        if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134218240;
          *(_QWORD *)&buf[4] = v52;
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v58;
          _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "Peers: %zu, viable peers %zu", buf, 0x16u);
        }

        v64 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v52));
        objc_msgSend(v120, "setObject:forKeyedSubscript:", v64, CFSTR("OAnPeers"));

        v65 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v58));
        objc_msgSend(v120, "setObject:forKeyedSubscript:", v65, CFSTR("OAnViablePeers"));

        v66 = v107;
      }

    }
  }
  v68 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  v108 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v68, "datePropertyForKey:", CFSTR("OALastCFU")));

  v69 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", +[CKKSAnalytics fuzzyDaysSinceDate:](CKKSAnalytics, "fuzzyDaysSinceDate:", v108)));
  objc_msgSend(v120, "setObject:forKeyedSubscript:", v69, CFSTR("OALastCFU"));

  v125 = 0u;
  v126 = 0u;
  v123 = 0u;
  v124 = 0u;
  obja = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "cdpContextTypes"));
  v70 = objc_msgSend(obja, "countByEnumeratingWithState:objects:count:", &v123, v144, 16);
  if (v70)
  {
    v71 = *(_QWORD *)v124;
    do
    {
      for (k = 0; k != v70; k = (char *)k + 1)
      {
        if (*(_QWORD *)v124 != v71)
          objc_enumerationMutation(obja);
        v73 = *(_QWORD *)(*((_QWORD *)&v123 + 1) + 8 * (_QWORD)k);
        v74 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@%@"), CFSTR("OACDPStateRun"), v73));
        v75 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@%@Tries"), CFSTR("OACDPStateRun"), v73));
        v76 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
        v77 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v76, "datePropertyForKey:", v74));

        if (v77)
        {
          v78 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", +[CKKSAnalytics fuzzyDaysSinceDate:](CKKSAnalytics, "fuzzyDaysSinceDate:", v77)));
          objc_msgSend(v120, "setObject:forKeyedSubscript:", v78, v74);

          v79 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
          v80 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v79, "numberPropertyForKey:", v75));
          objc_msgSend(v120, "setObject:forKeyedSubscript:", v80, v75);

        }
      }
      v70 = objc_msgSend(obja, "countByEnumeratingWithState:objects:count:", &v123, v144, 16);
    }
    while (v70);
  }

  v122 = v114;
  v81 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(objc_msgSend(WeakRetained, "escrowRequestClass"), "request:", &v122));
  v82 = v122;

  if (v81)
  {
    v121 = v82;
    v83 = objc_msgSend(v81, "pendingEscrowUpload:", &v121);
    v84 = v121;

    v85 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v83));
    objc_msgSend(v120, "setObject:forKeyedSubscript:", v85, CFSTR("OAPrerecordPending"));

    if (!v84)
      goto LABEL_74;
    v86 = sub_10000EF14("octagon-analytics");
    v87 = objc_claimAutoreleasedReturnValue(v86);
    if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)&buf[4] = v84;
      _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_DEFAULT, "Error fetching pendingEscrowUpload status: %@", buf, 0xCu);
    }
  }
  else
  {
    v88 = sub_10000EF14("octagon-analytics");
    v87 = objc_claimAutoreleasedReturnValue(v88);
    if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)&buf[4] = v82;
      _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_DEFAULT, "Error fetching escrowRequestClass: %@", buf, 0xCu);
    }
    v84 = v82;
  }

LABEL_74:
  v89 = (void *)objc_claimAutoreleasedReturnValue(+[ACAccountStore defaultStore](ACAccountStore, "defaultStore"));
  v90 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v89, "aa_primaryAppleAccount"));
  v91 = v90;
  if (v90)
  {
    v92 = ACAccountDataclassKeyValue;
    v93 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", objc_msgSend(v90, "isProvisionedForDataclass:", ACAccountDataclassKeyValue)));
    objc_msgSend(v120, "setObject:forKeyedSubscript:", v93, CFSTR("OADCKVSProvisioned"));

    v94 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", objc_msgSend(v91, "isEnabledForDataclass:", v92)));
    objc_msgSend(v120, "setObject:forKeyedSubscript:", v94, CFSTR("OADCKVSEnabled"));

    v95 = ACAccountDataclassKeychainSync;
    v96 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", objc_msgSend(v91, "isProvisionedForDataclass:", ACAccountDataclassKeychainSync)));
    objc_msgSend(v120, "setObject:forKeyedSubscript:", v96, CFSTR("OADCKCSProvisioned"));

    v97 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", objc_msgSend(v91, "isEnabledForDataclass:", v95)));
    objc_msgSend(v120, "setObject:forKeyedSubscript:", v97, CFSTR("OADCKCSEnabled"));

    v98 = ACAccountDataclassCKDatabaseService;
    v99 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", objc_msgSend(v91, "isProvisionedForDataclass:", ACAccountDataclassCKDatabaseService)));
    objc_msgSend(v120, "setObject:forKeyedSubscript:", v99, CFSTR("OADCCKProvisioned"));

    v100 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", objc_msgSend(v91, "isEnabledForDataclass:", v98)));
    objc_msgSend(v120, "setObject:forKeyedSubscript:", v100, CFSTR("OADCCKEnabled"));

    v101 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v91, "aa_altDSID"));
    if (v101)
    {
      v140 = 0;
      v141 = &v140;
      v142 = 0x2050000000;
      v102 = (void *)qword_100340F30;
      v143 = qword_100340F30;
      if (!qword_100340F30)
      {
        *(_QWORD *)buf = _NSConcreteStackBlock;
        *(_QWORD *)&buf[8] = 3221225472;
        *(_QWORD *)&buf[16] = sub_100067E14;
        v148 = &unk_1002EBE60;
        v149 = &v140;
        sub_100067E14((uint64_t)buf);
        v102 = (void *)v141[3];
      }
      v103 = objc_retainAutorelease(v102);
      _Block_object_dispose(&v140, 8);
      v104 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v103, "getAcceptedTermsForAltDSID:withError:", v101, 0));
      v105 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v104 != 0));
      objc_msgSend(v120, "setObject:forKeyedSubscript:", v105, CFSTR("OASecureBackupTermsAccepted"));

    }
  }

  return v120;
}

void sub_100067D90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
  _Block_object_dispose(&a55, 8);
  _Unwind_Resume(a1);
}

id sub_100067DB0(uint64_t a1)
{
  void *v1;
  void *v2;
  void *v3;

  v1 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "contextForContainerName:contextID:", CFSTR("com.apple.security.keychain"), CFSTR("defaultContext")));
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "followupHandler"));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "sfaStatus"));

  return v3;
}

Class sub_100067E14(uint64_t a1)
{
  Class result;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  __int128 v7;
  uint64_t v8;

  v6 = 0;
  if (!qword_100340F38)
  {
    v7 = off_1002DC318;
    v8 = 0;
    qword_100340F38 = _sl_dlopen(&v7, &v6);
  }
  if (!qword_100340F38)
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "void *CloudServicesLibrary(void)"));
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, CFSTR("OTManager.m"), 118, CFSTR("%s"), v6);

    goto LABEL_10;
  }
  if (v6)
    free(v6);
  result = objc_getClass("SecureBackup");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Class getSecureBackupClass(void)_block_invoke"));
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v5, CFSTR("OTManager.m"), 119, CFSTR("Unable to find class %s"), "SecureBackup");

LABEL_10:
    __break(1u);
  }
  qword_100340F30 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

void sub_100067FB0(uint64_t a1, void *a2)
{
  void *v3;
  id v4;

  v3 = *(void **)(a1 + 32);
  v4 = a2;
  objc_msgSend(v3, "stopWithEvent:result:", CFSTR("OctagonEventBottledPeerRestore"), v4);
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

}

void *sub_100068008()
{
  void *v0;
  void *v1;
  void *v3;
  void *v4;
  __int128 v5;
  uint64_t v6;

  v4 = 0;
  if (!qword_100340F18)
  {
    v5 = off_1002DC300;
    v6 = 0;
    qword_100340F18 = _sl_dlopen(&v5, &v4);
  }
  v0 = (void *)qword_100340F18;
  if (!qword_100340F18)
  {
    v0 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "void *KeychainCircleLibrary(void)"));
    objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("OTManager.m"), 110, CFSTR("%s"), v4);

    __break(1u);
    goto LABEL_7;
  }
  v1 = v4;
  if (v4)
LABEL_7:
    free(v1);
  return v0;
}

void sub_10006810C(_QWORD *a1, void *a2, void *a3, void *a4)
{
  void *v7;
  id v8;
  id v9;
  id v10;
  unint64_t Nanoseconds;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  os_signpost_id_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  int v20;
  int v21;
  uint64_t v22;
  __int16 v23;
  double v24;
  __int16 v25;
  int v26;

  if (!a4)
    *(_BYTE *)(*(_QWORD *)(a1[6] + 8) + 24) = 1;
  v7 = (void *)a1[4];
  v8 = a4;
  v9 = a3;
  v10 = a2;
  objc_msgSend(v7, "setSessionMetrics:", 0);
  Nanoseconds = _OctagonSignpostGetNanoseconds(a1[7], a1[8]);
  v12 = _OctagonSignpostLogSystem(Nanoseconds);
  v13 = objc_claimAutoreleasedReturnValue(v12);
  v14 = v13;
  v15 = a1[7];
  if (v15 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v13))
  {
    v16 = *(unsigned __int8 *)(*(_QWORD *)(a1[6] + 8) + 24);
    v21 = 67240192;
    LODWORD(v22) = v16;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v14, OS_SIGNPOST_INTERVAL_END, v15, "PairingChannelAcceptorVoucher", " OctagonSignpostNamePairingChannelAcceptorVoucher=%{public,signpost.telemetry:number1,name=OctagonSignpostNamePairingChannelAcceptorVoucher}d ", (uint8_t *)&v21, 8u);
  }

  v18 = _OctagonSignpostLogSystem(v17);
  v19 = objc_claimAutoreleasedReturnValue(v18);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    v21 = 134218496;
    v20 = *(unsigned __int8 *)(*(_QWORD *)(a1[6] + 8) + 24);
    v22 = a1[7];
    v23 = 2048;
    v24 = (double)Nanoseconds / 1000000000.0;
    v25 = 1026;
    v26 = v20;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: PairingChannelAcceptorVoucher  OctagonSignpostNamePairingChannelAcceptorVoucher=%{public,signpost.telemetry:number1,name=OctagonSignpostNamePairingChannelAcceptorVoucher}d ", (uint8_t *)&v21, 0x1Cu);
  }

  (*(void (**)(void))(a1[5] + 16))();
}

void sub_1000682E4(_QWORD *a1, uint64_t a2, void *a3)
{
  void *v4;
  id v5;
  unint64_t Nanoseconds;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  os_signpost_id_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  int v16;
  uint64_t v17;
  __int16 v18;
  double v19;
  __int16 v20;
  int v21;

  if (!a3)
    *(_BYTE *)(*(_QWORD *)(a1[6] + 8) + 24) = 1;
  v4 = (void *)a1[4];
  v5 = a3;
  objc_msgSend(v4, "setSessionMetrics:", 0);
  Nanoseconds = _OctagonSignpostGetNanoseconds(a1[7], a1[8]);
  v7 = _OctagonSignpostLogSystem(Nanoseconds);
  v8 = objc_claimAutoreleasedReturnValue(v7);
  v9 = v8;
  v10 = a1[7];
  if (v10 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v8))
  {
    v11 = *(unsigned __int8 *)(*(_QWORD *)(a1[6] + 8) + 24);
    v16 = 67240192;
    LODWORD(v17) = v11;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v9, OS_SIGNPOST_INTERVAL_END, v10, "PairingChannelAcceptorEpoch", " OctagonSignpostNamePairingChannelAcceptorEpoch=%{public,signpost.telemetry:number1,name=OctagonSignpostNamePairingChannelAcceptorEpoch}d ", (uint8_t *)&v16, 8u);
  }

  v13 = _OctagonSignpostLogSystem(v12);
  v14 = objc_claimAutoreleasedReturnValue(v13);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    v16 = 134218496;
    v15 = *(unsigned __int8 *)(*(_QWORD *)(a1[6] + 8) + 24);
    v17 = a1[7];
    v18 = 2048;
    v19 = (double)Nanoseconds / 1000000000.0;
    v20 = 1026;
    v21 = v15;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: PairingChannelAcceptorEpoch  OctagonSignpostNamePairingChannelAcceptorEpoch=%{public,signpost.telemetry:number1,name=OctagonSignpostNamePairingChannelAcceptorEpoch}d ", (uint8_t *)&v16, 0x1Cu);
  }

  (*(void (**)(void))(a1[5] + 16))();
}

void sub_100068494(uint64_t a1, void *a2)
{
  id v3;
  unint64_t Nanoseconds;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  os_signpost_id_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  int v13;
  int v14;
  uint64_t v15;
  __int16 v16;
  double v17;
  __int16 v18;
  int v19;

  v3 = a2;
  if (!v3)
  {
    objc_msgSend(*(id *)(a1 + 32), "clearPairingUUID");
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = 1;
  }
  objc_msgSend(*(id *)(a1 + 32), "setSessionMetrics:", 0);
  Nanoseconds = _OctagonSignpostGetNanoseconds(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64));
  v5 = _OctagonSignpostLogSystem(Nanoseconds);
  v6 = objc_claimAutoreleasedReturnValue(v5);
  v7 = v6;
  v8 = *(_QWORD *)(a1 + 56);
  if (v8 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v6))
  {
    v9 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
    v14 = 67240192;
    LODWORD(v15) = v9;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v7, OS_SIGNPOST_INTERVAL_END, v8, "PairingChannelInitiatorJoinOctagon", " OctagonSignpostNamePairingChannelInitiatorJoinOctagon=%{public,signpost.telemetry:number1,name=OctagonSignpostNamePairingChannelInitiatorJoinOctagon}d ", (uint8_t *)&v14, 8u);
  }

  v11 = _OctagonSignpostLogSystem(v10);
  v12 = objc_claimAutoreleasedReturnValue(v11);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    v14 = 134218496;
    v13 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
    v15 = *(_QWORD *)(a1 + 56);
    v16 = 2048;
    v17 = (double)Nanoseconds / 1000000000.0;
    v18 = 1026;
    v19 = v13;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: PairingChannelInitiatorJoinOctagon  OctagonSignpostNamePairingChannelInitiatorJoinOctagon=%{public,signpost.telemetry:number1,name=OctagonSignpostNamePairingChannelInitiatorJoinOctagon}d ", (uint8_t *)&v14, 0x1Cu);
  }

  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
}

void sub_100068640(_QWORD *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7)
{
  void *v13;
  id v14;
  id v15;
  id v16;
  id v17;
  id v18;
  id v19;
  unint64_t Nanoseconds;
  uint64_t v21;
  NSObject *v22;
  NSObject *v23;
  os_signpost_id_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  NSObject *v28;
  int v29;
  int v30;
  uint64_t v31;
  __int16 v32;
  double v33;
  __int16 v34;
  int v35;

  if (!a7)
    *(_BYTE *)(*(_QWORD *)(a1[6] + 8) + 24) = 1;
  v13 = (void *)a1[4];
  v14 = a7;
  v15 = a6;
  v16 = a5;
  v17 = a4;
  v18 = a3;
  v19 = a2;
  objc_msgSend(v13, "setSessionMetrics:", 0);
  Nanoseconds = _OctagonSignpostGetNanoseconds(a1[7], a1[8]);
  v21 = _OctagonSignpostLogSystem(Nanoseconds);
  v22 = objc_claimAutoreleasedReturnValue(v21);
  v23 = v22;
  v24 = a1[7];
  if (v24 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v22))
  {
    v25 = *(unsigned __int8 *)(*(_QWORD *)(a1[6] + 8) + 24);
    v30 = 67240192;
    LODWORD(v31) = v25;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v23, OS_SIGNPOST_INTERVAL_END, v24, "PairingChannelInitiatorPrepare", " OctagonSignpostNamePairingChannelInitiatorPrepare=%{public,signpost.telemetry:number1,name=OctagonSignpostNamePairingChannelInitiatorPrepare}d ", (uint8_t *)&v30, 8u);
  }

  v27 = _OctagonSignpostLogSystem(v26);
  v28 = objc_claimAutoreleasedReturnValue(v27);
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    v30 = 134218496;
    v29 = *(unsigned __int8 *)(*(_QWORD *)(a1[6] + 8) + 24);
    v31 = a1[7];
    v32 = 2048;
    v33 = (double)Nanoseconds / 1000000000.0;
    v34 = 1026;
    v35 = v29;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: PairingChannelInitiatorPrepare  OctagonSignpostNamePairingChannelInitiatorPrepare=%{public,signpost.telemetry:number1,name=OctagonSignpostNamePairingChannelInitiatorPrepare}d ", (uint8_t *)&v30, 0x1Cu);
  }

  (*(void (**)(void))(a1[5] + 16))();
}

void sub_10006885C(uint64_t a1, void *a2, void *a3, void *a4, void *a5)
{
  void *v9;
  id v10;
  id v11;
  id v12;
  id v13;

  v9 = *(void **)(a1 + 32);
  v10 = a5;
  v11 = a4;
  v12 = a3;
  v13 = a2;
  objc_msgSend(v9, "stopWithEvent:result:", CFSTR("OctagonEventFetchEscrowContents"), v10);
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

}

void sub_100068900(uint64_t a1, void *a2, void *a3, void *a4)
{
  void *v7;
  id v8;
  id v9;
  id v10;

  v7 = *(void **)(a1 + 32);
  v8 = a4;
  v9 = a3;
  v10 = a2;
  objc_msgSend(v7, "stopWithEvent:result:", CFSTR("OctagonEventFetchAllBottles"), v8);
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

}

void sub_100068990(uint64_t a1, void *a2)
{
  void *v3;
  id v4;

  v3 = *(void **)(a1 + 32);
  v4 = a2;
  objc_msgSend(v3, "stopWithEvent:result:", CFSTR("OctagonEventRemoveFriendsInClique"), v4);
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

}

void sub_1000689E8(uint64_t a1, void *a2)
{
  void *v3;
  id v4;

  v3 = *(void **)(a1 + 32);
  v4 = a2;
  objc_msgSend(v3, "stopWithEvent:result:", CFSTR("OctagonEventLeaveClique"), v4);
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

}

void sub_100068A40(uint64_t a1, void *a2)
{
  void *v3;
  id v4;

  v3 = *(void **)(a1 + 32);
  v4 = a2;
  objc_msgSend(v3, "stopWithEvent:result:", CFSTR("OctagonEventEstablish"), v4);
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

}

void sub_100068A98(uint64_t a1, void *a2)
{
  void *v3;
  id v4;

  v3 = *(void **)(a1 + 32);
  v4 = a2;
  objc_msgSend(v3, "stopWithEvent:result:", CFSTR("OctagonEventResetAndEstablish"), v4);
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

}

uint64_t sub_100068AF0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_100068B00(uint64_t a1, uint64_t a2, void *a3, void *a4, uint64_t a5, uint64_t a6, void *a7)
{
  id v12;
  id v13;
  void *v14;
  id v15;
  id v16;
  uint64_t v17;
  uint64_t v18;
  void *i;
  uint64_t v20;
  void *v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  _BYTE v26[128];

  v12 = a3;
  v13 = a7;
  v22 = 0u;
  v23 = 0u;
  v24 = 0u;
  v25 = 0u;
  v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a4, "allValues", 0));
  v15 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v22, v26, 16);
  if (v15)
  {
    v16 = v15;
    v17 = 0;
    v18 = *(_QWORD *)v23;
    do
    {
      for (i = 0; i != v16; i = (char *)i + 1)
      {
        if (*(_QWORD *)v23 != v18)
          objc_enumerationMutation(v14);
        v17 += (uint64_t)objc_msgSend(*(id *)(*((_QWORD *)&v22 + 1) + 8 * (_QWORD)i), "longValue");
      }
      v16 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v22, v26, 16);
    }
    while (v16);
  }
  else
  {
    v17 = 0;
  }

  v20 = *(_QWORD *)(a1 + 32);
  v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithLong:](NSNumber, "numberWithLong:", v17));
  (*(void (**)(uint64_t, uint64_t, id, void *, uint64_t, id))(v20 + 16))(v20, a2, v12, v21, a5, v13);

}

void sub_100068C7C(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v4;
  id v5;
  uint64_t v6;
  id v7;

  v4 = *(_QWORD *)(a1 + 32);
  v5 = a2;
  v6 = CKXPCSuitableError(a3);
  v7 = (id)objc_claimAutoreleasedReturnValue(v6);
  (*(void (**)(uint64_t, id, id))(v4 + 16))(v4, v5, v7);

}

void sub_100068CE0(uint64_t a1)
{
  id v1;

  v1 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "contexts"));
  objc_msgSend(v1, "removeAllObjects");

}

uint64_t sub_100068D10(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_100068D20(uint64_t a1)
{

}

void sub_100068D28(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  void *v3;
  id v4;
  id v5;
  uint64_t v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  void *v17;
  id v18;
  id v19;
  id obj;
  unsigned int v21;
  void *v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  _BYTE v27[128];

  v1 = a1;
  v23 = 0u;
  v24 = 0u;
  v25 = 0u;
  v26 = 0u;
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "contexts"));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "allValues"));

  obj = v3;
  v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v23, v27, 16);
  if (v4)
  {
    v5 = v4;
    v6 = *(_QWORD *)v24;
    do
    {
      v7 = 0;
      v19 = v5;
      do
      {
        if (*(_QWORD *)v24 != v6)
          objc_enumerationMutation(obj);
        v8 = *(void **)(*((_QWORD *)&v23 + 1) + 8 * (_QWORD)v7);
        v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "ckks"));
        v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "container"));
        v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v1 + 40), "container"));
        if ((objc_msgSend(v10, "isEqual:", v11) & 1) != 0)
        {
          v18 = v8;
          v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "ckks"));
          v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "operationDependencies"));
          v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "contextID"));
          v14 = v1;
          v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v1 + 40), "operationDependencies"));
          v16 = v6;
          v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "contextID"));
          v21 = objc_msgSend(v13, "isEqualToString:", v17);

          v6 = v16;
          v1 = v14;
          v5 = v19;

          if (v21)
          {
            objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(v1 + 48) + 8) + 40), v18);
            goto LABEL_12;
          }
        }
        else
        {

        }
        v7 = (char *)v7 + 1;
      }
      while (v5 != v7);
      v5 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v23, v27, 16);
    }
    while (v5);
  }
LABEL_12:

}

void sub_100068F40(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  id v7;

  v7 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@-%@"), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40)));
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "contexts"));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "objectForKeyedSubscript:", v7));

  if (v3)
  {
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "stateMachine"));
    objc_msgSend(v4, "haltOperation");

    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "ckks"));
    objc_msgSend(v5, "halt");

  }
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "contexts"));
  objc_msgSend(v6, "setObject:forKeyedSubscript:", 0, v7);

}

void sub_100069010(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  id v5;

  v5 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "contexts"));
  v2 = objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "allValues"));
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  v4 = *(void **)(v3 + 40);
  *(_QWORD *)(v3 + 40) = v2;

}

void sub_100069064(uint64_t a1)
{
  const void *v2;
  NSObject *v3;
  id WeakRetained;
  id v5;
  uint8_t v6[16];

  v2 = sub_10000EF14("octagon");
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "circle changed notification called, checking trust state", v6, 2u);
  }

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v5 = objc_alloc_init((Class)OTControlArguments);
  objc_msgSend(WeakRetained, "moveToCheckTrustedStateForArguments:", v5);

}

void sub_100069104(uint64_t a1)
{
  void *v1;
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v1 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "viewManager"));
  objc_msgSend(v1, "notifyNewTLKsInKeychain");

}

void sub_100069148(uint64_t a1)
{
  void *v1;
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v1 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "viewManager"));
  objc_msgSend(v1, "notifyNewTLKsInKeychain");

}

void sub_1000694D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  id *v20;
  id *v21;

  objc_destroyWeak(v21);
  objc_destroyWeak(v20);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100069BD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100069C8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10006A42C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10006A56C(uint64_t a1)
{
  void *v2;
  void *v3;

  if (objc_msgSend(*(id *)(a1 + 32), "fillInError"))
  {
    v2 = *(void **)(a1 + 32);
    v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "internalSuccesses"));
    objc_msgSend(v2, "allSuccessful:", v3);

  }
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 80) = 0;
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 81) = 1;
}

uint64_t sub_10006A5E8(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)(result + 32) + 81) = 1;
  return result;
}

uint64_t sub_10006A600(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)(result + 32) + 80) = 1;
  return result;
}

uint64_t sub_10006A618(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) = *(_BYTE *)(*(_QWORD *)(result + 32) + 81);
  return result;
}

uint64_t sub_10006A634(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) = *(_BYTE *)(*(_QWORD *)(result + 32) + 80);
  return result;
}

void sub_10006A650(uint64_t a1)
{
  id WeakRetained;
  void *v2;
  id v3;
  NSObject *v4;
  id v5;
  NSObject *v6;
  void *v7;
  int v8;
  void *v9;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v2 = WeakRetained;
  if (WeakRetained)
  {
    if ((objc_msgSend(WeakRetained, "allDependentsSuccessful") & 1) != 0)
    {
      objc_msgSend(v2, "groupStart");
    }
    else
    {
      v5 = sub_10000BDF4(CFSTR("ckksgroup"), 0);
      v6 = objc_claimAutoreleasedReturnValue(v5);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "error"));
        v8 = 138412290;
        v9 = v7;
        _os_log_debug_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "Not running due to some failed dependent: %@", (uint8_t *)&v8, 0xCu);

      }
      objc_msgSend(v2, "cancel");
    }
  }
  else
  {
    v3 = sub_10000BDF4(CFSTR("ckks"), 0);
    v4 = objc_claimAutoreleasedReturnValue(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v8) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "received callback for released object", (uint8_t *)&v8, 2u);
    }

  }
}

void sub_10006A7A0(uint64_t a1)
{
  id WeakRetained;
  void *v2;
  id v3;
  NSObject *v4;
  uint8_t v5[16];

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v2 = WeakRetained;
  if (WeakRetained)
  {
    objc_msgSend(WeakRetained, "completeOperation");
  }
  else
  {
    v3 = sub_10000BDF4(CFSTR("ckks"), 0);
    v4 = objc_claimAutoreleasedReturnValue(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "received callback for released object", v5, 2u);
    }

  }
}

void sub_10006A9FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10006AA1C(uint64_t a1)
{
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();

}

void sub_10006EA14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  _Block_object_dispose(&a26, 8);
  _Unwind_Resume(a1);
}

void sub_10006EC60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10006EEA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10006F188(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_10006F198(uint64_t a1)
{

}

void sub_10006F1A0(uint64_t a1, void *a2)
{
  void *v2;
  void *v3;
  id v4;

  v2 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  v4 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(a2, "objectForKeyedSubscript:", CFSTR("parentKeyUUID")));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "asString"));
  objc_msgSend(v2, "addObject:", v3);

}

void sub_10006F204(uint64_t a1, void *a2)
{
  void *v2;
  void *v3;
  id v4;

  v2 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  v4 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(a2, "objectForKeyedSubscript:", CFSTR("UUID")));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "asString"));
  objc_msgSend(v2, "addObject:", v3);

}

void sub_10006F268(uint64_t a1, void *a2)
{
  void *v2;
  void *v3;
  id v4;

  v2 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  v4 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(a2, "objectForKeyedSubscript:", CFSTR("UUID")));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "asString"));
  objc_msgSend(v2, "addObject:", v3);

}

void sub_100070A54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,id location)
{
  id *v35;

  objc_destroyWeak(v35);
  objc_destroyWeak(&location);
  _Block_object_dispose(&a29, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100070BC0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_100070BD0(uint64_t a1)
{

}

void sub_100070BD8(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6;
  id v7;
  id WeakRetained;
  id v9;
  NSObject *v10;
  void *v11;
  void *v12;
  void *v13;
  unsigned int v14;
  id v15;
  NSObject *v16;
  id v17;
  NSObject *v18;
  void *v19;
  void *v20;
  uint64_t v21;
  id v22;
  id v23;
  _QWORD v24[5];
  id v25;
  id v26;
  uint64_t v27;
  uint8_t buf[4];
  id v29;

  v6 = a3;
  v7 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (v7)
  {
    v9 = sub_10000BDF4(CFSTR("ckkszonemodifier"), 0);
    v10 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      v29 = v7;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Zone modification failed: %@", buf, 0xCu);
    }

    v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    objc_msgSend(v11, "inspectErrorForRetryAfter:", v7);

    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "reachabilityTracker"));
    v14 = objc_msgSend(v13, "isNetworkError:", v7);

    if (v14)
    {
      v15 = sub_10000BDF4(CFSTR("ckkszonemodifier"), 0);
      v16 = objc_claimAutoreleasedReturnValue(v15);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Waiting for reachability before issuing zone deletion", buf, 2u);
      }

      objc_msgSend(WeakRetained, "setNetworkError:", 1);
    }
  }
  v17 = sub_10000BDF4(CFSTR("ckkszonemodifier"), 0);
  v18 = objc_claimAutoreleasedReturnValue(v17);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    v29 = v6;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "deleted zones: %@", buf, 0xCu);
  }

  v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
  v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "databaseProvider"));
  v24[0] = _NSConcreteStackBlock;
  v24[1] = 3221225472;
  v24[2] = sub_100070F84;
  v24[3] = &unk_1002E9178;
  v21 = *(_QWORD *)(a1 + 32);
  v24[4] = WeakRetained;
  v25 = v6;
  v26 = v7;
  v27 = v21;
  v22 = v7;
  v23 = v6;
  objc_msgSend(v20, "dispatchSyncWithSQLTransaction:", v24);

}

void sub_100070E5C(uint64_t a1)
{
  id WeakRetained;
  id v2;
  NSObject *v3;
  void *v4;
  void *v5;
  id v6;
  NSObject *v7;
  uint8_t v8[16];
  uint8_t buf[16];

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v2 = sub_10000BDF4(CFSTR("ckkszonemodifier"), 0);
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Finished deleting zones", buf, 2u);
  }

  if (objc_msgSend(WeakRetained, "networkError"))
  {
    objc_msgSend(WeakRetained, "setNextState:", CFSTR("zone_deletion_failed_due_to_network_error"));
  }
  else
  {
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));

    if (!v4)
    {
      v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "intendedState"));
      objc_msgSend(WeakRetained, "setNextState:", v5);

      v6 = sub_10000BDF4(CFSTR("ckkszonemodifier"), 0);
      v7 = objc_claimAutoreleasedReturnValue(v6);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v8 = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "no fatal errors discovered!", v8, 2u);
      }

    }
  }

}

uint64_t sub_100070F84(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  void *v3;
  uint64_t v4;
  void *i;
  void *v6;
  id v7;
  id v8;
  id v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  void *v13;
  unsigned __int8 v14;
  id v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  id v23;
  id v24;
  uint64_t v25;
  void *j;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  id v31;
  BOOL v32;
  void *v33;
  void *v34;
  id v35;
  NSObject *v36;
  void *v37;
  void *v38;
  id v39;
  NSObject *v40;
  void *v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  id v46;
  NSObject *v47;
  void *v48;
  void *v49;
  id v50;
  NSObject *v51;
  void *v52;
  void *v53;
  void *v54;
  void *v55;
  void *v56;
  void *v57;
  void *v58;
  id v59;
  NSObject *v60;
  void *v61;
  void *v62;
  void *v63;
  uint64_t v65;
  void *v66;
  id v67;
  id v68;
  void *v69;
  uint64_t v70;
  id v71;
  id v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  uint8_t buf[4];
  void *v86;
  __int16 v87;
  id v88;
  _BYTE v89[128];
  _BYTE v90[128];
  _BYTE v91[128];

  v1 = a1;
  v81 = 0u;
  v82 = 0u;
  v83 = 0u;
  v84 = 0u;
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "deps"));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "views"));

  v68 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v81, v91, 16);
  if (v68)
  {
    v4 = *(_QWORD *)v82;
    v70 = v1;
    v65 = *(_QWORD *)v82;
    v66 = v3;
    do
    {
      for (i = 0; i != v68; i = (char *)i + 1)
      {
        if (*(_QWORD *)v82 != v4)
          objc_enumerationMutation(v3);
        v6 = *(void **)(*((_QWORD *)&v81 + 1) + 8 * (_QWORD)i);
        v77 = 0u;
        v78 = 0u;
        v79 = 0u;
        v80 = 0u;
        v7 = *(id *)(*(_QWORD *)(*(_QWORD *)(v1 + 56) + 8) + 40);
        v8 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v77, v90, 16);
        if (!v8)
          goto LABEL_56;
        v9 = v8;
        v69 = i;
        v10 = *(_QWORD *)v78;
LABEL_8:
        v11 = 0;
        while (1)
        {
          if (*(_QWORD *)v78 != v10)
            objc_enumerationMutation(v7);
          v12 = *(void **)(*((_QWORD *)&v77 + 1) + 8 * v11);
          v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "zoneID", v65, v66));
          v14 = objc_msgSend(v12, "isEqual:", v13);

          if ((v14 & 1) != 0)
            break;
          if (v9 == (id)++v11)
          {
            v9 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v77, v90, 16);
            if (!v9)
            {
              v1 = v70;
              i = v69;
              goto LABEL_56;
            }
            goto LABEL_8;
          }
        }
        v15 = v12;

        v1 = v70;
        i = v69;
        if (v15)
        {
          v16 = *(void **)(v70 + 40);
          v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "zoneID"));
          LOBYTE(v16) = objc_msgSend(v16, "containsObject:", v17);

          if ((v16 & 1) == 0)
          {
            v18 = *(void **)(v70 + 48);
            if (v18)
            {
              v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "userInfo"));
              v71 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "objectForKeyedSubscript:", CKPartialErrorsByItemIDKey));

              v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v70 + 48), "domain"));
              if (objc_msgSend(v20, "isEqualToString:", CKErrorDomain)
                && objc_msgSend(*(id *)(v70 + 48), "code") == (id)2)
              {

                if (v71)
                {
                  v67 = v15;
                  v75 = 0u;
                  v76 = 0u;
                  v73 = 0u;
                  v74 = 0u;
                  v21 = v71;
                  v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v71, "allKeys"));
                  v23 = objc_msgSend(v22, "countByEnumeratingWithState:objects:count:", &v73, v89, 16);
                  if (!v23)
                    goto LABEL_39;
                  v24 = v23;
                  v25 = *(_QWORD *)v74;
                  while (1)
                  {
                    for (j = 0; j != v24; j = (char *)j + 1)
                    {
                      if (*(_QWORD *)v74 != v25)
                        objc_enumerationMutation(v22);
                      v27 = *(void **)(*((_QWORD *)&v73 + 1) + 8 * (_QWORD)j);
                      v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "objectForKeyedSubscript:", v27));
                      v29 = v28;
                      if (!v28)
                        goto LABEL_31;
                      v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "domain"));
                      if ((objc_msgSend(v30, "isEqualToString:", CKErrorDomain) & 1) == 0)
                      {

LABEL_31:
                        objc_msgSend(*(id *)(v1 + 32), "setError:", *(_QWORD *)(v1 + 48));
                        goto LABEL_37;
                      }
                      if (objc_msgSend(v29, "code") == (id)26)
                      {

                      }
                      else
                      {
                        v31 = objc_msgSend(v29, "code");

                        v32 = v31 == (id)28;
                        v21 = v71;
                        if (!v32)
                          goto LABEL_31;
                      }
                      v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "zoneID"));
                      v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v33, "zoneName"));
                      v35 = sub_10000BDF4(CFSTR("ckkszone"), v34);
                      v36 = objc_claimAutoreleasedReturnValue(v35);

                      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)buf = 138412546;
                        v86 = v27;
                        v87 = 2112;
                        v88 = v29;
                        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "Attempted to delete zone %@, but it's already missing. This is okay: %@", buf, 0x16u);
                      }

                      v1 = v70;
                      v21 = v71;
LABEL_37:

                    }
                    v24 = objc_msgSend(v22, "countByEnumeratingWithState:objects:count:", &v73, v89, 16);
                    if (!v24)
                    {
LABEL_39:

                      v4 = v65;
                      v3 = v66;
                      i = v69;
                      v15 = v67;
                      goto LABEL_42;
                    }
                  }
                }
              }
              else
              {

              }
              objc_msgSend(*(id *)(v70 + 32), "setError:", *(_QWORD *)(v70 + 48));
LABEL_42:
              v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "zoneID"));
              v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v37, "zoneName"));
              v39 = sub_10000BDF4(CFSTR("ckkszone"), v38);
              v40 = objc_claimAutoreleasedReturnValue(v39);

              v1 = v70;
              if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
              {
                v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "zoneID"));
                v42 = *(void **)(v70 + 48);
                *(_DWORD *)buf = 138412546;
                v86 = v41;
                v87 = 2112;
                v88 = v42;
                _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "deletion of record zone %@ completed with error: %@", buf, 0x16u);

              }
              v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v70 + 32), "error"));

              if (v43)
              {
                v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "zoneID"));
                v45 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v44, "zoneName"));
                v46 = sub_10000BDF4(CFSTR("ckkszone"), v45);
                v47 = objc_claimAutoreleasedReturnValue(v46);

                if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "we hit a fatal error!!!", buf, 2u);
                }
LABEL_55:
                v1 = v70;

                v7 = v15;
LABEL_56:

                continue;
              }

            }
          }
          v48 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "zoneID"));
          v49 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v48, "zoneName"));
          v50 = sub_10000BDF4(CFSTR("ckkszone"), v49);
          v51 = objc_claimAutoreleasedReturnValue(v50);

          if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
          {
            v52 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "zoneID"));
            *(_DWORD *)buf = 138412290;
            v86 = v52;
            _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "deletion of record zone %@ completed successfully", buf, 0xCu);

          }
          v53 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v1 + 32), "deps"));
          v54 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v53, "contextID"));
          v55 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "zoneID"));
          v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v55, "zoneName"));
          v47 = objc_claimAutoreleasedReturnValue(+[CKKSZoneStateEntry contextID:zoneName:](CKKSZoneStateEntry, "contextID:zoneName:", v54, v56));

          -[NSObject setCkzonecreated:](v47, "setCkzonecreated:", 0);
          -[NSObject setCkzonesubscribed:](v47, "setCkzonesubscribed:", 0);
          v72 = 0;
          -[NSObject saveToDatabase:](v47, "saveToDatabase:", &v72);
          v71 = v72;
          if (v71)
          {
            v57 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "zoneID"));
            v58 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v57, "zoneName"));
            v59 = sub_10000BDF4(CFSTR("ckks"), v58);
            v60 = objc_claimAutoreleasedReturnValue(v59);

            if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
            {
              v61 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "zoneID"));
              *(_DWORD *)buf = 138412546;
              v86 = v61;
              v87 = 2112;
              v88 = v71;
              _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_ERROR, "couldn't save zone deletion status for %@: %@", buf, 0x16u);

            }
          }
          else
          {
            v71 = 0;
          }
          goto LABEL_55;
        }
      }
      v68 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v81, v91, 16);
    }
    while (v68);
  }

  v62 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v1 + 32), "operationQueue"));
  v63 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v1 + 32), "setResultStateOperation"));
  objc_msgSend(v62, "addOperation:", v63);

  return 1;
}

void sub_1000721BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,id location,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  id *v27;

  objc_destroyWeak(v27);
  objc_destroyWeak(&location);
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

void sub_1000722A4(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id WeakRetained;
  const void *v8;
  NSObject *v9;
  _BOOL4 v10;
  void *v11;
  void *v12;
  unsigned int v13;
  OctagonPendingFlag *v14;
  void *v15;
  void *v16;
  uint64_t v17;
  int v18;
  void *v19;
  void *v20;
  unsigned int v21;
  const void *v22;
  NSObject *v23;
  _BOOL4 v24;
  void *v25;
  void *v26;
  unsigned int v27;
  id v28;
  const void *v29;
  NSObject *v30;
  _BOOL4 v31;
  uint64_t v32;
  int v33;
  const void *v34;
  NSObject *v35;
  id v36;
  uint8_t buf[4];
  id v38;

  v5 = a2;
  v6 = a3;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v8 = sub_10000EF14("octagon-cdp-status");
  v9 = objc_claimAutoreleasedReturnValue(v8);
  v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    if (v10)
    {
      *(_DWORD *)buf = 138412290;
      v38 = v6;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Unable to talk with TPH; leaving CDP status as 'unknown': %@",
        buf,
        0xCu);
    }

    objc_msgSend(WeakRetained, "setError:", v6);
    v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "reachabilityTracker"));
    v13 = objc_msgSend(v12, "isNetworkError:", v6);

    if (v13)
    {
      v14 = -[OctagonPendingFlag initWithFlag:conditions:delayInSeconds:]([OctagonPendingFlag alloc], "initWithFlag:conditions:delayInSeconds:", CFSTR("pending_network_availablility"), 2, 0.2);
      v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
      v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "flagHandler"));
      objc_msgSend(v16, "handlePendingFlag:", v14);

    }
    goto LABEL_23;
  }
  if (v10)
  {
    *(_DWORD *)buf = 67109120;
    LODWORD(v38) = objc_msgSend(v5, "numberOfPeersInOctagon");
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Octagon reports %d peers", buf, 8u);
  }

  if (objc_msgSend(v5, "numberOfPeersInOctagon"))
  {
    v17 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v18 = 2;
LABEL_22:
    *(_DWORD *)(v17 + 24) = v18;
    goto LABEL_23;
  }
  v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
  v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "sosAdapter"));
  v21 = objc_msgSend(v20, "sosEnabled");

  v22 = sub_10000EF14("octagon-cdp-status");
  v23 = objc_claimAutoreleasedReturnValue(v22);
  v24 = os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT);
  if (!v21)
  {
    if (v24)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "No SOS. CDP bit is off.", buf, 2u);
    }

    v17 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v18 = 1;
    goto LABEL_22;
  }
  if (v24)
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Requesting SOS status...", buf, 2u);
  }

  v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
  v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v25, "sosAdapter"));
  v36 = 0;
  v27 = objc_msgSend(v26, "circleStatus:", &v36);
  v28 = v36;

  if (v28 || v27 == -1)
  {
    v34 = sub_10000EF14("octagon-cdp-status");
    v35 = objc_claimAutoreleasedReturnValue(v34);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v38 = v28;
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "Error fetching circle status. Leaving CDP status as 'unknown': %@", buf, 0xCu);
    }

  }
  else
  {
    v29 = sub_10000EF14("octagon-cdp-status");
    v30 = objc_claimAutoreleasedReturnValue(v29);
    v31 = os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT);
    if (v27 == 3)
    {
      if (v31)
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "SOS reports circle absent. Setting CDP to 'disabled'", buf, 2u);
      }

      v32 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v33 = 1;
    }
    else
    {
      if (v31)
      {
        *(_DWORD *)buf = 67109120;
        LODWORD(v38) = v27;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "SOS reports some existing circle (%d). Setting CDP to 'enabled'", buf, 8u);
      }

      v32 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v33 = 2;
    }
    *(_DWORD *)(v32 + 24) = v33;
  }

LABEL_23:
}

id sub_1000726AC(uint64_t a1, void *a2)
{
  id v3;
  unsigned int v4;
  const void *v5;
  NSObject *v6;
  _BOOL4 v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  void *v11;
  id v12;
  uint8_t buf[4];
  void *v15;

  v3 = a2;
  v4 = objc_msgSend(v3, "cdpState");
  v5 = sub_10000EF14("octagon-cdp-status");
  v6 = objc_claimAutoreleasedReturnValue(v5);
  v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v4 == 2)
  {
    if (v7)
    {
      v8 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      if (v8 >= 3)
        v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("(unknown: %i)"), *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24)));
      else
        v9 = *(&off_1002DC3A0 + v8);
      *(_DWORD *)buf = 138412290;
      v15 = v9;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "CDP bit is enabled on-disk, not modifying (would have been %@)", buf, 0xCu);

    }
    v12 = 0;
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 2;
  }
  else
  {
    if (v7)
    {
      v10 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      if (v10 >= 3)
        v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("(unknown: %i)"), *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24)));
      else
        v11 = *(&off_1002DC3A0 + v10);
      *(_DWORD *)buf = 138412290;
      v15 = v11;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Writing CDP bit as %@", buf, 0xCu);

    }
    objc_msgSend(v3, "setCdpState:", *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
    v12 = v3;
  }

  return v12;
}

void sub_100075F94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100075FBC(uint64_t a1, void *a2)
{
  id v3;

  v3 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(a2, "objectForKeyedSubscript:", CFSTR("count(*)")));
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = objc_msgSend(v3, "asNSInteger");

}

void sub_10007600C(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  id v8;

  v3 = a2;
  v8 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("count(rowid)")));
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "asNSNumberInteger"));
  v5 = *(void **)(a1 + 32);
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("state")));

  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "asString"));
  objc_msgSend(v5, "setObject:forKeyedSubscript:", v4, v7);

}

void sub_100077080(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100077608(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  id v8;

  v3 = a2;
  v8 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("count(rowid)")));
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "asNSNumberInteger"));
  v5 = *(void **)(a1 + 32);
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("parentKeyUUID")));

  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "asString"));
  objc_msgSend(v5, "setObject:forKeyedSubscript:", v4, v7);

}

void sub_1000776AC(uint64_t a1, void *a2)
{
  id v3;

  v3 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(a2, "objectForKeyedSubscript:", CFSTR("count(*)")));
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = objc_msgSend(v3, "asNSInteger");

}

void sub_1000776FC(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  id v8;

  v3 = a2;
  v8 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("count(rowid)")));
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "asNSNumberInteger"));
  v5 = *(void **)(a1 + 32);
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("state")));

  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "asString"));
  objc_msgSend(v5, "setObject:forKeyedSubscript:", v4, v7);

}

void sub_1000781C4(uint64_t a1, const __CFArray *a2, void *a3)
{
  id v4;
  uint64_t v5;
  CFIndex Count;
  id v7;
  id v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  const __CFDictionary *v12;
  const __CFArray *obj;
  CFTypeRef result;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  _QWORD v20[4];
  _QWORD v21[4];
  _BYTE v22[128];

  v4 = a3;
  v5 = objc_opt_class(NSArray);
  if ((objc_opt_isKindOfClass(a2, v5) & 1) != 0)
  {
    Count = CFArrayGetCount(a2);
    NSLog(CFSTR("scanning %d %@"), Count, v4);
    v18 = 0u;
    v19 = 0u;
    v16 = 0u;
    v17 = 0u;
    obj = a2;
    v7 = -[__CFArray countByEnumeratingWithState:objects:count:](obj, "countByEnumeratingWithState:objects:count:", &v16, v22, 16);
    if (v7)
    {
      v8 = v7;
      v9 = *(_QWORD *)v17;
      do
      {
        v10 = 0;
        do
        {
          if (*(_QWORD *)v17 != v9)
            objc_enumerationMutation(obj);
          v11 = *(_QWORD *)(*((_QWORD *)&v16 + 1) + 8 * (_QWORD)v10);
          v20[0] = kSecClass;
          v20[1] = kSecValuePersistentRef;
          v21[0] = v4;
          v21[1] = v11;
          v20[2] = kSecReturnAttributes;
          v20[3] = kSecUseDataProtectionKeychain;
          v21[2] = &__kCFBooleanTrue;
          v21[3] = &__kCFBooleanTrue;
          v12 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v21, v20, 4));
          result = 0;
          if (SecItemCopyMatching(v12, &result) && *(_DWORD *)(a1 + 40) != -25308)
            objc_msgSend(*(id *)(a1 + 32), "addObject:", v12);

          v10 = (char *)v10 + 1;
        }
        while (v8 != v10);
        v8 = -[__CFArray countByEnumeratingWithState:objects:count:](obj, "countByEnumeratingWithState:objects:count:", &v16, v22, 16);
      }
      while (v8);
    }

  }
}

void sub_1000783E0(id a1)
{
  id v1;
  void *v2;

  v1 = -[SFKeychainControlManager _init]([SFKeychainControlManager alloc], "_init");
  v2 = (void *)qword_100340F40;
  qword_100340F40 = (uint64_t)v1;

}

uint64_t sub_10007840C()
{
  void *v0;
  uint64_t v1;

  v0 = (void *)objc_claimAutoreleasedReturnValue(+[SFKeychainControlManager sharedManager](SFKeychainControlManager, "sharedManager"));
  v1 = objc_claimAutoreleasedReturnValue(objc_msgSend(v0, "xpcControlEndpoint"));

  return v1;
}

void sub_10007AF3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  uint64_t v30;

  _Block_object_dispose(&a26, 8);
  _Block_object_dispose(&a30, 8);
  _Block_object_dispose((const void *)(v30 - 168), 8);
  _Block_object_dispose((const void *)(v30 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_10007B31C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  uint64_t v29;

  _Block_object_dispose(&a21, 8);
  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a29, 8);
  _Block_object_dispose((const void *)(v29 - 160), 8);
  _Unwind_Resume(a1);
}

void sub_10007C3A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  uint64_t v47;

  _Block_object_dispose((const void *)(v47 - 176), 8);
  _Block_object_dispose(&a27, 8);
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a41, 8);
  _Block_object_dispose(&a47, 8);
  _Unwind_Resume(a1);
}

void sub_10007CB38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_10007CD78(uint64_t a1, uint64_t a2)
{
  return sub_10001B508(a2, *(_QWORD *)(a1 + 40), 0, (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
}

uint64_t sub_10007CD94(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_10007CDA4(uint64_t a1)
{

}

uint64_t sub_10007CDAC(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __CFString **v5;
  id v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  const void *v12;
  uint64_t v13;
  _QWORD v15[4];
  id v16;
  id v17;
  uint64_t v18;
  id v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  char v24;

  v4 = *(_QWORD *)(a1 + 104);
  v5 = (__CFString **)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24);
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  v15[2] = sub_10007CED0;
  v15[3] = &unk_1002DC458;
  v16 = *(id *)(a1 + 32);
  v6 = *(id *)(a1 + 40);
  v7 = *(_QWORD *)(a1 + 104);
  v24 = *(_BYTE *)(a1 + 112);
  v8 = *(_QWORD *)(a1 + 72);
  v23 = v7;
  v20 = v8;
  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(void **)(a1 + 56);
  v17 = v6;
  v18 = v9;
  v19 = v10;
  v21 = *(_OWORD *)(a1 + 80);
  v22 = *(_QWORD *)(a1 + 96);
  if ((sub_10001DADC(v4, a2, v5, (uint64_t)v15) & 1) == 0)
  {
    if (!sub_1001165A4(*(__CFError **)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24)))
    {
      v13 = 0;
      goto LABEL_7;
    }
    v11 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8);
    v12 = *(const void **)(v11 + 24);
    if (v12)
    {
      *(_QWORD *)(v11 + 24) = 0;
      CFRelease(v12);
    }
  }
  v13 = 1;
LABEL_7:

  return v13;
}

void sub_10007CED0(uint64_t a1, CFDictionaryRef *a2, uint64_t *a3)
{
  void *v6;
  const void *v7;
  const __CFString *Value;
  const __CFString *v9;
  void *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  unint64_t v14;
  void *v15;
  void *v16;
  id v17;
  NSObject *v18;
  CFComparisonResult v19;
  _BOOL4 v20;
  void *v21;
  void *v22;
  id v23;
  NSObject *v24;
  _BOOL4 v25;
  const __CFString *v26;
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;
  uint64_t v43;
  void *v44;
  void *v45;
  void *v46;
  id v47;
  NSObject *v48;
  void *v49;
  const void *v50;
  void *v51;
  void *v52;
  id v53;
  NSObject *v54;
  const void *v55;
  const __CFString *v56;
  uint64_t v57;
  const void *v58;
  uint64_t v59;
  uint64_t v60;
  void *v61;
  void *v62;
  void *v63;
  id v64;
  NSObject *v65;
  void *v66;
  void *v67;
  void *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  const void *v72;
  const __CFData *v73;
  const __CFData *v74;
  void *v75;
  void *v76;
  id v77;
  NSObject *v78;
  CFTypeRef v79;
  void *v80;
  void *v81;
  CFTypeRef cf;
  id v83;
  id v84;
  id v85;
  id v86;
  id v87;
  id obj;
  id v89;
  uint8_t buf[4];
  CFTypeRef v91;
  __int16 v92;
  const __CFString *v93;
  __int16 v94;
  const __CFString *v95;
  __int16 v96;
  CFDictionaryRef *v97;
  uint64_t v98;
  _UNKNOWN **v99;

  v98 = SecCoreAnalyticsValue;
  v99 = &off_10030A328;
  v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v99, &v98, 1));
  +[SecCoreAnalytics sendEvent:event:](SecCoreAnalytics, "sendEvent:event:", CFSTR("com.apple.security.ckks.pkconflict"), v6);

  v7 = (const void *)kSecAttrUUID;
  if (CFDictionaryContainsKey(a2[6], kSecAttrUUID))
  {
    if (*(_BYTE *)(a1 + 104))
    {
      Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(*(_QWORD *)(a1 + 96) + 48), v7);
      v9 = (const __CFString *)CFDictionaryGetValue(a2[6], v7);
      v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "deps"));
      v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "contextID"));
      v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
      v89 = 0;
      v13 = objc_claimAutoreleasedReturnValue(+[CKKSMirrorEntry tryFromDatabase:contextID:zoneID:error:](CKKSMirrorEntry, "tryFromDatabase:contextID:zoneID:error:", v9, v11, v12, &v89));
      v14 = (unint64_t)v89;

      if (v14)
      {
        v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
        v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "zoneName"));
        v17 = sub_10000BDF4(CFSTR("ckksincoming"), v16);
        v18 = objc_claimAutoreleasedReturnValue(v17);

        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412546;
          v91 = a2;
          v92 = 2112;
          v93 = (const __CFString *)v14;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Unable to fetch ckme for old item %@: %@", buf, 0x16u);
        }

      }
      v19 = CFStringCompare(Value, v9, 0);
      v80 = (void *)v13;
      v81 = (void *)v14;
      v20 = (v13 | v14) != 0;
      v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
      v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "zoneName"));
      v23 = sub_10000BDF4(CFSTR("ckksincoming"), v22);
      v24 = objc_claimAutoreleasedReturnValue(v23);

      v25 = os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT);
      if (v19 == kCFCompareGreaterThan && v20)
      {
        if (v25)
        {
          v26 = *(const __CFString **)(a1 + 96);
          *(_DWORD *)buf = 138413059;
          v91 = Value;
          v92 = 2113;
          v93 = v26;
          v94 = 2112;
          v95 = v9;
          v96 = 2113;
          v97 = a2;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Primary key conflict; deleting incoming CK item (%@)%{private}@in favor of old item (%@)%{private}@",
            buf,
            0x2Au);
        }

        v27 = *(_QWORD *)(a1 + 96);
        v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "deps"));
        v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "contextID"));
        v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
        v31 = *(_QWORD *)(a1 + 56);
        v32 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8);
        obj = *(id *)(v32 + 40);
        v33 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSOutgoingQueueEntry withItem:action:contextID:zoneID:keyCache:error:](CKKSOutgoingQueueEntry, "withItem:action:contextID:zoneID:keyCache:error:", v27, CFSTR("delete"), v29, v30, v31, &obj));
        objc_storeStrong((id *)(v32 + 40), obj);

        v34 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8);
        v87 = *(id *)(v34 + 40);
        objc_msgSend(v33, "saveToDatabase:", &v87);
        objc_storeStrong((id *)(v34 + 40), v87);
        objc_msgSend(*(id *)(a1 + 48), "setNewOutgoingEntries:", 1);
        v35 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8);
        v36 = *(void **)(v35 + 40);
        *(_QWORD *)(v35 + 40) = 0;

        v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "deps"));
        v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v37, "contextID"));
        v39 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
        v40 = *(_QWORD *)(a1 + 56);
        v41 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8);
        v86 = *(id *)(v41 + 40);
        v42 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSOutgoingQueueEntry withItem:action:contextID:zoneID:keyCache:error:](CKKSOutgoingQueueEntry, "withItem:action:contextID:zoneID:keyCache:error:", a2, CFSTR("add"), v38, v39, v40, &v86));
        objc_storeStrong((id *)(v41 + 40), v86);

        v43 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8);
        v85 = *(id *)(v43 + 40);
        objc_msgSend(v42, "saveToDatabase:", &v85);
        objc_storeStrong((id *)(v43 + 40), v85);
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 8) + 24) = 1;

        v44 = v80;
      }
      else
      {
        v44 = v80;
        if (v25)
        {
          v56 = &stru_1002EE888;
          if (!v80)
            v56 = CFSTR("non-onboarded");
          *(_DWORD *)buf = 138412290;
          v91 = v56;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Primary key conflict; replacing %@ with CK item",
            buf,
            0xCu);
        }

        if (a3)
        {
          v57 = *(_QWORD *)(a1 + 96);
          if (v57)
            CFRetain(*(CFTypeRef *)(a1 + 96));
          *a3 = v57;
          v58 = CFDictionaryGetValue(*(CFDictionaryRef *)(*(_QWORD *)(a1 + 96) + 48), kSecAttrModificationDate);
          v59 = objc_claimAutoreleasedReturnValue(v58);
          v60 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8);
          v61 = *(void **)(v60 + 40);
          *(_QWORD *)(v60 + 40) = v59;

        }
        if (v19 == kCFCompareEqualTo)
        {
LABEL_34:
          v72 = sub_10000C1D0(a2, kSecAttrPersistentReference);
          v73 = (const __CFData *)objc_claimAutoreleasedReturnValue(v72);
          v74 = v73;
          if (a3)
          {
            if (*a3)
            {
LABEL_36:
              if (v74)
              {
                if (-[__CFData length](v74, "length") == (id)16)
                {
                  cf = 0;
                  sub_10001D918(*a3, v74, (__CFString **)&cf);
                  if (cf)
                  {
                    v75 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
                    v76 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v75, "zoneName"));
                    v77 = sub_10000BDF4(CFSTR("ckksincoming"), v76);
                    v78 = objc_claimAutoreleasedReturnValue(v77);

                    if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 138412290;
                      v91 = cf;
                      _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, "error setting uuid persistent ref: %@", buf, 0xCu);
                    }

                    v79 = cf;
                    if (cf)
                    {
                      cf = 0;
                      CFRelease(v79);
                    }
                  }
                }
              }
              goto LABEL_48;
            }
            if (v73 && -[__CFData length](v73, "length") == (id)16)
            {
              if (*a3)
                goto LABEL_36;
            }
            else
            {
              objc_msgSend(*(id *)(a1 + 48), "_onqueueGenerateNewUUIDPersistentRefOnSecItem:viewState:", a2, *(_QWORD *)(a1 + 32), v80, v81);
              CFRetain(a2);
              *a3 = (uint64_t)a2;
            }
          }
LABEL_48:

          return;
        }
        v62 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
        v63 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v62, "zoneName"));
        v64 = sub_10000BDF4(CFSTR("ckksincoming"), v63);
        v65 = objc_claimAutoreleasedReturnValue(v64);

        if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412803;
          v91 = v9;
          v92 = 2112;
          v93 = Value;
          v94 = 2113;
          v95 = (const __CFString *)a2;
          _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "UUID of olditem (%@) is higher than UUID of incoming item (%@), issuing deletion of olditem: %{private}@", buf, 0x20u);
        }

        v66 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "deps"));
        v67 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v66, "contextID"));
        v68 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
        v69 = *(_QWORD *)(a1 + 56);
        v70 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8);
        v84 = *(id *)(v70 + 40);
        v33 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSOutgoingQueueEntry withItem:action:contextID:zoneID:keyCache:error:](CKKSOutgoingQueueEntry, "withItem:action:contextID:zoneID:keyCache:error:", a2, CFSTR("delete"), v67, v68, v69, &v84));
        objc_storeStrong((id *)(v70 + 40), v84);

        v71 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8);
        v83 = *(id *)(v71 + 40);
        objc_msgSend(v33, "saveToDatabase:", &v83);
        objc_storeStrong((id *)(v71 + 40), v83);
        objc_msgSend(*(id *)(a1 + 48), "setNewOutgoingEntries:", 1);
      }

      goto LABEL_34;
    }
    v51 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v52 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v51, "zoneName"));
    v53 = sub_10000BDF4(CFSTR("ckksincoming"), v52);
    v54 = objc_claimAutoreleasedReturnValue(v53);

    if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
    {
      v55 = *(const void **)(a1 + 96);
      *(_DWORD *)buf = 138477827;
      v91 = v55;
      _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "Primary key conflict; dropping CK item (arriving from wrong view) %{private}@",
        buf,
        0xCu);
    }

    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24) = 1;
  }
  else
  {
    v45 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v45, "zoneName"));
    v47 = sub_10000BDF4(CFSTR("ckksincoming"), v46);
    v48 = objc_claimAutoreleasedReturnValue(v47);

    if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
    {
      v49 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "uuid"));
      *(_DWORD *)buf = 138412290;
      v91 = v49;
      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "Replacing item (it doesn't have a UUID) for %@", buf, 0xCu);

    }
    if (a3)
    {
      v50 = *(const void **)(a1 + 96);
      if (v50)
        CFRetain(v50);
      *a3 = (uint64_t)v50;
    }
  }
}

uint64_t sub_10007D7F4(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  id v7;
  void *v8;
  id v9;
  NSObject *v10;
  uint64_t v11;
  id v12;
  void *v13;
  id v14;
  NSObject *v15;
  _BOOL4 v16;
  id v17;
  id v18;
  id v19;
  uint64_t v20;
  void *i;
  void *v22;
  void *v23;
  void *v24;
  uint64_t v25;
  id v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  void *v31;
  id v32;
  NSObject *v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  id v38;
  uint8_t v39[128];
  uint8_t buf[4];
  id v41;

  v2 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40);
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "deps"));
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "contextID"));
  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "zoneID"));
  v38 = 0;
  v6 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSIncomingQueueEntry fetch:startingAtUUID:state:action:contextID:zoneID:error:](CKKSIncomingQueueEntry, "fetch:startingAtUUID:state:action:contextID:zoneID:error:", 50, v2, CFSTR("mismatched_view"), 0, v4, v5, &v38));
  v7 = v38;

  if (!v7)
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24) = objc_msgSend(v6, "count");
    v12 = objc_msgSend(v6, "count");
    v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "zoneName"));
    v14 = sub_10000BDF4(CFSTR("ckksincoming"), v13);
    v15 = objc_claimAutoreleasedReturnValue(v14);

    v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
    if (v12)
    {
      if (v16)
      {
        v17 = objc_msgSend(v6, "count");
        *(_DWORD *)buf = 134217984;
        v41 = v17;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Inspecting %lu mismatched items", buf, 0xCu);
      }

      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24) += objc_msgSend(v6, "count");
      if ((objc_msgSend(*(id *)(a1 + 32), "intransaction:processQueueEntries:", *(_QWORD *)(a1 + 40), v6) & 1) == 0)
      {
        v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "zoneName"));
        v32 = sub_10000BDF4(CFSTR("ckksincoming"), v31);
        v33 = objc_claimAutoreleasedReturnValue(v32);

        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "processQueueEntries didn't complete successfully", buf, 2u);
        }

        goto LABEL_5;
      }
      v36 = 0u;
      v37 = 0u;
      v34 = 0u;
      v35 = 0u;
      v15 = v6;
      v18 = -[NSObject countByEnumeratingWithState:objects:count:](v15, "countByEnumeratingWithState:objects:count:", &v34, v39, 16);
      if (v18)
      {
        v19 = v18;
        v20 = *(_QWORD *)v35;
        do
        {
          for (i = 0; i != v19; i = (char *)i + 1)
          {
            if (*(_QWORD *)v35 != v20)
              objc_enumerationMutation(v15);
            v22 = *(void **)(*((_QWORD *)&v34 + 1) + 8 * (_QWORD)i);
            v23 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40);
            v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "uuid"));
            if (objc_msgSend(v23, "compare:", v24) == (id)1)
            {
              v25 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
              v26 = *(id *)(v25 + 40);
              v27 = *(void **)(v25 + 40);
              *(_QWORD *)(v25 + 40) = v26;
            }
            else
            {
              v28 = objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "uuid"));
              v29 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
              v27 = *(void **)(v29 + 40);
              *(_QWORD *)(v29 + 40) = v28;
            }

          }
          v19 = -[NSObject countByEnumeratingWithState:objects:count:](v15, "countByEnumeratingWithState:objects:count:", &v34, v39, 16);
        }
        while (v19);
      }
    }
    else if (v16)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "No mismatched view items", buf, 2u);
    }

    v11 = 1;
    goto LABEL_24;
  }
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "zoneName"));
  v9 = sub_10000BDF4(CFSTR("ckksincoming"), v8);
  v10 = objc_claimAutoreleasedReturnValue(v9);

  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Cannot fetch mismatched view items", buf, 2u);
  }

  objc_msgSend(*(id *)(a1 + 32), "setError:", v7);
LABEL_5:
  v11 = 0;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = 1;
LABEL_24:

  return v11;
}

uint64_t sub_10007DBF0(uint64_t a1)
{
  void *v2;
  id v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  id v12;
  void *v13;
  id v14;
  NSObject *v15;
  void *v16;
  void *v17;
  NSObject *v18;
  id v19;
  id v20;
  uint64_t v21;
  void *i;
  void *v23;
  void *v24;
  void *v25;
  uint64_t v26;
  id v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  id v32;
  void *v33;
  id v34;
  NSObject *v35;
  void *v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  id v42;
  uint8_t v43[128];
  uint8_t buf[4];
  id v45;

  if (!objc_msgSend(*(id *)(a1 + 32), "isCancelled"))
  {
    v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 40);
    v7 = *(_QWORD *)(a1 + 48);
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "deps"));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "contextID"));
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "zoneID"));
    v42 = 0;
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSIncomingQueueEntry fetch:startingAtUUID:state:action:contextID:zoneID:error:](CKKSIncomingQueueEntry, "fetch:startingAtUUID:state:action:contextID:zoneID:error:", 50, v6, CFSTR("new"), v7, v9, v10, &v42));
    v12 = v42;

    if (v12)
    {
      v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "zoneName"));
      v14 = sub_10000BDF4(CFSTR("ckksincoming"), v13);
      v15 = objc_claimAutoreleasedReturnValue(v14);

      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        v45 = v12;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Error fetching incoming queue records: %@", buf, 0xCu);
      }

      objc_msgSend(*(id *)(a1 + 32), "setError:", v12);
      v5 = 0;
    }
    else
    {
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24) = objc_msgSend(v11, "count");
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 24) += objc_msgSend(v11, "count");
      if (objc_msgSend(v11, "count"))
      {
        v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "zoneID"));
        v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "zoneName"));
        +[CKKSPowerCollection CKKSPowerEvent:zone:count:](CKKSPowerCollection, "CKKSPowerEvent:zone:count:", CFSTR("processIncomingQueue"), v17, objc_msgSend(v11, "count"));

        if ((objc_msgSend(*(id *)(a1 + 32), "intransaction:processQueueEntries:", *(_QWORD *)(a1 + 40), v11) & 1) == 0)
        {
          v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "zoneName"));
          v34 = sub_10000BDF4(CFSTR("ckksincoming"), v33);
          v35 = objc_claimAutoreleasedReturnValue(v34);

          if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "processQueueEntries didn't complete successfully", buf, 2u);
          }

          v5 = 0;
          *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = 1;
          goto LABEL_28;
        }
        v40 = 0u;
        v41 = 0u;
        v38 = 0u;
        v39 = 0u;
        v18 = v11;
        v19 = -[NSObject countByEnumeratingWithState:objects:count:](v18, "countByEnumeratingWithState:objects:count:", &v38, v43, 16);
        if (v19)
        {
          v20 = v19;
          v21 = *(_QWORD *)v39;
          do
          {
            for (i = 0; i != v20; i = (char *)i + 1)
            {
              if (*(_QWORD *)v39 != v21)
                objc_enumerationMutation(v18);
              v23 = *(void **)(*((_QWORD *)&v38 + 1) + 8 * (_QWORD)i);
              v24 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 40);
              v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v23, "uuid"));
              if (objc_msgSend(v24, "compare:", v25) == (id)1)
              {
                v26 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8);
                v27 = *(id *)(v26 + 40);
                v28 = *(void **)(v26 + 40);
                *(_QWORD *)(v26 + 40) = v27;
              }
              else
              {
                v29 = objc_claimAutoreleasedReturnValue(objc_msgSend(v23, "uuid"));
                v30 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8);
                v28 = *(void **)(v30 + 40);
                *(_QWORD *)(v30 + 40) = v29;
              }

            }
            v20 = -[NSObject countByEnumeratingWithState:objects:count:](v18, "countByEnumeratingWithState:objects:count:", &v38, v43, 16);
          }
          while (v20);
        }
      }
      else
      {
        v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "zoneName"));
        v32 = sub_10000BDF4(CFSTR("ckksincoming"), v31);
        v18 = objc_claimAutoreleasedReturnValue(v32);

        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          v37 = *(void **)(a1 + 48);
          *(_DWORD *)buf = 138412290;
          v45 = v37;
          _os_log_debug_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "Nothing in incoming queue to process (filter: %@)", buf, 0xCu);
        }
      }

      v5 = 1;
    }
LABEL_28:

    return v5;
  }
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "zoneName"));
  v3 = sub_10000BDF4(CFSTR("ckksincoming"), v2);
  v4 = objc_claimAutoreleasedReturnValue(v3);

  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "CKKSIncomingQueueOperation cancelled, quitting", buf, 2u);
  }

  v5 = 0;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = 1;
  return v5;
}

uint64_t sub_10007E0A8(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  id v5;
  BOOL v6;
  void *v7;
  id v8;
  NSObject *v9;
  const char *v10;
  NSObject *v11;
  os_log_type_t v12;
  void *v14;
  id v15;
  id v16;
  uint64_t v17;
  id v19;
  uint8_t buf[4];
  id v21;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "contextID"));
  v19 = 0;
  v4 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSCurrentItemPointer remoteItemPointers:contextID:error:](CKKSCurrentItemPointer, "remoteItemPointers:contextID:error:", v2, v3, &v19));
  v5 = v19;

  if (v5)
    v6 = 1;
  else
    v6 = v4 == 0;
  if (v6)
  {
    v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneName"));
    v8 = sub_10000BDF4(CFSTR("ckksincoming"), v7);
    v9 = objc_claimAutoreleasedReturnValue(v8);

    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v5;
      v10 = "Could not load remote item pointers: %@";
      v11 = v9;
      v12 = OS_LOG_TYPE_ERROR;
LABEL_12:
      _os_log_impl((void *)&_mh_execute_header, v11, v12, v10, buf, 0xCu);
    }
LABEL_13:

    goto LABEL_14;
  }
  if (!objc_msgSend(*(id *)(a1 + 40), "processNewCurrentItemPointers:viewState:", v4, *(_QWORD *)(a1 + 32)))
  {
    v17 = 0;
    goto LABEL_16;
  }
  if (objc_msgSend(v4, "count"))
  {
    v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneName"));
    v15 = sub_10000BDF4(CFSTR("ckksincoming"), v14);
    v9 = objc_claimAutoreleasedReturnValue(v15);

    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      v16 = objc_msgSend(v4, "count");
      *(_DWORD *)buf = 134217984;
      v21 = v16;
      v10 = "Processed %lu items in CIP queue";
      v11 = v9;
      v12 = OS_LOG_TYPE_DEFAULT;
      goto LABEL_12;
    }
    goto LABEL_13;
  }
LABEL_14:
  v17 = 1;
LABEL_16:

  return v17;
}

void sub_10007E8D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t sub_10007FFBC(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  void *v3;
  id v4;
  NSObject *v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  id v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  id v18;
  NSObject *v19;
  const char *v20;
  id v21;
  id v22;
  id v23;
  uint64_t v24;
  void *i;
  void *v26;
  void *v27;
  void *v28;
  id v29;
  NSObject *v30;
  void *v31;
  void *v32;
  void *v33;
  id v34;
  NSObject *v35;
  unsigned int v36;
  unsigned int v37;
  AAFAnalyticsEventSecurity *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  void *v43;
  void *v44;
  id *v45;
  id v46;
  void *v47;
  uint64_t v48;
  void *v49;
  void *v50;
  unsigned int v51;
  void *v52;
  void *v53;
  void *v54;
  void *v55;
  void *v56;
  NSObject *v57;
  id *v58;
  id v59;
  NSObject *v60;
  id v61;
  id v62;
  void *v63;
  void *v64;
  id v65;
  NSObject *v66;
  void *v67;
  void *v68;
  id v69;
  void *v70;
  unsigned int v71;
  CKKSCurrentKeyPointer *v72;
  void *v73;
  void *v74;
  void *v75;
  id v76;
  void *v77;
  void *v78;
  id v79;
  NSObject *v80;
  void *v81;
  void *v82;
  NSObject *v83;
  const char *v84;
  void *v85;
  unsigned int v86;
  CKKSDeviceStateEntry *v87;
  void *v88;
  void *v89;
  void *v90;
  void *v91;
  void *v92;
  id v93;
  CKKSMirrorEntry *v94;
  void *v95;
  void *v96;
  CKKSMirrorEntry *v97;
  void *v98;
  void *v99;
  id v100;
  NSObject *v101;
  void *v102;
  void *v103;
  id v104;
  void *v105;
  void *v106;
  void *v107;
  id v108;
  id v109;
  void *j;
  void *v111;
  void *v112;
  void *v113;
  void *v114;
  void *v115;
  void *v116;
  id v117;
  id *v118;
  uint64_t v119;
  id v120;
  void *v121;
  void *v122;
  id v123;
  NSObject *v124;
  void *v125;
  id v126;
  void *v127;
  void *v128;
  void *v129;
  void *v130;
  void *v131;
  id v132;
  void *v133;
  void *v134;
  id v135;
  NSObject *v136;
  void *v137;
  id v138;
  void *v139;
  void *v140;
  void *v141;
  void *v142;
  void *v143;
  void *v144;
  id v145;
  NSObject *v146;
  void *v147;
  void *v148;
  void *v149;
  void *v150;
  void *v151;
  uint64_t v152;
  unsigned int v153;
  void *v154;
  void *v155;
  id v156;
  NSObject *v157;
  _BOOL4 v158;
  void *v159;
  id v160;
  void *v161;
  void *v162;
  void *v163;
  void *v164;
  id v165;
  void *v166;
  void *v167;
  void *v168;
  uint64_t v170;
  void *v171;
  void *v172;
  void *v173;
  void *v174;
  id v175;
  NSObject *v176;
  void *v177;
  id v178;
  void *v179;
  void *v180;
  id v181;
  void *v182;
  void *v183;
  void *v184;
  void *v185;
  void *v186;
  id v187;
  void *v188;
  uint64_t v189;
  id v190;
  void *v191;
  void *v192;
  id v193;
  NSObject *v194;
  void *v195;
  void *v196;
  id v197;
  NSObject *v198;
  void *v199;
  unsigned __int8 v200;
  AAFAnalyticsEventSecurity *v201;
  id obj;
  id obja;
  id objb;
  uint64_t v205;
  id v206;
  uint64_t v207;
  char v208;
  void *v209;
  id v210;
  CKKSPowerCollection *v211;
  uint64_t v212;
  void *v213;
  void *v214;
  id v215;
  id v217;
  id v218;
  id v219;
  id v220;
  __int128 v221;
  __int128 v222;
  __int128 v223;
  __int128 v224;
  id v225;
  id v226;
  id v227;
  id v228;
  id v229;
  __int128 v230;
  __int128 v231;
  __int128 v232;
  __int128 v233;
  __int128 v234;
  __int128 v235;
  __int128 v236;
  __int128 v237;
  id v238;
  id v239;
  __int128 v240;
  __int128 v241;
  __int128 v242;
  __int128 v243;
  _BYTE v244[128];
  _BYTE v245[128];
  const __CFString *v246;
  void *v247;
  uint8_t v248[128];
  uint8_t buf[4];
  _BYTE v250[10];
  id v251;
  _BYTE v252[128];

  v1 = a1;
  if (!*(_QWORD *)(a1 + 32))
  {
    v236 = 0u;
    v237 = 0u;
    v234 = 0u;
    v235 = 0u;
    v21 = *(id *)(a1 + 80);
    v22 = objc_msgSend(v21, "countByEnumeratingWithState:objects:count:", &v234, v248, 16);
    if (v22)
    {
      v23 = v22;
      v24 = *(_QWORD *)v235;
      do
      {
        for (i = 0; i != v23; i = (char *)i + 1)
        {
          if (*(_QWORD *)v235 != v24)
            objc_enumerationMutation(v21);
          v26 = *(void **)(*((_QWORD *)&v234 + 1) + 8 * (_QWORD)i);
          v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "zoneID"));
          v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v27, "zoneName"));
          v29 = sub_10000BDF4(CFSTR("ckksoutgoing"), v28);
          v30 = objc_claimAutoreleasedReturnValue(v29);

          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
          {
            v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "recordName"));
            *(_DWORD *)buf = 138412290;
            *(_QWORD *)v250 = v31;
            _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "Record deletion successful for %@", buf, 0xCu);

          }
        }
        v23 = objc_msgSend(v21, "countByEnumeratingWithState:objects:count:", &v234, v248, 16);
      }
      while (v23);
    }

    v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "zoneID"));
    v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v32, "zoneName"));
    v34 = sub_10000BDF4(CFSTR("ckksoutgoing"), v33);
    v35 = objc_claimAutoreleasedReturnValue(v34);

    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      v36 = objc_msgSend(*(id *)(a1 + 88), "count");
      v37 = objc_msgSend(*(id *)(a1 + 80), "count");
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)v250 = v36;
      *(_WORD *)&v250[4] = 1024;
      *(_DWORD *)&v250[6] = v37;
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "Completed processing outgoing queue (%d modifications, %d deletions)", buf, 0xEu);
    }

    v211 = objc_alloc_init(CKKSPowerCollection);
    v38 = [AAFAnalyticsEventSecurity alloc];
    v246 = CFSTR("totalCKRecords");
    v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(*(id *)(a1 + 88), "count")));
    v247 = v39;
    v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v247, &v246, 1));
    v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 56), "deps"));
    v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v41, "activeAccount"));
    v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v42, "altDSID"));
    v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 56), "deps"));
    v201 = -[AAFAnalyticsEventSecurity initWithCKKSMetrics:altDSID:eventName:testsAreEnabled:category:sendMetric:](v38, "initWithCKKSMetrics:altDSID:eventName:testsAreEnabled:category:sendMetric:", v40, v43, CFSTR("com.apple.security.ckks.processOutgoingQueue.saveCKMirrorEntries"), 0, &off_10030AF70, objc_msgSend(v44, "sendMetric"));

    v45 = (id *)a1;
    v232 = 0u;
    v233 = 0u;
    v230 = 0u;
    v231 = 0u;
    obj = *(id *)(a1 + 88);
    v206 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v230, v245, 16);
    v46 = 0;
    v47 = 0;
    if (!v206)
    {
LABEL_51:
      v214 = v47;

      v223 = 0u;
      v224 = 0u;
      v221 = 0u;
      v222 = 0u;
      obja = v45[10];
      v210 = objc_msgSend(obja, "countByEnumeratingWithState:objects:count:", &v221, v244, 16);
      v109 = 0;
      if (v210)
      {
        v207 = *(_QWORD *)v222;
        do
        {
          for (j = 0; j != v210; j = (char *)j + 1)
          {
            if (*(_QWORD *)v222 != v207)
              objc_enumerationMutation(obja);
            v111 = *(void **)(*((_QWORD *)&v221 + 1) + 8 * (_QWORD)j);
            v112 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v111, "recordName"));
            v113 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v45[7], "deps"));
            v114 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v113, "contextID"));
            v115 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "zoneID"));
            v220 = v109;
            v116 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSOutgoingQueueEntry fromDatabase:state:contextID:zoneID:error:](CKKSOutgoingQueueEntry, "fromDatabase:state:contextID:zoneID:error:", v112, CFSTR("inflight"), v114, v115, &v220));
            v117 = v220;

            v118 = (id *)a1;
            v119 = *(_QWORD *)(a1 + 40);
            v219 = v117;
            objc_msgSend(v116, "intransactionMoveToState:viewState:error:", CFSTR("deleted"), v119, &v219);
            v120 = v219;

            if (v120)
            {
              v121 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "zoneID"));
              v122 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v121, "zoneName"));
              v123 = sub_10000BDF4(CFSTR("ckksoutgoing"), v122);
              v124 = objc_claimAutoreleasedReturnValue(v123);

              if (os_log_type_enabled(v124, OS_LOG_TYPE_ERROR))
              {
                v125 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v111, "recordName"));
                *(_DWORD *)buf = 138412546;
                *(_QWORD *)v250 = v125;
                *(_WORD *)&v250[8] = 2112;
                v251 = v120;
                _os_log_impl((void *)&_mh_execute_header, v124, OS_LOG_TYPE_ERROR, "Couldn't delete %@ from outgoingqueue: %@", buf, 0x16u);

              }
              v126 = v120;

              v118 = (id *)a1;
              objc_msgSend(*(id *)(a1 + 56), "setError:", v126);
              v214 = v126;
            }

            v127 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v111, "recordName"));
            v128 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v118[7], "deps"));
            v129 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v128, "contextID"));
            v130 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v118[5], "zoneID"));
            v218 = 0;
            v131 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSMirrorEntry tryFromDatabase:contextID:zoneID:error:](CKKSMirrorEntry, "tryFromDatabase:contextID:zoneID:error:", v127, v129, v130, &v218));
            v132 = v218;

            v217 = v132;
            objc_msgSend(v131, "deleteFromDatabase:", &v217);
            v109 = v217;

            if (v109)
            {
              v133 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v118[5], "zoneID"));
              v134 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v133, "zoneName"));
              v135 = sub_10000BDF4(CFSTR("ckksoutgoing"), v134);
              v136 = objc_claimAutoreleasedReturnValue(v135);

              if (os_log_type_enabled(v136, OS_LOG_TYPE_ERROR))
              {
                v137 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v111, "recordName"));
                *(_DWORD *)buf = 138412546;
                *(_QWORD *)v250 = v137;
                *(_WORD *)&v250[8] = 2112;
                v251 = v109;
                _os_log_impl((void *)&_mh_execute_header, v136, OS_LOG_TYPE_ERROR, "Couldn't delete %@ from ckmirror: %@", buf, 0x16u);

              }
              v138 = v109;

              v45 = (id *)a1;
              objc_msgSend(*(id *)(a1 + 56), "setError:", v138);
              v214 = v138;
            }
            else
            {
              v45 = v118;
            }
            -[CKKSPowerCollection deletedOQE:](v211, "deletedOQE:", v116);

          }
          v210 = objc_msgSend(obja, "countByEnumeratingWithState:objects:count:", &v221, v244, 16);
        }
        while (v210);
      }

      v139 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v45[7], "error"));
      v140 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v45[7], "error"));
      +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", v201, v139 == 0, v140);

      -[CKKSPowerCollection commit](v211, "commit");
      v141 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 56), "deps"));
      v142 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v141, "overallLaunch"));
      objc_msgSend(v142, "addEvent:", CFSTR("process-outgoing-queue-complete"));

      if (v214)
      {
        v143 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "zoneID"));
        v144 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v143, "zoneName"));
        v145 = sub_10000BDF4(CFSTR("ckksoutgoing"), v144);
        v146 = objc_claimAutoreleasedReturnValue(v145);

        if (os_log_type_enabled(v146, OS_LOG_TYPE_ERROR))
        {
          v147 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 56), "error"));
          *(_DWORD *)buf = 138412290;
          *(_QWORD *)v250 = v147;
          _os_log_impl((void *)&_mh_execute_header, v146, OS_LOG_TYPE_ERROR, "Operation failed; rolling back: %@",
            buf,
            0xCu);

        }
        v148 = *(void **)(a1 + 48);
        v149 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 56), "error"));
        v150 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "zoneID"));
        v151 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v150, "zoneName"));
        objc_msgSend(v148, "logRecoverableError:forEvent:zoneName:withAttributes:", v149, CFSTR("CKKSEventProcessOutgoingQueue"), v151, 0);

        v152 = 0;
      }
      else
      {
        v162 = *(void **)(a1 + 48);
        v149 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "zoneID"));
        v150 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v149, "zoneName"));
        objc_msgSend(v162, "logSuccessForEvent:zoneName:", CFSTR("CKKSEventProcessOutgoingQueue"), v150);
        v152 = 1;
      }

      return v152;
    }
    v205 = *(_QWORD *)v231;
LABEL_22:
    v48 = 0;
    while (1)
    {
      if (*(_QWORD *)v231 != v205)
        objc_enumerationMutation(obj);
      v49 = *(void **)(*((_QWORD *)&v230 + 1) + 8 * v48);
      v50 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v49, "recordType"));
      v51 = objc_msgSend(v50, "isEqualToString:", CFSTR("item"));

      if (v51)
      {
        v213 = v47;
        v209 = v49;
        v52 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v49, "recordID"));
        v53 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v52, "recordName"));
        v54 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v45[7], "deps"));
        v55 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v54, "contextID"));
        v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v45[5], "zoneID"));
        v229 = v46;
        v57 = objc_claimAutoreleasedReturnValue(+[CKKSOutgoingQueueEntry fromDatabase:state:contextID:zoneID:error:](CKKSOutgoingQueueEntry, "fromDatabase:state:contextID:zoneID:error:", v53, CFSTR("inflight"), v55, v56, &v229));
        v58 = v45;
        v59 = v229;

        v60 = v57;
        v61 = v58[5];
        v228 = v59;
        -[NSObject intransactionMoveToState:viewState:error:](v57, "intransactionMoveToState:viewState:error:", CFSTR("deleted"), v61, &v228);
        v62 = v228;

        if (v62)
        {
          v63 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v58[5], "zoneID"));
          v64 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v63, "zoneName"));
          v65 = sub_10000BDF4(CFSTR("ckksoutgoing"), v64);
          v66 = objc_claimAutoreleasedReturnValue(v65);

          v45 = v58;
          if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
          {
            v67 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v209, "recordID"));
            v68 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v67, "recordName"));
            *(_DWORD *)buf = 138412546;
            *(_QWORD *)v250 = v68;
            *(_WORD *)&v250[8] = 2112;
            v251 = v62;
            _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_ERROR, "Couldn't update %@ in outgoingqueue: %@", buf, 0x16u);

          }
          v69 = v62;

          objc_msgSend(v58[7], "setError:", v69);
          v47 = v69;
        }
        else
        {
          v45 = v58;
          v47 = v213;
        }

        v94 = [CKKSMirrorEntry alloc];
        v95 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v45[7], "deps"));
        v96 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v95, "contextID"));
        v97 = -[CKKSMirrorEntry initWithCKRecord:contextID:](v94, "initWithCKRecord:contextID:", v209, v96);

        v227 = 0;
        -[CKKSSQLDatabaseObject saveToDatabase:](v97, "saveToDatabase:", &v227);
        v46 = v227;
        if (v46)
        {
          v98 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v45[5], "zoneID"));
          v99 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v98, "zoneName"));
          v100 = sub_10000BDF4(CFSTR("ckksoutgoing"), v99);
          v101 = objc_claimAutoreleasedReturnValue(v100);

          if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
          {
            v102 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v209, "recordID"));
            v103 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v102, "recordName"));
            *(_DWORD *)buf = 138412546;
            *(_QWORD *)v250 = v103;
            *(_WORD *)&v250[8] = 2112;
            v251 = v46;
            _os_log_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_ERROR, "Couldn't save %@ to ckmirror: %@", buf, 0x16u);

          }
          v104 = v46;

          objc_msgSend(v45[7], "setError:", v104);
          v47 = v104;
          v60 = v57;
        }
        -[CKKSPowerCollection storedOQE:](v211, "storedOQE:", v60);

        goto LABEL_49;
      }
      v70 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v49, "recordType"));
      v71 = objc_msgSend(v70, "isEqualToString:", CFSTR("currentkey"));

      if (v71)
      {
        v72 = [CKKSCurrentKeyPointer alloc];
        v73 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v45[7], "deps"));
        v74 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v73, "contextID"));
        v75 = v49;
        v60 = -[CKKSCKRecordHolder initWithCKRecord:contextID:](v72, "initWithCKRecord:contextID:", v49, v74);

        v226 = v46;
        -[NSObject saveToDatabase:](v60, "saveToDatabase:", &v226);
        v76 = v226;

        if (!v76)
          goto LABEL_46;
        v77 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v45[5], "zoneID"));
        v78 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v77, "zoneName"));
        v79 = sub_10000BDF4(CFSTR("ckksoutgoing"), v78);
        v80 = objc_claimAutoreleasedReturnValue(v79);

        if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
        {
          v81 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v75, "recordID"));
          v82 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v81, "recordName"));
          *(_DWORD *)buf = 138412546;
          *(_QWORD *)v250 = v82;
          *(_WORD *)&v250[8] = 2112;
          v251 = v76;
          v83 = v80;
          v84 = "Couldn't save %@ to currentkey: %@";
LABEL_38:
          _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_ERROR, v84, buf, 0x16u);

        }
      }
      else
      {
        v85 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v49, "recordType"));
        v86 = objc_msgSend(v85, "isEqualToString:", CFSTR("devicestate"));

        if (!v86)
        {
          v105 = v49;
          v106 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v45[5], "zoneID"));
          v107 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v106, "zoneName"));
          v108 = sub_10000BDF4(CFSTR("ckksoutgoing"), v107);
          v60 = objc_claimAutoreleasedReturnValue(v108);

          if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412290;
            *(_QWORD *)v250 = v105;
            _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_ERROR, "unknown record type in results: %@", buf, 0xCu);
          }
          goto LABEL_49;
        }
        v87 = [CKKSDeviceStateEntry alloc];
        v88 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v45[7], "deps"));
        v89 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v88, "contextID"));
        v90 = v49;
        v60 = -[CKKSCKRecordHolder initWithCKRecord:contextID:](v87, "initWithCKRecord:contextID:", v49, v89);

        v225 = v46;
        -[NSObject saveToDatabase:](v60, "saveToDatabase:", &v225);
        v76 = v225;

        if (!v76)
        {
LABEL_46:
          v46 = 0;
          goto LABEL_49;
        }
        v91 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v45[5], "zoneID"));
        v92 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v91, "zoneName"));
        v93 = sub_10000BDF4(CFSTR("ckksoutgoing"), v92);
        v80 = objc_claimAutoreleasedReturnValue(v93);

        if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
        {
          v81 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v90, "recordID"));
          v82 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v81, "recordName"));
          *(_DWORD *)buf = 138412546;
          *(_QWORD *)v250 = v82;
          *(_WORD *)&v250[8] = 2112;
          v251 = v76;
          v83 = v80;
          v84 = "Couldn't save %@ to ckdevicestate: %@";
          goto LABEL_38;
        }
      }

      v46 = v76;
      objc_msgSend(v45[7], "setError:", v46);
      v47 = v46;
LABEL_49:

      if (v206 == (id)++v48)
      {
        v206 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v230, v245, 16);
        if (!v206)
          goto LABEL_51;
        goto LABEL_22;
      }
    }
  }
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "zoneID"));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "zoneName"));
  v4 = sub_10000BDF4(CFSTR("ckksoutgoing"), v3);
  v5 = objc_claimAutoreleasedReturnValue(v4);

  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    v6 = *(_QWORD *)(v1 + 32);
    *(_DWORD *)buf = 138412290;
    *(_QWORD *)v250 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "error processing outgoing queue: %@", buf, 0xCu);
  }

  v7 = *(void **)(v1 + 48);
  v8 = *(_QWORD *)(v1 + 32);
  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v1 + 40), "zoneID"));
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "zoneName"));
  objc_msgSend(v7, "logRecoverableError:forEvent:zoneName:withAttributes:", v8, CFSTR("CKKSEventProcessOutgoingQueue"), v10, 0);

  v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v1 + 56), "deps"));
  objc_msgSend(v11, "intransactionCKWriteFailed:attemptedRecordsChanged:", *(_QWORD *)(v1 + 32), *(_QWORD *)(v1 + 64));

  v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v1 + 32), "domain"));
  if (objc_msgSend(v12, "isEqualToString:", CKErrorDomain))
  {
    v13 = objc_msgSend(*(id *)(v1 + 32), "code");

    if (v13 == (id)2)
    {
      v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v1 + 32), "userInfo"));
      v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "objectForKeyedSubscript:", CKPartialErrorsByItemIDKey));

      if (objc_msgSend(*(id *)(v1 + 56), "intransactionIsErrorBadEtagOnKeyPointersOnly:", *(_QWORD *)(v1 + 32)))
      {
        v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v1 + 40), "zoneID"));
        v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "zoneName"));
        v18 = sub_10000BDF4(CFSTR("ckksoutgoing"), v17);
        v19 = objc_claimAutoreleasedReturnValue(v18);

        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          v20 = "Error is simply due to current key pointers changing; marking all records as 'needs reencrypt'";
LABEL_84:
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v20, buf, 2u);
          goto LABEL_85;
        }
        goto LABEL_85;
      }
      if (objc_msgSend(*(id *)(v1 + 56), "_onqueueIsErrorMissingSyncKey:", *(_QWORD *)(v1 + 32)))
      {
        v163 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v1 + 40), "zoneID"));
        v164 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v163, "zoneName"));
        v165 = sub_10000BDF4(CFSTR("ckksoutgoing"), v164);
        v19 = objc_claimAutoreleasedReturnValue(v165);

        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          v20 = "Error is due to the key records missing. Marking all as 'needs reencrypt'";
          goto LABEL_84;
        }
LABEL_85:

        v166 = *(void **)(v1 + 56);
        v167 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "allKeys"));
        objc_msgSend(v166, "_onqueueModifyAllRecords:as:viewState:", v167, CFSTR("reencrypt"), *(_QWORD *)(v1 + 40));

        goto LABEL_86;
      }
      v242 = 0u;
      v243 = 0u;
      v240 = 0u;
      v241 = 0u;
      v160 = v15;
      v215 = objc_msgSend(v160, "countByEnumeratingWithState:objects:count:", &v240, v252, 16);
      if (!v215)
        goto LABEL_87;
      objb = v15;
      v208 = 0;
      v212 = *(_QWORD *)v241;
LABEL_92:
      v170 = 0;
      while (1)
      {
        if (*(_QWORD *)v241 != v212)
          objc_enumerationMutation(v160);
        v171 = *(void **)(*((_QWORD *)&v240 + 1) + 8 * v170);
        v172 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v160, "objectForKeyedSubscript:", v171));
        v173 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v1 + 40), "zoneID"));
        v174 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v173, "zoneName"));
        v175 = sub_10000BDF4(CFSTR("ckksoutgoing"), v174);
        v176 = objc_claimAutoreleasedReturnValue(v175);

        if (os_log_type_enabled(v176, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412546;
          *(_QWORD *)v250 = v171;
          *(_WORD *)&v250[8] = 2112;
          v251 = v172;
          _os_log_impl((void *)&_mh_execute_header, v176, OS_LOG_TYPE_DEFAULT, "failed record: %@ %@", buf, 0x16u);
        }

        v177 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v172, "domain"));
        if (!objc_msgSend(v177, "isEqualToString:", CKErrorDomain))
          break;
        v178 = objc_msgSend(v172, "code");

        if (v178 != (id)14)
          goto LABEL_102;
        v179 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v171, "recordName"));
        if (objc_msgSend(v179, "isEqualToString:", CFSTR("classA")))
        {

        }
        else
        {
          v199 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v171, "recordName"));
          v200 = objc_msgSend(v199, "isEqualToString:", CFSTR("classC"));

          if ((v200 & 1) == 0)
            goto LABEL_114;
        }
        v208 = 1;
LABEL_118:

        if (v215 == (id)++v170)
        {
          v215 = objc_msgSend(v160, "countByEnumeratingWithState:objects:count:", &v240, v252, 16);
          if (!v215)
          {

            v15 = objb;
            if ((v208 & 1) == 0)
              goto LABEL_88;
LABEL_86:
            v160 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v1 + 56), "deps"));
            v168 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v160, "flagHandler"));
            objc_msgSend(v168, "_onqueueHandleFlag:", CFSTR("item_reencryption_needed"));

LABEL_87:
            v160 = v15;
            goto LABEL_88;
          }
          goto LABEL_92;
        }
      }

LABEL_102:
      v180 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v172, "domain"));
      if (objc_msgSend(v180, "isEqualToString:", CKErrorDomain))
      {
        v181 = objc_msgSend(v172, "code");

        if (v181 == (id)22)
        {
          if (objc_msgSend(*(id *)(v1 + 72), "containsObject:", v171))
          {
            v182 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v171, "recordName"));
            v183 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v1 + 56), "deps"));
            v184 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v183, "contextID"));
            v185 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v171, "zoneID"));
            v239 = 0;
            v186 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSOutgoingQueueEntry tryFromDatabase:state:contextID:zoneID:error:](CKKSOutgoingQueueEntry, "tryFromDatabase:state:contextID:zoneID:error:", v182, CFSTR("inflight"), v184, v185, &v239));
            v187 = v239;

            v1 = a1;
            v188 = v186;
            v189 = *(_QWORD *)(a1 + 40);
            v238 = v187;
            objc_msgSend(v186, "intransactionMoveToState:viewState:error:", CFSTR("new"), v189, &v238);
            v190 = v238;

            if (v190)
            {
              v191 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "zoneID"));
              v192 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v191, "zoneName"));
              v193 = sub_10000BDF4(CFSTR("ckksoutgoing"), v192);
              v194 = objc_claimAutoreleasedReturnValue(v193);

              if (os_log_type_enabled(v194, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 138412290;
                *(_QWORD *)v250 = v190;
                _os_log_impl((void *)&_mh_execute_header, v194, OS_LOG_TYPE_ERROR, "Couldn't clean up outgoing queue entry: %@", buf, 0xCu);
              }

              v1 = a1;
            }

          }
          goto LABEL_118;
        }
      }
      else
      {

      }
      v195 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v1 + 40), "zoneID"));
      v196 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v195, "zoneName"));
      v197 = sub_10000BDF4(CFSTR("ckksoutgoing"), v196);
      v198 = objc_claimAutoreleasedReturnValue(v197);

      if (os_log_type_enabled(v198, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412546;
        *(_QWORD *)v250 = v171;
        *(_WORD *)&v250[8] = 2112;
        v251 = v172;
        _os_log_impl((void *)&_mh_execute_header, v198, OS_LOG_TYPE_ERROR, "Unknown error on row: %@ %@", buf, 0x16u);
      }

      v1 = a1;
LABEL_114:
      if (objc_msgSend(*(id *)(v1 + 72), "containsObject:", v171))
        objc_msgSend(*(id *)(v1 + 56), "_onqueueModifyRecordAsError:recordError:viewState:", v171, v172, *(_QWORD *)(v1 + 40));
      goto LABEL_118;
    }
  }
  else
  {

  }
  v153 = objc_msgSend(*(id *)(v1 + 32), "isCKInternalServerHTTPError");
  v154 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v1 + 40), "zoneID"));
  v155 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v154, "zoneName"));
  v156 = sub_10000BDF4(CFSTR("ckks"), v155);
  v157 = objc_claimAutoreleasedReturnValue(v156);

  v158 = os_log_type_enabled(v157, OS_LOG_TYPE_DEFAULT);
  if (v153)
  {
    if (v158)
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)v250 = 1800;
      _os_log_impl((void *)&_mh_execute_header, v157, OS_LOG_TYPE_DEFAULT, "CloudKit is presumably down; scheduling upload after %d seconds",
        buf,
        8u);
    }

    v159 = *(void **)(v1 + 56);
    v160 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v1 + 72), "allObjects"));
    objc_msgSend(v159, "_onqueueSaveRecordsWithDelay:viewState:", v160, *(_QWORD *)(v1 + 40));
  }
  else
  {
    if (v158)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v157, OS_LOG_TYPE_DEFAULT, "Error is scary: putting all inflight OQEs back into state 'new'", buf, 2u);
    }

    v161 = *(void **)(v1 + 56);
    v160 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v1 + 72), "allObjects"));
    objc_msgSend(v161, "_onqueueModifyAllRecords:as:viewState:", v160, CFSTR("new"), *(_QWORD *)(v1 + 40));
  }
LABEL_88:

  objc_msgSend(*(id *)(v1 + 56), "setError:", *(_QWORD *)(v1 + 32));
  return 1;
}

uint64_t sub_100081850(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  void *v3;
  id v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  id v13;
  NSObject *v14;
  void *v15;
  void *v16;
  id v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  id v22;
  NSObject *v23;
  uint64_t v24;
  void *v25;
  void *v26;
  id v27;
  NSObject *v28;
  void *i;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  id v36;
  void *v37;
  unsigned __int8 v38;
  void *v39;
  void *v40;
  void *v41;
  unsigned int v42;
  void *v43;
  void *v44;
  void *v45;
  unsigned int v46;
  void *v47;
  unsigned int v48;
  void *v49;
  void *v50;
  id v51;
  void *v52;
  void *v53;
  uint64_t v54;
  void *v55;
  void *v56;
  id v57;
  NSObject *v58;
  void *v59;
  unsigned int v60;
  id v61;
  void *v62;
  void *v63;
  void *v64;
  uint64_t v65;
  void *v66;
  void *v67;
  id v68;
  NSObject *v69;
  void *v70;
  unsigned int v71;
  void *v72;
  void *v73;
  void *v74;
  void *v75;
  void *v76;
  void *v77;
  void *v78;
  void *v79;
  void *v80;
  void *v81;
  unsigned __int8 v82;
  void *v83;
  void *v84;
  void *v85;
  void *v86;
  id v87;
  void *v88;
  void *v89;
  uint64_t v90;
  void *v91;
  void *v92;
  id v93;
  NSObject *v94;
  void *v95;
  void *v96;
  id v97;
  NSObject *v98;
  void *v99;
  void *v100;
  uint64_t v101;
  void *v102;
  void *v103;
  id v104;
  NSObject *v105;
  void *v106;
  void *v107;
  id v108;
  NSObject *v109;
  void *v110;
  void *v111;
  void *v112;
  void *v113;
  void *v114;
  void *v115;
  uint64_t v116;
  void *v117;
  void *v118;
  id v119;
  NSObject *v120;
  void *v121;
  void *v122;
  id v123;
  NSObject *v124;
  uint64_t v125;
  void *v126;
  void *v127;
  id v128;
  NSObject *v129;
  void *v130;
  void *v131;
  id v132;
  NSObject *v133;
  void *v134;
  uint64_t v135;
  void *v136;
  void *v137;
  id v138;
  NSObject *v139;
  void *v140;
  id v141;
  uint64_t v142;
  void *j;
  void *v144;
  void *v145;
  void *v146;
  void *v147;
  uint64_t v148;
  void *v149;
  void *v150;
  void *v151;
  void *v152;
  void *v153;
  void *v154;
  void *v155;
  id v156;
  NSObject *v157;
  const char *v158;
  NSObject *v159;
  uint32_t v160;
  void *v161;
  void *v162;
  id v163;
  void *v164;
  void *v165;
  id v166;
  NSObject *v167;
  void *v168;
  void *v169;
  void *v170;
  void *v171;
  id v172;
  NSObject *v173;
  void *v174;
  void *v175;
  void *v176;
  void *v177;
  void *v178;
  void *v179;
  id v180;
  NSObject *v181;
  AAFAnalyticsEventSecurity *v182;
  void *v183;
  void *v184;
  void *v185;
  void *v186;
  void *v187;
  void *v188;
  void *v189;
  id v190;
  void *v191;
  void *v192;
  void *v193;
  void *v194;
  void *v195;
  void *v196;
  id v197;
  NSObject *v198;
  unsigned int v199;
  void *v200;
  void *v201;
  void *v202;
  id v203;
  NSObject *v204;
  unsigned int v205;
  unsigned int v206;
  void *v207;
  id v208;
  uint64_t v209;
  void *k;
  void *v211;
  void *v212;
  void *v213;
  id v214;
  NSObject *v215;
  id v216;
  id v217;
  uint64_t v218;
  void *m;
  void *v220;
  void *v221;
  void *v222;
  id v223;
  NSObject *v224;
  id v225;
  AAFAnalyticsEventSecurity *v226;
  void *v227;
  void *v228;
  void *v230;
  void *v231;
  void *v232;
  id v233;
  void *v234;
  char v235;
  void *v236;
  AAFAnalyticsEventSecurity *v237;
  id v238;
  void *v239;
  id v240;
  void *v241;
  id v242;
  void *v243;
  id v244;
  id v245;
  void *v246;
  id obj;
  id obja;
  uint64_t v249;
  id v250;
  id v251;
  id v252;
  id v253;
  void *context;
  _QWORD v256[5];
  id v257;
  id v258;
  id v259;
  id v260;
  AAFAnalyticsEventSecurity *v261;
  id v262;
  _QWORD *v263;
  _BYTE *v264;
  id v265;
  BOOL v266;
  _QWORD v267[6];
  _QWORD v268[3];
  int v269;
  __int128 v270;
  __int128 v271;
  __int128 v272;
  __int128 v273;
  __int128 v274;
  __int128 v275;
  __int128 v276;
  __int128 v277;
  id v278;
  __int128 v279;
  __int128 v280;
  __int128 v281;
  __int128 v282;
  id v283;
  id v284;
  id v285;
  id v286;
  id v287;
  id v288;
  id v289;
  id v290;
  __int128 v291;
  __int128 v292;
  __int128 v293;
  __int128 v294;
  id v295;
  id v296;
  id v297;
  _BYTE v298[128];
  _BYTE v299[128];
  _QWORD v300[2];
  _QWORD v301[2];
  _BYTE v302[128];
  _QWORD v303[5];
  _QWORD v304[5];
  _BYTE buf[24];
  void *v306;
  __int16 v307;
  void *v308;
  _BYTE v309[128];
  _QWORD v310[2];
  _QWORD v311[2];

  v1 = *(_QWORD *)(a1 + 32);
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "contextID"));
  v297 = 0;
  v234 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSOutgoingQueueOperation ontransactionFetchEntries:contextID:error:](CKKSOutgoingQueueOperation, "ontransactionFetchEntries:contextID:error:", v1, v3, &v297));
  v4 = v297;

  if (!v234 || v4)
  {
    v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v25, "zoneName"));
    v27 = sub_10000BDF4(CFSTR("ckksoutgoing"), v26);
    v28 = objc_claimAutoreleasedReturnValue(v27);

    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)&buf[4] = v4;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Error fetching outgoing queue records: %@", buf, 0xCu);
    }

    objc_msgSend(*(id *)(a1 + 40), "setError:", v4);
    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", *(_QWORD *)(a1 + 48), 0, v4);
    v24 = 0;
    goto LABEL_129;
  }
  v233 = objc_msgSend(v234, "count");
  v5 = *(void **)(a1 + 48);
  v310[0] = CFSTR("numKeychainItems");
  v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(v234, "count")));
  v310[1] = CFSTR("isFullUpload");
  v311[0] = v6;
  v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", (unint64_t)v233 > 0x63));
  v311[1] = v7;
  v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v311, v310, 2));
  objc_msgSend(v5, "addMetrics:", v8);

  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "zoneName"));
  +[CKKSPowerCollection CKKSPowerEvent:zone:count:](CKKSPowerCollection, "CKKSPowerEvent:zone:count:", CFSTR("processOutgoingQueue"), v10, objc_msgSend(v234, "count"));

  v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
  v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "zoneName"));
  v13 = sub_10000BDF4(CFSTR("ckksoutgoing"), v12);
  v14 = objc_claimAutoreleasedReturnValue(v13);

  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138412290;
    *(_QWORD *)&buf[4] = v234;
    _os_log_debug_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "processing outgoing queue: %@", buf, 0xCu);
  }

  v253 = objc_alloc_init((Class)NSMutableDictionary);
  v245 = objc_alloc_init((Class)NSMutableSet);
  v244 = objc_alloc_init((Class)NSMutableSet);
  v238 = objc_alloc_init((Class)NSMutableArray);
  v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "contextID"));
  v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
  v296 = 0;
  v246 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSCurrentKeyPointer fromDatabase:contextID:zoneID:error:](CKKSCurrentKeyPointer, "fromDatabase:contextID:zoneID:error:", CFSTR("classA"), v15, v16, &v296));
  v17 = v296;

  v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "contextID"));
  v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
  v295 = v17;
  v243 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSCurrentKeyPointer fromDatabase:contextID:zoneID:error:](CKKSCurrentKeyPointer, "fromDatabase:contextID:zoneID:error:", CFSTR("classC"), v18, v19, &v295));
  v4 = v295;

  v242 = objc_alloc_init((Class)NSMutableDictionary);
  if (v4)
  {
    v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "zoneName"));
    v22 = sub_10000BDF4(CFSTR("ckksoutgoing"), v21);
    v23 = objc_claimAutoreleasedReturnValue(v22);

    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)&buf[4] = v4;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Couldn't load current class keys: %@", buf, 0xCu);
    }

    objc_msgSend(*(id *)(a1 + 40), "setError:", v4);
    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", *(_QWORD *)(a1 + 48), 0, v4);
    v24 = 0;
    goto LABEL_128;
  }
  v293 = 0u;
  v294 = 0u;
  v291 = 0u;
  v292 = 0u;
  obj = v234;
  v251 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v291, v309, 16);
  if (!v251)
  {
    v4 = 0;
    v135 = 0;
    goto LABEL_72;
  }
  v235 = 0;
  v4 = 0;
  v249 = *(_QWORD *)v292;
  do
  {
    for (i = 0; i != v251; i = (char *)i + 1)
    {
      if (*(_QWORD *)v292 != v249)
        objc_enumerationMutation(obj);
      v30 = *(void **)(*((_QWORD *)&v291 + 1) + 8 * (_QWORD)i);
      context = objc_autoreleasePoolPush();
      v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "uuid"));
      v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
      v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v32, "contextID"));
      v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
      v290 = v4;
      v35 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSOutgoingQueueEntry tryFromDatabase:state:contextID:zoneID:error:](CKKSOutgoingQueueEntry, "tryFromDatabase:state:contextID:zoneID:error:", v31, CFSTR("inflight"), v33, v34, &v290));
      v36 = v290;

      if (!v36 && v35)
      {
        v4 = 0;
        goto LABEL_65;
      }
      v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "action"));
      v38 = objc_msgSend(v37, "isEqualToString:", CFSTR("delete"));

      if ((v38 & 1) == 0)
      {
        v39 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "item"));
        v40 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v39, "parentKeyUUID"));
        v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v246, "currentKeyUUID"));
        v42 = objc_msgSend(v40, "isEqualToString:", v41);

        if (v42)
        {
          objc_msgSend(v242, "setObject:forKeyedSubscript:", v246, CFSTR("classA"));
        }
        else
        {
          v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "item"));
          v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v43, "parentKeyUUID"));
          v45 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v243, "currentKeyUUID"));
          v46 = objc_msgSend(v44, "isEqualToString:", v45);

          if (!v46)
          {
            v95 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
            v96 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v95, "zoneName"));
            v97 = sub_10000BDF4(CFSTR("ckksoutgoing"), v96);
            v98 = objc_claimAutoreleasedReturnValue(v97);

            if (os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
            {
              v99 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "item"));
              v100 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v99, "parentKeyUUID"));
              *(_DWORD *)buf = 138413058;
              *(_QWORD *)&buf[4] = v30;
              *(_WORD *)&buf[12] = 2112;
              *(_QWORD *)&buf[14] = v100;
              *(_WORD *)&buf[22] = 2112;
              v306 = v246;
              v307 = 2112;
              v308 = v243;
              _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_DEFAULT, "Item's encryption key (%@ %@) is neither %@ or %@", buf, 0x2Au);

            }
            v101 = *(_QWORD *)(a1 + 32);
            v289 = v36;
            objc_msgSend(v30, "intransactionMoveToState:viewState:error:", CFSTR("reencrypt"), v101, &v289);
            v51 = v289;

            if (!v51)
            {
              v4 = 0;
              v235 = 1;
              goto LABEL_65;
            }
            v102 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
            v103 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v102, "zoneName"));
            v104 = sub_10000BDF4(CFSTR("ckksoutgoing"), v103);
            v105 = objc_claimAutoreleasedReturnValue(v104);

            if (os_log_type_enabled(v105, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 138412290;
              *(_QWORD *)&buf[4] = v51;
              _os_log_impl((void *)&_mh_execute_header, v105, OS_LOG_TYPE_ERROR, "couldn't save oqe to database: %@", buf, 0xCu);
            }

            objc_msgSend(*(id *)(a1 + 40), "setError:", v51);
            goto LABEL_48;
          }
          objc_msgSend(v242, "setObject:forKeyedSubscript:", v243, CFSTR("classC"));
        }
      }
      v47 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "action"));
      v48 = objc_msgSend(v47, "isEqualToString:", CFSTR("add"));

      if (v48)
      {
        v49 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "item"));
        v50 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
        v51 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v49, "CKRecordWithZoneID:", v50));

        v52 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v51, "recordID"));
        objc_msgSend(v253, "setObject:forKeyedSubscript:", v51, v52);

        v53 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v51, "recordID"));
        objc_msgSend(v245, "addObject:", v53);

        objc_msgSend(v244, "addObject:", v30);
        v54 = *(_QWORD *)(a1 + 32);
        v288 = v36;
        objc_msgSend(v30, "intransactionMoveToState:viewState:error:", CFSTR("inflight"), v54, &v288);
        v4 = v288;

        if (v4)
        {
          v55 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
          v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v55, "zoneName"));
          v57 = sub_10000BDF4(CFSTR("ckksoutgoing"), v56);
          v58 = objc_claimAutoreleasedReturnValue(v57);

          if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412290;
            *(_QWORD *)&buf[4] = v4;
            _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_ERROR, "couldn't save state for CKKSOutgoingQueueEntry: %@", buf, 0xCu);
          }

          objc_msgSend(*(id *)(a1 + 40), "setError:", v4);
        }
        goto LABEL_64;
      }
      v59 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "action"));
      v60 = objc_msgSend(v59, "isEqualToString:", CFSTR("delete"));

      if (v60)
      {
        v61 = objc_alloc((Class)CKRecordID);
        v62 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "item"));
        v63 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v62, "uuid"));
        v64 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
        v51 = objc_msgSend(v61, "initWithRecordName:zoneID:", v63, v64);

        objc_msgSend(v238, "addObject:", v51);
        objc_msgSend(v245, "addObject:", v51);
        objc_msgSend(v244, "addObject:", v30);
        v65 = *(_QWORD *)(a1 + 32);
        v287 = v36;
        objc_msgSend(v30, "intransactionMoveToState:viewState:error:", CFSTR("inflight"), v65, &v287);
        v4 = v287;

        if (v4)
        {
          v66 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
          v67 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v66, "zoneName"));
          v68 = sub_10000BDF4(CFSTR("ckksoutgoing"), v67);
          v69 = objc_claimAutoreleasedReturnValue(v68);

          if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412290;
            *(_QWORD *)&buf[4] = v4;
            _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_ERROR, "couldn't save state for CKKSOutgoingQueueEntry: %@", buf, 0xCu);
          }

        }
        goto LABEL_64;
      }
      v70 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "action"));
      v71 = objc_msgSend(v70, "isEqualToString:", CFSTR("modify"));

      if (!v71)
      {
        v4 = v36;
        goto LABEL_65;
      }
      v72 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "item"));
      v73 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v72, "uuid"));
      v74 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
      v75 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v74, "contextID"));
      v76 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
      v286 = v36;
      v51 = (id)objc_claimAutoreleasedReturnValue(+[CKKSMirrorEntry tryFromDatabase:contextID:zoneID:error:](CKKSMirrorEntry, "tryFromDatabase:contextID:zoneID:error:", v73, v75, v76, &v286));
      v240 = v286;

      if (!v51)
      {
        v106 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
        v107 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v106, "zoneName"));
        v108 = sub_10000BDF4(CFSTR("ckksoutgoing"), v107);
        v109 = objc_claimAutoreleasedReturnValue(v108);

        if (os_log_type_enabled(v109, OS_LOG_TYPE_ERROR))
        {
          v110 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "item"));
          v111 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v110, "uuid"));
          *(_DWORD *)buf = 138412290;
          *(_QWORD *)&buf[4] = v111;
          _os_log_impl((void *)&_mh_execute_header, v109, OS_LOG_TYPE_ERROR, "update to a record that doesn't exist? %@", buf, 0xCu);

        }
        v112 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "item"));
        v113 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
        v87 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v112, "CKRecordWithZoneID:", v113));

        v114 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v87, "recordID"));
        objc_msgSend(v253, "setObject:forKeyedSubscript:", v87, v114);

        v115 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v87, "recordID"));
        objc_msgSend(v245, "addObject:", v115);

        objc_msgSend(v244, "addObject:", v30);
        v116 = *(_QWORD *)(a1 + 32);
        v285 = v240;
        objc_msgSend(v30, "intransactionMoveToState:viewState:error:", CFSTR("inflight"), v116, &v285);
        v4 = v285;

        if (v4)
        {
          v117 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
          v118 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v117, "zoneName"));
          v119 = sub_10000BDF4(CFSTR("ckksoutgoing"), v118);
          v120 = objc_claimAutoreleasedReturnValue(v119);

          if (os_log_type_enabled(v120, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412290;
            *(_QWORD *)&buf[4] = v4;
            _os_log_impl((void *)&_mh_execute_header, v120, OS_LOG_TYPE_ERROR, "couldn't save state for CKKSOutgoingQueueEntry: %@", buf, 0xCu);
          }

          objc_msgSend(*(id *)(a1 + 40), "setError:", v4);
        }
        goto LABEL_63;
      }
      v236 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "item"));
      v77 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v236, "storedCKRecord"));
      v78 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v77, "recordChangeTag"));
      v79 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v51, "item"));
      v80 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v79, "storedCKRecord"));
      v81 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v80, "recordChangeTag"));
      v82 = objc_msgSend(v78, "isEqual:", v81);

      if ((v82 & 1) != 0)
      {
        v83 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "item"));
        v84 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v51, "item"));
        v85 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v84, "storedCKRecord"));
        v86 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
        v87 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v83, "updateCKRecord:zoneID:", v85, v86));

        v88 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v87, "recordID"));
        objc_msgSend(v253, "setObject:forKeyedSubscript:", v87, v88);

        v89 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v87, "recordID"));
        objc_msgSend(v245, "addObject:", v89);

        objc_msgSend(v244, "addObject:", v30);
        v90 = *(_QWORD *)(a1 + 32);
        v283 = v240;
        objc_msgSend(v30, "intransactionMoveToState:viewState:error:", CFSTR("inflight"), v90, &v283);
        v4 = v283;

        if (v4)
        {
          v91 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
          v92 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v91, "zoneName"));
          v93 = sub_10000BDF4(CFSTR("ckksoutgoing"), v92);
          v94 = objc_claimAutoreleasedReturnValue(v93);

          if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412290;
            *(_QWORD *)&buf[4] = v4;
            _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_ERROR, "couldn't save state for CKKSOutgoingQueueEntry: %@", buf, 0xCu);
          }

        }
LABEL_63:

        goto LABEL_64;
      }
      v121 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
      v122 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v121, "zoneName"));
      v123 = sub_10000BDF4(CFSTR("ckksoutgoing"), v122);
      v124 = objc_claimAutoreleasedReturnValue(v123);

      if (os_log_type_enabled(v124, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        *(_QWORD *)&buf[4] = v30;
        _os_log_impl((void *)&_mh_execute_header, v124, OS_LOG_TYPE_DEFAULT, "Record (%@)'s change tag doesn't match ckmirror's change tag, reencrypting", buf, 0xCu);
      }

      v125 = *(_QWORD *)(a1 + 32);
      v284 = v240;
      objc_msgSend(v30, "intransactionMoveToState:viewState:error:", CFSTR("reencrypt"), v125, &v284);
      v87 = v284;

      if (v87)
      {
        v126 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
        v127 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v126, "zoneName"));
        v128 = sub_10000BDF4(CFSTR("ckksoutgoing"), v127);
        v129 = objc_claimAutoreleasedReturnValue(v128);

        if (os_log_type_enabled(v129, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412290;
          *(_QWORD *)&buf[4] = v87;
          _os_log_impl((void *)&_mh_execute_header, v129, OS_LOG_TYPE_ERROR, "couldn't save oqe to database: %@", buf, 0xCu);
        }

        objc_msgSend(*(id *)(a1 + 40), "setError:", v87);
        v4 = 0;
        v235 = 1;
        goto LABEL_63;
      }
LABEL_48:
      v4 = 0;
      v235 = 1;
LABEL_64:

LABEL_65:
      objc_autoreleasePoolPop(context);
    }
    v251 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v291, v309, 16);
  }
  while (v251);

  if ((v235 & 1) != 0)
  {
    v130 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v131 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v130, "zoneName"));
    v132 = sub_10000BDF4(CFSTR("ckksoutgoing"), v131);
    v133 = objc_claimAutoreleasedReturnValue(v132);

    if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "An item needs reencryption!", buf, 2u);
    }

    obj = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
    v134 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(obj, "flagHandler"));
    objc_msgSend(v134, "_onqueueHandleFlag:", CFSTR("item_reencryption_needed"));

    v135 = 1;
LABEL_72:

  }
  else
  {
    v135 = 0;
  }
  if (objc_msgSend(v253, "count") || objc_msgSend(v238, "count"))
  {
    objc_msgSend(*(id *)(a1 + 40), "setItemsProcessed:", objc_msgSend(v253, "count"));
    v136 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v137 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v136, "zoneName"));
    v138 = sub_10000BDF4(CFSTR("ckksoutgoing"), v137);
    v139 = objc_claimAutoreleasedReturnValue(v138);

    if (os_log_type_enabled(v139, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)&buf[4] = v242;
      _os_log_debug_impl((void *)&_mh_execute_header, v139, OS_LOG_TYPE_DEBUG, "Current keys to update: %@", buf, 0xCu);
    }

    v281 = 0u;
    v282 = 0u;
    v279 = 0u;
    v280 = 0u;
    v140 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v242, "allValues"));
    v141 = objc_msgSend(v140, "countByEnumeratingWithState:objects:count:", &v279, v302, 16);
    if (v141)
    {
      v142 = *(_QWORD *)v280;
      do
      {
        for (j = 0; j != v141; j = (char *)j + 1)
        {
          if (*(_QWORD *)v280 != v142)
            objc_enumerationMutation(v140);
          v144 = *(void **)(*((_QWORD *)&v279 + 1) + 8 * (_QWORD)j);
          v145 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
          v146 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v144, "CKRecordWithZoneID:", v145));

          v147 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v146, "recordID"));
          objc_msgSend(v253, "setObject:forKeyedSubscript:", v146, v147);

        }
        v141 = objc_msgSend(v140, "countByEnumeratingWithState:objects:count:", &v279, v302, 16);
      }
      while (v141);
    }

    v148 = *(_QWORD *)(a1 + 32);
    v149 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
    v150 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v149, "accountStateTracker"));
    v151 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
    v152 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v151, "lockStateTracker"));
    v278 = 0;
    v241 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSDeviceStateEntry intransactionCreateDeviceStateForView:accountTracker:lockStateTracker:error:](CKKSDeviceStateEntry, "intransactionCreateDeviceStateForView:accountTracker:lockStateTracker:error:", v148, v150, v152, &v278));
    obja = v278;

    v153 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v239 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v241, "CKRecordWithZoneID:", v153));

    if (obja)
    {
      v154 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
      v155 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v154, "zoneName"));
      v156 = sub_10000BDF4(CFSTR("ckksoutgoing"), v155);
      v157 = objc_claimAutoreleasedReturnValue(v156);

      if (os_log_type_enabled(v157, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        *(_QWORD *)&buf[4] = obja;
        v158 = "Can't make current device state: %@";
        v159 = v157;
        v160 = 12;
        goto LABEL_88;
      }
    }
    else
    {
      v161 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
      v162 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v161, "zoneName"));
      v163 = sub_10000BDF4(CFSTR("ckksoutgoing"), v162);
      v157 = objc_claimAutoreleasedReturnValue(v163);

      if (v239)
      {
        if (os_log_type_enabled(v157, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          *(_QWORD *)&buf[4] = v241;
          _os_log_impl((void *)&_mh_execute_header, v157, OS_LOG_TYPE_DEFAULT, "Updating device state: %@", buf, 0xCu);
        }

        v157 = objc_claimAutoreleasedReturnValue(objc_msgSend(v239, "recordID"));
        objc_msgSend(v253, "setObject:forKeyedSubscript:", v239, v157);
      }
      else if (os_log_type_enabled(v157, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        v158 = "Can't make current device state cloudkit record, but no reason why";
        v159 = v157;
        v160 = 2;
LABEL_88:
        _os_log_impl((void *)&_mh_execute_header, v159, OS_LOG_TYPE_ERROR, v158, buf, v160);
      }
    }

    v178 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v179 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v178, "zoneName"));
    v180 = sub_10000BDF4(CFSTR("ckksoutgoing"), v179);
    v181 = objc_claimAutoreleasedReturnValue(v180);

    if (os_log_type_enabled(v181, OS_LOG_TYPE_DEBUG))
    {
      v230 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
      *(_DWORD *)buf = 138412546;
      *(_QWORD *)&buf[4] = v253;
      *(_WORD *)&buf[12] = 2112;
      *(_QWORD *)&buf[14] = v230;
      _os_log_debug_impl((void *)&_mh_execute_header, v181, OS_LOG_TYPE_DEBUG, "Saving records %@ to CloudKit zone %@", buf, 0x16u);

    }
    v182 = [AAFAnalyticsEventSecurity alloc];
    v300[0] = CFSTR("needsReencryption");
    v183 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v135));
    v301[0] = v183;
    v300[1] = CFSTR("isFullUpload");
    v184 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", (unint64_t)v233 > 0x63));
    v301[1] = v184;
    v185 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v301, v300, 2));
    v186 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
    v187 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v186, "activeAccount"));
    v188 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v187, "altDSID"));
    v189 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
    v237 = -[AAFAnalyticsEventSecurity initWithCKKSMetrics:altDSID:eventName:testsAreEnabled:category:sendMetric:](v182, "initWithCKKSMetrics:altDSID:eventName:testsAreEnabled:category:sendMetric:", v185, v188, CFSTR("com.apple.security.ckks.processOutgoingQueue.uploadOQEstoCK"), 0, &off_10030AF70, objc_msgSend(v189, "sendMetric"));

    v250 = objc_alloc_init((Class)NSBlockOperation);
    objc_msgSend(v250, "setName:", CFSTR("modifyRecordsComplete"));
    objc_msgSend(*(id *)(a1 + 40), "dependOnBeforeGroupFinished:", v250);
    v190 = objc_alloc((Class)CKModifyRecordsOperation);
    v191 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v253, "allValues"));
    v252 = objc_msgSend(v190, "initWithRecordsToSave:recordIDsToDelete:", v191, v238);

    objc_msgSend(v252, "setAtomic:", 1);
    objc_msgSend(v252, "linearDependencies:", *(_QWORD *)(a1 + 56));
    v192 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v252, "configuration"));
    objc_msgSend(v192, "setIsCloudKitSupportOperation:", 1);

    objc_msgSend(v252, "setSavePolicy:", 0);
    v193 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
    v194 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v193, "currentOutgoingQueueOperationGroup"));
    objc_msgSend(v252, "setGroup:", v194);

    v195 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v196 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v195, "zoneName"));
    v197 = sub_10000BDF4(CFSTR("ckksoutgoing"), v196);
    v198 = objc_claimAutoreleasedReturnValue(v197);

    if (os_log_type_enabled(v198, OS_LOG_TYPE_DEFAULT))
    {
      v199 = objc_msgSend(v252, "qualityOfService");
      v200 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v252, "group"));
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v199;
      *(_WORD *)&buf[8] = 2112;
      *(_QWORD *)&buf[10] = v200;
      _os_log_impl((void *)&_mh_execute_header, v198, OS_LOG_TYPE_DEFAULT, "QoS: %d; operation group is %@", buf, 0x12u);

    }
    v201 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v202 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v201, "zoneName"));
    v203 = sub_10000BDF4(CFSTR("ckksoutgoing"), v202);
    v204 = objc_claimAutoreleasedReturnValue(v203);

    if (os_log_type_enabled(v204, OS_LOG_TYPE_DEFAULT))
    {
      v205 = objc_msgSend(v253, "count");
      v206 = objc_msgSend(v238, "count");
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&buf[4] = v205;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = v206;
      _os_log_impl((void *)&_mh_execute_header, v204, OS_LOG_TYPE_DEFAULT, "Beginning upload for %d records, deleting %d records", buf, 0xEu);
    }

    v276 = 0u;
    v277 = 0u;
    v274 = 0u;
    v275 = 0u;
    v207 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v253, "allKeys"));
    v208 = objc_msgSend(v207, "countByEnumeratingWithState:objects:count:", &v274, v299, 16);
    if (v208)
    {
      v209 = *(_QWORD *)v275;
      do
      {
        for (k = 0; k != v208; k = (char *)k + 1)
        {
          if (*(_QWORD *)v275 != v209)
            objc_enumerationMutation(v207);
          v211 = *(void **)(*((_QWORD *)&v274 + 1) + 8 * (_QWORD)k);
          v212 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v211, "zoneID"));
          v213 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v212, "zoneName"));
          v214 = sub_10000BDF4(CFSTR("ckksoutgoing"), v213);
          v215 = objc_claimAutoreleasedReturnValue(v214);

          if (os_log_type_enabled(v215, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 138412290;
            *(_QWORD *)&buf[4] = v211;
            _os_log_debug_impl((void *)&_mh_execute_header, v215, OS_LOG_TYPE_DEBUG, "Record to save: %@", buf, 0xCu);
          }

        }
        v208 = objc_msgSend(v207, "countByEnumeratingWithState:objects:count:", &v274, v299, 16);
      }
      while (v208);
    }

    v272 = 0u;
    v273 = 0u;
    v270 = 0u;
    v271 = 0u;
    v216 = v238;
    v217 = objc_msgSend(v216, "countByEnumeratingWithState:objects:count:", &v270, v298, 16);
    if (v217)
    {
      v218 = *(_QWORD *)v271;
      do
      {
        for (m = 0; m != v217; m = (char *)m + 1)
        {
          if (*(_QWORD *)v271 != v218)
            objc_enumerationMutation(v216);
          v220 = *(void **)(*((_QWORD *)&v270 + 1) + 8 * (_QWORD)m);
          v221 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v220, "zoneID"));
          v222 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v221, "zoneName"));
          v223 = sub_10000BDF4(CFSTR("ckksoutgoing"), v222);
          v224 = objc_claimAutoreleasedReturnValue(v223);

          if (os_log_type_enabled(v224, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 138412290;
            *(_QWORD *)&buf[4] = v220;
            _os_log_debug_impl((void *)&_mh_execute_header, v224, OS_LOG_TYPE_DEBUG, "Record to delete: %@", buf, 0xCu);
          }

        }
        v217 = objc_msgSend(v216, "countByEnumeratingWithState:objects:count:", &v270, v298, 16);
      }
      while (v217);
    }

    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    LODWORD(v306) = 0;
    v268[0] = 0;
    v268[1] = v268;
    v268[2] = 0x2020000000;
    v269 = 0;
    v267[0] = _NSConcreteStackBlock;
    v267[1] = 3221225472;
    v267[2] = sub_100083AA4;
    v267[3] = &unk_1002DC4D0;
    v267[4] = buf;
    v267[5] = v268;
    objc_msgSend(v252, "setPerRecordSaveBlock:", v267);
    v256[0] = _NSConcreteStackBlock;
    v256[1] = 3221225472;
    v256[2] = sub_100083CA4;
    v256[3] = &unk_1002DC4F8;
    objc_copyWeak(&v265, (id *)(a1 + 64));
    v256[4] = *(_QWORD *)(a1 + 32);
    v266 = (unint64_t)v233 > 0x63;
    v257 = v253;
    v258 = v216;
    v259 = v245;
    v225 = v250;
    v260 = v225;
    v226 = v237;
    v261 = v226;
    v262 = *(id *)(a1 + 48);
    v263 = v268;
    v264 = buf;
    objc_msgSend(v252, "setModifyRecordsCompletionBlock:", v256);
    objc_msgSend(*(id *)(a1 + 40), "dependOnBeforeGroupFinished:", v252);
    v227 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
    v228 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v227, "ckdatabase"));
    objc_msgSend(v228, "addOperation:", v252);

    objc_destroyWeak(&v265);
    _Block_object_dispose(v268, 8);
    _Block_object_dispose(buf, 8);

  }
  else
  {
    v164 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v165 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v164, "zoneName"));
    v166 = sub_10000BDF4(CFSTR("ckksoutgoing"), v165);
    v167 = objc_claimAutoreleasedReturnValue(v166);

    if (os_log_type_enabled(v167, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v167, OS_LOG_TYPE_DEBUG, "Nothing in outgoing queue to process", buf, 2u);
    }

    v168 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
    v169 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v168, "currentOutgoingQueueOperationGroup"));

    if (v169)
    {
      v170 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
      v171 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v170, "zoneName"));
      v172 = sub_10000BDF4(CFSTR("ckksoutgoing"), v171);
      v173 = objc_claimAutoreleasedReturnValue(v172);

      if (os_log_type_enabled(v173, OS_LOG_TYPE_DEBUG))
      {
        v231 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
        v232 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v231, "currentOutgoingQueueOperationGroup"));
        *(_DWORD *)buf = 138412290;
        *(_QWORD *)&buf[4] = v232;
        _os_log_debug_impl((void *)&_mh_execute_header, v173, OS_LOG_TYPE_DEBUG, "End of operation group: %@", buf, 0xCu);

      }
      v174 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
      objc_msgSend(v174, "setCurrentOutgoingQueueOperationGroup:", 0);

    }
    v175 = *(void **)(a1 + 48);
    v303[0] = CFSTR("itemsToAdd");
    v303[1] = CFSTR("itemsToDelete");
    v304[0] = &off_10030A340;
    v304[1] = &off_10030A340;
    v303[2] = CFSTR("itemsToModify");
    v303[3] = CFSTR("errorItemsProcessed");
    v304[2] = &off_10030A340;
    v304[3] = &off_10030A340;
    v303[4] = CFSTR("successfulItemsProcessed");
    v304[4] = &off_10030A340;
    v176 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v304, v303, 5));
    objc_msgSend(v175, "addMetrics:", v176);

    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", *(_QWORD *)(a1 + 48), 1, 0);
    v177 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "intendedState"));
    objc_msgSend(*(id *)(a1 + 40), "setNextState:", v177);

  }
  v24 = 1;
LABEL_128:

LABEL_129:
  return v24;
}

void sub_100083A58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
  id *v53;

  objc_destroyWeak(v53);
  _Block_object_dispose(&a53, 8);
  _Block_object_dispose(&STACK[0x4E0], 8);
  _Unwind_Resume(a1);
}

void sub_100083AA4(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  void *v10;
  void *v11;
  id v12;
  NSObject *v13;
  void *v14;
  void *v15;
  id v16;
  void *v17;
  void *v18;
  int v19;
  id v20;
  __int16 v21;
  id v22;

  v7 = a2;
  v8 = a3;
  v9 = a4;
  if (v9)
  {
    ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "zoneID"));
    v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "zoneName"));
    v12 = sub_10000BDF4(CFSTR("ckksoutgoing"), v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);

    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v19 = 138412546;
      v20 = v9;
      v21 = 2112;
      v22 = v7;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "error on row: %@ %@", (uint8_t *)&v19, 0x16u);
    }
  }
  else
  {
    ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "zoneID"));
    v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "zoneName"));
    v16 = sub_10000BDF4(CFSTR("ckksoutgoing"), v15);
    v13 = objc_claimAutoreleasedReturnValue(v16);

    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "recordName"));
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "recordChangeTag"));
      v19 = 138412546;
      v20 = v17;
      v21 = 2112;
      v22 = v18;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Record upload successful for %@ (%@)", (uint8_t *)&v19, 0x16u);

    }
  }

}

void sub_100083CA4(uint64_t a1, void *a2, void *a3, void *a4)
{
  id *v7;
  id v8;
  id v9;
  id v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  id WeakRetained;
  _QWORD v24[5];
  _QWORD v25[5];
  _QWORD v26[3];
  _QWORD v27[3];

  v7 = (id *)(a1 + 104);
  v8 = a4;
  v9 = a3;
  v10 = a2;
  WeakRetained = objc_loadWeakRetained(v7);
  objc_msgSend(WeakRetained, "modifyRecordsCompleted:fullUpload:recordsToSave:recordIDsToDelete:recordIDsModified:modifyComplete:savedRecords:deletedRecordIDs:ckerror:", *(_QWORD *)(a1 + 32), *(unsigned __int8 *)(a1 + 112), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), v10, v9, v8);

  v11 = *(void **)(a1 + 72);
  v26[0] = CFSTR("itemsToAdd");
  v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(*(id *)(a1 + 40), "count")));
  v27[0] = v12;
  v26[1] = CFSTR("itemsToDelete");
  v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(*(id *)(a1 + 48), "count")));
  v27[1] = v13;
  v26[2] = CFSTR("itemsToModify");
  v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(*(id *)(a1 + 56), "count")));
  v27[2] = v14;
  v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v27, v26, 3));
  objc_msgSend(v11, "addMetrics:", v15);

  +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", *(_QWORD *)(a1 + 72), v8 == 0, v8);
  v16 = *(void **)(a1 + 80);
  v24[0] = CFSTR("itemsToAdd");
  v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(*(id *)(a1 + 40), "count")));
  v25[0] = v17;
  v24[1] = CFSTR("itemsToDelete");
  v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(*(id *)(a1 + 48), "count")));
  v25[1] = v18;
  v24[2] = CFSTR("itemsToModify");
  v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(*(id *)(a1 + 56), "count")));
  v25[2] = v19;
  v24[3] = CFSTR("errorItemsProcessed");
  v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 8) + 24)));
  v25[3] = v20;
  v24[4] = CFSTR("successfulItemsProcessed");
  v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 8) + 24)));
  v25[4] = v21;
  v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v25, v24, 5));
  objc_msgSend(v16, "addMetrics:", v22);

  +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", *(_QWORD *)(a1 + 80), v8 == 0, v8);
}

void sub_100084964(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  id *v15;

  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100084A90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100084C20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100084E3C(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  id v11;
  id v12;
  id v13;
  id v14;
  id v15;
  id WeakRetained;
  void *v17;
  const void *v18;
  NSObject *v19;
  void *v20;
  const void *v21;
  NSObject *v22;
  void *v23;
  void *v24;
  id v25;
  const void *v26;
  NSObject *v27;
  void *v28;
  const void *v29;
  NSObject *v30;
  void *v31;
  id v32;
  _QWORD v33[4];
  id v34;
  id v35;
  id v36;
  uint8_t buf[4];
  id v38;
  __int16 v39;
  id v40;

  v11 = a2;
  v12 = a3;
  v13 = a4;
  v14 = a5;
  v15 = a6;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v17 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v17, "logResultForEvent:hardFailure:result:", CFSTR("OctagonEventVoucherWithBottle"), 1, v15);

  if (v15)
  {
    v18 = sub_10000EF14("SecError");
    v19 = objc_claimAutoreleasedReturnValue(v18);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v38 = v15;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "octagon: Error preparing voucher using bottle: %@", buf, 0xCu);
    }

    objc_msgSend(WeakRetained, "setError:", v15);
LABEL_16:
    v25 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishedOp"));
    objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v25);
    goto LABEL_17;
  }
  v20 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v20, "recordRecoveredTLKMetrics:tlkRecoveryResults:uniqueTLKsRecoveredEvent:totalSharesRecoveredEvent:totalRecoverableTLKSharesEvent:totalRecoverableTLKsEvent:totalViewsWithSharesEvent:", *(_QWORD *)(a1 + 32), v14, CFSTR("OABottledUniqueTLKsRecoveredCount"), CFSTR("OABottledTotalTLKSharesRecoveredCount"), CFSTR("OABottledTotalTLKSharesCount"), CFSTR("OABottledUniqueTLKsWithSharesCount"), CFSTR("OABottledTLKUniqueViewCount"));

  objc_msgSend(WeakRetained, "setVoucher:", v11);
  objc_msgSend(WeakRetained, "setVoucherSig:", v12);
  if (!objc_msgSend(WeakRetained, "saveVoucher"))
  {
LABEL_13:
    v29 = sub_10000EF14("octagon");
    v30 = objc_claimAutoreleasedReturnValue(v29);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412546;
      v38 = v11;
      v39 = 2112;
      v40 = v12;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "Successfully vouched with a bottle: %@, %@", buf, 0x16u);
    }

    v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "intendedState"));
    objc_msgSend(WeakRetained, "setNextState:", v31);

    goto LABEL_16;
  }
  v21 = sub_10000EF14("octagon");
  v22 = objc_claimAutoreleasedReturnValue(v21);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Saving voucher for later use...", buf, 2u);
  }

  v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
  v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v23, "stateHolder"));
  v33[0] = _NSConcreteStackBlock;
  v33[1] = 3221225472;
  v33[2] = sub_100085238;
  v33[3] = &unk_1002DDD90;
  v34 = v11;
  v35 = v12;
  v36 = v13;
  v32 = 0;
  objc_msgSend(v24, "persistAccountChanges:error:", v33, &v32);
  v25 = v32;

  if (!v25)
  {

    goto LABEL_13;
  }
  v26 = sub_10000EF14("octagon");
  v27 = objc_claimAutoreleasedReturnValue(v26);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    v38 = v25;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "unable to save voucher: %@", buf, 0xCu);
  }

  v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishedOp"));
  objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v28);

LABEL_17:
}

id sub_100085238(_QWORD *a1, void *a2)
{
  id v3;

  v3 = a2;
  objc_msgSend(v3, "setVoucher:", a1[4]);
  objc_msgSend(v3, "setVoucherSignature:", a1[5]);
  objc_msgSend(v3, "setTLKSharesPairedWithVoucher:", a1[6]);
  return v3;
}

void sub_100085280(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id WeakRetained;
  void *v8;
  const void *v9;
  NSObject *v10;
  void *v11;
  id v12;
  id v13;
  id v14;
  uint64_t v15;
  void *i;
  void *v17;
  void *v18;
  unsigned int v19;
  CKKSTLKShareRecord *v20;
  void *v21;
  void *v22;
  CKKSTLKShareRecord *v23;
  void *v24;
  id v25;
  void *v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint8_t v31[128];
  uint8_t buf[4];
  id v33;

  v5 = a2;
  v6 = a3;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v8 = WeakRetained;
  if (v6)
  {
    v9 = sub_10000EF14("SecError");
    v10 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v33 = v6;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "octagon: Error fetching TLKShares to recover: %@", buf, 0xCu);
    }

    objc_msgSend(v8, "setError:", v6);
    v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "finishedOp"));
    objc_msgSend(v8, "runBeforeGroupFinished:", v11);
  }
  else
  {
    v26 = WeakRetained;
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
    v27 = 0u;
    v28 = 0u;
    v29 = 0u;
    v30 = 0u;
    v25 = v5;
    v12 = v5;
    v13 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v27, v31, 16);
    if (v13)
    {
      v14 = v13;
      v15 = *(_QWORD *)v28;
      do
      {
        for (i = 0; i != v14; i = (char *)i + 1)
        {
          if (*(_QWORD *)v28 != v15)
            objc_enumerationMutation(v12);
          v17 = *(void **)(*((_QWORD *)&v27 + 1) + 8 * (_QWORD)i);
          v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "recordType"));
          v19 = objc_msgSend(v18, "isEqual:", CFSTR("tlkshare"));

          if (v19)
          {
            v20 = [CKKSTLKShareRecord alloc];
            v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "deps"));
            v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "contextID"));
            v23 = -[CKKSCKRecordHolder initWithCKRecord:contextID:](v20, "initWithCKRecord:contextID:", v17, v22);

            v24 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSTLKShareRecord share](v23, "share"));
            objc_msgSend(v11, "addObject:", v24);

          }
        }
        v14 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v27, v31, 16);
      }
      while (v14);
    }

    v8 = v26;
    objc_msgSend(v26, "proceedWithFilteredTLKShares:", v11);
    v6 = 0;
    v5 = v25;
  }

}

void sub_1000854F8(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v9;
  id v10;
  id v11;
  id WeakRetained;
  void *v13;
  const void *v14;
  NSObject *v15;
  void *v16;
  void *v17;
  void *v18;
  const void *v19;
  NSObject *v20;
  void *v21;
  int v22;
  id v23;
  __int16 v24;
  id v25;

  v9 = a2;
  v10 = a3;
  v11 = a5;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v13 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v13, "logResultForEvent:hardFailure:result:", CFSTR("OctagonEventPreflightVouchWithBottle"), 1, v11);

  if (!v9 || v11)
  {
    v19 = sub_10000EF14("SecError");
    v20 = objc_claimAutoreleasedReturnValue(v19);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      v22 = 138412290;
      v23 = v11;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "octagon: Error preflighting voucher using bottle: %@", (uint8_t *)&v22, 0xCu);
    }

    objc_msgSend(WeakRetained, "setError:", v11);
    v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishedOp"));
    objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v21);

  }
  else
  {
    v14 = sub_10000EF14("octagon");
    v15 = objc_claimAutoreleasedReturnValue(v14);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "bottleID"));
      v22 = 138412546;
      v23 = v16;
      v24 = 2112;
      v25 = v9;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Bottle %@ is for peerID %@", (uint8_t *)&v22, 0x16u);

    }
    v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "ckks"));
    objc_msgSend(v18, "setCurrentSyncingPolicy:", v10);

    objc_msgSend(WeakRetained, "proceedWithPeerID:refetchWasNeeded:", v9, a4);
  }

}

void sub_100085A14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  id *v15;

  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100085E54(uint64_t a1)
{
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  objc_msgSend(WeakRetained, "proceedAfterFetch");

}

BOOL sub_1000887A4(uint64_t a1, uint64_t a2)
{
  char v4;
  unsigned int v5;
  unint64_t v6;
  unint64_t v7;
  char v8;
  int v10;
  uint64_t String;
  uint64_t v13;
  SECC2MPGenericEventMetricValue *v14;
  _QWORD v16[2];

  if (*(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    while (1)
    {
      if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error))
        return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
      v4 = 0;
      v5 = 0;
      v6 = 0;
      while (1)
      {
        v7 = *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v7 == -1 || v7 >= *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__length))
          break;
        v8 = *(_BYTE *)(*(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
        *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
        v6 |= (unint64_t)(v8 & 0x7F) << v4;
        if ((v8 & 0x80) == 0)
          goto LABEL_11;
        v4 += 7;
        if (v5++ >= 9)
        {
          v6 = 0;
          v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
          goto LABEL_13;
        }
      }
      *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
      v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
      if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error))
        v6 = 0;
LABEL_13:
      if (v10 || (v6 & 7) == 4)
        return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
      if ((v6 >> 3) == 201)
        break;
      if ((v6 >> 3) == 101)
      {
        String = PBReaderReadString(a2);
        v13 = objc_claimAutoreleasedReturnValue(String);
        v14 = *(SECC2MPGenericEventMetricValue **)(a1 + 8);
        *(_QWORD *)(a1 + 8) = v13;
LABEL_23:

        goto LABEL_25;
      }
      if ((PBReaderSkipValueWithTag(a2) & 1) == 0)
        return 0;
LABEL_25:
      if (*(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__length))
        return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    v14 = objc_alloc_init(SECC2MPGenericEventMetricValue);
    objc_storeStrong((id *)(a1 + 16), v14);
    v16[0] = 0xAAAAAAAAAAAAAAAALL;
    v16[1] = 0xAAAAAAAAAAAAAAAALL;
    if (!PBReaderPlaceMark(a2, v16) || (sub_10008BEA4((uint64_t)v14, a2) & 1) == 0)
    {

      return 0;
    }
    PBReaderRecallMark(a2, v16);
    goto LABEL_23;
  }
  return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

void sub_10008A148(id a1)
{
  void *v1;
  EscrowRequestXPCServer *v2;
  void *v3;
  id v4;
  void *v5;

  v1 = objc_autoreleasePoolPush();
  v2 = objc_opt_new(EscrowRequestXPCServer);
  v3 = (void *)qword_100340F58;
  qword_100340F58 = (uint64_t)v2;

  v4 = objc_msgSend(objc_alloc((Class)NSXPCListener), "initWithMachServiceName:", CFSTR("com.apple.security.escrow-update"));
  v5 = (void *)qword_100340F60;
  qword_100340F60 = (uint64_t)v4;

  objc_msgSend((id)qword_100340F60, "setDelegate:", qword_100340F58);
  objc_msgSend((id)qword_100340F60, "resume");
  objc_autoreleasePoolPop(v1);
}

void sub_10008A7D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id *location, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,id a26)
{
  objc_destroyWeak(location);
  objc_destroyWeak(&a26);
  _Unwind_Resume(a1);
}

void sub_10008AAFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id *location)
{
  uint64_t v22;

  objc_destroyWeak(location);
  objc_destroyWeak((id *)(v22 - 96));
  _Unwind_Resume(a1);
}

void sub_10008AC70(uint64_t a1, int a2, void *a3)
{
  __CFString *v5;
  id WeakRetained;
  void *v7;
  const void *v8;
  NSObject *v9;
  _BOOL4 v10;
  const __CFString *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  void *v15;
  int v16;
  const __CFString *v17;
  __int16 v18;
  uint64_t v19;

  v5 = a3;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (objc_msgSend(WeakRetained, "logForUpgrade"))
  {
    v7 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
    objc_msgSend(v7, "logResultForEvent:hardFailure:result:", CFSTR("OctagonEventUpgradeSetAllowList"), 1, v5);

  }
  v8 = sub_10000EF14("octagon-authkit");
  v9 = objc_claimAutoreleasedReturnValue(v8);
  v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (v10)
    {
      v16 = 138412290;
      v17 = v5;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Unable to save machineID allow-list: %@", (uint8_t *)&v16, 0xCu);
    }

    objc_msgSend(WeakRetained, "setError:", v5);
  }
  else
  {
    if (v10)
    {
      v11 = CFSTR("no");
      v12 = *(_QWORD *)(a1 + 32);
      if (a2)
        v11 = CFSTR("some");
      v16 = 138412546;
      v17 = v11;
      v18 = 2112;
      v19 = v12;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Successfully saved machineID allow-list (%@ change), version = %@", (uint8_t *)&v16, 0x16u);
    }

    if (a2)
      v13 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "stateIfListUpdates"));
    else
      v13 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "intendedState"));
    v14 = (void *)v13;
    objc_msgSend(WeakRetained, "setNextState:", v13);

  }
  v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishedOp"));
  objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v15);

}

void sub_10008AE44(uint64_t a1)
{
  id WeakRetained;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  unsigned int v8;
  const void *v9;
  NSObject *v10;
  _BOOL4 v11;
  OctagonPendingFlag *v12;
  OctagonPendingFlag *v13;
  void *v14;
  OctagonPendingFlag *v15;
  const void *v16;
  NSObject *v17;
  void *v18;
  const void *v19;
  NSObject *v20;
  uint64_t v21;
  OctagonPendingFlag *v22;
  uint64_t v23;
  void *v24;
  int v25;
  OctagonPendingFlag *v26;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));

  if (v3)
  {
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "retryFlag"));

    if (!v4)
    {
      v19 = sub_10000EF14("SecError");
      v20 = objc_claimAutoreleasedReturnValue(v19);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v25) = 0;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "octagon-authkit: Received an error updating the trusted device list operation, but no retry flag present.", (uint8_t *)&v25, 2u);
      }

      v21 = *(_QWORD *)(a1 + 32);
      v15 = (OctagonPendingFlag *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
      +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", v21, 0, v15);
      goto LABEL_19;
    }
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "lockStateTracker"));
    v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
    v8 = objc_msgSend(v6, "isLockedError:", v7);

    v9 = sub_10000EF14("octagon-authkit");
    v10 = objc_claimAutoreleasedReturnValue(v9);
    v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
    if (v8)
    {
      if (v11)
      {
        v12 = (OctagonPendingFlag *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
        v25 = 138412290;
        v26 = v12;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Setting the allowed device list failed due to lock state: %@", (uint8_t *)&v25, 0xCu);

      }
      objc_msgSend(WeakRetained, "setNextState:", CFSTR("WaitForUnlock"));
      v13 = [OctagonPendingFlag alloc];
      v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "retryFlag"));
      v15 = -[OctagonPendingFlag initWithFlag:conditions:](v13, "initWithFlag:conditions:", v14, 1);

      if (!v15)
        goto LABEL_18;
      v16 = sub_10000EF14("octagon-authkit");
      v17 = objc_claimAutoreleasedReturnValue(v16);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        v25 = 138412290;
        v26 = v15;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Machine ID list error is not fatal: requesting retry: %@", (uint8_t *)&v25, 0xCu);
      }

      v10 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
      v18 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject flagHandler](v10, "flagHandler"));
      objc_msgSend(v18, "handlePendingFlag:", v15);

    }
    else
    {
      if (v11)
      {
        v22 = (OctagonPendingFlag *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
        v25 = 138412290;
        v26 = v22;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Error is currently unknown, will not retry: %@", (uint8_t *)&v25, 0xCu);

      }
      v15 = 0;
    }

LABEL_18:
    v23 = *(_QWORD *)(a1 + 32);
    v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", v23, 0, v24);

LABEL_19:
    goto LABEL_20;
  }
  +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", *(_QWORD *)(a1 + 32), 1, 0);
LABEL_20:

}

void sub_10008B190(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8, void *a9, void *a10)
{
  id v17;
  id v18;
  id v19;
  id v20;
  id v21;
  id v22;
  id v23;
  id v24;
  id WeakRetained;
  void *v26;
  id v27;
  const void *v28;
  NSObject *v29;
  id v30;
  id v31;
  id v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  id v39;
  id v40;
  id v41;
  id v42;
  void *v43;
  const void *v44;
  NSObject *v45;
  void *v46;
  void *v47;
  uint64_t v48;
  id v49;
  id v50;
  id v51;
  id v52;
  id v53;
  _QWORD v54[5];
  uint8_t buf[4];
  id v56;

  v17 = a2;
  v53 = a3;
  v18 = a4;
  v19 = a5;
  v20 = a6;
  v21 = a7;
  v22 = a8;
  v23 = a9;
  v24 = a10;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v26 = WeakRetained;
  if (v24)
  {
    v50 = v21;
    v51 = v23;
    v49 = v22;
    v27 = v17;
    v28 = sub_10000EF14("SecError");
    v29 = objc_claimAutoreleasedReturnValue(v28);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v56 = v24;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "octagon-authkit: Unable to fetch machine ID list: %@", buf, 0xCu);
    }
    v30 = v20;
    v31 = v19;
    v32 = v18;

    if (objc_msgSend(v26, "logForUpgrade"))
    {
      v33 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
      objc_msgSend(v33, "logRecoverableError:forEvent:withAttributes:", v24, CFSTR("OctagonEventUpgradeFetchDeviceIDs"), 0);

    }
    objc_msgSend(v26, "setError:", v24);
    v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "deps"));
    v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v34, "cuttlefishXPCWrapper"));
    v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "deps"));
    v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v36, "activeAccount"));
    v54[0] = _NSConcreteStackBlock;
    v54[1] = 3221225472;
    v54[2] = sub_10008B53C;
    v54[3] = &unk_1002DD798;
    v54[4] = v26;
    objc_msgSend(v35, "markTrustedDeviceListFetchFailed:reply:", v37, v54);

    v18 = v32;
    v19 = v31;
    v17 = v27;
    v20 = v30;
    v22 = v49;
    v21 = v50;
    v23 = v51;
    v38 = v53;
  }
  else if (v17)
  {
    if (objc_msgSend(WeakRetained, "logForUpgrade"))
    {
      v52 = v23;
      v39 = v20;
      v40 = v17;
      v41 = v19;
      v42 = v18;
      v43 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
      objc_msgSend(v43, "logSuccessForEventNamed:", CFSTR("OctagonEventUpgradeFetchDeviceIDs"));

      v18 = v42;
      v19 = v41;
      v17 = v40;
      v20 = v39;
      v23 = v52;
    }
    LOBYTE(v48) = *(_BYTE *)(a1 + 40);
    v38 = v53;
    objc_msgSend(v26, "afterAuthKitFetch:userInitiatedRemovals:evictedRemovals:unknownReasonRemovals:trustedDeviceHash:deletedDeviceHash:trustedDevicesUpdateTimestamp:accountIsDemo:version:", v17, v53, v18, v19, v21, v22, v23, v48, v20);
  }
  else
  {
    v44 = sub_10000EF14("SecError");
    v45 = objc_claimAutoreleasedReturnValue(v44);
    if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "octagon-authkit: empty machine id list", buf, 2u);
    }

    if (objc_msgSend(v26, "logForUpgrade"))
    {
      v46 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
      objc_msgSend(v46, "logRecoverableError:forEvent:withAttributes:", 0, CFSTR("OctagonEventUpgradeFetchDeviceIDs"), 0);

    }
    objc_msgSend(v26, "setError:", 0);
    v47 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "finishedOp"));
    objc_msgSend(v26, "runBeforeGroupFinished:", v47);

    v38 = v53;
  }

}

void sub_10008B53C(uint64_t a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  _BOOL4 v6;
  void *v7;
  void *v8;
  int v9;
  id v10;

  v3 = a2;
  v4 = sub_10000EF14("octagon-authkit");
  v5 = objc_claimAutoreleasedReturnValue(v4);
  v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v6)
    {
      v9 = 138412290;
      v10 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Unable to mark machineID list as out of date: %@", (uint8_t *)&v9, 0xCu);
    }

    objc_msgSend(*(id *)(a1 + 32), "setError:", v3);
  }
  else
  {
    if (v6)
    {
      LOWORD(v9) = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Successfully marked machineID list as out of date", (uint8_t *)&v9, 2u);
    }

  }
  v7 = *(void **)(a1 + 32);
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "finishedOp"));
  objc_msgSend(v7, "runBeforeGroupFinished:", v8);

}

uint64_t sub_10008BEA4(uint64_t a1, uint64_t a2)
{
  char v4;
  unsigned int v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  char v9;
  BOOL v10;
  int v11;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  SECC2MPError *v16;
  uint64_t String;
  uint64_t v18;
  void *v19;
  char v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char v25;
  uint64_t result;
  _QWORD v27[2];

  while (*(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error))
      return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    v4 = 0;
    v5 = 0;
    v6 = 0;
    while (1)
    {
      v7 = *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos);
      v8 = v7 + 1;
      if (v7 == -1 || v8 > *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__length))
        break;
      v9 = *(_BYTE *)(*(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos) = v8;
      v6 |= (unint64_t)(v9 & 0x7F) << v4;
      if ((v9 & 0x80) == 0)
        goto LABEL_11;
      v4 += 7;
      v10 = v5++ >= 9;
      if (v10)
      {
        v6 = 0;
        v11 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }
    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    v11 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error))
      v6 = 0;
LABEL_13:
    if (v11 || (v6 & 7) == 4)
      return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    v13 = v6 >> 3;
    if ((int)(v6 >> 3) > 102)
    {
      if ((_DWORD)v13 == 103)
      {
        v20 = 0;
        v21 = 0;
        v22 = 0;
        *(_BYTE *)(a1 + 40) |= 1u;
        while (1)
        {
          v23 = *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos);
          v24 = v23 + 1;
          if (v23 == -1 || v24 > *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__length))
            break;
          v25 = *(_BYTE *)(*(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v23);
          *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos) = v24;
          v22 |= (unint64_t)(v25 & 0x7F) << v20;
          if ((v25 & 0x80) == 0)
            goto LABEL_39;
          v20 += 7;
          v10 = v21++ >= 9;
          if (v10)
          {
            v22 = 0;
            goto LABEL_41;
          }
        }
        *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_39:
        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error))
          v22 = 0;
LABEL_41:
        *(_QWORD *)(a1 + 8) = v22;
      }
      else
      {
        if ((_DWORD)v13 != 201)
        {
LABEL_36:
          result = PBReaderSkipValueWithTag(a2);
          if (!(_DWORD)result)
            return result;
          continue;
        }
        v16 = objc_alloc_init(SECC2MPError);
        objc_storeStrong((id *)(a1 + 24), v16);
        v27[0] = 0xAAAAAAAAAAAAAAAALL;
        v27[1] = 0xAAAAAAAAAAAAAAAALL;
        if (!PBReaderPlaceMark(a2, v27) || (sub_100145AA8((uint64_t)v16, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark(a2, v27);

      }
    }
    else if ((_DWORD)v13 == 101)
    {
      String = PBReaderReadString(a2);
      v18 = objc_claimAutoreleasedReturnValue(String);
      v19 = *(void **)(a1 + 32);
      *(_QWORD *)(a1 + 32) = v18;

    }
    else
    {
      if ((_DWORD)v13 != 102)
        goto LABEL_36;
      *(_BYTE *)(a1 + 40) |= 2u;
      v14 = *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v14 <= 0xFFFFFFFFFFFFFFF7 && v14 + 8 <= *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__length))
      {
        v15 = *(_QWORD *)(*(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v14);
        *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos) = v14 + 8;
      }
      else
      {
        *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
        v15 = 0;
      }
      *(_QWORD *)(a1 + 16) = v15;
    }
  }
  return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

BOOL sub_10008E290(uint64_t a1)
{
  double v2;

  objc_msgSend(*(id *)(a1 + 32), "timeIntervalSinceDate:");
  return v2 > (double)*(int *)(a1 + 40);
}

void sub_10008E2C4(id a1)
{
  NSObject *v1;
  void *v2;
  NSObject *v3;
  _QWORD *context;

  v1 = sub_1000327DC("ratelimiterdisabledlogevent", 60);
  v2 = (void *)qword_100340F70;
  qword_100340F70 = (uint64_t)v1;

  v3 = qword_100340F70;
  context = dispatch_get_context((dispatch_object_t)qword_100340F70);
  context[2] = _Block_copy(&stru_1002DC620);
  dispatch_activate(v3);
}

void sub_10008E320(id a1)
{
  id v1;
  NSObject *v2;
  uint8_t v3[16];

  v1 = sub_10000BDF4(CFSTR("ratelimit"), 0);
  v2 = objc_claimAutoreleasedReturnValue(v1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Rate limiting disabled, returning automatic all-clear", v3, 2u);
  }

}

void sub_10008EA8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,id location,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  id *v37;
  uint64_t v38;

  objc_destroyWeak(v37);
  _Block_object_dispose((const void *)(v38 - 192), 8);
  objc_destroyWeak(&location);
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a37, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10008ECC0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_10008ECD0(uint64_t a1)
{

}

void sub_10008ECD8(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  id v13;
  NSObject *v14;
  id v15;
  void *v16;
  id v17;
  id v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  id v23;
  void *v24;
  id obj;
  uint64_t v26;
  id v27;
  uint8_t buf[16];
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  _BYTE v33[128];

  v29 = 0u;
  v30 = 0u;
  v31 = 0u;
  v32 = 0u;
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "deps"));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "views"));

  obj = v3;
  v27 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v29, v33, 16);
  if (v27)
  {
    v26 = *(_QWORD *)v30;
    do
    {
      v4 = 0;
      do
      {
        if (*(_QWORD *)v30 != v26)
          objc_enumerationMutation(obj);
        v5 = *(void **)(*((_QWORD *)&v29 + 1) + 8 * (_QWORD)v4);
        v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "deps"));
        v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "contextID"));
        v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "zoneID"));
        v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "zoneName"));
        v10 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSZoneStateEntry contextID:zoneName:](CKKSZoneStateEntry, "contextID:zoneName:", v7, v9));

        if (objc_msgSend(v10, "ckzonecreated") && objc_msgSend(v10, "ckzonesubscribed"))
        {
          v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "zoneID"));
          v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "zoneName"));
          v13 = sub_10000BDF4(CFSTR("ckkskey"), v12);
          v14 = objc_claimAutoreleasedReturnValue(v13);

          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)buf = 0;
            _os_log_debug_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "Zone is already created and subscribed", buf, 2u);
          }

          objc_msgSend(v5, "setViewKeyHierarchyState:", CFSTR("initialized"));
        }
        else
        {
          v15 = objc_alloc((Class)CKRecordZone);
          v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "zoneID"));
          v17 = objc_msgSend(v15, "initWithZoneID:", v16);

          objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), "addObject:", v17);
          v18 = objc_alloc((Class)CKRecordZoneSubscription);
          v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "zoneID"));
          v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "zoneID"));
          v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "zoneName"));
          v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(CFSTR("zone:"), "stringByAppendingString:", v21));
          v23 = objc_msgSend(v18, "initWithZoneID:subscriptionID:", v19, v22);

          objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40), "addObject:", v23);
          objc_msgSend(v5, "setViewKeyHierarchyState:", CFSTR("initializing"));
          v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "launch"));
          objc_msgSend(v24, "addEvent:", CFSTR("zone-create"));

        }
        v4 = (char *)v4 + 1;
      }
      while (v27 != v4);
      v27 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v29, v33, 16);
    }
    while (v27);
  }

}

void sub_10008F020(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  id WeakRetained;
  id v11;
  NSObject *v12;
  void *v13;
  void *v14;
  void *v15;
  unsigned int v16;
  id v17;
  NSObject *v18;
  id v19;
  NSObject *v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  NSObject *v25;
  void *v26;
  void *v27;
  void *v28;
  id v29;
  uint64_t v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  _QWORD v37[4];
  id v38;
  uint64_t v39;
  id v40;
  uint8_t buf[4];
  id v42;

  v7 = a2;
  v8 = a3;
  v9 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  if (v9)
  {
    v11 = sub_10000BDF4(CFSTR("ckkszonemodifier"), 0);
    v12 = objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      v42 = v9;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Zone modification failed: %@", buf, 0xCu);
    }

    v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    objc_msgSend(v13, "inspectErrorForRetryAfter:", v9);

    v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "reachabilityTracker"));
    v16 = objc_msgSend(v15, "isNetworkError:", v9);

    if (v16)
    {
      v17 = sub_10000BDF4(CFSTR("ckkszonemodifier"), 0);
      v18 = objc_claimAutoreleasedReturnValue(v17);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Waiting for reachability before issuing zone creation", buf, 2u);
      }

      objc_msgSend(WeakRetained, "setNetworkError:", 1);
    }
  }
  v19 = sub_10000BDF4(CFSTR("ckkszonemodifier"), 0);
  v20 = objc_claimAutoreleasedReturnValue(v19);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    v42 = v7;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "created zones: %@", buf, 0xCu);
  }

  objc_msgSend(WeakRetained, "setZoneModificationError:", v9);
  v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "zoneModificationError"));

  if (v21)
  {
    v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "operationQueue"));
    v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "setResultStateOperation"));
    objc_msgSend(v22, "addOperation:", v23);

  }
  else
  {
    v24 = sub_10000BDF4(CFSTR("ckkszonemodifier"), 0);
    v25 = objc_claimAutoreleasedReturnValue(v24);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      v26 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
      *(_DWORD *)buf = 138412290;
      v42 = v26;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Attempting to subscribe to zones %@", buf, 0xCu);
    }

    v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v27, "cloudKitClassDependencies"));
    v29 = objc_msgSend(objc_msgSend(objc_msgSend(v28, "modifySubscriptionsOperationClass"), "alloc"), "initWithSubscriptionsToSave:subscriptionIDsToDelete:", *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), 0);
    v30 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v31 = *(void **)(v30 + 40);
    *(_QWORD *)(v30 + 40) = v29;

    v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), "configuration"));
    objc_msgSend(v32, "setIsCloudKitSupportOperation:", 1);

    v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v33, "ckdatabase"));
    objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), "setDatabase:", v34);

    objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), "setName:", CFSTR("zone-subscription-operation"));
    objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), "setQualityOfService:", 25);
    v37[0] = _NSConcreteStackBlock;
    v37[1] = 3221225472;
    v37[2] = sub_10008F674;
    v37[3] = &unk_1002DC670;
    objc_copyWeak(&v40, (id *)(a1 + 56));
    v39 = *(_QWORD *)(a1 + 48);
    v38 = v7;
    objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), "setModifySubscriptionsCompletionBlock:", v37);
    v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v35, "ckdatabase"));
    objc_msgSend(v36, "addOperation:", *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40));

    objc_destroyWeak(&v40);
  }

}

void sub_10008F484(_Unwind_Exception *a1)
{
  id *v1;

  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_10008F4A4(uint64_t a1)
{
  id WeakRetained;
  id v3;
  NSObject *v4;
  uint64_t v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  uint64_t v10;
  uint8_t v11[16];

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v3 = sub_10000BDF4(CFSTR("ckkszonemodifier"), 0);
  v4 = objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v11 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Finished creating & subscribing to zones", v11, 2u);
  }

  if (objc_msgSend(WeakRetained, "networkError"))
  {
    objc_msgSend(WeakRetained, "setNextState:", CFSTR("zone_creation_failed_due_to_network_error"));
    v5 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "zoneModificationError"));
    if (v5)
    {
      v6 = (void *)v5;
      objc_msgSend(WeakRetained, "setError:", v5);
    }
    else
    {
      v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "zoneSubscriptionError"));
      objc_msgSend(WeakRetained, "setError:", v8);

      v6 = 0;
    }
  }
  else if (objc_msgSend(WeakRetained, "allZoneCreationsSucceeded")
         && (objc_msgSend(WeakRetained, "allZoneSubscriptionsSucceeded") & 1) != 0)
  {
    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", *(_QWORD *)(a1 + 32), 1, 0);
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "intendedState"));
    objc_msgSend(WeakRetained, "setNextState:", v6);
  }
  else
  {
    objc_msgSend(WeakRetained, "setNextState:", CFSTR("zonecreationfailed"));
    v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "zoneModificationError"));
    if (v7)
    {
      objc_msgSend(WeakRetained, "setError:", v7);
    }
    else
    {
      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "zoneSubscriptionError"));
      objc_msgSend(WeakRetained, "setError:", v9);

    }
    v10 = *(_QWORD *)(a1 + 32);
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", v10, 0, v6);
  }

}

void sub_10008F674(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v6;
  id v7;
  id WeakRetained;
  id v9;
  NSObject *v10;
  void *v11;
  void *v12;
  void *v13;
  unsigned int v14;
  id v15;
  NSObject *v16;
  id v17;
  NSObject *v18;
  void *v19;
  void *v20;
  uint64_t v21;
  void *v22;
  id v23;
  id v24;
  void *v25;
  void *v26;
  _QWORD v27[5];
  id v28;
  id v29;
  id v30;
  uint64_t v31;
  uint8_t buf[4];
  id v33;

  v6 = a2;
  v7 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  objc_msgSend(WeakRetained, "setZoneSubscriptionError:", v7);
  if (v7)
  {
    v9 = sub_10000BDF4(CFSTR("ckkszonemodifier"), 0);
    v10 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      v33 = v7;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Couldn't create cloudkit zone subscription; keychain syncing is severely degraded: %@",
        buf,
        0xCu);
    }

    v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    objc_msgSend(v11, "inspectErrorForRetryAfter:", v7);

    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "reachabilityTracker"));
    v14 = objc_msgSend(v13, "isNetworkError:", v7);

    if (v14)
    {
      v15 = sub_10000BDF4(CFSTR("ckkszonemodifier"), 0);
      v16 = objc_claimAutoreleasedReturnValue(v15);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Waiting for reachability before issuing zone subscription", buf, 2u);
      }

      objc_msgSend(WeakRetained, "setNetworkError:", 1);
    }
  }
  v17 = sub_10000BDF4(CFSTR("ckkszonemodifier"), 0);
  v18 = objc_claimAutoreleasedReturnValue(v17);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    v33 = v6;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Successfully subscribed to %@", buf, 0xCu);
  }

  v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
  v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "databaseProvider"));
  v27[0] = _NSConcreteStackBlock;
  v27[1] = 3221225472;
  v27[2] = sub_10008F948;
  v27[3] = &unk_1002E9240;
  v22 = *(void **)(a1 + 32);
  v21 = *(_QWORD *)(a1 + 40);
  v27[4] = WeakRetained;
  v31 = v21;
  v28 = v22;
  v29 = v6;
  v30 = v7;
  v23 = v7;
  v24 = v6;
  objc_msgSend(v20, "dispatchSyncWithSQLTransaction:", v27);

  v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "operationQueue"));
  v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "setResultStateOperation"));
  objc_msgSend(v25, "addOperation:", v26);

}

uint64_t sub_10008F948(id *a1)
{
  id *v1;
  void *v2;
  void *v3;
  void *i;
  void *v5;
  id v6;
  id v7;
  id v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void *v12;
  void *v13;
  unsigned __int8 v14;
  id v15;
  void *v16;
  void *v17;
  id v18;
  NSObject *v19;
  uint64_t v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  id v25;
  void *v26;
  void *v27;
  void *v28;
  id v29;
  NSObject *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  id v35;
  id v36;
  id v37;
  uint64_t v38;
  uint64_t v39;
  void *v40;
  unsigned __int8 v41;
  id v42;
  int v43;
  void *v44;
  id v45;
  void *v46;
  void *v47;
  void *v48;
  void *v49;
  void *v50;
  void *v51;
  id v52;
  void *v53;
  void *v54;
  id v55;
  NSObject *v56;
  void *v57;
  void *v58;
  id v59;
  NSObject *v60;
  void *v61;
  uint64_t v62;
  void *v63;
  void *v64;
  void *v65;
  id v66;
  void *v67;
  void *v68;
  id v69;
  NSObject *v70;
  id v71;
  void *v72;
  void *v73;
  void *v74;
  void *v75;
  void *v76;
  id v77;
  void *v78;
  id v79;
  void *v80;
  void *v81;
  void *v82;
  void *v83;
  id v84;
  void *v85;
  void *v86;
  id v87;
  NSObject *v88;
  id v89;
  id v90;
  void *v91;
  void *v92;
  id v93;
  NSObject *v94;
  void *v95;
  void *v96;
  id obj;
  id v99;
  uint64_t v100;
  id *v101;
  id v102;
  void *v103;
  unsigned int v104;
  id v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  uint8_t buf[4];
  _BYTE v119[20];
  __int16 v120;
  id v121;
  _BYTE v122[128];
  _BYTE v123[128];
  _BYTE v124[128];

  v1 = a1;
  v114 = 0u;
  v115 = 0u;
  v116 = 0u;
  v117 = 0u;
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "deps"));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "views"));

  obj = v3;
  v102 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v114, v124, 16);
  if (v102)
  {
    v100 = *(_QWORD *)v115;
    v101 = v1;
    do
    {
      for (i = 0; i != v102; i = (char *)i + 1)
      {
        if (*(_QWORD *)v115 != v100)
          objc_enumerationMutation(obj);
        v5 = *(void **)(*((_QWORD *)&v114 + 1) + 8 * (_QWORD)i);
        v110 = 0u;
        v111 = 0u;
        v112 = 0u;
        v113 = 0u;
        v6 = *(id *)(*((_QWORD *)v1[8] + 1) + 40);
        v7 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v110, v123, 16);
        if (v7)
        {
          v8 = v7;
          v9 = *(_QWORD *)v111;
LABEL_8:
          v10 = 0;
          while (1)
          {
            if (*(_QWORD *)v111 != v9)
              objc_enumerationMutation(v6);
            v11 = *(void **)(*((_QWORD *)&v110 + 1) + 8 * v10);
            v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "zoneID"));
            v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "zoneID"));
            v14 = objc_msgSend(v12, "isEqual:", v13);

            if ((v14 & 1) != 0)
              break;
            if (v8 == (id)++v10)
            {
              v8 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v110, v123, 16);
              if (v8)
                goto LABEL_8;
              v1 = v101;
              goto LABEL_84;
            }
          }
          v15 = v11;

          v1 = v101;
          if (!v15)
            continue;
          v104 = objc_msgSend(v101[5], "containsObject:", v15);
          v99 = v15;
          if (v104)
          {
            v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "zoneID"));
            v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "zoneName"));
            v18 = sub_10000BDF4(CFSTR("ckkszone"), v17);
            v19 = objc_claimAutoreleasedReturnValue(v18);

            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
            {
              v63 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "zoneID"));
              *(_DWORD *)buf = 138412290;
              *(_QWORD *)v119 = v63;
              _os_log_debug_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "Successfully created '%@'", buf, 0xCu);

            }
            objc_msgSend(v5, "armReadyNotification");
            v103 = 0;
            goto LABEL_30;
          }
          v20 = objc_claimAutoreleasedReturnValue(objc_msgSend(v101[4], "zoneModificationError"));
          if (!v20)
            goto LABEL_24;
          v21 = (void *)v20;
          v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v101[4], "zoneModificationError"));
          v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "domain"));
          if (objc_msgSend(v23, "isEqualToString:", CKErrorDomain))
          {
            v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v101[4], "zoneModificationError"));
            v25 = objc_msgSend(v24, "code");

            if (v25 == (id)2)
            {
              v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v101[4], "zoneModificationError"));
              v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "userInfo"));
              v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "objectForKeyedSubscript:", CKPartialErrorsByItemIDKey));
              v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "zoneID"));
              v103 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v23, "objectForKeyedSubscript:", v26));

              goto LABEL_26;
            }
LABEL_24:
            v103 = 0;
          }
          else
          {
            v103 = 0;
LABEL_26:

          }
          v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "zoneID"));
          v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v27, "zoneName"));
          v29 = sub_10000BDF4(CFSTR("ckkszone"), v28);
          v30 = objc_claimAutoreleasedReturnValue(v29);

          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
          {
            v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "zoneID"));
            *(_DWORD *)buf = 138412546;
            *(_QWORD *)v119 = v31;
            *(_WORD *)&v119[8] = 2112;
            *(_QWORD *)&v119[10] = v103;
            _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Failed to create '%@' with error %@", buf, 0x16u);

          }
LABEL_30:
          v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "zoneID"));
          v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v32, "zoneName"));
          v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(CFSTR("zone:"), "stringByAppendingString:", v33));

          v108 = 0u;
          v109 = 0u;
          v106 = 0u;
          v107 = 0u;
          v35 = v101[6];
          v36 = objc_msgSend(v35, "countByEnumeratingWithState:objects:count:", &v106, v122, 16);
          if (v36)
          {
            v37 = v36;
            v38 = *(_QWORD *)v107;
LABEL_32:
            v39 = 0;
            while (1)
            {
              if (*(_QWORD *)v107 != v38)
                objc_enumerationMutation(v35);
              v40 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((_QWORD *)&v106 + 1) + 8 * v39), "subscriptionID"));
              v41 = objc_msgSend(v40, "isEqual:", v34);

              if ((v41 & 1) != 0)
                break;
              if (v37 == (id)++v39)
              {
                v37 = objc_msgSend(v35, "countByEnumeratingWithState:objects:count:", &v106, v122, 16);
                if (v37)
                  goto LABEL_32;
                goto LABEL_38;
              }
            }

            v42 = v101[7];
            if (!v42)
              goto LABEL_61;
            v43 = 1;
LABEL_42:
            v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v42, "domain"));
            if ((objc_msgSend(v44, "isEqualToString:", CKErrorDomain) & 1) == 0)
              goto LABEL_60;
            v45 = objc_msgSend(v101[7], "code");

            if (v45 != (id)2)
            {
              if (v43)
                goto LABEL_61;
              goto LABEL_54;
            }
            v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v101[7], "userInfo"));
            v47 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v46, "objectForKeyedSubscript:", CKPartialErrorsByItemIDKey));
            v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v47, "objectForKeyedSubscript:", v34));

            v48 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v44, "userInfo"));
            v49 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v48, "objectForKeyedSubscript:", NSUnderlyingErrorKey));

            if (!v44)
              goto LABEL_59;
            v50 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v44, "domain"));
            if (objc_msgSend(v50, "isEqualToString:", CKErrorDomain)
              && objc_msgSend(v44, "code") == (id)15
              && v49)
            {
              v51 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v49, "domain"));
              if ((objc_msgSend(v51, "isEqualToString:", CKErrorDomain) & 1) != 0)
              {
                v52 = objc_msgSend(v49, "code");

                if (v52 == (id)2032)
                {
                  v53 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "zoneID"));
                  v54 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v53, "zoneName"));
                  v55 = sub_10000BDF4(CFSTR("ckks"), v54);
                  v56 = objc_claimAutoreleasedReturnValue(v55);

                  if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
                  {
                    *(_WORD *)buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "zone subscription error appears to say that the zone subscription exists; this is okay!",
                      buf,
                      2u);
                  }

LABEL_61:
                  v64 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "zoneID"));
                  v65 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v64, "zoneName"));
                  v66 = sub_10000BDF4(CFSTR("ckkszone"), v65);
                  v60 = objc_claimAutoreleasedReturnValue(v66);

                  if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
                  {
                    v96 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "zoneID"));
                    *(_DWORD *)buf = 138412290;
                    *(_QWORD *)v119 = v96;
                    _os_log_debug_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEBUG, "Successfully subscribed '%@'", buf, 0xCu);

                  }
                  v62 = 1;
LABEL_64:

                  v67 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "zoneID"));
                  v68 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v67, "zoneName"));
                  v69 = sub_10000BDF4(CFSTR("ckkszone"), v68);
                  v70 = objc_claimAutoreleasedReturnValue(v69);

                  if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
                  {
                    v71 = v101[7];
                    *(_DWORD *)buf = 67109890;
                    *(_DWORD *)v119 = v104;
                    *(_WORD *)&v119[4] = 2112;
                    *(_QWORD *)&v119[6] = v103;
                    *(_WORD *)&v119[14] = 1024;
                    *(_DWORD *)&v119[16] = v62;
                    v120 = 2112;
                    v121 = v71;
                    _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "Zone setup progress: created:%d %@ subscribed:%d %@", buf, 0x22u);
                  }

                  if ((v104 & v62) == 1)
                    objc_msgSend(v5, "setViewKeyHierarchyState:", CFSTR("initialized"));
                  v72 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v101[4], "deps"));
                  v73 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v72, "contextID"));
                  v74 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "zoneID"));
                  v75 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v74, "zoneName"));
                  v76 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSZoneStateEntry contextID:zoneName:](CKKSZoneStateEntry, "contextID:zoneName:", v73, v75));

                  v1 = v101;
                  objc_msgSend(v76, "setCkzonecreated:", v104);
                  objc_msgSend(v76, "setCkzonesubscribed:", v62);
                  v77 = v101[7];
                  if (v77)
                  {
                    v78 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v77, "domain"));
                    if (!objc_msgSend(v78, "isEqualToString:", CKErrorDomain))
                      goto LABEL_78;
                    v79 = objc_msgSend(v101[7], "code");

                    if (v79 == (id)2)
                    {
                      v80 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v101[7], "userInfo"));
                      v81 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v80, "objectForKeyedSubscript:", CKPartialErrorsByItemIDKey));
                      v82 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "zoneID"));
                      v78 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v81, "objectForKeyedSubscript:", v82));

                      if (v78)
                      {
                        v83 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v78, "domain"));
                        if ((objc_msgSend(v83, "isEqualToString:", CKErrorDomain) & 1) != 0)
                        {
                          v84 = objc_msgSend(v78, "code");

                          if (v84 == (id)26)
                          {
                            v85 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "zoneID"));
                            v86 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v85, "zoneName"));
                            v87 = sub_10000BDF4(CFSTR("ckks"), v86);
                            v88 = objc_claimAutoreleasedReturnValue(v87);

                            if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
                            {
                              v89 = v101[7];
                              *(_DWORD *)buf = 138412290;
                              *(_QWORD *)v119 = v89;
                              _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_ERROR, "zone subscription error appears to say the zone doesn't exist, fixing status: %@", buf, 0xCu);
                            }

                            objc_msgSend(v76, "setCkzonecreated:", 0);
                          }
                        }
                        else
                        {

                        }
                      }
LABEL_78:

                    }
                  }
                  v105 = 0;
                  objc_msgSend(v76, "saveToDatabase:", &v105);
                  v90 = v105;
                  if (v90)
                  {
                    v91 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "zoneID"));
                    v92 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v91, "zoneName"));
                    v93 = sub_10000BDF4(CFSTR("ckks"), v92);
                    v94 = objc_claimAutoreleasedReturnValue(v93);

                    if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
                    {
                      v95 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "zoneID"));
                      *(_DWORD *)buf = 138412546;
                      *(_QWORD *)v119 = v95;
                      *(_WORD *)&v119[8] = 2112;
                      *(_QWORD *)&v119[10] = v90;
                      _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_ERROR, "couldn't save zone creation status for %@: %@", buf, 0x16u);

                    }
                  }
                  objc_msgSend(v101[4], "setAllZoneCreationsSucceeded:", v104 & objc_msgSend(v101[4], "allZoneCreationsSucceeded"));
                  objc_msgSend(v101[4], "setAllZoneSubscriptionsSucceeded:", v62 & objc_msgSend(v101[4], "allZoneSubscriptionsSucceeded"));

                  v6 = v99;
                  goto LABEL_84;
                }
LABEL_59:

LABEL_60:
                if ((v43 & 1) != 0)
                  goto LABEL_61;
LABEL_54:
                v57 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "zoneID"));
                v58 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v57, "zoneName"));
                v59 = sub_10000BDF4(CFSTR("ckkszone"), v58);
                v60 = objc_claimAutoreleasedReturnValue(v59);

                if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
                {
                  v61 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "zoneID"));
                  *(_DWORD *)buf = 138412290;
                  *(_QWORD *)v119 = v61;
                  _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_ERROR, "Failed to subscribe to '%@'", buf, 0xCu);

                }
                v62 = 0;
                goto LABEL_64;
              }

            }
            goto LABEL_59;
          }
LABEL_38:

          v42 = v101[7];
          if (v42)
          {
            v43 = 0;
            goto LABEL_42;
          }
          goto LABEL_54;
        }
LABEL_84:

      }
      v102 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v114, v124, 16);
    }
    while (v102);
  }

  return 1;
}

void sub_100090C84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  _Block_object_dispose(&a18, 8);
  _Block_object_dispose(&a24, 8);
  _Block_object_dispose(&a30, 8);
  _Unwind_Resume(a1);
}

void sub_100090F34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10009141C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49)
{
  uint64_t v49;

  _Block_object_dispose(&a23, 8);
  _Block_object_dispose(&a29, 8);
  _Block_object_dispose(&a33, 8);
  _Block_object_dispose(&a37, 8);
  _Block_object_dispose(&a41, 8);
  _Block_object_dispose(&a45, 8);
  _Block_object_dispose(&a49, 8);
  _Block_object_dispose((const void *)(v49 - 240), 8);
  _Unwind_Resume(a1);
}

void sub_100091A10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59)
{
  uint64_t v59;

  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a35, 8);
  _Block_object_dispose(&a39, 8);
  _Block_object_dispose(&a43, 8);
  _Block_object_dispose(&a47, 8);
  _Block_object_dispose(&a51, 8);
  _Block_object_dispose(&a55, 8);
  _Block_object_dispose(&a59, 8);
  _Block_object_dispose((const void *)(v59 - 240), 8);
  _Unwind_Resume(a1);
}

void sub_100091E8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100092214(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_100092224(uint64_t a1)
{

}

void sub_10009222C(uint64_t a1)
{
  void *v2;
  void *v3;
  id v4;
  void *v5;
  void *v6;
  id v7;
  CKKSPeerProviderState *v8;
  void *v9;
  CKKSPeerProviderState *v10;
  uint64_t v11;
  void *v12;
  id v13;
  id v14;

  v2 = *(void **)(a1 + 32);
  v14 = 0;
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "fetchSelfPeers:", &v14));
  v4 = v14;
  v5 = *(void **)(a1 + 32);
  v13 = 0;
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "fetchTrustedPeers:", &v13));
  v7 = v13;
  v8 = [CKKSPeerProviderState alloc];
  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "providerID"));
  v10 = -[CKKSPeerProviderState initWithPeerProviderID:essential:selfPeers:selfPeersError:trustedPeers:trustedPeersError:](v8, "initWithPeerProviderID:essential:selfPeers:selfPeersError:trustedPeers:trustedPeersError:", v9, objc_msgSend(*(id *)(a1 + 32), "essential"), v3, v4, v6, v7);
  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  v12 = *(void **)(v11 + 40);
  *(_QWORD *)(v11 + 40) = v10;

}

id sub_100092320(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "trustedPeerSetChanged:", *(_QWORD *)(a1 + 32));
}

id sub_10009232C(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "selfPeerChanged:", *(_QWORD *)(a1 + 32));
}

void sub_100092338(uint64_t a1, void *a2)
{
  const void *v4;
  NSObject *v5;
  uint64_t v6;
  id v7;
  NSObject *v8;
  const void *v9;
  int v10;
  void *v11;

  objc_msgSend(*(id *)(a1 + 32), "stopWithEvent:result:", CFSTR("OctagonSOSAdapterUpdateKeys"), a2);
  if (a2)
  {
    v4 = sub_10000EF14("SecError");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v10 = 138412290;
      v11 = a2;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "octagon-sos: failed to update Octagon keys in SOS:%@", (uint8_t *)&v10, 0xCu);
    }

    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
    v7 = a2;
    v8 = *(NSObject **)(v6 + 40);
    *(_QWORD *)(v6 + 40) = v7;
  }
  else
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
    v9 = sub_10000EF14("octagon-sos");
    v8 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v10) = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "successfully updated Octagon keys in SOS!", (uint8_t *)&v10, 2u);
    }
  }

  CFRelease(*(CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24));
  CFRelease(*(CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24));
  CFRelease(*(CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24));
  CFRelease(*(CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 24));
  CFRelease(*(CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 8) + 24));
  CFRelease(*(CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 8) + 24));
  CFRelease(*(CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 8) + 24));
  CFRelease(*(CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 8) + 24));
}

void sub_100092504(uint64_t a1, void *a2)
{
  const void *v4;
  NSObject *v5;
  uint64_t v6;
  id v7;
  NSObject *v8;
  const void *v9;
  int v10;
  void *v11;

  objc_msgSend(*(id *)(a1 + 32), "stopWithEvent:result:", CFSTR("OctagonSOSAdapterUpdateKeys"), a2);
  if (a2)
  {
    v4 = sub_10000EF14("SecError");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v10 = 138412290;
      v11 = a2;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "octagon-preload-keys: failed to preload Octagon keys in SOS:%@", (uint8_t *)&v10, 0xCu);
    }

    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
    v7 = a2;
    v8 = *(NSObject **)(v6 + 40);
    *(_QWORD *)(v6 + 40) = v7;
  }
  else
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
    v9 = sub_10000EF14("octagon-preload-keys");
    v8 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v10) = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "successfully preloaded Octagon keys in SOS!", (uint8_t *)&v10, 2u);
    }
  }

  CFRelease(*(CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24));
  CFRelease(*(CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24));
  CFRelease(*(CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24));
  CFRelease(*(CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 24));
  CFRelease(*(CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 8) + 24));
  CFRelease(*(CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 8) + 24));
}

void sub_1000926B0(uint64_t a1, CFSetRef theSet, void *a3)
{
  const void *v6;
  NSObject *v7;
  uint64_t v8;
  id *v9;
  uint64_t v10;
  _QWORD context[5];
  uint8_t buf[4];
  void *v13;

  if (a3)
  {
    v6 = sub_10000EF14("SecError");
    v7 = objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v13 = a3;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "octagon-sos: Error fetching trusted peers: %@", buf, 0xCu);
    }

    v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v10 = *(_QWORD *)(v8 + 40);
    v9 = (id *)(v8 + 40);
    if (v10)
      objc_storeStrong(v9, a3);
  }
  context[0] = _NSConcreteStackBlock;
  context[1] = 3221225472;
  context[2] = sub_1000927CC;
  context[3] = &unk_1002EB818;
  context[4] = *(_QWORD *)(a1 + 40);
  CFSetApplyFunction(theSet, (CFSetApplierFunction)sub_100092A78, context);
}

void sub_1000927CC(uint64_t a1, uint64_t a2)
{
  uint64_t PeerID;
  const void *v5;
  uint64_t v6;
  const void *v7;
  char v8;
  CFErrorDomain Domain;
  const void *v10;
  NSObject *v11;
  const void *v12;
  id v13;
  id v14;
  CKKSSOSPeer *v15;
  void *v16;
  CKKSSOSPeer *v17;
  CFErrorRef v18;
  CFErrorRef err;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  CFErrorRef v23;

  err = 0;
  if (!a2)
    return;
  PeerID = SOSPeerInfoGetPeerID(a2);
  v5 = (const void *)SOSPeerInfoCopyOctagonSigningPublicKey(a2, &err);
  if (v5)
  {
    v6 = SOSPeerInfoCopyOctagonEncryptionPublicKey(a2, &err);
    if (v6)
    {
      v7 = (const void *)v6;
      v8 = 0;
      goto LABEL_17;
    }
  }
  if (!err)
    goto LABEL_14;
  Domain = CFErrorGetDomain(err);
  if (Domain && kCFErrorDomainOSStatus)
  {
    if (!CFEqual(Domain, kCFErrorDomainOSStatus))
    {
LABEL_14:
      v12 = sub_10000EF14("SecError");
      v11 = objc_claimAutoreleasedReturnValue(v12);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412546;
        v21 = a2;
        v22 = 2112;
        v23 = err;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "octagon-sos: error fetching octagon keys for peer: %@ %@", buf, 0x16u);
      }
      goto LABEL_16;
    }
  }
  else if (Domain != kCFErrorDomainOSStatus)
  {
    goto LABEL_14;
  }
  if (CFErrorGetCode(err) != -50)
    goto LABEL_14;
  v10 = sub_10000EF14("octagon-sos");
  v11 = objc_claimAutoreleasedReturnValue(v10);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138412546;
    v21 = PeerID;
    v22 = 2112;
    v23 = err;
    _os_log_debug_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "Peer(%@) doesn't have Octagon keys, but this is expected: %@", buf, 0x16u);
  }
LABEL_16:

  v7 = 0;
  v13 = 0;
  v14 = 0;
  v8 = 1;
  if (v5)
  {
LABEL_17:
    v14 = objc_msgSend(objc_alloc((Class)_SFECPublicKey), "initWithSecKey:", v5);
    if ((v8 & 1) != 0)
    {
      v13 = 0;
      v8 = 1;
    }
    else
    {
      v13 = objc_msgSend(objc_alloc((Class)_SFECPublicKey), "initWithSecKey:", v7);
      v8 = 0;
    }
  }
  v15 = [CKKSSOSPeer alloc];
  v16 = (void *)objc_claimAutoreleasedReturnValue(+[OTSOSActualAdapter sosCKKSViewList](OTSOSActualAdapter, "sosCKKSViewList"));
  v17 = -[CKKSSOSPeer initWithSOSPeerID:encryptionPublicKey:signingPublicKey:viewList:](v15, "initWithSOSPeerID:encryptionPublicKey:signingPublicKey:viewList:", PeerID, v13, v14, v16);

  objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), "addObject:", v17);
  if (v5)
    CFRelease(v5);
  if ((v8 & 1) == 0)
    CFRelease(v7);
  v18 = err;
  if (err)
  {
    err = 0;
    CFRelease(v18);
  }

}

uint64_t sub_100092A78(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_100092A8C(_QWORD *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v5;
  id v6;
  void *v7;
  id v9;
  uint64_t v10;
  void *v11;
  id v12;
  uint64_t v13;
  uint64_t v14;

  if (a4)
  {
    v5 = *(_QWORD *)(a1[4] + 8);
    v6 = a4;
    v7 = *(void **)(v5 + 40);
    *(_QWORD *)(v5 + 40) = v6;
  }
  else
  {
    if (a2 && a3)
    {
      v9 = objc_msgSend(objc_alloc((Class)_SFECKeyPair), "initWithSecKey:", a3);
      v10 = *(_QWORD *)(a1[5] + 8);
      v11 = *(void **)(v10 + 40);
      *(_QWORD *)(v10 + 40) = v9;

      v12 = objc_msgSend(objc_alloc((Class)_SFECKeyPair), "initWithSecKey:", a2);
      v13 = a1[6];
    }
    else
    {
      v12 = (id)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:description:](NSError, "errorWithDomain:code:description:", CFSTR("CKKSErrorDomain"), 24, CFSTR("Not all SOS peer keys available, but no error returned")));
      v13 = a1[4];
    }
    v14 = *(_QWORD *)(v13 + 8);
    v7 = *(void **)(v14 + 40);
    *(_QWORD *)(v14 + 40) = v12;
  }

}

id sub_100092B50(uint64_t a1)
{
  const void *v2;
  NSObject *v3;
  uint8_t v5[16];

  v2 = sub_10000EF14("octagon-sos");
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Received a notification that the SOS Octagon peer set changed", v5, 2u);
  }

  return objc_msgSend(*(id *)(a1 + 32), "sendTrustedPeerSetChangedUpdate");
}

void sub_100092C08(id a1)
{
  uint64_t v1;
  void *v2;

  v1 = SOSViewCopyViewSet(6);
  v2 = (void *)qword_100340F78;
  qword_100340F78 = v1;

}

void sub_100093714(_Unwind_Exception *a1)
{
  id *v1;
  id *v2;
  uint64_t v3;

  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v3 - 80));
  _Unwind_Resume(a1);
}

void sub_100093B04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100093C6C(uint64_t a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9;
  id v10;
  id v11;
  id v12;
  id WeakRetained;
  void *v14;
  const void *v15;
  NSObject *v16;
  const void *v17;
  NSObject *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  id v23;
  unsigned int v24;
  id v25;
  void *v26;
  const void *v27;
  NSObject *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  id v34;
  _QWORD v35[4];
  id v36;
  id v37;
  uint8_t buf[4];
  id v39;

  v9 = a2;
  v10 = a3;
  v11 = a4;
  v12 = a5;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v14 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v14, "logResultForEvent:hardFailure:result:", CFSTR("OctagonEventEstablishIdentity"), 1, v12);

  if (v12)
  {
    v15 = sub_10000EF14("SecError");
    v16 = objc_claimAutoreleasedReturnValue(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v39 = v12;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "octagon: Error calling establish: %@", buf, 0xCu);
    }

    if (objc_msgSend(v12, "isCuttlefishError:", 1033))
    {
      v17 = sub_10000EF14("octagon-ckks");
      v18 = objc_claimAutoreleasedReturnValue(v17);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "ckksConflictState"));
        *(_DWORD *)buf = 138412290;
        v39 = v19;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "A CKKS key hierarchy is out of date; moving to '%@'",
          buf,
          0xCu);

      }
      v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "ckksConflictState"));
      objc_msgSend(WeakRetained, "setNextState:", v20);

    }
    else
    {
      objc_msgSend(WeakRetained, "setError:", v12);
    }
    v25 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishedOp"));
    objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v25);
  }
  else
  {
    objc_msgSend(WeakRetained, "setPeerID:", v9);
    v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "operationDependencies"));
    v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "stateHolder"));
    v35[0] = _NSConcreteStackBlock;
    v35[1] = 3221225472;
    v35[2] = sub_10009402C;
    v35[3] = &unk_1002DEC60;
    v36 = v9;
    v23 = v11;
    v37 = v23;
    v34 = 0;
    v24 = objc_msgSend(v22, "persistAccountChanges:error:", v35, &v34);
    v25 = v34;

    if (!v24 || v25)
    {
      v27 = sub_10000EF14("octagon");
      v28 = objc_claimAutoreleasedReturnValue(v27);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v39 = v25;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Couldn't persist results: %@", buf, 0xCu);
      }

      objc_msgSend(WeakRetained, "setError:", v25);
    }
    else
    {
      v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "intendedState"));
      objc_msgSend(WeakRetained, "setNextState:", v26);

    }
    v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "operationDependencies"));
    v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v29, "ckks"));
    objc_msgSend(v30, "setCurrentSyncingPolicy:", v23);

    v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "operationDependencies"));
    v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v31, "ckks"));
    objc_msgSend(v32, "receiveTLKUploadRecords:", v10);

    v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishedOp"));
    objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v33);

  }
}

id sub_10009402C(uint64_t a1, void *a2)
{
  id v3;

  v3 = a2;
  objc_msgSend(v3, "setTrustState:", 2);
  objc_msgSend(v3, "setPeerID:", *(_QWORD *)(a1 + 32));
  objc_msgSend(v3, "setTPSyncingPolicy:", *(_QWORD *)(a1 + 40));
  return v3;
}

void sub_100094074(uint64_t a1)
{
  id WeakRetained;
  const void *v2;
  NSObject *v3;
  uint64_t v4;
  void *v5;
  const __CFString *v6;
  int v7;
  const __CFString *v8;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v2 = sub_10000EF14("octagon");
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
    v5 = (void *)v4;
    v6 = CFSTR("no error");
    if (v4)
      v6 = (const __CFString *)v4;
    v7 = 138412290;
    v8 = v6;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Finishing an establish operation with %@", (uint8_t *)&v7, 0xCu);

  }
}

void sub_100094154(uint64_t a1)
{
  void *v2;
  void *v3;
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "viewKeySets"));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "pendingTLKShares"));
  objc_msgSend(WeakRetained, "proceedWithKeys:pendingTLKShares:", v2, v3);

}

void sub_1000945AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id *location, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,id a28)
{
  objc_destroyWeak(location);
  objc_destroyWeak(&a28);
  _Unwind_Resume(a1);
}

void sub_100094958(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,id location)
{
  id *v40;

  objc_destroyWeak(v40);
  _Block_object_dispose(&a30, 8);
  _Block_object_dispose(&a36, 8);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t sub_100094F38(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_100094F48(uint64_t a1)
{

}

uint64_t sub_100094F50(uint64_t a1)
{
  void *v1;
  void *v2;
  id v3;
  NSObject *v4;
  uint64_t v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  id v12;
  NSObject *v13;
  void *v14;
  void *v15;
  void *v16;
  id v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  BOOL v24;
  void *v25;
  void *v26;
  void *v27;
  unsigned __int8 v28;
  void *v29;
  void *v30;
  id v31;
  NSObject *v32;
  const char *v33;
  NSObject *v34;
  os_log_type_t v35;
  uint32_t v36;
  void *v37;
  _BOOL4 v38;
  void *v39;
  void *v40;
  id v41;
  NSObject *v42;
  CKKSCurrentKeyPointer *v43;
  void *v44;
  void *v45;
  id v46;
  void *v47;
  _BOOL4 v48;
  void *v49;
  void *v50;
  id v51;
  NSObject *v52;
  CKKSCurrentKeyPointer *v53;
  void *v54;
  void *v55;
  id v56;
  void *v57;
  _BOOL4 v58;
  void *v59;
  void *v60;
  id v61;
  NSObject *v62;
  CKKSCurrentKeyPointer *v63;
  void *v64;
  void *v65;
  id v66;
  void *v67;
  void *v68;
  void *v69;
  void *v70;
  void *v71;
  void *v72;
  void *v73;
  void *v74;
  void *v75;
  void *v76;
  char v77;
  unsigned int v78;
  void *v79;
  void *v80;
  id v81;
  _BOOL4 v82;
  void *v83;
  void *v84;
  void *v85;
  void *v86;
  id v87;
  NSObject *v88;
  void *v89;
  id v90;
  uint64_t v91;
  AAFAnalyticsEventSecurity *v92;
  void *v93;
  void *v94;
  void *v95;
  void *v96;
  void *v97;
  void *v98;
  void *v99;
  id v100;
  id v101;
  uint64_t v102;
  void *v103;
  void *v104;
  void *v105;
  void *v106;
  void *v107;
  void *v108;
  unsigned __int8 v109;
  unsigned __int8 v110;
  id v111;
  void *v112;
  void *v113;
  uint64_t v114;
  unsigned __int8 v115;
  void *v116;
  void *v117;
  void *v118;
  void *v119;
  void *v120;
  id *i;
  void *v122;
  void *v123;
  void *v124;
  unsigned int v125;
  void *v126;
  void *v127;
  void *v128;
  void *v129;
  void *v130;
  void *v131;
  void *v132;
  void *v133;
  void *v134;
  void *v135;
  void *v136;
  void *v137;
  void *v138;
  void *v139;
  void *v140;
  void *v141;
  void *v142;
  void *v143;
  id v144;
  NSObject *v145;
  void *v147;
  void *v148;
  void *v149;
  void *v150;
  void *v151;
  void *v152;
  id v153;
  NSObject *v154;
  void *v156;
  unsigned __int8 v157;
  void *v158;
  void *v159;
  uint64_t v160;
  unsigned __int8 v161;
  id v162;
  void *v163;
  void *v164;
  void *v165;
  void *v166;
  void *v167;
  void *v168;
  void *v169;
  void *v170;
  void *v171;
  id v172;
  NSObject *v173;
  void *v174;
  void *v175;
  void *v176;
  id v177;
  NSObject *v178;
  void *v179;
  void *v180;
  uint64_t v181;
  void *v182;
  void *v183;
  unsigned int v184;
  void *v185;
  void *v186;
  id v187;
  NSObject *v188;
  void *v189;
  __CFString **v190;
  void *v191;
  void *v192;
  id v193;
  void *v194;
  void *v195;
  void *v196;
  unsigned int v197;
  void *v198;
  void *v199;
  id v200;
  NSObject *v201;
  NSObject *v202;
  __CFString **v203;
  void *v204;
  void *v205;
  id v206;
  void *v207;
  void *v208;
  _BOOL4 v209;
  void *v210;
  void *v211;
  _BOOL4 v212;
  void *v213;
  void *v214;
  id v215;
  NSObject *v216;
  void *v217;
  void *v218;
  uint64_t v219;
  void *v220;
  void *v221;
  void *v222;
  void *v223;
  void *v224;
  void *v225;
  void *v226;
  void *v227;
  void *v228;
  void *v229;
  void *v230;
  uint64_t v231;
  void *v232;
  void *v233;
  void *v234;
  void *v235;
  id v236;
  NSObject *v237;
  id v238;
  void *v239;
  void *v240;
  unsigned int v241;
  void *v242;
  void *v243;
  id v244;
  NSObject *v245;
  void *v246;
  id v247;
  void *v248;
  void *v249;
  unsigned int v250;
  void *v251;
  void *v252;
  id v253;
  NSObject *v254;
  void *v255;
  id v256;
  id v257;
  uint64_t v258;
  void *j;
  void *v260;
  void *v261;
  void *v262;
  AAFAnalyticsEventSecurity *v263;
  void *v264;
  void *v265;
  void *v266;
  void *v267;
  void *v268;
  void *v269;
  void *v270;
  void *v271;
  void *v272;
  id v273;
  NSObject *v274;
  char *v275;
  uint64_t k;
  uint64_t v277;
  void *v278;
  void *v279;
  id v280;
  id v281;
  uint64_t v282;
  void *v283;
  id v284;
  char *v285;
  uint64_t v286;
  void *v287;
  id v288;
  id v289;
  uint64_t v290;
  void *m;
  void *v292;
  void *v293;
  id v294;
  void *v295;
  void *v296;
  void *v297;
  void *v298;
  void *v299;
  id v300;
  NSObject *v301;
  void *v302;
  void *v303;
  AAFAnalyticsEventSecurity *v304;
  uint64_t v305;
  id v306;
  id v307;
  void *v308;
  void *v309;
  void *v310;
  void *v311;
  void *v312;
  void *v313;
  void *v314;
  id v315;
  unsigned __int8 v316;
  void *v317;
  BOOL v318;
  BOOL v319;
  void *v320;
  unsigned __int8 froma;
  char from;
  void *v323;
  char v324;
  AAFAnalyticsEventSecurity *v325;
  id v326;
  id v327;
  char *v328;
  void *v329;
  id v330;
  void *v331;
  uint64_t v332;
  AAFAnalyticsEventSecurity *v333;
  void *v334;
  AAFAnalyticsEventSecurity *v335;
  id *to;
  id *toa;
  id v338;
  id *v340;
  id obj;
  id obja;
  void *v343;
  id v344;
  id v345;
  _QWORD v346[4];
  id v347;
  id v348;
  id v349;
  id v350;
  id v351;
  id v352;
  AAFAnalyticsEventSecurity *v353;
  AAFAnalyticsEventSecurity *v354;
  id v355;
  id v356;
  uint64_t v357;
  _BYTE *v358;
  id v359;
  _QWORD v360[4];
  id v361;
  _BYTE *v362;
  uint64_t v363;
  __int128 v364;
  __int128 v365;
  __int128 v366;
  __int128 v367;
  _QWORD v368[4];
  id v369;
  AAFAnalyticsEventSecurity *v370;
  id v371;
  _BYTE *v372;
  uint64_t v373;
  uint64_t v374;
  __int128 v375;
  __int128 v376;
  __int128 v377;
  __int128 v378;
  id v379;
  id v380;
  id v381;
  id v382;
  id v383;
  __int128 v384;
  __int128 v385;
  __int128 v386;
  __int128 v387;
  id v388;
  id v389;
  id v390;
  __int128 v391;
  __int128 v392;
  __int128 v393;
  __int128 v394;
  id v395;
  id v396;
  uint8_t v397[128];
  uint8_t v398[4];
  id v399;
  const __CFString *v400;
  void *v401;
  _QWORD v402[2];
  _QWORD v403[2];
  _BYTE buf[24];
  char v405;
  _BYTE v406[128];
  const __CFString *v407;
  void *v408;
  const __CFString *v409;
  void *v410;
  const __CFString *v411;
  void *v412;
  _BYTE v413[128];
  const __CFString *v414;
  void *v415;
  _BYTE v416[128];
  const __CFString *v417;
  void *v418;
  const __CFString *v419;
  void *v420;

  v1 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "zoneName"));
  v3 = sub_10000BDF4(CFSTR("ckksheal"), v2);
  v4 = objc_claimAutoreleasedReturnValue(v3);

  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *(_QWORD *)(a1 + 32);
    *(_DWORD *)buf = 138412290;
    *(_QWORD *)&buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Attempting to heal %@", buf, 0xCu);
  }

  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "contextID"));
  v343 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSCurrentKeySet loadForZone:contextID:](CKKSCurrentKeySet, "loadForZone:contextID:", v6, v7));

  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "error"));
  if (v8)
  {
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "error"));
    objc_msgSend(*(id *)(a1 + 40), "setError:", v9);

    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "zoneName"));
    v12 = sub_10000BDF4(CFSTR("ckksheal"), v11);
    v13 = objc_claimAutoreleasedReturnValue(v12);

    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "error"));
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)&buf[4] = v14;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "couldn't load current key set, attempting to proceed: %@", buf, 0xCu);

    }
  }
  else
  {
    v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "zoneName"));
    v17 = sub_10000BDF4(CFSTR("ckksheal"), v16);
    v13 = objc_claimAutoreleasedReturnValue(v17);

    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)&buf[4] = v343;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Key set is %@", buf, 0xCu);
    }
  }

  v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "currentTLKPointer"));
  if (!v18)
    goto LABEL_17;
  v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "currentClassAPointer"));
  if (!v19)
  {
LABEL_16:

    goto LABEL_17;
  }
  v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "currentClassCPointer"));
  if (!v20)
  {

    goto LABEL_16;
  }
  v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "tlk"));
  if (v21)
  {
    v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "classA"));
    if (v22)
    {
      v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "classC"));
      v24 = v23 == 0;

      if (!v24)
        goto LABEL_17;
      goto LABEL_51;
    }

  }
LABEL_51:
  if (objc_msgSend(*(id *)(a1 + 40), "allowFullRefetchResult"))
  {
    v85 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v86 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v85, "zoneName"));
    v87 = sub_10000BDF4(CFSTR("ckksheal"), v86);
    v88 = objc_claimAutoreleasedReturnValue(v87);

    if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "Have current key pointers, but no keys. This is exceptional; requesting full refetch",
        buf,
        2u);
    }

    objc_msgSend(*(id *)(a1 + 32), "setViewKeyHierarchyState:", CFSTR("needrefetch"));
    v89 = *(void **)(a1 + 48);
    v419 = CFSTR("fullRefetchNeeded");
    v420 = &__kCFBooleanTrue;
    v338 = (id)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v420, &v419, 1));
    objc_msgSend(v89, "addMetrics:", v338);
LABEL_55:
    v90 = 0;
LABEL_56:
    v91 = 1;
    goto LABEL_115;
  }
LABEL_17:
  v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
  v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v25, "contextID"));
  v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
  v396 = 0;
  v28 = +[CKKSIncomingQueueEntry allIQEsHaveValidUnwrappingKeysInContextID:zoneID:error:](CKKSIncomingQueueEntry, "allIQEsHaveValidUnwrappingKeysInContextID:zoneID:error:", v26, v27, &v396);
  v338 = v396;

  if (v338)
  {
    v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v29, "zoneName"));
    v31 = sub_10000BDF4(CFSTR("ckksheal"), v30);
    v32 = objc_claimAutoreleasedReturnValue(v31);

    if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
LABEL_21:

      goto LABEL_23;
    }
    *(_DWORD *)buf = 138412290;
    *(_QWORD *)&buf[4] = v338;
    v33 = "Unable to determine if all IQEs have parent keys: %@";
    v34 = v32;
    v35 = OS_LOG_TYPE_ERROR;
    v36 = 12;
LABEL_20:
    _os_log_impl((void *)&_mh_execute_header, v34, v35, v33, buf, v36);
    goto LABEL_21;
  }
  if ((v28 & 1) == 0)
  {
    v78 = objc_msgSend(*(id *)(a1 + 40), "allowFullRefetchResult");
    v79 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v80 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v79, "zoneName"));
    v81 = sub_10000BDF4(CFSTR("ckksheal"), v80);
    v32 = objc_claimAutoreleasedReturnValue(v81);

    v82 = os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT);
    if (v78)
    {
      if (v82)
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "We have some item that encrypts to a non-existent key. This is exceptional; requesting full refetch",
          buf,
          2u);
      }

      v83 = *(void **)(a1 + 48);
      v417 = CFSTR("fullRefetchNeeded");
      v418 = &__kCFBooleanTrue;
      v84 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v418, &v417, 1));
      objc_msgSend(v83, "addMetrics:", v84);

      objc_msgSend(*(id *)(a1 + 32), "setViewKeyHierarchyState:", CFSTR("needrefetch"));
      v338 = 0;
      goto LABEL_55;
    }
    if (!v82)
      goto LABEL_21;
    *(_WORD *)buf = 0;
    v33 = "We have some item that encrypts to a non-existent key, but we cannot request a refetch! Possible inifinite-loop ahead";
    v34 = v32;
    v35 = OS_LOG_TYPE_DEFAULT;
    v36 = 2;
    goto LABEL_20;
  }
LABEL_23:
  v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "currentTLKPointer"));
  v38 = v37 == 0;

  if (v38)
  {
    v39 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v40 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v39, "zoneName"));
    v41 = sub_10000BDF4(CFSTR("ckksheal"), v40);
    v42 = objc_claimAutoreleasedReturnValue(v41);

    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "No current TLK pointer?", buf, 2u);
    }

    v43 = [CKKSCurrentKeyPointer alloc];
    v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "contextID"));
    v45 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v46 = -[CKKSCurrentKeyPointer initForClass:contextID:currentKeyUUID:zoneID:encodedCKRecord:](v43, "initForClass:contextID:currentKeyUUID:zoneID:encodedCKRecord:", CFSTR("tlk"), v44, 0, v45, 0);
    objc_msgSend(v343, "setCurrentTLKPointer:", v46);

  }
  v47 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "currentClassAPointer"));
  v48 = v47 == 0;

  if (v48)
  {
    v49 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v50 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v49, "zoneName"));
    v51 = sub_10000BDF4(CFSTR("ckksheal"), v50);
    v52 = objc_claimAutoreleasedReturnValue(v51);

    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "No current ClassA pointer?", buf, 2u);
    }

    v53 = [CKKSCurrentKeyPointer alloc];
    v54 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "contextID"));
    v55 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v56 = -[CKKSCurrentKeyPointer initForClass:contextID:currentKeyUUID:zoneID:encodedCKRecord:](v53, "initForClass:contextID:currentKeyUUID:zoneID:encodedCKRecord:", CFSTR("classA"), v54, 0, v55, 0);
    objc_msgSend(v343, "setCurrentClassAPointer:", v56);

  }
  v57 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "currentClassCPointer"));
  v58 = v57 == 0;

  if (v58)
  {
    v59 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v60 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v59, "zoneName"));
    v61 = sub_10000BDF4(CFSTR("ckksheal"), v60);
    v62 = objc_claimAutoreleasedReturnValue(v61);

    if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "No current ClassC pointer?", buf, 2u);
    }

    v63 = [CKKSCurrentKeyPointer alloc];
    v64 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "contextID"));
    v65 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v66 = -[CKKSCurrentKeyPointer initForClass:contextID:currentKeyUUID:zoneID:encodedCKRecord:](v63, "initForClass:contextID:currentKeyUUID:zoneID:encodedCKRecord:", CFSTR("classC"), v64, 0, v65, 0);
    objc_msgSend(v343, "setCurrentClassCPointer:", v66);

  }
  v67 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "currentTLKPointer"));
  v68 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v67, "currentKeyUUID"));
  if (!v68)
    goto LABEL_62;
  v69 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "currentClassAPointer"));
  v70 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v69, "currentKeyUUID"));
  if (!v70)
  {
LABEL_61:

LABEL_62:
    goto LABEL_63;
  }
  v71 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "currentClassCPointer"));
  v72 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v71, "currentKeyUUID"));
  if (!v72)
  {
LABEL_60:

    goto LABEL_61;
  }
  v73 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "tlk"));
  if (!v73)
  {
LABEL_59:

    goto LABEL_60;
  }
  v74 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "classA"));
  if (!v74)
  {
LABEL_58:

    goto LABEL_59;
  }
  obj = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "classC"));
  if (!obj)
  {

    goto LABEL_58;
  }
  to = (id *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "classA"));
  v331 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(to, "parentKeyUUID"));
  v334 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "tlk"));
  v329 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v334, "uuid"));
  if (objc_msgSend(v331, "isEqualToString:", v329))
  {
    v326 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "classC"));
    v323 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v326, "parentKeyUUID"));
    v75 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "tlk"));
    v76 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v75, "uuid"));
    froma = objc_msgSend(v323, "isEqualToString:", v76);

    v77 = froma ^ 1;
  }
  else
  {
    v77 = 1;
  }

  if ((v77 & 1) == 0)
  {
    v156 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "tlk"));
    v345 = 0;
    v157 = objc_msgSend(v156, "validTLK:", &v345);
    v90 = v345;

    if ((v157 & 1) == 0)
    {
      v169 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:description:underlying:](NSError, "errorWithDomain:code:description:underlying:", CFSTR("CKKSErrorDomain"), 34, CFSTR("Invalid TLK from CloudKit (during heal)"), v90));
      v170 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
      v171 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v170, "zoneName"));
      v172 = sub_10000BDF4(CFSTR("ckkskey"), v171);
      v173 = objc_claimAutoreleasedReturnValue(v172);

      if (os_log_type_enabled(v173, OS_LOG_TYPE_ERROR))
      {
        v174 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "tlk"));
        *(_DWORD *)buf = 138412546;
        *(_QWORD *)&buf[4] = v174;
        *(_WORD *)&buf[12] = 2112;
        *(_QWORD *)&buf[14] = v169;
        _os_log_impl((void *)&_mh_execute_header, v173, OS_LOG_TYPE_ERROR, "CKKS claims %@ is not a valid TLK: %@", buf, 0x16u);

      }
      objc_msgSend(*(id *)(a1 + 32), "setViewKeyHierarchyState:", CFSTR("error"));
      objc_msgSend(*(id *)(a1 + 48), "populateUnderlyingErrorsStartingWithRootError:", v90);
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24) = 0;

      goto LABEL_56;
    }
    v158 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "tlk"));
    v159 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "contextID"));
    v160 = *(_QWORD *)(a1 + 56);
    v344 = v90;
    v161 = objc_msgSend(v158, "tlkMaterialPresentOrRecoverableViaTLKShareForContextID:forTrustStates:error:", v159, v160, &v344);
    v162 = v344;

    if ((v161 & 1) != 0)
    {
      v163 = *(void **)(a1 + 40);
      v164 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "tlk"));
      LOBYTE(v163) = objc_msgSend(v163, "ensureKeyPresent:viewState:", v164, *(_QWORD *)(a1 + 32));

      if ((v163 & 1) == 0)
        goto LABEL_135;
      v165 = *(void **)(a1 + 40);
      v166 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "classA"));
      LOBYTE(v165) = objc_msgSend(v165, "ensureKeyPresent:viewState:", v166, *(_QWORD *)(a1 + 32));

      if ((v165 & 1) == 0
        || (v167 = *(void **)(a1 + 40),
            v168 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "classC")),
            LOBYTE(v167) = objc_msgSend(v167, "ensureKeyPresent:viewState:", v168, *(_QWORD *)(a1 + 32)), v168, (v167 & 1) == 0))
      {
LABEL_135:
        v91 = 0;
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24) = 0;
LABEL_141:
        v90 = v162;
        goto LABEL_115;
      }
      objc_msgSend(*(id *)(a1 + 32), "setViewKeyHierarchyState:", CFSTR("ready"));
    }
    else
    {
      v181 = a1;
      if (v162
        && (v182 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps")),
            v183 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v182, "lockStateTracker")),
            v184 = objc_msgSend(v183, "isLockedError:", v162),
            v183,
            v182,
            v181 = a1,
            v184))
      {
        v185 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
        v186 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v185, "zoneName"));
        v187 = sub_10000BDF4(CFSTR("ckkskey"), v186);
        v188 = objc_claimAutoreleasedReturnValue(v187);

        if (os_log_type_enabled(v188, OS_LOG_TYPE_DEFAULT))
        {
          v189 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "tlk"));
          *(_DWORD *)buf = 138412290;
          *(_QWORD *)&buf[4] = v189;
          _os_log_impl((void *)&_mh_execute_header, v188, OS_LOG_TYPE_DEFAULT, "Received a TLK(%@), but keybag appears to be locked. Entering a waiting state.", buf, 0xCu);

        }
        v190 = off_1002E9DE0;
      }
      else
      {
        v191 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v181 + 32), "zoneID"));
        v192 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v191, "zoneName"));
        v193 = sub_10000BDF4(CFSTR("ckkskey"), v192);
        v188 = objc_claimAutoreleasedReturnValue(v193);

        if (os_log_type_enabled(v188, OS_LOG_TYPE_DEFAULT))
        {
          v194 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "tlk"));
          *(_DWORD *)buf = 138412546;
          *(_QWORD *)&buf[4] = v194;
          *(_WORD *)&buf[12] = 2112;
          *(_QWORD *)&buf[14] = v162;
          _os_log_impl((void *)&_mh_execute_header, v188, OS_LOG_TYPE_DEFAULT, "Received a TLK(%@) which we don't have in the local keychain: %@", buf, 0x16u);

        }
        v190 = &off_1002E9DE8;
      }

      objc_msgSend(*(id *)(a1 + 32), "setViewKeyHierarchyState:", *v190);
      objc_msgSend(*(id *)(a1 + 48), "populateUnderlyingErrorsStartingWithRootError:", v162);
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24) = 0;
    }
    v91 = 1;
    goto LABEL_141;
  }
LABEL_63:
  v92 = [AAFAnalyticsEventSecurity alloc];
  v93 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
  v94 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v93, "activeAccount"));
  v95 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v94, "altDSID"));
  v96 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
  v335 = -[AAFAnalyticsEventSecurity initWithCKKSMetrics:altDSID:eventName:testsAreEnabled:category:sendMetric:](v92, "initWithCKKSMetrics:altDSID:eventName:testsAreEnabled:category:sendMetric:", &__NSDictionary0__struct, v95, CFSTR("com.apple.security.ckks.healKeyHierarchy.healBrokenRecords"), 0, &off_10030AF70, objc_msgSend(v96, "sendMetric"));

  v97 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "contextID"));
  v98 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
  v395 = 0;
  v99 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSKey allKeysForContextID:zoneID:error:](CKKSKey, "allKeysForContextID:zoneID:error:", v97, v98, &v395));
  v90 = v395;

  v330 = objc_alloc_init((Class)NSMutableArray);
  v393 = 0u;
  v394 = 0u;
  v391 = 0u;
  v392 = 0u;
  obja = v99;
  v100 = objc_msgSend(obja, "countByEnumeratingWithState:objects:count:", &v391, v416, 16);
  if (!v100)
  {

LABEL_110:
    v151 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v152 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v151, "zoneName"));
    v153 = sub_10000BDF4(CFSTR("ckksheal"), v152);
    v154 = objc_claimAutoreleasedReturnValue(v153);

    if (os_log_type_enabled(v154, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v154, OS_LOG_TYPE_ERROR, "No possible TLK found. Waiting for creation.", buf, 2u);
    }

    objc_msgSend(*(id *)(a1 + 32), "setViewKeyHierarchyState:", CFSTR("waitfortlkcreation"));
    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", v335, 0, 0);
    v101 = 0;
    goto LABEL_113;
  }
  v101 = 0;
  v102 = *(_QWORD *)v392;
  do
  {
    v103 = 0;
    v104 = v90;
    do
    {
      if (*(_QWORD *)v392 != v102)
        objc_enumerationMutation(obja);
      v105 = *(void **)(*((_QWORD *)&v391 + 1) + 8 * (_QWORD)v103);
      v390 = v104;
      v106 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v105, "topKeyInAnyState:", &v390));
      v90 = v390;

      if (v101)
      {
        v107 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v101, "uuid"));
        v108 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v106, "uuid"));
        v109 = objc_msgSend(v107, "isEqualToString:", v108);

        if ((v109 & 1) == 0)
        {
          v142 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
          v143 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v142, "zoneName"));
          v144 = sub_10000BDF4(CFSTR("ckksheal"), v143);
          v145 = objc_claimAutoreleasedReturnValue(v144);

          if (os_log_type_enabled(v145, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v145, OS_LOG_TYPE_ERROR, "key hierarchy has split: there's two top keys. Currently we don't handle this situation.", buf, 2u);
          }

          v147 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Key hierarchy has split: %@ and %@ are roots"), v101, v106));
          v148 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:description:](NSError, "errorWithDomain:code:description:", CFSTR("CKKSErrorDomain"), 32, v147));
          v149 = *(void **)(a1 + 40);
          v340 = (id *)(a1 + 40);
          objc_msgSend(v149, "setError:", v148);

          objc_msgSend(*v340, "setNextState:", CFSTR("error"));
          v150 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*v340, "error"));
          +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", v335, 0, v150);

          goto LABEL_113;
        }
      }
      else
      {
        v101 = v106;
      }

      v103 = (char *)v103 + 1;
      v104 = v90;
    }
    while (v100 != v103);
    v100 = objc_msgSend(obja, "countByEnumeratingWithState:objects:count:", &v391, v416, 16);
  }
  while (v100);

  if (!v101)
    goto LABEL_110;
  v389 = v90;
  v110 = objc_msgSend(v101, "validTLK:", &v389);
  v111 = v389;

  v112 = *(void **)(a1 + 32);
  if ((v110 & 1) == 0)
  {
    v175 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v112, "zoneID"));
    v176 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v175, "zoneName"));
    v177 = sub_10000BDF4(CFSTR("ckkskey"), v176);
    v178 = objc_claimAutoreleasedReturnValue(v177);

    if (os_log_type_enabled(v178, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412546;
      *(_QWORD *)&buf[4] = v101;
      *(_WORD *)&buf[12] = 2112;
      *(_QWORD *)&buf[14] = v111;
      _os_log_impl((void *)&_mh_execute_header, v178, OS_LOG_TYPE_ERROR, "CKKS claims %@ is not a valid TLK: %@", buf, 0x16u);
    }

    v179 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:description:underlying:](NSError, "errorWithDomain:code:description:underlying:", CFSTR("CKKSErrorDomain"), 34, CFSTR("Invalid TLK from CloudKit (during heal)"), v111));
    objc_msgSend(*(id *)(a1 + 40), "setError:", v179);

    objc_msgSend(*(id *)(a1 + 32), "setViewKeyHierarchyState:", CFSTR("error"));
    v180 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "error"));
    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", v335, 0, v180);

    v91 = 1;
    v90 = v111;
    goto LABEL_114;
  }
  v113 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v112, "contextID"));
  v114 = *(_QWORD *)(a1 + 56);
  v388 = v111;
  v115 = objc_msgSend(v101, "tlkMaterialPresentOrRecoverableViaTLKShareForContextID:forTrustStates:error:", v113, v114, &v388);
  v90 = v388;

  if ((v115 & 1) == 0)
  {
    if (v90
      && (v195 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps")),
          v196 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v195, "lockStateTracker")),
          v197 = objc_msgSend(v196, "isLockedError:", v90),
          v196,
          v195,
          v197))
    {
      v198 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
      v199 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v198, "zoneName"));
      v200 = sub_10000BDF4(CFSTR("ckkskey"), v199);
      v201 = objc_claimAutoreleasedReturnValue(v200);

      if (os_log_type_enabled(v201, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        *(_QWORD *)&buf[4] = v101;
        _os_log_impl((void *)&_mh_execute_header, v201, OS_LOG_TYPE_DEFAULT, "Received a TLK(%@), but keybag appears to be locked. Entering a waiting state.", buf, 0xCu);
      }

      v414 = CFSTR("isLocked");
      v415 = &__kCFBooleanTrue;
      v202 = objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v415, &v414, 1));
      -[AAFAnalyticsEventSecurity addMetrics:](v335, "addMetrics:", v202);
      v203 = off_1002E9DE0;
    }
    else
    {
      v204 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
      v205 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v204, "zoneName"));
      v206 = sub_10000BDF4(CFSTR("ckkskey"), v205);
      v202 = objc_claimAutoreleasedReturnValue(v206);

      if (os_log_type_enabled(v202, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412546;
        *(_QWORD *)&buf[4] = v101;
        *(_WORD *)&buf[12] = 2112;
        *(_QWORD *)&buf[14] = v90;
        _os_log_impl((void *)&_mh_execute_header, v202, OS_LOG_TYPE_DEFAULT, "Received a TLK(%@) which we don't have in the local keychain: %@", buf, 0x16u);
      }
      v203 = &off_1002E9DE8;
    }

    objc_msgSend(*(id *)(a1 + 32), "setViewKeyHierarchyState:", *v203);
    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", v335, 0, v90);
LABEL_113:
    v91 = 1;
    goto LABEL_114;
  }
  v116 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "currentTLKPointer"));
  v117 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v116, "currentKeyUUID"));
  v118 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v101, "uuid"));
  v316 = objc_msgSend(v117, "isEqualToString:", v118);

  if ((v316 & 1) == 0)
  {
    objc_msgSend(v343, "setTlk:", v101);
    v119 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v101, "uuid"));
    v120 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "currentTLKPointer"));
    objc_msgSend(v120, "setCurrentKeyUUID:", v119);

  }
  v386 = 0u;
  v387 = 0u;
  v384 = 0u;
  v385 = 0u;
  v327 = obja;
  toa = (id *)objc_msgSend(v327, "countByEnumeratingWithState:objects:count:", &v384, v413, 16);
  if (!toa)
  {
    from = 0;
    v324 = 0;
    goto LABEL_152;
  }
  from = 0;
  v324 = 0;
  v332 = *(_QWORD *)v385;
  do
  {
    for (i = 0; i != toa; i = (id *)((char *)i + 1))
    {
      if (*(_QWORD *)v385 != v332)
        objc_enumerationMutation(v327);
      v122 = *(void **)(*((_QWORD *)&v384 + 1) + 8 * (_QWORD)i);
      v123 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v122, "parentKeyUUID"));
      v124 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v101, "uuid"));
      v125 = objc_msgSend(v123, "isEqualToString:", v124);

      if (v125)
      {
        v126 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v122, "keyclass"));
        if (!objc_msgSend(v126, "isEqualToString:", CFSTR("classA")))
          goto LABEL_93;
        v127 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "currentClassAPointer"));
        v128 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v127, "currentKeyUUID"));
        if (v128)
        {
          v129 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "classA"));
          v130 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v129, "parentKeyUUID"));
          v131 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v101, "uuid"));
          if (objc_msgSend(v130, "isEqualToString:", v131))
          {
            v132 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "classA"));
            v318 = v132 == 0;

            if (v318)
            {
LABEL_92:
              objc_msgSend(v343, "setClassA:", v122);
              v126 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v122, "uuid"));
              v133 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "currentClassAPointer"));
              objc_msgSend(v133, "setCurrentKeyUUID:", v126);

              v324 = 1;
LABEL_93:

            }
            v134 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v122, "keyclass"));
            if (!objc_msgSend(v134, "isEqualToString:", CFSTR("classC")))
              goto LABEL_102;
            v135 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "currentClassCPointer"));
            v136 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v135, "currentKeyUUID"));
            if (v136)
            {
              v137 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "classC"));
              v138 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v137, "parentKeyUUID"));
              v139 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v101, "uuid"));
              if (objc_msgSend(v138, "isEqualToString:", v139))
              {
                v140 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "classC"));
                v319 = v140 == 0;

                if (!v319)
                  continue;
LABEL_101:
                objc_msgSend(v343, "setClassC:", v122);
                v134 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v122, "uuid"));
                v141 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "currentClassCPointer"));
                objc_msgSend(v141, "setCurrentKeyUUID:", v134);

                from = 1;
LABEL_102:

                continue;
              }

            }
            goto LABEL_101;
          }

        }
        goto LABEL_92;
      }
    }
    toa = (id *)objc_msgSend(v327, "countByEnumeratingWithState:objects:count:", &v384, v413, 16);
  }
  while (toa);
LABEL_152:

  v207 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "currentClassAPointer"));
  v208 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v207, "currentKeyUUID"));
  v209 = v208 == 0;

  if (!v209)
  {
    v320 = 0;
    goto LABEL_154;
  }
  v383 = v90;
  v320 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSKey randomKeyWrappedByParent:keyclass:error:](CKKSKey, "randomKeyWrappedByParent:keyclass:error:", v101, CFSTR("classA"), &v383));
  v238 = v383;

  v382 = v238;
  objc_msgSend(v320, "saveKeyMaterialToKeychain:", &v382);
  v90 = v382;

  if (v90)
  {
    v239 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
    v240 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v239, "lockStateTracker"));
    v241 = objc_msgSend(v240, "isLockedError:", v90);

    v242 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v243 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v242, "zoneName"));
    v244 = sub_10000BDF4(CFSTR("ckksheal"), v243);
    v245 = objc_claimAutoreleasedReturnValue(v244);

    if (v241)
    {
      if (os_log_type_enabled(v245, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v245, OS_LOG_TYPE_DEFAULT, "Couldn't create a new class A key, but keybag appears to be locked. Entering waitforunlock.", buf, 2u);
      }

      objc_msgSend(*(id *)(a1 + 32), "setViewKeyHierarchyState:", CFSTR("waitforunlock"));
      v411 = CFSTR("isLocked");
      v412 = &__kCFBooleanTrue;
      v246 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v412, &v411, 1));
      -[AAFAnalyticsEventSecurity addMetrics:](v335, "addMetrics:", v246);

      +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", v335, 0, v90);
    }
    else
    {
      if (os_log_type_enabled(v245, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        *(_QWORD *)&buf[4] = v90;
        _os_log_impl((void *)&_mh_execute_header, v245, OS_LOG_TYPE_ERROR, "couldn't create new classA key: %@", buf, 0xCu);
      }

      objc_msgSend(*(id *)(a1 + 32), "setViewKeyHierarchyState:", CFSTR("error"));
      +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", v335, 0, v90);

    }
    goto LABEL_113;
  }
  objc_msgSend(v343, "setClassA:", v320);
  v310 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v320, "uuid"));
  v311 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "currentClassAPointer"));
  objc_msgSend(v311, "setCurrentKeyUUID:", v310);

  v90 = 0;
  v324 = 1;
LABEL_154:
  v210 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "currentClassCPointer"));
  v211 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v210, "currentKeyUUID"));
  v212 = v211 == 0;

  if (v212)
  {
    v381 = v90;
    v317 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSKey randomKeyWrappedByParent:keyclass:error:](CKKSKey, "randomKeyWrappedByParent:keyclass:error:", v101, CFSTR("classC"), &v381));
    v247 = v381;

    v380 = v247;
    objc_msgSend(v317, "saveKeyMaterialToKeychain:", &v380);
    v90 = v380;

    if (v90)
    {
      v248 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
      v249 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v248, "lockStateTracker"));
      v250 = objc_msgSend(v249, "isLockedError:", v90);

      v251 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
      v252 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v251, "zoneName"));
      v253 = sub_10000BDF4(CFSTR("ckksheal"), v252);
      v254 = objc_claimAutoreleasedReturnValue(v253);

      if (v250)
      {
        if (os_log_type_enabled(v254, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v254, OS_LOG_TYPE_DEFAULT, "Couldn't create a new class C key, but keybag appears to be locked. Entering waitforunlock.", buf, 2u);
        }

        v409 = CFSTR("isLocked");
        v410 = &__kCFBooleanTrue;
        v255 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v410, &v409, 1));
        -[AAFAnalyticsEventSecurity addMetrics:](v335, "addMetrics:", v255);

        +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", v335, 0, v90);
        objc_msgSend(*(id *)(a1 + 32), "setViewKeyHierarchyState:", CFSTR("waitforunlock"));

      }
      else
      {
        if (os_log_type_enabled(v254, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412290;
          *(_QWORD *)&buf[4] = v90;
          _os_log_impl((void *)&_mh_execute_header, v254, OS_LOG_TYPE_ERROR, "couldn't create new class C key: %@", buf, 0xCu);
        }

        objc_msgSend(*(id *)(a1 + 32), "setViewKeyHierarchyState:", CFSTR("error"));
        +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", v335, 0, v90);

      }
      goto LABEL_113;
    }
    objc_msgSend(v343, "setClassC:", v317);
    v312 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v317, "uuid"));
    v313 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "currentClassCPointer"));
    objc_msgSend(v313, "setCurrentKeyUUID:", v312);

    v90 = 0;
    from = 1;
  }
  else
  {
    v317 = 0;
  }
  v213 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
  v214 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v213, "zoneName"));
  v215 = sub_10000BDF4(CFSTR("ckksheal"), v214);
  v216 = objc_claimAutoreleasedReturnValue(v215);

  if (os_log_type_enabled(v216, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    *(_QWORD *)&buf[4] = v343;
    _os_log_impl((void *)&_mh_execute_header, v216, OS_LOG_TYPE_DEFAULT, "Attempting to move to new key hierarchy: %@", buf, 0xCu);
  }

  if (v320)
  {
    v217 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v218 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v320, "CKRecordWithZoneID:", v217));
    objc_msgSend(v330, "addObject:", v218);

  }
  v219 = a1;
  if (v317)
  {
    v220 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v221 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v317, "CKRecordWithZoneID:", v220));
    objc_msgSend(v330, "addObject:", v221);

    v219 = a1;
  }
  if ((v316 & 1) == 0)
  {
    v222 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "currentTLKPointer"));
    v223 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v224 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v222, "CKRecordWithZoneID:", v223));
    objc_msgSend(v330, "addObject:", v224);

    v219 = a1;
  }
  if ((v324 & 1) != 0)
  {
    v225 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "currentClassAPointer"));
    v226 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v227 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v225, "CKRecordWithZoneID:", v226));
    objc_msgSend(v330, "addObject:", v227);

    v219 = a1;
  }
  if ((from & 1) != 0)
  {
    v228 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v343, "currentClassCPointer"));
    v229 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v230 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v228, "CKRecordWithZoneID:", v229));
    objc_msgSend(v330, "addObject:", v230);

    v219 = a1;
  }
  v231 = *(_QWORD *)(v219 + 56);
  v379 = v90;
  v314 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSHealTLKSharesOperation createMissingKeyShares:trustStates:databaseProvider:error:](CKKSHealTLKSharesOperation, "createMissingKeyShares:trustStates:databaseProvider:error:", v343, v231, 0, &v379));
  v315 = v379;

  v407 = CFSTR("newTLKShares");
  v232 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(v314, "count")));
  v408 = v232;
  v233 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v408, &v407, 1));
  -[AAFAnalyticsEventSecurity addMetrics:](v335, "addMetrics:", v233);

  if (v315)
  {
    v234 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v235 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v234, "zoneName"));
    v236 = sub_10000BDF4(CFSTR("ckksshare"), v235);
    v237 = objc_claimAutoreleasedReturnValue(v236);

    if (os_log_type_enabled(v237, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)&buf[4] = v315;
      _os_log_impl((void *)&_mh_execute_header, v237, OS_LOG_TYPE_ERROR, "Unable to create TLK shares for new tlk: %@", buf, 0xCu);
    }

    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", v335, 0, v315);
    v91 = 0;
  }
  else
  {
    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", v335, 1, 0);
    v377 = 0u;
    v378 = 0u;
    v375 = 0u;
    v376 = 0u;
    v256 = v314;
    v257 = objc_msgSend(v256, "countByEnumeratingWithState:objects:count:", &v375, v406, 16);
    if (v257)
    {
      v258 = *(_QWORD *)v376;
      do
      {
        for (j = 0; j != v257; j = (char *)j + 1)
        {
          if (*(_QWORD *)v376 != v258)
            objc_enumerationMutation(v256);
          v260 = *(void **)(*((_QWORD *)&v375 + 1) + 8 * (_QWORD)j);
          v261 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
          v262 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v260, "CKRecordWithZoneID:", v261));

          objc_msgSend(v330, "addObject:", v262);
        }
        v257 = objc_msgSend(v256, "countByEnumeratingWithState:objects:count:", &v375, v406, 16);
      }
      while (v257);
    }

    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v405 = 1;
    v263 = [AAFAnalyticsEventSecurity alloc];
    v402[0] = CFSTR("totalCKRecords");
    v264 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(v330, "count")));
    v402[1] = CFSTR("isPrioritized");
    v403[0] = v264;
    v403[1] = &__kCFBooleanFalse;
    v265 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v403, v402, 2));
    v266 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
    v267 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v266, "activeAccount"));
    v268 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v267, "altDSID"));
    v269 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
    v325 = -[AAFAnalyticsEventSecurity initWithCKKSMetrics:altDSID:eventName:testsAreEnabled:category:sendMetric:](v263, "initWithCKKSMetrics:altDSID:eventName:testsAreEnabled:category:sendMetric:", v265, v268, CFSTR("com.apple.security.ckks.healKeyHierarchy.uploadHealedTLKShares"), 0, &off_10030AF70, objc_msgSend(v269, "sendMetric"));

    v400 = CFSTR("isPrioritized");
    v401 = &__kCFBooleanTrue;
    v270 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v401, &v400, 1));
    -[AAFAnalyticsEventSecurity addMetrics:](v325, "addMetrics:", v270);

    v271 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v272 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v271, "zoneName"));
    v273 = sub_10000BDF4(CFSTR("ckksheal"), v272);
    v274 = objc_claimAutoreleasedReturnValue(v273);

    if (os_log_type_enabled(v274, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v398 = 138412290;
      v399 = v330;
      _os_log_impl((void *)&_mh_execute_header, v274, OS_LOG_TYPE_DEFAULT, "Saving new records %@", v398, 0xCu);
    }

    v275 = 0;
    for (k = a1; ; k = a1)
    {
      v277 = 1000 * (_QWORD)v275;
      if (1000 * (uint64_t)v275 >= (unint64_t)objc_msgSend(v330, "count"))
        break;
      v328 = v275;
      v278 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(k + 32), "zoneName"));
      v279 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("heal-cloudkit-modify-operation-finished-%@"), v278));
      v368[0] = _NSConcreteStackBlock;
      v368[1] = 3221225472;
      v368[2] = sub_100097BCC;
      v368[3] = &unk_1002E9568;
      v280 = v330;
      v369 = v280;
      v374 = v277;
      v333 = v325;
      v370 = v333;
      v372 = buf;
      v281 = *(id *)(k + 48);
      v282 = *(_QWORD *)(k + 64);
      v371 = v281;
      v373 = v282;
      v283 = (void *)objc_claimAutoreleasedReturnValue(+[NSBlockOperation named:withBlock:](NSBlockOperation, "named:withBlock:", v279, v368));

      objc_msgSend(*(id *)(a1 + 40), "dependOnBeforeGroupFinished:", v283);
      v284 = objc_alloc_init((Class)NSMutableDictionary);
      v285 = (char *)objc_msgSend(v280, "count");
      if ((unint64_t)&v285[-v277] >= 0x3E8)
        v286 = 1000;
      else
        v286 = (uint64_t)&v285[-v277];
      v287 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v280, "subarrayWithRange:", v277, v286));
      v366 = 0u;
      v367 = 0u;
      v364 = 0u;
      v365 = 0u;
      v288 = v287;
      v289 = objc_msgSend(v288, "countByEnumeratingWithState:objects:count:", &v364, v397, 16);
      if (v289)
      {
        v290 = *(_QWORD *)v365;
        do
        {
          for (m = 0; m != v289; m = (char *)m + 1)
          {
            if (*(_QWORD *)v365 != v290)
              objc_enumerationMutation(v288);
            v292 = *(void **)(*((_QWORD *)&v364 + 1) + 8 * (_QWORD)m);
            v293 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v292, "recordID"));
            objc_msgSend(v284, "setObject:forKeyedSubscript:", v292, v293);

          }
          v289 = objc_msgSend(v288, "countByEnumeratingWithState:objects:count:", &v364, v397, 16);
        }
        while (v289);
      }

      v294 = objc_msgSend(objc_alloc((Class)CKModifyRecordsOperation), "initWithRecordsToSave:recordIDsToDelete:", v288, 0);
      objc_msgSend(v294, "setAtomic:", 1);
      objc_msgSend(v294, "setLongLived:", 0);
      v295 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v294, "configuration"));
      objc_msgSend(v295, "setIsCloudKitSupportOperation:", 1);

      objc_msgSend(v294, "setQualityOfService:", 25);
      v296 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
      v297 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v296, "ckoperationGroup"));
      objc_msgSend(v294, "setGroup:", v297);

      v298 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
      v299 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v298, "zoneName"));
      v300 = sub_10000BDF4(CFSTR("ckksheal"), v299);
      v301 = objc_claimAutoreleasedReturnValue(v300);

      if (os_log_type_enabled(v301, OS_LOG_TYPE_DEFAULT))
      {
        v302 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
        v303 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v302, "ckoperationGroup"));
        *(_DWORD *)v398 = 138412290;
        v399 = v303;
        _os_log_impl((void *)&_mh_execute_header, v301, OS_LOG_TYPE_DEFAULT, "Operation group is %@", v398, 0xCu);

      }
      v360[0] = _NSConcreteStackBlock;
      v360[1] = 3221225472;
      v360[2] = sub_100097C44;
      v360[3] = &unk_1002DC7A8;
      v361 = *(id *)(a1 + 32);
      v362 = buf;
      v363 = *(_QWORD *)(a1 + 64);
      objc_msgSend(v294, "setPerRecordSaveBlock:", v360);
      v346[0] = _NSConcreteStackBlock;
      v346[1] = 3221225472;
      v346[2] = sub_100097E04;
      v346[3] = &unk_1002DC7F8;
      objc_copyWeak(&v359, (id *)(a1 + 80));
      v347 = *(id *)(a1 + 32);
      v348 = v101;
      v349 = v320;
      v350 = v317;
      v351 = v343;
      v352 = v256;
      v304 = v335;
      v305 = *(_QWORD *)(a1 + 64);
      v353 = v304;
      v357 = v305;
      v358 = buf;
      v354 = v333;
      v306 = v284;
      v355 = v306;
      v307 = v283;
      v356 = v307;
      objc_msgSend(v294, "setModifyRecordsCompletionBlock:", v346);
      v308 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "setResultStateOperation"));
      objc_msgSend(v308, "addDependency:", v307);

      v309 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "ckOperations"));
      objc_msgSend(v294, "linearDependencies:", v309);

      objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 40), "addObject:", v294);
      objc_destroyWeak(&v359);

      v275 = v328 + 1;
    }

    _Block_object_dispose(buf, 8);
    v91 = 1;
  }

  v90 = v315;
LABEL_114:

LABEL_115:
  return v91;
}

void sub_100097B5C(_Unwind_Exception *a1)
{
  _Block_object_dispose(&STACK[0x3E0], 8);
  _Unwind_Resume(a1);
}

char *sub_100097BCC(uint64_t a1)
{
  char *result;

  result = (char *)objc_msgSend(*(id *)(a1 + 32), "count");
  if ((unint64_t)&result[-*(_QWORD *)(a1 + 72)] <= 0x3E8)
  {
    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", *(_QWORD *)(a1 + 40), *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24), 0);
    return (char *)+[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", *(_QWORD *)(a1 + 48), *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24), 0);
  }
  return result;
}

void sub_100097C44(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v6;
  id v7;
  void *v8;
  void *v9;
  id v10;
  NSObject *v11;
  void *v12;
  void *v13;
  id v14;
  void *v15;
  int v16;
  id v17;
  __int16 v18;
  id v19;

  v6 = a2;
  v7 = a4;
  if (v7)
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = 0;
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "zoneName"));
    v10 = sub_10000BDF4(CFSTR("ckksheal"), v9);
    v11 = objc_claimAutoreleasedReturnValue(v10);

    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v16 = 138412546;
      v17 = v7;
      v18 = 2112;
      v19 = v6;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "error on row: %@ %@", (uint8_t *)&v16, 0x16u);
    }
  }
  else
  {
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "zoneName"));
    v14 = sub_10000BDF4(CFSTR("ckksheal"), v13);
    v11 = objc_claimAutoreleasedReturnValue(v14);

    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "recordName"));
      v16 = 138412290;
      v17 = v15;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Successfully completed upload for %@", (uint8_t *)&v16, 0xCu);

    }
  }

}

void sub_100097E04(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v6;
  id v7;
  id WeakRetained;
  void *v9;
  void *v10;
  id v11;
  NSObject *v12;
  void *v13;
  void *v14;
  id v15;
  id v16;
  void *v17;
  void **v18;
  uint64_t v19;
  uint64_t (*v20)(uint64_t);
  void *v21;
  id v22;
  id v23;
  id v24;
  id v25;
  id v26;
  id v27;
  id v28;
  id v29;
  id v30;
  id v31;
  id v32;
  id v33;
  __int128 v34;
  uint8_t buf[4];
  id v36;

  v6 = a2;
  v7 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 128));
  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "zoneName"));
  v11 = sub_10000BDF4(CFSTR("ckksheal"), v10);
  v12 = objc_claimAutoreleasedReturnValue(v11);

  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    v36 = v7;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Completed Key Heal CloudKit operation with error: %@", buf, 0xCu);
  }

  v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
  v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "databaseProvider"));
  v18 = _NSConcreteStackBlock;
  v19 = 3221225472;
  v20 = sub_100098074;
  v21 = &unk_1002DC7D0;
  v22 = v7;
  v23 = *(id *)(a1 + 32);
  v24 = v6;
  v25 = *(id *)(a1 + 40);
  v26 = *(id *)(a1 + 48);
  v27 = *(id *)(a1 + 56);
  v28 = *(id *)(a1 + 64);
  v29 = *(id *)(a1 + 72);
  v30 = *(id *)(a1 + 80);
  v31 = WeakRetained;
  v34 = *(_OWORD *)(a1 + 112);
  v32 = *(id *)(a1 + 88);
  v33 = *(id *)(a1 + 96);
  v15 = v6;
  v16 = v7;
  objc_msgSend(v14, "dispatchSyncWithSQLTransaction:", &v18);

  v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "operationQueue", v18, v19, v20, v21));
  objc_msgSend(v17, "addOperation:", *(_QWORD *)(a1 + 104));

}

uint64_t sub_100098074(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  id v9;
  NSObject *v10;
  void *v11;
  void *v12;
  void *v13;
  uint64_t v14;
  void *v15;
  void *v16;
  id v17;
  id v18;
  id v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  void *v23;
  void *v24;
  unsigned int v25;
  void *v26;
  void *v27;
  void *v28;
  unsigned int v29;
  void *v30;
  void *v31;
  unsigned int v32;
  void *v33;
  id v34;
  void *v35;
  id v36;
  void *v37;
  id v38;
  void *v39;
  id v40;
  void *v41;
  id v42;
  void *v43;
  id v44;
  void *v45;
  id v46;
  id v47;
  id v48;
  id v49;
  uint64_t v50;
  void *v51;
  void *v52;
  void *v53;
  void *v54;
  void *v55;
  void *v56;
  id v57;
  NSObject *v58;
  void *v59;
  id v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  id v66;
  id v67;
  id v68;
  id v69;
  id v70;
  id v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  uint8_t buf[4];
  id v77;
  _BYTE v78[128];
  _BYTE v79[128];

  v2 = *(_QWORD *)(a1 + 32);
  v3 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  if (v2)
  {
    v4 = *(_QWORD *)(a1 + 32);
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "zoneID"));
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "zoneName"));
    objc_msgSend(v3, "logUnrecoverableError:forEvent:zoneName:withAttributes:", v4, CFSTR("CKKSEventProcessHealKeyHierarchy"), v6, 0);

    v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "zoneID"));
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "zoneName"));
    v9 = sub_10000BDF4(CFSTR("ckksheal"), v8);
    v10 = objc_claimAutoreleasedReturnValue(v9);

    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v11 = *(void **)(a1 + 32);
      *(_DWORD *)buf = 138412290;
      v77 = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "couldn't save new key hierarchy to CloudKit: %@", buf, 0xCu);
    }

    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) + 24) = 0;
    objc_msgSend(*(id *)(a1 + 112), "populateUnderlyingErrorsStartingWithRootError:", *(_QWORD *)(a1 + 32));
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 8) + 24) = 0;
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 104), "deps"));
    objc_msgSend(v12, "intransactionCKWriteFailed:attemptedRecordsChanged:", *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 120));

    v13 = *(void **)(a1 + 104);
    v14 = 1;
    objc_msgSend(v13, "setCloudkitWriteFailures:", 1);
    return v14;
  }
  v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "zoneID"));
  v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "zoneName"));
  objc_msgSend(v3, "logSuccessForEvent:zoneName:", CFSTR("CKKSEventProcessHealKeyHierarchy"), v16);

  v74 = 0u;
  v75 = 0u;
  v73 = 0u;
  v72 = 0u;
  v17 = *(id *)(a1 + 48);
  v18 = objc_msgSend(v17, "countByEnumeratingWithState:objects:count:", &v72, v79, 16);
  if (!v18)
    goto LABEL_27;
  v19 = v18;
  v20 = *(_QWORD *)v73;
  do
  {
    v21 = 0;
    do
    {
      if (*(_QWORD *)v73 != v20)
        objc_enumerationMutation(v17);
      v22 = *(_QWORD *)(*((_QWORD *)&v72 + 1) + 8 * (_QWORD)v21);
      if (objc_msgSend(*(id *)(a1 + 56), "matchesCKRecord:", v22))
      {
        v23 = *(void **)(a1 + 56);
LABEL_16:
        objc_msgSend(v23, "setStoredCKRecord:", v22);
        goto LABEL_17;
      }
      if (objc_msgSend(*(id *)(a1 + 64), "matchesCKRecord:", v22))
      {
        v23 = *(void **)(a1 + 64);
        goto LABEL_16;
      }
      if (objc_msgSend(*(id *)(a1 + 72), "matchesCKRecord:", v22))
      {
        v23 = *(void **)(a1 + 72);
        goto LABEL_16;
      }
      v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 80), "currentTLKPointer"));
      v25 = objc_msgSend(v24, "matchesCKRecord:", v22);

      v26 = *(void **)(a1 + 80);
      if (v25)
      {
        v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "currentTLKPointer"));
      }
      else
      {
        v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "currentClassAPointer"));
        v29 = objc_msgSend(v28, "matchesCKRecord:", v22);

        v30 = *(void **)(a1 + 80);
        if (v29)
        {
          v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "currentClassAPointer"));
        }
        else
        {
          v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "currentClassCPointer"));
          v32 = objc_msgSend(v31, "matchesCKRecord:", v22);

          if (!v32)
            goto LABEL_17;
          v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 80), "currentClassCPointer"));
        }
      }
      v33 = v27;
      objc_msgSend(v27, "setStoredCKRecord:", v22);

LABEL_17:
      v21 = (char *)v21 + 1;
    }
    while (v19 != v21);
    v34 = objc_msgSend(v17, "countByEnumeratingWithState:objects:count:", &v72, v79, 16);
    v19 = v34;
  }
  while (v34);
LABEL_27:

  v35 = *(void **)(a1 + 56);
  v71 = 0;
  objc_msgSend(v35, "saveToDatabaseAsOnlyCurrentKeyForClassAndState:", &v71);
  v36 = v71;
  v37 = *(void **)(a1 + 64);
  v70 = v36;
  objc_msgSend(v37, "saveToDatabaseAsOnlyCurrentKeyForClassAndState:", &v70);
  v38 = v70;

  v39 = *(void **)(a1 + 72);
  v69 = v38;
  objc_msgSend(v39, "saveToDatabaseAsOnlyCurrentKeyForClassAndState:", &v69);
  v40 = v69;

  v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 80), "currentTLKPointer"));
  v68 = v40;
  objc_msgSend(v41, "saveToDatabase:", &v68);
  v42 = v68;

  v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 80), "currentClassAPointer"));
  v67 = v42;
  objc_msgSend(v43, "saveToDatabase:", &v67);
  v44 = v67;

  v45 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 80), "currentClassCPointer"));
  v66 = v44;
  objc_msgSend(v45, "saveToDatabase:", &v66);
  v46 = v66;

  v64 = 0u;
  v65 = 0u;
  v62 = 0u;
  v63 = 0u;
  v47 = *(id *)(a1 + 88);
  v48 = objc_msgSend(v47, "countByEnumeratingWithState:objects:count:", &v62, v78, 16);
  if (v48)
  {
    v49 = v48;
    v50 = *(_QWORD *)v63;
    do
    {
      v51 = 0;
      v52 = v46;
      do
      {
        if (*(_QWORD *)v63 != v50)
          objc_enumerationMutation(v47);
        v53 = *(void **)(*((_QWORD *)&v62 + 1) + 8 * (_QWORD)v51);
        v61 = v52;
        objc_msgSend(v53, "saveToDatabase:", &v61);
        v46 = v61;

        v51 = (char *)v51 + 1;
        v52 = v46;
      }
      while (v49 != v51);
      v49 = objc_msgSend(v47, "countByEnumeratingWithState:objects:count:", &v62, v78, 16);
    }
    while (v49);
  }

  v54 = *(void **)(a1 + 40);
  if (v46)
  {
    v55 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v54, "zoneID"));
    v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v55, "zoneName"));
    v57 = sub_10000BDF4(CFSTR("ckksheal"), v56);
    v58 = objc_claimAutoreleasedReturnValue(v57);

    if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      v77 = v46;
      _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_ERROR, "couldn't save new key hierarchy to database; this is very bad: %@",
        buf,
        0xCu);
    }

    objc_msgSend(*(id *)(a1 + 96), "populateUnderlyingErrorsStartingWithRootError:", v46);
    objc_msgSend(*(id *)(a1 + 40), "setViewKeyHierarchyState:", CFSTR("error"));
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 8) + 24) = 0;

    return 0;
  }
  else
  {
    objc_msgSend(v54, "setViewKeyHierarchyState:", CFSTR("process_key_hierarchy"));
    v59 = *(void **)(a1 + 104);
    v14 = 1;
    objc_msgSend(v59, "setNewCloudKitRecordsWritten:", 1);
  }
  return v14;
}

void sub_100098658(uint64_t a1)
{
  id WeakRetained;
  id v2;
  NSObject *v3;
  const __CFString *v4;
  id v5;
  NSObject *v6;
  void *v7;
  uint8_t v8[16];
  uint8_t buf[16];

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (objc_msgSend(WeakRetained, "cloudkitWriteFailures"))
  {
    v2 = sub_10000BDF4(CFSTR("ckksheal"), 0);
    v3 = objc_claimAutoreleasedReturnValue(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Due to write failures, we'll try to fetch the current state", buf, 2u);
    }

    v4 = CFSTR("begin_fetch");
  }
  else
  {
    if (!objc_msgSend(WeakRetained, "newCloudKitRecordsWritten"))
    {
      v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "intendedState"));
      objc_msgSend(WeakRetained, "setNextState:", v7);

      goto LABEL_11;
    }
    v5 = sub_10000BDF4(CFSTR("ckksheal"), 0);
    v6 = objc_claimAutoreleasedReturnValue(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v8 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Some records were written! Process them", v8, 2u);
    }

    v4 = CFSTR("process_key_hierarchy");
  }
  objc_msgSend(WeakRetained, "setNextState:", v4);
LABEL_11:

}

void sub_100099AD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10009A5BC(uint64_t a1, void *a2)
{
  id v3;

  v3 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(a2, "objectForKeyedSubscript:", CFSTR("count(*)")));
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = objc_msgSend(v3, "asNSInteger");

}

void sub_10009DD88(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_10009DE58(id *a1)
{
  unsigned int v2;
  void *v3;
  id v4;
  NSObject *v5;
  uint64_t v6;
  CKKSOutgoingQueueOperation *v7;
  void *v8;
  CKKSOutgoingQueueOperation *v9;
  void *v10;
  CKKSIncomingQueueOperation *v11;
  void *v12;
  CKKSIncomingQueueOperation *v13;
  void *v14;
  CKKSReloadAllItemsOperation *v15;
  void *v16;
  CKKSReloadAllItemsOperation *v17;
  void *v18;
  CKKSIncomingQueueOperation *v19;
  void *v20;
  CKKSIncomingQueueOperation *v21;
  void *v22;
  CKKSScanLocalItemsOperation *v23;
  void *v24;
  CKKSScanLocalItemsOperation *v25;
  void *v26;
  CKKSResultOperation *v27;
  void *v28;
  CKKSScanLocalItemsOperation *v29;
  unsigned int v31;
  uint64_t v32;
  _QWORD v33[4];
  id v34;
  CKKSScanLocalItemsOperation *v35;
  id v36;
  uint8_t buf[4];
  unsigned int v38;

  v2 = objc_msgSend(a1[4], "isCancelled");
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[5], "zoneName"));
  v4 = sub_10000BDF4(CFSTR("ckksresync"), v3);
  v5 = objc_claimAutoreleasedReturnValue(v4);

  if (v2)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "CKKSSynchronizeOperation cancelled, quitting", buf, 2u);
    }
    v6 = 0;
  }
  else
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      v31 = objc_msgSend(a1[4], "restartCount");
      *(_DWORD *)buf = 67109120;
      v38 = v31;
      _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Beginning local resynchronize (attempt %u)", buf, 8u);
    }

    v32 = objc_claimAutoreleasedReturnValue(+[CKOperationGroup CKKSGroupWithName:](CKOperationGroup, "CKKSGroupWithName:", CFSTR("ckks-resync-local")));
    v7 = [CKKSOutgoingQueueOperation alloc];
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[5], "operationDependencies"));
    v9 = -[CKKSOutgoingQueueOperation initWithDependencies:intending:ckErrorState:errorState:](v7, "initWithDependencies:intending:ckErrorState:errorState:", v8, CFSTR("ready"), CFSTR("process_outgoing_queue_failed"), CFSTR("error"));

    v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("resync-step%u-outgoing"), 5 * objc_msgSend(a1[4], "restartCount") + 1));
    -[CKKSGroupOperation setName:](v9, "setName:", v10);

    objc_msgSend(a1[4], "runBeforeGroupFinished:", v9);
    v11 = [CKKSIncomingQueueOperation alloc];
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[5], "operationDependencies"));
    v13 = -[CKKSIncomingQueueOperation initWithDependencies:intending:pendingClassAItemsRemainingState:errorState:handleMismatchedViewItems:](v11, "initWithDependencies:intending:pendingClassAItemsRemainingState:errorState:handleMismatchedViewItems:", v12, CFSTR("ready"), CFSTR("ready"), CFSTR("unhealthy"), 0);

    v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("resync-step%u-incoming"), 5 * objc_msgSend(a1[4], "restartCount") + 2));
    -[CKKSIncomingQueueOperation setName:](v13, "setName:", v14);

    -[CKKSResultOperation addSuccessDependency:](v13, "addSuccessDependency:", v9);
    objc_msgSend(a1[4], "runBeforeGroupFinished:", v13);
    v15 = [CKKSReloadAllItemsOperation alloc];
    v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[5], "operationDependencies"));
    v17 = -[CKKSReloadAllItemsOperation initWithOperationDependencies:](v15, "initWithOperationDependencies:", v16);

    v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("resync-step%u-reload"), 5 * objc_msgSend(a1[4], "restartCount") + 3));
    -[CKKSReloadAllItemsOperation setName:](v17, "setName:", v18);

    objc_msgSend(a1[4], "runBeforeGroupFinished:", v17);
    v19 = [CKKSIncomingQueueOperation alloc];
    v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[5], "operationDependencies"));
    v21 = -[CKKSIncomingQueueOperation initWithDependencies:intending:pendingClassAItemsRemainingState:errorState:handleMismatchedViewItems:](v19, "initWithDependencies:intending:pendingClassAItemsRemainingState:errorState:handleMismatchedViewItems:", v20, CFSTR("ready"), CFSTR("ready"), CFSTR("unhealthy"), 0);

    v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("resync-step%u-incoming-again"), 5 * objc_msgSend(a1[4], "restartCount") + 4));
    -[CKKSIncomingQueueOperation setName:](v21, "setName:", v22);

    -[CKKSResultOperation addSuccessDependency:](v21, "addSuccessDependency:", v17);
    objc_msgSend(a1[4], "runBeforeGroupFinished:", v21);
    v23 = [CKKSScanLocalItemsOperation alloc];
    v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[5], "operationDependencies"));
    v25 = -[CKKSScanLocalItemsOperation initWithDependencies:intending:errorState:ckoperationGroup:](v23, "initWithDependencies:intending:errorState:ckoperationGroup:", v24, CFSTR("ready"), CFSTR("error"), v32);

    v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("resync-step%u-scan"), 5 * objc_msgSend(a1[4], "restartCount") + 5));
    -[CKKSScanLocalItemsOperation setName:](v25, "setName:", v26);

    -[CKKSResultOperation addSuccessDependency:](v25, "addSuccessDependency:", v21);
    objc_msgSend(a1[4], "runBeforeGroupFinished:", v25);
    v27 = objc_alloc_init(CKKSResultOperation);
    v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("resync-step%u-consider-restart"), 5 * objc_msgSend(a1[4], "restartCount") + 6));
    -[CKKSResultOperation setName:](v27, "setName:", v28);

    v33[0] = _NSConcreteStackBlock;
    v33[1] = 3221225472;
    v33[2] = sub_10009E3EC;
    v33[3] = &unk_1002EB5C0;
    objc_copyWeak(&v36, a1 + 6);
    v34 = a1[5];
    v29 = v25;
    v35 = v29;
    -[CKKSResultOperation addExecutionBlock:](v27, "addExecutionBlock:", v33);
    -[CKKSResultOperation addSuccessDependency:](v27, "addSuccessDependency:", v29);
    objc_msgSend(a1[4], "runBeforeGroupFinished:", v27);

    objc_destroyWeak(&v36);
    v6 = 1;
    v5 = v32;
  }

  return v6;
}

void sub_10009E3CC(_Unwind_Exception *a1)
{
  id *v1;

  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_10009E3EC(id *a1)
{
  id WeakRetained;
  void *v3;
  void *v4;
  void *v5;
  id v6;
  id v7;
  uint64_t v8;
  void *i;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  NSObject *v14;
  void *v15;
  id v16;
  NSObject *v17;
  void *v18;
  id v19;
  NSObject *v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  void *v25;
  id v26;
  NSObject *v27;
  id v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  NSErrorUserInfoKey v33;
  const __CFString *v34;
  uint8_t buf[4];
  NSObject *v36;
  _BYTE v37[128];

  WeakRetained = objc_loadWeakRetained(a1 + 6);
  if (WeakRetained)
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](NSMutableSet, "set"));
    v29 = 0u;
    v30 = 0u;
    v31 = 0u;
    v32 = 0u;
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "operationDependencies"));
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "activeManagedViews"));

    v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v29, v37, 16);
    if (v6)
    {
      v7 = v6;
      v8 = *(_QWORD *)v30;
      do
      {
        for (i = 0; i != v7; i = (char *)i + 1)
        {
          if (*(_QWORD *)v30 != v8)
            objc_enumerationMutation(v5);
          v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((_QWORD *)&v29 + 1) + 8 * (_QWORD)i), "zoneID"));
          objc_msgSend(v3, "addObject:", v10);

        }
        v7 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v29, v37, 16);
      }
      while (v7);
    }

    v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "operationDependencies"));
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "contextID"));
    v28 = 0;
    v13 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSSQLDatabaseObject allUUIDsWithContextID:inZones:error:](CKKSIncomingQueueEntry, "allUUIDsWithContextID:inZones:error:", v12, v3, &v28));
    v14 = v28;

    if (v14)
    {
      v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "zoneName"));
      v16 = sub_10000BDF4(CFSTR("ckksresync"), v15);
      v17 = objc_claimAutoreleasedReturnValue(v16);

      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        v36 = v14;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Couldn't fetch IQEs: %@", buf, 0xCu);
      }

    }
    if (objc_msgSend(a1[5], "recordsFound") || objc_msgSend(v13, "count"))
    {
      if ((int)objc_msgSend(WeakRetained, "restartCount") < 3)
      {
        objc_msgSend(WeakRetained, "setRestartCount:", objc_msgSend(WeakRetained, "restartCount") + 1);
        v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "zoneName"));
        v26 = sub_10000BDF4(CFSTR("ckksresync"), v25);
        v27 = objc_claimAutoreleasedReturnValue(v26);

        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "restarting synchronization operation due to new local items", buf, 2u);
        }

        objc_msgSend(WeakRetained, "groupStart");
      }
      else
      {
        v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "zoneName"));
        v19 = sub_10000BDF4(CFSTR("ckksresync"), v18);
        v20 = objc_claimAutoreleasedReturnValue(v19);

        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "restarted synchronization too often; Failing",
            buf,
            2u);
        }

        v33 = NSLocalizedDescriptionKey;
        v34 = CFSTR("resynchronization restarted too many times; churn in database?");
        v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v34, &v33, 1));
        v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("securityd"), 2, v21));
        objc_msgSend(WeakRetained, "setError:", v22);

      }
    }

  }
  else
  {
    v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "zoneName"));
    v24 = sub_10000BDF4(CFSTR("ckksresync"), v23);
    v14 = objc_claimAutoreleasedReturnValue(v24);

    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "received callback for released object", buf, 2u);
    }
  }

}

uint64_t sub_10009EA44(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  id v6;
  void *v7;
  void *v8;
  id v9;
  NSObject *v10;
  uint64_t v11;
  id v12;
  id v13;
  id v14;
  uint64_t v15;
  void *i;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  NSObject *v21;
  void *v22;
  void *v23;
  id v24;
  void *v26;
  void *v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  id v32;
  uint8_t v33[128];
  uint8_t buf[4];
  id v35;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "deps"));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "contextID"));
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "zoneID"));
  v32 = 0;
  v5 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSSQLDatabaseObject allWithContextID:zoneID:error:](CKKSMirrorEntry, "allWithContextID:zoneID:error:", v3, v4, &v32));
  v6 = v32;

  if (v6)
  {
    v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "zoneID"));
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "zoneName"));
    v9 = sub_10000BDF4(CFSTR("ckksresync"), v8);
    v10 = objc_claimAutoreleasedReturnValue(v9);

    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      v35 = v6;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Couldn't fetch mirror items: %@", buf, 0xCu);
    }

    objc_msgSend(*(id *)(a1 + 32), "setError:", v6);
    v11 = 0;
  }
  else
  {
    v26 = 0;
    v27 = v5;
    v30 = 0u;
    v31 = 0u;
    v28 = 0u;
    v29 = 0u;
    v12 = v5;
    v13 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v28, v33, 16);
    if (v13)
    {
      v14 = v13;
      v15 = *(_QWORD *)v29;
      do
      {
        for (i = 0; i != v14; i = (char *)i + 1)
        {
          if (*(_QWORD *)v29 != v15)
            objc_enumerationMutation(v12);
          v17 = *(void **)(*((_QWORD *)&v28 + 1) + 8 * (_QWORD)i);
          v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "item", v26, v27));
          v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "zoneID"));
          v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "CKRecordWithZoneID:", v19));

          if (v20)
          {
            v21 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "deps"));
            -[NSObject intransactionCKRecordChanged:resync:](v21, "intransactionCKRecordChanged:resync:", v20, 1);
          }
          else
          {
            v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "zoneID"));
            v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "zoneName"));
            v24 = sub_10000BDF4(CFSTR("ckksresync"), v23);
            v21 = objc_claimAutoreleasedReturnValue(v24);

            if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 138412290;
              v35 = v17;
              _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Couldn't make CKRecord for item: %@", buf, 0xCu);
            }
          }

        }
        v14 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v28, v33, 16);
      }
      while (v14);
    }

    v11 = 1;
    v6 = v26;
    v5 = v27;
  }

  return v11;
}

void sub_10009F880(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,id *location)
{
  uint64_t v21;

  objc_destroyWeak((id *)(v21 - 200));
  _Unwind_Resume(a1);
}

uint64_t sub_10009FB44(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_10009FB54(uint64_t a1)
{

}

id sub_10009FB5C(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;

  v3 = a2;
  v4 = objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "parsedSecureElementIdentity"));
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v6 = *(void **)(v5 + 40);
  *(_QWORD *)(v5 + 40) = v4;

  objc_msgSend(v3, "setAttemptedJoin:", 2);
  return v3;
}

void sub_10009FBAC(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  id v15;
  id v16;
  id v17;
  id v18;
  id v19;
  id v20;
  id v21;
  id WeakRetained;
  void *v23;
  const void *v24;
  NSObject *v25;
  void *v26;
  uint64_t v27;
  id v28;
  const void *v29;
  NSObject *v30;
  const void *v31;
  NSObject *v32;
  void *v33;
  void *v34;
  void *v35;
  id v36;
  unsigned int v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  const void *v42;
  NSObject *v43;
  void *v44;
  uint64_t v45;
  void *v46;
  id v47;
  id v48;
  id v49;
  void *v50;
  id v51;
  _QWORD v52[4];
  id v53;
  id v54;
  uint8_t buf[4];
  id v56;
  __int16 v57;
  id v58;
  __int16 v59;
  id v60;

  v15 = a2;
  v16 = a3;
  v17 = a4;
  v18 = a5;
  v19 = a6;
  v20 = a7;
  v21 = a8;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v23 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v23, "logResultForEvent:hardFailure:result:", CFSTR("OctagonEventPrepareIdentity"), 1, v21);

  v50 = v18;
  if (v21)
  {
    v24 = sub_10000EF14("SecError");
    v25 = objc_claimAutoreleasedReturnValue(v24);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v56 = v21;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "octagon: Error preparing identity: %@", buf, 0xCu);
    }

    objc_msgSend(WeakRetained, "setError:", v21);
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishedOp"));
    objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v26);

    v27 = *(_QWORD *)(a1 + 32);
    v28 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", v27, 0, v28);
  }
  else
  {
    v29 = sub_10000EF14("octagon");
    v30 = objc_claimAutoreleasedReturnValue(v29);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412802;
      v56 = v15;
      v57 = 2112;
      v58 = v16;
      v59 = 2112;
      v60 = v17;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "Prepared: %@ %@ %@", buf, 0x20u);
    }

    objc_msgSend(WeakRetained, "setPeerID:", v15);
    v49 = v16;
    objc_msgSend(WeakRetained, "setPermanentInfo:", v16);
    v48 = v17;
    objc_msgSend(WeakRetained, "setPermanentInfoSig:", v17);
    objc_msgSend(WeakRetained, "setStableInfo:", v18);
    v47 = v19;
    objc_msgSend(WeakRetained, "setStableInfoSig:", v19);
    v31 = sub_10000EF14("octagon-ckks");
    v32 = objc_claimAutoreleasedReturnValue(v31);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "viewList"));
      *(_DWORD *)buf = 138412546;
      v56 = v20;
      v57 = 2112;
      v58 = v33;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "New syncing policy: %@ views: %@", buf, 0x16u);

    }
    v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v34, "stateHolder"));
    v52[0] = _NSConcreteStackBlock;
    v52[1] = 3221225472;
    v52[2] = sub_1000A00A0;
    v52[3] = &unk_1002DEC60;
    v53 = v15;
    v36 = v20;
    v54 = v36;
    v51 = 0;
    v37 = objc_msgSend(v35, "persistAccountChanges:error:", v52, &v51);
    v28 = v51;

    if (!v37 || v28)
    {
      v42 = sub_10000EF14("octagon");
      v43 = objc_claimAutoreleasedReturnValue(v42);
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v56 = v28;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "Couldn't persist metadata: %@", buf, 0xCu);
      }

      objc_msgSend(WeakRetained, "setError:", v28);
      v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishedOp"));
      objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v44);

      v45 = *(_QWORD *)(a1 + 32);
      v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
      +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", v45, 0, v46);

    }
    else
    {
      v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
      v39 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v38, "ckks"));
      objc_msgSend(v39, "setCurrentSyncingPolicy:", v36);

      v40 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "intendedState"));
      objc_msgSend(WeakRetained, "setNextState:", v40);

      v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishedOp"));
      objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v41);

      +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", *(_QWORD *)(a1 + 32), 1, 0);
    }
    v19 = v47;

    v17 = v48;
    v16 = v49;
  }

}

id sub_1000A00A0(uint64_t a1, void *a2)
{
  id v3;

  v3 = a2;
  objc_msgSend(v3, "setPeerID:", *(_QWORD *)(a1 + 32));
  objc_msgSend(v3, "setTPSyncingPolicy:", *(_QWORD *)(a1 + 40));
  return v3;
}

void sub_1000A0404(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  id *v17;

  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000A056C(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id WeakRetained;
  void *v8;
  void *v9;
  id v10;
  id v11;
  void *v12;
  void *v13;
  id v14;
  void *v15;
  void *v16;
  id v17;

  v5 = a2;
  v6 = a3;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "stateHolder"));
  v17 = 0;
  objc_msgSend(v9, "persistAccountChanges:error:", &stru_1002DC900, &v17);
  v10 = v17;

  if (v10)
  {
    v11 = v10;
  }
  else
  {
    if (!v6)
    {
      v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "intendedState"));
      objc_msgSend(WeakRetained, "setNextState:", v16);

      v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "accountSettings"));
      v13 = v12;
      v14 = v5;
      goto LABEL_6;
    }
    v11 = v6;
  }
  objc_msgSend(WeakRetained, "setError:", v11);
  v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "accountSettings"));
  v13 = v12;
  v14 = 0;
LABEL_6:
  objc_msgSend(v12, "setAccountSettings:", v14);

  v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishedOp"));
  objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v15);

}

OTAccountMetadataClassC *__cdecl sub_1000A069C(id a1, OTAccountMetadataClassC *a2)
{
  OTAccountMetadataClassC *v2;
  void *v3;

  v2 = a2;
  v3 = (void *)objc_claimAutoreleasedReturnValue(-[OTAccountMetadataClassC peerID](v2, "peerID"));
  -[OTAccountMetadataClassC setOldPeerID:](v2, "setOldPeerID:", v3);

  return v2;
}

void sub_1000A083C(_QWORD *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  const void *v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  id v11;
  id v12;
  void *v13;
  void *v14;
  id v15;
  void *v16;
  void *v17;
  uint64_t v18;
  void *v19;
  void *v20;
  NSErrorUserInfoKey v21;
  const __CFString *v22;
  uint8_t buf[4];
  uint64_t v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  id v28;

  v5 = a2;
  v6 = a3;
  if (v6)
  {
    v7 = sub_10000EF14("octagon");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = a1[4];
      v10 = a1[5];
      *(_DWORD *)buf = 138412802;
      v24 = v9;
      v25 = 2112;
      v26 = v10;
      v27 = 2112;
      v28 = v6;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Unable to fetch account settings for (%@,%@): %@", buf, 0x20u);
    }

    (*(void (**)(void))(a1[6] + 16))();
  }
  else if (v5 && objc_msgSend(v5, "count"))
  {
    v11 = objc_alloc_init((Class)OTAccountSettings);
    v12 = objc_alloc_init((Class)OTWalrus);
    v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("walrus")));

    if (v13)
    {
      v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("walrus")));
      objc_msgSend(v12, "setEnabled:", objc_msgSend(v14, "value"));

    }
    objc_msgSend(v11, "setWalrus:", v12);
    v15 = objc_alloc_init((Class)OTWebAccess);
    v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("webAccess")));

    if (v16)
    {
      v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("webAccess")));
      objc_msgSend(v15, "setEnabled:", objc_msgSend(v17, "value"));

    }
    objc_msgSend(v11, "setWebAccess:", v15);
    (*(void (**)(void))(a1[6] + 16))();

  }
  else
  {
    v18 = a1[6];
    v21 = NSLocalizedDescriptionKey;
    v22 = CFSTR("No account settings have been set");
    v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v22, &v21, 1));
    v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("com.apple.security.octagon"), 53, v19));
    (*(void (**)(uint64_t, _QWORD, void *))(v18 + 16))(v18, 0, v20);

  }
}

void sub_1000A0AE0(_QWORD *a1, void *a2, uint64_t a3, void *a4)
{
  id v6;
  id v7;
  const void *v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  id v12;
  id v13;
  void *v14;
  void *v15;
  id v16;
  void *v17;
  void *v18;
  int v19;
  uint64_t v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  id v24;

  v6 = a2;
  v7 = a4;
  if (v7)
  {
    v8 = sub_10000EF14("octagon");
    v9 = objc_claimAutoreleasedReturnValue(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      v10 = a1[4];
      v11 = a1[5];
      v19 = 138412802;
      v20 = v10;
      v21 = 2112;
      v22 = v11;
      v23 = 2112;
      v24 = v7;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Unable to fetch account settings for (%@,%@): %@", (uint8_t *)&v19, 0x20u);
    }

    (*(void (**)(void))(a1[6] + 16))();
  }
  else
  {
    v12 = objc_alloc_init((Class)OTAccountSettings);
    v13 = objc_alloc_init((Class)OTWalrus);
    v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "walrus"));
    if ((objc_msgSend(v14, "value") & 1) != 0)
    {
      v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "walrus"));
      objc_msgSend(v13, "setEnabled:", objc_msgSend(v15, "value"));

    }
    else
    {
      objc_msgSend(v13, "setEnabled:", 0);
    }

    objc_msgSend(v12, "setWalrus:", v13);
    v16 = objc_alloc_init((Class)OTWebAccess);
    v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "webAccess"));
    if ((objc_msgSend(v17, "value") & 1) != 0)
    {
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "webAccess"));
      objc_msgSend(v16, "setEnabled:", objc_msgSend(v18, "value"));

    }
    else
    {
      objc_msgSend(v16, "setEnabled:", 0);
    }

    objc_msgSend(v12, "setWebAccess:", v16);
    (*(void (**)(void))(a1[6] + 16))();

  }
}

void sub_1000A0E44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000A1348(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_1000A1358(uint64_t a1)
{

}

void sub_1000A1360(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  const __CFDictionary *v8;
  uint64_t v9;
  id v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  id v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  CFTypeRef result;
  _QWORD v30[12];
  _QWORD v31[12];

  v30[0] = kSecClass;
  v30[1] = kSecAttrAccessible;
  v31[0] = kSecClassInternetPassword;
  v31[1] = kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly;
  v30[2] = kSecUseDataProtectionKeychain;
  v30[3] = kSecAttrAccessGroup;
  v31[2] = &__kCFBooleanTrue;
  v31[3] = CFSTR("com.apple.security.octagon");
  v30[4] = kSecAttrDescription;
  v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Octagon Account State (%@,%@)"), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40)));
  v31[4] = v2;
  v30[5] = kSecAttrServer;
  v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("octagon-%@"), *(_QWORD *)(a1 + 32)));
  v31[5] = v3;
  v30[6] = kSecAttrAccount;
  v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("octagon-%@"), *(_QWORD *)(a1 + 32)));
  v31[6] = v4;
  v30[7] = kSecAttrPath;
  v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("octagon-%@"), *(_QWORD *)(a1 + 40)));
  v31[7] = v5;
  v31[8] = &__kCFBooleanTrue;
  v30[8] = kSecAttrIsInvisible;
  v30[9] = kSecValueData;
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "data"));
  v31[9] = v6;
  v31[10] = &__kCFBooleanFalse;
  v30[10] = kSecAttrSynchronizable;
  v30[11] = kSecAttrSysBound;
  v31[11] = &off_10030A358;
  v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v31, v30, 12));
  v8 = (const __CFDictionary *)objc_msgSend(v7, "mutableCopy");

  result = 0;
  v9 = SecItemAdd(v8, &result);
  if ((_DWORD)v9)
  {
    if ((_DWORD)v9 == -25299)
    {
      v10 = objc_alloc_init((Class)NSMutableDictionary);
      v11 = (void *)objc_claimAutoreleasedReturnValue(-[__CFDictionary objectForKeyedSubscript:](v8, "objectForKeyedSubscript:", kSecClass));
      objc_msgSend(v10, "setObject:forKeyedSubscript:", v11, kSecClass);

      v12 = (void *)objc_claimAutoreleasedReturnValue(-[__CFDictionary objectForKeyedSubscript:](v8, "objectForKeyedSubscript:", kSecAttrSynchronizable));
      objc_msgSend(v10, "setObject:forKeyedSubscript:", v12, kSecAttrSynchronizable);

      v13 = (void *)objc_claimAutoreleasedReturnValue(-[__CFDictionary objectForKeyedSubscript:](v8, "objectForKeyedSubscript:", kSecAttrSyncViewHint));
      objc_msgSend(v10, "setObject:forKeyedSubscript:", v13, kSecAttrSyncViewHint);

      v14 = (void *)objc_claimAutoreleasedReturnValue(-[__CFDictionary objectForKeyedSubscript:](v8, "objectForKeyedSubscript:", kSecAttrAccessGroup));
      objc_msgSend(v10, "setObject:forKeyedSubscript:", v14, kSecAttrAccessGroup);

      v15 = (void *)objc_claimAutoreleasedReturnValue(-[__CFDictionary objectForKeyedSubscript:](v8, "objectForKeyedSubscript:", kSecAttrAccount));
      objc_msgSend(v10, "setObject:forKeyedSubscript:", v15, kSecAttrAccount);

      v16 = (void *)objc_claimAutoreleasedReturnValue(-[__CFDictionary objectForKeyedSubscript:](v8, "objectForKeyedSubscript:", kSecAttrServer));
      objc_msgSend(v10, "setObject:forKeyedSubscript:", v16, kSecAttrServer);

      v17 = (void *)objc_claimAutoreleasedReturnValue(-[__CFDictionary objectForKeyedSubscript:](v8, "objectForKeyedSubscript:", kSecAttrPath));
      objc_msgSend(v10, "setObject:forKeyedSubscript:", v17, kSecAttrPath);

      v18 = (void *)objc_claimAutoreleasedReturnValue(-[__CFDictionary objectForKeyedSubscript:](v8, "objectForKeyedSubscript:", kSecUseDataProtectionKeychain));
      objc_msgSend(v10, "setObject:forKeyedSubscript:", v18, kSecUseDataProtectionKeychain);

      v19 = -[__CFDictionary mutableCopy](v8, "mutableCopy");
      objc_msgSend(v19, "setObject:forKeyedSubscript:", 0, kSecClass);
      v20 = SecItemUpdate((CFDictionaryRef)v10, (CFDictionaryRef)v19);
      if ((_DWORD)v20)
      {
        v21 = (int)v20;
        v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("SecItemUpdate: %d"), v20));
        v23 = objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:description:](NSError, "errorWithDomain:code:description:", NSOSStatusErrorDomain, v21, v22));
        v24 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
        v25 = *(void **)(v24 + 40);
        *(_QWORD *)(v24 + 40) = v23;

      }
    }
    else
    {
      v26 = (int)v9;
      v10 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("SecItemUpdate: %d"), v9));
      v27 = objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:description:](NSError, "errorWithDomain:code:description:", NSOSStatusErrorDomain, v26, v10));
      v28 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
      v19 = *(id *)(v28 + 40);
      *(_QWORD *)(v28 + 40) = v27;
    }

  }
}

void sub_1000A1A38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000A1BFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v12;
  va_list va;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a11);
  va_start(va, a11);
  v12 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1000A1C20(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  const __CFDictionary *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  OTAccountMetadataClassC *v15;
  void *v16;
  OTAccountMetadataClassC *v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  void *v21;
  void *v22;
  unsigned __int8 v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  id v30;
  uint64_t v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  id v39;
  const void *v40;
  NSObject *v41;
  id v42;
  id v43;
  CFTypeRef result;
  uint8_t buf[4];
  void *v46;
  NSErrorUserInfoKey v47;
  void *v48;
  _QWORD v49[9];
  _QWORD v50[9];

  v49[0] = kSecClass;
  v49[1] = kSecUseDataProtectionKeychain;
  v50[0] = kSecClassInternetPassword;
  v50[1] = &__kCFBooleanTrue;
  v50[2] = CFSTR("com.apple.security.octagon");
  v49[2] = kSecAttrAccessGroup;
  v49[3] = kSecAttrServer;
  v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("octagon-%@"), a1[4]));
  v50[3] = v2;
  v49[4] = kSecAttrAccount;
  v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("octagon-%@"), a1[4]));
  v50[4] = v3;
  v49[5] = kSecAttrPath;
  v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("octagon-%@"), a1[5]));
  v50[5] = v4;
  v50[6] = &__kCFBooleanFalse;
  v49[6] = kSecAttrSynchronizable;
  v49[7] = kSecReturnAttributes;
  v49[8] = kSecReturnData;
  v50[7] = &__kCFBooleanTrue;
  v50[8] = &__kCFBooleanTrue;
  v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v50, v49, 9));
  v6 = (const __CFDictionary *)objc_msgSend(v5, "mutableCopy");

  result = 0;
  v7 = SecItemCopyMatching(v6, &result);
  v8 = (void *)result;
  if ((_DWORD)v7)
  {
    v9 = v7;
    if (result)
    {
      result = 0;
      CFRelease(v8);
    }
    v10 = (int)v9;
    v47 = NSLocalizedDescriptionKey;
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("SecItemCopyMatching: %d"), v9));
    v48 = v8;
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v48, &v47, 1));
    v12 = objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", NSOSStatusErrorDomain, v10, v11));
    v13 = *(_QWORD *)(a1[8] + 8);
    v14 = *(void **)(v13 + 40);
    *(_QWORD *)(v13 + 40) = v12;

    goto LABEL_14;
  }
  v15 = [OTAccountMetadataClassC alloc];
  v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "objectForKeyedSubscript:", kSecValueData));
  v17 = -[OTAccountMetadataClassC initWithData:](v15, "initWithData:", v16);
  v18 = *(_QWORD *)(a1[9] + 8);
  v19 = *(void **)(v18 + 40);
  *(_QWORD *)(v18 + 40) = v17;

  if (!*(_QWORD *)(*(_QWORD *)(a1[9] + 8) + 40))
  {
    v31 = objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:description:](NSError, "errorWithDomain:code:description:", CFSTR("com.apple.security.octagon"), 10, CFSTR("couldn't deserialize account state")));
    v32 = *(_QWORD *)(a1[8] + 8);
    v33 = *(void **)(v32 + 40);
    *(_QWORD *)(v32 + 40) = v31;

    v34 = a1[4];
    v35 = a1[5];
    v36 = a1[6];
    v37 = a1[7];
    v43 = 0;
    v38 = +[OTAccountMetadataClassC deleteFromKeychainForContainer:contextID:personaAdapter:personaUniqueString:error:](OTAccountMetadataClassC, "deleteFromKeychainForContainer:contextID:personaAdapter:personaUniqueString:error:", v34, v35, v36, v37, &v43);
    v39 = v43;
    v11 = v39;
    if (!v38 || v39)
    {
      v40 = sub_10000EF14("octagon");
      v41 = objc_claimAutoreleasedReturnValue(v40);
      if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v46 = v11;
        _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "failed to reset account metadata in keychain, %@", buf, 0xCu);
      }

    }
    goto LABEL_14;
  }
  v20 = objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "objectForKeyedSubscript:", kSecAttrSysBound));
  if (!v20
    || (v21 = (void *)v20,
        v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "objectForKeyedSubscript:", kSecAttrAccessible)),
        v23 = objc_msgSend(v22, "isEqualToString:", kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly),
        v22,
        v21,
        (v23 & 1) == 0))
  {
    v24 = *(void **)(*(_QWORD *)(a1[9] + 8) + 40);
    v25 = a1[4];
    v26 = a1[5];
    v27 = a1[6];
    v28 = a1[7];
    v29 = *(_QWORD *)(a1[8] + 8);
    v42 = *(id *)(v29 + 40);
    objc_msgSend(v24, "saveToKeychainForContainer:contextID:personaAdapter:personaUniqueString:error:", v25, v26, v27, v28, &v42);
    v30 = v42;
    v11 = *(void **)(v29 + 40);
    *(_QWORD *)(v29 + 40) = v30;
LABEL_14:

  }
}

void sub_1000A206C(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  const __CFDictionary *v6;
  _QWORD v7[7];
  _QWORD v8[7];

  v8[0] = kSecClassInternetPassword;
  v8[1] = &__kCFBooleanTrue;
  v8[2] = CFSTR("com.apple.security.octagon");
  v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("octagon-%@"), a1[4], kSecClass, kSecUseDataProtectionKeychain, kSecAttrAccessGroup, kSecAttrServer));
  v8[3] = v2;
  v7[4] = kSecAttrAccount;
  v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("octagon-%@"), a1[4]));
  v8[4] = v3;
  v7[5] = kSecAttrPath;
  v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("octagon-%@"), a1[5]));
  v7[6] = kSecAttrSynchronizable;
  v8[5] = v4;
  v8[6] = &__kCFBooleanFalse;
  v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v8, v7, 7));
  v6 = (const __CFDictionary *)objc_msgSend(v5, "mutableCopy");

  *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24) = SecItemDelete(v6);
}

OTAccountMetadataClassC *__cdecl sub_1000A4BBC(id a1, OTAccountMetadataClassC *a2)
{
  OTAccountMetadataClassC *v2;

  v2 = a2;
  -[OTAccountMetadataClassC setCdpState:](v2, "setCdpState:", 2);
  return v2;
}

void sub_1000A646C(id a1)
{
  void *v1;
  CKKSControlServer *v2;
  void *v3;
  id v4;
  void *v5;

  v1 = objc_autoreleasePoolPush();
  v2 = objc_opt_new(CKKSControlServer);
  v3 = (void *)qword_100340F90;
  qword_100340F90 = (uint64_t)v2;

  v4 = objc_msgSend(objc_alloc((Class)NSXPCListener), "initWithMachServiceName:", CFSTR("com.apple.securityd.ckks"));
  v5 = (void *)qword_100340F98;
  qword_100340F98 = (uint64_t)v4;

  objc_msgSend((id)qword_100340F98, "setDelegate:", qword_100340F90);
  objc_msgSend((id)qword_100340F98, "resume");
  objc_autoreleasePoolPop(v1);
}

void sub_1000A6A9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t sub_1000A6B80(uint64_t a1)
{
  id *v2;
  uint64_t v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  id v9;
  void *v10;
  void *v11;
  id v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  id v19;
  NSObject *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  id v25;
  NSObject *v26;
  uint64_t v27;
  void *v28;
  void *v29;
  id v30;
  NSObject *v31;
  void *v32;
  void *v33;
  id v34;
  NSObject *v35;
  void *v36;
  void *v37;
  void *v38;
  id v39;
  id v40;
  void *v41;
  id v42;
  void *v43;
  void *v44;
  void *v46;
  _QWORD v47[5];
  id v48;
  id v49;
  _QWORD v50[5];
  id v51;
  void *v52;
  NSErrorUserInfoKey v53;
  const __CFString *v54;
  uint8_t buf[4];
  id v56;
  __int16 v57;
  void *v58;

  v2 = (id *)(a1 + 40);
  v3 = *(_QWORD *)(a1 + 32);
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "accountStateTracker"));
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*v2, "deps"));
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "lockStateTracker"));
  v51 = 0;
  v8 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSDeviceStateEntry intransactionCreateDeviceStateForView:accountTracker:lockStateTracker:error:](CKKSDeviceStateEntry, "intransactionCreateDeviceStateForView:accountTracker:lockStateTracker:error:", v3, v5, v7, &v51));
  v9 = v51;

  if (v9 || !v8)
  {
    v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v23, "zoneName"));
    v25 = sub_10000BDF4(CFSTR("ckksdevice"), v24);
    v26 = objc_claimAutoreleasedReturnValue(v25);

    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      v56 = v9;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Error creating device state entry; quitting: %@",
        buf,
        0xCu);
    }

    objc_msgSend(*(id *)(a1 + 40), "setError:", v9);
    goto LABEL_15;
  }
  if (objc_msgSend(*(id *)(a1 + 40), "rateLimit"))
  {
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "storedCKRecord"));
    v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "modificationDate"));

    v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](NSDate, "date"));
    v12 = objc_alloc_init((Class)NSDateComponents);
    if (SecIsInternalRelease(v12, v13))
      v14 = -23;
    else
      v14 = -72;
    objc_msgSend(v12, "setHour:", v14);
    v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSCalendar currentCalendar](NSCalendar, "currentCalendar"));
    v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "dateByAddingComponents:toDate:options:", v12, v46, 0));

    if (v11 && objc_msgSend(v11, "compare:", v16) != (id)-1)
    {
      v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "zoneName"));
      v19 = sub_10000BDF4(CFSTR("ckksdevice"), v18);
      v20 = objc_claimAutoreleasedReturnValue(v19);

      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v56 = v11;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Last update is within 3 days (%@); rate-limiting this operation",
          buf,
          0xCu);
      }

      v53 = NSLocalizedDescriptionKey;
      v54 = CFSTR("Rate-limited the CKKSUpdateDeviceStateOperation");
      v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v54, &v53, 1));
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("CKKSErrorDomain"), 60, v21));
      objc_msgSend(*(id *)(a1 + 40), "setError:", v22);

LABEL_15:
      v27 = 0;
      goto LABEL_22;
    }
    v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "zoneName"));
    v30 = sub_10000BDF4(CFSTR("ckksdevice"), v29);
    v31 = objc_claimAutoreleasedReturnValue(v30);

    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412546;
      v56 = v11;
      v57 = 2112;
      v58 = v16;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "Not rate-limiting: last updated %@ vs %@", buf, 0x16u);
    }

  }
  v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
  v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v32, "zoneName"));
  v34 = sub_10000BDF4(CFSTR("ckksdevice"), v33);
  v35 = objc_claimAutoreleasedReturnValue(v34);

  if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    v56 = v8;
    _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "Saving new device state %@", buf, 0xCu);
  }

  v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
  v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "CKRecordWithZoneID:", v36));
  v52 = v37;
  v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v52, 1));

  v39 = objc_alloc_init((Class)NSBlockOperation);
  objc_msgSend(v39, "setName:", CFSTR("updateDeviceState-modifyRecordsComplete"));
  objc_msgSend(*(id *)(a1 + 40), "dependOnBeforeGroupFinished:", v39);
  v40 = objc_msgSend(objc_alloc((Class)CKModifyRecordsOperation), "initWithRecordsToSave:recordIDsToDelete:", v38, 0);
  objc_msgSend(v40, "setAtomic:", 1);
  objc_msgSend(v40, "setQualityOfService:", 17);
  objc_msgSend(v40, "setSavePolicy:", 2);
  v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "group"));
  objc_msgSend(v40, "setGroup:", v41);

  v50[0] = _NSConcreteStackBlock;
  v50[1] = 3221225472;
  v50[2] = sub_1000A7210;
  v50[3] = &unk_1002EA7B8;
  v50[4] = *(_QWORD *)(a1 + 32);
  objc_msgSend(v40, "setPerRecordSaveBlock:", v50);
  v47[0] = _NSConcreteStackBlock;
  v47[1] = 3221225472;
  v47[2] = sub_1000A7394;
  v47[3] = &unk_1002DC9E0;
  objc_copyWeak(&v49, (id *)(a1 + 56));
  v47[4] = *(_QWORD *)(a1 + 32);
  v42 = v39;
  v48 = v42;
  objc_msgSend(v40, "setModifyRecordsCompletionBlock:", v47);
  objc_msgSend(v40, "linearDependencies:", *(_QWORD *)(a1 + 48));
  objc_msgSend(*(id *)(a1 + 40), "dependOnBeforeGroupFinished:", v40);
  v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
  v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v43, "ckdatabase"));
  objc_msgSend(v44, "addOperation:", v40);

  objc_destroyWeak(&v49);
  v27 = 1;
LABEL_22:

  return v27;
}

void sub_1000A71F0(_Unwind_Exception *a1)
{
  id *v1;

  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_1000A7210(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  void *v10;
  void *v11;
  id v12;
  NSObject *v13;
  void *v14;
  int v15;
  id v16;
  __int16 v17;
  id v18;

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
  v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "zoneName"));
  v12 = sub_10000BDF4(CFSTR("ckksdevice"), v11);
  v13 = objc_claimAutoreleasedReturnValue(v12);

  if (v9)
  {
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v15 = 138412546;
      v16 = v9;
      v17 = 2112;
      v18 = v7;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "error on row: %@ %@", (uint8_t *)&v15, 0x16u);
    }
  }
  else if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "recordName"));
    v15 = 138412546;
    v16 = v14;
    v17 = 2112;
    v18 = v8;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Device state record upload successful for %@: %@", (uint8_t *)&v15, 0x16u);

  }
}

void sub_1000A7394(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  id WeakRetained;
  void *v11;
  void *v12;
  void *v13;
  id v14;
  NSObject *v15;
  void *v16;
  void *v17;
  void **v18;
  uint64_t v19;
  uint64_t (*v20)(uint64_t);
  void *v21;
  id v22;
  void *v23;
  uint64_t v24;
  __int128 *p_buf;
  __int128 buf;
  uint64_t v27;
  uint64_t (*v28)(uint64_t, uint64_t);
  void (*v29)(uint64_t);
  id v30;

  v7 = a2;
  v8 = a3;
  v9 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  v11 = WeakRetained;
  if (v9)
  {
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "zoneName"));
    v14 = sub_10000BDF4(CFSTR("ckksdevice"), v13);
    v15 = objc_claimAutoreleasedReturnValue(v14);

    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 138412290;
      *(_QWORD *)((char *)&buf + 4) = v9;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "CloudKit returned an error: %@", (uint8_t *)&buf, 0xCu);
    }

    objc_msgSend(v11, "setError:", v9);
    objc_msgSend(v11, "runBeforeGroupFinished:", *(_QWORD *)(a1 + 40));
  }
  else
  {
    *(_QWORD *)&buf = 0;
    *((_QWORD *)&buf + 1) = &buf;
    v27 = 0x3032000000;
    v28 = sub_1000A75D0;
    v29 = sub_1000A75E0;
    v30 = 0;
    v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "databaseProvider"));
    v18 = _NSConcreteStackBlock;
    v19 = 3221225472;
    v20 = sub_1000A75E8;
    v21 = &unk_1002E9178;
    v22 = v7;
    v23 = v11;
    v24 = *(_QWORD *)(a1 + 32);
    p_buf = &buf;
    objc_msgSend(v17, "dispatchSyncWithSQLTransaction:", &v18);

    objc_msgSend(v11, "setError:", *(_QWORD *)(*((_QWORD *)&buf + 1) + 40), v18, v19, v20, v21);
    objc_msgSend(v11, "runBeforeGroupFinished:", *(_QWORD *)(a1 + 40));

    _Block_object_dispose(&buf, 8);
  }

}

void sub_1000A75B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000A75D0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_1000A75E0(uint64_t a1)
{

}

uint64_t sub_1000A75E8(uint64_t a1)
{
  id v2;
  id v3;
  __int128 v4;
  id v5;
  uint64_t v6;
  void *i;
  void *v8;
  void *v9;
  unsigned int v10;
  CKKSDeviceStateEntry *v11;
  void *v12;
  void *v13;
  CKKSDeviceStateEntry *v14;
  uint64_t v15;
  void *v16;
  void *v17;
  id v18;
  NSObject *v19;
  uint64_t v20;
  __int128 v22;
  id obj;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint8_t buf[4];
  CKKSDeviceStateEntry *v29;
  __int16 v30;
  uint64_t v31;
  _BYTE v32[128];

  v24 = 0u;
  v25 = 0u;
  v26 = 0u;
  v27 = 0u;
  v2 = *(id *)(a1 + 32);
  v3 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v24, v32, 16);
  if (v3)
  {
    v5 = v3;
    v6 = *(_QWORD *)v25;
    *(_QWORD *)&v4 = 138412546;
    v22 = v4;
    do
    {
      for (i = 0; i != v5; i = (char *)i + 1)
      {
        if (*(_QWORD *)v25 != v6)
          objc_enumerationMutation(v2);
        v8 = *(void **)(*((_QWORD *)&v24 + 1) + 8 * (_QWORD)i);
        v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "recordType", v22));
        v10 = objc_msgSend(v9, "isEqualToString:", CFSTR("devicestate"));

        if (v10)
        {
          v11 = [CKKSDeviceStateEntry alloc];
          v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
          v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "contextID"));
          v14 = -[CKKSCKRecordHolder initWithCKRecord:contextID:](v11, "initWithCKRecord:contextID:", v8, v13);

          v15 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
          obj = *(id *)(v15 + 40);
          -[CKKSSQLDatabaseObject saveToDatabase:](v14, "saveToDatabase:", &obj);
          objc_storeStrong((id *)(v15 + 40), obj);
          if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 40))
          {
            v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "zoneID"));
            v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "zoneName"));
            v18 = sub_10000BDF4(CFSTR("ckksdevice"), v17);
            v19 = objc_claimAutoreleasedReturnValue(v18);

            if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
            {
              v20 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 40);
              *(_DWORD *)buf = v22;
              v29 = v14;
              v30 = 2112;
              v31 = v20;
              _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Couldn't save new device state(%@) to database: %@", buf, 0x16u);
            }

          }
        }
      }
      v5 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v24, v32, 16);
    }
    while (v5);
  }

  return 1;
}

void sub_1000A81A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_destroyWeak((id *)(v1 - 40));
  _Unwind_Resume(a1);
}

void sub_1000A8484(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_destroyWeak((id *)(v1 - 24));
  _Unwind_Resume(a1);
}

void sub_1000A8840(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000A8A88(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  NSObject *v4;
  intptr_t v5;
  NSObject *v6;

  v2 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "timer"));
  if (v2)
  {
    v3 = (void *)v2;
    v4 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "timer"));
    v5 = dispatch_source_testcancel(v4);

    if (!v5)
    {
      v6 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "timer"));
      dispatch_source_cancel(v6);

    }
  }
}

void sub_1000A8B18(uint64_t a1)
{
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  objc_msgSend(WeakRetained, "_onqueueTimerTick");

}

void sub_1000A8B44(uint64_t a1)
{
  void *v1;
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  objc_msgSend(WeakRetained, "setLiveRequest:", 1);
  v1 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "liveRequestReceived"));
  objc_msgSend(v1, "fulfill");

  objc_msgSend(WeakRetained, "_onqueueTrigger:maximumDelay:", 0, -1);
}

void sub_1000A8BA4(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  objc_msgSend(WeakRetained, "setLiveRequest:", 1);
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "liveRequestReceived"));
  objc_msgSend(v2, "fulfill");

  if (*(_QWORD *)(a1 + 40) == -1)
    v3 = 0;
  else
    v3 = *(_QWORD *)(a1 + 40);
  objc_msgSend(WeakRetained, "_onqueueTrigger:maximumDelay:", v3);

}

id sub_1000A8C0C(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "_onqueueTrigger:maximumDelay:", *(_QWORD *)(a1 + 40), -1);
}

id sub_1000A8C20(uint64_t a1)
{
  unint64_t v2;
  double v3;

  objc_msgSend(*(id *)(a1 + 32), "setInitialDelay:", *(_QWORD *)(a1 + 40));
  objc_msgSend(*(id *)(a1 + 32), "setCurrentDelay:", objc_msgSend(*(id *)(a1 + 32), "initialDelay"));
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
    v3 = (double)*(unint64_t *)(a1 + 48) / (double)v2;
  else
    v3 = 1.0;
  objc_msgSend(*(id *)(a1 + 32), "setBackoff:", v3);
  return objc_msgSend(*(id *)(a1 + 32), "setMaximumDelay:", *(_QWORD *)(a1 + 48));
}

void sub_1000A9D84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000A9F44(uint64_t a1, void *a2)
{
  void *v3;
  id v4;

  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a2, "objectForKeyedSubscript:", CFSTR("pcsk")));
  v4 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "asBase64DecodedData"));

  if (objc_msgSend(*(id *)(a1 + 32), "containsObject:", v4))
    objc_msgSend(*(id *)(a1 + 40), "addObject:", v4);

}

uint64_t sub_1000A9FB0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_1000A9FC0(uint64_t a1)
{

}

void sub_1000A9FC8(uint64_t a1, void *a2)
{
  uint64_t v3;
  uint64_t v4;
  void *v5;
  id v6;

  v6 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(a2, "objectForKeyedSubscript:", CFSTR("count(rowid)")));
  v3 = objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "asNSNumberInteger"));
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v5 = *(void **)(v4 + 40);
  *(_QWORD *)(v4 + 40) = v3;

}

void sub_1000AA024(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  id v8;

  v3 = a2;
  v8 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("count(rowid)")));
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "asNSNumberInteger"));
  v5 = *(void **)(a1 + 32);
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("ckzone")));

  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "asString"));
  objc_msgSend(v5, "setObject:forKeyedSubscript:", v4, v7);

}

void sub_1000AA0C8(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  id v8;

  v3 = a2;
  v8 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("count(rowid)")));
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "asNSNumberInteger"));
  v5 = *(void **)(a1 + 32);
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("parentKeyUUID")));

  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "asString"));
  objc_msgSend(v5, "setObject:forKeyedSubscript:", v4, v7);

}

void sub_1000AA668(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_1000AA8E4(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "_onqueueSetFlag:", *(_QWORD *)(a1 + 40));
}

uint64_t sub_1000AA8F0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_1000AA900(uint64_t a1)
{

}

void sub_1000AA908(uint64_t a1)
{
  void *v2;
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  id v7;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "flags"));
  v3 = objc_msgSend(v2, "containsObject:", *(_QWORD *)(a1 + 40));

  if (v3)
  {
    v7 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "flagConditions"));
    v4 = objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", *(_QWORD *)(a1 + 40)));
    v5 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
    v6 = *(void **)(v5 + 40);
    *(_QWORD *)(v5 + 40) = v4;

  }
}

void sub_1000AAE68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  _Block_object_dispose(&a28, 8);
  _Unwind_Resume(a1);
}

void sub_1000AB0F4(uint64_t a1)
{
  void *v2;
  id v3;
  id v4;
  uint64_t v5;
  void *i;
  uint64_t v7;
  void *v8;
  void *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  _BYTE v14[128];

  v10 = 0u;
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "allKeys", 0));
  v3 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v10, v14, 16);
  if (v3)
  {
    v4 = v3;
    v5 = *(_QWORD *)v11;
    do
    {
      for (i = 0; i != v4; i = (char *)i + 1)
      {
        if (*(_QWORD *)v11 != v5)
          objc_enumerationMutation(v2);
        v7 = *(_QWORD *)(*((_QWORD *)&v10 + 1) + 8 * (_QWORD)i);
        v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:", v7));
        v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "event"));
        objc_msgSend(v9, "setObject:forKeyedSubscript:", v8, v7);

      }
      v4 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v10, v14, 16);
    }
    while (v4);
  }

}

void sub_1000AB228(uint64_t a1)
{
  id v2;

  v2 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "event"));
  objc_msgSend(v2, "populateUnderlyingErrorsStartingWithRootError:", *(_QWORD *)(a1 + 40));

}

void sub_1000AB268(uint64_t a1)
{
  void *v2;
  void *v3;

  sub_1000AB32C();
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = objc_getClass("AAFAnalyticsEvent");
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    qword_100340FD8 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Class getAAFAnalyticsEventClass(void)_block_invoke"));
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("AAFAnalyticsEvent+Security.m"), 44, CFSTR("Unable to find class %s"), "AAFAnalyticsEvent");

    __break(1u);
  }
}

void *sub_1000AB32C()
{
  void *v0;
  void *v1;
  void *v3;
  void *v4;
  __int128 v5;
  uint64_t v6;

  v4 = 0;
  if (!qword_100340FC0)
  {
    v5 = off_1002DCB00;
    v6 = 0;
    qword_100340FC0 = _sl_dlopen(&v5, &v4);
  }
  v0 = (void *)qword_100340FC0;
  if (!qword_100340FC0)
  {
    v0 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "void *AAAFoundationLibrary(void)"));
    objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("AAFAnalyticsEvent+Security.m"), 43, CFSTR("%s"), v4);

    __break(1u);
    goto LABEL_7;
  }
  v1 = v4;
  if (v4)
LABEL_7:
    free(v1);
  return v0;
}

void sub_1000AB430()
{
  id *v0;
  void *v1;
  id v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v0 = (id *)qword_100340FE8;
  v8 = qword_100340FE8;
  if (!qword_100340FE8)
  {
    v1 = sub_1000AB32C();
    v0 = (id *)dlsym(v1, "kAAFDeviceSessionId");
    v6[3] = (uint64_t)v0;
    qword_100340FE8 = (uint64_t)v0;
  }
  _Block_object_dispose(&v5, 8);
  if (v0)
  {
    v2 = *v0;
  }
  else
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "NSString *getkAAFDeviceSessionId(void)"));
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, CFSTR("AAFAnalyticsEvent+Security.m"), 45, CFSTR("%s"), dlerror());

    __break(1u);
  }
}

void sub_1000AB514(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000AB77C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class sub_1000AB79C(uint64_t a1)
{
  Class result;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  __int128 v7;
  uint64_t v8;

  v6 = 0;
  if (!qword_100340FC8)
  {
    v7 = off_1002DCB18;
    v8 = 0;
    qword_100340FC8 = _sl_dlopen(&v7, &v6);
  }
  if (!qword_100340FC8)
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "void *AuthKitLibrary(void)"));
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, CFSTR("AAFAnalyticsEvent+Security.m"), 50, CFSTR("%s"), v6);

    goto LABEL_10;
  }
  if (v6)
    free(v6);
  result = objc_getClass("AKAccountManager");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](NSAssertionHandler, "currentHandler"));
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "Class getAKAccountManagerClass(void)_block_invoke"));
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v5, CFSTR("AAFAnalyticsEvent+Security.m"), 51, CFSTR("Unable to find class %s"), "AKAccountManager");

LABEL_10:
    __break(1u);
  }
  qword_100340FD0 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

void sub_1000AB938(id a1)
{
  const void *v1;
  NSObject *v2;
  __int128 v3;
  uint64_t v4;

  if (!qword_100340FC8)
  {
    v3 = off_1002DCB18;
    v4 = 0;
    qword_100340FC8 = _sl_dlopen(&v3, 0);
  }
  if (qword_100340FC8)
  {
    byte_100340FB0 = 1;
  }
  else
  {
    v1 = sub_10000EF14("SecError");
    v2 = objc_claimAutoreleasedReturnValue(v1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v3) = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "aafanalyticsevent-security: failed to softlink AuthKit", (uint8_t *)&v3, 2u);
    }

  }
}

void sub_1000ABA1C(id a1)
{
  const void *v1;
  NSObject *v2;
  __int128 v3;
  uint64_t v4;

  if (!qword_100340FC0)
  {
    v3 = off_1002DCB00;
    v4 = 0;
    qword_100340FC0 = _sl_dlopen(&v3, 0);
  }
  if (qword_100340FC0)
  {
    byte_100340FA0 = 1;
  }
  else
  {
    v1 = sub_10000EF14("SecError");
    v2 = objc_claimAutoreleasedReturnValue(v1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v3) = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "aafanalyticsevent-security: failed to softlink AAAFoundation", (uint8_t *)&v3, 2u);
    }

  }
}

void sub_1000ABE6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  id *v17;

  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000ABFDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000AC158(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id WeakRetained;
  void *v8;
  const void *v9;
  NSObject *v10;
  const void *v11;
  NSObject *v12;
  const void *v13;
  NSObject *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  int v20;
  id v21;

  v5 = a2;
  v6 = a3;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v8 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v8, "logResultForEvent:hardFailure:result:", CFSTR("OctagonEventSetRecoveryKey"), 1, v6);

  if (v6)
  {
    v9 = sub_10000EF14("SecError");
    v10 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      v20 = 138412290;
      v21 = v6;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "octagon: Error setting recovery key: %@", (uint8_t *)&v20, 0xCu);
    }

    objc_msgSend(WeakRetained, "setError:", v6);
  }
  else
  {
    v11 = sub_10000EF14("octagon");
    v12 = objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v20) = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "successfully set recovery key", (uint8_t *)&v20, 2u);
    }

    v13 = sub_10000EF14("octagon-ckks");
    v14 = objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
      v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "ckks"));
      v20 = 138412290;
      v21 = v16;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Providing setRecoveryKey() records to %@", (uint8_t *)&v20, 0xCu);

    }
    v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "ckks"));
    objc_msgSend(v18, "receiveTLKUploadRecords:", v5);

  }
  v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishOp"));
  objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v19);

}

void sub_1000AC390(uint64_t a1)
{
  void *v2;
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "viewKeySets"));
  objc_msgSend(WeakRetained, "proceedWithKeys:salt:", v2, *(_QWORD *)(a1 + 40));

}

void sub_1000AC770(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  id *v17;

  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000AC9E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  id *v18;

  objc_destroyWeak(v18);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000ACAE4(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  id WeakRetained;
  void *v11;
  const void *v12;
  NSObject *v13;
  id v14;
  const void *v15;
  NSObject *v16;
  id v17;
  void *v18;
  id v19;
  id v20;
  uint64_t v21;
  id v22;
  void *v23;
  const void *v24;
  NSObject *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  const void *v31;
  NSObject *v32;
  void *v33;
  void *v34;
  const void *v35;
  NSObject *v36;
  void *v37;
  id v38;
  uint8_t buf[4];
  id v40;

  v7 = a2;
  v8 = a3;
  v9 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v11 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v11, "logResultForEvent:hardFailure:result:", CFSTR("OctagonEventCreateCustodianRecoveryKeyTPH"), 1, v9);

  if (v9)
  {
    v12 = sub_10000EF14("SecError");
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v40 = v9;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "octagon: Error create custodian recovery key: %@", buf, 0xCu);
    }

    objc_msgSend(WeakRetained, "setError:", v9);
    v14 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishOp"));
    objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v14);
    goto LABEL_19;
  }
  v15 = sub_10000EF14("octagon");
  v16 = objc_claimAutoreleasedReturnValue(v15);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "successfully created custodian recovery key", buf, 2u);
  }

  v17 = objc_alloc((Class)NSUUID);
  v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "uuid"));
  v19 = objc_msgSend(v17, "initWithUUIDString:", v18);

  if (!v19)
  {
    v31 = sub_10000EF14("SecError");
    v32 = objc_claimAutoreleasedReturnValue(v31);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "uuid"));
      *(_DWORD *)buf = 138412290;
      v40 = v33;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "octagon: failed to parse UUID from TPH: %@", buf, 0xCu);

    }
    v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:description:](NSError, "errorWithDomain:code:description:", CFSTR("com.apple.security.octagon"), 54, CFSTR("Failed to parse UUID from TPH")));
    objc_msgSend(WeakRetained, "setError:", v34);

    v14 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishOp"));
    objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v14);
    goto LABEL_18;
  }
  v20 = objc_alloc((Class)OTCustodianRecoveryKey);
  v21 = *(_QWORD *)(a1 + 32);
  v38 = 0;
  v22 = objc_msgSend(v20, "initWithUUID:recoveryString:error:", v19, v21, &v38);
  v14 = v38;
  objc_msgSend(WeakRetained, "setCrk:", v22);

  v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "crk"));
  if (!v23)
  {
    v35 = sub_10000EF14("SecError");
    v36 = objc_claimAutoreleasedReturnValue(v35);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v40 = v14;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "octagon: failed to create crk: %@", buf, 0xCu);
    }

    objc_msgSend(WeakRetained, "setError:", v14);
    v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishOp"));
    objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v37);

LABEL_18:
    v14 = v19;
    goto LABEL_19;
  }
  v24 = sub_10000EF14("octagon-ckks");
  v25 = objc_claimAutoreleasedReturnValue(v24);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "ckks"));
    *(_DWORD *)buf = 138412290;
    v40 = v27;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Providing createCustodianRecoveryKey() records to %@", buf, 0xCu);

  }
  v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
  v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "ckks"));
  objc_msgSend(v29, "receiveTLKUploadRecords:", v7);

  v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishOp"));
  objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v30);

LABEL_19:
}

void sub_1000ACF44(uint64_t a1)
{
  void *v2;
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "viewKeySets"));
  objc_msgSend(WeakRetained, "proceedWithKeys:salt:", v2, *(_QWORD *)(a1 + 40));

}

void sub_1000AD1D4(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_1000AD4A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  id *v18;

  objc_destroyWeak(v18);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000AD5AC(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v6;
  id v7;
  id WeakRetained;
  void *v9;
  const void *v10;
  NSObject *v11;
  const void *v12;
  NSObject *v13;
  const void *v14;
  NSObject *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  int v21;
  id v22;

  v6 = a2;
  v7 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v9 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v9, "logResultForEvent:hardFailure:result:", CFSTR("OctagonEventCreateCustodianRecoveryKeyTPH"), 1, v7);

  if (v7)
  {
    v10 = sub_10000EF14("SecError");
    v11 = objc_claimAutoreleasedReturnValue(v10);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v21 = 138412290;
      v22 = v7;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "octagon: Error create inheritance key: %@", (uint8_t *)&v21, 0xCu);
    }

    objc_msgSend(WeakRetained, "setError:", v7);
  }
  else
  {
    v12 = sub_10000EF14("octagon");
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v21) = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "successfully created inheritance key", (uint8_t *)&v21, 2u);
    }

    v14 = sub_10000EF14("octagon-ckks");
    v15 = objc_claimAutoreleasedReturnValue(v14);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
      v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "ckks"));
      v21 = 138412290;
      v22 = v17;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Providing createCustodianRecoveryKey() records to %@", (uint8_t *)&v21, 0xCu);

    }
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "ckks"));
    objc_msgSend(v19, "receiveTLKUploadRecords:", v6);

  }
  v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishOp"));
  objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v20);

}

void sub_1000AD7E4(uint64_t a1)
{
  void *v2;
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "viewKeySets"));
  objc_msgSend(WeakRetained, "proceedWithKeys:salt:", v2, *(_QWORD *)(a1 + 40));

}

void sub_1000ADA48(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_1000ADBF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000ADCBC(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v6;
  id v7;
  id WeakRetained;
  void *v9;
  const void *v10;
  NSObject *v11;
  const void *v12;
  NSObject *v13;
  const void *v14;
  NSObject *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  int v21;
  id v22;

  v6 = a2;
  v7 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v9 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v9, "logResultForEvent:hardFailure:result:", CFSTR("OctagonEventCreateCustodianRecoveryKeyTPH"), 1, v7);

  if (v7)
  {
    v10 = sub_10000EF14("SecError");
    v11 = objc_claimAutoreleasedReturnValue(v10);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v21 = 138412290;
      v22 = v7;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "octagon: Error store inheritance key: %@", (uint8_t *)&v21, 0xCu);
    }

    objc_msgSend(WeakRetained, "setError:", v7);
  }
  else
  {
    v12 = sub_10000EF14("octagon");
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v21) = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "successfully stored inheritance key", (uint8_t *)&v21, 2u);
    }

    v14 = sub_10000EF14("octagon-ckks");
    v15 = objc_claimAutoreleasedReturnValue(v14);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
      v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "ckks"));
      v21 = 138412290;
      v22 = v17;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Providing storeCustodianRecoveryKey() records to %@", (uint8_t *)&v21, 0xCu);

    }
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "ckks"));
    objc_msgSend(v19, "receiveTLKUploadRecords:", v6);

  }
  v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishOp"));
  objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v20);

}

void sub_1000ADEF4(uint64_t a1)
{
  void *v2;
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "viewKeySets"));
  objc_msgSend(WeakRetained, "proceedWithKeys:", v2);

}

void sub_1000AE1AC(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_1000AE494(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  id *v18;

  objc_destroyWeak(v18);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000AE5CC(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v6;
  id v7;
  id WeakRetained;
  void *v9;
  const void *v10;
  NSObject *v11;
  const void *v12;
  NSObject *v13;
  const void *v14;
  NSObject *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  int v21;
  id v22;

  v6 = a2;
  v7 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v9 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v9, "logResultForEvent:hardFailure:result:", CFSTR("OctagonEventCreateCustodianRecoveryKeyTPH"), 1, v7);

  if (v7)
  {
    v10 = sub_10000EF14("SecError");
    v11 = objc_claimAutoreleasedReturnValue(v10);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v21 = 138412290;
      v22 = v7;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "octagon: Error recreatint inheritance key: %@", (uint8_t *)&v21, 0xCu);
    }

    objc_msgSend(WeakRetained, "setError:", v7);
  }
  else
  {
    v12 = sub_10000EF14("octagon");
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v21) = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "successfully recreated inheritance key", (uint8_t *)&v21, 2u);
    }

    v14 = sub_10000EF14("octagon-ckks");
    v15 = objc_claimAutoreleasedReturnValue(v14);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
      v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "ckks"));
      v21 = 138412290;
      v22 = v17;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Providing createCustodianRecoveryKey() records to %@", (uint8_t *)&v21, 0xCu);

    }
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "ckks"));
    objc_msgSend(v19, "receiveTLKUploadRecords:", v6);

  }
  v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishOp"));
  objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v20);

}

void sub_1000AE804(uint64_t a1)
{
  void *v2;
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "viewKeySets"));
  objc_msgSend(WeakRetained, "proceedWithKeys:salt:", v2, *(_QWORD *)(a1 + 40));

}

void sub_1000AEAEC(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_1000AEDEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  id *v18;

  objc_destroyWeak(v18);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000AEF84(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v6;
  id v7;
  id WeakRetained;
  void *v9;
  const void *v10;
  NSObject *v11;
  const void *v12;
  NSObject *v13;
  const void *v14;
  NSObject *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  int v21;
  id v22;

  v6 = a2;
  v7 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v9 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v9, "logResultForEvent:hardFailure:result:", CFSTR("OctagonEventCreateCustodianRecoveryKeyTPH"), 1, v7);

  if (v7)
  {
    v10 = sub_10000EF14("SecError");
    v11 = objc_claimAutoreleasedReturnValue(v10);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v21 = 138412290;
      v22 = v7;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "octagon: Error creating inheritance w/claimtoken+wrappingkey key: %@", (uint8_t *)&v21, 0xCu);
    }

    objc_msgSend(WeakRetained, "setError:", v7);
  }
  else
  {
    v12 = sub_10000EF14("octagon");
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v21) = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "successfully created inheritance key w/claimtoken+wrappingkey", (uint8_t *)&v21, 2u);
    }

    v14 = sub_10000EF14("octagon-ckks");
    v15 = objc_claimAutoreleasedReturnValue(v14);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
      v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "ckks"));
      v21 = 138412290;
      v22 = v17;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Providing createCustodianRecoveryKey() records to %@", (uint8_t *)&v21, 0xCu);

    }
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "ckks"));
    objc_msgSend(v19, "receiveTLKUploadRecords:", v6);

  }
  v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishOp"));
  objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v20);

}

void sub_1000AF1BC(uint64_t a1)
{
  void *v2;
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "viewKeySets"));
  objc_msgSend(WeakRetained, "proceedWithKeys:salt:", v2, *(_QWORD *)(a1 + 40));

}

void sub_1000B03E4(id a1)
{
  void *v1;
  uint64_t v2;
  void *v3;
  _QWORD v4[7];

  v4[0] = CFSTR("type");
  v4[1] = kSecValueData;
  v4[2] = CFSTR("pkkp");
  v4[3] = CFSTR("pkvp");
  v4[4] = CFSTR("ipkp");
  v4[5] = CFSTR("ipvp");
  v4[6] = CFSTR("flag");
  v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v4, 7));
  v2 = objc_claimAutoreleasedReturnValue(+[NSSet setWithArray:](NSSet, "setWithArray:", v1));
  v3 = (void *)qword_100340FF0;
  qword_100340FF0 = v2;

}

uint64_t sub_1000B2D70(uint64_t a1, uint64_t a2)
{
  char v4;
  unsigned int v5;
  unint64_t v6;
  unint64_t v7;
  char v8;
  BOOL v9;
  int v10;
  unint64_t v12;
  SECC2MPGenericEventMetric *v13;
  uint64_t String;
  uint64_t v15;
  void *v16;
  char v17;
  unsigned int v18;
  uint64_t v19;
  unint64_t v20;
  char v21;
  char v22;
  unsigned int v23;
  unint64_t v24;
  char v25;
  char v26;
  unsigned int v27;
  uint64_t v28;
  unint64_t v29;
  char v30;
  uint64_t result;
  uint64_t v32;
  _QWORD v33[2];

  while (*(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error))
      return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    v4 = 0;
    v5 = 0;
    v6 = 0;
    while (1)
    {
      v7 = *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v7 == -1 || v7 >= *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__length))
        break;
      v8 = *(_BYTE *)(*(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
      v6 |= (unint64_t)(v8 & 0x7F) << v4;
      if ((v8 & 0x80) == 0)
        goto LABEL_11;
      v4 += 7;
      v9 = v5++ >= 9;
      if (v9)
      {
        v6 = 0;
        v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }
    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error))
      v6 = 0;
LABEL_13:
    if (v10 || (v6 & 7) == 4)
      return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    v12 = v6 >> 3;
    if ((int)(v6 >> 3) <= 200)
    {
      if ((_DWORD)v12 == 1)
      {
        v26 = 0;
        v27 = 0;
        v28 = 0;
        *(_BYTE *)(a1 + 44) |= 4u;
        while (1)
        {
          v29 = *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v29 == -1 || v29 >= *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__length))
            break;
          v30 = *(_BYTE *)(*(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v29);
          *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos) = v29 + 1;
          v28 |= (unint64_t)(v30 & 0x7F) << v26;
          if ((v30 & 0x80) == 0)
            goto LABEL_60;
          v26 += 7;
          v9 = v27++ >= 9;
          if (v9)
          {
            LODWORD(v28) = 0;
            goto LABEL_62;
          }
        }
        *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_60:
        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error))
          LODWORD(v28) = 0;
LABEL_62:
        *(_DWORD *)(a1 + 40) = v28;
      }
      else
      {
        if ((_DWORD)v12 != 101)
        {
LABEL_48:
          result = PBReaderSkipValueWithTag(a2);
          if (!(_DWORD)result)
            return result;
          continue;
        }
        String = PBReaderReadString(a2);
        v15 = objc_claimAutoreleasedReturnValue(String);
        v16 = *(void **)(a1 + 32);
        *(_QWORD *)(a1 + 32) = v15;

      }
    }
    else
    {
      if ((_DWORD)v12 == 201)
      {
        v17 = 0;
        v18 = 0;
        v19 = 0;
        *(_BYTE *)(a1 + 44) |= 2u;
        while (1)
        {
          v20 = *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v20 == -1 || v20 >= *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__length))
            break;
          v21 = *(_BYTE *)(*(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v20);
          *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos) = v20 + 1;
          v19 |= (unint64_t)(v21 & 0x7F) << v17;
          if ((v21 & 0x80) == 0)
            goto LABEL_51;
          v17 += 7;
          v9 = v18++ >= 9;
          if (v9)
          {
            v19 = 0;
            goto LABEL_53;
          }
        }
        *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_51:
        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error))
          v19 = 0;
LABEL_53:
        v32 = 16;
        goto LABEL_58;
      }
      if ((_DWORD)v12 == 202)
      {
        v22 = 0;
        v23 = 0;
        v19 = 0;
        *(_BYTE *)(a1 + 44) |= 1u;
        while (1)
        {
          v24 = *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v24 == -1 || v24 >= *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__length))
            break;
          v25 = *(_BYTE *)(*(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v24);
          *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos) = v24 + 1;
          v19 |= (unint64_t)(v25 & 0x7F) << v22;
          if ((v25 & 0x80) == 0)
            goto LABEL_55;
          v22 += 7;
          v9 = v23++ >= 9;
          if (v9)
          {
            v19 = 0;
            goto LABEL_57;
          }
        }
        *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_55:
        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error))
          v19 = 0;
LABEL_57:
        v32 = 8;
LABEL_58:
        *(_QWORD *)(a1 + v32) = v19;
        continue;
      }
      if ((_DWORD)v12 != 301)
        goto LABEL_48;
      v13 = objc_alloc_init(SECC2MPGenericEventMetric);
      objc_msgSend((id)a1, "addMetric:", v13);
      v33[0] = 0xAAAAAAAAAAAAAAAALL;
      v33[1] = 0xAAAAAAAAAAAAAAAALL;
      if (!PBReaderPlaceMark(a2, v33) || !sub_1000887A4((uint64_t)v13, a2))
      {

        return 0;
      }
      PBReaderRecallMark(a2, v33);

    }
  }
  return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

id sub_1000B32E0()
{
  if (qword_100341008 != -1)
    dispatch_once(&qword_100341008, &stru_1002DCBA0);
  return (id)qword_100341000;
}

void sub_1000B3320(id a1)
{
  uint64_t v1;
  void *v2;
  _QWORD v3[34];
  _QWORD v4[34];

  v3[0] = CFSTR("ready");
  v3[1] = CFSTR("error");
  v4[0] = &off_10030A370;
  v4[1] = &off_10030A388;
  v3[2] = CFSTR("initializing");
  v3[3] = CFSTR("initialized");
  v4[2] = &off_10030A3A0;
  v4[3] = &off_10030A3B8;
  v3[4] = CFSTR("fetchcomplete");
  v3[5] = CFSTR("waitfortlk");
  v4[4] = &off_10030A3D0;
  v4[5] = &off_10030A3E8;
  v3[6] = CFSTR("waitforunlock");
  v3[7] = CFSTR("unhealthy");
  v4[6] = &off_10030A400;
  v4[7] = &off_10030A418;
  v3[8] = CFSTR("badcurrentpointers");
  v3[9] = CFSTR("newtlksfailed");
  v4[8] = &off_10030A430;
  v4[9] = &off_10030A448;
  v3[10] = CFSTR("needrefetch");
  v3[11] = CFSTR("healtlkshares");
  v4[10] = &off_10030A460;
  v4[11] = &off_10030A478;
  v3[12] = CFSTR("healtlksharesfailed");
  v3[13] = CFSTR("readypendingunlock");
  v4[12] = &off_10030A490;
  v4[13] = &off_10030A4A8;
  v3[14] = CFSTR("fetching");
  v3[15] = CFSTR("resetzone");
  v4[14] = &off_10030A4C0;
  v4[15] = &off_10030A4D8;
  v3[16] = CFSTR("resetlocal");
  v3[17] = CFSTR("loggedout");
  v4[16] = &off_10030A4F0;
  v4[17] = &off_10030A508;
  v3[18] = CFSTR("zonecreationfailed");
  v3[19] = CFSTR("waitfortrust");
  v4[18] = &off_10030A520;
  v4[19] = &off_10030A538;
  v3[20] = CFSTR("waitfortlkupload");
  v3[21] = CFSTR("waitfortlkcreation");
  v4[20] = &off_10030A550;
  v4[21] = &off_10030A568;
  v3[22] = CFSTR("process_key_hierarchy");
  v3[23] = CFSTR("become_ready");
  v4[22] = &off_10030A580;
  v4[23] = &off_10030A598;
  v3[24] = CFSTR("lose_trust");
  v3[25] = CFSTR("tlkmissing");
  v4[24] = &off_10030A5B0;
  v4[25] = &off_10030A5C8;
  v3[26] = CFSTR("wait_for_ck_account_status");
  v3[27] = CFSTR("begin_fetch");
  v4[26] = &off_10030A5E0;
  v4[27] = &off_10030A5F8;
  v3[28] = CFSTR("fixup_fetch_cip");
  v3[29] = CFSTR("fixup_fetch_tlkshares");
  v4[28] = &off_10030A610;
  v4[29] = &off_10030A628;
  v3[30] = CFSTR("fixup_local_reload");
  v3[31] = CFSTR("fixup_resave_cdse");
  v4[30] = &off_10030A640;
  v4[31] = &off_10030A658;
  v3[32] = CFSTR("fixup_delete_tombstones");
  v3[33] = CFSTR("check_tlk_shares");
  v4[32] = &off_10030A670;
  v4[33] = &off_10030A688;
  v1 = objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v4, v3, 34));
  v2 = (void *)qword_100341000;
  qword_100341000 = v1;

}

void sub_1000B3648(id a1)
{
  id v1;
  void *v2;
  void *v3;
  uint64_t v4;
  void *v5;
  id v6;

  v1 = sub_1000B32E0();
  v6 = (id)objc_claimAutoreleasedReturnValue(v1);
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "allKeys"));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "allValues"));
  v4 = objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:](NSDictionary, "dictionaryWithObjects:forKeys:", v2, v3));
  v5 = (void *)qword_100341010;
  qword_100341010 = v4;

}

__CFString *sub_1000B36D0(void *a1)
{
  id v1;
  id v2;
  void *v3;
  __CFString *v4;
  __CFString *v5;
  __CFString *v6;

  if (a1)
  {
    v1 = a1;
    if (qword_100341018 != -1)
      dispatch_once(&qword_100341018, &stru_1002DCBC0);
    v2 = (id)qword_100341010;
    v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "objectForKeyedSubscript:", v1));

    if (v3)
    {
      v4 = v3;
    }
    else
    {
      v4 = CFSTR("error");
      v6 = CFSTR("error");
    }

  }
  else
  {
    v4 = CFSTR("error");
    v5 = CFSTR("error");
  }
  return v4;
}

void sub_1000B3780(id a1)
{
  void *v1;
  uint64_t v2;
  void *v3;
  _QWORD v4[18];

  v4[0] = CFSTR("loggedout");
  v4[1] = CFSTR("resetzone");
  v4[2] = CFSTR("resetlocal");
  v4[3] = CFSTR("initializing");
  v4[4] = CFSTR("initialized");
  v4[5] = CFSTR("zonecreationfailed");
  v4[6] = CFSTR("ready");
  v4[7] = CFSTR("fetching");
  v4[8] = CFSTR("process_key_hierarchy");
  v4[9] = CFSTR("needrefetch");
  v4[10] = CFSTR("tlkmissing");
  v4[11] = CFSTR("waitfortlk");
  v4[12] = CFSTR("waitfortlkcreation");
  v4[13] = CFSTR("waitforunlock");
  v4[14] = CFSTR("waitfortrust");
  v4[15] = CFSTR("unhealthy");
  v4[16] = CFSTR("newtlksfailed");
  v4[17] = CFSTR("error");
  v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v4, 18));
  v2 = objc_claimAutoreleasedReturnValue(+[NSSet setWithArray:](NSSet, "setWithArray:", v1));
  v3 = (void *)qword_100341020;
  qword_100341020 = v2;

}

id sub_1000B38C8()
{
  if (qword_100341038 != -1)
    dispatch_once(&qword_100341038, &stru_1002DCC00);
  return (id)qword_100341030;
}

void sub_1000B3908(id a1)
{
  void *v1;
  uint64_t v2;
  void *v3;
  _QWORD v4[8];

  v4[0] = CFSTR("ready");
  v4[1] = CFSTR("waitfortrust");
  v4[2] = CFSTR("waitfortlk");
  v4[3] = CFSTR("waitfortlkcreation");
  v4[4] = CFSTR("waitforunlock");
  v4[5] = CFSTR("error");
  v4[6] = CFSTR("loggedout");
  v4[7] = CFSTR("halted");
  v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v4, 8));
  v2 = objc_claimAutoreleasedReturnValue(+[NSSet setWithArray:](NSSet, "setWithArray:", v1));
  v3 = (void *)qword_100341030;
  qword_100341030 = v2;

}

void sub_1000B39EC(id a1)
{
  id v1;
  void *v2;
  void *v3;
  id v4;
  NSObject *v5;
  const __CFString *v6;
  int v7;
  const __CFString *v8;
  const __CFString *v9;
  void *v10;

  v1 = objc_msgSend(objc_alloc((Class)NSUserDefaults), "initWithSuiteName:", CFSTR("com.apple.security.ckks"));
  v9 = CFSTR("reduce-rate-limiting");
  v2 = &__kCFBooleanTrue;
  if (!byte_100341050)
    v2 = &__kCFBooleanFalse;
  v10 = v2;
  v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v10, &v9, 1));
  objc_msgSend(v1, "registerDefaults:", v3);

  byte_100341050 = objc_msgSend(v1, "BOOLForKey:", CFSTR("reduce-rate-limiting"));
  v4 = sub_10000BDF4(CFSTR("ratelimit"), 0);
  v5 = objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_100341050)
      v6 = CFSTR("on");
    else
      v6 = CFSTR("off");
    v7 = 138412290;
    v8 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "reduce-rate-limiting is %@", (uint8_t *)&v7, 0xCu);
  }

}

void sub_1000B3B48(id a1)
{
  id v1;
  id v2;

  v1 = +[OctagonAPSReceiver receiverForNamedDelegatePort:apsConnectionClass:](OctagonAPSReceiver, "receiverForNamedDelegatePort:apsConnectionClass:", CFSTR("com.apple.securityd.aps"), objc_opt_class(APSConnection));
  v2 = (id)objc_claimAutoreleasedReturnValue(v1);
  objc_msgSend(v2, "registerForEnvironment:", APSEnvironmentProduction);

}

uint64_t sub_1000B3BAC(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_1000B3BC0(uint64_t a1, void *a2)
{
  id v3;
  _QWORD *v4;
  void *v5;
  _QWORD v6[4];
  id v7;

  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_1000B3C68;
  v6[3] = &unk_1002DF000;
  v7 = a2;
  v3 = v7;
  v4 = objc_retainBlock(v6);
  v5 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSViewManager manager](CKKSViewManager, "manager"));
  objc_msgSend(v5, "registerSyncStatusCallback:callback:", a1, v4);

}

uint64_t sub_1000B3C68(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_1000B3C74(id a1, NSError *a2)
{
  NSError *v2;
  id v3;
  NSObject *v4;
  _BOOL4 v5;
  const char *v6;
  NSObject *v7;
  uint32_t v8;
  int v9;
  NSError *v10;

  v2 = a2;
  v3 = sub_10000BDF4(CFSTR("reset"), 0);
  v4 = objc_claimAutoreleasedReturnValue(v3);
  v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v5)
    {
      v9 = 138412290;
      v10 = v2;
      v6 = "Local keychain reset resync finished with an error: %@";
      v7 = v4;
      v8 = 12;
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v9, v8);
    }
  }
  else if (v5)
  {
    LOWORD(v9) = 0;
    v6 = "Local keychain reset resync finished successfully";
    v7 = v4;
    v8 = 2;
    goto LABEL_6;
  }

}

void sub_1000B44E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000B4600(uint64_t a1, void *a2)
{
  void *v2;
  id v3;
  id v4;

  v2 = *(void **)(a1 + 32);
  v3 = a2;
  v4 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "rpcProcessIncomingQueue:errorOnClassAFailure:", 0, 0));
  objc_msgSend(v3, "dependOnBeforeGroupFinished:", v4);

}

void sub_1000B4658(id *a1)
{
  id WeakRetained;
  void *v3;
  id v4;
  NSObject *v5;
  void *v6;
  void *v7;
  void *v8;
  id v9;
  NSObject *v10;
  void *v11;
  id v12;
  NSObject *v13;
  uint8_t v14[8];
  NSErrorUserInfoKey v15;
  const __CFString *v16;

  WeakRetained = objc_loadWeakRetained(a1 + 6);
  if (WeakRetained)
  {
    if (objc_msgSend(a1[5], "recordsFound"))
    {
      if ((int)objc_msgSend(WeakRetained, "restartCount") < 3)
      {
        objc_msgSend(WeakRetained, "setRestartCount:", objc_msgSend(WeakRetained, "restartCount") + 1);
        v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "zoneName"));
        v12 = sub_10000BDF4(CFSTR("ckksresync"), v11);
        v13 = objc_claimAutoreleasedReturnValue(v12);

        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)v14 = 0;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "restarting synchronization operation due to new local items", v14, 2u);
        }

        objc_msgSend(WeakRetained, "groupStart");
      }
      else
      {
        v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "zoneName"));
        v4 = sub_10000BDF4(CFSTR("ckksresync"), v3);
        v5 = objc_claimAutoreleasedReturnValue(v4);

        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)v14 = 0;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "restarted synchronization too often; Failing",
            v14,
            2u);
        }

        v15 = NSLocalizedDescriptionKey;
        v16 = CFSTR("resynchronization restarted too many times; churn in database?");
        v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v16, &v15, 1));
        v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("securityd"), 2, v6));
        objc_msgSend(WeakRetained, "setError:", v7);

      }
    }
  }
  else
  {
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "zoneName"));
    v9 = sub_10000BDF4(CFSTR("ckksresync"), v8);
    v10 = objc_claimAutoreleasedReturnValue(v9);

    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v14 = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "received callback for released object", v14, 2u);
    }

  }
}

id sub_1000B4D5C(uint64_t a1, uint64_t a2)
{
  void *v3;
  id v4;
  _QWORD v6[4];
  id v7;

  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_1000B4DDC;
  v6[3] = &unk_1002DCD18;
  v3 = *(void **)(a1 + 32);
  v7 = *(id *)(a1 + 40);
  v4 = objc_msgSend(v3, "dispatchSyncWithConnection:readWriteTxion:block:", a2, 0, v6);

  return v4;
}

uint64_t sub_1000B4DDC(uint64_t a1)
{
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  return 1;
}

id sub_1000B4DFC(uint64_t a1, uint64_t a2)
{
  return objc_msgSend(*(id *)(a1 + 32), "dispatchSyncWithConnection:readWriteTxion:block:", a2, 1, *(_QWORD *)(a1 + 40));
}

BOOL sub_1000B4E10(uint64_t a1)
{
  _BYTE *v2;
  _BYTE *v3;
  _BYTE *v4;
  char v5;
  NSObject *v6;
  _BYTE *v7;
  _BOOL8 v8;
  _QWORD v10[4];
  id v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  char v16;

  v13 = 0;
  v14 = &v13;
  v15 = 0x2020000000;
  v16 = 0;
  off_100340BB8();
  v3 = v2;
  *v2 = 1;
  if (*(_BYTE *)(a1 + 48))
  {
    off_100340BD0();
    *v4 = v5;
  }
  v6 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "queue"));
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_1000B4F4C;
  v10[3] = &unk_1002DD6B8;
  v12 = &v13;
  v11 = *(id *)(a1 + 40);
  dispatch_sync(v6, v10);

  if (*(_BYTE *)(a1 + 48))
  {
    off_100340BD0();
    *v7 = 0;
  }
  *v3 = 0;
  v8 = *((unsigned __int8 *)v14 + 24) == 1;

  _Block_object_dispose(&v13, 8);
  return v8;
}

void sub_1000B4F34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000B4F4C(uint64_t a1)
{
  uint64_t result;

  result = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = result;
  return result;
}

void sub_1000B51DC(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  id v5;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "keysets"));

  if (!v2)
  {
    objc_msgSend(*(id *)(a1 + 32), "setKeysets:", *(_QWORD *)(a1 + 40));
    v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "startDependency"));

    if (v3)
    {
      v5 = objc_alloc_init((Class)NSOperationQueue);
      v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "startDependency"));
      objc_msgSend(v5, "addOperation:", v4);

      objc_msgSend(*(id *)(a1 + 32), "setStartDependency:", 0);
    }
  }
}

uint64_t sub_1000B5DA0(uint64_t a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass(&unk_1002DCD58);
  **(_QWORD **)(a1 + 32) = result;
  return result;
}

void sub_1000B5DD0(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;

  v2 = (const void *)a1[2];
  if (v2)
    CFRelease(v2);
  v3 = (const void *)a1[3];
  if (v3)
    CFRelease(v3);
  v4 = (const void *)a1[4];
  if (v4)
    CFRelease(v4);
}

CFStringRef sub_1000B5E18(uint64_t a1, const __CFDictionary *a2)
{
  const __CFArray *v4;
  const __CFString *v5;
  const __CFString *v6;
  CFIndex Count;
  CFIndex v8;

  v5 = *(const __CFString **)(a1 + 16);
  v4 = *(const __CFArray **)(a1 + 24);
  if (v5)
    v6 = v5;
  else
    v6 = CFSTR("NonConcrete");
  Count = CFArrayGetCount(v4);
  v8 = CFArrayGetCount(*(CFArrayRef *)(a1 + 32));
  return CFStringCreateWithFormat(kCFAllocatorDefault, a2, CFSTR("<ChangeTracker %@ children %ld/%ld>"), v6, Count, v8);
}

CFStringRef sub_1000B5E9C(uint64_t a1)
{
  const __CFDictionary *v2;

  v2 = (const __CFDictionary *)sub_100005100();
  return sub_1000B5E18(a1, v2);
}

void sub_1000B673C(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 144));
  _Unwind_Resume(a1);
}

void sub_1000B6840(uint64_t a1, char a2, void *a3)
{
  id v5;
  id WeakRetained;
  const void *v7;
  NSObject *v8;
  void *v9;
  void *v10;
  id v11;
  const void *v12;
  NSObject *v13;
  const void *v14;
  NSObject *v15;
  void *v16;
  void *v17;
  const void *v18;
  NSObject *v19;
  const void *v20;
  NSObject *v21;
  void *v22;
  void *v23;
  const void *v24;
  NSObject *v25;
  void *v26;
  id v27;
  id v28;
  uint8_t buf[4];
  id v30;
  __int16 v31;
  id v32;

  v5 = a3;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  if (objc_msgSend(WeakRetained, "checkFatalError:", v5))
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "uuid"));
      *(_DWORD *)buf = 138412546;
      v30 = v9;
      v31 = 2112;
      v32 = v5;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "escrowrequest: fatal error for record: %@, dropping: %@", buf, 0x16u);

    }
    v10 = *(void **)(a1 + 32);
    v28 = 0;
    objc_msgSend(v10, "deleteFromKeychain:", &v28);
    v11 = v28;
    if (*(_QWORD *)(a1 + 40))
    {
      v12 = sub_10000EF14("SecError");
      v13 = objc_claimAutoreleasedReturnValue(v12);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v30 = v11;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "escrowrequest: unable to delete last escrow time: %@", buf, 0xCu);
      }

    }
    objc_msgSend(WeakRetained, "setError:", v5);
LABEL_20:
    v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "operationQueue"));
    objc_msgSend(v23, "addOperation:", *(_QWORD *)(a1 + 48));

    goto LABEL_24;
  }
  if (!v5 && (a2 & 1) != 0)
  {
    objc_msgSend(WeakRetained, "setNumberOfRecordsUploaded:", 1);
    v14 = sub_10000EF14("SecError");
    v15 = objc_claimAutoreleasedReturnValue(v14);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "uuid"));
      *(_DWORD *)buf = 138412290;
      v30 = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "escrowrequest: prerecord %@ upload succeeded", buf, 0xCu);

    }
    objc_msgSend(*(id *)(a1 + 32), "setUploadCompleted:", 1);
    v17 = *(void **)(a1 + 32);
    v27 = 0;
    objc_msgSend(v17, "saveToKeychain:", &v27);
    v11 = v27;
    if (v11)
    {
      v18 = sub_10000EF14("SecError");
      v19 = objc_claimAutoreleasedReturnValue(v18);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v30 = 0;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "escrowrequest: unable to save last escrow time: %@", buf, 0xCu);
      }

      v20 = sub_10000EF14("SecError");
      v21 = objc_claimAutoreleasedReturnValue(v20);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "uuid"));
        *(_DWORD *)buf = 138412290;
        v30 = v22;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "escrowrequest: unable to save completion of prerecord %@ in keychain", buf, 0xCu);

      }
    }
    objc_msgSend(WeakRetained, "setNextState:", CFSTR("nothing_to_do"));
    goto LABEL_20;
  }
  v24 = sub_10000EF14("SecError");
  v25 = objc_claimAutoreleasedReturnValue(v24);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "uuid"));
    *(_DWORD *)buf = 138412546;
    v30 = v26;
    v31 = 2112;
    v32 = v5;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "escrowrequest: prerecord %@ upload failed: %@", buf, 0x16u);

  }
  objc_msgSend(WeakRetained, "setError:", v5);
  v11 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "operationQueue"));
  objc_msgSend(v11, "addOperation:", *(_QWORD *)(a1 + 48));
LABEL_24:

}

uint64_t sub_1000B6D14(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_1000B7870(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000B9310(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  void *v6;
  id v7;
  NSObject *v8;
  AAFAnalyticsEventSecurity *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  __CFString **v14;
  uint64_t v15;
  __CFString ***v16;
  __CFString *v17;
  void *v18;
  id v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  NSObject *v25;
  void *v26;
  void *v27;
  id *v28;
  __CFString *v29;
  __CFString **v30;
  id v31;
  NSObject *v32;
  __CFString *v33;
  void *v34;
  void *v35;
  void *v36;
  uint64_t v37;
  id *v38;
  void *v39;
  id v40;
  NSObject *v41;
  __CFString *v42;
  void *v43;
  void *v44;
  void *v45;
  void *v46;
  uint64_t v47;
  id *v48;
  void *v49;
  id v50;
  NSObject *v51;
  __CFString *v52;
  void *v53;
  void *v54;
  void *v55;
  void *v56;
  void *v57;
  void *v58;
  void *v59;
  id v60;
  AAFAnalyticsEventSecurity *v61;
  id v62;
  id v63;
  _QWORD v64[5];
  __CFString *v65;
  id v66;
  id v67;
  id v68;
  uint64_t *v69;
  __int128 *p_buf;
  id obj;
  id v72;
  uint64_t v73;
  uint64_t *v74;
  uint64_t v75;
  uint64_t (*v76)(uint64_t, uint64_t);
  void (*v77)(uint64_t);
  id v78;
  const __CFString *v79;
  void *v80;
  _QWORD v81[2];
  _QWORD v82[2];
  uint8_t v83[4];
  __CFString *v84;
  __int16 v85;
  void *v86;
  __int16 v87;
  id v88;
  _QWORD v89[4];
  _QWORD v90[4];
  __int128 buf;
  uint64_t v92;
  uint64_t (*v93)(uint64_t, uint64_t);
  void (*v94)(uint64_t);
  CKKSMemoryKeyCache *v95;

  v73 = 0;
  v74 = &v73;
  v75 = 0x3032000000;
  v76 = sub_1000B9FC4;
  v77 = sub_1000B9FD4;
  v78 = 0;
  v2 = *(void **)(a1 + 32);
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "contextID"));
  v5 = *(_QWORD *)(a1 + 48);
  v72 = 0;
  v6 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSSQLDatabaseObject allUUIDsWithContextID:inZones:error:](CKKSMirrorEntry, "allUUIDsWithContextID:inZones:error:", v4, v5, &v72));
  v60 = v72;
  objc_msgSend(v2, "unionSet:", v6);

  if (v60)
  {
    v7 = sub_10000BDF4(CFSTR("ckksscan"), 0);
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 138412290;
      *(_QWORD *)((char *)&buf + 4) = v60;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Unable to load CKMirrorEntries: %@", (uint8_t *)&buf, 0xCu);
    }

  }
  *(_QWORD *)&buf = 0;
  *((_QWORD *)&buf + 1) = &buf;
  v92 = 0x3032000000;
  v93 = sub_1000B9FC4;
  v94 = sub_1000B9FD4;
  v95 = (CKKSMemoryKeyCache *)0xAAAAAAAAAAAAAAAALL;
  v95 = objc_alloc_init(CKKSMemoryKeyCache);
  v9 = [AAFAnalyticsEventSecurity alloc];
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
  v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "activeAccount"));
  v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "altDSID"));
  v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
  v61 = -[AAFAnalyticsEventSecurity initWithCKKSMetrics:altDSID:eventName:testsAreEnabled:category:sendMetric:](v9, "initWithCKKSMetrics:altDSID:eventName:testsAreEnabled:category:sendMetric:", &__NSDictionary0__struct, v12, CFSTR("com.apple.security.ckks.scanLocalItems.querySyncableItems"), 0, &off_10030AF70, objc_msgSend(v13, "sendMetric"));

  v14 = &off_1002E2190;
  v15 = kSecAttrTombstone;
  v16 = off_1002E4320;
  do
  {
    if (*((_BYTE *)v14 + 8))
    {
      v17 = *v14;
      v89[0] = kSecClass;
      v89[1] = kSecReturnRef;
      v90[0] = v17;
      v90[1] = &__kCFBooleanTrue;
      v90[2] = &__kCFBooleanTrue;
      v89[2] = kSecAttrSynchronizable;
      v89[3] = v15;
      v90[3] = &__kCFBooleanFalse;
      v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v90, v89, 4));
      v19 = objc_msgSend(v18, "mutableCopy");

      v20 = *(void **)(a1 + 40);
      v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "deps"));
      v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "views"));
      v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "queryPredicatesForViewMapping:", v22));

      objc_msgSend(v19, "addEntriesFromDictionary:", v23);
      v24 = sub_10000BDF4(CFSTR("ckksscan"), 0);
      v25 = objc_claimAutoreleasedReturnValue(v24);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "name"));
        *(_DWORD *)v83 = 138412802;
        v84 = v17;
        v85 = 2112;
        v86 = v26;
        v87 = 2112;
        v88 = v19;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Scanning all synchronizable %@ items(%@) for: %@", v83, 0x20u);

      }
      v27 = *(void **)(a1 + 40);
      v28 = (id *)(v74 + 5);
      obj = (id)v74[5];
      v64[0] = _NSConcreteStackBlock;
      v64[1] = 3221225472;
      v64[2] = sub_1000B9FDC;
      v64[3] = &unk_1002DCF18;
      v64[4] = v27;
      v29 = v17;
      v65 = v29;
      v69 = &v73;
      v66 = *(id *)(a1 + 56);
      v67 = *(id *)(a1 + 32);
      p_buf = &buf;
      v68 = *(id *)(a1 + 64);
      objc_msgSend(v27, "executeQuery:readWrite:error:block:", v19, 0, &obj, v64);
      objc_storeStrong(v28, obj);

    }
    v30 = *v16++;
    v14 = v30;
  }
  while (v30);
  if (!objc_msgSend(*(id *)(a1 + 32), "count"))
    goto LABEL_22;
  v31 = sub_10000BDF4(CFSTR("ckksscan"), 0);
  v32 = objc_claimAutoreleasedReturnValue(v31);
  if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
  {
    v33 = (__CFString *)objc_msgSend(*(id *)(a1 + 32), "count");
    *(_DWORD *)v83 = 134217984;
    v84 = v33;
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "keychain missing %lu items from mirror, proceeding with queue scanning", v83, 0xCu);
  }

  v34 = *(void **)(a1 + 32);
  v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
  v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v35, "contextID"));
  v37 = *(_QWORD *)(a1 + 48);
  v38 = (id *)(v74 + 5);
  v63 = (id)v74[5];
  v39 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSSQLDatabaseObject allUUIDsWithContextID:inZones:error:](CKKSIncomingQueueEntry, "allUUIDsWithContextID:inZones:error:", v36, v37, &v63));
  objc_storeStrong(v38, v63);
  objc_msgSend(v34, "minusSet:", v39);

  if (v74[5])
  {
    v40 = sub_10000BDF4(CFSTR("ckksscan"), 0);
    v41 = objc_claimAutoreleasedReturnValue(v40);
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
    {
      v42 = (__CFString *)v74[5];
      *(_DWORD *)v83 = 138412290;
      v84 = v42;
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "unable to inspect incoming queue: %@", v83, 0xCu);
    }

    objc_msgSend(*(id *)(a1 + 40), "setError:", v74[5]);
    v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "error"));
    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", v61, 0, v43);
    goto LABEL_23;
  }
  v44 = *(void **)(a1 + 32);
  v45 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
  v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v45, "contextID"));
  v47 = *(_QWORD *)(a1 + 48);
  v48 = (id *)(v74 + 5);
  v62 = (id)v74[5];
  v49 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSSQLDatabaseObject allUUIDsWithContextID:inZones:error:](CKKSOutgoingQueueEntry, "allUUIDsWithContextID:inZones:error:", v46, v47, &v62));
  objc_storeStrong(v48, v62);
  objc_msgSend(v44, "minusSet:", v49);

  if (!v74[5])
  {
LABEL_22:
    v53 = *(void **)(a1 + 72);
    v81[0] = CFSTR("itemsScanned");
    v54 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(*(id *)(a1 + 40), "processedItems")));
    v81[1] = CFSTR("newItemsScanned");
    v82[0] = v54;
    v55 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", objc_msgSend(*(id *)(a1 + 40), "recordsFound")));
    v82[1] = v55;
    v56 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v82, v81, 2));
    objc_msgSend(v53, "addMetrics:", v56);

    v79 = CFSTR("newItemsScanned");
    v57 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", objc_msgSend(*(id *)(a1 + 40), "recordsFound")));
    v80 = v57;
    v58 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v80, &v79, 1));
    -[AAFAnalyticsEventSecurity addMetrics:](v61, "addMetrics:", v58);

    v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "error"));
    v59 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "error"));
    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", v61, v43 != 0, v59);

    goto LABEL_23;
  }
  v50 = sub_10000BDF4(CFSTR("ckksscan"), 0);
  v51 = objc_claimAutoreleasedReturnValue(v50);
  if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
  {
    v52 = (__CFString *)v74[5];
    *(_DWORD *)v83 = 138412290;
    v84 = v52;
    _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, "unable to inspect outgoing queue: %@", v83, 0xCu);
  }

  objc_msgSend(*(id *)(a1 + 40), "setError:", v74[5]);
  v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "error"));
  +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", v61, 0, v43);
LABEL_23:

  _Block_object_dispose(&buf, 8);
  _Block_object_dispose(&v73, 8);

}

void sub_1000B9BD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  uint64_t v31;

  _Block_object_dispose((const void *)(v31 - 176), 8);
  _Block_object_dispose(&a31, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000B9C20(uint64_t a1)
{
  void *v1;
  void *v2;
  id v3;
  __int128 v4;
  id v5;
  uint64_t v6;
  const __CFString *v7;
  __CFString *v8;
  void *i;
  void *v10;
  void *v11;
  unsigned __int8 v12;
  const __CFString *v13;
  void *v14;
  void *v15;
  void *v16;
  __CFString *v17;
  void *v18;
  void *v19;
  NSObject *v20;
  void *v21;
  id v22;
  void *v23;
  void *v24;
  id v25;
  NSObject *v26;
  NSObject *v27;
  os_log_type_t v28;
  const char *v29;
  uint32_t v30;
  void *v31;
  void *v32;
  id v33;
  void *v34;
  void *v35;
  __int128 v37;
  uint64_t v38;
  id obj;
  id v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  uint8_t buf[4];
  id v47;
  _BYTE v48[128];

  v42 = 0u;
  v43 = 0u;
  v44 = 0u;
  v45 = 0u;
  v1 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "deps"));
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "activeManagedViews"));

  obj = v2;
  v3 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v42, v48, 16);
  if (v3)
  {
    v5 = v3;
    v6 = *(_QWORD *)v43;
    v7 = CFSTR("ready");
    v8 = CFSTR("ckksscan");
    *(_QWORD *)&v4 = 138412290;
    v37 = v4;
    v38 = *(_QWORD *)v43;
    do
    {
      for (i = 0; i != v5; i = (char *)i + 1)
      {
        if (*(_QWORD *)v43 != v6)
          objc_enumerationMutation(obj);
        v10 = *(void **)(*((_QWORD *)&v42 + 1) + 8 * (_QWORD)i);
        v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "viewKeyHierarchyState", v37));
        v12 = objc_msgSend(v11, "isEqualToString:", v7);

        if ((v12 & 1) != 0)
        {
          v13 = v7;
          v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "launch"));
          objc_msgSend(v14, "addEvent:", CFSTR("scan-local-items"));

          v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "deps"));
          v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "contextID"));
          v17 = v8;
          v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "zoneID"));
          v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "zoneName"));
          v20 = objc_claimAutoreleasedReturnValue(+[CKKSZoneStateEntry contextID:zoneName:](CKKSZoneStateEntry, "contextID:zoneName:", v16, v19));

          v8 = v17;
          v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate now](NSDate, "now"));
          -[NSObject setLastLocalKeychainScanTime:](v20, "setLastLocalKeychainScanTime:", v21);

          v41 = 0;
          -[NSObject saveToDatabase:](v20, "saveToDatabase:", &v41);
          v22 = v41;
          v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "zoneID"));
          v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v23, "zoneName"));
          v25 = sub_10000BDF4(v17, v24);
          v26 = objc_claimAutoreleasedReturnValue(v25);

          if (v22)
          {
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = v37;
              v47 = v22;
              v27 = v26;
              v28 = OS_LOG_TYPE_ERROR;
              v29 = "Unable to save 'scanned' bit: %@";
              v30 = 12;
              goto LABEL_14;
            }
          }
          else if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            v27 = v26;
            v28 = OS_LOG_TYPE_DEFAULT;
            v29 = "Saved scanned status.";
            v30 = 2;
LABEL_14:
            _os_log_impl((void *)&_mh_execute_header, v27, v28, v29, buf, v30);
          }

          v7 = v13;
          v6 = v38;
          goto LABEL_16;
        }
        v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "zoneID"));
        v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v31, "zoneName"));
        v33 = sub_10000BDF4(v8, v32);
        v20 = objc_claimAutoreleasedReturnValue(v33);

        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "View wasn't ready for scan", buf, 2u);
        }
LABEL_16:

      }
      v5 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v42, v48, 16);
    }
    while (v5);
  }

  v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "deps"));
  v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v34, "overallLaunch"));
  objc_msgSend(v35, "addEvent:", CFSTR("scan-local-items"));

  return 1;
}

uint64_t sub_1000B9FC4(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_1000B9FD4(uint64_t a1)
{

}

void sub_1000B9FDC(uint64_t a1, __CFString *a2)
{
  id v4;
  NSObject *v5;
  id v6;
  NSObject *v7;
  const void *v8;
  void *v9;
  id v10;
  NSObject *v11;
  void *v12;
  void *v13;
  void *v14;
  id v15;
  id v16;
  uint64_t v17;
  void *i;
  void *v19;
  void *v20;
  void *v21;
  unsigned __int8 v22;
  id v23;
  const char *v24;
  NSObject *v25;
  const void *v26;
  __CFString *v27;
  void *v28;
  unsigned int v29;
  void *v30;
  void *v31;
  id v32;
  NSObject *v33;
  __CFDictionary *v34;
  id v35;
  void *v36;
  void *v37;
  id v38;
  NSObject *v39;
  uint64_t v40;
  void *v41;
  id v42;
  id v43;
  uint64_t v44;
  void *v45;
  void *v46;
  uint64_t v47;
  __CFString *v48;
  void *v49;
  uint64_t v50;
  __CFString *v51;
  uint64_t v52;
  id *v53;
  void *v54;
  void *v55;
  void *v56;
  void *v57;
  id v58;
  NSObject *v59;
  void *v60;
  void *v61;
  void *v62;
  void *v63;
  void *v64;
  id v65;
  NSObject *v66;
  void *v67;
  uint64_t v68;
  void *v69;
  void *v70;
  uint64_t v71;
  void *v72;
  void *v73;
  void *v74;
  id v75;
  NSObject *v76;
  _BOOL4 v77;
  void *v78;
  unsigned int v79;
  void *v80;
  void *v81;
  void *v82;
  uint64_t v83;
  NSObject *v84;
  id v85;
  id obj;
  __CFString *v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  uint8_t buf[4];
  __CFString *v93;
  __int16 v94;
  __CFString *v95;
  _BYTE v96[128];

  v4 = sub_10000BDF4(CFSTR("ckksscan"), 0);
  v5 = objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138477827;
    v93 = a2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "scanning item: %{private}@", buf, 0xCu);
  }

  objc_msgSend(*(id *)(a1 + 32), "setProcessedItems:", (char *)objc_msgSend(*(id *)(a1 + 32), "processedItems") + 1);
  if (sub_10001DA80(a2))
  {
    v6 = sub_10000BDF4(CFSTR("ckksscan"), 0);
    v7 = objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138477827;
      v93 = a2;
      _os_log_debug_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "Skipping tombstone %{private}@", buf, 0xCu);
    }
    goto LABEL_69;
  }
  v8 = sub_10000C1D0(a2, kSecAttrAccessible);
  v7 = objc_claimAutoreleasedReturnValue(v8);
  if ((-[NSObject isEqualToString:](v7, "isEqualToString:", kSecAttrAccessibleWhenUnlocked) & 1) == 0
    && (-[NSObject isEqualToString:](v7, "isEqualToString:", kSecAttrAccessibleAfterFirstUnlock) & 1) == 0
    && (-[NSObject isEqualToString:](v7, "isEqualToString:", kSecAttrAccessibleAlwaysPrivate) & 1) == 0)
  {
    v43 = sub_10000BDF4(CFSTR("ckksscan"), 0);
    v11 = objc_claimAutoreleasedReturnValue(v43);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      goto LABEL_68;
    *(_DWORD *)buf = 138412290;
    v93 = (__CFString *)v7;
    v24 = "skipping sync of device-bound(%@) item";
    goto LABEL_40;
  }
  if (qword_1003412C8 != -1)
    dispatch_once(&qword_1003412C8, &stru_1002E7860);
  if (!byte_1003412C0 && !sub_1001164E4(a2))
  {
    v23 = sub_10000BDF4(CFSTR("ckksscan"), 0);
    v11 = objc_claimAutoreleasedReturnValue(v23);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      goto LABEL_68;
    *(_DWORD *)buf = 138477827;
    v93 = a2;
    v24 = "Ignoring syncable keychain item for non-primary account: %{private}@";
LABEL_40:
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v24, buf, 0xCu);
    goto LABEL_68;
  }
  v9 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSKey isItemKeyForKeychainView:](CKKSKey, "isItemKeyForKeychainView:", a2));

  if (v9)
  {
    v10 = sub_10000BDF4(CFSTR("ckksscan"), 0);
    v11 = objc_claimAutoreleasedReturnValue(v10);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "Scanned item is a CKKS internal key, skipping", buf, 2u);
    }
    goto LABEL_68;
  }
  v84 = v7;
  v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "deps"));
  v11 = objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "viewNameForItem:", a2));

  v90 = 0u;
  v91 = 0u;
  v88 = 0u;
  v89 = 0u;
  v83 = a1;
  v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "deps"));
  v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "activeManagedViews"));

  v15 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v88, v96, 16);
  if (!v15)
    goto LABEL_24;
  v16 = v15;
  v17 = *(_QWORD *)v89;
  while (2)
  {
    for (i = 0; i != v16; i = (char *)i + 1)
    {
      if (*(_QWORD *)v89 != v17)
        objc_enumerationMutation(v14);
      v19 = *(void **)(*((_QWORD *)&v88 + 1) + 8 * (_QWORD)i);
      v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "zoneID"));
      v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "zoneName"));
      v22 = objc_msgSend(v21, "isEqualToString:", v11);

      if ((v22 & 1) != 0)
      {
        v25 = v19;

        if (!v25)
          goto LABEL_36;
        v87 = 0;
        v26 = sub_100019204(a2, (uint64_t)&off_1002E9538, &v87);
        v27 = (__CFString *)CFRetain(v26);
        v7 = v84;
        if (!v27
          || (v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSNull null](NSNull, "null")),
              v29 = -[__CFString isEqual:](v27, "isEqual:", v28),
              v28,
              v29))
        {
          v30 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject zoneID](v25, "zoneID"));
          v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "zoneName"));
          v32 = sub_10000BDF4(CFSTR("ckksscan"), v31);
          v33 = objc_claimAutoreleasedReturnValue(v32);

          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138478083;
            v93 = a2;
            v94 = 2112;
            v95 = v87;
            _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "making new UUID for item %{private}@: %@", buf, 0x16u);
          }

          v34 = sub_10001904C(a2, 1, 0, &v87);
          v35 = -[__CFDictionary mutableCopy](v34, "mutableCopy");

          objc_msgSend(v35, "setObject:forKeyedSubscript:", *(_QWORD *)(v83 + 40), kSecClass);
          if (SecErrorGetOSStatus(v87))
          {
            v36 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject zoneID](v25, "zoneID"));
            v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v36, "zoneName"));
            v38 = sub_10000BDF4(CFSTR("ckksscan"), v37);
            v39 = objc_claimAutoreleasedReturnValue(v38);

            if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 138412290;
              v93 = v87;
              _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "couldn't copy UUID-less item's primary key: %@", buf, 0xCu);
            }

            v40 = *(_QWORD *)(*(_QWORD *)(v83 + 72) + 8);
            v41 = *(void **)(v40 + 40);
            *(_QWORD *)(v40 + 40) = v87;

            objc_msgSend(*(id *)(v83 + 32), "setError:", *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v83 + 72) + 8) + 40));
          }
          else
          {
            v62 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v83 + 48), "objectForKeyedSubscript:", v25));
            if (!v62)
            {
              v62 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](NSMutableSet, "set"));
              objc_msgSend(*(id *)(v83 + 48), "setObject:forKeyedSubscript:", v62, v25);
            }
            objc_msgSend(v62, "addObject:", v35);

          }
          goto LABEL_66;
        }
        v44 = v83;
        v45 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v83 + 32), "deps"));
        v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v45, "contextID"));
        v47 = objc_claimAutoreleasedReturnValue(-[NSObject zoneID](v25, "zoneID"));
        v48 = v27;
        v49 = (void *)v47;
        v50 = *(_QWORD *)(*(_QWORD *)(v83 + 72) + 8);
        obj = *(id *)(v50 + 40);
        v51 = v48;
        v52 = objc_claimAutoreleasedReturnValue(+[CKKSMirrorEntry tryFromDatabase:contextID:zoneID:error:](CKKSMirrorEntry, "tryFromDatabase:contextID:zoneID:error:"));
        v53 = (id *)(v50 + 40);
        v54 = (void *)v52;
        objc_storeStrong(v53, obj);

        if (v54)
        {
          v55 = v54;
          v27 = v51;
          objc_msgSend(*(id *)(v83 + 56), "removeObject:", v51);
          v56 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject zoneID](v25, "zoneID"));
          v57 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v56, "zoneName"));
          v58 = sub_10000BDF4(CFSTR("ckksscan"), v57);
          v59 = objc_claimAutoreleasedReturnValue(v58);

          if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 138412290;
            v93 = v51;
            _os_log_debug_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEBUG, "Existing mirror entry with UUID %@", buf, 0xCu);
          }

          v60 = *(void **)(v83 + 32);
          v61 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v55, "item"));
          LOBYTE(v60) = objc_msgSend(v60, "areEquivalent:ckksItem:keyCache:", a2, v61, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v83 + 80) + 8) + 40));

          if ((v60 & 1) != 0)
          {
            v35 = v55;
LABEL_66:

            goto LABEL_67;
          }
          v44 = v83;
          v63 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject zoneID](v25, "zoneID"));
          v64 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v63, "zoneName"));
          v65 = sub_10000BDF4(CFSTR("ckksscan"), v64);
          v66 = objc_claimAutoreleasedReturnValue(v65);

          if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138412290;
            v93 = v51;
            _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "Existing mirror entry with UUID %@ does not match local item", buf, 0xCu);
          }

          v54 = v55;
        }
        v67 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v44 + 32), "deps", v54));
        v68 = v44;
        v69 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v67, "contextID"));
        v70 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject zoneID](v25, "zoneID"));
        v71 = *(_QWORD *)(*(_QWORD *)(v68 + 72) + 8);
        v85 = *(id *)(v71 + 40);
        v72 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSOutgoingQueueEntry tryFromDatabase:contextID:zoneID:error:](CKKSOutgoingQueueEntry, "tryFromDatabase:contextID:zoneID:error:", v51, v69, v70, &v85));
        objc_storeStrong((id *)(v71 + 40), v85);

        v73 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject zoneID](v25, "zoneID"));
        v74 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v73, "zoneName"));
        v75 = sub_10000BDF4(CFSTR("ckksscan"), v74);
        v76 = objc_claimAutoreleasedReturnValue(v75);

        v77 = os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT);
        v27 = v51;
        if (v72)
        {
          if (v77)
          {
            *(_DWORD *)buf = 138412290;
            v93 = v51;
            _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "Existing outgoing queue entry with UUID %@", buf, 0xCu);
          }

          v78 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v72, "state"));
          v79 = objc_msgSend(v78, "isEqualToString:", CFSTR("new"));

          v35 = v82;
          if (!v79)
            goto LABEL_65;
          v80 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v83 + 32), "viewsWithNewCKKSEntries"));
          objc_msgSend(v80, "addObject:", v25);
        }
        else
        {
          if (v77)
          {
            *(_DWORD *)buf = 138412290;
            v93 = v51;
            _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "Item(%@) is new; will attempt to add to CKKS",
              buf,
              0xCu);
          }

          objc_msgSend(*(id *)(v83 + 32), "setRecordsFound:", (char *)objc_msgSend(*(id *)(v83 + 32), "recordsFound") + 1);
          v80 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v83 + 64), "objectForKeyedSubscript:", v25));
          if (!v80)
          {
            v80 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
            objc_msgSend(*(id *)(v83 + 64), "setObject:forKeyedSubscript:", v80, v25);
          }
          v81 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v80, "objectForKeyedSubscript:", *(_QWORD *)(v83 + 40)));
          if (!v81)
          {
            v81 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](NSMutableSet, "set"));
            objc_msgSend(v80, "setObject:forKeyedSubscript:", v81, *(_QWORD *)(v83 + 40));
          }
          objc_msgSend(v81, "addObject:", v51);

          v35 = v82;
        }

LABEL_65:
        goto LABEL_66;
      }
    }
    v16 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v88, v96, 16);
    if (v16)
      continue;
    break;
  }
LABEL_24:

LABEL_36:
  v42 = sub_10000BDF4(CFSTR("ckksscan"), 0);
  v25 = objc_claimAutoreleasedReturnValue(v42);
  v7 = v84;
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138412290;
    v93 = (__CFString *)v11;
    _os_log_debug_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEBUG, "Scanned item is for view %@, skipping", buf, 0xCu);
  }
LABEL_67:

LABEL_68:
LABEL_69:

}

uint64_t sub_1000BAAEC(uint64_t a1)
{
  id v2;
  NSObject *v3;
  id v4;
  void *v5;
  void *v6;
  void *v7;
  __int128 v8;
  id v9;
  uint64_t v10;
  void **p_cache;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  BOOL v18;
  id v19;
  NSObject *v20;
  id v21;
  id v22;
  id v23;
  uint64_t v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  __int128 v31;
  uint64_t v32;
  id obj;
  id v34;
  id v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  id v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  _BYTE v45[128];
  uint8_t v46[128];
  uint8_t buf[4];
  id v48;
  __int16 v49;
  id v50;

  v2 = sub_10000BDF4(CFSTR("ckksscan"), 0);
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    v4 = objc_msgSend(*(id *)(a1 + 32), "count");
    v5 = *(void **)(a1 + 32);
    *(_DWORD *)buf = 134218242;
    v48 = v4;
    v49 = 2112;
    v50 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "BUG: keychain missing %lu items from mirror and/or queues: %@", buf, 0x16u);
  }

  objc_msgSend(*(id *)(a1 + 40), "setMissingLocalItemsFound:", objc_msgSend(*(id *)(a1 + 32), "count"));
  v6 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(*(id *)(a1 + 32), "count")));
  objc_msgSend(v6, "logMetric:withName:", v7, CFSTR("CKKSEventMissingLocalItemsFound"));

  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  obj = *(id *)(a1 + 32);
  v35 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v41, v46, 16);
  v9 = 0;
  if (v35)
  {
    v10 = *(_QWORD *)v42;
    p_cache = OTAccountsActualAdapter.cache;
    *(_QWORD *)&v8 = 138412546;
    v31 = v8;
    v32 = *(_QWORD *)v42;
    do
    {
      v12 = 0;
      v13 = v9;
      do
      {
        if (*(_QWORD *)v42 != v10)
          objc_enumerationMutation(obj);
        v14 = *(void **)(*((_QWORD *)&v41 + 1) + 8 * (_QWORD)v12);
        v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps", v31));
        v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "contextID"));
        v40 = v13;
        v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(p_cache + 508, "allWithUUID:contextID:error:", v14, v16, &v40));
        v9 = v40;

        if (v17)
          v18 = v9 == 0;
        else
          v18 = 0;
        if (v18)
        {
          v34 = v9;
          v38 = 0u;
          v39 = 0u;
          v36 = 0u;
          v37 = 0u;
          v21 = v17;
          v22 = objc_msgSend(v21, "countByEnumeratingWithState:objects:count:", &v36, v45, 16);
          if (v22)
          {
            v23 = v22;
            v24 = *(_QWORD *)v37;
            do
            {
              v25 = 0;
              do
              {
                if (*(_QWORD *)v37 != v24)
                  objc_enumerationMutation(v21);
                v26 = *(void **)(*((_QWORD *)&v36 + 1) + 8 * (_QWORD)v25);
                v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps"));
                v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "item"));
                v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "storedCKRecord"));
                objc_msgSend(v27, "intransactionCKRecordChanged:resync:", v29, 1);

                v25 = (char *)v25 + 1;
              }
              while (v23 != v25);
              v23 = objc_msgSend(v21, "countByEnumeratingWithState:objects:count:", &v36, v45, 16);
            }
            while (v23);
          }

          v10 = v32;
          p_cache = (void **)(OTAccountsActualAdapter + 16);
          v9 = v34;
        }
        else
        {
          v19 = sub_10000BDF4(CFSTR("ckksscan"), 0);
          v20 = objc_claimAutoreleasedReturnValue(v19);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = v31;
            v48 = v14;
            v49 = 2112;
            v50 = v9;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "BUG: error fetching previously-extant CKME (uuid: %@) from database: %@", buf, 0x16u);
          }

          objc_msgSend(*(id *)(a1 + 40), "setError:", v9);
        }

        v12 = (char *)v12 + 1;
        v13 = v9;
      }
      while (v12 != v35);
      v35 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v41, v46, 16);
    }
    while (v35);
  }

  return 1;
}

uint64_t sub_1000BAEB0(id *a1)
{
  id v2;
  uint64_t v3;
  void *i;
  uint64_t v5;
  void *v6;
  void *v7;
  id v8;
  NSObject *v9;
  id v10;
  id v11;
  int v12;
  const void *v13;
  void *v14;
  void *v15;
  id v16;
  NSObject *v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  id obj;
  _QWORD v23[5];
  id v24;
  id v25;
  __int128 *p_buf;
  uint64_t *v27;
  _QWORD *v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  _QWORD v33[5];
  CKKSMemoryKeyCache *v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t (*v38)(uint64_t, uint64_t);
  void (*v39)(uint64_t);
  id v40;
  uint8_t v41[4];
  uint64_t v42;
  __int128 buf;
  uint64_t v44;
  uint64_t v45;
  _BYTE v46[128];

  v35 = 0;
  v36 = &v35;
  v37 = 0x3032000000;
  v38 = sub_1000B9FC4;
  v39 = sub_1000B9FD4;
  v40 = 0;
  v33[0] = 0;
  v33[1] = v33;
  v33[2] = 0x3032000000;
  v33[3] = sub_1000B9FC4;
  v33[4] = sub_1000B9FD4;
  v34 = (CKKSMemoryKeyCache *)0xAAAAAAAAAAAAAAAALL;
  v34 = objc_alloc_init(CKKSMemoryKeyCache);
  v29 = 0u;
  v30 = 0u;
  v31 = 0u;
  v32 = 0u;
  obj = a1[4];
  v2 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v29, v46, 16);
  if (v2)
  {
    v3 = *(_QWORD *)v30;
    while (2)
    {
      for (i = 0; i != v2; i = (char *)i + 1)
      {
        if (*(_QWORD *)v30 != v3)
          objc_enumerationMutation(obj);
        v5 = *(_QWORD *)(*((_QWORD *)&v29 + 1) + 8 * (_QWORD)i);
        v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[5], "zoneID"));
        v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "zoneName"));
        v8 = sub_10000BDF4(CFSTR("ckksscan"), v7);
        v9 = objc_claimAutoreleasedReturnValue(v8);

        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 138412290;
          *(_QWORD *)((char *)&buf + 4) = v5;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Found item with no uuid: %@", (uint8_t *)&buf, 0xCu);
        }

        *(_QWORD *)&buf = 0;
        *((_QWORD *)&buf + 1) = &buf;
        v44 = 0x2020000000;
        v45 = 0;
        v23[0] = _NSConcreteStackBlock;
        v23[1] = 3221225472;
        v23[2] = sub_1000BB2A8;
        v23[3] = &unk_1002DCEF0;
        v23[4] = v5;
        p_buf = &buf;
        v10 = a1[5];
        v11 = a1[6];
        v24 = v10;
        v25 = v11;
        v27 = &v35;
        v28 = v33;
        v12 = sub_100011A30(1, 1, 0, (uint64_t)&v45, (uint64_t)v23);
        if ((v12 & 1) != 0)
        {
          v13 = *(const void **)(*((_QWORD *)&buf + 1) + 24);
          if (v13)
          {
            *(_QWORD *)(*((_QWORD *)&buf + 1) + 24) = 0;
            CFRelease(v13);
          }
        }
        else
        {
          v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[5], "zoneID"));
          v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "zoneName"));
          v16 = sub_10000BDF4(CFSTR("ckksscan"), v15);
          v17 = objc_claimAutoreleasedReturnValue(v16);

          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            v18 = *(_QWORD *)(*((_QWORD *)&buf + 1) + 24);
            *(_DWORD *)v41 = 138412290;
            v42 = v18;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "couldn't execute query: %@", v41, 0xCu);
          }

          v19 = (void *)v36[5];
          v36[5] = *(_QWORD *)(*((_QWORD *)&buf + 1) + 24);

          objc_msgSend(a1[6], "setError:", v36[5]);
        }

        _Block_object_dispose(&buf, 8);
        if (!v12)
        {
          v20 = 0;
          goto LABEL_19;
        }
      }
      v2 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v29, v46, 16);
      if (v2)
        continue;
      break;
    }
  }
  v20 = 1;
LABEL_19:

  _Block_object_dispose(v33, 8);
  _Block_object_dispose(&v35, 8);

  return v20;
}

void sub_1000BB24C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a37, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000BB2A8(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  __CFString **v6;
  uint64_t v7;
  void *v8;
  void *v9;
  id v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t result;
  uint64_t v15;
  __int128 v16;
  _BOOL4 v17;
  int v18;
  char v19;
  char v20;
  _QWORD v21[4];
  id v22;
  __int128 v23;
  __int128 v24;
  __int128 *p_buf;
  uint64_t v26;
  uint64_t v27;
  __int128 buf;
  uint64_t v29;
  char v30;

  v4 = sub_1000112B0(*(const __CFDictionary **)(a1 + 32), 0, -1, 0, (__CFString **)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24));
  if (v4
    && (v5 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8), v7 = *(_QWORD *)(v5 + 24), v6 = (__CFString **)(v5 + 24), !v7))
  {
    v15 = v4;
    *(_QWORD *)&buf = 0;
    *((_QWORD *)&buf + 1) = &buf;
    v29 = 0x2020000000;
    v30 = 1;
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 3221225472;
    v21[2] = sub_1000BB4CC;
    v21[3] = &unk_1002DCEC8;
    v22 = *(id *)(a1 + 40);
    v16 = *(_OWORD *)(a1 + 64);
    v23 = *(_OWORD *)(a1 + 48);
    v26 = a2;
    v27 = v15;
    v24 = v16;
    p_buf = &buf;
    v17 = sub_1000043D4(v15, 0, a2, v6, (uint64_t)v21);
    if (*(_BYTE *)(*((_QWORD *)&buf + 1) + 24))
      v18 = v17;
    else
      v18 = 0;
    *(_BYTE *)(*((_QWORD *)&buf + 1) + 24) = v18;
    v19 = sub_10001CAF8(v15, v18, (CFErrorRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24));
    if (*(_BYTE *)(*((_QWORD *)&buf + 1) + 24))
      v20 = v19;
    else
      v20 = 0;
    *(_BYTE *)(*((_QWORD *)&buf + 1) + 24) = v20;

    _Block_object_dispose(&buf, 8);
    return 1;
  }
  else
  {
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "zoneID"));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "zoneName"));
    v10 = sub_10000BDF4(CFSTR("ckksscan"), v9);
    v11 = objc_claimAutoreleasedReturnValue(v10);

    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v12 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24);
      LODWORD(buf) = 138412290;
      *(_QWORD *)((char *)&buf + 4) = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "couldn't create query: %@", (uint8_t *)&buf, 0xCu);
    }

    v13 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
    result = *(_QWORD *)(v13 + 24);
    if (result)
    {
      *(_QWORD *)(v13 + 24) = 0;
      CFRelease((CFTypeRef)result);
      return 0;
    }
  }
  return result;
}

void sub_1000BB4CC(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;
  const __CFDictionary *v6;
  void *v7;
  void *v8;
  id v9;
  NSObject *v10;
  const void *v11;
  const void *v12;
  uint64_t v13;
  CFTypeRef *v14;
  _BOOL4 v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  id v20;
  NSObject *v21;
  void *v22;
  void *v23;
  id v24;
  NSObject *v25;
  void *v26;
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;
  id v31;
  void *v32;
  uint64_t v33;
  BOOL v34;
  id v35;
  _QWORD v36[7];
  __int128 v37;
  uint8_t buf[4];
  void *v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  void *v43;

  v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](NSUUID, "UUID"));
  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "UUIDString"));

  v42 = kSecAttrUUID;
  v43 = v5;
  v6 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v43, &v42, 1));
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "zoneName"));
  v9 = sub_10000BDF4(CFSTR("ckksscan"), v8);
  v10 = objc_claimAutoreleasedReturnValue(v9);

  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412547;
    v39 = v5;
    v40 = 2113;
    v41 = a2;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Assigning new UUID %@ for item %{private}@", buf, 0x16u);
  }

  v11 = sub_1000070C4(a2, v6, (__CFString **)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24));
  if (v11)
  {
    v12 = v11;
    v13 = *(_QWORD *)(a1 + 48);
    v14 = (CFTypeRef *)(*(_QWORD *)(v13 + 8) + 24);
    v36[0] = _NSConcreteStackBlock;
    v36[1] = 3221225472;
    v36[2] = sub_1000BB84C;
    v36[3] = &unk_1002DCEA0;
    v36[5] = a2;
    v36[6] = v11;
    v37 = *(_OWORD *)(a1 + 80);
    v36[4] = v13;
    v15 = sub_10001AC0C(v37, 5, v14, (uint64_t)v36);
    if (v15)
    {
      v17 = *(_QWORD *)(a1 + 32);
      v16 = *(void **)(a1 + 40);
      v18 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 40);
      v19 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
      v35 = *(id *)(v19 + 40);
      objc_msgSend(v16, "onboardItemToCKKS:viewState:keyCache:error:", v12, v17, v18, &v35);
      v20 = v35;
      v21 = *(NSObject **)(v19 + 40);
      *(_QWORD *)(v19 + 40) = v20;
    }
    else
    {
      v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
      v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v29, "zoneName"));
      v31 = sub_10000BDF4(CFSTR("ckksscan"), v30);
      v21 = objc_claimAutoreleasedReturnValue(v31);

      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        v32 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
        *(_DWORD *)buf = 138412290;
        v39 = v32;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Unable to update item with new UUID: %@", buf, 0xCu);
      }
    }

    v33 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8);
    if (*(_BYTE *)(v33 + 24))
      v34 = v15;
    else
      v34 = 0;
    *(_BYTE *)(v33 + 24) = v34;
  }
  else
  {
    v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID"));
    v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "zoneName"));
    v24 = sub_10000BDF4(CFSTR("ckksscan"), v23);
    v25 = objc_claimAutoreleasedReturnValue(v24);

    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      v26 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
      *(_DWORD *)buf = 138412290;
      v39 = v26;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Unable to copy item with new UUID: %@", buf, 0xCu);
    }

    v27 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
    v28 = *(void **)(v27 + 40);
    *(_QWORD *)(v27 + 40) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);

    objc_msgSend(*(id *)(a1 + 40), "setError:", *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 40));
  }

}

uint64_t sub_1000BB84C(uint64_t a1)
{
  return sub_10000517C(*(_QWORD ***)(a1 + 40), *(_QWORD ***)(a1 + 48), *(_QWORD *)(a1 + 56), kCFBooleanFalse, *(unsigned __int8 *)(*(_QWORD *)(a1 + 64) + 154), (__CFString **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
}

uint64_t sub_1000BB878(uint64_t a1)
{
  CKKSMemoryKeyCache *v2;
  uint64_t v3;
  void *v4;
  void *v5;
  void *v6;
  id v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  CKKSMemoryKeyCache *v12;
  void *v13;
  void *v14;
  id v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD v21[4];
  id v22;
  id v23;
  CKKSMemoryKeyCache *v24;
  _BYTE *v25;
  id obj;
  uint8_t v27[4];
  uint64_t v28;
  __int16 v29;
  uint64_t v30;
  _BYTE buf[24];
  uint64_t (*v32)(uint64_t, uint64_t);
  void (*v33)(uint64_t);
  id v34;
  _QWORD v35[5];
  _QWORD v36[5];

  v2 = objc_alloc_init(CKKSMemoryKeyCache);
  v35[0] = kSecClass;
  v35[1] = kSecReturnRef;
  v3 = *(_QWORD *)(a1 + 40);
  v36[0] = *(_QWORD *)(a1 + 32);
  v36[1] = &__kCFBooleanTrue;
  v35[2] = kSecAttrSynchronizable;
  v35[3] = kSecAttrTombstone;
  v36[2] = &__kCFBooleanTrue;
  v36[3] = &__kCFBooleanFalse;
  v35[4] = kSecAttrUUID;
  v36[4] = v3;
  v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v36, v35, 5));
  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "zoneID"));
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "zoneName"));
  v7 = sub_10000BDF4(CFSTR("ckksscan"), v6);
  v8 = objc_claimAutoreleasedReturnValue(v7);

  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    v9 = *(_QWORD *)(a1 + 32);
    v10 = *(_QWORD *)(a1 + 40);
    *(_DWORD *)buf = 138412546;
    *(_QWORD *)&buf[4] = v9;
    *(_WORD *)&buf[12] = 2112;
    *(_QWORD *)&buf[14] = v10;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Onboarding %@ %@", buf, 0x16u);
  }

  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  *(_QWORD *)&buf[16] = 0x3032000000;
  v32 = sub_1000B9FC4;
  v33 = sub_1000B9FD4;
  v34 = 0;
  obj = 0;
  v21[0] = _NSConcreteStackBlock;
  v21[1] = 3221225472;
  v21[2] = sub_1000BBBC0;
  v21[3] = &unk_1002DCE78;
  v11 = *(void **)(a1 + 48);
  v22 = *(id *)(a1 + 56);
  v23 = v11;
  v12 = v2;
  v24 = v12;
  v25 = buf;
  objc_msgSend(v22, "executeQuery:readWrite:error:block:", v4, 1, &obj, v21);
  objc_storeStrong(&v34, obj);
  if (*(_QWORD *)(*(_QWORD *)&buf[8] + 40))
  {
    v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "zoneID"));
    v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "zoneName"));
    v15 = sub_10000BDF4(CFSTR("ckksscan"), v14);
    v16 = objc_claimAutoreleasedReturnValue(v15);

    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      v17 = *(_QWORD *)(a1 + 40);
      v18 = *(_QWORD *)(*(_QWORD *)&buf[8] + 40);
      *(_DWORD *)v27 = 138412546;
      v28 = v17;
      v29 = 2112;
      v30 = v18;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Need to upload %@, but can't save to database: %@", v27, 0x16u);
    }

    objc_msgSend(*(id *)(a1 + 56), "setError:", *(_QWORD *)(*(_QWORD *)&buf[8] + 40));
    v19 = 0;
  }
  else
  {
    v19 = 1;
  }

  _Block_object_dispose(buf, 8);
  return v19;
}

void sub_1000BBB9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000BBBC0(_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  id obj;

  v3 = (void *)a1[4];
  v2 = a1[5];
  v4 = a1[6];
  v5 = *(_QWORD *)(a1[7] + 8);
  obj = *(id *)(v5 + 40);
  objc_msgSend(v3, "onboardItemToCKKS:viewState:keyCache:error:", a2, v2, v4, &obj);
  objc_storeStrong((id *)(v5 + 40), obj);
}

BOOL sub_1000BBC10(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  __CFString **v5;
  _BOOL8 v6;
  _QWORD v8[4];
  id v9;

  v3 = a1[6];
  v4 = (void *)a1[4];
  v5 = (__CFString **)(*(_QWORD *)(a1[5] + 8) + 24);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_1000BBCA8;
  v8[3] = &unk_1002DCE28;
  v9 = v4;
  v6 = sub_1000043D4(v3, 0, a2, v5, (uint64_t)v8);

  return v6;
}

uint64_t sub_1000BBCA8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_1000BC364(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 120));
  _Unwind_Resume(a1);
}

void sub_1000BC520(uint64_t a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9;
  id v10;
  id v11;
  id v12;
  id WeakRetained;
  void *v14;
  const void *v15;
  NSObject *v16;
  void *v17;
  const void *v18;
  NSObject *v19;
  void *v20;
  id v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  unsigned int v27;
  const void *v28;
  NSObject *v29;
  void *v30;
  const void *v31;
  NSObject *v32;
  const void *v33;
  NSObject *v34;
  void *v35;
  void *v36;
  void *v37;
  id v38;
  _QWORD v39[4];
  id v40;
  id v41;
  uint8_t buf[4];
  id v43;

  v9 = a2;
  v10 = a3;
  v11 = a4;
  v12 = a5;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v14 = WeakRetained;
  if (!v12)
  {
    objc_msgSend(WeakRetained, "setPeerID:", v9);
    v22 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
    objc_msgSend(v22, "logSuccessForEventNamed:", CFSTR("OctagonEventJoinWithVoucher"));

    v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "deps"));
    v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v23, "ckks"));
    objc_msgSend(v24, "setCurrentSyncingPolicy:", v11);

    v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "deps"));
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v25, "stateHolder"));
    v39[0] = _NSConcreteStackBlock;
    v39[1] = 3221225472;
    v39[2] = sub_1000BC998;
    v39[3] = &unk_1002DEC60;
    v40 = v9;
    v41 = v11;
    v38 = 0;
    v27 = objc_msgSend(v26, "persistAccountChanges:error:", v39, &v38);
    v21 = v38;

    if (!v27 || v21)
    {
      v33 = sub_10000EF14("octagon");
      v34 = objc_claimAutoreleasedReturnValue(v33);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v43 = v21;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Couldn't persist results: %@", buf, 0xCu);
      }

      objc_msgSend(v14, "setError:", v21);
    }
    else
    {
      v28 = sub_10000EF14("SecError");
      v29 = objc_claimAutoreleasedReturnValue(v28);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "octagon: join successful", buf, 2u);
      }

      v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "intendedState"));
      objc_msgSend(v14, "setNextState:", v30);

    }
    v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "deps"));
    v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v35, "ckks"));
    objc_msgSend(v36, "receiveTLKUploadRecords:", v10);

    goto LABEL_22;
  }
  v15 = sub_10000EF14("SecError");
  v16 = objc_claimAutoreleasedReturnValue(v15);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    v43 = v12;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "octagon: Error joining with voucher: %@", buf, 0xCu);
  }

  v17 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v17, "logRecoverableError:forEvent:withAttributes:", v12, CFSTR("OctagonEventJoinWithVoucher"), 0);

  if (objc_msgSend(v12, "isCuttlefishError:", 1033))
  {
    v18 = sub_10000EF14("octagon-ckks");
    v19 = objc_claimAutoreleasedReturnValue(v18);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "ckksConflictState"));
      *(_DWORD *)buf = 138412290;
      v43 = v20;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "A CKKS key hierarchy is out of date; going to state '%@'",
        buf,
        0xCu);

    }
    v21 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "ckksConflictState"));
    objc_msgSend(v14, "setNextState:", v21);
LABEL_22:

    goto LABEL_23;
  }
  if (objc_msgSend(v12, "isCuttlefishError:", 1007))
  {
    v31 = sub_10000EF14("octagon");
    v32 = objc_claimAutoreleasedReturnValue(v31);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "requesting cuttlefish health check", buf, 2u);
    }

    objc_msgSend(v14, "setNextState:", CFSTR("CuttlefishTrustCheck"));
  }
  objc_msgSend(v14, "setError:", v12);
LABEL_23:
  v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "finishedOp"));
  objc_msgSend(v14, "runBeforeGroupFinished:", v37);

}

id sub_1000BC998(uint64_t a1, void *a2)
{
  id v3;
  void *v4;

  v3 = a2;
  objc_msgSend(v3, "setTrustState:", 2);
  objc_msgSend(v3, "setPeerID:", *(_QWORD *)(a1 + 32));
  objc_msgSend(v3, "setVoucher:", 0);
  objc_msgSend(v3, "setVoucherSignature:", 0);
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "tlkSharesForVouchedIdentitys"));
  objc_msgSend(v4, "removeAllObjects");

  objc_msgSend(v3, "setTPSyncingPolicy:", *(_QWORD *)(a1 + 40));
  return v3;
}

uint64_t sub_1000BD9F4(uint64_t a1)
{
  objc_msgSend(*(id *)(a1 + 32), "onqueuePerformLocalReset");
  return 1;
}

void sub_1000BEC24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000BF3E0(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  void *v7;
  unsigned int v8;
  void *v9;
  id v10;
  NSObject *v11;
  int v12;
  id v13;
  __int16 v14;
  id v15;

  v5 = a2;
  v6 = a3;
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "zoneID"));
  v8 = objc_msgSend(v7, "isEqual:", *(_QWORD *)(a1 + 32));

  if (v8)
  {
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneName"));
    v10 = sub_10000BDF4(CFSTR("ckksfetch"), v9);
    v11 = objc_claimAutoreleasedReturnValue(v10);

    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      v12 = 138412546;
      v13 = v5;
      v14 = 2112;
      v15 = v6;
      _os_log_debug_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "Sorting record modification %@: %@", (uint8_t *)&v12, 0x16u);
    }

    objc_msgSend(*(id *)(a1 + 40), "addObject:", v6);
  }

}

void sub_1000BF510(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  void *v7;
  unsigned int v8;
  void *v9;
  id v10;
  NSObject *v11;
  int v12;
  id v13;
  __int16 v14;
  id v15;

  v5 = a2;
  v6 = a3;
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "zoneID"));
  v8 = objc_msgSend(v7, "isEqual:", *(_QWORD *)(a1 + 32));

  if (v8)
  {
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneName"));
    v10 = sub_10000BDF4(CFSTR("ckksfetch"), v9);
    v11 = objc_claimAutoreleasedReturnValue(v10);

    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      v12 = 138412546;
      v13 = v5;
      v14 = 2112;
      v15 = v6;
      _os_log_debug_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "Sorting record deletion %@: %@", (uint8_t *)&v12, 0x16u);
    }

    objc_msgSend(*(id *)(a1 + 40), "addObject:", v6);
  }

}

void sub_1000BF640(uint64_t a1, void *a2)
{
  id v3;
  id WeakRetained;
  id v5;
  NSObject *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  int v12;
  void *v13;
  __int16 v14;
  id v15;

  v3 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v5 = sub_10000BDF4(CFSTR("ckksfetch"), 0);
  v6 = objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "recordType"));
    v12 = 138412546;
    v13 = v11;
    v14 = 2112;
    v15 = v3;
    _os_log_debug_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "CloudKit notification: record changed(%@): %@", (uint8_t *)&v12, 0x16u);

  }
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "modifications"));
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "recordID"));
  objc_msgSend(v7, "setObject:forKeyedSubscript:", v3, v8);

  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deletions"));
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "recordID"));
  objc_msgSend(v9, "removeObjectForKey:", v10);

  objc_msgSend(WeakRetained, "setFetchedItems:", (char *)objc_msgSend(WeakRetained, "fetchedItems") + 1);
}

void sub_1000BF7B4(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id WeakRetained;
  id v8;
  NSObject *v9;
  void *v10;
  CKKSCloudKitDeletion *v11;
  void *v12;
  int v13;
  id v14;
  __int16 v15;
  id v16;

  v5 = a2;
  v6 = a3;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v8 = sub_10000BDF4(CFSTR("ckksfetch"), 0);
  v9 = objc_claimAutoreleasedReturnValue(v8);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    v13 = 138412546;
    v14 = v6;
    v15 = 2112;
    v16 = v5;
    _os_log_debug_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "CloudKit notification: deleted record(%@): %@", (uint8_t *)&v13, 0x16u);
  }

  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "modifications"));
  objc_msgSend(v10, "removeObjectForKey:", v5);

  v11 = -[CKKSCloudKitDeletion initWithRecordID:recordType:]([CKKSCloudKitDeletion alloc], "initWithRecordID:recordType:", v5, v6);
  v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deletions"));
  objc_msgSend(v12, "setObject:forKeyedSubscript:", v11, v5);

  objc_msgSend(WeakRetained, "setFetchedItems:", (char *)objc_msgSend(WeakRetained, "fetchedItems") + 1);
}

void sub_1000BF91C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  id WeakRetained;
  id v11;
  NSObject *v12;
  void *v13;
  int v14;
  id v15;
  __int16 v16;
  id v17;
  __int16 v18;
  id v19;

  v7 = a2;
  v8 = a3;
  v9 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v11 = sub_10000BDF4(CFSTR("ckksfetch"), 0);
  v12 = objc_claimAutoreleasedReturnValue(v11);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    v14 = 138412802;
    v15 = v7;
    v16 = 2112;
    v17 = v8;
    v18 = 2112;
    v19 = v9;
    _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "Received a new server change token (via block) for %@: %@ %@", (uint8_t *)&v14, 0x20u);
  }

  v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "changeTokens"));
  objc_msgSend(v13, "setObject:forKeyedSubscript:", v8, v7);

}

void sub_1000BFA4C(uint64_t a1, void *a2, void *a3, void *a4, uint64_t a5, void *a6)
{
  id v11;
  id v12;
  id v13;
  id v14;
  id WeakRetained;
  id v16;
  NSObject *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  NSObject *v25;
  void *v26;
  void *v27;
  void *v28;
  id v29;
  NSObject *v30;
  int v31;
  id v32;
  __int16 v33;
  id v34;
  __int16 v35;
  _QWORD v36[2];
  const __CFString *v37;
  void *v38;

  v11 = a2;
  v12 = a3;
  v13 = a4;
  v14 = a6;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v16 = sub_10000BDF4(CFSTR("ckksfetch"), 0);
  v17 = objc_claimAutoreleasedReturnValue(v16);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
  {
    v31 = 138412802;
    v32 = v11;
    v33 = 2112;
    v34 = v12;
    v35 = 2112;
    v36[0] = v13;
    _os_log_debug_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "Received a new server change token for %@: %@ %@", (uint8_t *)&v31, 0x20u);
  }

  v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "changeTokens"));
  objc_msgSend(v18, "setObject:forKeyedSubscript:", v12, v11);

  v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "allClientOptions"));
  v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "objectForKeyedSubscript:", v11));
  objc_msgSend(v20, "setPreviousServerChangeToken:", v12);

  objc_msgSend(WeakRetained, "setMoreComing:", objc_msgSend(WeakRetained, "moreComing") | a5);
  v21 = *(void **)(a1 + 32);
  v37 = CFSTR("fullFetch");
  v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", objc_msgSend(WeakRetained, "moreComing")));
  v38 = v22;
  v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v38, &v37, 1));
  objc_msgSend(v21, "addMetrics:", v23);

  if ((_DWORD)a5)
  {
    v24 = sub_10000BDF4(CFSTR("ckksfetch"), 0);
    v25 = objc_claimAutoreleasedReturnValue(v24);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "changeTokens"));
      v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "objectForKeyedSubscript:", v11));
      v31 = 138412546;
      v32 = v11;
      v33 = 2112;
      v34 = v27;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "more changes pending for %@, will start a new fetch at change token %@", (uint8_t *)&v31, 0x16u);

    }
  }
  v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "zoneName"));
  v29 = sub_10000BDF4(CFSTR("ckksfetch"), v28);
  v30 = objc_claimAutoreleasedReturnValue(v29);

  if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
  {
    v31 = 138413058;
    v32 = v12;
    v33 = 2112;
    v34 = v13;
    v35 = 1024;
    LODWORD(v36[0]) = a5;
    WORD2(v36[0]) = 2112;
    *(_QWORD *)((char *)v36 + 6) = v14;
    _os_log_debug_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEBUG, "Record zone fetch complete: changeToken=%@ clientChangeTokenData=%@ moreComing=%{BOOL}d error=%@", (uint8_t *)&v31, 0x26u);
  }

  objc_msgSend(WeakRetained, "sendChangesToClient:moreComing:", v11, a5);
}

void sub_1000BFD8C(uint64_t a1, void *a2)
{
  id v3;
  id WeakRetained;
  NSObject *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  id v10;
  NSObject *v11;
  id v12;
  _UNKNOWN **v13;
  id v14;
  NSObject *v15;
  void *v16;
  id v17;
  id v18;
  uint64_t v19;
  void *i;
  void *v21;
  void *v22;
  void *v23;
  char *v24;
  void *v25;
  void *v26;
  void *v27;
  id v28;
  id v29;
  uint64_t v30;
  void *j;
  void *v32;
  void *v33;
  void *v34;
  char *v35;
  void *v36;
  void *v37;
  id v38;
  id v39;
  uint64_t v40;
  void *v41;
  void *v42;
  id v43;
  NSObject *v44;
  id v45;
  void *v46;
  void *v47;
  void *v48;
  void *v49;
  void *v50;
  void *v51;
  void *v52;
  NSObject *v53;
  id v54;
  id v55;
  uint64_t v56;
  void *k;
  void *v58;
  void *v59;
  void *v60;
  SecEventMetric *v61;
  void *v62;
  void *v63;
  void *v64;
  void *v65;
  NSObject *v66;
  id v67;
  id v68;
  uint64_t v69;
  void *m;
  void *v71;
  void *v72;
  void *v73;
  void *v74;
  void *v75;
  SecEventMetric *v76;
  id v77;
  id v78;
  id v79;
  void *v80;
  void *v81;
  void *v82;
  void *v83;
  void *v84;
  void *v85;
  void *v86;
  void *v87;
  uint64_t v88;
  void *v89;
  uint64_t v90;
  uint64_t v91;
  _UNKNOWN **v92;
  id v93;
  id obj;
  NSObject *v95;
  id v96;
  _QWORD v97[4];
  id v98;
  id v99;
  id v100;
  SecEventMetric *v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  _QWORD v122[2];
  _QWORD v123[2];
  _BYTE v124[128];
  _BYTE v125[128];
  _BYTE v126[128];
  _BYTE v127[128];
  uint8_t v128[128];
  uint8_t buf[4];
  id v130;

  v3 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    v5 = objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "modifications"));
    objc_msgSend(WeakRetained, "setTotalModifications:", (char *)objc_msgSend(v6, "count") + (_QWORD)objc_msgSend(WeakRetained, "totalModifications"));

    v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deletions"));
    objc_msgSend(WeakRetained, "setTotalDeletions:", (char *)objc_msgSend(v7, "count") + (_QWORD)objc_msgSend(WeakRetained, "totalDeletions"));

    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "modifications"));
    objc_msgSend(v8, "removeAllObjects");

    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deletions"));
    objc_msgSend(v9, "removeAllObjects");

    if (objc_msgSend(WeakRetained, "moreComing"))
    {
      if (!v3
        || +[CKKSReachabilityTracker isNetworkFailureError:](CKKSReachabilityTracker, "isNetworkFailureError:", v3))
      {
        v10 = sub_10000BDF4(CFSTR("ckksfetch"), 0);
        v11 = objc_claimAutoreleasedReturnValue(v10);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          v130 = v3;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Must issue another fetch (with potential error %@)", buf, 0xCu);
        }

        objc_msgSend(WeakRetained, "setMoreComing:", 0);
        +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", *(_QWORD *)(a1 + 32), 0, v3);
        objc_msgSend(WeakRetained, "performFetch");
        goto LABEL_61;
      }
    }
    else if (!v3)
    {
      v13 = &off_10030A6B8;
      goto LABEL_13;
    }
    objc_msgSend(WeakRetained, "setError:", v3);
    v13 = &off_10030A6A0;
LABEL_13:
    v92 = v13;
    v14 = sub_10000BDF4(CFSTR("ckksfetcher"), 0);
    v15 = objc_claimAutoreleasedReturnValue(v14);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v130 = v3;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Record zone changes fetch complete: error=%@", buf, 0xCu);
    }
    v90 = a1;

    +[CKKSPowerCollection CKKSPowerEvent:count:](CKKSPowerCollection, "CKKSPowerEvent:count:", CFSTR("fetchAllChanges"), objc_msgSend(WeakRetained, "fetchedItems"));
    v120 = 0u;
    v121 = 0u;
    v118 = 0u;
    v119 = 0u;
    v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "modifications"));
    v17 = objc_msgSend(v16, "countByEnumeratingWithState:objects:count:", &v118, v128, 16);
    if (v17)
    {
      v18 = v17;
      v19 = *(_QWORD *)v119;
      do
      {
        for (i = 0; i != v18; i = (char *)i + 1)
        {
          if (*(_QWORD *)v119 != v19)
            objc_enumerationMutation(v16);
          v21 = *(void **)(*((_QWORD *)&v118 + 1) + 8 * (_QWORD)i);
          v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "zoneID"));
          v23 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", v22));

          if (v23)
            v24 = (char *)objc_msgSend(v23, "unsignedLongValue");
          else
            v24 = 0;
          v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v24 + 1));
          v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "zoneID"));
          -[NSObject setObject:forKeyedSubscript:](v5, "setObject:forKeyedSubscript:", v25, v26);

        }
        v18 = objc_msgSend(v16, "countByEnumeratingWithState:objects:count:", &v118, v128, 16);
      }
      while (v18);
    }

    v116 = 0u;
    v117 = 0u;
    v114 = 0u;
    v115 = 0u;
    v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deletions"));
    v28 = objc_msgSend(v27, "countByEnumeratingWithState:objects:count:", &v114, v127, 16);
    if (v28)
    {
      v29 = v28;
      v30 = *(_QWORD *)v115;
      do
      {
        for (j = 0; j != v29; j = (char *)j + 1)
        {
          if (*(_QWORD *)v115 != v30)
            objc_enumerationMutation(v27);
          v32 = *(void **)(*((_QWORD *)&v114 + 1) + 8 * (_QWORD)j);
          v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v32, "zoneID"));
          v34 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", v33));

          if (v34)
            v35 = (char *)objc_msgSend(v34, "unsignedLongValue");
          else
            v35 = 0;
          v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v35 + 1));
          v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v32, "zoneID"));
          -[NSObject setObject:forKeyedSubscript:](v5, "setObject:forKeyedSubscript:", v36, v37);

        }
        v29 = objc_msgSend(v27, "countByEnumeratingWithState:objects:count:", &v114, v127, 16);
      }
      while (v29);
    }

    v112 = 0u;
    v113 = 0u;
    v110 = 0u;
    v111 = 0u;
    obj = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "apnsPushes"));
    v38 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v110, v126, 16);
    if (v38)
    {
      v39 = v38;
      v40 = *(_QWORD *)v111;
      v95 = v5;
      v96 = v3;
      v91 = *(_QWORD *)v111;
      do
      {
        v41 = 0;
        v93 = v39;
        do
        {
          if (*(_QWORD *)v111 != v40)
            objc_enumerationMutation(obj);
          v42 = *(void **)(*((_QWORD *)&v110 + 1) + 8 * (_QWORD)v41);
          if (objc_msgSend(v42, "ckksPushTracingEnabled"))
          {
            v43 = sub_10000BDF4(CFSTR("ckksfetch"), 0);
            v44 = objc_claimAutoreleasedReturnValue(v43);
            if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 138412290;
              v130 = v42;
              _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "Submitting post-fetch CKEventMetric due to notification %@", buf, 0xCu);
            }

            v45 = objc_msgSend(objc_alloc((Class)CKEventMetric), "initWithEventName:", CFSTR("APNSPushMetrics"));
            objc_msgSend(v45, "setIsPushTriggerFired:", 1);
            v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v42, "ckksPushTracingUUID"));
            objc_msgSend(v45, "setObject:forKeyedSubscript:", v46, CFSTR("push_token_uuid"));

            v47 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v42, "ckksPushReceivedDate"));
            objc_msgSend(v45, "setObject:forKeyedSubscript:", v47, CFSTR("push_received_date"));

            objc_msgSend(v45, "setObject:forKeyedSubscript:", CFSTR("CKKS Push"), CFSTR("push_event_name"));
            objc_msgSend(v45, "setObject:forKeyedSubscript:", v92, CFSTR("fetch_error"));
            v48 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "domain"));
            objc_msgSend(v45, "setObject:forKeyedSubscript:", v48, CFSTR("fetch_error_domain"));

            v49 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithLong:](NSNumber, "numberWithLong:", objc_msgSend(v3, "code")));
            objc_msgSend(v45, "setObject:forKeyedSubscript:", v49, CFSTR("fetch_error_code"));

            v50 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", objc_msgSend(WeakRetained, "totalModifications")));
            objc_msgSend(v45, "setObject:forKeyedSubscript:", v50, CFSTR("total_modifications"));

            v51 = WeakRetained;
            v52 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", objc_msgSend(WeakRetained, "totalDeletions")));
            objc_msgSend(v45, "setObject:forKeyedSubscript:", v52, CFSTR("total_deletions"));

            v108 = 0u;
            v109 = 0u;
            v106 = 0u;
            v107 = 0u;
            v53 = v95;
            v54 = -[NSObject countByEnumeratingWithState:objects:count:](v53, "countByEnumeratingWithState:objects:count:", &v106, v125, 16);
            if (v54)
            {
              v55 = v54;
              v56 = *(_QWORD *)v107;
              do
              {
                for (k = 0; k != v55; k = (char *)k + 1)
                {
                  if (*(_QWORD *)v107 != v56)
                    objc_enumerationMutation(v53);
                  v58 = *(void **)(*((_QWORD *)&v106 + 1) + 8 * (_QWORD)k);
                  v59 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject objectForKeyedSubscript:](v53, "objectForKeyedSubscript:", v58));
                  v60 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v58, "zoneName"));
                  objc_msgSend(v45, "setObject:forKeyedSubscript:", v59, v60);

                }
                v55 = -[NSObject countByEnumeratingWithState:objects:count:](v53, "countByEnumeratingWithState:objects:count:", &v106, v125, 16);
              }
              while (v55);
            }

            v61 = -[SecEventMetric initWithEventName:]([SecEventMetric alloc], "initWithEventName:", CFSTR("APNSPushMetrics"));
            v62 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v42, "ckksPushTracingUUID"));
            -[SecEventMetric setObject:forKeyedSubscript:](v61, "setObject:forKeyedSubscript:", v62, CFSTR("push_token_uuid"));

            v63 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v42, "ckksPushReceivedDate"));
            -[SecEventMetric setObject:forKeyedSubscript:](v61, "setObject:forKeyedSubscript:", v63, CFSTR("push_received_date"));

            -[SecEventMetric setObject:forKeyedSubscript:](v61, "setObject:forKeyedSubscript:", CFSTR("CKKS Push-webtunnel"), CFSTR("push_event_name"));
            -[SecEventMetric setObject:forKeyedSubscript:](v61, "setObject:forKeyedSubscript:", v96, CFSTR("fetch_error"));
            v64 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", objc_msgSend(v51, "totalModifications")));
            -[SecEventMetric setObject:forKeyedSubscript:](v61, "setObject:forKeyedSubscript:", v64, CFSTR("total_modifications"));

            v65 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", objc_msgSend(v51, "totalDeletions")));
            -[SecEventMetric setObject:forKeyedSubscript:](v61, "setObject:forKeyedSubscript:", v65, CFSTR("total_deletions"));

            v104 = 0u;
            v105 = 0u;
            v102 = 0u;
            v103 = 0u;
            v66 = v53;
            v67 = -[NSObject countByEnumeratingWithState:objects:count:](v66, "countByEnumeratingWithState:objects:count:", &v102, v124, 16);
            if (v67)
            {
              v68 = v67;
              v69 = *(_QWORD *)v103;
              do
              {
                for (m = 0; m != v68; m = (char *)m + 1)
                {
                  if (*(_QWORD *)v103 != v69)
                    objc_enumerationMutation(v66);
                  v71 = *(void **)(*((_QWORD *)&v102 + 1) + 8 * (_QWORD)m);
                  v72 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject objectForKeyedSubscript:](v66, "objectForKeyedSubscript:", v71));
                  v73 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v71, "zoneName"));
                  -[SecEventMetric setObject:forKeyedSubscript:](v61, "setObject:forKeyedSubscript:", v72, v73);

                }
                v68 = -[NSObject countByEnumeratingWithState:objects:count:](v66, "countByEnumeratingWithState:objects:count:", &v102, v124, 16);
              }
              while (v68);
            }

            WeakRetained = v51;
            v74 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v51, "container"));
            v75 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v51, "fetchRecordZoneChangesOperation"));
            v97[0] = _NSConcreteStackBlock;
            v97[1] = 3221225472;
            v97[2] = sub_1000C09E4;
            v97[3] = &unk_1002E97E0;
            v98 = v45;
            v99 = v75;
            v100 = v74;
            v101 = v61;
            v76 = v61;
            v77 = v74;
            v78 = v75;
            v79 = v45;
            v80 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSResultOperation named:withBlock:](CKKSResultOperation, "named:withBlock:", CFSTR("submit-metric"), v97));
            v81 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v51, "fetchCompletedOperation"));
            objc_msgSend(v80, "addSuccessDependency:", v81);

            v82 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v51, "operationQueue"));
            objc_msgSend(v82, "addOperation:", v80);

            v5 = v95;
            v3 = v96;
            v39 = v93;
            v40 = v91;
          }
          v41 = (char *)v41 + 1;
        }
        while (v41 != v39);
        v39 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v110, v126, 16);
      }
      while (v39);
    }

    v83 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "fetchCompletedOperation"));
    objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v83);

    objc_msgSend(WeakRetained, "setClientMap:", &__NSDictionary0__struct);
    v84 = *(void **)(v90 + 32);
    v122[0] = CFSTR("numKeychainItems");
    v85 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", objc_msgSend(WeakRetained, "fetchedItems")));
    v122[1] = CFSTR("totalCKRecords");
    v123[0] = v85;
    v86 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", (char *)objc_msgSend(WeakRetained, "totalDeletions")+ (_QWORD)objc_msgSend(WeakRetained, "totalModifications")));
    v123[1] = v86;
    v87 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v123, v122, 2));
    objc_msgSend(v84, "addMetrics:", v87);

    v88 = *(_QWORD *)(v90 + 32);
    v89 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", v88, 1, v89);

    goto LABEL_61;
  }
  v12 = sub_10000BDF4(CFSTR("ckksfetch"), 0);
  v5 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "received callback for released object", buf, 2u);
  }
LABEL_61:

}

void sub_1000C09E4(uint64_t a1)
{
  id v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  id v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  uint64_t v13;

  if ((objc_msgSend(*(id *)(a1 + 32), "associateWithCompletedOperation:", *(_QWORD *)(a1 + 40)) & 1) == 0)
  {
    v2 = sub_10000BDF4(CFSTR("ckksfetch"), 0);
    v3 = objc_claimAutoreleasedReturnValue(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4 = *(_QWORD *)(a1 + 32);
      v5 = *(_QWORD *)(a1 + 40);
      v10 = 138412546;
      v11 = v4;
      v12 = 2112;
      v13 = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Couldn't associate metric with operation: %@ %@", (uint8_t *)&v10, 0x16u);
    }

  }
  objc_msgSend(*(id *)(a1 + 48), "submitEventMetric:", *(_QWORD *)(a1 + 32));
  v6 = (void *)objc_claimAutoreleasedReturnValue(+[SecMetrics managerObject](SecMetrics, "managerObject"));
  objc_msgSend(v6, "submitEvent:", *(_QWORD *)(a1 + 56));

  v7 = sub_10000BDF4(CFSTR("ckksfetch"), 0);
  v8 = objc_claimAutoreleasedReturnValue(v7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    v9 = *(_QWORD *)(a1 + 32);
    v10 = 138412290;
    v11 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Metric submitted: %@", (uint8_t *)&v10, 0xCu);
  }

}

id sub_1000C2344(uint64_t a1)
{
  id result;

  result = objc_msgSend(*(id *)(a1 + 32), "completed");
  if ((result & 1) == 0)
    return objc_msgSend(*(id *)(a1 + 32), "onqueueStartFinishOperation:", *(_QWORD *)(a1 + 40));
  return result;
}

void sub_1000C4EA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
  _Block_object_dispose(&a45, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000C4F74(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_1000C4F84(uint64_t a1)
{

}

void sub_1000C4F8C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  uint64_t v10;
  NSObject *v11;
  id v12;
  void *v13;
  NSObject *v14;
  NSObject *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  unint64_t v21;
  uint64_t v22;
  int v23;
  id v24;
  __int16 v25;
  id v26;
  __int16 v27;
  id v28;

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
  v11 = objc_claimAutoreleasedReturnValue(v10);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
  {
    v23 = 138478339;
    v24 = v7;
    v25 = 2113;
    v26 = v8;
    v27 = 2114;
    v28 = v9;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "fetch result for lookupInfo %{private}@: participant %{private}@ error %{public}@", (uint8_t *)&v23, 0x20u);
  }

  v12 = sub_10004D178(v7);
  v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
  if (v13)
  {
    v14 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:", v13));
    v15 = v14;
    if (v8 && v14)
    {
      v16 = (unint64_t)-[NSObject permissionLevel](v14, "permissionLevel");
      if (v16 > 2)
        v17 = 0;
      else
        v17 = qword_100249520[v16];
      v21 = (unint64_t)-[NSObject permissionLevel](v15, "permissionLevel");
      if (v21 > 2)
        v22 = 0;
      else
        v22 = qword_100249538[v21];
      objc_msgSend(v8, "setRole:", v17);
      objc_msgSend(v8, "setPermission:", v22);
      objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), "setObject:forKeyedSubscript:", v8, v13);
    }
    else
    {
      v19 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
      v20 = objc_claimAutoreleasedReturnValue(v19);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        v23 = 138478083;
        v24 = v7;
        v25 = 2113;
        v26 = v13;
        _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "could not find CKShareParticipant or KCSharingParticipant for lookupinfo %{private}@ handle %{private}@", (uint8_t *)&v23, 0x16u);
      }

    }
  }
  else
  {
    v18 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
    v15 = objc_claimAutoreleasedReturnValue(v18);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      v23 = 138477827;
      v24 = v7;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Could not find handle for lookupinfo %{private}@", (uint8_t *)&v23, 0xCu);
    }
  }

}

void sub_1000C5204(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  NSObject *v5;
  void (*v6)(void);
  int v7;
  id v8;

  v3 = a2;
  if (v3)
  {
    v4 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v7 = 138543362;
      v8 = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to fetch share participants: %{public}@", (uint8_t *)&v7, 0xCu);
    }

    v6 = *(void (**)(void))(*(_QWORD *)(a1 + 32) + 16);
  }
  else
  {
    v6 = *(void (**)(void))(*(_QWORD *)(a1 + 32) + 16);
  }
  v6();

}

void sub_1000C52F4(uint64_t a1, void *a2, uint64_t a3)
{
  id v5;
  void *v6;
  uint64_t v7;
  _UNKNOWN **v8;
  void *i;
  uint64_t v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  _UNKNOWN **v15;
  uint64_t v16;
  void *v17;
  _BOOL8 v18;
  void *v19;
  uint64_t v20;
  NSObject *v21;
  uint64_t v22;
  id v23;
  void *v24;
  id obj;
  id v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint8_t buf[4];
  void *v32;
  _BYTE v33[128];

  v5 = a2;
  if (a3)
  {
    (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
  }
  else
  {
    v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionaryWithCapacity:](NSMutableDictionary, "dictionaryWithCapacity:", objc_msgSend(*(id *)(a1 + 32), "count")));
    v27 = 0u;
    v28 = 0u;
    v29 = 0u;
    v30 = 0u;
    v22 = a1;
    obj = *(id *)(a1 + 32);
    v26 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v27, v33, 16);
    if (v26)
    {
      v7 = *(_QWORD *)v28;
      v8 = &AAAccountClassPrimary_ptr;
      v23 = v5;
      v24 = v6;
      do
      {
        for (i = 0; i != v26; i = (char *)i + 1)
        {
          if (*(_QWORD *)v28 != v7)
            objc_enumerationMutation(obj);
          v10 = *(_QWORD *)(*((_QWORD *)&v27 + 1) + 8 * (_QWORD)i);
          v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", v10));
          v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "userIdentity"));
          if (objc_msgSend(v12, "hasiCloudAccount"))
          {
            v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", v10));
            v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "userIdentity"));
            v15 = v8;
            v16 = v7;
            v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "publicSharingKey"));
            v18 = objc_msgSend(v17, "length") != 0;

            v7 = v16;
            v8 = v15;

            v5 = v23;
            v6 = v24;
          }
          else
          {
            v18 = 0;
          }

          v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8[312], "numberWithBool:", v18));
          objc_msgSend(v6, "setObject:forKeyedSubscript:", v19, v10);

        }
        v26 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v27, v33, 16);
      }
      while (v26);
    }

    v20 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
    v21 = objc_claimAutoreleasedReturnValue(v20);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138477827;
      v32 = v6;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "availability results: %{private}@", buf, 0xCu);
    }

    (*(void (**)(void))(*(_QWORD *)(v22 + 40) + 16))();
  }

}

void sub_1000C557C(id *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  uint64_t v7;
  NSObject *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  _BOOL4 v15;
  void *v16;
  id v17;
  void *v18;
  void *v19;
  void *v20;
  id v21;
  id v22;
  id v23;
  void *v24;
  void *v25;
  uint64_t v26;
  NSObject *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  _QWORD v32[4];
  id v33;
  id v34;
  id v35;
  _BYTE *v36;
  _QWORD v37[5];
  _BYTE buf[24];
  uint64_t (*v39)(uint64_t, uint64_t);
  void (*v40)(uint64_t);
  id v41;

  v5 = a2;
  v6 = a3;
  if (v6)
  {
    v7 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "groupID"));
      *(_DWORD *)buf = 138412546;
      *(_QWORD *)&buf[4] = v30;
      *(_WORD *)&buf[12] = 2114;
      *(_QWORD *)&buf[14] = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to fetch share metadata for group invite %@: %{public}@", buf, 0x16u);

    }
    if (CKErrorIsCode(v6, 2))
    {
      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "userInfo"));
      v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "objectForKeyedSubscript:", CKPartialErrorsByItemIDKey));
      v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "shareURL"));
      v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "objectForKeyedSubscript:", v11));

      LODWORD(v10) = CKErrorIsCode(v12, 11);
      v13 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
      v14 = objc_claimAutoreleasedReturnValue(v13);
      v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
      if ((_DWORD)v10)
      {
        if (v15)
        {
          v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "groupID"));
          *(_DWORD *)buf = 138543362;
          *(_QWORD *)&buf[4] = v16;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Unknown item error for invite %{public}@, will consider decline a success", buf, 0xCu);

        }
        v17 = objc_alloc((Class)KCSharingGroup);
        v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "groupID"));
        v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "displayName"));
        v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "shareURL"));
        v21 = objc_msgSend(v17, "initWithGroupID:participants:displayName:shareURL:", v18, &__NSArray0__struct, v19, v20);

        (*((void (**)(void))a1[6] + 2))();
      }
      else
      {
        if (v15)
        {
          v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "groupID"));
          *(_DWORD *)buf = 138543618;
          *(_QWORD *)&buf[4] = v29;
          *(_WORD *)&buf[12] = 2114;
          *(_QWORD *)&buf[14] = v12;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Underlying failure for metadata fetch to decline %{public}@: %{public}@", buf, 0x16u);

        }
        (*((void (**)(void))a1[6] + 2))();
      }

    }
    else
    {
      (*((void (**)(void))a1[6] + 2))();
    }
  }
  else if (objc_msgSend(v5, "count") == (id)1)
  {
    v22 = objc_alloc_init((Class)CKDeclineSharesOperation);
    objc_msgSend(v22, "setShareMetadatas:", v5);
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3032000000;
    v39 = sub_1000C4F74;
    v40 = sub_1000C4F84;
    v41 = 0;
    v37[0] = _NSConcreteStackBlock;
    v37[1] = 3221225472;
    v37[2] = sub_1000C5A90;
    v37[3] = &unk_1002DD290;
    v37[4] = buf;
    objc_msgSend(v22, "setPerShareCompletionBlock:", v37);
    v32[0] = _NSConcreteStackBlock;
    v32[1] = 3221225472;
    v32[2] = sub_1000C5AA4;
    v32[3] = &unk_1002DD2B8;
    v36 = buf;
    v33 = a1[4];
    v23 = a1[6];
    v34 = a1[5];
    v35 = v23;
    objc_msgSend(v22, "setDeclineSharesCompletionBlock:", v32);
    v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[5], "syncController"));
    v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v24, "container"));
    objc_msgSend(v25, "addOperation:", v22);

    _Block_object_dispose(buf, 8);
  }
  else
  {
    v26 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
    v27 = objc_claimAutoreleasedReturnValue(v26);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "groupID"));
      *(_DWORD *)buf = 138543362;
      *(_QWORD *)&buf[4] = v31;
      _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Expected share metadata not found for group invite %{public}@", buf, 0xCu);

    }
    v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("KCSharingErrorDomain"), 9, 0));
    (*((void (**)(void))a1[6] + 2))();

  }
}

void sub_1000C5A70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000C5A90(uint64_t a1, int a2, id obj)
{
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), obj);
}

void sub_1000C5AA4(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  id v6;
  uint64_t v7;
  NSObject *v8;
  void *v9;
  void *v10;
  id v11;
  void *v12;
  _QWORD v13[4];
  id v14;
  uint64_t v15;
  id v16;
  uint8_t buf[4];
  void *v18;
  __int16 v19;
  id v20;

  v3 = a2;
  v4 = v3;
  v5 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 40);
  if (!v5)
    v5 = v3;
  v6 = v5;
  if (v6)
  {
    v7 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "groupID"));
      *(_DWORD *)buf = 138543618;
      v18 = v12;
      v19 = 2114;
      v20 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to decline shares for group invite %{public}@: %{public}@", buf, 0x16u);

    }
    (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
  }
  else
  {
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "messagingdConnection"));
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "groupID"));
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 3221225472;
    v13[2] = sub_1000C5C58;
    v13[3] = &unk_1002DD150;
    v14 = *(id *)(a1 + 32);
    v11 = *(id *)(a1 + 48);
    v15 = *(_QWORD *)(a1 + 40);
    v16 = v11;
    objc_msgSend(v9, "didDeclineInviteForGroupID:completion:", v10, v13);

  }
}

void sub_1000C5C58(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  NSObject *v5;
  id v6;
  void *v7;
  void *v8;
  void *v9;
  id v10;
  void *v11;
  int v12;
  void *v13;
  __int16 v14;
  id v15;

  v3 = a2;
  if (v3)
  {
    v4 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "groupID"));
      v12 = 138543618;
      v13 = v11;
      v14 = 2114;
      v15 = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to decline IDSInvite for %{public}@: %{public}@", (uint8_t *)&v12, 0x16u);

    }
    (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
  }
  else
  {
    v6 = objc_alloc((Class)KCSharingGroup);
    v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "groupID"));
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "displayName"));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "shareURL"));
    v10 = objc_msgSend(v6, "initWithGroupID:participants:displayName:shareURL:", v7, &__NSArray0__struct, v8, v9);

    (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
  }
  objc_msgSend(*(id *)(a1 + 40), "sendGroupsUpdatedNotifications");

}

void sub_1000C5DE8(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  id v11;
  uint64_t v12;
  id v13;
  id v14;
  void *v15;
  int v16;
  id v17;

  v5 = a2;
  v6 = a3;
  if (v6)
  {
    v7 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v16 = 138543362;
      v17 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to receive invite from keychainsharingmessagesd: %{public}@", (uint8_t *)&v16, 0xCu);
    }

    (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
  }
  else if (v5)
  {
    objc_msgSend(*(id *)(a1 + 40), "declineGroupInvite:completion:", v5, *(_QWORD *)(a1 + 48));
  }
  else
  {
    v9 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
    v10 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v15 = *(void **)(a1 + 32);
      v16 = 138543362;
      v17 = v15;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "No error and no invite from ksmd for accepting for %{public}@. We raced the sender cancelling the invite?", (uint8_t *)&v16, 0xCu);
    }

    v11 = objc_alloc((Class)KCSharingGroup);
    v12 = *(_QWORD *)(a1 + 32);
    v13 = objc_alloc_init((Class)NSURL);
    v14 = objc_msgSend(v11, "initWithGroupID:participants:displayName:shareURL:", v12, &__NSArray0__struct, CFSTR("unknown"), v13);

    (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
  }

}

void sub_1000C5FB4(id *a1, void *a2, void *a3)
{
  id v5;
  uint64_t (*v6)(uint64_t, uint64_t);
  uint64_t v7;
  NSObject *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  id v13;
  id v14;
  id v15;
  void *v16;
  void *v17;
  uint64_t v18;
  NSObject *v19;
  void *v20;
  id v21;
  void *v22;
  void *v23;
  _QWORD v24[4];
  id v25;
  id v26;
  id v27;
  id v28;
  id v29;
  _BYTE *v30;
  _QWORD v31[5];
  _BYTE buf[24];
  uint64_t (*v33)(uint64_t, uint64_t);
  void (*v34)(uint64_t);
  id v35;

  v5 = a2;
  v6 = a3;
  if (v6)
  {
    v7 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v21 = a1[4];
      v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "groupID"));
      *(_DWORD *)buf = 138478339;
      *(_QWORD *)&buf[4] = v21;
      *(_WORD *)&buf[12] = 2114;
      *(_QWORD *)&buf[14] = v22;
      *(_WORD *)&buf[22] = 2114;
      v33 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to fetch share metadata for group invite %{private}@ for group %{public}@: %{public}@", buf, 0x20u);

    }
    if (CKErrorIsCode(v6, 2))
    {
      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "userInfo"));
      v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "objectForKeyedSubscript:", CKPartialErrorsByItemIDKey));
      v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "shareURL"));
      v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "objectForKeyedSubscript:", v11));

      (*((void (**)(void))a1[6] + 2))();
    }
    else
    {
      (*((void (**)(void))a1[6] + 2))();
    }
  }
  else if (objc_msgSend(v5, "count") == (id)1)
  {
    v13 = objc_alloc_init((Class)CKAcceptSharesOperation);
    objc_msgSend(v13, "setShareMetadatas:", v5);
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3032000000;
    v33 = sub_1000C4F74;
    v34 = sub_1000C4F84;
    v35 = 0;
    v31[0] = _NSConcreteStackBlock;
    v31[1] = 3221225472;
    v31[2] = sub_1000C6380;
    v31[3] = &unk_1002DD1F0;
    v31[4] = buf;
    objc_msgSend(v13, "setPerShareCompletionBlock:", v31);
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 3221225472;
    v24[2] = sub_1000C6394;
    v24[3] = &unk_1002DD240;
    v30 = buf;
    v25 = a1[4];
    v14 = a1[6];
    v15 = a1[5];
    v29 = v14;
    v26 = v15;
    v27 = v5;
    v28 = 0;
    objc_msgSend(v13, "setAcceptSharesCompletionBlock:", v24);
    v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[5], "syncController"));
    v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "container"));
    objc_msgSend(v17, "addOperation:", v13);

    _Block_object_dispose(buf, 8);
  }
  else
  {
    v18 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
    v19 = objc_claimAutoreleasedReturnValue(v18);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "groupID"));
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)&buf[4] = v23;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Expected share metadata not found for invite for %@", buf, 0xCu);

    }
    v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("KCSharingErrorDomain"), 9, 0));
    (*((void (**)(void))a1[6] + 2))();

  }
}

void sub_1000C6360(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_list va;

  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000C6380(uint64_t a1, int a2, int a3, id obj)
{
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), obj);
}

void sub_1000C6394(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  id v6;
  uint64_t v7;
  NSObject *v8;
  void *v9;
  void *v10;
  id v11;
  uint64_t v12;
  void *v13;
  void *v14;
  _QWORD v15[4];
  id v16;
  uint64_t v17;
  id v18;
  id v19;
  id v20;
  uint8_t buf[4];
  void *v22;
  __int16 v23;
  id v24;

  v3 = a2;
  v4 = v3;
  v5 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 40);
  if (!v5)
    v5 = v3;
  v6 = v5;
  if (v6)
  {
    v7 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "groupID"));
      *(_DWORD *)buf = 138543618;
      v22 = v14;
      v23 = 2114;
      v24 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to accept shares for invite for group %{public}@: %{public}@", buf, 0x16u);

    }
    (*(void (**)(void))(*(_QWORD *)(a1 + 64) + 16))();
  }
  else
  {
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "messagingdConnection"));
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "groupID"));
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 3221225472;
    v15[2] = sub_1000C656C;
    v15[3] = &unk_1002DD218;
    v11 = *(id *)(a1 + 32);
    v12 = *(_QWORD *)(a1 + 40);
    v13 = *(void **)(a1 + 48);
    v16 = v11;
    v17 = v12;
    v18 = v13;
    v19 = *(id *)(a1 + 56);
    v20 = *(id *)(a1 + 64);
    objc_msgSend(v9, "didAcceptInviteForGroupID:completion:", v10, v15);

  }
}

void sub_1000C656C(id *a1, void *a2)
{
  id v3;
  uint64_t v4;
  NSObject *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  id v12;
  id v13;
  void *v14;
  _QWORD v15[4];
  id v16;
  id v17;
  id v18;
  id v19;
  void *v20;
  uint8_t buf[4];
  void *v22;
  __int16 v23;
  id v24;

  v3 = a2;
  if (v3)
  {
    v4 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "groupID"));
      *(_DWORD *)buf = 138543618;
      v22 = v14;
      v23 = 2114;
      v24 = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to accept IDSInvite for %{public}@: %{public}@", buf, 0x16u);

    }
  }
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[5], "syncController"));
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[6], "firstObject"));
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "share"));
  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "recordID"));
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "zoneID"));
  v20 = v10;
  v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v20, 1));
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  v15[2] = sub_1000C6758;
  v15[3] = &unk_1002DD1A0;
  v16 = a1[4];
  v12 = a1[7];
  v13 = a1[5];
  v17 = v12;
  v18 = v13;
  v19 = a1[8];
  objc_msgSend(v6, "fetchRemoteChangesForZoneIDs:completion:", v11, v15);

}

void sub_1000C6758(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  NSObject *v5;
  void *v6;
  void *v7;
  void *v8;
  id v9;
  void *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  int v14;
  void *v15;
  __int16 v16;
  uint64_t v17;

  v3 = a2;
  if (v3)
  {
    v4 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "groupID"));
      v13 = *(_QWORD *)(a1 + 40);
      v14 = 138543618;
      v15 = v12;
      v16 = 2114;
      v17 = v13;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to accept group invite for %{public}@: %{public}@", (uint8_t *)&v14, 0x16u);

    }
  }
  v6 = *(void **)(a1 + 48);
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "groupID"));
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "fetchLocalShareForGroupID:", v7));
  v9 = sub_10004D234(v8);
  v10 = (void *)objc_claimAutoreleasedReturnValue(v9);

  (*(void (**)(void))(*(_QWORD *)(a1 + 56) + 16))();
  objc_msgSend(*(id *)(a1 + 48), "sendGroupsUpdatedNotifications");
  v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "syncController"));
  objc_msgSend(v11, "setFeatureInUse");

}

void sub_1000C68BC(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  void *v12;
  void *v13;
  int v14;
  id v15;

  v5 = a2;
  v6 = a3;
  if (v6)
  {
    v7 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v14 = 138543362;
      v15 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to receive invite from keychainsharingmessagesd: %{public}@", (uint8_t *)&v14, 0xCu);
    }

    (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
  }
  else if (v5)
  {
    objc_msgSend(*(id *)(a1 + 40), "acceptGroupInvite:completion:", v5, *(_QWORD *)(a1 + 48));
  }
  else
  {
    v9 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
    v10 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v13 = *(void **)(a1 + 32);
      v14 = 138543362;
      v15 = v13;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "No error and no invite from ksmd for declining for %{public}@. We raced the sender cancelling the invite?", (uint8_t *)&v14, 0xCu);
    }

    v11 = *(_QWORD *)(a1 + 48);
    v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("KCSharingErrorDomain"), 9, 0));
    (*(void (**)(uint64_t, _QWORD, void *))(v11 + 16))(v11, 0, v12);

  }
}

void sub_1000C6A5C(uint64_t a1, void *a2)
{
  void *v3;
  void *v4;
  id v5;
  void *v6;
  void *v7;
  void *v8;
  uint64_t v9;
  NSObject *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  void *v15;
  void *v16;
  void *v17;
  _QWORD v18[4];
  id v19;
  uint8_t buf[4];
  void *v21;
  __int16 v22;
  void *v23;

  v3 = *(void **)(a1 + 32);
  v4 = *(void **)(a1 + 40);
  v5 = a2;
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "recordID"));
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "zoneID"));
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "translateSyncErrorForGroupRequest:zoneID:", v5, v7));

  if (v8)
  {
    v9 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
    v10 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "groupID"));
      *(_DWORD *)buf = 138543618;
      v21 = v15;
      v22 = 2114;
      v23 = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Failed to save staged outgoing changes for group delete request for %{public}@: %{public}@", buf, 0x16u);

    }
    (*(void (**)(void))(*(_QWORD *)(a1 + 64) + 16))();
  }
  else
  {
    (*(void (**)(void))(*(_QWORD *)(a1 + 64) + 16))();
    objc_msgSend(*(id *)(a1 + 32), "sendGroupsUpdatedNotifications");
    if (*(_QWORD *)(a1 + 56))
    {
      v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "messagingdConnection"));
      v12 = *(void **)(a1 + 56);
      v18[0] = _NSConcreteStackBlock;
      v18[1] = 3221225472;
      v18[2] = sub_1000C6CAC;
      v18[3] = &unk_1002DD798;
      v19 = v12;
      objc_msgSend(v11, "cancelPendingInvitesForGroup:participantHandles:completion:", v19, 0, v18);

    }
    else
    {
      v13 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
      v14 = objc_claimAutoreleasedReturnValue(v13);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "recordID"));
        v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "zoneID"));
        *(_DWORD *)buf = 138543362;
        v21 = v17;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Did not obtain group object for now-deleted group %{public}@, can't cancel pending invitations", buf, 0xCu);

      }
    }
  }

}

void sub_1000C6CAC(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  void *v7;
  int v8;
  void *v9;
  __int16 v10;
  id v11;

  v3 = a2;
  v4 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
  v5 = objc_claimAutoreleasedReturnValue(v4);
  v6 = v5;
  if (v3)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "groupID"));
      v8 = 138543618;
      v9 = v7;
      v10 = 2114;
      v11 = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Failed to cancel (some) pending invitations for now-deleted group %{public}@: %{public}@", (uint8_t *)&v8, 0x16u);
LABEL_6:

    }
  }
  else if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "groupID"));
    v8 = 138543362;
    v9 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Canceled pending invitations for now-deleted group %{public}@", (uint8_t *)&v8, 0xCu);
    goto LABEL_6;
  }

}

void sub_1000C6DE0(uint64_t a1, void *a2)
{
  void *v3;
  void *v4;
  id v5;
  void *v6;
  void *v7;
  void *v8;
  uint64_t v9;
  NSObject *v10;
  void *v11;
  int v12;
  void *v13;
  __int16 v14;
  void *v15;

  v3 = *(void **)(a1 + 32);
  v4 = *(void **)(a1 + 40);
  v5 = a2;
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "recordID"));
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "zoneID"));
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "translateSyncErrorForGroupRequest:zoneID:", v5, v7));

  if (v8)
  {
    v9 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
    v10 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "groupID"));
      v12 = 138543618;
      v13 = v11;
      v14 = 2114;
      v15 = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Failed to save staged outgoing changes for group leave request for %{public}@: %{public}@", (uint8_t *)&v12, 0x16u);

    }
    (*(void (**)(void))(*(_QWORD *)(a1 + 56) + 16))();
  }
  else
  {
    (*(void (**)(void))(*(_QWORD *)(a1 + 56) + 16))();
    objc_msgSend(*(id *)(a1 + 32), "sendGroupsUpdatedNotifications");
  }

}

void sub_1000C6F3C(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  uint64_t v7;
  NSObject *v8;
  void *v9;
  void *v10;
  void *v11;
  id v12;
  id v13;
  uint64_t v14;
  void *i;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  id v21;
  id v22;
  uint64_t v23;
  void *j;
  void *v25;
  void *v26;
  void *v27;
  id v28;
  void *v29;
  id v30;
  id v31;
  id v32;
  uint64_t v33;
  void *k;
  uint64_t v35;
  void *v36;
  void *v37;
  void *v38;
  id v39;
  id v40;
  id v41;
  uint64_t v42;
  void *m;
  uint64_t v44;
  void *v45;
  void *v46;
  void *v47;
  unint64_t v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  void *v52;
  void *v53;
  unsigned __int8 v54;
  id v55;
  uint64_t v56;
  NSObject *v57;
  NSObject *v58;
  void *v59;
  void *v60;
  id v61;
  void *v62;
  uint64_t v63;
  NSObject *v64;
  void (**v65)(id, _QWORD, void *);
  void *v66;
  void *v67;
  void *v68;
  id v69;
  void *v70;
  int8x16_t v71;
  void *v72;
  id *v73;
  _QWORD v74[4];
  int8x16_t v75;
  id v76;
  id v77;
  id v78;
  id v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  uint8_t buf[4];
  void *v97;
  __int16 v98;
  id v99;
  __int16 v100;
  id v101;
  id v102;
  _BYTE v103[128];
  _BYTE v104[128];
  _BYTE v105[128];
  _BYTE v106[128];

  v5 = a2;
  v6 = a3;
  v73 = (id *)a1;
  if (v6)
  {
    v7 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v67 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "groupID"));
      *(_DWORD *)buf = 138543618;
      v97 = v67;
      v98 = 2114;
      v99 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to fetch share participants for group %{public}@: %{public}@", buf, 0x16u);

    }
    (*(void (**)(void))(*(_QWORD *)(a1 + 56) + 16))();
  }
  else
  {
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "participants"));
    v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionaryWithCapacity:](NSMutableDictionary, "dictionaryWithCapacity:", objc_msgSend(v9, "count")));

    v94 = 0u;
    v95 = 0u;
    v92 = 0u;
    v93 = 0u;
    v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "participants"));
    v12 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v92, v106, 16);
    if (v12)
    {
      v13 = v12;
      v14 = *(_QWORD *)v93;
      do
      {
        for (i = 0; i != v13; i = (char *)i + 1)
        {
          if (*(_QWORD *)v93 != v14)
            objc_enumerationMutation(v11);
          v16 = *(void **)(*((_QWORD *)&v92 + 1) + 8 * (_QWORD)i);
          v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "handle"));
          objc_msgSend(v10, "setObject:forKeyedSubscript:", v16, v17);

        }
        v13 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v92, v106, 16);
      }
      while (v13);
    }
    v72 = v5;

    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v73[5], "participants"));
    v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionaryWithCapacity:](NSMutableDictionary, "dictionaryWithCapacity:", objc_msgSend(v18, "count")));

    v90 = 0u;
    v91 = 0u;
    v88 = 0u;
    v89 = 0u;
    v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v73[5], "participants"));
    v21 = objc_msgSend(v20, "countByEnumeratingWithState:objects:count:", &v88, v105, 16);
    if (v21)
    {
      v22 = v21;
      v23 = *(_QWORD *)v89;
      do
      {
        for (j = 0; j != v22; j = (char *)j + 1)
        {
          if (*(_QWORD *)v89 != v23)
            objc_enumerationMutation(v20);
          v25 = *(void **)(*((_QWORD *)&v88 + 1) + 8 * (_QWORD)j);
          v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v25, "userIdentity"));
          v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "lookupInfo"));
          v28 = sub_10004D178(v27);
          v29 = (void *)objc_claimAutoreleasedReturnValue(v28);

          if (v29)
            objc_msgSend(v19, "setObject:forKeyedSubscript:", v25, v29);

        }
        v22 = objc_msgSend(v20, "countByEnumeratingWithState:objects:count:", &v88, v105, 16);
      }
      while (v22);
    }

    v86 = 0u;
    v87 = 0u;
    v84 = 0u;
    v85 = 0u;
    v30 = v10;
    v31 = objc_msgSend(v30, "countByEnumeratingWithState:objects:count:", &v84, v104, 16);
    if (v31)
    {
      v32 = v31;
      v33 = *(_QWORD *)v85;
      do
      {
        for (k = 0; k != v32; k = (char *)k + 1)
        {
          if (*(_QWORD *)v85 != v33)
            objc_enumerationMutation(v30);
          v35 = *(_QWORD *)(*((_QWORD *)&v84 + 1) + 8 * (_QWORD)k);
          v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "objectForKeyedSubscript:", v35));

          if (!v36)
          {
            v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v72, "objectForKeyedSubscript:", v35));
            if (v37)
              objc_msgSend(v73[5], "addParticipant:", v37);

          }
        }
        v32 = objc_msgSend(v30, "countByEnumeratingWithState:objects:count:", &v84, v104, 16);
      }
      while (v32);
    }

    v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
    v80 = 0u;
    v81 = 0u;
    v82 = 0u;
    v83 = 0u;
    v39 = v19;
    v40 = objc_msgSend(v39, "countByEnumeratingWithState:objects:count:", &v80, v103, 16);
    if (v40)
    {
      v41 = v40;
      v42 = *(_QWORD *)v81;
      while (2)
      {
        for (m = 0; m != v41; m = (char *)m + 1)
        {
          if (*(_QWORD *)v81 != v42)
            objc_enumerationMutation(v39);
          v44 = *(_QWORD *)(*((_QWORD *)&v80 + 1) + 8 * (_QWORD)m);
          v45 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v39, "objectForKeyedSubscript:", v44));
          v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "objectForKeyedSubscript:", v44));
          v47 = v46;
          if (v46)
          {
            v48 = (unint64_t)objc_msgSend(v46, "permissionLevel");
            if (v48 > 2)
              v49 = 0;
            else
              v49 = qword_100249520[v48];
            objc_msgSend(v45, "setRole:", v49);
            v50 = (unint64_t)objc_msgSend(v47, "permissionLevel");
            if (v50 > 2)
              v51 = 0;
            else
              v51 = qword_100249538[v50];
            objc_msgSend(v45, "setPermission:", v51);
          }
          else
          {
            if (objc_msgSend(v45, "isCurrentUser"))
            {
              v62 = v38;
              v63 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
              v64 = objc_claimAutoreleasedReturnValue(v63);
              if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
              {
                v68 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v73[4], "groupID"));
                *(_DWORD *)buf = 138543362;
                v97 = v68;
                _os_log_error_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_ERROR, "Rejected request to remove self from group %{public}@", buf, 0xCu);

              }
              v65 = (void (**)(id, _QWORD, void *))v73[7];
              v66 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("KCSharingErrorDomain"), 15, 0));
              v65[2](v65, 0, v66);

              v55 = v39;
              goto LABEL_59;
            }
            objc_msgSend(v73[5], "removeParticipant:", v45);
            objc_msgSend(v38, "addObject:", v44);
          }

        }
        v41 = objc_msgSend(v39, "countByEnumeratingWithState:objects:count:", &v80, v103, 16);
        if (v41)
          continue;
        break;
      }
    }

    v52 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v73[6], "sharingStore"));
    v102 = v73[5];
    v53 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v102, 1));
    v79 = 0;
    v54 = objc_msgSend(v52, "stageOutgoingShares:deletionsForShares:error:", v53, 0, &v79);
    v55 = v79;

    v56 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
    v57 = objc_claimAutoreleasedReturnValue(v56);
    v58 = v57;
    if ((v54 & 1) != 0)
    {
      if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
      {
        v59 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v73[4], "groupID"));
        *(_DWORD *)buf = 138543362;
        v97 = v59;
        _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "Successfully created/updated and staged CKShare for group create/update request %{public}@", buf, 0xCu);

      }
      v60 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v73[6], "syncController"));
      v74[0] = _NSConcreteStackBlock;
      v74[1] = 3221225472;
      v74[2] = sub_1000C778C;
      v74[3] = &unk_1002DD218;
      v71 = *(int8x16_t *)(v73 + 5);
      v61 = (id)v71.i64[0];
      v75 = vextq_s8(v71, v71, 8uLL);
      v76 = v73[4];
      v78 = v73[7];
      v77 = v38;
      objc_msgSend(v60, "saveStagedOutgoingChangesWithCompletion:", v74);

      v5 = v72;
    }
    else
    {
      v62 = v38;
      if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
      {
        v69 = v73[5];
        v70 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v73[4], "groupID"));
        *(_DWORD *)buf = 138478339;
        v97 = v69;
        v98 = 2114;
        v99 = v70;
        v100 = 2114;
        v101 = v55;
        _os_log_error_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_ERROR, "Failed to stage outgoing share %{private}@ for group %{public}@: %{public}@", buf, 0x20u);

      }
      (*((void (**)(void))v73[7] + 2))();
LABEL_59:
      v5 = v72;
      v38 = v62;
    }

    v6 = 0;
  }

}

void sub_1000C778C(uint64_t a1, void *a2)
{
  void *v3;
  void *v4;
  id v5;
  void *v6;
  void *v7;
  void *v8;
  uint64_t v9;
  NSObject *v10;
  void *v11;
  void *v12;
  void *v13;
  id v14;
  id v15;
  void *v16;
  uint64_t v17;
  NSObject *v18;
  NSObject *v19;
  id v20;
  void *v21;
  void *v22;
  void *v23;
  uint64_t v24;
  void *v25;
  _QWORD v26[4];
  id v27;
  id v28;
  uint8_t buf[4];
  id v30;
  __int16 v31;
  void *v32;

  v3 = *(void **)(a1 + 32);
  v4 = *(void **)(a1 + 40);
  v5 = a2;
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "recordID"));
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "zoneID"));
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "translateSyncErrorForGroupRequest:zoneID:", v5, v7));

  if (v8)
  {
    v9 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
    v10 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "groupID"));
      *(_DWORD *)buf = 138543618;
      v30 = v25;
      v31 = 2114;
      v32 = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Failed to save staged outgoing changes for group create/update request for %{public}@: %{public}@", buf, 0x16u);

    }
    (*(void (**)(void))(*(_QWORD *)(a1 + 64) + 16))();
  }
  else
  {
    v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sharingStore"));
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "groupID"));
    v28 = 0;
    v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "fetchCKShareFromMirrorForGroupID:error:", v12, &v28));
    v14 = v28;

    v15 = sub_10004D234(v13);
    v16 = (void *)objc_claimAutoreleasedReturnValue(v15);
    v17 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
    v18 = objc_claimAutoreleasedReturnValue(v17);
    v19 = v18;
    if (v14 || !v16)
    {
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138543362;
        v30 = v14;
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Failed to fetch newly saved group from disk. This is a bug?! %{public}@", buf, 0xCu);
      }

      v20 = sub_10004D234(*(void **)(a1 + 40));
      v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
      (*(void (**)(void))(*(_QWORD *)(a1 + 64) + 16))();

    }
    else
    {
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138477827;
        v30 = v16;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Will return successfully saved group %{private}@", buf, 0xCu);
      }

      (*(void (**)(void))(*(_QWORD *)(a1 + 64) + 16))();
    }
    objc_msgSend(*(id *)(a1 + 32), "sendGroupsUpdatedNotifications");
    if (objc_msgSend(*(id *)(a1 + 56), "count"))
    {
      v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "messagingdConnection"));
      v23 = *(void **)(a1 + 48);
      v24 = *(_QWORD *)(a1 + 56);
      v26[0] = _NSConcreteStackBlock;
      v26[1] = 3221225472;
      v26[2] = sub_1000C7AAC;
      v26[3] = &unk_1002DD798;
      v27 = v23;
      objc_msgSend(v22, "cancelPendingInvitesForGroup:participantHandles:completion:", v27, v24, v26);

    }
  }

}

void sub_1000C7AAC(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  void *v7;
  int v8;
  void *v9;
  __int16 v10;
  id v11;

  v3 = a2;
  v4 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
  v5 = objc_claimAutoreleasedReturnValue(v4);
  v6 = v5;
  if (v3)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "groupID"));
      v8 = 138543618;
      v9 = v7;
      v10 = 2114;
      v11 = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Failed to cancel (some) pending invitations for participants removed from %{public}@: %{public}@", (uint8_t *)&v8, 0x16u);
LABEL_6:

    }
  }
  else if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "groupID"));
    v8 = 138543362;
    v9 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Canceled any pending invitations for participants removed from %{public}@", (uint8_t *)&v8, 0xCu);
    goto LABEL_6;
  }

}

void sub_1000C7BE0(id *a1, uint64_t a2, void *a3, void *a4)
{
  id v7;
  id v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  void *v14;
  void *v15;
  _QWORD v16[4];
  id v17;
  uint8_t buf[4];
  void *v19;
  __int16 v20;
  id v21;

  v7 = a3;
  v8 = a4;
  if (v8)
  {
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "objectForKeyedSubscript:", a2));
    v10 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
    v11 = objc_claimAutoreleasedReturnValue(v10);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543618;
      v19 = v9;
      v20 = 2114;
      v21 = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "CK failed to fetch metadata for %{public}@: %{public}@", buf, 0x16u);
    }

    if (CKErrorIsCode(v8, 11))
    {
      v12 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
      v13 = objc_claimAutoreleasedReturnValue(v12);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138543362;
        v19 = v9;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Metadata fetch error means the share for %{public}@ is no longer accessible to us, will attempt async to decline invitation", buf, 0xCu);
      }

      v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[5], "messagingdConnection"));
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 3221225472;
      v16[2] = sub_1000C7FD8;
      v16[3] = &unk_1002DD798;
      v17 = v9;
      objc_msgSend(v14, "didDeclineInviteForGroupID:completion:", v17, v16);

    }
  }
  else
  {
    v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "share"));

    if (v15)
      objc_msgSend(a1[6], "addObject:", v7);
  }

}

void sub_1000C7DD8(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  int IsCode;
  uint64_t v6;
  NSObject *v7;
  _BOOL4 v8;
  uint64_t v9;
  void *v10;
  void *v11;
  _BYTE *v12;
  int64_t v13;
  id v14;
  void *v15;
  int v16;
  void *v17;
  __int16 v18;
  int64_t v19;
  __int16 v20;
  id v21;
  __int16 v22;
  void *v23;

  v3 = a2;
  v4 = v3;
  if (v3)
  {
    IsCode = CKErrorIsCode(v3, 2);
    v6 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
    v7 = objc_claimAutoreleasedReturnValue(v6);
    v8 = os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
    if (IsCode)
    {
      if (v8)
      {
        v11 = *(void **)(a1 + 32);
        v12 = objc_msgSend(v11, "count");
        v13 = v12 - (_BYTE *)objc_msgSend(*(id *)(a1 + 40), "count");
        v14 = objc_msgSend(*(id *)(a1 + 32), "count");
        v16 = 138478595;
        v17 = v11;
        v18 = 2048;
        v19 = v13;
        v20 = 2048;
        v21 = v14;
        v22 = 2114;
        v23 = v4;
        _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Share metadata fetch for invites %{private}@ partly failed (%ld/%ld): %{public}@", (uint8_t *)&v16, 0x2Au);
      }
    }
    else if (v8)
    {
      v15 = *(void **)(a1 + 32);
      v16 = 138478083;
      v17 = v15;
      v18 = 2114;
      v19 = (int64_t)v4;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to fetch metadata for invites: %{private}@: %{public}@", (uint8_t *)&v16, 0x16u);
    }
  }
  else
  {
    v9 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
    v7 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v10 = *(void **)(a1 + 32);
      v16 = 138477827;
      v17 = v10;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Fetched share metadata for group invites: %{private}@", (uint8_t *)&v16, 0xCu);
    }
  }

  (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
}

void sub_1000C7FD8(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  id v12;

  v3 = a2;
  v4 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
  v5 = objc_claimAutoreleasedReturnValue(v4);
  v6 = v5;
  if (v3)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v7 = *(_QWORD *)(a1 + 32);
      v9 = 138543618;
      v10 = v7;
      v11 = 2114;
      v12 = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Failed to decline unusable invitation for groupID %{public}@: %{public}@", (uint8_t *)&v9, 0x16u);
    }
  }
  else if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v8 = *(_QWORD *)(a1 + 32);
    v9 = 138543362;
    v10 = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Declined invitation for groupID %{public}@ we no longer have access to.", (uint8_t *)&v9, 0xCu);
  }

}

void sub_1000C80F0(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  uint64_t v7;
  NSObject *v8;
  id v9;
  id v10;
  id v11;
  id v12;
  uint64_t v13;
  void *i;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  id v19;
  _QWORD v20[4];
  id v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint8_t v26[128];
  uint8_t buf[4];
  id v28;

  v5 = a2;
  v6 = a3;
  if (v6)
  {
    v7 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543362;
      v28 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to fetch received group invites: %{public}@", buf, 0xCu);
    }

    (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
  }
  else
  {
    v9 = objc_alloc_init((Class)NSMutableArray);
    v22 = 0u;
    v23 = 0u;
    v24 = 0u;
    v25 = 0u;
    v19 = v5;
    v10 = v5;
    v11 = objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v22, v26, 16);
    if (v11)
    {
      v12 = v11;
      v13 = *(_QWORD *)v23;
      do
      {
        for (i = 0; i != v12; i = (char *)i + 1)
        {
          if (*(_QWORD *)v23 != v13)
            objc_enumerationMutation(v10);
          v15 = *(void **)(*((_QWORD *)&v22 + 1) + 8 * (_QWORD)i);
          v16 = *(void **)(a1 + 32);
          v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "groupID", v19));
          LOBYTE(v16) = objc_msgSend(v16, "containsObject:", v17);

          if ((v16 & 1) == 0)
            objc_msgSend(v9, "addObject:", v15);
        }
        v12 = objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v22, v26, 16);
      }
      while (v12);
    }

    if (objc_msgSend(v9, "count"))
    {
      v20[0] = _NSConcreteStackBlock;
      v20[1] = 3221225472;
      v20[2] = sub_1000C8344;
      v20[3] = &unk_1002DEFD8;
      v18 = *(void **)(a1 + 40);
      v21 = *(id *)(a1 + 48);
      objc_msgSend(v18, "fetchCKShareMetadataForGroupInvites:completion:", v9, v20);

    }
    else
    {
      (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
    }

    v5 = v19;
  }

}

void sub_1000C8344(uint64_t a1, void *a2, void *a3)
{
  id v4;
  id v5;
  uint64_t v6;
  NSObject *v7;
  id v8;
  id v9;
  id v10;
  id v11;
  uint64_t v12;
  void *i;
  void *v14;
  void *v15;
  id v16;
  void *v17;
  uint64_t v18;
  NSObject *v19;
  void *v20;
  void *v21;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint8_t v27[128];
  uint8_t buf[4];
  id v29;

  v4 = a2;
  v5 = a3;
  if (v5)
  {
    v6 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
    v7 = objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543362;
      v29 = v5;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "(Partial) error fetching share metadata for group invites: %{public}@", buf, 0xCu);
    }

  }
  v21 = v5;
  v8 = objc_alloc_init((Class)NSMutableArray);
  v23 = 0u;
  v24 = 0u;
  v25 = 0u;
  v26 = 0u;
  v9 = v4;
  v10 = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v23, v27, 16);
  if (v10)
  {
    v11 = v10;
    v12 = *(_QWORD *)v24;
    do
    {
      for (i = 0; i != v11; i = (char *)i + 1)
      {
        if (*(_QWORD *)v24 != v12)
          objc_enumerationMutation(v9);
        v14 = *(void **)(*((_QWORD *)&v23 + 1) + 8 * (_QWORD)i);
        v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "share", v21));
        v16 = sub_10004D234(v15);
        v17 = (void *)objc_claimAutoreleasedReturnValue(v16);

        if (v17)
        {
          objc_msgSend(v8, "addObject:", v17);
        }
        else
        {
          v18 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
          v19 = objc_claimAutoreleasedReturnValue(v18);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "share"));
            *(_DWORD *)buf = 138543362;
            v29 = v20;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Ignoring share for non-group zone: %{public}@", buf, 0xCu);

          }
        }

      }
      v11 = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v23, v27, 16);
    }
    while (v11);
  }

  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_1000C85A4(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  id v11;
  id v12;
  uint64_t v13;
  int v14;
  id v15;
  __int16 v16;
  id v17;
  __int16 v18;
  uint64_t v19;

  v5 = a2;
  v6 = a3;
  if (v6)
  {
    v7 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v14 = 138543362;
      v15 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to fetch pending groups: %{public}@", (uint8_t *)&v14, 0xCu);
    }

  }
  if (objc_msgSend(v5, "count"))
    objc_msgSend(*(id *)(a1 + 32), "addObjectsFromArray:", v5);
  v9 = KCSharingLogObject(CFSTR("KCSharingDaemonGroupManager"));
  v10 = objc_claimAutoreleasedReturnValue(v9);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    v11 = objc_msgSend(*(id *)(a1 + 32), "count");
    v12 = objc_msgSend(v5, "count");
    v13 = *(_QWORD *)(a1 + 32);
    v14 = 134349571;
    v15 = v11;
    v16 = 2050;
    v17 = v12;
    v18 = 2113;
    v19 = v13;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Fetched %{public}ld groups (%{public}ld of which pending): %{private}@", (uint8_t *)&v14, 0x20u);
  }

  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
}

void sub_1000C8770(id a1)
{
  void *v1;
  KCSharingDaemonGroupManager *v2;
  void *v3;
  void *v4;
  KCSharingDaemonGroupManager *v5;
  void *v6;

  v1 = objc_autoreleasePoolPush();
  v2 = [KCSharingDaemonGroupManager alloc];
  v3 = (void *)objc_claimAutoreleasedReturnValue(+[KCSharingSyncController sharedInstance](KCSharingSyncController, "sharedInstance"));
  v4 = (void *)objc_claimAutoreleasedReturnValue(+[KCSharingMessagingdConnection sharedInstance](KCSharingMessagingdConnection, "sharedInstance"));
  v5 = -[KCSharingDaemonGroupManager initWithSyncController:messagingdConnection:](v2, "initWithSyncController:messagingdConnection:", v3, v4);
  v6 = (void *)qword_100341078;
  qword_100341078 = (uint64_t)v5;

  objc_autoreleasePoolPop(v1);
}

void sub_1000C8AD4(_Unwind_Exception *a1)
{
  id *v1;
  id *v2;
  uint64_t v3;

  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v3 - 80));
  _Unwind_Resume(a1);
}

void sub_1000C90EC(uint64_t a1)
{
  const void *v2;
  NSObject *v3;
  uint64_t v4;
  int v5;
  uint64_t v6;

  v2 = sub_10000EF14("octagon-ckks");
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = *(_QWORD *)(a1 + 32);
    v5 = 138412290;
    v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Successfully reset %@", (uint8_t *)&v5, 0xCu);
  }

}

void sub_1000C9198(id a1, NSError *a2)
{
  const void *v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = sub_10000EF14("octagon-ckks");
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "CKKS view reset complete", v4, 2u);
  }

}

void sub_1000C9204(uint64_t a1)
{
  id WeakRetained;
  const void *v2;
  NSObject *v3;
  uint64_t v4;
  void *v5;
  const __CFString *v6;
  int v7;
  const __CFString *v8;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v2 = sub_10000EF14("octagon");
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
    v5 = (void *)v4;
    v6 = CFSTR("no error");
    if (v4)
      v6 = (const __CFString *)v4;
    v7 = 138412290;
    v8 = v6;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Finishing resetting CKKS missing TLKs operation with %@", (uint8_t *)&v7, 0xCu);

  }
}

void sub_1000C92E4(uint64_t a1)
{
  void *v2;
  void *v3;
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "viewKeySets"));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "incompleteKeySets"));
  objc_msgSend(WeakRetained, "proceedWithKeys:incompleteKeySets:", v2, v3);

}

uint64_t sub_1000CA354(uint64_t a1, uint64_t a2)
{
  char v4;
  unsigned int v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  char v9;
  BOOL v10;
  int v11;
  uint64_t v12;
  unint64_t v14;
  uint64_t String;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  id v19;
  void *v20;
  uint64_t result;
  char v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  char v27;
  uint64_t Data;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  char v33;
  unsigned int v34;
  uint64_t v35;
  unint64_t v36;
  char v37;
  char v38;
  unsigned int v39;
  uint64_t v40;
  unint64_t v41;
  char v42;
  unint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;

  while (*(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error))
      break;
    v4 = 0;
    v5 = 0;
    v6 = 0;
    while (1)
    {
      v7 = *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos);
      v8 = v7 + 1;
      if (v7 == -1 || v8 > *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__length))
        break;
      v9 = *(_BYTE *)(*(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos) = v8;
      v6 |= (unint64_t)(v9 & 0x7F) << v4;
      if ((v9 & 0x80) == 0)
        goto LABEL_11;
      v4 += 7;
      v10 = v5++ >= 9;
      if (v10)
      {
        v6 = 0;
        v11 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }
    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    v11 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error))
      v6 = 0;
LABEL_13:
    v12 = v6 & 7;
    if (v11 || (_DWORD)v12 == 4)
      break;
    v14 = v6 >> 3;
    switch((v6 >> 3))
    {
      case 1u:
        String = PBReaderReadString(a2);
        v16 = objc_claimAutoreleasedReturnValue(String);
        v17 = 56;
        goto LABEL_34;
      case 2u:
        v22 = 0;
        v23 = 0;
        v24 = 0;
        *(_BYTE *)(a1 + 96) |= 8u;
        while (2)
        {
          v25 = *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos);
          v26 = v25 + 1;
          if (v25 == -1 || v26 > *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }
          else
          {
            v27 = *(_BYTE *)(*(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v25);
            *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos) = v26;
            v24 |= (unint64_t)(v27 & 0x7F) << v22;
            if (v27 < 0)
            {
              v22 += 7;
              v10 = v23++ >= 9;
              if (v10)
              {
                v24 = 0;
                goto LABEL_58;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error))
          v24 = 0;
LABEL_58:
        v46 = 40;
        goto LABEL_67;
      case 3u:
        Data = PBReaderReadData(a2);
        v16 = objc_claimAutoreleasedReturnValue(Data);
        v17 = 72;
        goto LABEL_34;
      case 4u:
        v29 = PBReaderReadString(a2);
        v16 = objc_claimAutoreleasedReturnValue(v29);
        v17 = 88;
        goto LABEL_34;
      case 5u:
        v30 = PBReaderReadData(a2);
        v16 = objc_claimAutoreleasedReturnValue(v30);
        v17 = 64;
        goto LABEL_34;
      case 6u:
        v31 = PBReaderReadData(a2);
        v16 = objc_claimAutoreleasedReturnValue(v31);
        v17 = 80;
LABEL_34:
        v32 = *(void **)(a1 + v17);
        *(_QWORD *)(a1 + v17) = v16;

        continue;
      case 7u:
        v33 = 0;
        v34 = 0;
        v24 = 0;
        *(_BYTE *)(a1 + 96) |= 4u;
        while (2)
        {
          v35 = *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos);
          v36 = v35 + 1;
          if (v35 == -1 || v36 > *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }
          else
          {
            v37 = *(_BYTE *)(*(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v35);
            *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos) = v36;
            v24 |= (unint64_t)(v37 & 0x7F) << v33;
            if (v37 < 0)
            {
              v33 += 7;
              v10 = v34++ >= 9;
              if (v10)
              {
                v24 = 0;
                goto LABEL_62;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error))
          v24 = 0;
LABEL_62:
        v46 = 32;
        goto LABEL_67;
      case 8u:
        v38 = 0;
        v39 = 0;
        v24 = 0;
        *(_BYTE *)(a1 + 96) |= 2u;
        break;
      case 9u:
        *(_BYTE *)(a1 + 96) |= 1u;
        v43 = *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v43 <= 0xFFFFFFFFFFFFFFF7 && v43 + 8 <= *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          v44 = *(_QWORD *)(*(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v43);
          *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos) = v43 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          v44 = 0;
        }
        v47 = 16;
        goto LABEL_72;
      case 0xAu:
        *(_BYTE *)(a1 + 96) |= 0x10u;
        v45 = *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v45 <= 0xFFFFFFFFFFFFFFF7 && v45 + 8 <= *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          v44 = *(_QWORD *)(*(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v45);
          *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos) = v45 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          v44 = 0;
        }
        v47 = 48;
LABEL_72:
        *(_QWORD *)(a1 + v47) = v44;
        continue;
      default:
        v18 = *(_QWORD *)(a1 + 8);
        if (!v18)
        {
          v19 = objc_alloc_init((Class)PBUnknownFields);
          v20 = *(void **)(a1 + 8);
          *(_QWORD *)(a1 + 8) = v19;

          v18 = *(_QWORD *)(a1 + 8);
        }
        result = PBUnknownFieldAdd(v18, v14, v12, a2);
        if (!(_DWORD)result)
          return result;
        continue;
    }
    while (1)
    {
      v40 = *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos);
      v41 = v40 + 1;
      if (v40 == -1 || v41 > *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__length))
        break;
      v42 = *(_BYTE *)(*(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v40);
      *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos) = v41;
      v24 |= (unint64_t)(v42 & 0x7F) << v38;
      if ((v42 & 0x80) == 0)
        goto LABEL_64;
      v38 += 7;
      v10 = v39++ >= 9;
      if (v10)
      {
        v24 = 0;
        goto LABEL_66;
      }
    }
    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_64:
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error))
      v24 = 0;
LABEL_66:
    v46 = 24;
LABEL_67:
    *(_QWORD *)(a1 + v46) = v24;
  }
  return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

void sub_1000CAAC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000CAB94(uint64_t a1, void *a2)
{
  id v3;
  id WeakRetained;
  void *v5;
  const void *v6;
  NSObject *v7;
  const void *v8;
  NSObject *v9;
  void *v10;
  int v11;
  id v12;

  v3 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v5 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v5, "logResultForEvent:hardFailure:result:", CFSTR("OctagonEventRemoveCustodianRecoveryKeyTPH"), 1, v3);

  if (v3)
  {
    v6 = sub_10000EF14("SecError");
    v7 = objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v11 = 138412290;
      v12 = v3;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "octagon: Error removing custodian recovery key: %@", (uint8_t *)&v11, 0xCu);
    }

    objc_msgSend(WeakRetained, "setError:", v3);
  }
  else
  {
    v8 = sub_10000EF14("octagon");
    v9 = objc_claimAutoreleasedReturnValue(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v11) = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "successfully removed custodian recovery key", (uint8_t *)&v11, 2u);
    }

  }
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishOp"));
  objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v10);

}

void sub_1000CAEF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000CAFFC(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id WeakRetained;
  void *v8;
  const void *v9;
  NSObject *v10;
  void *v11;
  const void *v12;
  NSObject *v13;
  void *v14;
  int v15;
  id v16;

  v5 = a2;
  v6 = a3;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v8 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v8, "logResultForEvent:hardFailure:result:", CFSTR("OctagonEventCheckCustodianRecoveryKeyTPH"), 1, v6);

  if (v6)
  {
    v9 = sub_10000EF14("SecError");
    v10 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      v15 = 138412290;
      v16 = v6;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "octagon: Error finding custodian recovery key: %@", (uint8_t *)&v15, 0xCu);
    }

    objc_msgSend(WeakRetained, "setError:", v6);
    v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishOp"));
    objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v11);

  }
  else
  {
    v12 = sub_10000EF14("octagon");
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v15) = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "successfully found custodian recovery key", (uint8_t *)&v15, 2u);
    }

    v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishOp"));
    objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v14);

    objc_msgSend(WeakRetained, "setCrk:", v5);
  }

}

void sub_1000CB73C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id *location)
{
  id *v17;
  uint64_t v18;

  objc_destroyWeak(v17);
  objc_destroyWeak(location);
  objc_destroyWeak((id *)(v18 - 136));
  _Unwind_Resume(a1);
}

void sub_1000CB8FC(uint64_t a1)
{
  id WeakRetained;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  unsigned int v7;
  const void *v8;
  NSObject *v9;
  _BOOL4 v10;
  NSObject *v11;
  OctagonPendingFlag *v12;
  void *v13;
  void *v14;
  double v15;
  double v16;
  OctagonPendingFlag *v17;
  void *v18;
  const void *v19;
  NSObject *v20;
  NSObject *v21;
  void *v22;
  const void *v23;
  int v24;
  NSObject *v25;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));

  if (v2)
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "retryFlag"));

    if (!v3)
    {
      v23 = sub_10000EF14("SecError");
      v9 = objc_claimAutoreleasedReturnValue(v23);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v24) = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "octagon: Received an error updating TPH, but no retry flag present.", (uint8_t *)&v24, 2u);
      }
      goto LABEL_16;
    }
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "lockStateTracker"));
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
    v7 = objc_msgSend(v5, "isLockedError:", v6);

    v8 = sub_10000EF14("octagon");
    v9 = objc_claimAutoreleasedReturnValue(v8);
    v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
    if (v7)
    {
      if (v10)
      {
        v11 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
        v24 = 138412290;
        v25 = v11;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Updating trust state failed because locked, retry once unlocked: %@", (uint8_t *)&v24, 0xCu);

      }
      objc_msgSend(WeakRetained, "setNextState:", CFSTR("WaitForUnlock"));
      v12 = [OctagonPendingFlag alloc];
      v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "retryFlag"));
      v9 = -[OctagonPendingFlag initWithFlag:conditions:](v12, "initWithFlag:conditions:", v13, 1);

      if (!v9)
      {
        v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
        objc_msgSend(v14, "retryInterval");
        v16 = v15;

        v17 = [OctagonPendingFlag alloc];
        v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "retryFlag"));
        v9 = -[OctagonPendingFlag initWithFlag:delayInSeconds:](v17, "initWithFlag:delayInSeconds:", v18, v16);

      }
      v19 = sub_10000EF14("octagon");
      v20 = objc_claimAutoreleasedReturnValue(v19);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        v24 = 138412290;
        v25 = v9;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Updating trust state not fatal: requesting retry: %@", (uint8_t *)&v24, 0xCu);
      }

      v21 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
      v22 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject flagHandler](v21, "flagHandler"));
      objc_msgSend(v22, "handlePendingFlag:", v9);

    }
    else
    {
      if (!v10)
      {
LABEL_16:

        goto LABEL_17;
      }
      v21 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
      v24 = 138412290;
      v25 = v21;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Error is currently unknown, aborting: %@", (uint8_t *)&v24, 0xCu);
    }

    goto LABEL_16;
  }
LABEL_17:

}

void sub_1000CBC10(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  __CFString *v8;
  id v9;
  id WeakRetained;
  const void *v11;
  NSObject *v12;
  void *v13;
  void *v14;
  __CFString *v15;
  unsigned int v16;
  id v17;
  void *v18;
  void *v19;
  unsigned int v20;
  NSObject *v21;
  void *v22;
  const void *v23;
  NSObject *v24;
  const void *v25;
  NSObject *v26;
  void *v27;
  uint64_t v28;
  void *v29;
  const void *v30;
  const void *v31;
  NSObject *v32;
  void *v33;
  void *v34;
  const void *v35;
  NSObject *v36;
  void *v37;
  void *v38;
  const void *v39;
  NSObject *v40;
  void *v41;
  void *v42;
  uint64_t v43;
  const void *v44;
  NSObject *v45;
  void *v46;
  const char *v47;
  NSObject *v48;
  uint32_t v49;
  const __CFString *v50;
  const void *v51;
  NSObject *v52;
  void *v53;
  void *v54;
  void *v55;
  const void *v56;
  NSObject *v57;
  void *v58;
  __CFString *v59;
  void *v60;
  void *v61;
  void *v62;
  const void *v63;
  NSObject *v64;
  void *v65;
  __CFString *v66;
  const void *v67;
  id v68;
  _QWORD v69[4];
  __CFString *v70;
  uint8_t buf[4];
  id v72;
  __int16 v73;
  const __CFString *v74;

  v7 = a2;
  v8 = a3;
  v9 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (!v7 || v9)
  {
    v23 = sub_10000EF14("SecError");
    v24 = objc_claimAutoreleasedReturnValue(v23);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v72 = v9;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "octagon: update errored: %@", buf, 0xCu);
    }

    objc_msgSend(WeakRetained, "setError:", v9);
    if (!objc_msgSend(v9, "isCuttlefishError:", 1037))
      goto LABEL_54;
    v25 = sub_10000EF14("octagon-ckks");
    v26 = objc_claimAutoreleasedReturnValue(v25);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Cuttlefish reports we no longer exist.", buf, 2u);
    }

    v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "determineCDPState"));
    if (v27)
    {
      v28 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "determineCDPState"));
    }
    else
    {
      if (!*(_BYTE *)(a1 + 40)
        || (v54 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "peerUnknownState")),
            v54,
            !v54))
      {
        objc_msgSend(WeakRetained, "setNextState:", CFSTR("BecomeUntrusted"));
        goto LABEL_54;
      }
      v28 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "peerUnknownState"));
    }
    v29 = (void *)v28;
    objc_msgSend(WeakRetained, "setNextState:", v28);

LABEL_54:
    v17 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishedOp"));
    objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v17);
    goto LABEL_55;
  }
  v11 = sub_10000EF14("octagon");
  v12 = objc_claimAutoreleasedReturnValue(v11);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412546;
    v72 = v7;
    v73 = 2112;
    v74 = v8;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "update complete: %@, %@", buf, 0x16u);
  }

  v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
  v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "stateHolder"));
  v69[0] = _NSConcreteStackBlock;
  v69[1] = 3221225472;
  v69[2] = sub_1000CC4AC;
  v69[3] = &unk_1002EAF10;
  v15 = v8;
  v70 = v15;
  v68 = 0;
  v16 = objc_msgSend(v14, "persistAccountChanges:error:", v69, &v68);
  v17 = v68;

  if (!v16 || v17)
  {
    v30 = sub_10000EF14("SecError");
    v21 = objc_claimAutoreleasedReturnValue(v30);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v72 = v17;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "octagon: Unable to save new syncing state: %@", buf, 0xCu);
    }
  }
  else
  {
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "ckks"));
    v20 = objc_msgSend(v19, "setCurrentSyncingPolicy:policyIsFresh:", v15, 1);

    if (!v20)
      goto LABEL_20;
    v21 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v22 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject flagHandler](v21, "flagHandler"));
    objc_msgSend(v22, "handleFlag:", CFSTR("ckks_views_changed"));

  }
LABEL_20:
  if (objc_msgSend(v7, "identityIsPreapproved"))
  {
    v31 = sub_10000EF14("octagon-sos");
    v32 = objc_claimAutoreleasedReturnValue(v31);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "Self peer is now preapproved!", buf, 2u);
    }

    v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v33, "flagHandler"));
    objc_msgSend(v34, "handleFlag:", CFSTR("preapproved"));

  }
  if (objc_msgSend(v7, "memberChanges"))
  {
    v35 = sub_10000EF14("octagon");
    v36 = objc_claimAutoreleasedReturnValue(v35);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "Member list changed", buf, 2u);
    }

    v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v37, "octagonAdapter"));
    objc_msgSend(v38, "sendTrustedPeerSetChangedUpdate");

  }
  if (objc_msgSend(v7, "unknownMachineIDsPresent"))
  {
    v39 = sub_10000EF14("octagon-authkit");
    v40 = objc_claimAutoreleasedReturnValue(v39);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "Unknown machine IDs are present; requesting fetch",
        buf,
        2u);
    }

    v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v41, "flagHandler"));
    objc_msgSend(v42, "handleFlag:", CFSTR("attempt_machine_id_list"));

  }
  if ((objc_msgSend(v7, "peerStatus") & 4) != 0)
  {
    v44 = sub_10000EF14("octagon");
    v45 = objc_claimAutoreleasedReturnValue(v44);
    if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
    {
      v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "peerID"));
      *(_DWORD *)buf = 138412290;
      v72 = v46;
      v47 = "Self peer (%@) is excluded; moving to untrusted";
      v48 = v45;
      v49 = 12;
LABEL_37:
      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, v47, buf, v49);

    }
  }
  else
  {
    if ((objc_msgSend(v7, "peerStatus") & 0x20) == 0)
    {
      v43 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "intendedState"));
LABEL_51:
      v60 = (void *)v43;
      objc_msgSend(WeakRetained, "setNextState:", v43);

      goto LABEL_52;
    }
    if (objc_msgSend(v7, "identityIsPreapproved"))
    {
      v51 = sub_10000EF14("octagon");
      v52 = objc_claimAutoreleasedReturnValue(v51);
      if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
      {
        v53 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "peerID"));
        *(_DWORD *)buf = 138412290;
        v72 = v53;
        _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "Self peer (%@) is excluded but is preapproved, moving to sosuprade", buf, 0xCu);

      }
      v50 = CFSTR("AttemptSOSUpgrade");
      goto LABEL_39;
    }
    v55 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "determineCDPState"));

    if (v55)
    {
      v56 = sub_10000EF14("octagon");
      v57 = objc_claimAutoreleasedReturnValue(v56);
      if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
      {
        v58 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "peerID"));
        v59 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "determineCDPState"));
        *(_DWORD *)buf = 138412546;
        v72 = v58;
        v73 = 2112;
        v74 = v59;
        _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "Self peer (%@) is unknown, but still figuring out cdp state; moving to '%@''",
          buf,
          0x16u);

      }
      v43 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "determineCDPState"));
      goto LABEL_51;
    }
    if (*(_BYTE *)(a1 + 40))
    {
      v62 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "peerUnknownState"));

      if (v62)
      {
        v63 = sub_10000EF14("octagon");
        v64 = objc_claimAutoreleasedReturnValue(v63);
        if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
        {
          v65 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "peerID"));
          v66 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "peerUnknownState"));
          *(_DWORD *)buf = 138412546;
          v72 = v65;
          v73 = 2112;
          v74 = v66;
          _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "Self peer (%@) is unknown and has attempted a join; moving to '%@''",
            buf,
            0x16u);

        }
        v43 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "peerUnknownState"));
        goto LABEL_51;
      }
    }
    v67 = sub_10000EF14("octagon");
    v45 = objc_claimAutoreleasedReturnValue(v67);
    if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
    {
      v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "peerID"));
      *(_DWORD *)buf = 138412546;
      v72 = v46;
      v73 = 2112;
      v74 = CFSTR("BecomeUntrusted");
      v47 = "Self peer (%@) is unknown and never attempted a join; moving to '%@''";
      v48 = v45;
      v49 = 22;
      goto LABEL_37;
    }
  }

  v50 = CFSTR("BecomeUntrusted");
LABEL_39:
  objc_msgSend(WeakRetained, "setNextState:", v50);
LABEL_52:
  v61 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishedOp"));
  objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v61);

LABEL_55:
}

id sub_1000CC4AC(uint64_t a1, void *a2)
{
  id v3;

  v3 = a2;
  objc_msgSend(v3, "setTPSyncingPolicy:", *(_QWORD *)(a1 + 32));
  return v3;
}

CFTypeRef sub_1000CDD7C(uint64_t a1, const void *a2, _QWORD *a3)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t **v9;
  uint64_t *v10;
  CFTypeRef result;

  v5 = *(_QWORD **)(a1 + 32);
  v6 = v5[2];
  v7 = *(uint64_t **)(v6 + 16);
  if (v7)
  {
    v9 = (uint64_t **)(v6 + 24);
    do
    {
      if (CFEqual((CFTypeRef)*v7, CFSTR("persistref")))
        sub_100115FE0(*(_QWORD *)(a1 + 32), a2, v7);
      v10 = *v9++;
      v7 = v10;
    }
    while (v10);
    v5 = *(_QWORD **)(a1 + 32);
  }
  result = CFRetain(v5);
  *a3 = result;
  return result;
}

CFTypeRef sub_1000CDE00(uint64_t a1, const void *a2, _QWORD *a3)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t **v9;
  uint64_t *v10;
  CFTypeRef result;

  v5 = *(_QWORD **)(a1 + 32);
  v6 = v5[2];
  v7 = *(uint64_t **)(v6 + 16);
  if (v7)
  {
    v9 = (uint64_t **)(v6 + 24);
    do
    {
      if (CFEqual((CFTypeRef)*v7, CFSTR("persistref")))
        sub_100115FE0(*(_QWORD *)(a1 + 32), a2, v7);
      v10 = *v9++;
      v7 = v10;
    }
    while (v10);
    v5 = *(_QWORD **)(a1 + 32);
  }
  result = CFRetain(v5);
  *a3 = result;
  return result;
}

CFTypeRef sub_1000CDE84(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  CFTypeRef result;

  result = CFRetain(*(CFTypeRef *)(a1 + 32));
  *a3 = result;
  return result;
}

CFTypeRef sub_1000CDEAC(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  void *v6;
  CFTypeRef result;

  if (objc_msgSend(*(id *)(a1 + 32), "type") == (id)3 && *(_QWORD *)(a1 + 40))
  {
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "groupUpdateInfoFrom:to:", a2, *(_QWORD *)(a1 + 32)));
    if (v6)
      objc_msgSend(*(id *)(a1 + 40), "addObject:", v6);

  }
  result = CFRetain(*(CFTypeRef *)(a1 + 56));
  *a3 = result;
  return result;
}

CFTypeRef sub_1000CDF28(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  CFTypeRef result;

  result = CFRetain(*(CFTypeRef *)(a1 + 32));
  *a3 = result;
  return result;
}

BOOL sub_1000CDF50(id a1, const SecDbAttr *a2)
{
  return a2->var1 == 8;
}

void sub_1000CDF60(uint64_t a1, void *a2)
{
  id v3;
  id v4;

  v3 = sub_10004CFE8(a2);
  v4 = (id)objc_claimAutoreleasedReturnValue(v3);
  if (objc_msgSend(v4, "inviteStatus") == (id)2)
    objc_msgSend(*(id *)(a1 + 32), "addObject:", v4);

}

void sub_1000CE44C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  id *v20;
  id *v21;
  id *v22;

  v22 = v21;
  objc_destroyWeak(v22);
  objc_destroyWeak(v20);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000CE59C(uint64_t a1)
{
  id WeakRetained;
  void *v2;
  void *v3;
  unsigned int v4;
  void *v5;
  double v6;
  double v7;
  const void *v8;
  NSObject *v9;
  void *v10;
  NSObject *v11;
  void *v12;
  OctagonPendingFlag *v13;
  const void *v14;
  int v15;
  double v16;
  __int16 v17;
  void *v18;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));

  if (v2)
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
    v4 = objc_msgSend(v3, "isRetryable");

    if (v4)
    {
      v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
      objc_msgSend(v5, "retryInterval");
      v7 = v6;

      v8 = sub_10000EF14("octagon-sos");
      v9 = objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
        v15 = 134218242;
        v16 = v7;
        v17 = 2112;
        v18 = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "SOS update preapproval error is not fatal: requesting retry in %0.2fs: %@", (uint8_t *)&v15, 0x16u);

      }
      v11 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
      v12 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject flagHandler](v11, "flagHandler"));
      v13 = -[OctagonPendingFlag initWithFlag:delayInSeconds:]([OctagonPendingFlag alloc], "initWithFlag:delayInSeconds:", CFSTR("attempt_sos_update_preapprovals"), v7);
      objc_msgSend(v12, "handlePendingFlag:", v13);

    }
    else
    {
      v14 = sub_10000EF14("octagon-sos");
      v11 = objc_claimAutoreleasedReturnValue(v14);
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
LABEL_9:

        goto LABEL_10;
      }
      v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
      v15 = 138412290;
      v16 = *(double *)&v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "SOS update preapproval error is: %@, not retrying", (uint8_t *)&v15, 0xCu);
    }

    goto LABEL_9;
  }
LABEL_10:

}

void sub_1000CE78C(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id WeakRetained;
  const void *v8;
  NSObject *v9;
  const void *v10;
  NSObject *v11;
  const void *v12;
  NSObject *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  int v18;
  id v19;

  v5 = a2;
  v6 = a3;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (v6)
  {
    v8 = sub_10000EF14("SecError");
    v9 = objc_claimAutoreleasedReturnValue(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      v18 = 138412290;
      v19 = v6;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "octagon-sos: unable to update preapproved keys: %@", (uint8_t *)&v18, 0xCu);
    }

    objc_msgSend(WeakRetained, "setError:", v6);
  }
  else
  {
    v10 = sub_10000EF14("octagon-sos");
    v11 = objc_claimAutoreleasedReturnValue(v10);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v18) = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Updated SOS preapproved keys", (uint8_t *)&v18, 2u);
    }

    if (objc_msgSend(v5, "memberChanges"))
    {
      v12 = sub_10000EF14("octagon");
      v13 = objc_claimAutoreleasedReturnValue(v12);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v18) = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Member list changed", (uint8_t *)&v18, 2u);
      }

      v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
      v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "octagonAdapter"));
      objc_msgSend(v15, "sendTrustedPeerSetChangedUpdate");

    }
    v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "intendedState"));
    objc_msgSend(WeakRetained, "setNextState:", v16);

  }
  v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishedOp"));
  objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v17);

}

uint64_t sub_1000CE990(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_1000CE9A0(uint64_t a1)
{

}

void sub_1000CE9A8(id a1)
{
  dispatch_queue_attr_t v1;
  dispatch_queue_t v2;
  void *v3;
  NSObject *v4;

  v1 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v4 = objc_claimAutoreleasedReturnValue(v1);
  v2 = dispatch_queue_create("ckks-logger", v4);
  v3 = (void *)qword_100341080;
  qword_100341080 = (uint64_t)v2;

}

void sub_1000CEE00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  id *v15;

  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000CEF2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000CF09C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000CF270(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  id v11;
  id v12;
  id v13;
  id v14;
  id v15;
  id WeakRetained;
  void *v17;
  const void *v18;
  NSObject *v19;
  void *v20;
  const void *v21;
  NSObject *v22;
  void *v23;
  void *v24;
  id v25;
  const void *v26;
  NSObject *v27;
  void *v28;
  const void *v29;
  NSObject *v30;
  void *v31;
  id v32;
  _QWORD v33[4];
  id v34;
  id v35;
  id v36;
  uint8_t buf[4];
  id v38;
  __int16 v39;
  id v40;

  v11 = a2;
  v12 = a3;
  v13 = a4;
  v14 = a5;
  v15 = a6;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v17 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v17, "logResultForEvent:hardFailure:result:", CFSTR("OctagonEventVoucherWithRecoveryKey"), 1, v15);

  if (v15)
  {
    v18 = sub_10000EF14("SecError");
    v19 = objc_claimAutoreleasedReturnValue(v18);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v38 = v15;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "octagon: Error preparing voucher using recovery key: %@", buf, 0xCu);
    }

    objc_msgSend(WeakRetained, "setError:", v15);
LABEL_16:
    v25 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishOp"));
    objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v25);
    goto LABEL_17;
  }
  v20 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v20, "recordRecoveredTLKMetrics:tlkRecoveryResults:uniqueTLKsRecoveredEvent:totalSharesRecoveredEvent:totalRecoverableTLKSharesEvent:totalRecoverableTLKsEvent:totalViewsWithSharesEvent:", *(_QWORD *)(a1 + 32), v14, CFSTR("OARKUniqueTLKsRecoveredCount"), CFSTR("OARKTotalTLKSharesRecoveredCount"), CFSTR("OARKTotalTLKSharesCount"), CFSTR("OARKUniqueTLKsWithSharesCount"), CFSTR("OARKTLKUniqueViewCount"));

  objc_msgSend(WeakRetained, "setVoucher:", v11);
  objc_msgSend(WeakRetained, "setVoucherSig:", v12);
  if (!objc_msgSend(WeakRetained, "saveVoucher"))
  {
LABEL_13:
    v29 = sub_10000EF14("octagon");
    v30 = objc_claimAutoreleasedReturnValue(v29);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412546;
      v38 = v11;
      v39 = 2112;
      v40 = v12;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "Successfully vouched with a recovery key: %@, %@", buf, 0x16u);
    }

    v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "intendedState"));
    objc_msgSend(WeakRetained, "setNextState:", v31);

    goto LABEL_16;
  }
  v21 = sub_10000EF14("octagon");
  v22 = objc_claimAutoreleasedReturnValue(v21);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Saving voucher for later use...", buf, 2u);
  }

  v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
  v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v23, "stateHolder"));
  v33[0] = _NSConcreteStackBlock;
  v33[1] = 3221225472;
  v33[2] = sub_1000CF66C;
  v33[3] = &unk_1002DDD90;
  v34 = v11;
  v35 = v12;
  v36 = v13;
  v32 = 0;
  objc_msgSend(v24, "persistAccountChanges:error:", v33, &v32);
  v25 = v32;

  if (!v25)
  {

    goto LABEL_13;
  }
  v26 = sub_10000EF14("octagon");
  v27 = objc_claimAutoreleasedReturnValue(v26);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    v38 = v25;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "unable to save voucher: %@", buf, 0xCu);
  }

  v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishOp"));
  objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v28);

LABEL_17:
}

id sub_1000CF66C(_QWORD *a1, void *a2)
{
  id v3;

  v3 = a2;
  objc_msgSend(v3, "setVoucher:", a1[4]);
  objc_msgSend(v3, "setVoucherSignature:", a1[5]);
  objc_msgSend(v3, "setTLKSharesPairedWithVoucher:", a1[6]);
  return v3;
}

void sub_1000CF6B4(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id WeakRetained;
  void *v8;
  const void *v9;
  NSObject *v10;
  void *v11;
  id v12;
  id v13;
  id v14;
  uint64_t v15;
  void *i;
  void *v17;
  void *v18;
  unsigned int v19;
  CKKSTLKShareRecord *v20;
  void *v21;
  void *v22;
  CKKSTLKShareRecord *v23;
  void *v24;
  id v25;
  void *v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint8_t v31[128];
  uint8_t buf[4];
  id v33;

  v5 = a2;
  v6 = a3;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v8 = WeakRetained;
  if (v6)
  {
    v9 = sub_10000EF14("SecError");
    v10 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v33 = v6;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "octagon: Error fetching TLKShares to recover: %@", buf, 0xCu);
    }

    objc_msgSend(v8, "setError:", v6);
    v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "finishOp"));
    objc_msgSend(v8, "runBeforeGroupFinished:", v11);
  }
  else
  {
    v26 = WeakRetained;
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
    v27 = 0u;
    v28 = 0u;
    v29 = 0u;
    v30 = 0u;
    v25 = v5;
    v12 = v5;
    v13 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v27, v31, 16);
    if (v13)
    {
      v14 = v13;
      v15 = *(_QWORD *)v28;
      do
      {
        for (i = 0; i != v14; i = (char *)i + 1)
        {
          if (*(_QWORD *)v28 != v15)
            objc_enumerationMutation(v12);
          v17 = *(void **)(*((_QWORD *)&v27 + 1) + 8 * (_QWORD)i);
          v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "recordType"));
          v19 = objc_msgSend(v18, "isEqual:", CFSTR("tlkshare"));

          if (v19)
          {
            v20 = [CKKSTLKShareRecord alloc];
            v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "deps"));
            v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "contextID"));
            v23 = -[CKKSCKRecordHolder initWithCKRecord:contextID:](v20, "initWithCKRecord:contextID:", v17, v22);

            v24 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSTLKShareRecord share](v23, "share"));
            objc_msgSend(v11, "addObject:", v24);

          }
        }
        v14 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v27, v31, 16);
      }
      while (v14);
    }

    v8 = v26;
    objc_msgSend(v26, "proceedWithFilteredTLKShares:", v11);
    v6 = 0;
    v5 = v25;
  }

}

void sub_1000CF92C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  id WeakRetained;
  void *v11;
  const void *v12;
  NSObject *v13;
  void *v14;
  void *v15;
  const void *v16;
  NSObject *v17;
  void *v18;
  int v19;
  id v20;

  v7 = a2;
  v8 = a3;
  v9 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v11 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v11, "logResultForEvent:hardFailure:result:", CFSTR("OctagonEventPreflightVouchWithRecoveryKey"), 1, v9);

  if (!v7 || v9)
  {
    v16 = sub_10000EF14("SecError");
    v17 = objc_claimAutoreleasedReturnValue(v16);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      v19 = 138412290;
      v20 = v9;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "octagon: Error preflighting voucher using recovery key: %@", (uint8_t *)&v19, 0xCu);
    }

    objc_msgSend(WeakRetained, "setError:", v9);
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishOp"));
    objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v18);

  }
  else
  {
    v12 = sub_10000EF14("octagon");
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      v19 = 138412290;
      v20 = v7;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Recovery key ID %@ looks good to go", (uint8_t *)&v19, 0xCu);
    }

    v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "ckks"));
    objc_msgSend(v15, "setCurrentSyncingPolicy:", v8);

    objc_msgSend(WeakRetained, "proceedWithRecoveryKeyID:", v7);
  }

}

void sub_1000CFEF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  id *v15;

  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000D0054(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000D0258(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  id v11;
  id v12;
  id v13;
  id v14;
  id v15;
  id WeakRetained;
  void *v17;
  const void *v18;
  NSObject *v19;
  void *v20;
  const void *v21;
  NSObject *v22;
  void *v23;
  void *v24;
  id v25;
  const void *v26;
  NSObject *v27;
  void *v28;
  const void *v29;
  NSObject *v30;
  void *v31;
  id v32;
  _QWORD v33[4];
  id v34;
  id v35;
  id v36;
  uint8_t buf[4];
  id v38;
  __int16 v39;
  id v40;

  v11 = a2;
  v12 = a3;
  v13 = a4;
  v14 = a5;
  v15 = a6;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v17 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v17, "logResultForEvent:hardFailure:result:", CFSTR("OctagonEventVoucherWithReroll"), 1, v15);

  if (v15)
  {
    v18 = sub_10000EF14("SecError");
    v19 = objc_claimAutoreleasedReturnValue(v18);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v38 = v15;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "octagon: Error preparing voucher using reroll: %@", buf, 0xCu);
    }

    objc_msgSend(WeakRetained, "setError:", v15);
LABEL_16:
    v25 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishOp"));
    objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v25);
    goto LABEL_17;
  }
  v20 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v20, "recordRecoveredTLKMetrics:tlkRecoveryResults:uniqueTLKsRecoveredEvent:totalSharesRecoveredEvent:totalRecoverableTLKSharesEvent:totalRecoverableTLKsEvent:totalViewsWithSharesEvent:", *(_QWORD *)(a1 + 32), v14, CFSTR("OARKUniqueTLKsRecoveredCount"), CFSTR("OARKTotalTLKSharesRecoveredCount"), CFSTR("OARKTotalTLKSharesCount"), CFSTR("OARKUniqueTLKsWithSharesCount"), CFSTR("OARKTLKUniqueViewCount"));

  objc_msgSend(WeakRetained, "setVoucher:", v11);
  objc_msgSend(WeakRetained, "setVoucherSig:", v12);
  if (!objc_msgSend(WeakRetained, "saveVoucher"))
  {
LABEL_13:
    v29 = sub_10000EF14("octagon");
    v30 = objc_claimAutoreleasedReturnValue(v29);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412546;
      v38 = v11;
      v39 = 2112;
      v40 = v12;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "Successfully vouched with a reroll: %@, %@", buf, 0x16u);
    }

    v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "intendedState"));
    objc_msgSend(WeakRetained, "setNextState:", v31);

    goto LABEL_16;
  }
  v21 = sub_10000EF14("octagon");
  v22 = objc_claimAutoreleasedReturnValue(v21);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Saving voucher for later use...", buf, 2u);
  }

  v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
  v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v23, "stateHolder"));
  v33[0] = _NSConcreteStackBlock;
  v33[1] = 3221225472;
  v33[2] = sub_1000D0654;
  v33[3] = &unk_1002DDD90;
  v34 = v11;
  v35 = v12;
  v36 = v13;
  v32 = 0;
  objc_msgSend(v24, "persistAccountChanges:error:", v33, &v32);
  v25 = v32;

  if (!v25)
  {

    goto LABEL_13;
  }
  v26 = sub_10000EF14("octagon");
  v27 = objc_claimAutoreleasedReturnValue(v26);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    v38 = v25;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "unable to save voucher: %@", buf, 0xCu);
  }

  v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishOp"));
  objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v28);

LABEL_17:
}

id sub_1000D0654(_QWORD *a1, void *a2)
{
  id v3;

  v3 = a2;
  objc_msgSend(v3, "setVoucher:", a1[4]);
  objc_msgSend(v3, "setVoucherSignature:", a1[5]);
  objc_msgSend(v3, "setTLKSharesPairedWithVoucher:", a1[6]);
  return v3;
}

void sub_1000D069C(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  const void *v7;
  NSObject *v8;
  void *v9;
  id v10;
  id v11;
  id v12;
  uint64_t v13;
  void *i;
  void *v15;
  void *v16;
  unsigned int v17;
  CKKSTLKShareRecord *v18;
  void *v19;
  void *v20;
  CKKSTLKShareRecord *v21;
  void *v22;
  void *v23;
  id WeakRetained;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint8_t v29[128];
  uint8_t buf[4];
  id v31;

  v5 = a2;
  v6 = a3;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (v6)
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v31 = v6;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Error fetching TLKShares to recover: %@", buf, 0xCu);
    }

  }
  v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array", v6));
  v25 = 0u;
  v26 = 0u;
  v27 = 0u;
  v28 = 0u;
  v10 = v5;
  v11 = objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v25, v29, 16);
  if (v11)
  {
    v12 = v11;
    v13 = *(_QWORD *)v26;
    do
    {
      for (i = 0; i != v12; i = (char *)i + 1)
      {
        if (*(_QWORD *)v26 != v13)
          objc_enumerationMutation(v10);
        v15 = *(void **)(*((_QWORD *)&v25 + 1) + 8 * (_QWORD)i);
        v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "recordType"));
        v17 = objc_msgSend(v16, "isEqual:", CFSTR("tlkshare"));

        if (v17)
        {
          v18 = [CKKSTLKShareRecord alloc];
          v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
          v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "contextID"));
          v21 = -[CKKSCKRecordHolder initWithCKRecord:contextID:](v18, "initWithCKRecord:contextID:", v15, v20);

          v22 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSTLKShareRecord share](v21, "share"));
          objc_msgSend(v9, "addObject:", v22);

        }
      }
      v12 = objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v25, v29, 16);
    }
    while (v12);
  }

  objc_msgSend(WeakRetained, "proceedWithFilteredTLKShares:", v9);
}

void sub_1000D0D64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,id location)
{
  id *v23;
  id *v24;

  objc_destroyWeak(v24);
  objc_destroyWeak(v23);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000D0FF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  id *v17;

  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000D12D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000D1470(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  id *v17;

  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000D178C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  id *v17;

  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000D19DC(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 112), 8);
  _Unwind_Resume(a1);
}

void sub_1000D1D4C(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_1000D1F08(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 80));
  _Unwind_Resume(a1);
}

void sub_1000D203C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  id *v16;
  uint64_t v17;

  objc_destroyWeak(v16);
  _Block_object_dispose(&a16, 8);
  objc_destroyWeak((id *)(v17 - 40));
  _Unwind_Resume(a1);
}

void sub_1000D228C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 128), 8);
  _Unwind_Resume(a1);
}

void sub_1000D2780(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  uint64_t v33;

  _Block_object_dispose((const void *)(v33 - 160), 8);
  _Block_object_dispose(&a33, 8);
  _Unwind_Resume(a1);
}

void sub_1000D3760(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  _Block_object_dispose(&a23, 8);
  _Block_object_dispose(&a29, 8);
  _Unwind_Resume(a1);
}

void sub_1000D4084(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,id location)
{
  id *v25;

  objc_destroyWeak(v25);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000D7200(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_1000D7A0C(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "deviceDidLock");
}

void sub_1000D7A14(id *a1)
{
  void *v2;
  NSObject *v3;
  id v4;
  _QWORD block[4];
  id v6;
  id v7;
  id v8;

  v2 = (void *)os_transaction_create("com.apple.securityd.kcsharing.resync");
  v3 = objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "queue"));
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000D7C4C;
  block[3] = &unk_1002E97B8;
  v6 = v2;
  v4 = v2;
  objc_copyWeak(&v8, a1 + 6);
  v7 = a1[5];
  dispatch_sync(v3, block);

  objc_destroyWeak(&v8);
}

void sub_1000D7AF0(uint64_t a1)
{
  id WeakRetained;
  void *v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  void *v7;
  id v8;
  BOOL v9;
  uint64_t v10;
  void *v11;
  uint8_t v12[16];

  WeakRetained = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 48));
  v3 = WeakRetained;
  if (WeakRetained && objc_msgSend(WeakRetained, "isPending"))
  {
    v4 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v12 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Not setting up resync: have extant operation", v12, 2u);
    }

    v6 = *(_QWORD *)(a1 + 48);
    v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("KCSharingErrorDomain"), 37, 0));
    (*(void (**)(uint64_t, _QWORD, void *))(v6 + 16))(v6, 0, v7);
  }
  else
  {
    v8 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 32));
    v7 = v8;
    if (*(_BYTE *)(a1 + 56))
      v9 = v8 == 0;
    else
      v9 = 1;
    if (v9 || !objc_msgSend(v8, "isPending"))
    {
      objc_msgSend(*(id *)(a1 + 40), "addNullableDependency:", v7);
    }
    else
    {
      v10 = *(_QWORD *)(a1 + 48);
      v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("KCSharingErrorDomain"), 35, 0));
      (*(void (**)(uint64_t, _QWORD, void *))(v10 + 16))(v10, 0, v11);

    }
  }

}

void sub_1000D7C4C(uint64_t a1)
{
  id WeakRetained;
  void *v3;
  uint64_t v4;
  NSObject *v5;
  CFTypeRef v6;
  uint64_t v7;
  NSObject *v8;
  void *v9;
  unsigned __int8 v10;
  id v11;
  void *v12;
  void *v13;
  uint64_t v14;
  NSObject *v15;
  unsigned __int8 v16;
  id v17;
  uint64_t v18;
  NSObject *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  id v25;
  id v26;
  uint64_t v27;
  void *i;
  const void *v29;
  uint64_t v30;
  NSObject *v31;
  void *v32;
  void *v33;
  void *v34;
  id v35;
  id v36;
  uint64_t v37;
  void *j;
  const void *v39;
  uint64_t v40;
  NSObject *v41;
  void *v42;
  void *v43;
  uint64_t v44;
  NSObject *v45;
  uint64_t v46;
  NSObject *v47;
  CFTypeRef v48;
  uint64_t v49;
  uint64_t v50;
  void *v51;
  uint64_t v52;
  NSObject *v53;
  uint64_t v54;
  NSObject *v55;
  void (*v56)(void);
  uint64_t v57;
  NSObject *v58;
  void *v59;
  uint64_t v60;
  void *v61;
  _QWORD v62[4];
  id v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  id v72;
  id v73;
  CFTypeRef cf;
  _BYTE v75[128];
  uint8_t v76[128];
  uint8_t buf[4];
  CFTypeRef v78;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  v3 = WeakRetained;
  if (WeakRetained)
  {
    if (*((_QWORD *)WeakRetained + 10) && *((_QWORD *)WeakRetained + 11))
    {
      cf = 0;
      if (!sub_1000336A4(dword_1003414E0, &cf))
      {
        v4 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
        v5 = objc_claimAutoreleasedReturnValue(v4);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412290;
          v78 = cf;
          _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Unable to acquire AKS lock assertion: %@", buf, 0xCu);
        }

      }
      v6 = cf;
      if (cf)
      {
        cf = 0;
        CFRelease(v6);
      }
      v7 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
      v8 = objc_claimAutoreleasedReturnValue(v7);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Starting resync operation with merge", buf, 2u);
      }

      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "store"));
      v73 = 0;
      v10 = objc_msgSend(v9, "mergeWithError:", &v73);
      v11 = v73;

      if ((v10 & 1) == 0)
      {
        v52 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
        v53 = objc_claimAutoreleasedReturnValue(v52);
        if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412290;
          v78 = v11;
          _os_log_error_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_ERROR, "Failed resync during merge: %@", buf, 0xCu);
        }

        (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
        v17 = v11;
        goto LABEL_58;
      }
      v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
      v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
      v14 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
      v15 = objc_claimAutoreleasedReturnValue(v14);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Resync: obtaining list of groups from CloudKit", buf, 2u);
      }

      v72 = v11;
      v16 = objc_msgSend(v3, "obtainAuthoritativeGroupsForPrivate:shared:error:", v12, v13, &v72);
      v17 = v72;

      if ((v16 & 1) != 0)
      {
        if (objc_msgSend(v12, "count") || objc_msgSend(v13, "count"))
        {
          v61 = v13;
          objc_msgSend(v3, "setCurrentUserMetadataFeatureUsage:", 2, v17);
          v18 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
          v19 = objc_claimAutoreleasedReturnValue(v18);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Resync: setting change tokens to nil", buf, 2u);
          }
          v60 = a1;

          v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "privateSyncEngine"));
          v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "state"));
          objc_msgSend(v21, "setServerChangeTokenForDatabase:", 0);

          v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "sharedSyncEngine"));
          v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "state"));
          objc_msgSend(v23, "setServerChangeTokenForDatabase:", 0);

          v70 = 0u;
          v71 = 0u;
          v68 = 0u;
          v69 = 0u;
          v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "allKeys"));
          v25 = objc_msgSend(v24, "countByEnumeratingWithState:objects:count:", &v68, v76, 16);
          if (v25)
          {
            v26 = v25;
            v27 = *(_QWORD *)v69;
            do
            {
              for (i = 0; i != v26; i = (char *)i + 1)
              {
                if (*(_QWORD *)v69 != v27)
                  objc_enumerationMutation(v24);
                v29 = *(const void **)(*((_QWORD *)&v68 + 1) + 8 * (_QWORD)i);
                v30 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
                v31 = objc_claimAutoreleasedReturnValue(v30);
                if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 138412290;
                  v78 = v29;
                  _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "Setting private DB change token to nil for zoneID %@", buf, 0xCu);
                }

                v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "privateSyncEngine"));
                v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v32, "state"));
                objc_msgSend(v33, "setServerChangeToken:forZoneID:", 0, v29);

              }
              v26 = objc_msgSend(v24, "countByEnumeratingWithState:objects:count:", &v68, v76, 16);
            }
            while (v26);
          }

          v66 = 0u;
          v67 = 0u;
          v64 = 0u;
          v65 = 0u;
          v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v61, "allKeys"));
          v35 = objc_msgSend(v34, "countByEnumeratingWithState:objects:count:", &v64, v75, 16);
          if (v35)
          {
            v36 = v35;
            v37 = *(_QWORD *)v65;
            do
            {
              for (j = 0; j != v36; j = (char *)j + 1)
              {
                if (*(_QWORD *)v65 != v37)
                  objc_enumerationMutation(v34);
                v39 = *(const void **)(*((_QWORD *)&v64 + 1) + 8 * (_QWORD)j);
                v40 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
                v41 = objc_claimAutoreleasedReturnValue(v40);
                if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 138412290;
                  v78 = v39;
                  _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "Setting shared DB change token to nil for zoneID %@", buf, 0xCu);
                }

                v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "sharedSyncEngine"));
                v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v42, "state"));
                objc_msgSend(v43, "setServerChangeToken:forZoneID:", 0, v39);

              }
              v36 = objc_msgSend(v34, "countByEnumeratingWithState:objects:count:", &v64, v75, 16);
            }
            while (v36);
          }

          v44 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
          v45 = objc_claimAutoreleasedReturnValue(v44);
          if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "Resync: kicking off full CK fetch", buf, 2u);
          }

          v62[0] = _NSConcreteStackBlock;
          v62[1] = 3221225472;
          v62[2] = sub_1000D84B4;
          v62[3] = &unk_1002DEF60;
          v63 = *(id *)(v60 + 40);
          objc_msgSend(v3, "_onQueueFetchRemoteChangesForZoneIDs:completion:", 0, v62);
          v17 = v59;
          if (!sub_10003384C(dword_1003414E0, &cf))
          {
            v46 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
            v47 = objc_claimAutoreleasedReturnValue(v46);
            if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 138412290;
              v78 = cf;
              _os_log_error_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "Failed to drop AKS lock assertion: %@", buf, 0xCu);
            }

          }
          v48 = cf;
          v13 = v61;
          if (cf)
          {
            cf = 0;
            CFRelease(v48);
          }

          goto LABEL_57;
        }
        v57 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
        v58 = objc_claimAutoreleasedReturnValue(v57);
        if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "CloudKit reports no private and no shared groups, returning early from resync", buf, 2u);
        }

        objc_msgSend(v3, "setCurrentUserMetadataFeatureUsage:", 1);
        v56 = *(void (**)(void))(*(_QWORD *)(a1 + 40) + 16);
      }
      else
      {
        v54 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
        v55 = objc_claimAutoreleasedReturnValue(v54);
        if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412290;
          v78 = v17;
          _os_log_error_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, "Cannot resync due to failure to fetch all CK groups: %@", buf, 0xCu);
        }

        v56 = *(void (**)(void))(*(_QWORD *)(a1 + 40) + 16);
      }
      v56();
LABEL_57:

LABEL_58:
      goto LABEL_59;
    }
    v49 = *(_QWORD *)(a1 + 40);
    v50 = 36;
  }
  else
  {
    v49 = *(_QWORD *)(a1 + 40);
    v50 = 14;
  }
  v51 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("KCSharingErrorDomain"), v50, 0));
  (*(void (**)(uint64_t, _QWORD, void *))(v49 + 16))(v49, 0, v51);

LABEL_59:
}

void sub_1000D84B4(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  int v7;
  id v8;

  v3 = a2;
  v4 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
  v5 = objc_claimAutoreleasedReturnValue(v4);
  v6 = v5;
  if (v3)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v7 = 138412290;
      v8 = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Resync failed: %@", (uint8_t *)&v7, 0xCu);
    }
  }
  else if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v7) = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Resync complete", (uint8_t *)&v7, 2u);
  }

  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t sub_1000D85D8(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_1000D85E8(uint64_t a1)
{

}

void sub_1000D85F0(uint64_t a1, void *a2, void *a3)
{
  id v4;
  id v5;
  id v6;
  uint64_t v7;
  NSObject *v8;
  id v9;
  id v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  unsigned __int8 v17;
  uint64_t v18;
  NSObject *v19;
  NSObject *v20;
  const char *v21;
  uint64_t v22;
  void *v23;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint8_t v29[128];
  uint8_t buf[4];
  void *v31;

  v4 = a2;
  v5 = a3;
  v23 = v5;
  if (!v5)
  {
    v27 = 0u;
    v28 = 0u;
    v25 = 0u;
    v26 = 0u;
    v9 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v25, v29, 16, 0);
    if (!v9)
      goto LABEL_21;
    v10 = v9;
    v11 = *(_QWORD *)v26;
LABEL_7:
    v12 = 0;
    while (1)
    {
      if (*(_QWORD *)v26 != v11)
        objc_enumerationMutation(v4);
      v13 = *(void **)(*((_QWORD *)&v25 + 1) + 8 * v12);
      v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "objectForKeyedSubscript:", v13));
      v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "share"));

      if (!v15)
        break;
      v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "zoneName"));
      v17 = objc_msgSend(v16, "hasPrefix:", CFSTR("group-"));

      if ((v17 & 1) == 0)
      {
        v22 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
        v19 = objc_claimAutoreleasedReturnValue(v22);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138543362;
          v31 = v14;
          v20 = v19;
          v21 = "Ignoring Private DB CKRecordZone with non-group zoneID: %{public}@";
LABEL_17:
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v21, buf, 0xCu);
        }
        goto LABEL_18;
      }
      objc_msgSend(*(id *)(a1 + 40), "setObject:forKeyedSubscript:", v14, v13);
LABEL_19:

      if (v10 == (id)++v12)
      {
        v10 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v25, v29, 16);
        if (!v10)
          goto LABEL_21;
        goto LABEL_7;
      }
    }
    v18 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
    v19 = objc_claimAutoreleasedReturnValue(v18);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138543362;
      v31 = v14;
      v20 = v19;
      v21 = "Ignoring Private DB CKRecordZone without a CKShare: %{public}@";
      goto LABEL_17;
    }
LABEL_18:

    goto LABEL_19;
  }
  v6 = v5;
  v7 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
  v8 = objc_claimAutoreleasedReturnValue(v7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 138543362;
    v31 = v6;
    _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to fetch record zones from Private DB: %{public}@", buf, 0xCu);
  }

  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40), a3);
LABEL_21:
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));

}

void sub_1000D88B0(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id v7;
  uint64_t v8;
  NSObject *v9;
  id v10;
  id v11;
  uint64_t v12;
  void *i;
  void *v14;
  void *v15;
  unsigned __int8 v16;
  NSObject *v17;
  uint64_t v18;
  void *v19;
  void *v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint8_t v25[128];
  uint8_t buf[4];
  void *v27;

  v5 = a2;
  v6 = a3;
  v20 = v6;
  if (v6)
  {
    v7 = v6;
    v8 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
    v9 = objc_claimAutoreleasedReturnValue(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543362;
      v27 = v7;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to fetch record zones from Shared DB: %{public}@", buf, 0xCu);
    }

    objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40), a3);
  }
  else
  {
    v23 = 0u;
    v24 = 0u;
    v21 = 0u;
    v22 = 0u;
    v10 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v21, v25, 16);
    if (v10)
    {
      v11 = v10;
      v12 = *(_QWORD *)v22;
      do
      {
        for (i = 0; i != v11; i = (char *)i + 1)
        {
          if (*(_QWORD *)v22 != v12)
            objc_enumerationMutation(v5);
          v14 = *(void **)(*((_QWORD *)&v21 + 1) + 8 * (_QWORD)i);
          v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "zoneName"));
          v16 = objc_msgSend(v15, "hasPrefix:", CFSTR("group-"));

          if ((v16 & 1) != 0)
          {
            v17 = objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", v14));
            objc_msgSend(*(id *)(a1 + 40), "setObject:forKeyedSubscript:", v17, v14);
          }
          else
          {
            v18 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
            v17 = objc_claimAutoreleasedReturnValue(v18);
            if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
            {
              v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", v14));
              *(_DWORD *)buf = 138543362;
              v27 = v19;
              _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Ignoring Shared DB CKRecordZone with non-group zoneID: %{public}@", buf, 0xCu);

            }
          }

        }
        v11 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v21, v25, 16);
      }
      while (v11);
    }
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));

}

void sub_1000D8B18(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  id v12;

  v3 = a2;
  v4 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
  v5 = objc_claimAutoreleasedReturnValue(v4);
  v6 = v5;
  if (v3)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v7 = *(_QWORD *)(a1 + 32);
      v9 = 138412546;
      v10 = v7;
      v11 = 2112;
      v12 = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "ksmd errored sending new invites for group %@: %@", (uint8_t *)&v9, 0x16u);
    }
  }
  else if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v8 = *(_QWORD *)(a1 + 32);
    v9 = 138412290;
    v10 = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "ksmd sent new invites if needed for group %@", (uint8_t *)&v9, 0xCu);
  }

}

void sub_1000D8C30(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  id v6;

  v6 = a2;
  if (v6)
  {
    v3 = *(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40);
    objc_sync_enter(v3);
    objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40), "addObject:", v6);
    objc_sync_exit(v3);

    v4 = *(void **)(a1 + 32);
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "privateSyncEngine"));
    objc_msgSend(v4, "isLockedError:duringFetchForEngine:", v6, v5);

  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));

}

void sub_1000D8CD4(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000D8CE8(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  id v6;

  v6 = a2;
  if (v6)
  {
    v3 = *(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40);
    objc_sync_enter(v3);
    objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40), "addObject:", v6);
    objc_sync_exit(v3);

    v4 = *(void **)(a1 + 32);
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "sharedSyncEngine"));
    objc_msgSend(v4, "isLockedError:duringFetchForEngine:", v6, v5);

  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));

}

void sub_1000D8D8C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000D8DA0(_QWORD *a1)
{
  uint64_t v2;
  NSObject *v3;
  id v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  NSErrorUserInfoKey v14;
  id v15;

  if (*(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 40))
  {
LABEL_2:
    v2 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
    v3 = objc_claimAutoreleasedReturnValue(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v11 = *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 40);
      v12 = 138543362;
      v13 = v11;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Failed to force-fetch remote changes: %{public}@", (uint8_t *)&v12, 0xCu);
    }
    goto LABEL_4;
  }
  if (objc_msgSend(*(id *)(*(_QWORD *)(a1[6] + 8) + 40), "count"))
  {
    if (!*(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 40))
    {
      v14 = NSMultipleUnderlyingErrorsKey;
      v5 = objc_msgSend(*(id *)(*(_QWORD *)(a1[6] + 8) + 40), "copy");
      v15 = v5;
      v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v15, &v14, 1));
      v7 = objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("KCSharingErrorDomain"), 14, v6));
      v8 = *(_QWORD *)(a1[5] + 8);
      v9 = *(void **)(v8 + 40);
      *(_QWORD *)(v8 + 40) = v7;

    }
    goto LABEL_2;
  }
  v10 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
  v3 = objc_claimAutoreleasedReturnValue(v10);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v12) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Force-fetch remote changes complete", (uint8_t *)&v12, 2u);
  }
LABEL_4:

  return (*(uint64_t (**)(void))(a1[4] + 16))();
}

id sub_1000D8F7C(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "_onQueueFetchRemoteChangesForZoneIDs:completion:", *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48));
}

void sub_1000D8F8C(uint64_t a1, void *a2)
{
  id v3;
  id v4;

  v4 = a2;
  if (v4)
  {
    v3 = *(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
    objc_sync_enter(v3);
    objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), "addObject:", v4);
    objc_sync_exit(v3);

  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));

}

void sub_1000D9000(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000D9014(uint64_t a1, void *a2)
{
  id v3;
  id v4;

  v4 = a2;
  if (v4)
  {
    v3 = *(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
    objc_sync_enter(v3);
    objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), "addObject:", v4);
    objc_sync_exit(v3);

  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));

}

void sub_1000D9088(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000D909C(uint64_t a1)
{
  id v2;
  void *v3;
  void *v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  int v8;
  void *v9;
  NSErrorUserInfoKey v10;
  id v11;

  if (objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), "count"))
  {
    v10 = NSMultipleUnderlyingErrorsKey;
    v2 = objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), "copy");
    v11 = v2;
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v11, &v10, 1));
    v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("KCSharingErrorDomain"), 14, v3));

    v5 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
    v6 = objc_claimAutoreleasedReturnValue(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v8 = 138543362;
      v9 = v4;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Failed to save local changes: %{public}@", (uint8_t *)&v8, 0xCu);
    }
  }
  else
  {
    v7 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
    v6 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      LOWORD(v8) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "Saved local changes", (uint8_t *)&v8, 2u);
    }
    v4 = 0;
  }

  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_1000D9238(uint64_t a1)
{
  id WeakRetained;
  uint64_t v3;
  NSObject *v4;
  void *v5;
  unsigned __int8 v6;
  id v7;
  uint64_t v8;
  NSObject *v9;
  void *v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  id v15;
  id v16;
  uint8_t buf[4];
  id v18;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    v3 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
    v4 = objc_claimAutoreleasedReturnValue(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Staging all outgoing changes", buf, 2u);
    }

    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "store"));
    v16 = 0;
    v6 = objc_msgSend(v5, "stageAllOutgoingChangesWithError:", &v16);
    v7 = v16;

    if ((v6 & 1) != 0)
    {
      v8 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
      v9 = objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "Triggering syncs for private and shared databases after staging changes", buf, 2u);
      }

      v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "privateSyncEngine"));
      objc_msgSend(v10, "setHasPendingModifications");

      v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "sharedSyncEngine"));
      objc_msgSend(v11, "setHasPendingModifications");
    }
    else
    {
      objc_msgSend(WeakRetained, "isLockedError:", v7);
      v12 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
      v13 = objc_claimAutoreleasedReturnValue(v12);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138543362;
        v18 = v7;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Failed to stage outgoing changes: %{public}@", buf, 0xCu);
      }

      v14 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v15 = v7;
      v11 = *(void **)(v14 + 40);
      *(_QWORD *)(v14 + 40) = v15;
    }

  }
}

void sub_1000D942C(uint64_t a1)
{
  id WeakRetained;
  uint64_t v3;
  NSObject *v4;
  _QWORD v5[5];
  id v6;
  uint8_t buf[16];

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    v3 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
    v4 = objc_claimAutoreleasedReturnValue(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Performing KCSharing maintenance now", buf, 2u);
    }

    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    v5[2] = sub_1000D9610;
    v5[3] = &unk_1002DE4E0;
    v5[4] = WeakRetained;
    v6 = *(id *)(a1 + 32);
    objc_msgSend(WeakRetained, "saveAllOutgoingChangesWithCompletion:", v5);

  }
}

void sub_1000D9508(uint64_t a1)
{
  id WeakRetained;
  void *v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  void *v7;
  void *v8;
  id v9;
  uint8_t v10[16];

  WeakRetained = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 40));
  v3 = WeakRetained;
  if (WeakRetained && objc_msgSend(WeakRetained, "isPending"))
  {
    v4 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v10 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Not setting up maintenance: have extant operation", v10, 2u);
    }

    v6 = *(_QWORD *)(a1 + 48);
    v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("KCSharingErrorDomain"), 37, 0));
    (*(void (**)(uint64_t, void *))(v6 + 16))(v6, v7);

  }
  else
  {
    objc_storeWeak((id *)(*(_QWORD *)(a1 + 32) + 40), *(id *)(a1 + 40));
    v8 = *(void **)(a1 + 40);
    v9 = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 32));
    objc_msgSend(v8, "addNullableDependency:", v9);

  }
}

void sub_1000D9610(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  NSObject *v5;
  uint8_t v6[16];

  v3 = a2;
  if (objc_msgSend(*(id *)(a1 + 32), "isLockedError:", v3))
  {
    v4 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Failed to complete maintenance due to lockstate, rescheduling", v6, 2u);
    }

    objc_msgSend(*(id *)(a1 + 32), "performMaintenanceWithCompletion:", *(_QWORD *)(a1 + 40));
  }
  else
  {
    (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
  }

}

void sub_1000D96C0(uint64_t a1, void *a2)
{
  id WeakRetained;
  void *v4;
  void (*v5)(void);
  uint64_t v6;
  id v7;

  v7 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v4 = WeakRetained;
  if (v7)
  {
    v5 = *(void (**)(void))(*(_QWORD *)(a1 + 32) + 16);
  }
  else
  {
    v6 = *(_QWORD *)(a1 + 32);
    if (WeakRetained)
    {
      objc_msgSend(WeakRetained, "saveStagedOutgoingChangesWithCompletion:", v6);
      goto LABEL_6;
    }
    v5 = *(void (**)(void))(v6 + 16);
  }
  v5();
LABEL_6:

}

void sub_1000D9738(id a1, NSError *a2)
{
  NSError *v2;
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  int v6;
  NSError *v7;

  v2 = a2;
  v3 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
  v4 = objc_claimAutoreleasedReturnValue(v3);
  v5 = v4;
  if (v2)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v6 = 138412290;
      v7 = v2;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to process KCSharing-relevant SecDb modifications: %@", (uint8_t *)&v6, 0xCu);
    }
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v6) = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Processed KCSharing-relevant SecDb modifications", (uint8_t *)&v6, 2u);
  }

}

void sub_1000D9824(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  NSObject *v6;
  id v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  _QWORD v24[4];
  int8x16_t v25;
  _QWORD v26[5];
  int8x16_t v27;
  uint8_t buf[8];
  void *v29;
  id v30;
  NSErrorUserInfoKey v31;
  uint64_t v32;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "privateSyncEngine"));

  if (v2)
  {
    v3 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
    v4 = objc_claimAutoreleasedReturnValue(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Provisioning user.", buf, 2u);
    }

    if ((objc_msgSend(*(id *)(a1 + 32), "isCurrentUserProvisioned") & 1) == 0)
    {
      v5 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
      v6 = objc_claimAutoreleasedReturnValue(v5);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Provisioning user's Manatee identity.", buf, 2u);
      }

      dispatch_group_enter(*(dispatch_group_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40));
      v7 = objc_msgSend(objc_alloc((Class)CKRecordZone), "initWithZoneName:", CFSTR("pv"));
      v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "privateSyncEngine"));
      v30 = v7;
      v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v30, 1));
      objc_msgSend(v8, "addRecordZonesToSave:recordZoneIDsToDelete:", v9, 0);

      v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "privateSyncEngine"));
      v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "zoneID"));
      v29 = v11;
      v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v29, 1));
      v26[0] = _NSConcreteStackBlock;
      v26[1] = 3221225472;
      v26[2] = sub_1000D9BA0;
      v26[3] = &unk_1002DD580;
      v26[4] = *(_QWORD *)(a1 + 32);
      v27 = vextq_s8(*(int8x16_t *)(a1 + 48), *(int8x16_t *)(a1 + 48), 8uLL);
      objc_msgSend(v10, "modifyPendingChangesInZoneIDs:completionHandler:", v12, v26);

    }
    if ((objc_msgSend(*(id *)(a1 + 32), "isCurrentUserIdentifierAvailable") & 1) == 0)
    {
      v13 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
      v14 = objc_claimAutoreleasedReturnValue(v13);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Fetching current user identifier.", buf, 2u);
      }

      dispatch_group_enter(*(dispatch_group_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40));
      v15 = *(void **)(a1 + 32);
      v24[0] = _NSConcreteStackBlock;
      v24[1] = 3221225472;
      v24[2] = sub_1000D9CB4;
      v24[3] = &unk_1002DD5A8;
      v25 = vextq_s8(*(int8x16_t *)(a1 + 48), *(int8x16_t *)(a1 + 48), 8uLL);
      objc_msgSend(v15, "fetchCurrentUserIdentifierWithReply:", v24);
    }
  }
  else
  {
    v16 = objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("KCSharingErrorDomain"), 35, 0));
    v17 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v18 = *(void **)(v17 + 40);
    *(_QWORD *)(v17 + 40) = v16;

    v19 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
    v31 = NSUnderlyingErrorKey;
    v32 = v19;
    v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v32, &v31, 1));
    v21 = objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("KCSharingErrorDomain"), 33, v20));
    v22 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v23 = *(void **)(v22 + 40);
    *(_QWORD *)(v22 + 40) = v21;

  }
}

void sub_1000D9BA0(_QWORD *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  unsigned __int8 v6;
  id v7;
  id v8;

  v3 = a2;
  if (v3)
  {
    v4 = *(id *)(*(_QWORD *)(a1[5] + 8) + 40);
    objc_sync_enter(v4);
    objc_msgSend(*(id *)(*(_QWORD *)(a1[5] + 8) + 40), "addObject:", v3);
    objc_sync_exit(v4);
  }
  else
  {
    v5 = (void *)a1[4];
    v8 = 0;
    v6 = objc_msgSend(v5, "updateCurrentUserMetadataForKey:toValue:withError:", CFSTR("pv"), &__kCFBooleanTrue, &v8);
    v4 = v8;
    if ((v6 & 1) == 0)
    {
      v7 = *(id *)(*(_QWORD *)(a1[5] + 8) + 40);
      objc_sync_enter(v7);
      objc_msgSend(*(id *)(*(_QWORD *)(a1[5] + 8) + 40), "addObject:", v4);
      objc_sync_exit(v7);

    }
  }

  dispatch_group_leave(*(dispatch_group_t *)(*(_QWORD *)(a1[6] + 8) + 40));
}

void sub_1000D9C94(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000D9CB4(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id v7;

  v7 = a2;
  v5 = a3;
  if (v5)
  {
    v6 = *(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
    objc_sync_enter(v6);
    objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), "addObject:", v5);
    objc_sync_exit(v6);

  }
  dispatch_group_leave(*(dispatch_group_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40));

}

void sub_1000D9D48(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000D9D5C(uint64_t a1)
{
  id WeakRetained;
  _QWORD v3[4];
  id v4;
  id v5;
  id v6;
  char v7;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_1000D9DFC;
    v3[3] = &unk_1002DD530;
    v4 = *(id *)(a1 + 32);
    v7 = *(_BYTE *)(a1 + 56);
    v5 = *(id *)(a1 + 40);
    v6 = WeakRetained;
    objc_msgSend(WeakRetained, "ensureCurrentUserProvisionedWithCompletion:", v3);

  }
}

void sub_1000D9DFC(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  int v10;
  uint64_t v11;

  v3 = a2;
  v4 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
  v5 = objc_claimAutoreleasedReturnValue(v4);
  v6 = v5;
  if (v3)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v10 = 138412290;
      v11 = (uint64_t)v3;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Failed to provision current user with error=%@", (uint8_t *)&v10, 0xCu);
    }
    v7 = 3;
  }
  else
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v10) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Successfully provisioned current user", (uint8_t *)&v10, 2u);
    }
    v7 = 0;
  }

  if (!*(_BYTE *)(a1 + 56) && (xpc_activity_set_completion_status(*(_QWORD *)(a1 + 40), v7) & 1) == 0)
  {
    v8 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
    v9 = objc_claimAutoreleasedReturnValue(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v10 = 134217984;
      v11 = v7;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to set completion status=%ld for provisioning activity", (uint8_t *)&v10, 0xCu);
    }

  }
  objc_msgSend(*(id *)(a1 + 48), "unregisterProvisioningActivity");
  if (v3)
    objc_msgSend(*(id *)(a1 + 48), "handleProvisioningActivity:isRetry:", *(_QWORD *)(a1 + 40), 1);

}

id sub_1000D9F8C(uint64_t a1, uint64_t a2)
{
  return objc_msgSend(*(id *)(a1 + 32), "handleProvisioningActivity:isRetry:", a2, 0);
}

void sub_1000D9F9C(id *a1)
{
  void *v2;
  NSObject *v3;
  id v4;
  _QWORD block[4];
  id v6;
  id v7;
  id v8;

  v2 = (void *)os_transaction_create("com.apple.securityd.kcsharing.preflight");
  v3 = objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "queue"));
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000DA078;
  block[3] = &unk_1002E97B8;
  v6 = v2;
  v4 = v2;
  objc_copyWeak(&v8, a1 + 6);
  v7 = a1[5];
  dispatch_async(v3, block);

  objc_destroyWeak(&v8);
}

void sub_1000DA078(uint64_t a1)
{
  id WeakRetained;
  void *v3;
  uint64_t v4;
  void *v5;
  void *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  CFTypeRef v11;
  uint64_t v12;
  NSObject *v13;
  void *v14;
  unsigned __int8 v15;
  id v16;
  uint64_t v17;
  NSObject *v18;
  NSObject *v19;
  void *v20;
  void *v21;
  void *v22;
  unsigned int v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  unsigned int v28;
  void *v29;
  unsigned int v30;
  uint64_t v31;
  NSObject *v32;
  _BOOL4 v33;
  uint64_t v34;
  NSObject *v35;
  unsigned int v36;
  uint64_t v37;
  NSObject *v38;
  _BOOL4 v39;
  uint64_t v40;
  void *v41;
  uint64_t v42;
  uint64_t v43;
  NSObject *v44;
  CFTypeRef v45;
  uint64_t v46;
  NSObject *v47;
  id v48;
  CFTypeRef cf;
  uint8_t buf[4];
  CFTypeRef v51;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  v3 = WeakRetained;
  if (WeakRetained)
  {
    v4 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "privateSyncEngine"));
    if (v4
      && (v5 = (void *)v4,
          v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "sharedSyncEngine")),
          v6,
          v5,
          v6))
    {
      v7 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
      v8 = objc_claimAutoreleasedReturnValue(v7);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Starting preflight", buf, 2u);
      }

      cf = 0;
      if (!sub_1000336A4(dword_1003414E0, &cf))
      {
        v9 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
        v10 = objc_claimAutoreleasedReturnValue(v9);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412290;
          v51 = cf;
          _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Unable to acquire AKS lock assertion: %@", buf, 0xCu);
        }

        v11 = cf;
        if (cf)
        {
          cf = 0;
          CFRelease(v11);
        }
      }
      v12 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
      v13 = objc_claimAutoreleasedReturnValue(v12);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, "Merging pending incoming changes during preflight", buf, 2u);
      }

      v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "store"));
      v48 = 0;
      v15 = objc_msgSend(v14, "mergeWithError:", &v48);
      v16 = v48;

      v17 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
      v18 = objc_claimAutoreleasedReturnValue(v17);
      v19 = v18;
      if ((v15 & 1) != 0)
      {
        if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "Checking for pending outgoing changes during preflight", buf, 2u);
        }

        v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "store"));
        v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "privateSyncEngine"));
        v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "database"));
        v23 = objc_msgSend(v20, "hasOutgoingChangesInDatabaseWithScope:", objc_msgSend(v22, "databaseScope"));

        if (v23)
        {
          v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "privateSyncEngine"));
          objc_msgSend(v24, "setHasPendingModifications");

        }
        v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "store"));
        v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "sharedSyncEngine"));
        v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "database"));
        v28 = objc_msgSend(v25, "hasOutgoingChangesInDatabaseWithScope:", objc_msgSend(v27, "databaseScope"));

        if (v28)
        {
          v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "sharedSyncEngine"));
          objc_msgSend(v29, "setHasPendingModifications");

        }
        v30 = objc_msgSend(v3, "isCurrentUserProvisioned");
        v31 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
        v32 = objc_claimAutoreleasedReturnValue(v31);
        v33 = os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT);
        if (v30)
        {
          if (v33)
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "Not registering provisioning activity; user already provisioned",
              buf,
              2u);
          }

        }
        else
        {
          if (v33)
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "Registering provisioning activity", buf, 2u);
          }

          objc_msgSend(v3, "registerProvisioningActivity");
        }
        if (!sub_10003384C(dword_1003414E0, &cf))
        {
          v43 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
          v44 = objc_claimAutoreleasedReturnValue(v43);
          if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412290;
            v51 = cf;
            _os_log_error_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "Failed to drop AKS lock assertion: %@", buf, 0xCu);
          }

          v45 = cf;
          if (cf)
          {
            cf = 0;
            CFRelease(v45);
          }
        }
        v46 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
        v47 = objc_claimAutoreleasedReturnValue(v46);
        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "Preflight complete", buf, 2u);
        }

        (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
      }
      else
      {
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412290;
          v51 = v16;
          _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Preflight error during merge: %@", buf, 0xCu);
        }

        v36 = objc_msgSend(v3, "isLockedError:", v16);
        v37 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
        v38 = objc_claimAutoreleasedReturnValue(v37);
        v39 = os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT);
        if (v36)
        {
          if (v39)
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "Rescheduling preflight for next unlock", buf, 2u);
          }

          v40 = *(_QWORD *)(a1 + 40);
          v41 = v3;
          v42 = 0;
        }
        else
        {
          if (v39)
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "Rescheduling preflight with delay", buf, 2u);
          }

          v40 = *(_QWORD *)(a1 + 40);
          v41 = v3;
          v42 = 1;
        }
        objc_msgSend(v41, "preflightWithCompletion:delay:", v40, v42);
      }

    }
    else
    {
      v34 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
      v35 = objc_claimAutoreleasedReturnValue(v34);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "Deferring preflight because engines aren't loaded", buf, 2u);
      }

      objc_msgSend(v3, "preflightWithCompletion:delay:", *(_QWORD *)(a1 + 40), 0);
    }
  }
  else
  {
    (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
  }

}

void sub_1000DA67C(uint64_t a1)
{
  _BYTE *WeakRetained;
  _BYTE *v3;
  void *v4;
  void *v5;
  id v6;
  uint64_t v7;
  NSObject *v8;
  void *v9;
  int v10;
  id v11;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v3 = WeakRetained;
  if (WeakRetained)
  {
    objc_msgSend(WeakRetained, "deviceDidLock");
    v4 = *(void **)(a1 + 32);
    if (v4)
    {
      objc_msgSend(v4, "cancelOperationsWithCompletionHandler:", &stru_1002DD4E0);
      v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "database"));
      v6 = objc_msgSend(v5, "databaseScope");

      if (v6 == (id)3)
      {
        v3[9] = 1;
      }
      else if (v6 == (id)2)
      {
        v3[8] = 1;
      }
      else
      {
        v7 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
        v8 = objc_claimAutoreleasedReturnValue(v7);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "database"));
          v10 = 134217984;
          v11 = objc_msgSend(v9, "databaseScope");
          _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Very unusual database scope: %ld", (uint8_t *)&v10, 0xCu);

        }
      }
    }
  }

}

void sub_1000DA7C0(uint64_t a1)
{
  NSObject *v2;
  _QWORD block[4];
  id v4;

  v2 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "queue"));
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000DA854;
  block[3] = &unk_1002EB598;
  objc_copyWeak(&v4, (id *)(a1 + 40));
  dispatch_sync(v2, block);

  objc_destroyWeak(&v4);
}

void sub_1000DA854(uint64_t a1)
{
  _QWORD *WeakRetained;
  id v2;
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  NSObject *v6;
  void *v7;
  void *v8;
  NSObject *v9;
  uint64_t v10;
  NSObject *v11;
  id v12;
  void *v13;
  id v14;
  void *v15;
  void *v16;
  uint64_t v17;
  NSObject *v18;
  id v19;
  void *v20;
  id v21;
  xpc_object_t empty;
  id v23;
  void *v24;
  id v25;
  void *v26;
  uint64_t v27;
  NSObject *v28;
  uint64_t v29;
  NSObject *v30;
  id v31;
  id v32;
  uint8_t buf[4];
  NSObject *v34;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v2 = WeakRetained;
  if (WeakRetained)
  {
    if (WeakRetained[10] && WeakRetained[11])
    {
      v3 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
      v4 = objc_claimAutoreleasedReturnValue(v3);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Not reinitializing sync engines, they are already instantiated", buf, 2u);
      }
    }
    else
    {
      v5 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
      v6 = objc_claimAutoreleasedReturnValue(v5);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "(Re)initializing sync engines", buf, 2u);
      }

      v7 = (void *)*((_QWORD *)v2 + 8);
      v32 = 0;
      v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "fetchValueForMetadataKey:error:", CFSTR("CKSyncEnginePrivateMetadata"), &v32));
      v9 = v32;
      if (v9)
      {
        v4 = v9;
        v10 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
        v11 = objc_claimAutoreleasedReturnValue(v10);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138543362;
          v34 = v4;
          _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Failed to fetch private engine metadata: %{public}@", buf, 0xCu);
        }

        if ((objc_msgSend(v2, "isLockedError:", v4) & 1) == 0)
          objc_msgSend(v2, "resetReinitOperationWithDelay:", 1);
      }
      else
      {
        v12 = objc_alloc((Class)CKSyncEngineConfiguration);
        v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*((id *)v2 + 9), "privateCloudDatabase"));
        v14 = objc_msgSend(v12, "initWithDatabase:dataSource:metadata:", v13, v2, v8);

        v15 = (void *)*((_QWORD *)v2 + 8);
        v31 = 0;
        v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "fetchValueForMetadataKey:error:", CFSTR("CKSyncEngineSharedMetadata"), &v31));
        v4 = v31;
        if (v4)
        {
          v17 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
          v18 = objc_claimAutoreleasedReturnValue(v17);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138543362;
            v34 = v4;
            _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Failed to fetch shared engine metadata: %{public}@", buf, 0xCu);
          }

          if ((objc_msgSend(v2, "isLockedError:", v4) & 1) == 0)
            objc_msgSend(v2, "resetReinitOperationWithDelay:", 1);
        }
        else
        {
          v19 = objc_alloc((Class)CKSyncEngineConfiguration);
          v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*((id *)v2 + 9), "sharedCloudDatabase"));
          v21 = objc_msgSend(v19, "initWithDatabase:dataSource:metadata:", v20, v2, v16);

          objc_msgSend(v14, "setApsMachServiceName:", CFSTR("com.apple.securityd.aps"));
          objc_msgSend(v21, "setApsMachServiceName:", CFSTR("com.apple.securityd.aps"));
          empty = xpc_dictionary_create_empty();
          xpc_dictionary_set_value(empty, XPC_ACTIVITY_REQUIRES_CLASS_A, &_xpc_BOOL_true);
          objc_msgSend(v14, "setXpcActivityCriteriaOverrides:", empty);
          objc_msgSend(v21, "setXpcActivityCriteriaOverrides:", empty);
          v23 = objc_msgSend(objc_alloc((Class)CKSyncEngine), "initWithConfiguration:", v14);
          v24 = (void *)*((_QWORD *)v2 + 10);
          *((_QWORD *)v2 + 10) = v23;

          v25 = objc_msgSend(objc_alloc((Class)CKSyncEngine), "initWithConfiguration:", v21);
          v26 = (void *)*((_QWORD *)v2 + 11);
          *((_QWORD *)v2 + 11) = v25;

          if (*((_BYTE *)v2 + 8))
          {
            v27 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
            v28 = objc_claimAutoreleasedReturnValue(v27);
            if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Sync engine reinit: private engine needs to fetch changes", buf, 2u);
            }

            objc_msgSend(*((id *)v2 + 10), "setNeedsToFetchChanges");
            *((_BYTE *)v2 + 8) = 0;
          }
          if (*((_BYTE *)v2 + 9))
          {
            v29 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
            v30 = objc_claimAutoreleasedReturnValue(v29);
            if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "Sync engine reinit: shared engine needs to fetch changes", buf, 2u);
            }

            objc_msgSend(*((id *)v2 + 11), "setNeedsToFetchChanges");
            *((_BYTE *)v2 + 9) = 0;
          }

        }
      }

    }
  }

}

void sub_1000DACAC(uint64_t a1)
{
  id WeakRetained;
  void *v2;
  NSObject *v3;
  _QWORD block[4];
  id v5;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v2 = WeakRetained;
  if (WeakRetained)
  {
    v3 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "queue"));
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000DAE90;
    block[3] = &unk_1002EC350;
    v5 = v2;
    dispatch_async(v3, block);

  }
}

void sub_1000DAD3C(uint64_t a1)
{
  id WeakRetained;
  void *v2;
  NSObject *v3;
  _QWORD block[4];
  id v5;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v2 = WeakRetained;
  if (WeakRetained)
  {
    v3 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "queue"));
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000DADCC;
    block[3] = &unk_1002EC350;
    v5 = v2;
    dispatch_async(v3, block);

  }
}

void sub_1000DADCC(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  _BOOL4 v5;
  uint8_t v6[16];
  uint8_t buf[16];

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 88);
  v3 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
  v4 = objc_claimAutoreleasedReturnValue(v3);
  v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v5)
    {
      *(_WORD *)v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Received shared DB push while engine is online, ignoring", v6, 2u);
    }

  }
  else
  {
    if (v5)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Received shared DB push while engine was offline, making note of this.", buf, 2u);
    }

    *(_BYTE *)(*(_QWORD *)(a1 + 32) + 9) = 1;
  }
}

void sub_1000DAE90(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  _BOOL4 v5;
  uint8_t v6[16];
  uint8_t buf[16];

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 80);
  v3 = KCSharingLogObject(CFSTR("KCSharingSyncController"));
  v4 = objc_claimAutoreleasedReturnValue(v3);
  v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v5)
    {
      *(_WORD *)v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "CKNotificationListener received private DB push while engine is online, ignoring", v6, 2u);
    }

  }
  else
  {
    if (v5)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "CKNotificationListener received private DB push while engine was offline, making note of this.", buf, 2u);
    }

    *(_BYTE *)(*(_QWORD *)(a1 + 32) + 8) = 1;
  }
}

void sub_1000DAF98(id a1)
{
  KCSharingSyncController *v1;
  void *v2;

  v1 = objc_alloc_init(KCSharingSyncController);
  v2 = (void *)qword_1003410A0;
  qword_1003410A0 = (uint64_t)v1;

}

void sub_1000DB7F4(_Unwind_Exception *a1)
{
  id *v1;
  id *v2;
  id *v3;
  id *v4;
  uint64_t v5;

  objc_destroyWeak(v4);
  objc_destroyWeak(v1);
  objc_destroyWeak(v3);
  objc_destroyWeak(v2);
  objc_destroyWeak((id *)(v5 - 128));
  _Unwind_Resume(a1);
}

void sub_1000E1384(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,id location)
{
  id *v21;

  objc_destroyWeak(v21);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000E162C(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 24));
  _Unwind_Resume(a1);
}

void sub_1000E17A0(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_1000E1A1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000E1B84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000E1CEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000E1FA8(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_1000E209C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000E2174(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 24));
  _Unwind_Resume(a1);
}

void sub_1000E224C(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 24));
  _Unwind_Resume(a1);
}

void sub_1000E2B8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,id location)
{
  _Block_object_dispose(&a21, 8);
  _Block_object_dispose(&location, 8);
  _Unwind_Resume(a1);
}

void sub_1000E377C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  id *v15;

  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000E3B4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a23, 8);
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

void sub_1000E42B4(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 128));
  _Unwind_Resume(a1);
}

void sub_1000E6D58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000E8BA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  uint64_t v34;

  _Block_object_dispose(&a22, 8);
  _Block_object_dispose(&a26, 8);
  _Block_object_dispose(&a30, 8);
  _Block_object_dispose(&a34, 8);
  _Block_object_dispose((const void *)(v34 - 160), 8);
  _Block_object_dispose((const void *)(v34 - 208), 8);
  _Unwind_Resume(a1);
}

void sub_1000EA5B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  id *v17;

  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000EC7C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,id location)
{
  id *v23;

  objc_destroyWeak(v23);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000ED020(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000ED198(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v7 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_1000ED3AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1000EDFDC(uint64_t a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  const void *v6;
  int v7;
  id v8;

  v3 = a2;
  if (v3)
  {
    v4 = sub_10000EF14("SecError");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v7 = 138412290;
      v8 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "octagon: failed to reset cdp account contents: %@", (uint8_t *)&v7, 0xCu);
    }
  }
  else
  {
    v6 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7) = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "successfully reset cdp account contents", (uint8_t *)&v7, 2u);
    }
  }

  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t sub_1000EE108(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_1000EE118(uint64_t a1)
{

}

void sub_1000EE120(uint64_t a1, void *a2, void *a3)
{
  id v6;
  id v7;
  const void *v8;
  NSObject *v9;
  uint64_t v10;
  int v11;
  id v12;

  v6 = a2;
  v7 = a3;
  if (v7)
  {
    v8 = sub_10000EF14("octagon-metrics");
    v9 = objc_claimAutoreleasedReturnValue(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      v11 = 138412290;
      v12 = v7;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Unable to fetch trust status: %@", (uint8_t *)&v11, 0xCu);
    }

    v10 = a1 + 32;
  }
  else
  {
    v10 = a1 + 40;
    a3 = a2;
  }
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)v10 + 8) + 40), a3);

}

void sub_1000EE220(uint64_t a1, void *a2, void *a3)
{
  id v6;
  const void *v7;
  NSObject *v8;
  void *v9;
  int v10;
  id v11;

  v6 = a3;
  if (v6)
  {
    v7 = sub_10000EF14("octagon");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v10 = 138412290;
      v11 = v6;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Unable to dump info: %@", (uint8_t *)&v10, 0xCu);
    }

    objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), a3);
  }
  else
  {
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a2, "objectForKeyedSubscript:", CFSTR("honorIDMSListChanges")));
    if (objc_msgSend(v9, "isEqualToString:", CFSTR("YES")))
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;

  }
}

void sub_1000EE33C(_QWORD *a1, void *a2, void *a3)
{
  id v5;
  const void *v6;
  NSObject *v7;
  uint64_t v8;
  id v9;
  NSObject *v10;
  const void *v11;
  void *v12;
  int v13;
  int v14;
  id v15;
  __int16 v16;
  int v17;

  v5 = a3;
  if (v5)
  {
    v6 = sub_10000EF14("octagon-metrics");
    v7 = objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v14 = 138412290;
      v15 = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Failed to fetch allowed machineIDs: %@", (uint8_t *)&v14, 0xCu);
    }

    v8 = *(_QWORD *)(a1[5] + 8);
    v9 = v5;
    v10 = *(NSObject **)(v8 + 40);
    *(_QWORD *)(v8 + 40) = v9;
  }
  else
  {
    if (objc_msgSend(a2, "containsObject:", a1[4]))
      *(_BYTE *)(*(_QWORD *)(a1[6] + 8) + 24) = 1;
    v11 = sub_10000EF14("octagon-metrics");
    v10 = objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      v12 = (void *)a1[4];
      v13 = *(unsigned __int8 *)(*(_QWORD *)(a1[6] + 8) + 24);
      v14 = 138412546;
      v15 = v12;
      v16 = 1024;
      v17 = v13;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "MID (%@) on list: %{BOOL}d", (uint8_t *)&v14, 0x12u);
    }
  }

}

void sub_1000EE4AC(uint64_t a1, void *a2)
{
  id v3;
  char *WeakRetained;
  const void *v5;
  NSObject *v6;
  void *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;

  v3 = a2;
  WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 40));
  *(_WORD *)(WeakRetained + 57) = 0;
  WeakRetained[59] = 0;
  if (v3)
  {
    (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  }
  else
  {
    v5 = sub_10000EF14("octagon-health");
    v6 = objc_claimAutoreleasedReturnValue(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      v8 = *((_QWORD *)WeakRetained + 8);
      v9 = 138412290;
      v10 = v8;
      _os_log_debug_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "results=%@", (uint8_t *)&v9, 0xCu);
    }

    (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
    v7 = (void *)*((_QWORD *)WeakRetained + 8);
    *((_QWORD *)WeakRetained + 8) = 0;

  }
}

uint64_t sub_1000EE5C4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_1000EE5D0(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  const void *v7;
  NSObject *v8;
  const void *v9;
  const void *v10;
  NSObject *v11;
  uint64_t v12;
  void *v13;
  void *v14;
  NSErrorUserInfoKey v15;
  const __CFString *v16;
  uint8_t buf[4];
  id v18;

  v5 = a2;
  v6 = a3;
  if (v6)
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v18 = v6;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon-tlk-recoverability: failed assessing tlk recoverability using the octagon identity, error: %@", buf, 0xCu);
    }
LABEL_4:

    (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
    goto LABEL_13;
  }
  if (v5 && objc_msgSend(v5, "count"))
  {
    v9 = sub_10000EF14("octagon-tlk-recoverability");
    v8 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v18 = v5;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "found views using octagon peer matching record! views: %@", buf, 0xCu);
    }
    goto LABEL_4;
  }
  v10 = sub_10000EF14("SecError");
  v11 = objc_claimAutoreleasedReturnValue(v10);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "octagon-tlk-recoverability: failed to find views", buf, 2u);
  }

  v12 = *(_QWORD *)(a1 + 32);
  v15 = NSLocalizedDescriptionKey;
  v16 = CFSTR("Record cannot recover any views");
  v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v16, &v15, 1));
  v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("com.apple.security.octagon"), 58, v13));
  (*(void (**)(uint64_t, _QWORD, void *))(v12 + 16))(v12, 0, v14);

LABEL_13:
}

void sub_1000EE808(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  const void *v10;
  NSObject *v11;
  id v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  id v18;
  void *v19;
  const void *v20;
  NSObject *v21;
  uint64_t v22;
  void *v23;
  _QWORD v24[4];
  id v25;
  uint64_t v26;
  id v27;
  NSErrorUserInfoKey v28;
  const __CFString *v29;
  uint8_t buf[4];
  id v31;

  v7 = a2;
  v8 = a3;
  v9 = a4;
  if (v9)
  {
    v10 = sub_10000EF14("SecError");
    v11 = objc_claimAutoreleasedReturnValue(v10);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v31 = v9;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "octagon-tlk-recoverability: fetching bottles failed: %@", buf, 0xCu);
    }

    (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
  }
  else
  {
    v12 = objc_msgSend(objc_alloc((Class)OTEscrowRecord), "initWithData:", *(_QWORD *)(a1 + 32));
    v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "escrowInformationMetadata"));
    v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "bottleId"));

    if ((objc_msgSend(v7, "containsObject:", v14) & 1) != 0
      || (objc_msgSend(v8, "containsObject:", v14) & 1) != 0)
    {
      v15 = *(void **)(a1 + 40);
      v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "escrowInformationMetadata"));
      v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "bottleId"));
      v24[0] = _NSConcreteStackBlock;
      v24[1] = 3221225472;
      v24[2] = sub_1000EEACC;
      v24[3] = &unk_1002DDBF0;
      v25 = v12;
      v18 = *(id *)(a1 + 48);
      v26 = *(_QWORD *)(a1 + 40);
      v27 = v18;
      objc_msgSend(v15, "octagonPeerIDGivenBottleID:reply:", v17, v24);

      v19 = v25;
    }
    else
    {
      v20 = sub_10000EF14("octagon-tlk-recoverability");
      v21 = objc_claimAutoreleasedReturnValue(v20);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "record's bottleID is not valid in cuttlefish", buf, 2u);
      }

      v22 = *(_QWORD *)(a1 + 48);
      v28 = NSLocalizedDescriptionKey;
      v29 = CFSTR("Record's bottleID is not valid in cuttlefish");
      v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v29, &v28, 1));
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("com.apple.security.octagon"), 58, v19));
      (*(void (**)(uint64_t, _QWORD, void *))(v22 + 16))(v22, 0, v23);

    }
  }

}

void sub_1000EEACC(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  id v6;
  const void *v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  id v11;
  NSErrorUserInfoKey v12;
  const __CFString *v13;
  uint8_t buf[4];
  uint64_t v15;

  v3 = a2;
  if (v3)
  {
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "ckks"));
    v11 = 0;
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "viewsForPeerID:error:", v3, &v11));
    v6 = v11;

    (*(void (**)(_QWORD, void *, id))(*(_QWORD *)(a1 + 48) + 16))(*(_QWORD *)(a1 + 48), v5, v6);
  }
  else
  {
    v7 = sub_10000EF14("octagon-tlk-recoverability");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)buf = 138412290;
      v15 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Octagon peerID not trusted for record %@", buf, 0xCu);
    }

    v10 = *(_QWORD *)(a1 + 48);
    v12 = NSLocalizedDescriptionKey;
    v13 = CFSTR("Octagon peerID not trusted for record");
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v13, &v12, 1));
    v6 = (id)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("com.apple.security.octagon"), 58, v5));
    (*(void (**)(uint64_t, _QWORD, id))(v10 + 16))(v10, 0, v6);
  }

}

void sub_1000EEC60(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  _QWORD v7[5];
  _QWORD v8[5];
  id v9;

  v5 = a2;
  v6 = a3;
  v8[0] = 0;
  v8[1] = v8;
  v8[2] = 0x3032000000;
  v8[3] = sub_1000EE108;
  v8[4] = sub_1000EE118;
  v9 = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_1000EED50;
  v7[3] = &unk_1002DDBC8;
  v7[4] = v8;
  objc_msgSend(v5, "enumerateKeysAndObjectsUsingBlock:", v7);
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  _Block_object_dispose(v8, 8);

}

void sub_1000EED38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000EED50(uint64_t a1, void *a2, void *a3, _BYTE *a4)
{
  id v8;

  v8 = a2;
  if (objc_msgSend(a3, "isEqualToString:", a3))
  {
    objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), a2);
    *a4 = 1;
  }

}

void sub_1000EEDC0(id *a1)
{
  void *v2;
  const void *v3;
  NSObject *v4;
  void *v5;
  NSObject *v6;
  void *v7;
  void *v8;
  id v9;
  const void *v10;
  NSObject *v11;
  id v12;
  unsigned __int8 v13;
  id v14;
  const void *v15;
  NSObject *v16;
  void *v17;
  void *v18;
  id v19;
  void *v20;
  void *v21;
  const void *v22;
  void (**v23)(id, id);
  void **v24;
  uint64_t v25;
  void (*v26)(uint64_t);
  void *v27;
  id v28;
  id v29;
  id v30;
  id v31;
  uint8_t buf[4];
  id v33;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "error"));

  if (!v2)
  {
    v22 = sub_10000EF14("octagon-ckks");
    v6 = objc_claimAutoreleasedReturnValue(v22);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Done waiting for CKKS Priority view download", buf, 2u);
    }
    goto LABEL_16;
  }
  v3 = sub_10000EF14("SecError");
  v4 = objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "error"));
    *(_DWORD *)buf = 138412290;
    v33 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "octagon-ckks: Done waiting for CKKS Priority view download with error: %@", buf, 0xCu);

  }
  v6 = objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "error"));
  v7 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject domain](v6, "domain"));
  if ((objc_msgSend(v7, "isEqualToString:", CFSTR("CKKSErrorDomain")) & 1) == 0)
  {

LABEL_16:
    goto LABEL_17;
  }
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "error"));
  v9 = objc_msgSend(v8, "code");

  if (v9 != (id)52)
  {
LABEL_17:
    v23 = (void (**)(id, id))a1[6];
    v14 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "error"));
    v23[2](v23, v14);
    goto LABEL_18;
  }
  v10 = sub_10000EF14("SecError");
  v11 = objc_claimAutoreleasedReturnValue(v10);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "octagon-ckks: Retrying wait for CKKS Priority view download", buf, 2u);
  }

  v12 = a1[5];
  v31 = 0;
  v13 = objc_msgSend(v12, "recheckCKKSTrustStatus:", &v31);
  v14 = v31;
  if ((v13 & 1) == 0)
  {
    v15 = sub_10000EF14("SecError");
    v16 = objc_claimAutoreleasedReturnValue(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v33 = v14;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "octagon-ckks: Unable to retry CKKS Priority view download: %@", buf, 0xCu);
    }

  }
  v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[5], "ckks"));
  v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "rpcWaitForPriorityViewProcessing"));

  v24 = _NSConcreteStackBlock;
  v25 = 3221225472;
  v26 = sub_1000EF11C;
  v27 = &unk_1002E95B8;
  v28 = v18;
  v29 = a1[4];
  v30 = a1[6];
  v19 = v18;
  v20 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSResultOperation named:withBlock:](CKKSResultOperation, "named:withBlock:", CFSTR("wait-for-sync-reply"), &v24));
  objc_msgSend(v20, "addDependency:", v19, v24, v25, v26, v27);
  v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[5], "operationQueue"));
  objc_msgSend(v21, "addOperation:", v20);

LABEL_18:
}

void sub_1000EF11C(uint64_t a1)
{
  void *v2;
  const void *v3;
  NSObject *v4;
  void *v5;
  const void *v6;
  uint64_t v7;
  void *v8;
  int v9;
  void *v10;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "error"));

  if (v2)
  {
    v3 = sub_10000EF14("SecError");
    v4 = objc_claimAutoreleasedReturnValue(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "error"));
      v9 = 138412290;
      v10 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "octagon-ckks: Done waiting for CKKS Priority view download retry with error: %@", (uint8_t *)&v9, 0xCu);

    }
  }
  else
  {
    v6 = sub_10000EF14("octagon-ckks");
    v4 = objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v9) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Done waiting for CKKS Priority view download retry", (uint8_t *)&v9, 2u);
    }
  }

  v7 = *(_QWORD *)(a1 + 48);
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "error"));
  (*(void (**)(uint64_t, void *))(v7 + 16))(v7, v8);

}

void sub_1000EF26C(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  const void *v7;
  NSObject *v8;
  const void *v9;
  int v10;
  id v11;

  v5 = a2;
  v6 = a3;
  if (v6)
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v10 = 138412290;
      v11 = v6;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon-settings: Failed fetching account settings: %@", (uint8_t *)&v10, 0xCu);
    }
  }
  else
  {
    v9 = sub_10000EF14("octagon-settings");
    v8 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v10 = 138412290;
      v11 = v5;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Succeeded fetching account settings: %@", (uint8_t *)&v10, 0xCu);
    }
  }

  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_1000EF3BC(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  const void *v7;
  NSObject *v8;
  _BOOL4 v9;
  int v10;
  id v11;

  v5 = a2;
  v6 = a3;
  v7 = sub_10000EF14("SecError");
  v8 = objc_claimAutoreleasedReturnValue(v7);
  v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    if (v9)
    {
      v10 = 138412290;
      v11 = v6;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon-settings: Failed fetching account settings: %@", (uint8_t *)&v10, 0xCu);
    }
  }
  else if (v9)
  {
    v10 = 138412290;
    v11 = v5;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon-settings: Succeeded fetching account settings: %@", (uint8_t *)&v10, 0xCu);
  }

  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_1000EF4F0(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id WeakRetained;
  void *v10;
  const void *v11;
  NSObject *v12;
  void *v13;
  void *v14;
  id v15;
  void *v16;
  id v17;
  id v18;
  id v19;
  uint64_t v20;
  void *i;
  void *v22;
  void *v23;
  id v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  unsigned int v31;
  void *v32;
  id v33;
  void *v34;
  void *v35;
  void *v36;
  unsigned __int8 v37;
  const void *v38;
  NSObject *v39;
  void *v40;
  void *v41;
  void *v42;
  id v43;
  id v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  uint8_t v49[128];
  uint8_t buf[4];
  void *v51;
  __int16 v52;
  void *v53;
  __int16 v54;
  id v55;

  v44 = a2;
  v7 = a3;
  v8 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  v10 = WeakRetained;
  if (v8)
  {
    v11 = sub_10000EF14("octagon");
    v12 = objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "containerName"));
      v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "contextID"));
      *(_DWORD *)buf = 138412802;
      v51 = v13;
      v52 = 2112;
      v53 = v14;
      v54 = 2112;
      v55 = v8;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Unable to fetch trusted peers for (%@,%@): %@", buf, 0x20u);

    }
    (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
  }
  else
  {
    v42 = WeakRetained;
    v15 = objc_alloc_init((Class)OTCurrentSecureElementIdentities);
    v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
    objc_msgSend(v15, "setTrustedPeerSecureElementIdentities:", v16);

    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    v43 = v7;
    v17 = v7;
    v18 = objc_msgSend(v17, "countByEnumeratingWithState:objects:count:", &v45, v49, 16);
    if (v18)
    {
      v19 = v18;
      v20 = *(_QWORD *)v46;
      do
      {
        for (i = 0; i != v19; i = (char *)i + 1)
        {
          if (*(_QWORD *)v46 != v20)
            objc_enumerationMutation(v17);
          v22 = *(void **)(*((_QWORD *)&v45 + 1) + 8 * (_QWORD)i);
          v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "secureElementIdentity"));

          if (v23)
          {
            v24 = objc_alloc_init((Class)OTSecureElementPeerIdentity);
            v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "secureElementIdentity"));
            v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v25, "peerIdentifier"));
            objc_msgSend(v24, "setPeerIdentifier:", v26);

            v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "secureElementIdentity"));
            v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v27, "peerData"));
            objc_msgSend(v24, "setPeerData:", v28);

            v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "peerID"));
            v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v44, "peerID"));
            v31 = objc_msgSend(v29, "isEqualToString:", v30);

            if (v31)
            {
              objc_msgSend(v15, "setLocalPeerIdentity:", v24);
            }
            else
            {
              v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "trustedPeerSecureElementIdentities"));
              objc_msgSend(v32, "addObject:", v24);

            }
          }
        }
        v19 = objc_msgSend(v17, "countByEnumeratingWithState:objects:count:", &v45, v49, 16);
      }
      while (v19);
    }

    v8 = 0;
    v10 = v42;
    if (*(_QWORD *)(a1 + 32))
    {
      v33 = objc_alloc_init((Class)OTSecureElementPeerIdentity);
      v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "peerIdentifier"));
      objc_msgSend(v33, "setPeerIdentifier:", v34);

      v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "peerData"));
      objc_msgSend(v33, "setPeerData:", v35);

      v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "localPeerIdentity"));
      v37 = objc_msgSend(v36, "isEqual:", v33);

      if ((v37 & 1) == 0)
      {
        v38 = sub_10000EF14("octagon");
        v39 = objc_claimAutoreleasedReturnValue(v38);
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
        {
          v40 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v42, "containerName"));
          v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v42, "contextID"));
          *(_DWORD *)buf = 138412802;
          v51 = v40;
          v52 = 2112;
          v53 = v41;
          v54 = 2112;
          v55 = v33;
          _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "Returning pending identity for (%@,%@): %@", buf, 0x20u);

        }
        objc_msgSend(v15, "setPendingLocalPeerIdentity:", v33);
      }

    }
    (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

    v7 = v43;
  }

}

OTAccountMetadataClassC *__cdecl sub_1000EF94C(id a1, OTAccountMetadataClassC *a2)
{
  OTAccountMetadataClassC *v2;

  v2 = a2;
  -[OTAccountMetadataClassC setSecureElementIdentity:](v2, "setSecureElementIdentity:", 0);
  return v2;
}

id sub_1000EF978(uint64_t a1, void *a2)
{
  id v3;

  v3 = a2;
  objc_msgSend(v3, "setOctagonSecureElementIdentity:", *(_QWORD *)(a1 + 32));
  return v3;
}

void sub_1000EF9A8(uint64_t a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  const __CFString *v6;
  void (*v7)(void);
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  unsigned int v14;
  const void *v15;
  NSObject *v16;
  const __CFString *v17;
  const void *v18;
  NSObject *v19;
  uint64_t v20;
  void *v21;
  int v22;
  const __CFString *v23;
  __int16 v24;
  id v25;

  v3 = a2;
  if (v3)
  {
    v4 = sub_10000EF14("octagon-ckks");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = CFSTR("enabled");
      if (!*(_BYTE *)(a1 + 48))
        v6 = CFSTR("disabled");
      v22 = 138412546;
      v23 = v6;
      v24 = 2112;
      v25 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Failed to set sync policy to '%@': %@", (uint8_t *)&v22, 0x16u);
    }

    v7 = *(void (**)(void))(*(_QWORD *)(a1 + 40) + 16);
LABEL_13:
    v7();
    goto LABEL_14;
  }
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "ckks"));
  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "operationDependencies"));
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "syncingPolicy"));

  if (v10)
  {
    v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "ckks"));
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "operationDependencies"));
    v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "syncingPolicy"));
    v14 = objc_msgSend(v13, "syncUserControllableViewsAsBoolean");

    v15 = sub_10000EF14("octagon-ckks");
    v16 = objc_claimAutoreleasedReturnValue(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      v17 = CFSTR("disabled");
      if (v14)
        v17 = CFSTR("enabled");
      v22 = 138412290;
      v23 = v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "User-controllable sync status is set as '%@'", (uint8_t *)&v22, 0xCu);
    }

    v7 = *(void (**)(void))(*(_QWORD *)(a1 + 40) + 16);
    goto LABEL_13;
  }
  v18 = sub_10000EF14("octagon-ckks");
  v19 = objc_claimAutoreleasedReturnValue(v18);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v22) = 0;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Policy missing even after a refetch?", (uint8_t *)&v22, 2u);
  }

  v20 = *(_QWORD *)(a1 + 40);
  v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:description:](NSError, "errorWithDomain:code:description:", CFSTR("com.apple.security.octagon"), 49, CFSTR("Sync policy is missing even after refetching")));
  (*(void (**)(uint64_t, _QWORD, void *))(v20 + 16))(v20, 0, v21);

LABEL_14:
}

void sub_1000EFC38(uint64_t a1, void *a2)
{
  __CFString *v3;
  const void *v4;
  NSObject *v5;
  void (*v6)(void);
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  unsigned int v11;
  const void *v12;
  NSObject *v13;
  const __CFString *v14;
  void *v15;
  void *v16;
  id v17;
  __CFString *v18;
  const void *v19;
  NSObject *v20;
  uint64_t v21;
  void *v22;
  uint8_t buf[4];
  const __CFString *v24;
  __int16 v25;
  __CFString *v26;

  v3 = a2;
  if (v3)
  {
    v4 = sub_10000EF14("octagon-ckks");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v24 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Failed to fetch policy: %@", buf, 0xCu);
    }

    v6 = *(void (**)(void))(*(_QWORD *)(a1 + 40) + 16);
LABEL_18:
    v6();
    goto LABEL_19;
  }
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "ckks"));
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "syncingPolicy"));

  if (v8)
  {
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "ckks"));
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "syncingPolicy"));
    v11 = objc_msgSend(v10, "syncUserControllableViewsAsBoolean");

    v12 = sub_10000EF14("octagon-ckks");
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      if (v11)
        v14 = CFSTR("enabled");
      else
        v14 = CFSTR("disabled");
      v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "ckks"));
      v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "syncingPolicy"));
      v17 = objc_msgSend(v16, "syncUserControllableViews");
      if (v17 >= 4)
        v18 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("(unknown: %i)"), v17));
      else
        v18 = off_1002DDD18[v17];
      *(_DWORD *)buf = 138412546;
      v24 = v14;
      v25 = 2112;
      v26 = v18;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Returning user-controllable status as %@ (%@)", buf, 0x16u);

    }
    v6 = *(void (**)(void))(*(_QWORD *)(a1 + 40) + 16);
    goto LABEL_18;
  }
  v19 = sub_10000EF14("octagon-ckks");
  v20 = objc_claimAutoreleasedReturnValue(v19);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Policy missing even after a refetch?", buf, 2u);
  }

  v21 = *(_QWORD *)(a1 + 40);
  v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:description:](NSError, "errorWithDomain:code:description:", CFSTR("com.apple.security.octagon"), 49, CFSTR("Sync policy is missing even after refetching")));
  (*(void (**)(uint64_t, _QWORD, void *))(v21 + 16))(v21, 0, v22);

LABEL_19:
}

void sub_1000EFEFC(uint64_t a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9;
  id v10;
  id v11;
  id v12;
  const void *v13;
  NSObject *v14;
  const void *v15;
  int v16;
  id v17;

  v9 = a2;
  v10 = a3;
  v11 = a4;
  v12 = a5;
  if (v12)
  {
    v13 = sub_10000EF14("SecError");
    v14 = objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      v16 = 138412290;
      v17 = v12;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "octagon: error fetching escrow contents: %@", (uint8_t *)&v16, 0xCu);
    }
  }
  else
  {
    v15 = sub_10000EF14("octagon");
    v14 = objc_claimAutoreleasedReturnValue(v15);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      v16 = 138412290;
      v17 = v10;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "fetched escrow contents for bottle: %@", (uint8_t *)&v16, 0xCu);
    }
  }

  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_1000F0084(uint64_t a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  const void *v6;
  int v7;
  id v8;

  v3 = a2;
  if (v3)
  {
    v4 = sub_10000EF14("SecError");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v7 = 138412290;
      v8 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "octagon: failed to remove escrow cache: %@", (uint8_t *)&v7, 0xCu);
    }
  }
  else
  {
    v6 = sub_10000EF14("octagon");
    v5 = objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7) = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "successfully removed escrow cache", (uint8_t *)&v7, 2u);
    }
  }

  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_1000F01B0(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  const void *v7;
  NSObject *v8;
  const void *v9;
  int v10;
  id v11;

  v5 = a2;
  v6 = a3;
  if (v6)
  {
    v7 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v10 = 138412290;
      v11 = v6;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: error fetching all viable escrow records: %@", (uint8_t *)&v10, 0xCu);
    }
  }
  else
  {
    v9 = sub_10000EF14("octagon");
    v8 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v10 = 138412290;
      v11 = v5;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "fetched escrow records: %@", (uint8_t *)&v10, 0xCu);
    }
  }

  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_1000F0300(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  const void *v10;
  NSObject *v11;
  const void *v12;
  NSObject *v13;
  const void *v14;
  int v15;
  id v16;

  v7 = a2;
  v8 = a3;
  v9 = a4;
  if (v9)
  {
    v10 = sub_10000EF14("SecError");
    v11 = objc_claimAutoreleasedReturnValue(v10);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v15 = 138412290;
      v16 = v9;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "octagon: error fetching all viable bottles: %@", (uint8_t *)&v15, 0xCu);
    }
  }
  else
  {
    v12 = sub_10000EF14("octagon");
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      v15 = 138412290;
      v16 = v7;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "fetched viable bottles: %@", (uint8_t *)&v15, 0xCu);
    }

    v14 = sub_10000EF14("octagon");
    v11 = objc_claimAutoreleasedReturnValue(v14);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v15 = 138412290;
      v16 = v8;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "fetched partially viable bottles: %@", (uint8_t *)&v15, 0xCu);
    }
  }

  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_1000F04C8(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  const void *v14;
  NSObject *v15;
  _BOOL4 v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  const void *v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  unsigned int v25;
  const void *v26;
  NSObject *v27;
  __CFString *v28;
  const void *v29;
  id v30;
  uint8_t buf[4];
  id v32;

  v5 = a2;
  v6 = a3;
  v7 = objc_msgSend(v5, "egoStatus");
  v8 = objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "egoPeerID"));
  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
  v10 = *(void **)(v9 + 40);
  *(_QWORD *)(v9 + 40) = v8;

  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = objc_msgSend(v5, "isExcluded");
  v11 = objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "viablePeerCountsByModelID"));
  v12 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8);
  v13 = *(void **)(v12 + 40);
  *(_QWORD *)(v12 + 40) = v11;

  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24) = objc_msgSend(v5, "isLocked");
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 40), a3);
  v14 = sub_10000EF14("octagon");
  v15 = objc_claimAutoreleasedReturnValue(v14);
  v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    if (v16)
    {
      *(_DWORD *)buf = 138412290;
      v32 = v6;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "error fetching trust status: %@", buf, 0xCu);
    }
    goto LABEL_26;
  }
  if (v16)
  {
    v17 = TPPeerStatusToString(v7);
    v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
    *(_DWORD *)buf = 138412290;
    v32 = v18;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "trust status: %@", buf, 0xCu);

  }
  objc_msgSend(*(id *)(a1 + 32), "popTooManyPeersDialogWithEgoPeerStatus:accountMeta:", v5, *(_QWORD *)(a1 + 40));
  if ((v7 & 4) != 0)
  {
LABEL_15:
    v19 = 1;
    goto LABEL_16;
  }
  if ((v7 & 0x5B) == 0)
  {
    if ((v7 & 0x80) == 0)
    {
      if ((v7 & 0x20) == 0)
      {
        v20 = sub_10000EF14("octagon");
        v21 = objc_claimAutoreleasedReturnValue(v20);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "TPPeerStatus is empty", buf, 2u);
        }

      }
      v19 = 3;
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  v19 = 0;
LABEL_16:
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 8) + 24) = v19;
  v22 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 8) + 24);
  if (v22)
    v23 = v22 == 1;
  else
    v23 = 2;
  v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "accountMetadataStore"));
  v30 = 0;
  v25 = objc_msgSend(v24, "persistNewTrustState:error:", v23, &v30);
  v15 = v30;

  if (!v25 || v15)
  {
    v29 = sub_10000EF14("SecError");
    v27 = objc_claimAutoreleasedReturnValue(v29);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v32 = v15;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "octagon: unable to persist clique trust state: %@", buf, 0xCu);
    }
  }
  else
  {
    v26 = sub_10000EF14("octagon");
    v27 = objc_claimAutoreleasedReturnValue(v26);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      v28 = off_1002DDD00[v23];
      *(_DWORD *)buf = 138412290;
      v32 = v28;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "updated account trust state: %@", buf, 0xCu);

    }
  }

LABEL_26:
}

void sub_1000F0828(uint64_t a1)
{
  const void *v2;
  NSObject *v3;
  void *v4;
  uint64_t v5;
  void *v6;
  void *v7;
  int v8;
  void *v9;

  v2 = sub_10000EF14("otrpc");
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "error"));
    v8 = 138412290;
    v9 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Returning an inheritance key call: %@", (uint8_t *)&v8, 0xCu);

  }
  v5 = *(_QWORD *)(a1 + 40);
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "ik"));
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "error"));
  (*(void (**)(uint64_t, void *, void *))(v5 + 16))(v5, v6, v7);

}

void sub_1000F0928(uint64_t a1)
{
  const void *v2;
  NSObject *v3;
  void *v4;
  uint64_t v5;
  void *v6;
  void *v7;
  int v8;
  void *v9;

  v2 = sub_10000EF14("otrpc");
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "error"));
    v8 = 138412290;
    v9 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Returning an inheritance key call: %@", (uint8_t *)&v8, 0xCu);

  }
  v5 = *(_QWORD *)(a1 + 40);
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "ik"));
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "error"));
  (*(void (**)(uint64_t, void *, void *))(v5 + 16))(v5, v6, v7);

}

void sub_1000F0A28(uint64_t a1)
{
  void *v1;
  const void *v3;
  NSObject *v4;
  void *v5;
  uint64_t v6;
  void *v7;
  _BOOL8 v8;
  void *v9;
  int v10;
  void *v11;
  __int16 v12;
  void *v13;

  v3 = sub_10000EF14("otrpc");
  v4 = objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "crk"));
    v1 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "error"));
    v10 = 138412546;
    v11 = v5;
    v12 = 2112;
    v13 = v1;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Returning a check inheritance key call: %@, %@", (uint8_t *)&v10, 0x16u);

  }
  v6 = *(_QWORD *)(a1 + 40);
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "crk"));
  if (v7)
  {
    v1 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "crk"));
    v8 = objc_msgSend(v1, "kind") == 2;
  }
  else
  {
    v8 = 0;
  }
  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "error"));
  (*(void (**)(uint64_t, _BOOL8, void *))(v6 + 16))(v6, v8, v9);

  if (v7)
}

void sub_1000F0B80(uint64_t a1)
{
  const void *v2;
  NSObject *v3;
  void *v4;
  uint64_t v5;
  void *v6;
  int v7;
  void *v8;

  v2 = sub_10000EF14("otrpc");
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "error"));
    v7 = 138412290;
    v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Returning remove inheritance key call: %@", (uint8_t *)&v7, 0xCu);

  }
  v5 = *(_QWORD *)(a1 + 40);
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "error"));
  (*(void (**)(uint64_t, void *))(v5 + 16))(v5, v6);

}

void sub_1000F0C68(uint64_t a1)
{
  const void *v2;
  NSObject *v3;
  void *v4;
  uint64_t v5;
  void *v6;
  int v7;
  void *v8;

  v2 = sub_10000EF14("otrpc");
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "error"));
    v7 = 138412290;
    v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Returning an inheritance key call: %@", (uint8_t *)&v7, 0xCu);

  }
  v5 = *(_QWORD *)(a1 + 40);
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "error"));
  (*(void (**)(uint64_t, void *))(v5 + 16))(v5, v6);

}

void sub_1000F0D50(uint64_t a1)
{
  const void *v2;
  NSObject *v3;
  void *v4;
  uint64_t v5;
  void *v6;
  void *v7;
  int v8;
  void *v9;

  v2 = sub_10000EF14("otrpc");
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "error"));
    v8 = 138412290;
    v9 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Returning an inheritance key call: %@", (uint8_t *)&v8, 0xCu);

  }
  v5 = *(_QWORD *)(a1 + 40);
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "ik"));
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "error"));
  (*(void (**)(uint64_t, void *, void *))(v5 + 16))(v5, v6, v7);

}

void sub_1000F0E50(uint64_t a1)
{
  void *v1;
  const void *v3;
  NSObject *v4;
  void *v5;
  uint64_t v6;
  void *v7;
  _BOOL8 v8;
  void *v9;
  int v10;
  void *v11;
  __int16 v12;
  void *v13;

  v3 = sub_10000EF14("otrpc");
  v4 = objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "crk"));
    v1 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "error"));
    v10 = 138412546;
    v11 = v5;
    v12 = 2112;
    v13 = v1;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Returning a check custodian recovery key call: %@, %@", (uint8_t *)&v10, 0x16u);

  }
  v6 = *(_QWORD *)(a1 + 40);
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "crk"));
  if (v7)
  {
    v1 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "crk"));
    v8 = objc_msgSend(v1, "kind") == 1;
  }
  else
  {
    v8 = 0;
  }
  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "error"));
  (*(void (**)(uint64_t, _BOOL8, void *))(v6 + 16))(v6, v8, v9);

  if (v7)
}

void sub_1000F0FA8(uint64_t a1)
{
  const void *v2;
  NSObject *v3;
  void *v4;
  uint64_t v5;
  void *v6;
  int v7;
  void *v8;

  v2 = sub_10000EF14("otrpc");
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "error"));
    v7 = 138412290;
    v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Returning a remove custodian recovery key call: %@", (uint8_t *)&v7, 0xCu);

  }
  v5 = *(_QWORD *)(a1 + 40);
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "error"));
  (*(void (**)(uint64_t, void *))(v5 + 16))(v5, v6);

}

void sub_1000F1090(uint64_t a1)
{
  const void *v2;
  NSObject *v3;
  void *v4;
  uint64_t v5;
  void *v6;
  void *v7;
  int v8;
  void *v9;

  v2 = sub_10000EF14("otrpc");
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "error"));
    v8 = 138412290;
    v9 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Returning a create custodian recovery key call: %@", (uint8_t *)&v8, 0xCu);

  }
  v5 = *(_QWORD *)(a1 + 40);
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "crk"));
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "error"));
  (*(void (**)(uint64_t, void *, void *))(v5 + 16))(v5, v6, v7);

}

uint64_t sub_1000F1190(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t sub_1000F119C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t sub_1000F11A8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_1000F11B4(uint64_t a1)
{
  const void *v2;
  NSObject *v3;
  void *v4;
  uint64_t v5;
  void *v6;
  int v7;
  void *v8;

  v2 = sub_10000EF14("otrpc");
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "error"));
    v7 = 138412290;
    v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Returning a set recovery key call: %@", (uint8_t *)&v7, 0xCu);

  }
  v5 = *(_QWORD *)(a1 + 40);
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "error"));
  (*(void (**)(uint64_t, void *))(v5 + 16))(v5, v6);

}

void sub_1000F129C(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  const void *v7;
  NSObject *v8;
  void *v9;
  void *v10;
  void *v11;
  id v12;
  id v13;
  uint64_t v14;
  void *i;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *j;
  void *v22;
  id v23;
  id v24;
  id v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  void *v29;
  unsigned __int8 v30;
  NSObject *v31;
  void *v32;
  void *v33;
  const void *v34;
  void *v35;
  id v36;
  uint64_t v37;
  id v38;
  uint64_t v39;
  id v40;
  void *v41;
  id obj;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  _BYTE v55[128];
  _BYTE v56[128];
  uint8_t v57[128];
  uint8_t buf[4];
  id v59;

  v5 = a2;
  v6 = a3;
  if (v6)
  {
    v7 = sub_10000EF14("octagon");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v59 = v6;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Unable to dump info: %@", buf, 0xCu);
    }

    (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
  }
  else
  {
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("self")));
    v37 = a1;
    v36 = v5;
    if (objc_msgSend(*(id *)(a1 + 32), "isEqualToString:", CFSTR("bottleID")))
    {
      v11 = v10;
      v51 = 0u;
      v52 = 0u;
      v53 = 0u;
      v54 = 0u;
      obj = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("bottles")));
      v12 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v51, v57, 16);
      if (v12)
      {
        v13 = v12;
        v14 = *(_QWORD *)v52;
        do
        {
          for (i = 0; i != v13; i = (char *)i + 1)
          {
            if (*(_QWORD *)v52 != v14)
              objc_enumerationMutation(obj);
            v16 = *(void **)(*((_QWORD *)&v51 + 1) + 8 * (_QWORD)i);
            v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "objectForKeyedSubscript:", CFSTR("bottleID")));
            v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "objectForKeyedSubscript:", CFSTR("peerID")));
            objc_msgSend(v9, "setObject:forKeyedSubscript:", v17, v18);

          }
          v13 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v51, v57, 16);
        }
        while (v13);
      }
      (*(void (**)(void))(*(_QWORD *)(v37 + 40) + 16))();
    }
    else
    {
      obj = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("peers")));
      v35 = v10;
      v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "objectForKeyedSubscript:", CFSTR("dynamicInfo")));
      v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "objectForKeyedSubscript:", CFSTR("included")));

      v49 = 0u;
      v50 = 0u;
      v47 = 0u;
      v48 = 0u;
      v38 = v20;
      v40 = objc_msgSend(v38, "countByEnumeratingWithState:objects:count:", &v47, v56, 16);
      if (v40)
      {
        v39 = *(_QWORD *)v48;
        v41 = v9;
        do
        {
          for (j = 0; j != v40; j = (char *)j + 1)
          {
            if (*(_QWORD *)v48 != v39)
              objc_enumerationMutation(v38);
            v22 = *(void **)(*((_QWORD *)&v47 + 1) + 8 * (_QWORD)j);
            v43 = 0u;
            v44 = 0u;
            v45 = 0u;
            v46 = 0u;
            v23 = obj;
            v24 = objc_msgSend(v23, "countByEnumeratingWithState:objects:count:", &v43, v55, 16);
            if (v24)
            {
              v25 = v24;
              v26 = *(_QWORD *)v44;
LABEL_21:
              v27 = 0;
              while (1)
              {
                if (*(_QWORD *)v44 != v26)
                  objc_enumerationMutation(v23);
                v28 = *(void **)(*((_QWORD *)&v43 + 1) + 8 * v27);
                v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "objectForKeyedSubscript:", CFSTR("peerID")));
                v30 = objc_msgSend(v29, "isEqualToString:", v22);

                if ((v30 & 1) != 0)
                  break;
                if (v25 == (id)++v27)
                {
                  v25 = objc_msgSend(v23, "countByEnumeratingWithState:objects:count:", &v43, v55, 16);
                  v9 = v41;
                  if (v25)
                    goto LABEL_21;
                  goto LABEL_27;
                }
              }
              v31 = v28;

              v9 = v41;
              if (!v31)
                goto LABEL_30;
              v32 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject objectForKeyedSubscript:](v31, "objectForKeyedSubscript:", CFSTR("stableInfo")));
              v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v32, "objectForKeyedSubscript:", *(_QWORD *)(v37 + 32)));
              objc_msgSend(v41, "setObject:forKeyedSubscript:", v33, v22);

            }
            else
            {
LABEL_27:

LABEL_30:
              v34 = sub_10000EF14("SecError");
              v31 = objc_claimAutoreleasedReturnValue(v34);
              if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 138412290;
                v59 = v22;
                _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "octagon: have a trusted peer ID without peer information: %@", buf, 0xCu);
              }
            }

          }
          v40 = objc_msgSend(v38, "countByEnumeratingWithState:objects:count:", &v47, v56, 16);
        }
        while (v40);
      }

      (*(void (**)(void))(*(_QWORD *)(v37 + 40) + 16))();
      v11 = v35;
    }

    v6 = 0;
    v5 = v36;
  }

}

void sub_1000F1784(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  const void *v7;
  NSObject *v8;
  void *v9;
  uint8_t v10[16];

  v5 = a2;
  v6 = a3;
  v7 = sub_10000EF14("octagon");
  v8 = objc_claimAutoreleasedReturnValue(v7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v10 = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Finished dump for status RPC", v10, 2u);
  }

  if (v6)
  {
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[SecXPCHelper cleanseErrorForXPC:](SecXPCHelper, "cleanseErrorForXPC:", v6));
    objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), "setObject:forKeyedSubscript:", v9, CFSTR("contextDumpError"));

  }
  else
  {
    objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), "setObject:forKeyedSubscript:", v5, CFSTR("contextDump"));
  }
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();

}

id sub_1000F188C(uint64_t a1, void *a2)
{
  id v3;

  v3 = a2;
  objc_msgSend(v3, "setVoucher:", *(_QWORD *)(a1 + 32));
  objc_msgSend(v3, "setVoucherSignature:", *(_QWORD *)(a1 + 40));
  return v3;
}

void sub_1000F18C8(uint64_t a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  id v6;
  int v7;
  id v8;

  v3 = a2;
  if (v3)
  {
    v4 = sub_10000EF14("SecError");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v7 = 138412290;
      v8 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "octagon failed to join: %@", (uint8_t *)&v7, 0xCu);
    }
  }
  else
  {
    v5 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "ckks"));
    v6 = -[NSObject rpcFetchBecause:](v5, "rpcFetchBecause:", CFSTR("octagon-pairing-complete"));
  }

  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
}

void sub_1000F19C0(uint64_t a1, int a2, void *a3)
{
  __CFString *v5;
  const void *v6;
  NSObject *v7;
  void (*v8)(void);
  const void *v9;
  NSObject *v10;
  const __CFString *v11;
  int v12;
  const __CFString *v13;

  v5 = a3;
  if (v5)
  {
    v6 = sub_10000EF14("SecError");
    v7 = objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v12 = 138412290;
      v13 = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "octagon-preflight-rk: error checking recovery key correctness: %@", (uint8_t *)&v12, 0xCu);
    }

    v8 = *(void (**)(void))(*(_QWORD *)(a1 + 32) + 16);
  }
  else
  {
    v9 = sub_10000EF14("octagon-preflight-rk");
    v10 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      v11 = CFSTR("incorrect");
      if (a2)
        v11 = CFSTR("correct");
      v12 = 138412290;
      v13 = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "recovery key is %@", (uint8_t *)&v12, 0xCu);
    }

    v8 = *(void (**)(void))(*(_QWORD *)(a1 + 32) + 16);
  }
  v8();

}

void sub_1000F1B1C(uint64_t a1, void *a2)
{
  id v3;
  id v4;

  v4 = a2;
  if (!v4)
  {
    v3 = objc_msgSend(*(id *)(a1 + 32), "notifierClass");
    objc_msgSend(v3, "post:", OTJoinedViaBottle);
  }
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

}

void sub_1000F1B7C(uint64_t a1)
{
  const void *v2;
  NSObject *v3;
  void *v4;
  void *v5;
  uint64_t v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  int v13;
  void *v14;
  __int16 v15;
  void *v16;

  v2 = sub_10000EF14("otrpc");
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "peerID"));
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "error"));
    v13 = 138412546;
    v14 = v4;
    v15 = 2112;
    v16 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Returning a prepare call: %@  %@", (uint8_t *)&v13, 0x16u);

  }
  v6 = *(_QWORD *)(a1 + 40);
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "peerID"));
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "permanentInfo"));
  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "permanentInfoSig"));
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "stableInfo"));
  v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "stableInfoSig"));
  v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "error"));
  (*(void (**)(uint64_t, void *, void *, void *, void *, void *, void *))(v6 + 16))(v6, v7, v8, v9, v10, v11, v12);

}

void sub_1000F1D0C(uint64_t a1)
{
  const void *v2;
  NSObject *v3;
  void *v4;
  void *v5;
  void *v6;
  uint64_t v7;
  void *v8;
  void *v9;
  void *v10;
  int v11;
  void *v12;
  __int16 v13;
  void *v14;
  __int16 v15;
  void *v16;

  v2 = sub_10000EF14("otrpc");
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "voucher"));
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "voucherSig"));
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "error"));
    v11 = 138412802;
    v12 = v4;
    v13 = 2112;
    v14 = v5;
    v15 = 2112;
    v16 = v6;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Returning a voucher call: %@, %@, %@", (uint8_t *)&v11, 0x20u);

  }
  v7 = *(_QWORD *)(a1 + 40);
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "voucher"));
  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "voucherSig"));
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "error"));
  (*(void (**)(uint64_t, void *, void *, void *))(v7 + 16))(v7, v8, v9, v10);

}

void sub_1000F1E68(uint64_t a1)
{
  id WeakRetained;
  const void *v3;
  NSObject *v4;
  void *v5;
  void *v6;
  uint64_t v7;
  void *v8;
  void *v9;
  int v10;
  void *v11;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 64));
  v3 = sub_10000EF14("otrpc");
  v4 = objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "error"));
    v10 = 138412290;
    v11 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Returning a updateTDL: %@", (uint8_t *)&v10, 0xCu);

  }
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "error"));

  if (v6)
  {
    v7 = *(_QWORD *)(a1 + 56);
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "error"));
    (*(void (**)(uint64_t, _QWORD, _QWORD, void *))(v7 + 16))(v7, 0, 0, v8);
  }
  else
  {
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "operationQueue"));
    objc_msgSend(v9, "addOperation:", *(_QWORD *)(a1 + 40));

    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "stateMachine"));
    objc_msgSend(v8, "handleExternalRequest:startTimeout:", *(_QWORD *)(a1 + 48), 120000000000);
  }

}

void sub_1000F1FC8(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;
  const void *v6;
  NSObject *v7;
  const char *v8;
  NSObject *v9;
  uint32_t v10;
  const void *v11;
  int v12;
  id v13;

  v5 = a3;
  if (v5)
  {
    v6 = sub_10000EF14("SecError");
    v7 = objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v12 = 138412290;
      v13 = v5;
      v8 = "rpc-epoch: failed to fetch epoch! error: %@";
      v9 = v7;
      v10 = 12;
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v12, v10);
    }
  }
  else
  {
    v11 = sub_10000EF14("rpc-epoch");
    v7 = objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v12) = 0;
      v8 = "fetched epoch";
      v9 = v7;
      v10 = 2;
      goto LABEL_6;
    }
  }

  (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), a2);
}

void sub_1000F20E8(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "cloudKitAccountInfo"));
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v2 != 0;

  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "cloudKitAccountInfo"));
  if (v3)
  {
    v5 = v3;
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "cloudKitAccountInfo"));
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = objc_msgSend(v4, "accountStatus") == (id)1;

    v3 = v5;
  }
  else
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = 0;
  }

}

void sub_1000F2184(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "cloudKitAccountInfo"));
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v2 != 0;

  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "cloudKitAccountInfo"));
  if (v3)
  {
    v5 = v3;
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "cloudKitAccountInfo"));
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = objc_msgSend(v4, "accountStatus") == (id)1;

    v3 = v5;
  }
  else
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = 0;
  }

}

void sub_1000F2220(uint64_t a1)
{
  void *v1;
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v1 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "stateMachine"));
  objc_msgSend(v1, "handleFlag:", CFSTR("attempt_sos_consistency"));

}

OTAccountMetadataClassC *__cdecl sub_1000F226C(id a1, OTAccountMetadataClassC *a2)
{
  OTAccountMetadataClassC *v2;

  v2 = a2;
  -[OTAccountMetadataClassC setWarnedTooManyPeers:](v2, "setWarnedTooManyPeers:", 1);
  return v2;
}

void sub_1000F2298(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  const void *v7;
  NSObject *v8;
  _BOOL4 v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  id v13;
  void *v14;
  int v15;
  id v16;

  v5 = a2;
  v6 = a3;
  v7 = sub_10000EF14("octagon-count-trusted-peers");
  v8 = objc_claimAutoreleasedReturnValue(v7);
  v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    if (v9)
    {
      v15 = 138412290;
      v16 = v6;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "totalTrustedPeers errored: %@", (uint8_t *)&v15, 0xCu);
    }

    v10 = a1 + 32;
    v11 = v6;
  }
  else
  {
    if (v9)
    {
      v15 = 138412290;
      v16 = v5;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "totalTrustedPeers succeeded, total count: %@", (uint8_t *)&v15, 0xCu);
    }

    v10 = a1 + 40;
    v11 = v5;
  }
  v12 = *(_QWORD *)(*(_QWORD *)v10 + 8);
  v13 = v11;
  v14 = *(void **)(v12 + 40);
  *(_QWORD *)(v12 + 40) = v13;

}

void sub_1000F23D0(uint64_t a1)
{
  id WeakRetained;
  const void *v2;
  NSObject *v3;
  void *v4;
  OctagonPendingFlag *v5;
  void *v6;
  int v7;
  void *v8;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v2 = sub_10000EF14("octagon-push-ratelimited");
    v3 = objc_claimAutoreleasedReturnValue(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "contextID"));
      v7 = 138412290;
      v8 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "notifying container of change for context: %@", (uint8_t *)&v7, 0xCu);

    }
    v5 = -[OctagonPendingFlag initWithFlag:conditions:]([OctagonPendingFlag alloc], "initWithFlag:conditions:", CFSTR("recd_push"), 1);
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "stateMachine"));
    objc_msgSend(v6, "handlePendingFlag:", v5);

  }
}

void sub_1000F24E4(uint64_t a1, void *a2)
{
  id v3;
  id WeakRetained;
  void *v5;
  unsigned int v6;
  void *v7;
  void *v8;
  id v9;
  void *v10;
  void *v11;
  unsigned int v12;
  void *v13;
  NSObject *v14;
  const void *v15;
  NSObject *v16;
  const void *v17;
  NSObject *v18;
  const void *v19;
  NSObject *v20;
  const void *v21;
  NSObject *v22;
  const void *v23;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;
  void *v27;
  OctagonCKKSPeerAdapter *v28;
  uint64_t v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  NSObject *v34;
  NSObject *v35;
  const void *v36;
  NSObject *v37;
  NSObject *v38;
  NSObject *v39;
  void *v40;
  unsigned int v41;
  void *v42;
  void *v43;
  void *v44;
  const void *v45;
  NSObject *v46;
  void *v47;
  unsigned int v48;
  const void *v49;
  NSObject *v50;
  _BOOL4 v51;
  __CFString **v52;
  void *v53;
  void *v54;
  void *v55;
  void *v56;
  unsigned int v57;
  NSObject *v58;
  unsigned int v59;
  const void *v60;
  NSObject *v61;
  const void *v62;
  id v63;
  id v64;
  id v65;
  id v66;
  _QWORD v67[6];
  uint64_t v68;
  uint64_t *v69;
  uint64_t v70;
  uint64_t (*v71)(uint64_t, uint64_t);
  void (*v72)(uint64_t);
  id v73;
  uint64_t v74;
  uint64_t *v75;
  uint64_t v76;
  uint64_t (*v77)(uint64_t, uint64_t);
  void (*v78)(uint64_t);
  id v79;
  void *v80;
  _QWORD v81[2];
  uint8_t buf[4];
  NSObject *v83;
  __int16 v84;
  NSObject *v85;

  v3 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "contextID"));
  v6 = objc_msgSend(v5, "isEqualToString:", CFSTR("defaultContext"));

  if (v6)
  {
    v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "accountStateTracker"));
    objc_msgSend(v7, "triggerOctagonStatusFetch");

  }
  v74 = 0;
  v75 = &v74;
  v76 = 0x3032000000;
  v77 = sub_1000EE108;
  v78 = sub_1000EE118;
  v79 = 0;
  v68 = 0;
  v69 = &v68;
  v70 = 0x3032000000;
  v71 = sub_1000EE108;
  v72 = sub_1000EE118;
  v73 = 0;
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "accountMetadataStore"));
  v66 = 0;
  v67[0] = _NSConcreteStackBlock;
  v67[1] = 3221225472;
  v67[2] = sub_1000F2DC0;
  v67[3] = &unk_1002DD9A8;
  v67[4] = &v74;
  v67[5] = &v68;
  objc_msgSend(v8, "persistAccountChanges:error:", v67, &v66);
  v9 = v66;

  if (!v75[5] || v9)
  {
    v17 = sub_10000EF14("SecError");
    v18 = objc_claimAutoreleasedReturnValue(v17);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "octagon-ckks: No peer ID to pass to CKKS. Syncing will be disabled.", buf, 2u);
    }
    goto LABEL_41;
  }
  v10 = (void *)v69[5];
  if (v10)
  {
    if (objc_msgSend(v10, "syncUserControllableViews"))
    {
      v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "sosAdapter"));
      v12 = objc_msgSend(v11, "sosEnabled");

      if (!v12)
      {
LABEL_21:
        v23 = sub_10000EF14("octagon-ckks");
        v24 = objc_claimAutoreleasedReturnValue(v23);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          v25 = v69[5];
          v26 = objc_claimAutoreleasedReturnValue(-[NSObject viewList](v25, "viewList"));
          *(_DWORD *)buf = 138412546;
          v83 = v25;
          v84 = 2112;
          v85 = v26;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Initializing CKKS views with policy %@: %@", buf, 0x16u);

        }
        v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "ckks"));
        objc_msgSend(v27, "setCurrentSyncingPolicy:", v69[5]);

        v28 = [OctagonCKKSPeerAdapter alloc];
        v29 = v75[5];
        v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "activeAccount"));
        v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "personaAdapter"));
        v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "cuttlefishXPCWrapper"));
        v18 = -[OctagonCKKSPeerAdapter initWithPeerID:specificUser:personaAdapter:cuttlefishXPC:](v28, "initWithPeerID:specificUser:personaAdapter:cuttlefishXPC:", v29, v30, v31, v32);

        v64 = 0;
        v33 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject fetchSelfPeers:](v18, "fetchSelfPeers:", &v64));
        v34 = v64;
        v35 = v34;
        if (!v33 || v34)
        {
          v45 = sub_10000EF14("SecError");
          v46 = objc_claimAutoreleasedReturnValue(v45);
          if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138412546;
            v83 = v18;
            v84 = 2112;
            v85 = v35;
            _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "octagon-ckks: Unable to fetch self peers for %@: %@", buf, 0x16u);
          }

          v47 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "lockStateTracker"));
          v48 = objc_msgSend(v47, "isLockedError:", v35);

          v49 = sub_10000EF14("octagon-ckks");
          v50 = objc_claimAutoreleasedReturnValue(v49);
          v51 = os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT);
          if (v48)
          {
            if (v51)
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "Waiting for device unlock to proceed", buf, 2u);
            }
            v52 = &off_1002E9098;
          }
          else
          {
            if (v51)
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "Error is scary; becoming untrusted",
                buf,
                2u);
            }
            v52 = &off_1002E92F0;
          }

          objc_msgSend(v3, "setNextState:", *v52);
          goto LABEL_51;
        }
        objc_msgSend(WeakRetained, "setOctagonAdapter:", v18);
        v36 = sub_10000EF14("octagon-ckks");
        v37 = objc_claimAutoreleasedReturnValue(v36);
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
        {
          v38 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "ckks"));
          v39 = v75[5];
          *(_DWORD *)buf = 138412546;
          v83 = v38;
          v84 = 2112;
          v85 = v39;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "Informing CKKS %@ of trusted operation with self peer %@", buf, 0x16u);

        }
        v40 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "sosAdapter"));
        v41 = objc_msgSend(v40, "sosEnabled");

        if (v41)
        {
          v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "octagonAdapter"));
          v81[0] = v42;
          v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "sosAdapter"));
          v81[1] = v43;
          v44 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v81, 2));

        }
        else
        {
          v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "octagonAdapter"));
          v80 = v42;
          v44 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v80, 1));
        }

        v53 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "ckks"));
        v54 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "suggestTLKUploadNotifier"));
        v55 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "requestPolicyCheckNotifier"));
        objc_msgSend(v53, "beginTrustedOperation:suggestTLKUpload:requestPolicyCheck:", v44, v54, v55);

LABEL_41:
        objc_msgSend(WeakRetained, "notifyTrustChanged:", 2);
        v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "intendedState"));
        objc_msgSend(v3, "setNextState:", v56);

        objc_msgSend(WeakRetained, "setShouldSendMetricsForOctagon:", 2);
        v63 = 0;
        v57 = objc_msgSend(WeakRetained, "fetchSendingMetricsPermitted:", &v63);
        v58 = v63;
        if (v58)
          v59 = 0;
        else
          v59 = v57;
        if (v59 == 1)
        {
          v60 = sub_10000EF14("octagon-metrics");
          v61 = objc_claimAutoreleasedReturnValue(v60);
          if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "triggered metrics check", buf, 2u);
          }

          v35 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "checkMetricsTrigger"));
          -[NSObject trigger](v35, "trigger");
          v18 = 0;
        }
        else
        {
          v18 = v58;
          if (!v58)
          {
LABEL_52:

            goto LABEL_53;
          }
          v62 = sub_10000EF14("SecError");
          v35 = objc_claimAutoreleasedReturnValue(v62);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138412290;
            v83 = v18;
            _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "octagon-metrics, failed to fetch metrics setting: %@", buf, 0xCu);
          }
        }
LABEL_51:

        goto LABEL_52;
      }
      v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "sosAdapter"));
      v65 = 0;
      objc_msgSend(v13, "updateCKKS4AllStatus:error:", 1, &v65);
      v14 = v65;

      if (v14)
      {
        v15 = sub_10000EF14("octagon-ckks");
        v16 = objc_claimAutoreleasedReturnValue(v15);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          v83 = v14;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Unable to enable the CKKS4All status in SOS: %@", buf, 0xCu);
        }

      }
    }
    else
    {
      v21 = sub_10000EF14("octagon-ckks");
      v22 = objc_claimAutoreleasedReturnValue(v21);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Memoized CKKS policy has no opinion of user-controllable view status", buf, 2u);
      }

      v14 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "upgradeUserControllableViewsRateLimiter"));
      -[NSObject trigger](v14, "trigger");
    }

    goto LABEL_21;
  }
  v19 = sub_10000EF14("SecError");
  v20 = objc_claimAutoreleasedReturnValue(v19);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "octagon-ckks: No memoized CKKS policy, re-fetching", buf, 2u);
  }

  objc_msgSend(v3, "setNextState:", CFSTR("RefetchCKKSPolicy"));
LABEL_53:
  _Block_object_dispose(&v68, 8);

  _Block_object_dispose(&v74, 8);
}

void sub_1000F2D78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  _Block_object_dispose(&a20, 8);
  _Block_object_dispose(&a26, 8);
  _Unwind_Resume(a1);
}

id sub_1000F2DC0(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  unsigned int v7;
  void *v8;
  id v9;

  v3 = a2;
  v4 = objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "peerID"));
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v6 = *(void **)(v5 + 40);
  *(_QWORD *)(v5 + 40) = v4;

  v7 = objc_msgSend(v3, "hasSyncingPolicy");
  if (v7)
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "getTPSyncingPolicy"));
  else
    v8 = 0;
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), v8);
  if (v7)

  if (objc_msgSend(v3, "attemptedJoin") == 2)
  {
    v9 = 0;
  }
  else
  {
    objc_msgSend(v3, "setAttemptedJoin:", 2);
    v9 = v3;
  }

  return v9;
}

void sub_1000F2E80(uint64_t a1, void *a2)
{
  id v3;
  id WeakRetained;
  void *v5;
  id v6;
  const void *v7;
  NSObject *v8;
  NSObject *v9;
  void *v10;
  void *v11;
  OctagonCKKSPeerAdapter *v12;
  uint64_t v13;
  void *v14;
  void *v15;
  void *v16;
  NSObject *v17;
  void *v18;
  id v19;
  void *v20;
  const void *v21;
  NSObject *v22;
  NSObject *v23;
  void *v24;
  void *v25;
  unsigned int v26;
  void *v27;
  void *v28;
  void *v29;
  const void *v30;
  const void *v31;
  NSObject *v32;
  const void *v33;
  NSObject *v34;
  void *v35;
  unsigned int v36;
  const void *v37;
  NSObject *v38;
  _BOOL4 v39;
  __CFString **v40;
  void *v41;
  void *v42;
  void *v43;
  void *v44;
  id v45;
  id v46;
  _QWORD v47[6];
  uint64_t v48;
  uint64_t *v49;
  uint64_t v50;
  uint64_t (*v51)(uint64_t, uint64_t);
  void (*v52)(uint64_t);
  id v53;
  uint64_t v54;
  uint64_t *v55;
  uint64_t v56;
  uint64_t (*v57)(uint64_t, uint64_t);
  void (*v58)(uint64_t);
  id v59;
  void *v60;
  _QWORD v61[2];
  uint8_t buf[4];
  NSObject *v63;
  __int16 v64;
  void *v65;

  v3 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v54 = 0;
  v55 = &v54;
  v56 = 0x3032000000;
  v57 = sub_1000EE108;
  v58 = sub_1000EE118;
  v59 = 0;
  v48 = 0;
  v49 = &v48;
  v50 = 0x3032000000;
  v51 = sub_1000EE108;
  v52 = sub_1000EE118;
  v53 = 0;
  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "accountMetadataStore"));
  v46 = 0;
  v47[0] = _NSConcreteStackBlock;
  v47[1] = 3221225472;
  v47[2] = sub_1000F3520;
  v47[3] = &unk_1002DD9A8;
  v47[4] = &v54;
  v47[5] = &v48;
  objc_msgSend(v5, "persistAccountChanges:error:", v47, &v46);
  v6 = v46;

  if (!v55[5] || v6)
  {
    v30 = sub_10000EF14("SecError");
    v17 = objc_claimAutoreleasedReturnValue(v30);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "octagon-ckks: No peer ID to pass to CKKS. Syncing will be disabled.", buf, 2u);
    }
    goto LABEL_29;
  }
  if (v49[5])
  {
    v7 = sub_10000EF14("octagon-ckks");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = v49[5];
      v10 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject viewList](v9, "viewList"));
      *(_DWORD *)buf = 138412546;
      v63 = v9;
      v64 = 2112;
      v65 = v10;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Initializing CKKS views with policy %@: %@", buf, 0x16u);

    }
    v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "ckks"));
    objc_msgSend(v11, "setCurrentSyncingPolicy:", v49[5]);

    v12 = [OctagonCKKSPeerAdapter alloc];
    v13 = v55[5];
    v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "activeAccount"));
    v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "personaAdapter"));
    v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "cuttlefishXPCWrapper"));
    v17 = -[OctagonCKKSPeerAdapter initWithPeerID:specificUser:personaAdapter:cuttlefishXPC:](v12, "initWithPeerID:specificUser:personaAdapter:cuttlefishXPC:", v13, v14, v15, v16);

    v45 = 0;
    v18 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject fetchSelfPeers:](v17, "fetchSelfPeers:", &v45));
    v19 = v45;
    v20 = v19;
    if (v18 && !v19)
    {
      objc_msgSend(WeakRetained, "setOctagonAdapter:", v17);
      v21 = sub_10000EF14("octagon-ckks");
      v22 = objc_claimAutoreleasedReturnValue(v21);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        v23 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "ckks"));
        v24 = (void *)v55[5];
        *(_DWORD *)buf = 138412546;
        v63 = v23;
        v64 = 2112;
        v65 = v24;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Informing CKKS %@ of trusted operation with self peer %@", buf, 0x16u);

      }
      v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "sosAdapter"));
      v26 = objc_msgSend(v25, "sosEnabled");

      if (v26)
      {
        v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "octagonAdapter"));
        v61[0] = v27;
        v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "sosAdapter"));
        v61[1] = v28;
        v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v61, 2));

      }
      else
      {
        v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "octagonAdapter"));
        v60 = v27;
        v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v60, 1));
      }

      objc_msgSend(WeakRetained, "setSuggestTLKUploadNotifier:", 0);
      objc_msgSend(WeakRetained, "setRequestPolicyCheckNotifier:", 0);
      v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "ckks"));
      v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "suggestTLKUploadNotifier"));
      v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "requestPolicyCheckNotifier"));
      objc_msgSend(v41, "beginTrustedOperation:suggestTLKUpload:requestPolicyCheck:", v29, v42, v43);

LABEL_29:
      objc_msgSend(WeakRetained, "notifyTrustChanged:", 2);
      v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "intendedState"));
      objc_msgSend(v3, "setNextState:", v44);

      objc_msgSend(WeakRetained, "setShouldSendMetricsForOctagon:", 2);
      goto LABEL_30;
    }
    v33 = sub_10000EF14("SecError");
    v34 = objc_claimAutoreleasedReturnValue(v33);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412546;
      v63 = v17;
      v64 = 2112;
      v65 = v20;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "octagon-ckks: Unable to fetch self peers for %@: %@", buf, 0x16u);
    }

    v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "lockStateTracker"));
    v36 = objc_msgSend(v35, "isLockedError:", v20);

    v37 = sub_10000EF14("octagon-ckks");
    v38 = objc_claimAutoreleasedReturnValue(v37);
    v39 = os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT);
    if (v36)
    {
      if (v39)
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "Waiting for device unlock to proceed", buf, 2u);
      }
      v40 = &off_1002E9098;
    }
    else
    {
      if (v39)
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "Error is scary; becoming untrusted",
          buf,
          2u);
      }
      v40 = &off_1002E92F0;
    }

    objc_msgSend(v3, "setNextState:", *v40);
  }
  else
  {
    v31 = sub_10000EF14("SecError");
    v32 = objc_claimAutoreleasedReturnValue(v31);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "octagon-ckks: No memoized CKKS policy, re-fetching", buf, 2u);
    }

    objc_msgSend(v3, "setNextState:", CFSTR("RefetchCKKSPolicy"));
  }
LABEL_30:
  _Block_object_dispose(&v48, 8);

  _Block_object_dispose(&v54, 8);
}

void sub_1000F34E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  uint64_t v11;
  va_list va;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a10);
  va_start(va, a10);
  v11 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

id sub_1000F3520(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  unsigned int v7;
  void *v8;

  v3 = a2;
  v4 = objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "peerID"));
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v6 = *(void **)(v5 + 40);
  *(_QWORD *)(v5 + 40) = v4;

  v7 = objc_msgSend(v3, "hasSyncingPolicy");
  if (v7)
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "getTPSyncingPolicy"));
  else
    v8 = 0;
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), v8);
  if (v7)

  return v3;
}

void sub_1000F35B0(uint64_t a1, void *a2)
{
  id v3;
  id WeakRetained;
  void *v5;
  unsigned int v6;
  void *v7;
  const void *v8;
  NSObject *v9;
  id v10;
  void *v11;
  const void *v12;
  NSObject *v13;
  void *v14;
  const void *v15;
  NSObject *v16;
  void *v17;
  void *v18;
  void *v19;
  unsigned int v20;
  void *v21;
  id v22;
  const void *v23;
  NSObject *v24;
  id v25;
  id v26;
  _QWORD v27[5];
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  char v31;
  uint8_t buf[4];
  id v33;

  v3 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "contextID"));
  v6 = objc_msgSend(v5, "isEqualToString:", CFSTR("defaultContext"));

  if (v6)
  {
    v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "accountStateTracker"));
    objc_msgSend(v7, "triggerOctagonStatusFetch");

  }
  v28 = 0;
  v29 = &v28;
  v30 = 0x2020000000;
  v31 = 0;
  v27[0] = _NSConcreteStackBlock;
  v27[1] = 3221225472;
  v27[2] = sub_1000F3994;
  v27[3] = &unk_1002DD8C8;
  v27[4] = &v28;
  objc_msgSend(WeakRetained, "checkTrustStatusAndPostRepairCFUIfNecessary:", v27);
  if (*((_BYTE *)v29 + 24))
  {
    v8 = sub_10000EF14("octagon");
    v9 = objc_claimAutoreleasedReturnValue(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "device is locked, state moving to wait for unlock", buf, 2u);
    }

    objc_msgSend(v3, "setNextState:", CFSTR("WaitForUnlock"));
    v10 = 0;
  }
  else
  {
    v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "accountMetadataStore"));
    v26 = 0;
    objc_msgSend(v11, "persistAccountChanges:error:", &stru_1002DD980, &v26);
    v10 = v26;

    objc_msgSend(WeakRetained, "setMetricsStateToActive");
    if (v10)
    {
      v12 = sub_10000EF14("octagon");
      v13 = objc_claimAutoreleasedReturnValue(v12);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v33 = v10;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Unable to set trust state: %@", buf, 0xCu);
      }

      objc_msgSend(v3, "setNextState:", CFSTR("Error"));
    }
    else
    {
      v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "intendedState"));
      objc_msgSend(v3, "setNextState:", v14);

    }
    v15 = sub_10000EF14("octagon-ckks");
    v16 = objc_claimAutoreleasedReturnValue(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "ckks"));
      *(_DWORD *)buf = 138412290;
      v33 = v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Informing %@ of new untrusted status", buf, 0xCu);

    }
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "ckks"));
    objc_msgSend(v18, "endTrustedOperation");

    v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "sosAdapter"));
    v20 = objc_msgSend(v19, "sosEnabled");

    if (v20)
    {
      v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "sosAdapter"));
      v25 = 0;
      objc_msgSend(v21, "updateCKKS4AllStatus:error:", 0, &v25);
      v22 = v25;

      if (v22)
      {
        v23 = sub_10000EF14("octagon-ckks");
        v24 = objc_claimAutoreleasedReturnValue(v23);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          v33 = v22;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Unable to disable the CKKS4All status in SOS: %@", buf, 0xCu);
        }

      }
    }
    if ((objc_msgSend(WeakRetained, "initialBecomeUntrustedPosted") & 1) == 0)
    {
      objc_msgSend(WeakRetained, "notifyTrustChanged:", 1);
      objc_msgSend(WeakRetained, "setInitialBecomeUntrustedPosted:", 1);
    }
    objc_msgSend(WeakRetained, "setOctagonAdapter:", 0);
  }
  _Block_object_dispose(&v28, 8);

}

void sub_1000F396C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000F3994(uint64_t a1, uint64_t a2, int a3, uint64_t a4, char a5, void *a6)
{
  id v10;
  void *v11;
  const void *v12;
  NSObject *v13;
  uint64_t v14;
  void *v15;
  const void *v16;
  const char *v17;
  NSObject *v18;
  uint32_t v19;
  const void *v20;
  int v21;
  id v22;
  __int16 v23;
  int v24;

  v10 = a6;
  v11 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v11, "logResultForEvent:hardFailure:result:", CFSTR("OctagonEventCheckTrustForCFU"), 0, v10);

  if (!v10)
  {
    if ((a5 & 1) == 0)
      goto LABEL_5;
    goto LABEL_8;
  }
  if (objc_msgSend(v10, "code") != (id)-25308)
  {
    v20 = sub_10000EF14("SecError");
    v13 = objc_claimAutoreleasedReturnValue(v20);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      goto LABEL_13;
    v21 = 138412290;
    v22 = v10;
    v17 = "octagon: hit an error checking trust state or posting a cfu: %@";
    v18 = v13;
    v19 = 12;
    goto LABEL_12;
  }
  if ((a5 & 1) != 0 || objc_msgSend(v10, "code") == (id)-25308)
  {
LABEL_8:
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a5;
    v16 = sub_10000EF14("SecError");
    v13 = objc_claimAutoreleasedReturnValue(v16);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      goto LABEL_13;
    LOWORD(v21) = 0;
    v17 = "octagon: device is locked, not posting cfu";
    v18 = v13;
    v19 = 2;
LABEL_12:
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v17, (uint8_t *)&v21, v19);
    goto LABEL_13;
  }
LABEL_5:
  v12 = sub_10000EF14("octagon");
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = OTCliqueStatusToString(a2);
    v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
    v21 = 138412546;
    v22 = v15;
    v23 = 1024;
    v24 = a3;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "clique status: %@, posted cfu: %d", (uint8_t *)&v21, 0x12u);

  }
LABEL_13:

}

OTAccountMetadataClassC *__cdecl sub_1000F3B90(id a1, OTAccountMetadataClassC *a2)
{
  OTAccountMetadataClassC *v2;

  v2 = a2;
  -[OTAccountMetadataClassC setTrustState:](v2, "setTrustState:", 1);
  -[OTAccountMetadataClassC setSendingMetricsPermitted:](v2, "setSendingMetricsPermitted:", 1);
  return v2;
}

void sub_1000F3BC8(uint64_t a1, uint64_t a2, void *a3, void *a4, int a5, int a6, void *a7)
{
  id v13;
  id v14;
  id v15;
  id WeakRetained;
  const void *v17;
  NSObject *v18;
  uint64_t v19;
  NSObject *v20;
  const void *v21;
  NSObject *v22;
  const void *v23;
  NSObject *v24;
  id v25;
  void (*v26)(void);
  const void *v27;
  NSObject *v28;
  void (*v29)(void);
  void *v30;
  unsigned int v31;
  void *v32;
  void *v33;
  NSObject *v34;
  void *v35;
  const void *v36;
  NSObject *v37;
  void *v38;
  NSObject *v39;
  void *v40;
  const void *v41;
  NSObject *v42;
  void *v43;
  const void *v44;
  const void *v45;
  _BOOL4 v46;
  NSObject *v47;
  NSObject *v48;
  const void *v49;
  unsigned int v50;
  NSObject *v51;
  os_log_t loga;
  NSObject *log;
  void *v54;
  id v55;
  id v56;
  id v57;
  id v58;
  uint8_t buf[4];
  NSObject *v60;
  __int16 v61;
  id v62;
  __int16 v63;
  id v64;
  __int16 v65;
  int v66;
  __int16 v67;
  id v68;

  v13 = a3;
  v14 = a4;
  v15 = a7;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v17 = sub_10000EF14("octagon");
  v18 = objc_claimAutoreleasedReturnValue(v17);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    v19 = OTCliqueStatusToString(a2);
    v20 = objc_claimAutoreleasedReturnValue(v19);
    *(_DWORD *)buf = 138413314;
    v60 = v20;
    v61 = 2112;
    v62 = v13;
    v63 = 2112;
    v64 = v14;
    v65 = 1024;
    v66 = a5;
    v67 = 2112;
    v68 = v15;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "clique status: %@, egoPeerID: %@, peerCountByModelID: %@, isExcluded: %d error: %@", buf, 0x30u);

  }
  if (a2 == -1 && objc_msgSend(v15, "code") == (id)-25300)
  {
    v21 = sub_10000EF14("SecError");
    v22 = objc_claimAutoreleasedReturnValue(v21);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "octagon: Lost our identity keys!", buf, 2u);
    }

    v23 = sub_10000EF14("SecError");
    v24 = objc_claimAutoreleasedReturnValue(v23);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "octagon: Posting CFU", buf, 2u);
    }

    v58 = 0;
    objc_msgSend(WeakRetained, "postRepairCFU:", &v58);
    v25 = v58;
    v26 = *(void (**)(void))(*(_QWORD *)(a1 + 32) + 16);
    goto LABEL_49;
  }
  if (v15 && objc_msgSend(v15, "code") != (id)-25308)
  {
    v29 = *(void (**)(void))(*(_QWORD *)(a1 + 32) + 16);
    goto LABEL_47;
  }
  if (a6)
  {
    v27 = sub_10000EF14("octagon");
    v28 = objc_claimAutoreleasedReturnValue(v27);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "device is locked; not posting CFU", buf, 2u);
    }

    v29 = *(void (**)(void))(*(_QWORD *)(a1 + 32) + 16);
    goto LABEL_47;
  }
  v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "sosAdapter"));
  v31 = objc_msgSend(v30, "sosEnabled");

  if (v31)
  {
    v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "accountMetadataStore"));
    v57 = 0;
    v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v32, "loadOrCreateAccountMetadata:", &v57));
    v34 = v57;

    v35 = v33;
    if (!v33 || v34)
    {
      v44 = sub_10000EF14("SecError");
      v39 = objc_claimAutoreleasedReturnValue(v44);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v60 = v34;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "octagon: failed to retrieve joining attempt information: %@", buf, 0xCu);
      }
      goto LABEL_42;
    }
    if (objc_msgSend(v33, "attemptedJoin") == 2)
    {
LABEL_43:

      goto LABEL_44;
    }
    v54 = v33;
    v36 = sub_10000EF14("octagon");
    v37 = objc_claimAutoreleasedReturnValue(v36);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "SOS is enabled and we haven't attempted to join; checking with SOS",
        buf,
        2u);
    }

    v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "sosAdapter"));
    v56 = 0;
    v50 = objc_msgSend(v38, "circleStatus:", &v56);
    v39 = v56;

    if (v39)
    {
      v40 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject domain](v39, "domain"));
      if ((objc_msgSend(v40, "isEqualToString:", kSOSErrorDomain) & 1) != 0)
      {
        loga = (os_log_t)-[NSObject code](v39, "code");

        if (loga == (os_log_t)4)
        {
          v41 = sub_10000EF14("octagon");
          v42 = objc_claimAutoreleasedReturnValue(v41);
          v43 = v54;
          if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "SOS is not ready, not posting CFU until it becomes so", buf, 2u);
          }
          goto LABEL_52;
        }
      }
      else
      {

      }
      v49 = sub_10000EF14("octagon");
      log = objc_claimAutoreleasedReturnValue(v49);
      v35 = v54;
      if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v60 = v39;
        _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "SOS is in an unknown error state, posting CFU: %@", buf, 0xCu);
      }
    }
    else
    {
      v45 = sub_10000EF14("octagon");
      log = objc_claimAutoreleasedReturnValue(v45);
      v46 = os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT);
      if (!v50)
      {
        if (v46)
        {
          *(_WORD *)buf = 0;
          v42 = log;
          _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "SOS is InCircle, not posting CFU", buf, 2u);
        }
        else
        {
          v42 = log;
        }
        v43 = v54;
LABEL_52:

        (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
        goto LABEL_50;
      }
      if (v46)
      {
        v47 = SOSCCGetStatusDescription(v50);
        *(_DWORD *)buf = 138412290;
        v60 = v47;
        v51 = v47;
        _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "SOS is %@, posting CFU", buf, 0xCu);

        v48 = log;
        v35 = v54;
LABEL_41:

LABEL_42:
        goto LABEL_43;
      }
      v35 = v54;
    }
    v48 = log;
    goto LABEL_41;
  }
LABEL_44:
  if ((a2 & 0xFFFFFFFFFFFFFFFDLL) == 1 || a5)
  {
    v55 = 0;
    objc_msgSend(WeakRetained, "postRepairCFU:", &v55);
    v25 = v55;
    v26 = *(void (**)(void))(*(_QWORD *)(a1 + 32) + 16);
LABEL_49:
    v26();

    goto LABEL_50;
  }
  v29 = *(void (**)(void))(*(_QWORD *)(a1 + 32) + 16);
LABEL_47:
  v29();
LABEL_50:

}

void sub_1000F428C(uint64_t a1, void *a2, void *a3, uint64_t a4, int a5, int a6, void *a7)
{
  id v12;
  id v13;
  const void *v14;
  NSObject *v15;
  const void *v16;
  NSObject *v17;
  uint64_t v18;
  __CFString *v19;
  const void *v20;
  NSObject *v21;
  const void *v22;
  NSObject *v23;
  void *v24;
  unsigned int v25;
  id v26;
  const void *v27;
  NSObject *v28;
  void *v29;
  uint64_t v30;
  id v31;
  void *v32;
  const void *v33;
  NSObject *v34;
  __CFString *v35;
  const void *v36;
  NSObject *v37;
  uint64_t v38;
  __CFString *v39;
  id v40;
  _QWORD v41[4];
  id v42;
  uint8_t buf[4];
  id v44;
  __int16 v45;
  id v46;
  __int16 v47;
  int v48;
  __int16 v49;
  id v50;

  v12 = a3;
  v13 = a7;
  v14 = sub_10000EF14("octagon-health");
  v15 = objc_claimAutoreleasedReturnValue(v14);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134218754;
    v44 = a2;
    v45 = 2112;
    v46 = v12;
    v47 = 1024;
    v48 = a5;
    v49 = 2112;
    v50 = v13;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "repairAccountIfTrustedByTPHWithIntendedState status: %ld, peerID: %@, isExcluded: %d error: %@", buf, 0x26u);
  }

  if (v13)
  {
    v16 = sub_10000EF14("octagon-health");
    v17 = objc_claimAutoreleasedReturnValue(v16);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v44 = v13;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "got an error from tph, returning to become_ready state: %@", buf, 0xCu);
    }

    v18 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
    v19 = CFSTR("BecomeReady");
LABEL_25:
    v35 = v19;
    v26 = *(id *)(v18 + 40);
    *(_QWORD *)(v18 + 40) = v19;
LABEL_26:

    goto LABEL_27;
  }
  if (a6)
  {
    v20 = sub_10000EF14("octagon-health");
    v21 = objc_claimAutoreleasedReturnValue(v20);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "device is locked", buf, 2u);
    }

    v18 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
    v19 = CFSTR("WaitForUnlock");
    goto LABEL_25;
  }
  if (!a2 && v12)
  {
    v22 = sub_10000EF14("octagon-health");
    v23 = objc_claimAutoreleasedReturnValue(v22);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v44 = v12;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "TPH believes we're trusted, accepting ego peerID as %@", buf, 0xCu);
    }

    v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "accountMetadataStore"));
    v41[0] = _NSConcreteStackBlock;
    v41[1] = 3221225472;
    v41[2] = sub_1000F4698;
    v41[3] = &unk_1002EAF10;
    v42 = v12;
    v40 = 0;
    v25 = objc_msgSend(v24, "persistAccountChanges:error:", v41, &v40);
    v26 = v40;

    if (!v25 || v26)
    {
      v36 = sub_10000EF14("SecError");
      v37 = objc_claimAutoreleasedReturnValue(v36);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v44 = v26;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "octagon-health: couldn't persist results: %@", buf, 0xCu);
      }

      v38 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
      v39 = CFSTR("Error");
      v32 = *(void **)(v38 + 40);
      *(_QWORD *)(v38 + 40) = CFSTR("Error");
    }
    else
    {
      v27 = sub_10000EF14("octagon-health");
      v28 = objc_claimAutoreleasedReturnValue(v27);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "added trusted identity to account metadata", buf, 2u);
      }

      v29 = *(void **)(a1 + 40);
      v30 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
      v31 = v29;
      v32 = *(void **)(v30 + 40);
      *(_QWORD *)(v30 + 40) = v31;
    }

    goto LABEL_26;
  }
  if (a2 && v12)
  {
    v33 = sub_10000EF14("octagon-health");
    v34 = objc_claimAutoreleasedReturnValue(v33);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "TPH believes we're not trusted, requesting CFU post", buf, 2u);
    }

    v18 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
    v19 = CFSTR("PostRepairCFU");
    goto LABEL_25;
  }
LABEL_27:

}

id sub_1000F4698(uint64_t a1, void *a2)
{
  id v3;

  v3 = a2;
  objc_msgSend(v3, "setTrustState:", 2);
  objc_msgSend(v3, "setPeerID:", *(_QWORD *)(a1 + 32));
  return v3;
}

void sub_1000F46D4(uint64_t a1, void *a2)
{
  id v3;
  id *v4;
  id WeakRetained;
  void *v6;
  void *v7;
  id v8;
  void *v9;
  unsigned int v10;
  const void *v11;
  NSObject *v12;
  const void *v13;
  NSObject *v14;
  void *v15;
  _BOOL4 v16;
  const void *v17;
  NSObject *v18;
  _BOOL4 v19;
  CKKSCondition *v20;
  dispatch_queue_global_t global_queue;
  NSObject *v22;
  void *v23;
  id v24;
  const void *v25;
  NSObject *v26;
  const char *v27;
  NSObject *v28;
  uint32_t v29;
  const void *v30;
  const void *v31;
  NSObject *v32;
  void *v33;
  void *v34;
  void *v35;
  void **v36;
  uint64_t v37;
  void (*v38)(uint64_t, void *, void *);
  void *v39;
  id v40;
  id v41;
  _QWORD block[4];
  id v43;
  id v44;
  uint8_t buf[4];
  id v46;

  v3 = a2;
  v4 = (id *)(a1 + 32);
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "accountMetadataStore"));
  v44 = 0;
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "loadOrCreateAccountMetadata:", &v44));
  v8 = v44;

  if (v8)
  {
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "lockStateTracker"));
    v10 = objc_msgSend(v9, "isLockedError:", v8);

    if (v10)
    {
      v11 = sub_10000EF14("octagon");
      v12 = objc_claimAutoreleasedReturnValue(v11);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Device is locked! pending initialization on unlock", buf, 2u);
      }

      objc_msgSend(v3, "setNextState:", CFSTR("WaitForClassCUnlock"));
      goto LABEL_30;
    }
  }
  else if (v7)
  {
    goto LABEL_10;
  }
  v13 = sub_10000EF14("octagon");
  v14 = objc_claimAutoreleasedReturnValue(v13);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    v46 = v8;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Error loading account data: %@", buf, 0xCu);
  }

  objc_msgSend(v3, "setNextState:", CFSTR("NoAccount"));
LABEL_10:
  if (objc_msgSend(v7, "isInheritedAccount"))
  {
    objc_msgSend(v3, "setNextState:", CFSTR("BecomeInherited"));
    goto LABEL_30;
  }
  if ((objc_msgSend(v7, "warmedEscrowCache") & 1) != 0)
    goto LABEL_27;
  v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "peerID"));
  v16 = v15 == 0;

  v17 = sub_10000EF14("octagon-warm-escrowcache");
  v18 = objc_claimAutoreleasedReturnValue(v17);
  v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT);
  if (v16)
  {
    if (v19)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Beginning fetching escrow records to warm up the escrow cache in TPH", buf, 2u);
    }

    v20 = objc_alloc_init(CKKSCondition);
    objc_msgSend(WeakRetained, "setPendingEscrowCacheWarmup:", v20);

    global_queue = dispatch_get_global_queue(17, 0);
    v22 = objc_claimAutoreleasedReturnValue(global_queue);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000F4BC8;
    block[3] = &unk_1002EB598;
    objc_copyWeak(&v43, v4);
    dispatch_async(v22, block);

    objc_destroyWeak(&v43);
  }
  else
  {
    if (v19)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Already have a peerID; no need to warm escrow cache",
        buf,
        2u);
    }

  }
  v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "accountMetadataStore"));
  v41 = 0;
  objc_msgSend(v23, "persistAccountChanges:error:", &stru_1002DD8E8, &v41);
  v24 = v41;

  if (v24)
  {
    v25 = sub_10000EF14("SecError");
    v26 = objc_claimAutoreleasedReturnValue(v25);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v46 = v24;
      v27 = "octagon-warm-escrowcache: Failed to write down escrow cache attempt: %@";
      v28 = v26;
      v29 = 12;
LABEL_25:
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, v27, buf, v29);
    }
  }
  else
  {
    v30 = sub_10000EF14("octagon-warm-escrowcache");
    v26 = objc_claimAutoreleasedReturnValue(v30);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v27 = "Successfully persisted warmed-escrow-cache attempt state";
      v28 = v26;
      v29 = 2;
      goto LABEL_25;
    }
  }

LABEL_27:
  v31 = sub_10000EF14("octagon");
  v32 = objc_claimAutoreleasedReturnValue(v31);
  if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "iCloud sign in occurred. Attempting to register with APS...", buf, 2u);
  }

  v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "containerName"));
  v34 = (void *)objc_claimAutoreleasedReturnValue(+[CKContainer containerWithIdentifier:](CKContainer, "containerWithIdentifier:", v33));

  v36 = _NSConcreteStackBlock;
  v37 = 3221225472;
  v38 = sub_1000F4C70;
  v39 = &unk_1002DD910;
  objc_copyWeak(&v40, v4);
  objc_msgSend(v34, "serverPreferredPushEnvironmentWithCompletionHandler:", &v36);
  v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "intendedState", v36, v37, v38, v39));
  objc_msgSend(v3, "setNextState:", v35);

  objc_destroyWeak(&v40);
LABEL_30:

}

void sub_1000F4BA8(_Unwind_Exception *a1)
{
  id *v1;

  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_1000F4BC8(uint64_t a1)
{
  id *v1;
  id WeakRetained;
  _QWORD v3[4];
  id v4;

  v1 = (id *)(a1 + 32);
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_1000F4E4C;
  v3[3] = &unk_1002E8BE8;
  objc_copyWeak(&v4, v1);
  objc_msgSend(WeakRetained, "rpcFetchAllViableEscrowRecordsFromSource:reply:", 0, v3);
  objc_destroyWeak(&v4);

}

void sub_1000F4C5C(_Unwind_Exception *a1)
{
  id *v1;

  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_1000F4C70(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id WeakRetained;
  const void *v8;
  NSObject *v9;
  NSObject *v10;
  const void *v11;
  const char *v12;
  NSObject *v13;
  uint32_t v14;
  const void *v15;
  int v16;
  id v17;
  __int16 v18;
  id v19;

  v5 = a2;
  v6 = a3;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (!WeakRetained)
  {
    v11 = sub_10000EF14("SecError");
    v10 = objc_claimAutoreleasedReturnValue(v11);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      goto LABEL_12;
    LOWORD(v16) = 0;
    v12 = "octagonpush: received callback for released object";
    v13 = v10;
    v14 = 2;
LABEL_11:
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v16, v14);
    goto LABEL_12;
  }
  if (!v5 || v6)
  {
    v15 = sub_10000EF14("SecError");
    v10 = objc_claimAutoreleasedReturnValue(v15);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      goto LABEL_12;
    v16 = 138412546;
    v17 = v5;
    v18 = 2112;
    v19 = v6;
    v12 = "octagonpush: Received error fetching preferred push environment (%@): %@";
    v13 = v10;
    v14 = 22;
    goto LABEL_11;
  }
  v8 = sub_10000EF14("octagonpush");
  v9 = objc_claimAutoreleasedReturnValue(v8);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    v16 = 138412290;
    v17 = v5;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Registering for environment '%@'", (uint8_t *)&v16, 0xCu);
  }

  v10 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "apsReceiver"));
  -[NSObject registerForEnvironment:](v10, "registerForEnvironment:", v5);
LABEL_12:

}

OTAccountMetadataClassC *__cdecl sub_1000F4E20(id a1, OTAccountMetadataClassC *a2)
{
  OTAccountMetadataClassC *v2;

  v2 = a2;
  -[OTAccountMetadataClassC setWarmedEscrowCache:](v2, "setWarmedEscrowCache:", 1);
  return v2;
}

void sub_1000F4E4C(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  id WeakRetained;
  const void *v6;
  NSObject *v7;
  const char *v8;
  NSObject *v9;
  uint32_t v10;
  const void *v11;
  void *v12;
  int v13;
  id v14;

  v4 = a3;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (v4)
  {
    v6 = sub_10000EF14("SecError");
    v7 = objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v13 = 138412290;
      v14 = v4;
      v8 = "octagon-warm-escrowcache: failed to fetch escrow records, %@";
      v9 = v7;
      v10 = 12;
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v13, v10);
    }
  }
  else
  {
    v11 = sub_10000EF14("octagon-warm-escrowcache");
    v7 = objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v13) = 0;
      v8 = "Successfully fetched escrow records";
      v9 = v7;
      v10 = 2;
      goto LABEL_6;
    }
  }

  v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "pendingEscrowCacheWarmup"));
  objc_msgSend(v12, "fulfill");

}

void sub_1000F4F7C(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  const __CFString *v5;
  _QWORD v6[5];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  char v10;

  v3 = a2;
  v7 = 0;
  v8 = &v7;
  v9 = 0x2020000000;
  v10 = 0;
  v4 = *(void **)(a1 + 32);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_1000F504C;
  v6[3] = &unk_1002DD8C8;
  v6[4] = &v7;
  objc_msgSend(v4, "checkTrustStatusAndPostRepairCFUIfNecessary:", v6);
  if (*((_BYTE *)v8 + 24))
    v5 = CFSTR("WaitForUnlock");
  else
    v5 = CFSTR("Untrusted");
  objc_msgSend(v3, "setNextState:", v5);
  _Block_object_dispose(&v7, 8);

}

void sub_1000F5034(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000F504C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, void *a6)
{
  id v8;
  const void *v9;
  NSObject *v10;
  const char *v11;
  NSObject *v12;
  uint32_t v13;
  const void *v14;
  const void *v15;
  int v16;
  id v17;

  v8 = a6;
  if (!v8)
  {
    if (a5)
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a5;
      v14 = sub_10000EF14("octagon-health");
      v10 = objc_claimAutoreleasedReturnValue(v14);
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        goto LABEL_11;
      LOWORD(v16) = 0;
      v11 = "device is locked, not posting cfu";
    }
    else
    {
      v15 = sub_10000EF14("octagon-health");
      v10 = objc_claimAutoreleasedReturnValue(v15);
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        goto LABEL_11;
      LOWORD(v16) = 0;
      v11 = "posted repair cfu via state machine";
    }
    v12 = v10;
    v13 = 2;
    goto LABEL_10;
  }
  v9 = sub_10000EF14("SecError");
  v10 = objc_claimAutoreleasedReturnValue(v9);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    v16 = 138412290;
    v17 = v8;
    v11 = "ocagon-health: failed to post repair cfu via state machine: %@";
    v12 = v10;
    v13 = 12;
LABEL_10:
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v11, (uint8_t *)&v16, v13);
  }
LABEL_11:

}

void sub_1000F51A0(uint64_t a1)
{
  const void *v2;
  NSObject *v3;
  unsigned int v4;
  unsigned int v5;
  void *v6;
  unsigned int v7;
  void *v8;
  void *v9;
  void *v10;
  uint64_t v11;
  void *v12;
  void *v13;
  unsigned int v14;
  const void *v15;
  NSObject *v16;
  id v17;
  void *v18;
  unsigned int v19;
  unsigned int v20;
  id v21;
  const void *v22;
  NSObject *v23;
  const void *v24;
  NSObject *v25;
  _BOOL4 v26;
  unsigned __int8 v27;
  void *v28;
  unsigned int v29;
  const void *v30;
  NSObject *v31;
  unsigned __int8 v32;
  id v33;
  void *v34;
  unsigned int v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  const void *v40;
  NSObject *v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  unsigned __int8 v46;
  id v47;
  unsigned int v48;
  unsigned int v49;
  id *from;
  void *v51;
  void *v52;
  void *v53;
  void *v54;
  _QWORD *WeakRetained;
  id v56;
  _QWORD v57[4];
  id v58;
  id v59;
  id v60;
  id v61;
  id v62;
  uint8_t buf[4];
  _BYTE v64[10];
  __int16 v65;
  unsigned int v66;
  __int16 v67;
  unsigned int v68;
  __int16 v69;
  unsigned int v70;
  __int16 v71;
  _BOOL4 v72;
  __int16 v73;
  void *v74;

  from = (id *)(a1 + 40);
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v2 = sub_10000EF14("octagon-health");
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v54 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "results"));
    v49 = objc_msgSend(v54, "postRepairCFU");
    v53 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "results"));
    v48 = objc_msgSend(v53, "postEscrowCFU");
    v52 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "results"));
    v4 = objc_msgSend(v52, "resetOctagon");
    v51 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "results"));
    v5 = objc_msgSend(v51, "leaveTrust");
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "results"));
    v7 = objc_msgSend(v6, "reroll");
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "results"));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "moveRequest"));
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "results"));
    *(_DWORD *)buf = 67110658;
    *(_DWORD *)v64 = v49;
    *(_WORD *)&v64[4] = 1024;
    *(_DWORD *)&v64[6] = v48;
    v65 = 1024;
    v66 = v4;
    v67 = 1024;
    v68 = v5;
    v69 = 1024;
    v70 = v7;
    v71 = 1024;
    v72 = v9 != 0;
    v73 = 2112;
    v74 = v10;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Returning from cuttlefish trust check call: postRepairCFU(%d), postEscrowCFU(%d), resetOctagon(%d), leaveTrust(%d), reroll(%d), moveRequest(%d), results=%@", buf, 0x30u);

  }
  v11 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "results"));
  v12 = (void *)WeakRetained[8];
  WeakRetained[8] = v11;

  v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "results"));
  v14 = objc_msgSend(v13, "postRepairCFU");

  if (v14)
  {
    v15 = sub_10000EF14("octagon-health");
    v16 = objc_claimAutoreleasedReturnValue(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Posting Repair CFU", buf, 2u);
    }

    v62 = 0;
    objc_msgSend(WeakRetained, "postRepairCFU:", &v62);
    v17 = v62;
    if (v17)
      objc_msgSend(*(id *)(a1 + 32), "setError:", v17);

  }
  v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "results"));
  v19 = objc_msgSend(v18, "postEscrowCFU");

  if (v19)
  {
    v61 = 0;
    v20 = objc_msgSend(WeakRetained, "shouldPostConfirmPasscodeCFU:", &v61);
    v21 = v61;
    if (v21)
    {
      v22 = sub_10000EF14("SecError");
      v23 = objc_claimAutoreleasedReturnValue(v22);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        *(_QWORD *)v64 = v21;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "octagon-health, hit an error evaluating prerecord status: %@", buf, 0xCu);
      }

      objc_msgSend(*(id *)(a1 + 32), "setError:", v21);
    }
    v24 = sub_10000EF14("octagon-health");
    v25 = objc_claimAutoreleasedReturnValue(v24);
    v26 = os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT);
    if (v20)
    {
      if (v26)
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Posting Escrow CFU", buf, 2u);
      }

      v60 = 0;
      v27 = objc_msgSend(WeakRetained, "postConfirmPasscodeCFU:", &v60);
      v25 = v60;
      if ((v27 & 1) == 0)
        objc_msgSend(*(id *)(a1 + 32), "setError:", v25);
    }
    else if (v26)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Not posting confirm passcode CFU, already pending a prerecord upload", buf, 2u);
    }

  }
  v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "results"));
  v29 = objc_msgSend(v28, "leaveTrust");

  if (v29)
  {
    v30 = sub_10000EF14("octagon-health");
    v31 = objc_claimAutoreleasedReturnValue(v30);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "Leaving Octagon and SOS trust", buf, 2u);
    }

    v59 = 0;
    v32 = objc_msgSend(WeakRetained, "leaveTrust:", &v59);
    v33 = v59;
    if ((v32 & 1) == 0)
      objc_msgSend(*(id *)(a1 + 32), "setError:", v33);

  }
  v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "results"));
  v35 = objc_msgSend(v34, "reroll");

  if (v35)
  {
    v57[0] = _NSConcreteStackBlock;
    v57[1] = 3221225472;
    v57[2] = sub_1000F5840;
    v57[3] = &unk_1002DD8A0;
    objc_copyWeak(&v58, from);
    v36 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSResultOperation named:withBlockTakingSelf:](CKKSResultOperation, "named:withBlockTakingSelf:", CFSTR("reroll"), v57));
    objc_msgSend(*(id *)(a1 + 32), "addDependency:", v36);
    v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "operationQueue"));
    objc_msgSend(v37, "addOperation:", v36);

    objc_destroyWeak(&v58);
  }
  v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "results"));
  v39 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v38, "moveRequest"));

  if (v39)
  {
    v40 = sub_10000EF14("octagon-health");
    v41 = objc_claimAutoreleasedReturnValue(v40);
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
    {
      v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "results"));
      v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v42, "moveRequest"));
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)v64 = v43;
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "Received escrow move request: %@", buf, 0xCu);

    }
    v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "results"));
    v45 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v44, "moveRequest"));
    v56 = 0;
    v46 = objc_msgSend(WeakRetained, "processMoveRequest:error:", v45, &v56);
    v47 = v56;

    if ((v46 & 1) == 0)
      objc_msgSend(*(id *)(a1 + 32), "setError:", v47);

  }
}

void sub_1000F5820(_Unwind_Exception *a1)
{
  id *v1;

  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_1000F5840(uint64_t a1, void *a2)
{
  id v3;
  id WeakRetained;
  const void *v5;
  NSObject *v6;
  id v7;
  _QWORD v8[4];
  id v9;
  uint8_t buf[16];

  v3 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v5 = sub_10000EF14("octagon-health");
  v6 = objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Rerolling Octagon PeerID", buf, 2u);
  }

  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_1000F5920;
  v8[3] = &unk_1002DD798;
  v9 = v3;
  v7 = v3;
  objc_msgSend(WeakRetained, "rerollWithReply:", v8);

}

void sub_1000F5920(uint64_t a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  int v6;
  id v7;

  v3 = a2;
  if (v3)
  {
    v4 = sub_10000EF14("SecError");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = 138412290;
      v7 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "octagon-health: reroll failed: %@", (uint8_t *)&v6, 0xCu);
    }

    objc_msgSend(*(id *)(a1 + 32), "setError:", v3);
  }

}

void sub_1000F59EC(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  id v5;
  _QWORD v6[4];
  id v7;

  v3 = a2;
  v4 = *(void **)(a1 + 32);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_1000F5A68;
  v6[3] = &unk_1002DD878;
  v7 = v3;
  v5 = v3;
  objc_msgSend(v4, "checkTrustStatusAndPostRepairCFUIfNecessary:", v6);

}

void sub_1000F5A68(uint64_t a1, uint64_t a2, int a3, char a4, int a5, void *a6)
{
  id v11;
  void *v12;
  const void *v13;
  NSObject *v14;
  void *v15;
  const __CFString *v16;
  const void *v17;
  NSObject *v18;
  const void *v19;
  NSObject *v20;
  _BOOL4 v21;
  int v22;
  id v23;

  v11 = a6;
  v12 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v12, "logResultForEvent:hardFailure:result:", CFSTR("OctagonEventTPHHealthCheckStatus"), 0, v11);

  if (v11)
  {
    v13 = sub_10000EF14("SecError");
    v14 = objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      v22 = 138412290;
      v23 = v11;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "octagon-health: hit an error asking TPH for trust status: %@", (uint8_t *)&v22, 0xCu);
    }

    objc_msgSend(*(id *)(a1 + 32), "setError:", v11);
    v15 = *(void **)(a1 + 32);
    v16 = CFSTR("Error");
LABEL_5:
    objc_msgSend(v15, "setNextState:", v16);
    goto LABEL_6;
  }
  if (!a5)
  {
    if ((a4 & 1) != 0)
    {
      v19 = sub_10000EF14("octagon-health");
      v20 = objc_claimAutoreleasedReturnValue(v19);
      v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT);
      if (a2)
      {
        if (v21)
        {
          v22 = 67109120;
          LODWORD(v23) = a3;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "TPH says we have an identity but we are not in Octagon, posted CFU: %d", (uint8_t *)&v22, 8u);
        }

        v15 = *(void **)(a1 + 32);
        v16 = CFSTR("PostRepairCFU");
      }
      else
      {
        if (v21)
        {
          LOWORD(v22) = 0;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "TPH says we're trusted and in", (uint8_t *)&v22, 2u);
        }

        v15 = *(void **)(a1 + 32);
        v16 = CFSTR("CuttlefishTrustCheck");
      }
    }
    else
    {
      v15 = *(void **)(a1 + 32);
      v16 = CFSTR("Untrusted");
    }
    goto LABEL_5;
  }
  objc_msgSend(*(id *)(a1 + 32), "setNextState:", CFSTR("WaitForUnlock"));
  v17 = sub_10000EF14("octagon-health");
  v18 = objc_claimAutoreleasedReturnValue(v17);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v22) = 0;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "TPH says device is locked!", (uint8_t *)&v22, 2u);
  }

LABEL_6:
}

void sub_1000F5CB4(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  id v6;
  uint64_t v7;
  void *v8;
  unsigned int v9;
  const void *v10;
  NSObject *v11;
  void *v12;
  const void *v13;
  NSObject *v14;
  void *v15;
  void *v16;
  id v17;
  uint8_t buf[4];
  void *v19;

  v3 = a2;
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "accountMetadataStore"));
  v17 = 0;
  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "loadOrCreateAccountMetadata:", &v17));
  v6 = v17;

  v7 = objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "peerID"));
  if (v7 && (v8 = (void *)v7, v9 = objc_msgSend(v5, "trustState"), v8, v9 == 2))
  {
    v10 = sub_10000EF14("octagon-health");
    v11 = objc_claimAutoreleasedReturnValue(v10);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "peerID"));
      *(_DWORD *)buf = 138412290;
      v19 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "peer is trusted: %@", buf, 0xCu);

    }
    objc_msgSend(v3, "setNextState:", CFSTR("TPHTrustCheck"));
  }
  else
  {
    v13 = sub_10000EF14("octagon-health");
    v14 = objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "trustStateAsString:", objc_msgSend(v5, "trustState")));
      *(_DWORD *)buf = 138412290;
      v19 = v15;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "trust state (%@). checking in with TPH", buf, 0xCu);

    }
    v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "repairAccountIfTrustedByTPHWithIntendedState:", CFSTR("TPHTrustCheck")));
    objc_msgSend(v3, "setNextState:", v16);

  }
}

void sub_1000F5EA8(uint64_t a1, void *a2)
{
  id v3;
  id WeakRetained;
  void *v5;
  void *v6;
  id v7;
  void *v8;
  unsigned int v9;
  const void *v10;
  NSObject *v11;
  __CFString **v12;
  const void *v13;
  NSObject *v14;
  id v15;
  uint8_t buf[4];
  id v17;

  v3 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "accountMetadataStore"));
  v15 = 0;
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "loadOrCreateAccountMetadata:", &v15));
  v7 = v15;

  if (v7)
  {
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "lockStateTracker"));
    v9 = objc_msgSend(v8, "isLockedError:", v7);

    if (v9)
    {
      v10 = sub_10000EF14("octagon");
      v11 = objc_claimAutoreleasedReturnValue(v10);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Device is locked! pending initialization on unlock", buf, 2u);
      }

      v12 = &off_1002E92D8;
      goto LABEL_11;
    }
  }
  else if (v6)
  {
    v12 = (__CFString **)(a1 + 32);
    goto LABEL_11;
  }
  v13 = sub_10000EF14("octagon");
  v14 = objc_claimAutoreleasedReturnValue(v13);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    v17 = v7;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Error loading account data: %@", buf, 0xCu);
  }

  v12 = &off_1002E9090;
LABEL_11:
  objc_msgSend(v3, "setNextState:", *v12);

}

void sub_1000F6054(uint64_t a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  void *v6;
  void *v7;
  id v8;
  const void *v9;
  NSObject *v10;
  void *v11;
  const void *v12;
  NSObject *v13;
  void *v14;
  void *v15;
  id v16;
  uint8_t buf[4];
  id v18;

  v3 = a2;
  v4 = sub_10000EF14("octagon");
  v5 = objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = *(void **)(a1 + 32);
    *(_DWORD *)buf = 138412290;
    v18 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Account now unavailable: %@", buf, 0xCu);
  }

  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "accountMetadataStore"));
  v16 = 0;
  objc_msgSend(v7, "persistAccountChanges:error:", &stru_1002DD828, &v16);
  v8 = v16;

  if (v8)
  {
    v9 = sub_10000EF14("SecError");
    v10 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v18 = v8;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "octagon: unable to persist new account availability: %@", buf, 0xCu);
    }

  }
  v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "accountStateTracker"));
  objc_msgSend(v11, "setCDPCapableiCloudAccountStatus:", 3);

  v12 = sub_10000EF14("octagon-ckks");
  v13 = objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "ckks"));
    *(_DWORD *)buf = 138412290;
    v18 = v14;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Informing %@ of new untrusted status (due to account disappearance)", buf, 0xCu);

  }
  v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "ckks"));
  objc_msgSend(v15, "endTrustedOperation");

  objc_msgSend(v3, "setError:", v8);
}

OTAccountMetadataClassC *__cdecl sub_1000F625C(id a1, OTAccountMetadataClassC *a2)
{
  OTAccountMetadataClassC *v2;

  v2 = a2;
  -[OTAccountMetadataClassC setIcloudAccountState:](v2, "setIcloudAccountState:", 1);
  -[OTAccountMetadataClassC setAltDSID:](v2, "setAltDSID:", 0);
  -[OTAccountMetadataClassC setTrustState:](v2, "setTrustState:", 0);
  -[OTAccountMetadataClassC setCdpState:](v2, "setCdpState:", 0);
  -[OTAccountMetadataClassC setSecureElementIdentity:](v2, "setSecureElementIdentity:", 0);
  return v2;
}

void sub_1000F62B8(uint64_t a1, void *a2)
{
  id v3;
  id WeakRetained;
  void *v5;
  void *v6;
  id v7;
  void *v8;
  unsigned int v9;
  const void *v10;
  NSObject *v11;
  const __CFString *v12;
  const void *v13;
  NSObject *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  id v21;
  void *v22;
  const void *v23;
  NSObject *v24;
  void *v25;
  void *v26;
  NSObject *v27;
  void *v28;
  const void *v29;
  NSObject *v30;
  void *v31;
  const void *v32;
  NSObject *v33;
  void *v34;
  const void *v35;
  NSObject *v36;
  const void *v37;
  void *v38;
  const void *v39;
  void *v40;
  uint64_t v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  unsigned __int8 v46;
  const void *v47;
  NSObject *v48;
  void *v49;
  void *v50;
  void *v51;
  void *v52;
  const void *v53;
  NSObject *v54;
  void *v55;
  void *v56;
  void *v57;
  void *v58;
  void *v59;
  void *v60;
  _QWORD v61[5];
  id v62;
  id v63;
  uint8_t buf[4];
  id v65;
  __int16 v66;
  id v67;

  v3 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "accountMetadataStore"));
  v63 = 0;
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "loadOrCreateAccountMetadata:", &v63));
  v7 = v63;

  if (v7)
  {
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "lockStateTracker"));
    v9 = objc_msgSend(v8, "isLockedError:", v7);

    if (v9)
    {
      v10 = sub_10000EF14("octagon");
      v11 = objc_claimAutoreleasedReturnValue(v10);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Device is locked! pending initialization on unlock", buf, 2u);
      }

      v12 = CFSTR("WaitForClassCUnlock");
      goto LABEL_20;
    }
    goto LABEL_16;
  }
  if (!v6)
  {
LABEL_16:
    v29 = sub_10000EF14("octagon");
    v30 = objc_claimAutoreleasedReturnValue(v29);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v65 = v7;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "Error loading account data: %@", buf, 0xCu);
    }

    objc_msgSend(WeakRetained, "setMetricsStateToActive");
LABEL_19:
    v12 = CFSTR("NoAccount");
    goto LABEL_20;
  }
  if (objc_msgSend(v6, "icloudAccountState") != 2)
  {
    if (objc_msgSend(v6, "icloudAccountState") == 1
      && (v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "altDSID")), v31, v31))
    {
      v32 = sub_10000EF14("octagon");
      v33 = objc_claimAutoreleasedReturnValue(v32);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "An iCloud account exists, but doesn't appear to be CDP Capable. Let's check!", buf, 2u);
      }
    }
    else
    {
      if (objc_msgSend(v6, "icloudAccountState") == 1)
      {
        v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "accountStateTracker"));
        objc_msgSend(v34, "setCDPCapableiCloudAccountStatus:", 3);

        v35 = sub_10000EF14("octagon");
        v36 = objc_claimAutoreleasedReturnValue(v35);
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "No iCloud account available.", buf, 2u);
        }

        objc_msgSend(WeakRetained, "setMetricsToState:", objc_msgSend(v6, "sendingMetricsPermitted"));
        goto LABEL_19;
      }
      v37 = sub_10000EF14("octagon");
      v33 = objc_claimAutoreleasedReturnValue(v37);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "icloudAccountStateAsString:", objc_msgSend(v6, "icloudAccountState")));
        *(_DWORD *)buf = 138412290;
        v65 = v38;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "Unknown account state (%@). Determining...", buf, 0xCu);

      }
    }

    objc_msgSend(WeakRetained, "setMetricsToState:", objc_msgSend(v6, "sendingMetricsPermitted"));
    v12 = CFSTR("DetermineiCloudAccountState");
    goto LABEL_20;
  }
  v13 = sub_10000EF14("octagon");
  v14 = objc_claimAutoreleasedReturnValue(v13);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "An CDP Capable iCloud account exists; waiting for CloudKit to confirm",
      buf,
      2u);
  }

  objc_msgSend(WeakRetained, "setMetricsToState:", objc_msgSend(v6, "sendingMetricsPermitted"));
  v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "activeAccount"));

  if (!v15)
  {
    v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "accountsAdapter"));
    v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "personaAdapter"));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "containerName"));
    v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "contextID"));
    v62 = 0;
    v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "findAccountForCurrentThread:optionalAltDSID:cloudkitContainerName:octagonContextID:error:", v17, 0, v18, v19, &v62));
    v21 = v62;
    objc_msgSend(WeakRetained, "setActiveAccount:", v20);

    v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "activeAccount"));
    if (!v22 || v21)
    {
      v39 = sub_10000EF14("SecError");
      v27 = objc_claimAutoreleasedReturnValue(v39);
      if (!os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        goto LABEL_35;
      v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "contextID"));
      *(_DWORD *)buf = 138412546;
      v65 = v28;
      v66 = 2112;
      v67 = v21;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "octagon-account: unable to determine active account for context(%@). Issues ahead: %@", buf, 0x16u);
    }
    else
    {
      v23 = sub_10000EF14("octagon-account");
      v24 = objc_claimAutoreleasedReturnValue(v23);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "contextID"));
        v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "activeAccount"));
        *(_DWORD *)buf = 138412546;
        v65 = v25;
        v66 = 2112;
        v67 = v26;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Found a new account (%@): %@", buf, 0x16u);

      }
      v27 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "accountMetadataStore"));
      v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "activeAccount"));
      -[NSObject changeActiveAccount:](v27, "changeActiveAccount:", v28);
    }

LABEL_35:
    v60 = v21;

    v40 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "activeAccount"));
    v41 = objc_claimAutoreleasedReturnValue(objc_msgSend(v40, "altDSID"));
    if (v41)
    {
      v42 = (void *)v41;
      v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "activeAccount", v21));
      v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v43, "altDSID"));
      v45 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "altDSID"));
      v46 = objc_msgSend(v44, "isEqualToString:", v45);

      if ((v46 & 1) != 0)
      {
LABEL_42:

        goto LABEL_43;
      }
    }
    else
    {

    }
    v47 = sub_10000EF14("SecError");
    v48 = objc_claimAutoreleasedReturnValue(v47);
    if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
    {
      v49 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "activeAccount"));
      v50 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v49, "altDSID"));
      v51 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "altDSID"));
      *(_DWORD *)buf = 138412546;
      v65 = v50;
      v66 = 2112;
      v67 = v51;
      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "octagon-account: discovered altDSID (%@) does not match persisted altDSID (%@)", buf, 0x16u);

    }
    goto LABEL_42;
  }
LABEL_43:
  v52 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "accountStateTracker", v60));
  objc_msgSend(v52, "setCDPCapableiCloudAccountStatus:", 1);

  v53 = sub_10000EF14("octagon-ckks");
  v54 = objc_claimAutoreleasedReturnValue(v53);
  if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "Initializing CKKS views", buf, 2u);
  }

  v55 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "cuttlefishXPCWrapper"));
  v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "activeAccount"));
  v57 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deviceAdapter"));
  v58 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v57, "modelID"));
  v61[0] = _NSConcreteStackBlock;
  v61[1] = 3221225472;
  v61[2] = sub_1000F6AC4;
  v61[3] = &unk_1002DD808;
  v61[4] = WeakRetained;
  objc_msgSend(v55, "fetchCurrentPolicyWithSpecificUser:modelIDOverride:isInheritedAccount:reply:", v56, v58, objc_msgSend(v6, "isInheritedAccount"), v61);

  v59 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "ckks"));
  objc_msgSend(v59, "beginCloudKitOperation");

  v12 = CFSTR("WaitingForCloudKitAccount");
LABEL_20:
  objc_msgSend(v3, "setNextState:", v12);

}

void sub_1000F6AC4(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v6;
  id v7;
  void *v8;
  const void *v9;
  NSObject *v10;
  NSObject *v11;
  const void *v12;
  int v13;
  id v14;

  v6 = a2;
  v7 = a4;
  v8 = v7;
  if (!v6 || v7)
  {
    v12 = sub_10000EF14("SecError");
    v11 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v13 = 138412290;
      v14 = v8;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "octagon-ckks: Unable to fetch initial syncing policy. THIS MIGHT CAUSE SYNCING FAILURES LATER: %@", (uint8_t *)&v13, 0xCu);
    }
  }
  else
  {
    v9 = sub_10000EF14("octagon-ckks");
    v10 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      v13 = 138412290;
      v14 = v6;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Fetched initial syncing policy: %@", (uint8_t *)&v13, 0xCu);
    }

    v11 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "ckks"));
    -[NSObject setCurrentSyncingPolicy:](v11, "setCurrentSyncingPolicy:", v6);
  }

}

void sub_1000F6C0C(uint64_t a1)
{
  id WeakRetained;
  unsigned int v2;
  __CFString *v3;
  const void *v4;
  NSObject *v5;
  void *v6;
  const void *v7;
  NSObject *v8;
  const __CFString *v9;
  unsigned int v10;
  __CFString *v11;
  __CFString *v12;
  const void *v13;
  NSObject *v14;
  const char *v15;
  NSObject *v16;
  uint32_t v17;
  const void *v18;
  void *v19;
  id v20;
  id v21;
  uint8_t buf[4];
  const __CFString *v23;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v21 = 0;
  v2 = objc_msgSend(WeakRetained, "fetchSendingMetricsPermitted:", &v21);
  v3 = (__CFString *)v21;
  if (!v3)
  {
    v7 = sub_10000EF14("octagon-metrics");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = CFSTR("Not Permitted");
      if (v2)
        v9 = CFSTR("Permitted");
      *(_DWORD *)buf = 138412290;
      v23 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "current metrics setting set to: %@", buf, 0xCu);
    }

    if (!v2)
      goto LABEL_18;
    v20 = 0;
    v10 = objc_msgSend(WeakRetained, "persistSendingMetricsPermitted:error:", 0, &v20);
    v11 = (__CFString *)v20;
    v12 = v11;
    if (!v10 || v11)
    {
      v18 = sub_10000EF14("SecError");
      v14 = objc_claimAutoreleasedReturnValue(v18);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v23 = v12;
        v15 = "octagon-metrics: failed to persist metrics setting: %@";
        v16 = v14;
        v17 = 12;
        goto LABEL_16;
      }
    }
    else
    {
      v13 = sub_10000EF14("octagon-metrics");
      v14 = objc_claimAutoreleasedReturnValue(v13);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        v15 = "persisted metrics setting set to not permitted";
        v16 = v14;
        v17 = 2;
LABEL_16:
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v15, buf, v17);
      }
    }

LABEL_18:
    v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "checkMetricsTrigger"));
    objc_msgSend(v19, "cancel");

    objc_msgSend(WeakRetained, "setCheckMetricsTrigger:", 0);
    goto LABEL_19;
  }
  v4 = sub_10000EF14("SecError");
  v5 = objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    v23 = v3;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "octagon-metrics: failed to fetch account metadata: %@", buf, 0xCu);
  }

  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "checkMetricsTrigger"));
  objc_msgSend(v6, "trigger");

LABEL_19:
}

void sub_1000F6E70(uint64_t a1, void *a2)
{
  id v3;
  const void *v4;
  NSObject *v5;
  const void *v6;
  NSObject *v7;
  int v8;
  id v9;

  v3 = a2;
  if (v3)
  {
    v4 = sub_10000EF14("SecError");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v8 = 138412290;
      v9 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "localReset returned an error: %@", (uint8_t *)&v8, 0xCu);
    }
  }
  else
  {
    v6 = sub_10000EF14("octagon");
    v7 = objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v8) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "localReset succeeded", (uint8_t *)&v8, 2u);
    }

    v5 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "pairingUUID"));
    objc_msgSend(*(id *)(a1 + 32), "setPairingUUID:", v5);
  }

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 48));
}

OTAccountMetadataClassC *__cdecl sub_1000F6FA4(id a1, OTAccountMetadataClassC *a2)
{
  OTAccountMetadataClassC *v2;

  v2 = a2;
  -[OTAccountMetadataClassC setCdpState:](v2, "setCdpState:", 2);
  return v2;
}

id sub_1000F6FD0(uint64_t a1, void *a2)
{
  id v3;

  v3 = a2;
  objc_msgSend(v3, "setAltDSID:", *(_QWORD *)(a1 + 32));
  return v3;
}

void sub_1000F7000(uint64_t a1)
{
  const void *v2;
  NSObject *v3;
  AAFAnalyticsEventSecurity *v4;
  void *v5;
  const void *v6;
  NSObject *v7;
  AAFAnalyticsEventSecurity *v8;
  AAFAnalyticsEventSecurity *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  id v19;
  void *v20;
  const void *v21;
  NSObject *v22;
  _BOOL4 v23;
  AAFAnalyticsEventSecurity *v24;
  void *v25;
  AAFAnalyticsEventSecurity *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  id v31;
  uint8_t buf[4];
  AAFAnalyticsEventSecurity *v33;
  __int16 v34;
  id v35;

  v2 = sub_10000EF14("octagon");
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = *(AAFAnalyticsEventSecurity **)(a1 + 32);
    *(_DWORD *)buf = 138412290;
    v33 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Told of a new CK account status: %@", buf, 0xCu);
  }

  objc_msgSend(*(id *)(a1 + 40), "setCloudKitAccountInfo:", *(_QWORD *)(a1 + 32));
  if (objc_msgSend(*(id *)(a1 + 32), "accountStatus") == (id)1)
  {
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "activeAccount"));

    if (!v5)
    {
      v7 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "sessionMetrics"));
      v9 = [AAFAnalyticsEventSecurity alloc];
      v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "activeAccount"));
      v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "altDSID"));
      v12 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject flowID](v7, "flowID"));
      v13 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject deviceSessionID](v7, "deviceSessionID"));
      LOBYTE(v30) = objc_msgSend(*(id *)(a1 + 40), "canSendMetricsUsingAccountState:", objc_msgSend(*(id *)(a1 + 40), "shouldSendMetricsForOctagon"));
      v8 = -[AAFAnalyticsEventSecurity initWithKeychainCircleMetrics:altDSID:flowID:deviceSessionID:eventName:testsAreEnabled:canSendMetrics:category:](v9, "initWithKeychainCircleMetrics:altDSID:flowID:deviceSessionID:eventName:testsAreEnabled:canSendMetrics:category:", 0, v11, v12, v13, CFSTR("com.apple.security.cloudKitAccountAvailability"), 0, v30, &off_10030AF70);

      v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "accountsAdapter"));
      v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "personaAdapter"));
      v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "containerName"));
      v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "contextID"));
      v31 = 0;
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "findAccountForCurrentThread:optionalAltDSID:cloudkitContainerName:octagonContextID:error:", v15, 0, v16, v17, &v31));
      v19 = v31;
      objc_msgSend(*(id *)(a1 + 40), "setActiveAccount:", v18);

      v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "activeAccount"));
      v21 = sub_10000EF14("octagon-account");
      v22 = objc_claimAutoreleasedReturnValue(v21);
      v23 = os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
      if (v20)
      {
        if (v23)
        {
          v24 = (AAFAnalyticsEventSecurity *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "contextID"));
          v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "activeAccount"));
          *(_DWORD *)buf = 138412546;
          v33 = v24;
          v34 = 2112;
          v35 = v25;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Found a new account (%@): %@", buf, 0x16u);

        }
        v22 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "accountMetadataStore"));
        v26 = (AAFAnalyticsEventSecurity *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "activeAccount"));
        -[NSObject changeActiveAccount:](v22, "changeActiveAccount:", v26);
      }
      else
      {
        if (!v23)
        {
LABEL_14:

          v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "activeAccount"));
          +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", v8, v27 != 0, v19);

          goto LABEL_15;
        }
        v26 = (AAFAnalyticsEventSecurity *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "contextID"));
        *(_DWORD *)buf = 138412546;
        v33 = v26;
        v34 = 2112;
        v35 = v19;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Unable to find a current account (context %@): %@", buf, 0x16u);
      }

      goto LABEL_14;
    }
  }
  v6 = sub_10000EF14("octagon-account");
  v7 = objc_claimAutoreleasedReturnValue(v6);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    v8 = (AAFAnalyticsEventSecurity *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "contextID"));
    *(_DWORD *)buf = 138412290;
    v33 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "skipping account fetch %@", buf, 0xCu);
LABEL_15:

  }
  v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "stateMachine"));
  objc_msgSend(v28, "_onqueuePokeStateMachine");

  v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "cloudKitAccountStateKnown"));
  objc_msgSend(v29, "fulfill");

}

id sub_1000F7454(uint64_t a1, uint64_t a2)
{
  return +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", *(_QWORD *)(a1 + 32), a2 == 0, a2);
}

void sub_1000F7474(uint64_t a1)
{
  id WeakRetained;
  const void *v2;
  NSObject *v3;
  void *v4;
  uint8_t v5[16];

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v2 = sub_10000EF14("octagon-ckks");
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Adding flag for CKKS TLK upload", v5, 2u);
  }

  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "stateMachine"));
  objc_msgSend(v4, "handleFlag:", CFSTR("tlk_upload_needed"));

}

void sub_1000F7510(uint64_t a1)
{
  id WeakRetained;
  const void *v2;
  NSObject *v3;
  void *v4;
  uint8_t v5[16];

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v2 = sub_10000EF14("octagon-ckks");
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Adding flag for CKKS policy check", v5, 2u);
  }

  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "stateMachine"));
  objc_msgSend(v4, "handleFlag:", CFSTR("policy_check_needed"));

}

void sub_1000F75AC(uint64_t a1)
{
  OctagonPendingFlag *v1;
  void *v2;
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v1 = -[OctagonPendingFlag initWithFlag:conditions:]([OctagonPendingFlag alloc], "initWithFlag:conditions:", CFSTR("attempt_ucv_upgrade"), 3);
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "stateMachine"));
  objc_msgSend(v2, "handlePendingFlag:", v1);

}

void sub_1000F761C(uint64_t a1)
{
  id WeakRetained;
  const void *v2;
  NSObject *v3;
  void *v4;
  uint8_t v5[16];

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v2 = sub_10000EF14("octagon-metrics");
  v3 = objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Added check-on-metrics flag to the state machine", v5, 2u);
  }

  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "stateMachine"));
  objc_msgSend(v4, "handleFlag:", CFSTR("check_on_rtc_metrics"));

}

__CFString *sub_1000F7BA4(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  __CFString *v6;

  if (!a1)
  {
    v6 = CFSTR("none");
    return v6;
  }
  v1 = a1;
  v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](NSMutableSet, "set"));
  v3 = v2;
  if ((v1 & 1) == 0)
  {
    if ((v1 & 2) == 0)
      goto LABEL_4;
LABEL_10:
    objc_msgSend(v3, "addObject:", CFSTR("network"));
    v1 &= ~2uLL;
    if (!v1)
      goto LABEL_6;
    goto LABEL_5;
  }
  objc_msgSend(v2, "addObject:", CFSTR("unlock"));
  v1 &= ~1uLL;
  if ((v1 & 2) != 0)
    goto LABEL_10;
LABEL_4:
  if (v1)
  {
LABEL_5:
    v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Conditions<0x%x>"), v1));
    objc_msgSend(v3, "addObject:", v4);

  }
LABEL_6:
  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "allObjects"));
  v6 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "componentsJoinedByString:", CFSTR(",")));

  return v6;
}

BOOL sub_1000F80EC(uint64_t a1, uint64_t a2)
{
  char v4;
  unsigned int v5;
  unint64_t v6;
  unint64_t v7;
  char v8;
  int v10;
  uint64_t String;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;

  if (*(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    while (1)
    {
      if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error))
        return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
      v4 = 0;
      v5 = 0;
      v6 = 0;
      while (1)
      {
        v7 = *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v7 == -1 || v7 >= *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__length))
          break;
        v8 = *(_BYTE *)(*(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
        *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
        v6 |= (unint64_t)(v8 & 0x7F) << v4;
        if ((v8 & 0x80) == 0)
          goto LABEL_11;
        v4 += 7;
        if (v5++ >= 9)
        {
          v6 = 0;
          v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
          goto LABEL_13;
        }
      }
      *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
      v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
      if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error))
        v6 = 0;
LABEL_13:
      if (v10 || (v6 & 7) == 4)
        return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
      if ((v6 >> 3) == 102)
        break;
      if ((v6 >> 3) == 101)
      {
        String = PBReaderReadString(a2);
        v13 = objc_claimAutoreleasedReturnValue(String);
        v14 = 8;
LABEL_21:
        v16 = *(void **)(a1 + v14);
        *(_QWORD *)(a1 + v14) = v13;

        goto LABEL_23;
      }
      if ((PBReaderSkipValueWithTag(a2) & 1) == 0)
        return 0;
LABEL_23:
      if (*(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(_QWORD *)(a2 + OBJC_IVAR___PBDataReader__length))
        return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    v15 = PBReaderReadString(a2);
    v13 = objc_claimAutoreleasedReturnValue(v15);
    v14 = 16;
    goto LABEL_21;
  }
  return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

void sub_1000F8524(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  id *v15;

  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000F8674(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v6;
  id v7;
  id WeakRetained;
  void *v9;
  const void *v10;
  NSObject *v11;
  void *v12;
  const void *v13;
  NSObject *v14;
  void *v15;
  int v16;
  id v17;

  v6 = a2;
  v7 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v9 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v9, "logResultForEvent:hardFailure:result:", CFSTR("OctagonEventPreflightVouchWithCustodianRecoveryKey"), 1, v7);

  if (!v6 || v7)
  {
    v13 = sub_10000EF14("SecError");
    v14 = objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      v16 = 138412290;
      v17 = v7;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "octagon: Error preflighting voucher using custodian recovery key: %@", (uint8_t *)&v16, 0xCu);
    }

    objc_msgSend(WeakRetained, "setError:", v7);
  }
  else
  {
    v10 = sub_10000EF14("octagon");
    v11 = objc_claimAutoreleasedReturnValue(v10);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v16 = 138412290;
      v17 = v6;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Preflight Custodian Recovery key ID %@ looks good to go", (uint8_t *)&v16, 0xCu);
    }

    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "intendedState"));
    objc_msgSend(WeakRetained, "setNextState:", v12);

  }
  v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishOp"));
  objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v15);

}

id sub_1000F8CA4(uint64_t a1, int a2, _BYTE *a3)
{
  uint64_t v3;
  unint64_t v4;
  void *v7;
  id v8;

  v3 = a2;
  v4 = *(_QWORD *)(a1 + 40);
  if (a2 >= v4)
  {
    if (a2 - v4 < (unint64_t)objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 8), "count"))
    {
      v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 8), "objectAtIndexedSubscript:", v3 - *(_QWORD *)(a1 + 40)));
      v8 = objc_msgSend(v7, "pointerValue");

      return v8;
    }
    *a3 = 1;
  }
  return 0;
}

void sub_1000F91D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  id *v15;

  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000F92FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000F9454(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000F9658(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  id v11;
  id v12;
  id v13;
  id v14;
  id v15;
  id WeakRetained;
  void *v17;
  const void *v18;
  NSObject *v19;
  void *v20;
  const void *v21;
  NSObject *v22;
  void *v23;
  void *v24;
  id v25;
  const void *v26;
  NSObject *v27;
  void *v28;
  const void *v29;
  NSObject *v30;
  void *v31;
  id v32;
  _QWORD v33[4];
  id v34;
  id v35;
  id v36;
  uint8_t buf[4];
  id v38;
  __int16 v39;
  id v40;

  v11 = a2;
  v12 = a3;
  v13 = a4;
  v14 = a5;
  v15 = a6;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v17 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v17, "logResultForEvent:hardFailure:result:", CFSTR("OctagonEventVoucherWithCustodianRecoveryKey"), 1, v15);

  if (v15)
  {
    v18 = sub_10000EF14("SecError");
    v19 = objc_claimAutoreleasedReturnValue(v18);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v38 = v15;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "octagon: Error preparing voucher using custodian recovery key: %@", buf, 0xCu);
    }

    objc_msgSend(WeakRetained, "setError:", v15);
LABEL_16:
    v25 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishOp"));
    objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v25);
    goto LABEL_17;
  }
  v20 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v20, "recordRecoveredTLKMetrics:tlkRecoveryResults:uniqueTLKsRecoveredEvent:totalSharesRecoveredEvent:totalRecoverableTLKSharesEvent:totalRecoverableTLKsEvent:totalViewsWithSharesEvent:", *(_QWORD *)(a1 + 32), v14, CFSTR("OACustodianUniqueTLKsRecoveredCount"), CFSTR("OACustodianTotalTLKSharesRecoveredCount"), CFSTR("OACustodianTotalTLKSharesCount"), CFSTR("OACustodianUniqueTLKsWithSharesCount"), CFSTR("OACustodianTLKUniqueViewCount"));

  objc_msgSend(WeakRetained, "setVoucher:", v11);
  objc_msgSend(WeakRetained, "setVoucherSig:", v12);
  if (!objc_msgSend(WeakRetained, "saveVoucher"))
  {
LABEL_13:
    v29 = sub_10000EF14("octagon");
    v30 = objc_claimAutoreleasedReturnValue(v29);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412546;
      v38 = v11;
      v39 = 2112;
      v40 = v12;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "Successfully vouched with a custodian recovery key: %@, %@", buf, 0x16u);
    }

    v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "intendedState"));
    objc_msgSend(WeakRetained, "setNextState:", v31);

    goto LABEL_16;
  }
  v21 = sub_10000EF14("octagon");
  v22 = objc_claimAutoreleasedReturnValue(v21);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Saving voucher for later use...", buf, 2u);
  }

  v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
  v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v23, "stateHolder"));
  v33[0] = _NSConcreteStackBlock;
  v33[1] = 3221225472;
  v33[2] = sub_1000F9A54;
  v33[3] = &unk_1002DDD90;
  v34 = v11;
  v35 = v12;
  v36 = v13;
  v32 = 0;
  objc_msgSend(v24, "persistAccountChanges:error:", v33, &v32);
  v25 = v32;

  if (!v25)
  {

    goto LABEL_13;
  }
  v26 = sub_10000EF14("octagon");
  v27 = objc_claimAutoreleasedReturnValue(v26);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    v38 = v25;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "unable to save voucher: %@", buf, 0xCu);
  }

  v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishOp"));
  objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v28);

LABEL_17:
}

id sub_1000F9A54(_QWORD *a1, void *a2)
{
  id v3;

  v3 = a2;
  objc_msgSend(v3, "setVoucher:", a1[4]);
  objc_msgSend(v3, "setVoucherSignature:", a1[5]);
  objc_msgSend(v3, "setTLKSharesPairedWithVoucher:", a1[6]);
  return v3;
}

void sub_1000F9A9C(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id WeakRetained;
  void *v8;
  const void *v9;
  NSObject *v10;
  void *v11;
  id v12;
  id v13;
  id v14;
  uint64_t v15;
  void *i;
  void *v17;
  void *v18;
  unsigned int v19;
  CKKSTLKShareRecord *v20;
  void *v21;
  void *v22;
  CKKSTLKShareRecord *v23;
  void *v24;
  id v25;
  void *v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint8_t v31[128];
  uint8_t buf[4];
  id v33;

  v5 = a2;
  v6 = a3;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v8 = WeakRetained;
  if (v6)
  {
    v9 = sub_10000EF14("SecError");
    v10 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v33 = v6;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "octagon: Error fetching TLKShares to recover: %@", buf, 0xCu);
    }

    objc_msgSend(v8, "setError:", v6);
    v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "finishOp"));
    objc_msgSend(v8, "runBeforeGroupFinished:", v11);
  }
  else
  {
    v26 = WeakRetained;
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
    v27 = 0u;
    v28 = 0u;
    v29 = 0u;
    v30 = 0u;
    v25 = v5;
    v12 = v5;
    v13 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v27, v31, 16);
    if (v13)
    {
      v14 = v13;
      v15 = *(_QWORD *)v28;
      do
      {
        for (i = 0; i != v14; i = (char *)i + 1)
        {
          if (*(_QWORD *)v28 != v15)
            objc_enumerationMutation(v12);
          v17 = *(void **)(*((_QWORD *)&v27 + 1) + 8 * (_QWORD)i);
          v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "recordType"));
          v19 = objc_msgSend(v18, "isEqual:", CFSTR("tlkshare"));

          if (v19)
          {
            v20 = [CKKSTLKShareRecord alloc];
            v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "deps"));
            v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "contextID"));
            v23 = -[CKKSCKRecordHolder initWithCKRecord:contextID:](v20, "initWithCKRecord:contextID:", v17, v22);

            v24 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSTLKShareRecord share](v23, "share"));
            objc_msgSend(v11, "addObject:", v24);

          }
        }
        v14 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v27, v31, 16);
      }
      while (v14);
    }

    v8 = v26;
    objc_msgSend(v26, "proceedWithFilteredTLKShares:", v11);
    v6 = 0;
    v5 = v25;
  }

}

void sub_1000F9D14(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  id WeakRetained;
  void *v11;
  const void *v12;
  NSObject *v13;
  void *v14;
  void *v15;
  const void *v16;
  NSObject *v17;
  void *v18;
  int v19;
  id v20;

  v7 = a2;
  v8 = a3;
  v9 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v11 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v11, "logResultForEvent:hardFailure:result:", CFSTR("OctagonEventPreflightVouchWithCustodianRecoveryKey"), 1, v9);

  if (!v7 || v9)
  {
    v16 = sub_10000EF14("SecError");
    v17 = objc_claimAutoreleasedReturnValue(v16);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      v19 = 138412290;
      v20 = v9;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "octagon: Error preflighting voucher using custodian recovery key: %@", (uint8_t *)&v19, 0xCu);
    }

    objc_msgSend(WeakRetained, "setError:", v9);
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishOp"));
    objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v18);

  }
  else
  {
    v12 = sub_10000EF14("octagon");
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      v19 = 138412290;
      v20 = v7;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Custodian Recovery key ID %@ looks good to go", (uint8_t *)&v19, 0xCu);
    }

    v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "ckks"));
    objc_msgSend(v15, "setCurrentSyncingPolicy:", v8);

    objc_msgSend(WeakRetained, "proceedWithRecoveryKeyID:", v7);
  }

}

void sub_1000FA5D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id *location)
{
  uint64_t v20;

  objc_destroyWeak(location);
  objc_destroyWeak((id *)(v20 - 128));
  _Block_object_dispose((const void *)(v20 - 176), 8);
  _Unwind_Resume(a1);
}

void sub_1000FA744(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000FAA34(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  id WeakRetained;
  void *v11;
  const void *v12;
  NSObject *v13;
  id v14;
  void *v15;
  const void *v16;
  NSObject *v17;
  void *v18;
  void *v19;
  const void *v20;
  NSObject *v21;
  _BOOL4 v22;
  void *v23;
  id v24;
  _QWORD v25[4];
  id v26;
  uint8_t buf[4];
  id v28;

  v7 = a2;
  v8 = a3;
  v9 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v11 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v11, "logResultForEvent:hardFailure:result:", CFSTR("OctagonEventVoucherWithInheritanceKey"), 1, v9);

  if (v9)
  {
    v12 = sub_10000EF14("SecError");
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v28 = v9;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "octagon-inheritor: Error recovering tlkshares: %@", buf, 0xCu);
    }

    objc_msgSend(WeakRetained, "setError:", v9);
    v14 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishOp"));
    objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v14);
  }
  else
  {
    v15 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
    objc_msgSend(v15, "recordRecoveredTLKMetrics:tlkRecoveryResults:uniqueTLKsRecoveredEvent:totalSharesRecoveredEvent:totalRecoverableTLKSharesEvent:totalRecoverableTLKsEvent:totalViewsWithSharesEvent:", *(_QWORD *)(a1 + 32), v8, CFSTR("OAInheritanceUniqueTLKsRecoveredCount"), CFSTR("OAInheritanceTotalTLKSharesRecoveredCount"), CFSTR("OAInheritanceTotalTLKSharesCount"), CFSTR("OAInheritanceUniqueTLKsWithSharesCount"), CFSTR("OAInheritanceTLKUniqueViewCount"));

    v16 = sub_10000EF14("octagon-inheritor");
    v17 = objc_claimAutoreleasedReturnValue(v16);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Saving tlkshares for later use...", buf, 2u);
    }

    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "stateHolder"));
    v25[0] = _NSConcreteStackBlock;
    v25[1] = 3221225472;
    v25[2] = sub_1000FAD74;
    v25[3] = &unk_1002EAF10;
    v26 = v7;
    v24 = 0;
    objc_msgSend(v19, "persistAccountChanges:error:", v25, &v24);
    v14 = v24;

    v20 = sub_10000EF14("octagon-inheritor");
    v21 = objc_claimAutoreleasedReturnValue(v20);
    v22 = os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
    if (v14)
    {
      if (v22)
      {
        *(_DWORD *)buf = 138412290;
        v28 = v14;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "unable to save shares: %@", buf, 0xCu);
      }
    }
    else
    {
      if (v22)
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Successfully recovered shares", buf, 2u);
      }

      v21 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "intendedState"));
      objc_msgSend(WeakRetained, "setNextState:", v21);
    }

    v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishOp"));
    objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v23);

  }
}

id sub_1000FAD74(uint64_t a1, void *a2)
{
  id v3;

  v3 = a2;
  objc_msgSend(v3, "setTLKSharesPairedWithVoucher:", *(_QWORD *)(a1 + 32));
  return v3;
}

uint64_t sub_1000FADA4(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_1000FADB4(uint64_t a1)
{

}

id sub_1000FADBC(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;

  v3 = a2;
  v4 = objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "parsedSecureElementIdentity"));
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v6 = *(void **)(v5 + 40);
  *(_QWORD *)(v5 + 40) = v4;

  return v3;
}

void sub_1000FAE00(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, uint64_t a8, void *a9, void *a10)
{
  id v16;
  id v17;
  id v18;
  id v19;
  id v20;
  id v21;
  id v22;
  id WeakRetained;
  void *v24;
  const void *v25;
  NSObject *v26;
  id v27;
  void *v28;
  void *v29;
  const void *v30;
  NSObject *v31;
  const void *v32;
  NSObject *v33;
  void *v34;
  id v35;
  id v36;
  id v37;
  uint64_t v38;
  void *i;
  void *v40;
  void *v41;
  unsigned int v42;
  CKKSTLKShareRecord *v43;
  void *v44;
  void *v45;
  CKKSTLKShareRecord *v46;
  void *v47;
  void *v48;
  void *v49;
  id v50;
  unsigned int v51;
  void *v52;
  void *v53;
  void *v54;
  const void *v55;
  NSObject *v56;
  void *v57;
  id v58;
  id v59;
  id v60;
  id v61;
  id v62;
  id v63;
  void *v64;
  void *v65;
  id v66;
  _QWORD v67[4];
  id v68;
  id v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  uint8_t v74[128];
  uint8_t buf[4];
  id v76;
  __int16 v77;
  id v78;
  __int16 v79;
  id v80;

  v16 = a2;
  v17 = a3;
  v18 = a4;
  v19 = a5;
  v20 = a6;
  v63 = a7;
  v21 = a9;
  v22 = a10;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v24 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v24, "logResultForEvent:hardFailure:result:", CFSTR("OctagonEventPrepareIdentity"), 1, v22);

  if (v22)
  {
    v25 = sub_10000EF14("SecError");
    v26 = objc_claimAutoreleasedReturnValue(v25);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v76 = v22;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "octagon-inheritor: Error preparing inheritor identity: %@", buf, 0xCu);
    }

    objc_msgSend(WeakRetained, "setError:", v22);
    v27 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishOp"));
    objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v27);
    v28 = WeakRetained;
    v29 = v63;
  }
  else
  {
    v30 = sub_10000EF14("octagon-inheritor");
    v31 = objc_claimAutoreleasedReturnValue(v30);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412802;
      v76 = v16;
      v77 = 2112;
      v78 = v17;
      v79 = 2112;
      v80 = v18;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "Prepared: %@ %@ %@", buf, 0x20u);
    }

    objc_msgSend(WeakRetained, "setPeerID:", v16);
    v62 = v17;
    objc_msgSend(WeakRetained, "setPermanentInfo:", v17);
    v61 = v18;
    objc_msgSend(WeakRetained, "setPermanentInfoSig:", v18);
    v60 = v19;
    objc_msgSend(WeakRetained, "setStableInfo:", v19);
    v65 = WeakRetained;
    v59 = v20;
    objc_msgSend(WeakRetained, "setStableInfoSig:", v20);
    v32 = sub_10000EF14("octagon-inheritor");
    v33 = objc_claimAutoreleasedReturnValue(v32);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v63, "viewList"));
      *(_DWORD *)buf = 138412546;
      v76 = v63;
      v77 = 2112;
      v78 = v34;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "New syncing policy: %@ views: %@", buf, 0x16u);

    }
    v64 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
    v70 = 0u;
    v71 = 0u;
    v72 = 0u;
    v73 = 0u;
    v58 = v21;
    v35 = v21;
    v36 = objc_msgSend(v35, "countByEnumeratingWithState:objects:count:", &v70, v74, 16);
    if (v36)
    {
      v37 = v36;
      v38 = *(_QWORD *)v71;
      do
      {
        for (i = 0; i != v37; i = (char *)i + 1)
        {
          if (*(_QWORD *)v71 != v38)
            objc_enumerationMutation(v35);
          v40 = *(void **)(*((_QWORD *)&v70 + 1) + 8 * (_QWORD)i);
          v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v40, "recordType"));
          v42 = objc_msgSend(v41, "isEqual:", CFSTR("tlkshare"));

          if (v42)
          {
            v43 = [CKKSTLKShareRecord alloc];
            v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v65, "deps"));
            v45 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v44, "contextID"));
            v46 = -[CKKSCKRecordHolder initWithCKRecord:contextID:](v43, "initWithCKRecord:contextID:", v40, v45);

            v47 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSTLKShareRecord share](v46, "share"));
            objc_msgSend(v64, "addObject:", v47);

          }
        }
        v37 = objc_msgSend(v35, "countByEnumeratingWithState:objects:count:", &v70, v74, 16);
      }
      while (v37);
    }

    v48 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v65, "deps"));
    v49 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v48, "stateHolder"));
    v67[0] = _NSConcreteStackBlock;
    v67[1] = 3221225472;
    v67[2] = sub_1000FB3D8;
    v67[3] = &unk_1002DEC60;
    v68 = v16;
    v29 = v63;
    v50 = v63;
    v69 = v50;
    v66 = 0;
    v51 = objc_msgSend(v49, "persistAccountChanges:error:", v67, &v66);
    v27 = v66;

    if (!v51 || v27)
    {
      v55 = sub_10000EF14("octagon-inheritor");
      v56 = objc_claimAutoreleasedReturnValue(v55);
      if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v76 = v27;
        _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "Couldn't persist metadata: %@", buf, 0xCu);
      }

      objc_msgSend(v65, "setError:", v27);
      v57 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v65, "finishOp"));
      objc_msgSend(v65, "runBeforeGroupFinished:", v57);

      v18 = v61;
      v17 = v62;
      v20 = v59;
      v19 = v60;
      v21 = v58;
      v54 = v64;
    }
    else
    {
      v52 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v65, "deps"));
      v53 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v52, "ckks"));
      objc_msgSend(v53, "setCurrentSyncingPolicy:", v50);

      v54 = v64;
      objc_msgSend(v65, "proceedWithFilteredTLKShares:", v64);
      v18 = v61;
      v17 = v62;
      v20 = v59;
      v19 = v60;
      v21 = v58;
    }

    v22 = 0;
    v28 = v65;
  }

}

id sub_1000FB3D8(uint64_t a1, void *a2)
{
  id v3;
  void *v4;

  v3 = a2;
  objc_msgSend(v3, "setPeerID:", *(_QWORD *)(a1 + 32));
  objc_msgSend(v3, "setTrustState:", 2);
  objc_msgSend(v3, "setIsInheritedAccount:", 1);
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "tlkSharesForVouchedIdentitys"));
  objc_msgSend(v4, "removeAllObjects");

  objc_msgSend(v3, "setTPSyncingPolicy:", *(_QWORD *)(a1 + 40));
  return v3;
}

CFMutableDictionaryRef sub_1000FB968(uint64_t a1)
{
  dispatch_queue_t v1;
  void *v2;
  CFMutableDictionaryRef result;

  **(_QWORD **)(a1 + 32) = _CFRuntimeRegisterClass(&unk_1002DDE50);
  v1 = dispatch_queue_create("SOSEngine queue", 0);
  v2 = (void *)qword_1003410C0;
  qword_1003410C0 = (uint64_t)v1;

  result = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  qword_1003410C8 = (uint64_t)result;
  return result;
}

CFStringRef sub_1000FB9E4(_QWORD *a1, const __CFDictionary *a2)
{
  const __CFArray *v4;
  CFStringRef v5;
  uint64_t v6;
  const __CFDictionary *v7;
  CFIndex Count;
  const __CFDictionary *v9;
  CFStringRef v10;

  v4 = (const __CFArray *)a1[10];
  if (v4)
    v5 = CFStringCreateByCombiningStrings(kCFAllocatorDefault, v4, CFSTR(" "));
  else
    v5 = &stru_1002EE888;
  v6 = a1[3];
  v7 = (const __CFDictionary *)a1[6];
  if (v7)
    Count = CFDictionaryGetCount(v7);
  else
    Count = 0;
  v9 = (const __CFDictionary *)a1[7];
  if (v9)
    v9 = (const __CFDictionary *)CFDictionaryGetCount(v9);
  v10 = CFStringCreateWithFormat(kCFAllocatorDefault, a2, CFSTR("<Engine %@ peers %@ MC[%d] PS[%d]>"), v6, v5, Count, v9);
  if (v5)
    CFRelease(v5);
  return v10;
}

CFStringRef sub_1000FBAA8(_QWORD *a1)
{
  return sub_1000FB9E4(a1, 0);
}

const void *sub_1000FBAB0(uint64_t a1, const void *a2)
{
  const void *v4;
  const __CFDictionary *v5;
  const void *Value;
  CFTypeID v7;
  const void *v8;
  NSObject *v9;
  int v11;
  const void *v12;

  if (!-[OTSOSActualAdapter sosEnabled]_0())
    return 0;
  v4 = 0;
  if (a2)
  {
    v5 = *(const __CFDictionary **)(a1 + 48);
    if (v5)
    {
      Value = CFDictionaryGetValue(v5, a2);
      v4 = Value;
      if (Value)
      {
        v7 = CFGetTypeID(Value);
        if (v7 != sub_1001E7FD8())
        {
          v8 = sub_10000EF14("SecError");
          v9 = objc_claimAutoreleasedReturnValue(v8);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            v11 = 138412290;
            v12 = a2;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "dropping corrupt manifest for %@ from cache", (uint8_t *)&v11, 0xCu);
          }

          CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 48), a2);
          return 0;
        }
      }
    }
  }
  return v4;
}

const void *sub_1000FBBB8(uint64_t a1, const __CFDictionary *a2, const void *a3)
{
  const void *Value;
  const void *v7;
  CFTypeID v8;
  const void *v9;
  const void *v10;

  if (!-[OTSOSActualAdapter sosEnabled]_0())
    return 0;
  Value = CFDictionaryGetValue(a2, a3);
  if (!Value || (v7 = Value, v8 = CFGetTypeID(Value), v8 != CFDataGetTypeID()))
    v7 = 0;
  v9 = sub_1000FBAB0(a1, v7);
  v10 = v9;
  if (v9)
    CFRetain(v9);
  return v10;
}

CFMutableArrayRef sub_1000FBC40(uint64_t a1, const __CFDictionary *a2, const void *a3, __CFArray *Mutable)
{
  const __CFArray *Value;
  const __CFArray *v9;
  CFTypeID v10;
  CFIndex Count;
  CFIndex v12;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v15;

  if (!-[OTSOSActualAdapter sosEnabled]_0())
  {
    SOSCCSetSOSDisabledError(Mutable);
    return 0;
  }
  Value = (const __CFArray *)CFDictionaryGetValue(a2, a3);
  if (Value)
  {
    v9 = Value;
    v10 = CFGetTypeID(Value);
    if (v10 == CFArrayGetTypeID())
    {
      Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      Count = CFArrayGetCount(v9);
      if (Count >= 1)
      {
        v12 = Count;
        for (i = 0; i != v12; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v9, i);
          v15 = sub_1000FBAB0(a1, ValueAtIndex);
          if (v15)
            CFArrayAppendValue(Mutable, v15);
        }
      }
      return Mutable;
    }
    if (!Mutable)
      return Mutable;
    sub_100019F20(-50, (__CFString **)Mutable, CFSTR("object %@ is not an array"), v9);
    return 0;
  }
  return CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
}

void sub_1000FBD80(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _BYTE *a6)
{
  uint64_t v8;
  const __CFString *v9;
  const void *v10;
  uint64_t v11;
  uint64_t PeerInfo;
  const void *v14;
  const void *v15;
  char v16;
  NSObject *v17;
  const __CFString *v18;
  CFTypeRef v19;
  char v20;
  const void *v21;
  NSObject *v22;
  const __CFString *v23;
  CFAllocatorRef v24;
  uint64_t v25;
  uint64_t Instance;
  const void *v27;
  const void *v28;
  const void *v29;
  const void *v30;
  uint64_t v31;
  NSObject *v32;
  const __CFString *v33;
  CFIndex v34;
  __CFData *Mutable;
  NSObject *v36;
  const __CFString *v37;
  NSObject *v38;
  const void *v39;
  NSObject *v40;
  _BYTE *v41;
  CFTypeRef cf;
  uint8_t buf[4];
  const __CFString *v44;
  __int16 v45;
  uint64_t v46;

  v8 = a1[5];
  v9 = (const __CFString *)a1[6];
  v11 = a1[7];
  v10 = (const void *)a1[8];
  if (!a3)
    goto LABEL_18;
  cf = 0;
  PeerInfo = SOSFullPeerInfoGetPeerInfo(v11);
  v14 = (const void *)SOSPeerInfoCopyPubKey(PeerInfo, &cf);
  if (!v14)
  {
    v15 = 0;
    goto LABEL_36;
  }
  v15 = (const void *)SOSPeerInfoCopyPubKey(v10, &cf);
  if (!v15)
  {
LABEL_36:
    v16 = 0;
    goto LABEL_5;
  }
  v16 = SecOTRSIsForKeys(*(_QWORD *)(a3 + 24), v14, v15);
LABEL_5:
  if (cf)
  {
    v17 = sub_10000EF14("SecError");
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      v18 = (const __CFString *)cf;
      if (!cf)
        v18 = CFSTR("No local error in SOSCoderCreate");
      *(_DWORD *)buf = 138412290;
      v44 = v18;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "SOSCoderIsFor failed: %@\n", buf, 0xCu);
    }
  }
  if (v14)
    CFRelease(v14);
  if (v15)
    CFRelease(v15);
  v19 = cf;
  if (cf)
  {
    cf = 0;
    CFRelease(v19);
  }
  if ((v16 & 1) != 0)
  {
    v20 = 1;
    goto LABEL_34;
  }
LABEL_18:
  v41 = a6;
  v21 = sub_10000EF14("coder");
  v22 = objc_claimAutoreleasedReturnValue(v21);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138412290;
    v44 = v9;
    _os_log_debug_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEBUG, "New coder for id %@.", buf, 0xCu);
  }
  v23 = v9;

  v24 = CFGetAllocator(v10);
  v25 = sub_1001E6D80();
  Instance = _CFRuntimeCreateInstance(kCFAllocatorDefault, v25, 48, 0);
  *(_QWORD *)(Instance + 16) = 0;
  *(_QWORD *)(Instance + 24) = 0;
  *(_BYTE *)(Instance + 32) = 0;
  *(_QWORD *)(Instance + 40) = 0;
  *(_QWORD *)(Instance + 48) = 0;
  *(_BYTE *)(Instance + 56) = 0;
  cf = 0;
  if (!v10 || !v11)
  {
    v32 = sub_10000EF14("coder");
    v33 = v23;
    a6 = v41;
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "NULL Coder requested, no transport security", buf, 2u);
    }
    goto LABEL_33;
  }
  v27 = (const void *)SOSFullPeerInfoCopyDeviceKey(v11, &cf);
  if (!v27)
  {
    v29 = 0;
    v30 = 0;
    v28 = 0;
LABEL_42:
    v33 = v23;
    goto LABEL_43;
  }
  v28 = (const void *)SecOTRFullIdentityCreateFromSecKeyRefSOS(v24, v27, &cf);
  if (!v28)
  {
    v29 = 0;
LABEL_40:
    v30 = 0;
    goto LABEL_42;
  }
  CFRelease(v27);
  v29 = (const void *)SOSPeerInfoCopyPubKey(v10, &cf);
  if (!v29)
  {
    v27 = 0;
    goto LABEL_40;
  }
  v30 = (const void *)SecOTRPublicIdentityCreateFromSecKeyRef(v24, v29, &cf);
  if (!v30)
  {
    v27 = 0;
    goto LABEL_42;
  }
  if (kCFBooleanTrue == kCFBooleanFalse)
    v31 = SecOTRSessionCreateFromIDAndFlags(v24, v28, v30, 2);
  else
    v31 = SecOTRSessionCreateFromID(v24, v28, v30);
  *(_QWORD *)(Instance + 24) = v31;
  v33 = v23;
  if (v31)
  {
    *(_BYTE *)(Instance + 32) = 0;
    *(_QWORD *)(Instance + 40) = 0;
    CFRelease(v29);
    CFRelease(v28);
    CFRelease(v30);
    a6 = v41;
LABEL_33:
    v34 = *(_QWORD *)ccsha1_di();
    Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0);
    CFDataSetLength(Mutable, v34);
    *(_QWORD *)(Instance + 48) = Mutable;
    *(_BYTE *)(Instance + 56) = 0;
    sub_1001E7150(Instance, 0);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v8 + 96), v33, (const void *)Instance);
    CFRelease((CFTypeRef)Instance);
    v20 = 1;
    *(_BYTE *)(v8 + 105) = 1;
    goto LABEL_34;
  }
  v27 = 0;
LABEL_43:
  v36 = sub_10000EF14("SecError");
  if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
  {
    v37 = (const __CFString *)cf;
    if (!cf)
      v37 = CFSTR("No local error in SOSCoderCreate");
    *(_DWORD *)buf = 138412290;
    v44 = v37;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "Coder create failed: %@\n", buf, 0xCu);
  }
  v38 = sub_10000EF14("SecError");
  a6 = v41;
  if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    v44 = 0;
    _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "Coder create failed: %@\n", buf, 0xCu);
  }
  if (v28)
    CFRelease(v28);
  if (v30)
    CFRelease(v30);
  if (v29)
    CFRelease(v29);
  if (v27)
    CFRelease(v27);
  CFRelease((CFTypeRef)Instance);
  v39 = sub_10000EF14("SecError");
  v40 = objc_claimAutoreleasedReturnValue(v39);
  if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412546;
    v44 = v33;
    v45 = 2112;
    v46 = 0;
    _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "Failed to create coder for %@: %@", buf, 0x16u);
  }

  v20 = 0;
LABEL_34:
  *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = v20;
  *a6 = *(_BYTE *)(a1[5] + 105);
}

uint64_t sub_1000FC2C0(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7;
  unsigned int v8;
  uint64_t v9;
  _QWORD v11[4];
  id v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  char v20;

  v7 = a4;
  if (-[OTSOSActualAdapter sosEnabled]_0())
  {
    v17 = 0;
    v18 = &v17;
    v19 = 0x2020000000;
    v20 = 1;
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    v11[2] = sub_1000FC3C4;
    v11[3] = &unk_1002DE098;
    v15 = a2;
    v16 = a3;
    v13 = &v17;
    v14 = a1;
    v12 = v7;
    v8 = sub_1000FC6A8(a1, a3, v11);
    if (*((_BYTE *)v18 + 24))
      v9 = v8;
    else
      v9 = 0;
    *((_BYTE *)v18 + 24) = v9;

    _Block_object_dispose(&v17, 8);
  }
  else
  {
    SOSCCSetSOSDisabledError(a3);
    v9 = 0;
  }

  return v9;
}

void sub_1000FC3AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_1000FC3C4(uint64_t a1)
{
  _QWORD *v2;
  const void *v3;
  const void *v4;
  uint64_t v5;
  CFTypeRef *v6;
  const __CFData *v7;
  const __CFData *v8;
  CFTypeRef v9;
  const __CFDictionary *v10;
  const void *v11;
  NSObject *v12;
  int v13;
  dispatch_queue_global_t global_queue;
  NSObject *v15;
  const void *Value;
  CFTypeID v17;
  _QWORD context[7];
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  char v22;
  uint8_t buf[4];
  int v24;

  v2 = sub_1000FC7D8(*(_QWORD *)(a1 + 48), *(const void **)(a1 + 56), *(__CFArray **)(a1 + 64));
  if (v2)
  {
    v3 = v2;
    v5 = *(_QWORD *)(a1 + 48);
    v4 = *(const void **)(a1 + 56);
    v6 = *(CFTypeRef **)(a1 + 64);
    if (!*(_BYTE *)(v5 + 104))
    {
      v19 = 0;
      v20 = &v19;
      v21 = 0x2020000000;
      v22 = 0;
      v7 = (const __CFData *)(*(uint64_t (**)(void))(*(_QWORD *)(v5 + 16) + 40))();
      v8 = v7;
      if (v7)
      {
        v9 = sub_1000FC910(v7, v6);
        if (v9)
        {
          v10 = *(const __CFDictionary **)(v5 + 56);
          context[0] = _NSConcreteStackBlock;
          context[1] = 3221225472;
          context[2] = sub_1000FC9E4;
          context[3] = &unk_1002EC9E8;
          context[5] = v9;
          context[6] = v5;
          context[4] = &v19;
          CFDictionaryApplyFunction(v10, (CFDictionaryApplierFunction)sub_1000FCFBC, context);
          v11 = sub_10000EF14("coder");
          v12 = objc_claimAutoreleasedReturnValue(v11);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            v13 = *((unsigned __int8 *)v20 + 24);
            *(_DWORD *)buf = 67109120;
            v24 = v13;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Will force peer registration: %{BOOL}d", buf, 8u);
          }

          if (*((_BYTE *)v20 + 24))
          {
            global_queue = dispatch_get_global_queue(-32768, 0);
            v15 = objc_claimAutoreleasedReturnValue(global_queue);
            dispatch_async(v15, &stru_1002DE398);

          }
          *(_BYTE *)(v5 + 104) = 1;
        }
        CFRelease(v8);
        if (v9)
          CFRelease(v9);
      }
      _Block_object_dispose(&v19, 8);
      *(_BYTE *)(v5 + 104) = 1;
    }
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 96), v4);
    if (!Value || (v17 = CFGetTypeID(Value), v17 != sub_1001E6D80()))
      SOSErrorCreate(1032, v6, 0, CFSTR("No coder for peer: %@"));
    (*(void (**)(_QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32));
    CFRelease(v3);
  }
  else
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = SOSErrorCreate(1032, *(_QWORD *)(a1 + 64), 0, CFSTR("Engine has no peer for %@"));
  }
}

void sub_1000FC680(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000FC6A8(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;
  uint64_t v6;
  uint64_t (*v7)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD *);
  id v8;
  uint64_t v9;
  _QWORD v11[4];
  id v12;
  uint64_t v13;

  v5 = a3;
  v6 = *(_QWORD *)(a1 + 16);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  v11[2] = sub_1000FC748;
  v11[3] = &unk_1002DE2D8;
  v12 = v5;
  v13 = a1;
  v7 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD *))(v6 + 64);
  v8 = v5;
  v9 = v7(v6, a2, 0, 1, v11);

  return v9;
}

void sub_1000FC748(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  _QWORD block[4];
  id v7;
  uint64_t v8;
  uint64_t v9;

  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000FC7C4;
  block[3] = &unk_1002DE2B0;
  v5 = *(_QWORD *)(a1 + 40);
  v7 = *(id *)(a1 + 32);
  v8 = a2;
  v9 = a3;
  dispatch_sync(*(dispatch_queue_t *)(v5 + 112), block);

}

uint64_t sub_1000FC7C4(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(a1[4] + 16))(a1[4], a1[5], a1[6]);
}

_QWORD *sub_1000FC7D8(uint64_t a1, const void *a2, __CFArray *a3)
{
  const void *Value;
  const void *v8;
  NSObject *v9;
  uint64_t v10;
  uint8_t buf[4];
  const void *v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  uint64_t v16;

  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 56), a2);
  if (Value)
    return sub_1000FDAA0(a1, a2, Value, a3);
  v8 = sub_10000EF14("SecError");
  v9 = objc_claimAutoreleasedReturnValue(v8);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    v10 = *(_QWORD *)(a1 + 56);
    *(_DWORD *)buf = 138412802;
    v12 = a2;
    v13 = 2112;
    v14 = v10;
    v15 = 2112;
    v16 = a1;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "peer: %@ not found, peerMap: %@, engine: %@", buf, 0x20u);
  }

  SOSErrorCreate(1032, a3, 0, CFSTR("peer: %@ not found"));
  return 0;
}

CFTypeRef sub_1000FC910(const __CFData *a1, CFTypeRef *a2)
{
  const UInt8 *BytePtr;
  CFIndex Length;
  const UInt8 *v6;
  unint64_t v7;
  BOOL v8;
  char v10;
  CFTypeRef v11;
  CFTypeRef cf;

  if (!-[OTSOSActualAdapter sosEnabled]_0())
  {
    SOSCCSetSOSDisabledError(a2);
    return 0;
  }
  cf = 0;
  if (a1)
  {
    BytePtr = CFDataGetBytePtr(a1);
    Length = CFDataGetLength(a1);
    v6 = &BytePtr[Length];
    v7 = sub_10002074C(kCFAllocatorDefault, (CFMutableDictionaryRef *)&cf, a2, (uint64_t)BytePtr, (uint64_t)&BytePtr[Length]);
    if (v7)
      v8 = v7 == (_QWORD)v6;
    else
      v8 = 1;
    if (!v8)
    {
      v10 = SOSErrorCreate(1029, a2, 0, CFSTR("trailing %td bytes at end of state"));
      if ((v10 & 1) != 0)
        return cf;
      goto LABEL_12;
    }
    if (!v7)
    {
LABEL_12:
      v11 = cf;
      if (cf)
      {
        cf = 0;
        CFRelease(v11);
      }
    }
  }
  return cf;
}

void sub_1000FC9E4(uint64_t a1, const __CFString *cf)
{
  CFTypeID v4;
  const void *v5;
  NSObject *v6;
  const __CFData *Value;
  const __CFData *v8;
  CFTypeID v9;
  uint64_t v10;
  uint64_t Instance;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const UInt8 *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const void *v23;
  NSObject *v24;
  const __CFString *v25;
  const char *v26;
  const void *v27;
  const __CFString *v28;
  const void *v29;
  const void *v30;
  NSObject *v31;
  BOOL v32;
  const UInt8 *v33;
  uint64_t v34;
  const UInt8 *v35;
  CFDataRef v36;
  uint64_t v37;
  CFIndex v38;
  __CFData *Mutable;
  const void *v40;
  CFTypeRef v41;
  CFTypeRef cfa;
  CFDataRef v43;
  unint64_t v44;
  unint64_t v45;
  _BYTE buf[12];
  __int16 v47;
  const __CFString *v48;

  if (cf)
  {
    v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID())
    {
      if (CFStringHasSuffix(cf, CFSTR("-tomb")))
      {
        v5 = sub_10000EF14("coder");
        v6 = objc_claimAutoreleasedReturnValue(v5);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          *(_QWORD *)&buf[4] = cf;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Skipping coder check for peer: %@", buf, 0xCu);
        }

        return;
      }
    }
  }
  Value = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), cf);
  if (!Value)
  {
    v23 = sub_10000EF14("coder");
    v24 = objc_claimAutoreleasedReturnValue(v23);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      v25 = *(const __CFString **)(a1 + 40);
      *(_DWORD *)buf = 138412546;
      *(_QWORD *)&buf[4] = cf;
      v47 = 2112;
      v48 = v25;
      v26 = "didn't find coder for peer: %@ engine dictionary: %@";
LABEL_23:
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, v26, buf, 0x16u);
    }
LABEL_24:

    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
    return;
  }
  v8 = Value;
  v9 = CFGetTypeID(Value);
  if (v9 != CFDataGetTypeID())
  {
    v27 = sub_10000EF14("coder");
    v24 = objc_claimAutoreleasedReturnValue(v27);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412546;
      *(_QWORD *)&buf[4] = cf;
      v47 = 2112;
      v48 = 0;
      v26 = "coder for %@ was not cf data: %@";
      goto LABEL_23;
    }
    goto LABEL_24;
  }
  cfa = 0;
  v10 = sub_1001E6D80();
  Instance = _CFRuntimeCreateInstance(kCFAllocatorDefault, v10, 48, 0);
  *(_QWORD *)(Instance + 40) = 0;
  *(_QWORD *)(Instance + 16) = 0;
  *(_QWORD *)(Instance + 24) = 0;
  *(_BYTE *)(Instance + 32) = 0;
  *(_QWORD *)(Instance + 48) = 0;
  *(_BYTE *)(Instance + 56) = 0;
  BytePtr = CFDataGetBytePtr(v8);
  Length = CFDataGetLength(v8);
  v14 = (uint64_t)&BytePtr[Length];
  v43 = 0;
  *(_QWORD *)buf = 0xAAAAAAAAAAAAAAAALL;
  if (!ccder_decode_tag(buf, BytePtr, &BytePtr[Length]))
    goto LABEL_26;
  if (*(_QWORD *)buf == 4)
  {
    v33 = sub_100021480(kCFAllocatorDefault, &v43, &cfa, (uint64_t)BytePtr, v14);
    *(_BYTE *)(Instance + 32) = 0;
    goto LABEL_38;
  }
  if (*(_QWORD *)buf != 0x2000000000000010)
    goto LABEL_26;
  v45 = 0;
  v15 = ccder_decode_sequence_tl(&v45, BytePtr, v14);
  v44 = 0xAAAAAAAAAAAAAAAALL;
  if (!ccder_decode_tag(&v44, v15, v14))
    goto LABEL_26;
  if (v44 != 4)
  {
    if (v44 == 2 && ccder_decode_uint64(0, v15, v45))
    {
      *(_QWORD *)buf = 0;
      v16 = ccder_decode_sequence_tl(buf, BytePtr, v14);
      if (*(_QWORD *)buf == v14)
      {
        v45 = 0xAAAAAAAAAAAAAAAALL;
        v18 = ccder_decode_uint64(&v45, v16, v14);
        if (v45 == 3)
        {
          v19 = sub_100021480(kCFAllocatorDefault, &v43, &cfa, v18, *(uint64_t *)buf);
          v20 = sub_1000324A4((BOOL *)(Instance + 32), (uint64_t)v19, *(uint64_t *)buf);
          v21 = sub_1000324A4((BOOL *)(Instance + 56), v20, *(uint64_t *)buf);
          v22 = (uint64_t)sub_100021480(kCFAllocatorDefault, (CFDataRef *)(Instance + 48), &cfa, v21, *(uint64_t *)buf);
          goto LABEL_36;
        }
        v28 = CFSTR("Unsupported Sequence Version: %lld");
        goto LABEL_27;
      }
LABEL_54:
      sub_100032660(1029, CFSTR("com.apple.security.cfder.error"), 0, &cfa, v17, CFSTR("Extra data in SOS coder"));
      goto LABEL_28;
    }
LABEL_26:
    v28 = CFSTR("Unsupported SOS Coder DER");
LABEL_27:
    SOSErrorCreate(1029, &cfa, 0, v28);
LABEL_28:
    v29 = (const void *)Instance;
    goto LABEL_29;
  }
  *(_QWORD *)buf = 0;
  v34 = ccder_decode_sequence_tl(buf, BytePtr, v14);
  if (*(_QWORD *)buf != v14)
    goto LABEL_54;
  v35 = sub_100021480(kCFAllocatorDefault, &v43, &cfa, v34, v14);
  v22 = sub_1000324A4((BOOL *)(Instance + 32), (uint64_t)v35, *(uint64_t *)buf);
LABEL_36:
  v33 = (const UInt8 *)v22;
  if (v22 != *(_QWORD *)buf)
    v33 = sub_100021480(kCFAllocatorDefault, (CFDataRef *)(Instance + 40), &cfa, v22, *(uint64_t *)buf);
LABEL_38:
  v36 = v43;
  if (!v33 || (v37 = SecOTRSessionCreateFromData(0, v43), (*(_QWORD *)(Instance + 24) = v37) == 0))
  {
    CFRelease((CFTypeRef)Instance);
    if (!v36)
      goto LABEL_30;
    v29 = v36;
LABEL_29:
    CFRelease(v29);
LABEL_30:
    v30 = sub_10000EF14("coder");
    v31 = objc_claimAutoreleasedReturnValue(v30);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412546;
      *(_QWORD *)&buf[4] = cf;
      v47 = 2112;
      v48 = (const __CFString *)cfa;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "Coder for '%@' failed to create: %@", buf, 0x16u);
    }
    Instance = 0;
    v32 = 1;
    goto LABEL_47;
  }
  if (!*(_QWORD *)(Instance + 48))
  {
    v38 = *(_QWORD *)ccsha1_di();
    Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0);
    CFDataSetLength(Mutable, v38);
    *(_QWORD *)(Instance + 48) = Mutable;
  }
  if (v36)
  {
    CFRelease(v36);
    v32 = 0;
  }
  else
  {
    v32 = Instance == 0;
  }
  CFDictionaryAddValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(a1 + 48) + 96), cf, (const void *)Instance);
  v40 = sub_10000EF14("coder");
  v31 = objc_claimAutoreleasedReturnValue(v40);
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412546;
    *(_QWORD *)&buf[4] = Instance;
    v47 = 2112;
    v48 = cf;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "adding coder: %@ for peerid: %@", buf, 0x16u);
  }
LABEL_47:

  v41 = cfa;
  if (cfa)
  {
    cfa = 0;
    CFRelease(v41);
  }
  if (!v32)
    CFRelease((CFTypeRef)Instance);
}

uint64_t sub_1000FCFBC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t sub_1000FCFD4(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  __CFDictionary *Mutable;
  __CFDictionary *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  CFNumberRef v11;
  unsigned int v12;
  const __CFString *v14;
  const __CFDictionary *v15;
  unsigned int v16;
  const __CFString *v17;
  unsigned int v18;
  const __CFString *v19;
  const __CFDictionary *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __CFData *v24;
  const void *v25;
  NSObject *v26;
  int v27;
  CFTypeRef v28;
  const void *v29;
  NSObject *v30;
  uint64_t v31;
  int v32;
  __CFDictionary *v33;
  uint64_t v34;
  uint64_t v35;
  const __CFString *v36;
  const void *v37;
  __CFData *v38;
  uint64_t v39;
  CFTypeRef cf;
  _BYTE valuePtr[24];
  void *v42;
  uint64_t v43;
  const __CFString *v44;

  if (!*(_QWORD *)(a1 + 16))
    return 1;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v7 = Mutable;
  v8 = *(const void **)(a1 + 24);
  if (v8)
    CFDictionarySetValue(Mutable, CFSTR("id"), v8);
  v9 = *(const void **)(a1 + 80);
  if (v9)
    CFDictionarySetValue(v7, CFSTR("peerIDs"), v9);
  v10 = *(const void **)(a1 + 88);
  if (v10)
    CFDictionarySetValue(v7, CFSTR("traceDate"), v10);
  *(_QWORD *)valuePtr = 2;
  v11 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, valuePtr);
  CFDictionarySetValue(v7, CFSTR("engine-stateVersion"), v11);
  if (v11)
    CFRelease(v11);
  if (v7)
  {
    v12 = sub_1000FD4DC(a1, a2, (uint64_t)CFSTR("engine-state-v2"), kSecAttrAccessibleAlwaysPrivate, (const __CFString *)v7, a3);
    CFRelease(v7);
  }
  else
  {
    v12 = 0;
  }
  v14 = (const __CFString *)CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v15 = *(const __CFDictionary **)(a1 + 56);
  *(_QWORD *)valuePtr = _NSConcreteStackBlock;
  *(_QWORD *)&valuePtr[8] = 3221225472;
  *(_QWORD *)&valuePtr[16] = sub_1000FD55C;
  v42 = &unk_1002ECD08;
  v43 = (uint64_t)v14;
  CFDictionaryApplyFunction(v15, (CFDictionaryApplierFunction)sub_1000FCFBC, valuePtr);
  if (v14)
  {
    v16 = sub_1000FD4DC(a1, a2, (uint64_t)CFSTR("engine-peer-states"), kSecAttrAccessibleAlwaysPrivate, v14, a3);
    CFRelease(v14);
  }
  else
  {
    v16 = 0;
  }
  v17 = (const __CFString *)CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  *(_QWORD *)valuePtr = _NSConcreteStackBlock;
  *(_QWORD *)&valuePtr[8] = 3221225472;
  *(_QWORD *)&valuePtr[16] = sub_1000FD694;
  v42 = &unk_1002DE128;
  v43 = (uint64_t)v17;
  sub_1000FD6EC(a1, valuePtr);
  if (v17)
  {
    v18 = sub_1000FD4DC(a1, a2, (uint64_t)CFSTR("engine-manifest-cache"), kSecAttrAccessibleAlwaysPrivate, v17, a3);
    CFRelease(v17);
  }
  else
  {
    v18 = 0;
  }
  if (*(_BYTE *)(a1 + 105))
  {
    cf = 0;
    v19 = (const __CFString *)CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    v20 = *(const __CFDictionary **)(a1 + 56);
    *(_QWORD *)valuePtr = _NSConcreteStackBlock;
    *(_QWORD *)&valuePtr[8] = 3221225472;
    *(_QWORD *)&valuePtr[16] = sub_1000FD76C;
    v42 = &unk_1002DEB50;
    v43 = a1;
    v44 = v19;
    CFDictionaryApplyFunction(v20, (CFDictionaryApplierFunction)sub_1000FCFBC, valuePtr);
    v24 = sub_10001A474(v19, &cf, v21, v22, v23);
    if (v19)
      CFRelease(v19);
    if (v24 && (*(unsigned int (**)(void))(*(_QWORD *)(a1 + 16) + 96))())
    {
      *(_BYTE *)(a1 + 105) = 0;
      v25 = sub_10000EF14("coder");
      v26 = objc_claimAutoreleasedReturnValue(v25);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
      {
        v39 = *(_QWORD *)(a1 + 96);
        *(_DWORD *)valuePtr = 138412290;
        *(_QWORD *)&valuePtr[4] = v39;
        _os_log_debug_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEBUG, "saved coders: %@", valuePtr, 0xCu);
      }

      v27 = 1;
    }
    else
    {
      if (a3)
      {
        v28 = cf;
        cf = 0;
        if (*a3)
          CFRelease(*a3);
        *a3 = v28;
      }
      v29 = sub_10000EF14("coder");
      v30 = objc_claimAutoreleasedReturnValue(v29);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        v31 = *(_QWORD *)(a1 + 96);
        *(_DWORD *)valuePtr = 138412546;
        *(_QWORD *)&valuePtr[4] = v31;
        *(_WORD *)&valuePtr[12] = 2112;
        *(_QWORD *)&valuePtr[14] = cf;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "failed to save coders: %@ (%@)", valuePtr, 0x16u);
      }

      v27 = 0;
      v32 = 0;
      if (!v24)
        goto LABEL_36;
    }
    CFRelease(v24);
    v32 = v27;
LABEL_36:
    if (cf)
      CFRelease(cf);
    goto LABEL_39;
  }
  v32 = 1;
LABEL_39:
  v33 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v36 = (const __CFString *)v33;
  v37 = *(const void **)(a1 + 24);
  if (v37)
    CFDictionarySetValue(v33, CFSTR("id"), v37);
  v38 = sub_10001A474(v36, 0, (uint64_t)v37, v34, v35);
  if (v36)
    CFRelease(v36);
  if (v38)
  {
    (*(void (**)(void))(*(_QWORD *)(a1 + 16) + 96))();
    CFRelease(v38);
  }
  return v12 & v16 & v18 & v32;
}

__CFData *sub_1000FD4DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const __CFString *a5, CFTypeRef *a6)
{
  __CFData *result;
  __CFData *v8;
  uint64_t v9;

  result = sub_10001A474(a5, a6, a3, a4, (uint64_t)a5);
  if (result)
  {
    v8 = result;
    v9 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 96))();
    CFRelease(v8);
    return (__CFData *)v9;
  }
  return result;
}

void sub_1000FD55C(uint64_t a1, const void *a2, __CFDictionary *cf)
{
  __CFDictionary *v3;
  CFTypeID v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const void *v10;
  __int16 v11;
  uint64_t v12;

  if (!cf)
    return;
  v3 = cf;
  v6 = CFGetTypeID(cf);
  if (v6 != sub_1001EB8FC())
  {
    CFRetain(v3);
    goto LABEL_9;
  }
  v3 = sub_1001EC820((uint64_t)v3);
  if (v3)
  {
LABEL_9:
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), a2, v3);
    CFRelease(v3);
    return;
  }
  v7 = sub_10000EF14("engine");
  v8 = objc_claimAutoreleasedReturnValue(v7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    v9 = 138412546;
    v10 = a2;
    v11 = 2112;
    v12 = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%@ failed to encode peer: %@", (uint8_t *)&v9, 0x16u);
  }

}

void sub_1000FD694(uint64_t a1, uint64_t a2)
{
  __CFDictionary *v3;

  v3 = *(__CFDictionary **)(a1 + 32);
  sub_1001ED750(v3, *(__CFData **)(a2 + 56));
  sub_1001ED750(v3, *(__CFData **)(a2 + 64));
  sub_1001ED750(v3, *(__CFData **)(a2 + 72));
  sub_1001ED79C(v3, *(CFTypeRef *)(a2 + 88));
  sub_1001ED79C(v3, *(CFTypeRef *)(a2 + 80));
}

void sub_1000FD6EC(uint64_t a1, void *a2)
{
  id v3;
  const __CFDictionary *Copy;
  uint64_t v5;
  id v6;

  v3 = a2;
  v5 = a1;
  v6 = objc_retainBlock(v3);
  Copy = CFDictionaryCreateCopy(0, *(CFDictionaryRef *)(a1 + 56));
  CFDictionaryApplyFunction(Copy, (CFDictionaryApplierFunction)sub_1000FDA48, &v5);
  CFRelease(Copy);

}

void sub_1000FD758(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void sub_1000FD76C(uint64_t a1, const void *a2)
{
  uint64_t v4;
  const void *Value;
  uint64_t v6;
  CFTypeID v7;
  const __CFData *v8;
  const __CFData *v9;
  CFIndex Length;
  uint64_t v11;
  uint64_t v12;
  const __CFData *v13;
  CFIndex v14;
  BOOL v15;
  CFIndex v16;
  __CFData *Mutable;
  UInt8 *MutableBytePtr;
  CFMutableDataRef v19;
  const __CFData *v20;
  uint64_t v21;
  uint8_t v22;
  const __CFData *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const void *v29;
  NSObject *v30;
  const void *v31;
  NSObject *v32;
  const __CFData *v33;
  uint8_t buf[4];
  const void *v35;
  __int16 v36;
  const __CFData *v37;

  v4 = *(_QWORD *)(a1 + 32);
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v4 + 96), a2);
  if (!Value)
    return;
  v6 = (uint64_t)Value;
  v7 = CFGetTypeID(Value);
  if (v7 != sub_1001E6D80())
    return;
  v33 = 0;
  v8 = sub_1001E7090(v6, (uint64_t)&v33);
  if (v8)
  {
    v9 = v8;
    Length = CFDataGetLength(v8);
    v11 = ccder_sizeof_raw_octet_string(Length);
    v12 = ccder_sizeof(1, 1);
    v13 = *(const __CFData **)(v6 + 40);
    if (v13)
    {
      v14 = CFDataGetLength(v13);
      v13 = (const __CFData *)ccder_sizeof_raw_octet_string(v14);
    }
    if (v11)
      v15 = v12 == 0;
    else
      v15 = 1;
    if (v15)
    {
LABEL_11:
      CFRelease(v9);
      goto LABEL_19;
    }
    v16 = ccder_sizeof(0x2000000000000010, (char *)v13 + v12 + v11);
    CFRelease(v9);
    if (v16)
    {
      Mutable = CFDataCreateMutable(0, v16);
      if (Mutable)
      {
        v9 = Mutable;
        CFDataSetLength(Mutable, v16);
        MutableBytePtr = CFDataGetMutableBytePtr(v9);
        v19 = sub_1001E7090(v6, (uint64_t)&v33);
        if (v19)
        {
          v20 = v19;
          v21 = (uint64_t)&MutableBytePtr[v16];
          v22 = *(_BYTE *)(v6 + 32);
          v23 = *(const __CFData **)(v6 + 40);
          v24 = v21;
          if (v23)
            v24 = sub_1000206B0(v23, (CFTypeRef *)&v33, (uint64_t)MutableBytePtr, v21);
          buf[0] = v22;
          v25 = ccder_encode_body(1, buf, MutableBytePtr, v24);
          v26 = ccder_encode_tl(1, 1, MutableBytePtr, v25);
          v27 = sub_1000206B0(v20, (CFTypeRef *)&v33, (uint64_t)MutableBytePtr, v26);
          v28 = ccder_encode_constructed_tl(0x2000000000000010, v21, MutableBytePtr, v27);
          CFRelease(v20);
          if (v28)
          {
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), a2, v9);
LABEL_24:
            CFRelease(v9);
            return;
          }
        }
        goto LABEL_11;
      }
    }
  }
LABEL_19:
  v29 = sub_10000EF14("SecError");
  v30 = objc_claimAutoreleasedReturnValue(v29);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412546;
    v35 = a2;
    v36 = 2112;
    v37 = v33;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "failed to der encode coder for peer %@, dropping it: %@", buf, 0x16u);
  }

  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v4 + 96), a2);
  v9 = v33;
  v31 = sub_10000EF14("engine");
  v32 = objc_claimAutoreleasedReturnValue(v31);
  if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412546;
    v35 = a2;
    v36 = 2112;
    v37 = v9;
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "%@ no coder for peer: %@", buf, 0x16u);
  }

  if (v9)
    goto LABEL_24;
}

void sub_1000FDA48(const void *a1, CFTypeRef cf, uint64_t *a3)
{
  _QWORD *v4;
  const void *v5;

  v4 = sub_1000FDAA0(*a3, a1, cf, 0);
  if (v4)
  {
    v5 = v4;
    (*(void (**)(void))(a3[1] + 16))();
    CFRelease(v5);
  }
}

_QWORD *sub_1000FDAA0(uint64_t a1, const void *a2, CFTypeRef cf, __CFArray *a4)
{
  CFTypeID v8;
  const __CFArray *v10;
  _QWORD *v11;
  const void *v12;
  NSObject *v13;
  CFTypeRef v14;
  CFTypeRef cfa;
  uint8_t buf[4];
  const void *v17;
  __int16 v18;
  CFTypeRef v19;
  __int16 v20;
  CFTypeRef v21;
  CFRange v22;

  if (cf)
  {
    v8 = CFGetTypeID(cf);
    if (v8 == sub_1001EB8FC())
      return CFRetain(cf);
  }
  v10 = *(const __CFArray **)(a1 + 80);
  if (v10
    && (v22.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 80)), v22.location = 0, CFArrayContainsValue(v10, v22, a2)))
  {
    cfa = 0;
    v11 = sub_1001ED338(a1, a2, (const __CFDictionary *)cf, (__CFArray *)&cfa);
    if (v11)
      goto LABEL_12;
    v12 = sub_10000EF14("SecError");
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412802;
      v17 = a2;
      v18 = 2112;
      v19 = cfa;
      v20 = 2112;
      v21 = cf;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "error inflating peer: %@: %@ from state: %@", buf, 0x20u);
    }

    v14 = cfa;
    if (cfa)
    {
      cfa = 0;
      CFRelease(v14);
    }
    v11 = sub_1001ED338(a1, a2, 0, a4);
    if (v11)
LABEL_12:
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), a2, v11);
  }
  else
  {
    SOSErrorCreate(1032, a4, 0, CFSTR("peer: %@ is untrusted inflating not allowed"));
    return 0;
  }
  return v11;
}

void sub_1000FDC78(id a1)
{
  const void *v1;
  NSObject *v2;
  CFTypeRef v3;
  CFTypeRef cf;
  uint8_t buf[4];
  CFTypeRef v6;

  cf = 0;
  if (!sub_10020C1F4(&cf))
  {
    v1 = sub_10000EF14("coder");
    v2 = objc_claimAutoreleasedReturnValue(v1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v6 = cf;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SOSCCProcessEnsurePeerRegistration failed with: %@", buf, 0xCu);
    }

  }
  v3 = cf;
  if (cf)
  {
    cf = 0;
    CFRelease(v3);
  }
}

uint64_t sub_1000FDD40(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  const __CFData *v5;
  const __CFData *v6;
  const __CFDictionary *v7;
  const __CFData *v8;
  CFTypeRef v9;
  const __CFData *v10;
  CFTypeRef v11;
  const __CFData *v12;
  const __CFData *v13;
  const __CFDictionary *v14;
  const void *Value;
  CFTypeID v16;
  const void *v17;
  CFTypeID v18;
  const void *v19;
  NSObject *v20;
  uint64_t v21;
  const void *v22;
  const void *v23;
  CFTypeID v24;
  const void *v25;
  const void *v26;
  const void *v27;
  CFTypeID v28;
  const void *v29;
  const void *v30;
  const void *v31;
  CFTypeID v32;
  const void *v33;
  const void *v34;
  NSObject *v35;
  const void *v36;
  const __CFArray *Mutable;
  const __CFArray *v38;
  CFTypeID v39;
  BOOL v40;
  uint64_t v41;
  CFTypeRef v42;
  CFTypeRef cf;
  __int128 buf;
  void *v46;
  void *v47;
  uint64_t v48;

  cf = 0;
  v5 = (const __CFData *)(*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 40))();
  v6 = v5;
  if (v5)
  {
    v7 = (const __CFDictionary *)sub_1000FC910(v5, &cf);
    v8 = (const __CFData *)(*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 40))();
    v9 = sub_1000FC910(v8, &cf);
    if (v8)
      CFRelease(v8);
    v10 = (const __CFData *)(*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 40))();
    v11 = sub_1000FC910(v10, &cf);
    if (v10)
      CFRelease(v10);
  }
  else
  {
    v12 = (const __CFData *)(*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 40))();
    if (v12)
    {
      v13 = v12;
      v14 = (const __CFDictionary *)sub_1000FC910(v12, &cf);
      v7 = v14;
      if (v14)
      {
        Value = CFDictionaryGetValue(v14, CFSTR("manifestCache"));
        v9 = Value;
        if (Value)
        {
          v16 = CFGetTypeID(Value);
          if (v16 == CFDictionaryGetTypeID())
            CFRetain(v9);
          else
            v9 = 0;
        }
        v17 = CFDictionaryGetValue(v7, CFSTR("peerState"));
        v11 = v17;
        if (v17)
        {
          v18 = CFGetTypeID(v17);
          if (v18 == CFDictionaryGetTypeID())
            CFRetain(v11);
          else
            v11 = 0;
        }
      }
      else
      {
        v11 = 0;
        v9 = 0;
      }
      CFRelease(v13);
    }
    else
    {
      v11 = 0;
      v9 = 0;
      v7 = 0;
    }
    v19 = sub_10000EF14("coder");
    v20 = objc_claimAutoreleasedReturnValue(v19);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Migrating from v0 engine state; dropping coders and forcing re-negotiation",
        (uint8_t *)&buf,
        2u);
    }

    _os_activity_initiate((void *)&_mh_execute_header, "CloudCircle EnsurePeerRegistration", OS_ACTIVITY_FLAG_DEFAULT, &stru_1002ED1E0);
    v21 = *(_QWORD *)(a1 + 80);
    if (v21)
    {
      *(_QWORD *)&buf = _NSConcreteStackBlock;
      *((_QWORD *)&buf + 1) = 3221225472;
      v46 = sub_100202158;
      v47 = &unk_1002ED1A0;
      v48 = v21;
      _os_activity_initiate((void *)&_mh_execute_header, "CloudCircle RequestSyncWithPeersList", OS_ACTIVITY_FLAG_DEFAULT, &buf);
    }
  }
  if (v7)
  {
    v22 = CFDictionaryGetValue(v7, CFSTR("id"));
    if (v22 && (v23 = v22, v24 = CFGetTypeID(v22), v24 == CFStringGetTypeID()))
    {
      if (*(const void **)(a1 + 24) != v23)
      {
        CFRetain(v23);
        v25 = *(const void **)(a1 + 24);
        if (!v25)
          goto LABEL_32;
        goto LABEL_31;
      }
    }
    else
    {
      v25 = *(const void **)(a1 + 24);
      if (v25)
      {
        v23 = 0;
LABEL_31:
        CFRelease(v25);
LABEL_32:
        *(_QWORD *)(a1 + 24) = v23;
      }
    }
    v26 = CFDictionaryGetValue(v7, CFSTR("peerIDs"));
    if (v26 && (v27 = v26, v28 = CFGetTypeID(v26), v28 == CFArrayGetTypeID()))
    {
      if (*(const void **)(a1 + 80) != v27)
      {
        CFRetain(v27);
        v29 = *(const void **)(a1 + 80);
        if (!v29)
          goto LABEL_41;
        goto LABEL_40;
      }
    }
    else
    {
      v29 = *(const void **)(a1 + 80);
      if (v29)
      {
        v27 = 0;
LABEL_40:
        CFRelease(v29);
LABEL_41:
        *(_QWORD *)(a1 + 80) = v27;
      }
    }
    v30 = CFDictionaryGetValue(v7, CFSTR("traceDate"));
    if (v30 && (v31 = v30, v32 = CFGetTypeID(v30), v32 == CFDateGetTypeID()))
    {
      if (*(const void **)(a1 + 88) != v31)
      {
        CFRetain(v31);
        v33 = *(const void **)(a1 + 88);
        if (!v33)
          goto LABEL_50;
        goto LABEL_49;
      }
    }
    else
    {
      v33 = *(const void **)(a1 + 88);
      if (v33)
      {
        v31 = 0;
LABEL_49:
        CFRelease(v33);
LABEL_50:
        *(_QWORD *)(a1 + 88) = v31;
      }
    }
    v34 = sub_10000EF14("engine");
    v35 = objc_claimAutoreleasedReturnValue(v34);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(_QWORD *)((char *)&buf + 4) = a1;
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "%@", (uint8_t *)&buf, 0xCu);
    }

  }
  v36 = *(const void **)(a1 + 48);
  if (v36)
  {
    *(_QWORD *)(a1 + 48) = 0;
    CFRelease(v36);
  }
  if (v9)
  {
    *(_QWORD *)(a1 + 48) = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    *(_QWORD *)&buf = _NSConcreteStackBlock;
    *((_QWORD *)&buf + 1) = 3221225472;
    v46 = sub_1000FE34C;
    v47 = &unk_1002ECD08;
    v48 = a1;
    CFDictionaryApplyFunction((CFDictionaryRef)v9, (CFDictionaryApplierFunction)sub_1000FCFBC, &buf);
  }
  if (v11)
  {
    Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    v38 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    v39 = CFGetTypeID(v11);
    if (v39 == CFDictionaryGetTypeID())
    {
      *(_QWORD *)&buf = _NSConcreteStackBlock;
      *((_QWORD *)&buf + 1) = 3221225472;
      v46 = sub_1000FE3D0;
      v47 = &unk_1002ECD08;
      v48 = a1;
      CFDictionaryApplyFunction((CFDictionaryRef)v11, (CFDictionaryApplierFunction)sub_1000FCFBC, &buf);
    }
    sub_1000FE5B4(a1, (uint64_t)v38, (uint64_t)Mutable);
    sub_1000FE6C0(a1, *(CFTypeRef *)(a1 + 24), v38, Mutable);
    if (v38)
      CFRelease(v38);
    if (Mutable)
      CFRelease(Mutable);
  }
  if (v11)
    v40 = v7 == 0;
  else
    v40 = 1;
  v41 = !v40;
  if (v6)
    CFRelease(v6);
  if (v7)
    CFRelease(v7);
  if (v9)
    CFRelease(v9);
  if (v11 && (CFRelease(v11), (_DWORD)v41))
  {
    v42 = cf;
  }
  else
  {
    v42 = cf;
    if (a3)
    {
      *a3 = cf;
      return v41;
    }
  }
  if (v42)
  {
    cf = 0;
    CFRelease(v42);
  }
  return v41;
}

void sub_1000FE34C(uint64_t a1, const void *a2, CFTypeRef cf)
{
  CFTypeID v6;
  const void *v7;
  const void *v8;

  if (cf)
  {
    v6 = CFGetTypeID(cf);
    if (v6 == CFDataGetTypeID())
    {
      v7 = (const void *)sub_1001E8440((const __CFData *)cf, 0);
      if (v7)
      {
        v8 = v7;
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(a1 + 32) + 48), a2, v7);
        CFRelease(v8);
      }
    }
  }
}

void sub_1000FE3D0(uint64_t a1, const void *a2, const __CFData *a3)
{
  const void *Value;
  uint64_t v7;
  CFTypeID v8;
  CFIndex Length;
  __CFString *Mutable;
  const UInt8 *BytePtr;
  CFIndex v12;
  CFIndex v13;
  unsigned int v14;
  const void *v15;
  NSObject *v16;
  CFTypeRef v17;
  CFTypeRef cf;
  uint8_t buf[4];
  const void *v20;
  __int16 v21;
  CFTypeRef v22;
  __int16 v23;
  __CFString *v24;

  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(*(_QWORD *)(a1 + 32) + 56), a2);
  if (Value && (v7 = (uint64_t)Value, v8 = CFGetTypeID(Value), v8 == sub_1001EB8FC()))
  {
    cf = 0;
    if (!sub_1001ED044(v7, *(_QWORD *)(a1 + 32), a3, (__CFArray *)&cf))
    {
      Length = CFDataGetLength(a3);
      Mutable = CFStringCreateMutable(kCFAllocatorDefault, 2 * Length);
      BytePtr = CFDataGetBytePtr(a3);
      v12 = CFDataGetLength(a3);
      if (v12 >= 1)
      {
        v13 = v12;
        do
        {
          v14 = *BytePtr++;
          CFStringAppendFormat(Mutable, 0, CFSTR("%02X"), v14);
          --v13;
        }
        while (v13);
      }
      v15 = sub_10000EF14("SecError");
      v16 = objc_claimAutoreleasedReturnValue(v15);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412802;
        v20 = a2;
        v21 = 2112;
        v22 = cf;
        v23 = 2112;
        v24 = Mutable;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "peer: %@: bad state: %@ in engine state: %@", buf, 0x20u);
      }

      if (Mutable)
        CFRelease(Mutable);
      v17 = cf;
      if (cf)
      {
        cf = 0;
        CFRelease(v17);
      }
    }
  }
  else
  {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(a1 + 32) + 56), a2, a3);
  }
}

void sub_1000FE5B4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const __CFArray *v6;
  unint64_t Count;
  CFIndex v8;
  const void **v9;
  const __CFAllocator *v10;
  const __CFDictionary *v11;
  _QWORD context[7];
  CFRange v13;

  v6 = *(const __CFArray **)(a1 + 80);
  if (v6)
  {
    Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 80));
    if (Count >> 61)
    {
      v6 = 0;
    }
    else
    {
      v8 = Count;
      v9 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
      v13.location = 0;
      v13.length = v8;
      CFArrayGetValues(v6, v13, v9);
      v10 = CFGetAllocator(v6);
      v6 = CFSetCreate(v10, v9, v8, &kCFTypeSetCallBacks);
      free(v9);
    }
  }
  v11 = *(const __CFDictionary **)(a1 + 56);
  context[0] = _NSConcreteStackBlock;
  context[1] = 3221225472;
  context[2] = sub_1000FFBFC;
  context[3] = &unk_1002DE148;
  context[4] = v6;
  context[5] = a2;
  context[6] = a3;
  CFDictionaryApplyFunction(v11, (CFDictionaryApplierFunction)sub_1000FCFBC, context);
  if (v6)
    CFRelease(v6);
}

void sub_1000FE6C0(uint64_t a1, CFTypeRef a2, const __CFArray *a3, const __CFArray *a4)
{
  __CFString *MutableCopy;
  CFMutableDictionaryRef Mutable;
  CFTypeRef v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  id v14;
  CFTypeRef v15;
  const void *v16;
  const void *v17;
  NSObject *v18;
  _QWORD v19[6];
  uint64_t v20;
  const __CFSet *v21;
  __CFString *v22;
  __int128 buf;
  void (*v24)(uint64_t, uint64_t);
  void *v25;
  __CFString *v26;
  CFTypeRef v27;
  CFRange v28;
  CFRange v29;

  v21 = 0;
  v22 = 0;
  v20 = 0;
  MutableCopy = CFStringCreateMutableCopy(kCFAllocatorDefault, 0, CFSTR("me"));
  if (a2)
    a2 = sub_1001EB620(a2, &v21, &v20, &v22);
  if (MutableCopy)
  {
    *(_QWORD *)&buf = _NSConcreteStackBlock;
    *((_QWORD *)&buf + 1) = 3221225472;
    v24 = sub_1000FE968;
    v25 = &unk_1002EBDB0;
    v26 = MutableCopy;
    v27 = a2;
    sub_10002FEC4(v21, (uint64_t)&buf);
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (*(_BYTE *)(a1 + 104))
  {
    v10 = *(CFTypeRef *)(a1 + 24);
    if (a2 && v10)
    {
      if (!CFEqual(a2, v10))
        goto LABEL_16;
    }
    else if (a2 != v10)
    {
LABEL_16:
      *(_BYTE *)(a1 + 105) = 1;
      goto LABEL_17;
    }
    v19[0] = _NSConcreteStackBlock;
    v19[1] = 3221225472;
    v19[2] = sub_1000FE99C;
    v19[3] = &unk_1002ECBA8;
    v19[4] = a1;
    v19[5] = Mutable;
    v11 = objc_retainBlock(v19);
    v12 = v11;
    if (a3)
    {
      v13 = v11;
      v28.length = CFArrayGetCount(a3);
      v28.location = 0;
      CFArrayApplyFunction(a3, v28, (CFArrayApplierFunction)sub_1000FEA00, v13);

    }
    if (a4)
    {
      v14 = v12;
      v29.length = CFArrayGetCount(a4);
      v29.location = 0;
      CFArrayApplyFunction(a4, v29, (CFArrayApplierFunction)sub_1000FEA00, v14);

    }
    goto LABEL_16;
  }
LABEL_17:
  v15 = *(CFTypeRef *)(a1 + 24);
  if (v15 != a2)
  {
    if (!a2 || (CFRetain(a2), (v15 = *(CFTypeRef *)(a1 + 24)) != 0))
      CFRelease(v15);
    *(_QWORD *)(a1 + 24) = a2;
  }
  v16 = *(const void **)(a1 + 96);
  if (v16)
    CFRelease(v16);
  *(_QWORD *)(a1 + 96) = Mutable;
  sub_1000FEA14(a1, a3, a4, MutableCopy);
  v17 = sub_10000EF14("engine");
  v18 = objc_claimAutoreleasedReturnValue(v17);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 138412290;
    *(_QWORD *)((char *)&buf + 4) = MutableCopy;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%@", (uint8_t *)&buf, 0xCu);
  }

  if (MutableCopy)
    CFRelease(MutableCopy);
}

void sub_1000FE968(uint64_t a1, uint64_t a2)
{
  CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 32), 0, CFSTR(" %@ (%@)"), *(_QWORD *)(a1 + 40), a2);
}

void sub_1000FE99C(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3;
  const void *v4;
  const void *Value;

  v3 = sub_1001EB620(cf, 0, 0, 0);
  if (v3)
  {
    v4 = v3;
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(*(_QWORD *)(a1 + 32) + 96), v3);
    if (Value)
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), v4, Value);
  }
}

uint64_t sub_1000FEA00(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_1000FEA14(uint64_t a1, const __CFArray *a2, const __CFArray *a3, __CFString *a4)
{
  const void *v7;
  const void *Value;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  const void *v16;
  CFTypeID v17;
  const void *v18;
  __CFDictionary *v19;
  const void *v20;
  NSObject *v21;
  void *V0BackupViewSet;
  const __CFDictionary *v23;
  void *V0BackupBagViewSet;
  CFMutableArrayRef *v25;
  CFIndex Count;
  CFIndex i;
  const void *ValueAtIndex;
  void *v29;
  void *V0ViewSet;
  __CFDictionary *v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  CFDictionaryRef v37;
  CFMutableArrayRef *v38;
  CFTypeID v39;
  void *v40;
  CFTypeRef *v41;
  _OWORD *v42;
  _OWORD *v43;
  CFIndex v44;
  CFIndex j;
  const void *v46;
  CFTypeRef v47;
  CFSetRef v48;
  void *MutableCopy;
  const __CFSet *v50;
  CFTypeID v51;
  CFTypeID v52;
  const void *v53;
  int v54;
  const void *v55;
  const void *v56;
  const void *v57;
  CFMutableDictionaryRef v58;
  const __CFDictionary *v59;
  const void *v60;
  __CFArray *theArray;
  const __CFDictionary *Mutable;
  __CFDictionary *theDict;
  CFSetRef v65;
  CFTypeRef cf;
  CFTypeRef *p_cf;
  uint64_t v68;
  char v69;
  __int128 buf;
  void *v71;
  void *v72;
  CFTypeRef *p_isa;
  CFTypeRef v74;

  theArray = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  theDict = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (*(_QWORD *)(a1 + 24))
  {
    v7 = (const void *)kSOSViewKeychainV0_tomb;
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 56), kSOSViewKeychainV0_tomb);
    if (Value && (v16 = Value, v17 = CFGetTypeID(Value), v17 == sub_1001EB8FC()))
    {
      v18 = (const void *)*((_QWORD *)v16 + 14);
      if (v18)
        CFRetain(*((CFTypeRef *)v16 + 14));
    }
    else
    {
      cf = 0;
      v19 = sub_1000FF1C8(kCFAllocatorDefault, v9, v10, v11, v12, v13, v14, v15, (void *)kSecAttrAccessGroup, (uint64_t)CFSTR("com.apple.sbd"));
      v18 = (const void *)(*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 48))();
      if (v19)
        CFRelease(v19);
      if (!v18)
      {
        v20 = sub_10000EF14("engine");
        v21 = objc_claimAutoreleasedReturnValue(v20);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 138412290;
          *(_QWORD *)((char *)&buf + 4) = cf;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "No keybag found for v0 backup peer: %@", (uint8_t *)&buf, 0xCu);
        }

      }
    }
    V0BackupViewSet = (void *)SOSViewsGetV0BackupViewSet();
    sub_1000FF248(a1, v7, V0BackupViewSet, v18, Mutable, theDict);
    if (v18)
      CFRelease(v18);
    v23 = *(const __CFDictionary **)(a1 + 64);
    V0BackupBagViewSet = (void *)SOSViewsGetV0BackupBagViewSet();
    v25 = sub_1000FF390(v23, Mutable, V0BackupBagViewSet);
    CFArrayAppendValue(v25[3], &stru_1002DE1A8);
  }
  if (a2 && CFArrayGetCount(a2))
  {
    if (a4)
      CFStringAppend(a4, CFSTR(" trusted"));
    Count = CFArrayGetCount(a2);
    if (Count >= 1)
    {
      for (i = 0; i != Count; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a2, i);
        v65 = 0;
        cf = 0;
        v29 = (void *)sub_1001EB620(ValueAtIndex, &cf, &v65, 0);
        CFArrayAppendValue(theArray, v29);
        if (a4)
        {
          *(_QWORD *)&buf = _NSConcreteStackBlock;
          *((_QWORD *)&buf + 1) = 3221225472;
          v71 = sub_1000FE968;
          v72 = &unk_1002EBDB0;
          p_isa = (CFTypeRef *)&a4->isa;
          v74 = v29;
          sub_10002FEC4((const __CFSet *)cf, (uint64_t)&buf);
        }
        V0ViewSet = (void *)cf;
        if (!cf)
        {
          V0ViewSet = (void *)SOSViewsGetV0ViewSet();
          cf = V0ViewSet;
        }
        if (v65)
        {
          sub_1000FF248(a1, v29, V0ViewSet, v65, Mutable, theDict);
        }
        else
        {
          v31 = (__CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 56), v29);
          v37 = sub_1001EB7C4(v31, V0ViewSet, 0, v32, v33, v34, v35, v36);
          if (v37)
          {
            v38 = sub_1000FF390(*(const __CFDictionary **)(a1 + 64), Mutable, V0ViewSet);
            v39 = CFGetTypeID(v37);
            if (v39 == CFDictionaryGetTypeID())
            {
              *(_QWORD *)&buf = _NSConcreteStackBlock;
              v40 = sub_1000FF528;
              v41 = (CFTypeRef *)v29;
            }
            else
            {
              *(_QWORD *)&buf = _NSConcreteStackBlock;
              v40 = sub_1000FF4FC;
              v41 = (CFTypeRef *)v37;
            }
            *((_QWORD *)&buf + 1) = 3221225472;
            v71 = v40;
            v72 = &unk_1002DE1C8;
            p_isa = v41;
            v42 = objc_retainBlock(&buf);
            v43 = objc_retainBlock(v42);
            CFArrayAppendValue(v38[4], v43);
            CFDictionarySetValue(theDict, v29, v37);
            CFRelease(v37);

          }
        }
      }
    }
  }
  if (a3 && CFArrayGetCount(a3))
  {
    if (a4)
      CFStringAppend(a4, CFSTR(" untrusted"));
    v44 = CFArrayGetCount(a3);
    if (v44 >= 1)
    {
      for (j = 0; j != v44; ++j)
      {
        v46 = CFArrayGetValueAtIndex(a3, j);
        v65 = 0;
        v47 = sub_1001EB620(v46, &v65, 0, 0);
        if (a4)
        {
          *(_QWORD *)&buf = _NSConcreteStackBlock;
          *((_QWORD *)&buf + 1) = 3221225472;
          v71 = sub_1000FE968;
          v72 = &unk_1002EBDB0;
          p_isa = (CFTypeRef *)&a4->isa;
          v74 = v47;
          sub_10002FEC4(v65, (uint64_t)&buf);
        }
        if (v65)
        {
          v48 = 0;
        }
        else
        {
          v48 = CFSetCreate(kCFAllocatorDefault, 0, 0, &kCFTypeSetCallBacks);
          v65 = v48;
        }
        MutableCopy = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 56), v47);
        v50 = v65;
        if (!v65)
          sub_10003429C(CFSTR("Execution has encountered an unexpected state"), 0x53C0000Eu);
        if (MutableCopy)
        {
          v51 = CFGetTypeID(MutableCopy);
          if (v51 == sub_1001EB8FC())
          {
            sub_1001EB978((uint64_t)MutableCopy, v50);
            MutableCopy = sub_1001EC820((uint64_t)MutableCopy);
          }
          else
          {
            v52 = CFGetTypeID(MutableCopy);
            if (v52 == CFDictionaryGetTypeID())
            {
              v53 = CFDictionaryGetValue((CFDictionaryRef)MutableCopy, CFSTR("views"));
              MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, (CFDictionaryRef)MutableCopy);
              CFDictionarySetValue((CFMutableDictionaryRef)MutableCopy, CFSTR("views"), v50);
              if (v53)
              {
                cf = 0;
                p_cf = &cf;
                v68 = 0x2020000000;
                v69 = 1;
                *(_QWORD *)&buf = _NSConcreteStackBlock;
                *((_QWORD *)&buf + 1) = 3221225472;
                v71 = sub_1001EC42C;
                v72 = &unk_1002EC5E8;
                p_isa = &cf;
                v74 = v53;
                CFSetApplyFunction(v50, (CFSetApplierFunction)sub_1001EC460, &buf);
                v54 = *((unsigned __int8 *)p_cf + 24);
                _Block_object_dispose(&cf, 8);
                if (!v54)
                  CFDictionarySetValue((CFMutableDictionaryRef)MutableCopy, CFSTR("has-been-in-sync"), kCFBooleanFalse);
              }
            }
            else
            {
              MutableCopy = 0;
            }
          }
        }
        if (v48)
          CFRelease(v48);
        if (MutableCopy)
        {
          CFDictionarySetValue(theDict, v47, MutableCopy);
          CFRelease(MutableCopy);
        }
      }
    }
  }
  v55 = *(const void **)(a1 + 80);
  if (v55)
    CFRelease(v55);
  *(_QWORD *)(a1 + 80) = theArray;
  v56 = *(const void **)(a1 + 56);
  if (v56)
    CFRelease(v56);
  *(_QWORD *)(a1 + 56) = theDict;
  v57 = *(const void **)(a1 + 64);
  if (v57)
    CFRelease(v57);
  *(_QWORD *)(a1 + 64) = Mutable;
  v58 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v59 = *(const __CFDictionary **)(a1 + 64);
  *(_QWORD *)&buf = _NSConcreteStackBlock;
  *((_QWORD *)&buf + 1) = 3221225472;
  v71 = sub_1000FF65C;
  v72 = &unk_1002ECD08;
  p_isa = (CFTypeRef *)v58;
  CFDictionaryApplyFunction(v59, (CFDictionaryApplierFunction)sub_1000FCFBC, &buf);
  v60 = *(const void **)(a1 + 72);
  if (v60)
    CFRelease(v60);
  *(_QWORD *)(a1 + 72) = v58;
}

void sub_1000FF1A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

__CFDictionary *sub_1000FF1C8(const __CFAllocator *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *key, uint64_t a10)
{
  __CFDictionary *Mutable;
  const void *v11;
  const void **v12;
  const void **v14;

  Mutable = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v14 = (const void **)&a10;
  v11 = key;
  if (key)
  {
    do
    {
      CFDictionarySetValue(Mutable, v11, *v14);
      v12 = v14 + 1;
      v14 += 2;
      v11 = *v12;
    }
    while (*v12);
  }
  return Mutable;
}

void sub_1000FF248(uint64_t a1, const void *a2, void *a3, const void *a4, const __CFDictionary *a5, __CFDictionary *a6)
{
  __CFDictionary *Value;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  CFDictionaryRef v18;
  const __CFDictionary *v19;
  CFTypeID v20;
  _QWORD *v21;
  CFMutableArrayRef *v22;
  _QWORD *v23;
  id v24;
  _QWORD v25[5];

  Value = (__CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 56), a2);
  v18 = sub_1001EB7C4(Value, a3, a4, v13, v14, v15, v16, v17);
  if (v18)
  {
    v19 = v18;
    v20 = CFGetTypeID(v18);
    if (v20 == CFDictionaryGetTypeID())
    {
      v21 = sub_1001ED338(a1, a2, v19, 0);
      CFRelease(v19);
      if (!Value)
        sub_1001EBC14((uint64_t)v21);
    }
    else
    {
      v21 = v19;
    }
    CFDictionarySetValue(a6, a2, v21);
    CFRelease(v21);
    if (a4)
    {
      v22 = sub_1000FF390(*(const __CFDictionary **)(a1 + 64), a5, a3);
      v25[0] = _NSConcreteStackBlock;
      v25[1] = 3221225472;
      v25[2] = sub_1000FFA24;
      v25[3] = &unk_1002DE168;
      v25[4] = v21;
      v23 = objc_retainBlock(v25);
      v24 = objc_msgSend(v23, "copy");
      CFArrayAppendValue(v22[3], v24);

    }
  }
}

CFMutableArrayRef *sub_1000FF390(const __CFDictionary *a1, CFDictionaryRef theDict, void *key)
{
  CFMutableArrayRef *Value;
  CFMutableArrayRef *v7;
  __CFDictionary *v8;
  const void *v9;
  CFMutableArrayRef *v10;
  _QWORD block[5];

  Value = (CFMutableArrayRef *)CFDictionaryGetValue(theDict, key);
  if (!Value)
  {
    v7 = (CFMutableArrayRef *)CFDictionaryGetValue(a1, key);
    if (v7)
    {
      Value = v7;
      CFArrayRemoveAllValues(v7[3]);
      CFArrayRemoveAllValues(Value[4]);
      v8 = theDict;
      v9 = key;
      v10 = Value;
    }
    else
    {
      block[0] = _NSConcreteStackBlock;
      block[1] = 0x40000000;
      block[2] = sub_1000B5DA0;
      block[3] = &unk_1002DCDB8;
      block[4] = &qword_100341068;
      if (qword_100341060 != -1)
        dispatch_once(&qword_100341060, block);
      Value = (CFMutableArrayRef *)_CFRuntimeCreateInstance(kCFAllocatorDefault, qword_100341068, 24, 0);
      if (Value)
      {
        Value[3] = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        Value[4] = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        CFDictionarySetValue(theDict, key, Value);
        CFRelease(Value);
        return Value;
      }
      v8 = theDict;
      v9 = key;
      v10 = 0;
    }
    CFDictionarySetValue(v8, v9, v10);
  }
  return Value;
}

uint64_t sub_1000FF4FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, CFDataRef *a8, CFTypeRef *a9)
{
  sub_1001ED81C(*(_QWORD **)(a1 + 32), a5, a7, a8, a9);
  return 1;
}

BOOL sub_1000FF528(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, CFDataRef *a8, CFTypeRef *a9)
{
  _QWORD *v13;
  _BOOL8 v14;
  const void *v15;
  const void *v16;
  NSObject *v17;
  uint64_t v18;
  const void *v20;
  uint8_t buf[4];
  uint64_t v22;
  __int16 v23;
  const void *v24;

  v20 = 0;
  v13 = sub_1000FC7D8(a3, *(const void **)(a1 + 32), (__CFArray *)&v20);
  v14 = v13 != 0;
  if (v13)
  {
    v15 = v13;
    sub_1001ED81C(v13, a5, a7, a8, a9);
  }
  else
  {
    v16 = sub_10000EF14("SecError");
    v17 = objc_claimAutoreleasedReturnValue(v16);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      v18 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)buf = 138412546;
      v22 = v18;
      v23 = 2112;
      v24 = v20;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%@: peer failed to inflate: %@", buf, 0x16u);
    }

    v15 = v20;
    if (!v20)
      return 0;
  }
  CFRelease(v15);
  return v14;
}

void sub_1000FF65C(uint64_t a1, CFSetRef theSet, uint64_t a3)
{
  _QWORD v3[6];

  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_1000FF6C0;
  v3[3] = &unk_1002ECBA8;
  v3[4] = *(_QWORD *)(a1 + 32);
  v3[5] = a3;
  CFSetApplyFunction(theSet, (CFSetApplierFunction)sub_1000FEA00, v3);
}

void sub_1000FF6C0(uint64_t a1, const void *a2)
{
  CFTypeID v4;
  CFTypeID TypeID;
  void *v6;
  __CFSet *Mutable;
  void *value;

  value = 0;
  if (CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(a1 + 32), a2, (const void **)&value))
  {
    if (value)
    {
      v4 = CFGetTypeID(value);
      TypeID = CFSetGetTypeID();
      v6 = value;
      if (v4 == TypeID)
      {
        CFSetAddValue((CFMutableSetRef)value, *(const void **)(a1 + 40));
        return;
      }
    }
    else
    {
      v6 = 0;
    }
    if (!CFEqual(*(CFTypeRef *)(a1 + 40), v6))
    {
      Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
      CFSetAddValue(Mutable, value);
      CFSetAddValue(Mutable, *(const void **)(a1 + 40));
      CFDictionaryReplaceValue(*(CFMutableDictionaryRef *)(a1 + 32), a2, Mutable);
      CFRelease(Mutable);
    }
  }
  else
  {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), a2, *(const void **)(a1 + 40));
  }
}

BOOL sub_1000FF7A4(id a1, __OpaqueSOSChangeTracker *a2, __OpaqueSOSEngine *a3, __OpaqueSOSTransaction *a4, unint64_t a5, unint64_t a6, __CFArray *a7, __CFError **a8)
{
  CFIndex Count;
  CFIndex v10;
  CFIndex v11;
  const void *ValueAtIndex;
  CFTypeID v13;
  _QWORD *v14;
  CFTypeID v15;
  _QWORD *v16;
  const void *v17;
  const __CFString *v18;
  const void *v19;
  _QWORD *v20;
  const void *v21;
  uint64_t v22;
  const __CFArray *Mutable;
  const __CFArray *v24;
  const void *v26;

  Count = CFArrayGetCount(a7);
  if (Count >= 1)
  {
    v10 = Count;
    v11 = 0;
    v26 = (const void *)kSOSViewKeychainV0_tomb;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a7, v11);
      v13 = CFGetTypeID(ValueAtIndex);
      if (v13 == CFArrayGetTypeID())
      {
        if (CFArrayGetCount((CFArrayRef)ValueAtIndex) != 1)
          sub_10003429C(CFSTR("Execution has encountered an unexpected state"), 0x53C0000Eu);
        v14 = CFArrayGetValueAtIndex((CFArrayRef)ValueAtIndex, 0);
        ValueAtIndex = 0;
        if (!v14)
        {
LABEL_10:
          v16 = 0;
          goto LABEL_11;
        }
      }
      else
      {
        v14 = ValueAtIndex;
        if (!ValueAtIndex)
          goto LABEL_10;
      }
      v15 = CFGetTypeID(v14);
      if (v15 == CFDataGetTypeID())
        goto LABEL_29;
      v16 = v14;
LABEL_11:
      v17 = sub_10000C1D0(v16, kSecAttrService);
      if (v17 && CFEqual(v17, CFSTR("SecureBackupService")))
      {
        v18 = (const __CFString *)sub_10000C1D0(v14, kSecAttrAccessible);
        if (v18 && kSecAttrAccessibleWhenUnlocked)
        {
          if (CFEqual(v18, kSecAttrAccessibleWhenUnlocked))
            goto LABEL_18;
        }
        else if (v18 == kSecAttrAccessibleWhenUnlocked)
        {
LABEL_18:
          v19 = sub_10000C1D0(v14, kSecAttrAccount);
          if (v19 && CFEqual(v19, CFSTR("SecureBackupPublicKeybag")))
          {
            v20 = sub_1000FC7D8((uint64_t)a3, v26, 0);
            if (ValueAtIndex)
              v21 = sub_100019204(ValueAtIndex, (uint64_t)&off_1002DFE00, 0);
            else
              v21 = 0;
            v22 = v20[14];
            sub_1001EBA6C((uint64_t)v20, v21);
            if (!v22)
              sub_1001EBC14((uint64_t)v20);
            CFRelease(v20);
            Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
            v24 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
            sub_1000FE5B4((uint64_t)a3, (uint64_t)v24, (uint64_t)Mutable);
            sub_1000FEA14((uint64_t)a3, v24, Mutable, 0);
            if (v24)
              CFRelease(v24);
            if (Mutable)
              CFRelease(Mutable);
          }
        }
      }
LABEL_29:
      ++v11;
    }
    while (v10 != v11);
  }
  return 1;
}

BOOL sub_1000FFA24(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, CFTypeRef *a8)
{
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  BOOL v14;
  _BOOL8 v15;
  void *v16;
  _QWORD v18[9];
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  char v22;
  _QWORD activity_block[5];
  uint64_t v24;

  v11 = *(_QWORD *)(a1 + 32);
  if (-[OTSOSActualAdapter sosEnabled]_0())
    v12 = *(_QWORD *)(a3 + 16);
  else
    v12 = 0;
  v19 = 0;
  v20 = &v19;
  v21 = 0x2020000000;
  v22 = 1;
  if (*(_BYTE *)(v11 + 48) && (sub_1001EBFEC(v11, a8) & 1) == 0)
  {
    *((_BYTE *)v20 + 24) = 0;
LABEL_12:
    v24 = *(_QWORD *)(v11 + 16);
    v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v24, 1));
    activity_block[0] = _NSConcreteStackBlock;
    activity_block[1] = 3221225472;
    activity_block[2] = sub_10020D4FC;
    activity_block[3] = &unk_1002ED1A0;
    activity_block[4] = v16;
    _os_activity_initiate((void *)&_mh_execute_header, "CloudCircle SOSCCRequestSyncWithBackupPeerList", OS_ACTIVITY_FLAG_DEFAULT, activity_block);

    v15 = *((_BYTE *)v20 + 24) != 0;
    goto LABEL_13;
  }
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472;
  v18[2] = sub_1001EDB0C;
  v18[3] = &unk_1002EC5C0;
  v18[4] = &v19;
  v18[5] = a7;
  v18[6] = v12;
  v18[7] = v11;
  v18[8] = a8;
  v13 = sub_1001ECDD8(v11, a8, v18);
  if (*((_BYTE *)v20 + 24))
    v14 = v13;
  else
    v14 = 0;
  *((_BYTE *)v20 + 24) = v14;
  if (!v14)
    goto LABEL_12;
  v15 = 1;
LABEL_13:
  _Block_object_dispose(&v19, 8);
  return v15;
}

void sub_1000FFBD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  _Unwind_Resume(exception_object);
}

void sub_1000FFBFC(const __CFSet **a1, const __CFDictionary *cf1, uint64_t *cf)
{
  CFTypeID v6;
  uint64_t v7;
  const void *v8;
  const __CFDictionary *v9;
  CFDictionaryRef v10;
  const void *Value;
  const __CFSet *v12;

  if (cf)
  {
    v6 = CFGetTypeID(cf);
    if (v6 == sub_1001EB8FC())
    {
      v7 = cf[3];
      v8 = (const void *)cf[14];
      v9 = cf1;
LABEL_10:
      v10 = sub_1001EB4E0(v9, v7, (uint64_t)v8);
      goto LABEL_11;
    }
  }
  if (!cf1 || !kSOSViewKeychainV0_tomb)
  {
    if ((const __CFDictionary *)kSOSViewKeychainV0_tomb == cf1)
      goto LABEL_7;
LABEL_9:
    Value = CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("views"));
    v8 = CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("keybag"));
    v9 = cf1;
    v7 = (uint64_t)Value;
    goto LABEL_10;
  }
  if (!CFEqual(cf1, kSOSViewKeychainV0_tomb))
    goto LABEL_9;
LABEL_7:
  v10 = 0;
LABEL_11:
  v12 = a1[4];
  if (v12 && CFSetContainsValue(v12, cf1))
    goto LABEL_16;
  if (!cf1 || !kSOSViewKeychainV0_tomb)
  {
    if ((const __CFDictionary *)kSOSViewKeychainV0_tomb == cf1)
      goto LABEL_16;
LABEL_19:
    CFArrayAppendValue(a1[6], cf1);
    if (!v10)
      return;
    goto LABEL_20;
  }
  if (!CFEqual(cf1, kSOSViewKeychainV0_tomb))
    goto LABEL_19;
LABEL_16:
  if (!v10)
    return;
  CFArrayAppendValue(a1[5], v10);
LABEL_20:
  CFRelease(v10);
}

CFTypeRef sub_1000FFD34(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (-[OTSOSActualAdapter sosEnabled]_0())
    return sub_1000FFD90(a1, *(const void **)(a2 + 24), a3);
  SOSCCSetSOSDisabledError(a3);
  return 0;
}

CFTypeRef sub_1000FFD90(uint64_t a1, const void *a2, uint64_t a3)
{
  _QWORD *Value;
  _QWORD *v6;
  const void *v7;
  CFTypeRef v8;
  CFTypeRef v9;

  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), a2);
  if (Value)
  {
    v6 = Value;
    CFRetain(Value);
    v7 = (const void *)v6[2];
    if (v7)
    {
      v8 = CFRetain(v7);
      if (v8)
      {
LABEL_12:
        CFRelease(v6);
        return v8;
      }
    }
    else
    {
      SOSErrorCreate(1042, 0, 0, CFSTR("ChangeTracker is not concrete"));
    }
    v8 = (CFTypeRef)(*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 24))();
    v9 = (CFTypeRef)v6[2];
    if (v9 != v8)
    {
      if (!v8 || (CFRetain(v8), (v9 = (CFTypeRef)v6[2]) != 0))
        CFRelease(v9);
      v6[2] = v8;
    }
    goto LABEL_12;
  }
  SOSErrorCreate(1032, a3, 0, CFSTR("no change tracker for view set %@"));
  return 0;
}

void sub_1000FFE80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  NSObject *v7;
  _QWORD block[9];

  v6 = *(_QWORD *)(a1 + 32);
  v7 = *(NSObject **)(v6 + 112);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000FFEE0;
  block[3] = &unk_1002DE1E8;
  block[4] = v6;
  block[5] = a3;
  block[6] = a4;
  block[7] = a5;
  block[8] = a6;
  dispatch_sync(v7, block);
}

void sub_1000FFEE0(uint64_t a1)
{
  const void *v2;
  NSObject *v3;
  const void *v4;
  NSObject *v5;
  CFTypeRef cf;
  uint8_t buf[4];
  CFTypeRef v8;

  if (-[OTSOSActualAdapter sosEnabled]_0())
  {
    cf = 0;
    if ((sub_10010000C(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *(const __CFArray **)(a1 + 64), &cf) & 1) == 0)
    {
      v2 = sub_10000EF14("SecError");
      v3 = objc_claimAutoreleasedReturnValue(v2);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v8 = cf;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "updateChanged failed: %@", buf, 0xCu);
      }

    }
    if (cf)
      CFRelease(cf);
  }
  else
  {
    v4 = sub_10000EF14("engine");
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "SOS disabled for this platform", buf, 2u);
    }

  }
}

uint64_t sub_10010000C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const __CFArray *a5, CFTypeRef *a6)
{
  const void *v11;
  NSObject *v12;
  uint64_t v13;
  const char *v14;
  const char *v15;
  const char *v16;
  uint64_t v17;
  CFIndex Count;
  CFIndex v19;
  int v20;
  const __CFArray *ValueAtIndex;
  const __CFArray *v22;
  CFTypeID v23;
  CFIndex v24;
  _QWORD *v25;
  CFTypeID v26;
  CFBooleanRef v27;
  const void *v28;
  NSObject *v29;
  CFTypeRef v30;
  int v31;
  CFSetRef v32;
  const void *v33;
  NSObject *v34;
  NSObject *v35;
  uint64_t v36;
  _QWORD v39[4];
  CFDictionaryRef theDict;
  CFSetRef theSet;
  CFTypeRef cf;
  CFTypeRef *p_cf;
  uint64_t v44;
  char v45;
  _BYTE buf[24];
  const char *v47;
  _BYTE v48[30];

  if (!-[OTSOSActualAdapter sosEnabled]_0())
  {
    SOSCCSetSOSDisabledError(a6);
    return 0;
  }
  v11 = sub_10000EF14("engine");
  v12 = objc_claimAutoreleasedReturnValue(v11);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    v13 = *(_QWORD *)(a1 + 24);
    v14 = "did-rollback";
    if (a3 == 2)
      v14 = "did-commit";
    if (a3 == 1)
      v15 = "will-commit";
    else
      v15 = v14;
    if (a4)
    {
      if (a4 == 3)
      {
        v16 = "ckks";
      }
      else if (a4 == 1)
      {
        v16 = "api";
      }
      else
      {
        v16 = "unknown";
      }
    }
    else
    {
      v16 = "sos";
    }
    *(_DWORD *)buf = 138413570;
    *(_QWORD *)&buf[4] = v13;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = v15;
    *(_WORD *)&buf[22] = 2080;
    v47 = v16;
    *(_WORD *)v48 = 2048;
    *(_QWORD *)&v48[2] = CFArrayGetCount(a5);
    *(_WORD *)&v48[10] = 2112;
    *(_QWORD *)&v48[12] = a2;
    *(_WORD *)&v48[20] = 2048;
    *(_QWORD *)&v48[22] = a2;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%@: %s %s %ld changes, txn=%@, %p", buf, 0x3Eu);
  }

  if ((unint64_t)(a3 - 1) >= 2)
  {
    if (!a3)
      return sub_1000FDD40(a1, a2, a6);
    return 1;
  }
  v39[0] = a1;
  v39[1] = a2;
  v39[2] = a3;
  v39[3] = a4;
  theDict = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  theSet = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  Count = CFArrayGetCount(a5);
  if (Count >= 1)
  {
    v19 = 0;
    v20 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(a5, v19);
      v22 = ValueAtIndex;
      if (!ValueAtIndex)
        goto LABEL_38;
      v23 = CFGetTypeID(ValueAtIndex);
      if (v23 == CFArrayGetTypeID())
      {
        v24 = CFArrayGetCount(v22);
        if (v24 == 1)
        {
          v25 = CFArrayGetValueAtIndex(v22, 0);
          v22 = 0;
          if (v25)
            goto LABEL_28;
        }
        else
        {
          if (v24 != 2)
          {
            sub_100019F20(-50, (__CFString **)a6, 0, CFSTR("invalid entry in changes array: %@"), v22);
            goto LABEL_38;
          }
          v25 = CFArrayGetValueAtIndex(v22, 0);
          v22 = (const __CFArray *)CFArrayGetValueAtIndex(v22, 1);
          if (v25)
          {
LABEL_28:
            v20 |= sub_100100D98((uint64_t)v39, 0, v25);
            if (!v22)
              goto LABEL_38;
            goto LABEL_29;
          }
        }
        if (!v22)
          goto LABEL_38;
      }
LABEL_29:
      if (sub_100100D98((uint64_t)v39, 1, v22))
      {
        v20 = 1;
      }
      else
      {
        v26 = CFGetTypeID(v22);
        if (v26 != CFDataGetTypeID() && sub_10001DA80((_QWORD **)v22))
        {
          v27 = (CFBooleanRef)sub_100019204(v22, (uint64_t)&off_1002DFE78, 0);
          if (v27 && kCFBooleanTrue)
          {
            if (!CFEqual(v27, kCFBooleanTrue))
              goto LABEL_41;
          }
          else if (v27 != kCFBooleanTrue)
          {
LABEL_41:
            cf = 0;
            if (!sub_10001E020((CFStringRef **)v22, a2, &cf, (uint64_t)&stru_1002DE790))
            {
              v28 = sub_10000EF14("SecError");
              v29 = objc_claimAutoreleasedReturnValue(v28);
              if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 138478083;
                *(_QWORD *)&buf[4] = v22;
                *(_WORD *)&buf[12] = 2112;
                *(_QWORD *)&buf[14] = cf;
                _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "failed to delete tombstone %{private}@ that no one cares about: %@", buf, 0x16u);
              }

              v30 = cf;
              if (cf)
              {
                cf = 0;
                CFRelease(v30);
              }
            }
          }
        }
      }
LABEL_38:
      if (Count == ++v19)
        goto LABEL_49;
    }
  }
  v20 = 0;
LABEL_49:
  cf = 0;
  p_cf = &cf;
  v44 = 0x2020000000;
  v45 = 1;
  *(_QWORD *)buf = _NSConcreteStackBlock;
  *(_QWORD *)&buf[8] = 3221225472;
  *(_QWORD *)&buf[16] = sub_100100694;
  v47 = (const char *)&unk_1002EC9E8;
  *(_QWORD *)v48 = &cf;
  *(_QWORD *)&v48[8] = v39;
  *(_QWORD *)&v48[16] = a6;
  CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)sub_1000FCFBC, buf);
  v31 = *((unsigned __int8 *)p_cf + 24);
  v17 = *((_BYTE *)p_cf + 24) != 0;
  _Block_object_dispose(&cf, 8);
  v32 = theSet;
  if (qword_1003410D8 != -1)
    dispatch_once(&qword_1003410D8, &stru_1002DE268);
  if (qword_1003410E0 && CFSetGetCount(v32))
  {
    CFRetain(v32);
    *(_QWORD *)buf = _NSConcreteStackBlock;
    *(_QWORD *)&buf[8] = 3221225472;
    *(_QWORD *)&buf[16] = sub_100100CDC;
    v47 = (const char *)&unk_1002ED1A0;
    *(_QWORD *)v48 = v32;
    dispatch_async((dispatch_queue_t)qword_1003410E0, buf);
  }
  if (theDict)
    CFRelease(theDict);
  if (theSet)
    CFRelease(theSet);
  if (a3 == 1 && v31)
  {
    v33 = sub_10000EF14("engine");
    v34 = objc_claimAutoreleasedReturnValue(v33);
    v35 = v34;
    if (((a4 != 0) & (v20 ^ 1)) == 0)
    {
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "saving engine state", buf, 2u);
      }

      v17 = sub_1000FCFD4(a1, a2, a6);
      if ((a4 & 0xFFFFFFFFFFFFFFFDLL) == 1)
      {
        v36 = *(_QWORD *)(a1 + 80);
        *(_QWORD *)buf = _NSConcreteStackBlock;
        *(_QWORD *)&buf[8] = 3221225472;
        *(_QWORD *)&buf[16] = sub_100202158;
        v47 = (const char *)&unk_1002ED1A0;
        *(_QWORD *)v48 = v36;
        _os_activity_initiate((void *)&_mh_execute_header, "CloudCircle RequestSyncWithPeersList", OS_ACTIVITY_FLAG_DEFAULT, buf);
      }
      return v17;
    }
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEBUG, "Not saving engine state, nothing changed.", buf, 2u);
    }

    return 1;
  }
  return v17;
}

void sub_100100674(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100100694(uint64_t result, uint64_t a2, CFArrayRef theArray)
{
  uint64_t v3;
  uint64_t *v6;
  CFTypeRef *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __CFString *MutableCopy;
  CFIndex Count;
  CFIndex v13;
  CFIndex i;
  const void *ValueAtIndex;
  CFTypeID v16;
  CFTypeID TypeID;
  CFTypeID v18;
  BOOL v19;
  const __CFString *v20;
  const __CFString *v21;
  const __CFString *v22;
  NSObject *v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  const char *v27;
  BOOL v28;
  CFIndex v29;
  CFIndex v30;
  CFIndex j;
  const __CFArray *v32;
  const __CFArray *v33;
  CFTypeID v34;
  char **v35;
  CFTypeID v36;
  const void *v37;
  const __CFData *v38;
  uint64_t v39;
  __int128 *BytePtr;
  NSObject *v41;
  CFTypeRef v42;
  NSObject *v43;
  const void *v44;
  const void *v45;
  _BOOL4 v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  const void *v51;
  const __CFArray *v52;
  CFIndex v53;
  CFIndex v54;
  CFIndex v55;
  uint64_t (**v56)(const void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, const void *, const void *, CFTypeRef *);
  uint64_t v57;
  uint64_t v58;
  CFIndex k;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  CFTypeRef *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  CFTypeRef cf;
  void *v68[2];
  __int128 v69;
  uint8_t buf[32];
  __int16 v71;
  __CFString *v72;
  uint8_t v73[4];
  const __CFArray *v74;
  __int16 v75;
  CFTypeRef v76;

  v3 = result;
  if (theArray
    && (v6 = *(uint64_t **)(result + 40),
        v7 = *(CFTypeRef **)(result + 48),
        v8 = v6[1],
        v66 = *v6,
        v10 = v6[2],
        v9 = v6[3],
        (result = CFArrayGetCount(theArray)) != 0))
  {
    v64 = v10;
    v65 = v9;
    v63 = v7;
    v61 = a2;
    v62 = v3;
    MutableCopy = CFStringCreateMutableCopy(kCFAllocatorDefault, 0, CFSTR("("));
    Count = CFArrayGetCount(theArray);
    if (Count >= 1)
    {
      v13 = Count;
      for (i = 0; i != v13; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(theArray, i);
        v16 = CFGetTypeID(ValueAtIndex);
        TypeID = CFArrayGetTypeID();
        if (v16 == TypeID)
          ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)ValueAtIndex, 0);
        if (ValueAtIndex)
        {
          v18 = CFGetTypeID(ValueAtIndex);
          v19 = v18 == CFDataGetTypeID();
          v20 = CFSTR("a");
          if (v16 == TypeID)
          {
            v20 = CFSTR("d");
            v21 = CFSTR("D");
          }
          else
          {
            v21 = CFSTR("A");
          }
          if (v19)
            v22 = v20;
          else
            v22 = v21;
        }
        else if (v16 == TypeID)
        {
          v22 = CFSTR("D");
        }
        else
        {
          v22 = CFSTR("A");
        }
        CFStringAppend(MutableCopy, v22);
        CFRelease(v22);
      }
    }
    CFStringAppend(MutableCopy, CFSTR(")"));
    v23 = sub_10000EF14("tracker");
    v25 = v64;
    v24 = v65;
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      v26 = "did-rollback";
      if (v64 == 2)
        v26 = "did-commit";
      if (v64 == 1)
        v26 = "will-commit";
      if (v65)
      {
        if (v65 == 3)
        {
          v27 = "ckks";
        }
        else
        {
          v27 = "unknown";
          if (v65 == 1)
            v27 = "api";
        }
      }
      else
      {
        v27 = "sos";
      }
      *(_DWORD *)buf = 138413058;
      *(_QWORD *)&buf[4] = a2;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = v26;
      *(_WORD *)&buf[22] = 2080;
      *(_QWORD *)&buf[24] = v27;
      v71 = 2112;
      v72 = MutableCopy;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%@ %s %s changes: %@", buf, 0x2Au);
    }
    if (MutableCopy)
      CFRelease(MutableCopy);
    if (*(_QWORD *)(a2 + 16) || *(_QWORD *)(a2 + 32))
    {
      memset(buf, 0, sizeof(buf));
      *(_OWORD *)v68 = 0u;
      v69 = 0u;
      v29 = CFArrayGetCount(theArray);
      if (v29 >= 1)
      {
        v30 = v29;
        for (j = 0; v30 != j; ++j)
        {
          v32 = (const __CFArray *)CFArrayGetValueAtIndex(theArray, j);
          v33 = v32;
          if (v32)
          {
            v34 = CFGetTypeID(v32);
            if (v34 == CFArrayGetTypeID())
            {
              v33 = (const __CFArray *)CFArrayGetValueAtIndex(v33, 0);
              v35 = (char **)buf;
              if (!v33)
                goto LABEL_45;
            }
            else
            {
              v35 = (char **)v68;
            }
            v36 = CFGetTypeID(v33);
            if (v36 == CFDataGetTypeID())
            {
              v37 = 0;
              v38 = v33;
              goto LABEL_47;
            }
          }
          else
          {
            v35 = (char **)v68;
          }
LABEL_45:
          cf = 0;
          -[OTSOSActualAdapter sosEnabled]_0();
          v39 = (*(uint64_t (**)(const __CFArray *, CFTypeRef *))(*(_QWORD *)(v66 + 16) + 112))(v33, &cf);
          if (!v39)
          {
            v43 = sub_10000EF14("SecError");
            if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)v73 = 138412546;
              v74 = v33;
              v75 = 2112;
              v76 = cf;
              _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "change %@ SOSObjectCopyDigest: %@", v73, 0x16u);
            }
            v42 = cf;
            if (!cf)
              continue;
            cf = 0;
            goto LABEL_57;
          }
          v37 = (const void *)v39;
          v38 = (const __CFData *)v39;
LABEL_47:
          if (CFDataGetLength(v38) == 20)
          {
            BytePtr = (__int128 *)CFDataGetBytePtr(v38);
            sub_1001E7584(v35, BytePtr);
            *((_BYTE *)v35 + 24) = 1;
          }
          else
          {
            v41 = sub_10000EF14("SecError");
            if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)v73 = 138412546;
              v74 = v33;
              v75 = 2112;
              v76 = v38;
              _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "change %@ bad length digest: %@", v73, 0x16u);
            }
          }
          if (!v37)
            continue;
          v42 = v37;
LABEL_57:
          CFRelease(v42);
        }
      }
      v44 = (const void *)sub_1001E88E8((uint64_t)buf, v63);
      if (v44)
      {
        v45 = (const void *)sub_1001E88E8((uint64_t)v68, v63);
        v46 = v45 != 0;
      }
      else
      {
        v45 = 0;
        v46 = 0;
      }
      free(v68[0]);
      v68[0] = 0;
      v68[1] = 0;
      BYTE8(v69) = 0;
      *(_QWORD *)&v69 = 0;
      free(*(void **)buf);
      v47 = 0;
      if (v46)
      {
        v48 = *(_QWORD *)(v61 + 16);
        if (v48)
        {
          v49 = sub_1001E8930(v48, (uint64_t)v44, (uint64_t)v45, v63);
          if (v49)
          {
            v50 = v49;
            v51 = *(const void **)(v61 + 16);
            if (v51)
              CFRelease(v51);
            *(_QWORD *)(v61 + 16) = v50;
          }
        }
        v52 = *(const __CFArray **)(v61 + 32);
        if (v52 && (v53 = CFArrayGetCount(v52), v53 >= 1))
        {
          v54 = v53;
          v55 = 0;
          LOBYTE(v47) = 1;
          do
          {
            v56 = (uint64_t (**)(const void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, const void *, const void *, CFTypeRef *))CFArrayGetValueAtIndex(*(CFArrayRef *)(v61 + 32), v55);
            if ((_BYTE)v47)
              v47 = v56[2](v56, v61, v66, v8, v65, v64, v44, v45, v63);
            else
              v47 = 0;
            ++v55;
          }
          while (v54 != v55);
        }
        else
        {
          v47 = 1;
        }
      }
      if (v44)
        CFRelease(v44);
      v57 = v8;
      v25 = v64;
      v24 = v65;
      if (v45)
        CFRelease(v45);
    }
    else
    {
      v47 = 1;
      v57 = v8;
    }
    result = *(_QWORD *)(v61 + 24);
    if (result)
    {
      result = CFArrayGetCount((CFArrayRef)result);
      if (result >= 1)
      {
        v58 = result;
        for (k = 0; k != v58; ++k)
        {
          result = (uint64_t)CFArrayGetValueAtIndex(*(CFArrayRef *)(v61 + 24), k);
          if ((_BYTE)v47)
          {
            result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, CFArrayRef, CFTypeRef *))(result + 16))(result, v61, v66, v57, v24, v25, theArray, v63);
            v47 = result;
          }
          else
          {
            v47 = 0;
          }
        }
      }
    }
    v28 = v47 != 0;
    v3 = v62;
  }
  else
  {
    v28 = 1;
  }
  v60 = *(_QWORD *)(*(_QWORD *)(v3 + 32) + 8);
  if (!*(_BYTE *)(v60 + 24))
    v28 = 0;
  *(_BYTE *)(v60 + 24) = v28;
  return result;
}

void sub_100100CDC(uint64_t a1)
{
  const __CFSet *v2;
  dispatch_time_t v3;
  _QWORD context[5];

  v2 = *(const __CFSet **)(a1 + 32);
  if (qword_1003410D0)
  {
    context[0] = _NSConcreteStackBlock;
    context[1] = 3221225472;
    context[2] = sub_1001017F0;
    context[3] = &unk_1002EDB28;
    context[4] = qword_1003410D0;
    CFSetApplyFunction(v2, (CFSetApplierFunction)sub_1000FEA00, context);
  }
  else
  {
    qword_1003410D0 = (uint64_t)CFSetCreateMutableCopy(0, 0, v2);
    v3 = dispatch_time(0, 1000000000);
    dispatch_after(v3, (dispatch_queue_t)qword_1003410E0, &stru_1002DE288);
  }
  CFRelease(*(CFTypeRef *)(a1 + 32));
}

BOOL sub_100100D98(uint64_t a1, char a2, _QWORD *cf)
{
  CFTypeID v6;
  const __CFDictionary *v7;
  CFIndex Count;
  const __CFSet *Mutable;
  _QWORD *v10;
  CFTypeID v11;
  const __CFBoolean *Value;
  int v13;
  uint64_t v14;
  uint64_t v15;
  const void *v16;
  CFTypeID v17;
  const __CFNumber *v18;
  const __CFNumber *v19;
  CFTypeID v20;
  const __CFString **v21;
  const __CFString *v23;
  const __CFString *v24;
  CFTypeID v25;
  CFStringRef v26;
  CFStringRef v27;
  const void *v28;
  NSObject *v29;
  const void *v30;
  const void *v31;
  BOOL v32;
  _QWORD v33[6];
  char v34;
  _QWORD v35[2];
  void (*v36)(uint64_t, const __CFString *);
  void *v37;
  uint64_t v38;
  const __CFSet *v39;
  _QWORD context[6];
  char v41;
  BOOL valuePtr;
  _BYTE buf[12];

  v6 = CFGetTypeID(cf);
  if (v6 == CFDataGetTypeID())
  {
    v7 = *(const __CFDictionary **)(*(_QWORD *)a1 + 64);
    context[0] = _NSConcreteStackBlock;
    context[1] = 3221225472;
    context[2] = sub_100101580;
    context[3] = &unk_1002DE228;
    v41 = a2;
    context[4] = a1;
    context[5] = cf;
    CFDictionaryApplyFunction(v7, (CFDictionaryApplierFunction)sub_1000FCFBC, context);
    Count = CFDictionaryGetCount(*(CFDictionaryRef *)(*(_QWORD *)a1 + 64));
    return Count != 0;
  }
  Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  v35[0] = _NSConcreteStackBlock;
  v35[1] = 3221225472;
  v36 = sub_100101594;
  v37 = &unk_1002EBDB0;
  v38 = a1;
  v39 = Mutable;
  v10 = v35;
  v11 = CFGetTypeID(cf);
  if (v11 == CFDictionaryGetTypeID())
  {
    Value = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)cf, kSecAttrTombstone);
    if (Value)
    {
      v13 = CFBooleanGetValue(Value);
      v36((uint64_t)v10, (const __CFString *)kSOSViewKeychainV0);
      if (v13)
        goto LABEL_31;
    }
    else
    {
      v36((uint64_t)v10, (const __CFString *)kSOSViewKeychainV0);
    }
    v21 = (const __CFString **)&kSOSViewKeychainV0_tomb;
    goto LABEL_30;
  }
  valuePtr = 0;
  *(_QWORD *)buf = 0;
  v14 = sub_10001E6A8((_QWORD *)cf[2], 11, (__CFString **)buf);
  if (!sub_10000BCD4(cf, v14, &valuePtr, (__CFString **)buf))
    valuePtr = SecErrorGetOSStatus(*(_QWORD *)buf) == -26275;
  if (*(_QWORD *)buf)
    CFRelease(*(CFTypeRef *)buf);
  if (!valuePtr)
    goto LABEL_31;
  v15 = cf[2];
  v16 = sub_10000C1D0(cf, kSecAttrAccessible);
  if (v15 != sub_1000119B8((uint64_t)CFSTR("genp"), &qword_100341240, (uint64_t)&unk_100341238)
    && v15 != sub_1000119B8((uint64_t)CFSTR("inet"), &qword_100341250, (uint64_t)&unk_100341248)
    && v15 != sub_1000119B8((uint64_t)CFSTR("keys"), &qword_100341270, (uint64_t)&unk_100341268)
    && v15 != sub_1000119B8((uint64_t)CFSTR("cert"), &qword_100341260, (uint64_t)&unk_100341258))
  {
    goto LABEL_31;
  }
  if (!v16)
    goto LABEL_31;
  v17 = CFGetTypeID(v16);
  if (v17 != CFStringGetTypeID()
    || !CFEqual(v16, kSecAttrAccessibleWhenUnlocked)
    && !CFEqual(v16, kSecAttrAccessibleAfterFirstUnlock)
    && !CFEqual(v16, kSecAttrAccessibleAlwaysPrivate)
    && !CFEqual(v16, kSecAttrAccessibleWhenUnlockedThisDeviceOnly)
    && !CFEqual(v16, kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly)
    && !CFEqual(v16, kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate))
  {
    goto LABEL_31;
  }
  v18 = (const __CFNumber *)sub_10000C1D0(cf, kSecAttrTombstone);
  valuePtr = 0;
  v32 = v18
     && (v19 = v18, v20 = CFGetTypeID(v18), v20 == CFNumberGetTypeID())
     && CFNumberGetValue(v19, kCFNumberCharType, &valuePtr)
     && valuePtr;
  v23 = (const __CFString *)sub_10000C1D0(cf, kSecAttrSyncViewHint);
  v24 = v23;
  if (v23)
  {
    v25 = CFGetTypeID(v23);
    if (v25 != CFStringGetTypeID())
      v24 = 0;
  }
  if ((SOSViewHintInCKKSSystem(v24) & 1) != 0)
    goto LABEL_31;
  if (!sub_1001164E4(cf))
  {
    v28 = sub_10000EF14("item");
    v29 = objc_claimAutoreleasedReturnValue(v28);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138477827;
      *(_QWORD *)&buf[4] = cf;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Skipping non-primary item %{private}@", buf, 0xCu);
    }

    goto LABEL_31;
  }
  if (v24)
  {
    v36((uint64_t)v10, v24);
    if (!v32)
    {
      v26 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@-tomb"), v24);
      if (v26)
      {
        v27 = v26;
        v36((uint64_t)v10, v26);
        CFRelease(v27);
      }
    }
    goto LABEL_31;
  }
  if (v15 == sub_1000119B8((uint64_t)CFSTR("cert"), &qword_100341260, (uint64_t)&unk_100341258))
  {
    v36((uint64_t)v10, (const __CFString *)kSOSViewOtherSyncable);
    if (v32)
      goto LABEL_31;
    goto LABEL_64;
  }
  if (!sub_10000C1D0(cf, kSecAttrTokenID))
  {
    v36((uint64_t)v10, (const __CFString *)kSOSViewKeychainV0);
    if (!v32)
      v36((uint64_t)v10, (const __CFString *)kSOSViewKeychainV0_tomb);
  }
  v30 = sub_10000C1D0(cf, kSecAttrAccessGroup);
  if (v15 != sub_1000119B8((uint64_t)CFSTR("keys"), &qword_100341270, (uint64_t)&unk_100341268))
  {
    if (v30)
    {
LABEL_53:
      if (CFEqual(v30, CFSTR("com.apple.cfnetwork")))
      {
        v36((uint64_t)v10, (const __CFString *)kSOSViewAutofillPasswords);
        if (!v32)
        {
          v21 = (const __CFString **)&kSOSViewAutofillPasswords_tomb;
LABEL_30:
          v36((uint64_t)v10, *v21);
          goto LABEL_31;
        }
        goto LABEL_31;
      }
      if (CFEqual(v30, CFSTR("com.apple.safari.credit-cards")))
      {
        v36((uint64_t)v10, (const __CFString *)kSOSViewSafariCreditCards);
        if (!v32)
        {
          v21 = (const __CFString **)&kSOSViewSafariCreditCards_tomb;
          goto LABEL_30;
        }
        goto LABEL_31;
      }
      if (v15 == sub_1000119B8((uint64_t)CFSTR("genp"), &qword_100341240, (uint64_t)&unk_100341238))
      {
        if (CFEqual(v30, CFSTR("apple")))
        {
          v31 = sub_10000C1D0(cf, kSecAttrService);
          if (v31)
          {
            if (CFEqual(v31, CFSTR("AirPort")))
            {
              v36((uint64_t)v10, (const __CFString *)kSOSViewWiFi);
              if (!v32)
              {
                v21 = (const __CFString **)&kSOSViewWiFi_tomb;
                goto LABEL_30;
              }
              goto LABEL_31;
            }
          }
        }
        if (CFEqual(v30, CFSTR("com.apple.sbd")))
        {
          v36((uint64_t)v10, (const __CFString *)kSOSViewBackupBagV0);
          if (!v32)
          {
            v21 = (const __CFString **)&kSOSViewBackupBagV0_tomb;
            goto LABEL_30;
          }
          goto LABEL_31;
        }
      }
      goto LABEL_63;
    }
LABEL_62:
    sub_1000119B8((uint64_t)CFSTR("genp"), &qword_100341240, (uint64_t)&unk_100341238);
LABEL_63:
    v36((uint64_t)v10, (const __CFString *)kSOSViewOtherSyncable);
    if (v32)
      goto LABEL_31;
LABEL_64:
    v21 = (const __CFString **)&kSOSViewOtherSyncable_tomb;
    goto LABEL_30;
  }
  if (!v30)
    goto LABEL_62;
  if (!CFEqual(v30, CFSTR("com.apple.security.sos")))
    goto LABEL_53;
  v36((uint64_t)v10, (const __CFString *)kSOSViewiCloudIdentity);
  if (!v32)
  {
    v21 = (const __CFString **)&kSOSViewiCloudIdentity_tomb;
    goto LABEL_30;
  }
LABEL_31:

  v33[0] = _NSConcreteStackBlock;
  v33[1] = 3221225472;
  v33[2] = sub_1001016A4;
  v33[3] = &unk_1002DE248;
  v34 = a2;
  v33[4] = a1;
  v33[5] = cf;
  CFSetApplyFunction(Mutable, (CFSetApplierFunction)sub_1000FEA00, v33);
  Count = CFSetGetCount(Mutable);
  if (Mutable)
    CFRelease(Mutable);
  return Count != 0;
}

void sub_100101580(uint64_t a1, uint64_t a2, const void *a3)
{
  sub_1001016B4(*(_QWORD *)(a1 + 32), a3, *(unsigned __int8 *)(a1 + 48), *(const void **)(a1 + 40));
}

void sub_100101594(uint64_t a1, const __CFString *a2)
{
  const __CFSet *Value;
  const __CFSet *v5;
  CFTypeID v6;
  uint64_t v7;
  CFTypeID v8;
  const __CFString *v9;
  _QWORD context[5];

  Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(**(_QWORD **)(a1 + 32) + 72), a2);
  if (Value)
  {
    v5 = Value;
    v6 = CFGetTypeID(Value);
    if (v6 == CFSetGetTypeID())
    {
      context[0] = _NSConcreteStackBlock;
      context[1] = 3221225472;
      context[2] = sub_1001017E8;
      context[3] = &unk_1002EDB28;
      context[4] = *(_QWORD *)(a1 + 40);
      CFSetApplyFunction(v5, (CFSetApplierFunction)sub_1000FEA00, context);
    }
    else
    {
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 40), v5);
    }
  }
  v7 = *(_QWORD *)(a1 + 32);
  if (!a2 || (v8 = CFGetTypeID(a2), v8 != CFStringGetTypeID()))
    sub_10003429C(CFSTR("Execution has encountered an unexpected state"), 0x53C0000Eu);
  if (CFStringHasPrefix(a2, CFSTR("PCS-")))
    v9 = CFSTR("PCS");
  else
    v9 = a2;
  CFSetSetValue(*(CFMutableSetRef *)(v7 + 40), v9);
}

void sub_1001016A4(uint64_t a1, const void *a2)
{
  sub_1001016B4(*(_QWORD *)(a1 + 32), a2, *(unsigned __int8 *)(a1 + 48), *(const void **)(a1 + 40));
}

void sub_1001016B4(uint64_t a1, const void *a2, int a3, const void *a4)
{
  void *Value;
  CFArrayRef v9;
  const void *v10;

  Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), a2);
  if (!Value)
  {
    Value = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), a2, Value);
    if (Value)
      CFRelease(Value);
  }
  if (a3)
  {
    CFArrayAppendValue((CFMutableArrayRef)Value, a4);
  }
  else
  {
    v10 = a4;
    v9 = CFArrayCreate(kCFAllocatorDefault, &v10, 1, &kCFTypeArrayCallBacks);
    CFArrayAppendValue((CFMutableArrayRef)Value, v9);
    if (v9)
      CFRelease(v9);
  }
}

void sub_1001017E8(uint64_t a1, const void *a2)
{
  CFSetAddValue(*(CFMutableSetRef *)(a1 + 32), a2);
}

void sub_1001017F0(uint64_t a1, const void *a2)
{
  CFSetSetValue(*(CFMutableSetRef *)(a1 + 32), a2);
}

void sub_1001017F8(id a1)
{
  const __CFSet *v1;
  _QWORD context[5];

  v1 = (const __CFSet *)qword_1003410D0;
  context[0] = _NSConcreteStackBlock;
  context[1] = 3221225472;
  context[2] = sub_100101874;
  context[3] = &unk_1002EDB28;
  context[4] = CFNotificationCenterGetDarwinNotifyCenter();
  CFSetApplyFunction(v1, (CFSetApplierFunction)sub_1000FEA00, context);
  CFRelease((CFTypeRef)qword_1003410D0);
  qword_1003410D0 = 0;
}

void sub_100101874(uint64_t a1, uint64_t a2)
{
  const void *v4;
  NSObject *v5;
  const __CFString *v6;
  const __CFString *v7;
  uint8_t buf[4];
  uint64_t v9;

  v4 = sub_10000EF14("view");
  v5 = objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138412290;
    v9 = a2;
    _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Sending view notification for view %@", buf, 0xCu);
  }

  v6 = CFStringCreateWithFormat(0, 0, CFSTR("com.apple.security.view-change.%@"), a2);
  if (v6)
  {
    v7 = v6;
    CFNotificationCenterPostNotificationWithOptions(*(CFNotificationCenterRef *)(a1 + 32), v6, 0, 0, 0);
    CFRelease(v7);
  }
}

void sub_10010196C(id a1)
{
  dispatch_queue_t v1;
  void *v2;

  v1 = dispatch_queue_create("ViewNotificationQueue", 0);
  v2 = (void *)qword_1003410E0;
  qword_1003410E0 = (uint64_t)v1;

}

void sub_100101998(uint64_t a1, const void *a2, _BYTE *a3)
{
  const __CFData *v6;
  const __CFData *v7;
  uint64_t v8;
  __int128 *BytePtr;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  char v14;
  const void *v15;
  NSObject *v16;
  uint64_t v17;
  _QWORD *v18;
  const void *v19;
  NSObject *v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  __int128 *v24;
  uint64_t v25;
  const __CFDate *v26;
  double Current;
  CFAbsoluteTime AbsoluteTime;
  int64_t v29;
  const __CFString *v30;
  uint64_t v31;
  unint64_t v32;
  BOOL v33;
  CFTypeRef cf1;
  uint8_t buf[4];
  uint64_t v36;
  __int16 v37;
  _QWORD *v38;

  v6 = (const __CFData *)(*(uint64_t (**)(const void *, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 16)
                                                                         + 112))(a2, *(_QWORD *)(a1 + 64));
  if (v6)
  {
    v7 = v6;
    v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    BytePtr = (__int128 *)CFDataGetBytePtr(v6);
    sub_1001E7584((char **)(v8 + 32), BytePtr);
    *(_BYTE *)(v8 + 56) = 1;
    cf1 = 0;
    v10 = (*(uint64_t (**)(_QWORD, const void *, CFTypeRef *, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 16)
                                                                               + 88))(*(_QWORD *)(a1 + 88), a2, &cf1, *(_QWORD *)(a1 + 64));
    v11 = v10;
    v12 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    if (v10)
      v13 = *(_BYTE *)(v12 + 24) == 0;
    else
      v13 = 1;
    v14 = !v13;
    *(_BYTE *)(v12 + 24) = v14;
    if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24))
    {
      if ((v10 & 0xFFFFFFFFFFFFFFFELL) == 2)
      {
        **(_BYTE **)(a1 + 96) = 1;
      }
      else
      {
        if (!CFEqual(cf1, a2))
        {
          v23 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
          v24 = (__int128 *)CFDataGetBytePtr(v7);
          sub_1001E7584((char **)(v23 + 32), v24);
          *(_BYTE *)(v23 + 56) = 1;
        }
        CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 104), cf1);
      }
    }
    else
    {
      *a3 = 1;
      **(_BYTE **)(a1 + 72) = 0;
      v19 = sub_10000EF14("SecError");
      v20 = objc_claimAutoreleasedReturnValue(v19);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        v21 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 16);
        v22 = *(_QWORD **)(a1 + 64);
        if (v22)
          v22 = (_QWORD *)*v22;
        *(_DWORD *)buf = 138412546;
        v36 = v21;
        v37 = 2112;
        v38 = v22;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%@ SOSDataSourceMergeObject failed %@ rolling back changes", buf, 0x16u);
      }

    }
    if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24))
    {
      if (*(_BYTE *)(a1 + 112))
      {
        v25 = (*(uint64_t (**)(const void *, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 16) + 120))(a2, 0);
        if (v25)
        {
          v26 = (const __CFDate *)v25;
          Current = CFAbsoluteTimeGetCurrent();
          AbsoluteTime = CFDateGetAbsoluteTime(v26);
          v29 = (uint64_t)(Current - AbsoluteTime);
          if (AbsoluteTime <= Current)
            v29 = 0;
          if (v11 == 1)
            v30 = CFSTR("com.apple.security.secureobjectsync.itemtime.known");
          else
            v30 = CFSTR("com.apple.security.secureobjectsync.itemtime.new");
          v31 = 1;
          if (v29 >= 101)
          {
            v32 = v29;
            do
            {
              v29 = v32 / 0xA;
              v31 *= 10;
              v33 = v32 > 0x3F1;
              v32 /= 0xAuLL;
            }
            while (v33);
          }
          SecCoreAnalyticsSendValue(v30, v31 * v29);
          CFRelease(v26);
        }
      }
    }
    if (cf1)
      CFRelease(cf1);
    CFRelease(v7);
  }
  else
  {
    *a3 = 1;
    **(_BYTE **)(a1 + 72) = 0;
    v15 = sub_10000EF14("SecError");
    v16 = objc_claimAutoreleasedReturnValue(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      v17 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 16);
      v18 = *(_QWORD **)(a1 + 64);
      if (v18)
        v18 = (_QWORD *)*v18;
      *(_DWORD *)buf = 138412546;
      v36 = v17;
      v37 = 2112;
      v38 = v18;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%@ peer sent bad object: %@, rolling back changes", buf, 0x16u);
    }

  }
}

void sub_100101CDC(uint64_t a1, void *a2)
{
  id v3;
  _QWORD block[4];
  id v5;
  uint64_t v6;

  v3 = a2;
  if (-[OTSOSActualAdapter sosEnabled]_0())
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100101D64;
    block[3] = &unk_1002DDEE0;
    v6 = a1;
    v5 = v3;
    dispatch_sync(*(dispatch_queue_t *)(a1 + 112), block);

  }
}

void sub_100101D64(uint64_t a1)
{
  id v2;
  uint64_t v3;
  void *v4;

  v2 = objc_msgSend(*(id *)(a1 + 32), "copy");
  v3 = *(_QWORD *)(a1 + 40);
  v4 = *(void **)(v3 + 136);
  *(_QWORD *)(v3 + 136) = v2;

}

void sub_100101D94(uint64_t a1, void *a2)
{
  id v3;
  _QWORD block[4];
  id v5;
  uint64_t v6;

  v3 = a2;
  if (-[OTSOSActualAdapter sosEnabled]_0())
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100101E1C;
    block[3] = &unk_1002DDF30;
    v6 = a1;
    v5 = v3;
    dispatch_sync(*(dispatch_queue_t *)(a1 + 112), block);

  }
}

void sub_100101E1C(uint64_t a1)
{
  objc_storeStrong((id *)(*(_QWORD *)(a1 + 40) + 128), *(id *)(a1 + 32));
}

void sub_100101E28(_QWORD *a1)
{
  const void *v2;
  const void *v3;

  (*(void (**)(void))(a1[4] + 16))();
  v2 = (const void *)a1[5];
  if (v2)
    CFRelease(v2);
  v3 = (const void *)a1[6];
  if (v3)
    CFRelease(v3);
}

void sub_100101E74(uint64_t a1, CFDataRef theData, const void *a3, _BYTE *a4)
{
  const __CFString *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const __CFString *v12;
  __CFData *v13;
  const __CFData *v14;
  const __CFData *v15;
  const UInt8 *v16;
  const UInt8 *v17;
  const void *v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  __CFArray *v30;
  CFArrayRef v31;
  CFIndex Length;
  _QWORD *v33;
  const UInt8 *v34;
  CFIndex v35;
  const UInt8 *v36;
  uint64_t v37;
  uint64_t v38;
  const __CFString *v39;
  const UInt8 *BytePtr;
  const void *v41;
  NSObject *v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  int v46;
  int v47;
  int v48;
  uint64_t v49;
  __CFArray *v50;
  CFArrayRef v51;
  int OSStatus;
  const UInt8 *v53;
  const void *v54;
  NSObject *v55;
  _BOOL4 v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  int v60;
  int v61;
  int v62;
  __CFArray *v63;
  CFArrayRef v64;
  CFTypeRef v65;
  uint64_t v66;
  uint64_t v67;
  int v68;
  int v69;
  int v70;
  int v71;
  CFTypeRef *v72;
  const UInt8 *v73;
  CFIndex v74;
  __CFString *Mutable;
  const UInt8 *v76;
  CFIndex v77;
  CFIndex v78;
  unsigned int v79;
  const void *v80;
  NSObject *v81;
  uint64_t v82;
  uint64_t v83;
  int v84;
  int v85;
  int v86;
  int v87;
  uint64_t v88;
  const void *v89;
  __CFArray *v90;
  CFArrayRef v91;
  uint64_t v92;
  const void *v93;
  _QWORD *v94;
  __CFArray *v95;
  const __CFAllocator *v96;
  uint64_t v97;
  __int128 *v98;
  uint64_t v99;
  const __CFArray *v100;
  CFIndex Count;
  const void *Value;
  __CFArray *v103;
  const void *v104;
  CFIndex v105;
  CFTypeRef cf;
  uint64_t v107;
  _BYTE buf[12];
  __int16 v109;
  uint64_t v110;
  __int16 v111;
  int v112;
  __int16 v113;
  int v114;
  __int16 v115;
  int v116;
  __int16 v117;
  int v118;
  __int16 v119;
  _BYTE v120[10];
  CFTypeRef v121;
  int v122;
  CFRange v123;

  cf = 0;
  if (!a3)
  {
    BytePtr = CFDataGetBytePtr(theData);
    v41 = sub_10000EF14("SecError");
    v42 = objc_claimAutoreleasedReturnValue(v41);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      v43 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 24);
      v44 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 16);
      v45 = *BytePtr;
      v46 = BytePtr[1];
      v47 = BytePtr[2];
      v48 = BytePtr[3];
      v49 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      *(_DWORD *)buf = 138413826;
      *(_QWORD *)&buf[4] = v43;
      v109 = 2112;
      v110 = v44;
      v111 = 1024;
      v112 = v45;
      v113 = 1024;
      v114 = v46;
      v115 = 1024;
      v116 = v47;
      v117 = 1024;
      v118 = v48;
      v119 = 2112;
      *(_QWORD *)v120 = v49;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "%@:%@ object %02X%02X%02X%02X dropping from manifest: not found in datasource: %@", buf, 0x38u);
    }

    v50 = *(__CFArray **)(a1 + 80);
    *(_QWORD *)buf = theData;
    v51 = CFArrayCreate(kCFAllocatorDefault, (const void **)buf, 1, &kCFTypeArrayCallBacks);
    CFArrayAppendValue(v50, v51);
    if (v51)
      CFRelease(v51);
    v13 = 0;
    goto LABEL_51;
  }
  v8 = (const __CFString *)(*(uint64_t (**)(const void *, CFTypeRef *))(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 16)
                                                                                + 136))(a3, &cf);
  if (!v8)
  {
    v13 = 0;
    goto LABEL_22;
  }
  v12 = v8;
  v13 = sub_10001A474(v8, &cf, v9, v10, v11);
  CFRelease(v12);
  if (!v13
    || (v14 = (const __CFData *)(*(uint64_t (**)(const void *, CFTypeRef *))(*(_QWORD *)(*(_QWORD *)(a1 + 64)
                                                                                                 + 16)
                                                                                     + 112))(a3, &cf)) == 0)
  {
LABEL_22:
    OSStatus = SecErrorGetOSStatus(cf);
    v53 = CFDataGetBytePtr(theData);
    v54 = sub_10000EF14("engine");
    v55 = objc_claimAutoreleasedReturnValue(v54);
    v56 = os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT);
    if (OSStatus == -26275)
    {
      if (v56)
      {
        v57 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 24);
        v58 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 16);
        v59 = *v53;
        v60 = v53[1];
        v61 = v53[2];
        v62 = v53[3];
        *(_DWORD *)buf = 138413826;
        *(_QWORD *)&buf[4] = v57;
        v109 = 2112;
        v110 = v58;
        v111 = 1024;
        v112 = v59;
        v113 = 1024;
        v114 = v60;
        v115 = 1024;
        v116 = v61;
        v117 = 1024;
        v118 = v62;
        v119 = 2112;
        *(_QWORD *)v120 = cf;
        _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "%@:%@ object %02X%02X%02X%02X dropping from manifest: %@", buf, 0x38u);
      }

      v63 = *(__CFArray **)(a1 + 80);
      *(_QWORD *)buf = theData;
      v64 = CFArrayCreate(kCFAllocatorDefault, (const void **)buf, 1, &kCFTypeArrayCallBacks);
      CFArrayAppendValue(v63, v64);
      if (v64)
        CFRelease(v64);
      v65 = cf;
    }
    else
    {
      if (v56)
      {
        v66 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 24);
        v67 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 16);
        v68 = *v53;
        v69 = v53[1];
        v70 = v53[2];
        v71 = v53[3];
        *(_DWORD *)buf = 138413826;
        *(_QWORD *)&buf[4] = v66;
        v109 = 2112;
        v110 = v67;
        v111 = 1024;
        v112 = v68;
        v113 = 1024;
        v114 = v69;
        v115 = 1024;
        v116 = v70;
        v117 = 1024;
        v118 = v71;
        v119 = 2112;
        *(_QWORD *)v120 = cf;
        _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "%@:%@ object %02X%02X%02X%02X in SOSDataSourceForEachObject: %@", buf, 0x38u);
      }

      *a4 = 1;
      if (cf)
      {
        v72 = *(CFTypeRef **)(a1 + 88);
        if (v72 && !*v72)
          *v72 = cf;
        else
          CFRelease(cf);
      }
      v92 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
      v65 = *(CFTypeRef *)(v92 + 24);
      if (!v65)
        goto LABEL_51;
      *(_QWORD *)(v92 + 24) = 0;
    }
    CFRelease(v65);
LABEL_51:
    v15 = 0;
    goto LABEL_52;
  }
  v15 = v14;
  if (!CFEqual(theData, v14))
  {
    v16 = CFDataGetBytePtr(theData);
    v17 = CFDataGetBytePtr(v15);
    v18 = sub_10000EF14("engine");
    v19 = objc_claimAutoreleasedReturnValue(v18);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      v20 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 24);
      v21 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 16);
      v22 = *v16;
      v23 = v16[1];
      v24 = v16[2];
      v25 = v16[3];
      v26 = *v17;
      v27 = v17[1];
      v28 = v17[2];
      v29 = v17[3];
      *(_DWORD *)buf = 138414594;
      *(_QWORD *)&buf[4] = v20;
      v109 = 2112;
      v110 = v21;
      v111 = 1024;
      v112 = v22;
      v113 = 1024;
      v114 = v23;
      v115 = 1024;
      v116 = v24;
      v117 = 1024;
      v118 = v25;
      v119 = 1024;
      *(_DWORD *)v120 = v26;
      *(_WORD *)&v120[4] = 1024;
      *(_DWORD *)&v120[6] = v27;
      LOWORD(v121) = 1024;
      *(_DWORD *)((char *)&v121 + 2) = v28;
      HIWORD(v121) = 1024;
      v122 = v29;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%@:%@ object %02X%02X%02X%02X is really %02X%02X%02X%02X dropping from local manifest", buf, 0x46u);
    }

    v30 = *(__CFArray **)(a1 + 80);
    *(_QWORD *)buf = theData;
    v31 = CFArrayCreate(kCFAllocatorDefault, (const void **)buf, 1, &kCFTypeArrayCallBacks);
    CFArrayAppendValue(v30, v31);
    if (v31)
      CFRelease(v31);
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 80), a3);
  }
  Length = CFDataGetLength(v13);
  v33 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  v34 = CFDataGetBytePtr(v13);
  v35 = CFDataGetLength(v13);
  v36 = &v34[v35];
  v107 = 0;
  *(_QWORD *)buf = 0;
  v37 = ccder_decode_tag(buf, v34, &v34[v35]);
  if (!v37)
  {
    if (SOSErrorCreate(1035, &cf, 0, CFSTR("Invalid DER, no tag found")))
      goto LABEL_64;
LABEL_35:
    v105 = Length;
    v73 = CFDataGetBytePtr(v15);
    v74 = CFDataGetLength(v13);
    Mutable = CFStringCreateMutable(kCFAllocatorDefault, 2 * v74);
    v76 = CFDataGetBytePtr(v13);
    v77 = CFDataGetLength(v13);
    if (v77 >= 1)
    {
      v78 = v77;
      do
      {
        v79 = *v76++;
        CFStringAppendFormat(Mutable, 0, CFSTR("%02X"), v79);
        --v78;
      }
      while (v78);
    }
    v80 = sub_10000EF14("engine");
    v81 = objc_claimAutoreleasedReturnValue(v80);
    if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
    {
      v82 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 24);
      v83 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 16);
      v84 = *v73;
      v85 = v73[1];
      v86 = v73[2];
      v87 = v73[3];
      *(_DWORD *)buf = 138414082;
      *(_QWORD *)&buf[4] = v82;
      v109 = 2112;
      v110 = v83;
      v111 = 1024;
      v112 = v84;
      v113 = 1024;
      v114 = v85;
      v115 = 1024;
      v116 = v86;
      v117 = 1024;
      v118 = v87;
      v119 = 2112;
      *(_QWORD *)v120 = Mutable;
      *(_WORD *)&v120[8] = 2112;
      v121 = cf;
      _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_DEFAULT, "%@:%@ object %02X%02X%02X%02X der: %@ dropping from manifest: %@", buf, 0x42u);
    }

    Length = v105;
    if (Mutable)
      CFRelease(Mutable);
    v88 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v89 = *(const void **)(v88 + 24);
    if (v89)
    {
      *(_QWORD *)(v88 + 24) = 0;
      CFRelease(v89);
    }
    v90 = *(__CFArray **)(a1 + 80);
    *(_QWORD *)buf = v15;
    v91 = CFArrayCreate(kCFAllocatorDefault, (const void **)buf, 1, &kCFTypeArrayCallBacks);
    CFArrayAppendValue(v90, v91);
    if (!v91)
      goto LABEL_73;
    goto LABEL_72;
  }
  if (*(_QWORD *)buf)
  {
    v38 = ccder_decode_len(&v107, v37, v36);
    if (v38)
    {
      if (v36 == (const UInt8 *)(v38 + v107))
        goto LABEL_64;
      v39 = CFSTR("Object has %td trailing unused bytes");
    }
    else
    {
      v39 = CFSTR("Object with tag %lu has no valid DER length");
    }
  }
  else
  {
    v39 = CFSTR("Object has EOL tag");
  }
  if ((SOSErrorCreate(1035, &cf, 0, v39) & 1) == 0)
    goto LABEL_35;
LABEL_64:
  v95 = (__CFArray *)v33[10];
  if (v95
    || (v96 = CFGetAllocator(v33), v95 = CFArrayCreateMutable(v96, 0, &kCFTypeArrayCallBacks), (v33[10] = v95) != 0))
  {
    CFArrayAppendValue(v95, v13);
  }
  v97 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
  v98 = (__int128 *)CFDataGetBytePtr(v15);
  sub_1001E7584((char **)(v97 + 32), v98);
  *(_BYTE *)(v97 + 56) = 1;
  if (!**(_QWORD **)(a1 + 96))
    **(_QWORD **)(a1 + 96) = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v99 = (*(uint64_t (**)(const void *, CFTypeRef *))(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 16) + 136))(a3, &cf);
  if (!v99)
    goto LABEL_73;
  v91 = (CFArrayRef)v99;
  v100 = **(const __CFArray ***)(a1 + 96);
  Count = CFArrayGetCount(v100);
  Value = CFDictionaryGetValue(v91, kSecAttrAccessGroup);
  v123.location = 0;
  v123.length = Count;
  if (!CFArrayContainsValue(v100, v123, Value))
  {
    v103 = **(__CFArray ***)(a1 + 96);
    v104 = CFDictionaryGetValue(v91, kSecAttrAccessGroup);
    CFArrayAppendValue(v103, v104);
  }
LABEL_72:
  CFRelease(v91);
LABEL_73:
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) += Length;
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) >= 0xFA01uLL)
    *a4 = 1;
LABEL_52:
  v93 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v93)
  {
    v94 = *(_QWORD **)(a1 + 88);
    if (v94 && !*v94)
      *v94 = v93;
    else
      CFRelease(v93);
  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  if (v13)
    CFRelease(v13);
  if (v15)
    CFRelease(v15);
}

void sub_100102790(uint64_t a1, char a2)
{
  NSObject *v4;
  _QWORD v5[4];
  id v6;
  char v7;

  v4 = *((_QWORD *)objc_msgSend(*(id *)(a1 + 32), "engine") + 14);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_10010281C;
  v5[3] = &unk_1002E9358;
  v7 = a2;
  v6 = *(id *)(a1 + 32);
  dispatch_async(v4, v5);

}

void sub_10010281C(uint64_t a1)
{
  const void *v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  id v6;
  const void *v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  id v11;
  const char *v12;
  const void *v13;
  uint64_t v14;
  uint64_t v15;
  id v16;
  int v17;
  uint64_t v18;
  __int16 v19;
  uint64_t v20;
  __int16 v21;
  id v22;

  if (*(_BYTE *)(a1 + 40))
  {
    *((_BYTE *)objc_msgSend(*(id *)(a1 + 32), "peer") + 48) = 0;
    if (!objc_msgSend(*(id *)(a1 + 32), "confirmed") && !objc_msgSend(*(id *)(a1 + 32), "proposed"))
    {
      *((_BYTE *)objc_msgSend(*(id *)(a1 + 32), "peer") + 49) = 1;
      v2 = sub_10000EF14("engine");
      v3 = objc_claimAutoreleasedReturnValue(v2);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        v4 = *((_QWORD *)objc_msgSend(*(id *)(a1 + 32), "engine") + 3);
        v5 = *((_QWORD *)objc_msgSend(*(id *)(a1 + 32), "peer") + 2);
        v6 = objc_msgSend(*(id *)(a1 + 32), "local");
        v17 = 138412802;
        v18 = v4;
        v19 = 2112;
        v20 = v5;
        v21 = 2112;
        v22 = v6;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%@:%@ sendObjects=true L:%@", (uint8_t *)&v17, 0x20u);
      }

    }
    sub_1001ED53C((CFArrayRef *)objc_msgSend(*(id *)(a1 + 32), "peer") + 11, objc_msgSend(*(id *)(a1 + 32), "local"));
    sub_1001ED53C((CFArrayRef *)objc_msgSend(*(id *)(a1 + 32), "peer") + 10, objc_msgSend(*(id *)(a1 + 32), "proposed"));
    v7 = sub_10000EF14("engine");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = *((_QWORD *)objc_msgSend(*(id *)(a1 + 32), "engine") + 3);
      v10 = *((_QWORD *)objc_msgSend(*(id *)(a1 + 32), "peer") + 2);
      v11 = objc_msgSend(*(id *)(a1 + 32), "message");
      v17 = 138412802;
      v18 = v9;
      v19 = 2112;
      v20 = v10;
      v21 = 2112;
      v22 = v11;
      v12 = "send %@:%@ %@";
LABEL_11:
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v17, 0x20u);
    }
  }
  else
  {
    v13 = sub_10000EF14("SecError");
    v8 = objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v14 = *((_QWORD *)objc_msgSend(*(id *)(a1 + 32), "engine") + 3);
      v15 = *((_QWORD *)objc_msgSend(*(id *)(a1 + 32), "peer") + 2);
      v16 = objc_msgSend(*(id *)(a1 + 32), "message");
      v17 = 138412802;
      v18 = v14;
      v19 = 2112;
      v20 = v15;
      v21 = 2112;
      v22 = v16;
      v12 = "%@:%@ failed to send %@";
      goto LABEL_11;
    }
  }

}

CFMutableSetRef sub_100102A80(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  CFMutableSetRef Mutable;
  _QWORD v10[8];
  char v11;
  _QWORD v12[3];
  char v13;

  if (-[OTSOSActualAdapter sosEnabled]_0())
  {
    v12[0] = 0;
    v12[1] = v12;
    v12[2] = 0x2020000000;
    v13 = 0;
    Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_100102B9C;
    v10[3] = &unk_1002DDFD0;
    v11 = a3;
    v10[4] = v12;
    v10[5] = a2;
    v10[6] = a1;
    v10[7] = Mutable;
    if ((sub_1000FC6A8(a1, a4, v10) & 1) == 0 && Mutable)
    {
      CFRelease(Mutable);
      Mutable = 0;
    }
    _Block_object_dispose(v12, 8);
  }
  else
  {
    SOSCCSetSOSDisabledError(a4);
    return 0;
  }
  return Mutable;
}

void sub_100102B7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100102B9C(uint64_t a1, uint64_t a2)
{
  const __CFSet *v4;
  uint64_t v5;
  const void *v6;
  NSObject *v7;
  CFTypeRef v8;
  _QWORD context[6];
  __int128 v10;
  char v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  char v15;
  uint8_t buf[4];
  CFTypeRef v17;

  v12 = 0;
  v13 = &v12;
  v14 = 0x2020000000;
  v15 = 0;
  context[0] = _NSConcreteStackBlock;
  context[1] = 3221225472;
  context[2] = sub_100102D10;
  context[3] = &unk_1002DDFA8;
  v11 = *(_BYTE *)(a1 + 64);
  v4 = *(const __CFSet **)(a1 + 40);
  v5 = *(_QWORD *)(a1 + 32);
  context[4] = &v12;
  context[5] = v5;
  v10 = *(_OWORD *)(a1 + 48);
  CFSetApplyFunction(v4, (CFSetApplierFunction)sub_1000FEA00, context);
  if (*((_BYTE *)v13 + 24))
  {
    v8 = 0;
    if ((sub_1000FCFD4(*(_QWORD *)(a1 + 48), a2, &v8) & 1) == 0)
    {
      v6 = sub_10000EF14("engine-save");
      v7 = objc_claimAutoreleasedReturnValue(v6);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v17 = v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Failed to save engine: %@", buf, 0xCu);
      }

    }
  }
  _Block_object_dispose(&v12, 8);
}

void sub_100102CEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  _Unwind_Resume(exception_object);
}

void sub_100102D10(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v2;
  CFTypeID v4;
  const __CFDictionary *v5;
  _BOOL4 v6;
  const void *v7;
  NSObject *v8;
  CFTypeRef v9;
  CFTypeRef cfa;
  uint8_t buf[4];
  CFTypeRef v12;
  __int16 v13;
  CFTypeRef v14;

  v2 = cf;
  cfa = 0;
  if (!cf)
  {
    sub_100019F20(-50, (__CFString **)&cfa, CFSTR("object %@ is not a string"), 0);
LABEL_9:
    v5 = 0;
    v6 = 0;
    goto LABEL_10;
  }
  v4 = CFGetTypeID(cf);
  if (v4 != CFStringGetTypeID())
  {
    sub_100019F20(-50, (__CFString **)&cfa, CFSTR("object %@ is not a string"), v2);
    v2 = 0;
    goto LABEL_9;
  }
  v5 = (const __CFDictionary *)sub_1000FC7D8(*(_QWORD *)(a1 + 48), v2, (__CFArray *)&cfa);
  if (sub_1001ECB5C(v5))
  {
    if (*(_BYTE *)(a1 + 64))
      *((_BYTE *)v5 + 48) = 1;
    v6 = sub_100102ED4(*(_QWORD *)(a1 + 48), (uint64_t)v5, 0, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24, &cfa);
  }
  else
  {
    v6 = 1;
  }
LABEL_10:
  if (cfa)
  {
    v7 = sub_10000EF14("engine-sync");
    v8 = objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412546;
      v12 = v2;
      v13 = 2112;
      v14 = cfa;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Failed to process sync for %@: %@", buf, 0x16u);
    }

  }
  if (v6)
    CFSetAddValue(*(CFMutableSetRef *)(a1 + 56), v2);
  v9 = cfa;
  if (cfa)
  {
    cfa = 0;
    CFRelease(v9);
  }
  if (v5)
    CFRelease(v5);
}

BOOL sub_100102ED4(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, CFTypeRef *a6)
{
  uint64_t *v12;
  char v13;
  uint64_t v14;
  char v15;
  char v16;
  const void *v17;
  NSObject *v18;
  uint64_t v19;
  const char *v20;
  const char *v21;
  const char *v22;
  const char *v23;
  unint64_t v24;
  _BOOL8 v25;
  unint64_t v26;
  BOOL v27;
  BOOL v28;
  const void *v29;
  NSObject *v30;
  const void *v31;
  NSObject *v32;
  const char *v33;
  const void *v34;
  CFTypeRef v35;
  CFTypeRef v36;
  int v37;
  int v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD v42[16];
  CFTypeRef v43;
  CFTypeRef cf;
  uint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  char v48;
  uint64_t v49;
  uint64_t *v50;
  uint64_t v51;
  const void *v52;
  uint64_t v53;
  uint64_t *v54;
  uint64_t v55;
  CFTypeRef v56;
  uint64_t v57;
  uint64_t *v58;
  uint64_t v59;
  char v60;
  uint8_t buf[4];
  const char *v62;
  __int16 v63;
  uint64_t v64;
  __int16 v65;
  const char *v66;
  __int16 v67;
  const char *v68;
  __int16 v69;
  const char *v70;
  __int16 v71;
  unint64_t v72;
  __int16 v73;
  unint64_t v74;

  v12 = &v57;
  v57 = 0;
  v58 = &v57;
  v59 = 0x2020000000;
  v60 = -86;
  if (*(_BYTE *)(a2 + 48))
  {
    v13 = sub_1001EBFEC(a2, a6);
    v12 = v58;
  }
  else
  {
    v13 = 1;
  }
  v60 = v13;
  if (!*((_BYTE *)v12 + 24))
  {
    v25 = 0;
    goto LABEL_50;
  }
  if (!*(_QWORD *)(a2 + 112))
  {
    v25 = 1;
    goto LABEL_50;
  }
  v53 = 0;
  v54 = &v53;
  v55 = 0x2020000000;
  v56 = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
  v56 = sub_1000FFD34(a1, a2, (uint64_t)a6);
  v49 = 0;
  v50 = &v49;
  v51 = 0x2020000000;
  v52 = (const void *)0xAAAAAAAAAAAAAAAALL;
  v52 = sub_1001ED4B0(a2);
  v45 = 0;
  v46 = &v45;
  v47 = 0x2020000000;
  v48 = 1;
  v43 = 0;
  cf = 0;
  v14 = *(_QWORD *)(a2 + 16);
  v15 = sub_1001E8590(v50[3], v54[3], (uint64_t *)&v43, &cf, a6);
  if (*((_BYTE *)v58 + 24))
    v16 = v15;
  else
    v16 = 0;
  *((_BYTE *)v58 + 24) = v16;
  v17 = sub_10000EF14("engine");
  v18 = objc_claimAutoreleasedReturnValue(v17);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    v39 = a3;
    v19 = v14;
    v40 = a4;
    v41 = a5;
    v20 = *(const char **)(a1 + 24);
    if (v54[3])
      v21 = "L";
    else
      v21 = "l";
    if (v50[3])
      v22 = "P";
    else
      v22 = "0";
    if (cf)
      v23 = "O";
    else
      v23 = "0";
    if (cf)
      v24 = CFDataGetLength(*((CFDataRef *)cf + 3)) / 0x14uLL;
    else
      v24 = 0;
    v26 = (unint64_t)v43;
    if (v43)
      v26 = CFDataGetLength(*((CFDataRef *)v43 + 3)) / 0x14uLL;
    *(_DWORD *)buf = 138413826;
    v62 = v20;
    v63 = 2112;
    v64 = v19;
    v65 = 2080;
    v66 = v21;
    v67 = 2080;
    v68 = v22;
    v14 = v19;
    v69 = 2080;
    v70 = v23;
    v71 = 2048;
    v72 = v24;
    v73 = 2048;
    v74 = v26;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%@:%@: Send state for peer [%s%s%s] O: %zu, M: %zu", buf, 0x48u);
    a4 = v40;
    a5 = v41;
    a3 = v39;
  }

  if ((!v43 || (unint64_t)CFDataGetLength(*((CFDataRef *)v43 + 3)) <= 0x13)
    && (!cf || (unint64_t)CFDataGetLength(*((CFDataRef *)cf + 3)) <= 0x13))
  {
    if (!a3)
    {
      v31 = sub_10000EF14("engine");
      v32 = objc_claimAutoreleasedReturnValue(v31);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        v33 = *(const char **)(a1 + 24);
        *(_DWORD *)buf = 138412546;
        v62 = v33;
        v63 = 2112;
        v64 = a2;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "%@:%@ backup still done", buf, 0x16u);
      }

      goto LABEL_43;
    }
    *((_BYTE *)v46 + 24) = 0;
  }
  v42[0] = _NSConcreteStackBlock;
  v42[1] = 3221225472;
  v42[2] = sub_100103418;
  v42[3] = &unk_1002DE350;
  v42[8] = v43;
  v42[9] = a1;
  v42[10] = v14;
  v42[11] = a6;
  v42[4] = &v57;
  v42[5] = &v53;
  v42[12] = cf;
  v42[13] = a2;
  v42[6] = &v49;
  v42[7] = &v45;
  v42[14] = a4;
  v42[15] = a5;
  v27 = sub_1001ECDD8(a2, a6, v42);
  if (*((_BYTE *)v58 + 24))
    v28 = v27;
  else
    v28 = 0;
  *((_BYTE *)v58 + 24) = v28;
  if (*((_BYTE *)v46 + 24))
  {
    v29 = sub_10000EF14("backup");
    v30 = objc_claimAutoreleasedReturnValue(v29);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      v62 = "writing changes to backup";
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "posting notification to CloudServices: %s", buf, 0xCu);
    }

    notify_post("com.apple.security.itembackup");
  }
LABEL_43:
  v34 = (const void *)v54[3];
  if (v34)
    CFRelease(v34);
  v35 = cf;
  if (cf)
  {
    cf = 0;
    CFRelease(v35);
  }
  v36 = v43;
  if (v43)
  {
    v43 = 0;
    CFRelease(v36);
  }
  v37 = *((unsigned __int8 *)v58 + 24);
  _Block_object_dispose(&v45, 8);
  _Block_object_dispose(&v49, 8);
  _Block_object_dispose(&v53, 8);
  v25 = v37 != 0;
LABEL_50:
  _Block_object_dispose(&v57, 8);
  return v25;
}

void sub_1001033B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  uint64_t v39;

  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a35, 8);
  _Block_object_dispose(&a39, 8);
  _Block_object_dispose((const void *)(v39 - 224), 8);
  _Unwind_Resume(a1);
}

void sub_100103418(uint64_t a1, FILE *a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const __CFArray *Mutable;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  char v15;
  const void *v16;
  NSObject *v17;
  uint64_t v18;
  CFTypeRef v19;
  const void *v20;
  const void *v21;
  const void *v22;
  const void *v23;
  uint64_t *v24;
  uint64_t *v25;
  const void *v26;
  const void *v27;
  const void *v28;
  NSObject *v29;
  const void *v30;
  const __CFArray *v31;
  const char *v32;
  const void *v33;
  NSObject *v34;
  const void *v35;
  const __CFArray *v36;
  uint64_t v37;
  unint64_t v38;
  const void *v39;
  NSObject *v40;
  const void *v41;
  const __CFArray *v42;
  CFTypeRef *v43;
  unint64_t v44;
  const char *v45;
  CFTypeRef cf[8];
  __int128 v47;
  const __CFArray *v48;
  uint64_t v49;
  int v50;
  _QWORD v51[7];
  __int128 v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t *v55;
  uint64_t v56;
  const char *v57;
  __int128 v58;
  __int128 v59;
  uint64_t v60;
  uint64_t *v61;
  uint64_t v62;
  const char *v63;
  __int128 v64;
  __int128 v65;
  uint8_t buf[4];
  const __CFArray *v67;
  __int16 v68;
  CFTypeRef v69;
  __int16 v70;
  CFTypeRef v71;
  __int16 v72;
  unint64_t v73;
  __int16 v74;
  const char *v75;

  v60 = 0;
  v61 = &v60;
  v62 = 0x4010000000;
  v63 = "";
  v64 = 0u;
  v65 = 0u;
  v54 = 0;
  v55 = &v54;
  v56 = 0x4010000000;
  v57 = "";
  v58 = 0u;
  v59 = 0u;
  v6 = *(_QWORD *)(a1 + 64);
  v51[0] = _NSConcreteStackBlock;
  v51[1] = 3221225472;
  v51[2] = sub_100103B0C;
  v51[3] = &unk_1002DE300;
  v52 = *(_OWORD *)(a1 + 72);
  v53 = *(_QWORD *)(a1 + 88);
  v7 = *(_QWORD *)(a1 + 32);
  v51[4] = &v60;
  v51[5] = v7;
  v51[6] = a2;
  sub_1001E8388(v6, (uint64_t)v51);
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    v8 = *(_QWORD *)(a1 + 96);
    if (v8)
    {
      if ((unint64_t)CFDataGetLength(*(CFDataRef *)(v8 + 24)) >= 0x14)
      {
        Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        v10 = *(_QWORD *)(a1 + 88);
        cf[1] = _NSConcreteStackBlock;
        cf[2] = (CFTypeRef)3221225472;
        v11 = *(_OWORD *)(a1 + 72);
        v12 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 16);
        cf[3] = sub_100103BF8;
        cf[4] = &unk_1002DE328;
        v47 = v11;
        v50 = a3;
        v48 = Mutable;
        v49 = v10;
        cf[5] = *(CFTypeRef *)(a1 + 32);
        cf[6] = &v54;
        cf[7] = a2;
        v13 = (*(uint64_t (**)(void))(v12 + 32))();
        v14 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
        if (*(_BYTE *)(v14 + 24))
          v15 = v13;
        else
          v15 = 0;
        *(_BYTE *)(v14 + 24) = v15;
        if (CFArrayGetCount(Mutable))
        {
          cf[0] = 0;
          if ((sub_10010000C(*(_QWORD *)(a1 + 72), 0, 2, 0, Mutable, cf) & 1) == 0)
          {
            v16 = sub_10000EF14("SecError");
            v17 = objc_claimAutoreleasedReturnValue(v16);
            if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 138412546;
              v67 = Mutable;
              v68 = 2112;
              v69 = cf[0];
              _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "SOSEngineUpdateChanges_locked: %@ failed: %@", buf, 0x16u);
            }

          }
          if (cf[0])
            CFRelease(cf[0]);
          v18 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
          v19 = sub_1000FFD34(*(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 88));
          v20 = *(const void **)(v18 + 24);
          if (v20)
            CFRelease(v20);
          *(_QWORD *)(v18 + 24) = v19;
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = sub_1001ED4B0(*(_QWORD *)(a1 + 104));
        }
        if (Mutable)
          CFRelease(Mutable);
      }
    }
  }
  if (v55[5] || (v24 = v61, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24)) && v61[5])
  {
    **(_BYTE **)(a1 + 112) = 1;
    v21 = (const void *)sub_1001E88E8((uint64_t)(v61 + 4), *(CFTypeRef **)(a1 + 88));
    v22 = (const void *)sub_1001E88E8((uint64_t)(v55 + 4), *(CFTypeRef **)(a1 + 88));
    v23 = (const void *)sub_1001E8930(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24), (uint64_t)v21, (uint64_t)v22, *(CFTypeRef **)(a1 + 88));
    if (v21)
      CFRelease(v21);
    if (v22)
      CFRelease(v22);
    sub_1001ED434((__CFArray **)(*(_QWORD *)(a1 + 104) + 80), v23);
    if (v23)
      CFRelease(v23);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = sub_1001ED4B0(*(_QWORD *)(a1 + 104));
    v24 = v61;
  }
  free((void *)v24[4]);
  v24[4] = 0;
  v24[5] = 0;
  *((_BYTE *)v24 + 56) = 0;
  v24[6] = 0;
  v25 = v55;
  free((void *)v55[4]);
  v25[4] = 0;
  v25[5] = 0;
  *((_BYTE *)v25 + 56) = 0;
  v25[6] = 0;
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    v26 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
    v27 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
    if (v26 && v27)
    {
      if (CFEqual(v26, v27))
        goto LABEL_31;
    }
    else if (v26 == v27)
    {
LABEL_31:
      cf[0] = 0;
      if (sub_1001E2E94(a2, 899, (__CFString **)cf))
      {
        *(_BYTE *)(*(_QWORD *)(a1 + 104) + 49) = 1;
        **(_BYTE **)(a1 + 112) = 1;
        v28 = sub_10000EF14("backup");
        v29 = objc_claimAutoreleasedReturnValue(v28);
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
        {
          v30 = *(const void **)(a1 + 80);
          v31 = *(const __CFArray **)(*(_QWORD *)(a1 + 72) + 24);
          if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24))
            v32 = " notifying sbd";
          else
            v32 = "";
          *(_DWORD *)buf = 138412802;
          v67 = v31;
          v68 = 2112;
          v69 = v30;
          v70 = 2080;
          v71 = v32;
          _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "%@:%@ backup done%s", buf, 0x20u);
        }

      }
      else
      {
        v39 = sub_10000EF14("SecWarning");
        v40 = objc_claimAutoreleasedReturnValue(v39);
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
        {
          v41 = *(const void **)(a1 + 80);
          v42 = *(const __CFArray **)(*(_QWORD *)(a1 + 72) + 24);
          *(_DWORD *)buf = 138412802;
          v67 = v42;
          v68 = 2112;
          v69 = v41;
          v70 = 2112;
          v71 = cf[0];
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "%@:%@ in SOSBackupPeerWriteCompleteMarker: %@", buf, 0x20u);
        }

        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
        **(_BYTE **)(a1 + 120) = 1;
        if (cf[0])
        {
          v43 = *(CFTypeRef **)(a1 + 88);
          if (v43 && !*v43)
            *v43 = cf[0];
          else
            CFRelease(cf[0]);
        }
      }
      goto LABEL_59;
    }
  }
  v33 = sub_10000EF14("backup");
  v34 = objc_claimAutoreleasedReturnValue(v33);
  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
  {
    v35 = *(const void **)(a1 + 80);
    v36 = *(const __CFArray **)(*(_QWORD *)(a1 + 72) + 24);
    v37 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
    if (v37)
      v38 = CFDataGetLength(*(CFDataRef *)(v37 + 24)) / 0x14uLL;
    else
      v38 = 0;
    v44 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
    if (v44)
      v44 = CFDataGetLength(*(CFDataRef *)(v44 + 24)) / 0x14uLL;
    if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24))
      v45 = " notifying sbd";
    else
      v45 = "";
    *(_DWORD *)buf = 138413314;
    v67 = v36;
    v68 = 2112;
    v69 = v35;
    v70 = 2048;
    v71 = (CFTypeRef)v38;
    v72 = 2048;
    v73 = v44;
    v74 = 2080;
    v75 = v45;
    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "%@:%@ backup incomplete [%zu/%zu]%s", buf, 0x34u);
  }

  **(_BYTE **)(a1 + 120) = 1;
LABEL_59:
  _Block_object_dispose(&v54, 8);
  _Block_object_dispose(&v60, 8);
}

void sub_100103AB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  uint64_t v33;

  _Block_object_dispose(&a33, 8);
  _Block_object_dispose((const void *)(v33 - 208), 8);
  _Unwind_Resume(a1);
}

void sub_100103B0C(uint64_t a1, const __CFData *a2, _BYTE *a3)
{
  uint64_t v6;
  __int128 *BytePtr;
  CFTypeRef *v8;
  CFTypeRef cf;

  cf = 0;
  if (ftello(*(FILE **)(a1 + 48)) < 64001)
  {
    if (sub_1001E2D24(*(FILE **)(a1 + 48), a2, (__CFString **)&cf))
    {
      v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      BytePtr = (__int128 *)CFDataGetBytePtr(a2);
      sub_1001E7584((char **)(v6 + 32), BytePtr);
      *(_BYTE *)(v6 + 56) = 1;
    }
    else
    {
      sub_100103F34(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), a2, 0, (uint64_t)"in SOSPeerWriteDelete", (const __CFString *)cf);
      if (cf)
      {
        v8 = *(CFTypeRef **)(a1 + 72);
        if (v8 && !*v8)
          *v8 = cf;
        else
          CFRelease(cf);
      }
      *a3 = 1;
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
    }
  }
  else
  {
    *a3 = 1;
  }
}

void sub_100103BF8(uint64_t a1, const __CFData *a2, const void *a3, _BYTE *a4)
{
  uint64_t v8;
  CFArrayRef v9;
  const __CFData *v10;
  const __CFData *v11;
  __CFArray *v12;
  CFArrayRef v13;
  uint64_t v14;
  __int128 *BytePtr;
  int OSStatus;
  uint64_t v17;
  uint64_t v18;
  __CFArray *v19;
  CFArrayRef v20;
  __CFArray *v21;
  CFTypeRef *v22;
  CFTypeRef *v23;
  const __CFData *v24;
  CFTypeRef cf;
  void *values;

  cf = 0;
  if (ftello(*(FILE **)(a1 + 48)) >= 64001)
  {
    *a4 = 1;
    return;
  }
  v8 = *(_QWORD *)(a1 + 56);
  if (!a3)
  {
    sub_100103F34(v8, *(_QWORD *)(a1 + 64), a2, 0, (uint64_t)"dropping from manifest: not found in datasource", 0);
    v21 = *(__CFArray **)(a1 + 72);
    values = a2;
    v9 = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
    CFArrayAppendValue(v21, v9);
    if (!v9)
      return;
    goto LABEL_29;
  }
  v9 = (CFArrayRef)(*(uint64_t (**)(const void *, _QWORD, CFTypeRef *))(*(_QWORD *)(v8 + 16) + 144))(a3, *(int *)(a1 + 88), &cf);
  if (v9)
  {
    v10 = (const __CFData *)(*(uint64_t (**)(const void *, CFTypeRef *))(*(_QWORD *)(*(_QWORD *)(a1 + 56)
                                                                                             + 16)
                                                                                 + 112))(a3, &cf);
    if (v10)
    {
      v11 = v10;
      if (!CFEqual(a2, v10))
      {
        sub_100103F34(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), a2, v11, (uint64_t)"", 0);
        v12 = *(__CFArray **)(a1 + 72);
        values = a2;
        v13 = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
        CFArrayAppendValue(v12, v13);
        if (v13)
          CFRelease(v13);
        CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 72), a3);
      }
      if (sub_1001E2DF8(*(FILE **)(a1 + 48), v9, (__CFString **)&cf))
      {
        v14 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
        BytePtr = (__int128 *)CFDataGetBytePtr(v11);
        sub_1001E7584((char **)(v14 + 32), BytePtr);
        *(_BYTE *)(v14 + 56) = 1;
      }
      else
      {
        sub_100103F34(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), a2, 0, (uint64_t)"in SOSPeerWriteAdd", (const __CFString *)cf);
        *a4 = 1;
        if (cf)
        {
          v23 = *(CFTypeRef **)(a1 + 80);
          if (v23 && !*v23)
            *v23 = cf;
          else
            CFRelease(cf);
        }
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
      }
      CFRelease(v9);
      v24 = v11;
      goto LABEL_33;
    }
  }
  OSStatus = SecErrorGetOSStatus(cf);
  v17 = *(_QWORD *)(a1 + 56);
  v18 = *(_QWORD *)(a1 + 64);
  if (OSStatus == -26275)
  {
    sub_100103F34(v17, v18, a2, 0, (uint64_t)"dropping from manifest", (const __CFString *)cf);
    v19 = *(__CFArray **)(a1 + 72);
    values = a2;
    v20 = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
    CFArrayAppendValue(v19, v20);
    if (v20)
      CFRelease(v20);
    CFRelease(cf);
    if (!v9)
      return;
LABEL_29:
    v24 = v9;
LABEL_33:
    CFRelease(v24);
    return;
  }
  sub_100103F34(v17, v18, a2, 0, (uint64_t)"in SOSDataSourceForEachObject", (const __CFString *)cf);
  *a4 = 1;
  if (cf)
  {
    v22 = *(CFTypeRef **)(a1 + 80);
    if (v22 && !*v22)
      *v22 = cf;
    else
      CFRelease(cf);
  }
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  if (v9)
    goto LABEL_29;
}

void sub_100103F34(uint64_t a1, uint64_t a2, CFDataRef theData, const __CFData *a4, uint64_t a5, const __CFString *a6)
{
  const UInt8 *BytePtr;
  const UInt8 *v12;
  const void *v13;
  NSObject *v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  const char *v24;
  NSObject *v25;
  uint32_t v26;
  const void *v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  const __CFString *v32;
  int v33;
  int v34;
  uint64_t v35;
  __int16 v36;
  uint64_t v37;
  __int16 v38;
  int v39;
  __int16 v40;
  int v41;
  __int16 v42;
  int v43;
  __int16 v44;
  int v45;
  __int16 v46;
  _BYTE v47[10];
  const __CFString *v48;
  int v49;

  BytePtr = CFDataGetBytePtr(theData);
  if (a4)
  {
    v12 = CFDataGetBytePtr(a4);
    v13 = sub_10000EF14("SecWarning");
    v14 = objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      v15 = *(_QWORD *)(a1 + 24);
      v16 = *BytePtr;
      v17 = BytePtr[1];
      v18 = BytePtr[2];
      v19 = BytePtr[3];
      v20 = *v12;
      v21 = v12[1];
      v22 = v12[2];
      v23 = v12[3];
      v34 = 138414594;
      v35 = v15;
      v36 = 2112;
      v37 = a2;
      v38 = 1024;
      v39 = v16;
      v40 = 1024;
      v41 = v17;
      v42 = 1024;
      v43 = v18;
      v44 = 1024;
      v45 = v19;
      v46 = 1024;
      *(_DWORD *)v47 = v20;
      *(_WORD *)&v47[4] = 1024;
      *(_DWORD *)&v47[6] = v21;
      LOWORD(v48) = 1024;
      *(_DWORD *)((char *)&v48 + 2) = v22;
      HIWORD(v48) = 1024;
      v49 = v23;
      v24 = "%@:%@ object %02X%02X%02X%02X is really %02X%02X%02X%02X dropping from local manifest";
      v25 = v14;
      v26 = 70;
LABEL_8:
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, v24, (uint8_t *)&v34, v26);
    }
  }
  else
  {
    v27 = sub_10000EF14("SecWarning");
    v14 = objc_claimAutoreleasedReturnValue(v27);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      v28 = *(_QWORD *)(a1 + 24);
      v29 = *BytePtr;
      v30 = BytePtr[1];
      v31 = BytePtr[2];
      v32 = &stru_1002EE888;
      v33 = BytePtr[3];
      if (a6)
        v32 = a6;
      v34 = 138414082;
      v35 = v28;
      v36 = 2112;
      v37 = a2;
      v38 = 1024;
      v39 = v29;
      v40 = 1024;
      v41 = v30;
      v42 = 1024;
      v43 = v31;
      v44 = 1024;
      v45 = v33;
      v46 = 2080;
      *(_QWORD *)v47 = a5;
      *(_WORD *)&v47[8] = 2112;
      v48 = v32;
      v24 = "%@:%@ object %02X%02X%02X%02X %s: %@";
      v25 = v14;
      v26 = 66;
      goto LABEL_8;
    }
  }

}

void sub_100104148(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD activity_block[5];

  sub_1000FE6C0(*(_QWORD *)(a1 + 40), *(CFTypeRef *)(a1 + 48), *(const __CFArray **)(a1 + 56), *(const __CFArray **)(a1 + 64));
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    v2 = *(_QWORD *)(a1 + 40);
    if (*(_QWORD *)(v2 + 24))
    {
      if (CFArrayGetCount(*(CFArrayRef *)(v2 + 80)))
      {
        v3 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 80);
        activity_block[0] = _NSConcreteStackBlock;
        activity_block[1] = 3221225472;
        activity_block[2] = sub_100202158;
        activity_block[3] = &unk_1002ED1A0;
        activity_block[4] = v3;
        _os_activity_initiate((void *)&_mh_execute_header, "CloudCircle RequestSyncWithPeersList", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
      }
    }
  }
}

uint64_t sub_100104208(_QWORD *a1, uint64_t a2, _BYTE *a3)
{
  uint64_t result;

  result = sub_1000FCFD4(a1[6], a2, (CFTypeRef *)(*(_QWORD *)(a1[5] + 8) + 24));
  *a3 = result;
  *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = result;
  return result;
}

CFTypeRef sub_10010424C(_QWORD *a1)
{
  uint64_t v2;
  const void *V0ViewSet;
  CFTypeRef result;

  v2 = a1[5];
  V0ViewSet = (const void *)SOSViewsGetV0ViewSet();
  result = sub_1000FFD90(v2, V0ViewSet, a1[6]);
  *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = result;
  return result;
}

void sub_10010428C(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;
  uint64_t v6;
  void (*v7)(uint64_t, uint64_t, _QWORD, _QWORD *);
  id v8;
  _QWORD v9[4];
  id v10;
  uint64_t v11;

  v5 = a3;
  v6 = *(_QWORD *)(a1 + 16);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  v9[2] = sub_100104320;
  v9[3] = &unk_1002DE378;
  v10 = v5;
  v11 = a1;
  v7 = *(void (**)(uint64_t, uint64_t, _QWORD, _QWORD *))(v6 + 80);
  v8 = v5;
  v7(v6, a2, 0, v9);

}

void sub_100104320(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD v4[4];
  id v5;
  uint64_t v6;

  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_10010438C;
  v4[3] = &unk_1002DDEE0;
  v3 = *(_QWORD *)(a1 + 40);
  v5 = *(id *)(a1 + 32);
  v6 = a2;
  dispatch_sync(*(dispatch_queue_t *)(v3 + 112), v4);

}

uint64_t sub_10010438C(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
}

uint64_t sub_10010439C(uint64_t a1)
{
  uint64_t result;

  result = sub_10010000C(*(_QWORD *)(a1 + 40), 0, 2, *(_QWORD *)(a1 + 48), *(const __CFArray **)(a1 + 56), *(CFTypeRef **)(a1 + 64));
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

BOOL sub_1001043DC(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7;
  _BOOL8 v8;
  _QWORD v10[4];
  id v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  char v19;

  v7 = a4;
  if (-[OTSOSActualAdapter sosEnabled]_0())
  {
    v16 = 0;
    v17 = &v16;
    v18 = 0x2020000000;
    v19 = 1;
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_1001044E4;
    v10[3] = &unk_1002DE070;
    v13 = a1;
    v14 = a2;
    v15 = a3;
    v11 = v7;
    v12 = &v16;
    sub_10010428C(a1, a3, v10);
    v8 = *((_BYTE *)v17 + 24) != 0;

    _Block_object_dispose(&v16, 8);
  }
  else
  {
    SOSCCSetSOSDisabledError(a3);
    v8 = 0;
  }

  return v8;
}

void sub_1001044CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1001044E4(uint64_t a1)
{
  _QWORD *v2;
  const void *v3;

  v2 = sub_1000FC7D8(*(_QWORD *)(a1 + 48), *(const void **)(a1 + 56), *(__CFArray **)(a1 + 64));
  if (v2)
  {
    v3 = v2;
    (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
    CFRelease(v3);
  }
  else
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
  }
}

void sub_100104554(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const __CFData *v5;
  __CFData *v6;
  __CFData *v7;
  BOOL v8;
  BOOL v9;
  int v10;
  __CFData *v11;
  const void *v12;
  _QWORD *v13;
  id v14;
  id v15;
  const void *v16;
  NSObject *v17;
  _BOOL4 v18;
  void *v19;
  __int16 v20;
  uint8_t v21[16];
  uint8_t buf[16];

  v20 = 0;
  v5 = *(const __CFData **)(a3 + 112);
  if (v5)
  {
    v6 = sub_100019B60(v5);
    v7 = *(__CFData **)(a1 + 40);
    v8 = v6 == 0;
    if (v6)
      v9 = v7 == 0;
    else
      v9 = 1;
    if (!v9)
    {
      v10 = CFEqual(v7, v6);
      v8 = 0;
      v11 = v6;
      if (v10)
        goto LABEL_7;
LABEL_11:
      v12 = 0;
      *(_BYTE *)(a3 + 48) = 1;
      v6 = v11;
      goto LABEL_12;
    }
  }
  else
  {
    v6 = 0;
    v7 = *(__CFData **)(a1 + 40);
    v8 = 1;
  }
  v11 = v6;
  v6 = v7;
  if (v7 != v11)
    goto LABEL_11;
LABEL_7:
  v12 = (const void *)sub_1001E8440(*(const __CFData **)(a1 + 48), *(CFTypeRef **)(a1 + 56));
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v12 != 0;
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    sub_1001ED4F4(a3, v12);
    sub_1001ED434((__CFArray **)(a3 + 80), v12);
  }
LABEL_12:
  *(_BYTE *)(a3 + 49) = 0;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = sub_100102ED4(*(_QWORD *)(a1 + 64), a3, 1, (uint64_t)&v20 + 1, (uint64_t)&v20, *(CFTypeRef **)(a1 + 56));
  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    v13 = *(_QWORD **)(a1 + 56);
    if (v13)
    {
      if (SecErrorGetOSStatus(*v13) == -25308)
      {
        if (qword_100341498 != -1)
          dispatch_once(&qword_100341498, &stru_1002EAB20);
        v14 = (id)qword_1003414A8;
        objc_sync_enter(v14);
        v15 = objc_msgSend((id)qword_1003414A0, "operationCount");
        v16 = sub_10000EF14("engine");
        v17 = objc_claimAutoreleasedReturnValue(v16);
        v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
        if (v15)
        {
          if (v18)
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "SOSEnsureBackup: Backup already scheduled for next unlock", buf, 2u);
          }
        }
        else
        {
          if (v18)
          {
            *(_WORD *)v21 = 0;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "SOSEnsureBackup: Scheduling a backup for next unlock", v21, 2u);
          }

          v17 = objc_claimAutoreleasedReturnValue(+[NSBlockOperation blockOperationWithBlock:](NSBlockOperation, "blockOperationWithBlock:", &stru_1002EAB40));
          v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)qword_1003414A8, "unlockDependency"));
          -[NSObject addNullableDependency:](v17, "addNullableDependency:", v19);

          objc_msgSend((id)qword_1003414A0, "addOperation:", v17);
        }

        objc_sync_exit(v14);
      }
    }
  }
  if (v12)
    CFRelease(v12);
  if (!v8)
    CFRelease(v6);
}

void sub_1001047DC(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1001047F4(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  _QWORD v7[5];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  CFMutableArrayRef Mutable;
  _QWORD block[4];
  id v13;
  uint64_t v14;

  if (-[OTSOSActualAdapter sosEnabled]_0())
  {
    v8 = 0;
    v9 = &v8;
    v10 = 0x2020000000;
    Mutable = (CFMutableArrayRef)0xAAAAAAAAAAAAAAAALL;
    Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    v7[2] = sub_100104904;
    v7[3] = &unk_1002DE0E8;
    v7[4] = &v8;
    v4 = v7;
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100104918;
    block[3] = &unk_1002DDEE0;
    v13 = v4;
    v14 = a1;
    dispatch_sync(*(dispatch_queue_t *)(a1 + 112), block);

    v5 = v9[3];
    _Block_object_dispose(&v8, 8);
  }
  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0;
  }
  return v5;
}

void sub_100104904(uint64_t a1, uint64_t a2)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), *(const void **)(a2 + 16));
}

void sub_100104918(uint64_t a1)
{
  uint64_t v1;
  id v2;
  const __CFDictionary *Copy;
  uint64_t v4;
  id v5;

  v1 = *(_QWORD *)(a1 + 40);
  v2 = *(id *)(a1 + 32);
  v4 = v1;
  v5 = objc_retainBlock(v2);
  Copy = CFDictionaryCreateCopy(0, *(CFDictionaryRef *)(v1 + 56));
  CFDictionaryApplyFunction(Copy, (CFDictionaryApplierFunction)sub_100104998, &v4);
  CFRelease(Copy);

}

void sub_100104984(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void sub_100104998(const void *a1, const void *a2, uint64_t *a3)
{
  _QWORD *v6;
  const void *v7;

  if (sub_1001ECB5C((const __CFDictionary *)a2))
  {
    v6 = sub_1000FDAA0(*a3, a1, a2, 0);
    if (v6)
    {
      v7 = v6;
      (*(void (**)(void))(a3[1] + 16))();
      CFRelease(v7);
    }
  }
}

_QWORD *sub_100104A10(_QWORD *result, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;

  v2 = result;
  v3 = *(_QWORD *)(a2 + 16);
  if (v3)
    result = CFRetain(*(CFTypeRef *)(a2 + 16));
  *(_QWORD *)(*(_QWORD *)(v2[4] + 8) + 24) = v3;
  return result;
}

void sub_100104A48(uint64_t a1)
{
  const void *v1;
  uint64_t v2;
  id v3;
  __CFDictionary *Mutable;
  const __CFDictionary *Copy;
  const void *Value;
  uint64_t v7;
  id v8;

  v2 = *(_QWORD *)(a1 + 40);
  v1 = *(const void **)(a1 + 48);
  v3 = *(id *)(a1 + 32);
  v7 = v2;
  v8 = objc_retainBlock(v3);
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  Copy = CFDictionaryCreateCopy(0, *(CFDictionaryRef *)(v2 + 56));
  Value = CFDictionaryGetValue(Copy, v1);
  if (Value)
  {
    CFDictionaryAddValue(Mutable, v1, Value);
    CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)sub_100104998, &v7);
  }
  CFRelease(Copy);
  CFRelease(Mutable);

}

void sub_100104B1C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t sub_100104B3C(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD v6[7];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  if (-[OTSOSActualAdapter sosEnabled]_0())
  {
    v7 = 0;
    v8 = &v7;
    v9 = 0x2020000000;
    v10 = 0;
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    v6[2] = sub_100104C08;
    v6[3] = &unk_1002DE048;
    v6[4] = &v7;
    v6[5] = a1;
    v6[6] = a2;
    sub_10010428C(a1, a2, v6);
    v4 = v8[3];
    _Block_object_dispose(&v7, 8);
  }
  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0;
  }
  return v4;
}

void sub_100104BF0(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_100104C08(uint64_t a1)
{
  CFMutableArrayRef Mutable;
  const __CFDictionary *v3;
  __int128 v4;
  _QWORD v5[6];
  _QWORD context[4];
  __int128 v7;
  CFMutableArrayRef v8;

  v4 = *(_OWORD *)(a1 + 40);
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v3 = *(const __CFDictionary **)(v4 + 64);
  context[0] = _NSConcreteStackBlock;
  context[1] = 3221225472;
  context[2] = sub_100104CF4;
  context[3] = &unk_1002DE148;
  v7 = v4;
  v8 = Mutable;
  CFDictionaryApplyFunction(v3, (CFDictionaryApplierFunction)sub_1000FCFBC, context);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_100104D5C;
  v5[3] = &unk_1002DE3B8;
  v5[4] = v4;
  v5[5] = Mutable;
  sub_1000FD6EC(v4, v5);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = Mutable;
}

void sub_100104CF4(uint64_t a1, const void *a2)
{
  CFDataRef *v4;

  v4 = (CFDataRef *)sub_1000FFD90(*(_QWORD *)(a1 + 32), a2, *(_QWORD *)(a1 + 40));
  sub_100104DE0(*(__CFArray **)(a1 + 48), 0, v4, a2);
  if (v4)
    CFRelease(v4);
}

void sub_100104D5C(uint64_t a1, uint64_t a2)
{
  const __CFDictionary *v4;
  const __CFString *Value;
  CFStringRef v6;

  v4 = *(const __CFDictionary **)(*(_QWORD *)(a1 + 32) + 96);
  if (v4)
  {
    Value = (const __CFString *)CFDictionaryGetValue(v4, *(const void **)(a2 + 16));
    if (!Value)
    {
      v6 = 0;
      goto LABEL_6;
    }
  }
  else
  {
    Value = CFSTR("Coders not loaded.");
  }
  v6 = CFCopyDescription(Value);
LABEL_6:
  sub_100104DE0(*(__CFArray **)(a1 + 40), *(_QWORD *)(a2 + 16), *(CFDataRef **)(a2 + 72), *(const void **)(a2 + 24));
  if (v6)
    CFRelease(v6);
}

void sub_100104DE0(__CFArray *a1, uint64_t a2, CFDataRef *a3, const void *a4)
{
  const __CFAllocator *v8;
  unint64_t v9;
  CFNumberRef v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  void *key;
  __CFDictionary *v19;
  unint64_t valuePtr;

  v8 = kCFAllocatorDefault;
  if (a3)
    v9 = CFDataGetLength(a3[3]) / 0x14uLL;
  else
    v9 = 0;
  valuePtr = v9;
  v10 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
  sub_1001E8288((__CFData *)a3);
  key = (void *)kSOSCCEngineStatePeerIDKey;
  if (a4)
  {
    CFGetTypeID(a4);
    CFSetGetTypeID();
    v8 = kCFAllocatorDefault;
  }
  v19 = sub_100104F4C(v8, v11, v12, v13, v14, v15, v16, v17, key, a2);
  if (v10)
    CFRelease(v10);
  CFArrayAppendValue(a1, v19);
  if (v19)
    CFRelease(v19);
}

__CFDictionary *sub_100104F4C(const __CFAllocator *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *key, uint64_t a10)
{
  __CFDictionary *Mutable;
  const void *v11;
  const void **v12;
  const void **v13;
  const void **v15;
  const void **v16;

  Mutable = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v15 = (const void **)&a10;
  v11 = key;
  if (key)
  {
    do
    {
      v12 = v15;
      v16 = v15 + 1;
      if (*v12)
        CFDictionarySetValue(Mutable, v11, *v12);
      v13 = v16;
      v15 = v16 + 1;
      v11 = *v13;
    }
    while (*v13);
  }
  return Mutable;
}

void sub_100104FD0(id a1, __CFString *a2)
{
  const void *v3;
  NSObject *v4;
  int v5;
  __CFString *v6;

  v3 = sub_10000EF14("engineLogState");
  v4 = objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = 138412290;
    v6 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%@", (uint8_t *)&v5, 0xCu);
  }

}

void sub_1001096D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10010A480(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  id v11;

  v3 = a2;
  v11 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("count(rowid)")));
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "asNSNumberInteger"));
  v5 = *(void **)(a1 + 32);
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("state")));
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "asString"));
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("keyclass")));

  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "asString"));
  v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@-%@"), v7, v9));
  objc_msgSend(v5, "setObject:forKeyedSubscript:", v4, v10);

}

uint64_t sub_10010A588(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_10010A598(uint64_t a1)
{

}

void sub_10010A5A0(uint64_t a1, void *a2)
{
  uint64_t v3;
  uint64_t v4;
  void *v5;
  id v6;

  v6 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(a2, "objectForKeyedSubscript:", CFSTR("count(rowid)")));
  v3 = objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "asNSNumberInteger"));
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v5 = *(void **)(v4 + 40);
  *(_QWORD *)(v4 + 40) = v3;

}

void sub_10010AC6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id *location, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,id a32)
{
  objc_destroyWeak(location);
  objc_destroyWeak(&a32);
  _Unwind_Resume(a1);
}

void sub_10010B0EC(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10010B258(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10010B30C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10010B390(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10010B5D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
  objc_sync_exit(obj);
  _Unwind_Resume(a1);
}

void sub_10010D038(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10010D408(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10010DBDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id *location, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id a18)
{
  objc_destroyWeak(location);
  objc_destroyWeak(&a18);
  _Unwind_Resume(a1);
}

void sub_10010E03C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id *location, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id a18)
{
  objc_destroyWeak(location);
  objc_destroyWeak(&a18);
  _Unwind_Resume(a1);
}

void sub_10010F904(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  id v3;

  v2 = *(_QWORD *)(a1 + 40);
  v3 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sanitizeErrorDomain:", a2));
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v3);

}

void sub_10010F94C(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  id v3;

  v2 = *(_QWORD *)(a1 + 40);
  v3 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sanitizeErrorDomain:", a2));
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v3);

}

void sub_10010F994(uint64_t a1, void *a2, void *a3, void *a4, uint64_t a5)
{
  uint64_t v8;
  void *v9;
  id v10;
  id v11;
  id v12;
  id v13;

  v9 = *(void **)(a1 + 32);
  v8 = *(_QWORD *)(a1 + 40);
  v10 = a4;
  v11 = a3;
  v12 = a2;
  v13 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "sanitizeErrorDomain:", a5));
  (*(void (**)(uint64_t, id, id, id, id))(v8 + 16))(v8, v12, v11, v10, v13);

}

void sub_10010FA2C(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  id v3;

  v2 = *(_QWORD *)(a1 + 40);
  v3 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "sanitizeErrorDomain:", a2));
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v3);

}

id sub_10010FA74(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return objc_msgSend(*(id *)(a1 + 32), "setObject:forKeyedSubscript:", a3, a2);
}

void sub_10010FA80(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  void *v5;
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  objc_msgSend(WeakRetained, "allDependentsSuccessful");
  v2 = *(_QWORD *)(a1 + 32);
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
  v4 = CKXPCSuitableError(v3);
  v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  (*(void (**)(uint64_t, void *))(v2 + 16))(v2, v5);

}

void sub_10010FAF8(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  void *v5;
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  objc_msgSend(WeakRetained, "allDependentsSuccessful");
  v2 = *(_QWORD *)(a1 + 32);
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
  v4 = CKXPCSuitableError(v3);
  v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  (*(void (**)(uint64_t, void *))(v2 + 16))(v2, v5);

}

void sub_10010FB74(uint64_t a1)
{
  id WeakRetained;
  id v3;
  NSObject *v4;
  void *v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  void *v9;
  int v10;
  void *v11;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v3 = sub_10000BDF4(CFSTR("ckks"), 0);
  v4 = objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
    v10 = 138412290;
    v11 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Ending rsync-local rpc with %@", (uint8_t *)&v10, 0xCu);

  }
  v6 = *(_QWORD *)(a1 + 32);
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
  v8 = CKXPCSuitableError(v7);
  v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
  (*(void (**)(uint64_t, void *))(v6 + 16))(v6, v9);

}

void sub_10010FC84(uint64_t a1)
{
  id WeakRetained;
  id v3;
  NSObject *v4;
  void *v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  void *v9;
  int v10;
  void *v11;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v3 = sub_10000BDF4(CFSTR("ckks"), 0);
  v4 = objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
    v10 = 138412290;
    v11 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Ending rsync-CloudKit rpc with %@", (uint8_t *)&v10, 0xCu);

  }
  v6 = *(_QWORD *)(a1 + 32);
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
  v8 = CKXPCSuitableError(v7);
  v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
  (*(void (**)(uint64_t, void *))(v6 + 16))(v6, v9);

}

void sub_10010FD94(id a1, SOSAccountTransaction *a2)
{
  CFMutableSetRef v2;
  id v3;
  NSObject *v4;
  id v5;
  NSObject *v6;
  CFTypeRef v7;
  CFTypeRef cf;
  uint8_t buf[4];
  CFTypeRef v10;

  cf = 0;
  v2 = sub_1001D5B58(a2, (uint64_t)&cf);
  if (cf)
  {
    v3 = sub_10000BDF4(CFSTR("backup"), 0);
    v4 = objc_claimAutoreleasedReturnValue(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      v10 = cf;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Couldn't process sync with backup peers: %@", buf, 0xCu);
    }

  }
  else
  {
    v5 = sub_10000BDF4(CFSTR("ckksbackup"), 0);
    v6 = objc_claimAutoreleasedReturnValue(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "telling CloudServices about TLK arrival", buf, 2u);
    }

    notify_post("com.apple.security.itembackup");
  }
  v7 = cf;
  if (cf)
  {
    cf = 0;
    CFRelease(v7);
  }

}

uint64_t sub_10010FED0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_10010FEE0(uint64_t a1)
{

}

void sub_10010FEE8(uint64_t a1)
{
  void *v2;
  id v3;
  id v4;
  NSObject *v5;
  CKKSRateLimiter *v6;
  void *v7;
  uint64_t v8;
  void *v9;
  id v10;
  uint8_t buf[4];
  id v12;

  v10 = 0;
  v2 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSZoneStateEntry tryFromDatabase:zoneName:error:](CKKSZoneStateEntry, "tryFromDatabase:zoneName:error:", &stru_1002EE888, CFSTR("all"), &v10));
  v3 = v10;
  if (v3)
  {
    v4 = sub_10000BDF4(CFSTR("manager"), 0);
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      v12 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, " couldn't load global zone state: %@", buf, 0xCu);
    }

  }
  else
  {
    v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "rateLimiter"));

    if (v7)
    {
      v6 = (CKKSRateLimiter *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "rateLimiter"));
      goto LABEL_8;
    }
  }
  v6 = objc_alloc_init(CKKSRateLimiter);
LABEL_8:
  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v9 = *(void **)(v8 + 40);
  *(_QWORD *)(v8 + 40) = v6;

}

void sub_100110028(id a1)
{
  dispatch_queue_attr_t v1;
  dispatch_queue_t v2;
  void *v3;
  NSObject *v4;

  v1 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v4 = objc_claimAutoreleasedReturnValue(v1);
  v2 = dispatch_queue_create("CKKS global zone state", v4);
  v3 = (void *)qword_1003410F0;
  qword_1003410F0 = (uint64_t)v2;

}

id sub_100110078(uint64_t a1)
{
  id WeakRetained;
  void *v2;
  void *v3;
  unsigned int v4;
  id v5;
  id v6;
  NSObject *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  unsigned __int8 v14;
  void *v15;
  id v16;
  id v17;
  id v18;
  uint64_t v19;
  void *i;
  uint64_t v21;
  void *v22;
  void *v23;
  void *v24;
  id v26;
  void *v27;
  void *v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  id v33;
  _BYTE v34[128];
  _QWORD v35[2];
  uint8_t buf[4];
  id v37;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v2 = WeakRetained;
  if (WeakRetained)
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "sosPeerAdapter"));
    v33 = 0;
    v4 = objc_msgSend(v3, "circleStatus:", &v33);
    v5 = v33;

    if (v5)
    {
      v6 = sub_10000BDF4(CFSTR("manager"), 0);
      v7 = objc_claimAutoreleasedReturnValue(v6);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        v37 = v5;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, " couldn't fetch sos status for SF report: %@", buf, 0xCu);
      }

    }
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
    if (!v4)
    {
      v9 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
      v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](NSDate, "date"));
      objc_msgSend(v9, "setDateProperty:forKey:", v10, CFSTR("lastInCircle"));

    }
    v26 = v5;
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v4 == 0));
    objc_msgSend(v8, "setObject:forKeyedSubscript:", v11, CFSTR("inCircle"));

    v28 = v2;
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "accountTracker"));
    v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "currentCKAccountInfo"));
    v14 = objc_msgSend(v13, "hasValidCredentials");

    if ((v14 & 1) == 0)
    {
      v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", 0, v5));
      objc_msgSend(v8, "setObject:forKeyedSubscript:", v15, CFSTR("validCredentials"));

    }
    v35[0] = CFSTR("lastUnlock");
    v35[1] = CFSTR("lastInCircle");
    v29 = 0u;
    v30 = 0u;
    v31 = 0u;
    v32 = 0u;
    v16 = (id)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v35, 2, v26));
    v17 = objc_msgSend(v16, "countByEnumeratingWithState:objects:count:", &v29, v34, 16);
    if (v17)
    {
      v18 = v17;
      v19 = *(_QWORD *)v30;
      do
      {
        for (i = 0; i != v18; i = (char *)i + 1)
        {
          if (*(_QWORD *)v30 != v19)
            objc_enumerationMutation(v16);
          v21 = *(_QWORD *)(*((_QWORD *)&v29 + 1) + 8 * (_QWORD)i);
          v22 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
          v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "datePropertyForKey:", v21));

          v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", +[CKKSAnalytics fuzzyDaysSinceDate:](CKKSAnalytics, "fuzzyDaysSinceDate:", v23)));
          objc_msgSend(v8, "setObject:forKeyedSubscript:", v24, v21);

        }
        v18 = objc_msgSend(v16, "countByEnumeratingWithState:objects:count:", &v29, v34, 16);
      }
      while (v18);
    }

    v2 = v28;
  }
  else
  {
    v8 = 0;
  }

  return v8;
}

id sub_1001103A8(uint64_t a1)
{
  id WeakRetained;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  uint64_t v7;
  void *v8;
  void *v9;
  uint64_t v10;
  void *v11;
  void *v12;
  uint64_t v13;
  id v14;
  id v15;
  id v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  uint64_t v25;
  id v26;
  void *v27;
  id v28;
  NSObject *v29;
  NSObject *v30;
  void *v31;
  id v32;
  void *v33;
  void *v34;
  uint64_t v35;
  id v36;
  void *v37;
  id v38;
  NSObject *v39;
  NSObject *v40;
  void *v41;
  id v42;
  void *v43;
  void *v44;
  void *v45;
  id v46;
  void *v47;
  id v48;
  NSObject *v49;
  NSObject *v50;
  void *v51;
  id v52;
  void *v53;
  void *v54;
  id v55;
  void *v56;
  void *v57;
  void *v58;
  uint64_t v59;
  void *v60;
  void *v61;
  unsigned int v62;
  void *v63;
  void *v64;
  void *v65;
  uint64_t v66;
  void *v67;
  void *v68;
  void *v69;
  void *v71;
  void *v72;
  void *v73;
  void *v74;
  void *v75;
  unint64_t v76;
  unint64_t v77;
  void *v78;
  void *v79;
  void *v80;
  void *v81;
  void *v82;
  void *v83;
  void *v84;
  void *v85;
  void *v86;
  id v87;
  id v88;
  id v89;
  uint8_t buf[4];
  uint64_t v91;
  __int16 v92;
  id v93;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "viewStateForName:", *(_QWORD *)(a1 + 40)));
    if (!v4)
    {
LABEL_39:

      goto LABEL_40;
    }
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "zoneName"));
    v7 = objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "dateOfLastSuccessForEvent:zoneName:", CFSTR("CKKSEventProcessIncomingQueueClassA"), v6));

    v8 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "zoneName"));
    v10 = objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "dateOfLastSuccessForEvent:zoneName:", CFSTR("CKKSEventProcessIncomingQueueClassC"), v9));

    v11 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "zoneName"));
    v13 = objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "datePropertyForKey:zoneName:", CFSTR("lastKSR"), v12));

    v81 = (void *)v7;
    v14 = +[CKKSAnalytics fuzzyDaysSinceDate:](CKKSAnalytics, "fuzzyDaysSinceDate:", v7);
    v80 = (void *)v10;
    v15 = +[CKKSAnalytics fuzzyDaysSinceDate:](CKKSAnalytics, "fuzzyDaysSinceDate:", v10);
    v79 = (void *)v13;
    v16 = +[CKKSAnalytics fuzzyDaysSinceDate:](CKKSAnalytics, "fuzzyDaysSinceDate:", v13);
    v76 = (unint64_t)v14;
    v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", v14));
    v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@-daysSinceClassASync"), *(_QWORD *)(a1 + 40)));
    objc_msgSend(v3, "setValue:forKey:", v17, v18);

    v77 = (unint64_t)v15;
    v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", v15));
    v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@-daysSinceClassCSync"), *(_QWORD *)(a1 + 40)));
    objc_msgSend(v3, "setValue:forKey:", v19, v20);

    v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", v16));
    v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@-daysSinceLastKeystateReady"), *(_QWORD *)(a1 + 40)));
    objc_msgSend(v3, "setValue:forKey:", v21, v22);

    v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "contextID"));
    v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "zoneID"));
    v89 = 0;
    v25 = objc_claimAutoreleasedReturnValue(+[CKKSMirrorEntry countsWithContextID:zoneID:error:](CKKSMirrorEntry, "countsWithContextID:zoneID:error:", v23, v24, &v89));
    v26 = v89;

    v85 = v26;
    if (v26 || !v25)
    {
      v32 = sub_10000BDF4(CFSTR("manager"), 0);
      v30 = objc_claimAutoreleasedReturnValue(v32);
      if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      {
LABEL_12:

        v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "contextID"));
        v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "zoneID"));
        v88 = 0;
        v35 = objc_claimAutoreleasedReturnValue(+[CKKSTLKShareRecord countsWithContextID:zoneID:error:](CKKSTLKShareRecord, "countsWithContextID:zoneID:error:", v33, v34, &v88));
        v36 = v88;

        v84 = v36;
        v86 = (void *)v35;
        if (v36 || !v35)
        {
          v42 = sub_10000BDF4(CFSTR("manager"), 0);
          v40 = objc_claimAutoreleasedReturnValue(v42);
          if (!os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
            goto LABEL_20;
          v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "zoneID"));
          *(_DWORD *)buf = 138412546;
          v91 = (uint64_t)v41;
          v92 = 2112;
          v93 = v36;
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "couldn't fetch CKKSTLKShare counts for %@: %@", buf, 0x16u);
        }
        else
        {
          v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "zoneName"));
          v38 = sub_10000BDF4(CFSTR("metrics"), v37);
          v39 = objc_claimAutoreleasedReturnValue(v38);

          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138412290;
            v91 = (uint64_t)v86;
            _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "View has %@ tlkshares", buf, 0xCu);
          }

          v40 = objc_claimAutoreleasedReturnValue(+[CKKSAnalytics fuzzyNumber:](CKKSAnalytics, "fuzzyNumber:", v86));
          v41 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@-%@"), *(_QWORD *)(a1 + 40), CFSTR("numTLKShares")));
          objc_msgSend(v3, "setObject:forKeyedSubscript:", v40, v41);
        }

LABEL_20:
        v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "contextID"));
        v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "zoneID"));
        v87 = 0;
        v45 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSKey countsWithContextID:zoneID:error:](CKKSKey, "countsWithContextID:zoneID:error:", v43, v44, &v87));
        v46 = v87;

        v83 = v46;
        v78 = (void *)v25;
        if (v46 || !v45)
        {
          v52 = sub_10000BDF4(CFSTR("manager"), 0);
          v50 = objc_claimAutoreleasedReturnValue(v52);
          if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
          {
            v53 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "zoneID"));
            *(_DWORD *)buf = 138412546;
            v91 = (uint64_t)v53;
            v92 = 2112;
            v93 = v83;
            _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, "couldn't fetch CKKSKey counts for %@: %@", buf, 0x16u);

          }
          v51 = v3;
        }
        else
        {
          v47 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "zoneName"));
          v48 = sub_10000BDF4(CFSTR("metrics"), v47);
          v49 = objc_claimAutoreleasedReturnValue(v48);

          if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138412290;
            v91 = (uint64_t)v45;
            _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "View has %@ sync keys", buf, 0xCu);
          }

          v50 = objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@-%@"), *(_QWORD *)(a1 + 40), CFSTR("numSyncKeys")));
          objc_msgSend(v3, "setObject:forKeyedSubscript:", v45, v50);
          v51 = v3;
        }

        v54 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "viewKeyHierarchyState"));
        v55 = objc_msgSend(v54, "isEqualToString:", CFSTR("ready"));

        v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "lastIncomingQueueOperation"));
        v82 = v4;
        v57 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v56, "error"));

        v58 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "lastOutgoingQueueOperation"));
        v75 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v58, "error"));

        v74 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@-%@"), *(_QWORD *)(a1 + 40), CFSTR("TLKs")));
        v59 = objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@-%@"), *(_QWORD *)(a1 + 40), CFSTR("inSyncA")));
        v73 = (void *)v59;
        v60 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@-%@"), *(_QWORD *)(a1 + 40), CFSTR("inSyncC")));
        v71 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@-%@"), *(_QWORD *)(a1 + 40), CFSTR("IQNOE")));
        v72 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@-%@"), *(_QWORD *)(a1 + 40), CFSTR("OQNOE")));
        v61 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v55));
        objc_msgSend(v51, "setObject:forKeyedSubscript:", v61, v74);

        if (v76 < 7)
          v62 = v55;
        else
          v62 = 0;
        v63 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v76 < 7));
        objc_msgSend(v51, "setObject:forKeyedSubscript:", v63, v59);

        if (v77 >= 7)
          v62 = 0;
        v64 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v77 < 7));
        objc_msgSend(v51, "setObject:forKeyedSubscript:", v64, v60);

        v4 = v82;
        if (v57)
          v62 = 0;
        v65 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v57 == 0));
        objc_msgSend(v51, "setObject:forKeyedSubscript:", v65, v71);

        if (v75)
          v66 = 0;
        else
          v66 = v62;
        v67 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v75 == 0));
        objc_msgSend(v51, "setObject:forKeyedSubscript:", v67, v72);

        v68 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@-%@"), *(_QWORD *)(a1 + 40), CFSTR("inSync")));
        v69 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v66));
        objc_msgSend(v51, "setObject:forKeyedSubscript:", v69, v68);

        v3 = v51;
        goto LABEL_39;
      }
      v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "zoneID"));
      *(_DWORD *)buf = 138412546;
      v91 = (uint64_t)v31;
      v92 = 2112;
      v93 = v85;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "couldn't fetch CKMirror counts for %@: %@", buf, 0x16u);
    }
    else
    {
      v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "zoneName"));
      v28 = sub_10000BDF4(CFSTR("metrics"), v27);
      v29 = objc_claimAutoreleasedReturnValue(v28);

      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v91 = v25;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "View has %@ item ckrecords", buf, 0xCu);
      }

      v30 = objc_claimAutoreleasedReturnValue(+[CKKSAnalytics fuzzyNumber:](CKKSAnalytics, "fuzzyNumber:", v25));
      v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@-%@"), *(_QWORD *)(a1 + 40), CFSTR("numItems")));
      objc_msgSend(v3, "setObject:forKeyedSubscript:", v30, v31);
    }

    goto LABEL_12;
  }
  v3 = 0;
LABEL_40:

  return v3;
}

void sub_100110E80(uint64_t a1)
{
  id v2;
  unsigned __int8 v3;
  id v4;

  v4 = (id)objc_claimAutoreleasedReturnValue(+[OTManager manager](OTManager, "manager"));
  v2 = objc_alloc_init((Class)OTControlArguments);
  v3 = objc_msgSend(v4, "waitForReady:wait:", v2, 2000000000);

  if ((v3 & 1) == 0)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;

}

void sub_100111298(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  id *v15;

  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100111384(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v6;
  id v7;
  id WeakRetained;
  void *v9;
  const void *v10;
  NSObject *v11;
  const void *v12;
  NSObject *v13;
  void *v14;
  void *v15;
  void *v16;
  id v17;
  id v18;
  const void *v19;
  NSObject *v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  _QWORD v25[4];
  id v26;
  uint8_t buf[4];
  id v28;
  __int16 v29;
  void *v30;

  v6 = a2;
  v7 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v9 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v9, "logResultForEvent:hardFailure:result:", CFSTR("OctagonEventFetchViews"), 1, v7);

  if (v7)
  {
    v10 = sub_10000EF14("SecError");
    v11 = objc_claimAutoreleasedReturnValue(v10);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v28 = v7;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "octagon: failed to retrieve policy+views: %@", buf, 0xCu);
    }

    objc_msgSend(WeakRetained, "setError:", v7);
  }
  else
  {
    v12 = sub_10000EF14("octagon-ckks");
    v13 = objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "viewList"));
      *(_DWORD *)buf = 138412546;
      v28 = v6;
      v29 = 2112;
      v30 = v14;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Received syncing policy %@ with view list: %@", buf, 0x16u);

    }
    v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "stateHolder"));
    v25[0] = _NSConcreteStackBlock;
    v25[1] = 3221225472;
    v25[2] = sub_100111668;
    v25[3] = &unk_1002EAF10;
    v17 = v6;
    v26 = v17;
    v24 = 0;
    objc_msgSend(v16, "persistAccountChanges:error:", v25, &v24);
    v18 = v24;

    if (v18)
    {
      v19 = sub_10000EF14("SecError");
      v20 = objc_claimAutoreleasedReturnValue(v19);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v28 = v18;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "octagon: failed to save policy+views: %@", buf, 0xCu);
      }

      objc_msgSend(WeakRetained, "setError:", v18);
    }
    else
    {
      v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
      v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "ckks"));
      objc_msgSend(v22, "setCurrentSyncingPolicy:", v17);

      v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "intendedState"));
      objc_msgSend(WeakRetained, "setNextState:", v23);

    }
  }

}

id sub_100111668(uint64_t a1, void *a2)
{
  id v3;

  v3 = a2;
  objc_msgSend(v3, "setTPSyncingPolicy:", *(_QWORD *)(a1 + 32));
  return v3;
}

void sub_100113890(id a1)
{
  void *v1;
  uint64_t v2;
  void *v3;
  _QWORD v4[11];

  v4[0] = kSecAttrAccessGroup;
  v4[1] = kSecAttrSharingGroup;
  v4[2] = kSecAttrKeyType;
  v4[3] = kSecAttrApplicationTag;
  v4[4] = kSecAttrLabel;
  v4[5] = kSecAttrApplicationLabel;
  v4[6] = kSecValueData;
  v4[7] = kSecAttrKeySizeInBits;
  v4[8] = kSecAttrEffectiveKeySize;
  v4[9] = kSecAttrCreationDate;
  v4[10] = kSecAttrModificationDate;
  v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v4, 11));
  v2 = objc_claimAutoreleasedReturnValue(+[NSSet setWithArray:](NSSet, "setWithArray:", v1));
  v3 = (void *)qword_100341100;
  qword_100341100 = v2;

}

void sub_100113DD8(uint64_t a1)
{
  id v2;
  id v3;
  void *v4;
  id v5;

  v2 = objc_alloc((Class)_SFAuthenticatedEncryptionOperation);
  v5 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "keySpecifier"));
  v3 = objc_msgSend(v2, "initWithKeySpecifier:", v5);
  v4 = (void *)qword_100341130;
  qword_100341130 = (uint64_t)v3;

}

void sub_100113E3C(uint64_t a1)
{
  id v2;
  id v3;
  void *v4;
  id v5;

  v2 = objc_alloc((Class)_SFAuthenticatedEncryptionOperation);
  v5 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "keySpecifier"));
  v3 = objc_msgSend(v2, "initWithKeySpecifier:", v5);
  v4 = (void *)qword_100341120;
  qword_100341120 = (uint64_t)v3;

}

void sub_100113EA0(id a1)
{
  id v1;
  void *v2;

  v1 = objc_msgSend(objc_alloc((Class)_SFAESKeySpecifier), "initWithBitSize:", 2);
  v2 = (void *)qword_100341110;
  qword_100341110 = (uint64_t)v1;

}

void sub_100114084(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  id *v15;

  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1001141A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1001144F4(_Unwind_Exception *a1)
{
  id *v1;
  id *v2;
  uint64_t v3;

  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v3 - 72));
  _Unwind_Resume(a1);
}

id sub_100114710(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "_onqueueSetNetworkReachability:", *(unsigned __int8 *)(a1 + 40));
}

void sub_100114720(uint64_t a1)
{
  NSObject *v1;
  id WeakRetained;
  _QWORD block[5];

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v1 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "queue"));
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100114818;
  block[3] = &unk_1002EC350;
  block[4] = WeakRetained;
  dispatch_sync(v1, block);

}

void sub_1001147A0(uint64_t a1)
{
  id WeakRetained;
  void *v2;
  void *v3;
  id v4;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v4 = WeakRetained;
    v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "timer"));

    WeakRetained = v4;
    if (v2)
    {
      v3 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
      objc_msgSend(v3, "noteEvent:", CFSTR("CKKSEventReachabilityTimerExpired"));

      objc_msgSend(v4, "_onQueueRunReachabilityDependency");
      WeakRetained = v4;
    }
  }

}

void sub_100114818(uint64_t a1)
{
  unsigned int v2;
  id v3;
  NSObject *v4;
  _BOOL4 v5;
  int v6;
  uint64_t v7;

  v2 = objc_msgSend(*(id *)(a1 + 32), "haveNetwork");
  v3 = sub_10000BDF4(CFSTR("network"), 0);
  v4 = objc_claimAutoreleasedReturnValue(v3);
  v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v5)
    {
      LOWORD(v6) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Network available", (uint8_t *)&v6, 2u);
    }

  }
  else
  {
    if (v5)
    {
      v6 = 134217984;
      v7 = 0x4028000000000000;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Network still not available, retrying after waiting %2.1f hours", (uint8_t *)&v6, 0xCu);
    }

    objc_msgSend(*(id *)(a1 + 32), "_onQueueResetReachabilityDependency");
  }
}

id sub_10011491C(uint64_t a1)
{
  id result;

  result = objc_msgSend(*(id *)(a1 + 32), "haveNetwork");
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = (_BYTE)result;
  return result;
}

id sub_10011494C(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "_onQueueResetReachabilityDependency");
}

void sub_100114954(uint64_t a1, void *a2)
{
  id *v2;
  NSObject *v3;
  id WeakRetained;
  nw_path_status_t status;
  id v6;
  NSObject *v7;
  const __CFString *v8;
  int v9;
  const __CFString *v10;

  v2 = (id *)(a1 + 32);
  v3 = a2;
  WeakRetained = objc_loadWeakRetained(v2);
  status = nw_path_get_status(v3);

  v6 = sub_10000BDF4(CFSTR("ckksnetwork"), 0);
  v7 = objc_claimAutoreleasedReturnValue(v6);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    v8 = CFSTR("unavailable");
    if (status == nw_path_status_satisfied)
      v8 = CFSTR("available");
    v9 = 138412290;
    v10 = v8;
    _os_log_debug_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "nw_path update: network is %@", (uint8_t *)&v9, 0xCu);
  }

  objc_msgSend(WeakRetained, "_onqueueSetNetworkReachability:", status == nw_path_status_satisfied);
}

void sub_1001154B4(id a1)
{
  qword_100341160 = (uint64_t)dispatch_queue_create("secd-hash-name", 0);
  qword_100341158 = (uint64_t)CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
}

uint64_t sub_100115500(uint64_t a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass(&unk_1002DE5B8);
  **(_QWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_100115530(_QWORD **a1, _QWORD **a2)
{
  const void *v3;
  uint64_t v4;
  uint64_t v5;
  const void *v6;

  v3 = a1;
  if (a1)
  {
    v4 = sub_10001E6A8(a1[2], 7, 0);
    v3 = sub_100019204(v3, v4, 0);
  }
  if (a2)
  {
    v5 = sub_10001E6A8(a2[2], 7, 0);
    v6 = sub_100019204(a2, v5, 0);
  }
  else
  {
    v6 = 0;
  }
  return CFEqual(v3, v6);
}

uint64_t sub_1001155AC(_QWORD **a1)
{
  uint64_t v2;
  const __CFData *v3;

  v2 = sub_10001E6A8(a1[2], 7, 0);
  v3 = (const __CFData *)sub_100019204(a1, v2, 0);
  return *(int *)CFDataGetBytePtr(v3);
}

__CFString *sub_1001155F0(_QWORD **a1, CFTypeRef cf)
{
  CFTypeID v4;
  const __CFAllocator *v5;
  __CFString *Mutable;
  _QWORD *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  _QWORD *v11;
  CFStringRef *v12;
  CFStringRef **v13;
  CFStringRef *v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  __CFString *v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  __int128 *v24;
  const void *v25;
  const UInt8 *v26;
  const void *v27;
  const void *v28;
  CFTypeID v29;
  const __CFDate *v30;
  const __CFDate *v31;
  CFTypeID v32;
  double AbsoluteTime;
  const __CFData *v34;
  const __CFData *v35;
  CFTypeID v36;
  const __CFNumber *v37;
  const __CFNumber *v38;
  CFTypeID v39;
  char *p_valuePtr;
  const void *v41;
  const void *v42;
  CFTypeID v43;
  BOOL v44;
  const void *v45;
  const __CFNumber *v46;
  const __CFNumber *v47;
  CFTypeID v48;
  const __CFNumber *v49;
  CFNumberType v50;
  const __CFData *v51;
  const __CFData *v52;
  CFTypeID v53;
  const __CFNumber *v54;
  CFTypeID v55;
  const void *v56;
  const void *v57;
  CFTypeID v58;
  const void *v59;
  const void *v60;
  CFTypeID v61;
  const UInt8 *v62;
  CFIndex Length;
  CFIndex v64;
  unsigned int v65;
  uint64_t v66;
  const __CFAllocator *v67;
  const char *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  const char *v74;
  uint64_t v75;
  int v76;
  const char *v77;
  CFTypeRef v79;
  __CFString *v80;
  const UInt8 *BytePtr;
  const void *v82;
  const void *v83;
  const void *v84;
  uint64_t v85;
  __int16 valuePtr;
  int v87;
  __int128 v88;
  __int128 v89;

  if (cf
    && (v4 = CFGetTypeID(cf), v4 == CFDictionaryGetTypeID())
    && CFDictionaryContainsKey((CFDictionaryRef)cf, CFSTR("debug")))
  {
    v5 = CFGetAllocator(a1);
    Mutable = CFStringCreateMutable(v5, 0);
    CFStringAppendFormat(Mutable, 0, CFSTR("<%@"), *a1[2]);
    v7 = a1[2];
    v8 = v7[2];
    if (v8)
    {
      v9 = v7 + 3;
      do
      {
        if ((*(_BYTE *)(v8 + 16) & 1) != 0)
          sub_100115CD0(a1, (CFStringRef *)v8, Mutable);
        v10 = *v9++;
        v8 = v10;
      }
      while (v10);
    }
    CFStringAppend(Mutable, CFSTR(", |otherAttr"));
    v11 = a1[2];
    v12 = (CFStringRef *)v11[2];
    if (v12)
    {
      v13 = (CFStringRef **)(v11 + 3);
      do
      {
        if (*v12 && CFEqual(CFSTR("tomb"), *v12))
          sub_100115CD0(a1, v12, Mutable);
        v14 = *v13++;
        v12 = v14;
      }
      while (v14);
      v15 = a1[2];
      v16 = v15[2];
      if (v16)
      {
        v17 = v15 + 3;
        do
        {
          if ((*(_BYTE *)(v16 + 16) & 1) == 0 && (!*(_QWORD *)v16 || !CFEqual(CFSTR("tomb"), *(CFTypeRef *)v16)))
            sub_100115CD0(a1, (CFStringRef *)v16, Mutable);
          v18 = *v17++;
          v16 = v18;
        }
        while (v18);
      }
    }
    CFStringAppend(Mutable, CFSTR(">"));
  }
  else
  {
    v87 = 0;
    valuePtr = 0;
    v85 = 0;
    v88 = 0u;
    v89 = 0u;
    v19 = CFStringCreateMutable(kCFAllocatorDefault, 0);
    v20 = a1[2];
    v23 = v20[2];
    v21 = v20 + 2;
    v22 = v23;
    v24 = &v88;
    if (v23)
    {
      v84 = 0;
      v82 = 0;
      v25 = 0;
      v79 = (CFTypeRef)kSecAttrMultiUser;
      BytePtr = (const UInt8 *)&v87;
      v26 = (const UInt8 *)&v87;
      do
      {
        switch(*(_DWORD *)(v22 + 8))
        {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 9:
            if ((*(_BYTE *)(v22 + 16) & 0x30) != 0)
            {
              v27 = sub_100019204(a1, v22, 0);
              if (v27)
              {
                v28 = v27;
                if (!CFEqual(v27, kCFNull))
                {
                  v29 = CFGetTypeID(v28);
                  if (v29 != CFStringGetTypeID() || !CFEqual(*(CFTypeRef *)v22, kSecAttrAccessGroup))
                  {
                    CFStringAppend(v19, CFSTR(","));
                    goto LABEL_70;
                  }
                  v82 = v28;
                }
              }
            }
            break;
          case 6:
            v30 = (const __CFDate *)sub_100019204(a1, v22, 0);
            if (v30)
            {
              v31 = v30;
              v32 = CFGetTypeID(v30);
              if (v32 == CFDateGetTypeID())
              {
                AbsoluteTime = CFDateGetAbsoluteTime(v31);
                v24 = (__int128 *)sub_100022108(0, 0, (uint64_t)v24, (unint64_t)&v89 + 15, AbsoluteTime);
              }
            }
            break;
          case 7:
            v34 = (const __CFData *)sub_100019204(a1, v22, 0);
            if (v34)
            {
              v35 = v34;
              v36 = CFGetTypeID(v34);
              if (v36 == CFDataGetTypeID() && CFDataGetLength(v35) >= 4)
                BytePtr = CFDataGetBytePtr(v35);
            }
            break;
          case 8:
            v46 = (const __CFNumber *)sub_100019204(a1, v22, 0);
            if (v46)
            {
              v47 = v46;
              v48 = CFGetTypeID(v46);
              if (v48 == CFNumberGetTypeID())
              {
                p_valuePtr = (char *)&v85;
                v49 = v47;
                v50 = kCFNumberSInt64Type;
                goto LABEL_56;
              }
            }
            break;
          case 0xA:
            v51 = (const __CFData *)sub_100019204(a1, v22, 0);
            if (v51)
            {
              v52 = v51;
              v53 = CFGetTypeID(v51);
              if (v53 == CFDataGetTypeID())
                v26 = CFDataGetBytePtr(v52);
            }
            break;
          case 0xB:
            v54 = (const __CFNumber *)sub_100019204(a1, v22, 0);
            if (v54)
            {
              v38 = v54;
              v55 = CFGetTypeID(v54);
              if (v55 == CFNumberGetTypeID())
              {
                p_valuePtr = (char *)&valuePtr + 1;
                goto LABEL_55;
              }
            }
            break;
          case 0xC:
            v37 = (const __CFNumber *)sub_100019204(a1, v22, 0);
            if (v37)
            {
              v38 = v37;
              v39 = CFGetTypeID(v37);
              if (v39 == CFNumberGetTypeID())
              {
                p_valuePtr = (char *)&valuePtr;
LABEL_55:
                v49 = v38;
                v50 = kCFNumberCharType;
LABEL_56:
                CFNumberGetValue(v49, v50, p_valuePtr);
              }
            }
            break;
          case 0xD:
            v41 = sub_100019204(a1, v22, 0);
            if (v41)
            {
              v42 = v41;
              v43 = CFGetTypeID(v41);
              v44 = v43 != CFBooleanGetTypeID();
              v45 = v84;
              if (!v44)
                v45 = v42;
              v84 = v45;
            }
            break;
          case 0xE:
            v56 = sub_100019204(a1, v22, 0);
            if (v56)
            {
              v57 = v56;
              v58 = CFGetTypeID(v56);
              if (v58 == CFStringGetTypeID())
                v25 = v57;
            }
            break;
          case 0x10:
            v59 = sub_100019204(a1, v22, 0);
            if (v59)
            {
              v60 = v59;
              if (CFEqual(*(CFTypeRef *)v22, v79))
              {
                v61 = CFGetTypeID(v60);
                if (v61 == CFDataGetTypeID())
                {
                  CFStringAppend(v19, CFSTR(","));
                  if (CFDataGetLength((CFDataRef)v60))
                  {
                    v62 = CFDataGetBytePtr((CFDataRef)v60);
                    Length = CFDataGetLength((CFDataRef)v60);
                    if (Length >= 1)
                    {
                      v64 = Length;
                      do
                      {
                        v65 = *v62++;
                        CFStringAppendFormat(v19, 0, CFSTR("%02X"), v65);
                        --v64;
                      }
                      while (v64);
                    }
                  }
                  else
                  {
LABEL_70:
                    CFStringAppend(v19, *(CFStringRef *)v22);
                  }
                }
              }
            }
            break;
          default:
            break;
        }
        v66 = v21[1];
        ++v21;
        v22 = v66;
      }
      while (v66);
    }
    else
    {
      v25 = 0;
      v82 = 0;
      v84 = 0;
      v26 = (const UInt8 *)&v87;
      BytePtr = (const UInt8 *)&v87;
    }
    v83 = v25;
    v80 = v19;
    v67 = CFGetAllocator(a1);
    if ((_BYTE)valuePtr)
      v68 = "T";
    else
      v68 = "O";
    v69 = *a1[2];
    v70 = *v26;
    v71 = v26[1];
    v72 = v26[2];
    v73 = v26[3];
    if (HIBYTE(valuePtr))
      v74 = "S";
    else
      v74 = "L";
    v75 = v85;
    if (v84)
    {
      v76 = CFEqual(v84, kCFBooleanFalse);
      v77 = "F,";
      if (!v76)
        v77 = "T,";
    }
    else
    {
      v77 = "";
    }
    Mutable = (__CFString *)CFStringCreateWithFormat(v67, 0, CFSTR("%s,%@,%02X%02X%02X%02X,%s,%@,%@,%lld%@,%s,%s%02X%02X%02X%02X"), v68, v69, v70, v71, v72, v73, v74, v83, v82, v75, v80, v24, v77, *BytePtr, BytePtr[1], BytePtr[2],
                              BytePtr[3]);
    if (v80)
      CFRelease(v80);
  }
  return Mutable;
}

__CFString *sub_100115CA8(_QWORD **a1)
{
  const void *v2;

  v2 = (const void *)sub_100005100();
  return sub_1001155F0(a1, v2);
}

void sub_100115CD0(const void *a1, CFStringRef *a2, __CFString *a3)
{
  const __CFNull *v6;
  const __CFData *v7;
  const UInt8 *BytePtr;
  CFIndex Length;
  unint64_t v10;
  unsigned int v11;
  uint64_t i;
  CFTypeID v13;
  uint64_t v14;

  if (!CFEqual(CFSTR("data"), *a2) && !CFEqual(CFSTR("v_pk"), *a2))
  {
    v6 = (const __CFNull *)sub_100019204(a1, (uint64_t)a2, 0);
    if (v6)
    {
      v7 = v6;
      if (v6 != kCFNull)
      {
        CFStringAppend(a3, CFSTR(","));
        CFStringAppend(a3, *a2);
        CFStringAppend(a3, CFSTR("="));
        if (CFEqual(CFSTR("data"), *a2))
        {
          BytePtr = CFDataGetBytePtr(v7);
          Length = CFDataGetLength(v7);
          if ((Length & 0x8000000000000000) == 0)
          {
            v10 = Length;
            CFStringAppendFormat(a3, 0, CFSTR("%04lx:"), Length);
            if (v10 > 8)
            {
              v14 = 0;
              CNCRC(60, BytePtr + 8, v10 - 8, &v14);
              for (i = 0; i != 8; ++i)
                CFStringAppendFormat(a3, 0, CFSTR("%02X"), BytePtr[i]);
              CFStringAppendFormat(a3, 0, CFSTR("...|%08llx"), v14);
            }
            else
            {
              for (; v10; --v10)
              {
                v11 = *BytePtr++;
                CFStringAppendFormat(a3, 0, CFSTR("%02X"), v11);
              }
            }
          }
        }
        else if (CFEqual(CFSTR("v_Data"), *a2))
        {
          CFStringAppend(a3, CFSTR("<?>"));
        }
        else
        {
          v13 = CFGetTypeID(v7);
          if (v13 == CFDataGetTypeID())
            sub_100115EE0(a3, v7);
          else
            CFStringAppendFormat(a3, 0, CFSTR("%@"), v7);
        }
      }
    }
  }
}

void sub_100115EE0(__CFString *a1, CFDataRef theData)
{
  const UInt8 *BytePtr;
  CFIndex Length;
  CFIndex v6;
  unsigned int v7;

  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  if (Length >= 1)
  {
    v6 = Length;
    do
    {
      v7 = *BytePtr++;
      CFStringAppendFormat(a1, 0, CFSTR("%02X"), v7);
      --v6;
    }
    while (v6);
  }
}

BOOL sub_100115F58(uint64_t a1, int a2, __CFString **a3)
{
  _BOOL8 v5;
  _QWORD *v6;

  v5 = sub_1000192F4(a1, 1, a3);
  if (v5 && *(_DWORD *)(a1 + 28) != a2)
  {
    *(_DWORD *)(a1 + 28) = a2;
    *(_QWORD *)(a1 + 32) = 0;
    if (*(_DWORD *)(a1 + 40) == 2)
    {
      v6 = (_QWORD *)sub_10001E6A8(*(_QWORD **)(a1 + 16), 9, 0);
      sub_10001A56C(a1, v6, kCFNull, 0);
    }
  }
  return v5;
}

void sub_100115FE0(uint64_t a1, const void *a2, uint64_t *a3)
{
  const __CFData *v5;
  NSObject *v6;
  uint64_t v7;
  const char *v8;
  CFTypeRef v9;
  const __CFData *v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  CFTypeRef cf;
  uint8_t buf[4];
  uint64_t v16;
  __int16 v17;
  CFTypeRef v18;

  cf = 0;
  v5 = (const __CFData *)sub_100019204(a2, (uint64_t)a3, (__CFString **)&cf);
  if (cf)
  {
    v6 = sub_10000EF14("secitem");
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      goto LABEL_5;
    v7 = *a3;
    *(_DWORD *)buf = 138412546;
    v16 = v7;
    v17 = 2112;
    v18 = cf;
    v8 = "Merging: unable to get attribute (%@) : %@";
    goto LABEL_4;
  }
  v10 = v5;
  if (v5 && (!kCFNull || !CFEqual(v5, kCFNull)))
  {
    v11 = sub_10000EF14("secitem");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      v13 = *a3;
      *(_DWORD *)buf = 138412290;
      v16 = v13;
      _os_log_debug_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "Preserving existing data for %@", buf, 0xCu);
    }
    sub_10001A56C(a1, a3, v10, (__CFString **)&cf);
    if (cf)
    {
      v6 = sub_10000EF14("secitem");
      if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
LABEL_5:
        v9 = cf;
        if (cf)
        {
          cf = 0;
          CFRelease(v9);
        }
        return;
      }
      v12 = *a3;
      *(_DWORD *)buf = 138412546;
      v16 = v12;
      v17 = 2112;
      v18 = cf;
      v8 = "Unable to set attribute (%@) : %@";
LABEL_4:
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v8, buf, 0x16u);
      goto LABEL_5;
    }
  }
}

CFNumberRef sub_1001161BC(const __CFAllocator *a1, sqlite3_stmt *a2, int iCol)
{
  sqlite3_int64 v4;
  sqlite3_int64 *p_valuePtr;
  const __CFAllocator *v6;
  CFNumberType v7;
  int v9;
  sqlite3_int64 valuePtr;

  v4 = sqlite3_column_int64(a2, iCol);
  valuePtr = v4;
  if (v4 == (int)v4)
  {
    v9 = v4;
    p_valuePtr = (sqlite3_int64 *)&v9;
    v6 = a1;
    v7 = kCFNumberSInt32Type;
  }
  else
  {
    p_valuePtr = &valuePtr;
    v6 = a1;
    v7 = kCFNumberSInt64Type;
  }
  return CFNumberCreate(v6, v7, p_valuePtr);
}

CFStringRef sub_10011621C(const __CFAllocator *a1, sqlite3_stmt *a2, int iCol, __int16 a4)
{
  const unsigned __int8 *v6;
  const UInt8 *v7;
  size_t v8;

  v6 = sqlite3_column_text(a2, iCol);
  if (v6)
  {
    v7 = v6;
    v8 = strlen((const char *)v6);
    if (v8)
      return CFStringCreateWithBytes(a1, v7, v8, 0x8000100u, 0);
  }
  if ((a4 & 0x800) != 0)
    return &stru_1002EE888;
  if ((a4 & 0x400) != 0)
    return CFSTR("0");
  return (CFStringRef)kCFNull;
}

const void *sub_1001162B4(const __CFAllocator *a1, _QWORD *a2, const __CFData *a3, int a4, uint64_t a5, __CFString **a6)
{
  const void *v9;
  _QWORD *v10;

  v9 = (const void *)sub_10001E8EC(a1, (uint64_t)a2, a4, a5);
  v10 = (_QWORD *)sub_10001E6A8(a2, 9, a6);
  if (v10 && (sub_10001A56C((uint64_t)v9, v10, a3, a6) & 1) == 0 && v9)
  {
    CFRelease(v9);
    return 0;
  }
  return v9;
}

void sub_100116330(CFMutableStringRef theString, uint64_t a2)
{
  unint64_t v3;
  char v4;

  if (a2 >= 1)
  {
    v3 = a2 + 1;
    v4 = 1;
    do
    {
      if ((v4 & 1) == 0)
        CFStringAppend(theString, CFSTR(","));
      CFStringAppend(theString, CFSTR("?"));
      v4 = 0;
      --v3;
    }
    while (v3 > 1);
  }
  CFStringAppend(theString, CFSTR(")"));
}

uint64_t sub_1001163AC(_QWORD **a1, __CFString **a2)
{
  uint64_t v4;
  const __CFNumber *v5;
  const __CFNumber *v6;
  CFTypeID v7;
  uint64_t valuePtr;

  valuePtr = 0;
  v4 = sub_10001E6A8(a1[2], 8, a2);
  if (v4)
  {
    v5 = (const __CFNumber *)sub_100019204(a1, v4, a2);
    v6 = v5;
    if (!v5
      || (v7 = CFGetTypeID(v5), v7 != CFNumberGetTypeID())
      || !CFNumberGetValue(v6, kCFNumberSInt64Type, &valuePtr))
    {
      sub_10003060C(1, (CFTypeRef *)a2, CFSTR("rowid %@ is not a 64 bit number"), v6);
    }
  }
  return valuePtr;
}

void sub_100116454(uint64_t a1, __CFString **a2)
{
  const void **v3;

  v3 = (const void **)sub_10001E6A8(*(_QWORD **)(a1 + 16), 8, a2);
  if (v3)
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 48), *v3);
}

uint64_t sub_10011649C(uint64_t a1, __CFString **a2)
{
  _QWORD *v4;

  v4 = (_QWORD *)sub_10001E6A8(*(_QWORD **)(a1 + 16), 11, a2);
  return sub_10001A56C(a1, v4, kCFBooleanTrue, a2);
}

BOOL sub_1001164E4(const void *a1)
{
  const void *v1;
  const void *v2;

  v1 = sub_100019204(a1, (uint64_t)&off_1002E7D78, 0);
  if (!v1)
    return 1;
  v2 = v1;
  if (qword_100341188 != -1)
    dispatch_once(&qword_100341188, &stru_1002DED08);
  return qword_100341190 && CFEqual(v2, (CFTypeRef)qword_100341190) != 0;
}

const void *sub_100116568(_QWORD **a1, __CFString **a2)
{
  uint64_t v4;

  v4 = sub_10001E6A8(a1[2], 7, a2);
  return sub_100019204(a1, v4, a2);
}

__CFError *sub_1001165A4(__CFError *result)
{
  __CFError *v1;
  CFErrorDomain Domain;

  if (result)
  {
    v1 = result;
    if (CFErrorGetCode(result) == 19)
    {
      Domain = CFErrorGetDomain(v1);
      return (__CFError *)(CFEqual(CFSTR("com.apple.utilities.sqlite3"), Domain) != 0);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

_QWORD *sub_1001165F8(_QWORD *a1, __CFString **a2)
{
  __CFDictionary *v4;
  __CFDictionary *v5;
  _QWORD *v6;
  _QWORD *v7;
  const void *v8;

  v4 = sub_10001904C(a1, 1, 0, a2);
  if (!v4)
    return 0;
  v5 = v4;
  v6 = sub_1000114E8(a1[2], 0, 0, 0, a2);
  v7 = v6;
  if (v6)
  {
    v8 = (const void *)v6[1];
    if (v8)
      CFRelease(v8);
    v7[1] = v5;
  }
  else
  {
    CFRelease(v5);
  }
  return v7;
}

void sub_100116680(uint64_t a1, uint64_t a2)
{
  int v4;
  NSObject *v5;
  uint64_t v6;
  const void *v7;
  const void **v8;
  const void *v9;
  const void **v10;
  const __CFData *v11;
  uint64_t v12;
  int v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  const void *v17;
  CFTypeRef cf;
  unsigned __int8 v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  uint64_t v23;

  v19 = 0;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = sub_1001169E8((__CFString *)a2, &v19, *(CFErrorRef **)(a1 + 56));
  cf = 0;
  v4 = v19;
  if (!v19)
  {
    if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24))
      return;
    v15 = *(_QWORD *)(a1 + 32);
    if (!v15)
      return;
    (*(void (**)(uint64_t, uint64_t, CFTypeRef *))(v15 + 16))(v15, a2, &cf);
    if (!cf)
      return;
LABEL_8:
    v10 = (const void **)sub_10001E6A8(*(_QWORD **)(a2 + 16), 8, *(__CFString ***)(a1 + 56));
    v11 = (const __CFData *)sub_1000198E0(a2, v10);
    if (v11)
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = sub_10001A56C((uint64_t)cf, v10, v11, (__CFString **)(*(_QWORD *)(*(_QWORD *)(a1 + 48)+ 8)+ 24));
      v12 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
      v13 = *(unsigned __int8 *)(v12 + 24);
      if (!v4 && *(_BYTE *)(v12 + 24))
      {
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = sub_100023550((_QWORD **)cf, (const void *)a2, *(__CFString ***)(a1 + 56));
        v12 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
        v13 = *(unsigned __int8 *)(v12 + 24);
      }
      if (!v13)
      {
        v14 = 0;
LABEL_21:
        *(_BYTE *)(v12 + 24) = v14;
        CFRelease(cf);
        if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24))
        {
          v16 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
          v17 = *(const void **)(v16 + 24);
          if (v17)
          {
            *(_QWORD *)(v16 + 24) = 0;
            CFRelease(v17);
          }
        }
        return;
      }
      v14 = sub_100007BB0((__CFString ***)a2, (CFStringRef **)cf, *(_QWORD *)(a1 + 72), (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24), (uint64_t)&stru_1002DE6E0);
    }
    else
    {
      v14 = sub_100019F20(-26276, (__CFString **)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24), CFSTR("no rowid for %@"), a2);
    }
    v12 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    goto LABEL_21;
  }
  v5 = sub_10000EF14("item");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = *(_QWORD *)(a1 + 64);
    *(_DWORD *)buf = 138478083;
    v21 = a2;
    v22 = 2113;
    v23 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "replacing corrupted item %{private}@ with %{private}@", buf, 0x16u);
  }
  v7 = *(const void **)(a1 + 64);
  cf = v7;
  CFRetain(v7);
  v8 = *(const void ***)(a1 + 56);
  if (v8)
  {
    v9 = *v8;
    if (*v8)
    {
      *v8 = 0;
      CFRelease(v9);
    }
  }
  if (v7)
    goto LABEL_8;
}

uint64_t sub_1001168E0(uint64_t a1, const __CFNull *a2)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t result;

  v3 = *(_QWORD *)(a1 + 48);
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  v5 = *(_DWORD *)(v4 + 24);
  *(_DWORD *)(v4 + 24) = v5 + 1;
  result = sub_100116944(v3, *(sqlite3_stmt **)(a1 + 56), v5, *(_QWORD *)(a1 + 64), a2, *(__CFString ***)(a1 + 72));
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t sub_100116930(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_100116944(uint64_t a1, sqlite3_stmt *a2, int a3, uint64_t a4, const __CFNull *a5, __CFString **a6)
{
  const __CFString *v9;
  const __CFString *v10;
  uint64_t v11;

  if (*(_DWORD *)(a4 + 8) == 8)
    v9 = (const __CFString *)CFNumberCreate(0, kCFNumberSInt64Type, (const void *)(a1 + 72));
  else
    v9 = (const __CFString *)sub_1000108B4(a4, a5, a6);
  v10 = v9;
  if (!v9)
    return 0;
  v11 = sub_100013544(a2, (a3 + 1), v9, (CFTypeRef *)a6);
  CFRelease(v10);
  return v11;
}

BOOL sub_1001169D4(id a1, const SecDbAttr *a2)
{
  return 0;
}

BOOL sub_1001169DC(id a1, const SecDbAttr *a2)
{
  return a2->var2 & 1;
}

uint64_t sub_1001169E8(__CFString *a1, _BYTE *a2, CFErrorRef *a3)
{
  const void **v6;
  const __CFData *v7;
  const __CFData *v8;
  CFTypeRef v9;
  uint64_t v10;
  const void *v11;
  const void *v12;
  CFTypeID v13;
  CFAllocatorRef v14;
  uint64_t v15;
  const __CFString *Protection;
  NSObject *v17;
  int v18;
  NSObject *v19;
  CFTypeRef v20;
  CFDataRef v21;
  const __CFData *v22;
  CFIndex Length;
  __CFString *Mutable;
  const UInt8 *BytePtr;
  CFIndex v26;
  CFIndex v27;
  unsigned int v28;
  CFIndex v29;
  __CFString *v30;
  const UInt8 *v31;
  CFIndex v32;
  CFIndex v33;
  unsigned int v34;
  NSObject *v35;
  const void *v36;
  __CFError *v37;
  CFErrorRef v38;
  uint64_t result;
  char *data;
  uint64_t v41;
  uint64_t *v42;
  const void *v43;
  uint64_t v44;
  NSObject *v45;
  const void *v46;
  NSObject *v47;
  const void *v48;
  NSObject *v49;
  const void *v50;
  CFTypeRef v51;
  int v52;
  _BYTE *v53;
  CFTypeRef cf;
  uint8_t buf[4];
  CFTypeRef v56;
  __int16 v57;
  CFTypeRef v58;
  __int16 v59;
  __CFString *v60;
  __int16 v61;
  __CFString *v62;

  cf = 0;
  v6 = (const void **)sub_10001E6A8((_QWORD *)a1->data, 7, (__CFString **)&cf);
  v7 = (const __CFData *)sub_100019204(a1, (uint64_t)v6, (__CFString **)&cf);
  v8 = v7;
  if (v7)
    CFRetain(v7);
  v9 = cf;
  if (!cf)
  {
    if (sub_1000192F4((uint64_t)a1, 1, (__CFString **)&cf))
    {
LABEL_16:
      v18 = 0;
      goto LABEL_24;
    }
    v9 = cf;
  }
  if (SecErrorGetOSStatus(v9) != -26275)
    goto LABEL_16;
  v10 = sub_10001E6A8((_QWORD *)a1->data, 15, (__CFString **)&cf);
  v11 = sub_100019204(a1, v10, (__CFString **)&cf);
  if (!v11)
    goto LABEL_18;
  v12 = v11;
  v13 = CFGetTypeID(v11);
  if (v13 != CFDataGetTypeID())
    goto LABEL_18;
  v14 = CFGetAllocator(a1);
  v15 = SecAccessControlCreateFromData(v14, v12, &cf);
  if (!v15)
    goto LABEL_18;
  Protection = (const __CFString *)SecAccessControlGetProtection(v15);
  if (!Protection || !kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly)
  {
    if (Protection == kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly)
      goto LABEL_13;
LABEL_18:
    v19 = sub_10000EF14("SecError");
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412547;
      v56 = cf;
      v57 = 2113;
      v58 = a1;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "error %@ reading item %{private}@ (corrupted)", buf, 0x16u);
    }
    sub_10003429C(CFSTR("Corrupted item found in keychain"), 0x53C00002u);
    v18 = 0;
    goto LABEL_21;
  }
  if (!CFEqual(Protection, kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly))
    goto LABEL_18;
LABEL_13:
  v17 = sub_10000EF14("SecWarning");
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138478083;
    v56 = a1;
    v57 = 2112;
    v58 = cf;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "cannot decrypt item %{private}@, item is irrecoverably lost with older passcode (error %@)", buf, 0x16u);
  }
  v18 = 1;
LABEL_21:
  v20 = cf;
  if (cf)
  {
    cf = 0;
    CFRelease(v20);
  }
  *a2 = 1;
LABEL_24:
  v21 = sub_1000199CC(a1, (uint64_t)v6);
  v22 = v21;
  if (v8 && v21 && !CFEqual(v8, v21))
  {
    v52 = v18;
    v53 = a2;
    Length = CFDataGetLength(v8);
    Mutable = CFStringCreateMutable(kCFAllocatorDefault, 2 * Length);
    BytePtr = CFDataGetBytePtr(v8);
    v26 = CFDataGetLength(v8);
    if (v26 >= 1)
    {
      v27 = v26;
      do
      {
        v28 = *BytePtr++;
        CFStringAppendFormat(Mutable, 0, CFSTR("%02X"), v28);
        --v27;
      }
      while (v27);
    }
    v29 = CFDataGetLength(v22);
    v30 = CFStringCreateMutable(kCFAllocatorDefault, 2 * v29);
    v31 = CFDataGetBytePtr(v22);
    v32 = CFDataGetLength(v22);
    if (v32 >= 1)
    {
      v33 = v32;
      do
      {
        v34 = *v31++;
        CFStringAppendFormat(v30, 0, CFSTR("%02X"), v34);
        --v33;
      }
      while (v33);
    }
    v35 = sub_10000EF14("SecError");
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      v36 = *v6;
      *(_DWORD *)buf = 138413059;
      v56 = v36;
      v57 = 2112;
      v58 = Mutable;
      v59 = 2112;
      v60 = v30;
      v61 = 2113;
      v62 = a1;
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "error %@ %@ != %@ item %{private}@ (corrupted)", buf, 0x2Au);
    }
    v18 = v52;
    if (Mutable)
      CFRelease(Mutable);
    a2 = v53;
    if (v30)
      CFRelease(v30);
    *v53 = 1;
  }
  if (!cf)
  {
    data = a1->data;
    v41 = *((_QWORD *)data + 2);
    if (v41)
    {
      v42 = (uint64_t *)(data + 24);
      do
      {
        if ((*(_WORD *)(v41 + 16) & 0x2080) != 0)
        {
          v43 = sub_100019204(a1, v41, (__CFString **)&cf);
          if (!v43)
          {
            if (SecErrorGetOSStatus(cf) == -26275)
            {
              if (v18)
              {
                v45 = sub_10000EF14("SecWarning");
                if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
                {
                  v46 = *(const void **)v41;
                  *(_DWORD *)buf = 138412803;
                  v56 = v46;
                  v57 = 2112;
                  v58 = cf;
                  v59 = 2113;
                  v60 = a1;
                  _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "attribute %@: %@ item %{private}@ (item lost with older passcode)", buf, 0x20u);
                }
              }
              else
              {
                v49 = sub_10000EF14("SecError");
                if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
                {
                  v50 = *(const void **)v41;
                  *(_DWORD *)buf = 138412803;
                  v56 = v50;
                  v57 = 2112;
                  v58 = cf;
                  v59 = 2113;
                  v60 = a1;
                  _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "error attribute %@: %@ item %{private}@ (corrupted)", buf, 0x20u);
                }
                sub_10003429C(CFSTR("Corrupted item found in keychain"), 0x53C00002u);
              }
              *a2 = 1;
              v51 = cf;
              if (cf)
              {
                cf = 0;
                CFRelease(v51);
              }
            }
            break;
          }
          if (CFEqual(kCFNull, v43) && (*(_BYTE *)(v41 + 17) & 0x10) != 0)
          {
            v47 = sub_10000EF14("SecError");
            if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
            {
              v48 = *(const void **)v41;
              *(_DWORD *)buf = 138412547;
              v56 = v48;
              v57 = 2113;
              v58 = a1;
              _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "error attribute %@ has NULL value in item %{private}@ (corrupted)", buf, 0x16u);
            }
            sub_10003429C(CFSTR("Corrupted item (attr NULL) found in keychain"), 0x53C00002u);
            *a2 = 1;
            break;
          }
        }
        v44 = *v42++;
        v41 = v44;
      }
      while (v44);
    }
  }
  if (v22)
    CFRelease(v22);
  if (v8)
    CFRelease(v8);
  v37 = (__CFError *)cf;
  if (a3 && cf)
  {
    if (*a3)
    {
      if (CFErrorGetCode(*a3) != -25330)
        goto LABEL_53;
      v38 = *a3;
      if (*a3)
      {
        *a3 = 0;
        CFRelease(v38);
LABEL_53:
        if (*a3)
          goto LABEL_54;
      }
    }
    result = 0;
    *a3 = v37;
    return result;
  }
  if (cf)
  {
    if (!a3)
    {
LABEL_54:
      CFRelease(v37);
      return 0;
    }
    goto LABEL_53;
  }
  return 1;
}

BOOL sub_100117078(id a1, const SecDbAttr *a2)
{
  return a2->var1 == 8;
}

void sub_100117088(uint64_t a1, _QWORD **a2, uint64_t *a3)
{
  const void *v6;
  uint64_t v7;
  __CFString ***v8;
  CFTypeRef *v9;
  const __CFDate *v10;
  const __CFDate *v11;
  const __CFDate *v12;
  BOOL v13;
  __CFString ***v14;
  BOOL v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t **v19;
  uint64_t *v20;
  CFComparisonResult v21;
  uint64_t v22;
  const __CFData *v23;
  uint64_t v24;
  const __CFData *v25;
  const __CFData *v26;
  CFIndex Length;
  CFIndex v28;
  unint64_t v29;
  size_t v30;
  const UInt8 *BytePtr;
  const UInt8 *v32;
  int v33;
  _BOOL4 v34;
  const void *v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t **v38;
  uint64_t *v39;
  NSObject *v40;
  const char *v41;
  NSObject *v42;
  NSObject *v43;
  const void *v44;
  const void *v45;
  NSObject *v46;
  uint64_t v47;
  NSObject *v48;
  unint64_t v49;
  _BYTE cf[24];

  if (sub_10001DA80(a2))
  {
    v6 = *(const void **)(a1 + 32);
    if (v6)
    {
      CFRetain(v6);
      v7 = *(_QWORD *)(a1 + 32);
    }
    else
    {
      v7 = 0;
    }
    *a3 = v7;
    if (!*(_BYTE *)(a1 + 40))
    {
      v17 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16);
      v18 = *(uint64_t **)(v17 + 16);
      if (v18)
      {
        v19 = (uint64_t **)(v17 + 24);
        do
        {
          if (CFEqual((CFTypeRef)*v18, CFSTR("UUID")) || CFEqual((CFTypeRef)*v18, CFSTR("persistref")))
            sub_100115FE0(*(_QWORD *)(a1 + 32), a2, v18);
          v20 = *v19++;
          v18 = v20;
        }
        while (v20);
      }
    }
    return;
  }
  if (!a3 || !*(_BYTE *)(a1 + 41) || *a3)
    return;
  v49 = 0;
  *(_QWORD *)cf = 0;
  v8 = *(__CFString ****)(a1 + 32);
  v9 = sub_100012504(v8[2], kSecAttrModificationDate, (__CFString **)&v49);
  v10 = (const __CFDate *)sub_100019204(v8, (uint64_t)v9, (__CFString **)cf);
  v11 = (const __CFDate *)sub_100019204(a2, (uint64_t)v9, (__CFString **)cf);
  v12 = v11;
  if (v10)
    v13 = v11 == 0;
  else
    v13 = 1;
  if (v13)
  {
    if (SecErrorGetOSStatus(*(_QWORD *)cf) == -26275)
    {
      if (v10)
        v14 = v8;
      else
        v14 = 0;
      v15 = v12 == 0;
      goto LABEL_17;
    }
LABEL_56:
    v16 = 0;
    goto LABEL_57;
  }
  v21 = CFDateCompare(v10, v11, 0);
  v16 = (uint64_t)a2;
  if (v21 == kCFCompareLessThan)
    goto LABEL_57;
  if (v21)
  {
    v16 = 0;
    if (v21 == kCFCompareGreaterThan)
      v16 = (uint64_t)v8;
    goto LABEL_57;
  }
  v22 = sub_10001E6A8(v8[2], 7, (__CFString **)cf);
  v23 = (const __CFData *)sub_100019204(v8, v22, (__CFString **)cf);
  v24 = sub_10001E6A8(a2[2], 7, (__CFString **)cf);
  v25 = (const __CFData *)sub_100019204(a2, v24, (__CFString **)cf);
  v26 = v25;
  if (!v23 || !v25)
  {
    if (SecErrorGetOSStatus(*(_QWORD *)cf) == -26275)
    {
      if (v23)
        v14 = v8;
      else
        v14 = 0;
      v15 = v26 == 0;
LABEL_17:
      if (v15)
        v16 = (uint64_t)v14;
      else
        v16 = (uint64_t)a2;
      goto LABEL_57;
    }
    goto LABEL_56;
  }
  Length = CFDataGetLength(v23);
  v28 = CFDataGetLength(v26);
  v29 = v28;
  if (Length < 0 || v28 < 0)
  {
    v16 = (uint64_t)a2;
    if (Length > v28)
      goto LABEL_57;
    v34 = Length < v28;
  }
  else
  {
    if (Length >= v28)
      v30 = v28;
    else
      v30 = Length;
    BytePtr = CFDataGetBytePtr(v23);
    v32 = CFDataGetBytePtr(v26);
    v33 = memcmp(BytePtr, v32, v30);
    v16 = (uint64_t)a2;
    if (v33 > 0)
      goto LABEL_57;
    if (!v33)
    {
      v16 = (uint64_t)a2;
      if (Length > v29)
        goto LABEL_57;
    }
    v34 = v33 == 0;
    if (Length >= v29)
      v34 = 0;
    if (v33 < 0)
      v34 = 1;
  }
  v16 = (uint64_t)v8;
  if (!v34)
    v16 = (uint64_t)a2;
LABEL_57:
  v35 = *(const void **)cf;
  if (!*(_QWORD *)cf)
    goto LABEL_61;
  if (v16 | v49)
  {
    *(_QWORD *)cf = 0;
    CFRelease(v35);
LABEL_61:
    if (!v16)
      goto LABEL_72;
    v36 = *(_QWORD *)(v16 + 16);
    v37 = *(uint64_t **)(v36 + 16);
    if (v37)
    {
      v38 = (uint64_t **)(v36 + 24);
      do
      {
        if (*v37 && CFEqual((CFTypeRef)*v37, CFSTR("persistref")))
          sub_100115FE0(v16, v8, v37);
        v39 = *v38++;
        v37 = v39;
      }
      while (v39);
    }
    CFRetain((CFTypeRef)v16);
    CFRetain((CFTypeRef)v16);
    *a3 = v16;
    if (a2 && CFEqual((CFTypeRef)v16, a2))
    {
      v40 = sub_10000EF14("insert");
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)cf = 138477827;
        *(_QWORD *)&cf[4] = a2;
        v41 = "Conflict resolver chose my (local) item: %{private}@";
LABEL_85:
        v48 = v40;
        goto LABEL_86;
      }
    }
    else
    {
      v45 = *(const void **)(a1 + 32);
      if (v45 && CFEqual((CFTypeRef)v16, v45))
      {
        v46 = sub_10000EF14("insert");
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
        {
          v47 = *(_QWORD *)(a1 + 32);
          *(_DWORD *)cf = 138477827;
          *(_QWORD *)&cf[4] = v47;
          v41 = "Conflict resolver chose item from the backup: %{private}@";
          v48 = v46;
LABEL_86:
          _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, v41, cf, 0xCu);
        }
      }
      else
      {
        v40 = sub_10000EF14("insert");
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)cf = 138477827;
          *(_QWORD *)&cf[4] = v16;
          v41 = "Conflict resolver created a new item; return it to our caller: %{private}@";
          goto LABEL_85;
        }
      }
    }
    CFRelease((CFTypeRef)v16);
    return;
  }
  v49 = *(_QWORD *)cf;
LABEL_72:
  v42 = sub_10000EF14("SecError");
  if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)cf = 138412290;
    *(_QWORD *)&cf[4] = v49;
    _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "insert: failed to created a merged item: %@", cf, 0xCu);
  }
  v43 = sub_10000EF14("insert");
  if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)cf = 0;
    _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "failed to create a merged item so we will choose the item from the backup", cf, 2u);
  }
  v44 = *(const void **)(a1 + 32);
  if (v44)
    CFRetain(v44);
  *a3 = (uint64_t)v44;
}

BOOL sub_1001175B8(id a1, const SecDbAttr *a2)
{
  return a2->var1 == 8;
}

void sub_1001175C8(uint64_t a1, __CFString *a2)
{
  char v4;
  int v5;
  int v6;
  BOOL v7;
  BOOL v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  const void *v12;
  unsigned __int8 v13;

  v13 = 0;
  v4 = sub_1001169E8(a2, &v13, *(CFErrorRef **)(a1 + 48));
  v5 = 0;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v4;
  v6 = v13;
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    v7 = v13 == 0;
  else
    v7 = 0;
  if (v7)
  {
    if (sub_10001DA80(a2))
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = sub_100023550(*(_QWORD ***)(a1 + 56), a2, *(__CFString ***)(a1 + 48));
      v5 = 1;
    }
    else
    {
      v5 = 0;
    }
  }
  if (v6)
    v5 = 1;
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    v8 = v5 == 0;
  else
    v8 = 1;
  if (!v8)
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = sub_10000C25C(*(CFStringRef ***)(a1 + 64), *(_QWORD *)(a1 + 72), *(CFTypeRef **)(a1 + 48), (uint64_t)&stru_1002DE850);
    v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    if (*(_BYTE *)(v9 + 24))
    {
      v10 = sub_100007BB0((__CFString ***)a2, *(CFStringRef ***)(a1 + 56), *(_QWORD *)(a1 + 72), *(CFTypeRef **)(a1 + 48), (uint64_t)&stru_1002DE890);
      v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    }
    else
    {
      v10 = 0;
    }
    *(_BYTE *)(v9 + 24) = v10;
    v11 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v12 = *(const void **)(v11 + 24);
    if (v12)
    {
      *(_QWORD *)(v11 + 24) = 0;
      CFRelease(v12);
    }
  }
}

const void *sub_10011770C(uint64_t a1, const __CFData *a2, int a3, __CFString **a4)
{
  const __CFAllocator *v8;
  const void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *i;
  unsigned int v13;
  uint64_t v14;
  _QWORD *v15;
  const __CFData *v16;
  uint64_t v17;
  BOOL v18;
  const __CFData *v19;
  const __CFData *v20;
  uint64_t v21;

  v8 = CFGetAllocator((CFTypeRef)a1);
  v9 = (const void *)sub_10001E8EC(v8, *(_QWORD *)(a1 + 16), *(_DWORD *)(a1 + 28), *(_QWORD *)(a1 + 32));
  v10 = *(_QWORD *)(a1 + 16);
  v11 = *(_QWORD *)(v10 + 16);
  if (!v11)
    return v9;
  for (i = (uint64_t *)(v10 + 24); ; ++i)
  {
    v13 = *(_DWORD *)(v11 + 8);
    if (v13 == 12)
    {
      v14 = (uint64_t)v9;
      v15 = (_QWORD *)v11;
      v16 = kCFBooleanTrue;
LABEL_13:
      if ((sub_10001A56C(v14, v15, v16, a4) & 1) == 0)
        break;
      goto LABEL_14;
    }
    v17 = *(_QWORD *)(v11 + 16);
    if ((v17 & 1) != 0 || (v13 <= 0xE ? (v18 = ((1 << v13) & 0x4120) == 0) : (v18 = 1), !v18 || (v17 & 0x2000) != 0))
    {
      v19 = (const __CFData *)sub_100019204((const void *)a1, v11, a4);
      if (!v19)
        break;
      v20 = v19;
      if (CFEqual(kCFNull, v19))
        goto LABEL_14;
      v14 = (uint64_t)v9;
      v15 = (_QWORD *)v11;
      v16 = v20;
      goto LABEL_13;
    }
    if (v13 != 6)
    {
      if (a2 && v13 == 13)
        sub_10001A56C((uint64_t)v9, (_QWORD *)v11, a2, a4);
      goto LABEL_14;
    }
    if (a3)
      sub_100115FE0((uint64_t)v9, (const void *)a1, (uint64_t *)v11);
    if ((sub_100004988(v9, (const void *)a1, (_QWORD *)v11, a4) & 1) == 0)
      break;
LABEL_14:
    v21 = *i;
    v11 = v21;
    if (!v21)
      return v9;
  }
  if (v9)
  {
    CFRelease(v9);
    return 0;
  }
  return v9;
}

BOOL sub_1001178AC(id a1, const SecDbAttr *a2)
{
  return a2->var2 & 1;
}

BOOL sub_1001178B8(id a1, const SecDbAttr *a2)
{
  return a2->var1 == 8;
}

BOOL sub_1001178C8(id a1, const SecDbAttr *a2)
{
  return a2->var1 == 8;
}

BOOL sub_1001178D8(id a1, const SecDbAttr *a2)
{
  return a2->var1 == 8;
}

void sub_100117DFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id location)
{
  id *v24;

  objc_destroyWeak(v24);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100117F00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1001189C0(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_100118E44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100118FB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1001195E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id location)
{
  id *v22;

  objc_destroyWeak(v22);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100119D78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10011A2B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10011A59C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
  id *v19;

  objc_destroyWeak(v19);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10011AD08(uint64_t a1, void *a2)
{
  void *v3;
  id v4;
  void *v5;
  const void *v6;
  NSObject *v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  void *v11;
  const __CFString *v12;
  uint64_t v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  uint8_t buf[4];
  uint64_t v19;
  __int16 v20;
  const __CFString *v21;

  v3 = *(void **)(a1 + 32);
  v4 = a2;
  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "name"));
  v6 = sub_10000EF90((const __CFString *)+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@-%@"), v5, CFSTR("state-rpc")));
  v7 = objc_claimAutoreleasedReturnValue(v6);

  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    v8 = *(_QWORD *)(a1 + 40);
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "result"));
    v10 = objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "error"));
    v11 = (void *)v10;
    v12 = CFSTR("no error");
    if (v10)
      v12 = (const __CFString *)v10;
    *(_DWORD *)buf = 138412546;
    v19 = v8;
    v20 = 2112;
    v21 = v12;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Returning '%@' result: %@", buf, 0x16u);

  }
  v13 = *(_QWORD *)(a1 + 56);
  if (v13)
  {
    v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "result"));
    v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "error"));
    (*(void (**)(uint64_t, void *))(v13 + 16))(v13, v15);

  }
  v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "result"));
  v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "error"));
  objc_msgSend(v4, "setError:", v17);

}

void sub_10011AEB0(uint64_t a1)
{
  id WeakRetained;
  void *v3;
  const void *v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  const __CFString *v9;
  uint64_t v10;
  void *v11;
  uint8_t buf[4];
  uint64_t v13;
  __int16 v14;
  const __CFString *v15;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "name"));
  v4 = sub_10000EF90((const __CFString *)+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@-%@"), v3, CFSTR("state-rpc")));
  v5 = objc_claimAutoreleasedReturnValue(v4);

  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = *(_QWORD *)(a1 + 32);
    v7 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "error"));
    v8 = (void *)v7;
    v9 = CFSTR("no error");
    if (v7)
      v9 = (const __CFString *)v7;
    *(_DWORD *)buf = 138412546;
    v13 = v6;
    v14 = 2112;
    v15 = v9;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Returning '%@' result: %@", buf, 0x16u);

  }
  v10 = *(_QWORD *)(a1 + 48);
  v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "error"));
  (*(void (**)(uint64_t, void *))(v10 + 16))(v10, v11);

}

void sub_10011AFFC(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v2 = *(void **)(a1 + 32);
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "currentState"));
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "timeoutErrorForState:", v3));
  objc_msgSend(v2, "onqueueHandleStartTimeout:", v4);

}

id sub_10011B070(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "_onqueueRegisterMultiStateArrivalWatcher:startTimeout:", *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48));
}

void sub_10011B080(uint64_t a1)
{
  void *v2;
  dispatch_time_t v3;
  NSObject *v4;
  _QWORD block[4];
  id v6;
  id v7;
  id location;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "stateMachineWatchers"));
  objc_msgSend(v2, "addObject:", *(_QWORD *)(a1 + 40));

  objc_msgSend(*(id *)(a1 + 32), "_onqueuePokeStateMachine");
  if ((unint64_t)(*(_QWORD *)(a1 + 48) + 1) >= 2)
  {
    location = (id)0xAAAAAAAAAAAAAAAALL;
    objc_initWeak(&location, *(id *)(a1 + 32));
    v3 = dispatch_time(0, *(_QWORD *)(a1 + 48));
    v4 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "queue"));
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10011B1A0;
    block[3] = &unk_1002EA8C8;
    objc_copyWeak(&v7, &location);
    v6 = *(id *)(a1 + 40);
    dispatch_after(v3, v4, block);

    objc_destroyWeak(&v7);
    objc_destroyWeak(&location);
  }
}

void sub_10011B18C(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_destroyWeak((id *)(v1 - 40));
  _Unwind_Resume(a1);
}

void sub_10011B1A0(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v2 = *(void **)(a1 + 32);
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "currentState"));
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "timeoutErrorForState:", v3));
  objc_msgSend(v2, "onqueueHandleStartTimeout:", v4);

}

void sub_10011B214(uint64_t a1)
{
  void *v2;
  dispatch_time_t v3;
  NSObject *v4;
  _QWORD block[4];
  id v6;
  id v7;
  id location;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "stateMachineRequests"));
  objc_msgSend(v2, "addObject:", *(_QWORD *)(a1 + 40));

  objc_msgSend(*(id *)(a1 + 32), "_onqueuePokeStateMachine");
  if ((unint64_t)(*(_QWORD *)(a1 + 48) + 1) >= 2)
  {
    location = (id)0xAAAAAAAAAAAAAAAALL;
    objc_initWeak(&location, *(id *)(a1 + 32));
    v3 = dispatch_time(0, *(_QWORD *)(a1 + 48));
    v4 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "queue"));
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10011B334;
    block[3] = &unk_1002EA8C8;
    objc_copyWeak(&v7, &location);
    v6 = *(id *)(a1 + 40);
    dispatch_after(v3, v4, block);

    objc_destroyWeak(&v7);
    objc_destroyWeak(&location);
  }
}

void sub_10011B320(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_destroyWeak((id *)(v1 - 40));
  _Unwind_Resume(a1);
}

void sub_10011B334(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v2 = *(void **)(a1 + 32);
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "currentState"));
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "timeoutErrorForState:", v3));
  objc_msgSend(v2, "onqueueHandleStartTimeout:", v4);

}

id sub_10011B3A8(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "holdStateMachineOperation"));

  if (v2)
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "operationQueue"));
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "holdStateMachineOperation"));
    objc_msgSend(v3, "addOperation:", v4);

    objc_msgSend(*(id *)(a1 + 32), "setHoldStateMachineOperation:", 0);
  }
  objc_msgSend(*(id *)(a1 + 32), "setHalted:", 1);
  objc_msgSend(*(id *)(a1 + 32), "setAllowPendingFlags:", 0);
  return objc_msgSend(*(id *)(a1 + 32), "_onqueuePokeStateMachine");
}

void sub_10011B440(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "holdStateMachineOperation"));

  if (v2)
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "operationQueue"));
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "holdStateMachineOperation"));
    objc_msgSend(v3, "addOperation:", v4);

    objc_msgSend(*(id *)(a1 + 32), "setHoldStateMachineOperation:", 0);
  }
}

void sub_10011B4C8(uint64_t a1)
{
  void *v2;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "nextStateMachineCycleOperation"));
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v2 == 0;

}

id sub_10011B504(uint64_t a1)
{
  void *v2;
  const void *v3;
  NSObject *v4;
  uint64_t v5;
  void *v6;
  uint8_t buf[4];
  uint64_t v9;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "name"));
  v3 = sub_10000EF90((const __CFString *)+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@-%@"), v2, CFSTR("test")));
  v4 = objc_claimAutoreleasedReturnValue(v3);

  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *(_QWORD *)(a1 + 40);
    *(_DWORD *)buf = 138412290;
    v9 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Releasing state machine test pause from %@", buf, 0xCu);
  }

  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "testHoldStates"));
  objc_msgSend(v6, "removeObject:", *(_QWORD *)(a1 + 40));

  return objc_msgSend(*(id *)(a1 + 32), "_onqueuePokeStateMachine");
}

void sub_10011B610(uint64_t a1)
{
  id v2;

  v2 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "testHoldStates"));
  objc_msgSend(v2, "addObject:", *(_QWORD *)(a1 + 40));

}

void sub_10011B650(uint64_t a1)
{
  id WeakRetained;
  NSObject *v2;
  id v3;
  _QWORD block[5];

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v3 = WeakRetained;
    v2 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "queue"));
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10011B82C;
    block[3] = &unk_1002EC350;
    block[4] = v3;
    dispatch_sync(v2, block);

    WeakRetained = v3;
  }

}

void sub_10011B6D4(uint64_t a1)
{
  id WeakRetained;
  NSObject *v2;
  id v3;
  _QWORD block[5];

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v3 = WeakRetained;
    v2 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "queue"));
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10011B758;
    block[3] = &unk_1002EC350;
    block[4] = v3;
    dispatch_sync(v2, block);

    WeakRetained = v3;
  }

}

id sub_10011B758(uint64_t a1)
{
  void *v2;
  const void *v3;
  NSObject *v4;
  uint8_t buf[16];

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "name"));
  v3 = sub_10000EF90((const __CFString *)+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@-%@"), v2, CFSTR("pending-flag")));
  v4 = objc_claimAutoreleasedReturnValue(v3);

  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Network is reachable", buf, 2u);
  }

  objc_msgSend(*(id *)(a1 + 32), "setConditionChecksInFlight:", (unint64_t)objc_msgSend(*(id *)(a1 + 32), "conditionChecksInFlight") & 0xFFFFFFFFFFFFFFFDLL);
  objc_msgSend(*(id *)(a1 + 32), "_onqueueRecheckConditions");
  return objc_msgSend(*(id *)(a1 + 32), "_onqueueSendAnyPendingFlags");
}

id sub_10011B82C(uint64_t a1)
{
  void *v2;
  const void *v3;
  NSObject *v4;
  uint8_t buf[16];

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "name"));
  v3 = sub_10000EF90((const __CFString *)+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@-%@"), v2, CFSTR("pending-flag")));
  v4 = objc_claimAutoreleasedReturnValue(v3);

  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Unlock occurred", buf, 2u);
  }

  objc_msgSend(*(id *)(a1 + 32), "setConditionChecksInFlight:", (unint64_t)objc_msgSend(*(id *)(a1 + 32), "conditionChecksInFlight") & 0xFFFFFFFFFFFFFFFELL);
  objc_msgSend(*(id *)(a1 + 32), "_onqueueRecheckConditions");
  return objc_msgSend(*(id *)(a1 + 32), "_onqueueSendAnyPendingFlags");
}

uint64_t sub_10011B900(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_10011B910(uint64_t a1)
{

}

void sub_10011B918(uint64_t a1)
{
  void *v2;
  void *v3;
  id v4;
  id v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  void *v9;
  void *v10;
  void *v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _BYTE v16[128];

  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "pendingFlags", 0));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "allKeys"));

  v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
  if (v4)
  {
    v5 = v4;
    v6 = *(_QWORD *)v13;
    do
    {
      v7 = 0;
      do
      {
        if (*(_QWORD *)v13 != v6)
          objc_enumerationMutation(v3);
        v8 = *(_QWORD *)(*((_QWORD *)&v12 + 1) + 8 * (_QWORD)v7);
        v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "pendingFlags"));
        v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "objectForKeyedSubscript:", v8));
        v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "description"));
        objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), "setObject:forKeyedSubscript:", v11, v8);

        v7 = (char *)v7 + 1;
      }
      while (v5 != v7);
      v5 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
    }
    while (v5);
  }

}

id sub_10011BA78(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "setAllowPendingFlags:", 0);
}

void sub_10011BA84(uint64_t a1)
{
  NSObject *v1;
  id WeakRetained;
  _QWORD block[5];

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v1 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "queue"));
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10011BB04;
  block[3] = &unk_1002EC350;
  block[4] = WeakRetained;
  dispatch_sync(v1, block);

}

id sub_10011BB04(uint64_t a1)
{
  void *v2;
  const void *v3;
  NSObject *v4;
  uint8_t buf[16];

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "name"));
  v3 = sub_10000EF90((const __CFString *)+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@-%@"), v2, CFSTR("pending-flag")));
  v4 = objc_claimAutoreleasedReturnValue(v3);

  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Finished waiting for operation", buf, 2u);
  }

  return objc_msgSend(*(id *)(a1 + 32), "_onqueueSendAnyPendingFlags");
}

id sub_10011BBB8(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "_onqueueHandlePendingFlag:", *(_QWORD *)(a1 + 40));
}

id sub_10011BBC4(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "_onqueueHandlePendingFlag:", *(_QWORD *)(a1 + 40));
}

id sub_10011BBD0(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "_onqueueHandleFlag:", *(_QWORD *)(a1 + 40));
}

id sub_10011BBDC(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "_onqueuePokeStateMachine");
}

void sub_10011BBE4(uint64_t a1)
{
  NSObject *v2;
  id WeakRetained;
  _QWORD block[5];
  id v5;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v2 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "queue"));
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10011BC7C;
  block[3] = &unk_1002E9728;
  block[4] = WeakRetained;
  v5 = *(id *)(a1 + 32);
  dispatch_sync(v2, block);

}

id sub_10011BC7C(uint64_t a1)
{
  void *v2;
  const void *v3;
  NSObject *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  uint64_t v11;
  void *v12;
  const __CFString *v13;
  void *v14;
  id v15;
  id v16;
  uint64_t v17;
  void *i;
  void *v19;
  void *v20;
  const void *v21;
  NSObject *v22;
  void *v23;
  char *v24;
  void *v25;
  void *v26;
  void *v27;
  unsigned int v28;
  void *v29;
  void *v30;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint8_t v36[128];
  uint8_t buf[4];
  void *v38;
  __int16 v39;
  void *v40;
  __int16 v41;
  void *v42;
  __int16 v43;
  void *v44;
  __int16 v45;
  void *v46;
  __int16 v47;
  const __CFString *v48;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "name"));
  v3 = sub_10000EF90((const __CFString *)+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@-%@"), v2, CFSTR("state")));
  v4 = objc_claimAutoreleasedReturnValue(v3);

  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "nextState"));
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "intendedState"));
    v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "currentFlags"));
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "contentsAsString"));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "pendingFlagsString"));
    v10 = *(void **)(a1 + 40);
    v11 = objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "error"));
    v12 = (void *)v11;
    *(_DWORD *)buf = 138413570;
    v13 = CFSTR("(no error)");
    v38 = v5;
    if (v11)
      v13 = (const __CFString *)v11;
    v39 = 2112;
    v40 = v6;
    v41 = 2112;
    v42 = v8;
    v43 = 2112;
    v44 = v9;
    v45 = 2112;
    v46 = v10;
    v47 = 2112;
    v48 = v13;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Finishing state transition attempt (ending in %@, intended: %@, f:[%@], p:[%@]): %@ %@", buf, 0x3Eu);

  }
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "stateMachineWatchers"));
  v15 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v32, v36, 16);
  if (v15)
  {
    v16 = v15;
    v17 = *(_QWORD *)v33;
    do
    {
      for (i = 0; i != v16; i = (char *)i + 1)
      {
        if (*(_QWORD *)v33 != v17)
          objc_enumerationMutation(v14);
        v19 = *(void **)(*((_QWORD *)&v32 + 1) + 8 * (_QWORD)i);
        v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "name"));
        v21 = sub_10000EF90((const __CFString *)+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@-%@"), v20, CFSTR("state")));
        v22 = objc_claimAutoreleasedReturnValue(v21);

        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          v38 = v19;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "notifying watcher: %@", buf, 0xCu);
        }

        objc_msgSend(v19, "onqueueHandleTransition:", *(_QWORD *)(a1 + 40));
      }
      v16 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v32, v36, 16);
    }
    while (v16);
  }

  v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "stateMachineWatchers"));
  v24 = (char *)objc_msgSend(v23, "count");

  if ((uint64_t)(v24 - 1) >= 0)
  {
    do
    {
      --v24;
      v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "stateMachineWatchers"));
      v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v25, "objectAtIndexedSubscript:", v24));
      v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "result"));
      v28 = objc_msgSend(v27, "isFinished");

      if (v28)
      {
        v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "stateMachineWatchers"));
        objc_msgSend(v29, "removeObjectAtIndex:", v24);

      }
    }
    while ((uint64_t)v24 > 0);
  }
  v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "nextState"));
  objc_msgSend(*(id *)(a1 + 32), "setCurrentState:", v30);

  objc_msgSend(*(id *)(a1 + 32), "setNextStateMachineCycleOperation:", 0);
  return objc_msgSend(*(id *)(a1 + 32), "_onqueueStartNextStateMachineOperation:", 1);
}

void sub_10011C02C(uint64_t a1)
{
  id v2;
  uint64_t v3;
  void *v4;
  id v5;

  v5 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "mutableStateConditions"));
  v2 = objc_msgSend(v5, "copy");
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  v4 = *(void **)(v3 + 40);
  *(_QWORD *)(v3 + 40) = v2;

}

void sub_10011C07C(uint64_t a1)
{
  id WeakRetained;
  NSObject *v2;
  id v3;
  _QWORD block[4];
  id v5;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v2 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "queue"));
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10011C108;
  block[3] = &unk_1002EC350;
  v5 = WeakRetained;
  v3 = WeakRetained;
  dispatch_sync(v2, block);

}

id sub_10011C108(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "_onqueueSendAnyPendingFlags");
}

BOOL sub_10011C114(const __CFData *a1, uint64_t a2, const __CFData *a3, __CFData *a4, const __CFDictionary *a5, __CFData **a6, int a7, char a8, CFTypeRef *a9)
{
  __int128 v16;
  __CFData *Mutable;
  uint64_t Constraints;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  const __CFData *v24;
  const __CFData *v25;
  CFMutableDictionaryRef MutableCopy;
  __CFDictionary *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  CFTypeID v31;
  CFTypeID TypeID;
  __CFData *v33;
  CFIndex Length;
  _BOOL8 v35;
  __CFData *v36;
  __CFData *v37;
  const void *Protection;
  uint64_t v40;
  const void *v41;
  __CFDictionary *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  const void *v46;
  CFIndex v47;
  const UInt8 *v48;
  int v49;
  uint64_t v50;
  const UInt8 *v51;
  char v52;
  unsigned int v53;
  const __CFString *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  CFIndex v58;
  UInt8 *MutableBytePtr;
  UInt8 *v60;
  unsigned int v61;
  uint64_t v62;
  CFIndex v63;
  __CFData *v64;
  size_t v65;
  UInt8 *v66;
  unsigned int v67;
  UInt8 *v68;
  UInt8 *v69;
  _BYTE *v70;
  UInt8 *v71;
  void *v72;
  uint64_t v73;
  const UInt8 *v74;
  const UInt8 *v75;
  uint64_t v76;
  const __CFData *v77;
  const UInt8 *BytePtr;
  uint64_t v79;
  CFIndex v80;
  CFDataRef theData;
  const __CFData *theDataa;
  unsigned int v83;
  int64_t v85;
  __CFData **v86;
  int v87;
  uint64_t v88;
  _QWORD context[5];
  CFIndex v90;
  void **v91;
  CFIndex v92;
  uint64_t v93;
  void *v94;
  void *v95;
  _OWORD bytes[2];
  CFRange v97;

  *(_QWORD *)&v16 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
  bytes[0] = v16;
  bytes[1] = v16;
  Mutable = CFDataCreateMutable(0, 0);
  CFDataSetLength(Mutable, 72);
  Constraints = SecAccessControlGetConstraints(a2);
  v22 = Constraints;
  if (Constraints)
    v23 = 6;
  else
    v23 = 3;
  v86 = a6;
  if (!Constraints)
  {
    v24 = a3;
    v25 = a1;
    v83 = v23;
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, a4);
    v27 = MutableCopy;
    if (a5)
    {
      context[0] = _NSConcreteStackBlock;
      context[1] = 3221225472;
      context[2] = sub_10011C8D0;
      context[3] = &unk_1002ECD08;
      context[4] = MutableCopy;
      CFDictionaryApplyFunction(a5, (CFDictionaryApplierFunction)sub_10011C8D8, context);
    }
    if (v27)
    {
      CFDictionaryRemoveValue(v27, kSecAttrAccessControl);
      a4 = sub_10001A474((const __CFString *)v27, a9, v28, v29, v30);
      CFRelease(v27);
      a1 = v25;
      a3 = v24;
      v22 = 0;
      if (a4)
        goto LABEL_12;
    }
    else
    {
      a4 = 0;
    }
LABEL_17:
    LOBYTE(v33) = 1;
LABEL_18:
    v35 = sub_100019F20(-50, (__CFString **)a9, CFSTR("ks_encrypt_data: invalid plain text"));
    goto LABEL_19;
  }
  if (!a4)
    goto LABEL_17;
  v83 = v23;
  a4 = sub_10001A474((const __CFString *)a4, a9, v19, v20, v21);
  if (!a4)
    goto LABEL_17;
LABEL_12:
  theData = a1;
  v31 = CFGetTypeID(a4);
  TypeID = CFDataGetTypeID();
  LOBYTE(v33) = 0;
  if (!a2 || v31 != TypeID)
    goto LABEL_18;
  Length = CFDataGetLength(a4);
  v88 = 16;
  v87 = 0;
  if (SecRandomCopyBytes(kSecRandomDefault, 0x20uLL, bytes))
  {
    v35 = sub_100019F20(-108, (__CFString **)a9, CFSTR("ks_encrypt_data: SecRandomCopyBytes failed"));
    LOBYTE(v33) = 0;
LABEL_19:
    v36 = 0;
    goto LABEL_20;
  }
  Protection = (const void *)SecAccessControlGetProtection(a2);
  v40 = sub_10001D720(Protection, (__CFString **)a9);
  if (!(_DWORD)v40)
  {
    LOBYTE(v33) = 0;
    v36 = 0;
LABEL_74:
    v35 = 1;
    goto LABEL_20;
  }
  v80 = Length;
  if (v22)
  {
    v79 = v40;
    v41 = (const void *)SecAccessControlGetConstraints(a2);
    v42 = CFDictionaryCreateMutableCopy(0, 0, a5);
    CFDictionarySetValue(v42, CFSTR("acl"), v41);
    v36 = sub_10001A474((const __CFString *)v42, 0, v43, v44, v45);
    if (v42)
      CFRelease(v42);
    v94 = 0;
    v95 = 0;
    v92 = 0;
    v93 = 0;
    v46 = (const void *)SecAccessControlCopyData(a2);
    v91 = 0;
    if (a3 && (SecAccessControlIsBound(a2) & 1) != 0)
    {
      BytePtr = CFDataGetBytePtr(v36);
      v47 = CFDataGetLength(v36);
      v48 = CFDataGetBytePtr(a3);
      v49 = CFDataGetLength(a3);
      sub_100023C38(0, 0, (uint64_t)BytePtr, v47, (uint64_t)v48, v49, &v95, &v93);
      v50 = sub_1000240CC((int)theData, v79, 0, (uint64_t)v95, v93, &v91);
      if ((_DWORD)v50
        || (v50 = sub_1000242F8((uint64_t)v91, (uint64_t)v95, v93, (uint64_t)bytes, 32, &v94, (size_t *)&v92), (_DWORD)v50))
      {
        sub_1001468B0(v50, CFSTR("oe"), (uint64_t)theData, v79, (uint64_t)v46, a3, (__CFString **)a9);
      }
      else
      {
        v90 = 0xAAAAAAAAAAAAAAAALL;
        v51 = (const UInt8 *)sub_1000252F8((uint64_t *)v91, &v90);
        if (v51)
        {
          if (sub_100146214((UInt8 *)v94, v92, v51, v90, Mutable))
          {
            v52 = 1;
LABEL_45:
            if (v91)
              sub_100024478((uint64_t *)&v91);
            if (v95)
              free(v95);
            if (v94)
              free(v94);
            if (v46)
              CFRelease(v46);
            if ((v52 & 1) != 0)
            {
              v53 = CFDataGetLength(Mutable);
              v54 = (const __CFString *)SecAccessControlGetProtection(a2);
              v58 = sub_1000212A4(v54, 0, v55, v56, v57);
              v33 = CFDataCreateMutable(0, 0);
              CFDataSetLength(v33, v58);
              MutableBytePtr = CFDataGetMutableBytePtr(v33);
              v60 = CFDataGetMutableBytePtr(v33);
              if (sub_100020FA0(v54, 0, 0, MutableBytePtr, (unint64_t)&v60[v58]))
              {
                if (v33)
                {
                  theDataa = v33;
                  v61 = CFDataGetLength(v33);
                  v62 = v61 + 28;
                  Length = v80;
                  goto LABEL_59;
                }
              }
              else
              {
                CFRelease(v33);
                LOBYTE(v33) = 0;
              }
              goto LABEL_74;
            }
            LOBYTE(v33) = 0;
LABEL_84:
            v35 = 0;
LABEL_20:
            memset_s(bytes, 0x20uLL, 0, 0x20uLL);
            v37 = 0;
            if (!Mutable)
              goto LABEL_22;
            goto LABEL_21;
          }
          sub_100019F20(-26275, (__CFString **)a9, CFSTR("ks_crypt_acl: %x failed to '%s' item (class %d, bag: %d) Item can't be encrypted due to merge failed, so drop the item."), 0, "encrypt", v79, theData);
        }
        else
        {
          sub_100019F20(-26275, (__CFString **)a9, CFSTR("ks_crypt_acl: %x failed to '%s' item (class %d, bag: %d) Item can't be encrypted due to invalid key data, so drop the item."), 0, "encrypt", v79, theData);
        }
      }
    }
    else
    {
      SecAccessControlIsBound(a2);
      sub_100146644((CFErrorRef *)a9, (uint64_t)v46);
    }
    v52 = 0;
    goto LABEL_45;
  }
  if (!sub_10001567C(CFSTR("oe"), (uint64_t)theData, 0, v40, 0x20u, bytes, &v87, Mutable, a8, (__CFString **)a9))
  {
    LOBYTE(v33) = 0;
    v36 = 0;
    goto LABEL_84;
  }
  v53 = CFDataGetLength(Mutable);
  v36 = 0;
  v61 = 0;
  theDataa = 0;
  v62 = 28;
LABEL_59:
  v63 = v62 + Length + v53;
  v64 = CFDataCreateMutable(0, v63);
  v37 = v64;
  if (!v64)
  {
    v35 = 1;
    goto LABEL_70;
  }
  v65 = v53;
  CFDataSetLength(v64, v63);
  v66 = CFDataGetMutableBytePtr(v37);
  v67 = v83 | 0x80000000;
  if (!a7)
    v67 = v83;
  *(_DWORD *)v66 = v67;
  if (v22)
  {
    *((_DWORD *)v66 + 1) = v61;
    v68 = v66 + 8;
    v97.length = v61;
    v97.location = 0;
    CFDataGetBytes(theDataa, v97, v66 + 8);
    v69 = &v68[v61];
  }
  else
  {
    *((_DWORD *)v66 + 1) = v87;
    v69 = v66 + 8;
  }
  *(_DWORD *)v69 = v53;
  v70 = v69 + 4;
  if (a7)
  {
    v71 = CFDataGetMutableBytePtr(v37);
    v85 = v70 - v71;
    v72 = &unk_100249570;
    v73 = 12;
  }
  else
  {
    v71 = 0;
    v85 = 0;
    v72 = 0;
    v73 = 0;
  }
  v74 = CFDataGetBytePtr(Mutable);
  memcpy(v70, v74, v65);
  v75 = CFDataGetBytePtr(a4);
  v76 = CCCryptorGCM(0, 0, bytes, 32, v72, v73, v71, v85, v75, v80, &v70[v65], &v70[v65 + v80], &v88);
  if ((_DWORD)v76)
  {
    v35 = sub_100019F20(-26276, (__CFString **)a9, CFSTR("ks_encrypt_data: CCCryptorGCM failed: %d"), v76);
LABEL_70:
    v77 = theDataa;
    goto LABEL_76;
  }
  v77 = theDataa;
  v35 = v88 == 16
     || sub_100019F20(-26276, (__CFString **)a9, CFSTR("ks_encrypt_data: CCCryptorGCM expected: 16 got: %ld byte tag"), v88);
LABEL_76:
  memset_s(bytes, 0x20uLL, 0, 0x20uLL);
  if (v77)
    CFRelease(v77);
  LOBYTE(v33) = 0;
  if (Mutable)
LABEL_21:
    CFRelease(Mutable);
LABEL_22:
  if ((v33 & 1) == 0)
    CFRelease(a4);
  if (v35)
  {
    *v86 = v37;
  }
  else if (v37)
  {
    CFRelease(v37);
  }
  if (v36)
    CFRelease(v36);
  return v35;
}

void sub_10011C8D0(uint64_t a1, const void *a2, const void *a3)
{
  CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 32), a2, a3);
}

uint64_t sub_10011C8D8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void sub_10011C8F0(uint64_t a1, const void *a2, const void *a3)
{
  CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 32), a2, a3);
}

void sub_10011C8F8(id a1)
{
  NSObject *v1;
  void *v2;
  NSObject *v3;
  _QWORD *context;

  v1 = sub_1000327DC("non-device keybag", 2);
  v2 = (void *)qword_100341170;
  qword_100341170 = (uint64_t)v1;

  v3 = qword_100341170;
  context = dispatch_get_context((dispatch_object_t)qword_100341170);
  context[2] = _Block_copy(&stru_1002DEB90);
  dispatch_activate(v3);
}

void sub_10011C954(id a1)
{
  const void *v1;
  NSObject *v2;
  uint8_t v3[16];

  v1 = sub_10000EF14("SecWarning");
  v2 = objc_claimAutoreleasedReturnValue(v1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "ks_encrypt_data: called with non-device keybag - call should be rerouted to ks_encrypt_data_legacy", v3, 2u);
  }

}

__CFData *sub_10011C9C0(const __CFString *a1, CFTypeRef *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  CFIndex v7;
  __CFData *Mutable;
  UInt8 *MutableBytePtr;
  UInt8 *v10;

  v7 = sub_1000212A4(a1, a2, a3, a4, a5);
  Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0);
  CFDataSetLength(Mutable, v7);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  v10 = CFDataGetMutableBytePtr(Mutable);
  if (!sub_100020FA0(a1, a2, 0, MutableBytePtr, (unint64_t)&v10[v7]))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

uint64_t sub_10011CA58(uint64_t a1, uint64_t a2, const UInt8 *a3, CFIndex a4, uint64_t a5, unsigned int a6, __CFDictionary **a7, _QWORD *a8, CFTypeRef *a9, __CFString **a10)
{
  CFBooleanRef v17;
  CFDataRef v18;
  const __CFData *v19;
  const UInt8 *BytePtr;
  size_t Length;
  uint64_t v22;
  const UInt8 *v23;
  const __CFDictionary *v24;
  __CFDictionary *MutableCopy;
  uint64_t v26;
  uint64_t *v27;
  const void *Value;
  const void *v29;
  __CFDictionary *Mutable;
  uint64_t v31;
  uint64_t v32;
  const void *v34;
  const void *v35;
  CFTypeID v36;
  uint64_t v37;
  _QWORD *v38;
  CFDictionaryRef theDict;
  uint64_t v41;
  const __CFData *v42;
  CFDataRef theData;
  uint64_t v44;
  CFBooleanRef v45;

  v44 = 0;
  v45 = 0;
  v42 = 0;
  theData = 0;
  sub_100020974(0, &v45, 0, a3, (uint64_t)&a3[a4]);
  v17 = v45;
  if (!v45)
  {
    v18 = 0;
    MutableCopy = 0;
    sub_100019F20(-26275, a10, CFSTR("kc_attribs_key_encrypted_data_from_blob: failed to decode 'blob data'"));
    goto LABEL_52;
  }
  if ((sub_10014658C(v45, (CFTypeRef *)&v42, (CFTypeRef *)&theData) & 1) != 0)
  {
    v18 = v42;
  }
  else
  {
    v18 = CFDataCreate(kCFAllocatorDefault, a3, a4);
    v42 = v18;
    theData = (CFDataRef)CFRetain(v18);
  }
  if (!v18)
  {
    MutableCopy = 0;
    sub_100019F20(-26275, a10, CFSTR("kc_attribs_key_encrypted_data_from_blob: failed to decode 'encrypted data'"));
    goto LABEL_52;
  }
  v19 = theData;
  if (!theData)
  {
    MutableCopy = 0;
    sub_100019F20(-26275, a10, CFSTR("kc_attribs_key_encrypted_data_from_blob: failed to decode 'key data'"));
    goto LABEL_52;
  }
  v41 = 0;
  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(v19);
  v22 = sub_100024528(a1, BytePtr, Length, &v44);
  if ((_DWORD)v22)
  {
    if ((_DWORD)v22 == -536870206)
      sub_100019F20(-26275, a10, CFSTR("aks_ref_key: failed to create ref key with blob because bad data (bag: %d)"), a1);
    else
      sub_100019F20(-26275, a10, CFSTR("aks_ref_key: failed to create ref key with blob: %x (bag: %d)"), v22, a1);
    goto LABEL_24;
  }
  v37 = a5;
  v38 = a8;
  v23 = (const UInt8 *)sub_100025304(v44, &v41);
  if (!v23)
  {
LABEL_24:
    v32 = 0;
    MutableCopy = 0;
    goto LABEL_25;
  }
  theDict = 0;
  sub_100020974(0, &theDict, 0, v23, (uint64_t)&v23[v41]);
  v24 = theDict;
  if (!theDict)
  {
    MutableCopy = 0;
    sub_100019F20(-26275, a10, CFSTR("kc_attribs_key_encrypted_data_from_blob: failed to decode 'encrypted data dictionary'"));
    goto LABEL_52;
  }
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDict);
  v26 = *(_QWORD *)(a2 + 16);
  if (v26)
  {
    v27 = (uint64_t *)(a2 + 24);
    do
    {
      if ((*(_BYTE *)(v26 + 17) & 0x20) != 0)
      {
        CFDictionaryRemoveValue(MutableCopy, *(const void **)v26);
        Value = CFDictionaryGetValue(v24, *(const void **)v26);
        if (Value)
        {
          v29 = Value;
          Mutable = *a7;
          if (!*a7)
          {
            Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            *a7 = Mutable;
          }
          CFDictionaryAddValue(Mutable, *(const void **)v26, v29);
        }
      }
      v31 = *v27++;
      v26 = v31;
    }
    while (v31);
  }
  CFRelease(v24);
  if (MutableCopy)
  {
    if (a6 == 4)
    {
      SecAccessControlSetConstraints(v37, MutableCopy);
LABEL_39:
      if (!SecAccessControlGetConstraint(v37, CFSTR("oe")))
        SecAccessControlAddConstraintForOperation(v37, CFSTR("oe"), kCFBooleanTrue, 0);
      goto LABEL_41;
    }
    v34 = CFDictionaryGetValue(MutableCopy, CFSTR("acl"));
    if (v34)
    {
      v35 = v34;
      v36 = CFGetTypeID(v34);
      if (v36 == CFDictionaryGetTypeID())
      {
        SecAccessControlSetConstraints(v37, v35);
        if (a6 > 5)
          goto LABEL_41;
        goto LABEL_39;
      }
    }
    sub_100019F20(-26275, a10, CFSTR("kc_attribs_key_encrypted_data_from_blob: acl missing"));
LABEL_52:
    v32 = 0;
LABEL_25:
    if (v44)
      sub_100024478(&v44);
    if (v17)
      goto LABEL_28;
    goto LABEL_29;
  }
LABEL_41:
  if (a9)
    *a9 = CFRetain(v18);
  if (!v38)
  {
    v32 = 1;
    goto LABEL_25;
  }
  *v38 = v44;
  v44 = 0;
  v32 = 1;
  if (v17)
LABEL_28:
    CFRelease(v17);
LABEL_29:
  if (theData)
    CFRelease(theData);
  if (v18)
    CFRelease(v18);
  if (MutableCopy)
    CFRelease(MutableCopy);
  return v32;
}

CFTypeRef sub_10011CDF4(CFDataRef data, CFErrorRef *error)
{
  CFPropertyListRef v3;

  v3 = CFPropertyListCreateWithData(0, data, 1uLL, 0, error);
  return sub_10011D460(v3, (__CFString **)error);
}

CFTypeRef sub_10011CE2C(const __CFData *a1, CFTypeRef *a2)
{
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v6;
  unsigned __int8 *v7;
  uint64_t v8;
  CFErrorDomain Domain;
  uint64_t v10;
  CFTypeRef v11;
  CFTypeRef v12;
  CFTypeRef cf;

  cf = 0;
  BytePtr = CFDataGetBytePtr(a1);
  Length = CFDataGetLength(a1);
  v6 = (uint64_t)&BytePtr[Length];
  v7 = sub_100020974(0, (CFBooleanRef *)&cf, a2, BytePtr, (uint64_t)&BytePtr[Length]);
  if (a2 && !v7)
  {
    Domain = CFErrorGetDomain((CFErrorRef)*a2);
    if (!Domain || !CFEqual(Domain, CFSTR("com.apple.security.cfder.error")) || CFErrorGetCode((CFErrorRef)*a2) != -1)
      return sub_10011D460(cf, (__CFString **)a2);
    v11 = *a2;
    if (*a2)
    {
      *a2 = 0;
      CFRelease(v11);
    }
    v7 = sub_10011CF34((CFBooleanRef *)&cf, a2, (unint64_t)BytePtr, v6, v10);
  }
  if (v7)
  {
    if (v7 != (unsigned __int8 *)v6)
    {
      sub_100032660(-26275, kCFErrorDomainOSStatus, 0, a2, v8, CFSTR("trailing garbage at end of decrypted item"));
      v12 = cf;
      if (cf)
      {
        cf = 0;
        CFRelease(v12);
      }
    }
  }
  return sub_10011D460(cf, (__CFString **)a2);
}

void sub_10011CF2C(uint64_t a1, const void *a2, const void *a3)
{
  CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 32), a2, a3);
}

unsigned __int8 *sub_10011CF34(CFBooleanRef *a1, CFTypeRef *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v5;
  uint64_t v9;
  const __CFString *v11;
  uint64_t v12;
  __CFSet *Mutable;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  void *v20;
  uint64_t v21;
  BOOL v22;
  void *v23;
  __CFArray *v25;
  unint64_t v26;
  uint64_t v27;
  void *v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  void *value;
  void *key;
  unint64_t v34;

  v5 = a3;
  if (!a3)
  {
    v11 = CFSTR("Null DER");
LABEL_7:
    sub_100032660(-1, CFSTR("com.apple.security.cfder.error"), 0, a2, a5, v11);
    return (unsigned __int8 *)v5;
  }
  v30 = 0xAAAAAAAAAAAAAAAALL;
  if (!ccder_decode_tag(&v30, a3, a4))
  {
    sub_100032660(-1, CFSTR("com.apple.security.cfder.error"), 0, a2, v9, CFSTR("Unknown data encoding"));
    return 0;
  }
  if (v30 <= 23)
  {
    switch(v30)
    {
      case 1:
        return sub_100021808(a1, a2, v5, a4);
      case 2:
        return (unsigned __int8 *)sub_1000218B0(0, a1, a2, v5, a4);
      case 3:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
        goto LABEL_37;
      case 4:
        return (unsigned __int8 *)sub_100021480(0, a1, a2, v5, a4);
      case 5:
        return (unsigned __int8 *)sub_100032FF4(a1, a2, v5, a4);
      case 12:
        return (unsigned __int8 *)sub_100020DA8(0, (CFStringRef *)a1, a2, v5, a4);
      default:
        if (v30 != 0xC000000000000011)
          goto LABEL_37;
        v34 = 0;
        v5 = ccder_decode_constructed_tl(0xC000000000000011, &v34, v5, a4);
        if (!v5)
        {
          v11 = CFSTR("Unknown data encoding, expected CCDER_CONSTRUCTED_CFSET");
          goto LABEL_7;
        }
        Mutable = CFSetCreateMutable(0, 0, &kCFTypeSetCallBacks);
        if (Mutable)
        {
          v22 = v5 == v34;
          if (v5 < v34)
          {
            do
            {
              key = 0;
              v5 = sub_10011CF34(&key, a2, v5);
              v23 = key;
              if (v5)
                CFSetAddValue(Mutable, key);
              if (v23)
                CFRelease(v23);
            }
            while (v5 && v5 < v34);
            v22 = v5 == v34;
          }
          if (!v22)
          {
            CFRelease(Mutable);
            return (unsigned __int8 *)v5;
          }
        }
        else
        {
          sub_100032660(-3, CFSTR("com.apple.security.cfder.error"), 0, a2, v21, CFSTR("Failed to create set"));
          v5 = 0;
          if (v34)
            return (unsigned __int8 *)v5;
        }
        if (*a1)
          CFRelease(*a1);
        break;
    }
    goto LABEL_74;
  }
  if (v30 == 24)
  {
    v5 = sub_100021A6C(0, a1, a2, v5, a4);
    if (!v5)
      return (unsigned __int8 *)sub_10011D4F0(a1, (CFErrorRef *)a2, a4);
    return (unsigned __int8 *)v5;
  }
  if (v30 == 0x2000000000000010)
  {
    v25 = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
    v34 = 0xAAAAAAAAAAAAAAAALL;
    v26 = ccder_decode_sequence_tl(&v34, v5, a4);
    v5 = v26;
    if (v26 && v26 < v34)
    {
      while (1)
      {
        key = 0;
        v27 = sub_10011CF34(&key, a2, v5);
        if (!v27)
          break;
        v5 = v27;
        v28 = key;
        CFArrayAppendValue(v25, key);
        if (v28)
          CFRelease(v28);
        if (v5 >= v34)
          goto LABEL_54;
      }
    }
    else if (v26)
    {
LABEL_54:
      *a1 = v25;
      return (unsigned __int8 *)v5;
    }
    if (v25)
      CFRelease(v25);
    return 0;
  }
  if (v30 != 0x2000000000000011)
  {
LABEL_37:
    sub_100032660(-2, CFSTR("com.apple.security.cfder.error"), 0, a2, v9, CFSTR("Unsupported DER Type"));
    return 0;
  }
  v31 = 0;
  v5 = ccder_decode_constructed_tl(0x2000000000000011, &v31, v5, a4);
  if (!v5)
  {
    v11 = CFSTR("Unknown data encoding, expected CCDER_CONSTRUCTED_SET");
    goto LABEL_7;
  }
  Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    v14 = v31;
    if (v5 < v31)
    {
      while (1)
      {
        v34 = 0;
        v15 = ccder_decode_constructed_tl(0x2000000000000010, &v34, v5, v14);
        if (!v15)
        {
          sub_100032660(-1, CFSTR("com.apple.security.cfder.error"), 0, a2, v16, CFSTR("Unknown data encoding, expected CCDER_CONSTRUCTED_SEQUENCE"));
          goto LABEL_71;
        }
        value = 0;
        key = 0;
        v17 = sub_10011CF34(&key, a2, v15);
        v18 = sub_10011CF34(&value, a2, v17);
        v19 = key;
        if (!v18)
          break;
        v5 = v18;
        v20 = value;
        CFDictionaryAddValue(Mutable, key, value);
        if (v19)
          CFRelease(v19);
        if (v20)
          CFRelease(v20);
        v14 = v31;
        if (v5 >= v31)
          goto LABEL_72;
      }
      if (key)
        CFRelease(key);
      if (value)
        CFRelease(value);
LABEL_71:
      v5 = 0;
      v14 = v31;
LABEL_72:
      v29 = v5;
      v5 = v14;
      if (v29 == v14)
        goto LABEL_74;
      goto LABEL_73;
    }
    v29 = v5;
    if (v5 != v31)
    {
LABEL_73:
      CFRelease(Mutable);
      return (unsigned __int8 *)v29;
    }
LABEL_74:
    *a1 = Mutable;
    return (unsigned __int8 *)v5;
  }
  sub_100032660(-3, CFSTR("com.apple.security.cfder.error"), 0, a2, v12, CFSTR("Failed to create dictionary"));
  v5 = 0;
  if (!v31)
    goto LABEL_74;
  return (unsigned __int8 *)v5;
}

CFTypeRef sub_10011D460(CFTypeRef cf, __CFString **a2)
{
  CFTypeRef v2;
  CFTypeID v4;
  CFTypeID v5;
  CFStringRef v6;

  v2 = cf;
  if (cf)
  {
    v4 = CFGetTypeID(cf);
    if (v4 != CFDictionaryGetTypeID())
    {
      v5 = CFGetTypeID(v2);
      v6 = CFCopyTypeIDDescription(v5);
      sub_100019F20(-26275, a2, CFSTR("plist is a %@, expecting a dictionary"), v6);
      if (v6)
        CFRelease(v6);
      CFRelease(v2);
      return 0;
    }
  }
  return v2;
}

uint64_t sub_10011D4F0(CFDateRef *a1, CFErrorRef *a2, uint64_t a3)
{
  CFErrorDomain Domain;
  __CFCalendar *v8;
  const __CFTimeZone *v9;
  CFDateRef v10;
  CFErrorRef v11;
  CFAbsoluteTime at;

  Domain = CFErrorGetDomain(*a2);
  if (!Domain || !CFEqual(Domain, CFSTR("com.apple.security.cfder.error")) || CFErrorGetCode(*a2) != -1)
    return 0;
  at = 0.0;
  v8 = CFCalendarCreateWithIdentifier(0, kCFGregorianCalendar);
  v9 = CFTimeZoneCreateWithTimeIntervalFromGMT(0, 0.0);
  CFCalendarSetTimeZone(v8, v9);
  CFCalendarComposeAbsoluteTime(v8, &at, "yMd", 2001, 3, 24);
  if (v9)
    CFRelease(v9);
  if (v8)
    CFRelease(v8);
  v10 = CFDateCreate(0, at);
  *a1 = v10;
  if (!v10)
    return 0;
  v11 = *a2;
  if (*a2)
  {
    *a2 = 0;
    CFRelease(v11);
  }
  return a3;
}

void sub_10011D600(uint64_t a1, CFDictionaryRef theDict, __CFString **a3)
{
  const void *Value;
  const void *v7;
  int v8;
  CFDataRef v9;
  CFDataRef v10;
  CFDataRef v11;
  unint64_t v12;
  CFDataRef theData;
  CFTypeRef cf2;

  Value = CFDictionaryGetValue(theDict, kSecValuePersistentRef);
  if (Value)
  {
    v7 = Value;
    theData = 0;
    cf2 = 0;
    v12 = 0xAAAAAAAAAAAAAAAALL;
    if ((_SecItemParsePersistentRef(Value, &cf2, &v12, &theData, 0) & 1) != 0)
    {
      v8 = CFEqual(**(CFTypeRef **)(a1 + 16), cf2);
      v9 = theData;
      if (v8)
      {
        if (theData)
        {
          if (CFDataGetLength(theData) == 16)
            sub_10001D918(a1, theData, a3);
          v10 = theData;
          if (theData)
          {
            theData = 0;
            CFRelease(v10);
          }
        }
      }
      else
      {
        if (theData)
        {
          theData = 0;
          CFRelease(v9);
        }
        sub_100019F20(-26275, a3, CFSTR("v_PersistentRef has unexpected class %@"), cf2);
      }
    }
    else
    {
      v11 = theData;
      if (theData)
      {
        theData = 0;
        CFRelease(v11);
      }
      sub_100019F20(-26275, a3, CFSTR("v_PersistentRef %@ failed to decode"), v7);
    }
  }
  else
  {
    sub_100019F20(-26275, a3, CFSTR("No v_PersistentRef in backup dictionary %@"), theDict);
  }
}

void sub_10011D868(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10011D9EC(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10011DB7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id obj)
{
  objc_sync_exit(obj);
  _Unwind_Resume(a1);
}

void sub_10011DBF0(uint64_t a1)
{
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();

}

void sub_10011EE1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,id *location)
{
  uint64_t v42;

  objc_destroyWeak(location);
  objc_destroyWeak((id *)(v42 - 152));
  _Unwind_Resume(a1);
}

void sub_10011EFA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10011F140(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10011F6E0(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_10011F8F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10011FB08(uint64_t a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9;
  id v10;
  id v11;
  id v12;
  id WeakRetained;
  void *v14;
  const void *v15;
  NSObject *v16;
  const void *v17;
  NSObject *v18;
  void *v19;
  const void *v20;
  NSObject *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  unsigned int v26;
  id v27;
  void *v28;
  const void *v29;
  NSObject *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  const void *v35;
  NSObject *v36;
  void *v37;
  id v38;
  _QWORD v39[4];
  id v40;
  id v41;
  uint8_t buf[4];
  id v43;

  v9 = a2;
  v10 = a3;
  v11 = a4;
  v12 = a5;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v14 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v14, "logResultForEvent:hardFailure:result:", CFSTR("OctagonEventUpgradePreapprovedJoin"), 1, v12);

  if (v12)
  {
    v15 = sub_10000EF14("SecError");
    v16 = objc_claimAutoreleasedReturnValue(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v43 = v12;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "octagon-sos: attemptPreapprovedJoin failed: %@", buf, 0xCu);
    }

    if (objc_msgSend(v12, "isCuttlefishError:", 1033))
    {
      v17 = sub_10000EF14("octagon-ckks");
      v18 = objc_claimAutoreleasedReturnValue(v17);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "A CKKS key hierarchy is out of date; requesting reset",
          buf,
          2u);
      }

      v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "ckksConflictState"));
      objc_msgSend(WeakRetained, "setNextState:", v19);

    }
    else
    {
      objc_msgSend(WeakRetained, "setError:", v12);
      objc_msgSend(WeakRetained, "setNextState:", CFSTR("BecomeUntrusted"));
    }
    v27 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishedOp"));
    objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v27);
  }
  else
  {
    objc_msgSend(WeakRetained, "requestSilentEscrowUpdate");
    v20 = sub_10000EF14("SecError");
    v21 = objc_claimAutoreleasedReturnValue(v20);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "octagon-sos: attemptPreapprovedJoin succeded", buf, 2u);
    }

    v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "ckks"));
    objc_msgSend(v23, "setCurrentSyncingPolicy:", v11);

    v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v24, "stateHolder"));
    v39[0] = _NSConcreteStackBlock;
    v39[1] = 3221225472;
    v39[2] = sub_10011FF88;
    v39[3] = &unk_1002DEC60;
    v40 = v9;
    v41 = v11;
    v38 = 0;
    v26 = objc_msgSend(v25, "persistAccountChanges:error:", v39, &v38);
    v27 = v38;

    if (!v26 || v27)
    {
      v35 = sub_10000EF14("octagon-sos");
      v36 = objc_claimAutoreleasedReturnValue(v35);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v43 = v27;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "Couldn't persist results: %@", buf, 0xCu);
      }

      objc_msgSend(WeakRetained, "setError:", v27);
      objc_msgSend(WeakRetained, "setNextState:", CFSTR("Error"));
    }
    else
    {
      v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "intendedState"));
      objc_msgSend(WeakRetained, "setNextState:", v28);

      v29 = sub_10000EF14("octagon-ckks");
      v30 = objc_claimAutoreleasedReturnValue(v29);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
        v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v31, "ckks"));
        *(_DWORD *)buf = 138412290;
        v43 = v32;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "Providing ck records (from sos upgrade) to %@", buf, 0xCu);

      }
      v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
      v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v33, "ckks"));
      objc_msgSend(v34, "receiveTLKUploadRecords:", v10);

    }
    v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishedOp"));
    objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v37);

  }
}

id sub_10011FF88(uint64_t a1, void *a2)
{
  id v3;

  v3 = a2;
  objc_msgSend(v3, "setTrustState:", 2);
  objc_msgSend(v3, "setPeerID:", *(_QWORD *)(a1 + 32));
  objc_msgSend(v3, "setTPSyncingPolicy:", *(_QWORD *)(a1 + 40));
  return v3;
}

void sub_10011FFD0(uint64_t a1)
{
  void *v2;
  void *v3;
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "viewKeySets"));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "pendingTLKShares"));
  objc_msgSend(WeakRetained, "proceedWithKeys:pendingTLKShares:", v2, v3);

}

void sub_10012003C(uint64_t a1)
{
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  objc_msgSend(WeakRetained, "afterUpdate");

}

void sub_100120068(uint64_t a1, char a2, void *a3)
{
  id v5;
  id WeakRetained;
  void *v7;
  const void *v8;
  NSObject *v9;
  const void *v10;
  NSObject *v11;
  _BOOL4 v12;
  void *v13;
  int v14;
  id v15;

  v5 = a3;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v7 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v7, "logResultForEvent:hardFailure:result:", CFSTR("OctagonEventUpgradePreflightPreapprovedJoin"), 1, v5);

  if (v5)
  {
    v8 = sub_10000EF14("SecError");
    v9 = objc_claimAutoreleasedReturnValue(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      v14 = 138412290;
      v15 = v5;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "octagon-sos: preflightPreapprovedJoin failed: %@", (uint8_t *)&v14, 0xCu);
    }

    objc_msgSend(WeakRetained, "setError:", v5);
LABEL_12:
    objc_msgSend(WeakRetained, "setNextState:", CFSTR("BecomeUntrusted"));
    v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishedOp"));
    objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v13);

    goto LABEL_13;
  }
  v10 = sub_10000EF14("octagon-sos");
  v11 = objc_claimAutoreleasedReturnValue(v10);
  v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
  if ((a2 & 1) == 0)
  {
    if (v12)
    {
      LOWORD(v14) = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "TPH believes a preapprovedJoin will fail; aborting.",
        (uint8_t *)&v14,
        2u);
    }

    goto LABEL_12;
  }
  if (v12)
  {
    LOWORD(v14) = 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "TPH believes a preapprovedJoin might succeed; continuing.",
      (uint8_t *)&v14,
      2u);
  }

  objc_msgSend(WeakRetained, "afterPreflight");
LABEL_13:

}

void sub_100120234(uint64_t a1)
{
  id WeakRetained;
  void *v2;
  void *v3;
  unsigned int v4;
  void *v5;
  double v6;
  double v7;
  const void *v8;
  NSObject *v9;
  void *v10;
  NSObject *v11;
  void *v12;
  OctagonPendingFlag *v13;
  void *v14;
  const void *v15;
  void *v16;
  int v17;
  double v18;
  __int16 v19;
  void *v20;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));

  if (v2)
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
    v4 = objc_msgSend(v3, "isRetryable");

    if (v4)
    {
      v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
      objc_msgSend(v5, "retryInterval");
      v7 = v6;

      v8 = sub_10000EF14("octagon-sos");
      v9 = objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
        v17 = 134218242;
        v18 = v7;
        v19 = 2112;
        v20 = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "SOS upgrade error is not fatal: requesting retry in %0.2fs: %@", (uint8_t *)&v17, 0x16u);

      }
      v11 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
      v12 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject flagHandler](v11, "flagHandler"));
      v13 = -[OctagonPendingFlag initWithFlag:delayInSeconds:]([OctagonPendingFlag alloc], "initWithFlag:delayInSeconds:", CFSTR("attempt_sos_upgrade"), v7);
      objc_msgSend(v12, "handlePendingFlag:", v13);

    }
    else
    {
      v15 = sub_10000EF14("octagon-sos");
      v11 = objc_claimAutoreleasedReturnValue(v15);
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
LABEL_10:

        v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "eventS"));
        v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
        +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", v14, 0, v16);

        goto LABEL_11;
      }
      v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "error"));
      v17 = 138412290;
      v18 = *(double *)&v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "SOS upgrade error is: %@; not retrying",
        (uint8_t *)&v17,
        0xCu);
    }

    goto LABEL_10;
  }
  v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "eventS"));
  +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", v14, 1, 0);
LABEL_11:

}

void sub_100120498(uint64_t a1, void *a2, void *a3, void *a4, uint64_t a5, uint64_t a6, void *a7, void *a8)
{
  id v13;
  id v14;
  id v15;
  id v16;
  id v17;
  id WeakRetained;
  void *v19;
  const void *v20;
  NSObject *v21;
  id v22;
  const void *v23;
  NSObject *v24;
  void *v25;
  void *v26;
  id v27;
  unsigned int v28;
  void *v29;
  void *v30;
  const void *v31;
  NSObject *v32;
  void *v33;
  id v34;
  id v35;
  _QWORD v36[4];
  id v37;
  uint8_t buf[4];
  id v39;
  __int16 v40;
  id v41;
  __int16 v42;
  id v43;

  v13 = a2;
  v14 = a3;
  v15 = a4;
  v16 = a7;
  v17 = a8;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v19 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v19, "logResultForEvent:hardFailure:result:", CFSTR("OctagonEventUpgradePrepare"), 1, v17);

  if (v17)
  {
    v20 = sub_10000EF14("SecError");
    v21 = objc_claimAutoreleasedReturnValue(v20);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v39 = v17;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "octagon-sos: Error preparing identity: %@", buf, 0xCu);
    }

    objc_msgSend(WeakRetained, "setError:", v17);
    objc_msgSend(WeakRetained, "handlePrepareErrors:nextExpectedState:", v17, CFSTR("BecomeUntrusted"));
    v22 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishedOp"));
    objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v22);
  }
  else
  {
    v23 = sub_10000EF14("octagon-sos");
    v24 = objc_claimAutoreleasedReturnValue(v23);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412802;
      v39 = v13;
      v40 = 2112;
      v41 = v14;
      v42 = 2112;
      v43 = v15;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Prepared: %@ %@ %@", buf, 0x20u);
    }
    v34 = v13;

    v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v25, "stateHolder"));
    v36[0] = _NSConcreteStackBlock;
    v36[1] = 3221225472;
    v36[2] = sub_100120804;
    v36[3] = &unk_1002EAF10;
    v27 = v16;
    v37 = v27;
    v35 = 0;
    v28 = objc_msgSend(v26, "persistAccountChanges:error:", v36, &v35);
    v22 = v35;

    if (!v28 || v22)
    {
      v31 = sub_10000EF14("SecError");
      v32 = objc_claimAutoreleasedReturnValue(v31);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v39 = v22;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "octagon-ckks: Error persisting new views and policy: %@", buf, 0xCu);
      }

      objc_msgSend(WeakRetained, "setError:", v22);
      objc_msgSend(WeakRetained, "handlePrepareErrors:nextExpectedState:", v22, CFSTR("BecomeUntrusted"));
      v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishedOp"));
      objc_msgSend(WeakRetained, "runBeforeGroupFinished:", v33);

    }
    else
    {
      v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
      v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v29, "ckks"));
      objc_msgSend(v30, "setCurrentSyncingPolicy:", v27);

      objc_msgSend(WeakRetained, "afterPrepare");
    }
    v13 = v34;

  }
}

id sub_100120804(uint64_t a1, void *a2)
{
  id v3;

  v3 = a2;
  objc_msgSend(v3, "setTPSyncingPolicy:", *(_QWORD *)(a1 + 32));
  return v3;
}

OTAccountMetadataClassC *__cdecl sub_100120834(id a1, OTAccountMetadataClassC *a2)
{
  OTAccountMetadataClassC *v2;

  v2 = a2;
  -[OTAccountMetadataClassC setAttemptedJoin:](v2, "setAttemptedJoin:", 2);
  -[OTAccountMetadataClassC setCdpState:](v2, "setCdpState:", 2);
  return v2;
}

void sub_10012086C(id a1)
{
  qword_100341180 = (uint64_t)CFDataCreateWithBytesNoCopy(0, byte_10024957C, 16, kCFAllocatorNull);
}

void sub_1001208A4(id a1)
{
  qword_100341190 = (uint64_t)CFDataCreateWithBytesNoCopy(0, 0, 0, kCFAllocatorNull);
}

void sub_1001208D8(id a1)
{
  qword_1003411A0 = (uint64_t)CFDataCreateWithBytesNoCopy(0, byte_10024958D, 16, kCFAllocatorNull);
}

void sub_100120910(const void *a1, const __CFData *a2, uint64_t a3)
{
  const void **v5;
  const void **v6;
  const void *Value;
  const void *v8;
  CFTypeID v9;
  __CFArray *Mutable;
  const void *v11;

  v5 = sub_100012504(*(__CFString ***)a3, a1, (__CFString **)(a3 + 40));
  if (v5)
  {
    v6 = v5;
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 8), *v5);
    if (Value)
    {
      v8 = Value;
      v9 = CFGetTypeID(Value);
      if (v9 == CFArrayGetTypeID())
      {
        Mutable = (__CFArray *)CFRetain(v8);
      }
      else
      {
        Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        CFArrayAppendValue(Mutable, v8);
      }
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a3 + 8), *v6);
      if (Mutable)
        goto LABEL_9;
    }
    else
    {
      Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      if (Mutable)
      {
LABEL_9:
        sub_1000122D8(v6, a2, a3);
        v11 = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 8), *v6);
        CFArrayAppendValue(Mutable, v11);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a3 + 8), *v6, Mutable);
        CFRelease(Mutable);
      }
    }
  }
}

void sub_100120A38(const void *a1, const __CFData *a2, uint64_t a3)
{
  const void **v5;
  const void **v6;
  const void *Value;
  const void *v8;
  CFTypeID v9;
  __CFArray *Mutable;
  NSObject *v11;
  const void *v12;
  const void *v13;
  int v14;
  const void *v15;
  __int16 v16;
  const void *v17;

  v5 = sub_100012504(*(__CFString ***)a3, a1, (__CFString **)(a3 + 40));
  if (v5)
  {
    v6 = v5;
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 8), *v5);
    if (Value)
    {
      v8 = Value;
      v9 = CFGetTypeID(Value);
      if (v9 == CFArrayGetTypeID())
      {
        Mutable = (__CFArray *)CFRetain(v8);
      }
      else
      {
        v11 = sub_10000EF14("SecError");
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          v12 = *v6;
          v14 = 138412546;
          v15 = v12;
          v16 = 2112;
          v17 = v8;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "negating %@ = %@ in query", (uint8_t *)&v14, 0x16u);
        }
        Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        CFArrayAppendValue(Mutable, kCFNull);
        CFArrayAppendValue(Mutable, v8);
      }
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a3 + 8), *v6);
      if (Mutable)
        goto LABEL_11;
    }
    else
    {
      Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      CFArrayAppendValue(Mutable, kCFNull);
      if (Mutable)
      {
LABEL_11:
        sub_1000122D8(v6, a2, a3);
        v13 = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 8), *v6);
        CFArrayAppendValue(Mutable, v13);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a3 + 8), *v6, Mutable);
        CFRelease(Mutable);
      }
    }
  }
}

void sub_100120C0C(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3;

  v3 = *(CFTypeRef *)(a1 + 208);
  if (v3 != cf)
  {
    if (!cf || (CFRetain(cf), (v3 = *(CFTypeRef *)(a1 + 208)) != 0))
      CFRelease(v3);
    *(_QWORD *)(a1 + 208) = cf;
  }
}

void sub_100120C54(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3;

  v3 = *(CFTypeRef *)(a1 + 216);
  if (v3 != cf)
  {
    if (!cf || (CFRetain(cf), (v3 = *(CFTypeRef *)(a1 + 216)) != 0))
      CFRelease(v3);
    *(_QWORD *)(a1 + 216) = cf;
  }
}

void sub_100120C9C(uint64_t a1, CFTypeRef cf)
{
  const void *v4;

  if (*(CFTypeRef *)(a1 + 232) != cf)
  {
    CFRetain(cf);
    v4 = *(const void **)(a1 + 232);
    if (v4)
      CFRelease(v4);
    *(_QWORD *)(a1 + 232) = cf;
  }
}

void sub_100120CE0(uint64_t a1, CFTypeRef cf)
{
  const void *v4;

  if (*(CFTypeRef *)(a1 + 248) != cf)
  {
    CFRetain(cf);
    v4 = *(const void **)(a1 + 248);
    if (v4)
      CFRelease(v4);
    *(_QWORD *)(a1 + 248) = cf;
  }
}

void sub_100120D24(uint64_t a1, CFTypeRef cf)
{
  const void *v4;

  if (*(CFTypeRef *)(a1 + 224) != cf)
  {
    CFRetain(cf);
    v4 = *(const void **)(a1 + 224);
    if (v4)
      CFRelease(v4);
    *(_QWORD *)(a1 + 224) = cf;
  }
}

void sub_100120EE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1001211EC(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_100121754(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1001217E0(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100121BBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id obj)
{
  objc_sync_exit(obj);
  _Unwind_Resume(a1);
}

void sub_100121D90(uint64_t a1)
{
  void *v1;
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (objc_msgSend(WeakRetained, "timeoutCanOccur"))
  {
    v1 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "_onqueueTimeoutError"));
    objc_msgSend(WeakRetained, "setError:", v1);

    objc_msgSend(WeakRetained, "setTimeoutCanOccur:", 0);
    objc_msgSend(WeakRetained, "cancel");
  }

}

BOOL sub_100121DFC(id a1, id a2, unint64_t a3, BOOL *a4)
{
  return objc_msgSend(a2, "isFinished", a3, a4) ^ 1;
}

id sub_100121E18(uint64_t a1)
{
  id result;

  result = objc_msgSend(*(id *)(a1 + 32), "isCancelled");
  if ((result & 1) == 0)
    return objc_msgSend(*(id *)(a1 + 32), "setTimeoutCanOccur:", 0);
  return result;
}

void sub_100121E54(uint64_t a1)
{
  id WeakRetained;
  void *v3;
  void (**v4)(void);
  void *v5;
  void *v6;
  id v7;
  id v8;
  uint64_t v9;
  void *i;
  id v11;
  NSObject *v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint8_t buf[8];
  _BYTE v18[128];

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v3 = WeakRetained;
  if (WeakRetained)
  {
    v4 = (void (**)(void))objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "finishingBlock"));
    v4[2]();

    (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "completionHandlerDidRunCondition"));
    objc_msgSend(v5, "fulfill");

    v15 = 0u;
    v16 = 0u;
    v13 = 0u;
    v14 = 0u;
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "dependencies", 0));
    v7 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v13, v18, 16);
    if (v7)
    {
      v8 = v7;
      v9 = *(_QWORD *)v14;
      do
      {
        for (i = 0; i != v8; i = (char *)i + 1)
        {
          if (*(_QWORD *)v14 != v9)
            objc_enumerationMutation(v6);
          objc_msgSend(v3, "removeDependency:", *(_QWORD *)(*((_QWORD *)&v13 + 1) + 8 * (_QWORD)i));
        }
        v8 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v13, v18, 16);
      }
      while (v8);
    }

  }
  else
  {
    v11 = sub_10000BDF4(CFSTR("resultoperation"), 0);
    v12 = objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "completion handler called on deallocated operation instance", buf, 2u);
    }

    (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  }

}

void sub_100121FFC(uint64_t a1)
{
  void *v1;
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate dateWithTimeIntervalSinceNow:](NSDate, "dateWithTimeIntervalSinceNow:", 0.0));
  objc_msgSend(WeakRetained, "setFinishDate:", v1);

}

void sub_1001221D4(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_1001221F4(uint64_t a1)
{
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();

}

uint64_t sub_1001231D8(uint64_t a1, CFTypeRef *a2)
{
  unsigned __int8 v2;
  uint64_t v3;
  _QWORD v5[7];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  int v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = -1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_10012328C;
  v5[3] = &unk_1002DEDD8;
  v5[5] = a1;
  v5[6] = a2;
  v5[4] = &v6;
  v2 = sub_1001232EC(a2, (uint64_t)v5);
  v3 = *((unsigned int *)v7 + 6);
  if ((v2 & 1) == 0 && (v3 & 0x80000000) == 0)
  {
    close(*((_DWORD *)v7 + 6));
    v3 = 0xFFFFFFFFLL;
    *((_DWORD *)v7 + 6) = -1;
  }
  _Block_object_dispose(&v6, 8);
  return v3;
}

BOOL sub_10012328C(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD v7[6];

  v4 = a1[5];
  v5 = a1[6];
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_1001233A0;
  v7[3] = &unk_1002DEDB0;
  v7[4] = a1[4];
  v7[5] = v5;
  return sub_1001043DC(a3, v4, v5, v7);
}

_QWORD *sub_1001232EC(CFTypeRef *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *result;
  _QWORD *v7;
  uint64_t v8;

  v4 = sub_100011C40(0);
  v5 = sub_10001A338(v4);
  sub_10003268C(v5 != 0, a1, CFSTR("No datasource"));
  if (!v5)
    return 0;
  result = (_QWORD *)(*(uint64_t (**)(uint64_t, const CFStringRef, CFTypeRef *))(v5 + 8))(v5, kSecAttrAccessibleWhenUnlocked, a1);
  if (result)
  {
    v7 = result;
    v8 = *result;
    if (*result)
      (*(void (**)(uint64_t, _QWORD *, uint64_t))(a2 + 16))(a2, result, v8);
    LODWORD(result) = ((uint64_t (*)(_QWORD *, CFTypeRef *))v7[9])(v7, a1);
    if (v8)
      return (_QWORD *)result;
    else
      return 0;
  }
  return result;
}

void sub_1001233A0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFTypeRef *v4;
  int v5;
  _QWORD v6[6];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  int v10;

  v4 = *(CFTypeRef **)(a1 + 40);
  v7 = 0;
  v8 = &v7;
  v9 = 0x2020000000;
  v10 = -1;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_1001ECBB4;
  v6[3] = &unk_1002EC570;
  v6[4] = &v7;
  v6[5] = v4;
  sub_1001EBEC4(a3, v4, v6);
  v5 = *((_DWORD *)v8 + 6);
  _Block_object_dispose(&v7, 8);
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v5;
}

void sub_100123444(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10012345C(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  unsigned int v4;
  uint64_t v5;
  _QWORD v7[9];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  char v11;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 1;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_100123500;
  v7[3] = &unk_1002DEE00;
  v7[4] = &v8;
  v7[5] = a1;
  v7[6] = a2;
  v7[7] = a3;
  v7[8] = a4;
  v4 = sub_1001232EC(a4, (uint64_t)v7);
  if (*((_BYTE *)v9 + 24))
    v5 = v4;
  else
    v5 = 0;
  *((_BYTE *)v9 + 24) = v5;
  _Block_object_dispose(&v8, 8);
  return v5;
}

void sub_100123500(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  BOOL v8;
  __int128 v9;
  _QWORD v10[5];
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  char v17;

  v5 = *(_QWORD *)(a1 + 40);
  v9 = *(_OWORD *)(a1 + 48);
  v6 = *(_QWORD *)(a1 + 64);
  if (-[OTSOSActualAdapter sosEnabled]_0())
  {
    v14 = 0;
    v15 = &v14;
    v16 = 0x2020000000;
    v17 = 1;
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_100104554;
    v10[3] = &unk_1002DE0C0;
    v10[4] = &v14;
    v11 = v9;
    v12 = v6;
    v13 = a3;
    v7 = sub_1001043DC(a3, v5, v6, v10);
    if (*((_BYTE *)v15 + 24))
      v8 = v7;
    else
      v8 = 0;
    *((_BYTE *)v15 + 24) = v8;
    _Block_object_dispose(&v14, 8);
  }
  else
  {
    SOSCCSetSOSDisabledError(v6);
    v8 = 0;
  }
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v8;
}

void sub_1001235F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100123608(CFTypeRef *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  const void *v3;
  uint64_t v4;
  _QWORD v6[6];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 0;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = sub_1001236A8;
  v6[3] = &unk_1002DEE28;
  v6[4] = &v7;
  v6[5] = a1;
  v1 = sub_1001232EC(a1, (uint64_t)v6);
  v2 = v8;
  if ((v1 & 1) == 0)
  {
    v3 = (const void *)v8[3];
    if (v3)
    {
      v8[3] = 0;
      CFRelease(v3);
      v2 = v8;
    }
  }
  v4 = v2[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

uint64_t sub_1001236A8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = sub_1001047F4(a3, *(_QWORD *)(a1 + 40));
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t sub_1001236DC(uint64_t a1, CFTypeRef *a2)
{
  unsigned __int8 v2;
  uint64_t *v3;
  const void *v4;
  uint64_t v5;
  _QWORD v7[7];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_100123788;
  v7[3] = &unk_1002DEE50;
  v7[4] = &v8;
  v7[5] = a1;
  v7[6] = a2;
  v2 = sub_1001232EC(a2, (uint64_t)v7);
  v3 = v9;
  if ((v2 & 1) == 0)
  {
    v4 = (const void *)v9[3];
    if (v4)
    {
      v9[3] = 0;
      CFRelease(v4);
      v3 = v9;
    }
  }
  v5 = v3[3];
  _Block_object_dispose(&v8, 8);
  return v5;
}

void sub_100123788(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v9[5];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  const __CFString *v13;
  _QWORD block[4];
  id v15;
  uint64_t v16;
  uint64_t v17;

  v6 = a1[5];
  v5 = a1[6];
  if (-[OTSOSActualAdapter sosEnabled]_0())
  {
    v10 = 0;
    v11 = &v10;
    v12 = 0x2020000000;
    v13 = &stru_1002EE888;
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = sub_100104A10;
    v9[3] = &unk_1002DE0E8;
    v9[4] = &v10;
    v7 = v9;
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100104A48;
    block[3] = &unk_1002DE2B0;
    v16 = a3;
    v17 = v6;
    v15 = v7;
    dispatch_sync(*(dispatch_queue_t *)(a3 + 112), block);

    v8 = v11[3];
    _Block_object_dispose(&v10, 8);
  }
  else
  {
    SOSCCSetSOSDisabledError(v5);
    v8 = 0;
  }
  *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = v8;
}

uint64_t sub_10012388C(int a1, uint64_t a2, uint64_t a3, CFTypeRef cf, uint64_t a5, CFTypeRef *a6)
{
  CFTypeID v11;
  uint64_t v12;
  const void *v13;
  int v14;
  int v15;
  unsigned __int8 v16;
  unsigned __int8 v17;
  BOOL v18;
  BOOL v19;
  uint64_t v20;
  _QWORD v22[7];
  int v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  char v27;

  v24 = 0;
  v25 = &v24;
  v26 = 0x2000000000;
  v27 = 0;
  if (cf && (v11 = CFGetTypeID(cf), v11 == CFDataGetTypeID()))
  {
    v12 = SOSBackupSliceKeyBagCreateFromData(kCFAllocatorDefault, a3, a6);
    if (v12)
    {
      v13 = (const void *)v12;
      if (a2)
      {
        v14 = SOSBSKBLoadAndUnlockWithPeerIDAndSecret();
      }
      else if (SOSBSKBIsDirect())
      {
        v14 = SOSBSKBLoadAndUnlockWithDirectSecret(v13, cf, a6);
      }
      else
      {
        v14 = SOSBSKBLoadAndUnlockWithWrappingSecret(v13, cf, a6);
      }
      v15 = v14;
      if (v14 != -1)
      {
        *((_BYTE *)v25 + 24) = 1;
        v22[0] = _NSConcreteStackBlock;
        v22[1] = 0x40000000;
        v22[2] = sub_100123A3C;
        v22[3] = &unk_1002DEEC0;
        v22[4] = &v24;
        v22[5] = a6;
        v22[6] = a5;
        v23 = v14;
        v16 = sub_1001232EC(a6, (uint64_t)v22);
        if (*((_BYTE *)v25 + 24))
          v17 = v16;
        else
          v17 = 0;
        *((_BYTE *)v25 + 24) = v17;
        v18 = sub_100147114(v15, a6);
        if (*((_BYTE *)v25 + 24))
          v19 = v18;
        else
          v19 = 0;
        *((_BYTE *)v25 + 24) = v19;
      }
      CFRelease(v13);
    }
  }
  else if (a6)
  {
    sub_100019F20(-50, (__CFString **)a6, CFSTR("object %@ is not a data"), cf);
  }
  v20 = *((unsigned __int8 *)v25 + 24);
  _Block_object_dispose(&v24, 8);
  return v20;
}

uint64_t sub_100123A3C(uint64_t a1, uint64_t a2)
{
  int8x16_t v3;
  uint64_t result;
  uint64_t v5;
  char v6;
  _QWORD v7[6];
  int8x16_t v8;
  int v9;

  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_100123AE0;
  v7[3] = &unk_1002DEE98;
  v7[4] = *(_QWORD *)(a1 + 32);
  v7[5] = a2;
  v9 = *(_DWORD *)(a1 + 56);
  v3 = *(int8x16_t *)(a1 + 40);
  v8 = vextq_s8(v3, v3, 8uLL);
  result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD *))(a2 + 64))(a2, v3.i64[0], 0, 0, v7);
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v5 + 24))
    v6 = result;
  else
    v6 = 0;
  *(_BYTE *)(v5 + 24) = v6;
  return result;
}

void sub_100123AE0(uint64_t a1, uint64_t a2)
{
  int v3;
  const __CFData *v4;
  CFTypeRef *v5;
  const __CFDictionary *v6;
  const __CFDictionary *v7;
  CFTypeID v8;
  BOOL v9;
  uint64_t v10;
  BOOL v11;
  void **v12;
  uint64_t v13;
  void (*v14)(_QWORD *, uint64_t);
  void *v15;
  uint64_t v16;
  uint64_t v17;
  CFTypeRef *v18;
  _QWORD context[7];
  int v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  char v24;

  v3 = *(_DWORD *)(a1 + 64);
  v12 = _NSConcreteStackBlock;
  v13 = 0x40000000;
  v14 = sub_100123C70;
  v15 = &unk_1002DEE70;
  v4 = *(const __CFData **)(a1 + 48);
  v5 = *(CFTypeRef **)(a1 + 56);
  v16 = *(_QWORD *)(a1 + 40);
  v17 = a2;
  v18 = v5;
  v21 = 0;
  v22 = &v21;
  v23 = 0x2000000000;
  v24 = 1;
  v6 = (const __CFDictionary *)sub_100016590(kCFAllocatorDefault, v4, v5);
  v7 = v6;
  if (v6)
  {
    v8 = CFGetTypeID(v6);
    if (v8 == CFDictionaryGetTypeID())
    {
      *((_BYTE *)v22 + 24) = 1;
      context[0] = _NSConcreteStackBlock;
      context[1] = 0x40000000;
      context[2] = sub_100123CB4;
      context[3] = &unk_1002DEEE8;
      v20 = v3;
      context[4] = &v12;
      context[5] = &v21;
      context[6] = v5;
      CFDictionaryApplyFunction(v7, (CFDictionaryApplierFunction)sub_100123E4C, context);
LABEL_7:
      CFRelease(v7);
      v9 = *((_BYTE *)v22 + 24) != 0;
      goto LABEL_9;
    }
  }
  if (v5)
    sub_100019F20(-50, (__CFString **)v5, CFSTR("object %@ is not a dictionary"), v7, v12, v13, v14, v15, v16, v17, v18);
  *((_BYTE *)v22 + 24) = 0;
  if (v7)
    goto LABEL_7;
  v9 = 0;
LABEL_9:
  _Block_object_dispose(&v21, 8);
  v10 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v10 + 24))
    v11 = v9;
  else
    v11 = 0;
  *(_BYTE *)(v10 + 24) = v11;
}

void sub_100123C70(_QWORD *a1, uint64_t a2)
{
  CFTypeRef cf;

  cf = 0;
  if ((*(uint64_t (**)(_QWORD, uint64_t, CFTypeRef *, _QWORD))(a1[4] + 88))(a1[5], a2, &cf, a1[6]))
  {
    if (cf)
      CFRelease(cf);
  }
}

void sub_100123CB4(uint64_t a1, CFTypeRef cf, const void *a3)
{
  __CFString **v5;
  CFTypeID v7;
  __CFString **v8;
  __CFString **v9;
  __CFString **v10;
  CFTypeID v11;
  CFIndex Count;
  CFIndex v13;
  CFIndex i;
  const __CFData *ValueAtIndex;
  const void *v16;
  const void *v17;
  BOOL v18;
  uint64_t v19;
  BOOL v20;

  v5 = *(__CFString ***)(a1 + 48);
  if (!cf || (v7 = CFGetTypeID(cf), v7 != CFStringGetTypeID()))
  {
    if (v5)
      sub_100019F20(-50, v5, CFSTR("object %@ is not a string"), cf);
    goto LABEL_15;
  }
  v8 = sub_100011884(cf);
  v9 = *(__CFString ***)(a1 + 48);
  if (!v8)
  {
    v18 = sub_100019F20(-26275, v9, CFSTR("bad class %@ in backup"), cf);
    v19 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    if (*(_BYTE *)(v19 + 24))
      v20 = v18;
    else
      v20 = 0;
    *(_BYTE *)(v19 + 24) = v20;
    return;
  }
  if (!a3 || (v10 = v8, v11 = CFGetTypeID(a3), v11 != CFArrayGetTypeID()))
  {
    if (v9)
      sub_100019F20(-50, v9, CFSTR("object %@ is not an array"), a3);
LABEL_15:
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
    return;
  }
  Count = CFArrayGetCount((CFArrayRef)a3);
  if (Count >= 1)
  {
    v13 = Count;
    for (i = 0; i != v13; ++i)
    {
      ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex((CFArrayRef)a3, i);
      v16 = sub_1001162B4(kCFAllocatorDefault, v10, ValueAtIndex, *(_DWORD *)(a1 + 56), 0, *(__CFString ***)(a1 + 48));
      if (v16)
      {
        v17 = v16;
        (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
        CFRelease(v17);
      }
      else
      {
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
      }
    }
  }
}

uint64_t sub_100123E4C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void sub_100124C54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a17, 8);
  _Block_object_dispose(&a21, 8);
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100124E54(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_100124E64(uint64_t a1)
{

}

void sub_100124E6C(uint64_t a1, int a2, int a3, int a4, uint64_t a5, void *a6)
{
  id v12;
  const void *v13;
  NSObject *v14;
  _DWORD v15[2];
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;

  v12 = a6;
  v13 = sub_10000EF14("octagon");
  v14 = objc_claimAutoreleasedReturnValue(v13);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    v15[0] = 67109632;
    v15[1] = a2;
    v16 = 1024;
    v17 = a3;
    v18 = 1024;
    v19 = a4;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "fetch ramp records returned with featureAllowed: %d,\n featurePromoted: %d,\n featureVisible: %d,\n", (uint8_t *)v15, 0x14u);
  }

  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = a2;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = a5;
  if (v12)
    objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 40), a6);
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));

}

void sub_100124F98(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  const void *v7;
  NSObject *v8;
  void *v9;
  void *v10;
  void *v11;
  unsigned int v12;
  void *v13;
  unsigned int v14;
  void *v15;
  unsigned int v16;
  void *v17;
  id v18;
  const void *v19;
  NSObject *v20;
  void *v21;
  void *v22;
  void *v23;
  const void *v24;
  NSObject *v25;
  uint64_t v26;
  NSErrorUserInfoKey v27;
  const __CFString *v28;
  uint8_t buf[4];
  id v30;
  __int16 v31;
  id v32;
  __int16 v33;
  void *v34;
  __int16 v35;
  id v36;

  v5 = a2;
  v6 = a3;
  v7 = sub_10000EF14("octagon");
  v8 = objc_claimAutoreleasedReturnValue(v7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412546;
    v30 = v5;
    v31 = 2112;
    v32 = v6;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Fetch operation records %@ fetchError %@", buf, 0x16u);
  }

  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", *(_QWORD *)(a1 + 32)));
  v10 = v9;
  if (v9)
  {
    v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("FeatureAllowed")));
    v12 = objc_msgSend(v11, "BOOLValue");

    v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "objectForKeyedSubscript:", CFSTR("FeaturePromoted")));
    v14 = objc_msgSend(v13, "BOOLValue");

    v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "objectForKeyedSubscript:", CFSTR("FeatureVisible")));
    v16 = objc_msgSend(v15, "BOOLValue");

    v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "objectForKeyedSubscript:", CFSTR("RetryAfter")));
    v18 = objc_msgSend(v17, "integerValue");

    v19 = sub_10000EF14("octagon");
    v20 = objc_claimAutoreleasedReturnValue(v19);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      v21 = &__kCFBooleanFalse;
      if (v12)
        v22 = &__kCFBooleanTrue;
      else
        v22 = &__kCFBooleanFalse;
      if (v14)
        v23 = &__kCFBooleanTrue;
      else
        v23 = &__kCFBooleanFalse;
      *(_DWORD *)buf = 138413058;
      if (v16)
        v21 = &__kCFBooleanTrue;
      v30 = v22;
      v31 = 2112;
      v32 = v23;
      v33 = 2112;
      v34 = v21;
      v35 = 2048;
      v36 = v18;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Fetch ramp state - featureAllowed %@, featurePromoted: %@, featureVisible: %@, retryAfter: %ld", buf, 0x2Au);
    }
  }
  else
  {
    v24 = sub_10000EF14("SecError");
    v25 = objc_claimAutoreleasedReturnValue(v24);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "octagon: Couldn't find CKRecord for ramp. Defaulting to not ramped in", buf, 2u);
    }

    v27 = NSLocalizedDescriptionKey;
    v28 = CFSTR(" Couldn't find CKRecord for ramp. Defaulting to not ramped in");
    v20 = objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v28, &v27, 1));
    v26 = objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("com.apple.security.octagon"), 26, v20));

    v6 = (id)v26;
  }

  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
}

void sub_10012550C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  id *v15;

  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1001255FC(uint64_t a1, void *a2)
{
  NSObject *v3;
  id WeakRetained;
  void *v5;
  void *v6;
  void *v7;
  unsigned int v8;
  const void *v9;
  NSObject *v10;
  _BOOL4 v11;
  void *v12;
  void *v13;
  unsigned int v14;
  const void *v15;
  NSObject *v16;
  void *v17;
  NSObject *v18;
  void *v19;
  void *v20;
  const void *v21;
  NSObject *v22;
  void *v23;
  id v24;
  uint8_t buf[4];
  NSObject *v26;
  __int16 v27;
  void *v28;
  __int16 v29;
  NSObject *v30;

  v3 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v5 = WeakRetained;
  if (!v3)
  {
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "deps"));
    v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "stateHolder"));
    v24 = 0;
    v14 = objc_msgSend(v13, "persistNewTrustState:error:", 1, &v24);
    v10 = v24;

    if (!v14 || v10)
    {
      v21 = sub_10000EF14("SecError");
      v22 = objc_claimAutoreleasedReturnValue(v21);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v26 = v10;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "octagon: unable to persist clique departure: %@", buf, 0xCu);
      }

      objc_msgSend(v5, "setError:", v10);
      goto LABEL_17;
    }
    v15 = sub_10000EF14("octagon");
    v16 = objc_claimAutoreleasedReturnValue(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Successfully departed clique", buf, 2u);
    }

    v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "intendedState"));
    objc_msgSend(v5, "setNextState:", v17);
    goto LABEL_13;
  }
  objc_msgSend(WeakRetained, "setError:", v3);
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "deps"));
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "lockStateTracker"));
  v8 = objc_msgSend(v7, "isLockedError:", v3);

  v9 = sub_10000EF14("octagon");
  v10 = objc_claimAutoreleasedReturnValue(v9);
  v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
  if (!v8)
  {
    if (!v11)
    {
LABEL_17:

      goto LABEL_18;
    }
    v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "deps"));
    v18 = objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "containerName"));
    v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "deps"));
    v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "contextID"));
    *(_DWORD *)buf = 138412802;
    v26 = v18;
    v27 = 2112;
    v28 = v20;
    v29 = 2112;
    v30 = v3;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Unable to depart for (%@,%@): %@", buf, 0x20u);

LABEL_13:
    goto LABEL_17;
  }
  if (v11)
  {
    *(_DWORD *)buf = 138412290;
    v26 = v3;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Departing failed due to lock state: %@", buf, 0xCu);
  }

  objc_msgSend(v5, "setNextState:", CFSTR("WaitForUnlock"));
LABEL_18:
  v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "finishedOp"));
  objc_msgSend(v5, "runBeforeGroupFinished:", v23);

}

void sub_100125900(uint64_t a1, uint64_t a2, const __CFBoolean *a3)
{
  id v6;
  id v7;
  void *v8;
  id v9;
  NSObject *v10;
  NSObject *v11;
  uint64_t v12;
  unsigned __int8 v13;
  id v14;
  const void *v15;
  NSObject *v16;
  const void *v17;
  id v18;
  id v19;
  uint8_t buf[4];
  id v21;

  v6 = objc_alloc((Class)_SWCServiceSpecifier);
  v7 = objc_msgSend(v6, "initWithServiceType:applicationIdentifier:domain:", _SWCServiceTypeWebCredentials, a1, a2);
  v19 = 0;
  v8 = (void *)objc_claimAutoreleasedReturnValue(+[_SWCServiceDetails serviceDetailsWithServiceSpecifier:error:](_SWCServiceDetails, "serviceDetailsWithServiceSpecifier:error:", v7, &v19));
  v9 = v19;
  if (!v8)
  {
    v17 = sub_10000EF14("SecError");
    v11 = objc_claimAutoreleasedReturnValue(v17);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v9;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "+[_SWCServiceDetails serviceDetailsWithServiceSpecifier:error:] failed with %@", buf, 0xCu);
    }
    goto LABEL_12;
  }
  v10 = objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "firstObject"));
  v11 = v10;
  if (!v10)
  {
LABEL_12:
    v14 = v9;
    goto LABEL_13;
  }
  if (kCFBooleanTrue == a3)
    v12 = 1;
  else
    v12 = 2 * (kCFBooleanFalse == a3);
  v18 = v9;
  v13 = -[NSObject setUserApprovalState:error:](v10, "setUserApprovalState:error:", v12, &v18);
  v14 = v18;

  if ((v13 & 1) == 0)
  {
    v15 = sub_10000EF14("SecError");
    v16 = objc_claimAutoreleasedReturnValue(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v14;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "-[_SWCServiceDetails setUserApprovalState:error:] failed with %@", buf, 0xCu);
    }

  }
LABEL_13:

}

void sub_100126C18(uint64_t a1, void *a2)
{
  uint64_t v2;
  id v3;
  id v4;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = sub_100006D8C(a2);
  v4 = (id)objc_claimAutoreleasedReturnValue(v3);
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v4);

}

void sub_100126C60(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4;
  id v5;
  id v6;

  v4 = *(_QWORD *)(a1 + 32);
  v5 = sub_100006D8C(a3);
  v6 = (id)objc_claimAutoreleasedReturnValue(v5);
  (*(void (**)(uint64_t, uint64_t, id))(v4 + 16))(v4, a2, v6);

}

void sub_100126CB0(uint64_t a1, void *a2)
{
  uint64_t v2;
  id v3;
  id v4;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = sub_100006D8C(a2);
  v4 = (id)objc_claimAutoreleasedReturnValue(v3);
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v4);

}

void sub_100126CF8(uint64_t a1, void *a2)
{
  uint64_t v2;
  id v3;
  id v4;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = sub_100006D8C(a2);
  v4 = (id)objc_claimAutoreleasedReturnValue(v3);
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v4);

}

void sub_100126D40(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4;
  id v5;
  id v6;
  id v7;

  v4 = *(_QWORD *)(a1 + 32);
  v5 = a2;
  v6 = sub_100006D8C(a3);
  v7 = (id)objc_claimAutoreleasedReturnValue(v6);
  (*(void (**)(uint64_t, id, id))(v4 + 16))(v4, v5, v7);

}

void sub_100126DA4(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4;
  id v5;
  id v6;
  id v7;

  v4 = *(_QWORD *)(a1 + 32);
  v5 = a2;
  v6 = sub_100006D8C(a3);
  v7 = (id)objc_claimAutoreleasedReturnValue(v6);
  (*(void (**)(uint64_t, id, id))(v4 + 16))(v4, v5, v7);

}

void sub_100126E08(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4;
  id v5;
  id v6;
  id v7;

  v4 = *(_QWORD *)(a1 + 32);
  v5 = a2;
  v6 = sub_100006D8C(a3);
  v7 = (id)objc_claimAutoreleasedReturnValue(v6);
  (*(void (**)(uint64_t, id, id))(v4 + 16))(v4, v5, v7);

}

void sub_100126E6C(uint64_t a1, void *a2)
{
  uint64_t v2;
  id v3;
  id v4;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = sub_100006D8C(a2);
  v4 = (id)objc_claimAutoreleasedReturnValue(v3);
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v4);

}

void sub_100126EB4(uint64_t a1, void *a2)
{
  uint64_t v2;
  id v3;
  id v4;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = sub_100006D8C(a2);
  v4 = (id)objc_claimAutoreleasedReturnValue(v3);
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v4);

}

void sub_100126EFC(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4;
  id v5;
  id v6;
  id v7;

  v4 = *(_QWORD *)(a1 + 32);
  v5 = a2;
  v6 = sub_100006D8C(a3);
  v7 = (id)objc_claimAutoreleasedReturnValue(v6);
  (*(void (**)(uint64_t, id, id))(v4 + 16))(v4, v5, v7);

}

void sub_100126F60(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4;
  id v5;
  id v6;
  id v7;

  v4 = *(_QWORD *)(a1 + 32);
  v5 = a2;
  v6 = sub_100006D8C(a3);
  v7 = (id)objc_claimAutoreleasedReturnValue(v6);
  (*(void (**)(uint64_t, id, id))(v4 + 16))(v4, v5, v7);

}

void sub_100126FC4(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4;
  id v5;
  id v6;
  id v7;

  v4 = *(_QWORD *)(a1 + 32);
  v5 = a2;
  v6 = sub_100006D8C(a3);
  v7 = (id)objc_claimAutoreleasedReturnValue(v6);
  (*(void (**)(uint64_t, id, id))(v4 + 16))(v4, v5, v7);

}

void sub_100127028(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4;
  id v5;
  id v6;
  id v7;

  v4 = *(_QWORD *)(a1 + 32);
  v5 = a2;
  v6 = sub_100006D8C(a3);
  v7 = (id)objc_claimAutoreleasedReturnValue(v6);
  (*(void (**)(uint64_t, id, id))(v4 + 16))(v4, v5, v7);

}

uint64_t sub_10012708C(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v4;
  BOOL v9;
  NSObject *v10;
  NSObject *v11;
  const __CFUUID *v12;
  const __CFData *v13;
  NSObject *v14;
  CFTypeRef v15;
  __CFError *v16;
  NSObject *v17;
  uint64_t v18;
  __CFString *v19;
  __CFString **v20;
  __CFString *v21;
  __CFString *v22;
  __CFString *v23;
  NSObject *v24;
  NSObject *v25;
  __CFString *v26;
  __CFString *v27;
  const void *v28;
  const void *v29;
  __CFString *v30;
  _QWORD v32[11];
  CFTypeRef cf;
  CFUUIDBytes bytes;
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  char v38;
  uint64_t v39;
  __CFString **v40;
  uint64_t v41;
  __CFString *v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t *v52;
  uint64_t v53;
  uint64_t v54;
  uint8_t buf[4];
  uint64_t v56;
  __int16 v57;
  CFTypeRef v58;

  v4 = 0;
  v51 = 0;
  v52 = &v51;
  v53 = 0x2000000000;
  v54 = 0;
  v47 = 0;
  v48 = &v47;
  v49 = 0x2000000000;
  v50 = 0;
  v43 = 0;
  v44 = &v43;
  v45 = 0x2000000000;
  v46 = 0;
  v35 = 0;
  v36 = &v35;
  v39 = 0;
  v40 = (__CFString **)&v39;
  v41 = 0x2000000000;
  v42 = 0;
  v37 = 0x2000000000;
  v38 = 0;
  if (a1 && a2)
  {
    v9 = sub_100115F58(a2, dword_1003414E0, &v42);
    v10 = sub_10000EF14("ds");
    v11 = v10;
    if (v9)
    {
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 138477827;
        v56 = a2;
        _os_log_debug_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "setting UUID persistent ref on peersitem: %{private}@", buf, 0xCu);
      }
      v12 = CFUUIDCreate(kCFAllocatorDefault);
      bytes = CFUUIDGetUUIDBytes(v12);
      v13 = CFDataCreate(kCFAllocatorDefault, &bytes.byte0, 16);
      if (v12)
        CFRelease(v12);
      cf = 0;
      sub_10001D918(a2, v13, (__CFString **)&cf);
      if (cf)
      {
        v14 = sub_10000EF14("ds");
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138478083;
          v56 = a2;
          v57 = 2112;
          v58 = cf;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "failed to set persistent ref on item %{private}@, error: %@", buf, 0x16u);
        }
        v15 = cf;
        if (cf)
        {
          cf = 0;
          CFRelease(v15);
        }
      }
      if (v13)
        CFRelease(v13);
      v32[0] = _NSConcreteStackBlock;
      v32[1] = 0x40000000;
      v32[2] = sub_1001275AC;
      v32[3] = &unk_1002DF028;
      v32[4] = &v35;
      v32[5] = &v47;
      v32[6] = &v39;
      v32[7] = &v51;
      v32[9] = a2;
      v32[10] = a3;
      v32[8] = &v43;
      if (sub_10001DADC(a2, a1, v40 + 3, (uint64_t)v32) && !*((_BYTE *)v36 + 24))
      {
        v24 = sub_10000EF14("ds");
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138477827;
          v56 = a2;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Insert succeeded for: %{private}@", buf, 0xCu);
        }
        v52[3] = 2;
        if (v40[3])
        {
          v25 = sub_10000EF14("ds");
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
          {
            v26 = v40[3];
            *(_DWORD *)buf = 138412290;
            v56 = (uint64_t)v26;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "kSOSMergeFailure => kSOSMergePeersObject, %@", buf, 0xCu);
          }
          v27 = v40[3];
          if (v27)
            CFRelease(v27);
        }
      }
      v16 = (__CFError *)v40[3];
      if (v16 && (sub_1001165A4(v16) & 1) == 0)
      {
        v17 = sub_10000EF14("ds");
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          v18 = v52[3];
          v19 = v40[3];
          *(_DWORD *)buf = 134218242;
          v56 = v18;
          v57 = 2112;
          v58 = v19;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "dsMergeObject failed: mr=%ld, %@", buf, 0x16u);
        }
        if (!v52[3])
        {
          v20 = v40;
          v21 = v40[3];
          if (v21)
          {
            if (a4 && !*a4)
            {
              *a4 = v21;
            }
            else
            {
              CFRelease(v21);
              v20 = v40;
            }
          }
          v20[3] = 0;
        }
      }
      v28 = (const void *)v48[3];
      if (v28)
        CFRelease(v28);
      v29 = (const void *)v44[3];
      if (v29)
        CFRelease(v29);
      v30 = v40[3];
      if (v30)
        CFRelease(v30);
      v4 = v52[3];
    }
    else
    {
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        v22 = v40[3];
        *(_DWORD *)buf = 138412290;
        v56 = (uint64_t)v22;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "kSOSMergeFailure => SecDbItemSetKeybag: %@", buf, 0xCu);
      }
      v23 = v40[3];
      if (v23)
      {
        if (a4 && !*a4)
        {
          v4 = 0;
          *a4 = v23;
          goto LABEL_50;
        }
        CFRelease(v23);
      }
      v4 = 0;
    }
  }
LABEL_50:
  _Block_object_dispose(&v35, 8);
  _Block_object_dispose(&v39, 8);
  _Block_object_dispose(&v43, 8);
  _Block_object_dispose(&v47, 8);
  _Block_object_dispose(&v51, 8);
  return v4;
}

void sub_1001275AC(uint64_t a1, __CFString ***a2, _QWORD *a3)
{
  __CFString ***v6;
  __CFString **v7;
  CFTypeRef *v8;
  const __CFDate *v9;
  const __CFDate *v10;
  const __CFData *v11;
  BOOL v12;
  __CFString ***v13;
  __CFString ***v14;
  CFComparisonResult v15;
  uint64_t v16;
  uint64_t v17;
  const __CFData *v18;
  CFIndex Length;
  CFIndex v21;
  unint64_t v22;
  size_t v23;
  const UInt8 *BytePtr;
  const UInt8 *v25;
  int v26;
  BOOL v27;
  _BOOL4 v28;
  __CFString **v29;
  uint64_t *v30;
  uint64_t **v31;
  uint64_t *v32;
  __CFString **v33;
  __CFString *v34;
  __CFString **v35;
  __CFString *v36;
  const void *v37;
  NSObject *v38;
  uint64_t v39;
  uint64_t v40;
  __CFString ***v41;
  uint64_t v42;
  uint64_t v43;
  NSObject *v44;
  uint64_t v45;
  NSObject *v46;
  uint64_t v47;
  _BYTE cf[24];

  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  v6 = *(__CFString ****)(a1 + 72);
  v7 = (__CFString **)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
  *(_QWORD *)cf = 0;
  v8 = sub_100012504(v6[2], kSecAttrModificationDate, v7);
  v9 = (const __CFDate *)sub_100019204(v6, (uint64_t)v8, (__CFString **)cf);
  v10 = (const __CFDate *)sub_100019204(a2, (uint64_t)v8, (__CFString **)cf);
  v11 = v10;
  if (v9)
    v12 = v10 == 0;
  else
    v12 = 1;
  if (v12)
    goto LABEL_6;
  v15 = CFDateCompare(v9, v10, 0);
  v14 = a2;
  if (v15 == kCFCompareLessThan)
    goto LABEL_40;
  if (v15)
  {
    v14 = 0;
    if (v15 == kCFCompareGreaterThan)
      v14 = v6;
    goto LABEL_40;
  }
  v16 = sub_10001E6A8(v6[2], 7, (__CFString **)cf);
  v9 = (const __CFDate *)sub_100019204(v6, v16, (__CFString **)cf);
  v17 = sub_10001E6A8(a2[2], 7, (__CFString **)cf);
  v18 = (const __CFData *)sub_100019204(a2, v17, (__CFString **)cf);
  v11 = v18;
  if (!v9 || v18 == 0)
  {
LABEL_6:
    if (SecErrorGetOSStatus(*(_QWORD *)cf) == -26275)
    {
      if (v9)
        v13 = v6;
      else
        v13 = 0;
      if (v11)
        v14 = a2;
      else
        v14 = v13;
    }
    else
    {
      v14 = 0;
    }
    goto LABEL_40;
  }
  Length = CFDataGetLength(v9);
  v21 = CFDataGetLength(v11);
  v22 = v21;
  if (Length < 0 || v21 < 0)
  {
    v14 = a2;
    if (Length > v21)
      goto LABEL_40;
    v28 = Length < v21;
  }
  else
  {
    if (Length >= v21)
      v23 = v21;
    else
      v23 = Length;
    BytePtr = CFDataGetBytePtr(v9);
    v25 = CFDataGetBytePtr(v11);
    v26 = memcmp(BytePtr, v25, v23);
    v14 = a2;
    if (v26 > 0)
      goto LABEL_40;
    v27 = !v26 && Length > v22;
    v14 = a2;
    if (v27)
      goto LABEL_40;
    v28 = v26 == 0;
    if (Length >= v22)
      v28 = 0;
    if (v26 < 0)
      v28 = 1;
  }
  v14 = v6;
  if (!v28)
    v14 = a2;
LABEL_40:
  if (!*(_QWORD *)cf)
  {
LABEL_44:
    if (v14 && a2 && v14 != a2)
    {
      v29 = v14[2];
      v30 = (uint64_t *)v29[2];
      if (!v30)
        goto LABEL_62;
      v31 = (uint64_t **)(v29 + 3);
      do
      {
        if (*v30)
        {
          if (CFEqual((CFTypeRef)*v30, CFSTR("UUID")))
            sub_100115FE0((uint64_t)v14, a2, v30);
          if (*v30 && CFEqual((CFTypeRef)*v30, CFSTR("persistref")))
            sub_100115FE0((uint64_t)v14, a2, v30);
        }
        v32 = *v31++;
        v30 = v32;
      }
      while (v32);
      v33 = v14[2];
      v34 = v33[2];
      if (!v34)
      {
LABEL_62:
        CFRetain(v14);
        goto LABEL_63;
      }
      v35 = v33 + 3;
      do
      {
        if ((BYTE2(v34->data) & 2) != 0)
          sub_100115FE0((uint64_t)v14, a2, (uint64_t *)v34);
        v36 = *v35++;
        v34 = v36;
      }
      while (v36);
    }
    if (!v14)
      goto LABEL_63;
    goto LABEL_62;
  }
  if (v14 || *v7)
  {
    CFRelease(*(CFTypeRef *)cf);
    goto LABEL_44;
  }
  *v7 = *(__CFString **)cf;
LABEL_63:
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v14;
  v37 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  if (v37)
  {
    if (*(_QWORD *)(a1 + 80))
    {
      **(_QWORD **)(a1 + 80) = CFRetain(v37);
      v37 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
    }
    if (CFEqual(v37, a2))
    {
      if ((sub_100004514(a2) & 1) == 0)
      {
        v38 = sub_10000EF14("ds");
        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)cf = 138477827;
          *(_QWORD *)&cf[4] = a2;
          _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "Conflict resolver chose my (local) item: %{private}@", cf, 0xCu);
        }
      }
      v39 = 1;
    }
    else
    {
      v40 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8);
      v41 = *(__CFString ****)(v40 + 24);
      if (v41 != a2)
      {
        if (!a2 || (CFRetain(a2), (v41 = *(__CFString ****)(v40 + 24)) != 0))
          CFRelease(v41);
        *(_QWORD *)(v40 + 24) = a2;
      }
      v42 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
      v43 = *(_QWORD *)(v42 + 24);
      if (v43)
        CFRetain(*(CFTypeRef *)(v42 + 24));
      *a3 = v43;
      if (CFEqual(*(CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), *(CFTypeRef *)(a1 + 72)))
      {
        if ((sub_100004514(*(__CFString ****)(a1 + 72)) & 1) == 0)
        {
          v44 = sub_10000EF14("ds");
          if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
          {
            v45 = *(_QWORD *)(a1 + 72);
            *(_DWORD *)cf = 138477827;
            *(_QWORD *)&cf[4] = v45;
            _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "Conflict resolver chose peers item: %{private}@", cf, 0xCu);
          }
        }
        v39 = 2;
      }
      else
      {
        if ((sub_100004514(*(__CFString ****)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24)) & 1) == 0)
        {
          v46 = sub_10000EF14("ds");
          if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
          {
            v47 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
            *(_DWORD *)cf = 138477827;
            *(_QWORD *)&cf[4] = v47;
            _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "Conflict resolver created a new item; return it to our caller: %{private}@",
              cf,
              0xCu);
          }
        }
        v39 = 3;
      }
    }
  }
  else
  {
    v39 = 0;
  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = v39;
}

uint64_t sub_100127ACC(uint64_t a1)
{
  return *(_QWORD *)(a1 + 160);
}

void sub_100127AD4(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD v3[6];

  v2 = *(_QWORD *)(a1 + 152);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = sub_10012A688;
  v3[3] = &unk_1002DF0E0;
  v3[4] = a2;
  v3[5] = a1;
  sub_100030A78(v2, v3);
}

CFTypeRef sub_100127B2C(uint64_t a1, const __CFSet *a2, CFTypeRef *a3)
{
  const __CFArray *Mutable;
  uint64_t v7;
  CFTypeRef v8;
  const void *v9;
  CFTypeRef v10;
  CFIndex Count;
  CFIndex v12;
  CFIndex v13;
  const void **ValueAtIndex;
  NSObject *v15;
  _QWORD context[8];
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  char v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  CFTypeRef cf;
  CFTypeRef *p_cf;
  uint64_t v28;
  uint64_t v29;
  __int128 buf;
  BOOL (*v31)(uint64_t, uint64_t);
  void *v32;
  uint64_t *v33;
  CFTypeRef *v34;
  const __CFArray *v35;

  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, 0);
  v18 = 0;
  v19 = &v18;
  v20 = 0x2000000000;
  v21 = 1;
  context[0] = _NSConcreteStackBlock;
  context[1] = 0x40000000;
  context[2] = sub_1001299F4;
  context[3] = &unk_1002DF108;
  context[4] = &v18;
  context[5] = a1;
  context[6] = Mutable;
  context[7] = a3;
  CFSetApplyFunction(a2, (CFSetApplierFunction)sub_100129F24, context);
  if (*((_BYTE *)v19 + 24))
  {
    cf = 0;
    p_cf = &cf;
    v28 = 0x2000000000;
    v29 = 0;
    v22 = 0;
    v23 = &v22;
    v24 = 0x2000000000;
    v25 = 0;
    v7 = *(_QWORD *)(a1 + 152);
    *(_QWORD *)&buf = _NSConcreteStackBlock;
    *((_QWORD *)&buf + 1) = 0x40000000;
    v31 = sub_100129F38;
    v32 = &unk_1002DF1F8;
    v34 = &cf;
    v35 = Mutable;
    v33 = &v22;
    if ((sub_100011A30(0, 1, v7, a3, &buf) & 1) == 0)
    {
      v8 = p_cf[3];
      if (v8)
        CFRelease(v8);
    }
    v9 = (const void *)v23[3];
    if (v9)
    {
      if (a3 && !*a3)
        *a3 = v9;
      else
        CFRelease(v9);
    }
    v10 = p_cf[3];
    _Block_object_dispose(&v22, 8);
    _Block_object_dispose(&cf, 8);
  }
  else
  {
    v10 = 0;
  }
  Count = CFArrayGetCount(Mutable);
  if (Count >= 1)
  {
    v12 = Count;
    v13 = 0;
    while (1)
    {
      ValueAtIndex = (const void **)CFArrayGetValueAtIndex(Mutable, v13);
      cf = 0;
      if ((sub_100011108(ValueAtIndex, (CFErrorRef *)&cf) & 1) != 0)
        goto LABEL_22;
      v15 = sub_10000EF14("SecError");
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138412290;
        *(_QWORD *)((char *)&buf + 4) = cf;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "query_destroy failed: %@", (uint8_t *)&buf, 0xCu);
      }
      if (!cf)
        goto LABEL_21;
      if (!a3 || *a3)
        break;
      *a3 = cf;
      if (v10)
      {
LABEL_25:
        CFRelease(v10);
        v10 = 0;
      }
LABEL_22:
      if (v12 == ++v13)
        goto LABEL_26;
    }
    CFRelease(cf);
LABEL_21:
    if (v10)
      goto LABEL_25;
    goto LABEL_22;
  }
LABEL_26:
  if (Mutable)
    CFRelease(Mutable);
  _Block_object_dispose(&v18, 8);
  return v10;
}

uint64_t sub_100127DF0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __CFString **a5)
{
  CFStringRef v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  __CFDictionary *v18;
  uint64_t v19;
  const void **v20;
  const void **v21;
  const void *v22;
  NSObject *v23;
  __CFString *v24;
  uint64_t v25;
  _QWORD v27[10];
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  uint8_t buf[4];
  uint64_t v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  __CFString *v37;

  v10 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("SOSDataSource-%@"), *(_QWORD *)(a1 + 160));
  v18 = sub_1000FF1C8(kCFAllocatorDefault, v11, v12, v13, v14, v15, v16, v17, (void *)kSecAttrAccessGroup, kSOSInternalAccessGroup);
  if (v10)
    CFRelease(v10);
  v28 = 0;
  v29 = &v28;
  v30 = 0x2000000000;
  v31 = 0;
  v19 = sub_1000119B8((uint64_t)CFSTR("genp"), &qword_100341240, (uint64_t)&unk_100341238);
  v20 = (const void **)sub_1000114E8(v19, 0, v18, 0, a5);
  if (v20)
  {
    v21 = v20;
    v22 = v20[1];
    if (v22)
      CFRelease(v22);
    v21[1] = v18;
    v27[0] = _NSConcreteStackBlock;
    v27[1] = 0x40000000;
    v27[2] = sub_10012984C;
    v27[3] = &unk_1002DF2F8;
    v27[6] = a5;
    v27[7] = v18;
    v27[8] = a2;
    v27[9] = a3;
    v27[4] = &v28;
    v27[5] = v21;
    if (a4)
      sub_10012984C((uint64_t)v27, a4);
    else
      sub_100011A30(0, 1, *(_QWORD *)(a1 + 152), a5, v27);
    sub_100011108(v21, (CFErrorRef *)a5);
  }
  else if (v18)
  {
    CFRelease(v18);
  }
  if (!v29[3])
  {
    v23 = sub_10000EF14("ds");
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      if (a5)
        v24 = *a5;
      else
        v24 = 0;
      *(_DWORD *)buf = 138412802;
      v33 = a2;
      v34 = 2112;
      v35 = a3;
      v36 = 2112;
      v37 = v24;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "failed to load %@@%@ state: %@", buf, 0x20u);
    }
  }
  v25 = v29[3];
  _Block_object_dispose(&v28, 8);
  return v25;
}

uint64_t sub_100128094(uint64_t a1, CFDictionaryRef theDict, __CFString **a3)
{
  const __CFDictionary *MutableCopy;
  uint64_t v7;
  const void **v8;
  const void **v9;
  const void *v10;
  uint64_t v11;
  NSObject *v12;
  __CFString *v13;
  uint64_t v14;
  _QWORD v16[9];
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint8_t buf[4];
  CFDictionaryRef v22;
  __int16 v23;
  __CFString *v24;

  MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, theDict);
  v17 = 0;
  v18 = &v17;
  v19 = 0x2000000000;
  v20 = 0;
  v7 = sub_1000119B8((uint64_t)CFSTR("genp"), &qword_100341240, (uint64_t)&unk_100341238);
  v8 = (const void **)sub_1000114E8(v7, 0, MutableCopy, 0, a3);
  if (v8)
  {
    v9 = v8;
    v10 = v8[1];
    if (v10)
      CFRelease(v10);
    v9[1] = MutableCopy;
    v11 = *(_QWORD *)(a1 + 152);
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 0x40000000;
    v16[2] = sub_1001296B4;
    v16[3] = &unk_1002DF368;
    v16[6] = a3;
    v16[7] = MutableCopy;
    v16[8] = theDict;
    v16[4] = &v17;
    v16[5] = v9;
    sub_100011A30(0, 1, v11, a3, v16);
    sub_100011108(v9, (CFErrorRef *)a3);
  }
  else if (MutableCopy)
  {
    CFRelease(MutableCopy);
  }
  if (!v18[3])
  {
    v12 = sub_10000EF14("ds");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      if (a3)
        v13 = *a3;
      else
        v13 = 0;
      *(_DWORD *)buf = 138412546;
      v22 = theDict;
      v23 = 2112;
      v24 = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "failed to load item %@: %@", buf, 0x16u);
    }
  }
  v14 = v18[3];
  _Block_object_dispose(&v17, 8);
  return v14;
}

uint64_t sub_100128278(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4, uint64_t a5)
{
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  _QWORD v15[14];
  _QWORD v16[4];
  _QWORD v17[4];
  _QWORD v18[4];
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  char v22;
  _OWORD v23[2];
  _OWORD v24[2];
  _OWORD v25[2];

  v19 = 0;
  v20 = &v19;
  v21 = 0x2000000000;
  v22 = 1;
  v10 = (_QWORD *)sub_1000119B8((uint64_t)CFSTR("genp"), &qword_100341240, (uint64_t)&unk_100341238);
  v11 = sub_10001E6A8(v10, 7, a4);
  if (v11)
  {
    memset(v25, 0, sizeof(v25));
    memset(v24, 0, sizeof(v24));
    memset(v23, 0, sizeof(v23));
    v18[0] = 0;
    v18[1] = v18;
    v18[2] = 0x2000000000;
    v18[3] = v25;
    v17[0] = 0;
    v17[1] = v17;
    v17[2] = 0x2000000000;
    v17[3] = v24;
    v16[0] = 0;
    v16[1] = v16;
    v16[2] = 0x2000000000;
    v16[3] = v23;
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 0x40000000;
    v15[2] = sub_100129114;
    v15[3] = &unk_1002DF460;
    v15[8] = v18;
    v15[9] = v17;
    v15[4] = &stru_1002DF3A8;
    v15[5] = &stru_1002DF3E8;
    v15[10] = v16;
    v15[11] = a4;
    v15[12] = a3;
    v15[13] = v11;
    v15[6] = a5;
    v15[7] = &v19;
    if (a2)
    {
      sub_100129114((uint64_t)v15, a2);
      v12 = *((_BYTE *)v20 + 24) != 0;
    }
    else
    {
      v13 = sub_100011A30(0, 1, *(_QWORD *)(a1 + 152), a4, v15);
      if (*((_BYTE *)v20 + 24))
        v12 = v13;
      else
        v12 = 0;
      *((_BYTE *)v20 + 24) = v12;
    }
    _Block_object_dispose(v16, 8);
    _Block_object_dispose(v17, 8);
    _Block_object_dispose(v18, 8);
  }
  else
  {
    v12 = 0;
  }
  _Block_object_dispose(&v19, 8);
  return v12;
}

uint64_t sub_100128468(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5)
{
  uint64_t v5;
  _QWORD v7[7];
  char v8;

  v5 = *(_QWORD *)(a1 + 152);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_100128FE0;
  v7[3] = &unk_1002DF4D8;
  v7[5] = a3;
  v7[6] = a2;
  v8 = a4;
  v7[4] = a5;
  return sub_100011A30(1, 1, v5, a2, v7);
}

uint64_t sub_1001284D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD v6[5];

  v4 = *(_QWORD *)(a1 + 152);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = sub_100128F4C;
  v6[3] = &unk_1002DF528;
  v6[4] = a4;
  return sub_100011A30(0, 1, v4, a2, v6);
}

uint64_t sub_10012853C()
{
  return 1;
}

BOOL sub_100128544(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, __CFString **a6)
{
  CFStringRef v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  __CFDictionary *v18;
  uint64_t v19;
  const void *v20;
  uint64_t v21;
  NSObject *v22;
  __CFString *v23;
  uint8_t buf[4];
  uint64_t v26;
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  __CFString *v30;

  v10 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("SOSDataSource-%@"), *(_QWORD *)(a1 + 160));
  v18 = sub_1000FF1C8(kCFAllocatorDefault, v11, v12, v13, v14, v15, v16, v17, (void *)kSecAttrAccessGroup, kSOSInternalAccessGroup);
  if (v10)
    CFRelease(v10);
  v19 = sub_1000119B8((uint64_t)CFSTR("genp"), &qword_100341240, (uint64_t)&unk_100341238);
  v20 = sub_10001E9E8(v19, v18, dword_1003414E0, a6);
  v21 = sub_10012708C(a2, (uint64_t)v20, 0, a6);
  if (!v21)
  {
    v22 = sub_10000EF14("SecError");
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      if (a6)
        v23 = *a6;
      else
        v23 = 0;
      *(_DWORD *)buf = 138412802;
      v26 = a3;
      v27 = 2112;
      v28 = a4;
      v29 = 2112;
      v30 = v23;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "failed to save %@@%@ state: %@", buf, 0x20u);
    }
  }
  if (v20)
    CFRelease(v20);
  if (v18)
    CFRelease(v18);
  return v21 != 0;
}

BOOL sub_100128760(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __CFString **a5)
{
  CFStringRef v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  __CFDictionary *v15;
  uint64_t v16;
  CFStringRef **v17;
  _BOOL8 v18;

  v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("SOSDataSource-%@"), *(_QWORD *)(a1 + 160));
  v15 = sub_1000FF1C8(kCFAllocatorDefault, v8, v9, v10, v11, v12, v13, v14, (void *)kSecAttrAccessGroup, kSOSInternalAccessGroup);
  if (v7)
    CFRelease(v7);
  v16 = sub_1000119B8((uint64_t)CFSTR("genp"), &qword_100341240, (uint64_t)&unk_100341238);
  v17 = (CFStringRef **)sub_10001E9E8(v16, v15, dword_1003414E0, a5);
  v18 = sub_10001E020(v17, a4, (CFTypeRef *)a5, (uint64_t)&stru_1002DE790);
  if (v15)
    CFRelease(v15);
  if (v17)
    CFRelease(v17);
  return v18;
}

BOOL sub_1001288B8(uint64_t a1, int a2, CFDictionaryRef theDict, __CFString **a4)
{
  const void *Value;
  const __CFData *v9;
  BOOL v10;
  const __CFData *v12;
  __CFString **v13;
  const void *v14;
  const void *v15;
  _BOOL8 v16;

  Value = CFDictionaryGetValue(theDict, CFSTR("class"));
  v9 = (const __CFData *)CFDictionaryGetValue(theDict, CFSTR("data"));
  if (Value)
    v10 = v9 == 0;
  else
    v10 = 1;
  if (v10)
    return sub_100019F20(-26275, a4, CFSTR("no class or data in object"));
  v12 = v9;
  v13 = sub_100011884(Value);
  if (!v13)
    return sub_100019F20(-26275, a4, CFSTR("no such class %@; update kc_class_with_name "), Value);
  v14 = sub_1001162B4(kCFAllocatorDefault, v13, v12, a2, 0, a4);
  if (!v14)
    return 0;
  v15 = v14;
  v16 = sub_10012708C(a1, (uint64_t)v14, 0, a4) != 0;
  CFRelease(v15);
  return v16;
}

const void *sub_1001289D8(_QWORD **a1, __CFString **a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;

  v4 = sub_10001E6A8(a1[2], 7, a2);
  v5 = sub_100019204(a1, v4, a2);
  v6 = v5;
  if (v5)
    CFRetain(v5);
  return v6;
}

const void *sub_100128A2C(_QWORD **a1)
{
  uint64_t v2;
  const void *v3;
  const void *v4;

  v2 = sub_10001E6A8(a1[2], 6, 0);
  if (!v2)
    return 0;
  v3 = sub_100019204(a1, v2, 0);
  v4 = v3;
  if (v3)
    CFRetain(v3);
  return v4;
}

const void *sub_100128A88(const __CFDictionary *a1, __CFString **a2)
{
  const void *Value;
  const void *v5;
  __CFString **v6;

  Value = CFDictionaryGetValue(a1, kSecClass);
  if (Value)
  {
    v5 = Value;
    v6 = sub_100011884(Value);
    if (v6)
      return sub_10001E9E8((uint64_t)v6, a1, dword_1003414E0, a2);
    sub_100019F20(-25306, a2, CFSTR("can find class named: %@"), v5);
  }
  else
  {
    sub_100019F20(-50, a2, CFSTR("query missing %@ attribute"), kSecClass);
  }
  return 0;
}

__CFDictionary *sub_100128B30(uint64_t a1, __CFString **a2)
{
  __CFDictionary *v4;
  __CFDictionary *v5;
  __CFDictionary *v6;
  __CFDictionary *v7;
  _QWORD v9[5];
  _QWORD context[5];

  v4 = sub_10001904C((_QWORD *)a1, 32, 0x20000, a2);
  v5 = sub_10001904C((_QWORD *)a1, 128, 0x20000, a2);
  v6 = sub_10001904C((_QWORD *)a1, 0x2000, 0x20000, a2);
  v7 = v6;
  if (v5)
  {
    if (v6)
    {
      context[0] = _NSConcreteStackBlock;
      context[1] = 0x40000000;
      context[2] = sub_100128F24;
      context[3] = &unk_1002DF548;
      context[4] = v5;
      CFDictionaryApplyFunction(v6, (CFDictionaryApplierFunction)sub_100128F2C, context);
    }
    if (v4)
    {
      v9[0] = _NSConcreteStackBlock;
      v9[1] = 0x40000000;
      v9[2] = sub_100128F44;
      v9[3] = &unk_1002DF568;
      v9[4] = v5;
      CFDictionaryApplyFunction(v4, (CFDictionaryApplierFunction)sub_100128F2C, v9);
    }
    CFDictionaryAddValue(v5, kSecClass, **(const void ***)(a1 + 16));
  }
  if (v4)
    CFRelease(v4);
  if (v7)
    CFRelease(v7);
  return v5;
}

CFDictionaryRef sub_100128C6C(uint64_t a1, const __CFData *a2, __CFString **a3)
{
  uint64_t v6;
  __CFDictionary *v7;
  __CFDictionary *v8;
  const __CFDictionary *v9;
  const void *v10;
  const void *v11;
  NSObject *v12;
  CFDictionaryRef v13;
  NSObject *v15;
  const __CFString *v16;
  const __CFString *v17;
  const __CFString *v18;
  const __CFString *v19;
  __CFData *v20;
  void *values[2];
  CFTypeRef cf;
  uint8_t buf[4];
  const __CFString *v24;
  __int16 v25;
  const __CFString *v26;
  __int16 v27;
  const __CFString *v28;

  v6 = sub_10001E6A8(*(_QWORD **)(a1 + 16), 7, a3);
  values[0] = (void *)sub_100019204((const void *)a1, v6, a3);
  if (!values[0])
    return 0;
  v20 = 0;
  v7 = sub_10001904C((_QWORD *)a1, 128, 0, a3);
  v8 = sub_10001904C((_QWORD *)a1, 0x2000, 0, a3);
  v9 = v8;
  if (v7 && v8)
  {
    v10 = sub_10001D188((_QWORD **)a1, a3);
    if (v10)
    {
      v11 = v10;
      if (sub_10011C114(a2, (uint64_t)v10, *(const __CFData **)(a1 + 56), v7, v9, &v20, 0, 0, (CFTypeRef *)a3))
      {
        *(_DWORD *)(a1 + 40) = 4;
      }
      else
      {
        v15 = sub_10000EF14("SecCritical");
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          if (a3)
            v16 = *a3;
          else
            v16 = &stru_1002EE888;
          *(_DWORD *)buf = 138412290;
          v24 = v16;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "ks_encrypt_data (db): failed: %@", buf, 0xCu);
        }
      }
      CFRelease(v11);
    }
    goto LABEL_23;
  }
  if (!((unint64_t)v7 | (unint64_t)v8))
    goto LABEL_13;
  if (dword_10033F080 != -1
    || (v12 = sub_10000EF14("SecEmergency"), !os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)))
  {
    if (v7)
      goto LABEL_23;
LABEL_11:
    if (!v9)
      goto LABEL_13;
    goto LABEL_12;
  }
  v17 = CFSTR("missing");
  if (v7)
    v18 = CFSTR("present");
  else
    v18 = CFSTR("missing");
  if (v9)
    v17 = CFSTR("present");
  if (a3)
    v19 = *a3;
  else
    v19 = CFSTR("no error pointer");
  *(_DWORD *)buf = 138412802;
  v24 = v18;
  v25 = 2112;
  v26 = v17;
  v27 = 2112;
  v28 = v19;
  _os_log_fault_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_FAULT, "SecDbItemCopyEncryptedDataToBackup: not all plists are present: attributes: %@, auth_attributes: %@ : %@", buf, 0x20u);
  if (!v7)
    goto LABEL_11;
LABEL_23:
  CFRelease(v7);
  if (v9)
LABEL_12:
    CFRelease(v9);
LABEL_13:
  cf = v20;
  if (!v20)
    return 0;
  values[1] = **(void ***)(a1 + 16);
  v13 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)&off_10033FD48, (const void **)values, 3, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFRelease(cf);
  return v13;
}

void sub_100128F24(uint64_t a1, const void *a2, const void *a3)
{
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), a2, a3);
}

uint64_t sub_100128F2C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void sub_100128F44(uint64_t a1, const void *a2, const void *a3)
{
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), a2, a3);
}

uint64_t sub_100128F4C(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  _QWORD v4[6];
  _QWORD block[5];

  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_100128FD0;
  v4[3] = &unk_1002DF500;
  v4[4] = *(_QWORD *)(a1 + 32);
  v4[5] = a2;
  v2 = *(NSObject **)(*(_QWORD *)(a2 + 16) + 32);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_1000321C0;
  block[3] = &unk_1002DB530;
  block[4] = v4;
  dispatch_sync(v2, block);
  return 1;
}

uint64_t sub_100128FD0(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
}

BOOL sub_100128FE0(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  CFTypeRef *v5;
  _QWORD v7[6];
  char v8;

  v3 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(a1 + 40) == 1)
    v4 = 2;
  else
    v4 = 4;
  v7[0] = _NSConcreteStackBlock;
  v7[2] = sub_100129058;
  v7[3] = &unk_1002DF4B0;
  v5 = *(CFTypeRef **)(a1 + 48);
  v7[1] = 0x40000000;
  v8 = *(_BYTE *)(a1 + 56);
  v7[4] = v3;
  v7[5] = a2;
  return sub_10001AC94(a2, v4, v5, (uint64_t)v7);
}

void sub_100129058(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  NSObject *v3;
  _QWORD v4[7];
  _QWORD block[5];

  if (*(_BYTE *)(a1 + 48))
  {
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000;
    v4[2] = sub_100129100;
    v4[3] = &unk_1002DF488;
    v2 = *(_QWORD *)(a1 + 40);
    v4[4] = *(_QWORD *)(a1 + 32);
    v4[5] = v2;
    v4[6] = a2;
    v3 = *(NSObject **)(*(_QWORD *)(v2 + 16) + 32);
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = sub_1000321C0;
    block[3] = &unk_1002DB530;
    block[4] = v4;
    dispatch_sync(v3, block);
  }
  else
  {
    (*(void (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), a2);
  }
}

uint64_t sub_100129100(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(a1[4] + 16))(a1[4], a1[5], a1[6]);
}

uint64_t sub_100129114(uint64_t a1, uint64_t a2)
{
  unint64_t i;
  char v5;
  _QWORD *v6;
  __CFString *v7;
  sqlite3_stmt *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t j;
  sqlite3_stmt *v14;
  BOOL v15;
  uint64_t v16;
  BOOL v17;
  const void *v18;
  const void **v19;
  char v20;
  uint64_t v21;
  char v22;
  _QWORD v24[4];
  int8x16_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;

  for (i = 0; i != 32; i += 8)
  {
    v5 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24);
    if (v5)
    {
      if (qword_1003411E0 != -1)
        dispatch_once(&qword_1003411E0, &stru_1002DF188);
      v6 = sub_1000114E8(qword_1003411E8[i / 8], 0, 0, 0, *(__CFString ***)(a1 + 88));
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24) + i) = v6;
      if (v6
        && (v7 = sub_10001EA54(*(CFDictionaryRef **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24) + i), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), 0), (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24) + i) = v7) != 0))
      {
        v8 = sub_100012AE8(a2, *(const __CFString **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24) + i), 0, *(CFTypeRef **)(a1 + 88));
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 24) + i) = v8;
        v5 = v8 != 0;
      }
      else
      {
        v5 = 0;
      }
    }
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = v5;
  }
  v9 = *(_QWORD *)(a1 + 56);
  if (*(_BYTE *)(*(_QWORD *)(v9 + 8) + 24))
  {
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 0x40000000;
    v24[2] = sub_100129364;
    v24[3] = &unk_1002DF438;
    v10 = *(_QWORD *)(a1 + 80);
    v11 = *(_QWORD *)(a1 + 88);
    v28 = *(_QWORD *)(a1 + 64);
    v29 = v10;
    v12 = *(_QWORD *)(a1 + 96);
    v30 = *(_QWORD *)(a1 + 104);
    v31 = v11;
    v32 = a2;
    v25 = vextq_s8(*(int8x16_t *)(a1 + 32), *(int8x16_t *)(a1 + 32), 8uLL);
    v26 = *(_QWORD *)(a1 + 48);
    v27 = v9;
    sub_1001E8388(v12, (uint64_t)v24);
  }
  for (j = 0; j != 32; j += 8)
  {
    v14 = *(sqlite3_stmt **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 24) + j);
    if (v14)
      v15 = sub_100012D08(v14, *(CFTypeRef **)(a1 + 88));
    else
      v15 = 1;
    v16 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
    if (*(_BYTE *)(v16 + 24))
      v17 = v15;
    else
      v17 = 0;
    *(_BYTE *)(v16 + 24) = v17;
    v18 = *(const void **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24) + j);
    if (v18)
      CFRelease(v18);
    v19 = *(const void ***)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24) + j);
    if (v19)
    {
      v20 = sub_100011108(v19, *(CFErrorRef **)(a1 + 88));
      v21 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
      if (*(_BYTE *)(v21 + 24))
        v22 = v20;
      else
        v22 = 0;
      *(_BYTE *)(v21 + 24) = v22;
    }
  }
  return 1;
}

void sub_100129364(uint64_t a1, void *value)
{
  unint64_t v4;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  sqlite3_stmt *v8;
  uint64_t v9;
  CFTypeRef *v10;
  char v11;
  uint64_t v12;
  char v13;
  sqlite3_stmt *v14;
  CFTypeRef *v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;
  BOOL v19;
  const void *v20;
  _QWORD v21[10];
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;

  v22 = 0;
  v23 = &v22;
  v24 = 0x2000000000;
  v25 = 0;
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24))
  {
    v4 = 0;
    do
    {
      if (v23[3])
        v5 = 1;
      else
        v5 = v4 >= 4;
      if (v5)
        break;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24) + 8 * v4)+ 8), **(const void ***)(a1 + 80), value);
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = sub_10001ED30(*(CFDictionaryRef **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24)+ 8 * v4), *(sqlite3_stmt **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8)+ 24)+ 8 * v4), *(__CFString ***)(a1 + 88), *(_QWORD *)(a1 + 32), 0);
      if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24))
        break;
      v7 = *(_QWORD *)(a1 + 64);
      v6 = *(_QWORD *)(a1 + 72);
      v8 = *(sqlite3_stmt **)(*(_QWORD *)(*(_QWORD *)(v6 + 8) + 24) + 8 * v4);
      v10 = *(CFTypeRef **)(a1 + 88);
      v9 = *(_QWORD *)(a1 + 96);
      v21[0] = _NSConcreteStackBlock;
      v21[1] = 0x40000000;
      v21[2] = sub_100129588;
      v21[3] = &unk_1002DF410;
      v21[6] = v7;
      v21[7] = v6;
      v21[8] = v4;
      v21[9] = v10;
      v21[4] = *(_QWORD *)(a1 + 40);
      v21[5] = &v22;
      v11 = sub_100019C40(v9, v8, v10, (uint64_t)v21);
      v12 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
      v13 = *(_BYTE *)(v12 + 24) ? v11 : 0;
      *(_BYTE *)(v12 + 24) = v13;
      if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24))
        break;
      v14 = *(sqlite3_stmt **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24) + 8 * v4);
      v15 = *(CFTypeRef **)(a1 + 88);
      v16 = sqlite3_reset(v14);
      v17 = sub_100013978(v16, v14, v15, CFSTR("reset"));
      v18 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
      v19 = *(_BYTE *)(v18 + 24) && v17;
      *(_BYTE *)(v18 + 24) = v19;
      ++v4;
    }
    while (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24));
  }
  (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
  v20 = (const void *)v23[3];
  if (v20)
    CFRelease(v20);
  _Block_object_dispose(&v22, 8);
}

uint64_t sub_100129588(uint64_t *a1)
{
  uint64_t result;

  result = sub_10001E594(kCFAllocatorDefault, **(_QWORD ***)(*(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24) + 8 * a1[8]), *(sqlite3_stmt **)(*(_QWORD *)(*(_QWORD *)(a1[7] + 8) + 24) + 8 * a1[8]), dword_1003414E0, a1[4]);
  *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24) = result;
  return result;
}

void sub_1001295F0(id a1)
{
  qword_1003411E8[0] = sub_1000119B8((uint64_t)CFSTR("genp"), &qword_100341240, (uint64_t)&unk_100341238);
  qword_1003411F0 = sub_1000119B8((uint64_t)CFSTR("inet"), &qword_100341250, (uint64_t)&unk_100341248);
  qword_1003411F8 = sub_1000119B8((uint64_t)CFSTR("keys"), &qword_100341270, (uint64_t)&unk_100341268);
  qword_100341200 = sub_1000119B8((uint64_t)CFSTR("cert"), &qword_100341260, (uint64_t)&unk_100341258);
}

BOOL sub_100129690(id a1, const SecDbAttr *a2)
{
  return a2->var1 == 7;
}

BOOL sub_1001296A0(id a1, const SecDbAttr *a2)
{
  return (a2->var1 & 0xFFFFFFFE) == 8;
}

BOOL sub_1001296B4(_QWORD *a1, uint64_t a2)
{
  CFTypeRef *v2;
  uint64_t v3;
  CFDictionaryRef *v4;
  _QWORD v6[7];
  Block_layout v7;
  uint64_t v8;

  v7.isa = _NSConcreteStackBlock;
  *(_QWORD *)&v7.flags = 0x40000000;
  v7.invoke = (void (*)(void *, ...))sub_100129748;
  v7.descriptor = (Block_descriptor_1 *)&unk_1002DF318;
  v2 = (CFTypeRef *)a1[6];
  v8 = a1[7];
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = sub_10012976C;
  v6[3] = &unk_1002DF340;
  v3 = a1[8];
  v4 = (CFDictionaryRef *)a1[5];
  v6[4] = a1[4];
  v6[5] = v3;
  v6[6] = v2;
  return sub_10001E280(v4, a2, v2, 0, &v7, 0, 0, (uint64_t)v6);
}

BOOL sub_100129748(uint64_t a1, const void **a2)
{
  return CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 32), *a2) != 0;
}

const void *sub_10012976C(uint64_t a1, const void *a2)
{
  NSObject *v4;
  uint64_t v5;
  const void *result;
  const void *v7;
  int v8;
  uint64_t v9;

  v4 = sub_10000EF14("ds");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *(_QWORD *)(a1 + 40);
    v8 = 138412290;
    v9 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "found item for keys %@", (uint8_t *)&v8, 0xCu);
  }
  result = sub_100019204(a2, (uint64_t)&off_1002DFE00, *(__CFString ***)(a1 + 48));
  v7 = result;
  if (result)
    result = CFRetain(result);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v7;
  return result;
}

BOOL sub_10012984C(uint64_t a1, uint64_t a2)
{
  CFTypeRef *v2;
  CFDictionaryRef *v3;
  _QWORD v5[5];
  __int128 v6;
  CFTypeRef *v7;
  Block_layout v8;
  uint64_t v9;

  v8.isa = _NSConcreteStackBlock;
  *(_QWORD *)&v8.flags = 0x40000000;
  v8.invoke = (void (*)(void *, ...))sub_1001298E4;
  v8.descriptor = (Block_descriptor_1 *)&unk_1002DF2A8;
  v2 = *(CFTypeRef **)(a1 + 48);
  v9 = *(_QWORD *)(a1 + 56);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_100129908;
  v5[3] = &unk_1002DF2D0;
  v6 = *(_OWORD *)(a1 + 64);
  v3 = *(CFDictionaryRef **)(a1 + 40);
  v5[4] = *(_QWORD *)(a1 + 32);
  v7 = v2;
  return sub_10001E280(v3, a2, v2, 0, &v8, 0, 0, (uint64_t)v5);
}

BOOL sub_1001298E4(uint64_t a1, const void **a2)
{
  return CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 32), *a2) != 0;
}

const void *sub_100129908(uint64_t a1, const void *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  const void *result;
  const void *v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  uint64_t v12;

  v4 = sub_10000EF14("ds");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *(_QWORD *)(a1 + 40);
    v6 = *(_QWORD *)(a1 + 48);
    v9 = 138412546;
    v10 = v5;
    v11 = 2112;
    v12 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "found item for key %@@%@", (uint8_t *)&v9, 0x16u);
  }
  result = sub_100019204(a2, (uint64_t)&off_1002DFE00, *(__CFString ***)(a1 + 56));
  v8 = result;
  if (result)
    result = CFRetain(result);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v8;
  return result;
}

void sub_1001299F4(uint64_t a1, CFStringRef theString)
{
  __CFString **v3;
  __CFArray *v4;
  int HasSuffix;
  void *v6;
  const void *v7;
  uint64_t i;
  uint64_t v9;
  __CFString **v10;
  _BOOL4 v11;
  uint64_t v12;
  const __CFString *v13;
  _BOOL4 v14;
  uint64_t v15;
  uint64_t v16;
  __CFString **v17;
  uint64_t v18;
  __CFString **v19;
  uint64_t v20;
  __CFString **v21;
  uint64_t v22;
  __CFString **v23;
  uint64_t j;
  CFRange v25;

  v4 = *(__CFArray **)(a1 + 48);
  v3 = *(__CFString ***)(a1 + 56);
  HasSuffix = CFStringHasSuffix(theString, CFSTR("-tomb"));
  if (HasSuffix)
  {
    v25.length = CFStringGetLength(theString) - 5;
    v25.location = 0;
    v6 = (void *)CFStringCreateWithSubstring(kCFAllocatorDefault, theString, v25);
  }
  else
  {
    v6 = (void *)CFRetain(theString);
  }
  v7 = v6;
  if ((SOSViewInSOSSystem() & 1) == 0)
    goto LABEL_23;
  if (CFEqual(v7, kSOSViewKeychainV0))
  {
    for (i = 0; i != 3; ++i)
    {
      if (qword_1003411C0 != -1)
        dispatch_once(&qword_1003411C0, &stru_1002DF148);
      sub_10012A3B4(v4, qword_1003411C8[i], HasSuffix != 0, 0, 0, v3);
    }
    goto LABEL_23;
  }
  if (CFEqual(v7, kSOSViewWiFi))
  {
    v9 = sub_1000119B8((uint64_t)CFSTR("genp"), &qword_100341240, (uint64_t)&unk_100341238);
    v10 = sub_10012A5B4(v4, v9, HasSuffix != 0, (const __CFBoolean *)CFSTR("apple"), v3);
    if (v10)
      sub_100012178(kSecAttrService, (const __CFBoolean *)CFSTR("AirPort"), (uint64_t)v10);
    goto LABEL_23;
  }
  if (CFEqual(v7, kSOSViewAutofillPasswords))
  {
    v11 = HasSuffix != 0;
    v12 = sub_1000119B8((uint64_t)CFSTR("inet"), &qword_100341250, (uint64_t)&unk_100341248);
    v13 = CFSTR("com.apple.cfnetwork");
LABEL_22:
    sub_10012A5B4(v4, v12, v11, (const __CFBoolean *)v13, v3);
    goto LABEL_23;
  }
  if (CFEqual(v7, kSOSViewSafariCreditCards))
  {
    v11 = HasSuffix != 0;
    v12 = sub_1000119B8((uint64_t)CFSTR("genp"), &qword_100341240, (uint64_t)&unk_100341238);
    v13 = CFSTR("com.apple.safari.credit-cards");
    goto LABEL_22;
  }
  if (CFEqual(v7, kSOSViewiCloudIdentity))
  {
    v11 = HasSuffix != 0;
    v12 = sub_1000119B8((uint64_t)CFSTR("keys"), &qword_100341270, (uint64_t)&unk_100341268);
    v13 = CFSTR("com.apple.security.sos");
    goto LABEL_22;
  }
  if (CFEqual(v7, kSOSViewBackupBagV0))
  {
    v11 = HasSuffix != 0;
    v12 = sub_1000119B8((uint64_t)CFSTR("genp"), &qword_100341240, (uint64_t)&unk_100341238);
    v13 = CFSTR("com.apple.sbd");
    goto LABEL_22;
  }
  if (CFEqual(v7, kSOSViewOtherSyncable))
  {
    v14 = HasSuffix != 0;
    v15 = sub_1000119B8((uint64_t)CFSTR("cert"), &qword_100341260, (uint64_t)&unk_100341258);
    sub_10012A3B4(v4, v15, v14, 1, 0, v3);
    v16 = sub_1000119B8((uint64_t)CFSTR("genp"), &qword_100341240, (uint64_t)&unk_100341238);
    v17 = sub_10012A5B4(v4, v16, v14, (const __CFBoolean *)CFSTR("apple"), v3);
    sub_100120A38(kSecAttrService, (const __CFData *)CFSTR("AirPort"), (uint64_t)v17);
    v18 = sub_1000119B8((uint64_t)CFSTR("genp"), &qword_100341240, (uint64_t)&unk_100341238);
    v19 = sub_10012A3B4(v4, v18, v14, 1, 0, v3);
    sub_100120A38(kSecAttrAccessGroup, (const __CFData *)CFSTR("apple"), (uint64_t)v19);
    sub_100120A38(kSecAttrAccessGroup, (const __CFData *)CFSTR("com.apple.safari.credit-cards"), (uint64_t)v19);
    sub_100120A38(kSecAttrAccessGroup, (const __CFData *)CFSTR("com.apple.sbd"), (uint64_t)v19);
    v20 = sub_1000119B8((uint64_t)CFSTR("inet"), &qword_100341250, (uint64_t)&unk_100341248);
    v21 = sub_10012A3B4(v4, v20, v14, 1, 0, v3);
    sub_100120A38(kSecAttrAccessGroup, (const __CFData *)CFSTR("com.apple.cfnetwork"), (uint64_t)v21);
    v22 = sub_1000119B8((uint64_t)CFSTR("keys"), &qword_100341270, (uint64_t)&unk_100341268);
    v23 = sub_10012A3B4(v4, v22, v14, 1, 0, v3);
    sub_100120A38(kSecAttrAccessGroup, (const __CFData *)CFSTR("com.apple.security.sos"), (uint64_t)v23);
  }
  else
  {
    for (j = 0; j != 4; ++j)
    {
      if (qword_1003411E0 != -1)
        dispatch_once(&qword_1003411E0, &stru_1002DF188);
      sub_10012A3B4(v4, qword_1003411E8[j], HasSuffix != 0, 1, (const __CFData *)v7, v3);
    }
  }
LABEL_23:
  if (v7)
    CFRelease(v7);
}

uint64_t sub_100129F24(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

BOOL sub_100129F38(uint64_t a1, uint64_t a2)
{
  CFIndex Count;
  CFIndex v5;
  BOOL v6;
  CFIndex v7;
  CFDictionaryRef *ValueAtIndex;
  uint64_t v9;
  __CFString *v10;
  __CFString *v11;
  char v12;
  char v13;
  int v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t *v17;
  _QWORD v19[5];
  _QWORD v20[5];
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  char v29;
  __int128 buf;
  uint64_t (*v31)(uint64_t, sqlite3_stmt *);
  void *v32;
  _QWORD *v33;
  uint64_t v34;
  _QWORD *v35;
  uint64_t *v36;
  CFDictionaryRef *v37;
  uint64_t v38;
  uint64_t v39;

  v21 = 0;
  v22 = &v21;
  v23 = 0x3800000000;
  v24 = 0u;
  v25 = 0u;
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 48));
  if (Count < 1)
  {
    v6 = 1;
LABEL_11:
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = sub_1001E88E8((uint64_t)(v22 + 3), (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8)+ 24));
  }
  else
  {
    v5 = Count;
    v6 = 0;
    v7 = 0;
    while (1)
    {
      ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 48), v7);
      v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v20[1] = 0x40000000;
      v20[2] = sub_10012A1E4;
      v20[3] = &unk_1002DF1A8;
      v20[4] = ValueAtIndex;
      v19[0] = _NSConcreteStackBlock;
      v19[1] = 0x40000000;
      v19[2] = sub_10012A20C;
      v19[3] = &unk_1002DF1D0;
      v19[4] = &v21;
      v20[0] = _NSConcreteStackBlock;
      v26 = 0;
      v27 = &v26;
      v28 = 0x2000000000;
      v29 = 1;
      v10 = sub_10001EA54(ValueAtIndex, (uint64_t)&stru_1002DF238, (uint64_t)v20, 0);
      if (!v10)
        break;
      v11 = v10;
      *(_QWORD *)&buf = _NSConcreteStackBlock;
      *((_QWORD *)&buf + 1) = 0x40000000;
      v31 = sub_10012A304;
      v32 = &unk_1002DF288;
      v37 = ValueAtIndex;
      v38 = v9 + 24;
      v33 = v20;
      v34 = 0;
      v39 = a2;
      v35 = v19;
      v36 = &v26;
      v12 = sub_10001E3C4(a2, (uint64_t)v10, (CFTypeRef *)(v9 + 24), (uint64_t)&buf);
      if (*((_BYTE *)v27 + 24))
        v13 = v12;
      else
        v13 = 0;
      *((_BYTE *)v27 + 24) = v13;
      CFRelease(v11);
      v14 = *((unsigned __int8 *)v27 + 24);
      _Block_object_dispose(&v26, 8);
      if (!v14)
        goto LABEL_13;
      v6 = ++v7 >= v5;
      if (v5 == v7)
        goto LABEL_11;
    }
    *((_BYTE *)v27 + 24) = 0;
    _Block_object_dispose(&v26, 8);
LABEL_13:
    v15 = sub_10000EF14("SecError");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v16 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      LODWORD(buf) = 138412290;
      *(_QWORD *)((char *)&buf + 4) = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "SecDbItemSelectSHA1 failed: %@", (uint8_t *)&buf, 0xCu);
    }
  }
  v17 = v22;
  free((void *)v22[3]);
  v17[3] = 0;
  v17[4] = 0;
  *((_BYTE *)v17 + 48) = 0;
  v17[5] = 0;
  _Block_object_dispose(&v21, 8);
  return v6;
}

BOOL sub_10012A1E4(uint64_t a1, const void **a2)
{
  return CFDictionaryContainsKey(*(CFDictionaryRef *)(*(_QWORD *)(a1 + 32) + 8), *a2) != 0;
}

void sub_10012A20C(uint64_t a1, sqlite3_stmt *a2)
{
  __int128 *v4;
  int v5;
  uint64_t v6;
  int v7;
  NSObject *v8;
  int v9;
  uint64_t v10;

  v4 = (__int128 *)sqlite3_column_blob(a2, 0);
  v5 = sqlite3_column_bytes(a2, 0);
  if (v5 == 20)
  {
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    sub_1001E7584((char **)(v6 + 24), v4);
    *(_BYTE *)(v6 + 48) = 1;
  }
  else
  {
    v7 = v5;
    v8 = sub_10000EF14("SecError");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 134217984;
      v10 = v7;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "digest %zu bytes", (uint8_t *)&v9, 0xCu);
    }
  }
}

uint64_t sub_10012A304(uint64_t a1, sqlite3_stmt *a2)
{
  uint64_t result;
  uint64_t v5;
  CFTypeRef *v6;
  _QWORD v7[6];

  result = sub_10001ED30(*(CFDictionaryRef **)(a1 + 64), a2, *(__CFString ***)(a1 + 72), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
  if ((_DWORD)result)
  {
    v6 = *(CFTypeRef **)(a1 + 72);
    v5 = *(_QWORD *)(a1 + 80);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 0x40000000;
    v7[2] = sub_10012A390;
    v7[3] = &unk_1002DF260;
    v7[4] = *(_QWORD *)(a1 + 48);
    v7[5] = a2;
    result = sub_100019C40(v5, a2, v6, (uint64_t)v7);
  }
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = result;
  return result;
}

uint64_t sub_10012A390(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), a2);
}

BOOL sub_10012A3A4(id a1, const SecDbAttr *a2)
{
  return a2->var1 == 7;
}

__CFString **sub_10012A3B4(__CFArray *a1, uint64_t a2, int a3, BOOL a4, const __CFData *a5, __CFString **a6)
{
  __CFString **v11;
  __CFString **v12;
  __CFString **v13;
  __CFString ***v14;
  BOOL v15;
  const __CFData *v16;
  const __CFData *v17;
  __CFString **v18;

  v11 = (__CFString **)sub_1000114E8(a2, 0, 0, 0, a6);
  v12 = v11;
  if (v11)
  {
    *((_DWORD *)v11 + 12) = 3;
    v11[13] = (__CFString *)-1;
    *((_DWORD *)v11 + 30) = dword_1003414E0;
    sub_100012178(kSecAttrSynchronizable, kCFBooleanTrue, (uint64_t)v11);
    sub_100120910(kSecAttrAccessible, (const __CFData *)kSecAttrAccessibleWhenUnlocked, (uint64_t)v12);
    sub_100120910(kSecAttrAccessible, (const __CFData *)kSecAttrAccessibleAfterFirstUnlock, (uint64_t)v12);
    sub_100120910(kSecAttrAccessible, kSecAttrAccessibleAlwaysPrivate, (uint64_t)v12);
    sub_100120910(kSecAttrAccessible, (const __CFData *)kSecAttrAccessibleWhenUnlockedThisDeviceOnly, (uint64_t)v12);
    sub_100120910(kSecAttrAccessible, (const __CFData *)kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly, (uint64_t)v12);
    sub_100120910(kSecAttrAccessible, kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate, (uint64_t)v12);
    if (a3)
      sub_100012178(kSecAttrTombstone, kCFBooleanFalse, (uint64_t)v12);
    CFArrayAppendValue(a1, v12);
    v13 = *(__CFString ***)(a2 + 16);
    if (v13)
    {
      v14 = (__CFString ***)(a2 + 24);
      do
      {
        v15 = v13 != &off_1002E9510;
        if (v13 == &off_1002DFE50)
          v15 = a4;
        if (!v15)
        {
          if (a5 && v13 == &off_1002E9510)
          {
            sub_1000122D8(&off_1002E9510, a5, (uint64_t)v12);
          }
          else
          {
            v16 = sub_100019FB0((uint64_t)v13, v12 + 5);
            if (v16)
            {
              v17 = v16;
              sub_1000122D8(v13, v16, (uint64_t)v12);
              CFRelease(v17);
            }
          }
        }
        v18 = *v14++;
        v13 = v18;
      }
      while (v18);
    }
  }
  return v12;
}

__CFString **sub_10012A5B4(__CFArray *a1, uint64_t a2, int a3, const __CFBoolean *a4, __CFString **a5)
{
  __CFString **v6;
  __CFString **v7;

  v6 = sub_10012A3B4(a1, a2, a3, 1, 0, a5);
  v7 = v6;
  if (a4 && v6)
    sub_100012178(kSecAttrAccessGroup, a4, (uint64_t)v6);
  return v7;
}

void sub_10012A608(id a1)
{
  qword_1003411C8[0] = sub_1000119B8((uint64_t)CFSTR("genp"), &qword_100341240, (uint64_t)&unk_100341238);
  qword_1003411D0 = sub_1000119B8((uint64_t)CFSTR("inet"), &qword_100341250, (uint64_t)&unk_100341248);
  qword_1003411D8 = sub_1000119B8((uint64_t)CFSTR("keys"), &qword_100341270, (uint64_t)&unk_100341268);
}

uint64_t sub_10012A688(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), a2, a3, a4, a5);
}

CFStringRef sub_10012A6A8()
{
  return kSecAttrAccessibleWhenUnlocked;
}

uint64_t sub_10012A6B8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v3;
  uint64_t v4;
  _QWORD v6[8];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 0;
  v3 = *(NSObject **)(a1 + 32);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = sub_10012A750;
  v6[3] = &unk_1002DF590;
  v6[4] = &v7;
  v6[5] = a1;
  v6[6] = a2;
  v6[7] = a3;
  dispatch_sync(v3, v6);
  v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_10012A750(uint64_t a1)
{
  const void *v2;
  uint64_t v3;
  const void *v4;
  _QWORD *v5;
  uint64_t Instance;
  dispatch_queue_t v7;
  void *v8;
  void *v9;
  const void *v10;
  NSObject *v11;
  CFTypeRef v12;
  const void *v13;
  NSObject *v14;
  uint64_t v15;
  CFMutableDictionaryRef Mutable;
  const void *v17;
  CFMutableDictionaryRef v18;
  const void *v19;
  CFMutableDictionaryRef v20;
  const void *v21;
  const void *v22;
  const void *v23;
  uint64_t v24;
  CFTypeRef cf;
  __int128 buf;
  void *v27;
  void *v28;
  uint64_t *v29;

  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = CFDictionaryGetValue(*(CFDictionaryRef *)(*(_QWORD *)(a1 + 40) + 24), *(const void **)(a1 + 48));
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    v2 = *(const void **)(*(_QWORD *)(a1 + 40) + 40);
    if (v2)
    {
      v4 = *(const void **)(a1 + 48);
      v3 = *(_QWORD *)(a1 + 56);
      v5 = malloc_type_calloc(1uLL, 0xA8uLL, 0xE00405186C4AEuLL);
      v5[1] = sub_100127ACC;
      v5[2] = sub_100127AD4;
      v5[5] = sub_100127DF0;
      v5[6] = sub_100128094;
      v5[3] = sub_100127B2C;
      v5[4] = sub_100128278;
      v5[9] = sub_10012853C;
      v5[10] = sub_1001284D8;
      v5[11] = sub_10012708C;
      v5[12] = sub_100128544;
      v5[7] = sub_100128760;
      v5[8] = sub_100128468;
      v5[13] = sub_1001288B8;
      v5[14] = sub_1001289D8;
      v5[15] = sub_100128A2C;
      v5[16] = sub_100128A88;
      v5[17] = sub_100128B30;
      v5[18] = sub_100128C6C;
      CFRetain(v2);
      v5[19] = v2;
      if (v4)
        CFRetain(v4);
      v5[20] = v4;
      if (-[OTSOSActualAdapter sosEnabled]_0())
      {
        *(_QWORD *)&buf = _NSConcreteStackBlock;
        *((_QWORD *)&buf + 1) = 3221225472;
        v27 = sub_1000FB968;
        v28 = &unk_1002ED1A0;
        v29 = &qword_1003410B8;
        if (qword_1003410B0 != -1)
          dispatch_once(&qword_1003410B0, &buf);
        Instance = _CFRuntimeCreateInstance(kCFAllocatorDefault, qword_1003410B8, 136, 0);
        *(_QWORD *)(Instance + 16) = v5;
        v7 = dispatch_queue_create("engine", 0);
        v8 = *(void **)(Instance + 112);
        *(_QWORD *)(Instance + 112) = v7;

        *(_QWORD *)(Instance + 56) = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        *(_QWORD *)(Instance + 64) = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        *(_QWORD *)(Instance + 72) = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        v9 = *(void **)(Instance + 136);
        *(_QWORD *)(Instance + 136) = 0;

        *(_QWORD *)(Instance + 96) = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        *(_WORD *)(Instance + 104) = 0;
        cf = 0;
        if ((sub_1000FDD40(Instance, 0, &cf) & 1) == 0)
        {
          v10 = sub_10000EF14("SecWarning");
          v11 = objc_claimAutoreleasedReturnValue(v10);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 138412290;
            *(_QWORD *)((char *)&buf + 4) = cf;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "engine failed load state starting with nothing %@", (uint8_t *)&buf, 0xCu);
          }

          v12 = cf;
          if (cf)
          {
            cf = 0;
            CFRelease(v12);
          }
          v13 = sub_10000EF14("engine");
          v14 = objc_claimAutoreleasedReturnValue(v13);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            v15 = (*(uint64_t (**)(void))(*(_QWORD *)(Instance + 16) + 8))();
            LODWORD(buf) = 138412290;
            *(_QWORD *)((char *)&buf + 4) = v15;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "new engine for datasource named %@", (uint8_t *)&buf, 0xCu);
          }

          Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          v17 = *(const void **)(Instance + 56);
          if (v17)
            CFRelease(v17);
          *(_QWORD *)(Instance + 56) = Mutable;
          v18 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          v19 = *(const void **)(Instance + 64);
          if (v19)
            CFRelease(v19);
          *(_QWORD *)(Instance + 64) = v18;
          v20 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          v21 = *(const void **)(Instance + 72);
          if (v21)
            CFRelease(v21);
          *(_QWORD *)(Instance + 72) = v20;
          v22 = *(const void **)(Instance + 48);
          if (v22)
          {
            *(_QWORD *)(Instance + 48) = 0;
            CFRelease(v22);
          }
          v23 = *(const void **)(Instance + 80);
          if (v23)
          {
            *(_QWORD *)(Instance + 80) = 0;
            CFRelease(v23);
          }
          sub_1000FE6C0(Instance, 0, 0, 0);
        }
        v24 = *(_QWORD *)(Instance + 16);
        *(_QWORD *)&buf = _NSConcreteStackBlock;
        *((_QWORD *)&buf + 1) = 3221225472;
        v27 = sub_1000FFE80;
        v28 = &unk_1002DE208;
        v29 = (uint64_t *)Instance;
        (*(void (**)(void))(v24 + 16))();
        *v5 = Instance;
      }
      else
      {
        SOSCCSetSOSDisabledError(v3);
        free(v5);
        v5 = 0;
      }
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v5;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(a1 + 40) + 24), *(const void **)(a1 + 48), *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
    }
  }
}

void sub_10012AC64(id a1)
{
  qword_1003411A8 = (uint64_t)dispatch_queue_create("dataSourceFactory queue", 0);
  qword_1003411B0 = (uint64_t)CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, 0);
}

uint64_t sub_10012ACB4(const __CFDictionary *a1, CFTypeRef *a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t *v5;
  _QWORD v7[5];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;

  v3 = &v8;
  v8 = 0;
  v9 = &v8;
  v10 = 0x3800000000;
  v11 = 0u;
  v12 = 0u;
  if (a1)
  {
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 0x40000000;
    v7[2] = sub_10012AD74;
    v7[3] = &unk_1002DF0B8;
    v7[4] = &v8;
    CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)sub_100128F2C, v7);
    v3 = v9;
  }
  v4 = sub_1001E88E8((uint64_t)(v3 + 3), a2);
  v5 = v9;
  free((void *)v9[3]);
  v5[3] = 0;
  v5[4] = 0;
  *((_BYTE *)v5 + 48) = 0;
  v5[5] = 0;
  _Block_object_dispose(&v8, 8);
  return v4;
}

void sub_10012AD74(uint64_t a1, int a2, CFTypeRef cf)
{
  CFTypeID v5;
  const __CFData *Value;
  const __CFData *v7;
  CFTypeID v8;
  uint64_t v9;
  __int128 *BytePtr;

  if (cf)
  {
    v5 = CFGetTypeID(cf);
    if (v5 == CFDictionaryGetTypeID())
    {
      Value = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("hash"));
      if (Value)
      {
        v7 = Value;
        v8 = CFGetTypeID(Value);
        if (v8 == CFDataGetTypeID() && CFDataGetLength(v7) == 20)
        {
          v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
          BytePtr = (__int128 *)CFDataGetBytePtr(v7);
          sub_1001E7584((char **)(v9 + 24), BytePtr);
          *(_BYTE *)(v9 + 48) = 1;
        }
      }
    }
  }
}

void sub_10012B9DC(id a1, OTAuthKitAdapterNotifier *a2)
{
  -[OTAuthKitAdapterNotifier notificationOfMachineIDListChange](a2, "notificationOfMachineIDListChange");
}

void sub_10012B9E4(_QWORD *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  void *v7;
  AAFAnalyticsEventSecurity *v8;
  const void *v9;
  NSObject *v10;
  void *v11;
  void *v12;
  id v13;
  id v14;
  uint64_t v15;
  void *i;
  void *v17;
  void *v18;
  const void *v19;
  NSObject *v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  _QWORD *v25;
  void *v26;
  id v27;
  uint64_t v28;
  void *j;
  void *v30;
  id v31;
  void *v32;
  const void *v33;
  NSObject *v34;
  void *v35;
  void *v36;
  NSObject *v37;
  const char *v38;
  void *v39;
  const void *v40;
  void *v41;
  void *v42;
  const void *v43;
  void *v44;
  const void *v45;
  NSObject *v46;
  id v47;
  void *v48;
  void *v49;
  __CFString *v50;
  void *v51;
  __CFString *v52;
  void *v53;
  void *v54;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  void *v58;
  void *v59;
  _QWORD *v60;
  void *v61;
  void *v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  uint8_t buf[4];
  id v72;
  __int16 v73;
  id v74;
  __int16 v75;
  void *v76;
  __int16 v77;
  void *v78;
  _BYTE v79[128];
  _BYTE v80[128];

  v5 = a2;
  v6 = a3;
  if (v6)
  {
    v7 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
    objc_msgSend(v7, "logUnrecoverableError:forEvent:withAttributes:", v6, CFSTR("OctagonEventAuthKitDeviceList"), 0);

    LOBYTE(v55) = 1;
    v8 = -[AAFAnalyticsEventSecurity initWithKeychainCircleMetrics:altDSID:flowID:deviceSessionID:eventName:testsAreEnabled:canSendMetrics:category:]([AAFAnalyticsEventSecurity alloc], "initWithKeychainCircleMetrics:altDSID:flowID:deviceSessionID:eventName:testsAreEnabled:canSendMetrics:category:", &__NSDictionary0__struct, a1[4], a1[5], a1[6], CFSTR("com.apple.security.trustedDeviceListFailure"), 0, v55, &off_10030AF70);
    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", v8, 0, v6);
    v9 = sub_10000EF14("authkit");
    v10 = objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      v11 = (void *)a1[4];
      *(_DWORD *)buf = 138412546;
      v72 = v11;
      v73 = 2112;
      v74 = v6;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "received no device list(%@): %@", buf, 0x16u);
    }

    (*(void (**)(_QWORD, _QWORD))(a1[7] + 16))(a1[7], 0);
    goto LABEL_5;
  }
  v60 = a1;
  if (!v5)
  {
    v8 = (AAFAnalyticsEventSecurity *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:description:](NSError, "errorWithDomain:code:description:", CFSTR("com.apple.security.octagon"), 68, CFSTR("bad response from AuthKit")));
    (*(void (**)(_QWORD, _QWORD))(a1[7] + 16))(a1[7], 0);
    v51 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
    objc_msgSend(v51, "logUnrecoverableError:forEvent:withAttributes:", v8, CFSTR("OctagonEventAuthKitDeviceList"), 0);

LABEL_5:
    goto LABEL_47;
  }
  v62 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](NSMutableSet, "set"));
  v57 = objc_claimAutoreleasedReturnValue(+[NSMutableSet set](NSMutableSet, "set"));
  v58 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](NSMutableSet, "set"));
  v59 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](NSMutableSet, "set"));
  v61 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "deviceListVersion"));
  v67 = 0u;
  v68 = 0u;
  v69 = 0u;
  v70 = 0u;
  v56 = v5;
  v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "deviceList"));
  v13 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v67, v80, 16);
  if (v13)
  {
    v14 = v13;
    v15 = *(_QWORD *)v68;
    do
    {
      for (i = 0; i != v14; i = (char *)i + 1)
      {
        if (*(_QWORD *)v68 != v15)
          objc_enumerationMutation(v12);
        v17 = *(void **)(*((_QWORD *)&v67 + 1) + 8 * (_QWORD)i);
        v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "machineId"));
        objc_msgSend(v62, "addObject:", v18);

        v19 = sub_10000EF14("authkit");
        v20 = objc_claimAutoreleasedReturnValue(v19);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          v21 = (void *)v60[4];
          v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "machineId"));
          *(_DWORD *)buf = 138412802;
          v72 = v21;
          v73 = 2112;
          v74 = v61;
          v75 = 2112;
          v76 = v22;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Current machine ID on list for (%@) version %@: %@", buf, 0x20u);

        }
      }
      v14 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v67, v80, 16);
    }
    while (v14);
  }

  v65 = 0u;
  v66 = 0u;
  v63 = 0u;
  v64 = 0u;
  v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "deletedDeviceList"));
  v24 = objc_msgSend(v23, "countByEnumeratingWithState:objects:count:", &v63, v79, 16);
  v25 = v60;
  v26 = (void *)v57;
  if (v24)
  {
    v27 = v24;
    v28 = *(_QWORD *)v64;
    do
    {
      for (j = 0; j != v27; j = (char *)j + 1)
      {
        if (*(_QWORD *)v64 != v28)
          objc_enumerationMutation(v23);
        v30 = *(void **)(*((_QWORD *)&v63 + 1) + 8 * (_QWORD)j);
        v31 = objc_msgSend(v30, "removalReason");
        if (!v31)
        {
          v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "machineId"));
          objc_msgSend(v59, "addObject:", v42);

          v43 = sub_10000EF14("authkit");
          v34 = objc_claimAutoreleasedReturnValue(v43);
          if (!os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
            goto LABEL_34;
          v44 = (void *)v25[4];
          v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "machineId"));
          *(_DWORD *)buf = 138412802;
          v72 = v44;
          v73 = 2112;
          v74 = v61;
          v75 = 2112;
          v76 = v36;
          v37 = v34;
          v38 = "Device evicted for unknown reason for (%@) version %@: %@";
          goto LABEL_30;
        }
        if (v31 == (id)2)
        {
          v39 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "machineId"));
          objc_msgSend(v58, "addObject:", v39);

          v40 = sub_10000EF14("authkit");
          v34 = objc_claimAutoreleasedReturnValue(v40);
          if (!os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
            goto LABEL_34;
          v41 = (void *)v25[4];
          v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "machineId"));
          *(_DWORD *)buf = 138412802;
          v72 = v41;
          v73 = 2112;
          v74 = v61;
          v75 = 2112;
          v76 = v36;
          v37 = v34;
          v38 = "Device evicted due to limit for (%@) version %@: %@";
          goto LABEL_30;
        }
        if (v31 == (id)1)
        {
          v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "machineId"));
          objc_msgSend(v26, "addObject:", v32);

          v33 = sub_10000EF14("authkit");
          v34 = objc_claimAutoreleasedReturnValue(v33);
          if (!os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
            goto LABEL_34;
          v35 = (void *)v25[4];
          v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "machineId"));
          *(_DWORD *)buf = 138412802;
          v72 = v35;
          v73 = 2112;
          v74 = v61;
          v75 = 2112;
          v76 = v36;
          v37 = v34;
          v38 = "User initiated removed machine ID for (%@) version %@: %@";
LABEL_30:
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, v38, buf, 0x20u);

          goto LABEL_34;
        }
        v45 = sub_10000EF14("SecError");
        v46 = objc_claimAutoreleasedReturnValue(v45);
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
        {
          v47 = objc_msgSend(v30, "removalReason");
          v48 = (void *)v60[4];
          v49 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "machineId"));
          *(_DWORD *)buf = 134218754;
          v72 = v47;
          v26 = (void *)v57;
          v73 = 2112;
          v74 = v48;
          v25 = v60;
          v75 = 2112;
          v76 = v61;
          v77 = 2112;
          v78 = v49;
          _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "authkit: super shrug here. Device is in the deletedDeviceList but has an undefined removal reason (%ld) for (%@) version %@: %@", buf, 0x2Au);

        }
        v34 = objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "machineId"));
        objc_msgSend(v59, "addObject:", v34);
LABEL_34:

      }
      v27 = objc_msgSend(v23, "countByEnumeratingWithState:objects:count:", &v63, v79, 16);
    }
    while (v27);
  }

  v5 = v56;
  if ((objc_opt_respondsToSelector(v56, "trustedDeviceHash") & 1) != 0)
    v50 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(v56, "trustedDeviceHash"));
  else
    v50 = &stru_1002EE888;
  if ((objc_opt_respondsToSelector(v56, "deletedDeviceHash") & 1) != 0)
    v52 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(v56, "deletedDeviceHash"));
  else
    v52 = &stru_1002EE888;
  if ((objc_opt_respondsToSelector(v56, "trustedDevicesUpdateTimestamp") & 1) != 0)
    v53 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v56, "trustedDevicesUpdateTimestamp"));
  else
    v53 = 0;
  (*(void (**)(_QWORD, void *))(v25[7] + 16))(v25[7], v62);
  v54 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](CKKSAnalytics, "logger"));
  objc_msgSend(v54, "logSuccessForEventNamed:", CFSTR("OctagonEventAuthKitDeviceList"));

  v6 = 0;
LABEL_47:

}

void sub_10012E0C4(id a1)
{
  void *v1;
  OctagonControlServer *v2;
  void *v3;
  id v4;
  void *v5;

  v1 = objc_autoreleasePoolPush();
  v2 = objc_opt_new(OctagonControlServer);
  v3 = (void *)qword_100341218;
  qword_100341218 = (uint64_t)v2;

  v4 = objc_msgSend(objc_alloc((Class)NSXPCListener), "initWithMachServiceName:", CFSTR("com.apple.security.octagon"));
  v5 = (void *)qword_100341220;
  qword_100341220 = (uint64_t)v4;

  objc_msgSend((id)qword_100341220, "setDelegate:", qword_100341218);
  objc_msgSend((id)qword_100341220, "resume");
  objc_autoreleasePoolPop(v1);
}

uint64_t sub_10012E148(uint64_t a1, unsigned int *a2, const __CFArray *a3, int a4, uint64_t a5)
{
  CFMutableStringRef Mutable;
  __CFString *v11;
  uint64_t *v12;
  uint64_t **v13;
  uint64_t *v14;
  uint64_t v15;
  _QWORD v17[7];
  _QWORD context[6];
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  char v22;
  _QWORD v23[5];
  CFRange v24;

  v19 = 0;
  v20 = &v19;
  v21 = 0x2000000000;
  v22 = 1;
  Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
  v11 = Mutable;
  if (a3)
  {
    context[0] = _NSConcreteStackBlock;
    context[1] = 0x40000000;
    context[2] = sub_10012E2E8;
    context[3] = &unk_1002DF690;
    context[4] = a2;
    context[5] = Mutable;
    v24.length = CFArrayGetCount(a3);
    v24.location = 0;
    CFArrayApplyFunction(a3, v24, (CFArrayApplierFunction)sub_10012E2FC, context);
  }
  else
  {
    v12 = (uint64_t *)*((_QWORD *)a2 + 1);
    if (v12)
    {
      v13 = (uint64_t **)(a2 + 4);
      do
      {
        sub_10012E310(v11, v12);
        v14 = *v13++;
        v12 = v14;
      }
      while (v14);
    }
  }
  if (a4)
    CFStringAppendFormat(v11, 0, CFSTR("INSERT INTO tversion(version,minor) VALUES(%d, %d);"), *a2, a2[1]);
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 0x40000000;
  v17[2] = sub_10012E554;
  v17[3] = &unk_1002DF6B8;
  v17[4] = &v19;
  v17[5] = a1;
  v17[6] = a5;
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 0x40000000;
  v23[2] = sub_1000104A0;
  v23[3] = &unk_1002DB170;
  v23[4] = v17;
  sub_1000137F8(v11, (uint64_t)v23);
  if (v11)
    CFRelease(v11);
  v15 = *((unsigned __int8 *)v20 + 24);
  _Block_object_dispose(&v19, 8);
  return v15;
}

void sub_10012E2E8(uint64_t a1, int a2)
{
  sub_10012E310(*(__CFString **)(a1 + 40), *(uint64_t **)(*(_QWORD *)(a1 + 32) + 8 * a2 + 8));
}

uint64_t sub_10012E2FC(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_10012E310(__CFString *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t *v5;
  unsigned int v6;
  const __CFString *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  uint64_t *v12;
  const __CFString *v13;
  const __CFString *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  CFStringAppendFormat(a1, 0, CFSTR("CREATE TABLE %@("), *a2);
  v4 = a2[2];
  if (!v4)
    goto LABEL_26;
  v5 = a2 + 3;
  do
  {
    if ((*(_BYTE *)(v4 + 16) & 2) == 0)
      goto LABEL_11;
    v6 = *(_DWORD *)(v4 + 8) - 2;
    v7 = CFSTR("BLOB");
    if (v6 <= 0xD)
      v7 = off_1002DFC00[v6];
    CFStringAppendFormat(a1, 0, CFSTR("%@ %@"), *(_QWORD *)v4, v7);
    v8 = *(_QWORD *)(v4 + 16);
    if ((v8 & 0x1000) != 0)
    {
      CFStringAppend(a1, CFSTR(" NOT NULL"));
      v8 = *(_QWORD *)(v4 + 16);
      if ((v8 & 0x400) != 0)
      {
LABEL_14:
        CFStringAppend(a1, CFSTR(" DEFAULT 0"));
        if ((*(_QWORD *)(v4 + 16) & 0x800) == 0)
          goto LABEL_10;
LABEL_9:
        CFStringAppend(a1, CFSTR(" DEFAULT ''"));
        goto LABEL_10;
      }
    }
    else if ((v8 & 0x400) != 0)
    {
      goto LABEL_14;
    }
    if ((v8 & 0x800) != 0)
      goto LABEL_9;
LABEL_10:
    CFStringAppend(a1, CFSTR(","));
LABEL_11:
    v9 = *v5++;
    v4 = v9;
  }
  while (v9);
  v10 = a2[2];
  if (v10)
  {
    v11 = 0;
    v12 = a2 + 3;
    do
    {
      if ((~*(_DWORD *)(v10 + 16) & 3) == 0)
      {
        v13 = *(const __CFString **)v10;
        if (v11)
          v14 = CFSTR(",");
        else
          v14 = CFSTR("UNIQUE(");
        v11 = 1;
        CFStringAppend(a1, v14);
        CFStringAppend(a1, v13);
      }
      v15 = *v12++;
      v10 = v15;
    }
    while (v15);
    if (v11)
      CFStringAppend(a1, CFSTR(")"));
  }
LABEL_26:
  CFStringAppend(a1, CFSTR(");"));
  v16 = (uint64_t *)a2[2];
  if (v16)
  {
    v17 = 3;
    do
    {
      if ((~*((_DWORD *)v16 + 4) & 6) == 0)
      {
        v18 = *((_DWORD *)v16 + 2);
        v19 = *a2;
        v20 = *v16;
        if (v18 == 11)
          CFStringAppendFormat(a1, 0, CFSTR("CREATE INDEX %@%@0 ON %@(%@) WHERE %@=0;"), v19, v20, v19, v20, v20);
        else
          CFStringAppendFormat(a1, 0, CFSTR("CREATE INDEX %@%@ ON %@(%@);"), v19, v20, *a2, v20, v21);
      }
      v16 = (uint64_t *)a2[v17++];
    }
    while (v16);
  }
}

BOOL sub_10012E554(uint64_t a1, const char *a2)
{
  uint64_t v4;
  _BOOL8 result;

  v4 = sqlite3_exec(*(sqlite3 **)(*(_QWORD *)(a1 + 40) + 64), a2, 0, 0, 0);
  result = sub_100030654(v4, *(sqlite3 **)(*(_QWORD *)(a1 + 40) + 64), *(CFTypeRef **)(a1 + 48), CFSTR("sqlite3_exec: %s"), a2);
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

BOOL sub_10012E5B8(const void *a1, uint64_t a2)
{
  const __CFDictionary *v3;
  const __CFDictionary *v4;
  const void *Value;
  _BOOL8 v6;

  if (!a2)
    return 0;
  v3 = (const __CFDictionary *)SecTokenItemValueCopy(a2, 0);
  if (!v3)
    return 0;
  v4 = v3;
  Value = CFDictionaryGetValue(v3, CFSTR("oid"));
  if (Value)
    v6 = CFEqual(a1, Value) != 0;
  else
    v6 = a1 == 0;
  CFRelease(v4);
  return v6;
}

void sub_10012E630(void *key, void *value, CFMutableDictionaryRef theDict)
{
  CFDictionarySetValue(theDict, key, value);
}

void sub_10012E644(id a1)
{
  NSObject *v1;
  _QWORD *context;

  v1 = sub_1000327DC("ratelimiterdisabledlogevent", 1);
  qword_100341230 = (uint64_t)v1;
  context = dispatch_get_context(v1);
  context[2] = _Block_copy(&stru_1002DFBA0);
  dispatch_activate(v1);
}

void sub_10012E694(id a1)
{
  NSObject *v1;
  _DWORD v2[2];

  v1 = sub_10000EF14("SecError");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    v2[0] = 67109120;
    v2[1] = -25308;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "decode item failed, keychain is locked (%d)", (uint8_t *)v2, 8u);
  }
}

void sub_10012E734(sqlite3_stmt *a1, uint64_t a2)
{
  uint64_t **v4;
  sqlite3_int64 v5;
  const __CFData *v6;
  const UInt8 *v7;
  int v8;
  const __CFData *v9;
  const __CFData *v10;
  const void *UUIDBasedPersistentRef;
  _BOOL4 v12;
  __CFData *v13;
  _BOOL4 v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  CFDictionaryRef v22;
  CFDictionaryRef v23;
  NSObject *v24;
  uint64_t v25;
  uint8_t buf[4];
  sqlite3_int64 v27;
  __int16 v28;
  uint64_t v29;

  v4 = *(uint64_t ***)a2;
  v5 = sqlite3_column_int64(a1, 0);
  v6 = sub_100014E94(a1, 1);
  v7 = (const UInt8 *)sqlite3_column_blob(a1, 3);
  v8 = sqlite3_column_bytes(a1, 3);
  v9 = CFDataCreate(kCFAllocatorDefault, v7, v8);
  if (!v9)
  {
    UUIDBasedPersistentRef = 0;
    if (v6)
      goto LABEL_8;
LABEL_5:
    v12 = 0;
    v13 = 0;
    v14 = UUIDBasedPersistentRef != 0;
    goto LABEL_13;
  }
  v10 = v9;
  if (CFDataGetLength(v9) == 16)
    UUIDBasedPersistentRef = (const void *)_SecItemCreateUUIDBasedPersistentRef(**v4, v10, 0);
  else
    UUIDBasedPersistentRef = 0;
  CFRelease(v10);
  if (!v6)
    goto LABEL_5;
LABEL_8:
  v13 = sub_100032878(v6);
  v12 = v13 != 0;
  v14 = UUIDBasedPersistentRef != 0;
  if (v13 && UUIDBasedPersistentRef)
  {
    v22 = sub_10012E96C(0, v15, v16, v17, v18, v19, v20, v21, (uint64_t)kSecValuePersistentRef, (uint64_t)UUIDBasedPersistentRef);
    if (v22)
    {
      v23 = v22;
      CFArrayAppendValue(*(CFMutableArrayRef *)(a2 + 24), v22);
      CFRelease(v23);
    }
    ++*(_DWORD *)(a2 + 32);
    v14 = 1;
    goto LABEL_15;
  }
LABEL_13:
  v24 = sub_10000EF14("item");
  if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
  {
    if (!v12)
      goto LABEL_16;
    goto LABEL_15;
  }
  v25 = **v4;
  *(_DWORD *)buf = 134218242;
  v27 = v5;
  v28 = 2112;
  v29 = v25;
  _os_log_debug_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "rowid %lu in %@ failed to create pref/digest", buf, 0x16u);
  if (v12)
LABEL_15:
    CFRelease(v13);
LABEL_16:
  if (v6)
  {
    CFRelease(v6);
    if (!v14)
      return;
    goto LABEL_18;
  }
  if (v14)
LABEL_18:
    CFRelease(UUIDBasedPersistentRef);
}

CFDictionaryRef sub_10012E96C(CFAllocatorRef allocator, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  unint64_t v11;
  uint64_t *v12;
  unint64_t v13;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v15;
  const void **v16;
  const void *v17;
  const __CFNull *v18;
  CFNullRef v19;
  CFDictionaryRef Copy;
  uint64_t *v22;
  const void **v23;

  v22 = &a10;
  v11 = 0;
  if (a9)
  {
    do
    {
      v11 += 2;
      v12 = v22;
      v22 += 2;
    }
    while (v12[1]);
  }
  v13 = v11 >> 1;
  v23 = (const void **)&a9;
  Mutable = CFDictionaryCreateMutable(allocator, v11 >> 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
    return 0;
  v15 = Mutable;
  if (v11)
  {
    do
    {
      v16 = v23;
      v17 = *v23;
      v23 += 2;
      v18 = (const __CFNull *)v16[1];
      if (v18)
        v19 = v18;
      else
        v19 = kCFNull;
      CFDictionarySetValue(v15, v17, v19);
      --v13;
    }
    while (v13);
  }
  Copy = CFDictionaryCreateCopy(allocator, v15);
  CFRelease(v15);
  return Copy;
}

uint64_t sub_10012EA5C(const __CFDictionary *a1, uint64_t a2, int a3)
{
  const __CFNumber *Value;
  const __CFNumber *v7;
  CFTypeID v8;
  BOOL v9;
  uint64_t result;
  const void *v11;
  CFTypeID v12;
  const void *v13;
  char v14;
  uint64_t v15;
  char v16;
  char v17;
  char v18;
  char v19;
  int v20;
  char v21;
  const void *v22;
  unint64_t v23;
  BOOL v24;
  const void *v25;
  const void *v26;
  const void *v27;
  char v28;
  uint64_t v29;
  char v30;
  char v31;
  char v32;
  char v33;
  int v34;
  char v35;
  CFTypeID v36;
  const void *v37;
  const void *v38;
  char v39;
  uint64_t v40;
  char v41;
  char v42;
  char v43;
  char v44;
  int v45;
  char v46;
  const __CFString *v47;
  unint64_t v48;
  BOOL v49;
  const void *v50;
  CFTypeRef cf;
  int valuePtr;

  Value = (const __CFNumber *)CFDictionaryGetValue(a1, kSecAttrSysBound);
  if (Value && (v7 = Value, v8 = CFGetTypeID(Value), v8 == CFNumberGetTypeID()))
  {
    valuePtr = 0;
    if (CFNumberGetValue(v7, kCFNumberSInt32Type, &valuePtr))
      v9 = valuePtr == 0;
    else
      v9 = 1;
    return !v9;
  }
  else
  {
    result = (uint64_t)CFDictionaryGetValue(a1, kSecAttrAccessGroup);
    if (result)
    {
      v11 = (const void *)result;
      v12 = CFGetTypeID((CFTypeRef)result);
      if (v12 != CFStringGetTypeID())
        return 0;
      if (kSOSInternalAccessGroup && CFEqual(v11, kSOSInternalAccessGroup)
        || CFEqual(v11, CFSTR("lockdown-identities")))
      {
        return 1;
      }
      if (CFEqual(v11, CFSTR("apple"))
        && sub_1000119B8((uint64_t)CFSTR("genp"), &qword_100341240, (uint64_t)&unk_100341238) == a2)
      {
        v37 = CFDictionaryGetValue(a1, kSecAttrService);
        v38 = CFDictionaryGetValue(a1, kSecAttrAccount);
        if (sub_10012F0D0(v37))
        {
          if (sub_10012F0D0(v38) && CFEqual(v37, CFSTR("com.apple.managedconfiguration")))
          {
            v39 = 0;
            v40 = 0;
            v41 = 1;
            v42 = 1;
            do
            {
              v43 = v42;
              v44 = v39;
              v42 = v41;
              v45 = CFEqual(v38, off_1002DF860[v40]);
              if (v45)
                break;
              v41 = 0;
              v39 = 1;
              v40 = 1;
            }
            while ((v44 & 1) == 0);
            v46 = v45 ? v43 : v42;
            if ((v46 & 1) != 0)
              return 1;
          }
        }
        if (sub_10012F0D0(v37) && CFEqual(v37, CFSTR("com.apple.account.CloudKit.token"))
          || sub_10012F0D0(v37) && CFEqual(v37, CFSTR("com.apple.account.idms.continuation-key")))
        {
          return 1;
        }
      }
      if (a3)
      {
        if (CFEqual(v11, CFSTR("com.apple.apsd")))
        {
          if (sub_1000119B8((uint64_t)CFSTR("genp"), &qword_100341240, (uint64_t)&unk_100341238) == a2)
          {
            v13 = CFDictionaryGetValue(a1, kSecAttrService);
            if (sub_10012F0D0(v13))
            {
              v14 = 0;
              v15 = 0;
              v16 = 1;
              v17 = 1;
              do
              {
                v18 = v17;
                v19 = v14;
                v17 = v16;
                v20 = CFEqual(v13, off_1002DF870[v15]);
                if (v20)
                  break;
                v16 = 0;
                v14 = 1;
                v15 = 1;
              }
              while ((v19 & 1) == 0);
              v21 = v20 ? v18 : v17;
              if ((v21 & 1) != 0)
                return 1;
            }
          }
        }
        if (CFEqual(v11, CFSTR("appleaccount")))
        {
          if (sub_1000119B8((uint64_t)CFSTR("genp"), &qword_100341240, (uint64_t)&unk_100341238) == a2)
          {
            v22 = CFDictionaryGetValue(a1, kSecAttrService);
            if (sub_10012F0D0(v22))
            {
              v23 = 0;
              v24 = 1;
              do
              {
                if (CFEqual(v22, off_1002DF880[v23]))
                  break;
                v24 = v23++ < 3;
              }
              while (v23 != 4);
              if (v24)
                return 1;
            }
          }
        }
        if (CFEqual(v11, CFSTR("apple"))
          && sub_1000119B8((uint64_t)CFSTR("genp"), &qword_100341240, (uint64_t)&unk_100341238) == a2)
        {
          v47 = (const __CFString *)CFDictionaryGetValue(a1, kSecAttrService);
          if (sub_10012F0D0(v47))
          {
            v48 = 0;
            v49 = 1;
            do
            {
              if (CFEqual(v47, off_1002DF8A0[v48]))
                break;
              v49 = v48++ < 0xD;
            }
            while (v48 != 14);
            if (v49)
              return 1;
          }
          if (sub_10012F0D0(v47) && CFStringHasPrefix(v47, CFSTR("com.apple.gs.")))
            return 1;
          if (sub_10012F0D0(v47))
          {
            if (CFEqual(v47, CFSTR("com.apple.facetime")))
            {
              v50 = CFDictionaryGetValue(a1, kSecAttrAccount);
              if (sub_10012F0D0(v50))
              {
                if (CFEqual(v50, CFSTR("registrationV1")))
                  return 1;
              }
            }
          }
        }
        if (CFEqual(v11, CFSTR("com.apple.ind")))
        {
          if (sub_1000119B8((uint64_t)CFSTR("genp"), &qword_100341240, (uint64_t)&unk_100341238) == a2)
          {
            v25 = CFDictionaryGetValue(a1, kSecAttrService);
            if (sub_10012F0D0(v25))
            {
              if (CFEqual(v25, CFSTR("com.apple.ind.registration")))
                return 1;
            }
          }
        }
        if (CFEqual(v11, CFSTR("ichat")))
        {
          if (sub_1000119B8((uint64_t)CFSTR("genp"), &qword_100341240, (uint64_t)&unk_100341238) == a2)
          {
            v26 = CFDictionaryGetValue(a1, kSecAttrService);
            if (sub_10012F0D0(v26))
            {
              if (CFEqual(v26, CFSTR("ids")))
                return 1;
            }
          }
        }
        if (CFEqual(v11, CFSTR("ichat")))
        {
          if (sub_1000119B8((uint64_t)CFSTR("keys"), &qword_100341270, (uint64_t)&unk_100341268) == a2)
          {
            v27 = CFDictionaryGetValue(a1, kSecAttrLabel);
            if (sub_10012F0D0(v27))
            {
              v28 = 0;
              v29 = 0;
              v30 = 1;
              v31 = 1;
              do
              {
                v32 = v31;
                v33 = v28;
                v31 = v30;
                v34 = CFEqual(v27, off_1002DF910[v29]);
                if (v34)
                  break;
                v30 = 0;
                v28 = 1;
                v29 = 1;
              }
              while ((v33 & 1) == 0);
              v35 = v34 ? v32 : v31;
              if ((v35 & 1) != 0)
                return 1;
            }
          }
        }
        if (CFEqual(v11, CFSTR("com.apple.rapport"))
          && sub_1000119B8((uint64_t)CFSTR("genp"), &qword_100341240, (uint64_t)&unk_100341238) == a2)
        {
          return 1;
        }
      }
      cf = 0;
      if (CFDictionaryGetValueIfPresent(a1, kSecAttrSharingGroup, &cf)
        && cf
        && (v36 = CFGetTypeID(cf), v36 == CFStringGetTypeID()))
      {
        return 1;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

const void *sub_10012F0D0(const void *result)
{
  CFTypeID v1;

  if (result)
  {
    v1 = CFGetTypeID(result);
    return (const void *)(v1 == CFStringGetTypeID());
  }
  return result;
}

BOOL sub_10012F100(uint64_t a1, uint64_t a2, int a3, CFTypeRef *a4)
{
  NSObject *v8;
  _QWORD v10[7];
  char v11;
  uint8_t buf[4];
  uint64_t v13;
  __int16 v14;
  int v15;

  v8 = sub_10000EF14("SecWarning");
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412546;
    v13 = a2;
    v14 = 1024;
    v15 = a3;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "SecServerDeleteAllForUser for user: %@ keepU %{BOOL}d", buf, 0x12u);
  }
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = sub_10012F214;
  v10[3] = &unk_1002DF920;
  v10[4] = a1;
  v10[5] = a2;
  v11 = a3;
  v10[6] = a4;
  return sub_10001AC0C(a1, 2, a4, (uint64_t)v10);
}

uint64_t sub_10012F214(uint64_t a1)
{
  if (sub_10012F2A8(*(_QWORD *)(a1 + 32), CFSTR("DELETE FROM genp WHERE musr = ?"), *(const __CFString **)(a1 + 40), *(unsigned __int8 *)(a1 + 56), *(CFTypeRef **)(a1 + 48))&& sub_10012F2A8(*(_QWORD *)(a1 + 32), CFSTR("DELETE FROM inet WHERE musr = ?"), *(const __CFString **)(a1 + 40), *(unsigned __int8 *)(a1 + 56), *(CFTypeRef **)(a1 + 48))&& sub_10012F2A8(*(_QWORD *)(a1 + 32), CFSTR("DELETE FROM cert WHERE musr = ?"), *(const __CFString **)(a1 + 40), *(unsigned __int8 *)(a1 + 56), *(CFTypeRef **)(a1 + 48)))
  {
    return sub_10012F2A8(*(_QWORD *)(a1 + 32), CFSTR("DELETE FROM keys WHERE musr = ?"), *(const __CFString **)(a1 + 40), *(unsigned __int8 *)(a1 + 56), *(CFTypeRef **)(a1 + 48));
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10012F2A8(uint64_t a1, CFTypeRef cf, const __CFString *a3, int a4, CFTypeRef *a5)
{
  const __CFString *v8;
  const __CFString *v9;
  sqlite3_stmt *v10;
  sqlite3_stmt *v11;
  uint64_t v12;
  NSObject *v13;
  CFTypeRef v14;
  uint64_t result;
  uint8_t buf[4];
  const __CFString *v17;
  __int16 v18;
  const __CFString *v19;
  __int16 v20;
  CFTypeRef v21;

  if (a4)
    v8 = CFStringCreateWithFormat(0, 0, CFSTR("%@ AND pdmn NOT IN ('aku','akpu','cku','dku')"), cf);
  else
    v8 = (const __CFString *)CFRetain(cf);
  v9 = v8;
  if (v8)
  {
    v10 = sub_100012AE8(a1, v8, 0, a5);
    if (v10)
    {
      v11 = v10;
      if (sub_100013544(v10, 1, a3, a5))
        sub_100019C40(a1, v11, a5, (uint64_t)&stru_1002DFBC0);
      if (sub_100012D08(v11, a5))
      {
        v12 = 1;
LABEL_16:
        CFRelease(v9);
        return v12;
      }
    }
  }
  v13 = sub_10000EF14("SecWarning");
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    if (a5)
      v14 = *a5;
    else
      v14 = 0;
    *(_DWORD *)buf = 138412802;
    v17 = v9;
    v18 = 2112;
    v19 = a3;
    v20 = 2112;
    v21 = v14;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "DeleteAllFromTableForMUSRView failed for %@ for musr: %@: %@", buf, 0x20u);
  }
  v12 = 0;
  result = 0;
  if (v9)
    goto LABEL_16;
  return result;
}

uint64_t sub_10012F430(uint64_t a1)
{
  NSObject *v2;
  unsigned __int8 v3;
  int v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  const void *v8;
  _QWORD v10[7];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  char v14;
  uint8_t v15[4];
  uint64_t v16;
  __int16 v17;
  int v18;
  __int16 v19;
  uint64_t v20;
  __int128 buf;
  uint64_t v22;
  uint64_t v23;

  v2 = sub_10000EF14("item");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 138412290;
    *(_QWORD *)((char *)&buf + 4) = a1;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Request to delete app clip keychain items for identifier '%@'", (uint8_t *)&buf, 0xCu);
  }
  *(_QWORD *)&buf = 0;
  *((_QWORD *)&buf + 1) = &buf;
  v22 = 0x2000000000;
  v23 = 0;
  v11 = 0;
  v12 = &v11;
  v13 = 0x2000000000;
  v14 = 1;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = sub_10012F610;
  v10[3] = &unk_1002DF998;
  v10[4] = &buf;
  v10[5] = &v11;
  v10[6] = a1;
  v3 = sub_100011A30(1, 1, 0, (uint64_t)&v23, (uint64_t)v10);
  v4 = v3 & (*((_BYTE *)v12 + 24) != 0);
  *((_BYTE *)v12 + 24) = v4;
  if (v4)
    v5 = 0;
  else
    v5 = 4294941020;
  v6 = sub_10000EF14("item");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v7 = *(_QWORD *)(*((_QWORD *)&buf + 1) + 24);
    *(_DWORD *)v15 = 138412802;
    v16 = a1;
    v17 = 1024;
    v18 = v5;
    v19 = 2112;
    v20 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Finished request to delete app clip keychain items for identifier '%@' with status %i: %@", v15, 0x1Cu);
  }
  v8 = *(const void **)(*((_QWORD *)&buf + 1) + 24);
  if (v8)
  {
    *(_QWORD *)(*((_QWORD *)&buf + 1) + 24) = 0;
    CFRelease(v8);
  }
  _Block_object_dispose(&v11, 8);
  _Block_object_dispose(&buf, 8);
  return v5;
}

BOOL sub_10012F610(int8x16_t *a1, uint64_t a2)
{
  int8x16_t v2;
  CFTypeRef *v3;
  uint64_t v4;
  _QWORD v6[4];
  int8x16_t v7;
  uint64_t v8;
  uint64_t v9;

  v6[0] = _NSConcreteStackBlock;
  v2 = vextq_s8(a1[2], a1[2], 8uLL);
  v3 = (CFTypeRef *)(*(_QWORD *)(a1[2].i64[0] + 8) + 24);
  v6[1] = 0x40000000;
  v6[2] = sub_10012F684;
  v6[3] = &unk_1002DF970;
  v7 = v2;
  v4 = a1[3].i64[0];
  v8 = a2;
  v9 = v4;
  return sub_10001AC0C(a2, 2, v3, (uint64_t)v6);
}

uint64_t sub_10012F684(int8x16_t *a1)
{
  __CFString **v2;
  __CFString ***v3;
  CFStringRef v4;
  uint64_t v5;
  uint64_t v6;
  CFTypeRef *v7;
  int8x16_t v8;
  char v9;
  uint64_t v10;
  char v11;
  __CFString **v12;
  _QWORD v14[6];
  int8x16_t v15;

  v2 = &off_1002E2190;
  v3 = off_1002E4320;
  do
  {
    if (*((_BYTE *)v2 + 8))
    {
      v4 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("DELETE FROM %@ WHERE agrp = ? AND clip = 1"), *v2);
      v6 = a1[2].i64[0];
      v5 = a1[2].i64[1];
      v7 = (CFTypeRef *)(*(_QWORD *)(v5 + 8) + 24);
      v14[0] = _NSConcreteStackBlock;
      v14[1] = 0x40000000;
      v14[2] = sub_10012F7A0;
      v14[3] = &unk_1002DF948;
      v14[4] = v6;
      v14[5] = v5;
      v8 = a1[3];
      v15 = vextq_s8(v8, v8, 8uLL);
      v9 = sub_10001E3C4(v8.i64[0], (uint64_t)v4, v7, (uint64_t)v14);
      v10 = *(_QWORD *)(a1[2].i64[0] + 8);
      if (*(_BYTE *)(v10 + 24))
        v11 = v9;
      else
        v11 = 0;
      *(_BYTE *)(v10 + 24) = v11;
      if (v4)
        CFRelease(v4);
    }
    v12 = *v3++;
    v2 = v12;
  }
  while (v12);
  return *(unsigned __int8 *)(*(_QWORD *)(a1[2].i64[0] + 8) + 24);
}

uint64_t sub_10012F7A0(uint64_t a1, sqlite3_stmt *a2)
{
  char v4;
  uint64_t v5;
  char v6;
  uint64_t result;
  uint64_t v8;
  char v9;

  v4 = sub_100013544(a2, 1, *(const __CFString **)(a1 + 48), (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v5 + 24))
    v6 = v4;
  else
    v6 = 0;
  *(_BYTE *)(v5 + 24) = v6;
  result = sub_100019C40(*(_QWORD *)(a1 + 56), a2, (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), 0);
  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v8 + 24))
    v9 = result;
  else
    v9 = 0;
  *(_BYTE *)(v8 + 24) = v9;
  return result;
}

BOOL sub_10012F824(int8x16_t *a1, uint64_t a2)
{
  int8x16_t v2;
  CFTypeRef *v3;
  uint64_t v4;
  _QWORD v6[4];
  int8x16_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v6[0] = _NSConcreteStackBlock;
  v2 = vextq_s8(a1[2], a1[2], 8uLL);
  v3 = (CFTypeRef *)(*(_QWORD *)(a1[2].i64[0] + 8) + 24);
  v6[1] = 0x40000000;
  v6[2] = sub_10012F89C;
  v6[3] = &unk_1002DFA48;
  v7 = v2;
  v4 = a1[3].i64[1];
  v8 = a1[3].i64[0];
  v9 = a2;
  v10 = v4;
  return sub_10001AC0C(a2, 2, v3, (uint64_t)v6);
}

uint64_t sub_10012F89C(uint64_t a1)
{
  __CFString **v2;
  __CFString ***v3;
  const __CFDictionary *v4;
  CFDictionaryRef *v5;
  const void **v6;
  int8x16_t v7;
  CFTypeRef *v8;
  int8x16_t v9;
  BOOL v10;
  uint64_t v11;
  BOOL v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const void *v17;
  __CFString **v18;
  _QWORD v20[4];
  int8x16_t v21;
  int8x16_t v22;
  uint8_t buf[4];
  uint64_t v24;
  __int16 v25;
  uint64_t v26;

  v2 = &off_1002E2190;
  v3 = off_1002E4320;
  do
  {
    if (*((_BYTE *)v2 + 8))
    {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), kSecClass, *v2);
      v4 = *(const __CFDictionary **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      if (qword_100341198 != -1)
        dispatch_once(&qword_100341198, &stru_1002DED48);
      v5 = (CFDictionaryRef *)sub_1000112B0(v4, (const void *)qword_1003411A0, -1, 0, (__CFString **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
      if (v5)
      {
        v6 = (const void **)v5;
        v20[0] = _NSConcreteStackBlock;
        v7 = vextq_s8(*(int8x16_t *)(a1 + 40), *(int8x16_t *)(a1 + 40), 8uLL);
        v8 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
        v20[1] = 0x40000000;
        v20[2] = sub_10012FAF0;
        v20[3] = &unk_1002DFA20;
        v9 = *(int8x16_t *)(a1 + 56);
        v21 = v7;
        v22 = vextq_s8(v9, v9, 8uLL);
        v10 = sub_10001E280(v5, v9.i64[0], v8, 0, &stru_1002DF9D8, 0, 0, (uint64_t)v20);
        v11 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
        if (*(_BYTE *)(v11 + 24))
          v12 = v10;
        else
          v12 = 0;
        *(_BYTE *)(v11 + 24) = v12;
        sub_100011108(v6, 0);
      }
      else
      {
        v13 = sub_10000EF14("SecError");
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          v14 = (uint64_t)**(v3 - 1);
          v15 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
          *(_DWORD *)buf = 138412546;
          v24 = v14;
          v25 = 2112;
          v26 = v15;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "AppcClipPromotion: unable to create query for class %@: %@", buf, 0x16u);
        }
        v16 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
        v17 = *(const void **)(v16 + 24);
        if (v17)
        {
          *(_QWORD *)(v16 + 24) = 0;
          CFRelease(v17);
        }
      }
    }
    v18 = *v3++;
    v2 = v18;
  }
  while (v18);
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
}

void sub_10012FAF0(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  const void *v6;
  const void *v7;
  uint64_t v8;
  CFTypeRef v9;
  int v10;
  NSObject *v11;
  int Code;
  NSObject *v14;
  NSObject *v15;
  CFTypeRef v17;
  uint64_t v18;
  _QWORD v19[5];
  CFTypeRef cf;
  uint8_t buf[4];
  int v22;
  __int16 v23;
  uint64_t v24;

  cf = 0;
  if (!sub_1000192F4(a2, 1, (__CFString **)&cf))
    goto LABEL_13;
  v6 = sub_1000070C4(a2, *(const __CFDictionary **)(a1 + 48), (__CFString **)&cf);
  v7 = v6;
  if (cf || (sub_100116454((uint64_t)v6, (__CFString **)&cf), cf))
  {
LABEL_11:
    if (!v7)
      goto LABEL_13;
    goto LABEL_12;
  }
  v8 = *(_QWORD *)(a1 + 56);
  v19[0] = _NSConcreteStackBlock;
  v19[1] = 0x40000000;
  v19[2] = sub_10012FE18;
  v19[3] = &unk_1002DF9F8;
  v19[4] = v7;
  if ((sub_10001DADC((uint64_t)v7, v8, (__CFString **)&cf, (uint64_t)v19) & 1) == 0)
  {
    if (!sub_1001165A4((__CFError *)cf))
    {
      v10 = 0;
      goto LABEL_10;
    }
    v9 = cf;
    if (cf)
    {
      cf = 0;
      CFRelease(v9);
    }
  }
  v10 = 1;
LABEL_10:
  v11 = sub_10000EF14("item");
  if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    goto LABEL_11;
  *(_DWORD *)buf = 67109120;
  v22 = v10;
  _os_log_debug_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "SecServerPromoteAppClipItemsToParentApp SecDbItemInsertOrReplace %d", buf, 8u);
  if (v7)
LABEL_12:
    CFRelease(v7);
LABEL_13:
  if (cf)
  {
    Code = CFErrorGetCode((CFErrorRef)cf);
    if (Code == -25330 || Code == -26275)
    {
      v14 = sub_10000EF14("item");
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109379;
        v22 = Code;
        v23 = 2113;
        v24 = a2;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Unable (%i) to promote item: %{private}@", buf, 0x12u);
      }
    }
    else
    {
      v15 = sub_10000EF14("item");
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109379;
        v22 = Code;
        v23 = 2113;
        v24 = a2;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Encountered error %i during promotion: %{private}@", buf, 0x12u);
      }
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
    }
  }
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    v17 = cf;
    if (cf)
    {
      cf = 0;
      CFRelease(v17);
    }
  }
  else
  {
    *a3 = 1;
    if (cf)
    {
      v18 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
      if (!*(_QWORD *)(v18 + 24))
        *(_QWORD *)(v18 + 24) = cf;
    }
  }
}

BOOL sub_10012FDA0(id a1, const SecDbAttr *a2)
{
  __CFString *var0;
  CFStringRef v5;

  var0 = a2->var0;
  if (!a2->var0)
  {
    v5 = kSecAttrAccessGroup;
    return var0 == v5;
  }
  if (CFEqual(var0, CFSTR("clip")))
    return 1;
  var0 = a2->var0;
  v5 = kSecAttrAccessGroup;
  if (!a2->var0 || !kSecAttrAccessGroup)
    return var0 == v5;
  return CFEqual(var0, kSecAttrAccessGroup) != 0;
}

CFTypeRef sub_10012FE18(CFTypeRef result, uint64_t a2, _QWORD *a3)
{
  uint64_t v4;

  v4 = *((_QWORD *)result + 4);
  if (v4)
    result = CFRetain(*((CFTypeRef *)result + 4));
  *a3 = v4;
  return result;
}

__CFDictionary *sub_10012FE48(uint64_t a1, uint64_t a2, int *a3, unsigned int a4, __CFString **a5)
{
  CFMutableDictionaryRef Mutable;
  unsigned int v10;
  char v11;
  uint64_t v12;
  CFStringRef v13;
  CFStringRef v14;
  int v15;
  int v16;
  int v17;
  NSObject *v18;
  uint64_t v19;
  BOOL v20;
  int *v21;
  const char *v22;
  int v23;
  NSObject *v24;
  uint64_t v25;
  NSObject *v26;
  uint64_t v27;
  const __CFString *v28;
  CFIndex Count;
  NSObject *v30;
  uint64_t v31;
  const void *v32;
  NSObject *v33;
  uint64_t v34;
  const void *v35;
  const void *v36;
  CFTypeRef *v38;
  CFStringRef v39;
  __CFDictionary *theDict;
  const char *v42;
  CFErrorRef err;
  _OWORD v44[3];
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 cf;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  uint64_t v58;
  unsigned __int8 uu[32];
  _BYTE bytes[40];
  unint64_t v61;
  unint64_t v62;
  _QWORD v63[4];

  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v58 = 0;
  v56 = 0u;
  v57 = 0u;
  v54 = 0u;
  v55 = 0u;
  v52 = 0u;
  v53 = 0u;
  cf = 0u;
  v51 = 0u;
  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  v47 = 0u;
  v45 = 0u;
  memset(v44, 0, sizeof(v44));
  DWORD2(v49) = dword_1003414E0;
  theDict = Mutable;
  if (!Mutable)
  {
    if (a5 && !*a5)
      sub_100019F20(-108, a5, CFSTR("Can't create keychain dictionary"));
    v14 = 0;
    goto LABEL_55;
  }
  LODWORD(v45) = 11;
  *((_QWORD *)&v48 + 1) = -1;
  WORD4(v51) = 257;
  v38 = (CFTypeRef *)a5;
  if (!a2 || !*(_BYTE *)(a2 + 36))
  {
    if (qword_100341188 != -1)
      dispatch_once(&qword_100341188, &stru_1002DED08);
    v12 = a1;
    *(_QWORD *)&cf = qword_100341190;
    CFRetain((CFTypeRef)qword_100341190);
    if (a3)
    {
      v13 = sub_1001304E4(*a3, 0);
      if (v13)
      {
LABEL_9:
        v39 = v13;
        CFDictionarySetValue(theDict, CFSTR("keybag-uuid"), v13);
LABEL_21:
        v11 = 0;
        goto LABEL_22;
      }
    }
    else
    {
      v15 = dword_1003414E0;
      memset(uu, 170, 16);
      v16 = sub_100026480(dword_1003414E0, uu);
      if (v16)
      {
        v17 = v16;
        v18 = sub_10000EF14("SecError");
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)bytes = 67109376;
          *(_DWORD *)&bytes[4] = v15;
          *(_WORD *)&bytes[8] = 1024;
          *(_DWORD *)&bytes[10] = v17;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "keybag-uuid: could not determine backup keybag UUID for %d: %d", bytes, 0xEu);
        }
        v13 = 0;
      }
      else
      {
        memset(bytes, 0, 37);
        uuid_unparse_lower(uu, bytes);
        v13 = CFStringCreateWithCString(0, bytes, 0x8000100u);
      }
      v12 = a1;
      if (v13)
        goto LABEL_9;
    }
    v39 = 0;
    goto LABEL_21;
  }
  v10 = *(_DWORD *)(a2 + 20);
  *(_QWORD *)bytes = 0x104B57A5353A5AA7;
  *(_DWORD *)&bytes[8] = -1803342146;
  *(_DWORD *)&bytes[12] = bswap32(v10);
  v39 = 0;
  *(_QWORD *)&cf = CFDataCreate(0, bytes, 16);
  v11 = 1;
  v12 = a1;
LABEL_22:
  v63[0] = sub_1000119B8((uint64_t)CFSTR("genp"), &qword_100341240, (uint64_t)&unk_100341238);
  v63[1] = sub_1000119B8((uint64_t)CFSTR("inet"), &qword_100341250, (uint64_t)&unk_100341248);
  v63[2] = sub_1000119B8((uint64_t)CFSTR("cert"), &qword_100341260, (uint64_t)&unk_100341258);
  v19 = 0;
  v63[3] = sub_1000119B8((uint64_t)CFSTR("keys"), &qword_100341270, (uint64_t)&unk_100341268);
  v20 = a3 == 0;
  if (a3)
    v21 = a3;
  else
    v21 = &dword_1003414E0;
  v22 = "non-";
  if (a4 == 1)
    v22 = "";
  v42 = v22;
  while (1)
  {
    *(_QWORD *)&v44[0] = v63[v19];
    v61 = 0xAAAAAAAAAAAAAAAALL;
    v62 = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&bytes[32] = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)bytes = v44;
    *(_QWORD *)&bytes[8] = 0;
    *(_QWORD *)&bytes[16] = v12;
    *(_QWORD *)&bytes[24] = 0;
    v23 = *v21;
    *(_DWORD *)&bytes[32] = 0;
    LODWORD(v61) = v23;
    BYTE4(v61) = v20;
    LODWORD(v62) = a4;
    BYTE4(v62) = v11;
    v24 = sub_10000EF14("item");
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      v25 = **(_QWORD **)&v44[0];
      *(_DWORD *)uu = 136315394;
      *(_QWORD *)&uu[4] = v42;
      *(_WORD *)&uu[12] = 2112;
      *(_QWORD *)&uu[14] = v25;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "exporting %ssysbound class '%@'", uu, 0x16u);
    }
    err = 0;
    if (!sub_100012878((uint64_t)sub_1001305F4, (uint64_t)bytes, (__CFString **)&err))
      break;
    v26 = sub_10000EF14("item");
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      v27 = **(_QWORD **)&v44[0];
      *(_DWORD *)uu = 138412290;
      *(_QWORD *)&uu[4] = v27;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "exporting class '%@' complete", uu, 0xCu);
    }
    if (CFArrayGetCount(*(CFArrayRef *)&bytes[24]))
    {
      v28 = **(const __CFString ***)&v44[0];
      Count = CFArrayGetCount(*(CFArrayRef *)&bytes[24]);
      if (CFStringGetLength(v28) == 4)
      {
        memset(uu, 170, 5);
        if (CFStringGetCString(v28, (char *)uu, 5, 0x8000100u))
          kdebug_trace(726810628, *(unsigned int *)uu, Count, a4, 0);
      }
      CFDictionaryAddValue(theDict, **(const void ***)&v44[0], *(const void **)&bytes[24]);
      v12 = a1;
    }
LABEL_42:
    v32 = *(const void **)&bytes[24];
    if (*(_QWORD *)&bytes[24])
    {
      *(_QWORD *)&bytes[24] = 0;
      CFRelease(v32);
    }
    if (++v19 == 4)
    {
      v14 = v39;
      goto LABEL_56;
    }
  }
  if (CFErrorGetCode(err) == -25300)
  {
    v30 = sub_10000EF14("item");
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      v31 = **(_QWORD **)&v44[0];
      *(_DWORD *)uu = 138412290;
      *(_QWORD *)&uu[4] = v31;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "exporting class '%@' complete (no items)", uu, 0xCu);
    }
    CFRelease(err);
    goto LABEL_42;
  }
  v33 = sub_10000EF14("SecError");
  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
  {
    v34 = **(_QWORD **)&v44[0];
    *(_DWORD *)uu = 138412546;
    *(_QWORD *)&uu[4] = v34;
    *(_WORD *)&uu[12] = 2112;
    *(_QWORD *)&uu[14] = err;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "exporting class '%@' failed: %@", uu, 0x16u);
  }
  if (v38)
  {
    if (*v38)
      CFRelease(*v38);
    *v38 = err;
  }
  else
  {
    CFRelease(err);
  }
  CFRelease(theDict);
  v35 = *(const void **)&bytes[24];
  v14 = v39;
  if (*(_QWORD *)&bytes[24])
  {
    *(_QWORD *)&bytes[24] = 0;
    CFRelease(v35);
  }
LABEL_55:
  theDict = 0;
LABEL_56:
  v36 = (const void *)cf;
  if ((_QWORD)cf)
  {
    *(_QWORD *)&cf = 0;
    CFRelease(v36);
  }
  if (v14)
    CFRelease(v14);
  return theDict;
}

CFStringRef sub_1001304E4(int a1, uint64_t a2)
{
  int v4;
  int v5;
  NSObject *v6;
  __int128 v7;
  uuid_string_t out;

  *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  if (a2)
  {
    uuid_copy((unsigned __int8 *)&v7, (const unsigned __int8 *)(a2 + 32));
LABEL_3:
    memset(out, 0, sizeof(out));
    uuid_unparse_lower((const unsigned __int8 *)&v7, out);
    return CFStringCreateWithCString(0, out, 0x8000100u);
  }
  v4 = sub_100025E0C(a1, &v7);
  if (!v4)
    goto LABEL_3;
  v5 = v4;
  v6 = sub_10000EF14("SecError");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)out = 67109376;
    *(_DWORD *)&out[4] = a1;
    *(_WORD *)&out[8] = 1024;
    *(_DWORD *)&out[10] = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "keybag-uuid: could not determine keybag UUID for %d: %d", (uint8_t *)out, 0xEu);
  }
  return 0;
}

void sub_1001305F4(sqlite3_stmt *a1, uint64_t a2)
{
  __CFString **v4;
  sqlite3_int64 v5;
  __CFDictionary *Mutable;
  int v7;
  const __CFDictionary *MutableCopy;
  char *data;
  uint64_t *p_length;
  const void *v11;
  char *v12;
  CFStringRef Protection;
  _BOOL4 v14;
  BOOL v15;
  int v16;
  int v17;
  int v18;
  _BOOL4 v19;
  const __CFDictionary *v20;
  int v21;
  int v22;
  const __CFData *v23;
  const __CFData *v24;
  uint64_t UUIDBasedPersistentRef;
  NSObject *v26;
  int OSStatus;
  NSObject *v29;
  int v30;
  const unsigned __int8 *v31;
  CFStringRef v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  CFStringRef v40;
  CFDictionaryRef v41;
  NSObject *v42;
  __CFString *v43;
  __CFDictionary *v44;
  char *v45;
  uint64_t *v46;
  const void *v47;
  char *v48;
  void **v49;
  BOOL v50;
  void *v51;
  int v52;
  NSObject *v53;
  __CFString *v54;
  NSObject *v55;
  void *isa;
  __CFString *v57;
  CFTypeRef v58;
  CFDictionaryRef v59;
  __CFString *v60;
  void *value;
  int v62;
  CFDictionaryRef theDict;
  __CFString *v64;
  CFTypeRef cf;
  uint8_t buf[4];
  _BYTE v67[18];
  __int16 v68;
  __CFString *v69;

  v4 = *(__CFString ***)a2;
  v64 = 0;
  cf = 0;
  v5 = sqlite3_column_int64(a1, 0);
  theDict = 0;
  Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v62 = 0;
  v7 = sub_100014B3C(a1, (uint64_t)v4, 1, *(const __CFArray **)(a2 + 8), &theDict, &cf, &v62, &v64);
  MutableCopy = 0;
  if (v7)
  {
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDict);
    data = (*v4)->data;
    if (data)
    {
      p_length = &(*v4)->length;
      do
      {
        if ((data[16] & 0x20) != 0)
        {
          v11 = CFDictionaryGetValue(MutableCopy, *(const void **)data);
          if (v11)
          {
            CFDictionarySetValue(Mutable, *(const void **)data, v11);
            CFDictionaryRemoveValue(MutableCopy, *(const void **)data);
          }
        }
        v12 = (char *)*p_length++;
        data = v12;
      }
      while (v12);
    }
  }
  if (!cf)
  {
    v15 = (v62 & 0x1F) == 12;
    goto LABEL_14;
  }
  Protection = (CFStringRef)SecAccessControlGetProtection(cf);
  if (!Protection || !kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly)
  {
    v15 = Protection == kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly;
LABEL_14:
    v14 = v15;
    goto LABEL_17;
  }
  v14 = CFEqual(Protection, kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly) != 0;
LABEL_17:
  if (theDict)
    v16 = v7;
  else
    v16 = 0;
  if (v16 == 1)
    v17 = CFDictionaryContainsKey(theDict, kSecAttrTokenID);
  else
    v17 = 0;
  if (v17)
    v18 = 1;
  else
    v18 = v14;
  v19 = v18 == 1 && *(_DWORD *)(a2 + 48) == 2;
  v20 = theDict;
  if (theDict)
    v21 = v7;
  else
    v21 = 0;
  if (v21 != 1 || v19)
  {
    if ((v21 & 1) != 0)
    {
      v26 = sub_10000EF14("item");
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134218240;
        *(_QWORD *)v67 = v5;
        *(_WORD *)&v67[8] = 1024;
        *(_DWORD *)&v67[10] = v19;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "export rowid %llu skipped. akpu/token: %i", buf, 0x12u);
      }
      goto LABEL_83;
    }
    OSStatus = SecErrorGetOSStatus(v64);
    if (OSStatus == -25308 && v14)
    {
      if (!v19)
      {
        v29 = sub_10000EF14("SecError");
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
        {
          v30 = *(_DWORD *)(a2 + 48);
          *(_DWORD *)buf = 67109378;
          *(_DWORD *)v67 = v30;
          *(_WORD *)&v67[4] = 2112;
          *(_QWORD *)&v67[6] = v64;
          _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Encountered akpu item we cannot export (filter %d), skipping. %@", buf, 0x12u);
        }
        if (sqlite3_column_count(a1) >= 3)
        {
          v31 = sqlite3_column_text(a1, 2);
          v32 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)v31, 0x8000100u);
          if (v32)
          {
            v40 = v32;
            v41 = sub_10012E96C(0, v33, v34, v35, v36, v37, v38, v39, (uint64_t)CFSTR("agrp"), (uint64_t)v32);
            SecABCTrigger(CFSTR("keychain"), CFSTR("invalid-akpu+sysbound"), 0, v41);
            if (v41)
              CFRelease(v41);
            CFRelease(v40);
          }
        }
      }
    }
    else
    {
      v52 = OSStatus;
      v53 = sub_10000EF14("item");
      if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 134218242;
        *(_QWORD *)v67 = v5;
        *(_WORD *)&v67[8] = 2112;
        *(_QWORD *)&v67[10] = v64;
        _os_log_debug_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEBUG, "Could not export item for rowid %llu: %@", buf, 0x16u);
      }
      if (v52 != -26275)
      {
        v60 = v4[5];
        if (v60)
          CFRelease(v60);
        v4[5] = v64;
        goto LABEL_83;
      }
    }
    v54 = v64;
    if (!v64)
      goto LABEL_83;
    v64 = 0;
    goto LABEL_82;
  }
  v22 = *(_DWORD *)(a2 + 48);
  if (v22)
  {
    if ((v22 != 1) == sub_10012EA5C(theDict, (uint64_t)*v4, *(unsigned __int8 *)(a2 + 52)))
      goto LABEL_83;
    v20 = theDict;
  }
  v23 = (const __CFData *)CFDictionaryGetValue(v20, kSecAttrPersistentReference);
  if (v23 && (v24 = v23, CFDataGetLength(v23) == 16))
  {
    UUIDBasedPersistentRef = _SecItemCreateUUIDBasedPersistentRef((*v4)->isa, v24, theDict);
  }
  else
  {
    v42 = sub_10000EF14("pref");
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)v67 = v5;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "s3dl_export_row: Creating old persistent ref for %llu", buf, 0xCu);
    }
    UUIDBasedPersistentRef = _SecItemCreatePersistentRef((*v4)->isa, v5, theDict);
  }
  v43 = (__CFString *)UUIDBasedPersistentRef;
  if (UUIDBasedPersistentRef)
  {
    if (*(_DWORD *)(a2 + 40) != -1)
    {
      v44 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      v45 = (*v4)->data;
      if (v45)
      {
        v46 = &(*v4)->length;
        do
        {
          if ((v45[17] & 0x20) != 0)
          {
            v47 = CFDictionaryGetValue(MutableCopy, *(const void **)v45);
            if (v47)
            {
              CFDictionaryAddValue(v44, *(const void **)v45, v47);
              CFDictionaryRemoveValue(MutableCopy, *(const void **)v45);
            }
          }
          v48 = (char *)*v46++;
          v45 = v48;
        }
        while (v48);
      }
      value = 0;
      v49 = (void **)(v4 + 5);
      v50 = sub_10001D40C((const __CFData *)*(unsigned int *)(a2 + 40), (uint64_t)cf, (const __CFData *)v4[18], Mutable, MutableCopy, v44, (__CFData **)&value, 0, *(_BYTE *)(a2 + 44), v4 + 5);
      CFDictionaryRemoveAllValues(theDict);
      CFRelease(v44);
      if (v50)
      {
        v51 = value;
        CFDictionarySetValue(theDict, kSecValueData, value);
        if (!v51)
          goto LABEL_79;
      }
      else
      {
        v55 = sub_10000EF14("SecCritical");
        if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
        {
          isa = (*v4)->isa;
          v57 = v4[5];
          *(_DWORD *)buf = 138412802;
          *(_QWORD *)v67 = isa;
          *(_WORD *)&v67[8] = 2048;
          *(_QWORD *)&v67[10] = v5;
          v68 = 2112;
          v69 = v57;
          _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "ks_encrypt_data %@,rowid=%lld: failed: %@", buf, 0x20u);
        }
        v51 = *v49;
        if (!*v49)
          goto LABEL_79;
        *v49 = 0;
      }
      CFRelease(v51);
    }
LABEL_79:
    if (CFDictionaryGetCount(theDict))
    {
      CFDictionarySetValue(theDict, kSecValuePersistentRef, v43);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a2 + 24), theDict);
      ++*(_DWORD *)(a2 + 32);
    }
    v54 = v43;
LABEL_82:
    CFRelease(v54);
  }
LABEL_83:
  v58 = cf;
  if (cf)
  {
    cf = 0;
    CFRelease(v58);
  }
  v59 = theDict;
  if (theDict)
  {
    theDict = 0;
    CFRelease(v59);
  }
  if (MutableCopy)
    CFRelease(MutableCopy);
  if (Mutable)
    CFRelease(Mutable);
}

BOOL sub_100130CBC(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5, const __CFDictionary *a6, int a7, int a8, __CFString **a9)
{
  CFTypeRef *v16;
  _BOOL8 v17;
  __CFDictionary *v18;
  const void *Value;
  const void *v20;
  const __CFDictionary *v21;
  CFTypeID v22;
  BOOL v23;
  unsigned int v24;
  CFDataRef v25;
  CFDataRef v26;
  const __CFDictionary *v27;
  const void *v28;
  BOOL v29;
  NSObject *v30;
  CFStringRef v31;
  NSObject *v32;
  const char *v33;
  NSObject *v34;
  uint32_t v35;
  NSObject *v36;
  uint64_t v37;
  const void *v38;
  NSObject *v39;
  CFIndex Count;
  NSObject *v41;
  CFIndex v42;
  CFTypeRef v43;
  id v44;
  NSObject *v45;
  void *v46;
  CFStringRef cf1;
  const void *v50;
  const void *context;
  CFTypeRef cf;
  int v53;
  int v54;
  uint64_t v55;
  int v56;
  int v57;
  uint64_t v58;
  int v59;
  int v60;
  _QWORD v61[6];
  uint8_t buf[4];
  uint64_t v63;
  __int128 bytes;
  uint64_t v65;
  CFTypeRef v66[3];

  v16 = (CFTypeRef *)a9;
  if (a7 == 2)
  {
    LODWORD(bytes) = -1;
    v17 = 1;
    v18 = sub_10012FE48(a1, a2, (int *)&bytes, 1u, a9);
    if (!v18)
      return v17;
  }
  else
  {
    v18 = 0;
  }
  cf1 = sub_1001304E4(a3, a4);
  v50 = (const void *)a1;
  if (!cf1
    || (Value = CFDictionaryGetValue(a6, CFSTR("keybag-uuid"))) == 0
    || (v20 = Value,
        v21 = a6,
        v22 = CFGetTypeID(Value),
        v23 = v22 == CFStringGetTypeID(),
        a6 = v21,
        v16 = (CFTypeRef *)a9,
        !v23)
    || CFEqual(cf1, v20))
  {
    if (*(_BYTE *)(a2 + 36))
    {
      v24 = *(_DWORD *)(a2 + 20);
      *(_QWORD *)&bytes = 0x104B57A5353A5AA7;
      DWORD2(bytes) = -1803342146;
      HIDWORD(bytes) = bswap32(v24);
      v25 = CFDataCreate(0, (const UInt8 *)&bytes, 16);
      if (!v25)
        goto LABEL_18;
      v26 = v25;
      v27 = a6;
      v28 = v50;
      v29 = sub_10012F100((uint64_t)v50, (uint64_t)v25, 1, v16);
      CFRelease(v26);
      if (!v29)
        goto LABEL_18;
      goto LABEL_29;
    }
    if (a8)
    {
      v27 = a6;
      v30 = sub_10000EF14("SecWarning");
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(bytes) = 0;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "SecServerDeleteAll", (uint8_t *)&bytes, 2u);
      }
      *(_QWORD *)&bytes = _NSConcreteStackBlock;
      *((_QWORD *)&bytes + 1) = 0x40000000;
      v65 = (uint64_t)sub_10013127C;
      v66[0] = &unk_1002DFBE0;
      v28 = v50;
      v66[1] = v50;
      v66[2] = v16;
      if (!sub_10001AC0C((uint64_t)v50, 2, v16, (uint64_t)&bytes))
      {
LABEL_18:
        v17 = 0;
        v31 = cf1;
        if (!v18)
          goto LABEL_47;
LABEL_46:
        CFRelease(v18);
        goto LABEL_47;
      }
LABEL_29:
      v54 = -1431655766;
      v57 = -1431655766;
      context = v28;
      cf = 0;
      v53 = a3;
      v55 = a4;
      v56 = a5;
      v58 = a2;
      v60 = -1431655766;
      v59 = a7;
      v39 = sub_10000EF14("SecWarning");
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        Count = CFDictionaryGetCount(v27);
        LODWORD(bytes) = 134217984;
        *(_QWORD *)((char *)&bytes + 4) = Count;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "Restoring backup items '%ld'", (uint8_t *)&bytes, 0xCu);
      }
      CFDictionaryApplyFunction(v27, (CFDictionaryApplierFunction)sub_100131390, &context);
      v31 = cf1;
      if (v18)
      {
        v53 = -1;
        v55 = 0;
        v59 = 1;
        v41 = sub_10000EF14("SecWarning");
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
        {
          v42 = CFDictionaryGetCount(v18);
          LODWORD(bytes) = 134217984;
          *(_QWORD *)((char *)&bytes + 4) = v42;
          _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "Restoring sysbound items '%ld'", (uint8_t *)&bytes, 0xCu);
        }
        CFDictionaryApplyFunction(v18, (CFDictionaryApplierFunction)sub_100131390, &context);
      }
      v43 = cf;
      v17 = cf == 0;
      if (cf)
      {
        if (v16)
        {
          if (*v16)
          {
            CFRelease(*v16);
            v43 = cf;
          }
          *v16 = v43;
        }
        else
        {
          CFRelease(cf);
        }
      }
      if (sub_10000BD64())
      {
        v44 = sub_10000BDF4(CFSTR("reset"), 0);
        v45 = objc_claimAutoreleasedReturnValue(v44);
        if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(bytes) = 0;
          _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "Local keychain was reset; performing local resync",
            (uint8_t *)&bytes,
            2u);
        }

        v46 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSViewManager manager](CKKSViewManager, "manager"));
        objc_msgSend(v46, "rpcResyncLocal:reply:", 0, &stru_1002DCCA0);

      }
      if (!v18)
        goto LABEL_47;
      goto LABEL_46;
    }
    *(_QWORD *)&bytes = 0;
    *((_QWORD *)&bytes + 1) = &bytes;
    v65 = 0x2000000000;
    v66[0] = 0;
    v61[0] = _NSConcreteStackBlock;
    v61[1] = 0x40000000;
    v61[2] = sub_1001312F4;
    v61[3] = &unk_1002DFA98;
    v61[4] = &bytes;
    v61[5] = a1;
    v27 = a6;
    if (sub_10001AC0C(a1, 2, v66, (uint64_t)v61))
    {
      v32 = sub_10000EF14("restore");
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        v33 = "Successfully deleted nonsyncable items";
        v34 = v32;
        v35 = 2;
LABEL_25:
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, v33, buf, v35);
      }
    }
    else
    {
      v36 = sub_10000EF14("SecError");
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
      {
        v37 = *(_QWORD *)(*((_QWORD *)&bytes + 1) + 24);
        *(_DWORD *)buf = 138412290;
        v63 = v37;
        v33 = "Unable to delete nonsyncable items prior to keychain restore: %@";
        v34 = v36;
        v35 = 12;
        goto LABEL_25;
      }
    }
    v38 = *(const void **)(*((_QWORD *)&bytes + 1) + 24);
    if (v38)
    {
      *(_QWORD *)(*((_QWORD *)&bytes + 1) + 24) = 0;
      CFRelease(v38);
    }
    _Block_object_dispose(&bytes, 8);
    v28 = v50;
    goto LABEL_29;
  }
  v31 = cf1;
  sub_100019F20(-26275, a9, CFSTR("Keybag UUID (%@) mismatch with backup (%@)"), cf1, v20);
  v17 = 1;
  if (v18)
    goto LABEL_46;
LABEL_47:
  if (v31)
    CFRelease(v31);
  return v17;
}

uint64_t sub_10013127C(uint64_t a1)
{
  if (sub_10001B41C(*(_QWORD *)(a1 + 32), CFSTR("DELETE from genp;"), *(CFTypeRef **)(a1 + 40))
    && sub_10001B41C(*(_QWORD *)(a1 + 32), CFSTR("DELETE from inet;"), *(CFTypeRef **)(a1 + 40))
    && sub_10001B41C(*(_QWORD *)(a1 + 32), CFSTR("DELETE from cert;"), *(CFTypeRef **)(a1 + 40)))
  {
    return sub_10001B41C(*(_QWORD *)(a1 + 32), CFSTR("DELETE from keys;"), *(CFTypeRef **)(a1 + 40));
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1001312F4(uint64_t a1)
{
  int v2;
  int v3;
  int v4;

  v2 = sub_10001B41C(*(_QWORD *)(a1 + 40), CFSTR("DELETE FROM genp WHERE sync = 0 AND NOT agrp IN ('com.apple.security.sos', 'com.apple.security.sos-usercredential', 'com.apple.security.ckks', 'com.apple.security.egoIdentities', 'com.apple.security.octagon') AND NOT ggrp <> '';"),
         (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  v3 = v2 & sub_10001B41C(*(_QWORD *)(a1 + 40), CFSTR("DELETE FROM inet WHERE sync = 0 AND NOT agrp IN ('com.apple.security.sos', 'com.apple.security.sos-usercredential', 'com.apple.security.ckks', 'com.apple.security.egoIdentities', 'com.apple.security.octagon') AND NOT ggrp <> '';"),
              (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  v4 = sub_10001B41C(*(_QWORD *)(a1 + 40), CFSTR("DELETE FROM cert WHERE sync = 0 AND NOT agrp IN ('com.apple.security.sos', 'com.apple.security.sos-usercredential', 'com.apple.security.ckks', 'com.apple.security.egoIdentities', 'com.apple.security.octagon') AND NOT ggrp <> '';"),
         (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  return v3 & v4 & sub_10001B41C(*(_QWORD *)(a1 + 40), CFSTR("DELETE FROM keys WHERE sync = 0 AND NOT agrp IN ('com.apple.security.sos', 'com.apple.security.sos-usercredential', 'com.apple.security.ckks', 'com.apple.security.egoIdentities', 'com.apple.security.octagon') AND NOT ggrp <> '';"),
                                   (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
}

void sub_100131390(CFTypeRef cf, const void *a2, uint64_t a3)
{
  __CFString **v3;
  CFTypeID v7;
  __CFString **v8;
  const __CFString **v9;
  CFTypeID v10;
  NSObject *v11;
  CFIndex Count;
  int v13;
  const __CFString *v14;
  CFIndex v15;
  NSObject *v16;
  const char *v17;
  NSObject *v18;
  uint32_t v19;
  _BOOL4 v20;
  CFTypeID v21;
  NSObject *v22;
  _BOOL4 v23;
  int v24;
  int v25;
  uint64_t context[2];
  uint8_t buf[4];
  uint64_t v28;
  __int16 v29;
  CFTypeRef v30;
  __int16 v31;
  int v32;
  CFRange v33;

  v3 = (__CFString **)(a3 + 8);
  if (*(_QWORD *)(a3 + 8))
    return;
  if (!cf)
  {
    sub_100019F20(-50, v3, CFSTR("class name %@ is not a string"), 0);
    return;
  }
  v7 = CFGetTypeID(cf);
  if (v7 != CFStringGetTypeID())
  {
    sub_100019F20(-50, v3, CFSTR("class name %@ is not a string"), cf);
    return;
  }
  if (CFEqual(cf, CFSTR("keybag-uuid")))
    return;
  v8 = sub_100011884(cf);
  if (!v8)
  {
    v16 = sub_10000EF14("SecWarning");
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      return;
    *(_DWORD *)buf = 138412290;
    v28 = (uint64_t)cf;
    v17 = "Ignoring unknown key class '%@'";
    v18 = v16;
    v19 = 12;
    goto LABEL_26;
  }
  v9 = (const __CFString **)v8;
  if (v8 == &off_1002E3A00)
  {
    sub_100019F20(-50, v3, CFSTR("attempt to import an identity"));
    return;
  }
  context[0] = (uint64_t)v8;
  context[1] = a3;
  if (a2)
  {
    v10 = CFGetTypeID(a2);
    if (v10 == CFArrayGetTypeID())
    {
      v11 = sub_10000EF14("SecWarning");
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        Count = CFArrayGetCount((CFArrayRef)a2);
        v13 = *(_DWORD *)(a3 + 48);
        *(_DWORD *)buf = 134218498;
        v28 = Count;
        v29 = 2112;
        v30 = cf;
        v31 = 1024;
        v32 = v13;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Import %ld items of class %@ (filter %d)", buf, 0x1Cu);
      }
      v14 = *v9;
      v15 = CFArrayGetCount((CFArrayRef)a2);
      sub_1001316DC(v14, v15, *(_DWORD *)(a3 + 48));
      v33.length = CFArrayGetCount((CFArrayRef)a2);
      v33.location = 0;
      CFArrayApplyFunction((CFArrayRef)a2, v33, (CFArrayApplierFunction)sub_100131760, context);
      return;
    }
    v21 = CFGetTypeID(a2);
    v20 = v21 == CFDictionaryGetTypeID();
  }
  else
  {
    v20 = 0;
  }
  v22 = sub_10000EF14("SecWarning");
  v23 = os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
  if (!v20)
  {
    if (!v23)
      return;
    v25 = *(_DWORD *)(a3 + 48);
    *(_DWORD *)buf = 138412546;
    v28 = (uint64_t)cf;
    v29 = 1024;
    LODWORD(v30) = v25;
    v17 = "Unknown value type for class %@ (filter %d)";
    v18 = v22;
    v19 = 18;
LABEL_26:
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v17, buf, v19);
    return;
  }
  if (v23)
  {
    v24 = *(_DWORD *)(a3 + 48);
    *(_DWORD *)buf = 134218498;
    v28 = 1;
    v29 = 2112;
    v30 = cf;
    v31 = 1024;
    v32 = v24;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Import %ld items of class %@ (filter %d)", buf, 0x1Cu);
  }
  sub_1001316DC(*v9, 1, *(_DWORD *)(a3 + 48));
  sub_100131760(a2, context);
}

uint64_t sub_1001316DC(const __CFString *a1, uint64_t a2, unsigned int a3)
{
  uint64_t result;
  char buffer[8];

  result = CFStringGetLength(a1);
  if (result == 4)
  {
    memset(buffer, 170, 5);
    result = CFStringGetCString(a1, buffer, 5, 0x8000100u);
    if ((_DWORD)result)
      return kdebug_trace(726810632, *(unsigned int *)buffer, a2, a3, 0);
  }
  return result;
}

void sub_100131760(CFTypeRef cf, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v7;
  CFTypeID v8;
  CFTypeID TypeID;
  uint64_t v10;
  int v11;
  uint64_t v12;
  _QWORD *v13;
  int v14;
  __CFString **v15;
  const __CFData *Value;
  _QWORD *v18;
  _QWORD *v19;
  const __CFDictionary *v20;
  const void *v21;
  const void *v22;
  const void *v23;
  _BOOL4 v24;
  uint64_t v25;
  NSObject *v26;
  CFDataRef v27;
  const __CFData *v28;
  unsigned int v29;
  uint64_t v30;
  const __CFData *v31;
  NSObject *v32;
  CFTypeRef v33;
  NSObject *v34;
  char v35;
  NSObject *v36;
  uint64_t v37;
  void *v38;
  uint64_t v39;
  const void *v40;
  NSObject *v41;
  const __CFUUID *v42;
  const __CFData *v43;
  NSObject *v44;
  CFTypeRef v45;
  uint64_t v46;
  const __CFString *v47;
  const __CFString *v48;
  CFTypeID v49;
  const void *v50;
  const void *v51;
  CFTypeID v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  const void *v58;
  const void *v59;
  const void *v60;
  const void *v61;
  CFTypeID v62;
  CFTypeID v63;
  CFTypeID v64;
  const void *v65;
  NSObject *v66;
  CFTypeRef v67;
  CFUUIDBytes bytes;
  CFTypeRef cfa;
  _BYTE buf[24];
  void *v71;
  _QWORD *v72;
  __int16 v73;

  v3 = a2[1];
  v5 = *(_QWORD *)(v3 + 8);
  v4 = v3 + 8;
  if (v5)
    return;
  if (!cf)
  {
    sub_100019F20(-50, (__CFString **)v4, CFSTR("value %@ is not a dictionary"), 0);
    return;
  }
  v7 = *(unsigned __int8 *)(*(_QWORD *)(v4 + 32) + 36);
  v8 = CFGetTypeID(cf);
  TypeID = CFDictionaryGetTypeID();
  v10 = a2[1];
  if (v8 != TypeID)
  {
    sub_100019F20(-50, (__CFString **)(v10 + 8), CFSTR("value %@ is not a dictionary"), cf);
    return;
  }
  v11 = *(_DWORD *)(v10 + 16);
  v12 = *(_QWORD *)(v10 + 24);
  v13 = (_QWORD *)*a2;
  v14 = *(_DWORD *)(v10 + 32);
  v15 = (__CFString **)(v10 + 8);
  if (v11 == -1 && v12 == 0)
  {
    v19 = sub_10001E9E8(*a2, (const __CFDictionary *)cf, *(_DWORD *)(v10 + 32), (__CFString **)(v10 + 8));
    if (v19)
      goto LABEL_16;
  }
  else
  {
    Value = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("v_Data"));
    if (!Value)
    {
      sub_100019F20(-26275, v15, CFSTR("No v_Data in backup dictionary %@"), cf);
LABEL_62:
      v19 = 0;
      goto LABEL_63;
    }
    v18 = sub_1001162B4(kCFAllocatorDefault, v13, Value, v11, v12, v15);
    v19 = v18;
    if (v18)
    {
      if (!sub_100115F58((uint64_t)v18, v14, v15))
        goto LABEL_61;
LABEL_16:
      if (sub_1000192F4((uint64_t)v19, 1, (__CFString **)(a2[1] + 8)))
      {
        v20 = (const __CFDictionary *)v19[6];
        if (!v20)
          goto LABEL_50;
        if (*(_DWORD *)(a2[1] + 48) == 2)
        {
          if (sub_10012EA5C(v20, *a2, v7 != 0)
            || v7
            && (v21 = CFDictionaryGetValue((CFDictionaryRef)v19[6], kSecAttrAccessible)) != 0
            && ((v22 = v21, CFEqual(v21, kSecAttrAccessibleWhenUnlockedThisDeviceOnly))
             || CFEqual(v22, kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly)
             || CFEqual(v22, kSecAttrAccessibleWhenUnlockedThisDeviceOnly)
             || CFEqual(v22, kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly))
            || CFDictionaryContainsKey((CFDictionaryRef)v19[6], kSecAttrTokenID))
          {
            CFRelease(v19);
            return;
          }
          v20 = (const __CFDictionary *)v19[6];
          if (!v20)
            goto LABEL_50;
        }
        v23 = CFDictionaryGetValue(v20, kSecAttrMultiUser);
        if (qword_100341178 != -1)
          dispatch_once(&qword_100341178, &stru_1002DECC8);
        if (v23 && qword_100341180)
          v24 = CFEqual(v23, (CFTypeRef)qword_100341180) != 0;
        else
          v24 = v23 == (const void *)qword_100341180;
        v25 = *(_QWORD *)(a2[1] + 40);
        if (v25 && *(_BYTE *)(v25 + 36))
        {
          if (v24)
          {
            v26 = sub_10000EF14("SecWarning");
            if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 138477827;
              *(_QWORD *)&buf[4] = v19;
              _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "system keychain not allowed in multi user mode for item: %{private}@", buf, 0xCu);
            }
            goto LABEL_61;
          }
          v29 = *(_DWORD *)(v25 + 20);
          *(_QWORD *)buf = 0x104B57A5353A5AA7;
          *(_DWORD *)&buf[8] = -1803342146;
          *(_DWORD *)&buf[12] = bswap32(v29);
          v27 = CFDataCreate(0, buf, 16);
        }
        else
        {
          if (!v24)
          {
            if (qword_100341188 != -1)
              dispatch_once(&qword_100341188, &stru_1002DED08);
            v28 = (const __CFData *)qword_100341190;
            if (!qword_100341190)
              goto LABEL_61;
            CFRetain((CFTypeRef)qword_100341190);
            goto LABEL_49;
          }
          v27 = CFDataCreateWithBytesNoCopy(0, byte_10024957C, 16, kCFAllocatorNull);
        }
        v28 = v27;
        if (v27)
        {
LABEL_49:
          sub_10001BA44((uint64_t)v19, CFSTR("musr"), v28, (__CFString **)(a2[1] + 8));
          CFRelease(v28);
LABEL_50:
          v30 = a2[1];
          if (*(_DWORD *)(v30 + 48) != 1)
            sub_10011D600((uint64_t)v19, (CFDictionaryRef)cf, (__CFString **)(v30 + 8));
          cfa = 0;
          v31 = (const __CFData *)sub_1000045A0((_QWORD **)v19, (__CFString **)&cfa);
          if (cfa)
          {
            v32 = sub_10000EF14("SecError");
            if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 138412290;
              *(_QWORD *)&buf[4] = cfa;
              _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "import: failed to get the persistent ref: %@", buf, 0xCu);
            }
            v33 = cfa;
            if (cfa)
            {
              cfa = 0;
              CFRelease(v33);
            }
          }
          if (v31 && CFDataGetLength(v31) == 16)
          {
            v34 = sub_10000EF14("import");
            if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 138477827;
              *(_QWORD *)&buf[4] = v19;
              _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Item already has a UUID persistent ref set: %{private}@", buf, 0xCu);
            }
          }
          else
          {
            v42 = CFUUIDCreate(kCFAllocatorDefault);
            bytes = CFUUIDGetUUIDBytes(v42);
            v43 = CFDataCreate(kCFAllocatorDefault, &bytes.byte0, 16);
            v67 = 0;
            sub_10001D918((uint64_t)v19, v43, (__CFString **)&v67);
            v44 = sub_10000EF14("import");
            if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 138478083;
              *(_QWORD *)&buf[4] = v19;
              *(_WORD *)&buf[12] = 2112;
              *(_QWORD *)&buf[14] = v67;
              _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "SecServerImportItem: generated a new persistentref UUID for item %{private}@: %@", buf, 0x16u);
            }
            if (v42)
              CFRelease(v42);
            if (v43)
              CFRelease(v43);
            v45 = v67;
            if (v67)
            {
              v67 = 0;
              CFRelease(v45);
            }
          }
          v46 = a2[1];
          v47 = (const __CFString *)sub_10000C1D0(v19, kSecAttrSharingGroup);
          if (!v47 || (v48 = v47, v49 = CFGetTypeID(v47), v49 != CFStringGetTypeID()) || !CFStringGetLength(v48))
          {
            v50 = sub_10000C1D0(v19, kSecAttrAccessGroup);
            if (v50)
            {
              v51 = v50;
              v52 = CFGetTypeID(v50);
              if (v52 == CFStringGetTypeID())
              {
                if (CFEqual(v51, CFSTR("com.apple.cfnetwork")))
                {
                  v53 = v19[2];
                  if (v53 == sub_1000119B8((uint64_t)CFSTR("inet"), &qword_100341250, (uint64_t)&unk_100341248))
                  {
                    v58 = sub_10000C1D0(v19, kSecAttrServer);
                    v59 = sub_10000C1D0(v19, kSecAttrProtocol);
                    v60 = sub_10000C1D0(v19, kSecAttrAuthenticationType);
                    if (v58)
                    {
                      v61 = v60;
                      v62 = CFGetTypeID(v58);
                      if (v62 == CFStringGetTypeID())
                      {
                        if (v59)
                        {
                          v63 = CFGetTypeID(v59);
                          if (v63 == CFStringGetTypeID())
                          {
                            if (v61)
                            {
                              v64 = CFGetTypeID(v61);
                              if (v64 == CFStringGetTypeID())
                              {
                                v65 = sub_10000EF14("item");
                                v66 = objc_claimAutoreleasedReturnValue(v65);
                                if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
                                {
                                  *(_DWORD *)buf = 138477827;
                                  *(_QWORD *)&buf[4] = v19;
                                  _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "Make this item syncable: %{private}@", buf, 0xCu);
                                }

                                sub_10011649C((uint64_t)v19, (__CFString **)(v46 + 8));
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          v54 = a2[1];
          v55 = *(_QWORD *)v54;
          *(_QWORD *)buf = _NSConcreteStackBlock;
          *(_QWORD *)&buf[8] = 0x40000000;
          *(_QWORD *)&buf[16] = sub_100117088;
          v71 = &unk_1002DE728;
          v72 = v19;
          v73 = 256;
          if ((sub_10001DADC((uint64_t)v19, v55, (__CFString **)(v54 + 8), (uint64_t)buf) & 1) == 0)
          {
            sub_100116454((uint64_t)v19, 0);
            v56 = a2[1];
            v57 = *(_QWORD *)v56;
            *(_QWORD *)buf = _NSConcreteStackBlock;
            *(_QWORD *)&buf[8] = 0x40000000;
            *(_QWORD *)&buf[16] = sub_100117088;
            v71 = &unk_1002DE728;
            v72 = v19;
            v73 = 256;
            sub_10001DADC((uint64_t)v19, v57, (__CFString **)(v56 + 8), (uint64_t)buf);
          }
          v35 = 0;
          goto LABEL_64;
        }
      }
LABEL_61:
      CFRelease(v19);
      goto LABEL_62;
    }
  }
LABEL_63:
  v35 = 1;
LABEL_64:
  if (*(_QWORD *)(a2[1] + 8))
  {
    v36 = sub_10000EF14("SecWarning");
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
    {
      v37 = *(_QWORD *)*a2;
      v38 = *(void **)(a2[1] + 8);
      *(_DWORD *)buf = 138478339;
      *(_QWORD *)&buf[4] = v19;
      *(_WORD *)&buf[12] = 2112;
      *(_QWORD *)&buf[14] = v37;
      *(_WORD *)&buf[22] = 2112;
      v71 = v38;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "Failed to import an item (%{private}@) of class '%@': %@ - ignoring error.", buf, 0x20u);
    }
    v39 = a2[1];
    v40 = *(const void **)(v39 + 8);
    if (v40)
    {
      *(_QWORD *)(v39 + 8) = 0;
      CFRelease(v40);
    }
  }
  else
  {
    v41 = sub_10000EF14("import");
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138477827;
      *(_QWORD *)&buf[4] = v19;
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "imported item: %{private}@", buf, 0xCu);
    }
  }
  if ((v35 & 1) == 0)
    CFRelease(v19);
}

BOOL sub_1001320A8(const void *a1, int a2)
{
  BOOL v2;
  unint64_t v3;
  uint64_t *v4;
  const void **v5;
  const void **v6;
  BOOL v7;
  CFTypeRef v8;
  char v9;
  CFErrorRef v10;
  NSObject *v11;
  uint64_t v12;
  __int128 v14;
  CFTypeRef cf[2];
  __int128 v16;
  CFErrorRef err;
  uint8_t buf[4];
  uint64_t v19;
  _QWORD v20[4];

  err = 0;
  cf[1] = 0;
  v16 = 0u;
  v14 = 0u;
  cf[0] = a1;
  DWORD2(v16) = a2;
  v20[0] = sub_1000119B8((uint64_t)CFSTR("genp"), &qword_100341240, (uint64_t)&unk_100341238);
  v20[1] = sub_1000119B8((uint64_t)CFSTR("inet"), &qword_100341250, (uint64_t)&unk_100341248);
  v20[2] = sub_1000119B8((uint64_t)CFSTR("keys"), &qword_100341270, (uint64_t)&unk_100341268);
  v2 = 0;
  v3 = 0;
  v20[3] = sub_1000119B8((uint64_t)CFSTR("cert"), &qword_100341260, (uint64_t)&unk_100341258);
  do
  {
    v4 = (uint64_t *)v20[v3];
    v5 = (const void **)sub_1000114E8((uint64_t)v4, 0, 0, 0, (__CFString **)&err);
    if (!v5)
      break;
    v6 = v5;
    *(_QWORD *)&v14 = v5;
    v5[13] = (const void *)-1;
    v7 = sub_100012878((uint64_t)sub_1001322C4, (uint64_t)&v14, (__CFString **)&err);
    sub_100011108(v6, 0);
    v8 = cf[1];
    if (cf[1])
    {
      cf[1] = 0;
      CFRelease(v8);
    }
    if (err)
      v9 = v7;
    else
      v9 = 1;
    if ((v9 & 1) != 0 || CFErrorGetCode(err) != -25300)
    {
      v11 = sub_10000EF14("SecError");
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        v12 = *v4;
        *(_DWORD *)buf = 138412290;
        v19 = v12;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Class %@ not up to date", buf, 0xCu);
      }
      return v2;
    }
    v10 = err;
    if (err)
    {
      err = 0;
      CFRelease(v10);
    }
    v2 = v3++ > 2;
  }
  while (v3 != 4);
  return v2;
}

void sub_1001322C4(sqlite3_stmt *a1, _DWORD *a2)
{
  int v3;
  const __CFData *v4;
  const __CFData *v5;
  unint64_t Length;
  const UInt8 *BytePtr;

  v3 = a2[10];
  v4 = sub_100014E94(a1, 1);
  if (v4)
  {
    v5 = v4;
    Length = CFDataGetLength(v4);
    BytePtr = CFDataGetBytePtr(v5);
    if (Length >= 8)
    {
      if ((v3 == 0) != *((_DWORD *)BytePtr + 1) > 0x1Fu)
      {
LABEL_6:
        CFRelease(v5);
        return;
      }
    }
    else
    {
      sub_100019F20(-26275, (__CFString **)(*(_QWORD *)a2 + 40), CFSTR("check_generation: Check for underflow"));
    }
    ++a2[8];
    goto LABEL_6;
  }
  ++a2[8];
}

void sub_100132378(uint64_t a1, _BYTE *a2)
{
  int v4;
  CFTypeRef *v5;
  _QWORD v6[5];
  __int128 v7;
  int v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  char v12;

  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = 0;
  v8 = -1431655766;
  if (!sub_1000269AC(dword_1003414E0, 0, &v8) && (v8 & 2) != 0)
  {
    v5 = *(CFTypeRef **)(a1 + 32);
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000;
    v6[2] = sub_100132478;
    v6[3] = &unk_1002DFAC0;
    v6[4] = &v9;
    v7 = *(_OWORD *)(a1 + 40);
    v4 = sub_100033998(dword_1003414E0, v5, (uint64_t)v6);
    if (v4)
      LOBYTE(v4) = *((_BYTE *)v10 + 24);
    else
      *((_BYTE *)v10 + 24) = 0;
  }
  else
  {
    LOBYTE(v4) = sub_100019F20(-909, *(__CFString ***)(a1 + 32), CFSTR("No key roll in progress."));
    *((_BYTE *)v10 + 24) = v4;
  }
  *a2 = v4;
  _Block_object_dispose(&v9, 8);
}

void sub_100132478(_QWORD *a1)
{
  __CFDictionary *v2;
  const __CFDictionary *v3;
  NSObject *v4;
  CFTypeRef v5;
  NSObject *v6;
  CFTypeRef v7;
  int v8;
  CFTypeRef cf;
  uint8_t buf[4];
  CFTypeRef v11;

  cf = 0;
  v8 = -1;
  v2 = sub_10012FE48(a1[5], 0, &v8, 0, (__CFString **)&cf);
  if (v2)
  {
    v3 = v2;
    if (cf)
    {
      v4 = sub_10000EF14("SecError");
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v11 = cf;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Ignoring export error: %@ during roll export", buf, 0xCu);
      }
      v5 = cf;
      if (cf)
      {
        cf = 0;
        CFRelease(v5);
      }
    }
    *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = sub_100130CBC(a1[5], a1[6], -1, 0, dword_1003414E0, v3, 0, 1, (__CFString **)&cf);
    if (cf)
    {
      v6 = sub_10000EF14("SecError");
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v11 = cf;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Ignoring export error: %@ during roll export", buf, 0xCu);
      }
      v7 = cf;
      if (cf)
      {
        cf = 0;
        CFRelease(v7);
      }
    }
    CFRelease(v3);
  }
}

const void *sub_100132614(uint64_t a1)
{
  const void *v2;
  __CFString ***v3;
  const void **v4;
  const void *result;
  const void **v6;

  v2 = *(const void **)(a1 + 40);
  v3 = off_1002E4318;
  v4 = (const void **)&off_1002E2190;
  while (1)
  {
    result = *v4;
    if (!v2 || !result)
    {
      if (result == v2)
        goto LABEL_8;
      goto LABEL_7;
    }
    result = (const void *)CFEqual(result, v2);
    if ((_DWORD)result)
      break;
LABEL_7:
    v6 = (const void **)v3[1];
    ++v3;
    v4 = v6;
    if (!v6)
      goto LABEL_8;
  }
  v4 = (const void **)*v3;
LABEL_8:
  **(_QWORD **)(a1 + 32) = v4;
  return result;
}

void sub_1001326E4(id a1)
{
  void *v1;
  uint64_t v2;
  void *v3;
  _QWORD v4[6];

  v4[0] = kSecAttrUUID;
  v4[1] = CFSTR("zone");
  v4[2] = CFSTR("ownr");
  v4[3] = CFSTR("type");
  v4[4] = CFSTR("deln");
  v4[5] = kSecValueData;
  v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v4, 6));
  v2 = objc_claimAutoreleasedReturnValue(+[NSSet setWithArray:](NSSet, "setWithArray:", v1));
  v3 = (void *)qword_1003412A8;
  qword_1003412A8 = v2;

}

void sub_1001328BC(id a1)
{
  const void *v1;
  NSObject *v2;
  const __CFString *v3;
  int v4;
  const __CFString *v5;

  byte_10033FE20 = _os_feature_enabled_impl("Security", "EnableSecureObjectSync");
  v1 = sub_10000EF14("octagon");
  v2 = objc_claimAutoreleasedReturnValue(v1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_10033FE20)
      v3 = CFSTR("enabled");
    else
      v3 = CFSTR("disabled");
    v4 = 138412290;
    v5 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SOS Feature is %@ (via feature flags)", (uint8_t *)&v4, 0xCu);
  }

}

void sub_100132998(id a1)
{
  const void *v1;
  NSObject *v2;
  const char *v3;
  int v4;
  const char *v5;

  byte_1003412C0 = _os_feature_enabled_impl("Security", "OctagonSupportsPersonaMultiuser");
  v1 = sub_10000EF14("octagon");
  v2 = objc_claimAutoreleasedReturnValue(v1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1003412C0)
      v3 = "enabled";
    else
      v3 = "disabled";
    v4 = 136315138;
    v5 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "OctagonSupportsMultiuser is %s", (uint8_t *)&v4, 0xCu);
  }

}

void sub_100132A74(id a1)
{
  const void *v1;
  NSObject *v2;
  const char *v3;
  int v4;
  const char *v5;

  byte_1003412D0 = _os_feature_enabled_impl("CoreCDP", "DeferSOSFromSignIn");
  v1 = sub_10000EF14("octagon");
  v2 = objc_claimAutoreleasedReturnValue(v1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1003412D0)
      v3 = "enabled";
    else
      v3 = "disabled";
    v4 = 136315138;
    v5 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "DeferSOSFromSignIn is %s", (uint8_t *)&v4, 0xCu);
  }

}

void sub_100132B50(id a1)
{
  NSObject *v1;
  const char *v2;
  int v3;
  const char *v4;

  byte_1003412E0 = _os_feature_enabled_impl("Security", "SecSystemKeychainAlwaysSupported");
  v1 = sub_10000EF14("keychain");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1003412E0)
      v2 = "enabled";
    else
      v2 = "disabled";
    v3 = 136315138;
    v4 = v2;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "System Keychain Always Supported set via feature flag to %s", (uint8_t *)&v3, 0xCu);
  }
}

void sub_100133324()
{
  __CFNotificationCenter *DistributedCenter;

  os_unfair_lock_lock((os_unfair_lock_t)&unk_1003412F0);
  DistributedCenter = CFNotificationCenterGetDistributedCenter();
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1003412F0);
  CFNotificationCenterPostNotificationWithOptions(DistributedCenter, CFSTR("com.apple.security.shared-items-changed"), 0, 0, 0);
}

void sub_100133374()
{
  if (qword_1003412F8 != -1)
    dispatch_once(&qword_1003412F8, &stru_1002E7900);
  dispatch_source_merge_data((dispatch_source_t)qword_100341300, 1uLL);
}

void sub_1001333B8(id a1)
{
  NSObject *v1;
  _QWORD *context;

  v1 = sub_1000327DC("SecKeychainChanged", 1);
  qword_100341300 = (uint64_t)v1;
  context = dispatch_get_context(v1);
  context[2] = _Block_copy(&stru_1002E7940);
  dispatch_activate(v1);
}

void sub_100133408(id a1)
{
  uint32_t v1;
  uint32_t v2;
  NSObject *v3;
  const char *v4;
  NSObject *v5;
  uint32_t v6;
  NSObject *v7;
  int v8;
  const char *v9;
  __int16 v10;
  uint32_t v11;

  v1 = notify_post("com.apple.security.keychainchanged");
  if (v1)
  {
    v2 = v1;
    v3 = sub_10000EF14("SecError");
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      return;
    v8 = 136315394;
    v9 = "com.apple.security.keychainchanged";
    v10 = 1024;
    v11 = v2;
    v4 = "notify_post %s returned: %u";
    v5 = v3;
    v6 = 18;
  }
  else
  {
    v7 = sub_10000EF14("item");
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      return;
    v8 = 136315138;
    v9 = "com.apple.security.keychainchanged";
    v4 = "Sent %s";
    v5 = v7;
    v6 = 12;
  }
  _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v4, (uint8_t *)&v8, v6);
}

uint64_t sub_100133520(uint64_t a1, int *a2, CFTypeRef *a3)
{
  char v6;
  char v7;
  int v8;
  int v9;
  NSObject *v10;
  CFTypeRef v11;
  NSObject *v12;
  int v13;
  int v14;
  CFTypeRef v15;
  NSObject *v16;
  uid_t v17;
  uid_t v18;
  CFTypeRef v19;
  uint64_t v20;
  _QWORD v22[8];
  _QWORD v23[7];
  _QWORD v24[7];
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  char v28;
  uint64_t v29;
  CFTypeRef *v30;
  uint64_t v31;
  CFTypeRef v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  char v36;
  uint8_t buf[4];
  _BYTE v38[10];
  __int16 v39;
  CFTypeRef v40;

  v33 = 0;
  v34 = &v33;
  v35 = 0x2000000000;
  v36 = 1;
  v29 = 0;
  v30 = (CFTypeRef *)&v29;
  v31 = 0x2000000000;
  v32 = 0;
  v25 = 0;
  v26 = &v25;
  v27 = 0x2000000000;
  v28 = 0;
  v24[0] = _NSConcreteStackBlock;
  v24[1] = 0x40000000;
  v24[2] = sub_1001338A4;
  v24[3] = &unk_1002E7990;
  v24[5] = &v25;
  v24[6] = a1;
  v24[4] = &v33;
  v6 = sub_10001E3C4(a1, (uint64_t)CFSTR("SELECT name FROM sqlite_master WHERE type='table' AND name='tversion'"), &v32, (uint64_t)v24);
  if (*((_BYTE *)v34 + 24))
    v7 = v6;
  else
    v7 = 0;
  *((_BYTE *)v34 + 24) = v7;
  if ((v7 & 1) != 0)
  {
    if (*((_BYTE *)v26 + 24))
    {
      v23[0] = _NSConcreteStackBlock;
      v23[1] = 0x40000000;
      v23[2] = sub_100133918;
      v23[3] = &unk_1002E79D8;
      v23[4] = &v33;
      v23[5] = a1;
      v23[6] = a2;
      v8 = sub_10001E3C4(a1, (uint64_t)CFSTR("SELECT version FROM tversion"), v30 + 3, (uint64_t)v23);
      if (*((_BYTE *)v34 + 24))
        v9 = v8;
      else
        v9 = 0;
      *((_BYTE *)v34 + 24) = v9;
      if (v9 == 1 && *(unsigned __int16 *)a2 >= 9u)
      {
        v22[0] = _NSConcreteStackBlock;
        v22[1] = 0x40000000;
        v22[2] = sub_10013398C;
        v22[3] = &unk_1002E7A20;
        v22[4] = &v33;
        v22[5] = &v29;
        v22[6] = a2;
        v22[7] = a1;
        sub_10001E3C4(a1, (uint64_t)CFSTR("SELECT minor FROM tversion WHERE version = ?"), v30 + 3, (uint64_t)v22);
        *((_BYTE *)v34 + 24) = 1;
      }
    }
    else
    {
      v10 = sub_10000EF14("upgr");
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        v11 = v30[3];
        *(_DWORD *)buf = 138412290;
        *(_QWORD *)v38 = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "no tversion table, will setup a new database: %@", buf, 0xCu);
      }
      *a2 = 0;
    }
  }
  else
  {
    sub_10003060C(11, a3, CFSTR("Failed to read sqlite_master table: %@"), v30[3]);
  }
  v12 = sub_10000EF14("upgr");
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    v13 = *a2;
    v14 = *((unsigned __int8 *)v34 + 24);
    v15 = v30[3];
    *(_DWORD *)buf = 67109634;
    *(_DWORD *)v38 = v13;
    *(_WORD *)&v38[4] = 1024;
    *(_DWORD *)&v38[6] = v14;
    v39 = 2112;
    v40 = v15;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "database version is: 0x%08x : %d : %@", buf, 0x18u);
  }
  v16 = sub_10000EF14("upgr");
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    v17 = getuid();
    v18 = geteuid();
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)v38 = v17;
    *(_WORD *)&v38[4] = 1024;
    *(_DWORD *)&v38[6] = v18;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "UID: %d  EUID: %d", buf, 0xEu);
  }
  v19 = v30[3];
  if (v19)
    CFRelease(v19);
  v20 = *((unsigned __int8 *)v34 + 24);
  _Block_object_dispose(&v25, 8);
  _Block_object_dispose(&v29, 8);
  _Block_object_dispose(&v33, 8);
  return v20;
}

uint64_t sub_1001338A4(_QWORD *a1, sqlite3_stmt *a2)
{
  uint64_t v3;
  uint64_t result;
  _QWORD v5[5];

  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_100133AD4;
  v5[3] = &unk_1002E7968;
  v3 = a1[6];
  v5[4] = a1[5];
  result = sub_100019C40(v3, a2, 0, (uint64_t)v5);
  *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = result;
  return result;
}

uint64_t sub_100133918(_QWORD *a1, sqlite3_stmt *a2)
{
  uint64_t v3;
  uint64_t result;
  _QWORD v5[6];

  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_100133A94;
  v5[3] = &unk_1002E79B0;
  v3 = a1[5];
  v5[4] = a1[6];
  v5[5] = a2;
  result = sub_100019C40(v3, a2, 0, (uint64_t)v5);
  *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = result;
  return result;
}

uint64_t sub_10013398C(uint64_t a1, sqlite3_stmt *a2)
{
  CFTypeRef *v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  _QWORD v9[6];

  v4 = (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  v5 = sqlite3_bind_int(a2, 1, **(_DWORD **)(a1 + 48));
  result = sub_100013978(v5, a2, v4, CFSTR("bind_int[%d]"), 1);
  if ((_DWORD)result)
  {
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000;
    v9[2] = sub_100133A48;
    v9[3] = &unk_1002E79F8;
    v8 = *(_QWORD *)(a1 + 48);
    v7 = *(_QWORD *)(a1 + 56);
    v9[4] = a2;
    v9[5] = v8;
    result = sub_100019C40(v7, a2, 0, (uint64_t)v9);
  }
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

sqlite3_int64 sub_100133A48(uint64_t a1, _BYTE *a2)
{
  sqlite3_int64 result;

  result = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 32), 0);
  **(_DWORD **)(a1 + 40) |= ((_DWORD)result << 8) & 0xFF00FF00;
  *a2 = 1;
  return result;
}

uint64_t sub_100133A94(uint64_t a1, _BYTE *a2)
{
  uint64_t result;

  result = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 40), 0);
  **(_DWORD **)(a1 + 32) = result;
  if ((_DWORD)result)
    *a2 = 1;
  return result;
}

uint64_t sub_100133AD4(uint64_t result, _BYTE *a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = 1;
  *a2 = 1;
  return result;
}

uint64_t sub_100133AEC(uint64_t a1)
{
  int64_t v2;
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  timeval v7;

  v7.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v7.tv_usec = 0xAAAAAAAAAAAAAAAALL;
  gettimeofday(&v7, 0);
  v2 = 1000 * (v7.tv_sec - *(_QWORD *)a1) + *(_DWORD *)(a1 + 8) / -1000 + v7.tv_usec / 1000;
  v3 = 1;
  if (v2 >= 101)
  {
    v4 = 1000 * (v7.tv_sec - *(_QWORD *)a1) + *(_DWORD *)(a1 + 8) / -1000 + v7.tv_usec / 1000;
    do
    {
      v2 = v4 / 0xA;
      v3 *= 10;
      v5 = v4 > 0x3F1;
      v4 /= 0xAuLL;
    }
    while (v5);
  }
  return v3 * v2;
}

uint64_t sub_100133BB0(_QWORD *a1, sqlite3_stmt *a2)
{
  uint64_t v2;
  CFTypeRef *v3;
  uint64_t v4;
  _QWORD v6[7];

  v2 = a1[5];
  v3 = (CFTypeRef *)(*(_QWORD *)(a1[4] + 8) + 24);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = sub_1001345BC;
  v6[3] = &unk_1002E7A48;
  v6[4] = v2;
  v6[5] = a2;
  v4 = a1[6];
  v6[6] = a1[7];
  return sub_100019C40(v4, a2, v3, (uint64_t)v6);
}

void sub_100133C18(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  CFDictionaryRef *v5;
  __CFString *v6;
  uint64_t v7;
  __CFString *v8;
  _QWORD v9[6];
  __int128 v10;
  uint64_t v11;
  CFDictionaryRef *v12;
  _QWORD v13[5];
  __CFString *v14;

  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    v14 = 0;
    v4 = **(_QWORD **)(a1 + 40);
    if (qword_100341198 != -1)
      dispatch_once(&qword_100341198, &stru_1002DED48);
    v5 = (CFDictionaryRef *)sub_1000114E8(v4, (const void *)qword_1003411A0, 0, 0, &v14);
    v6 = v14;
    if (v14)
    {
      v14 = 0;
      CFRelease(v6);
    }
    v7 = *(_QWORD *)(a1 + 48);
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000;
    v13[2] = sub_100133D7C;
    v13[3] = &unk_1002E7B10;
    v13[4] = a2;
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000;
    v9[2] = sub_100133D90;
    v9[3] = &unk_1002E7B38;
    v9[4] = *(_QWORD *)(a1 + 32);
    v9[5] = a2;
    v10 = *(_OWORD *)(a1 + 56);
    v11 = v7;
    v12 = v5;
    sub_10001E280(v5, v7, (CFTypeRef *)&v14, &stru_1002E7AB0, &stru_1002E7AF0, 0, (uint64_t)v13, (uint64_t)v9);
    if (v5)
      sub_100011108((const void **)v5, 0);
    v8 = v14;
    if (v14)
    {
      v14 = 0;
      CFRelease(v8);
    }
  }
}

uint64_t sub_100133D68(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_100133D7C(uint64_t a1, sqlite3_stmt *a2)
{
  return sub_100013544(a2, 1, *(const __CFString **)(a1 + 32), 0);
}

void sub_100133D90(uint64_t a1, _QWORD **a2)
{
  uint64_t v4;
  uint64_t v5;
  const __CFData *v6;
  NSObject *v7;
  CFTypeRef v8;
  CFTypeRef v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  const __CFString *v13;
  NSObject *v14;
  CFTypeRef v15;
  CFTypeRef v16;
  NSObject *v17;
  const __CFData *v18;
  char v19;
  char v20;
  int v21;
  CFTypeRef v22;
  NSObject *v23;
  _BOOL4 v24;
  NSObject *v25;
  CFTypeRef v26;
  NSObject *v27;
  CFTypeRef v28;
  CFTypeRef v29;
  CFTypeRef v30;
  CFTypeRef cf;
  uint8_t buf[4];
  uint64_t v33;
  __int16 v34;
  _BYTE v35[18];

  v30 = 0;
  cf = 0;
  v4 = qword_100341308;
  qword_100341308 = 0;
  v5 = *(_QWORD *)(a1 + 40);
  if (v5)
    CFRetain(*(CFTypeRef *)(a1 + 40));
  qword_100341308 = v5;
  v6 = (const __CFData *)sub_1000045A0(a2, (__CFString **)&cf);
  if (cf)
  {
    v7 = sub_10000EF14("SecError");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v33 = (uint64_t)cf;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "upgr-phase3: failed to get persistent ref error: %@", buf, 0xCu);
    }
    if (sub_100134320((__CFError *)cf, *(__CFError ***)(a1 + 48)))
    {
LABEL_7:
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
      **(_BYTE **)(a1 + 56) = 1;
      if (qword_100341308)
        CFRelease((CFTypeRef)qword_100341308);
      qword_100341308 = v4;
      v8 = cf;
      if (cf)
      {
        cf = 0;
LABEL_65:
        CFRelease(v8);
        return;
      }
      return;
    }
    v9 = cf;
    if (cf)
    {
      cf = 0;
      CFRelease(v9);
    }
  }
  v10 = sub_1001163AC(a2, (__CFString **)&v30);
  if (v30)
  {
    v11 = sub_10000EF14("SecError");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v33 = (uint64_t)v30;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "upgr-phase3: failed to get rowID error: %@", buf, 0xCu);
    }
  }
  v12 = *a2[2];
  v13 = CFSTR("YES");
  if (v6 && CFDataGetLength(v6) == 16)
    v13 = CFSTR("NO");
  v14 = sub_10000EF14("upgr-phase3");
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134218498;
    v33 = v10;
    v34 = 2112;
    *(_QWORD *)v35 = v12;
    *(_WORD *)&v35[8] = 2112;
    *(_QWORD *)&v35[10] = v13;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "inspecting item at row %lld in table %@, should add persistref uuid?: %@", buf, 0x20u);
  }
  v15 = v30;
  if (v30)
  {
    v30 = 0;
    CFRelease(v15);
  }
  v16 = cf;
  if (cf)
  {
    cf = 0;
    CFRelease(v16);
  }
  if (CFStringCompare(v13, CFSTR("YES"), 0))
    return;
  v17 = sub_10000EF14("upgr-phase3");
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    v33 = v10;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "upgrading item persistentref at row id %lld", buf, 0xCu);
  }
  v18 = sub_10001CDC8();
  v19 = sub_10001BA44((uint64_t)a2, kSecAttrPersistentReference, v18, (__CFString **)&cf);
  if (v18)
    CFRelease(v18);
  if (cf)
    v20 = 0;
  else
    v20 = v19;
  if ((v20 & 1) == 0)
  {
    v25 = sub_10000EF14("SecError");
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138478083;
      v33 = (uint64_t)a2;
      v34 = 2112;
      *(_QWORD *)v35 = cf;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "upgr-phase3: failed to set persistentref for item:%{private}@, error:%@", buf, 0x16u);
    }
    if (cf)
    {
      if (sub_100134320((__CFError *)cf, *(__CFError ***)(a1 + 48)))
        goto LABEL_7;
      v26 = cf;
      if (cf)
      {
        cf = 0;
        goto LABEL_60;
      }
    }
    else if ((v19 & 1) == 0)
    {
      v27 = sub_10000EF14("SecError");
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "upgr-phase3: SecDbItemSetValueWithName returned false", buf, 2u);
      }
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
      **(_BYTE **)(a1 + 56) = 1;
      if (qword_100341308)
        CFRelease((CFTypeRef)qword_100341308);
      qword_100341308 = v4;
      return;
    }
LABEL_63:
    if (!v4)
      return;
    v8 = (CFTypeRef)v4;
    goto LABEL_65;
  }
  v29 = 0;
  v21 = sub_10000517C(a2, a2, *(_QWORD *)(a1 + 64), 0, *(unsigned __int8 *)(*(_QWORD *)(a1 + 72) + 154), (__CFString **)&v29);
  v22 = v29;
  v23 = sub_10000EF14("upgr-phase3");
  v24 = os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT);
  if (v21 && !v22)
  {
    if (v24)
    {
      *(_DWORD *)buf = 138478083;
      v33 = (uint64_t)a2;
      v34 = 1024;
      *(_DWORD *)v35 = 1;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "updated item %{private}@: %d", buf, 0x12u);
    }
    goto LABEL_61;
  }
  if (v24)
  {
    *(_DWORD *)buf = 138478339;
    v33 = (uint64_t)a2;
    v34 = 1024;
    *(_DWORD *)v35 = v21;
    *(_WORD *)&v35[4] = 2112;
    *(_QWORD *)&v35[6] = v29;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "phase3: failed to update item %{private}@: %d, error: %@", buf, 0x1Cu);
  }
  if (!v29)
    goto LABEL_61;
  if (!sub_100134320((__CFError *)v29, *(__CFError ***)(a1 + 48)))
  {
    v26 = v29;
    if (!v29)
      goto LABEL_61;
    v29 = 0;
LABEL_60:
    CFRelease(v26);
LABEL_61:
    v28 = cf;
    if (cf)
    {
      cf = 0;
      CFRelease(v28);
    }
    goto LABEL_63;
  }
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  **(_BYTE **)(a1 + 56) = 1;
  if (qword_100341308)
    CFRelease((CFTypeRef)qword_100341308);
  qword_100341308 = v4;
  v8 = v29;
  if (v29)
  {
    v29 = 0;
    goto LABEL_65;
  }
}

BOOL sub_100134304(id a1, const SecDbAttr *a2)
{
  return a2->var1 == 8;
}

BOOL sub_100134314(id a1, const SecDbAttr *a2)
{
  return (LOBYTE(a2->var2) >> 1) & 1;
}

uint64_t sub_100134320(__CFError *a1, __CFError **a2)
{
  CFIndex Code;
  NSObject *v5;
  _BOOL4 v6;
  uint64_t result;
  const char *v8;
  NSObject *v9;
  uint32_t v10;
  NSObject *v11;
  _BOOL4 v12;
  NSObject *v13;
  const char *v14;
  _BOOL4 v15;
  int v16;
  __CFError *v17;

  Code = CFErrorGetCode(a1);
  if (Code > -25331)
  {
    switch(Code)
    {
      case -25330:
        v11 = sub_10000EF14("upgr-phase3");
        v15 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
        result = 0;
        if (!v15)
          return result;
        v16 = 138412290;
        v17 = a1;
        v8 = "authentication needed: %@";
        break;
      case -25308:
        v13 = sub_10000EF14("upgr-phase3");
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          v16 = 138412290;
          v17 = a1;
          v14 = "interaction not allowed: %@";
          goto LABEL_20;
        }
LABEL_21:
        if (a1)
        {
          CFRetain(a1);
          if (a2 && !*a2)
            *a2 = a1;
          else
            CFRelease(a1);
        }
        return 1;
      case -25291:
        v11 = sub_10000EF14("upgr-phase3");
        v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
        result = 0;
        if (!v12)
          return result;
        v16 = 138412290;
        v17 = a1;
        v8 = "AKS is unavailable: %@";
        break;
      default:
        goto LABEL_25;
    }
    v9 = v11;
    v10 = 12;
    goto LABEL_17;
  }
  if (Code == -536870186 || Code == -536870184)
  {
    v13 = sub_10000EF14("upgr-phase3");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      v16 = 138412290;
      v17 = a1;
      v14 = "AKS is not ready/timing out: %@";
LABEL_20:
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v14, (uint8_t *)&v16, 0xCu);
      goto LABEL_21;
    }
    goto LABEL_21;
  }
  if (Code != -26275)
  {
LABEL_25:
    if (!a1)
      return 0;
    CFRetain(a1);
    if (!a2 || *a2)
    {
      CFRelease(a1);
      return 0;
    }
    result = 0;
    *a2 = a1;
    return result;
  }
  v5 = sub_10000EF14("upgr-phase3");
  v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  result = 0;
  if (v6)
  {
    LOWORD(v16) = 0;
    v8 = "failed to decode keychain item";
    v9 = v5;
    v10 = 2;
LABEL_17:
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v16, v10);
    return 0;
  }
  return result;
}

void sub_1001345BC(uint64_t a1, _BYTE *a2)
{
  sqlite3_int64 v4;
  NSObject *v5;
  const __CFNumber *v6;
  const __CFNumber *v7;
  sqlite3_int64 valuePtr;
  uint8_t buf[4];
  sqlite3_int64 v10;

  v4 = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  valuePtr = v4;
  v5 = sub_10000EF14("upgr-phase3");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "picked up rowid: %lld that needs a persistref", buf, 0xCu);
  }
  v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  v7 = v6;
  if (qword_100341308 && CFNumberCompare(v6, (CFNumberRef)qword_100341308, 0) != kCFCompareGreaterThan)
  {
LABEL_7:
    if (!v7)
      return;
    goto LABEL_8;
  }
  if (CFArrayGetCount(*(CFArrayRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24)) <= 99)
  {
    CFArrayAppendValue(*(CFMutableArrayRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), v7);
    goto LABEL_7;
  }
  *a2 = 1;
  **(_BYTE **)(a1 + 48) = 1;
  if (!v7)
    return;
LABEL_8:
  CFRelease(v7);
}

uint64_t sub_100134708(uint64_t a1, uint8_t *a2, uint64_t a3, int a4, _BYTE *a5, CFTypeRef *a6)
{
  int v11;
  NSObject *v12;
  int v13;
  char v14;
  NSObject *v15;
  _BOOL4 v16;
  int v17;
  uint64_t v18;
  NSObject *v19;
  _BOOL4 v20;
  _BOOL4 v21;
  NSObject *v22;
  NSObject *v23;
  __CFString *v24;
  __CFError *v25;
  CFErrorDomain Domain;
  CFIndex Code;
  uint64_t v28;
  NSObject *v29;
  __CFString *v30;
  const void *v31;
  NSObject *v32;
  const char *v33;
  NSObject *v34;
  uint32_t v35;
  __CFString ***v36;
  __CFString **v37;
  __CFString *v38;
  __CFString **v39;
  __CFString **v40;
  const __CFString *v41;
  char v42;
  NSObject *v43;
  __CFString *v44;
  void *isa;
  CFTypeRef v46;
  __CFString *v47;
  __CFString **v48;
  uint64_t v49;
  NSObject *v50;
  CFTypeRef v51;
  NSObject *v52;
  __CFString *v53;
  NSObject *v54;
  __CFString *v55;
  NSObject *v56;
  __CFString *v57;
  uint64_t *v58;
  const void *v59;
  int v60;
  uint64_t v61;
  CFTypeRef v62;
  NSObject *v63;
  NSObject *v64;
  NSObject *v65;
  const char *v66;
  CFTypeRef v67;
  const void *v68;
  NSObject *v69;
  NSObject *v70;
  NSObject *global_queue;
  int v73;
  int v75;
  uint64_t v76;
  CFTypeRef *v77;
  _BYTE *v78;
  unsigned int v79;
  CFTypeRef cf;
  uint64_t v81;
  uint64_t *v82;
  uint64_t v83;
  CFTypeRef v84;
  void *values;
  void **p_values;
  uint64_t v87;
  char v88;
  CFTypeRef block;
  uint64_t p_block;
  uint64_t v91;
  void *v92;
  uint8_t *v93;
  CFTypeRef *v94;
  uint64_t v95;
  uint8_t v96[4];
  __CFString *v97;
  __int16 v98;
  void *v99;
  __int16 v100;
  CFTypeRef v101;
  uint8_t buf[32];
  __int128 v103;
  __int128 v104;
  int *v105;
  _BYTE *v106;
  int v107;
  int v108;

  v79 = 0;
  v11 = 0;
  if (sub_100033B04())
  {
    if (qword_100340E20 != -1)
      dispatch_once(&qword_100340E20, &stru_1002DB938);
    if (byte_100340E18)
    {
      v11 = 0;
    }
    else
    {
      if (qword_100340E10 != -1)
        dispatch_once(&qword_100340E10, &stru_1002DB8F8);
      v11 = byte_100340E0C;
    }
  }
  v73 = a4;
  if ((a4 & 1) != 0)
  {
    if (v11)
    {
      v12 = sub_10000EF14("upgr");
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "created new db, setting edu bag version", buf, 2u);
      }
      sub_10013545C(a3);
    }
    goto LABEL_18;
  }
  v13 = sub_100133520(a3, (int *)&v79, a6);
  if ((v13 & v11) == 1)
  {
    v14 = sub_1001353A8(a3);
    v15 = sub_10000EF14("upgr");
    v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
    if ((v14 & 1) == 0)
    {
      if (v16)
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "must transcrypt", buf, 2u);
      }
      block = 0;
      *(_DWORD *)buf = -1431655766;
      v49 = sub_100025F30(-6, buf);
      if (sub_10003252C(v49, &block, CFSTR("aks_get_lock_state failed: %x"), v49))
      {
        if ((buf[0] & 1) == 0)
        {
          v63 = sub_10000EF14("upgr");
          if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "using default keybag", buf, 2u);
          }
          dword_1003414E0 = 0;
          v17 = 1;
          goto LABEL_20;
        }
      }
      else
      {
        v50 = sub_10000EF14("upgr");
        if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          *(_QWORD *)&buf[4] = block;
          _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "error querying system keybag lock state: %@", buf, 0xCu);
        }
        v51 = block;
        if (block)
        {
          block = 0;
          CFRelease(v51);
        }
      }
      v64 = sub_10000EF14("SecError");
      if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "Cannot transcrypt because system keybag not (yet) unlocked!! 🫸", buf, 2u);
      }
      sub_100019F20(-25291, (__CFString **)a6, CFSTR("transcryption error: system keybag not (yet) unlocked"));
      v17 = 0;
LABEL_111:
      v65 = sub_10000EF14("SecError");
      if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
      {
        v66 = "";
        if (v73)
          v66 = "from v0 ";
        if (a6)
          v67 = *a6;
        else
          v67 = 0;
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = v66;
        *(_WORD *)&buf[12] = 2112;
        *(_QWORD *)&buf[14] = v67;
        _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "Upgrade %sfailed: %@", buf, 0x16u);
      }
      v61 = 0;
      if (!a6)
        goto LABEL_103;
      goto LABEL_119;
    }
    if (v16)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "already transcrypted", buf, 2u);
LABEL_18:
      v17 = 0;
      goto LABEL_20;
    }
  }
  v17 = 0;
  if (!v13)
    goto LABEL_111;
LABEL_20:
  v18 = v79;
  block = 0;
  p_block = (uint64_t)&block;
  v91 = 0x2000000000;
  LOBYTE(v92) = 0;
  values = 0;
  p_values = &values;
  v87 = 0x2000000000;
  v88 = 1;
  v81 = 0;
  v82 = &v81;
  v83 = 0x2000000000;
  v84 = 0;
  if (a6)
    *a6 = 0;
  if ((_DWORD)v18 != 2060)
  {
    if (v18 == 12 && ((unsigned __int16)v18 & 0xFF00u) >= 0x801)
    {
      v19 = sub_10000EF14("upgr");
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "skipping upgrade since minor is newer", buf, 2u);
      }
    }
    else
    {
      *(_QWORD *)buf = _NSConcreteStackBlock;
      *(_QWORD *)&buf[16] = sub_1001355D0;
      *(_QWORD *)&buf[24] = &unk_1002E83F8;
      *(_QWORD *)&v103 = &values;
      *((_QWORD *)&v103 + 1) = &v81;
      v107 = v18;
      v108 = 2060;
      *(_QWORD *)&buf[8] = 0x40000000;
      v105 = dword_1002E4310;
      v106 = a5;
      *(_QWORD *)&v104 = &block;
      *((_QWORD *)&v104 + 1) = a3;
      v20 = sub_10001AC94(a3, 2, &v84, (uint64_t)buf);
      if (*((_BYTE *)p_values + 24))
        v21 = v20;
      else
        v21 = 0;
      *((_BYTE *)p_values + 24) = v21;
      if (v21 && *(_BYTE *)(p_block + 24))
        SecCoreAnalyticsSendValue(CFSTR("com.apple.keychain.migration-success"), 1);
    }
  }
  v77 = a6;
  v78 = a5;
  v76 = a1;
  v75 = v17;
  if (!*((_BYTE *)p_values + 24))
  {
LABEL_38:
    v23 = sub_10000EF14("SecError");
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      v24 = (__CFString *)v82[3];
      *(_DWORD *)v96 = 138412290;
      v97 = v24;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "upgrade: error occurred, considering marking database as corrupt: %@", v96, 0xCu);
    }
    v25 = (__CFError *)v82[3];
    if (v25)
    {
      Domain = CFErrorGetDomain(v25);
      Code = CFErrorGetCode((CFErrorRef)v82[3]);
      if (Domain && CFEqual(Domain, CFSTR("com.apple.utilities.sqlite3")))
      {
        if ((unint64_t)Code - 5 < 2
          || Code == -536870184
          || Code == 13
          || Code == -25291)
        {
          goto LABEL_52;
        }
        v28 = -536870186;
      }
      else
      {
        if (Code == -536870186 || Code == -536870184)
          goto LABEL_52;
        v28 = -25291;
      }
      if (Code == v28)
      {
LABEL_52:
        v29 = sub_10000EF14("SecError");
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
        {
          v30 = (__CFString *)v82[3];
          *(_DWORD *)v96 = 138412290;
          v97 = v30;
          _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "upgrade: not marking keychain database corrupt for error: %@", v96, 0xCu);
        }
        v31 = (const void *)v82[3];
        if (v31)
        {
          v82[3] = 0;
          CFRelease(v31);
        }
        goto LABEL_97;
      }
      v52 = sub_10000EF14("SecError");
      if (!os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
        goto LABEL_86;
      v53 = (__CFString *)v82[3];
      *(_DWORD *)v96 = 138412290;
      v97 = v53;
      v33 = "upgrade: unable to complete upgrade, marking DB as corrupt: %@";
      v34 = v52;
      v35 = 12;
    }
    else
    {
      v32 = sub_10000EF14("SecError");
      if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
LABEL_86:
        v54 = sub_10000EF14("SecError");
        if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v96 = 0;
          _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "upgrade: marking database as corrupt", v96, 2u);
        }
        v55 = (__CFString *)v82[3];
        if (dword_10033F080 == -1)
        {
          v56 = sub_10000EF14("SecEmergency");
          if (os_log_type_enabled(v56, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)v96 = 138412290;
            v97 = v55;
            _os_log_fault_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_FAULT, "SecDBCorrupt: %@", v96, 0xCu);
          }
        }
        *(_BYTE *)(a3 + 40) = 1;
        v57 = *(__CFString **)(a3 + 56);
        if (v57 != v55)
        {
          if (!v55 || (CFRetain(v55), (v57 = *(__CFString **)(a3 + 56)) != 0))
            CFRelease(v57);
          *(_QWORD *)(a3 + 56) = v55;
        }
        SecCoreAnalyticsSendValue(CFSTR("com.apple.keychain.migration-failure"), 1);
        goto LABEL_97;
      }
      *(_WORD *)v96 = 0;
      v33 = "upgrade: unable to complete upgrade and no error object returned, marking DB as corrupt";
      v34 = v32;
      v35 = 2;
    }
    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, v33, v96, v35);
    goto LABEL_86;
  }
  if (v82[3])
  {
    v22 = sub_10000EF14("SecWarning");
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v96 = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "upgrade: error has been set but status is true", v96, 2u);
    }
    *((_BYTE *)p_values + 24) = 0;
    goto LABEL_38;
  }
  if (*(_BYTE *)(p_block + 24))
    LKAReportKeychainUpgradeOutcomeWithError(v18, 2060, 0, 0);
  if ((_DWORD)v18 == 2060 || *(_BYTE *)(p_block + 24))
  {
    sub_100136A80(a3);
    v36 = off_1002E4318;
    v37 = &off_1002E2190;
    do
    {
      v38 = v37[2];
      if (v38)
      {
        v39 = v37 + 3;
        do
        {
          if ((~LODWORD(v38->data) & 6) == 0)
          {
            cf = 0;
            v40 = *v36;
            v41 = CFStringCreateWithFormat(0, 0, CFSTR("CREATE INDEX IF NOT EXISTS %@%@ ON %@(%@);"),
                    **v36,
                    v38->isa,
                    **v36,
                    v38->isa);
            v42 = sub_10001B41C(a3, v41, &cf);
            if (v41)
              CFRelease(v41);
            if ((v42 & 1) == 0)
            {
              v43 = sub_10000EF14("SecError");
              if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
              {
                v44 = *v40;
                isa = v38->isa;
                *(_DWORD *)v96 = 138412802;
                v97 = v44;
                v98 = 2112;
                v99 = isa;
                v100 = 2112;
                v101 = cf;
                _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "upgrade: unable to opportunistically create index (%@,%@): %@", v96, 0x20u);
              }
            }
            v46 = cf;
            if (cf)
            {
              cf = 0;
              CFRelease(v46);
            }
          }
          v47 = *v39++;
          v38 = v47;
        }
        while (v47);
      }
      v48 = v36[1];
      ++v36;
      v37 = v48;
    }
    while (v48);
  }
LABEL_97:
  v58 = v82;
  v59 = (const void *)v82[3];
  a6 = v77;
  a5 = v78;
  a1 = v76;
  v17 = v75;
  if (v59)
  {
    if (!v77 || (*v77 = CFRetain(v59), v58 = v82, (v59 = (const void *)v82[3]) != 0))
    {
      v58[3] = 0;
      CFRelease(v59);
    }
  }
  v60 = *((unsigned __int8 *)p_values + 24);
  _Block_object_dispose(&v81, 8);
  _Block_object_dispose(&values, 8);
  _Block_object_dispose(&block, 8);
  if (!v60)
    goto LABEL_111;
  v61 = 1;
  if (!v77)
  {
LABEL_103:
    v62 = 0;
    goto LABEL_120;
  }
LABEL_119:
  v62 = *a6;
LABEL_120:
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v62;
  if (v17)
  {
    values = CFSTR("*");
    v103 = 0u;
    v104 = 0u;
    memset(buf, 0, sizeof(buf));
    *(_QWORD *)&buf[8] = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
    *(_WORD *)&buf[16] = 1;
    buf[18] = 0;
    block = _NSConcreteStackBlock;
    p_block = 0x40000000;
    v91 = (uint64_t)sub_100136F08;
    v92 = &unk_1002E8768;
    v93 = buf;
    v94 = a6;
    v95 = a3;
    sub_10001AC0C(a3, 2, a6, (uint64_t)&block);
    v68 = *(const void **)&buf[8];
    if (*(_QWORD *)&buf[8])
    {
      *(_QWORD *)&buf[8] = 0;
      CFRelease(v68);
    }
    v69 = sub_10000EF14("upgr");
    if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(block) = 0;
      _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "transcrypted, setting flag to remember we've already done so", (uint8_t *)&block, 2u);
    }
    sub_10013545C(a3);
    v70 = sub_10000EF14("upgr");
    if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(block) = 0;
      _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "transcrypted, using system keychain handle", (uint8_t *)&block, 2u);
    }
    dword_1003414E0 = -6;
  }
  if ((_DWORD)v61 && (!a5 || !*a5))
  {
    global_queue = dispatch_get_global_queue(0, 0);
    *(_QWORD *)buf = _NSConcreteStackBlock;
    *(_QWORD *)&buf[8] = 0x40000000;
    *(_QWORD *)&buf[16] = sub_1001370F8;
    *(_QWORD *)&buf[24] = &unk_1002E7C38;
    *(_QWORD *)&v103 = a2;
    dispatch_async(global_queue, buf);
    if (byte_1003410A8 == 1)
      dispatch_async(global_queue, &stru_1002E7C78);
    block = _NSConcreteStackBlock;
    p_block = 0x40000000;
    v91 = (uint64_t)sub_1001371E4;
    v92 = &unk_1002E7C98;
    v93 = a2;
    dispatch_async(global_queue, &block);
  }
  return v61;
}

void sub_10013539C(id a1)
{
  +[SecDbKeychainMetadataKeyStore resetSharedStore](SecDbKeychainMetadataKeyStore, "resetSharedStore");
}

uint64_t sub_1001353A8(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  _DWORD v4[2];

  v1 = sub_10001B28C(a1, CFSTR("PRAGMA user_version"), 0) & 1;
  v2 = sub_10000EF14("edutranscrypted");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v4[0] = 67109120;
    v4[1] = v1;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "got: %{BOOL}d", (uint8_t *)v4, 8u);
  }
  return v1;
}

void sub_10013545C(uint64_t a1)
{
  int v2;
  const __CFString *v3;
  char v4;
  NSObject *v5;
  NSObject *v6;
  CFTypeRef v7;
  CFTypeRef cf;
  uint8_t buf[4];
  CFTypeRef v10;

  cf = 0;
  v2 = sub_10001B28C(a1, CFSTR("PRAGMA user_version"), 0);
  v3 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("PRAGMA user_version = %d"), v2 | 1u);
  v4 = sub_10001B41C(a1, v3, &cf);
  if ((v4 & 1) == 0)
  {
    v5 = sub_10000EF14("SecError");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v10 = cf;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "setDbUserVersion failed: %@", buf, 0xCu);
    }
  }
  if (v3)
    CFRelease(v3);
  if ((v4 & 1) == 0)
  {
    v6 = sub_10000EF14("edutranscrypted");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v10 = cf;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "failed to set DB user version: %@", buf, 0xCu);
    }
    v7 = cf;
    if (cf)
    {
      cf = 0;
      CFRelease(v7);
    }
  }
}

void sub_1001355D0(uint64_t a1, _BYTE *a2)
{
  CFMutableStringRef v2;
  uint64_t v4;
  int v5;
  unsigned int v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  void ***v11;
  uint64_t (*__ptr32 *v12)();
  unsigned int v13;
  const __CFArray *v14;
  int **v15;
  int *v16;
  int *v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const __CFString *v23;
  NSObject *v24;
  int v25;
  uint64_t v26;
  int v27;
  uint64_t *v28;
  const __CFString **v29;
  const void *v30;
  CFStringRef v31;
  unsigned int v32;
  const __CFDictionary *v33;
  const void *v34;
  const __CFString **v35;
  const __CFDictionary *v36;
  CFStringRef v37;
  const __CFSet *v38;
  CFMutableArrayRef v39;
  CFTypeRef *v40;
  int v41;
  int v42;
  __CFString ***v43;
  __CFString **v44;
  __CFString *v45;
  __CFString **v46;
  __CFString **v47;
  __CFString *v48;
  __CFString **v49;
  char v50;
  char v51;
  int v52;
  int v53;
  CFIndex v54;
  const __CFString *v55;
  const void *ValueAtIndex;
  __darwin_time_t *v57;
  NSObject *v58;
  __darwin_time_t v59;
  uint64_t v60;
  uint64_t v62;
  const void *v63;
  const __CFString *v64;
  const __CFArray *v65;
  uint64_t v66;
  CFDictionaryRef *v67;
  BOOL v68;
  BOOL v69;
  __CFString *v70;
  uint64_t v71;
  char v72;
  uint64_t *v73;
  uint64_t v74;
  int v75;
  int v76;
  char v77;
  char v78;
  int v79;
  int64_t v80;
  uint64_t v81;
  unint64_t v82;
  BOOL v83;
  uint64_t v84;
  uint64_t v85;
  const __CFString *v86;
  const __CFString *v87;
  const void *v88;
  int v89;
  __CFString *v90;
  uint64_t v91;
  uint64_t *v92;
  uint64_t *v93;
  uint64_t v94;
  void **v95;
  const void **v96;
  __CFString **v97;
  __CFString ***v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  CFDictionaryRef *v102;
  uint64_t v103;
  BOOL v104;
  BOOL v105;
  __CFString **v106;
  int64_t v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  char v113;
  unsigned int v114;
  __CFString *v115;
  uint64_t v116;
  __CFError *v117;
  const void *v118;
  __CFString *v119;
  NSObject *v120;
  int v121;
  uint64_t v122;
  uint64_t v123;
  NSObject *v124;
  char v125;
  NSObject *v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  const void *v132;
  NSObject *v133;
  uint64_t v134;
  const char *v135;
  NSObject *v136;
  uint32_t v137;
  NSObject *v138;
  uint64_t v139;
  NSObject *v140;
  uint64_t v141;
  unsigned int v142;
  unsigned int v143;
  unsigned int v144;
  const __CFArray *cf;
  const __CFSet *theSet;
  unsigned int v147;
  _BYTE *v148;
  uint64_t v149;
  const __CFDictionary *theDict;
  CFTypeRef *v151;
  uint64_t v152;
  const void **v153;
  _BOOL4 v154;
  const __CFDictionary *Mutable;
  unsigned int v156;
  _QWORD *v157;
  uint64_t v158;
  unsigned int v159;
  void **v160;
  uint64_t v161;
  void *v162;
  void *v163;
  __CFString **v164;
  __CFString **v165;
  _QWORD *v166;
  CFTypeRef *v167;
  uint64_t v168;
  void **v169;
  uint64_t v170;
  void *v171;
  void *v172;
  const __CFSet *v173;
  const __CFDictionary *v174;
  int *v175;
  CFMutableStringRef v176;
  CFMutableArrayRef v177;
  void **v178;
  uint64_t v179;
  void (*v180)(uint64_t, const void *, int);
  void *v181;
  const __CFSet *v182;
  const __CFDictionary *v183;
  int *v184;
  CFMutableStringRef v185;
  void **context;
  uint64_t v187;
  void (*v188)(uint64_t, const void *, int);
  void *v189;
  const __CFDictionary *v190;
  int *v191;
  int *v192;
  const __CFSet *v193;
  timeval v194;
  _QWORD v195[4];
  __CFString *v196;
  __CFString **v197;
  uint64_t v198;
  char v199;
  timeval v200;
  void (*v201)(uint64_t, const void *);
  void *v202;
  const __CFDictionary *v203;
  int *v204;
  CFMutableStringRef v205;
  _BYTE buf[24];
  void *v207;
  _QWORD *v208;
  _QWORD *p_context;
  __CFString **v210;
  int *v211;
  CFMutableStringRef v212;
  uint64_t v213;
  CFRange v214;

  v4 = a1;
  v159 = 0;
  v5 = sub_100133520(*(_QWORD *)(a1 + 56), (int *)&v159, (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v4 + 32) + 8) + 24) = v5;
  if (!v5)
    goto LABEL_16;
  v6 = *(_DWORD *)(v4 + 80);
  if (v6 == v159)
  {
    v7 = *(unsigned int **)(v4 + 64);
    v8 = v7[1];
    if ((*v7 | (v8 << 8)) == v6)
      goto LABEL_16;
    if (v6)
    {
      v9 = (unsigned __int16)*(_DWORD *)(v4 + 80);
      v159 = v9;
      v10 = *v7 | (v8 << 8);
      if (v6 < 0x10000 || v9 == (_DWORD)v10)
      {
        v11 = &v169;
        v12 = &off_100248000;
        v13 = HIWORD(v6);
        v147 = HIWORD(v6);
        v148 = a2;
        v149 = v4;
        if (!HIWORD(v6))
        {
          v159 = v10;
          v14 = (const __CFArray *)dword_1002E4310;
          v15 = (int **)&off_1002E6F38;
          v16 = dword_1002E4310;
          while ((*v16 | (v16[1] << 8)) != v9)
          {
            v17 = *v15++;
            v16 = v17;
            if (!v17)
            {
              sub_10003060C(11, (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(v4 + 40) + 8) + 24), CFSTR("no schema for version: 0x%x"), (unsigned __int16)v6);
              *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v4 + 32) + 8) + 24) = 0;
              v18 = sub_10000EF14("SecError");
              if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 67109120;
                *(_DWORD *)&buf[4] = v9;
                _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "no schema for version 0x%x", buf, 8u);
              }
              v19 = v159;
              v20 = *(unsigned int *)(v4 + 84);
              v21 = 6;
              goto LABEL_14;
            }
          }
          v143 = v6;
          v24 = sub_10000EF14("upgr");
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          {
            v25 = **(_DWORD **)(v4 + 64) | (*(_DWORD *)(*(_QWORD *)(v4 + 64) + 4) << 8);
            *(_DWORD *)buf = 67109376;
            *(_DWORD *)&buf[4] = v9;
            *(_WORD *)&buf[8] = 1024;
            *(_DWORD *)&buf[10] = v25;
            _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Upgrading from version 0x%x to 0x%x", buf, 0xEu);
          }
          v144 = v9;
          kdebug_trace(726794280, 0, 0, 0, 0);
          v152 = *(_QWORD *)(v4 + 56);
          v26 = *(_QWORD *)(*(_QWORD *)(v4 + 40) + 8);
          v11 = (void ***)*v16;
          v27 = v16[1];
          v196 = 0;
          v197 = &v196;
          v198 = 0x2000000000;
          v199 = 1;
          v195[0] = 0;
          v195[1] = v195;
          v195[2] = 0x2000000000;
          v195[3] = 0;
          v194.tv_sec = 0xAAAAAAAAAAAAAAAALL;
          *(_QWORD *)&v194.tv_usec = 0xAAAAAAAAAAAAAAAALL;
          gettimeofday(&v194, 0);
          v214.location = 48;
          v214.length = 57;
          v28 = (uint64_t *)CFCharacterSetCreateWithCharactersInRange(0, v214);
          Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, 0);
          v29 = (const __CFString **)*((_QWORD *)v16 + 1);
          if (v29)
          {
            v30 = 0;
            v2 = (CFMutableStringRef)Mutable;
            while (1)
            {
              v31 = sub_1000300B4(*v29, (const __CFCharacterSet *)v28);
              if (CFDictionaryContainsKey(Mutable, v31))
                break;
              CFDictionarySetValue(Mutable, v31, v30);
              if (v31)
                CFRelease(v31);
              v29 = *(const __CFString ***)&v16[2 * (_QWORD)v30 + 4];
              v30 = (char *)v30 + 1;
              if (!v29)
                goto LABEL_25;
            }
          }
          else
          {
LABEL_25:
            v151 = (CFTypeRef *)(v26 + 24);
            v32 = v11 | (v27 << 8);
            v33 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, 0);
            v34 = 0;
            v35 = (const __CFString **)&off_1002E2190;
            v11 = &v169;
            v36 = Mutable;
            while (1)
            {
              v37 = sub_1000300B4(*v35, (const __CFCharacterSet *)v28);
              if (CFDictionaryContainsKey(v33, v37))
                break;
              CFDictionarySetValue(v33, v37, v34);
              if (v37)
                CFRelease(v37);
              v35 = *(const __CFString ***)&dword_1002E4310[2 * (_QWORD)v34 + 4];
              v34 = (char *)v34 + 1;
              if (v34 == (const void *)27)
              {
                v142 = v32;
                if (v28)
                  CFRelease(v28);
                v38 = CFSetCreateMutable(0, 0, &kCFTypeSetCallBacks);
                context = _NSConcreteStackBlock;
                v187 = 0x40000000;
                v188 = sub_1001375CC;
                v189 = &unk_1002E8418;
                v190 = v33;
                v191 = v16;
                v192 = dword_1002E4310;
                v193 = v38;
                CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)sub_1001376F4, &context);
                v2 = CFStringCreateMutable(0, 0);
                v39 = CFArrayCreateMutable(0, 0, 0);
                *(_QWORD *)buf = _NSConcreteStackBlock;
                *(_QWORD *)&buf[8] = 0x40000000;
                *(_QWORD *)&buf[16] = sub_10013770C;
                v207 = &unk_1002E8438;
                v208 = Mutable;
                p_context = v16;
                v210 = (__CFString **)v33;
                v211 = dword_1002E4310;
                v212 = v2;
                v213 = (uint64_t)v39;
                CFSetApplyFunction(v38, (CFSetApplierFunction)sub_100133D68, buf);
                v178 = _NSConcreteStackBlock;
                v179 = 0x40000000;
                v180 = sub_100137794;
                v181 = &unk_1002E8458;
                v182 = v38;
                v183 = v33;
                v184 = v16;
                v185 = v2;
                CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)sub_1001376F4, &v178);
                v169 = _NSConcreteStackBlock;
                v170 = 0x40000000;
                v171 = sub_10013780C;
                v172 = &unk_1002E8478;
                cf = v39;
                theSet = v38;
                v173 = v38;
                v174 = Mutable;
                v175 = dword_1002E4310;
                v176 = v2;
                v177 = v39;
                theDict = v33;
                CFDictionaryApplyFunction(v33, (CFDictionaryApplierFunction)sub_1001376F4, &v169);
                v40 = v151;
                if (CFStringGetLength(v2) >= 1)
                {
                  v41 = sub_10001B41C(v152, v2, v151);
                  v42 = *((_BYTE *)v197 + 24) ? v41 : 0;
                  *((_BYTE *)v197 + 24) = v42;
                  if (v42 != 1)
                  {
                    v14 = 0;
                    v28 = 0;
                    v153 = 0;
                    v130 = 8;
                    goto LABEL_191;
                  }
                }
                if (v2)
                  CFRelease(v2);
                v2 = CFStringCreateMutable(0, 0);
                v43 = off_1002E4318;
                v44 = &off_1002E2190;
                do
                {
                  v45 = v44[2];
                  if (v45)
                  {
                    v46 = v44 + 3;
                    do
                    {
                      if ((~LODWORD(v45->data) & 6) == 0)
                      {
                        v47 = *v43;
                        CFStringAppendFormat(v2, 0, CFSTR("DROP INDEX IF EXISTS %@%@;"), **v43, v45->isa);
                        if (LODWORD(v45->info) == 11)
                          CFStringAppendFormat(v2, 0, CFSTR("DROP INDEX IF EXISTS %@%@0;"), *v47, v45->isa);
                      }
                      v48 = *v46++;
                      v45 = v48;
                    }
                    while (v48);
                  }
                  v49 = v43[1];
                  ++v43;
                  v44 = v49;
                }
                while (v49);
                v40 = v151;
                v50 = sub_10001B41C(v152, v2, v151);
                if (*((_BYTE *)v197 + 24))
                  v51 = v50;
                else
                  v51 = 0;
                *((_BYTE *)v197 + 24) = v51;
                if ((v51 & 1) == 0)
                {
                  v14 = 0;
                  v28 = 0;
                  v153 = 0;
                  v130 = 9;
                  goto LABEL_191;
                }
                if (v2)
                  CFRelease(v2);
                v52 = sub_10012E148(v152, (unsigned int *)dword_1002E4310, cf, 0, (uint64_t)v151);
                if (*((_BYTE *)v197 + 24))
                  v53 = v52;
                else
                  v53 = 0;
                *((_BYTE *)v197 + 24) = v53;
                if (v53 != 1)
                {
                  v14 = 0;
                  v2 = 0;
                  v28 = 0;
                  v153 = 0;
                  v130 = 10;
                  goto LABEL_191;
                }
                v14 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
                v160 = _NSConcreteStackBlock;
                v161 = 0x40000000;
                v162 = sub_1001378A4;
                v163 = &unk_1002E8560;
                v164 = (__CFString **)v14;
                CFSetApplyFunction(v38, (CFSetApplierFunction)sub_100133D68, &v160);
                v2 = 0;
                v54 = 0;
                v28 = 0;
                v153 = 0;
                v55 = CFSTR("%@");
                while (2)
                {
                  if (v54 >= CFArrayGetCount(v14))
                  {
                    if (v2)
                      CFRelease(v2);
                    v2 = CFStringCreateMutable(0, 0);
                    v200.tv_sec = (__darwin_time_t)_NSConcreteStackBlock;
                    *(_QWORD *)&v200.tv_usec = 0x40000000;
                    v201 = sub_100137CD8;
                    v202 = &unk_1002E8540;
                    v203 = v36;
                    v204 = v16;
                    v205 = v2;
                    CFSetApplyFunction(theSet, (CFSetApplierFunction)sub_100133D68, &v200);
                    if (CFStringGetLength(v2) < 1)
                      goto LABEL_106;
                    v77 = sub_10001B41C(v152, v2, v40);
                    v78 = *((_BYTE *)v197 + 24) ? v77 : 0;
                    *((_BYTE *)v197 + 24) = v78;
                    if ((v78 & 1) != 0)
                      goto LABEL_106;
                    v130 = 13;
LABEL_191:
                    LKAReportKeychainUpgradeOutcomeWithError(v142, 2060, v130, *v40);
                    goto LABEL_106;
                  }
                  ValueAtIndex = CFArrayGetValueAtIndex(v14, v54);
                  v57 = *(__darwin_time_t **)&v16[2 * (int)CFDictionaryGetValue(v36, ValueAtIndex) + 2];
                  v157 = *(_QWORD **)&dword_1002E4310[2 * (int)CFDictionaryGetValue(theDict, ValueAtIndex) + 2];
                  v58 = sub_10000EF14("upgr");
                  if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
                  {
                    v59 = *v57;
                    LODWORD(v200.tv_sec) = 138412290;
                    *(__darwin_time_t *)((char *)&v200.tv_sec + 4) = v59;
                    _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "Upgrading table %@", (uint8_t *)&v200, 0xCu);
                  }
                  if (v57[2])
                  {
                    v60 = 0;
                    while (v57[v60++ + 3])
                      ;
                    v62 = v60;
                    if (!v28)
                      goto LABEL_70;
                  }
                  else
                  {
                    v62 = 0;
                    if (!v28)
                    {
LABEL_70:
                      v64 = v55;
                      v65 = v14;
                      v66 = v62;
                      v28 = (uint64_t *)malloc_type_malloc(8 * v62 + 24, 0x649CA7ECuLL);
                      *v28 = (uint64_t)CFStringCreateWithFormat(0, 0, CFSTR("%@_old"), *v57);
                      *((_BYTE *)v28 + 8) = *((_BYTE *)v57 + 8);
                      if ((v62 & 0x80000000) == 0)
                      {
                        do
                        {
                          v28[v66 + 2] = v57[v66 + 2];
                          --v66;
                        }
                        while (v66 != -1);
                      }
                      if (*((_BYTE *)v57 + 8))
                      {
                        v40 = v151;
                        v14 = v65;
                        if (v153)
                          sub_100011108(v153, 0);
                        v11 = &v169;
                        v55 = v64;
                        if (qword_100341198 != -1)
                          dispatch_once(&qword_100341198, &stru_1002DED48);
                        v67 = (CFDictionaryRef *)sub_1000114E8((uint64_t)v28, (const void *)qword_1003411A0, 0, 0, (__CFString **)v151);
                        if (!v67)
                          goto LABEL_186;
                        v160 = _NSConcreteStackBlock;
                        v161 = 0x40000000;
                        v162 = sub_1001378AC;
                        v163 = &unk_1002E8520;
                        v164 = (__CFString **)v195;
                        v165 = &v196;
                        v166 = v157;
                        v167 = v151;
                        v168 = v152;
                        v153 = (const void **)v67;
                        v68 = sub_10001E280(v67, v152, v151, &stru_1002E84B8, &stru_1002E84F8, 0, 0, (uint64_t)&v160);
                        if (*((_BYTE *)v197 + 24))
                          v69 = v68;
                        else
                          v69 = 0;
                        *((_BYTE *)v197 + 24) = v69;
                        if (!v69)
                        {
                          v130 = 11;
                          v36 = Mutable;
                          goto LABEL_191;
                        }
                        v36 = Mutable;
                      }
                      else
                      {
                        v14 = v65;
                        if (v2)
                          CFRelease(v2);
                        v2 = CFStringCreateMutable(0, 0);
                        v70 = CFStringCreateMutable(0, 0);
                        v71 = v28[2];
                        v55 = v64;
                        if (v71)
                        {
                          v72 = 0;
                          v73 = v28 + 3;
                          do
                          {
                            if ((*(_BYTE *)(v71 + 16) & 2) != 0)
                            {
                              if ((v72 & 1) != 0)
                                CFStringAppendFormat(v70, 0, CFSTR(","));
                              CFStringAppendFormat(v70, 0, v64, *(_QWORD *)v71);
                              v72 = 1;
                            }
                            v74 = *v73++;
                            v71 = v74;
                          }
                          while (v74);
                        }
                        CFStringAppendFormat(v2, 0, CFSTR("INSERT OR REPLACE INTO %@ (%@) SELECT %@ FROM %@;"),
                          *v157,
                          v70,
                          v70,
                          *v28);
                        if (v70)
                          CFRelease(v70);
                        v40 = v151;
                        v75 = sub_10001B41C(v152, v2, v151);
                        v11 = &v169;
                        if (*((_BYTE *)v197 + 24))
                          v76 = v75;
                        else
                          v76 = 0;
                        *((_BYTE *)v197 + 24) = v76;
                        v36 = Mutable;
                        if (v76 != 1)
                        {
                          v130 = 12;
                          goto LABEL_191;
                        }
                      }
                      ++v54;
                      continue;
                    }
                  }
                  break;
                }
                v63 = (const void *)*v28;
                if (*v28)
                {
                  *v28 = 0;
                  CFRelease(v63);
                }
                free(v28);
                goto LABEL_70;
              }
            }
            v128 = _os_assert_log(0);
            _os_crash(v128);
            __break(1u);
          }
          v129 = _os_assert_log(0);
          _os_crash(v129);
          __break(1u);
LABEL_186:
          v153 = 0;
          v36 = Mutable;
LABEL_106:
          v79 = *((unsigned __int8 *)v11[32] + 24);
          v80 = (int64_t)v11[28][3];
          v81 = 1;
          if (v80 >= 101)
          {
            v82 = (unint64_t)v11[28][3];
            do
            {
              v80 = v82 / 0xA;
              v81 *= 10;
              v83 = v82 > 0x3F1;
              v82 /= 0xAuLL;
            }
            while (v83);
          }
          v84 = v81 * v80;
          v85 = sub_100133AEC((uint64_t)&v194);
          if (v79)
            v86 = CFSTR("com.apple.keychain.phase1.migrated-items-success");
          else
            v86 = CFSTR("com.apple.keychain.phase1.migrated-items-fail");
          if (v79)
            v87 = CFSTR("com.apple.keychain.phase1.migrated-time-success");
          else
            v87 = CFSTR("com.apple.keychain.phase1.migrated-time-fail");
          SecCoreAnalyticsSendValue(v86, v84);
          SecCoreAnalyticsSendValue(v87, v85);
          if (v153)
            sub_100011108(v153, 0);
          v4 = v149;
          if (v2)
            CFRelease(v2);
          v12 = &off_100248000;
          if (cf)
            CFRelease(cf);
          a2 = v148;
          if (v28)
          {
            v88 = (const void *)*v28;
            if (*v28)
            {
              *v28 = 0;
              CFRelease(v88);
            }
            free(v28);
          }
          if (v14)
            CFRelease(v14);
          if (theSet)
            CFRelease(theSet);
          if (v36)
            CFRelease(v36);
          if (theDict)
            CFRelease(theDict);
          v89 = *((unsigned __int8 *)v11[32] + 24);
          _Block_object_dispose(v195, 8);
          _Block_object_dispose(&v196, 8);
          *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v149 + 32) + 8) + 24) = v89;
          if (v89)
          {
            kdebug_trace(726794284, 0, 0, 0, 0);
            v13 = v144;
            v6 = v143;
            goto LABEL_135;
          }
          v140 = sub_10000EF14("SecError");
          if (os_log_type_enabled(v140, OS_LOG_TYPE_DEFAULT))
          {
            v141 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v149 + 40) + 8) + 24);
            *(_DWORD *)buf = 138412290;
            *(_QWORD *)&buf[4] = v141;
            v135 = "upgrade: Upgrade phase1 failed: %@";
            v136 = v140;
            v137 = 12;
            goto LABEL_204;
          }
          goto LABEL_16;
        }
LABEL_135:
        v156 = v13;
        v154 = v6 < 0x10000;
        v11[31] = 0;
        kdebug_trace(726794288, 0, 0, 0, 0);
        v90 = *(__CFString **)(v4 + 72);
        v91 = v159;
        off_100340C18();
        v93 = v92;
        v158 = *v92;
        *v92 = v94;
        v11[17] = 0;
        v11[18] = (void **)&context;
        v95 = (void **)*((_QWORD *)v12 + 500);
        v11[19] = v95;
        LOBYTE(v189) = 1;
        v11[9] = 0;
        v11[10] = (void **)&v178;
        v11[11] = v95;
        v11[12] = 0;
        memset(&v200, 170, sizeof(v200));
        gettimeofday(&v200, 0);
        v96 = 0;
        v97 = &off_1002E2190;
        v98 = off_1002E4320;
        while (!LOBYTE(v90->isa))
        {
          if (*((_BYTE *)v97 + 8))
          {
            v99 = sub_10001E6A8(v97, 14, &v196);
            if (v99)
            {
              v100 = v99;
              if (v96)
                sub_100011108(v96, 0);
              v101 = (uint64_t)*(v98 - 1);
              if (qword_100341198 != -1)
                dispatch_once(&qword_100341198, &stru_1002DED48);
              v102 = (CFDictionaryRef *)sub_1000114E8(v101, (const void *)qword_1003411A0, 0, 0, &v196);
              if (!v102)
              {
                *(_BYTE *)(v187 + 24) = 0;
                a2 = v148;
                v110 = v158;
                goto LABEL_156;
              }
              v96 = (const void **)v102;
              v103 = *v93;
              v169 = _NSConcreteStackBlock;
              v170 = 0x40000000;
              v171 = sub_100137D2C;
              v172 = &unk_1002E85C0;
              v173 = (const __CFSet *)v100;
              v160 = _NSConcreteStackBlock;
              v161 = 0x40000000;
              v162 = sub_100137D84;
              v163 = &unk_1002E85E0;
              v164 = &v196;
              *(_QWORD *)buf = _NSConcreteStackBlock;
              *(_QWORD *)&buf[8] = 0x40000000;
              *(_QWORD *)&buf[16] = sub_100137DF8;
              v207 = &unk_1002E8608;
              v208 = &v178;
              p_context = &context;
              v210 = &v196;
              v211 = (int *)v102;
              v212 = v90;
              v213 = v91 | 0x80C00000000;
              v104 = sub_10001E280(v102, v103, (CFTypeRef *)&v196, 0, &stru_1002E85A0, (uint64_t)&v169, (uint64_t)&v160, (uint64_t)buf);
              v105 = *(_BYTE *)(v187 + 24) && v104;
              *(_BYTE *)(v187 + 24) = v105;
              if (!v105)
              {
                LKAReportKeychainUpgradeOutcomeWithError(v91, 2060, 14, v196);
                a2 = v148;
                v110 = v158;
LABEL_155:
                sub_100011108(v96, 0);
                goto LABEL_156;
              }
            }
          }
          v106 = *v98++;
          v97 = v106;
          if (!v106)
            break;
        }
        v107 = *(_QWORD *)(v179 + 24);
        v108 = 1;
        if (v107 < 101)
        {
          a2 = v148;
          v110 = v158;
        }
        else
        {
          v109 = *(_QWORD *)(v179 + 24);
          a2 = v148;
          v110 = v158;
          do
          {
            v107 = v109 / 0xA;
            v108 *= 10;
            v83 = v109 > 0x3F1;
            v109 /= 0xAuLL;
          }
          while (v83);
        }
        v111 = v108 * v107;
        v112 = sub_100133AEC((uint64_t)&v200);
        SecCoreAnalyticsSendValue(CFSTR("com.apple.keychain.phase2.migrated-items"), v111);
        SecCoreAnalyticsSendValue(CFSTR("com.apple.keychain.phase2.migrated-time"), v112);
        if (v96)
          goto LABEL_155;
LABEL_156:
        *v93 = v110;
        v113 = *(_BYTE *)(v187 + 24);
        _Block_object_dispose(&v178, 8);
        _Block_object_dispose(&context, 8);
        v4 = v149;
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v149 + 32) + 8) + 24) = v113;
        if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v149 + 32) + 8) + 24))
          goto LABEL_157;
        if (v147)
        {
          v115 = v196;
          if (v196)
          {
            v116 = *(_QWORD *)(*(_QWORD *)(v149 + 40) + 8);
            v117 = *(__CFError **)(v116 + 24);
            if (v117)
            {
              if (CFErrorGetCode(v117) == -25330)
              {
                v118 = *(const void **)(v116 + 24);
                if (!v118)
                  goto LABEL_183;
                *(_QWORD *)(v116 + 24) = 0;
                CFRelease(v118);
              }
              if (*(_QWORD *)(v116 + 24))
              {
                v119 = v115;
LABEL_182:
                CFRelease(v119);
                goto LABEL_157;
              }
            }
LABEL_183:
            *(_QWORD *)(v116 + 24) = v115;
          }
        }
        else
        {
          **(_BYTE **)(v149 + 72) = 1;
          *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v149 + 32) + 8) + 24) = 1;
          v119 = v196;
          if (v196)
          {
            v196 = 0;
            goto LABEL_182;
          }
        }
LABEL_157:
        if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v149 + 32) + 8) + 24))
        {
          if (**(_BYTE **)(v149 + 72))
          {
            v114 = v156;
          }
          else
          {
            v120 = sub_10000EF14("upgr");
            if (os_log_type_enabled(v120, OS_LOG_TYPE_DEFAULT))
            {
              v121 = **(_DWORD **)(v149 + 64) | (*(_DWORD *)(*(_QWORD *)(v149 + 64) + 4) << 8);
              *(_DWORD *)buf = 67109376;
              *(_DWORD *)&buf[4] = v156;
              *(_WORD *)&buf[8] = 1024;
              *(_DWORD *)&buf[10] = v121;
              _os_log_impl((void *)&_mh_execute_header, v120, OS_LOG_TYPE_DEFAULT, "Done upgrading from version 0x%x to 0x%x", buf, 0xEu);
            }
            *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v149 + 48) + 8) + 24) = 1;
            kdebug_trace(726794292, 0, 0, 0, 0);
            v114 = 0;
          }
          v122 = v159 | (v114 << 16);
          v123 = (v114 << 8) & 0xFF0000 | BYTE1(v159);
          v124 = sub_10000EF14("upgr");
          if (os_log_type_enabled(v124, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 67109376;
            *(_DWORD *)&buf[4] = v122;
            *(_WORD *)&buf[8] = 1024;
            *(_DWORD *)&buf[10] = v123;
            _os_log_impl((void *)&_mh_execute_header, v124, OS_LOG_TYPE_DEFAULT, "Upgrading saving version major 0x%x minor 0x%x", buf, 0xEu);
          }
          v23 = CFStringCreateWithFormat(0, 0, CFSTR("UPDATE tversion SET version='%d', minor='%d'"), v122, v123);
          v125 = sub_10001B41C(*(_QWORD *)(v149 + 56), v23, (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(v149 + 40) + 8) + 24));
          *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v149 + 32) + 8) + 24) = v125;
          if ((v125 & 1) == 0)
          {
            v138 = sub_10000EF14("SecError");
            if (os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT))
            {
              v139 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v149 + 40) + 8) + 24);
              *(_DWORD *)buf = 138412290;
              *(_QWORD *)&buf[4] = v139;
              _os_log_impl((void *)&_mh_execute_header, v138, OS_LOG_TYPE_DEFAULT, "upgrade: Setting version failed: %@", buf, 0xCu);
            }
          }
          goto LABEL_174;
        }
        v133 = sub_10000EF14("SecError");
        if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT))
        {
          v134 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v149 + 40) + 8) + 24);
          *(_DWORD *)buf = 67109378;
          *(_DWORD *)&buf[4] = v154;
          *(_WORD *)&buf[8] = 2112;
          *(_QWORD *)&buf[10] = v134;
          v135 = "upgrade: Upgrade phase2 (%d) failed: %@";
          v136 = v133;
          v137 = 18;
LABEL_204:
          _os_log_impl((void *)&_mh_execute_header, v136, OS_LOG_TYPE_DEFAULT, v135, buf, v137);
        }
LABEL_16:
        v23 = 0;
        goto LABEL_174;
      }
      sub_10003060C(11, (CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(v4 + 40) + 8) + 24), CFSTR("Half migrated but obsolete DB found: found 0x%x(0x%x) but 0x%x is needed"), (unsigned __int16)v6, HIWORD(v6), v10);
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v4 + 32) + 8) + 24) = 0;
      v19 = v159;
      v20 = *(unsigned int *)(v4 + 84);
      v21 = 5;
LABEL_14:
      v22 = 0;
    }
    else
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v4 + 32) + 8) + 24) = sub_10012E148(*(_QWORD *)(v4 + 56), v7, 0, 1, *(_QWORD *)(*(_QWORD *)(v4 + 40) + 8) + 24);
      sub_100136A80(*(_QWORD *)(v4 + 56));
      v19 = v159;
      v20 = *(unsigned int *)(v4 + 84);
      v22 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v4 + 40) + 8) + 24);
      v21 = 4;
    }
    LKAReportKeychainUpgradeOutcomeWithError(v19, v20, v21, v22);
    goto LABEL_16;
  }
  v131 = *(_QWORD *)(*(_QWORD *)(v4 + 40) + 8);
  v132 = *(const void **)(v131 + 24);
  if (v132)
  {
    *(_QWORD *)(v131 + 24) = 0;
    CFRelease(v132);
  }
  v23 = 0;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v4 + 32) + 8) + 24) = 1;
LABEL_174:
  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v4 + 32) + 8) + 24))
  {
    v126 = sub_10000EF14("SecError");
    if (os_log_type_enabled(v126, OS_LOG_TYPE_DEFAULT))
    {
      v127 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v4 + 40) + 8) + 24);
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)&buf[4] = v127;
      _os_log_impl((void *)&_mh_execute_header, v126, OS_LOG_TYPE_DEFAULT, "upgrade: SecDB upgrade failed: %@", buf, 0xCu);
    }
  }
  if (v23)
    CFRelease(v23);
  *a2 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v4 + 32) + 8) + 24);
}

