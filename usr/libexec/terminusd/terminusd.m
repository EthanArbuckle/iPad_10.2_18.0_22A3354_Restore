id *sub_100003144(id *a1, char a2, char a3, void *a4)
{
  id v8;
  id *v9;
  id v11;
  int IsLevelEnabled;
  id v13;
  uint64_t v14;
  char *v15;
  int *v16;
  uint64_t v17;
  id v18;
  uint64_t v19;
  objc_super v20;

  v8 = a4;
  if (a1)
  {
    v20.receiver = a1;
    v20.super_class = (Class)NRToken;
    v9 = (id *)objc_msgSendSuper2(&v20, "init");
    if (!v9)
    {
      v11 = sub_1000032B8();
      IsLevelEnabled = _NRLogIsLevelEnabled(v11, 16);

      if (IsLevelEnabled)
      {
        v13 = sub_1000032B8();
        _NRLogWithArgs(v13, 16, "%s%.30s:%-4d ABORTING: [super init] failed", "", "-[NRToken initWithType:action:value:]", 63);

      }
      v14 = _os_log_pack_size(12);
      v15 = (char *)&v19 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
      v16 = __error();
      v17 = _os_log_pack_fill(v15, v14, *v16, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)v17 = 136446210;
      *(_QWORD *)(v17 + 4) = "-[NRToken initWithType:action:value:]";
      v18 = sub_1000032B8();
      _NRLogAbortWithPack(v18, v15);
    }
    a1 = v9;
    *((_BYTE *)v9 + 8) = a2;
    *((_BYTE *)v9 + 9) = a3;
    objc_storeStrong(v9 + 2, a4);
  }

  return a1;
}

id sub_1000032B8()
{
  if (qword_1001E44B8 != -1)
    dispatch_once(&qword_1001E44B8, &stru_1001B5D00);
  return (id)qword_1001E44B0;
}

void sub_1000032F8(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001E44B0;
  qword_1001E44B0 = (uint64_t)v1;

}

id sub_100003328(uint64_t a1)
{
  id v2;

  if (!a1)
    return 0;
  v2 = objc_alloc_init((Class)NSMutableData);
  ((void (*)(void))NRTLVAdd)();
  if (*(_QWORD *)(a1 + 16))
    NRTLVAddData(v2, 2);
  NRTLVAdd(v2, 3, 1, a1 + 9);
  return v2;
}

uint64_t sub_1000033AC(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_1000033BC(uint64_t a1)
{

}

uint64_t sub_1000033C4(_QWORD *a1, unsigned __int8 *a2)
{
  unsigned int v3;
  uint64_t v4;
  int v5;
  unsigned __int8 v6;
  uint64_t v7;
  id v8;
  uint64_t v9;
  void *v10;
  uint64_t result;

  v3 = *(unsigned __int16 *)(a2 + 1);
  v4 = __rev16(v3);
  v5 = *a2;
  switch(v5)
  {
    case 3:
      if (v3 == 256)
      {
        v6 = a2[3];
        v7 = a1[7];
        goto LABEL_8;
      }
      *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = 1;
      if (qword_1001E44B8 != -1)
        dispatch_once(&qword_1001E44B8, &stru_1001B5D00);
      result = _NRLogIsLevelEnabled(qword_1001E44B0, 16);
      if ((_DWORD)result)
      {
        if (qword_1001E44B8 != -1)
          dispatch_once(&qword_1001E44B8, &stru_1001B5D00);
        _NRLogWithArgs(qword_1001E44B0, 16, "%s%.30s:%-4d unexpected size for token action %u");
        return 0;
      }
      break;
    case 2:
      v8 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", a2 + 3, v4);
      v9 = *(_QWORD *)(a1[6] + 8);
      v10 = *(void **)(v9 + 40);
      *(_QWORD *)(v9 + 40) = v8;

      return 1;
    case 1:
      if (v3 == 256)
      {
        v6 = a2[3];
        v7 = a1[5];
LABEL_8:
        *(_BYTE *)(*(_QWORD *)(v7 + 8) + 24) = v6;
        return 1;
      }
      *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = 1;
      if (qword_1001E44B8 != -1)
        dispatch_once(&qword_1001E44B8, &stru_1001B5D00);
      result = _NRLogIsLevelEnabled(qword_1001E44B0, 16);
      if ((_DWORD)result)
      {
        if (qword_1001E44B8 != -1)
          dispatch_once(&qword_1001E44B8, &stru_1001B5D00);
        _NRLogWithArgs(qword_1001E44B0, 16, "%s%.30s:%-4d unexpected size for token type %u");
        return 0;
      }
      break;
    default:
      return 1;
  }
  return result;
}

id sub_100004A00()
{
  if (qword_1001E44C8 != -1)
    dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
  return (id)qword_1001E44C0;
}

void sub_100004A40(_QWORD *a1, int a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  id v11;
  id v12;
  void *v13;
  id v14;
  id v15;
  void *v16;

  if (a1)
  {
    v11 = a3;
    v12 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:arguments:", v11, &a9);

    v13 = (void *)a1[3];
    v14 = v12;
    v15 = v13;
    v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "description"));
    sub_100121E18(v15, a2, v16, v14);

  }
}

void sub_100004AF0(uint64_t a1, id *a2)
{
  id v4;

  if (a1 && *a2)
  {
    if (qword_1001E44C8 != -1)
      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
    if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
    {
      if (qword_1001E44C8 != -1)
        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
      _NRLogWithArgs(qword_1001E44C0, 0, "%s%.30s:%-4d %@: Invalidating IKE Session %@", "", "-[NRPairingClient invalidateIKESession:]", 914, a1, *a2);
    }
    objc_msgSend(*a2, "setStateUpdateBlock:", 0);
    objc_msgSend(*a2, "setChildStateUpdateBlock:", 0);
    objc_msgSend(*a2, "setConfigurationUpdateBlock:", 0);
    objc_msgSend(*a2, "setTrafficSelectorUpdateBlock:", 0);
    objc_msgSend(*a2, "setAdditionalAddressesUpdateBlock:", 0);
    objc_msgSend(*a2, "setShortDPDEventBlock:", 0);
    objc_msgSend(*a2, "setRedirectEventBlock:", 0);
    objc_msgSend(*a2, "setPrivateNotifyStatusEvent:", 0);
    objc_msgSend(*a2, "disconnect");
    objc_msgSend(*a2, "invalidate");
    v4 = *a2;
    *a2 = 0;

  }
}

void sub_100004C50(uint64_t a1)
{
  void *v2;
  void *v3;
  id v4;
  id v5;
  id v6;
  id v7;
  id v8;
  id v9;
  id v10;
  id v11;
  char IsLevelEnabled;
  id v13;
  id v14;
  int v15;
  id *v16;
  id v17;
  _QWORD v18[4];
  id v19;
  id v20;
  _QWORD v21[4];
  id v22;
  id v23;
  _QWORD v24[4];
  id v25;
  id v26;
  _QWORD v27[4];
  id v28;
  id v29;
  _QWORD v30[4];
  id v31;
  id v32;
  _QWORD v33[4];
  id v34;
  id v35;
  _QWORD v36[4];
  id v37;
  id v38;
  id location[2];

  if (a1 && (*(_BYTE *)(a1 + 8) & 0xFE) != 6)
  {
    v2 = *(void **)(a1 + 80);
    if (v2)
    {
      v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "description"));
      objc_msgSend(*(id *)(a1 + 80), "setClientQueue:", *(_QWORD *)(a1 + 32));
      objc_initWeak(location, (id)a1);
      v36[0] = _NSConcreteStackBlock;
      v36[1] = 3221225472;
      v36[2] = sub_100007E8C;
      v36[3] = &unk_1001B6C10;
      objc_copyWeak(&v38, location);
      v4 = v3;
      v37 = v4;
      objc_msgSend(*(id *)(a1 + 80), "setStateUpdateBlock:", v36);
      v33[0] = _NSConcreteStackBlock;
      v33[1] = 3221225472;
      v33[2] = sub_10000839C;
      v33[3] = &unk_1001B6C38;
      objc_copyWeak(&v35, location);
      v5 = v4;
      v34 = v5;
      objc_msgSend(*(id *)(a1 + 80), "setChildStateUpdateBlock:", v33);
      v30[0] = _NSConcreteStackBlock;
      v30[1] = 3221225472;
      v30[2] = sub_100008564;
      v30[3] = &unk_1001B6C60;
      objc_copyWeak(&v32, location);
      v6 = v5;
      v31 = v6;
      objc_msgSend(*(id *)(a1 + 80), "setConfigurationUpdateBlock:", v30);
      v27[0] = _NSConcreteStackBlock;
      v27[1] = 3221225472;
      v27[2] = sub_10000864C;
      v27[3] = &unk_1001B6C88;
      v16 = &v29;
      objc_copyWeak(&v29, location);
      v7 = v6;
      v28 = v7;
      objc_msgSend(*(id *)(a1 + 80), "setTrafficSelectorUpdateBlock:", v27);
      v24[0] = _NSConcreteStackBlock;
      v24[1] = 3221225472;
      v24[2] = sub_100008758;
      v24[3] = &unk_1001B6CB0;
      objc_copyWeak(&v26, location);
      v8 = v7;
      v25 = v8;
      objc_msgSend(*(id *)(a1 + 80), "setAdditionalAddressesUpdateBlock:", v24);
      v21[0] = _NSConcreteStackBlock;
      v21[1] = 3221225472;
      v21[2] = sub_100008840;
      v21[3] = &unk_1001B87F0;
      objc_copyWeak(&v23, location);
      v9 = v8;
      v22 = v9;
      objc_msgSend(*(id *)(a1 + 80), "setShortDPDEventBlock:", v21);
      v18[0] = _NSConcreteStackBlock;
      v18[1] = 3221225472;
      v18[2] = sub_100008924;
      v18[3] = &unk_1001B6CB0;
      objc_copyWeak(&v20, location);
      v10 = v9;
      v19 = v10;
      objc_msgSend(*(id *)(a1 + 80), "setPrivateNotifyStatusEvent:", v18);
      if (qword_1001E44C8 != -1)
        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
      v11 = (id)qword_1001E44C0;
      IsLevelEnabled = _NRLogIsLevelEnabled(v11, 0);

      if ((IsLevelEnabled & 1) != 0)
      {
        if (qword_1001E44C8 != -1)
          dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
        v13 = (id)qword_1001E44C0;
        _NRLogWithArgs(v13, 0, "%s%.30s:%-4d %@: Setup IKE pairing %@ callbacks", "", "-[NRPairingClient setupIKECallbacksPairing]", 1156, a1, v10, &v29);

      }
      objc_destroyWeak(&v20);

      objc_destroyWeak(&v23);
      objc_destroyWeak(&v26);

      objc_destroyWeak(v16);
      objc_destroyWeak(&v32);

      objc_destroyWeak(&v35);
      objc_destroyWeak(&v38);
      objc_destroyWeak(location);

    }
    else
    {
      v14 = sub_100004A00();
      v15 = _NRLogIsLevelEnabled(v14, 17);

      if (v15)
      {
        v17 = sub_100004A00();
        _NRLogWithArgs(v17, 17, "%s called with null _ikeSessionPairing", "-[NRPairingClient setupIKECallbacksPairing]");

      }
    }
  }
}

void sub_10000507C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id *location, id *a15, id *a16)
{
  id *v16;
  id *v17;
  id *v18;
  id *v19;
  uint64_t v20;

  objc_destroyWeak(v19);
  objc_destroyWeak(v18);
  objc_destroyWeak(v17);
  objc_destroyWeak(location);
  objc_destroyWeak(v16);
  objc_destroyWeak(a15);
  objc_destroyWeak(a16);
  objc_destroyWeak((id *)(v20 - 112));
  _Unwind_Resume(a1);
}

void sub_100005110(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  uint64_t v9;
  id v10;
  uint64_t v11;
  void *v12;
  char *v13;
  id v14;
  id v15;
  id v16;
  id v17;
  id *v18;
  void *v19;
  void *LogString;
  uint64_t v21;
  void *v22;
  char *v23;
  uint64_t v24;
  unsigned __int8 *v25;
  int v26;
  id v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  id v33;
  void *v34;
  uint64_t v35;
  id v36;

  v36 = a2;
  v7 = a3;
  v8 = a4;
  v9 = *(_QWORD *)(a1 + 32);
  if ((*(_BYTE *)(v9 + 8) & 0xFE) != 6)
  {
    v10 = sub_100005460(v9, 0);
    if (_os_feature_enabled_impl("terminus", "EncryptedIdentity"))
    {
      v11 = *(_QWORD *)(a1 + 32);
      if (v11)
        v12 = *(void **)(v11 + 24);
      else
        v12 = 0;
      v13 = sub_100138520((uint64_t)NRDLocalDevice, v12);
      if (v13)
      {
        v14 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50351, v13);
        objc_msgSend(v10, "addObject:", v14);

      }
    }
    if (v36)
    {
      v15 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50411, v36);
      objc_msgSend(v10, "addObject:", v15);

    }
    if (v7)
    {
      v16 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50412, v7);
      objc_msgSend(v10, "addObject:", v16);

    }
    if (v8)
    {
      v17 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50413, v8);
      objc_msgSend(v10, "addObject:", v17);

    }
    objc_msgSend(*(id *)(a1 + 40), "setCustomIKEAuthPrivateNotifies:", v10);
    if (qword_1001E44C8 != -1)
      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
    if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
    {
      if (qword_1001E44C8 != -1)
        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
      _NRLogWithArgs(qword_1001E44C0, 0, "%s%.30s:%-4d %@: Responding to session for pairing with OOBK", "", "-[NRPairingClient requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBlock:]_block_invoke", 1710, *(_QWORD *)(a1 + 32));
    }
    v18 = *(id **)(a1 + 32);
    v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "sharedSecret"));
    LogString = (void *)_NRKeyCreateLogString(v19);
    sub_100007E0C(v18, 3014, LogString);

    v21 = *(_QWORD *)(a1 + 32);
    if (v21)
      v22 = *(void **)(v21 + 24);
    else
      v22 = 0;
    v23 = sub_10012FFF4((uint64_t)NRDLocalDevice, v22);
    if (*(_QWORD *)(a1 + 48))
    {
      v24 = *(_QWORD *)(a1 + 32);
      if (v24
        && (v25 = (unsigned __int8 *)*(id *)(v24 + 40)) != 0
        && (v26 = v25[11], v25, v26))
      {
        v27 = sub_100112420();
        objc_msgSend(v27, "setSequencePerTrafficClass:", 1);
        v28 = v27;
        v29 = 16;
      }
      else
      {
        v27 = sub_100112420();
        objc_msgSend(v27, "setMode:", 2);
        v28 = v27;
        v29 = 4;
      }
      objc_msgSend(v28, "setReplayWindowSize:", v29);
      v30 = *(_QWORD *)(a1 + 56);
      v31 = *(_QWORD *)(a1 + 40);
      if (v27)
      {
        v32 = *(_QWORD *)(a1 + 32);
        if (v32)
        {
          v33 = *(id *)(v32 + 40);
          v34 = v33;
          if (v33)
          {
            v35 = *((_QWORD *)v33 + 5);
LABEL_33:
            (*(void (**)(uint64_t, uint64_t, id, uint64_t))(v30 + 16))(v30, v31, v27, v35);

LABEL_35:
            goto LABEL_36;
          }
        }
        else
        {
          v34 = 0;
        }
        v35 = 0;
        goto LABEL_33;
      }
    }
    else
    {
      v30 = *(_QWORD *)(a1 + 56);
      v31 = *(_QWORD *)(a1 + 40);
    }
    (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD))(v30 + 16))(v30, v31, 0, 0);
    goto LABEL_35;
  }
LABEL_36:

}

id sub_100005460(uint64_t a1, int a2)
{
  id v4;
  id v5;
  id v6;
  id v7;
  void *v8;
  id v9;
  id v10;
  void *v11;
  id v12;
  id v13;
  id v14;
  id v15;
  char *v16;
  char *v17;
  id v18;
  id v19;
  unsigned __int8 *v20;
  int v21;
  char *v22;
  char *v23;
  id v24;
  id v25;
  id v26;
  id v27;
  id v28;
  id v29;
  id v30;
  id v31;
  char *v32;
  char *v33;
  void *v34;
  id v35;
  id v36;
  void *v37;
  id v38;
  unsigned __int8 v39;
  _QWORD *v40;
  _QWORD *v41;
  id v42;
  id v44;
  int IsLevelEnabled;
  id v46;
  id v47;
  int v48;
  id v49;
  uint64_t v50;
  char *v51;
  int *v52;
  uint64_t v53;
  id v54;
  uint64_t v55;
  __int128 v56;

  if (!a1)
    return 0;
  v4 = objc_alloc_init((Class)NSMutableArray);
  LOWORD(v56) = 5632;
  v5 = objc_msgSend(objc_alloc((Class)NSMutableData), "initWithBytes:length:", &v56, 2);
  v6 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 48602, v5);
  objc_msgSend(v4, "addObject:", v6);

  if (qword_1001E4860 != -1)
    dispatch_once(&qword_1001E4860, &stru_1001B7B90);
  v7 = (id)qword_1001E4858;
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "dataUsingEncoding:", 4));

  v9 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 48603, v8);
  objc_msgSend(v4, "addObject:", v9);

  if (qword_1001E4850 != -1)
    dispatch_once(&qword_1001E4850, &stru_1001B7B70);
  v10 = (id)qword_1001E4848;
  v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "dataUsingEncoding:", 4));

  v12 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 48604, v11);
  objc_msgSend(v4, "addObject:", v12);

  if (qword_1001E48E0 != -1)
    dispatch_once(&qword_1001E48E0, &stru_1001B7CE0);
  LOBYTE(v56) = byte_1001E48D8;
  v13 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &v56, 1);
  v14 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 48606, v13);
  objc_msgSend(v4, "addObject:", v14);

  v15 = sub_100112E3C();
  objc_msgSend(v4, "addObject:", v15);

  v16 = sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(a1 + 24));
  if (!v16)
  {
    v44 = sub_100004A00();
    IsLevelEnabled = _NRLogIsLevelEnabled(v44, 16);

    if (IsLevelEnabled)
    {
      v46 = sub_100004A00();
      _NRLogWithArgs(v46, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)", "", "-[NRPairingClient copyNotifyPayloadsToSendWithProxy:]", 844);

    }
LABEL_32:
    v50 = _os_log_pack_size(12);
    v51 = (char *)&v55 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
    v52 = __error();
    v53 = _os_log_pack_fill(v51, v50, *v52, &_mh_execute_header, "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
    *(_DWORD *)v53 = 136446210;
    *(_QWORD *)(v53 + 4) = "-[NRPairingClient copyNotifyPayloadsToSendWithProxy:]";
    v54 = sub_100004A00();
    _NRLogAbortWithPack(v54, v51);
    return 0;
  }
  v17 = v16;
  *(_QWORD *)&v56 = *((_QWORD *)v16 + 17);
  v18 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &v56, 8);
  v19 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 48605, v18);

  objc_msgSend(v4, "addObject:", v19);
  v20 = (unsigned __int8 *)*(id *)(a1 + 40);
  if (v20)
  {
    v21 = v20[8];

    if (v21)
    {
      v22 = sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(a1 + 24));
      if (v22)
      {
        v23 = v22;
        v56 = 0uLL;
        sub_100133C94(v22, &v56);
        v24 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &v56, 16);
        v25 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50801, v24);
        objc_msgSend(v4, "addObject:", v25);

        v56 = 0uLL;
        sub_10013453C(v23, &v56);
        v26 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &v56, 16);
        v27 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50802, v26);
        objc_msgSend(v4, "addObject:", v27);

        v56 = 0uLL;
        sub_10013CDB8(v23, &v56);
        v28 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &v56, 16);
        v29 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50811, v28);
        objc_msgSend(v4, "addObject:", v29);

        v56 = 0uLL;
        sub_10013CC28(v23, &v56);
        v30 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &v56, 16);
        v31 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50812, v30);
        objc_msgSend(v4, "addObject:", v31);

        goto LABEL_13;
      }
      v47 = sub_100004A00();
      v48 = _NRLogIsLevelEnabled(v47, 16);

      if (v48)
      {
        v49 = sub_100004A00();
        _NRLogWithArgs(v49, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)", "", "-[NRPairingClient copyNotifyPayloadsToSendWithProxy:]", 850);

      }
      goto LABEL_32;
    }
  }
LABEL_13:
  if (a2)
  {
    v32 = sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(a1 + 24));
    v33 = v32;
    if (v32)
      v34 = (void *)*((_QWORD *)v32 + 16);
    else
      v34 = 0;
    v35 = v34;
    v36 = objc_msgSend(v35, "proxyCapability");

    if (v36 == (id)1)
    {
      if (v33)
        v37 = (void *)*((_QWORD *)v33 + 16);
      else
        v37 = 0;
      v38 = v37;
      v39 = objc_msgSend(v38, "hasCompanionDatapath");

      if ((v39 & 1) != 0)
      {
        v40 = 0;
      }
      else
      {
        v41 = *(_QWORD **)(a1 + 40);
        if (v41)
          v41 = (_QWORD *)v41[4];
        v40 = v41;
      }
      v42 = sub_100112FCC(v33, v40);
      objc_msgSend(v4, "addObject:", v42);

    }
  }
  return v4;
}

uint64_t sub_100005AFC(uint64_t a1, int a2)
{
  uint64_t v2;
  id v4;
  int IsLevelEnabled;
  id v6;
  void *String;
  uint64_t v8;
  char *v9;
  int *v10;
  uint64_t v11;
  uint64_t v12;
  id v13;
  uint64_t v14;
  uint64_t v15;

  switch(a2)
  {
    case 1:
      v2 = 104;
      return a1 + v2;
    case 4:
      v2 = 88;
      return a1 + v2;
    case 3:
      v2 = 96;
      return a1 + v2;
  }
  HIDWORD(v15) = a2;
  v4 = sub_100004A00();
  IsLevelEnabled = _NRLogIsLevelEnabled(v4, 16);

  if (IsLevelEnabled)
  {
    v6 = sub_100004A00();
    String = (void *)NRDataProtectionClassCreateString(HIDWORD(v15));
    _NRLogWithArgs(v6, 16, "%s%.30s:%-4d ABORTING: Cannot copy IKE session pointer for %@", "", "-[NRPairingClient ikeSessionPointerForDataProtectionClass:]", 781, String);

  }
  v8 = _os_log_pack_size(22);
  v9 = (char *)&v15 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  v10 = __error();
  v11 = _os_log_pack_fill(v9, v8, *v10, &_mh_execute_header, "%{public}s Cannot copy IKE session pointer for %@");
  v12 = NRDataProtectionClassCreateString(HIDWORD(v15));
  *(_DWORD *)v11 = 136446466;
  *(_QWORD *)(v11 + 4) = "-[NRPairingClient ikeSessionPointerForDataProtectionClass:]";
  *(_WORD *)(v11 + 12) = 2112;
  *(_QWORD *)(v11 + 14) = v12;
  v13 = sub_100004A00();
  v14 = _NRLogAbortWithPack(v13, v9);
  return sub_100005C6C(v14);
}

void sub_100005C6C(uint64_t a1, uint64_t a2)
{
  int v2;
  void *String;
  void *v5;
  uint64_t v6;
  id v7;
  id v8;
  id v9;
  int v10;
  id v11;
  id v12;
  int IsLevelEnabled;
  id v14;
  int v15;
  _QWORD v16[4];
  id v17;
  id v18;
  uint64_t v19;
  id v20[2];
  char v21;
  id location;

  if ((*(_BYTE *)(a1 + 8) & 0xFE) != 6)
  {
    v2 = a2;
    String = (void *)NRDataProtectionClassCreateString(a2);
    switch(v2)
    {
      case 1:
        v5 = *(void **)(a1 + 104);
        if (v5)
        {
          v6 = 8;
          goto LABEL_11;
        }
        v12 = sub_100004A00();
        IsLevelEnabled = _NRLogIsLevelEnabled(v12, 17);

        if (IsLevelEnabled)
        {
          v11 = sub_100004A00();
          _NRLogWithArgs(v11, 17, "%s called with null _ikeSessionClassA");
          goto LABEL_27;
        }
        break;
      case 3:
        v5 = *(void **)(a1 + 96);
        if (v5)
        {
          v6 = 4;
          goto LABEL_11;
        }
        v14 = sub_100004A00();
        v15 = _NRLogIsLevelEnabled(v14, 17);

        if (v15)
        {
          v11 = sub_100004A00();
          _NRLogWithArgs(v11, 17, "%s called with null _ikeSessionClassC");
          goto LABEL_27;
        }
        break;
      case 4:
        v5 = *(void **)(a1 + 88);
        if (v5)
        {
          v6 = 2;
LABEL_11:
          v7 = v5;
          objc_msgSend(v7, "setClientQueue:", *(_QWORD *)(a1 + 32));
          objc_initWeak(&location, (id)a1);
          v16[0] = _NSConcreteStackBlock;
          v16[1] = 3221225472;
          v16[2] = sub_100005F10;
          v16[3] = &unk_1001B5DB8;
          objc_copyWeak(v20, &location);
          v21 = v2;
          v17 = String;
          v8 = v7;
          v20[1] = (id)v6;
          v18 = v8;
          v19 = a1;
          objc_msgSend(v8, "setStateUpdateBlock:", v16);

          objc_destroyWeak(v20);
          objc_destroyWeak(&location);

LABEL_19:
          return;
        }
        v9 = sub_100004A00();
        v10 = _NRLogIsLevelEnabled(v9, 17);

        if (v10)
        {
          v11 = sub_100004A00();
          _NRLogWithArgs(v11, 17, "%s called with null _ikeSessionClassD");
LABEL_27:

        }
        break;
      default:
        if (qword_1001E44C8 != -1)
          dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
        if (_NRLogIsLevelEnabled(qword_1001E44C0, 17))
        {
          if (qword_1001E44C8 != -1)
            dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
          _NRLogWithArgs(qword_1001E44C0, 17, "%@: Cannot setup IKE callbacks", a1);
        }
        break;
    }
    v8 = 0;
    goto LABEL_19;
  }
}

void sub_100005EF4(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 56));
  _Unwind_Resume(a1);
}

void sub_100005F10(uint64_t a1, uint64_t a2, void *a3)
{
  _QWORD *WeakRetained;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  id v23;
  char *v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  id v28;
  id v29;
  void *v30;
  uint64_t v31;
  unsigned __int8 *v32;
  int v33;
  void *SessionStateString;
  void *v35;
  id v36;
  _QWORD v37[4];
  id v38;
  id location;

  v36 = a3;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  if (!WeakRetained)
    goto LABEL_27;
  if (!v36)
  {
    v12 = *(_QWORD *)(a1 + 40);
    SessionStateString = (void *)NEIKEv2CreateSessionStateString(a2);
    sub_100004A40(WeakRetained, 3009, CFSTR("IKE session %@ changed state to %@"), v13, v14, v15, v16, v17, v12);

    switch(a2)
    {
      case 1:
        goto LABEL_27;
      case 2:
        WeakRetained[6] |= *(_QWORD *)(a1 + 64);
        sub_100006684((uint64_t)WeakRetained, 4, 0);
        v23 = (id)WeakRetained[3];
        v24 = sub_10012FFF4((uint64_t)NRDLocalDevice, v23);
        v25 = (void *)WeakRetained[14];
        WeakRetained[14] = v24;

        if ((~*((_DWORD *)WeakRetained + 12) & 6) != 0)
          goto LABEL_24;
        v26 = WeakRetained[14];
        if ((WeakRetained[6] & 8) != 0)
        {
          if (!v26)
            goto LABEL_23;
        }
        else if (!v26 || *(unsigned __int16 *)(v26 + 28) <= 0x12u)
        {
LABEL_24:
          v32 = (unsigned __int8 *)(id)WeakRetained[5];
          if (v32)
          {
            v33 = v32[14];

            if (v33)
            {
              sub_100006AD0(*(_QWORD *)(a1 + 48), 4);
              sub_100006AD0(*(_QWORD *)(a1 + 48), 3);
              sub_100006AD0(*(_QWORD *)(a1 + 48), 1);
            }
          }
          goto LABEL_27;
        }
        if (*(unsigned __int16 *)(v26 + 28) >= 0x10u)
        {
          v27 = WeakRetained[5];
          if (!v27 || !*(_BYTE *)(v27 + 8))
          {
            v28 = objc_alloc_init((Class)NSMutableArray);
            v29 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 51601, 0);
            objc_msgSend(v28, "addObject:", v29);
            objc_initWeak(&location, WeakRetained);
            v30 = (void *)WeakRetained[10];
            v31 = WeakRetained[4];
            v37[0] = _NSConcreteStackBlock;
            v37[1] = 3221225472;
            v37[2] = sub_100006D60;
            v37[3] = &unk_1001B7978;
            objc_copyWeak(&v38, &location);
            objc_msgSend(v30, "sendPrivateNotifies:maxRetries:retryIntervalInMilliseconds:callbackQueue:callback:", v28, 10, 3000, v31, v37);
            objc_destroyWeak(&v38);
            objc_destroyWeak(&location);

          }
          goto LABEL_24;
        }
LABEL_23:
        sub_100006EE4((uint64_t)WeakRetained);
        goto LABEL_24;
      case 3:
        if (*(_BYTE *)(a1 + 72) == 1)
          sub_100006244((uint64_t)WeakRetained);
        sub_100004A40(WeakRetained, 3018, CFSTR("%@ session %@ got IKE Disconnected state with no error"), v18, v19, v20, v21, v22, *(_QWORD *)(a1 + 32));
        goto LABEL_6;
      default:
        sub_100006CA0((uint64_t)WeakRetained);
        sub_100006684((uint64_t)WeakRetained, 6, 0);
        goto LABEL_27;
    }
  }
  if (*(_BYTE *)(a1 + 72) == 1)
    sub_100006244((uint64_t)WeakRetained);
  v6 = *(_QWORD *)(a1 + 32);
  v35 = (void *)NEIKEv2CreateSessionStateString(a2);
  sub_100004A40(WeakRetained, 3018, CFSTR("%@ session %@ got IKE error %@ with state %@"), v7, v8, v9, v10, v11, v6);

LABEL_6:
  if ((*(_QWORD *)(a1 + 64) & WeakRetained[6]) == 0)
    sub_1000064BC(WeakRetained, *(unsigned __int8 *)(a1 + 72));
LABEL_27:

}

void sub_100006228(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 72));
  _Unwind_Resume(a1);
}

void sub_100006244(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  char *v4;
  char *v5;
  id v6;
  id v7;
  int IsLevelEnabled;
  id v9;
  uint64_t v10;
  char *v11;
  int *v12;
  uint64_t v13;
  id v14;
  _QWORD v15[4];
  char *v16;
  id v17;
  id location;

  v2 = *(_QWORD *)(a1 + 40);
  if ((!v2 || !*(_BYTE *)(v2 + 8)) && (*(_BYTE *)(a1 + 48) & 8) == 0)
  {
    v3 = *(_QWORD *)(a1 + 112);
    if (!v3 || *(unsigned __int16 *)(v3 + 28) <= 0x12u)
    {
      if (*(_BYTE *)(a1 + 13))
      {
        *(_BYTE *)(a1 + 12) = 1;
        v4 = sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(a1 + 24));
        if (!v4)
        {
          v7 = sub_100004A00();
          IsLevelEnabled = _NRLogIsLevelEnabled(v7, 16);

          if (IsLevelEnabled)
          {
            v9 = sub_100004A00();
            _NRLogWithArgs(v9, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)", "", "-[NRPairingClient scheduleIKESessionClassADueToConnectFailure]", 661);

          }
          v10 = _os_log_pack_size(12);
          v11 = (char *)v15 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
          v12 = __error();
          v13 = _os_log_pack_fill(v11, v10, *v12, &_mh_execute_header, "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
          *(_DWORD *)v13 = 136446210;
          *(_QWORD *)(v13 + 4) = "-[NRPairingClient scheduleIKESessionClassADueToConnectFailure]";
          v14 = sub_100004A00();
          _NRLogAbortWithPack(v14, v11);
          __break(1u);
        }
        v5 = v4;
        if (!v4[14] && *((unsigned __int16 *)v4 + 14) <= 0x12u)
        {
          objc_initWeak(&location, (id)a1);
          v6 = sub_10014A154((uint64_t)NRDKeyManager);
          v15[0] = _NSConcreteStackBlock;
          v15[1] = 3221225472;
          v15[2] = sub_100007C88;
          v15[3] = &unk_1001B87F0;
          objc_copyWeak(&v17, &location);
          v16 = v5;
          sub_10014B110((uint64_t)v6, v15);

          objc_destroyWeak(&v17);
          objc_destroyWeak(&location);
        }

      }
      else
      {
        *(_BYTE *)(a1 + 13) = 1;
        sub_1000064BC(a1, 1);
      }
    }
  }
}

void sub_100006490(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 48));
  _Unwind_Resume(a1);
}

void sub_1000064BC(uint64_t a1, uint64_t a2)
{
  id *v4;
  uint64_t v5;
  uint64_t v6;
  id String;

  if ((*(_BYTE *)(a1 + 8) & 0xFE) != 6)
  {
    String = (id)NRDataProtectionClassCreateString(a2);
    v4 = (id *)sub_100005AFC(a1, a2);
    sub_100004AF0(a1, v4);
    if (qword_1001E44C8 != -1)
      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
    if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
    {
      if (qword_1001E44C8 != -1)
        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
      _NRLogWithArgs(qword_1001E44C0, 0, "%s%.30s:%-4d %@: Restarting %@ session", "", "-[NRPairingClient restartIKESessionForDataProtectionClass:]", 688, a1, String);
    }
    if ((_DWORD)a2 == 1)
    {
      if (*(_BYTE *)(a1 + 12))
      {
        if (qword_1001E44C8 != -1)
          dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
        if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
        {
          if (qword_1001E44C8 != -1)
            dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
          _NRLogWithArgs(qword_1001E44C0, 0, "%s%.30s:%-4d %@: Not restarting ClassA session because attempt failed once. Will retry at next unlock", "", "-[NRPairingClient restartIKESessionForDataProtectionClass:]", 691, a1);
        }
        goto LABEL_19;
      }
      v5 = a1;
      v6 = 1;
    }
    else
    {
      v5 = a1;
      v6 = a2;
    }
    sub_10000716C(v5, v6);
LABEL_19:

  }
}

void sub_100006684(uint64_t a1, int a2, char a3)
{
  uint64_t v6;
  char *v7;
  char *v8;
  char v9;
  BOOL v10;
  id *v11;
  id *v12;
  void *v13;
  id v14;
  id v15;
  NSObject *v16;
  id v17;
  id *v18;
  id v19;
  void *v20;
  id v21;
  id v22;
  id v23;
  uint64_t v24;
  void *i;
  uint64_t v26;
  NSObject *v27;
  id v28;
  const __CFString *v29;
  id v30;
  id v31;
  _QWORD block[4];
  id v33;
  char v34;
  char v35;
  _QWORD v36[5];
  char v37;
  char v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  _BYTE v43[128];

  if (!a1)
    return;
  v6 = *(_QWORD *)(a1 + 48);
  if (*(unsigned __int8 *)(a1 + 8) == a2 && v6 == *(_QWORD *)(a1 + 152))
    return;
  *(_BYTE *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 152) = v6;
  if (a2 == 7)
  {
    v7 = sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(a1 + 24));
    v8 = v7;
    if (!v7)
    {
LABEL_20:
      objc_opt_self(NRPairingClientManager);
      if (qword_1001E44F8 != -1)
        dispatch_once(&qword_1001E44F8, &stru_1001B5F00);
      v11 = (id *)(id)qword_1001E44F0;
      if (!v11
        || (v12 = v11,
            v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11[3], "objectForKeyedSubscript:", *(_QWORD *)(a1 + 24))),
            v14 = objc_msgSend(v13, "count"),
            v13,
            v12,
            !v14))
      {
        v28 = objc_alloc((Class)NSString);
        if ((a3 - 1) > 7u)
          v29 = CFSTR("None");
        else
          v29 = *(&off_1001B5DF8 + (a3 - 1));
        v30 = objc_msgSend(v28, "initWithFormat:", CFSTR("pairing client failed %@"), v29);
        sub_100136BA4((uint64_t)NRDLocalDevice, -2017, v30, *(void **)(a1 + 24));

LABEL_30:
        goto LABEL_31;
      }
LABEL_24:
      if (qword_1001E44C8 != -1)
        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
      if (_NRLogIsLevelEnabled(qword_1001E44C0, 17))
      {
        if (qword_1001E44C8 != -1)
          dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
        _NRLogWithArgs(qword_1001E44C0, 17, "%@: Pairing client failed while local device registered", a1);
      }
      goto LABEL_30;
    }
    if (v7[15])
    {
      v9 = 1;
      if (!v7[12])
        goto LABEL_19;
    }
    else
    {
      if (v7[14])
        v10 = 1;
      else
        v10 = *((unsigned __int16 *)v7 + 14) > 0x12u;
      v9 = v10;
      if (!v7[12])
        goto LABEL_19;
    }
    if (!v7[13])
      v9 = 0;
    if ((v9 & 1) != 0)
      goto LABEL_24;
LABEL_19:
    if (v7[8])
      goto LABEL_24;
    goto LABEL_20;
  }
LABEL_31:
  v15 = objc_retainBlock(*(id *)(a1 + 144));
  v16 = *(NSObject **)(a1 + 32);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100007154;
  block[3] = &unk_1001B5D40;
  v17 = v15;
  v33 = v17;
  v34 = a2;
  v35 = a3;
  dispatch_async(v16, block);
  if ((a2 - 5) <= 2 && !*(_BYTE *)(a1 + 11))
  {
    objc_opt_self(NRPairingClientManager);
    if (qword_1001E44F8 != -1)
      dispatch_once(&qword_1001E44F8, &stru_1001B5F00);
    v18 = (id *)(id)qword_1001E44F0;
    v19 = *(id *)(a1 + 24);
    if (v18)
    {
      objc_msgSend(v18[2], "setObject:forKeyedSubscript:", 0, v19);
      v31 = v19;
      v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18[3], "objectForKeyedSubscript:", v19));
      v39 = 0u;
      v40 = 0u;
      v41 = 0u;
      v42 = 0u;
      v21 = v20;
      v22 = objc_msgSend(v21, "countByEnumeratingWithState:objects:count:", &v39, v43, 16);
      if (v22)
      {
        v23 = v22;
        v24 = *(_QWORD *)v40;
        do
        {
          for (i = 0; i != v23; i = (char *)i + 1)
          {
            if (*(_QWORD *)v40 != v24)
              objc_enumerationMutation(v21);
            v26 = *(_QWORD *)(*((_QWORD *)&v39 + 1) + 8 * (_QWORD)i);
            if (v26)
              v27 = *(NSObject **)(v26 + 8);
            else
              v27 = 0;
            v36[0] = _NSConcreteStackBlock;
            v36[1] = 3221225472;
            v36[2] = sub_1000107B4;
            v36[3] = &unk_1001B8908;
            v36[4] = v26;
            v37 = a2;
            v38 = a3;
            dispatch_async(v27, v36);
          }
          v23 = objc_msgSend(v21, "countByEnumeratingWithState:objects:count:", &v39, v43, 16);
        }
        while (v23);
      }

      v19 = v31;
      objc_msgSend(v18[3], "setObject:forKeyedSubscript:", 0, v31);

    }
  }

}

void sub_100006AD0(uint64_t a1, int a2)
{
  uint64_t v4;
  id *v5;
  id v6;
  void *v7;
  void *v8;
  id v9;
  uint64_t v10;
  uint64_t v11;
  id v12;
  void *v13;
  void *v14;
  id v15;
  uint64_t v16;
  id v17;
  void *v18;
  void *v19;
  id v20;
  id *v21;

  if (a1)
  {
    v4 = *(_QWORD *)(a1 + 40);
    if (!v4 || !*(_BYTE *)(v4 + 8))
    {
      if (*(_BYTE *)(a1 + 14))
      {
        v5 = (id *)sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(a1 + 24));
        if (a2 != 4 || (*(_BYTE *)(a1 + 48) & 2) != 0)
        {
          v11 = *(_QWORD *)(a1 + 40);
          if (v11 && *(_BYTE *)(v11 + 14) && (*(_BYTE *)(a1 + 48) & 2) == 0)
            goto LABEL_37;
          if (a2 != 3 || (*(_BYTE *)(a1 + 48) & 4) != 0)
          {
            if (v11 && *(_BYTE *)(v11 + 14))
            {
              if (a2 != 1)
                goto LABEL_37;
              v16 = *(_QWORD *)(a1 + 48);
              if ((v16 & 4) == 0)
                goto LABEL_37;
            }
            else
            {
              if (a2 != 1)
              {
LABEL_37:

                return;
              }
              v16 = *(_QWORD *)(a1 + 48);
            }
            if ((v16 & 8) != 0)
              goto LABEL_37;
            v21 = v5;
            if (v5)
            {
              v17 = v5[11];
              v18 = v17;
              v19 = v17 ? (void *)*((_QWORD *)v17 + 1) : 0;
            }
            else
            {
              v18 = 0;
              v19 = 0;
            }
            v20 = v19;

            v5 = v21;
            if (!v20)
              goto LABEL_37;
            v10 = 1;
          }
          else
          {
            v21 = v5;
            if (v5)
            {
              v12 = v5[10];
              v13 = v12;
              if (v12)
                v14 = (void *)*((_QWORD *)v12 + 1);
              else
                v14 = 0;
            }
            else
            {
              v13 = 0;
              v14 = 0;
            }
            v15 = v14;

            v5 = v21;
            if (!v15)
              goto LABEL_37;
            v10 = 3;
          }
        }
        else
        {
          v21 = v5;
          if (v5)
          {
            v6 = v5[9];
            v7 = v6;
            if (v6)
              v8 = (void *)*((_QWORD *)v6 + 1);
            else
              v8 = 0;
          }
          else
          {
            v7 = 0;
            v8 = 0;
          }
          v9 = v8;

          v5 = v21;
          if (!v9)
            goto LABEL_37;
          v10 = 4;
        }
        sub_1000064BC(a1, v10);
        v5 = v21;
        goto LABEL_37;
      }
    }
  }
}

void sub_100006CA0(uint64_t a1)
{
  void *v2;
  void *v3;
  id v4;

  if (a1)
  {
    sub_100004AF0(a1, (id *)(a1 + 88));
    sub_100004AF0(a1, (id *)(a1 + 96));
    sub_100004AF0(a1, (id *)(a1 + 104));
    sub_100004AF0(a1, (id *)(a1 + 80));
    v2 = *(void **)(a1 + 72);
    if (v2)
    {
      objc_msgSend(v2, "cancel");
      v3 = *(void **)(a1 + 72);
      *(_QWORD *)(a1 + 72) = 0;

    }
    objc_opt_self(NRIKEv2Listener);
    if (qword_1001E44D8 != -1)
      dispatch_once(&qword_1001E44D8, &stru_1001B5E70);
    v4 = (id)qword_1001E44D0;
    sub_10000FF40((uint64_t)v4, (void *)a1);

  }
}

void sub_100006D60(uint64_t a1, int a2)
{
  _BYTE *WeakRetained;
  uint64_t v4;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained && (WeakRetained[8] & 0xFE) != 6)
  {
    v4 = (uint64_t)WeakRetained;
    if (a2)
    {
      if (qword_1001E44C8 != -1)
        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
      if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
      {
        if (qword_1001E44C8 != -1)
          dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
        _NRLogWithArgs(qword_1001E44C0, 0, "%s%.30s:%-4d %@: pairing ACK was received", "", "-[NRPairingClient finalizePairing]_block_invoke", 1238, v4);
      }
      sub_100006EE4(v4);
    }
    else
    {
      if (qword_1001E44C8 != -1)
        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
      if (_NRLogIsLevelEnabled(qword_1001E44C0, 16))
      {
        if (qword_1001E44C8 != -1)
          dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
        _NRLogWithArgs(qword_1001E44C0, 16, "%s%.30s:%-4d %@: pairing ACK was not received", "", "-[NRPairingClient finalizePairing]_block_invoke", 1242, v4);
      }
      sub_100006684(v4, 7, 7);
    }
    WeakRetained = (_BYTE *)v4;
  }

}

void sub_100006EE4(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  void *v4;
  id v5;
  uint64_t v6;
  id v7;
  void *v8;
  void *v9;
  id v10;
  unsigned __int16 *v11;

  if (qword_1001E44C8 != -1)
    dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
  if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
  {
    if (qword_1001E44C8 != -1)
      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
    _NRLogWithArgs(qword_1001E44C0, 0, "%s%.30s:%-4d %@: pairing completed", "", "-[NRPairingClient handlePairingComplete]", 1161, a1);
  }
  v2 = *(_QWORD *)(a1 + 48);
  if ((v2 & 2) != 0)
  {
    sub_1001364DC((uint64_t)NRDLocalDevice, 4, *(void **)(a1 + 24));
    v2 = *(_QWORD *)(a1 + 48);
    if ((v2 & 4) == 0)
    {
LABEL_9:
      if ((v2 & 8) == 0)
        goto LABEL_11;
      goto LABEL_10;
    }
  }
  else if ((v2 & 4) == 0)
  {
    goto LABEL_9;
  }
  sub_1001364DC((uint64_t)NRDLocalDevice, 3, *(void **)(a1 + 24));
  v2 = *(_QWORD *)(a1 + 48);
  if ((v2 & 8) != 0)
  {
LABEL_10:
    sub_1001364DC((uint64_t)NRDLocalDevice, 1, *(void **)(a1 + 24));
    v2 = *(_QWORD *)(a1 + 48);
  }
LABEL_11:
  *(_QWORD *)(a1 + 48) = v2 | 0x10;
  sub_100006684(a1, 5, 0);
  v3 = *(void **)(a1 + 72);
  if (v3)
  {
    objc_msgSend(v3, "cancel");
    v4 = *(void **)(a1 + 72);
    *(_QWORD *)(a1 + 72) = 0;

  }
  objc_opt_self(NRIKEv2Listener);
  if (qword_1001E44D8 != -1)
    dispatch_once(&qword_1001E44D8, &stru_1001B5E70);
  v5 = (id)qword_1001E44D0;
  sub_10000FF40((uint64_t)v5, (void *)a1);

  v11 = (unsigned __int16 *)sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(a1 + 24));
  if (!v11 || v11[14] < 0x10u || (v6 = *(_QWORD *)(a1 + 40)) == 0 || !*(_BYTE *)(v6 + 13))
  {
    sub_100004AF0(a1, (id *)(a1 + 80));
    sub_100004AF0(a1, (id *)(a1 + 88));
    sub_100004AF0(a1, (id *)(a1 + 96));
    sub_100004AF0(a1, (id *)(a1 + 104));
  }
  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v7 = (id)qword_1001E4708;
  v8 = v7;
  if (v7)
    v9 = (void *)*((_QWORD *)v7 + 6);
  else
    v9 = 0;
  v10 = v9;
  sub_100147674((uint64_t)v10, 0, *(void **)(a1 + 64));

}

uint64_t sub_100007154(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), *(unsigned __int8 *)(a1 + 40), *(unsigned __int8 *)(a1 + 41));
}

void sub_10000716C(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  id *v5;
  id *v6;
  void *String;
  char *v8;
  char *v9;
  id v10;
  id v11;
  id v12;
  uint64_t v13;
  void *v14;
  id v15;
  id v16;
  id v17;
  void *v18;
  id v19;
  void *v20;
  BOOL v21;
  void *v22;
  id v23;
  _BYTE *v24;
  BOOL v25;
  id v26;
  _BYTE *v27;
  BOOL v28;
  id v29;
  _QWORD *v30;
  _QWORD *v31;
  _QWORD *v32;
  _QWORD *v33;
  id v34;
  id v35;
  uint64_t v36;
  uint64_t v37;
  id v38;
  id v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  id v46;
  int v47;
  id v48;
  id v49;
  int IsLevelEnabled;
  id v51;
  unsigned int v52;
  id v53;
  void *v54;
  int v55;
  unsigned int v56;
  id v57;
  void *v58;
  int v59;
  unsigned int v60;
  id v61;
  void *v62;
  int v63;
  id v64;
  int v65;
  id v66;
  int v67;
  int v68;
  dispatch_time_t v69;
  void *v70;
  NSObject *v71;
  _QWORD *v72;
  id v73;
  id v74;
  id v75;
  void *v76;
  _QWORD block[4];
  id v78;
  char v79;
  id location;
  _QWORD v81[5];
  _QWORD v82[3];
  int v83;
  _QWORD v84[2];

  if ((*(_BYTE *)(a1 + 8) & 0xFE) != 6)
  {
    v4 = *(_QWORD *)(a1 + 40);
    if (!v4 || !*(_BYTE *)(v4 + 8))
    {
      v5 = (id *)sub_100005AFC(a1, a2);
      if (!*v5)
      {
        v6 = v5;
        String = (void *)NRDataProtectionClassCreateString(a2);
        v8 = sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(a1 + 24));
        v9 = v8;
        if (!v8)
        {
          v49 = sub_100004A00();
          IsLevelEnabled = _NRLogIsLevelEnabled(v49, 17);

          if (IsLevelEnabled)
          {
            v51 = sub_100004A00();
            _NRLogWithArgs(v51, 17, "%@: Not starting %@ IKE initiator session because localDevice is missing", a1, String);

          }
          sub_100006684(a1, 7, 3);
          goto LABEL_63;
        }
        if ((_DWORD)a2 == 1)
        {
          if (*((unsigned __int16 *)v8 + 14) > 0x12u)
          {
            if (qword_1001E44C8 != -1)
              dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
            if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
            {
              v10 = sub_100004A00();
              _NRLogWithArgs(v10, 0, "%s%.30s:%-4d %@: Not starting ClassA IKE initiator session because peer supports skipping ClassA pairing %@", "", "-[NRPairingClient setupIPsecInitiatorIfNecessary:]", 507, a1, v9);

            }
            goto LABEL_63;
          }
          v11 = *((id *)v8 + 11);
        }
        else
        {
          v11 = sub_100131288(v8, a2);
        }
        v12 = v11;

        if (!v12)
        {
          if (qword_1001E44C8 != -1)
            dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
          if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
          {
            v23 = sub_100004A00();
            _NRLogWithArgs(v23, 0, "%s%.30s:%-4d %@: Not starting %@ IKE initiator session because we do not have keys %@", "", "-[NRPairingClient setupIPsecInitiatorIfNecessary:]", 511, a1, String, v9);

          }
          sub_100006684(a1, 7, 8);
          goto LABEL_63;
        }
        v76 = sub_100112798(1, v9, a2);
        if ((_DWORD)a2 != 1)
        {
          v13 = *(_QWORD *)(a1 + 40);
          if (v13)
          {
            if (*(_BYTE *)(v13 + 11))
            {
              v14 = (void *)objc_claimAutoreleasedReturnValue(+[NWAddressEndpoint endpointWithHostname:port:](NWAddressEndpoint, "endpointWithHostname:port:", CFSTR("::"), CFSTR("0")));
              v15 = objc_alloc((Class)NEIKEv2ConfigurationMessage);
              v16 = objc_msgSend(objc_alloc((Class)NEIKEv2InitiatorTransportIPv6Address), "initWithAddress:", v14);
              v84[0] = v16;
              v17 = objc_msgSend(objc_alloc((Class)NEIKEv2ResponderTransportIPv6Address), "initWithAddress:", v14);
              v84[1] = v17;
              v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v84, 2));
              v19 = objc_msgSend(v15, "initWithWithAttributes:", v18);
              objc_msgSend(v76, "setConfigurationRequest:", v19);

            }
          }
        }
        v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v76, "customIKEAuthPrivateNotifies"));
        v21 = v20 == 0;

        if (v21)
        {
          v75 = objc_alloc_init((Class)NSMutableArray);
        }
        else
        {
          v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v76, "customIKEAuthPrivateNotifies"));
          v75 = objc_msgSend(v22, "mutableCopy");

        }
        if (objc_msgSend(v75, "count"))
          objc_msgSend(v76, "setCustomIKEAuthPrivateNotifies:", v75);
        v74 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("terminusIKE-NRPairing-%@"), String);
        v24 = *(id *)(a1 + 40);
        if (!v24 || (v25 = v24[9] == 0, v24, v25))
          v73 = 0;
        else
          v73 = (id)a1;
        v26 = sub_100112198();
        sub_100111E90(*(void **)(a1 + 112), v26);
        objc_msgSend(v26, "setRequestChildlessSA:", 1);
        v82[0] = 0;
        v82[1] = v82;
        v83 = 0;
        v82[2] = 0x2020000000;
        v27 = *(id *)(a1 + 40);
        if (!v27 || (v28 = v27[11] == 0, v27, v28))
        {
          v30 = *(_QWORD **)(a1 + 40);
          if (v30)
            v30 = (_QWORD *)v30[2];
          v31 = v30;
          objc_msgSend(v26, "setOutgoingInterfaceName:", v31);

          v32 = *(_QWORD **)(a1 + 40);
          if (v32)
            v32 = (_QWORD *)v32[3];
          v33 = v32;
          objc_msgSend(v26, "setRemoteEndpoint:", v33);

          objc_msgSend(v26, "setRandomizeLocalPort:", 1);
          v29 = sub_100112420();
          objc_msgSend(v29, "setMode:", 2);
          objc_msgSend(v29, "setReplayWindowSize:", 4);
          v81[0] = _NSConcreteStackBlock;
          v81[1] = 3221225472;
          v81[2] = sub_100007B70;
          v81[3] = &unk_1001B65E8;
          v81[4] = v82;
          v72 = objc_retainBlock(v81);
        }
        else
        {
          v29 = sub_100112420();
          objc_msgSend(v29, "setSequencePerTrafficClass:", 1);
          objc_msgSend(v29, "setReplayWindowSize:", 16);
          v72 = 0;
        }
        v34 = v26;
        if (qword_1001E4870 != -1)
          dispatch_once(&qword_1001E4870, &stru_1001B7BB0);
        if (byte_1001E4868)
        {
          objc_msgSend(v34, "setForceUDPEncapsulation:", 1);
          objc_msgSend(v34, "setRandomizeLocalPort:", 1);
        }

        v35 = objc_alloc((Class)NEIKEv2Session);
        v36 = *(_QWORD *)(a1 + 40);
        if (v36)
          v37 = *(_QWORD *)(v36 + 40);
        else
          v37 = 0;
        v38 = objc_msgSend(v35, "initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:kernelSASessionName:packetDelegate:", v34, v29, v76, *(_QWORD *)(a1 + 32), v37, v72, v74, v73);
        v39 = *v6;
        *v6 = v38;

        if (*v6)
        {
          switch((_DWORD)a2)
          {
            case 4:
              v45 = 17;
              break;
            case 3:
              v45 = 18;
              break;
            case 1:
              v45 = 19;
              break;
            default:
LABEL_55:
              sub_100004A40((_QWORD *)a1, 3015, CFSTR("%@ %@"), v40, v41, v42, v43, v44, (uint64_t)String);
              sub_100005C6C(a1, a2);
              if (qword_1001E44C8 != -1)
                dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
              v46 = (id)qword_1001E44C0;
              v47 = _NRLogIsLevelEnabled(v46, 0);

              if (v47)
              {
                if (qword_1001E44C8 != -1)
                  dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                v48 = (id)qword_1001E44C0;
                _NRLogWithArgs(v48, 0, "%s%.30s:%-4d %@: Connecting initiator %@ session %@", "", "-[NRPairingClient setupIPsecInitiatorIfNecessary:]", 637, a1, String, *v6);

              }
              objc_msgSend(*v6, "connect");
              goto LABEL_62;
          }
          *(_BYTE *)(a1 + v45) = 0;
          goto LABEL_55;
        }
        switch((_DWORD)a2)
        {
          case 3:
            v56 = ++*(_BYTE *)(a1 + 18);
            v57 = sub_100004A00();
            v58 = v57;
            if (v56 >= 3)
            {
              v59 = _NRLogIsLevelEnabled(v57, 17);

              if (v59)
                goto LABEL_79;
              goto LABEL_80;
            }
            v67 = _NRLogIsLevelEnabled(v57, 16);

            if (v67)
            {
              v66 = sub_100004A00();
              _NRLogWithArgs(v66, 16, "%s%.30s:%-4d %@: Failed to create initiator %@ IKE session", "", "-[NRPairingClient setupIPsecInitiatorIfNecessary:]", 588, a1, String);
              goto LABEL_87;
            }
            break;
          case 4:
            v52 = ++*(_BYTE *)(a1 + 17);
            v53 = sub_100004A00();
            v54 = v53;
            if (v52 >= 3)
            {
              v55 = _NRLogIsLevelEnabled(v53, 17);

              if (v55)
                goto LABEL_79;
              goto LABEL_80;
            }
            v65 = _NRLogIsLevelEnabled(v53, 16);

            if (v65)
            {
              v66 = sub_100004A00();
              _NRLogWithArgs(v66, 16, "%s%.30s:%-4d %@: Failed to create initiator %@ IKE session", "", "-[NRPairingClient setupIPsecInitiatorIfNecessary:]", 587, a1, String);
LABEL_87:

            }
            break;
          case 1:
            v60 = ++*(_BYTE *)(a1 + 19);
            v61 = sub_100004A00();
            v62 = v61;
            if (v60 >= 3)
            {
              v63 = _NRLogIsLevelEnabled(v61, 17);

              if (v63)
              {
LABEL_79:
                v64 = sub_100004A00();
                _NRLogWithArgs(v64, 17, "%@: Failed to create initiator %@ IKE session", a1, String);

              }
LABEL_80:
              sub_100006684(a1, 7, 6);
LABEL_62:
              _Block_object_dispose(v82, 8);

LABEL_63:
              return;
            }
            v68 = _NRLogIsLevelEnabled(v61, 16);

            if (v68)
            {
              v66 = sub_100004A00();
              _NRLogWithArgs(v66, 16, "%s%.30s:%-4d %@: Failed to create initiator %@ IKE session", "", "-[NRPairingClient setupIPsecInitiatorIfNecessary:]", 589, a1, String);
              goto LABEL_87;
            }
            break;
        }
        objc_initWeak(&location, (id)a1);
        v69 = dispatch_time(0x8000000000000000, 3000000000);
        v70 = *(void **)(a1 + 32);
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_100007BC0;
        block[3] = &unk_1001B7358;
        v71 = v70;
        objc_copyWeak(&v78, &location);
        v79 = a2;
        dispatch_after(v69, v71, block);

        objc_destroyWeak(&v78);
        objc_destroyWeak(&location);
        goto LABEL_62;
      }
    }
  }
}

void sub_100007B54(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 144), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100007B70(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;

  v9 = getpid();
  return NEHelperGetIKESocketWithResult(a3, a4, a5, v9, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

void sub_100007BC0(uint64_t a1)
{
  _BYTE *WeakRetained;
  int v3;
  _BYTE *v4;
  _BYTE *v5;
  _BYTE *v6;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained && (WeakRetained[8] & 0xFE) != 6)
  {
    v3 = *(unsigned __int8 *)(a1 + 40);
    if (v3 == 4)
    {
      if ((WeakRetained[48] & 2) != 0 || *((_QWORD *)WeakRetained + 11))
        goto LABEL_3;
      v4 = WeakRetained;
      sub_1000064BC(WeakRetained, 4);
      WeakRetained = v4;
      v3 = *(unsigned __int8 *)(a1 + 40);
    }
    if (v3 == 3)
    {
      if ((WeakRetained[48] & 4) != 0 || *((_QWORD *)WeakRetained + 12))
        goto LABEL_3;
      v5 = WeakRetained;
      sub_1000064BC(WeakRetained, 3);
      WeakRetained = v5;
      v3 = *(unsigned __int8 *)(a1 + 40);
    }
    if (v3 == 1 && (WeakRetained[48] & 8) == 0 && !*((_QWORD *)WeakRetained + 13))
    {
      v6 = WeakRetained;
      sub_1000064BC(WeakRetained, 1);
      WeakRetained = v6;
    }
  }
LABEL_3:

}

void sub_100007C88(uint64_t a1)
{
  void **WeakRetained;
  void **v3;
  char *v4;
  char *v5;
  uint64_t v6;
  id v7;
  int IsLevelEnabled;
  id v9;
  uint64_t v10;
  char *v11;
  int *v12;
  uint64_t v13;
  id v14;
  void **v15;

  WeakRetained = (void **)objc_loadWeakRetained((id *)(a1 + 40));
  v3 = WeakRetained;
  if (WeakRetained && ((_BYTE)WeakRetained[1] & 0xFE) != 6)
  {
    *((_BYTE *)WeakRetained + 12) = 0;
    v15 = WeakRetained;
    v4 = sub_10012FFF4((uint64_t)NRDLocalDevice, WeakRetained[3]);
    if (!v4)
    {
      v7 = sub_100004A00();
      IsLevelEnabled = _NRLogIsLevelEnabled(v7, 16);

      if (IsLevelEnabled)
      {
        v9 = sub_100004A00();
        _NRLogWithArgs(v9, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice2) != ((void *)0)", "", "-[NRPairingClient scheduleIKESessionClassADueToConnectFailure]_block_invoke", 675);

      }
      v10 = _os_log_pack_size(12);
      v11 = (char *)&v15 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
      v12 = __error();
      v13 = _os_log_pack_fill(v11, v10, *v12, &_mh_execute_header, "%{public}s Assertion Failed: (localDevice2) != ((void *)0)");
      *(_DWORD *)v13 = 136446210;
      *(_QWORD *)(v13 + 4) = "-[NRPairingClient scheduleIKESessionClassADueToConnectFailure]_block_invoke";
      v14 = sub_100004A00();
      _NRLogAbortWithPack(v14, v11);
    }
    v5 = v4;
    if (!v4[14])
    {
      v6 = *(_QWORD *)(a1 + 32);
      if (!v6 || *(unsigned __int16 *)(v6 + 28) <= 0x12u)
        sub_1000064BC(v15, 1);
    }

    v3 = v15;
  }

}

void sub_100007E0C(id *a1, int a2, void *a3)
{
  id v6;
  id v7;
  id v8;

  if (a1)
  {
    v6 = a1[3];
    v7 = a3;
    v8 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "description"));
    sub_100121E18(v6, a2, v8, v7);

  }
}

void sub_100007E8C(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;
  _QWORD *WeakRetained;
  uint64_t v7;
  uint64_t v8;
  id v9;
  void *SessionStateString;
  unsigned int v11;
  uint64_t v12;
  id v13;
  id v14;
  id v15;
  id v16;
  char *v17;
  id v18;
  id v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  _QWORD v24[4];
  id v25;
  id location[5];

  v5 = a3;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v7 = (uint64_t)WeakRetained;
  if (WeakRetained)
  {
    if (v5)
    {
      if (qword_1001E44C8 != -1)
        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
      if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
      {
        if (qword_1001E44C8 != -1)
          dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
        v8 = *(_QWORD *)(a1 + 32);
        v9 = (id)qword_1001E44C0;
        SessionStateString = (void *)NEIKEv2CreateSessionStateString(a2);
        _NRLogWithArgs(v9, 0, "%s%.30s:%-4d %@: pairing session %@ got IKE error %@ with state %@", "", "-[NRPairingClient setupIKECallbacksPairing]_block_invoke", 946, v7, v8, v5, SessionStateString);

      }
      if ((*(_BYTE *)(v7 + 48) & 0x10) == 0 && (*(_BYTE *)(v7 + 8) & 0xFE) != 6)
      {
        sub_100004AF0(v7, (id *)(v7 + 88));
        sub_100004AF0(v7, (id *)(v7 + 96));
        sub_100004AF0(v7, (id *)(v7 + 104));
        v11 = ++*(_BYTE *)(v7 + 9);
        if (v11 < 2)
        {
          v22 = *(_QWORD *)(v7 + 40);
          if (!v22 || !*(_BYTE *)(v22 + 8))
          {
            sub_100004AF0(v7, (id *)(v7 + 80));
            v23 = *(void **)(v7 + 24);
            location[0] = _NSConcreteStackBlock;
            location[1] = (id)3221225472;
            location[2] = sub_10000B364;
            location[3] = &unk_1001B5D90;
            location[4] = (id)v7;
            sub_1001385D4((uint64_t)NRDLocalDevice, v23, 4, location);
          }
        }
        else
        {
          sub_100006684(v7, 7, 4);
        }
      }
    }
    else
    {
      switch(a2)
      {
        case 3:
          if (qword_1001E44C8 != -1)
            dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
          if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
          {
            if (qword_1001E44C8 != -1)
              dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
            _NRLogWithArgs(qword_1001E44C0, 0, "%s%.30s:%-4d %@: pairing session IKE disconnected %@ ", "", "-[NRPairingClient setupIKECallbacksPairing]_block_invoke", 1026, v7, *(_QWORD *)(a1 + 32));
          }
          break;
        case 2:
          WeakRetained[6] |= 1uLL;
          sub_100006684((uint64_t)WeakRetained, 3, 0);
          v12 = *(_QWORD *)(v7 + 40);
          if (!v12 || !*(_BYTE *)(v12 + 8))
          {
            v13 = objc_alloc_init((Class)NSMutableArray);
            if (*(_QWORD *)(v7 + 120))
            {
              sub_100007E0C((id *)v7, 3400, CFSTR("ClassD"));
              v14 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50411, *(_QWORD *)(v7 + 120));
              objc_msgSend(v13, "addObject:", v14);
              sub_10000B18C(v7);

            }
            if (*(_QWORD *)(v7 + 128))
            {
              sub_100007E0C((id *)v7, 3400, CFSTR("ClassC"));
              v15 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50412, *(_QWORD *)(v7 + 128));
              objc_msgSend(v13, "addObject:", v15);
              sub_10000B198(v7);

            }
            if (*(_QWORD *)(v7 + 136))
            {
              sub_100007E0C((id *)v7, 3400, CFSTR("ClassA"));
              v16 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50413, *(_QWORD *)(v7 + 136));
              objc_msgSend(v13, "addObject:", v16);
              sub_10000B1A4(v7);

            }
            if (objc_msgSend(v13, "count"))
            {
              if (_os_feature_enabled_impl("terminus", "EncryptedIdentity"))
              {
                v17 = sub_100138520((uint64_t)NRDLocalDevice, *(void **)(v7 + 24));
                if (v17)
                {
                  sub_100007E0C((id *)v7, 3400, CFSTR("Identity"));
                  v18 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50351, v17);
                  objc_msgSend(v13, "addObject:", v18);

                }
              }
              v19 = sub_100005460(v7, 0);
              objc_msgSend(v13, "addObjectsFromArray:", v19);

              objc_initWeak(location, (id)v7);
              v20 = *(void **)(v7 + 80);
              v21 = *(_QWORD *)(v7 + 32);
              v24[0] = _NSConcreteStackBlock;
              v24[1] = 3221225472;
              v24[2] = sub_10000B1B0;
              v24[3] = &unk_1001B7978;
              objc_copyWeak(&v25, location);
              objc_msgSend(v20, "sendPrivateNotifies:maxRetries:retryIntervalInMilliseconds:callbackQueue:callback:", v13, 10, 3000, v21, v24);
              objc_destroyWeak(&v25);
              objc_destroyWeak(location);
            }

          }
          break;
        case 1:
          sub_100006684((uint64_t)WeakRetained, 2, 0);
          break;
      }
    }
  }

}

void sub_100008380(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 88));
  _Unwind_Resume(a1);
}

void sub_10000839C(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id WeakRetained;
  id v7;
  void *SessionStateString;
  const char *v9;
  id v10;

  v10 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    if (v10)
    {
      if (qword_1001E44C8 != -1)
        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
      if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
      {
        if (qword_1001E44C8 != -1)
          dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
        v7 = (id)qword_1001E44C0;
        SessionStateString = (void *)NEIKEv2CreateSessionStateString(a3);
        v9 = "%s%.30s:%-4d %@: pairing session %@ got child %u state update %@ error %@";
LABEL_15:
        _NRLogWithArgs(v7, 0, v9);

      }
    }
    else
    {
      if (qword_1001E44C8 != -1)
        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
      if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
      {
        if (qword_1001E44C8 != -1)
          dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
        v7 = (id)qword_1001E44C0;
        SessionStateString = (void *)NEIKEv2CreateSessionStateString(a3);
        v9 = "%s%.30s:%-4d %@: pairing session %@ got child %u state update %@";
        goto LABEL_15;
      }
    }
  }

}

void sub_100008564(uint64_t a1, void *a2)
{
  id WeakRetained;
  id v4;

  v4 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    if (qword_1001E44C8 != -1)
      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
    if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
    {
      if (qword_1001E44C8 != -1)
        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
      _NRLogWithArgs(qword_1001E44C0, 0, "%s%.30s:%-4d %@: pairing session %@ got config update %@", "", "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_4", 1052, WeakRetained, *(_QWORD *)(a1 + 32), v4);
    }
  }

}

void sub_10000864C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v7;
  id WeakRetained;
  id v9;

  v9 = a3;
  v7 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    if (qword_1001E44C8 != -1)
      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
    if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
    {
      if (qword_1001E44C8 != -1)
        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
      _NRLogWithArgs(qword_1001E44C0, 0, "%s%.30s:%-4d %@: pairing session %@ got child %u traffic selector update local %@ remote %@", "", "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_5", 1063, WeakRetained, *(_QWORD *)(a1 + 32), a2, v9, v7);
    }
  }

}

void sub_100008758(uint64_t a1, void *a2)
{
  id WeakRetained;
  id v4;

  v4 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    if (qword_1001E44C8 != -1)
      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
    if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
    {
      if (qword_1001E44C8 != -1)
        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
      _NRLogWithArgs(qword_1001E44C0, 0, "%s%.30s:%-4d %@: pairing session %@ got additional addresses %@", "", "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_6", 1072, WeakRetained, *(_QWORD *)(a1 + 32), v4);
    }
  }

}

void sub_100008840(uint64_t a1)
{
  id WeakRetained;
  void *v3;
  int IsLevelEnabled;
  id v5;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v3 = WeakRetained;
  if (WeakRetained)
  {
    v5 = WeakRetained;
    if (qword_1001E44C8 != -1)
      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
    IsLevelEnabled = _NRLogIsLevelEnabled(qword_1001E44C0, 0);
    v3 = v5;
    if (IsLevelEnabled)
    {
      if (qword_1001E44C8 != -1)
      {
        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
        v3 = v5;
      }
      _NRLogWithArgs(qword_1001E44C0, 0, "%s%.30s:%-4d %@: pairing session %@ got short DPD", "", "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_7", 1080, v3, *(_QWORD *)(a1 + 32));
      v3 = v5;
    }
  }

}

void sub_100008924(uint64_t a1, void *a2)
{
  id v3;
  id *WeakRetained;
  id v5;
  void *v6;
  void *v7;
  id v8;
  id v9;
  id v10;
  uint64_t v11;
  void *i;
  id v13;
  void *v14;
  void *v15;
  id v16;
  id *v17;
  void *v18;
  id v19;
  void *v20;
  void *v21;
  id v22;
  id v23;
  void *v24;
  void *v25;
  id v26;
  id v27;
  void *v28;
  void *v29;
  id v30;
  id v31;
  id v32;
  unsigned int v33;
  char *v34;
  id v35;
  int IsLevelEnabled;
  id v37;
  unsigned __int8 *v38;
  int v39;
  id v40;
  int v41;
  id v42;
  id v43;
  int v44;
  id v45;
  unsigned __int8 *v46;
  int v47;
  unsigned __int8 *v48;
  int v49;
  id v50;
  int v51;
  unsigned __int8 *v52;
  int v53;
  id v54;
  int v55;
  unsigned __int8 *v56;
  int v57;
  id v58;
  int v59;
  id v60;
  id v61;
  int v62;
  id v63;
  id v64;
  id v65;
  int v66;
  id v67;
  id v68;
  int v69;
  id v70;
  uint64_t v71;
  void *v72;
  int v73;
  uint64_t v74;
  void *v75;
  void *v76;
  id v77;
  int v78;
  id v79;
  id v80;
  id v81;
  int v82;
  id v83;
  int v84;
  id v85;
  int v86;
  id v87;
  int v88;
  id v89;
  int v90;
  int v91;
  id v92;
  int v93;
  id v94;
  uint64_t v95;
  void *v96;
  int v97;
  id v98;
  int v99;
  uint64_t v100;
  int v101;
  id v102;
  int v103;
  uint64_t v104;
  int v105;
  id v106;
  int v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  void *v114;
  id v115;
  _QWORD v116[4];
  id *v117;
  _QWORD v118[4];
  id *v119;
  _QWORD v120[4];
  id *v121;
  _QWORD v122[4];
  id *v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  char *v128;
  uint64_t v129;
  _BYTE v130[128];
  id v131;

  v3 = a2;
  WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    v5 = objc_msgSend(objc_alloc((Class)NSSortDescriptor), "initWithKey:ascending:", CFSTR("notifyStatus"), 1);
    v131 = v5;
    v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v131, 1));
    v115 = v3;
    v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "sortedArrayUsingDescriptors:", v6));

    v114 = v5;
    if (qword_1001E44C8 != -1)
      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
    if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
    {
      if (qword_1001E44C8 != -1)
        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
      _NRLogWithArgs(qword_1001E44C0, 0, "%s%.30s:%-4d %@: pairing session %@ got private notifies %@", "", "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_8", 1092, WeakRetained, *(_QWORD *)(a1 + 32), v7, v5);
    }
    v126 = 0u;
    v127 = 0u;
    v124 = 0u;
    v125 = 0u;
    v8 = v7;
    v9 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v124, v130, 16);
    if (v9)
    {
      v10 = v9;
      v11 = *(_QWORD *)v125;
      do
      {
        for (i = 0; i != v10; i = (char *)i + 1)
        {
          if (*(_QWORD *)v125 != v11)
            objc_enumerationMutation(v8);
          v18 = *(void **)(*((_QWORD *)&v124 + 1) + 8 * (_QWORD)i);
          if (objc_msgSend(v18, "notifyStatus") == 50351)
          {
            v13 = WeakRetained[3];
            v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "description"));
            sub_100121E18(v13, 3401, v14, CFSTR("Identity"));

            v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "notifyData"));
            v16 = WeakRetained[3];
            v122[0] = _NSConcreteStackBlock;
            v122[1] = 3221225472;
            v122[2] = sub_10000A3D8;
            v122[3] = &unk_1001B6B48;
            v123 = WeakRetained;
            sub_100139818((uint64_t)NRDLocalDevice, v15, v16, v122);

            v17 = v123;
            goto LABEL_13;
          }
          if (objc_msgSend(v18, "notifyStatus") == 50411)
          {
            v19 = WeakRetained[3];
            v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "description"));
            sub_100121E18(v19, 3401, v20, CFSTR("ClassD"));

            v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "notifyData"));
            v22 = WeakRetained[3];
            v120[0] = _NSConcreteStackBlock;
            v120[1] = 3221225472;
            v120[2] = sub_10000A698;
            v120[3] = &unk_1001B6B48;
            v121 = WeakRetained;
            sub_100139B60((uint64_t)NRDLocalDevice, v21, v22, v120);

            v17 = v121;
            goto LABEL_13;
          }
          if (objc_msgSend(v18, "notifyStatus") == 50412)
          {
            v23 = WeakRetained[3];
            v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "description"));
            sub_100121E18(v23, 3401, v24, CFSTR("ClassC"));

            v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "notifyData"));
            v26 = WeakRetained[3];
            v118[0] = _NSConcreteStackBlock;
            v118[1] = 3221225472;
            v118[2] = sub_10000AA40;
            v118[3] = &unk_1001B6B48;
            v119 = WeakRetained;
            sub_100139EF8((uint64_t)NRDLocalDevice, v25, v26, v118);

            v17 = v119;
            goto LABEL_13;
          }
          if (objc_msgSend(v18, "notifyStatus") == 50413)
          {
            v27 = WeakRetained[3];
            v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "description"));
            sub_100121E18(v27, 3401, v28, CFSTR("ClassA"));

            v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "notifyData"));
            v30 = WeakRetained[3];
            v116[0] = _NSConcreteStackBlock;
            v116[1] = 3221225472;
            v116[2] = sub_10000ADE8;
            v116[3] = &unk_1001B6B48;
            v117 = WeakRetained;
            sub_10013A37C((uint64_t)NRDLocalDevice, v29, v30, v116);

            v17 = v117;
            goto LABEL_13;
          }
          v31 = objc_msgSend(v18, "notifyStatus");
          v17 = (id *)(id)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "notifyData"));
          if (((_BYTE)WeakRetained[1] & 0xFE) != 6)
          {
            if (qword_1001E44C8 != -1)
              dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
            if ((_NRLogIsLevelEnabled(qword_1001E44C0, 0) & 1) != 0)
            {
              if (qword_1001E44C8 != -1)
                dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
              v32 = (id)qword_1001E44C0;
              _NRLogWithArgs(v32, 0, "%s%.30s:%-4d %@: Received notify code %u len %llu", "", "-[NRPairingClient handleNotifyCode:payload:]", 1338, WeakRetained, v31, objc_msgSend(v17, "length"));

            }
            if ((int)v31 <= 50500)
            {
              if ((int)v31 <= 50350)
              {
                switch((int)v31)
                {
                  case 48601:
                  case 48607:
                    goto LABEL_79;
                  case 48602:
                    LOWORD(v128) = 0;
                    if ((unint64_t)objc_msgSend(v17, "length") >= 2)
                    {
                      objc_msgSend(v17, "getBytes:length:", &v128, 2);
                      v33 = (unsigned __int16)v128;
                      if (qword_1001E44C8 != -1)
                        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                      v34 = (char *)(bswap32(v33) >> 16);
                      v35 = (id)qword_1001E44C0;
                      IsLevelEnabled = _NRLogIsLevelEnabled(v35, 0);

                      if (IsLevelEnabled)
                      {
                        if (qword_1001E44C8 != -1)
                          dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                        v37 = (id)qword_1001E44C0;
                        _NRLogWithArgs(v37, 0, "%s%.30s:%-4d %@: Received remote terminus version %u", "", "-[NRPairingClient handleNotifyCode:payload:]", 1351, WeakRetained, v34);

                      }
                      sub_10013BBC0((uint64_t)NRDLocalDevice, v34, WeakRetained[3]);
                    }
                    goto LABEL_85;
                  case 48603:
                    v60 = objc_msgSend(objc_alloc((Class)NSString), "initWithData:encoding:", v17, 4);
                    if (qword_1001E44C8 != -1)
                      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                    v61 = (id)qword_1001E44C0;
                    v62 = _NRLogIsLevelEnabled(v61, 0);

                    if (v62)
                    {
                      if (qword_1001E44C8 != -1)
                        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                      v63 = (id)qword_1001E44C0;
                      _NRLogWithArgs(v63, 0, "%s%.30s:%-4d %@: Received remote device name \"%@\"", "", "-[NRPairingClient handleNotifyCode:payload:]", 1357, WeakRetained, v60);

                    }
                    sub_10013BF60((uint64_t)NRDLocalDevice, v60, WeakRetained[3]);

                    goto LABEL_85;
                  case 48604:
                    v64 = objc_msgSend(objc_alloc((Class)NSString), "initWithData:encoding:", v17, 4);
                    if (qword_1001E44C8 != -1)
                      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                    v65 = (id)qword_1001E44C0;
                    v66 = _NRLogIsLevelEnabled(v65, 0);

                    if (v66)
                    {
                      if (qword_1001E44C8 != -1)
                        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                      v67 = (id)qword_1001E44C0;
                      _NRLogWithArgs(v67, 0, "%s%.30s:%-4d %@: Received remote build version \"%@\"", "", "-[NRPairingClient handleNotifyCode:payload:]", 1363, WeakRetained, v64);

                    }
                    sub_10013C194((uint64_t)NRDLocalDevice, v64, WeakRetained[3]);

                    goto LABEL_85;
                  case 48605:
                    v128 = 0;
                    if (objc_msgSend(v17, "length") == (id)8)
                    {
                      objc_msgSend(v17, "getBytes:length:", &v128, 8);
                      if (qword_1001E44C8 != -1)
                        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                      v68 = (id)qword_1001E44C0;
                      v69 = _NRLogIsLevelEnabled(v68, 0);

                      if (v69)
                      {
                        if (qword_1001E44C8 != -1)
                          dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                        v70 = (id)qword_1001E44C0;
                        _NRLogWithArgs(v70, 0, "%s%.30s:%-4d %@: Received remote device flags \"%llu\"", "", "-[NRPairingClient handleNotifyCode:payload:]", 1382, WeakRetained, v128);

                      }
                      sub_10013CA58((uint64_t)NRDLocalDevice, v128, WeakRetained[3]);
                      goto LABEL_143;
                    }
                    if (qword_1001E44C8 != -1)
                      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                    v81 = (id)qword_1001E44C0;
                    v82 = _NRLogIsLevelEnabled(v81, 16);

                    if (!v82)
                      goto LABEL_85;
                    if (qword_1001E44C8 != -1)
                      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                    v42 = (id)qword_1001E44C0;
                    _NRLogWithArgs(v42, 16, "%s%.30s:%-4d %@: Invalid NRLinkIKEPrivateNotifyCodeDeviceFlags payload length %zu", "", "-[NRPairingClient handleNotifyCode:payload:]", 1378, WeakRetained, objc_msgSend(v17, "length"));
                    break;
                  case 48606:
                    LOBYTE(v128) = 0;
                    if (objc_msgSend(v17, "length") == (id)1)
                    {
                      objc_msgSend(v17, "getBytes:length:", &v128, 1);
                      v72 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[3], v71);
                      v73 = _NRLogIsLevelEnabled(v72, 0);

                      if (v73)
                      {
                        v75 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[3], v74);
                        v76 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "description"));
                        _NRLogWithArgs(v75, 0, "%s%.30s:%-4d %@: Received remote device type %u", "", "-[NRPairingClient handleNotifyCode:payload:]", 1371, v76, v128);

                      }
                      sub_10013BD90((uint64_t)NRDLocalDevice, (char *)v128, WeakRetained[3]);
                    }
                    goto LABEL_85;
                  default:
                    if (!(_DWORD)v31)
                      goto LABEL_79;
                    if ((_DWORD)v31 != 48701)
                      goto LABEL_143;
                    LOBYTE(v128) = 0;
                    if (objc_msgSend(v17, "length"))
                      objc_msgSend(v17, "getBytes:length:", &v128, 1);
                    goto LABEL_85;
                }
LABEL_183:

                goto LABEL_85;
              }
              if (((_DWORD)v31 - 50351) > 0x3E
                || ((1 << (v31 + 81)) & 0x701C000000000003) == 0)
              {
                goto LABEL_143;
              }
              goto LABEL_79;
            }
            if ((int)v31 > 50800)
            {
              if ((int)v31 <= 51300)
              {
                switch((int)v31)
                {
                  case 50801:
                    v38 = (unsigned __int8 *)WeakRetained[5];
                    if (v38 && (v39 = v38[8], v38, v39))
                    {
                      if (qword_1001E44C8 != -1)
                        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                      v40 = (id)qword_1001E44C0;
                      v41 = _NRLogIsLevelEnabled(v40, 16);

                      if (v41)
                      {
                        if (qword_1001E44C8 != -1)
                          dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                        v42 = (id)qword_1001E44C0;
                        _NRLogWithArgs(v42, 16, "%s%.30s:%-4d %@: Did not expect InnerAddressInitiatorClassD as responder", "", "-[NRPairingClient handleNotifyCode:payload:]", 1418, WeakRetained, v113);
                        goto LABEL_183;
                      }
                    }
                    else
                    {
                      v128 = 0;
                      v129 = 0;
                      if ((unint64_t)objc_msgSend(v17, "length") > 0xF)
                      {
                        objc_msgSend(v17, "getBytes:length:", &v128, 16);
                        v91 = sub_10013D69C((uint64_t)NRDLocalDevice, (uint64_t)&v128, WeakRetained[3]);
                        if (qword_1001E44C8 != -1)
                          dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                        v92 = (id)qword_1001E44C0;
                        v93 = _NRLogIsLevelEnabled(v92, 0);

                        if (v91)
                        {
                          if (!v93)
                            goto LABEL_85;
                          v94 = sub_100004A00();
                          v96 = (void *)createIPv6AddrString(&v128, v95);
                          _NRLogWithArgs(v94, 0, "%s%.30s:%-4d %@: updated local device with local addresses %@ (classD)", "", "-[NRPairingClient handleNotifyCode:payload:]", 1428, WeakRetained, v96);
                        }
                        else
                        {
                          if (!v93)
                            goto LABEL_85;
                          v94 = sub_100004A00();
                          v96 = (void *)createIPv6AddrString(&v128, v109);
                          _NRLogWithArgs(v94, 0, "%s%.30s:%-4d %@: received local classD address %@", "", "-[NRPairingClient handleNotifyCode:payload:]", 1430, WeakRetained, v96);
                        }
                        goto LABEL_212;
                      }
                      if (qword_1001E44C8 != -1)
                        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                      v83 = (id)qword_1001E44C0;
                      v84 = _NRLogIsLevelEnabled(v83, 16);

                      if (v84)
                      {
                        if (qword_1001E44C8 != -1)
                          dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                        v42 = (id)qword_1001E44C0;
                        _NRLogWithArgs(v42, 16, "%s%.30s:%-4d %@: InnerAddressInitiatorClassD payload too short %@", "", "-[NRPairingClient handleNotifyCode:payload:]", 1423, WeakRetained, v17);
                        goto LABEL_183;
                      }
                    }
                    goto LABEL_85;
                  case 50802:
                    v48 = (unsigned __int8 *)WeakRetained[5];
                    if (v48 && (v49 = v48[8], v48, v49))
                    {
                      if (qword_1001E44C8 != -1)
                        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                      v50 = (id)qword_1001E44C0;
                      v51 = _NRLogIsLevelEnabled(v50, 16);

                      if (v51)
                      {
                        if (qword_1001E44C8 != -1)
                          dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                        v42 = (id)qword_1001E44C0;
                        _NRLogWithArgs(v42, 16, "%s%.30s:%-4d %@: Did not expect InnerAddressResponderClassD as responder", "", "-[NRPairingClient handleNotifyCode:payload:]", 1454, WeakRetained, v113);
                        goto LABEL_183;
                      }
                    }
                    else
                    {
                      v128 = 0;
                      v129 = 0;
                      if ((unint64_t)objc_msgSend(v17, "length") > 0xF)
                      {
                        objc_msgSend(v17, "getBytes:length:", &v128, 16);
                        v97 = sub_10013DEEC((uint64_t)NRDLocalDevice, (uint64_t)&v128, WeakRetained[3]);
                        if (qword_1001E44C8 != -1)
                          dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                        v98 = (id)qword_1001E44C0;
                        v99 = _NRLogIsLevelEnabled(v98, 0);

                        if (v97)
                        {
                          if (!v99)
                            goto LABEL_85;
                          v94 = sub_100004A00();
                          v96 = (void *)createIPv6AddrString(&v128, v100);
                          _NRLogWithArgs(v94, 0, "%s%.30s:%-4d %@: updated local device with remote addresses %@ (classD)", "", "-[NRPairingClient handleNotifyCode:payload:]", 1464, WeakRetained, v96);
                        }
                        else
                        {
                          if (!v99)
                            goto LABEL_85;
                          v94 = sub_100004A00();
                          v96 = (void *)createIPv6AddrString(&v128, v110);
                          _NRLogWithArgs(v94, 0, "%s%.30s:%-4d %@: received remote classD address %@", "", "-[NRPairingClient handleNotifyCode:payload:]", 1466, WeakRetained, v96);
                        }
                        goto LABEL_212;
                      }
                      if (qword_1001E44C8 != -1)
                        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                      v85 = (id)qword_1001E44C0;
                      v86 = _NRLogIsLevelEnabled(v85, 16);

                      if (v86)
                      {
                        if (qword_1001E44C8 != -1)
                          dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                        v42 = (id)qword_1001E44C0;
                        _NRLogWithArgs(v42, 16, "%s%.30s:%-4d %@: InnerAddressResponderClassD payload too short %@", "", "-[NRPairingClient handleNotifyCode:payload:]", 1459, WeakRetained, v17);
                        goto LABEL_183;
                      }
                    }
                    goto LABEL_85;
                  case 50803:
                  case 50804:
                  case 50805:
                  case 50806:
                  case 50807:
                  case 50808:
                  case 50809:
                  case 50810:
                    goto LABEL_143;
                  case 50811:
                    v52 = (unsigned __int8 *)WeakRetained[5];
                    if (v52 && (v53 = v52[8], v52, v53))
                    {
                      if (qword_1001E44C8 != -1)
                        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                      v54 = (id)qword_1001E44C0;
                      v55 = _NRLogIsLevelEnabled(v54, 16);

                      if (v55)
                      {
                        if (qword_1001E44C8 != -1)
                          dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                        v42 = (id)qword_1001E44C0;
                        _NRLogWithArgs(v42, 16, "%s%.30s:%-4d %@: Did not expect InnerAddressInitiatorClassC as responder", "", "-[NRPairingClient handleNotifyCode:payload:]", 1436, WeakRetained, v113);
                        goto LABEL_183;
                      }
                    }
                    else
                    {
                      v128 = 0;
                      v129 = 0;
                      if ((unint64_t)objc_msgSend(v17, "length") > 0xF)
                      {
                        objc_msgSend(v17, "getBytes:length:", &v128, 16);
                        v101 = sub_10013DAC4((uint64_t)NRDLocalDevice, (uint64_t)&v128, WeakRetained[3]);
                        if (qword_1001E44C8 != -1)
                          dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                        v102 = (id)qword_1001E44C0;
                        v103 = _NRLogIsLevelEnabled(v102, 0);

                        if (v101)
                        {
                          if (!v103)
                            goto LABEL_85;
                          v94 = sub_100004A00();
                          v96 = (void *)createIPv6AddrString(&v128, v104);
                          _NRLogWithArgs(v94, 0, "%s%.30s:%-4d %@: updated local device with local addresses %@ (classC)", "", "-[NRPairingClient handleNotifyCode:payload:]", 1446, WeakRetained, v96);
                        }
                        else
                        {
                          if (!v103)
                            goto LABEL_85;
                          v94 = sub_100004A00();
                          v96 = (void *)createIPv6AddrString(&v128, v111);
                          _NRLogWithArgs(v94, 0, "%s%.30s:%-4d %@: received local classC address %@", "", "-[NRPairingClient handleNotifyCode:payload:]", 1448, WeakRetained, v96);
                        }
                        goto LABEL_212;
                      }
                      if (qword_1001E44C8 != -1)
                        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                      v87 = (id)qword_1001E44C0;
                      v88 = _NRLogIsLevelEnabled(v87, 16);

                      if (v88)
                      {
                        if (qword_1001E44C8 != -1)
                          dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                        v42 = (id)qword_1001E44C0;
                        _NRLogWithArgs(v42, 16, "%s%.30s:%-4d %@: InnerAddressInitiatorClassC payload too short %@", "", "-[NRPairingClient handleNotifyCode:payload:]", 1441, WeakRetained, v17);
                        goto LABEL_183;
                      }
                    }
                    goto LABEL_85;
                  case 50812:
                    v56 = (unsigned __int8 *)WeakRetained[5];
                    if (v56 && (v57 = v56[8], v56, v57))
                    {
                      if (qword_1001E44C8 != -1)
                        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                      v58 = (id)qword_1001E44C0;
                      v59 = _NRLogIsLevelEnabled(v58, 16);

                      if (v59)
                      {
                        if (qword_1001E44C8 != -1)
                          dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                        v42 = (id)qword_1001E44C0;
                        _NRLogWithArgs(v42, 16, "%s%.30s:%-4d %@: Did not expect InnerAddressResponderClassC as responder", "", "-[NRPairingClient handleNotifyCode:payload:]", 1472, WeakRetained, v113);
                        goto LABEL_183;
                      }
                    }
                    else
                    {
                      v128 = 0;
                      v129 = 0;
                      if ((unint64_t)objc_msgSend(v17, "length") > 0xF)
                      {
                        objc_msgSend(v17, "getBytes:length:", &v128, 16);
                        v105 = sub_10013E314((uint64_t)NRDLocalDevice, (uint64_t)&v128, WeakRetained[3]);
                        if (qword_1001E44C8 != -1)
                          dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                        v106 = (id)qword_1001E44C0;
                        v107 = _NRLogIsLevelEnabled(v106, 0);

                        if (v105)
                        {
                          if (!v107)
                            goto LABEL_85;
                          v94 = sub_100004A00();
                          v96 = (void *)createIPv6AddrString(&v128, v108);
                          _NRLogWithArgs(v94, 0, "%s%.30s:%-4d %@: updated local device with remote addresses %@ (classC)", "", "-[NRPairingClient handleNotifyCode:payload:]", 1482, WeakRetained, v96);
                        }
                        else
                        {
                          if (!v107)
                            goto LABEL_85;
                          v94 = sub_100004A00();
                          v96 = (void *)createIPv6AddrString(&v128, v112);
                          _NRLogWithArgs(v94, 0, "%s%.30s:%-4d %@: received remote classC address %@", "", "-[NRPairingClient handleNotifyCode:payload:]", 1484, WeakRetained, v96);
                        }
LABEL_212:

                      }
                      else
                      {
                        if (qword_1001E44C8 != -1)
                          dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                        v89 = (id)qword_1001E44C0;
                        v90 = _NRLogIsLevelEnabled(v89, 16);

                        if (v90)
                        {
                          if (qword_1001E44C8 != -1)
                            dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                          v42 = (id)qword_1001E44C0;
                          _NRLogWithArgs(v42, 16, "%s%.30s:%-4d %@: InnerAddressResponderClassC payload too short %@", "", "-[NRPairingClient handleNotifyCode:payload:]", 1477, WeakRetained, v17);
                          goto LABEL_183;
                        }
                      }
                    }
                    break;
                  default:
                    if ((_DWORD)v31 == 50901)
                      goto LABEL_79;
                    goto LABEL_143;
                }
                goto LABEL_85;
              }
              if ((int)v31 > 51500)
              {
                if ((_DWORD)v31 == 51501)
                {
                  if (qword_1001E44C8 != -1)
                    dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                  v77 = (id)qword_1001E44C0;
                  v78 = _NRLogIsLevelEnabled(v77, 16);

                  if (v78)
                  {
                    if (qword_1001E44C8 != -1)
                      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                    v79 = (id)qword_1001E44C0;
                    _NRLogWithArgs(v79, 16, "%s%.30s:%-4d %@: Did not expect IsAltAccountDevice", "", "-[NRPairingClient handleNotifyCode:payload:]", 1394, WeakRetained);

                  }
                }
                else if ((_DWORD)v31 == 51601)
                {
                  v46 = (unsigned __int8 *)WeakRetained[5];
                  if (v46)
                  {
                    v47 = v46[8];

                    if (v47)
                      sub_100006EE4((uint64_t)WeakRetained);
                  }
                  goto LABEL_85;
                }
LABEL_143:
                if (qword_1001E44C8 != -1)
                  dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                if (_NRLogIsLevelEnabled(qword_1001E44C0, 1))
                {
                  if (qword_1001E44C8 != -1)
                    dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                  v80 = (id)qword_1001E44C0;
                  _NRLogWithArgs(v80, 1, "%s%.30s:%-4d %@: Received unknown notify code %u", "", "-[NRPairingClient handleNotifyCode:payload:]", 1517, WeakRetained, v31);

                }
                goto LABEL_85;
              }
              if ((_DWORD)v31 != 51301)
              {
                if ((_DWORD)v31 == 51401)
                {
                  LOBYTE(v128) = 0;
                  objc_msgSend(v17, "getBytes:length:", &v128, 1);
                  if (qword_1001E44C8 != -1)
                    dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                  v43 = (id)qword_1001E44C0;
                  v44 = _NRLogIsLevelEnabled(v43, 0);

                  if (v44)
                  {
                    if (qword_1001E44C8 != -1)
                      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                    v45 = (id)qword_1001E44C0;
                    _NRLogWithArgs(v45, 0, "%s%.30s:%-4d %@: Received Always On Wi-Fi supported: %u", "", "-[NRPairingClient handleNotifyCode:payload:]", 1389, WeakRetained, v128);

                  }
                  sub_10013C3C8((uint64_t)NRDLocalDevice, (char *)(v128 == 1), WeakRetained[3]);
                  goto LABEL_85;
                }
                goto LABEL_143;
              }
              goto LABEL_79;
            }
            if (((_DWORD)v31 - 50501) < 5)
              goto LABEL_79;
            if ((_DWORD)v31 != 50701)
            {
              if ((_DWORD)v31 != 50702)
                goto LABEL_143;
LABEL_79:
              if (qword_1001E44C8 != -1)
                dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
              if (_NRLogIsLevelEnabled(qword_1001E44C0, 1))
              {
                if (qword_1001E44C8 != -1)
                  dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
                _NRLogWithArgs(qword_1001E44C0, 1, "%s%.30s:%-4d %@: Received unexpected notify code %u", "", "-[NRPairingClient handleNotifyCode:payload:]", 1513, WeakRetained, v31);
              }
              goto LABEL_85;
            }
            sub_10013C5A0((uint64_t)NRDLocalDevice, v17, WeakRetained[3]);
          }
LABEL_85:

LABEL_13:
        }
        v10 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v124, v130, 16);
      }
      while (v10);
    }

    v3 = v115;
  }

}

void sub_10000A3D8(uint64_t a1, void *a2)
{
  uint64_t v3;
  id v4;
  id v5;
  void *v6;
  void *v7;
  id v8;
  void *v9;
  uint64_t v10;
  id v11;
  id v12;
  void *v13;
  void *v14;
  id v15;
  void *LogString;
  id *v17;

  v17 = a2;
  if (qword_1001E44C8 != -1)
    dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
  if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
  {
    if (qword_1001E44C8 != -1)
      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
    _NRLogWithArgs(qword_1001E44C0, 0, "%s%.30s:%-4d %@: Plumbed device identity %@", "", "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_9", 1099, *(_QWORD *)(a1 + 32), v17);
  }
  if (qword_1001E44C8 != -1)
    dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
  if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
  {
    if (qword_1001E44C8 != -1)
      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
    v3 = *(_QWORD *)(a1 + 32);
    v4 = (id)qword_1001E44C0;
    if (v17)
    {
      v5 = v17[8];
      v6 = v5;
      if (v5)
        v7 = (void *)*((_QWORD *)v5 + 1);
      else
        v7 = 0;
    }
    else
    {
      v6 = 0;
      v7 = 0;
    }
    v8 = v7;
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "UUIDString"));
    _NRLogWithArgs(v4, 0, "%s%.30s:%-4d %@: deviceIdentityUUID=%@", "", "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_9", 1101, v3, v9);

  }
  if (qword_1001E44C8 != -1)
    dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
  if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
  {
    if (qword_1001E44C8 != -1)
      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
    v10 = *(_QWORD *)(a1 + 32);
    v11 = (id)qword_1001E44C0;
    if (v17)
    {
      v12 = v17[8];
      v13 = v12;
      if (v12)
        v14 = (void *)*((_QWORD *)v12 + 2);
      else
        v14 = 0;
    }
    else
    {
      v13 = 0;
      v14 = 0;
    }
    v15 = v14;
    LogString = (void *)_NRKeyCreateLogString(v15);
    _NRLogWithArgs(v11, 0, "%s%.30s:%-4d %@: deviceIdentityPublicKey=%@", "", "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_9", 1103, v10, LogString);

  }
}

void sub_10000A698(uint64_t a1, void *a2)
{
  void *v3;
  id v4;
  uint64_t v5;
  id v6;
  void *v7;
  _QWORD *v8;
  _QWORD *v9;
  void *LogString;
  uint64_t v11;
  id v12;
  void *v13;
  _QWORD *v14;
  _QWORD *v15;
  void *v16;
  uint64_t v17;
  id v18;
  id v19;
  void *v20;
  void *v21;
  id v22;
  void *v23;
  _QWORD *v24;

  v24 = a2;
  if (qword_1001E44C8 != -1)
    dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
  if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
  {
    if (qword_1001E44C8 != -1)
      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
    _NRLogWithArgs(qword_1001E44C0, 0, "%s%.30s:%-4d %@: Plumbed classD keys with OOBK %@", "", "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_10", 1110, *(_QWORD *)(a1 + 32), v24);
  }
  if (v24)
    v3 = (void *)v24[9];
  else
    v3 = 0;
  v4 = v3;
  if (qword_1001E44C8 != -1)
    dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
  if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
  {
    if (qword_1001E44C8 != -1)
      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
    v5 = *(_QWORD *)(a1 + 32);
    v6 = (id)qword_1001E44C0;
    if (v4)
      v7 = (void *)*((_QWORD *)v4 + 1);
    else
      v7 = 0;
    v8 = v7;
    v9 = sub_10012B324(v8);
    LogString = (void *)_NRKeyCreateLogString(v9);
    _NRLogWithArgs(v6, 0, "%s%.30s:%-4d %@: classDRemotePublicKey=%@", "", "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_10", 1113, v5, LogString);

  }
  if (qword_1001E44C8 != -1)
    dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
  if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
  {
    if (qword_1001E44C8 != -1)
      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
    v11 = *(_QWORD *)(a1 + 32);
    v12 = (id)qword_1001E44C0;
    if (v4)
      v13 = (void *)*((_QWORD *)v4 + 2);
    else
      v13 = 0;
    v14 = v13;
    v15 = sub_10012B324(v14);
    v16 = (void *)_NRKeyCreateLogString(v15);
    _NRLogWithArgs(v12, 0, "%s%.30s:%-4d %@: classDLocalPublicKey=%@", "", "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_10", 1115, v11, v16);

  }
  if (qword_1001E44C8 != -1)
    dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
  if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
  {
    if (qword_1001E44C8 != -1)
      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
    v17 = *(_QWORD *)(a1 + 32);
    v18 = (id)qword_1001E44C0;
    if (v4)
    {
      v19 = *((id *)v4 + 3);
      v20 = v19;
      if (v19)
      {
        v21 = (void *)*((_QWORD *)v19 + 2);
LABEL_33:
        v22 = v21;
        v23 = (void *)_NRKeyCreateLogString(v22);
        _NRLogWithArgs(v18, 0, "%s%.30s:%-4d %@: classDSharedSecret=%@", "", "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_10", 1117, v17, v23);

        goto LABEL_34;
      }
    }
    else
    {
      v20 = 0;
    }
    v21 = 0;
    goto LABEL_33;
  }
LABEL_34:
  sub_100006AD0(*(_QWORD *)(a1 + 32), 4);

}

void sub_10000AA40(uint64_t a1, void *a2)
{
  void *v3;
  id v4;
  uint64_t v5;
  id v6;
  void *v7;
  _QWORD *v8;
  _QWORD *v9;
  void *LogString;
  uint64_t v11;
  id v12;
  void *v13;
  _QWORD *v14;
  _QWORD *v15;
  void *v16;
  uint64_t v17;
  id v18;
  id v19;
  void *v20;
  void *v21;
  id v22;
  void *v23;
  _QWORD *v24;

  v24 = a2;
  if (qword_1001E44C8 != -1)
    dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
  if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
  {
    if (qword_1001E44C8 != -1)
      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
    _NRLogWithArgs(qword_1001E44C0, 0, "%s%.30s:%-4d %@: Plumbed classC keys with OOBK %@", "", "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_11", 1125, *(_QWORD *)(a1 + 32), v24);
  }
  if (v24)
    v3 = (void *)v24[10];
  else
    v3 = 0;
  v4 = v3;
  if (qword_1001E44C8 != -1)
    dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
  if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
  {
    if (qword_1001E44C8 != -1)
      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
    v5 = *(_QWORD *)(a1 + 32);
    v6 = (id)qword_1001E44C0;
    if (v4)
      v7 = (void *)*((_QWORD *)v4 + 1);
    else
      v7 = 0;
    v8 = v7;
    v9 = sub_10012B324(v8);
    LogString = (void *)_NRKeyCreateLogString(v9);
    _NRLogWithArgs(v6, 0, "%s%.30s:%-4d %@: classCRemotePublicKey=%@", "", "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_11", 1128, v5, LogString);

  }
  if (qword_1001E44C8 != -1)
    dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
  if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
  {
    if (qword_1001E44C8 != -1)
      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
    v11 = *(_QWORD *)(a1 + 32);
    v12 = (id)qword_1001E44C0;
    if (v4)
      v13 = (void *)*((_QWORD *)v4 + 2);
    else
      v13 = 0;
    v14 = v13;
    v15 = sub_10012B324(v14);
    v16 = (void *)_NRKeyCreateLogString(v15);
    _NRLogWithArgs(v12, 0, "%s%.30s:%-4d %@: classCLocalPublicKey=%@", "", "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_11", 1130, v11, v16);

  }
  if (qword_1001E44C8 != -1)
    dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
  if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
  {
    if (qword_1001E44C8 != -1)
      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
    v17 = *(_QWORD *)(a1 + 32);
    v18 = (id)qword_1001E44C0;
    if (v4)
    {
      v19 = *((id *)v4 + 3);
      v20 = v19;
      if (v19)
      {
        v21 = (void *)*((_QWORD *)v19 + 2);
LABEL_33:
        v22 = v21;
        v23 = (void *)_NRKeyCreateLogString(v22);
        _NRLogWithArgs(v18, 0, "%s%.30s:%-4d %@: classCSharedSecret=%@", "", "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_11", 1132, v17, v23);

        goto LABEL_34;
      }
    }
    else
    {
      v20 = 0;
    }
    v21 = 0;
    goto LABEL_33;
  }
LABEL_34:
  sub_100006AD0(*(_QWORD *)(a1 + 32), 3);

}

void sub_10000ADE8(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  id v5;
  uint64_t v6;
  id v7;
  void *v8;
  _QWORD *v9;
  _QWORD *v10;
  void *LogString;
  uint64_t v12;
  id v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v16;
  void *v17;
  uint64_t v18;
  id v19;
  id v20;
  void *v21;
  void *v22;
  id v23;
  void *v24;
  id v25;

  v3 = a2;
  v25 = v3;
  if (v3)
    v4 = (void *)*((_QWORD *)v3 + 11);
  else
    v4 = 0;
  v5 = v4;
  if (qword_1001E44C8 != -1)
    dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
  if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
  {
    if (qword_1001E44C8 != -1)
      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
    _NRLogWithArgs(qword_1001E44C0, 0, "%s%.30s:%-4d %@: Plumbed classA keys with OOBK %@", "", "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_12", 1141, *(_QWORD *)(a1 + 32), v25);
  }
  if (qword_1001E44C8 != -1)
    dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
  if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
  {
    if (qword_1001E44C8 != -1)
      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
    v6 = *(_QWORD *)(a1 + 32);
    v7 = (id)qword_1001E44C0;
    if (v5)
      v8 = (void *)*((_QWORD *)v5 + 1);
    else
      v8 = 0;
    v9 = v8;
    v10 = sub_10012B324(v9);
    LogString = (void *)_NRKeyCreateLogString(v10);
    _NRLogWithArgs(v7, 0, "%s%.30s:%-4d %@: classARemotePublicKey=%@", "", "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_12", 1143, v6, LogString);

  }
  if (qword_1001E44C8 != -1)
    dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
  if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
  {
    if (qword_1001E44C8 != -1)
      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
    v12 = *(_QWORD *)(a1 + 32);
    v13 = (id)qword_1001E44C0;
    if (v5)
      v14 = (void *)*((_QWORD *)v5 + 2);
    else
      v14 = 0;
    v15 = v14;
    v16 = sub_10012B324(v15);
    v17 = (void *)_NRKeyCreateLogString(v16);
    _NRLogWithArgs(v13, 0, "%s%.30s:%-4d %@: classALocalPublicKey=%@", "", "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_12", 1145, v12, v17);

  }
  if (qword_1001E44C8 != -1)
    dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
  if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
  {
    if (qword_1001E44C8 != -1)
      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
    v18 = *(_QWORD *)(a1 + 32);
    v19 = (id)qword_1001E44C0;
    if (v5)
    {
      v20 = *((id *)v5 + 3);
      v21 = v20;
      if (v20)
      {
        v22 = (void *)*((_QWORD *)v20 + 2);
LABEL_33:
        v23 = v22;
        v24 = (void *)_NRKeyCreateLogString(v23);
        _NRLogWithArgs(v19, 0, "%s%.30s:%-4d %@: classASharedSecret=%@", "", "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_12", 1147, v18, v24);

        goto LABEL_34;
      }
    }
    else
    {
      v21 = 0;
    }
    v22 = 0;
    goto LABEL_33;
  }
LABEL_34:
  sub_100006AD0(*(_QWORD *)(a1 + 32), 1);

}

void sub_10000B18C(uint64_t a1)
{
  objc_storeStrong((id *)(a1 + 120), 0);
}

void sub_10000B198(uint64_t a1)
{
  objc_storeStrong((id *)(a1 + 128), 0);
}

void sub_10000B1A4(uint64_t a1)
{
  objc_storeStrong((id *)(a1 + 136), 0);
}

void sub_10000B1B0(uint64_t a1, int a2)
{
  _BYTE *WeakRetained;
  uint64_t v4;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained && (WeakRetained[8] & 0xFE) != 6)
  {
    v4 = (uint64_t)WeakRetained;
    if (a2)
    {
      WeakRetained[14] = 1;
      if (qword_1001E44C8 != -1)
        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
      if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
      {
        if (qword_1001E44C8 != -1)
          dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
        _NRLogWithArgs(qword_1001E44C0, 0, "%s%.30s:%-4d %@: initiatorLocalPublicKeys were received", "", "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_2", 1013, v4);
      }
      sub_100006AD0(v4, 4);
      sub_100006AD0(v4, 3);
      sub_100006AD0(v4, 1);
    }
    else
    {
      if (qword_1001E44C8 != -1)
        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
      if (_NRLogIsLevelEnabled(qword_1001E44C0, 16))
      {
        if (qword_1001E44C8 != -1)
          dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
        _NRLogWithArgs(qword_1001E44C0, 16, "%s%.30s:%-4d %@: initiatorLocalPublicKeys were not received", "", "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_2", 1019, v4);
      }
      sub_100006684(v4, 7, 7);
    }
    WeakRetained = (_BYTE *)v4;
  }

}

void sub_10000B364(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v8;
  id v9;
  id v10;
  uint64_t v11;
  id v12;
  void *LogString;
  uint64_t v14;
  id v15;
  id v16;
  void *v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  id v22;
  id v23;
  id v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  unsigned __int8 *v30;
  int v31;
  id v32;
  id v33;
  uint64_t v34;
  unsigned __int8 *v35;
  int v36;
  id v37;
  _QWORD *v38;
  _QWORD *v39;
  _QWORD *v40;
  _QWORD *v41;
  _QWORD *v42;
  uint64_t v43;
  id v44;
  id v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  id v50;
  uint64_t v51;
  void *v52;
  uint64_t v53;
  id v54;
  int IsLevelEnabled;
  id v56;
  id v57;
  int v58;
  id v59;
  uint64_t v60;
  id v61;
  int v62;
  id v63;
  uint64_t v64;
  id v65;
  int v66;
  id v67;
  id v68;
  int v69;
  id v70;
  dispatch_time_t v71;
  _QWORD *v72;
  NSObject *v73;
  id v74;
  void *v75;
  id v76;
  uint64_t v77;
  _QWORD block[4];
  id v79;
  id location;
  _QWORD v81[5];
  _QWORD v82[3];
  int v83;

  v8 = a2;
  v9 = a3;
  v10 = a4;
  if (qword_1001E44C8 != -1)
    dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
  v77 = a1;
  if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
  {
    v75 = a4;
    if (qword_1001E44C8 != -1)
      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
    v11 = *(_QWORD *)(a1 + 32);
    v12 = (id)qword_1001E44C0;
    LogString = (void *)_NRKeyCreateLogString(v8);
    v14 = _NRKeyCreateLogString(v9);
    v15 = v9;
    v16 = v8;
    v17 = (void *)v14;
    v18 = (void *)_NRKeyCreateLogString(v10);
    _NRLogWithArgs(v12, 0, "%s%.30s:%-4d %@: Queryied for pairing keys for OOBK pairing D %@ C %@ A %@", "", "-[NRPairingClient setupInitiator]_block_invoke", 385, v11, LogString, v17, v18);

    v8 = v16;
    v9 = v15;

    a4 = v75;
    a1 = v77;
  }
  v19 = *(_QWORD *)(a1 + 32);
  if ((*(_BYTE *)(v19 + 8) & 0xFE) != 6)
  {
    objc_storeStrong((id *)(v19 + 120), a2);
    v20 = *(_QWORD *)(a1 + 32);
    if (v20)
    {
      objc_storeStrong((id *)(v20 + 128), a3);
      v21 = *(_QWORD *)(a1 + 32);
      if (v21)
        objc_storeStrong((id *)(v21 + 136), a4);
    }
    v22 = objc_msgSend(objc_alloc((Class)NEIKEv2AuthenticationProtocol), "initWithMethod:", 2);
    v74 = v10;
    if (qword_1001E4960 != -1)
      dispatch_once(&qword_1001E4960, &stru_1001B7E08);
    v23 = (id)qword_1001E4958;
    v24 = sub_10011268C(1, v23, v22);

    v25 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 112);
    if (v25)
    {
      v26 = *(_QWORD **)(v25 + 152);
      if (v26)
        v26 = (_QWORD *)v26[2];
      v27 = v26;
    }
    else
    {
      v27 = 0;
    }
    objc_msgSend(v24, "setSharedSecret:", v27);

    v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v24, "sharedSecret"));
    if (v28)
    {
      v29 = *(_QWORD *)(a1 + 32);
      if (v29
        && (v30 = (unsigned __int8 *)*(id *)(v29 + 40)) != 0
        && (v31 = v30[9], v30, v31))
      {
        v32 = v8;
        v76 = *(id *)(a1 + 32);
      }
      else
      {
        v32 = v8;
        v76 = 0;
      }
      v33 = sub_100112198();
      sub_100111E90(*(void **)(*(_QWORD *)(a1 + 32) + 112), v33);
      objc_msgSend(v33, "setRequestChildlessSA:", 1);
      v82[0] = 0;
      v82[1] = v82;
      v83 = 0;
      v82[2] = 0x2020000000;
      v34 = *(_QWORD *)(a1 + 32);
      if (v34
        && (v35 = (unsigned __int8 *)*(id *)(v34 + 40)) != 0
        && (v36 = v35[11], v35, v36))
      {
        v37 = sub_100112420();
        objc_msgSend(v37, "setSequencePerTrafficClass:", 1);
        objc_msgSend(v37, "setReplayWindowSize:", 16);
        v38 = 0;
      }
      else
      {
        v39 = *(_QWORD **)(*(_QWORD *)(a1 + 32) + 40);
        if (v39)
          v39 = (_QWORD *)v39[2];
        v40 = v39;
        objc_msgSend(v33, "setOutgoingInterfaceName:", v40);

        v41 = *(_QWORD **)(*(_QWORD *)(v77 + 32) + 40);
        if (v41)
          v41 = (_QWORD *)v41[3];
        v42 = v41;
        objc_msgSend(v33, "setRemoteEndpoint:", v42);

        objc_msgSend(v33, "setRandomizeLocalPort:", 1);
        v37 = sub_100112420();
        objc_msgSend(v37, "setMode:", 2);
        objc_msgSend(v37, "setReplayWindowSize:", 4);
        v81[0] = _NSConcreteStackBlock;
        v81[1] = 3221225472;
        v81[2] = sub_10000BBEC;
        v81[3] = &unk_1001B65E8;
        v81[4] = v82;
        v38 = objc_retainBlock(v81);
      }
      v43 = *(_QWORD *)(v77 + 32);
      v44 = v33;
      if (v43)
      {
        if (qword_1001E4870 != -1)
          dispatch_once(&qword_1001E4870, &stru_1001B7BB0);
        if (byte_1001E4868)
        {
          objc_msgSend(v44, "setForceUDPEncapsulation:", 1);
          objc_msgSend(v44, "setRandomizeLocalPort:", 1);
        }
      }

      v45 = objc_alloc((Class)NEIKEv2Session);
      v46 = *(_QWORD *)(v77 + 32);
      v47 = *(_QWORD *)(v46 + 32);
      v48 = *(_QWORD *)(v46 + 40);
      if (v48)
        v49 = *(_QWORD *)(v48 + 40);
      else
        v49 = 0;
      v50 = objc_msgSend(v45, "initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:kernelSASessionName:packetDelegate:", v44, v37, v24, v47, v49, v38, CFSTR("terminusIKEForPairingWithOOBKey"), v76);
      v51 = *(_QWORD *)(v77 + 32);
      v52 = *(void **)(v51 + 80);
      *(_QWORD *)(v51 + 80) = v50;

      v53 = *(_QWORD *)(v77 + 32);
      if (*(_QWORD *)(v53 + 80))
      {
        *(_BYTE *)(v53 + 16) = 0;
        if (qword_1001E44C8 != -1)
          dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
        v54 = (id)qword_1001E44C0;
        IsLevelEnabled = _NRLogIsLevelEnabled(v54, 0);

        if (IsLevelEnabled)
        {
          if (qword_1001E44C8 != -1)
            dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
          v56 = (id)qword_1001E44C0;
          _NRLogWithArgs(v56, 0, "%s%.30s:%-4d %@: Created initiator OOBK pairing IKE session", "", "-[NRPairingClient setupInitiator]_block_invoke", 468, *(_QWORD *)(v77 + 32));

        }
        sub_100004C50(*(_QWORD *)(v77 + 32));
        if (qword_1001E44C8 != -1)
          dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
        v57 = (id)qword_1001E44C0;
        v58 = _NRLogIsLevelEnabled(v57, 0);

        if (v58)
        {
          if (qword_1001E44C8 != -1)
            dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
          v59 = (id)qword_1001E44C0;
          _NRLogWithArgs(v59, 0, "%s%.30s:%-4d %@: Connecting initiator OOBK pairing session", "", "-[NRPairingClient setupInitiator]_block_invoke", 470, *(_QWORD *)(v77 + 32));

        }
        objc_msgSend(*(id *)(*(_QWORD *)(v77 + 32) + 80), "connect");
        v60 = *(_QWORD *)(v77 + 32);
        if (v60)
          *(_BYTE *)(v60 + 14) = 0;
      }
      else
      {
        ++*(_BYTE *)(v53 + 16);
        v64 = *(_QWORD *)(v77 + 32);
        if (v64 && *(unsigned __int8 *)(v64 + 16) >= 3u)
        {
          v65 = sub_100004A00();
          v66 = _NRLogIsLevelEnabled(v65, 17);

          if (v66)
          {
            v67 = sub_100004A00();
            _NRLogWithArgs(v67, 17, "%@: Failed to create initiator OOBK pairing IKE session", *(_QWORD *)(v77 + 32));

          }
          sub_100006684(*(_QWORD *)(v77 + 32), 7, 4);
        }
        else
        {
          v68 = sub_100004A00();
          v69 = _NRLogIsLevelEnabled(v68, 16);

          if (v69)
          {
            v70 = sub_100004A00();
            _NRLogWithArgs(v70, 16, "%s%.30s:%-4d %@: Failed to create initiator OOBK pairing IKE session", "", "-[NRPairingClient setupInitiator]_block_invoke", 446, *(_QWORD *)(v77 + 32));

          }
          objc_initWeak(&location, *(id *)(v77 + 32));
          v71 = dispatch_time(0x8000000000000000, 3000000000);
          v72 = *(_QWORD **)(v77 + 32);
          if (v72)
            v72 = (_QWORD *)v72[4];
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472;
          block[2] = sub_10000BC3C;
          block[3] = &unk_1001B7F28;
          v73 = v72;
          objc_copyWeak(&v79, &location);
          dispatch_after(v71, v73, block);

          objc_destroyWeak(&v79);
          objc_destroyWeak(&location);
        }
      }
      _Block_object_dispose(v82, 8);

      v8 = v32;
    }
    else
    {
      v61 = sub_100004A00();
      v62 = _NRLogIsLevelEnabled(v61, 17);

      if (v62)
      {
        v63 = sub_100004A00();
        _NRLogWithArgs(v63, 17, "%@: Missing out of band key", *(_QWORD *)(a1 + 32));

      }
      sub_100006684(*(_QWORD *)(a1 + 32), 7, 8);
    }

    v10 = v74;
  }

}

void sub_10000BBD4(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 120), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10000BBEC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;

  v9 = getpid();
  return NEHelperGetIKESocketWithResult(a3, a4, a5, v9, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

void sub_10000BC3C(uint64_t a1)
{
  id WeakRetained;
  _QWORD *v2;
  void *v3;
  _QWORD v4[5];

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v2 = WeakRetained;
  if (WeakRetained
    && (*((_BYTE *)WeakRetained + 8) & 0xFE) != 6
    && (*((_BYTE *)WeakRetained + 48) & 0x10) == 0
    && !*((_QWORD *)WeakRetained + 10))
  {
    sub_100004AF0((uint64_t)WeakRetained, (id *)WeakRetained + 10);
    v3 = (void *)v2[3];
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472;
    v4[2] = sub_10000B364;
    v4[3] = &unk_1001B5D90;
    v4[4] = v2;
    sub_1001385D4((uint64_t)NRDLocalDevice, v3, 4, v4);
  }

}

void sub_10000BCE4(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001E44C0;
  qword_1001E44C0 = (uint64_t)v1;

}

id *sub_10000BD14(id *a1, void *a2, void *a3, __objc2_prot *a4)
{
  id v8;
  char *v9;
  __objc2_prot *v10;
  __objc2_prot *v11;
  id *v12;
  unint64_t v13;
  uint64_t v14;
  id v15;
  id *v16;
  id v18;
  int IsLevelEnabled;
  id v20;
  id v21;
  int v22;
  id v23;
  int v24;
  id v25;
  int v26;
  id v27;
  int *v28;
  uint64_t v29;
  id v30;
  uint64_t v31;
  objc_super v32;

  v8 = a2;
  v9 = a3;
  v10 = a4;
  v11 = v10;
  if (!a1)
    goto LABEL_22;
  if (!v8)
  {
    v18 = sub_100004A00();
    IsLevelEnabled = _NRLogIsLevelEnabled(v18, 17);

    if (!IsLevelEnabled)
      goto LABEL_22;
    v20 = sub_100004A00();
    _NRLogWithArgs(v20, 17, "%s called with null queue");
LABEL_21:

    v16 = 0;
    goto LABEL_14;
  }
  if (!v9)
  {
    v21 = sub_100004A00();
    v22 = _NRLogIsLevelEnabled(v21, 17);

    if (!v22)
      goto LABEL_22;
    v20 = sub_100004A00();
    _NRLogWithArgs(v20, 17, "%s called with null nrUUID");
    goto LABEL_21;
  }
  if (!v10)
  {
    v23 = sub_100004A00();
    v24 = _NRLogIsLevelEnabled(v23, 17);

    if (v24)
    {
      v20 = sub_100004A00();
      _NRLogWithArgs(v20, 17, "%s called with null parameters");
      goto LABEL_21;
    }
LABEL_22:
    v16 = 0;
    goto LABEL_14;
  }
  v32.receiver = a1;
  v32.super_class = (Class)NRPairingClient;
  v12 = (id *)objc_msgSendSuper2(&v32, "init");
  if (v12)
  {
    a1 = v12;
    do
      v13 = __ldxr(&qword_1001E38E8);
    while (__stxr(v13 + 1, &qword_1001E38E8));
    v12[7] = (id)v13;
    objc_storeStrong(v12 + 4, a2);
    objc_storeStrong(a1 + 3, a3);
    objc_storeStrong(a1 + 5, a4);
    v14 = objc_claimAutoreleasedReturnValue(+[NSUUID UUID](NSUUID, "UUID"));
    v15 = a1[8];
    a1[8] = (id)v14;

    a4 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
    if (qword_1001E44C8 == -1)
      goto LABEL_9;
  }
  else
  {
    v25 = sub_100004A00();
    v26 = _NRLogIsLevelEnabled(v25, 16);

    if (v26)
    {
      v27 = sub_100004A00();
      _NRLogWithArgs(v27, 16, "%s%.30s:%-4d ABORTING: [super init] failed", "", "-[NRPairingClient initWithQueue:nrUUID:parameters:]", 123);

    }
    v8 = (id)_os_log_pack_size(12);
    v9 = (char *)&v31 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
    v28 = __error();
    v29 = _os_log_pack_fill(v9, v8, *v28, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)v29 = 136446210;
    *(_QWORD *)(v29 + 4) = "-[NRPairingClient initWithQueue:nrUUID:parameters:]";
    v30 = sub_100004A00();
    _NRLogAbortWithPack(v30, v9);
  }
  dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
LABEL_9:
  if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
  {
    if (a4[17].isa != (void *)-1)
      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
    _NRLogWithArgs(qword_1001E44C0, 0, "%s%.30s:%-4d %@: Created", "", "-[NRPairingClient initWithQueue:nrUUID:parameters:]", 131, a1);
  }
  a1 = a1;
  v16 = a1;
LABEL_14:

  return v16;
}

void sub_10000C08C(uint64_t a1)
{
  char *v2;
  void *v3;
  uint64_t v4;
  int v5;
  BOOL v6;
  int v7;
  uint64_t v8;
  id *v9;
  id *v10;
  uint64_t v11;
  void *v12;
  id v13;
  NSObject *v14;
  nw_interface_type_t type;
  int subtype;
  id v17;
  void *v18;
  void *v19;
  id v20;
  id *v21;
  id *v22;
  void *v23;
  id *v24;
  void *v25;
  void *v26;
  id v27;
  id v28;
  _QWORD *v29;
  void *v30;
  void *v31;
  id v32;
  id v33;
  NRPendingClientForPairing *v34;
  NRPendingClientForPairing *v35;
  SEL v36;
  void *v37;
  _QWORD v38[4];
  id v39;
  id location[5];

  if (!a1 || (*(_BYTE *)(a1 + 8) & 0xFE) == 6)
    return;
  *(_BYTE *)(a1 + 10) = 1;
  v2 = sub_1001300EC((uint64_t)NRDLocalDevice, *(void **)(a1 + 24), 0);
  v3 = *(void **)(a1 + 112);
  *(_QWORD *)(a1 + 112) = v2;

  v4 = *(_QWORD *)(a1 + 112);
  if (!v4)
  {
    if (qword_1001E44C8 != -1)
      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
    if (_NRLogIsLevelEnabled(qword_1001E44C0, 16))
    {
      if (qword_1001E44C8 != -1)
        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
      _NRLogWithArgs(qword_1001E44C0, 16, "%s%.30s:%-4d %@: %@ no local device found", "", "-[NRPairingClient start]", 232, a1, *(_QWORD *)(a1 + 24));
    }
    sub_100006684(a1, 7, 3);
    return;
  }
  if (!*(_BYTE *)(v4 + 15))
  {
    if (*(_BYTE *)(v4 + 14))
      v6 = 1;
    else
      v6 = *(unsigned __int16 *)(v4 + 28) > 0x12u;
    v5 = v6;
    if (!*(_BYTE *)(v4 + 12))
      goto LABEL_33;
LABEL_22:
    if (*(_BYTE *)(v4 + 13))
      v7 = v5;
    else
      v7 = 0;
    if (v7 == 1)
    {
      if (qword_1001E44C8 != -1)
        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
      if (_NRLogIsLevelEnabled(qword_1001E44C0, 16))
      {
        if (qword_1001E44C8 != -1)
          dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
        _NRLogWithArgs(qword_1001E44C0, 16, "%s%.30s:%-4d %@: already paired", "", "-[NRPairingClient start]", 238, a1);
      }
      sub_100006684(a1, 5, 0);
      return;
    }
    goto LABEL_33;
  }
  v5 = 1;
  if (*(_BYTE *)(v4 + 12))
    goto LABEL_22;
LABEL_33:
  *(_BYTE *)(a1 + 11) = 0;
  v8 = *(_QWORD *)(a1 + 40);
  if (v8 && *(_BYTE *)(v8 + 8))
    goto LABEL_35;
  objc_opt_self(NRPairingClientManager);
  if (qword_1001E44F8 != -1)
    dispatch_once(&qword_1001E44F8, &stru_1001B5F00);
  v21 = (id *)(id)qword_1001E44F0;
  if (v21
    && (v22 = v21,
        v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21[2], "objectForKeyedSubscript:", *(_QWORD *)(a1 + 24))),
        v23,
        v22,
        !v23))
  {
LABEL_35:
    objc_opt_self(NRPairingClientManager);
    if (qword_1001E44F8 != -1)
      dispatch_once(&qword_1001E44F8, &stru_1001B5F00);
    v9 = (id *)(id)qword_1001E44F0;
    v10 = v9;
    if (v9)
      objc_msgSend(v9[2], "setObject:forKeyedSubscript:", &__kCFBooleanTrue, *(_QWORD *)(a1 + 24));

    v11 = *(_QWORD *)(a1 + 40);
    if (!v11)
      goto LABEL_72;
    v12 = *(void **)(v11 + 16);
    if (v12)
    {
      v13 = v12;
      v14 = nw_interface_create_with_name(objc_msgSend(v13, "UTF8String"));
      type = nw_interface_get_type(v14);
      subtype = nw_interface_get_subtype(v14);
      if (type == nw_interface_type_wifi || subtype == 1001)
      {
        objc_opt_self(NRLinkDirector);
        if (qword_1001E4710 != -1)
          dispatch_once(&qword_1001E4710, &stru_1001B6E60);
        v17 = (id)qword_1001E4708;
        v18 = v17;
        if (v17)
          v19 = (void *)*((_QWORD *)v17 + 6);
        else
          v19 = 0;
        v20 = v19;
        sub_100147674((uint64_t)v20, 1, *(void **)(a1 + 64));

      }
      v11 = *(_QWORD *)(a1 + 40);
      if (!v11)
        goto LABEL_72;
    }
    if (*(_BYTE *)(v11 + 8))
    {
      if ((sub_10000C86C(a1) & 1) == 0)
      {
        sub_100006684(a1, 7, 6);
        return;
      }
    }
    else
    {
LABEL_72:
      sub_100004AF0(a1, (id *)(a1 + 80));
      v37 = *(void **)(a1 + 24);
      location[0] = _NSConcreteStackBlock;
      location[1] = (id)3221225472;
      location[2] = sub_10000B364;
      location[3] = &unk_1001B5D90;
      location[4] = (id)a1;
      sub_1001385D4((uint64_t)NRDLocalDevice, v37, 4, location);
    }
    sub_100006684(a1, 1, 0);
  }
  else
  {
    if (qword_1001E44C8 != -1)
      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
    if (_NRLogIsLevelEnabled(qword_1001E44C0, 1))
    {
      if (qword_1001E44C8 != -1)
        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
      _NRLogWithArgs(qword_1001E44C0, 1, "%s%.30s:%-4d %@: skipping as pairing is ongoing", "", "-[NRPairingClient start]", 246, a1);
    }
    *(_BYTE *)(a1 + 11) = 1;
    objc_initWeak(location, (id)a1);
    objc_opt_self(NRPairingClientManager);
    if (qword_1001E44F8 != -1)
      dispatch_once(&qword_1001E44F8, &stru_1001B5F00);
    v24 = (id *)(id)qword_1001E44F0;
    v25 = *(void **)(a1 + 24);
    v26 = *(void **)(a1 + 32);
    v38[0] = _NSConcreteStackBlock;
    v38[1] = 3221225472;
    v38[2] = sub_10000C724;
    v38[3] = &unk_1001B5D68;
    objc_copyWeak(&v39, location);
    v27 = v25;
    v28 = v26;
    v29 = v38;
    if (v24)
    {
      v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v24[2], "objectForKeyedSubscript:", v27));

      if (v30)
      {
        v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v24[3], "objectForKeyedSubscript:", v27));
        v32 = objc_alloc_init((Class)NSMutableArray);
        if (objc_msgSend(v31, "count"))
        {
          v33 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithArray:", v31);

          v32 = v33;
        }
        v34 = objc_alloc_init(NRPendingClientForPairing);
        v35 = v34;
        if (v34)
        {
          objc_storeStrong((id *)&v34->_queue, v26);
          objc_setProperty_nonatomic_copy(v35, v36, v29, 16);
        }
        objc_msgSend(v32, "addObject:", v35);
        objc_msgSend(v24[3], "setObject:forKeyedSubscript:", v32, v27);

      }
    }

    objc_destroyWeak(&v39);
    objc_destroyWeak(location);
  }
}

void sub_10000C700(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10000C724(uint64_t a1, int a2, char a3)
{
  _BYTE *WeakRetained;
  const __CFString *v6;
  _BYTE *v7;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained && (WeakRetained[8] & 0xFE) != 6)
  {
    v7 = WeakRetained;
    if (qword_1001E44C8 != -1)
      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
    if (_NRLogIsLevelEnabled(qword_1001E44C0, 1))
    {
      if (qword_1001E44C8 != -1)
        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
      if ((a2 - 1) > 6)
        v6 = CFSTR("Invalid");
      else
        v6 = *(&off_1001B5E38 + (a2 - 1));
      _NRLogWithArgs(qword_1001E44C0, 1, "%s%.30s:%-4d %@: received update for pending client %@", "", "-[NRPairingClient start]_block_invoke", 257, v7, v6);
    }
    if ((a2 & 0xFE) == 6)
    {
      sub_10000C08C(v7);
LABEL_16:
      WeakRetained = v7;
      goto LABEL_17;
    }
    WeakRetained = v7;
    if (a2 == 5)
    {
      sub_100006684((uint64_t)v7, 5, a3);
      goto LABEL_16;
    }
  }
LABEL_17:

}

uint64_t sub_10000C86C(uint64_t a1)
{
  void *v2;
  void *v3;
  id v4;
  uint64_t v5;
  const char *v6;
  id v7;
  id v8;
  uint64_t v9;
  id v10;
  void *v11;
  uint64_t v12;
  void *v13;
  id *v14;
  uint64_t v15;
  void *v16;
  void *v17;
  id v18;
  id *v19;
  id v20;
  id v21;
  void *v22;
  id v23;
  id v24;
  id v25;
  id v26;
  id v27;
  uint64_t v28;
  void *v29;
  id v30;
  void *v31;
  void *v32;
  id v33;
  id v34;
  id v35;
  uint64_t v36;
  NRIKEv2ListenerRegistration *v37;
  id *p_isa;
  unsigned int v40;
  id v41;
  void *v42;
  int v43;
  id v44;
  int v45;
  id v46;
  dispatch_time_t v47;
  void *v48;
  NSObject *v49;
  id v50;
  int IsLevelEnabled;
  id v52;
  int v53;
  unsigned __int8 v54;
  id v55;
  void *v56;
  id obj;
  id v58;
  id *v59;
  _QWORD block[4];
  id v61;
  id location;

  v2 = *(void **)(a1 + 72);
  if (v2)
  {
    objc_msgSend(v2, "cancel");
    v3 = *(void **)(a1 + 72);
    *(_QWORD *)(a1 + 72) = 0;

  }
  v4 = objc_alloc((Class)NSString);
  v5 = *(_QWORD *)(a1 + 40);
  v6 = "Tunnel";
  if (v5 && *(_BYTE *)(v5 + 11))
    v6 = "Transport";
  v7 = objc_msgSend(v4, "initWithFormat:", CFSTR("NRPairingResponder-%sMode"), v6);
  v8 = sub_100112198();
  objc_msgSend(v8, "setRequestChildlessSA:", 1);
  v9 = *(_QWORD *)(a1 + 40);
  if (!v9)
  {
    v12 = 0;
    goto LABEL_16;
  }
  if (!*(_BYTE *)(v9 + 11))
  {
    v12 = *(_QWORD *)(v9 + 16);
LABEL_16:
    objc_msgSend(v8, "setOutgoingInterfaceName:", v12);
    v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "outgoingInterfaceName"));

    if (!v13)
    {
      if (qword_1001E44C8 != -1)
        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
      if (_NRLogIsLevelEnabled(qword_1001E44C0, 17))
      {
        if (qword_1001E44C8 != -1)
          dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
        _NRLogWithArgs(qword_1001E44C0, 17, "%@: missing outgoing interface", a1);
      }
      v36 = 0;
      goto LABEL_63;
    }
    objc_opt_self(NRIKEv2Listener);
    if (qword_1001E44D8 != -1)
      dispatch_once(&qword_1001E44D8, &stru_1001B5E70);
    v14 = (id *)(id)qword_1001E44D0;
    v15 = *(_QWORD *)(a1 + 40);
    if (v15)
    {
      v16 = *(void **)(v15 + 16);
      v17 = *(void **)(v15 + 32);
    }
    else
    {
      v16 = 0;
      v17 = 0;
    }
    v18 = v16;
    v19 = (id *)(id)a1;
    v20 = v18;
    v21 = v17;
    v22 = v21;
    if (!v14)
      goto LABEL_61;
    if (!v20)
    {
      v50 = sub_10000E2AC();
      IsLevelEnabled = _NRLogIsLevelEnabled(v50, 17);

      if (!IsLevelEnabled)
        goto LABEL_61;
      v24 = sub_10000E2AC();
      _NRLogWithArgs(v24, 17, "%s called with null interfaceName");
      goto LABEL_60;
    }
    if (!v21)
    {
      v52 = sub_10000E2AC();
      v53 = _NRLogIsLevelEnabled(v52, 17);

      if (!v53)
        goto LABEL_61;
      v24 = sub_10000E2AC();
      _NRLogWithArgs(v24, 17, "%s called with null localEndpoint");
      goto LABEL_60;
    }
    if (*((_BYTE *)v19 + 8) == 6)
    {
LABEL_61:

LABEL_62:
      v36 = 1;
      goto LABEL_63;
    }
    obj = v17;
    v58 = v16;
    v23 = v19[3];
    v24 = sub_10000E3A4((uint64_t)v14, v20, v22, v23);

    v25 = v14[4];
    if (!v25)
    {
      v26 = objc_alloc_init((Class)NSMutableDictionary);
      v27 = v14[4];
      v14[4] = v26;

      v25 = v14[4];
    }
    v28 = objc_claimAutoreleasedReturnValue(objc_msgSend(v25, "objectForKeyedSubscript:", v24));
    v29 = (void *)v28;
    v59 = (id *)v28;
    if (!v28)
      goto LABEL_43;
    v30 = *(id *)(v28 + 32);
    v31 = v30;
    v55 = v24;
    v56 = v22;
    if (v30)
      v32 = (void *)*((_QWORD *)v30 + 3);
    else
      v32 = 0;
    v33 = v32;
    v34 = v19[3];
    if (objc_msgSend(v33, "isEqual:", v34))
    {
      v35 = v59[1];
      if (objc_msgSend(v35, "isEqualToString:", v20))
      {
        v54 = objc_msgSend(v59[2], "isEqual:", v56);

        v22 = v56;
        v24 = v55;
        v29 = v59;
        if ((v54 & 1) != 0)
        {
LABEL_59:

LABEL_60:
          goto LABEL_61;
        }
LABEL_43:
        if ((sub_10000F0F0((uint64_t)v14) & 1) != 0)
        {
          if (qword_1001E44E8 != -1)
            dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
          if (_NRLogIsLevelEnabled(qword_1001E44E0, 0))
          {
            if (qword_1001E44E8 != -1)
              dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
            _NRLogWithArgs(qword_1001E44E0, 0, "%s%.30s:%-4d Successfully registered pairing client %@", "", "-[NRIKEv2Listener registerPairingClient:localInterfaceName:localEndpoint:]", 317, v19);
          }
          v37 = objc_alloc_init(NRIKEv2ListenerRegistration);
          p_isa = (id *)&v37->super.isa;
          if (v37)
          {
            objc_storeStrong((id *)&v37->_pairingClient, (id)a1);
            objc_storeStrong(p_isa + 2, obj);
            objc_storeStrong(p_isa + 1, v58);
          }
          objc_msgSend(v14[4], "setObject:forKeyedSubscript:", p_isa, v24);
          sub_10000F2C4((uint64_t)v14);
          sub_10000FC60((uint64_t)v14, v24);

          v29 = v59;
        }
        else
        {
          if (qword_1001E44E8 != -1)
            dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
          if (_NRLogIsLevelEnabled(qword_1001E44E0, 17))
          {
            if (qword_1001E44E8 != -1)
              dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
            _NRLogWithArgs(qword_1001E44E0, 17, "Failed to register pairing client %@", v19);
          }
        }
        goto LABEL_59;
      }

    }
    v24 = v55;
    v22 = v56;
    v29 = v59;
    goto LABEL_43;
  }
  v10 = objc_msgSend(objc_alloc((Class)NEIKEv2Listener), "initWithListenerIKEConfig:kernelSASessionName:packetDelegate:listenerQueue:delegate:delegateQueue:", v8, v7, a1, *(_QWORD *)(a1 + 32), a1, *(_QWORD *)(a1 + 32));
  v11 = *(void **)(a1 + 72);
  *(_QWORD *)(a1 + 72) = v10;

  if (*(_QWORD *)(a1 + 72))
  {
    *(_BYTE *)(a1 + 15) = 0;
    if (qword_1001E44C8 != -1)
      dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
    if (_NRLogIsLevelEnabled(qword_1001E44C0, 0))
    {
      if (qword_1001E44C8 != -1)
        dispatch_once(&qword_1001E44C8, &stru_1001B5DD8);
      _NRLogWithArgs(qword_1001E44C0, 0, "%s%.30s:%-4d %@: Created IKE listener", "", "-[NRPairingClient setupResponder]", 356, a1);
    }
    goto LABEL_62;
  }
  v40 = ++*(_BYTE *)(a1 + 15);
  v41 = sub_100004A00();
  v42 = v41;
  if (v40 < 3)
  {
    v45 = _NRLogIsLevelEnabled(v41, 16);

    if (v45)
    {
      v46 = sub_100004A00();
      _NRLogWithArgs(v46, 16, "%s%.30s:%-4d %@: Failed to create IKE listener", "", "-[NRPairingClient setupResponder]", 332, a1);

    }
    objc_initWeak(&location, (id)a1);
    v47 = dispatch_time(0x8000000000000000, 3000000000);
    v48 = *(void **)(a1 + 32);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10000CFC8;
    block[3] = &unk_1001B7F28;
    v49 = v48;
    objc_copyWeak(&v61, &location);
    dispatch_after(v47, v49, block);

    objc_destroyWeak(&v61);
    objc_destroyWeak(&location);
    goto LABEL_62;
  }
  v43 = _NRLogIsLevelEnabled(v41, 17);

  if (v43)
  {
    v44 = sub_100004A00();
    _NRLogWithArgs(v44, 17, "%@: Failed to create IKE listener", a1);

  }
  sub_100006684(a1, 7, 6);
  v36 = 0;
LABEL_63:

  return v36;
}

void sub_10000CFC8(uint64_t a1)
{
  id WeakRetained;
  id v2;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained
    && (*((_BYTE *)WeakRetained + 8) & 0xFE) != 6
    && (*((_BYTE *)WeakRetained + 48) & 0x10) == 0
    && !*((_QWORD *)WeakRetained + 9))
  {
    v2 = WeakRetained;
    sub_10000C86C();
    WeakRetained = v2;
  }

}

id sub_10000E2AC()
{
  if (qword_1001E44E8 != -1)
    dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
  return (id)qword_1001E44E0;
}

void sub_10000E2EC(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  __CFString *v10;
  id v11;
  id v12;
  id v13;

  if (a1)
  {
    v10 = CFSTR("%@");
    v11 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:arguments:", CFSTR("%@"), &a9);

    v12 = v11;
    v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("NRIKEv2Listener[%@]"), CFSTR("62743"));
    sub_100121E18(0, a2, v13, v12);

  }
}

id sub_10000E3A4(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  void *v10;
  NSObject *v11;
  char *v12;
  id v13;
  id v15;
  int v16;
  id v17;
  int v18;
  id v19;
  int IsLevelEnabled;

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = v9;
  if (!a1)
    goto LABEL_16;
  if (v7)
  {
    if (v8)
    {
      if (v9)
      {
        v11 = objc_msgSend(v8, "copyCEndpoint");
        v12 = nw_endpoint_copy_address_string(v11);
        v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s/%@/%@"), v12, v7, v10);
        if (v12)
          free(v12);
        goto LABEL_7;
      }
      v19 = sub_10000E2AC();
      IsLevelEnabled = _NRLogIsLevelEnabled(v19, 17);

      if (IsLevelEnabled)
      {
        v11 = sub_10000E2AC();
        _NRLogWithArgs(v11, 17, "%s called with null nrUUID");
        goto LABEL_15;
      }
LABEL_16:
      v13 = 0;
      goto LABEL_8;
    }
    v17 = sub_10000E2AC();
    v18 = _NRLogIsLevelEnabled(v17, 17);

    if (!v18)
      goto LABEL_16;
    v11 = sub_10000E2AC();
    _NRLogWithArgs(v11, 17, "%s called with null localEndpoint");
  }
  else
  {
    v15 = sub_10000E2AC();
    v16 = _NRLogIsLevelEnabled(v15, 17);

    if (!v16)
      goto LABEL_16;
    v11 = sub_10000E2AC();
    _NRLogWithArgs(v11, 17, "%s called with null interfaceName");
  }
LABEL_15:
  v13 = 0;
LABEL_7:

LABEL_8:
  return v13;
}

void sub_10000E528(id *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7)
{
  id v14;
  id v15;
  id v16;
  id v17;
  id v18;
  id v19;
  id v20;
  id v21;
  NRIKEv2PendingSession *v22;
  NRIKEv2PendingSession *v23;
  SEL v24;
  SEL v25;
  id v26;
  id v27;
  id v28;
  id *v29;
  id v30;
  id v31;
  int IsLevelEnabled;
  id v33;
  NEIKEv2Session *session;
  NEIKEv2Session *v35;
  id v36;
  id *v37;
  NSObject *v38;
  dispatch_time_t v39;
  NSObject *v40;
  id v41;
  char v42;
  id v43;
  id v44;
  id v45;
  id v46;
  _QWORD v47[5];
  id v48;
  id v49;
  id location;
  _QWORD handler[4];
  NSObject *v52;
  id v53[2];
  id from[2];

  v14 = a2;
  v15 = a3;
  v16 = a4;
  v17 = a5;
  v18 = a6;
  v19 = a7;
  if (a1)
  {
    v46 = v16;
    if (!a1[6])
    {
      v20 = objc_alloc_init((Class)NSMutableDictionary);
      v21 = a1[6];
      a1[6] = v20;

    }
    v22 = objc_alloc_init(NRIKEv2PendingSession);
    v23 = v22;
    if (v22)
    {
      objc_storeStrong((id *)&v22->_session, a2);
      objc_storeStrong((id *)&v23->_sessionConfig, a3);
      objc_storeStrong((id *)&v23->_childConfig, a4);
      objc_setProperty_nonatomic_copy(v23, v24, v17, 32);
      objc_setProperty_nonatomic_copy(v23, v25, v18, 40);
      v23->_sessionReceivedTimestamp = mach_continuous_time();
    }
    else
    {
      mach_continuous_time();
    }
    objc_initWeak(&location, v14);
    v26 = a1[1];
    objc_msgSend(v14, "setClientQueue:", v26);

    v47[0] = _NSConcreteStackBlock;
    v47[1] = 3221225472;
    v47[2] = sub_10000EA6C;
    v47[3] = &unk_1001B5E98;
    objc_copyWeak(&v49, &location);
    v47[4] = a1;
    v45 = v19;
    v27 = v19;
    v48 = v27;
    objc_msgSend(v14, "setStateUpdateBlock:", v47);
    v44 = v15;
    v28 = a1[6];
    v29 = (id *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "objectForKeyedSubscript:", v27));

    if (v29)
    {
      v30 = v29[5];
      (*((void (**)(id, _QWORD, _QWORD, _QWORD))v30 + 2))(v30, 0, 0, 0);

    }
    if (qword_1001E44E8 != -1)
      dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
    v31 = (id)qword_1001E44E0;
    IsLevelEnabled = _NRLogIsLevelEnabled(v31, 1);

    if (IsLevelEnabled)
    {
      if (qword_1001E44E8 != -1)
        dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
      v33 = (id)qword_1001E44E0;
      if (v23)
        session = v23->_session;
      else
        session = 0;
      v35 = session;
      _NRLogWithArgs(v33, 1, "%s%.30s:%-4d adding pending session: %@", "", "-[NRIKEv2Listener addPendingSession:sessionConfig:childConfig:validateAuthBlock:responseBlock:key:]", 533, v35);

    }
    v36 = a1[6];
    objc_msgSend(v36, "setObject:forKeyedSubscript:", v23, v27);

    v37 = a1 + 7;
    if (!a1[7])
    {
      v38 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, (dispatch_queue_t)a1[1]);
      v39 = dispatch_time(0x8000000000000000, 10000000000);
      dispatch_source_set_timer(v38, v39, 0x2540BE400uLL, 0x3A35294400uLL);
      objc_initWeak(from, a1);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 3221225472;
      handler[2] = sub_10000EBB8;
      handler[3] = &unk_1001B6D28;
      objc_copyWeak(v53, from);
      v40 = v38;
      v52 = v40;
      v53[1] = (id)0x4024000000000000;
      dispatch_source_set_event_handler(v40, handler);
      dispatch_activate(v40);
      objc_storeStrong(v37, v38);
      if (qword_1001E44E8 != -1)
        dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
      v41 = (id)qword_1001E44E0;
      v42 = _NRLogIsLevelEnabled(v41, 0);

      if ((v42 & 1) != 0)
      {
        if (qword_1001E44E8 != -1)
          dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
        v43 = (id)qword_1001E44E0;
        _NRLogWithArgs(v43, 0, "%s%.30s:%-4d starting pending session monitoring source", "", "-[NRIKEv2Listener armPendingSessionCleanupTimer]", 582);

      }
      objc_destroyWeak(v53);
      objc_destroyWeak(from);

    }
    objc_destroyWeak(&v49);
    objc_destroyWeak(&location);

    v15 = v44;
    v19 = v45;
    v16 = v46;
  }

}

void sub_10000E9E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,id location)
{
  id *v25;
  id *v26;
  uint64_t v27;

  objc_destroyWeak(v25);
  objc_destroyWeak((id *)(v27 - 112));
  objc_destroyWeak(v26);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10000EA24(uint64_t a1, uint64_t a2)
{
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
  if (a2)
    sub_10013C890((uint64_t)NRDLocalDevice, *(void **)(a1 + 32));
}

void sub_10000EA6C(uint64_t a1, uint64_t a2)
{
  id WeakRetained;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  void *v9;
  id v10;
  uint64_t v11;
  void *v12;
  id v13;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (a2 == 3 && WeakRetained)
  {
    v5 = *(_QWORD **)(a1 + 32);
    v13 = WeakRetained;
    if (v5)
      v5 = (_QWORD *)v5[6];
    v6 = *(_QWORD *)(a1 + 40);
    v7 = v5;
    v8 = objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", v6));
    v9 = (void *)v8;
    if (v8)
      v10 = *(id *)(v8 + 8);
    else
      v10 = 0;

    WeakRetained = v13;
    if (v10 == v13)
    {
      if (qword_1001E44E8 != -1)
        dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
      if (_NRLogIsLevelEnabled(qword_1001E44E0, 1))
      {
        if (qword_1001E44E8 != -1)
          dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
        _NRLogWithArgs(qword_1001E44E0, 1, "%s%.30s:%-4d removing pending session %@", "", "-[NRIKEv2Listener addPendingSession:sessionConfig:childConfig:validateAuthBlock:responseBlock:key:]_block_invoke", 524, v13);
      }
      v11 = *(_QWORD *)(a1 + 32);
      if (v11)
        v12 = *(void **)(v11 + 48);
      else
        v12 = 0;
      objc_msgSend(v12, "setObject:forKeyedSubscript:", 0, *(_QWORD *)(a1 + 40));
      WeakRetained = v13;
    }
  }

}

void sub_10000EBB8(uint64_t a1)
{
  id *WeakRetained;
  uint64_t v3;
  id v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  id v10;
  id v11;
  id v12;
  uint64_t v13;
  void *i;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  _QWORD *v19;
  double v20;
  unint64_t v21;
  uint64_t v23;
  id v24;
  uint64_t v25;
  id v26;
  id v27;
  id v28;
  uint64_t v29;
  void *j;
  uint64_t v31;
  id obj;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  _BYTE v41[128];
  _BYTE v42[128];

  WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 40));
  v3 = (uint64_t)WeakRetained;
  if (WeakRetained)
  {
    v4 = WeakRetained[6];
    if (objc_msgSend(v4, "count"))
    {
      v31 = a1;
      v5 = *(_QWORD *)(v3 + 56);
      v6 = *(_QWORD *)(v31 + 32);

      v7 = v5 == v6;
      v8 = v31;
      if (v7)
      {
        v9 = mach_continuous_time();
        v37 = 0u;
        v38 = 0u;
        v39 = 0u;
        v40 = 0u;
        obj = *(id *)(v3 + 48);
        v10 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v37, v42, 16);
        if (v10)
        {
          v11 = v10;
          v12 = 0;
          v13 = *(_QWORD *)v38;
          do
          {
            for (i = 0; i != v11; i = (char *)i + 1)
            {
              if (*(_QWORD *)v38 != v13)
                objc_enumerationMutation(obj);
              v15 = *(_QWORD *)(*((_QWORD *)&v37 + 1) + 8 * (_QWORD)i);
              v16 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v3 + 48), "objectForKeyedSubscript:", v15));
              v19 = (_QWORD *)v16;
              v20 = 0.0;
              if (v16)
              {
                v21 = *(_QWORD *)(v16 + 48);
                if (v21 && v9 > v21)
                {
                  if (qword_1001E48A8 != -1)
                    dispatch_once(&qword_1001E48A8, &stru_1001B7C30);
                  LODWORD(v17) = dword_1001E48B0;
                  LODWORD(v18) = *(_DWORD *)algn_1001E48B4;
                  v20 = (double)(v9 - v21) * (0.000000001 * (double)v17) / (double)v18;
                }
              }
              if (v20 > *(double *)(v8 + 48))
              {
                if (qword_1001E44E8 != -1)
                  dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
                if (_NRLogIsLevelEnabled(qword_1001E44E0, 1))
                {
                  if (qword_1001E44E8 != -1)
                    dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
                  if (v19)
                    v23 = v19[1];
                  else
                    v23 = 0;
                  v24 = (id)qword_1001E44E0;
                  _NRLogWithArgs(v24, 1, "%s%.30s:%-4d cancelling pending session: %@", "", "-[NRIKEv2Listener armPendingSessionCleanupTimer]_block_invoke", 565, v23);

                  v8 = v31;
                }
                if (v19)
                  v25 = v19[5];
                else
                  v25 = 0;
                (*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD))(v25 + 16))(v25, 0, 0, 0);
                if (!v12)
                  v12 = objc_alloc_init((Class)NSMutableArray);
                objc_msgSend(v12, "addObject:", v15);
              }

            }
            v11 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v37, v42, 16);
          }
          while (v11);
        }
        else
        {
          v12 = 0;
        }

        v35 = 0u;
        v36 = 0u;
        v33 = 0u;
        v34 = 0u;
        v26 = v12;
        v27 = objc_msgSend(v26, "countByEnumeratingWithState:objects:count:", &v33, v41, 16);
        if (v27)
        {
          v28 = v27;
          v29 = *(_QWORD *)v34;
          do
          {
            for (j = 0; j != v28; j = (char *)j + 1)
            {
              if (*(_QWORD *)v34 != v29)
                objc_enumerationMutation(v26);
              objc_msgSend(*(id *)(v3 + 48), "setObject:forKeyedSubscript:", 0, *(_QWORD *)(*((_QWORD *)&v33 + 1) + 8 * (_QWORD)j));
            }
            v28 = objc_msgSend(v26, "countByEnumeratingWithState:objects:count:", &v33, v41, 16);
          }
          while (v28);
        }

        sub_10000EF60(v3);
      }
    }
    else
    {

    }
  }

}

void sub_10000EF60(uint64_t a1)
{
  void *v2;

  if (!objc_msgSend(*(id *)(a1 + 48), "count") && *(_QWORD *)(a1 + 56))
  {
    if (qword_1001E44E8 != -1)
      dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
    if (_NRLogIsLevelEnabled(qword_1001E44E0, 0))
    {
      if (qword_1001E44E8 != -1)
        dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
      _NRLogWithArgs(qword_1001E44E0, 0, "%s%.30s:%-4d cancelling pending session monitoring source", "", "-[NRIKEv2Listener disarmPendingSessionCleanupTimer]", 592);
    }
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 56));
    v2 = *(void **)(a1 + 56);
    *(_QWORD *)(a1 + 56) = 0;

  }
}

void sub_10000F054(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001E44E0;
  qword_1001E44E0 = (uint64_t)v1;

}

id sub_10000F084()
{
  objc_opt_self();
  if (qword_1001E44D8 != -1)
    dispatch_once(&qword_1001E44D8, &stru_1001B5E70);
  return (id)qword_1001E44D0;
}

void sub_10000F0C8(id a1)
{
  NRIKEv2Listener *v1;
  void *v2;

  v1 = objc_alloc_init(NRIKEv2Listener);
  v2 = (void *)qword_1001E44D0;
  qword_1001E44D0 = (uint64_t)v1;

}

uint64_t sub_10000F0F0(uint64_t a1)
{
  _BOOL8 v1;
  id v3;
  id v4;
  id v5;
  id v6;
  void *v7;
  uint64_t v8;
  id v10;
  int IsLevelEnabled;
  id v12;
  uint64_t v13;

  if (*(_QWORD *)(a1 + 16))
    return 1;
  v3 = sub_100112198();
  objc_msgSend(v3, "setRequestChildlessSA:", 1);
  if (qword_1001E4870 != -1)
    dispatch_once(&qword_1001E4870, &stru_1001B7BB0);
  if (byte_1001E4868)
    objc_msgSend(v3, "setForceUDPEncapsulation:", 1);
  v4 = objc_alloc((Class)NEIKEv2Listener);
  v5 = *(id *)(a1 + 8);
  LOBYTE(v13) = 1;
  v6 = objc_msgSend(v4, "initWithListenerIKEConfig:kernelSASessionName:listenerUDPPort:listenerQueue:delegate:delegateQueue:includeP2P:", v3, CFSTR("terminusIKE-Shared-Listener"), CFSTR("62743"), v5, a1, v5, v13);
  v7 = *(void **)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v6;

  v8 = *(_QWORD *)(a1 + 16);
  v1 = v8 != 0;
  if (v8)
  {
    if (qword_1001E44E8 != -1)
      dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
    if (_NRLogIsLevelEnabled(qword_1001E44E0, 0))
    {
      if (qword_1001E44E8 != -1)
        dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
      _NRLogWithArgs(qword_1001E44E0, 0, "%s%.30s:%-4d Created shared IKE listener", "", "-[NRIKEv2Listener resume]", 192);
    }
  }
  else
  {
    v10 = sub_10000E2AC();
    IsLevelEnabled = _NRLogIsLevelEnabled(v10, 17);

    if (IsLevelEnabled)
    {
      v12 = sub_10000E2AC();
      _NRLogWithArgs(v12, 17, "Failed to create shared IKE listener");

    }
  }

  return v1;
}

void sub_10000F2C4(uint64_t a1)
{
  id v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  id *v5;
  id v6;
  id v7;
  uint64_t v8;
  void *v9;
  void *v10;
  void *v11;
  id v12;
  id v13;
  id v14;
  id v15;
  uint64_t v16;
  void *i;
  void *v18;
  uint64_t v19;
  id v20;
  id v21;
  id v22;
  id v23;
  uint64_t v24;
  void *j;
  void *v26;
  id v27;
  id v28;
  id v29;
  id v30;
  uint64_t v31;
  void *k;
  void *v33;
  uint64_t v34;
  id v35;
  id v36;
  id v37;
  id v38;
  uint64_t v39;
  void *m;
  void *v41;
  id v42;
  id v43;
  id *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  id v48;
  void *v49;
  id v50;
  id v51;
  id v52;
  id v53;
  id *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  void *v59;
  void *v60;
  id v61;
  id v62;
  id *v63;
  id v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  _BYTE v81[128];
  _BYTE v82[128];
  _BYTE v83[128];
  _BYTE v84[128];

  if (*(_QWORD *)(a1 + 40))
  {
    if (qword_1001E44E8 != -1)
      dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
    if (_NRLogIsLevelEnabled(qword_1001E44E0, 1))
    {
      if (qword_1001E44E8 != -1)
        dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
      _NRLogWithArgs(qword_1001E44E0, 1, "%s%.30s:%-4d Uninstalling route rules to allow all incoming IKE connections", "", "-[NRIKEv2Listener updateRouteRules]", 278);
    }
    objc_opt_self(NRDPolicySessionManager);
    if (qword_1001E4A20 != -1)
      dispatch_once(&qword_1001E4A20, &stru_1001B8590);
    v1 = (id)qword_1001E4A18;
    sub_100127618((uint64_t)v1, CFSTR("NRIKEv2Listener"));

    objc_opt_self(NRDPolicySessionManager);
    if (qword_1001E4A20 != -1)
      dispatch_once(&qword_1001E4A20, &stru_1001B8590);
    v62 = (id)qword_1001E4A18;
    if (v62)
    {
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v62 + 1));
      if ((objc_msgSend(*((id *)v62 + 2), "apply") & 1) == 0)
        sub_100109270(CFSTR("NRPolicySessionManager"), CFSTR("ApplyPolicy Failed"), 0, 1, CFSTR("Failed to apply policies"), v2, v3, v4, v58);
    }

  }
  else
  {
    v5 = (id *)a1;
    v6 = objc_alloc_init((Class)NSMutableArray);
    v60 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyRouteRule routeRuleWithAction:forType:](NEPolicyRouteRule, "routeRuleWithAction:forType:", 2, 0));
    objc_msgSend(v6, "addObject:");
    v7 = objc_alloc_init((Class)NSMutableArray);
    v8 = objc_claimAutoreleasedReturnValue(+[NWAddressEndpoint endpointWithHostname:port:](NWAddressEndpoint, "endpointWithHostname:port:", CFSTR("::"), CFSTR("62743")));
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](NEPolicyCondition, "allInterfaces"));
    objc_msgSend(v7, "addObject:", v9);

    v59 = (void *)v8;
    v10 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition flowLocalAddress:prefix:](NEPolicyCondition, "flowLocalAddress:prefix:", v8, 0));
    objc_msgSend(v7, "addObject:", v10);

    v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5[3], "allValues"));
    v61 = v7;
    if (objc_msgSend(v11, "count"))
    {
      v63 = v5;
      v12 = objc_alloc_init((Class)NSMutableSet);
      v77 = 0u;
      v78 = 0u;
      v79 = 0u;
      v80 = 0u;
      v13 = v11;
      v14 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v77, v84, 16);
      if (v14)
      {
        v15 = v14;
        v16 = *(_QWORD *)v78;
        do
        {
          for (i = 0; i != v15; i = (char *)i + 1)
          {
            if (*(_QWORD *)v78 != v16)
              objc_enumerationMutation(v13);
            v19 = *(_QWORD *)(*((_QWORD *)&v77 + 1) + 8 * (_QWORD)i);
            if (v19 && (v20 = *(id *)(v19 + 8)) != 0)
            {
              v18 = v20;
              objc_msgSend(v12, "addObject:", v20);

            }
            else
            {
              if (qword_1001E44E8 != -1)
                dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
              if (_NRLogIsLevelEnabled(qword_1001E44E0, 17))
              {
                if (qword_1001E44E8 != -1)
                  dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
                _NRLogWithArgs(qword_1001E44E0, 17, "%@: invalid object at interface name index", v19);
              }
            }
          }
          v15 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v77, v84, 16);
        }
        while (v15);
      }

      v75 = 0u;
      v76 = 0u;
      v73 = 0u;
      v74 = 0u;
      v21 = v12;
      v22 = objc_msgSend(v21, "countByEnumeratingWithState:objects:count:", &v73, v83, 16);
      v7 = v61;
      if (v22)
      {
        v23 = v22;
        v24 = *(_QWORD *)v74;
        do
        {
          for (j = 0; j != v23; j = (char *)j + 1)
          {
            if (*(_QWORD *)v74 != v24)
              objc_enumerationMutation(v21);
            v26 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyRouteRule routeRuleWithAction:forInterfaceName:](NEPolicyRouteRule, "routeRuleWithAction:forInterfaceName:", 1, *(_QWORD *)(*((_QWORD *)&v73 + 1) + 8 * (_QWORD)j)));
            objc_msgSend(v6, "addObject:", v26);

          }
          v23 = objc_msgSend(v21, "countByEnumeratingWithState:objects:count:", &v73, v83, 16);
        }
        while (v23);
      }

      v5 = v63;
    }
    v64 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v5[4], "allValues"));
    if (objc_msgSend(v64, "count"))
    {
      v27 = objc_alloc_init((Class)NSMutableSet);
      v69 = 0u;
      v70 = 0u;
      v71 = 0u;
      v72 = 0u;
      v28 = v64;
      v29 = objc_msgSend(v28, "countByEnumeratingWithState:objects:count:", &v69, v82, 16);
      if (v29)
      {
        v30 = v29;
        v31 = *(_QWORD *)v70;
        do
        {
          for (k = 0; k != v30; k = (char *)k + 1)
          {
            if (*(_QWORD *)v70 != v31)
              objc_enumerationMutation(v28);
            v34 = *(_QWORD *)(*((_QWORD *)&v69 + 1) + 8 * (_QWORD)k);
            if (v34 && (v35 = *(id *)(v34 + 8)) != 0)
            {
              v33 = v35;
              objc_msgSend(v27, "addObject:", v35);

            }
            else
            {
              if (qword_1001E44E8 != -1)
                dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
              if (_NRLogIsLevelEnabled(qword_1001E44E0, 17))
              {
                if (qword_1001E44E8 != -1)
                  dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
                _NRLogWithArgs(qword_1001E44E0, 17, "%@: invalid object at interface name index", v34);
              }
            }
          }
          v30 = objc_msgSend(v28, "countByEnumeratingWithState:objects:count:", &v69, v82, 16);
        }
        while (v30);
      }

      v67 = 0u;
      v68 = 0u;
      v65 = 0u;
      v66 = 0u;
      v36 = v27;
      v37 = objc_msgSend(v36, "countByEnumeratingWithState:objects:count:", &v65, v81, 16);
      v7 = v61;
      if (v37)
      {
        v38 = v37;
        v39 = *(_QWORD *)v66;
        do
        {
          for (m = 0; m != v38; m = (char *)m + 1)
          {
            if (*(_QWORD *)v66 != v39)
              objc_enumerationMutation(v36);
            v41 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyRouteRule routeRuleWithAction:forInterfaceName:](NEPolicyRouteRule, "routeRuleWithAction:forInterfaceName:", 1, *(_QWORD *)(*((_QWORD *)&v65 + 1) + 8 * (_QWORD)m)));
            objc_msgSend(v6, "addObject:", v41);

          }
          v38 = objc_msgSend(v36, "countByEnumeratingWithState:objects:count:", &v65, v81, 16);
        }
        while (v38);
      }

    }
    if (qword_1001E44E8 != -1)
      dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
    if (_NRLogIsLevelEnabled(qword_1001E44E0, 1))
    {
      if (qword_1001E44E8 != -1)
        dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
      _NRLogWithArgs(qword_1001E44E0, 1, "%s%.30s:%-4d adding route rules %@", "", "-[NRIKEv2Listener updateRouteRules]", 263, v6);
    }
    objc_opt_self(NRDPolicySessionManager);
    if (qword_1001E4A20 != -1)
      dispatch_once(&qword_1001E4A20, &stru_1001B8590);
    v42 = (id)qword_1001E4A18;
    sub_100127618((uint64_t)v42, CFSTR("NRIKEv2Listener"));

    objc_opt_self(NRDPolicySessionManager);
    if (qword_1001E4A20 != -1)
      dispatch_once(&qword_1001E4A20, &stru_1001B8590);
    v43 = (id)qword_1001E4A18;
    v44 = (id *)v43;
    if (v43)
    {
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v43 + 1));
      if ((objc_msgSend(v44[2], "apply") & 1) == 0)
        sub_100109270(CFSTR("NRPolicySessionManager"), CFSTR("ApplyPolicy Failed"), 0, 1, CFSTR("Failed to apply policies"), v45, v46, v47, v58);
    }

    v48 = objc_alloc((Class)NEPolicy);
    v49 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult routeRules:](NEPolicyResult, "routeRules:", v6));
    v50 = objc_msgSend(v48, "initWithOrder:result:conditions:", 6, v49, v7);

    objc_opt_self(NRDPolicySessionManager);
    if (qword_1001E4A20 != -1)
      dispatch_once(&qword_1001E4A20, &stru_1001B8590);
    v51 = (id)qword_1001E4A18;
    v52 = sub_100127310((uint64_t)v51, CFSTR("NRIKEv2Listener"), v50);

    objc_opt_self(NRDPolicySessionManager);
    if (qword_1001E4A20 != -1)
      dispatch_once(&qword_1001E4A20, &stru_1001B8590);
    v53 = (id)qword_1001E4A18;
    v54 = (id *)v53;
    if (v53)
    {
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v53 + 1));
      if ((objc_msgSend(v54[2], "apply") & 1) == 0)
        sub_100109270(CFSTR("NRPolicySessionManager"), CFSTR("ApplyPolicy Failed"), 0, 1, CFSTR("Failed to apply policies"), v55, v56, v57, v58);
    }

  }
}

void sub_10000FC60(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  uint64_t v6;
  void *v7;
  void *v8;
  uint64_t v9;
  id v10;
  void *v11;
  uint64_t v12;
  id v13;
  void *v14;
  id v15;
  id v16;
  id v17;
  id v18;
  uint64_t v19;
  id v20;
  id v21;

  v21 = a2;
  v3 = *(id *)(a1 + 48);
  if (v3)
  {
    v4 = v3;
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "objectForKeyedSubscript:", v21));

    if (v5)
    {
      v6 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "objectForKeyedSubscript:", v21));
      objc_msgSend(*(id *)(a1 + 48), "setObject:forKeyedSubscript:", 0, v21);
      if (v6)
      {
        objc_msgSend(*(id *)(v6 + 8), "setStateUpdateBlock:", 0);
        objc_msgSend(*(id *)(v6 + 8), "setClientQueue:", 0);
        v7 = *(void **)(v6 + 8);
      }
      else
      {
        objc_msgSend(0, "setStateUpdateBlock:", 0);
        objc_msgSend(0, "setClientQueue:", 0);
        v7 = 0;
      }
      if (objc_msgSend(v7, "state") == (id)3)
      {
        if (qword_1001E44E8 != -1)
          dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
        if (!_NRLogIsLevelEnabled(qword_1001E44E0, 1))
          goto LABEL_23;
        if (qword_1001E44E8 == -1)
        {
          v8 = (void *)qword_1001E44E0;
          if (v6)
          {
LABEL_11:
            v9 = *(_QWORD *)(v6 + 8);
LABEL_12:
            v10 = v8;
            _NRLogWithArgs(v10, 1, "%s%.30s:%-4d not processing disconnected pending session: %@", "", "-[NRIKEv2Listener processPendingSessionForKey:]", 484, v9);

LABEL_23:
            goto LABEL_24;
          }
        }
        else
        {
          dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
          v8 = (void *)qword_1001E44E0;
          if (v6)
            goto LABEL_11;
        }
        v9 = 0;
        goto LABEL_12;
      }
      if (qword_1001E44E8 != -1)
        dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
      if (!_NRLogIsLevelEnabled(qword_1001E44E0, 1))
      {
LABEL_20:
        v14 = *(void **)(a1 + 16);
        if (v6)
        {
          v15 = *(id *)(v6 + 8);
          v16 = *(id *)(v6 + 16);
          v17 = *(id *)(v6 + 24);
          v18 = *(id *)(v6 + 32);
          v19 = *(_QWORD *)(v6 + 40);
        }
        else
        {
          v18 = 0;
          v16 = 0;
          v15 = 0;
          v17 = 0;
          v19 = 0;
        }
        v20 = v14;
        objc_msgSend((id)a1, "requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBlock:", v20, v15, v16, v17, v18, v19);

        sub_10000EF60(a1);
        goto LABEL_23;
      }
      if (qword_1001E44E8 == -1)
      {
        v11 = (void *)qword_1001E44E0;
        if (v6)
        {
LABEL_18:
          v12 = *(_QWORD *)(v6 + 8);
LABEL_19:
          v13 = v11;
          _NRLogWithArgs(v13, 1, "%s%.30s:%-4d processing pending session: %@", "", "-[NRIKEv2Listener processPendingSessionForKey:]", 487, v12);

          goto LABEL_20;
        }
      }
      else
      {
        dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
        v11 = (void *)qword_1001E44E0;
        if (v6)
          goto LABEL_18;
      }
      v12 = 0;
      goto LABEL_19;
    }
  }
LABEL_24:

}

void sub_10000FF40(uint64_t a1, void *a2)
{
  id v3;
  id v4;
  id v5;
  id v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  _QWORD *v10;
  void *v11;
  id v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  _BYTE v17[128];

  v3 = a2;
  if (a1)
  {
    v15 = 0u;
    v16 = 0u;
    v13 = 0u;
    v14 = 0u;
    v4 = *(id *)(a1 + 32);
    v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v13, v17, 16);
    if (!v5)
    {
LABEL_19:
      v12 = v4;
LABEL_20:

      goto LABEL_21;
    }
    v6 = v5;
    v7 = *(_QWORD *)v14;
LABEL_5:
    v8 = 0;
    while (1)
    {
      if (*(_QWORD *)v14 != v7)
        objc_enumerationMutation(v4);
      v9 = *(void **)(*((_QWORD *)&v13 + 1) + 8 * v8);
      v10 = (_QWORD *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:", v9));
      v11 = v10;
      if (v10)
      {
        if ((id)v10[4] == v3)
          break;
      }

      if (v6 == (id)++v8)
      {
        v6 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v13, v17, 16);
        if (!v6)
          goto LABEL_19;
        goto LABEL_5;
      }
    }
    v12 = v9;

    if (v12)
    {
      objc_msgSend(*(id *)(a1 + 32), "setObject:forKeyedSubscript:", 0, v12);
      if (qword_1001E44E8 != -1)
        dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
      if (_NRLogIsLevelEnabled(qword_1001E44E0, 0))
      {
        if (qword_1001E44E8 != -1)
          dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
        _NRLogWithArgs(qword_1001E44E0, 0, "%s%.30s:%-4d Successfully un-registered pairing client %@", "", "-[NRIKEv2Listener unregisterPairingClient:]", 353, v3, (_QWORD)v13);
      }
      sub_10000F2C4(a1);
      goto LABEL_20;
    }
  }
LABEL_21:

}

uint64_t sub_10001013C(uint64_t IsLevelEnabled, void *a2, void *a3, void *a4)
{
  id v8;
  id v9;
  id v10;
  void *v11;
  void *v12;
  id v13;
  void *v14;
  id v15;
  void *v16;
  uint64_t v17;
  void *v18;
  id v19;
  id v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  id v25;
  id v26;
  BOOL v27;
  id v28;
  NRIKEv2ListenerRegistration *v29;
  id *p_isa;
  id v32;
  id v33;
  id v34;
  void *v35;
  id obj;

  v8 = a2;
  v9 = a3;
  v10 = a4;
  v11 = v10;
  if (!IsLevelEnabled)
    goto LABEL_32;
  if (!v8)
  {
    v32 = sub_10000E2AC();
    IsLevelEnabled = _NRLogIsLevelEnabled(v32, 17);

    if (!(_DWORD)IsLevelEnabled)
      goto LABEL_32;
    v13 = sub_10000E2AC();
    _NRLogWithArgs(v13, 17, "%s called with null link");
    goto LABEL_39;
  }
  if (!v9)
  {
    v33 = sub_10000E2AC();
    IsLevelEnabled = _NRLogIsLevelEnabled(v33, 17);

    if (!(_DWORD)IsLevelEnabled)
      goto LABEL_32;
    v13 = sub_10000E2AC();
    _NRLogWithArgs(v13, 17, "%s called with null interfaceName");
    goto LABEL_39;
  }
  if (!v10)
  {
    v34 = sub_10000E2AC();
    IsLevelEnabled = _NRLogIsLevelEnabled(v34, 17);

    if (!(_DWORD)IsLevelEnabled)
      goto LABEL_32;
    v13 = sub_10000E2AC();
    _NRLogWithArgs(v13, 17, "%s called with null localEndpoint");
LABEL_39:
    IsLevelEnabled = 0;
LABEL_31:

    goto LABEL_32;
  }
  if (objc_msgSend(v8, "state") != 255)
  {
    obj = a2;
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "nrUUID"));
    v13 = sub_10000E3A4(IsLevelEnabled, v9, v11, v12);

    v14 = *(void **)(IsLevelEnabled + 24);
    if (!v14)
    {
      v15 = objc_alloc_init((Class)NSMutableDictionary);
      v16 = *(void **)(IsLevelEnabled + 24);
      *(_QWORD *)(IsLevelEnabled + 24) = v15;

      v14 = *(void **)(IsLevelEnabled + 24);
    }
    v17 = objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "objectForKeyedSubscript:", v13));
    v18 = (void *)v17;
    if (!v17)
      goto LABEL_12;
    v35 = v11;
    v19 = v9;
    v20 = *(id *)(v17 + 24);
    v21 = a4;
    v22 = a3;
    v23 = v18;
    v24 = v13;
    v25 = objc_msgSend(v20, "identifier");
    v26 = objc_msgSend(v8, "identifier");

    v9 = v19;
    v11 = v35;
    v27 = v25 == v26;
    v13 = v24;
    v18 = v23;
    a3 = v22;
    a4 = v21;
    if (v27)
    {
      IsLevelEnabled = 1;
    }
    else
    {
LABEL_12:
      if ((sub_10000F0F0(IsLevelEnabled) & 1) != 0)
      {
        if (qword_1001E44E8 != -1)
          dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
        if (_NRLogIsLevelEnabled(qword_1001E44E0, 0))
        {
          if (qword_1001E44E8 != -1)
            dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
          _NRLogWithArgs(qword_1001E44E0, 0, "%s%.30s:%-4d Successfully registered link %@", "", "-[NRIKEv2Listener registerLink:localInterfaceName:localEndpoint:]", 428, v8);
        }
        v28 = v9;
        v29 = objc_alloc_init(NRIKEv2ListenerRegistration);
        p_isa = (id *)&v29->super.isa;
        if (v29)
        {
          objc_storeStrong((id *)&v29->_link, obj);
          objc_storeStrong(p_isa + 2, a4);
          objc_storeStrong(p_isa + 1, a3);
        }
        objc_msgSend(*(id *)(IsLevelEnabled + 24), "setObject:forKeyedSubscript:", p_isa, v13);
        sub_10000F2C4(IsLevelEnabled);
        sub_10000FC60(IsLevelEnabled, v13);

        IsLevelEnabled = 1;
        v9 = v28;
      }
      else
      {
        if (qword_1001E44E8 != -1)
          dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
        if (_NRLogIsLevelEnabled(qword_1001E44E0, 17))
        {
          if (qword_1001E44E8 != -1)
            dispatch_once(&qword_1001E44E8, &stru_1001B5EE0);
          _NRLogWithArgs(qword_1001E44E0, 17, "Failed to register link %@", v8);
        }
        IsLevelEnabled = 0;
      }
    }

    goto LABEL_31;
  }
  IsLevelEnabled = 0;
LABEL_32:

  return IsLevelEnabled;
}

void sub_100010564(id a1)
{
  NRPairingClientManager *v1;
  _QWORD *v2;
  void *v3;
  id v4;

  v1 = [NRPairingClientManager alloc];
  v4 = sub_10014CFBC();
  v2 = sub_1000105BC(v1, v4);
  v3 = (void *)qword_1001E44F0;
  qword_1001E44F0 = (uint64_t)v2;

}

_QWORD *sub_1000105BC(_QWORD *a1, void *a2)
{
  id v4;
  id v5;
  id v6;
  void *v7;
  id v8;
  void *v9;
  id v11;
  int IsLevelEnabled;
  id v13;
  uint64_t v14;
  char *v15;
  int *v16;
  uint64_t v17;
  id v18;
  uint64_t v19;
  objc_super v20;

  v4 = a2;
  if (a1)
  {
    v20.receiver = a1;
    v20.super_class = (Class)NRPairingClientManager;
    v5 = objc_msgSendSuper2(&v20, "init");
    if (!v5)
    {
      v11 = sub_100010744();
      IsLevelEnabled = _NRLogIsLevelEnabled(v11, 16);

      if (IsLevelEnabled)
      {
        v13 = sub_100010744();
        _NRLogWithArgs(v13, 16, "%s%.30s:%-4d ABORTING: [super init] failed", "", "-[NRPairingClientManager initWithQueue:]", 48);

      }
      v14 = _os_log_pack_size(12);
      v15 = (char *)&v19 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
      v16 = __error();
      v17 = _os_log_pack_fill(v15, v14, *v16, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)v17 = 136446210;
      *(_QWORD *)(v17 + 4) = "-[NRPairingClientManager initWithQueue:]";
      v18 = sub_100010744();
      _NRLogAbortWithPack(v18, v15);
    }
    a1 = v5;
    objc_storeStrong((id *)v5 + 1, a2);
    v6 = objc_alloc_init((Class)NSMutableDictionary);
    v7 = (void *)a1[2];
    a1[2] = v6;

    v8 = objc_alloc_init((Class)NSMutableDictionary);
    v9 = (void *)a1[3];
    a1[3] = v8;

  }
  return a1;
}

id sub_100010744()
{
  if (qword_1001E4508 != -1)
    dispatch_once(&qword_1001E4508, &stru_1001B5F20);
  return (id)qword_1001E4500;
}

void sub_100010784(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001E4500;
  qword_1001E4500 = (uint64_t)v1;

}

uint64_t sub_1000107B4(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  if (v1)
    v1 = *(_QWORD *)(v1 + 16);
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(v1 + 16))(v1, *(unsigned __int8 *)(a1 + 40), *(unsigned __int8 *)(a1 + 41));
}

void sub_100010D2C(_Unwind_Exception *a1)
{
  id *v1;
  id *v2;
  id *v3;
  uint64_t v4;

  objc_destroyWeak(v3);
  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v4 - 88));
  _Unwind_Resume(a1);
}

void sub_100010DE0(uint64_t a1)
{
  NSObject **WeakRetained;
  id *v2;
  id *v3;
  id *v4;
  id *v5;
  id *v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  NSObject **v10;

  WeakRetained = (NSObject **)objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained && !*((_BYTE *)WeakRetained + 9) && !*((_BYTE *)WeakRetained + 11) && !*((_BYTE *)WeakRetained + 12))
  {
    v10 = WeakRetained;
    objc_opt_self(NRLinkDirector);
    if (qword_1001E4710 != -1)
      dispatch_once(&qword_1001E4710, &stru_1001B6E60);
    v2 = (id *)(id)qword_1001E4708;
    v3 = v2;
    if (v2)
    {
      v4 = (id *)v2[6];
      v5 = v4;
      if (v4)
        objc_msgSend(v4[33], "removeObject:", v10);
    }
    else
    {
      v5 = 0;
    }

    v6 = (id *)v10;
    *((_BYTE *)v10 + 10) = 0;
    v7 = v10[5];
    if (v7)
    {
      dispatch_source_cancel(v7);
      v8 = v10[5];
      v10[5] = 0;

      v6 = (id *)v10;
    }
    objc_msgSend(v6[11], "removeAllObjects");
    if (qword_1001E4518 != -1)
      dispatch_once(&qword_1001E4518, &stru_1001B6140);
    if (_NRLogIsLevelEnabled(qword_1001E4510, 0))
    {
      if (qword_1001E4518 != -1)
        dispatch_once(&qword_1001E4518, &stru_1001B6140);
      _NRLogWithArgs(qword_1001E4510, 0, "%s%.30s:%-4d Disabling PHS peers created", "", "-[NROnDemandLinkSetupManager handlePHSStopped]", 788);
    }
    sub_1000134C0((uint64_t)v10);
    if (!*((_BYTE *)v10 + 11) && !*((_BYTE *)v10 + 12))
      sub_1000136C4((uint64_t)v10);
    v9 = sub_10014CFBC();
    dispatch_async(v9, &stru_1001B69F0);

    WeakRetained = v10;
  }

}

void sub_100010FA4(uint64_t a1)
{
  void *v2;
  void *v3;
  id v4;
  id v5;
  uint64_t v6;
  void *i;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  _BYTE v12[128];

  if (*(_BYTE *)(a1 + 16))
  {
    v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 56), "activeDevices"));

    if (v2)
    {
      v10 = 0u;
      v11 = 0u;
      v8 = 0u;
      v9 = 0u;
      v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 56), "activeDevices", 0));
      v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v8, v12, 16);
      if (v4)
      {
        v5 = v4;
        v6 = *(_QWORD *)v9;
        do
        {
          for (i = 0; i != v5; i = (char *)i + 1)
          {
            if (*(_QWORD *)v9 != v6)
              objc_enumerationMutation(v3);
            sub_1000124D0(a1, *(void **)(*((_QWORD *)&v8 + 1) + 8 * (_QWORD)i));
          }
          v5 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v8, v12, 16);
        }
        while (v5);
      }

    }
  }
}

void sub_1000110C4(uint64_t a1)
{
  uint64_t v1;
  id v2;
  __objc2_prot *v3;
  id v4;
  void *i;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void *v9;
  id v10;
  void *v11;
  void *v12;
  void *v13;
  id v14;
  char *v15;
  char *v16;
  void *v17;
  id v18;
  id v19;
  BOOL v20;
  void *v21;
  void *v22;
  char *v23;
  void *v24;
  id v25;
  void *v26;
  id v27;
  void *v28;
  id v29;
  NRValidPeer *v30;
  void *v31;
  id *v32;
  void *v33;
  char *v34;
  uint64_t v35;
  id obj;
  uint64_t v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  const __CFString *v42;
  id v43;
  _BYTE v44[128];
  _OWORD bytes[2];

  v1 = a1;
  v38 = 0u;
  v39 = 0u;
  v40 = 0u;
  v41 = 0u;
  obj = objc_msgSend(*(id *)(a1 + 72), "copy");
  v2 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v38, v44, 16);
  v3 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
  if (v2)
  {
    v4 = v2;
    v37 = *(_QWORD *)v39;
    v35 = v1;
    do
    {
      for (i = 0; i != v4; i = (char *)i + 1)
      {
        if (*(_QWORD *)v39 != v37)
          objc_enumerationMutation(obj);
        v7 = *(_QWORD *)(*((_QWORD *)&v38 + 1) + 8 * (_QWORD)i);
        if (v7)
          v8 = *(void **)(v7 + 8);
        else
          v8 = 0;
        v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "objectForKeyedSubscript:", CFSTR("relay-req")));
        if (objc_msgSend(v9, "count"))
        {
          v10 = objc_alloc_init((Class)NSMutableDictionary);
          objc_msgSend(v10, "setObject:forKeyedSubscript:", &off_1001C4558, CFSTR("v"));
          objc_msgSend(v10, "setObject:forKeyedSubscript:", &off_1001C4570, CFSTR("nrv"));
          v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("rid")));
          objc_msgSend(v10, "setObject:forKeyedSubscript:", v11, CFSTR("rid"));

          v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("id")));
          v13 = v12;
          if (v12)
          {
            v14 = v12;
            if (nrSupportsPHSProxy() && *(_BYTE *)(v1 + 15) && *(_BYTE *)(v1 + 13))
            {
              v15 = sub_100134EE8((uint64_t)NRDLocalDevice, v14, 0);
              v16 = v15;
              if (v15)
                v17 = (void *)*((_QWORD *)v15 + 16);
              else
                v17 = 0;
              v18 = v17;
              v19 = objc_msgSend(v18, "proxyCapability");

              v20 = v19 == (id)2;
              v1 = v35;
              v3 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
              if (!v20)
              {
                objc_msgSend(v10, "setObject:forKeyedSubscript:", &off_1001C45A0, CFSTR("rspc"));
                if (qword_1001E48E0 != -1)
                  dispatch_once(&qword_1001E48E0, &stru_1001B7CE0);
                v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", byte_1001E48D8));
                objc_msgSend(v10, "setObject:forKeyedSubscript:", v21, CFSTR("t"));

                objc_msgSend(v10, "setObject:forKeyedSubscript:", &off_1001C45B8, CFSTR("fl"));
                v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("reg")));
                v23 = sub_100134EE8((uint64_t)NRDLocalDevice, v14, 0);
                v33 = v22;
                v34 = v23;
                if (objc_msgSend(v22, "BOOLValue") && v23 && v23[8])
                {
                  objc_msgSend(v10, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("reg"));
                }
                else
                {
                  objc_msgSend(v10, "setObject:forKeyedSubscript:", &__kCFBooleanFalse, CFSTR("reg"));
                  v25 = v14;
                  v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v35 + 80), "objectForKeyedSubscript:", v25));

                  if (!v26)
                  {
                    memset(bytes, 0, sizeof(bytes));
                    while (SecRandomCopyBytes(kSecRandomDefault, 0x20uLL, bytes))
                      ;
                    v27 = +[NSData _newZeroingDataWithBytes:length:](NSData, "_newZeroingDataWithBytes:length:", bytes, 32);
                    objc_msgSend(*(id *)(v35 + 80), "setObject:forKeyedSubscript:", v27, v25);

                  }
                  v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v35 + 80), "objectForKeyedSubscript:", v25));

                  objc_msgSend(v10, "setObject:forKeyedSubscript:", v28, CFSTR("psk"));
                  if (v34 && v34[8])
                  {
                    if (qword_1001E4518 != -1)
                      dispatch_once(&qword_1001E4518, &stru_1001B6140);
                    if (_NRLogIsLevelEnabled(qword_1001E4510, 0))
                    {
                      if (qword_1001E4518 != -1)
                        dispatch_once(&qword_1001E4518, &stru_1001B6140);
                      _NRLogWithArgs(qword_1001E4510, 0, "%s%.30s:%-4d unregistering device %@ as peer does not have a matching registration", "", "-[NROnDemandLinkSetupManager sendReplyForInternetRelayRequest]", 560, v34);
                    }
                    v29 = *((id *)v34 + 4);
                    sub_1001370D8((uint64_t)NRDLocalDevice, v29, &stru_1001B6050);

                  }
                }
                v30 = [NRValidPeer alloc];
                v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("nrv")));
                v32 = sub_10001183C((id *)&v30->super.isa, v31);
                v1 = v35;
                objc_msgSend(*(id *)(v35 + 88), "setObject:forKeyedSubscript:", v32, v14);

                v3 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
LABEL_34:
                v42 = CFSTR("relay-res");
                v43 = v10;
                v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v43, &v42, 1));
                if (v7)
                  v6 = *(_QWORD *)(v7 + 24);
                else
                  v6 = 0;
                (*(void (**)(uint64_t, void *))(v6 + 16))(v6, v24);
                objc_msgSend(*(id *)(v1 + 72), "removeObject:", v7);

                goto LABEL_7;
              }
            }
            else
            {

            }
          }
          if (qword_1001E4518 != -1)
            dispatch_once(&qword_1001E4518, &stru_1001B6140);
          if (_NRLogIsLevelEnabled(v3[18].isa, 0))
          {
            if (qword_1001E4518 != -1)
              dispatch_once(&qword_1001E4518, &stru_1001B6140);
            _NRLogWithArgs(v3[18].isa, 0, "%s%.30s:%-4d cannot provide internet relay service to peer ids device ID %@", "", "-[NROnDemandLinkSetupManager sendReplyForInternetRelayRequest]", 545, v13);
          }
          objc_msgSend(v10, "setObject:forKeyedSubscript:", &off_1001C4588, CFSTR("rspc"));
          goto LABEL_34;
        }
LABEL_7:

      }
      v4 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v38, v44, 16);
    }
    while (v4);
  }

  if (objc_msgSend(*(id *)(v1 + 88), "count"))
  {
    if (qword_1001E4518 != -1)
      dispatch_once(&qword_1001E4518, &stru_1001B6140);
    if (_NRLogIsLevelEnabled(v3[18].isa, 16))
    {
      if (qword_1001E4518 != -1)
        dispatch_once(&qword_1001E4518, &stru_1001B6140);
      _NRLogWithArgs(v3[18].isa, 16, "%s%.30s:%-4d sent response to peer(s)", "", "-[NROnDemandLinkSetupManager sendReplyForInternetRelayRequest]", 575);
    }
    sub_100011998(v1);
  }
  else
  {
    if (qword_1001E4518 != -1)
      dispatch_once(&qword_1001E4518, &stru_1001B6140);
    if (_NRLogIsLevelEnabled(v3[18].isa, 16))
    {
      if (qword_1001E4518 != -1)
        dispatch_once(&qword_1001E4518, &stru_1001B6140);
      _NRLogWithArgs(v3[18].isa, 16, "%s%.30s:%-4d no valid peers for internet relay", "", "-[NROnDemandLinkSetupManager sendReplyForInternetRelayRequest]", 578);
    }
  }
}

id *sub_10001183C(id *a1, void *a2)
{
  id v4;
  id *v5;
  id v7;
  int IsLevelEnabled;
  id v9;
  uint64_t v10;
  char *v11;
  int *v12;
  uint64_t v13;
  id v14;
  uint64_t v15;
  objc_super v16;

  v4 = a2;
  if (a1)
  {
    v16.receiver = a1;
    v16.super_class = (Class)NRValidPeer;
    v5 = (id *)objc_msgSendSuper2(&v16, "init");
    if (!v5)
    {
      v7 = sub_10001248C();
      IsLevelEnabled = _NRLogIsLevelEnabled(v7, 16);

      if (IsLevelEnabled)
      {
        v9 = sub_10001248C();
        _NRLogWithArgs(v9, 16, "%s%.30s:%-4d ABORTING: [super init] failed", "", "-[NRValidPeer initWithInnerLinkVersion:]", 102);

      }
      v10 = _os_log_pack_size(12);
      v11 = (char *)&v15 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
      v12 = __error();
      v13 = _os_log_pack_fill(v11, v10, *v12, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)v13 = 136446210;
      *(_QWORD *)(v13 + 4) = "-[NRValidPeer initWithInnerLinkVersion:]";
      v14 = sub_10001248C();
      _NRLogAbortWithPack(v14, v11);
    }
    a1 = v5;
    objc_storeStrong(v5 + 1, a2);
  }

  return a1;
}

void sub_100011998(uint64_t a1)
{
  _BYTE *v1;
  NSObject *v2;
  void *v3;
  uint64_t v4;
  void *i;
  void *v6;
  id v7;
  uint64_t v8;
  void *v9;
  void *v10;
  id v11;
  unsigned int v12;
  char *v13;
  char *v14;
  id v15;
  uint64_t v16;
  id v17;
  id v18;
  id v19;
  id v20;
  id v21;
  id v22;
  void *v23;
  id v24;
  id v25;
  uint64_t v26;
  void *j;
  id v28;
  _QWORD *v29;
  _QWORD *v30;
  __objc2_class *v31;
  id v32;
  id v33;
  void *v34;
  id v35;
  void *v36;
  id v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  void *v41;
  uint64_t v42;
  void *v43;
  id v44;
  void *v45;
  id v46;
  id obj;
  uint64_t v48;
  id v49;
  _BYTE *v50;
  void *v51;
  unsigned int v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  _BYTE v61[128];
  _BYTE v62[128];

  v1 = (_BYTE *)a1;
  if (objc_msgSend(*(id *)(a1 + 88), "count"))
  {
    v2 = *((_QWORD *)v1 + 5);
    if (v2)
    {
      dispatch_source_cancel(v2);
      v3 = (void *)*((_QWORD *)v1 + 5);
      *((_QWORD *)v1 + 5) = 0;

    }
  }
  v59 = 0u;
  v60 = 0u;
  v57 = 0u;
  v58 = 0u;
  obj = *((id *)v1 + 11);
  v49 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v57, v62, 16);
  if (v49)
  {
    v4 = 0x1001E3000;
    v48 = *(_QWORD *)v58;
    v50 = v1;
    do
    {
      for (i = 0; i != v49; i = (char *)i + 1)
      {
        if (*(_QWORD *)v58 != v48)
          objc_enumerationMutation(obj);
        v6 = *(void **)(*((_QWORD *)&v57 + 1) + 8 * (_QWORD)i);
        v7 = *((id *)v1 + 11);
        v8 = objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", v6));
        v9 = (void *)v8;
        if (v8)
          v10 = *(void **)(v8 + 8);
        else
          v10 = 0;
        v11 = v10;

        if (v11)
          v12 = objc_msgSend(v11, "unsignedShortValue");
        else
          v12 = 0;
        v52 = v12;
        v13 = sub_100134EE8(v4 + 2200, v6, 0);
        v51 = v11;
        if (v13)
        {
          v14 = v13;
          if (qword_1001E4518 != -1)
            dispatch_once(&qword_1001E4518, &stru_1001B6140);
          if (_NRLogIsLevelEnabled(qword_1001E4510, 0))
          {
            if (qword_1001E4518 != -1)
              dispatch_once(&qword_1001E4518, &stru_1001B6140);
            _NRLogWithArgs(qword_1001E4510, 0, "%s%.30s:%-4d PHS peer is an existing device %@", "", "-[NROnDemandLinkSetupManager activateValidPHSPeers]", 808, v14);
          }
        }
        else
        {
          v15 = v6;
          v16 = objc_opt_self(v4 + 2200);
          v14 = sub_100134EE8(v16, v15, 1);

          if (qword_1001E4518 != -1)
            dispatch_once(&qword_1001E4518, &stru_1001B6140);
          if (_NRLogIsLevelEnabled(qword_1001E4510, 0))
          {
            if (qword_1001E4518 != -1)
              dispatch_once(&qword_1001E4518, &stru_1001B6140);
            _NRLogWithArgs(qword_1001E4510, 0, "%s%.30s:%-4d PHS peer created %@", "", "-[NROnDemandLinkSetupManager activateValidPHSPeers]", 811, v14);
          }
        }
        v17 = objc_alloc_init((Class)NSMutableArray);
        v18 = objc_alloc_init((Class)NSMutableArray);
        if (v1[13])
          objc_msgSend(v17, "addObject:", &off_1001C45E8);
        if (v1[14])
        {
          objc_msgSend(v17, "addObject:", &off_1001C4600);
          objc_msgSend(v18, "addObject:", &off_1001C4618);
          objc_msgSend(v18, "addObject:", &off_1001C4630);
        }
        if (!v14)
        {
          v28 = 0;
          v30 = 0;
LABEL_71:
          v34 = v28;
          v28 = objc_alloc_init((Class)NRDeviceOperationalProperties);

          v35 = *((id *)v1 + 10);
          if (v14)
            v36 = (void *)*((_QWORD *)v14 + 6);
          else
            v36 = 0;
          v37 = v36;
          v38 = objc_claimAutoreleasedReturnValue(objc_msgSend(v35, "objectForKeyedSubscript:", v37));

          if (v1[13])
          {
            v39 = 1;
            v31 = &OBJC_METACLASS___NRAnalyticsLocalDevice;
            goto LABEL_77;
          }
          v40 = v1[14];
          v31 = &OBJC_METACLASS___NRAnalyticsLocalDevice;
          if (v40)
          {
            v39 = 2;
LABEL_77:
            objc_msgSend(v28, "setProxyCapability:", v39);
          }
          objc_msgSend(v28, "setAllowedLinkTypes:", v17);
          objc_msgSend(v28, "setAllowedLinkSubtypes:", v18);
          objc_msgSend(v28, "setUsesTLS:", 1);
          v30 = (_QWORD *)v38;
          if (!v38)
          {
LABEL_79:
            v4 = (uint64_t)v31;
            if (qword_1001E4518 != -1)
              dispatch_once(&qword_1001E4518, &stru_1001B6140);
            v1 = v50;
            if (_NRLogIsLevelEnabled(qword_1001E4510, 16))
            {
              if (qword_1001E4518 != -1)
                dispatch_once(&qword_1001E4518, &stru_1001B6140);
              _NRLogWithArgs(qword_1001E4510, 16, "%s%.30s:%-4d no PSK to complete registration", "", "-[NROnDemandLinkSetupManager activateValidPHSPeers]", 876);
            }
            goto LABEL_9;
          }
LABEL_67:
          v4 = (uint64_t)v31;
          v1 = v50;
          if (objc_msgSend(v28, "proxyCapability") == (id)1)
          {
            if (v50[15])
              v33 = +[NRDeviceProxyProviderCriteria copyCriteriaForCellularSlicing](NRDeviceProxyProviderCriteria, "copyCriteriaForCellularSlicing");
            else
              v33 = objc_alloc_init((Class)NRDeviceProxyProviderCriteria);
            v41 = v33;
            objc_msgSend(v28, "setProxyProviderCriteria:", v33);

          }
          if (_os_feature_enabled_impl("terminus", "PHSProxyForceEnable"))
          {
            if (qword_1001E4518 != -1)
              dispatch_once(&qword_1001E4518, &stru_1001B6140);
            if (_NRLogIsLevelEnabled(qword_1001E4510, 1))
            {
              if (qword_1001E4518 != -1)
                dispatch_once(&qword_1001E4518, &stru_1001B6140);
              _NRLogWithArgs(qword_1001E4510, 1, "%s%.30s:%-4d discovering all supported devices", "", "-[NROnDemandLinkSetupManager activateValidPHSPeers]", 890);
              v42 = 255;
            }
            else
            {
              v42 = 255;
            }
LABEL_98:
            objc_msgSend(v28, "setAllowedPeerDeviceType:", v42);
          }
          else
          {
            if (v50[13])
            {
              v42 = 6;
              goto LABEL_98;
            }
            if (v50[14])
            {
              v42 = 1;
              goto LABEL_98;
            }
          }
          objc_msgSend(v28, "setAllowsDeviceDiscovery:", 1);
          objc_msgSend(v28, "setAllowsDeadPeerDetection:", 1);
          if (v14)
            v43 = (void *)*((_QWORD *)v14 + 16);
          else
            v43 = 0;
          v44 = v43;
          objc_msgSend(v28, "setOperationalScope:", (unint64_t)objc_msgSend(v44, "operationalScope") | (unint64_t)objc_msgSend(v28, "operationalScope") | 1);

          objc_msgSend(v28, "setActiveOperationalScope:", (unint64_t)objc_msgSend(v28, "activeOperationalScope") | 1);
          sub_10010B4E0(v28);
          if (qword_1001E4518 != -1)
            dispatch_once(&qword_1001E4518, &stru_1001B6140);
          if (_NRLogIsLevelEnabled(qword_1001E4510, 0))
          {
            if (qword_1001E4518 != -1)
              dispatch_once(&qword_1001E4518, &stru_1001B6140);
            _NRLogWithArgs(qword_1001E4510, 0, "%s%.30s:%-4d peer version %u, op prop %@", "", "-[NROnDemandLinkSetupManager activateValidPHSPeers]", 907, v52, v28);
          }
          if (v14)
            v45 = (void *)*((_QWORD *)v14 + 4);
          else
            v45 = 0;
          v46 = v45;
          sub_100135314(v4 + 2200, v46, 0, v52, 0, v30, 0, 0, 0, v28, 0, CFSTR("relay-req"), &stru_1001B60E0);

LABEL_9:
          goto LABEL_10;
        }
        if (!v14[8] || (v19 = *((id *)v14 + 16), v19, !v19))
        {
LABEL_61:
          v28 = *((id *)v14 + 16);
          v29 = (_QWORD *)*((_QWORD *)v14 + 19);
          if (v29)
            v29 = (_QWORD *)v29[2];
          v30 = v29;
          if (!v14[8])
          {
            v1 = v50;
            goto LABEL_71;
          }
          v31 = (__objc2_class *)v4;
          if (v52)
          {
            v32 = *((id *)v14 + 4);
            sub_10013BBC0(v4 + 2200, (char *)v52, v32);

          }
          if (!v30)
            goto LABEL_79;
          goto LABEL_67;
        }
        if (v1[14]
          && (v20 = *((id *)v14 + 16),
              v21 = objc_msgSend(v20, "proxyCapability"),
              v20,
              v21 == (id)1))
        {
          if (qword_1001E4518 != -1)
            dispatch_once(&qword_1001E4518, &stru_1001B6140);
          if (_NRLogIsLevelEnabled(qword_1001E4510, 16))
          {
            if (qword_1001E4518 != -1)
              dispatch_once(&qword_1001E4518, &stru_1001B6140);
            _NRLogWithArgs(qword_1001E4510, 16, "%s%.30s:%-4d PHS peer incompatible with existing registration due to mismatching proxy role. Ignoring", "", "-[NROnDemandLinkSetupManager activateValidPHSPeers]", 832);
          }
        }
        else
        {
          v55 = 0u;
          v56 = 0u;
          v53 = 0u;
          v54 = 0u;
          v22 = *((id *)v14 + 16);
          v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "allowedLinkTypes"));

          v24 = objc_msgSend(v23, "countByEnumeratingWithState:objects:count:", &v53, v61, 16);
          if (v24)
          {
            v25 = v24;
            v26 = *(_QWORD *)v54;
            while (2)
            {
              for (j = 0; j != v25; j = (char *)j + 1)
              {
                if (*(_QWORD *)v54 != v26)
                  objc_enumerationMutation(v23);
                if ((objc_msgSend(v17, "containsObject:", *(_QWORD *)(*((_QWORD *)&v53 + 1) + 8 * (_QWORD)j)) & 1) != 0)
                {

                  goto LABEL_61;
                }
              }
              v25 = objc_msgSend(v23, "countByEnumeratingWithState:objects:count:", &v53, v61, 16);
              if (v25)
                continue;
              break;
            }
          }

          if (qword_1001E4518 != -1)
            dispatch_once(&qword_1001E4518, &stru_1001B6140);
          if (_NRLogIsLevelEnabled(qword_1001E4510, 16))
          {
            if (qword_1001E4518 != -1)
              dispatch_once(&qword_1001E4518, &stru_1001B6140);
            _NRLogWithArgs(qword_1001E4510, 16, "%s%.30s:%-4d PHS peer incompatible with existing registration due to mismatching links. Ignoring", "", "-[NROnDemandLinkSetupManager activateValidPHSPeers]", 844);
          }
        }
LABEL_10:

      }
      v49 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v57, v62, 16);
    }
    while (v49);
  }

}

void sub_1000123BC(id a1, int64_t a2, NSString *a3)
{
  NSString *v4;

  v4 = a3;
  if (qword_1001E4518 != -1)
    dispatch_once(&qword_1001E4518, &stru_1001B6140);
  if (_NRLogIsLevelEnabled(qword_1001E4510, 0))
  {
    if (qword_1001E4518 != -1)
      dispatch_once(&qword_1001E4518, &stru_1001B6140);
    _NRLogWithArgs(qword_1001E4510, 0, "%s%.30s:%-4d PHS peer registered with res %lld %@", "", "-[NROnDemandLinkSetupManager activateValidPHSPeers]_block_invoke", 921, a2, v4);
  }

}

id sub_10001248C()
{
  if (qword_1001E4518 != -1)
    dispatch_once(&qword_1001E4518, &stru_1001B6140);
  return (id)qword_1001E4510;
}

void sub_1000124D0(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  unsigned int v6;
  id v7;
  void *v8;
  id v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  void *v13;
  char *v14;
  _BOOL8 v15;
  void *v16;
  void *v17;
  void *v18;
  id v19;
  id v20;
  id v21;
  id v22;
  id v23;
  id v24;
  id v25;
  void *v26;
  id v27;
  void **v28;
  void *v29;
  id v30;
  id v31;
  _QWORD v32[4];
  id v33;
  id v34;
  id v35;
  id v36;
  id v37;
  id v38;
  id location;
  const __CFString *v40;
  id v41;

  v3 = a2;
  if (a1 && (*(_BYTE *)(a1 + 11) || *(_BYTE *)(a1 + 12)))
  {
    if (*(_BYTE *)(a1 + 14))
    {
      v31 = v3;
      v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "model"));
      v3 = v31;
      if (!v4
        || (v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v31, "model")),
            v6 = objc_msgSend(v5, "localizedCaseInsensitiveContainsString:", CFSTR("phone")),
            v5,
            v4,
            v3 = v31,
            v6))
      {
        v7 = v3;
        ++*(_DWORD *)(a1 + 24);
        v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:"));
        v9 = objc_alloc_init((Class)NSMutableDictionary);
        objc_msgSend(v9, "setObject:forKeyedSubscript:", &off_1001C4558, CFSTR("v"));
        objc_msgSend(v9, "setObject:forKeyedSubscript:", &off_1001C4570, CFSTR("nrv"));
        objc_opt_self(NRLinkDirector);
        if (qword_1001E4710 != -1)
          dispatch_once(&qword_1001E4710, &stru_1001B6E60);
        v10 = (id)qword_1001E4708;
        v11 = sub_1000AFE70(v10, 0);
        objc_msgSend(v9, "setObject:forKeyedSubscript:", v11, CFSTR("id"));

        v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "idsDeviceIdentifier"));
        if (v12)
        {
          v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "idsDeviceIdentifier"));
          v14 = sub_100134EE8((uint64_t)NRDLocalDevice, v13, 0);

          if (v14)
            v15 = v14[8] != 0;
          else
            v15 = 0;
          v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v15));
          objc_msgSend(v9, "setObject:forKeyedSubscript:", v16, CFSTR("reg"));

        }
        objc_msgSend(v9, "setObject:forKeyedSubscript:", &off_1001C45D0, CFSTR("r"));
        objc_msgSend(v9, "setObject:forKeyedSubscript:", v8, CFSTR("rid"));
        if (qword_1001E48E0 != -1)
          dispatch_once(&qword_1001E48E0, &stru_1001B7CE0);
        v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", byte_1001E48D8));
        objc_msgSend(v9, "setObject:forKeyedSubscript:", v17, CFSTR("t"));

        objc_msgSend(v9, "setObject:forKeyedSubscript:", &off_1001C45B8, CFSTR("fl"));
        v40 = CFSTR("relay-req");
        v41 = v9;
        v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v41, &v40, 1));
        v19 = objc_alloc_init((Class)RPCompanionLinkClient);
        objc_msgSend(v19, "setDispatchQueue:", *(_QWORD *)(a1 + 32));
        objc_msgSend(v19, "setServiceType:", CFSTR("com.apple.networkrelay.on-demand-setup"));
        objc_msgSend(v19, "setControlFlags:", 4);
        objc_msgSend(v19, "setDestinationDevice:", v7);
        objc_initWeak(&location, (id)a1);
        v20 = *(id *)(a1 + 56);
        v32[0] = _NSConcreteStackBlock;
        v32[1] = 3221225472;
        v32[2] = sub_100012964;
        v32[3] = &unk_1001B60A0;
        objc_copyWeak(&v38, &location);
        v21 = v20;
        v33 = v21;
        v22 = v7;
        v34 = v22;
        v23 = v8;
        v35 = v23;
        v24 = v19;
        v36 = v24;
        v25 = v18;
        v37 = v25;
        objc_msgSend(v24, "activateWithCompletion:", v32);
        v26 = *(void **)(a1 + 64);
        if (!v26)
        {
          v27 = objc_alloc_init((Class)NSMutableDictionary);
          v29 = *(void **)(a1 + 64);
          v28 = (void **)(a1 + 64);
          *v28 = v27;

          v26 = *v28;
        }
        v30 = v26;
        objc_msgSend(v30, "setObject:forKeyedSubscript:", v24, v23);

        objc_destroyWeak(&v38);
        objc_destroyWeak(&location);

        v3 = v31;
      }
    }
  }

}

void sub_10001293C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,id location)
{
  id *v21;

  objc_destroyWeak(v21);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100012964(uint64_t a1, void *a2)
{
  id v3;
  id *WeakRetained;
  id *v5;
  void *v6;
  void *v7;
  uint64_t v8;
  _QWORD v9[4];
  id v10;
  id v11;
  id v12;
  id *v13;
  id v14;
  id v15;

  v3 = a2;
  WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 72));
  v5 = WeakRetained;
  if (WeakRetained
    && !*((_BYTE *)WeakRetained + 9)
    && WeakRetained[7] == *(id *)(a1 + 32)
    && *((_BYTE *)WeakRetained + 16))
  {
    if (v3)
    {
      if (qword_1001E4518 != -1)
        dispatch_once(&qword_1001E4518, &stru_1001B6140);
      if (_NRLogIsLevelEnabled(qword_1001E4510, 1))
      {
        if (qword_1001E4518 != -1)
          dispatch_once(&qword_1001E4518, &stru_1001B6140);
        _NRLogWithArgs(qword_1001E4510, 1, "%s%.30s:%-4d message client activation failed with error %@ for device %@", "", "-[NROnDemandLinkSetupManager requestInternetRelayFromPeer:]_block_invoke", 649, v3, *(_QWORD *)(a1 + 40));
      }
      v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5[8], "objectForKeyedSubscript:", *(_QWORD *)(a1 + 48)));
      objc_msgSend(v6, "invalidate");

      objc_msgSend(v5[8], "setObject:forKeyedSubscript:", 0, *(_QWORD *)(a1 + 48));
    }
    else
    {
      v7 = *(void **)(a1 + 56);
      v8 = *(_QWORD *)(a1 + 64);
      v9[0] = _NSConcreteStackBlock;
      v9[1] = 3221225472;
      v9[2] = sub_100012B84;
      v9[3] = &unk_1001B6078;
      objc_copyWeak(&v15, (id *)(a1 + 72));
      v10 = *(id *)(a1 + 32);
      v11 = 0;
      v12 = *(id *)(a1 + 40);
      v13 = v5;
      v14 = *(id *)(a1 + 48);
      objc_msgSend(v7, "sendRequestID:request:options:responseHandler:", CFSTR("com.apple.networkrelay.on-demand-setup"), v8, 0, v9);

      objc_destroyWeak(&v15);
    }
  }

}

void sub_100012B70(_Unwind_Exception *a1)
{
  id *v1;

  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_100012B84(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  id v7;
  id *WeakRetained;
  id *v9;
  uint64_t v10;
  void *v11;
  void *v12;
  uint64_t v13;
  void *v14;
  id v15;
  id v16;
  id v17;
  id v18;
  void *v19;
  void *v20;
  void *v21;
  unsigned __int8 v22;
  int v23;
  void *v24;
  void *v25;
  char *v26;
  unsigned __int8 v27;
  const __CFString *v28;
  id v29;
  uint64_t v30;
  void *v31;
  id v32;
  void *v33;
  void *v34;
  void *v35;
  NRValidPeer *v36;
  void *v37;
  id *v38;
  id v39;
  void *v40;
  void *v41;
  void *v42;
  id v43;
  void *v44;
  id v45;

  v45 = a2;
  v7 = a3;
  WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 72));
  v9 = WeakRetained;
  if (!WeakRetained
    || *((_BYTE *)WeakRetained + 9)
    || WeakRetained[7] != *(id *)(a1 + 32)
    || !*((_BYTE *)WeakRetained + 16))
  {
    goto LABEL_4;
  }
  if (!a4)
  {
    v15 = *(id *)(a1 + 48);
    v16 = v45;
    v17 = v7;
    if (qword_1001E4518 != -1)
      dispatch_once(&qword_1001E4518, &stru_1001B6140);
    if (_NRLogIsLevelEnabled(qword_1001E4510, 0))
    {
      if (qword_1001E4518 != -1)
        dispatch_once(&qword_1001E4518, &stru_1001B6140);
      v18 = (id)qword_1001E4510;
      v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "allKeys"));
      _NRLogWithArgs(v18, 0, "%s%.30s:%-4d received response %@ from device %@", "", "-[NROnDemandLinkSetupManager processInternetRelayResponseFromPeer:response:options:]", 682, v19, v15);

    }
    v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "objectForKeyedSubscript:", CFSTR("relay-res")));
    if (!objc_msgSend(v20, "count"))
      goto LABEL_54;
    v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "objectForKeyedSubscript:", CFSTR("rspc")));
    v22 = objc_msgSend(v21, "unsignedShortValue");
    v23 = v22;
    if (v22 != 1)
    {
      v27 = v22;
      if (qword_1001E4518 != -1)
        dispatch_once(&qword_1001E4518, &stru_1001B6140);
      if (_NRLogIsLevelEnabled(qword_1001E4510, 16))
      {
        if (qword_1001E4518 != -1)
          dispatch_once(&qword_1001E4518, &stru_1001B6140);
        if ((v27 & 0xFC) != 0)
          v28 = CFSTR("unknown");
        else
          v28 = off_1001B6160[v23];
        _NRLogWithArgs(qword_1001E4510, 16, "%s%.30s:%-4d received internet relay response code %@ from device %@", "", "-[NROnDemandLinkSetupManager processInternetRelayResponseFromPeer:response:options:]", 692, v28, v15);
      }
      goto LABEL_53;
    }
    v43 = v17;
    v44 = v21;
    v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "objectForKeyedSubscript:", CFSTR("reg")));
    v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "idsDeviceIdentifier"));
    v26 = sub_100134EE8((uint64_t)NRDLocalDevice, v25, 0);

    v42 = v24;
    if (objc_msgSend(v24, "BOOLValue"))
    {
      if (!v26)
        goto LABEL_41;
      if (v26[8])
        goto LABEL_43;
    }
    else
    {
      if (!v26)
        goto LABEL_41;
      if (v26[8])
      {
LABEL_40:
        v29 = *((id *)v26 + 4);
        sub_1001370D8((uint64_t)NRDLocalDevice, v29, &stru_1001B60C0);

        goto LABEL_41;
      }
    }
    if (v26[9])
      goto LABEL_40;
LABEL_41:
    v30 = objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "objectForKeyedSubscript:", CFSTR("psk")));
    if (!v30)
    {
      if (qword_1001E4518 != -1)
        dispatch_once(&qword_1001E4518, &stru_1001B6140);
      v41 = v42;
      v17 = v43;
      if (_NRLogIsLevelEnabled(qword_1001E4510, 16))
      {
        if (qword_1001E4518 != -1)
          dispatch_once(&qword_1001E4518, &stru_1001B6140);
        _NRLogWithArgs(qword_1001E4510, 16, "%s%.30s:%-4d no device registration psk from device %@", "", "-[NROnDemandLinkSetupManager processInternetRelayResponseFromPeer:response:options:]", 707, v15);
      }
      goto LABEL_44;
    }
    v31 = (void *)v30;
    v32 = v9[10];
    v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "idsDeviceIdentifier"));
    objc_msgSend(v32, "setObject:forKeyedSubscript:", v31, v33);

LABEL_43:
    v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "objectForKeyedSubscript:", CFSTR("rid")));
    v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9[8], "objectForKeyedSubscript:", v34));
    objc_msgSend(v35, "invalidate");

    objc_msgSend(v9[8], "setObject:forKeyedSubscript:", 0, v34);
    v36 = [NRValidPeer alloc];
    v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "objectForKeyedSubscript:", CFSTR("nrv")));
    v38 = sub_10001183C((id *)&v36->super.isa, v37);

    v39 = v9[11];
    v40 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "idsDeviceIdentifier"));
    objc_msgSend(v39, "setObject:forKeyedSubscript:", v38, v40);

    sub_100011998((uint64_t)v9);
    v41 = v42;
    v17 = v43;
LABEL_44:

    v21 = v44;
LABEL_53:

LABEL_54:
    goto LABEL_4;
  }
  if (qword_1001E4518 != -1)
    dispatch_once(&qword_1001E4518, &stru_1001B6140);
  if (_NRLogIsLevelEnabled(qword_1001E4510, 1))
  {
    if (qword_1001E4518 != -1)
      dispatch_once(&qword_1001E4518, &stru_1001B6140);
    _NRLogWithArgs(qword_1001E4510, 1, "%s%.30s:%-4d message received response with error %@ for device %@", "", "-[NROnDemandLinkSetupManager requestInternetRelayFromPeer:]_block_invoke_2", 666, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48));
  }
  v10 = *(_QWORD *)(a1 + 56);
  if (v10)
    v11 = *(void **)(v10 + 64);
  else
    v11 = 0;
  v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "objectForKeyedSubscript:", *(_QWORD *)(a1 + 64)));
  objc_msgSend(v12, "invalidate");

  v13 = *(_QWORD *)(a1 + 56);
  if (v13)
    v14 = *(void **)(v13 + 64);
  else
    v14 = 0;
  objc_msgSend(v14, "setObject:forKeyedSubscript:", 0, *(_QWORD *)(a1 + 64));
LABEL_4:

}

void sub_100013164(uint64_t a1, void *a2)
{
  id WeakRetained;
  void *v4;
  id v5;

  v5 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  v4 = WeakRetained;
  if (WeakRetained && *((_QWORD *)WeakRetained + 7) == *(_QWORD *)(a1 + 32))
  {
    if (qword_1001E4518 != -1)
      dispatch_once(&qword_1001E4518, &stru_1001B6140);
    if (_NRLogIsLevelEnabled(qword_1001E4510, 0))
    {
      if (qword_1001E4518 != -1)
        dispatch_once(&qword_1001E4518, &stru_1001B6140);
      _NRLogWithArgs(qword_1001E4510, 0, "%s%.30s:%-4d [Browser] device found: %@", "", "-[NROnDemandLinkSetupManager startBrowser]_block_invoke", 338, v5);
    }
    sub_1000124D0(*(_QWORD *)(a1 + 40), v5);
  }

}

void sub_100013260(uint64_t a1, void *a2)
{
  id WeakRetained;
  void *v4;
  id v5;

  v5 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v4 = WeakRetained;
  if (WeakRetained && *((_QWORD *)WeakRetained + 7) == *(_QWORD *)(a1 + 32))
  {
    if (qword_1001E4518 != -1)
      dispatch_once(&qword_1001E4518, &stru_1001B6140);
    if (_NRLogIsLevelEnabled(qword_1001E4510, 1))
    {
      if (qword_1001E4518 != -1)
        dispatch_once(&qword_1001E4518, &stru_1001B6140);
      _NRLogWithArgs(qword_1001E4510, 1, "%s%.30s:%-4d [Browser] device lost: %@", "", "-[NROnDemandLinkSetupManager startBrowser]_block_invoke_2", 346, v5);
    }
  }

}

void sub_100013350(uint64_t a1, void *a2)
{
  _QWORD *WeakRetained;
  uint64_t v4;
  id v5;

  v5 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v4 = (uint64_t)WeakRetained;
  if (WeakRetained && WeakRetained[7] == *(_QWORD *)(a1 + 32))
  {
    if (qword_1001E4518 != -1)
      dispatch_once(&qword_1001E4518, &stru_1001B6140);
    if (_NRLogIsLevelEnabled(qword_1001E4510, 0))
    {
      if (qword_1001E4518 != -1)
        dispatch_once(&qword_1001E4518, &stru_1001B6140);
      _NRLogWithArgs(qword_1001E4510, 0, "%s%.30s:%-4d [Browser] activated with error %@", "", "-[NROnDemandLinkSetupManager startBrowser]_block_invoke_3", 353, v5);
    }
    if (v5)
    {
      objc_msgSend(*(id *)(v4 + 56), "invalidate");
    }
    else
    {
      *(_BYTE *)(v4 + 16) = 1;
      sub_100010FA4(v4);
    }
  }

}

void sub_100013464(uint64_t a1)
{
  id WeakRetained;
  id v3;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained && !*((_BYTE *)WeakRetained + 9) && *((_QWORD *)WeakRetained + 5) == *(_QWORD *)(a1 + 32))
  {
    v3 = WeakRetained;
    objc_msgSend(WeakRetained, "didUpdatePHSState:llphsActive:", 0, 0);
    WeakRetained = v3;
  }

}

void sub_1000134C0(uint64_t a1)
{
  id v1;
  id v2;
  id v3;
  id v4;
  uint64_t v5;
  void *i;
  id v7;
  char *v8;
  char *v9;
  int v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  _BYTE v15[128];

  if (a1)
  {
    v1 = sub_1000137E8(a1);
    if (qword_1001E4518 != -1)
      dispatch_once(&qword_1001E4518, &stru_1001B6140);
    if (_NRLogIsLevelEnabled(qword_1001E4510, 0))
    {
      if (qword_1001E4518 != -1)
        dispatch_once(&qword_1001E4518, &stru_1001B6140);
      _NRLogWithArgs(qword_1001E4510, 0, "%s%.30s:%-4d Ineligible peers: %@", "", "-[NROnDemandLinkSetupManager updateRegistrationForInEligibleNRUUIDsInner]", 984, v1);
    }
    v13 = 0u;
    v14 = 0u;
    v11 = 0u;
    v12 = 0u;
    v2 = v1;
    v3 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)v12;
      do
      {
        for (i = 0; i != v4; i = (char *)i + 1)
        {
          if (*(_QWORD *)v12 != v5)
            objc_enumerationMutation(v2);
          v8 = sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(*((_QWORD *)&v11 + 1) + 8 * (_QWORD)i));
          v9 = v8;
          if (!v8)
          {
            v7 = 0;
LABEL_13:
            sub_1001370D8((uint64_t)NRDLocalDevice, v7, &stru_1001B6120);
            goto LABEL_14;
          }
          v10 = v8[8];
          v7 = *((id *)v8 + 4);
          if (!v10)
            goto LABEL_13;
          sub_100137528((uint64_t)NRDLocalDevice, v7, &stru_1001B6100);
LABEL_14:

        }
        v4 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
      }
      while (v4);
    }

  }
}

void sub_1000136C4(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  id v5;
  id v6;
  uint64_t v7;
  void *v8;
  void *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  _BYTE v14[128];

  v2 = *(void **)(a1 + 56);
  if (v2)
  {
    objc_msgSend(v2, "invalidate");
    v3 = *(void **)(a1 + 56);
    *(_QWORD *)(a1 + 56) = 0;

    *(_BYTE *)(a1 + 16) = 0;
  }
  v12 = 0u;
  v13 = 0u;
  v10 = 0u;
  v11 = 0u;
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 64), "allValues", 0));
  v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v10, v14, 16);
  if (v5)
  {
    v6 = v5;
    v7 = *(_QWORD *)v11;
    do
    {
      v8 = 0;
      do
      {
        if (*(_QWORD *)v11 != v7)
          objc_enumerationMutation(v4);
        objc_msgSend(*(id *)(*((_QWORD *)&v10 + 1) + 8 * (_QWORD)v8), "invalidate");
        v8 = (char *)v8 + 1;
      }
      while (v6 != v8);
      v6 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v10, v14, 16);
    }
    while (v6);
  }

  v9 = *(void **)(a1 + 64);
  *(_QWORD *)(a1 + 64) = 0;

}

id sub_1000137E8(uint64_t a1)
{
  id v2;
  id v3;
  id v4;
  uint64_t v5;
  void *i;
  id v7;
  id v8;
  id v9;
  char *v10;
  id *v11;
  id v12;
  void *v13;
  id v14;
  id v15;
  id v16;
  unint64_t v17;
  id v18;
  unsigned __int8 v19;
  id v20;
  id v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  _BYTE v27[128];

  if (!a1)
    return 0;
  v22 = objc_alloc_init((Class)NSMutableArray);
  v23 = 0u;
  v24 = 0u;
  v25 = 0u;
  v26 = 0u;
  v2 = sub_1001379CC((uint64_t)NRDLocalDevice);
  v3 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v23, v27, 16);
  if (v3)
  {
    v4 = v3;
    v5 = *(_QWORD *)v24;
    do
    {
      for (i = 0; i != v4; i = (char *)i + 1)
      {
        if (*(_QWORD *)v24 != v5)
          objc_enumerationMutation(v2);
        v10 = sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(*((_QWORD *)&v23 + 1) + 8 * (_QWORD)i));
        v11 = (id *)v10;
        if (v10)
        {
          v12 = *((id *)v10 + 16);
          if (v12)
          {
            v13 = v12;
            v14 = v11[16];
            v15 = objc_msgSend(v14, "operationalScope");

            if (v15)
            {
              v16 = v11[16];
              v17 = (unint64_t)objc_msgSend(v16, "activeOperationalScope");

              v18 = v11[16];
              v19 = objc_msgSend(v18, "operationalScope");

              if ((v19 & 1) != 0 && !*(_BYTE *)(a1 + 11) && !*(_BYTE *)(a1 + 12))
                v17 &= ~1uLL;
              v7 = v11[16];
              objc_msgSend(v7, "setActiveOperationalScope:", v17);

              v8 = v11[16];
              v9 = objc_msgSend(v8, "activeOperationalScope");

              if (!v9)
              {
                v20 = v11[4];
                objc_msgSend(v22, "addObject:", v20);

              }
            }
          }
        }

      }
      v4 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v23, v27, 16);
    }
    while (v4);
  }

  return v22;
}

void sub_1000139FC(id a1, int64_t a2, NSString *a3)
{
  NSString *v4;

  v4 = a3;
  if (qword_1001E4518 != -1)
    dispatch_once(&qword_1001E4518, &stru_1001B6140);
  if (_NRLogIsLevelEnabled(qword_1001E4510, 0))
  {
    if (qword_1001E4518 != -1)
      dispatch_once(&qword_1001E4518, &stru_1001B6140);
    _NRLogWithArgs(qword_1001E4510, 0, "%s%.30s:%-4d PHS peer unregistered with res %lld %@", "", "-[NROnDemandLinkSetupManager updateRegistrationForInEligibleNRUUIDsInner]_block_invoke_2", 995, a2, v4);
  }

}

void sub_100013ACC(id a1, int64_t a2, NSString *a3)
{
  NSString *v4;

  v4 = a3;
  if (qword_1001E4518 != -1)
    dispatch_once(&qword_1001E4518, &stru_1001B6140);
  if (_NRLogIsLevelEnabled(qword_1001E4510, 0))
  {
    if (qword_1001E4518 != -1)
      dispatch_once(&qword_1001E4518, &stru_1001B6140);
    _NRLogWithArgs(qword_1001E4510, 0, "%s%.30s:%-4d PHS peer disabled with res %lld %@", "", "-[NROnDemandLinkSetupManager updateRegistrationForInEligibleNRUUIDsInner]_block_invoke", 990, a2, v4);
  }

}

void sub_100013B9C(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001E4510;
  qword_1001E4510 = (uint64_t)v1;

}

id *sub_100013BCC(id *a1, void *a2)
{
  id v4;
  id *v5;
  id v6;
  id v7;
  id v8;
  id v9;
  id v10;
  id v11;
  id v13;
  int IsLevelEnabled;
  id v15;
  uint64_t v16;
  char *v17;
  int *v18;
  uint64_t v19;
  id v20;
  uint64_t v21;
  objc_super v22;

  v4 = a2;
  if (a1)
  {
    v22.receiver = a1;
    v22.super_class = (Class)NROnDemandLinkSetupManager;
    v5 = (id *)objc_msgSendSuper2(&v22, "init");
    if (!v5)
    {
      v13 = sub_10001248C();
      IsLevelEnabled = _NRLogIsLevelEnabled(v13, 16);

      if (IsLevelEnabled)
      {
        v15 = sub_10001248C();
        _NRLogWithArgs(v15, 16, "%s%.30s:%-4d ABORTING: [super init] failed", "", "-[NROnDemandLinkSetupManager initWithQueue:]", 140);

      }
      v16 = _os_log_pack_size(12);
      v17 = (char *)&v21 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
      v18 = __error();
      v19 = _os_log_pack_fill(v17, v16, *v18, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)v19 = 136446210;
      *(_QWORD *)(v19 + 4) = "-[NROnDemandLinkSetupManager initWithQueue:]";
      v20 = sub_10001248C();
      _NRLogAbortWithPack(v20, v17);
    }
    a1 = v5;
    objc_storeStrong(v5 + 4, a2);
    v6 = objc_alloc_init((Class)NSMutableArray);
    v7 = a1[9];
    a1[9] = v6;

    v8 = objc_alloc_init((Class)NSMutableDictionary);
    v9 = a1[10];
    a1[10] = v8;

    v10 = objc_alloc_init((Class)NSMutableDictionary);
    v11 = a1[11];
    a1[11] = v10;

    *((_DWORD *)a1 + 5) = -1;
  }

  return a1;
}

void sub_100013D74(uint64_t a1)
{
  _QWORD *v2;
  _QWORD v3[4];
  id v4;

  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v2 = (id)qword_1001E4708;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100013E54;
  v3[3] = &unk_1001B5F68;
  objc_copyWeak(&v4, (id *)(a1 + 32));

  objc_destroyWeak(&v4);
}

void sub_100013E40(_Unwind_Exception *a1)
{
  id *v1;

  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_100013E54(uint64_t a1, void *a2)
{
  id v3;
  id v4;
  _QWORD v5[4];
  id v6;

  v3 = a2;
  objc_opt_self(NRDKeyManager);
  if (qword_1001E4AD8 != -1)
    dispatch_once(&qword_1001E4AD8, &stru_1001B8968);
  v4 = (id)qword_1001E4AD0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_100013F3C;
  v5[3] = &unk_1001B7F28;
  objc_copyWeak(&v6, (id *)(a1 + 32));
  sub_10014ACE0((uint64_t)v4, v5);

  objc_destroyWeak(&v6);
}

void sub_100013F28(_Unwind_Exception *a1)
{
  id *v1;

  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_100013F3C(uint64_t a1)
{
  id WeakRetained;
  void *v2;
  id v3;
  id v4;
  id v5;
  id v6;
  id v7;
  void *v8;
  id v9;
  NSObject *v10;
  NSObject *v11;
  dispatch_time_t v12;
  id val;
  _QWORD v14[4];
  id v15;
  id v16;
  id from[4];
  id v18;
  id v19;
  void **v20;
  uint64_t v21;
  void *v22;
  void *v23;
  id v24;
  id v25;
  void **handler;
  uint64_t v27;
  void *v28;
  void *v29;
  id v30;
  id v31;
  id location;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v2 = WeakRetained;
  if (WeakRetained && !*((_BYTE *)WeakRetained + 9))
  {
    val = WeakRetained;
    if (!*((_QWORD *)WeakRetained + 6))
    {
      v3 = objc_alloc_init((Class)RPCompanionLinkClient);
      objc_msgSend(v3, "setDispatchQueue:", *((_QWORD *)val + 4));
      objc_initWeak(&location, val);
      handler = _NSConcreteStackBlock;
      v27 = 3221225472;
      v28 = sub_100014CB8;
      v29 = &unk_1001B5FB8;
      objc_copyWeak(&v31, &location);
      v4 = v3;
      v30 = v4;
      objc_msgSend(v4, "registerRequestID:options:handler:", CFSTR("com.apple.networkrelay.on-demand-setup"), 0, &handler);
      v20 = _NSConcreteStackBlock;
      v21 = 3221225472;
      v22 = sub_100015128;
      v23 = &unk_1001B87F0;
      objc_copyWeak(&v25, &location);
      v5 = v4;
      v24 = v5;
      objc_msgSend(v5, "setInterruptionHandler:", &v20);
      from[0] = _NSConcreteStackBlock;
      from[1] = (id)3221225472;
      from[2] = sub_100015208;
      from[3] = &unk_1001B87F0;
      objc_copyWeak(&v19, &location);
      v6 = v5;
      v18 = v6;
      objc_msgSend(v6, "setInvalidationHandler:", from);
      v14[0] = _NSConcreteStackBlock;
      v14[1] = 3221225472;
      v14[2] = sub_1000152E8;
      v14[3] = &unk_1001B7A40;
      objc_copyWeak(&v16, &location);
      v7 = v6;
      v15 = v7;
      objc_msgSend(v7, "activateWithCompletion:", v14);
      v8 = (void *)*((_QWORD *)val + 6);
      *((_QWORD *)val + 6) = v7;
      v9 = v7;

      objc_destroyWeak(&v16);
      objc_destroyWeak(&v19);

      objc_destroyWeak(&v25);
      objc_destroyWeak(&v31);
      objc_destroyWeak(&location);
      v2 = val;
    }
    objc_initWeak(from, v2);
    v10 = *((id *)val + 4);
    handler = _NSConcreteStackBlock;
    v27 = 3221225472;
    v28 = sub_1000142D4;
    v29 = &unk_1001B6030;
    objc_copyWeak(&v30, from);
    xpc_set_event_stream_handler("com.apple.notifyd.matching", v10, &handler);

    v11 = *((id *)val + 4);
    v20 = _NSConcreteStackBlock;
    v21 = 3221225472;
    v22 = sub_100014364;
    v23 = &unk_1001B6030;
    objc_copyWeak(&v24, from);
    xpc_set_event_stream_handler("com.apple.rapport.matching", v11, &v20);

    objc_destroyWeak(&v24);
    objc_destroyWeak(&v30);
    objc_destroyWeak(from);
    v12 = dispatch_time(0, 1000000000);
    dispatch_after(v12, *((dispatch_queue_t *)val + 4), &stru_1001B5F40);
    v2 = val;
  }

}

void sub_100014254(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;
  id *v17;
  id *v18;
  id *v19;
  uint64_t v20;
  id *v21;

  v21 = v19;
  objc_destroyWeak(v21);
  objc_destroyWeak(v18);
  objc_destroyWeak(v17);
  objc_destroyWeak(v16);
  objc_destroyWeak((id *)(v20 - 104));
  _Unwind_Resume(a1);
}

void sub_1000142C8(id a1)
{
  notify_post("com.apple.networkrelay.launch");
}

void sub_1000142D4(uint64_t a1, void *a2)
{
  _BYTE *WeakRetained;
  _BYTE *v4;
  const char *string;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  xpc_object_t xdict;

  xdict = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v4 = WeakRetained;
  if (WeakRetained)
  {
    if (!WeakRetained[9])
    {
      string = xpc_dictionary_get_string(xdict, _xpc_event_key_name);
      sub_1000145EC((uint64_t)string, v6, CFSTR("notify(%s)"), v7, v8, v9, v10, v11, (uint64_t)string);
      if (!strcmp(string, "com.apple.networkrelay.launch.phs"))
        sub_10001465C(v4);
    }
  }

}

void sub_100014364(uint64_t a1, void *a2)
{
  id WeakRetained;
  void *v4;
  const char *string;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  id v12;
  void *v13;
  xpc_object_t reply;
  void *v15;
  id v16;
  int v17;
  id v18;
  uint64_t v19;
  char *v20;
  int *v21;
  uint64_t v22;
  id v23;
  int IsLevelEnabled;
  id v25;
  uint64_t v26;
  int *v27;
  uint64_t v28;
  id v29;
  id v30;

  v30 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v4 = WeakRetained;
  if (WeakRetained)
  {
    if (!*((_BYTE *)WeakRetained + 9))
    {
      string = xpc_dictionary_get_string(v30, _xpc_event_key_name);
      sub_1000145EC((uint64_t)string, v6, CFSTR("rapport(%s)"), v7, v8, v9, v10, v11, (uint64_t)string);
      if (xpc_dictionary_get_BOOL(v30, "replyRequired"))
      {
        v12 = v30;
        if (v12)
        {
          v13 = v12;
          reply = xpc_dictionary_create_reply(v12);
          if (reply)
          {
            v15 = reply;

            xpc_dictionary_send_reply(v15);
            goto LABEL_7;
          }
          v23 = sub_10001248C();
          IsLevelEnabled = _NRLogIsLevelEnabled(v23, 16);

          if (IsLevelEnabled)
          {
            v25 = sub_10001248C();
            _NRLogWithArgs(v25, 16, "%s%.30s:%-4d ABORTING: xpc_dictionary_create_reply failed", "", "nr_xpc_dictionary_create_reply", 92);

          }
          v26 = _os_log_pack_size(12);
          v20 = (char *)&v30 - ((__chkstk_darwin(v26) + 15) & 0xFFFFFFFFFFFFFFF0);
          v27 = __error();
          v28 = _os_log_pack_fill(v20, v26, *v27, &_mh_execute_header, "%{public}s xpc_dictionary_create_reply failed");
          *(_DWORD *)v28 = 136446210;
          *(_QWORD *)(v28 + 4) = "nr_xpc_dictionary_create_reply";
        }
        else
        {
          v16 = sub_10001248C();
          v17 = _NRLogIsLevelEnabled(v16, 16);

          if (v17)
          {
            v18 = sub_10001248C();
            _NRLogWithArgs(v18, 16, "%s%.30s:%-4d ABORTING: nr_xpc_dictionary_create_reply called with NULL original", "", "nr_xpc_dictionary_create_reply", 88);

          }
          v19 = _os_log_pack_size(12);
          v20 = (char *)&v30 - ((__chkstk_darwin(v19) + 15) & 0xFFFFFFFFFFFFFFF0);
          v21 = __error();
          v22 = _os_log_pack_fill(v20, v19, *v21, &_mh_execute_header, "%{public}s nr_xpc_dictionary_create_reply called with NULL original");
          *(_DWORD *)v22 = 136446210;
          *(_QWORD *)(v22 + 4) = "nr_xpc_dictionary_create_reply";
        }
        v29 = sub_10001248C();
        _NRLogAbortWithPack(v29, v20);
      }
    }
  }
LABEL_7:

}

void sub_1000145EC(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  id v9;
  id v10;

  v9 = a3;
  v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:arguments:", v9, &a9);

  sub_100121E18(0, 30101, &stru_1001B95A0, v10);
}

void sub_10001465C(_BYTE *a1)
{
  id v2;
  _BYTE *v3;
  int v4;
  id v5;
  void *v6;
  void *v7;
  id v8;
  _BYTE *v9;
  void *v10;
  id v11;
  void *v12;
  NSObject *v13;
  id v14;
  id v15;
  id v16;
  int v17;
  id v18;
  id v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  unsigned __int8 v23;
  NRSCDInterfaceConfig *v24;
  id *v25;
  void *v26;
  id v27;
  char IsLevelEnabled;
  id v29;
  void **block;
  uint64_t v31;
  id (*v32)(uint64_t);
  void *v33;
  _BYTE *v34;
  id v35;
  _QWORD v36[4];
  id v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t (*v42)(uint64_t, uint64_t);
  void (*v43)(uint64_t);
  id v44;

  if (a1)
  {
    if ((nrSupportsPHSProxy() & 1) != 0)
    {
      objc_opt_self(NRDKeyManager);
      if (qword_1001E4AD8 != -1)
        dispatch_once(&qword_1001E4AD8, &stru_1001B8968);
      v2 = (id)qword_1001E4AD0;
      if (!v2)
        goto LABEL_53;
      v3 = v2;
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v2 + 2));
      if (!v3[10])
      {
        v3[10] = 1;
        if (v3[8] == 4)
        {
          sub_10014A63C((uint64_t)v3);
          if (v3[9])
          {
            v3[8] = 3;
            sub_10014A8AC((uint64_t)v3);
          }
        }
      }
      v4 = v3[8] & 0xFD;

      if (v4 == 1)
      {
        if (!a1[10])
        {
          if (qword_1001E4518 != -1)
            dispatch_once(&qword_1001E4518, &stru_1001B6140);
          if (_NRLogIsLevelEnabled(qword_1001E4510, 0))
          {
            if (qword_1001E4518 != -1)
              dispatch_once(&qword_1001E4518, &stru_1001B6140);
            _NRLogWithArgs(qword_1001E4510, 0, "%s%.30s:%-4d subscribing for PHS updates", "", "-[NROnDemandLinkSetupManager handleLaunchEventForPHS]", 418);
          }
          objc_opt_self(NRLinkDirector);
          if (qword_1001E4710 != -1)
            dispatch_once(&qword_1001E4710, &stru_1001B6E60);
          v5 = (id)qword_1001E4708;
          v6 = v5;
          if (v5)
            v7 = (void *)*((_QWORD *)v5 + 6);
          else
            v7 = 0;
          v8 = v7;
          v9 = a1;
          if (v8)
          {
            v10 = (void *)*((_QWORD *)v8 + 33);
            if (!v10)
            {
              v11 = objc_alloc_init((Class)NSMutableSet);
              v12 = (void *)*((_QWORD *)v8 + 33);
              *((_QWORD *)v8 + 33) = v11;

              v10 = (void *)*((_QWORD *)v8 + 33);
            }
            objc_msgSend(v10, "addObject:", v9);
            v13 = sub_10014CFBC();
            block = _NSConcreteStackBlock;
            v31 = 3221225472;
            v32 = sub_1001493BC;
            v33 = &unk_1001B8778;
            v34 = v9;
            v35 = v8;
            dispatch_async(v13, &block);

            v39 = 0;
            v40 = &v39;
            v41 = 0x3032000000;
            v42 = sub_10014387C;
            v43 = sub_10014388C;
            v44 = 0;
            v14 = *((id *)v8 + 22);
            v36[0] = _NSConcreteStackBlock;
            v36[1] = 3221225472;
            v36[2] = sub_100149404;
            v36[3] = &unk_1001B8840;
            v15 = v14;
            v37 = v15;
            v38 = &v39;
            if (sub_1001437AC((uint64_t)NRLinkManagerWiFi, v36))
            {
              if (qword_1001E4AB8 != -1)
                dispatch_once(&qword_1001E4AB8, &stru_1001B8928);
              v27 = (id)qword_1001E4AB0;
              IsLevelEnabled = _NRLogIsLevelEnabled(v27, 17);

              if ((IsLevelEnabled & 1) != 0)
              {
                if (qword_1001E4AB8 != -1)
                  dispatch_once(&qword_1001E4AB8, &stru_1001B8928);
                v29 = (id)qword_1001E4AB0;
                _NRLogWithArgs(v29, 17, "timed out fetching IR interface name");

              }
            }
            else
            {
              if (!v40[5])
              {
                v40[5] = (uint64_t)CFSTR("ir0");
                if (qword_1001E4AB8 != -1)
                  dispatch_once(&qword_1001E4AB8, &stru_1001B8928);
                v16 = (id)qword_1001E4AB0;
                v17 = _NRLogIsLevelEnabled(v16, 1);

                if (v17)
                {
                  if (qword_1001E4AB8 != -1)
                    dispatch_once(&qword_1001E4AB8, &stru_1001B8928);
                  v18 = (id)qword_1001E4AB0;
                  _NRLogWithArgs(v18, 1, "%s%.30s:%-4d Failed to fetch IR interface name. Falling back to %@", "", "-[NRLinkManagerWiFi setupIRInterfaceConfigIfNeeded]", 2061, v40[5], block, v31, v32, v33);

                }
              }
              v19 = *((id *)v8 + 16);
              if (!v19)
                goto LABEL_37;
              v20 = v19;
              v21 = (_QWORD *)*((_QWORD *)v8 + 16);
              if (v21)
                v21 = (_QWORD *)v21[3];
              v22 = v21;
              v23 = objc_msgSend(v22, "isEqualToString:", v40[5]);

              if ((v23 & 1) == 0)
              {
LABEL_37:
                v24 = [NRSCDInterfaceConfig alloc];
                v25 = sub_10001E9E8((id *)&v24->super.isa, (void *)v40[5], 0);
                v26 = (void *)*((_QWORD *)v8 + 16);
                *((_QWORD *)v8 + 16) = v25;

                if (*((_QWORD *)v8 + 16))
                  sub_100143A68((uint64_t)v8);
              }
            }

            _Block_object_dispose(&v39, 8);
          }

          a1[10] = 1;
        }
      }
      else
      {
LABEL_53:
        if (qword_1001E4518 != -1)
          dispatch_once(&qword_1001E4518, &stru_1001B6140);
        if (_NRLogIsLevelEnabled(qword_1001E4510, 0))
        {
          if (qword_1001E4518 != -1)
            dispatch_once(&qword_1001E4518, &stru_1001B6140);
          _NRLogWithArgs(qword_1001E4510, 0, "%s%.30s:%-4d ignoring processing launch event as device not classC unlocked");
        }
      }
    }
    else
    {
      if (qword_1001E4518 != -1)
        dispatch_once(&qword_1001E4518, &stru_1001B6140);
      if (_NRLogIsLevelEnabled(qword_1001E4510, 0))
      {
        if (qword_1001E4518 != -1)
          dispatch_once(&qword_1001E4518, &stru_1001B6140);
        _NRLogWithArgs(qword_1001E4510, 0, "%s%.30s:%-4d PHS proxy not supported");
      }
    }
  }
}

void sub_100014CA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_list va;

  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100014CB8(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v8;
  id v9;
  id v10;
  _QWORD *WeakRetained;
  uint64_t v12;
  _QWORD *v13;
  id v14;
  _QWORD *v15;
  void *v16;
  id v17;
  id v18;
  void *v19;
  void *v20;
  NRPendingIncomingRequest *v21;
  id *p_isa;
  SEL v23;
  id v24;
  void *v25;
  id v26;
  unsigned __int8 v27;
  void *v28;
  id v29;
  _QWORD v30[4];
  id v31;

  v8 = a2;
  v9 = a3;
  v10 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v12 = (uint64_t)WeakRetained;
  if (WeakRetained && WeakRetained[6] == *(_QWORD *)(a1 + 32))
  {
    if (qword_1001E4518 != -1)
      dispatch_once(&qword_1001E4518, &stru_1001B6140);
    if (_NRLogIsLevelEnabled(qword_1001E4510, 0))
    {
      if (qword_1001E4518 != -1)
        dispatch_once(&qword_1001E4518, &stru_1001B6140);
      _NRLogWithArgs(qword_1001E4510, 0, "%s%.30s:%-4d [Receiver] received request %@ with options %@", "", "-[NROnDemandLinkSetupManager startReceiver]_block_invoke", 277, v8, v9);
    }
    v30[0] = _NSConcreteStackBlock;
    v30[1] = 3221225472;
    v30[2] = sub_1000153E8;
    v30[3] = &unk_1001B5F90;
    v31 = v10;
    v13 = objc_retainBlock(v30);
    v14 = v8;
    v29 = v9;
    v15 = v13;
    v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "objectForKeyedSubscript:", CFSTR("relay-req")));
    if (!objc_msgSend(v16, "count"))
      goto LABEL_35;
    v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "objectForKeyedSubscript:", CFSTR("r")));
    v27 = objc_msgSend(v25, "unsignedLongValue");
    v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "objectForKeyedSubscript:", CFSTR("reg")));
    if (qword_1001E4518 != -1)
      dispatch_once(&qword_1001E4518, &stru_1001B6140);
    v26 = v14;
    if (_NRLogIsLevelEnabled(qword_1001E4510, 0))
    {
      if (qword_1001E4518 != -1)
        dispatch_once(&qword_1001E4518, &stru_1001B6140);
      v17 = (id)qword_1001E4510;
      v18 = objc_alloc_init((Class)NSMutableString);
      v19 = v18;
      if ((v27 & 1) != 0)
        objc_msgSend(v18, "appendString:", CFSTR("PHS,"));
      _NRLogWithArgs(v17, 0, "%s%.30s:%-4d received request for internet relay (reason: %@ registered: %d)", "", "-[NROnDemandLinkSetupManager processIncomingRequest:options:response:]", 592, v19, objc_msgSend(v28, "BOOLValue"));

    }
    v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "objectForKeyedSubscript:", CFSTR("t")));
    if (objc_msgSend(v20, "unsignedCharValue") == 6
      || (_os_feature_enabled_impl("terminus", "PHSProxyForceEnable") & 1) != 0)
    {
      if ((v27 & 1) == 0)
      {
LABEL_34:

        v14 = v26;
LABEL_35:

        goto LABEL_36;
      }
      v21 = objc_alloc_init(NRPendingIncomingRequest);
      p_isa = (id *)&v21->super.isa;
      if (v21)
      {
        objc_storeStrong((id *)&v21->_request, a2);
        objc_storeStrong(p_isa + 2, a3);
        objc_setProperty_nonatomic_copy(p_isa, v23, v15, 24);
      }
      objc_msgSend(*(id *)(v12 + 72), "addObject:", p_isa);
      sub_10001465C((_BYTE *)v12);
      if (*(_BYTE *)(v12 + 11) || *(_BYTE *)(v12 + 12))
      {
        if (*(_BYTE *)(v12 + 13))
          sub_1000110C4(v12);
      }
    }
    else
    {
      if (qword_1001E4518 != -1)
        dispatch_once(&qword_1001E4518, &stru_1001B6140);
      if (!_NRLogIsLevelEnabled(qword_1001E4510, 0))
        goto LABEL_34;
      if (qword_1001E4518 != -1)
        dispatch_once(&qword_1001E4518, &stru_1001B6140);
      v24 = (id)qword_1001E4510;
      p_isa = (id *)createStringFromNRDeviceEndpointType(objc_msgSend(v20, "unsignedCharValue"));
      _NRLogWithArgs(v24, 0, "%s%.30s:%-4d ignoring internet relay request from unsupported device type %@", "", "-[NROnDemandLinkSetupManager processIncomingRequest:options:response:]", 597, p_isa);

    }
    goto LABEL_34;
  }
LABEL_36:

}

void sub_100015128(uint64_t a1)
{
  id WeakRetained;
  void *v3;
  int IsLevelEnabled;
  id v5;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v3 = WeakRetained;
  if (WeakRetained && *((_QWORD *)WeakRetained + 6) == *(_QWORD *)(a1 + 32))
  {
    v5 = WeakRetained;
    if (qword_1001E4518 != -1)
      dispatch_once(&qword_1001E4518, &stru_1001B6140);
    IsLevelEnabled = _NRLogIsLevelEnabled(qword_1001E4510, 0);
    v3 = v5;
    if (IsLevelEnabled)
    {
      if (qword_1001E4518 != -1)
        dispatch_once(&qword_1001E4518, &stru_1001B6140);
      _NRLogWithArgs(qword_1001E4510, 0, "%s%.30s:%-4d [Receiver] interrupted", "", "-[NROnDemandLinkSetupManager startReceiver]_block_invoke_3", 288);
      v3 = v5;
    }
  }

}

void sub_100015208(uint64_t a1)
{
  id WeakRetained;
  void *v3;
  int IsLevelEnabled;
  id v5;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v3 = WeakRetained;
  if (WeakRetained && *((_QWORD *)WeakRetained + 6) == *(_QWORD *)(a1 + 32))
  {
    v5 = WeakRetained;
    if (qword_1001E4518 != -1)
      dispatch_once(&qword_1001E4518, &stru_1001B6140);
    IsLevelEnabled = _NRLogIsLevelEnabled(qword_1001E4510, 0);
    v3 = v5;
    if (IsLevelEnabled)
    {
      if (qword_1001E4518 != -1)
        dispatch_once(&qword_1001E4518, &stru_1001B6140);
      _NRLogWithArgs(qword_1001E4510, 0, "%s%.30s:%-4d [Receiver] invalidated", "", "-[NROnDemandLinkSetupManager startReceiver]_block_invoke_4", 295);
      v3 = v5;
    }
  }

}

void sub_1000152E8(uint64_t a1, void *a2)
{
  id *WeakRetained;
  id *v4;
  id v5;

  v5 = a2;
  WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 40));
  v4 = WeakRetained;
  if (WeakRetained && WeakRetained[6] == *(id *)(a1 + 32))
  {
    if (qword_1001E4518 != -1)
      dispatch_once(&qword_1001E4518, &stru_1001B6140);
    if (_NRLogIsLevelEnabled(qword_1001E4510, 0))
    {
      if (qword_1001E4518 != -1)
        dispatch_once(&qword_1001E4518, &stru_1001B6140);
      _NRLogWithArgs(qword_1001E4510, 0, "%s%.30s:%-4d [Receiver] activated with error %@", "", "-[NROnDemandLinkSetupManager startReceiver]_block_invoke_5", 302, v5);
    }
    if (v5)
      objc_msgSend(v4[6], "invalidate");
  }

}

uint64_t sub_1000153E8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_1000153FC(uint64_t a1, int a2)
{
  _BYTE *WeakRetained;
  _BYTE *v4;
  uint32_t state;
  const char *v6;
  id v7;
  int IsLevelEnabled;
  id v9;
  uint32_t v10;
  uint64_t state64;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v4 = WeakRetained;
  if (WeakRetained && *((_DWORD *)WeakRetained + 5) == a2)
  {
    state64 = 0;
    state = notify_get_state(a2, &state64);
    if (state)
    {
      v10 = state;
      v7 = sub_10001248C();
      IsLevelEnabled = _NRLogIsLevelEnabled(v7, 17);

      if (IsLevelEnabled)
      {
        v9 = sub_10001248C();
        _NRLogWithArgs(v9, 17, "notify_get_state(%s, %d) failed: %u", "com.apple.CoreTelephony.Slicing.LLPHS.State", a2, v10);

      }
      v4[15] = 0;
    }
    else
    {
      v4[15] = state64 != 0;
      if (qword_1001E4518 != -1)
        dispatch_once(&qword_1001E4518, &stru_1001B6140);
      if (_NRLogIsLevelEnabled(qword_1001E4510, 0))
      {
        if (qword_1001E4518 != -1)
          dispatch_once(&qword_1001E4518, &stru_1001B6140);
        if (v4[15])
          v6 = "en";
        else
          v6 = "dis";
        _NRLogWithArgs(qword_1001E4510, 0, "%s%.30s:%-4d cellular slicing is %sabled", "", "-[NROnDemandLinkSetupManager monitorState]_block_invoke", 240, v6);
      }
      if (!v4[15] && v4[13])
        objc_msgSend(v4, "didUpdatePHSState:llphsActive:", 0, 0);
    }
  }

}

void sub_100015590(uint64_t a1)
{
  id v2;
  id v3;
  id v4;
  uint64_t v5;
  void *v6;
  char *v7;
  char *v8;
  id v9;
  void *v10;
  id v11;
  BOOL v12;
  id v13;
  BOOL v14;
  _BYTE *v15;
  id v16;
  BOOL v17;
  NRValidPeer *v18;
  void *v19;
  id *v20;
  _QWORD *v21;
  _QWORD *v22;
  id v23;
  id v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  _BYTE v29[128];

  v2 = sub_1000137E8(*(_QWORD *)(a1 + 32));
  v25 = 0u;
  v26 = 0u;
  v27 = 0u;
  v28 = 0u;
  v3 = v2;
  v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v25, v29, 16);
  if (v4)
  {
    v5 = *(_QWORD *)v26;
    do
    {
      v6 = 0;
      do
      {
        if (*(_QWORD *)v26 != v5)
          objc_enumerationMutation(v3);
        v7 = sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(*((_QWORD *)&v25 + 1) + 8 * (_QWORD)v6));
        v8 = v7;
        if (v7)
        {
          v9 = *((id *)v7 + 16);
          if (v9)
          {
            v10 = v9;
            v11 = *((id *)v8 + 16);
            v12 = objc_msgSend(v11, "operationalScope", (_QWORD)v25) == 0;

            if (!v12)
            {
              if (v8[8])
              {
                if (v8[9])
                {
                  v13 = *((id *)v8 + 16);
                  v14 = ((unint64_t)objc_msgSend(v13, "operationalScope") & 1) == 0;

                  if (!v14)
                  {
                    v15 = *(_BYTE **)(a1 + 32);
                    if (v15)
                    {
                      if (v15[11] || v15[12])
                        goto LABEL_20;
                      sub_10001465C(v15);
                    }
                    v16 = *((id *)v8 + 6);
                    v17 = v16 == 0;

                    if (!v17)
                    {
                      v18 = [NRValidPeer alloc];
                      v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", *((unsigned __int16 *)v8 + 14)));
                      v20 = sub_10001183C((id *)&v18->super.isa, v19);

                      v21 = *(_QWORD **)(a1 + 32);
                      if (v21)
                        v21 = (_QWORD *)v21[11];
                      v22 = v21;
                      v23 = *((id *)v8 + 6);
                      objc_msgSend(v22, "setObject:forKeyedSubscript:", v20, v23);

                    }
                  }
                }
              }
            }
          }
        }
LABEL_20:

        v6 = (char *)v6 + 1;
      }
      while (v4 != v6);
      v24 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v25, v29, 16);
      v4 = v24;
    }
    while (v24);
  }

  sub_1000134C0(*(_QWORD *)(a1 + 32));
}

void sub_100015D68(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001E4520;
  qword_1001E4520 = (uint64_t)v1;

}

_BYTE *sub_100015D98(_BYTE *a1, void *a2)
{
  id v4;
  id v5;
  id v7;
  int IsLevelEnabled;
  id v9;
  uint64_t v10;
  char *v11;
  int *v12;
  uint64_t v13;
  id v14;
  uint64_t v15;
  objc_super v16;

  v4 = a2;
  if (a1)
  {
    v16.receiver = a1;
    v16.super_class = (Class)NRNetInfo;
    v5 = objc_msgSendSuper2(&v16, "init");
    if (!v5)
    {
      v7 = sub_100015EFC();
      IsLevelEnabled = _NRLogIsLevelEnabled(v7, 16);

      if (IsLevelEnabled)
      {
        v9 = sub_100015EFC();
        _NRLogWithArgs(v9, 16, "%s%.30s:%-4d ABORTING: [super init] failed", "", "-[NRNetInfo initWithQueue:]", 95);

      }
      v10 = _os_log_pack_size(12);
      v11 = (char *)&v15 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
      v12 = __error();
      v13 = _os_log_pack_fill(v11, v10, *v12, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)v13 = 136446210;
      *(_QWORD *)(v13 + 4) = "-[NRNetInfo initWithQueue:]";
      v14 = sub_100015EFC();
      _NRLogAbortWithPack(v14, v11);
    }
    a1 = v5;
    objc_storeStrong((id *)v5 + 6, a2);
    a1[14] = 1;
  }

  return a1;
}

id sub_100015EFC()
{
  if (qword_1001E4528 != -1)
    dispatch_once(&qword_1001E4528, &stru_1001B6248);
  return (id)qword_1001E4520;
}

char *sub_100015F3C(char *a1, void *a2)
{
  char *v2;
  __objc2_prot *v3;
  char *v5;
  char *v6;
  char *v7;
  id v8;
  int v9;
  uint64_t v10;
  void *v11;
  char *v12;
  id v14;
  void *v15;
  id v16;
  int IsLevelEnabled;
  id v18;
  int *v19;
  uint64_t v20;
  id v21;
  objc_super v22;
  _QWORD v23[6];
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t (*v27)(uint64_t, uint64_t);
  void (*v28)(uint64_t);
  id v29;
  unsigned __int8 v30;
  uint64_t v31;
  unsigned __int16 v32;

  v5 = a2;
  if (!a1)
    goto LABEL_24;
  v22.receiver = a1;
  v22.super_class = (Class)NRNetInfo;
  v6 = (char *)objc_msgSendSuper2(&v22, "init");
  a1 = v6;
  if (!v6)
  {
    v16 = sub_100015EFC();
    IsLevelEnabled = _NRLogIsLevelEnabled(v16, 16);

    if (IsLevelEnabled)
    {
      v18 = sub_100015EFC();
      _NRLogWithArgs(v18, 16, "%s%.30s:%-4d ABORTING: [super init] failed", "", "-[NRNetInfo initWithIncomingData:]", 103);

    }
    a1 = (char *)_os_log_pack_size(12);
    v5 = (char *)&v22 - ((__chkstk_darwin(a1) + 15) & 0xFFFFFFFFFFFFFFF0);
    v19 = __error();
    v20 = _os_log_pack_fill(v5, a1, *v19, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)v20 = 136446210;
    *(_QWORD *)(v20 + 4) = "-[NRNetInfo initWithIncomingData:]";
    v21 = sub_100015EFC();
    _NRLogAbortWithPack(v21, v5);
    __break(1u);
LABEL_39:
    dispatch_once(&qword_1001E4528, &stru_1001B6248);
LABEL_7:
    if (_NRLogIsLevelEnabled(qword_1001E4520, 16))
    {
      if (v3[18].inst_meths != (__objc2_meth_list *)-1)
        dispatch_once(&qword_1001E4528, &stru_1001B6248);
      v8 = (id)qword_1001E4520;
      _NRLogWithArgs(v8, 16, "%s%.30s:%-4d received insufficient bytes for net-info %u", "", "-[NRNetInfo processIncomingData:]", 591, objc_msgSend(v2, "length"));

    }
    goto LABEL_23;
  }
  v6[11] = 1;
  v7 = v5;
  v2 = v7;
  if (a1[10])
  {

    goto LABEL_24;
  }
  v32 = 0;
  v31 = 0;
  if ((unint64_t)objc_msgSend(v7, "length") <= 9)
  {
    v3 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
    if (qword_1001E4528 == -1)
      goto LABEL_7;
    goto LABEL_39;
  }
  v30 = 0;
  objc_msgSend(v2, "getBytes:length:", &v30, 1);
  v9 = v30;
  if (v30 >= 2u)
  {
    if (qword_1001E4528 != -1)
      dispatch_once(&qword_1001E4528, &stru_1001B6248);
    if (_NRLogIsLevelEnabled(qword_1001E4520, 16))
    {
      if (qword_1001E4528 != -1)
        dispatch_once(&qword_1001E4528, &stru_1001B6248);
      _NRLogWithArgs(qword_1001E4520, 16, "%s%.30s:%-4d received unsupported net-info version %d", "", "-[NRNetInfo processIncomingData:]", 599, v30);
    }
    goto LABEL_23;
  }
  a1[14] = v30;
  if (v9 != 1)
  {
LABEL_23:

    goto LABEL_24;
  }
  objc_msgSend(v2, "getBytes:range:", &v31, 0, 10);
  v10 = bswap32(v32) >> 16;
  if (objc_msgSend(v2, "length") != (id)(v10 + 10))
  {
    if (qword_1001E4528 != -1)
      dispatch_once(&qword_1001E4528, &stru_1001B6248);
    if (_NRLogIsLevelEnabled(qword_1001E4520, 16))
    {
      v14 = sub_100015EFC();
      _NRLogWithArgs(v14, 16, "%s%.30s:%-4d received insufficient tlv bytes for net-info %u != (%zu + %u)", "", "-[NRNetInfo processIncomingData:]", 610, objc_msgSend(v2, "length"), 0xAuLL, v10);

    }
    goto LABEL_23;
  }
  if (v10 < 4)
    v11 = 0;
  else
    v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "subdataWithRange:", 10, v10));
  *(_WORD *)(a1 + 15) = WORD1(v31);
  *((_DWORD *)a1 + 7) = bswap32(HIDWORD(v31));
  v24 = 0;
  v25 = &v24;
  v26 = 0x3032000000;
  v27 = sub_100016478;
  v28 = sub_100016488;
  v29 = 0;
  v15 = (void *)*((_QWORD *)a1 + 5);
  *((_QWORD *)a1 + 5) = 0;

  if (!v11
    || (v23[0] = _NSConcreteStackBlock,
        v23[1] = 3221225472,
        v23[2] = sub_100016490,
        v23[3] = &unk_1001B6228,
        v23[4] = a1,
        v23[5] = &v24,
        (NRTLVParse(v11, v23) & 1) != 0))
  {
    objc_storeStrong((id *)a1 + 16, (id)v25[5]);
    _Block_object_dispose(&v24, 8);

    a1 = a1;
    v12 = a1;
    goto LABEL_25;
  }
  _Block_object_dispose(&v24, 8);

LABEL_24:
  v12 = 0;
LABEL_25:

  return v12;
}

void sub_10001645C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 128), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100016478(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_100016488(uint64_t a1)
{

}

uint64_t sub_100016490(uint64_t a1, unsigned __int8 *a2)
{
  unsigned int v4;
  uint64_t v5;
  unsigned int v6;
  BOOL v7;
  uint64_t result;
  id v9;
  id v10;
  id v11;
  id v12;
  void *v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  void *v22;
  id v23;
  uint64_t v24;
  void *v25;
  _QWORD v26[6];
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t (*v30)(uint64_t, uint64_t);
  void (*v31)(uint64_t);
  id v32;

  v4 = *(unsigned __int16 *)(a2 + 1);
  v5 = __rev16(v4);
  v6 = sub_10001693C(*(_QWORD *)(a1 + 32), *a2);
  if (v6)
    v7 = v6 >= v5;
  else
    v7 = 1;
  if (v7)
  {
    result = 1;
    switch(*a2)
    {
      case 1u:
        v9 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", a2 + 3, bswap32(*(unsigned __int16 *)(a2 + 1)) >> 16);
        v10 = *(id *)(a1 + 32);
        v11 = v9;
        v12 = v11;
        if (v10)
        {
          v27 = 0;
          v28 = &v27;
          v29 = 0x3032000000;
          v30 = sub_100016478;
          v31 = sub_100016488;
          v32 = 0;
          v26[0] = _NSConcreteStackBlock;
          v26[1] = 3221225472;
          v26[2] = sub_100016AF8;
          v26[3] = &unk_1001B6228;
          v26[4] = v10;
          v26[5] = &v27;
          if (NRTLVParse(v11, v26))
            v13 = (void *)v28[5];
          else
            v13 = 0;
          v10 = v13;
          _Block_object_dispose(&v27, 8);

          if (v10)
          {
            v22 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
            if (!v22)
            {
              v23 = objc_alloc_init((Class)NSMutableArray);
              v24 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
              v25 = *(void **)(v24 + 40);
              *(_QWORD *)(v24 + 40) = v23;

              v22 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
            }
            objc_msgSend(v22, "addObject:", v10);
          }
        }
        else
        {

        }
        goto LABEL_54;
      case 2u:
        v12 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", a2 + 3, v5);
        v17 = *(_QWORD *)(a1 + 32);
        if (v17)
          objc_storeStrong((id *)(v17 + 40), v12);
LABEL_54:

        goto LABEL_55;
      case 3u:
        if (v4 == 2048)
        {
          *(_QWORD *)(*(_QWORD *)(a1 + 32) + 112) = *(_QWORD *)(a2 + 3);
          v15 = *(_QWORD *)(a1 + 32);
          if (v15)
            *(_QWORD *)(v15 + 112) = bswap64(*(_QWORD *)(v15 + 112));
          return result;
        }
        if (qword_1001E4528 != -1)
          dispatch_once(&qword_1001E4528, &stru_1001B6248);
        if (!_NRLogIsLevelEnabled(qword_1001E4520, 16))
          goto LABEL_55;
        if (qword_1001E4528 != -1)
          dispatch_once(&qword_1001E4528, &stru_1001B6248);
        v20 = qword_1001E4520;
        v21 = 649;
        goto LABEL_47;
      case 4u:
        if (v4 == 2048)
        {
          *(_QWORD *)(*(_QWORD *)(a1 + 32) + 120) = *(_QWORD *)(a2 + 3);
          v18 = *(_QWORD *)(a1 + 32);
          if (v18)
            *(_QWORD *)(v18 + 120) = bswap64(*(_QWORD *)(v18 + 120));
          return result;
        }
        if (qword_1001E4528 != -1)
          dispatch_once(&qword_1001E4528, &stru_1001B6248);
        if (!_NRLogIsLevelEnabled(qword_1001E4520, 16))
          goto LABEL_55;
        if (qword_1001E4528 != -1)
          dispatch_once(&qword_1001E4528, &stru_1001B6248);
        v20 = qword_1001E4520;
        v21 = 657;
        goto LABEL_47;
      case 5u:
        if (v4 == 1024)
        {
          v19 = *(_QWORD *)(a1 + 32);
          if (v19)
            *(_DWORD *)(v19 + 20) = bswap32(*(_DWORD *)(a2 + 3));
        }
        else
        {
          if (qword_1001E4528 != -1)
            dispatch_once(&qword_1001E4528, &stru_1001B6248);
          if (_NRLogIsLevelEnabled(qword_1001E4520, 16))
          {
            if (qword_1001E4528 != -1)
              dispatch_once(&qword_1001E4528, &stru_1001B6248);
            v20 = qword_1001E4520;
            v21 = 665;
LABEL_47:
            _NRLogWithArgs(v20, 16, "%s%.30s:%-4d invalid tlv data size", "", "-[NRNetInfo processIncomingData:]_block_invoke", v21);
          }
LABEL_55:
          result = 1;
        }
        break;
      case 7u:
        v16 = *(_QWORD *)(a1 + 32);
        if (v16)
          *(_BYTE *)(v16 + 9) = 1;
        return result;
      default:
        return result;
    }
  }
  else
  {
    v14 = v6;
    if (qword_1001E4528 != -1)
      dispatch_once(&qword_1001E4528, &stru_1001B6248);
    result = _NRLogIsLevelEnabled(qword_1001E4520, 16);
    if ((_DWORD)result)
    {
      if (qword_1001E4528 != -1)
        dispatch_once(&qword_1001E4528, &stru_1001B6248);
      _NRLogWithArgs(qword_1001E4520, 16, "%s%.30s:%-4d unexpected length %u > %u for tlv type %u", "", "-[NRNetInfo processIncomingData:]_block_invoke", 629, v5, v14, *a2);
      return 0;
    }
  }
  return result;
}

void sub_100016908(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10001693C(uint64_t result, int a2)
{
  if (result)
  {
    result = 0x8000;
    switch(a2)
    {
      case 0:
        goto LABEL_13;
      case 1:
        return result;
      case 2:
        result = 1024;
        break;
      case 3:
      case 4:
      case 6:
        result = 8;
        break;
      case 5:
        result = 4;
        break;
      case 41:
      case 42:
      case 43:
        result = 0x2000;
        break;
      default:
        if (qword_1001E4528 != -1)
          dispatch_once(&qword_1001E4528, &stru_1001B6248);
        result = _NRLogIsLevelEnabled(qword_1001E4520, 1);
        if ((_DWORD)result)
        {
          if (qword_1001E4528 != -1)
            dispatch_once(&qword_1001E4528, &stru_1001B6248);
          _NRLogWithArgs(qword_1001E4520, 1, "%s%.30s:%-4d unhandled type %u", "", "-[NRNetInfo maxTLVLen:]", 580, a2);
LABEL_13:
          result = 0;
        }
        break;
    }
  }
  return result;
}

uint64_t sub_100016AF8(uint64_t a1, unsigned __int8 *a2)
{
  unsigned int v4;
  uint64_t v5;
  unsigned int v6;
  BOOL v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t result;
  id v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  id v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  void *v25;

  v4 = *(unsigned __int16 *)(a2 + 1);
  v5 = __rev16(v4);
  v6 = sub_10001693C(*(_QWORD *)(a1 + 32), *a2);
  if (v6)
    v7 = v6 >= v5;
  else
    v7 = 1;
  if (!v7)
  {
    if (qword_1001E4528 != -1)
      dispatch_once(&qword_1001E4528, &stru_1001B6248);
    result = _NRLogIsLevelEnabled(qword_1001E4520, 16);
    if ((_DWORD)result)
    {
      if (qword_1001E4528 != -1)
        dispatch_once(&qword_1001E4528, &stru_1001B6248);
      _NRLogWithArgs(qword_1001E4520, 16, "%s%.30s:%-4d unexpected length %u > %u for tlv type %u", "");
      return 0;
    }
    return result;
  }
  v8 = *a2;
  if (v8 == 43)
  {
    v15 = objc_msgSend(objc_alloc((Class)NSString), "initWithBytes:length:encoding:", a2 + 3, v5, 4);
    if (v15)
    {
      v16 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
      if (!v16)
      {
        v17 = nw_resolver_config_create();
        v18 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
        v19 = *(void **)(v18 + 40);
        *(_QWORD *)(v18 + 40) = v17;

        v16 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
      }
      nw_resolver_config_add_search_domain(v16, objc_msgSend(v15, "UTF8String"));
    }
    goto LABEL_28;
  }
  if (v8 == 42)
  {
    v15 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", a2 + 3, v5);
    v20 = sub_10010A6B4(v15, 1, 0, 0);
    v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
    if (v21)
    {
      if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40))
      {
        v22 = nw_resolver_config_create();
        v23 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
        v24 = *(void **)(v23 + 40);
        *(_QWORD *)(v23 + 40) = v22;

      }
      v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "hostname"));
      nw_resolver_config_add_name_server(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), objc_msgSend(v25, "UTF8String"));

    }
LABEL_28:

    return 1;
  }
  if (v8 != 41)
    return 1;
  if (v4 == 512)
  {
    v9 = *(unsigned __int16 *)(a2 + 3);
    v10 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
    if (!v10)
    {
      v11 = nw_resolver_config_create();
      v12 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
      v13 = *(void **)(v12 + 40);
      *(_QWORD *)(v12 + 40) = v11;

      v10 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
    }
    nw_resolver_config_set_class(v10, __rev16(v9));
    return 1;
  }
  if (qword_1001E4528 != -1)
    dispatch_once(&qword_1001E4528, &stru_1001B6248);
  result = _NRLogIsLevelEnabled(qword_1001E4520, 16);
  if ((_DWORD)result)
  {
    if (qword_1001E4528 != -1)
      dispatch_once(&qword_1001E4528, &stru_1001B6248);
    _NRLogWithArgs(qword_1001E4520, 16, "%s%.30s:%-4d invalid length for resolver class %d != %zu");
    return 0;
  }
  return result;
}

void sub_100016DFC(uint64_t a1, void *a2)
{
  id v3;
  id *WeakRetained;
  id *v5;
  id v6;
  void *v7;
  NSObject *v8;
  NSObject *v9;
  nw_interface_type_t type;
  NSString *v11;
  id v12;
  id v13;
  int v14;
  unsigned int v15;
  void *v16;
  unsigned int v17;
  unsigned int v18;
  int IsLevelEnabled;
  uint64_t v20;
  id v21;
  id v22;
  uint64_t v23;
  void *v24;
  id v25;
  int64_t v26;
  dispatch_time_t v27;
  _QWORD *v28;
  NSObject *v29;
  unsigned int v30;
  _QWORD block[4];
  id v32;
  id v33;
  void *v34;
  id location;

  v3 = a2;
  if (qword_1001E4528 != -1)
    dispatch_once(&qword_1001E4528, &stru_1001B6248);
  if (_NRLogIsLevelEnabled(qword_1001E4520, 0))
  {
    if (qword_1001E4528 != -1)
      dispatch_once(&qword_1001E4528, &stru_1001B6248);
    _NRLogWithArgs(qword_1001E4520, 0, "%s%.30s:%-4d received path update: %@", "", "-[NRNetInfo start]_block_invoke", 144, v3);
  }
  WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 48));
  v5 = WeakRetained;
  if (WeakRetained && !*((_BYTE *)WeakRetained + 10) && WeakRetained[9] == *(id *)(a1 + 32))
  {
    v6 = v3;
    v7 = v6;
    if (*((_BYTE *)v5 + 12))
      goto LABEL_54;
    v8 = nw_path_copy_interface(v6);
    v9 = v8;
    if (v8)
    {
      type = nw_interface_get_type(v8);
      if (type == *((unsigned __int8 *)v5 + 16))
      {
        location = 0;
        v34 = 0;
        v11 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", nw_interface_get_name(v9));
        v12 = (id)objc_claimAutoreleasedReturnValue(v11);

        v13 = location;
        if (location)
        {
          v14 = 0;
          goto LABEL_27;
        }
LABEL_25:
        v12 = v5[12];
        v13 = 0;
        if (!v12)
        {
          v15 = 0;
LABEL_30:

LABEL_31:
          v16 = v34;
          if (v34 || (v12 = v5[13]) != 0)
          {
            v17 = objc_msgSend(v16, "intersectsSet:", v5[13]) ^ 1;
            if (v16)
            {
LABEL_37:
              if ((v15 | v17) == 1)
              {
                *((_BYTE *)v5 + 12) = 1;
                if (v15)
                {
                  v30 = v17;
                  if (qword_1001E4528 != -1)
                    dispatch_once(&qword_1001E4528, &stru_1001B6248);
                  IsLevelEnabled = _NRLogIsLevelEnabled(qword_1001E4520, 1);
                  v17 = v30;
                  if (IsLevelEnabled)
                  {
                    if (qword_1001E4528 != -1)
                      dispatch_once(&qword_1001E4528, &stru_1001B6248);
                    v20 = (uint64_t)v5[12];
                    v21 = location;
                    v22 = (id)qword_1001E4520;
                    _NRLogWithArgs(v22, 1, "%s%.30s:%-4d local v4 addresses changed: %@ -> %@", "", "-[NRNetInfo checkPathForNetworkFlaps:]", 220, v20, v21);

                    v17 = v30;
                  }
                }
                if (v17)
                {
                  if (qword_1001E4528 != -1)
                    dispatch_once(&qword_1001E4528, &stru_1001B6248);
                  if (_NRLogIsLevelEnabled(qword_1001E4520, 1))
                  {
                    if (qword_1001E4528 != -1)
                      dispatch_once(&qword_1001E4528, &stru_1001B6248);
                    v23 = (uint64_t)v5[13];
                    v24 = v34;
                    v25 = (id)qword_1001E4520;
                    _NRLogWithArgs(v25, 1, "%s%.30s:%-4d local v6 addresses changed: %@ -> %@", "", "-[NRNetInfo checkPathForNetworkFlaps:]", 223, v23, v24);

                  }
                }
              }

LABEL_53:
LABEL_54:

              if (!*((_BYTE *)v5 + 8))
              {
                objc_initWeak(&location, v5);
                *((_BYTE *)v5 + 8) = 1;
                if (*((_BYTE *)v5 + 17))
                  v26 = 500000000;
                else
                  v26 = 10000000000;
                v27 = dispatch_time(0x8000000000000000, v26);
                v28 = *(_QWORD **)(a1 + 40);
                if (v28)
                  v28 = (_QWORD *)v28[6];
                block[0] = _NSConcreteStackBlock;
                block[1] = 3221225472;
                block[2] = sub_100017DD4;
                block[3] = &unk_1001B87F0;
                v29 = v28;
                objc_copyWeak(&v33, &location);
                v32 = *(id *)(a1 + 32);
                dispatch_after(v27, v29, block);

                objc_destroyWeak(&v33);
                objc_destroyWeak(&location);
              }
              goto LABEL_61;
            }
          }
          else
          {
            v17 = 0;
          }
          v18 = v17;

          v17 = v18;
          goto LABEL_37;
        }
        v14 = 1;
LABEL_27:
        v15 = objc_msgSend(v13, "intersectsSet:", v5[12]) ^ 1;
        v13 = v12;
        if (!v14)
          goto LABEL_31;
        goto LABEL_30;
      }
    }
    else
    {
      if (!*((_BYTE *)v5 + 16))
      {
        location = 0;
        v34 = 0;
        goto LABEL_25;
      }
      type = nw_interface_type_other;
    }
    if (qword_1001E4528 != -1)
      dispatch_once(&qword_1001E4528, &stru_1001B6248);
    if (_NRLogIsLevelEnabled(qword_1001E4520, 1))
    {
      if (qword_1001E4528 != -1)
        dispatch_once(&qword_1001E4528, &stru_1001B6248);
      _NRLogWithArgs(qword_1001E4520, 1, "%s%.30s:%-4d interface type changed: %u -> %u", "", "-[NRNetInfo checkPathForNetworkFlaps:]", 201, *((unsigned __int8 *)v5 + 16), type);
    }
    *((_BYTE *)v5 + 12) = 1;
    goto LABEL_53;
  }
LABEL_61:

}

void sub_10001730C(uint64_t a1)
{
  id v2;
  uint64_t v3;
  void *v4;
  unsigned __int8 status;
  NSObject *v6;
  NSObject *v7;
  NSString *v8;
  void *v9;
  void *v10;
  int v11;
  int v12;
  int v13;
  uint64_t estimated_upload_throughput;
  uint64_t estimated_download_throughput;
  id v16;
  unint64_t v17;
  unint64_t v18;
  void *v19;
  id v20;
  uint64_t v21;
  int v22;
  void *v23;
  void *v24;
  int v25;
  id v26;
  id v27;
  id v28;
  void (*v29)(uint64_t);
  id v30;
  id v31;
  id v32;
  id v33;
  id v34;
  id v35;
  _BOOL4 v36;
  id *v37;
  id *v38;
  id *v39;
  id *v40;
  NSObject *v41;
  id v42;
  _QWORD *v43;
  _QWORD *v44;
  id v45;
  _QWORD *v46;
  id v47;
  int v48;
  int IsLevelEnabled;
  id v50;
  id v51;
  unsigned __int8 v52;
  void *v53;
  NSObject *v54;
  id v55;
  int v56;
  id v57;
  NSObject *v58;
  char v59;
  int type;
  void *v61;
  _QWORD block[10];
  uint64_t v63;
  uint64_t *v64;
  uint64_t v65;
  uint64_t (*v66)(uint64_t, uint64_t);
  void (*v67)(uint64_t);
  id v68;
  id obj;
  void *v70;
  _QWORD v71[4];
  id v72;
  _QWORD v73[4];
  id v74;
  void **v75;
  uint64_t v76;
  void *v77;
  void *v78;
  id v79;
  id v80;
  void ***v81;
  void **v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t (*v85)(uint64_t, uint64_t);
  void (*v86)(uint64_t);
  id v87;

  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 48));
  *(_BYTE *)(a1 + 8) = 0;
  v2 = *(id *)(a1 + 72);
  v3 = nw_path_evaluator_copy_path();
  v4 = *(void **)(a1 + 64);
  *(_QWORD *)(a1 + 64) = v3;

  status = nw_path_get_status(*(nw_path_t *)(a1 + 64));
  v6 = nw_path_copy_interface(*(_QWORD *)(a1 + 64));
  obj = 0;
  v70 = 0;
  v58 = v6;
  if (v6)
  {
    v7 = v6;
    type = nw_interface_get_type(v6);
    v8 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", nw_interface_get_name(v7));
    v9 = (void *)objc_claimAutoreleasedReturnValue(v8);

    v10 = v70;
  }
  else
  {
    v10 = 0;
    type = 0;
  }
  objc_storeStrong((id *)(a1 + 96), v10);
  objc_storeStrong((id *)(a1 + 104), obj);
  if (nw_path_is_expensive(*(nw_path_t *)(a1 + 64)))
    v11 = 8;
  else
    v11 = 0;
  if (nw_path_is_constrained(*(nw_path_t *)(a1 + 64)))
    v11 |= 0x10u;
  v12 = v11 | nw_path_has_dns(*(nw_path_t *)(a1 + 64));
  if (nw_path_has_ipv4(*(nw_path_t *)(a1 + 64)))
    v12 |= 2u;
  if (nw_path_has_ipv6(*(nw_path_t *)(a1 + 64)))
    v12 |= 4u;
  if (nw_path_is_roaming(*(_QWORD *)(a1 + 64)))
    v13 = v12 | 0x20;
  else
    v13 = v12;
  if (*(_BYTE *)(a1 + 13))
  {
    estimated_upload_throughput = nw_path_get_estimated_upload_throughput(*(_QWORD *)(a1 + 64));
    estimated_download_throughput = nw_path_get_estimated_download_throughput(*(_QWORD *)(a1 + 64));
  }
  else
  {
    estimated_upload_throughput = 0;
    estimated_download_throughput = 0;
  }
  if (*(unsigned __int8 *)(a1 + 15) == status
    && *(unsigned __int8 *)(a1 + 16) == type
    && *(_DWORD *)(a1 + 28) == v13
    && *(_QWORD *)(a1 + 112) == estimated_upload_throughput
    && *(_QWORD *)(a1 + 120) == estimated_download_throughput)
  {
    v59 = 0;
  }
  else
  {
    *(_BYTE *)(a1 + 15) = status;
    *(_BYTE *)(a1 + 16) = type;
    *(_DWORD *)(a1 + 28) = v13;
    v59 = 1;
    *(_QWORD *)(a1 + 112) = estimated_upload_throughput;
    *(_QWORD *)(a1 + 120) = estimated_download_throughput;
  }
  v63 = 0;
  v64 = &v63;
  v65 = 0x3032000000;
  v66 = sub_100016478;
  v67 = sub_100016488;
  v68 = 0;
  v16 = *(id *)(a1 + 64);
  block[5] = _NSConcreteStackBlock;
  block[6] = 3221225472;
  block[7] = sub_100017C18;
  block[8] = &unk_1001B61B0;
  block[9] = &v63;
  nw_path_enumerate_resolver_configs();

  v17 = (unint64_t)(id)v64[5];
  v18 = (unint64_t)*(id *)(a1 + 128);
  v19 = (void *)v18;
  v61 = (void *)v17;
  if (!(v17 | v18))
    goto LABEL_27;
  v20 = objc_msgSend((id)v18, "count");
  if (v20 == objc_msgSend(v61, "count"))
  {
    if (!objc_msgSend(v19, "count"))
    {
LABEL_27:

      goto LABEL_45;
    }
    v21 = 0;
    v22 = 0;
    while (1)
    {
      v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "objectAtIndex:", v21));
      v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v61, "objectAtIndex:", v21));
      v25 = nw_resolver_config_get_class(v23);
      if (v25 != nw_resolver_config_get_class(v24))
        break;
      v26 = objc_alloc_init((Class)NSMutableArray);
      v27 = objc_alloc_init((Class)NSMutableArray);
      v75 = _NSConcreteStackBlock;
      v76 = 3221225472;
      v77 = sub_100017CB4;
      v78 = &unk_1001B61D8;
      v28 = v26;
      v79 = v28;
      nw_resolver_config_enumerate_name_servers(v23, &v75);
      v82 = _NSConcreteStackBlock;
      v83 = 3221225472;
      v84 = (uint64_t)sub_100017CFC;
      v85 = (uint64_t (*)(uint64_t, uint64_t))&unk_1001B61D8;
      v29 = (void (*)(uint64_t))v27;
      v86 = v29;
      nw_resolver_config_enumerate_name_servers(v24, &v82);
      v30 = objc_msgSend(v28, "count");
      if (v30 == objc_msgSend(v29, "count") && objc_msgSend(v28, "isEqualToArray:", v29))
      {
        v31 = objc_alloc_init((Class)NSMutableArray);
        v32 = objc_alloc_init((Class)NSMutableArray);
        v73[0] = _NSConcreteStackBlock;
        v73[1] = 3221225472;
        v73[2] = sub_100017D44;
        v73[3] = &unk_1001B61D8;
        v33 = v31;
        v74 = v33;
        nw_resolver_config_enumerate_search_domains(v23, v73);
        v71[0] = _NSConcreteStackBlock;
        v71[1] = 3221225472;
        v71[2] = sub_100017D8C;
        v71[3] = &unk_1001B61D8;
        v34 = v32;
        v72 = v34;
        nw_resolver_config_enumerate_search_domains(v24, v71);
        v35 = objc_msgSend(v33, "count");
        v36 = v35 != objc_msgSend(v34, "count") || (objc_msgSend(v33, "isEqualToArray:", v34) & 1) == 0;

      }
      else
      {
        v36 = 1;
      }

      if (v36)
        goto LABEL_44;
      v21 = (unsigned __int16)++v22;
      if ((unint64_t)objc_msgSend(v19, "count") <= (unsigned __int16)v22)
        goto LABEL_27;
    }

  }
LABEL_44:

  objc_storeStrong((id *)(a1 + 128), (id)v64[5]);
  v59 = 1;
LABEL_45:
  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v37 = (id *)(id)qword_1001E4708;
  v38 = v37;
  if (v37 && (v39 = (id *)v37[6]) != 0)
  {
    v40 = v39;
    v41 = v39[3];
    dispatch_assert_queue_V2(v41);

    v82 = 0;
    v83 = (uint64_t)&v82;
    v84 = 0x3032000000;
    v85 = sub_10014387C;
    v86 = sub_10014388C;
    v87 = 0;
    v42 = v40[22];
    v43 = v40[13];
    if (v43)
      v43 = (_QWORD *)v43[3];
    v44 = v43;
    v75 = _NSConcreteStackBlock;
    v76 = 3221225472;
    v77 = sub_1001491B8;
    v78 = &unk_1001B8868;
    v45 = v42;
    v79 = v45;
    v46 = v44;
    v80 = v46;
    v81 = &v82;
    if (sub_1001437AC((uint64_t)NRLinkManagerWiFi, &v75))
    {
      v42 = sub_100140BFC();
      IsLevelEnabled = _NRLogIsLevelEnabled(v42, 16);

      if (IsLevelEnabled)
      {
        v42 = sub_100140BFC();
        _NRLogWithArgs(v42, 16, "%s%.30s:%-4d Timed out getting WiFi SSID", "", "-[NRLinkManagerWiFi copyWiFiSSIDData]", 1925);

      }
      v47 = 0;
    }
    else
    {
      v47 = *(id *)(v83 + 40);
    }

    _Block_object_dispose(&v82, 8);
    if (v47)
    {
      v48 = 0;
      goto LABEL_61;
    }
  }
  else
  {

  }
  v50 = *(id *)(a1 + 40);
  v47 = 0;
  if (!v50)
    goto LABEL_65;
  v42 = v50;
  v48 = 1;
LABEL_61:
  v51 = *(id *)(a1 + 40);
  v52 = objc_msgSend(v47, "isEqualToData:", v51);

  if (v48)
  if ((v52 & 1) == 0)
  {
    objc_storeStrong((id *)(a1 + 40), v47);
    v59 = 1;
  }
LABEL_65:
  if (type != 1)
  {
    v53 = *(void **)(a1 + 40);
    *(_QWORD *)(a1 + 40) = 0;

  }
  if ((v59 & 1) != 0)
    goto LABEL_68;
  if (*(_BYTE *)(a1 + 15) != 2 && *(_BYTE *)(a1 + 12))
  {
    ++*(_DWORD *)(a1 + 20);
    if (qword_1001E4528 != -1)
      dispatch_once(&qword_1001E4528, &stru_1001B6248);
    v55 = (id)qword_1001E4520;
    v56 = _NRLogIsLevelEnabled(v55, 1);

    if (v56)
    {
      if (qword_1001E4528 != -1)
        dispatch_once(&qword_1001E4528, &stru_1001B6248);
      v57 = (id)qword_1001E4520;
      _NRLogWithArgs(v57, 1, "%s%.30s:%-4d forcing a net-info update due to a network flap (id: %u)", "", "-[NRNetInfo processPathUpdate]", 325, *(_DWORD *)(a1 + 20));

    }
LABEL_68:
    ++*(_QWORD *)(a1 + 32);
    v54 = *(NSObject **)(a1 + 48);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100017C88;
    block[3] = &unk_1001B8AE0;
    block[4] = a1;
    dispatch_async(v54, block);
  }
  *(_BYTE *)(a1 + 12) = 0;

  _Block_object_dispose(&v63, 8);
}

void sub_100017BE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  uint64_t v27;

  _Block_object_dispose((const void *)(v27 - 152), 8);
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100017C18(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  id v5;
  uint64_t v6;
  void *v7;

  v3 = a2;
  v4 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  if (!v4)
  {
    v5 = objc_alloc_init((Class)NSMutableArray);
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v7 = *(void **)(v6 + 40);
    *(_QWORD *)(v6 + 40) = v5;

    v4 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  }
  objc_msgSend(v4, "addObject:", v3);

  return 1;
}

uint64_t sub_100017C88(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 32);
  if (!v1)
    return MEMORY[0x10]();
  if (!*(_BYTE *)(v1 + 10))
    return (*(uint64_t (**)(void))(*(_QWORD *)(v1 + 56) + 16))();
  return result;
}

uint64_t sub_100017CB4(uint64_t a1, uint64_t a2)
{
  void *v2;
  void *v3;

  v2 = *(void **)(a1 + 32);
  v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a2));
  objc_msgSend(v2, "addObject:", v3);

  return 1;
}

uint64_t sub_100017CFC(uint64_t a1, uint64_t a2)
{
  void *v2;
  void *v3;

  v2 = *(void **)(a1 + 32);
  v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a2));
  objc_msgSend(v2, "addObject:", v3);

  return 1;
}

uint64_t sub_100017D44(uint64_t a1, uint64_t a2)
{
  void *v2;
  void *v3;

  v2 = *(void **)(a1 + 32);
  v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a2));
  objc_msgSend(v2, "addObject:", v3);

  return 1;
}

uint64_t sub_100017D8C(uint64_t a1, uint64_t a2)
{
  void *v2;
  void *v3;

  v2 = *(void **)(a1 + 32);
  v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a2));
  objc_msgSend(v2, "addObject:", v3);

  return 1;
}

void sub_100017DD4(uint64_t a1)
{
  id WeakRetained;
  id v3;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained && !*((_BYTE *)WeakRetained + 10) && *((_QWORD *)WeakRetained + 9) == *(_QWORD *)(a1 + 32))
  {
    v3 = WeakRetained;
    sub_10001730C((uint64_t)WeakRetained);
    WeakRetained = v3;
  }

}

uint64_t sub_100017E28(uint64_t a1, uint64_t a2)
{
  void *v3;
  void *v4;
  id v5;
  void *v6;

  v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a2));
  v4 = (void *)objc_claimAutoreleasedReturnValue(+[NWAddressEndpoint endpointWithHostname:port:](NWAddressEndpoint, "endpointWithHostname:port:", v3, CFSTR("0")));

  v5 = sub_10010A268(v4, 0, 0);
  v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  if (v6)
    NRTLVAddData(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), 42);

  return 1;
}

uint64_t sub_100017ECC(uint64_t a1, uint64_t a2)
{
  void *v3;
  void *v4;

  v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a2));
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "dataUsingEncoding:", 4));

  NRTLVAddData(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), 43);
  return 1;
}

dispatch_queue_t *sub_100017F3C(dispatch_queue_t *a1)
{
  dispatch_queue_t *v1;
  NSObject *v2;
  id v4;
  uint64_t v5;
  void *v6;
  id v7;
  void *v8;
  id v9;
  id v10;
  int IsLevelEnabled;
  id v12;
  id v13;
  NSObject *v14;
  _BOOL4 v15;
  dispatch_queue_t *v16;
  unint64_t v17;
  unint64_t v18;
  unsigned int v19;
  dispatch_queue_t *v20;
  NSObject *obj;
  id v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  _WORD v27[5];
  _QWORD v28[5];
  _QWORD v29[5];
  __int16 v30;
  unint64_t v31;
  unint64_t *v32;
  uint64_t v33;
  uint64_t (*v34)(uint64_t, uint64_t);
  void (*v35)(uint64_t);
  id v36;
  _BYTE v37[128];

  v1 = a1;
  if (!a1)
    return v1;
  dispatch_assert_queue_V2(a1[6]);
  if (*((_BYTE *)v1 + 10))
    return 0;
  if (*((_BYTE *)v1 + 8))
    sub_10001730C((uint64_t)v1);
  v2 = v1[10];
  if (!v2 || v2 != v1[4] || !v1[11])
  {
    memset((char *)v27 + 1, 0, 9);
    LOBYTE(v27[0]) = *((_BYTE *)v1 + 14);
    v27[1] = *(_WORD *)((char *)v1 + 15);
    *(_DWORD *)&v27[2] = bswap32(*((_DWORD *)v1 + 7));
    v22 = objc_alloc_init((Class)NSMutableData);
    v23 = 0u;
    v24 = 0u;
    v25 = 0u;
    v26 = 0u;
    v20 = v1;
    obj = v1[16];
    v4 = -[NSObject countByEnumeratingWithState:objects:count:](obj, "countByEnumeratingWithState:objects:count:", &v23, v37, 16);
    if (v4)
    {
      v5 = *(_QWORD *)v24;
      do
      {
        v6 = 0;
        do
        {
          if (*(_QWORD *)v24 != v5)
            objc_enumerationMutation(obj);
          v7 = *(id *)(*((_QWORD *)&v23 + 1) + 8 * (_QWORD)v6);
          if (v7)
          {
            v8 = v7;
            v31 = 0;
            v32 = &v31;
            v33 = 0x3032000000;
            v34 = sub_100016478;
            v35 = sub_100016488;
            v36 = objc_alloc_init((Class)NSMutableData);
            v30 = bswap32(nw_resolver_config_get_class(v8)) >> 16;
            NRTLVAdd(v32[5], 41, 2, &v30);
            v29[0] = _NSConcreteStackBlock;
            v29[1] = 3221225472;
            v29[2] = sub_100017E28;
            v29[3] = &unk_1001B6200;
            v29[4] = &v31;
            nw_resolver_config_enumerate_name_servers(v8, v29);
            v28[0] = _NSConcreteStackBlock;
            v28[1] = 3221225472;
            v28[2] = sub_100017ECC;
            v28[3] = &unk_1001B6200;
            v28[4] = &v31;
            nw_resolver_config_enumerate_search_domains(v8, v28);
            v9 = (id)v32[5];
            _Block_object_dispose(&v31, 8);

            if (v9)
              NRTLVAddData(v22, 1);
          }
          else
          {
            if (qword_1001E4528 != -1)
              dispatch_once(&qword_1001E4528, &stru_1001B6248);
            v10 = (id)qword_1001E4520;
            IsLevelEnabled = _NRLogIsLevelEnabled(v10, 17);

            if (IsLevelEnabled)
            {
              if (qword_1001E4528 != -1)
                dispatch_once(&qword_1001E4528, &stru_1001B6248);
              v12 = (id)qword_1001E4520;
              _NRLogWithArgs(v12, 17, "%s called with null config", "-[NRNetInfo copyResolverConfigData:]");

            }
            v9 = 0;
          }

          v6 = (char *)v6 + 1;
        }
        while (v4 != v6);
        v13 = -[NSObject countByEnumeratingWithState:objects:count:](obj, "countByEnumeratingWithState:objects:count:", &v23, v37, 16);
        v4 = v13;
      }
      while (v13);
    }

    v14 = v1[5];
    if (-[NSObject length](v14, "length"))
    {
      v15 = (unint64_t)-[NSObject length](v20[5], "length") < 0xFF;

      if (v15)
        NRTLVAddData(v22, 2);
    }
    else
    {

    }
    v16 = v20;
    v17 = (unint64_t)v20[14];
    if (v17)
    {
      v31 = bswap64(v17);
      NRTLVAdd(v22, 3, 8, &v31);
      v16 = v20;
    }
    v18 = (unint64_t)v16[15];
    if (v18)
    {
      v31 = bswap64(v18);
      NRTLVAdd(v22, 4, 8, &v31);
      v16 = v20;
    }
    v19 = *((_DWORD *)v16 + 5);
    if (*((_DWORD *)v16 + 6) != v19)
    {
      LODWORD(v31) = bswap32(v19);
      NRTLVAdd(v22, 5, 4, &v31);
      v16 = v20;
      *((_DWORD *)v20 + 6) = *((_DWORD *)v20 + 5);
    }
    if (*((_BYTE *)v16 + 17))
      NRTLVAdd(v22, 7, 0, 0);
    if (qword_1001E48D0 != -1)
      dispatch_once(&qword_1001E48D0, &stru_1001B7CC0);
    v31 = bswap64(qword_1001E48C8);
    NRTLVAdd(v22, 6, 8, &v31);
    v27[4] = bswap32(objc_msgSend(v22, "length")) >> 16;
    v1 = (dispatch_queue_t *)objc_msgSend(objc_alloc((Class)NSMutableData), "initWithBytes:length:", v27, 10);
    -[dispatch_queue_t appendData:](v1, "appendData:", v22);
    v20[10] = v20[4];
    objc_storeStrong((id *)v20 + 11, v1);

    return v1;
  }
  if (qword_1001E4528 != -1)
    dispatch_once(&qword_1001E4528, &stru_1001B6248);
  if (_NRLogIsLevelEnabled(qword_1001E4520, 2))
  {
    if (qword_1001E4528 != -1)
      dispatch_once(&qword_1001E4528, &stru_1001B6248);
    _NRLogWithArgs(qword_1001E4520, 2, "%s%.30s:%-4d using cached send data for generation %llu", "", "-[NRNetInfo copySendData]", 494, v1[4]);
  }
  return (dispatch_queue_t *)v1[11];
}

void sub_1000184F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  _Block_object_dispose(&a39, 8);
  _Unwind_Resume(a1);
}

id sub_100018DE8()
{
  if (qword_1001E4548 != -1)
    dispatch_once(&qword_1001E4548, &stru_1001B62D0);
  return (id)qword_1001E4540;
}

uint64_t sub_10001B82C(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), *(unsigned __int8 *)(a1 + 48), *(_QWORD *)(a1 + 32));
}

void sub_10001B880(id a1)
{
  NRBluetoothPairingManager *v1;
  void *v2;

  v1 = objc_alloc_init(NRBluetoothPairingManager);
  v2 = (void *)qword_1001E4530;
  qword_1001E4530 = (uint64_t)v1;

}

void sub_10001B8A8(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001E4540;
  qword_1001E4540 = (uint64_t)v1;

}

id sub_10001BDA4()
{
  if (qword_1001E4560 != -1)
    dispatch_once(&qword_1001E4560, &stru_1001B6390);
  return (id)qword_1001E4558;
}

void sub_10001BDE4(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001E4558;
  qword_1001E4558 = (uint64_t)v1;

}

void sub_10001C30C(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 72));
  _Unwind_Resume(a1);
}

void sub_10001C4D4(_BYTE *val, int a2)
{
  char v2;
  void *v4;
  NSObject *v5;
  _QWORD block[4];
  id v7;
  char v8;
  id location;

  if (val)
  {
    v2 = a2;
    if (val[8] != a2)
    {
      val[8] = a2;
      val[9] = (a2 - 1) < 3;
      objc_initWeak(&location, val);
      v4 = (void *)*((_QWORD *)val + 5);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10001C7E4;
      block[3] = &unk_1001B7358;
      v5 = v4;
      objc_copyWeak(&v7, &location);
      v8 = v2;
      dispatch_async(v5, block);

      objc_destroyWeak(&v7);
      objc_destroyWeak(&location);
    }
  }
}

void sub_10001C5A4(uint64_t a1, int a2, int a3)
{
  unsigned __int8 *WeakRetained;
  uint64_t v7;
  void *v8;
  int IsLevelEnabled;
  void *v10;
  void *v11;
  int v12;
  uint64_t v13;
  void *v14;
  int v15;
  void *v16;
  int v17;
  uint64_t v18;
  void *v19;
  void *v20;
  int v21;
  uint64_t v22;
  void *v23;
  unsigned __int8 *val;

  WeakRetained = (unsigned __int8 *)objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained && !WeakRetained[12] && *((_QWORD *)WeakRetained + 10) == *(_QWORD *)(a1 + 32))
  {
    val = WeakRetained;
    if (a3)
    {
      v8 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 6), v7);
      IsLevelEnabled = _NRLogIsLevelEnabled(v8, 16);

      WeakRetained = val;
      if (IsLevelEnabled)
      {
        v10 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)val + 6), v7);
        _NRLogWithArgs(v10, 16, "%s%.30s:%-4d discovery proxy client error: %d", "", "-[NRDNSProxyClient startDiscoveryProxyClient]_block_invoke", 227, a3);

        WeakRetained = val;
      }
    }
    switch(a2)
    {
      case -1:
        v16 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 6), v7);
        v17 = _NRLogIsLevelEnabled(v16, 0);

        if (v17)
        {
          v19 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)val + 6), v18);
          _NRLogWithArgs(v19, 0, "%s%.30s:%-4d discovery proxy client invalidated", "", "-[NRDNSProxyClient startDiscoveryProxyClient]_block_invoke", 241);

        }
        WeakRetained = val;
        if (!val[12])
        {
          v15 = 4;
LABEL_20:
          sub_10001C4D4(val, v15);
          WeakRetained = val;
        }
        break;
      case 2:
        v20 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 6), v7);
        v21 = _NRLogIsLevelEnabled(v20, 0);

        if (v21)
        {
          v23 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)val + 6), v22);
          _NRLogWithArgs(v23, 0, "%s%.30s:%-4d discovery proxy client interrupted", "", "-[NRDNSProxyClient startDiscoveryProxyClient]_block_invoke", 236);

        }
        WeakRetained = val;
        v15 = val[8];
        if (val[8])
          goto LABEL_20;
        break;
      case 1:
        v11 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 6), v7);
        v12 = _NRLogIsLevelEnabled(v11, 0);

        if (v12)
        {
          v14 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)val + 6), v13);
          _NRLogWithArgs(v14, 0, "%s%.30s:%-4d discovery proxy client started", "", "-[NRDNSProxyClient startDiscoveryProxyClient]_block_invoke", 232);

        }
        v15 = 2;
        goto LABEL_20;
    }
  }

}

void sub_10001C7E4(uint64_t a1)
{
  id *WeakRetained;
  id v3;
  id *v4;

  WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained && *((unsigned __int8 *)WeakRetained + 8) == *(unsigned __int8 *)(a1 + 40))
  {
    v4 = WeakRetained;
    v3 = objc_loadWeakRetained(WeakRetained + 8);
    objc_msgSend(v3, "didUpdateDNSProxyState:state:", v4, *(unsigned __int8 *)(a1 + 40));

    WeakRetained = v4;
  }

}

void sub_10001CAB4(uint64_t a1)
{
  void *v2;
  char *v3;
  _QWORD *v4;
  id v5;
  id v6;
  uint64_t v7;
  void *i;
  uint64_t v9;
  void *v10;
  id v11;
  id v12;
  uint64_t v13;
  void *v14;
  char IsLevelEnabled;
  id v16;
  uint64_t v17;
  void *v18;
  _QWORD v19[4];
  id v20;
  _QWORD *v21;
  id v22;
  id location;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  int v28;
  _BYTE v29[128];

  if (a1)
  {
    v28 = -1;
    v2 = (void *)mrc_dns_proxy_parameters_create(&v28);
    if (v28)
    {
      if (qword_1001E4560 != -1)
        dispatch_once(&qword_1001E4560, &stru_1001B6390);
      if (_NRLogIsLevelEnabled(qword_1001E4558, 17))
      {
        if (qword_1001E4560 != -1)
          dispatch_once(&qword_1001E4560, &stru_1001B6390);
        _NRLogWithArgs(qword_1001E4558, 17, "mrc_dns_proxy_parameters_create failed");
      }
      sub_10001C4D4((_BYTE *)a1, 4);
    }
    else
    {
      v3 = sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(a1 + 48));
      v4 = sub_1001331E8(v3, CFSTR("53"));
      v26 = 0u;
      v27 = 0u;
      v24 = 0u;
      v25 = 0u;
      v5 = *(id *)(a1 + 72);
      v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v24, v29, 16);
      if (v6)
      {
        v7 = *(_QWORD *)v25;
        do
        {
          for (i = 0; i != v6; i = (char *)i + 1)
          {
            if (*(_QWORD *)v25 != v7)
              objc_enumerationMutation(v5);
            mrc_dns_proxy_parameters_add_input_interface(v2, objc_msgSend(*(id *)(*((_QWORD *)&v24 + 1) + 8 * (_QWORD)i), "unsignedIntValue"));
          }
          v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v24, v29, 16);
        }
        while (v6);
      }

      mrc_dns_proxy_parameters_set_output_interface(v2, 0);
      v9 = mrc_dns_proxy_create(v2, &v28);
      v10 = (void *)v9;
      if (v9)
      {
        mrc_dns_proxy_set_queue(v9, *(_QWORD *)(a1 + 40));
        objc_initWeak(&location, (id)a1);
        v19[0] = _NSConcreteStackBlock;
        v19[1] = 3221225472;
        v19[2] = sub_10001CE9C;
        v19[3] = &unk_1001B6320;
        objc_copyWeak(&v22, &location);
        v11 = v10;
        v20 = v11;
        v21 = v4;
        mrc_dns_proxy_set_event_handler(v11, v19);
        mrc_dns_proxy_activate(v11);
        v12 = *(id *)(a1 + 48);
        v14 = (void *)_NRCopyLogObjectForNRUUID(v12, v13);
        IsLevelEnabled = _NRLogIsLevelEnabled(v14, 0);

        if ((IsLevelEnabled & 1) != 0)
        {
          v16 = *(id *)(a1 + 48);
          v18 = (void *)_NRCopyLogObjectForNRUUID(v16, v17);
          _NRLogWithArgs(v18, 0, "%s%.30s:%-4d dns proxy activated", "", "-[NRDNSProxyServer startDNS53Server]", 369);

        }
        objc_storeStrong((id *)(a1 + 80), v10);
        sub_10001C4D4((_BYTE *)a1, 1);

        objc_destroyWeak(&v22);
        objc_destroyWeak(&location);
      }
      else
      {
        if (qword_1001E4560 != -1)
          dispatch_once(&qword_1001E4560, &stru_1001B6390);
        if (_NRLogIsLevelEnabled(qword_1001E4558, 17))
        {
          if (qword_1001E4560 != -1)
            dispatch_once(&qword_1001E4560, &stru_1001B6390);
          _NRLogWithArgs(qword_1001E4558, 17, "mrc_dns_proxy_create failed");
        }
        sub_10001C4D4((_BYTE *)a1, 4);
      }

    }
  }
}

void sub_10001CE74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  id *v20;

  objc_destroyWeak(v20);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10001CE9C(uint64_t a1, int a2, int a3)
{
  _QWORD *WeakRetained;
  _QWORD *v7;
  void *v8;
  int IsLevelEnabled;
  void *v10;
  void *v11;
  int v12;
  uint64_t v13;
  void *v14;
  id v15;
  void *v16;
  int v17;
  void *v18;
  int v19;
  uint64_t v20;
  void *v21;
  void *v22;
  int v23;
  uint64_t v24;
  _QWORD *val;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  v7 = WeakRetained;
  if (WeakRetained && !*((_BYTE *)WeakRetained + 12) && WeakRetained[10] == *(_QWORD *)(a1 + 32))
  {
    val = WeakRetained;
    if (a3)
    {
      v8 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[6], WeakRetained);
      IsLevelEnabled = _NRLogIsLevelEnabled(v8, 16);

      v7 = val;
      if (IsLevelEnabled)
      {
        v10 = (void *)_NRCopyLogObjectForNRUUID(val[6], val);
        _NRLogWithArgs(v10, 16, "%s%.30s:%-4d dns proxy error: %d", "", "-[NRDNSProxyServer startDNS53Server]_block_invoke", 341, a3);

        v7 = val;
      }
    }
    switch(a2)
    {
      case -1:
        v18 = (void *)_NRCopyLogObjectForNRUUID(v7[6], v7);
        v19 = _NRLogIsLevelEnabled(v18, 0);

        if (v19)
        {
          v21 = (void *)_NRCopyLogObjectForNRUUID(val[6], v20);
          _NRLogWithArgs(v21, 0, "%s%.30s:%-4d dns proxy invalidated", "", "-[NRDNSProxyServer startDNS53Server]_block_invoke", 355);

        }
        v7 = val;
        if (!*((_BYTE *)val + 12))
        {
          v17 = 4;
LABEL_22:
          sub_10001C4D4(v7, v17);
          v7 = val;
        }
        break;
      case 2:
        v22 = (void *)_NRCopyLogObjectForNRUUID(v7[6], v7);
        v23 = _NRLogIsLevelEnabled(v22, 0);

        if (!v23)
        {
          v17 = 4;
          goto LABEL_21;
        }
        v16 = (void *)_NRCopyLogObjectForNRUUID(val[6], v24);
        _NRLogWithArgs(v16, 0, "%s%.30s:%-4d dns proxy interrupted", "", "-[NRDNSProxyServer startDNS53Server]_block_invoke", 351);
        v17 = 4;
LABEL_19:

LABEL_21:
        v7 = val;
        goto LABEL_22;
      case 1:
        v11 = (void *)_NRCopyLogObjectForNRUUID(v7[6], v7);
        v12 = _NRLogIsLevelEnabled(v11, 0);

        if (v12)
        {
          v14 = (void *)_NRCopyLogObjectForNRUUID(val[6], v13);
          _NRLogWithArgs(v14, 0, "%s%.30s:%-4d dns proxy started", "", "-[NRDNSProxyServer startDNS53Server]_block_invoke", 346);

        }
        v15 = *(id *)(a1 + 40);
        v16 = (void *)val[3];
        val[3] = v15;
        v17 = 2;
        goto LABEL_19;
    }
  }

}

void sub_10001D3B8(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  int IsLevelEnabled;
  uint64_t v5;
  void *v6;
  unsigned __int8 v7;
  uint64_t v8;
  void *v9;
  int v10;
  uint64_t v11;
  void *v12;
  void *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  id v19;
  id v20;
  id v21;
  uint64_t v22;
  uint64_t v23;
  void *i;
  void *v25;
  uint64_t v26;
  void *v27;
  int v28;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  void *v33;
  int v34;
  uint64_t v35;
  void *v36;
  void *v37;
  id v38;
  void *v39;
  void *v40;
  id v41;
  int v42;
  id v43;
  uint64_t v44;
  char *v45;
  int *v46;
  uint64_t v47;
  id v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  _BYTE v53[128];

  if (a1)
  {
    *(_DWORD *)(a1 + 16) = 1;
    sub_10001C4D4((_BYTE *)a1, 1);
    v3 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), v2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v3, 0);

    if (IsLevelEnabled)
    {
      v6 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), v5);
      _NRLogWithArgs(v6, 0, "%s%.30s:%-4d activating discovery proxy", "", "-[NRDiscoveryProxyServer startDiscoveryProxyServer]", 629);

    }
    v7 = objc_msgSend(*(id *)(a1 + 96), "count");
    if (!v7)
    {
      v13 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), v8);
      v14 = _NRLogIsLevelEnabled(v13, 16);

      if (v14)
      {
        v12 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), v15);
        _NRLogWithArgs(v12, 16, "%s%.30s:%-4d no allowed interfaces for discovery proxy");
        goto LABEL_10;
      }
LABEL_11:
      sub_10001C4D4((_BYTE *)a1, 4);
      return;
    }
    if (v7 >= 9u)
    {
      v9 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), v8);
      v10 = _NRLogIsLevelEnabled(v9, 16);

      if (v10)
      {
        v12 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), v11);
        _NRLogWithArgs(v12, 16, "%s%.30s:%-4d unexpected number of interfaces for discovery proxy %u");
LABEL_10:

        goto LABEL_11;
      }
      goto LABEL_11;
    }
    v16 = v7;
    v17 = malloc_type_calloc(v7, 8uLL, 0xF1748037uLL);
    if (!v17)
    {
      v41 = sub_10001BDA4();
      v42 = _NRLogIsLevelEnabled(v41, 16);

      if (v42)
      {
        v43 = sub_10001BDA4();
        _NRLogWithArgs(v43, 16, "%s%.30s:%-4d ABORTING: strict_calloc(%zu, %zu) failed", "", "strict_calloc", 108, v16, 8uLL);

      }
      v44 = _os_log_pack_size(32);
      v45 = (char *)&v49 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
      v46 = __error();
      v47 = _os_log_pack_fill(v45, v44, *v46, &_mh_execute_header, "%{public}s strict_calloc(%zu, %zu) failed");
      *(_DWORD *)v47 = 136446722;
      *(_QWORD *)(v47 + 4) = "strict_calloc";
      *(_WORD *)(v47 + 12) = 2048;
      *(_QWORD *)(v47 + 14) = v16;
      *(_WORD *)(v47 + 22) = 2048;
      *(_QWORD *)(v47 + 24) = 8;
      v48 = sub_10001BDA4();
      _NRLogAbortWithPack(v48, v45);
    }
    v18 = v17;
    v51 = 0u;
    v52 = 0u;
    v50 = 0u;
    v49 = 0u;
    v19 = *(id *)(a1 + 96);
    v20 = objc_msgSend(v19, "countByEnumeratingWithState:objects:count:", &v49, v53, 16);
    if (v20)
    {
      v21 = v20;
      v22 = 0;
      v23 = *(_QWORD *)v50;
      do
      {
        for (i = 0; i != v21; i = (char *)i + 1)
        {
          if (*(_QWORD *)v50 != v23)
            objc_enumerationMutation(v19);
          v25 = *(void **)(*((_QWORD *)&v49 + 1) + 8 * (_QWORD)i);
          if (objc_msgSend(v25, "length", (_QWORD)v49))
          {
            v18[(int)v22] = objc_msgSend(v25, "UTF8String");
            v22 = (v22 + 1);
          }
          else
          {
            v27 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), v26);
            v28 = _NRLogIsLevelEnabled(v27, 17);

            if (v28)
            {
              v30 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), v29);
              _NRLogWithArgs(v30, 17, "invalid interface name for discovery proxy");

            }
          }
        }
        v21 = objc_msgSend(v19, "countByEnumeratingWithState:objects:count:", &v49, v53, 16);
      }
      while (v21);

      if ((_DWORD)v22)
      {
        v32 = advertising_proxy_enable_with_interfaces(a1 + 80, *(_QWORD *)(a1 + 40), sub_10001D8FC, v18, v22);
        if ((_DWORD)v32)
        {
          sub_10001DCB8(a1, v32);
        }
        else
        {
          v37 = (void *)qword_1001E4550;
          if (!qword_1001E4550)
          {
            v38 = objc_alloc_init((Class)NSMutableDictionary);
            v39 = (void *)qword_1001E4550;
            qword_1001E4550 = (uint64_t)v38;

            v37 = (void *)qword_1001E4550;
          }
          v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", *(_QWORD *)(a1 + 80)));
          objc_msgSend(v37, "setObject:forKeyedSubscript:", a1, v40);

        }
LABEL_31:
        free(v18);
        return;
      }
    }
    else
    {

    }
    v33 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), v31);
    v34 = _NRLogIsLevelEnabled(v33, 16);

    if (v34)
    {
      v36 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), v35);
      _NRLogWithArgs(v36, 16, "%s%.30s:%-4d no valid interfaces for discovery proxy", "", "-[NRDiscoveryProxyServer startDiscoveryProxyServer]", 654);

    }
    sub_10001C4D4((_BYTE *)a1, 4);
    goto LABEL_31;
  }
}

void sub_10001D8FC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v4;
  void *v5;
  uint64_t v6;
  void *v7;
  int IsLevelEnabled;
  uint64_t v9;
  void *v10;
  NSObject *v11;
  uint32_t v12;
  id v13;
  char v14;
  id v15;
  id v16;
  uint64_t v17;
  void *v18;
  int v19;
  uint64_t v20;
  void *v21;
  id v22;
  int v23;
  id v24;
  int v25;
  id v26;
  id val;
  _QWORD handler[4];
  id v29;
  id location;

  if (a1)
  {
    v4 = (void *)qword_1001E4550;
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", a1));
    val = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "objectForKeyedSubscript:", v5));

    if (val)
    {
      if ((_DWORD)a3)
      {
        sub_10001DCB8((uint64_t)val, a3);
LABEL_5:

        return;
      }
      v7 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)val + 6), v6);
      IsLevelEnabled = _NRLogIsLevelEnabled(v7, 0);

      if (IsLevelEnabled)
      {
        v10 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)val + 6), v9);
        _NRLogWithArgs(v10, 0, "%s%.30s:%-4d activated discovery proxy", "", "discoveryProxyCallback", 616);

      }
      sub_10001DD58((uint64_t)val);
      if (*((_DWORD *)val + 19) != -1)
      {

        return;
      }
      objc_initWeak(&location, val);
      v11 = *((id *)val + 5);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 3221225472;
      handler[2] = sub_10001DF98;
      handler[3] = &unk_1001B8990;
      objc_copyWeak(&v29, &location);
      v12 = notify_register_dispatch("com.apple.srp-mdns-proxy.tls-key-update", (int *)val + 19, v11, handler);

      if (v12)
      {
        if (qword_1001E4560 != -1)
          dispatch_once(&qword_1001E4560, &stru_1001B6390);
        v13 = (id)qword_1001E4558;
        v14 = _NRLogIsLevelEnabled(v13, 17);

        if ((v14 & 1) == 0)
          goto LABEL_20;
        if (qword_1001E4560 != -1)
          dispatch_once(&qword_1001E4560, &stru_1001B6390);
        v15 = (id)qword_1001E4558;
        _NRLogWithArgs(v15, 17, "notify_register_dispatch(%s, %d) failed: %u", "com.apple.srp-mdns-proxy.tls-key-update", *((_DWORD *)val + 19), v12);
      }
      else
      {
        v16 = *((id *)val + 6);
        v18 = (void *)_NRCopyLogObjectForNRUUID(v16, v17);
        v19 = _NRLogIsLevelEnabled(v18, 0);

        if (!v19)
        {
LABEL_20:
          objc_destroyWeak(&v29);
          objc_destroyWeak(&location);
          goto LABEL_5;
        }
        v15 = *((id *)val + 6);
        v21 = (void *)_NRCopyLogObjectForNRUUID(v15, v20);
        _NRLogWithArgs(v21, 0, "%s%.30s:%-4d monitoring server certificate changes (%d)", "", "-[NRDiscoveryProxyServer watchForServerCertificateChanges]", 603, *((_DWORD *)val + 19));

      }
      goto LABEL_20;
    }
    v24 = sub_10001BDA4();
    v25 = _NRLogIsLevelEnabled(v24, 17);

    if (v25)
    {
      v26 = sub_10001BDA4();
      _NRLogWithArgs(v26, 17, "%s called with null server", "discoveryProxyCallback");

    }
  }
  else
  {
    v22 = sub_10001BDA4();
    v23 = _NRLogIsLevelEnabled(v22, 17);

    if (v23)
    {
      val = sub_10001BDA4();
      _NRLogWithArgs(val, 17, "%s called with null ref", "discoveryProxyCallback");
      goto LABEL_5;
    }
  }
}

void sub_10001DC98(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 72));
  _Unwind_Resume(a1);
}

void sub_10001DCB8(uint64_t a1, uint64_t a2)
{
  int v2;
  void *v4;
  int IsLevelEnabled;
  uint64_t v6;
  void *v7;
  void *v8;

  v2 = a2;
  v4 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), a2);
  IsLevelEnabled = _NRLogIsLevelEnabled(v4, 16);

  if (IsLevelEnabled)
  {
    v7 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), v6);
    _NRLogWithArgs(v7, 16, "%s%.30s:%-4d SRP proxy failed (error:%d)", "", "-[NRDiscoveryProxyServer handleDiscoverProxyServerFailed:]", 551, v2);

  }
  v8 = *(void **)(a1 + 32);
  *(_QWORD *)(a1 + 32) = 0;

  sub_10001C4D4((_BYTE *)a1, 4);
}

void sub_10001DD58(uint64_t a1)
{
  char *v2;
  _QWORD *v3;
  void *v4;
  _QWORD *v5;
  NSObject *v6;
  void *v7;
  NSObject *v8;
  _QWORD v9[2];
  void (*v10)(uint64_t, void *);
  void *v11;
  id v12;
  id location;
  _QWORD handler[4];
  _QWORD *v15;
  uint64_t *v16;
  id v17;
  id from;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t (*v22)(uint64_t, uint64_t);
  void (*v23)(uint64_t);
  CFDataRef v24;

  v2 = sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(a1 + 48));
  v3 = sub_1001331E8(v2, CFSTR("853"));
  v4 = *(void **)(a1 + 24);
  *(_QWORD *)(a1 + 24) = v3;

  objc_initWeak(&location, (id)a1);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  v10 = sub_10001E008;
  v11 = &unk_1001B6370;
  objc_copyWeak(&v12, &location);
  v5 = v9;
  v19 = 0;
  v20 = &v19;
  v21 = 0x3032000000;
  v22 = sub_10001E098;
  v23 = sub_10001E0A8;
  v24 = sub_10001E0B0(a1);
  if (v20[5])
  {
    ((void (*)(_QWORD *))v10)(v5);
  }
  else
  {
    objc_initWeak(&from, (id)a1);
    v6 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, *(dispatch_queue_t *)(a1 + 40));
    dispatch_source_set_timer(v6, 0, 0x2540BE400uLL, 0x3B9ACA00uLL);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472;
    handler[2] = sub_10001E5FC;
    handler[3] = &unk_1001B6348;
    objc_copyWeak(&v17, &from);
    v16 = &v19;
    v15 = v5;
    dispatch_source_set_event_handler(v6, handler);
    dispatch_activate(v6);
    v7 = *(void **)(a1 + 88);
    *(_QWORD *)(a1 + 88) = v6;
    v8 = v6;

    objc_destroyWeak(&v17);
    objc_destroyWeak(&from);
  }
  _Block_object_dispose(&v19, 8);

  objc_destroyWeak(&v12);
  objc_destroyWeak(&location);

}

void sub_10001DF68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  id *v23;

  _Block_object_dispose(&a23, 8);
  objc_destroyWeak(v23);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10001DF98(uint64_t a1, int a2)
{
  _BYTE *WeakRetained;
  _BYTE *v4;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained && !WeakRetained[12] && *((_DWORD *)WeakRetained + 19) == a2 && WeakRetained[8] == 2)
  {
    v4 = WeakRetained;
    sub_10001C4D4(WeakRetained, 3);
    sub_10001DD58((uint64_t)v4);
    WeakRetained = v4;
  }

}

void sub_10001E008(uint64_t a1, void *a2)
{
  unsigned __int8 *WeakRetained;
  _BYTE *v5;
  id v6;

  v6 = a2;
  WeakRetained = (unsigned __int8 *)objc_loadWeakRetained((id *)(a1 + 32));
  v5 = WeakRetained;
  if (WeakRetained && (WeakRetained[8] | 2) == 3 && !WeakRetained[12])
  {
    objc_storeStrong((id *)WeakRetained + 4, a2);
    if (v6)
      sub_10001C4D4(v5, 2);
    else
      sub_10001DCB8((uint64_t)v5, 4294901759);
  }

}

uint64_t sub_10001E098(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_10001E0A8(uint64_t a1)
{

}

CFDataRef sub_10001E0B0(uint64_t a1)
{
  const __CFDictionary *v2;
  uint64_t v3;
  const char *v4;
  CFTypeID v5;
  uint64_t v6;
  uint64_t v7;
  const void *ValueAtIndex;
  CFTypeID v9;
  uint64_t v10;
  void *Value;
  uint64_t v12;
  void *v13;
  CFTypeID v14;
  uint64_t v15;
  double Current;
  uint64_t v17;
  CFDataRef v18;
  uint64_t v19;
  void *v20;
  int v21;
  uint64_t v22;
  void *v23;
  void *v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  const char *v29;
  void *v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  const char *v34;
  uint64_t v35;
  void *v36;
  int IsLevelEnabled;
  uint64_t v38;
  uint64_t v39;
  void *v40;
  int v41;
  uint64_t v42;
  void *v43;
  int v44;
  uint64_t v45;
  CFTypeRef v46;
  void *v48;
  int v49;
  id v50;
  uint64_t v51;
  CFTypeID v52;
  CFTypeID v53;
  void *v54;
  int v55;
  uint64_t v56;
  CFTypeID v57;
  __CFString *v58;
  void *v59;
  int v60;
  uint64_t v61;
  void *v62;
  int v63;
  uint64_t v64;
  const char *v65;
  const char *v66;
  const char *v67;
  uint64_t v68;
  CFTypeRef result;
  _QWORD v70[6];
  _QWORD v71[6];

  v70[0] = kSecClass;
  v70[1] = kSecMatchLimit;
  v71[0] = kSecClassCertificate;
  v71[1] = kSecMatchLimitAll;
  v70[2] = kSecAttrAccessGroup;
  v70[3] = kSecAttrSynchronizable;
  v71[2] = CFSTR("com.apple.srp-mdns-proxy");
  v71[3] = &__kCFBooleanTrue;
  v70[4] = kSecReturnAttributes;
  v70[5] = kSecReturnRef;
  v71[4] = &__kCFBooleanTrue;
  v71[5] = &__kCFBooleanTrue;
  v2 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v71, v70, 6));
  result = 0;
  v4 = (const char *)SecItemCopyMatching(v2, &result);
  if ((_DWORD)v4 || !result)
  {
    if (result)
    {
      CFRelease(result);
      result = 0;
    }
    if ((_DWORD)v4 == -25308)
    {
      v36 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), v3);
      IsLevelEnabled = _NRLogIsLevelEnabled(v36, 16);

      if (IsLevelEnabled)
      {
        v27 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), v38);
        v28 = (void *)v27;
        v68 = 463;
        v66 = "";
        v67 = "-[NRDiscoveryProxyServer copyServerCertificateData]";
        v29 = "%s%.30s:%-4d Failed to retrieve SRP Pk: keychain locked";
        goto LABEL_22;
      }
    }
    else if ((_DWORD)v4 == -25300)
    {
      v24 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), v3);
      v25 = _NRLogIsLevelEnabled(v24, 16);

      if (v25)
      {
        v27 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), v26);
        v28 = (void *)v27;
        v68 = 461;
        v66 = "";
        v67 = "-[NRDiscoveryProxyServer copyServerCertificateData]";
        v29 = "%s%.30s:%-4d Failed to retrieve SRP Pk: not found";
LABEL_22:
        v39 = 16;
LABEL_25:
        _NRLogWithArgs(v27, v39, v29, v66, v67, v68);

        v18 = 0;
        goto LABEL_34;
      }
    }
    else
    {
      v40 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), v3);
      v41 = _NRLogIsLevelEnabled(v40, 17);

      if (v41)
      {
        v27 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), v42);
        v28 = (void *)v27;
        v66 = v4;
        v29 = "Failed to retrieve SRP Pk: %d";
        v39 = 17;
        goto LABEL_25;
      }
    }
    v18 = 0;
    goto LABEL_34;
  }
  v5 = CFGetTypeID(result);
  if (v5 != CFArrayGetTypeID())
  {
    v48 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), v6);
    v49 = _NRLogIsLevelEnabled(v48, 17);

    if (!v49)
      goto LABEL_45;
    v50 = *(id *)(a1 + 48);
    v23 = (void *)_NRCopyLogObjectForNRUUID(v50, v51);
    v52 = CFGetTypeID(result);

    v53 = v52;
LABEL_43:
    v58 = (__CFString *)CFCopyTypeIDDescription(v53);
    _NRLogWithArgs(v23, 17, "Read keychain for SRP Pk with bad class %@", v58);
    goto LABEL_44;
  }
  if (!CFArrayGetCount((CFArrayRef)result))
  {
    v30 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), v7);
    v31 = _NRLogIsLevelEnabled(v30, 16);

    if (!v31)
      goto LABEL_45;
    v33 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), v32);
    v23 = (void *)v33;
    v68 = 479;
    v65 = "";
    v67 = "-[NRDiscoveryProxyServer copyServerCertificateData]";
    v34 = "%s%.30s:%-4d No SRP Pk(s)";
    goto LABEL_19;
  }
  ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)result, 0);
  v9 = CFGetTypeID(ValueAtIndex);
  if (v9 != CFDictionaryGetTypeID())
  {
    v54 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), v10);
    v55 = _NRLogIsLevelEnabled(v54, 17);

    if (!v55)
      goto LABEL_45;
    v23 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), v56);
    v57 = CFGetTypeID(ValueAtIndex);
    v58 = (__CFString *)CFCopyTypeIDDescription(v57);
    _NRLogWithArgs(v23, 17, "Read keychain for SRP Pk attributes with bad class %@", v58);
LABEL_44:

    goto LABEL_30;
  }
  Value = (void *)CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, kSecValueRef);
  if (!Value)
  {
    v59 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), v12);
    v60 = _NRLogIsLevelEnabled(v59, 16);

    if (!v60)
      goto LABEL_45;
    v33 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), v61);
    v23 = (void *)v33;
    v68 = 492;
    v65 = "";
    v67 = "-[NRDiscoveryProxyServer copyServerCertificateData]";
    v34 = "%s%.30s:%-4d No SRP certificate: not found";
LABEL_19:
    v35 = 16;
LABEL_29:
    _NRLogWithArgs(v33, v35, v34, v65, v67, v68);
LABEL_30:
    v18 = 0;
    goto LABEL_31;
  }
  v13 = Value;
  v14 = CFGetTypeID(Value);
  if (v14 != SecCertificateGetTypeID())
  {
    v62 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), v15);
    v63 = _NRLogIsLevelEnabled(v62, 17);

    if (!v63)
      goto LABEL_45;
    v23 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), v64);
    v53 = CFGetTypeID(v13);
    goto LABEL_43;
  }
  Current = CFAbsoluteTimeGetCurrent();
  if ((SecCertificateIsValid(v13, Current) & 1) == 0)
  {
    v43 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), v17);
    v44 = _NRLogIsLevelEnabled(v43, 17);

    if (v44)
    {
      v33 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), v45);
      v23 = (void *)v33;
      v34 = "Read keychain for invalid SRP Pk";
      v35 = 17;
      goto LABEL_29;
    }
LABEL_45:
    v18 = 0;
    v46 = result;
    if (!result)
      goto LABEL_34;
    goto LABEL_33;
  }
  v18 = SecCertificateCopyData((SecCertificateRef)v13);
  v20 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), v19);
  v21 = _NRLogIsLevelEnabled(v20, 0);

  if (!v21)
    goto LABEL_32;
  v23 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 48), v22);
  _NRLogWithArgs(v23, 0, "%s%.30s:%-4d Fetched server certificate of size %u bytes", "", "-[NRDiscoveryProxyServer copyServerCertificateData]", 508, -[__CFData length](v18, "length"));
LABEL_31:

LABEL_32:
  v46 = result;
  if (result)
  {
LABEL_33:
    CFRelease(v46);
    result = 0;
  }
LABEL_34:

  return v18;
}

void sub_10001E5FC(uint64_t a1)
{
  dispatch_source_t *WeakRetained;
  CFDataRef v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  dispatch_source_t v7;
  void *v8;
  int IsLevelEnabled;
  uint64_t v10;
  void *v11;
  dispatch_source_t *v12;

  WeakRetained = (dispatch_source_t *)objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained && !*((_BYTE *)WeakRetained + 12))
  {
    ++*((_BYTE *)WeakRetained + 72);
    v12 = WeakRetained;
    v3 = sub_10001E0B0((uint64_t)WeakRetained);
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v5 = *(void **)(v4 + 40);
    *(_QWORD *)(v4 + 40) = v3;

    if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40) || *((unsigned __int8 *)v12 + 72) >= 5u)
    {
      dispatch_source_cancel(v12[11]);
      v7 = v12[11];
      v12[11] = 0;

      if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40))
        *((_BYTE *)v12 + 72) = 0;
      (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
    }
    else
    {
      v8 = (void *)_NRCopyLogObjectForNRUUID(v12[6], v6);
      IsLevelEnabled = _NRLogIsLevelEnabled(v8, 1);

      WeakRetained = v12;
      if (!IsLevelEnabled)
        goto LABEL_9;
      v11 = (void *)_NRCopyLogObjectForNRUUID(v12[6], v10);
      _NRLogWithArgs(v11, 1, "%s%.30s:%-4d failed to get SRP server certificate, retrying", "", "-[NRDiscoveryProxyServer fetchServerCertificateWithCompletion:]_block_invoke", 542);

    }
    WeakRetained = v12;
  }
LABEL_9:

}

id *sub_10001E760(id *a1, void *a2, void *a3, void *a4, void *a5, void *a6, int a7, char a8)
{
  id v16;
  id v17;
  id v18;
  id v19;
  id v20;
  id *v21;
  id v23;
  int IsLevelEnabled;
  id v25;
  objc_super v26;

  v16 = a2;
  v17 = a3;
  v18 = a4;
  v19 = a5;
  v20 = a6;
  if (a1)
  {
    v26.receiver = a1;
    v26.super_class = (Class)NRDNSProxyClient;
    v21 = (id *)objc_msgSendSuper2(&v26, "initWithQueue:nrUUID:delegate:", v17, v18, v19);
    if (v21)
    {
      a1 = v21;
      objc_storeStrong(v21 + 3, a2);
      objc_storeStrong(a1 + 4, a6);
      *((_DWORD *)a1 + 4) = a7;
      *((_BYTE *)a1 + 13) = a8;
    }
    else
    {
      v23 = sub_10001BDA4();
      IsLevelEnabled = _NRLogIsLevelEnabled(v23, 17);

      if (IsLevelEnabled)
      {
        v25 = sub_10001BDA4();
        _NRLogWithArgs(v25, 17, "%s called with null self", "-[NRDNSProxyClient initWithServerEndpoint:queue:nrUUID:delegate:serverCertificateData:resolverProtocol:isDiscoveryProxy:]");

      }
      a1 = 0;
    }
  }

  return a1;
}

id *sub_10001E9E8(id *a1, void *a2, char a3)
{
  __objc2_prot *v3;
  id v7;
  void *v8;
  id *v9;
  id v10;
  id v11;
  id v12;
  id v13;
  id v14;
  id v15;
  char *v16;
  CFStringRef NetworkInterfaceEntity;
  id v18;
  CFStringRef v19;
  id v20;
  CFStringRef v21;
  id v22;
  id *v23;
  id v25;
  int IsLevelEnabled;
  id v27;
  int v28;
  id v29;
  int *v30;
  uint64_t v31;
  id v32;
  uint64_t v33;
  objc_super v34;

  v7 = a2;
  v8 = v7;
  if (!a1)
    goto LABEL_26;
  if (!v7)
  {
    v25 = sub_10001EE18();
    IsLevelEnabled = _NRLogIsLevelEnabled(v25, 17);

    if (!IsLevelEnabled)
      goto LABEL_26;
    v16 = (char *)sub_10001EE18();
    _NRLogWithArgs(v16, 17, "%s called with null interfaceName");
LABEL_25:

LABEL_26:
    v23 = 0;
    goto LABEL_27;
  }
  v34.receiver = a1;
  v34.super_class = (Class)NRSCDInterfaceConfig;
  v9 = (id *)objc_msgSendSuper2(&v34, "init");
  if (!v9)
  {
    v27 = sub_10001EE18();
    v28 = _NRLogIsLevelEnabled(v27, 16);

    v16 = "-[NRSCDInterfaceConfig initWithInterfaceName:allowsLinkLocalAddresses:]";
    if (v28)
    {
      v29 = sub_10001EE18();
      _NRLogWithArgs(v29, 16, "%s%.30s:%-4d ABORTING: [super init] failed", "", "-[NRSCDInterfaceConfig initWithInterfaceName:allowsLinkLocalAddresses:]", 37);

    }
    v8 = (void *)_os_log_pack_size(12);
    a1 = (id *)((char *)&v33 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0));
    v30 = __error();
    v31 = _os_log_pack_fill(a1, v8, *v30, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)v31 = 136446210;
    *(_QWORD *)(v31 + 4) = "-[NRSCDInterfaceConfig initWithInterfaceName:allowsLinkLocalAddresses:]";
    v32 = sub_10001EE18();
    _NRLogAbortWithPack(v32, a1);
LABEL_33:
    dispatch_once(&qword_1001E4570, &stru_1001B63D8);
LABEL_9:
    if (_NRLogIsLevelEnabled(qword_1001E4568, 17))
    {
      if (v3[19].inst_meths != (__objc2_meth_list *)-1)
        dispatch_once(&qword_1001E4570, &stru_1001B63D8);
      _NRLogWithArgs(qword_1001E4568, 17, "SCDynamicStoreKeyCreateNetworkInterfaceEntity(%s/IPv4) failed");
    }
    goto LABEL_25;
  }
  a1 = v9;
  objc_storeStrong(v9 + 3, a2);
  v10 = objc_alloc_init((Class)NSMutableArray);
  v11 = a1[7];
  a1[7] = v10;

  v12 = objc_alloc_init((Class)NSMutableArray);
  v13 = a1[8];
  a1[8] = v12;

  v14 = objc_alloc_init((Class)NSMutableDictionary);
  v15 = a1[9];
  a1[9] = v14;

  *((_BYTE *)a1 + 8) = a3;
  sub_10001EE58((uint64_t)a1);
  v16 = (char *)a1[3];
  objc_msgSend(v16, "UTF8String");
  NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity(0, kSCDynamicStoreDomainState, (CFStringRef)a1[3], kSCEntNetIPv4);
  v18 = a1[4];
  a1[4] = (id)NetworkInterfaceEntity;

  if (!a1[4])
  {
    v3 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
    if (qword_1001E4570 == -1)
      goto LABEL_9;
    goto LABEL_33;
  }
  v19 = SCDynamicStoreKeyCreateNetworkInterfaceEntity(0, kSCDynamicStoreDomainState, (CFStringRef)a1[3], kSCEntNetIPv6);
  v20 = a1[5];
  a1[5] = (id)v19;

  if (!a1[5])
  {
    if (qword_1001E4570 != -1)
      dispatch_once(&qword_1001E4570, &stru_1001B63D8);
    if (_NRLogIsLevelEnabled(qword_1001E4568, 17))
    {
      if (qword_1001E4570 != -1)
        dispatch_once(&qword_1001E4570, &stru_1001B63D8);
      _NRLogWithArgs(qword_1001E4568, 17, "SCDynamicStoreKeyCreateNetworkInterfaceEntity(%s/IPv6) failed");
    }
    goto LABEL_25;
  }
  v21 = SCDynamicStoreKeyCreateNetworkInterfaceEntity(0, kSCDynamicStoreDomainState, (CFStringRef)a1[3], kSCEntNetLink);
  v22 = a1[6];
  a1[6] = (id)v21;

  if (!a1[6])
  {
    if (qword_1001E4570 != -1)
      dispatch_once(&qword_1001E4570, &stru_1001B63D8);
    if (_NRLogIsLevelEnabled(qword_1001E4568, 17))
    {
      if (qword_1001E4570 != -1)
        dispatch_once(&qword_1001E4570, &stru_1001B63D8);
      _NRLogWithArgs(qword_1001E4568, 17, "SCDynamicStoreKeyCreateNetworkInterfaceEntity(%s/Link) failed");
    }
    goto LABEL_25;
  }

  a1 = a1;
  v23 = a1;
LABEL_27:

  return v23;
}

id sub_10001EE18()
{
  if (qword_1001E4570 != -1)
    dispatch_once(&qword_1001E4570, &stru_1001B63D8);
  return (id)qword_1001E4568;
}

void sub_10001EE58(uint64_t a1)
{
  unsigned int v2;
  id v3;

  v3 = *(id *)(a1 + 24);
  v2 = if_nametoindex((const char *)objc_msgSend(v3, "UTF8String"));
  *(_DWORD *)(a1 + 12) = v2;
  if (!v2)
  {
    if (qword_1001E4570 != -1)
      dispatch_once(&qword_1001E4570, &stru_1001B63D8);
    if (_NRLogIsLevelEnabled(qword_1001E4568, 0))
    {
      if (qword_1001E4570 != -1)
        dispatch_once(&qword_1001E4570, &stru_1001B63D8);
      _NRLogWithArgs(qword_1001E4568, 0, "%s%.30s:%-4d interface index unavailable for '%@'", "", "-[NRSCDInterfaceConfig updateIFIndex]", 90, *(_QWORD *)(a1 + 24));
    }
  }

}

void sub_10001EF38(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001E4568;
  qword_1001E4568 = (uint64_t)v1;

}

uint64_t sub_10001EF68(uint64_t result)
{
  uint64_t v1;
  id v2;
  id v3;

  if (result)
  {
    v1 = result;
    if (!*(_DWORD *)(result + 12) || !*(_BYTE *)(result + 9))
      return 0;
    v2 = *(id *)(result + 56);
    if (objc_msgSend(v2, "count"))
    {

      return 1;
    }
    v3 = objc_msgSend(*(id *)(v1 + 64), "count");

    return v3 != 0;
  }
  return result;
}

void sub_100020AE4(id a1)
{
  NSObject *v1;
  dispatch_queue_t v2;
  void *v3;
  id v4;
  int IsLevelEnabled;
  id v6;
  uint64_t v7;
  char *v8;
  int *v9;
  uint64_t v10;
  id v11;
  uint64_t v12;

  v1 = _NRCopySerialQueueAttr(a1);
  v2 = dispatch_queue_create("terminusd_awdl_browse", v1);

  if (!v2)
  {
    v4 = sub_100020C4C();
    IsLevelEnabled = _NRLogIsLevelEnabled(v4, 16);

    if (IsLevelEnabled)
    {
      v6 = sub_100020C4C();
      _NRLogWithArgs(v6, 16, "%s%.30s:%-4d ABORTING: dispatch_queue_create(%s) failed", "", "nr_dispatch_queue_create", 118, "terminusd_awdl_browse");

    }
    v7 = _os_log_pack_size(22);
    v8 = (char *)&v12 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
    v9 = __error();
    v10 = _os_log_pack_fill(v8, v7, *v9, &_mh_execute_header, "%{public}s dispatch_queue_create(%s) failed");
    *(_DWORD *)v10 = 136446466;
    *(_QWORD *)(v10 + 4) = "nr_dispatch_queue_create";
    *(_WORD *)(v10 + 12) = 2080;
    *(_QWORD *)(v10 + 14) = "terminusd_awdl_browse";
    v11 = sub_100020C4C();
    _NRLogAbortWithPack(v11, v8);
  }
  v3 = (void *)qword_1001E4588;
  qword_1001E4588 = (uint64_t)v2;

}

id sub_100020C4C()
{
  if (qword_1001E4580 != -1)
    dispatch_once(&qword_1001E4580, &stru_1001B63F8);
  return (id)qword_1001E4578;
}

void sub_100020C8C(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned int a8, uint64_t a9, void *a10)
{
  uint64_t v15;
  void *v16;
  id v17;
  id v18;
  id v19;

  if (a4)
  {
    if (qword_1001E4580 != -1)
      dispatch_once(&qword_1001E4580, &stru_1001B63F8);
    if (_NRLogIsLevelEnabled(qword_1001E4578, 16))
    {
      if (qword_1001E4580 != -1)
        dispatch_once(&qword_1001E4580, &stru_1001B63F8);
      _NRLogWithArgs(qword_1001E4578, 16, "%s%.30s:%-4d received error %d");
    }
  }
  else if (a5)
  {
    if (a6)
    {
      if (a10)
      {
        v19 = a10;
        v15 = objc_opt_class(BTPResolver);
        if ((objc_opt_isKindOfClass(v19, v15) & 1) != 0)
        {
          v16 = 0;
          if (a8 && a9)
            v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", a9, a8));
          v17 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", a5);
          v18 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", a6);
          objc_msgSend(v19, "handleReplyFullName:hostTarget:port:txtRecord:ifIndex:", v17, v18, a7, v16, a3);

        }
        else
        {
          if (qword_1001E4580 != -1)
            dispatch_once(&qword_1001E4580, &stru_1001B63F8);
          if (_NRLogIsLevelEnabled(qword_1001E4578, 16))
          {
            if (qword_1001E4580 != -1)
              dispatch_once(&qword_1001E4580, &stru_1001B63F8);
            _NRLogWithArgs(qword_1001E4578, 16, "%s%.30s:%-4d received context of wrong class", "", "btpResolveReply", 469);
          }
        }

      }
      else
      {
        if (qword_1001E4580 != -1)
          dispatch_once(&qword_1001E4580, &stru_1001B63F8);
        if (_NRLogIsLevelEnabled(qword_1001E4578, 16))
        {
          if (qword_1001E4580 != -1)
            dispatch_once(&qword_1001E4580, &stru_1001B63F8);
          _NRLogWithArgs(qword_1001E4578, 16, "%s%.30s:%-4d received NULL context");
        }
      }
    }
    else
    {
      if (qword_1001E4580 != -1)
        dispatch_once(&qword_1001E4580, &stru_1001B63F8);
      if (_NRLogIsLevelEnabled(qword_1001E4578, 16))
      {
        if (qword_1001E4580 != -1)
          dispatch_once(&qword_1001E4580, &stru_1001B63F8);
        _NRLogWithArgs(qword_1001E4578, 16, "%s%.30s:%-4d received NULL hostTarget");
      }
    }
  }
  else
  {
    if (qword_1001E4580 != -1)
      dispatch_once(&qword_1001E4580, &stru_1001B63F8);
    if (_NRLogIsLevelEnabled(qword_1001E4578, 16))
    {
      if (qword_1001E4580 != -1)
        dispatch_once(&qword_1001E4580, &stru_1001B63F8);
      _NRLogWithArgs(qword_1001E4578, 16, "%s%.30s:%-4d received NULL fullName");
    }
  }
}

void sub_10002107C(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001E4578;
  qword_1001E4578 = (uint64_t)v1;

}

void sub_1000210AC(uint64_t a1, unsigned int a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  uint64_t v13;
  id v14;
  id v15;
  id v16;
  id v17;

  if (a4)
  {
    if (qword_1001E4580 != -1)
      dispatch_once(&qword_1001E4580, &stru_1001B63F8);
    if (_NRLogIsLevelEnabled(qword_1001E4578, 16))
    {
      if (qword_1001E4580 != -1)
        dispatch_once(&qword_1001E4580, &stru_1001B63F8);
      _NRLogWithArgs(qword_1001E4578, 16, "%s%.30s:%-4d received error %d");
    }
    return;
  }
  if (a5)
  {
    if (a6)
    {
      if (a7)
      {
        if (a8)
        {
          v17 = a8;
          v13 = objc_opt_class(BTPBrowser);
          if ((objc_opt_isKindOfClass(v17, v13) & 1) != 0)
          {
            v14 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", a5);
            v15 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", a6);
            v16 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", a7);
            objc_msgSend(v17, "handleReplyName:type:domain:ifIndex:add:", v14, v15, v16, a3, (a2 >> 1) & 1);

          }
          else
          {
            if (qword_1001E4580 != -1)
              dispatch_once(&qword_1001E4580, &stru_1001B63F8);
            if (!_NRLogIsLevelEnabled(qword_1001E4578, 16))
              goto LABEL_42;
            v14 = sub_100020C4C();
            _NRLogWithArgs(v14, 16, "%s%.30s:%-4d received context of wrong class", "", "btpBrowseReply", 517);
          }

LABEL_42:
          return;
        }
        if (qword_1001E4580 != -1)
          dispatch_once(&qword_1001E4580, &stru_1001B63F8);
        if (_NRLogIsLevelEnabled(qword_1001E4578, 16))
        {
          v17 = sub_100020C4C();
          _NRLogWithArgs(v17, 16, "%s%.30s:%-4d received NULL context", "", "btpBrowseReply", 512);
          goto LABEL_42;
        }
      }
      else
      {
        if (qword_1001E4580 != -1)
          dispatch_once(&qword_1001E4580, &stru_1001B63F8);
        if (_NRLogIsLevelEnabled(qword_1001E4578, 16))
        {
          if (qword_1001E4580 != -1)
            dispatch_once(&qword_1001E4580, &stru_1001B63F8);
          _NRLogWithArgs(qword_1001E4578, 16, "%s%.30s:%-4d received NULL domain");
        }
      }
    }
    else
    {
      if (qword_1001E4580 != -1)
        dispatch_once(&qword_1001E4580, &stru_1001B63F8);
      if (_NRLogIsLevelEnabled(qword_1001E4578, 16))
      {
        if (qword_1001E4580 != -1)
          dispatch_once(&qword_1001E4580, &stru_1001B63F8);
        _NRLogWithArgs(qword_1001E4578, 16, "%s%.30s:%-4d received NULL type");
      }
    }
  }
  else
  {
    if (qword_1001E4580 != -1)
      dispatch_once(&qword_1001E4580, &stru_1001B63F8);
    if (_NRLogIsLevelEnabled(qword_1001E4578, 16))
    {
      if (qword_1001E4580 != -1)
        dispatch_once(&qword_1001E4580, &stru_1001B63F8);
      _NRLogWithArgs(qword_1001E4578, 16, "%s%.30s:%-4d received NULL name");
    }
  }
}

id sub_100021848(unsigned int a1)
{
  id v1;
  const char *v2;

  switch(a1)
  {
    case 0u:
      v1 = objc_alloc((Class)NSString);
      v2 = "Invalid";
      return objc_msgSend(v1, "initWithUTF8String:", v2);
    case 1u:
      v1 = objc_alloc((Class)NSString);
      v2 = "Hello";
      return objc_msgSend(v1, "initWithUTF8String:", v2);
    case 2u:
      v1 = objc_alloc((Class)NSString);
      v2 = "UpdateWiFiAddressIPv6";
      return objc_msgSend(v1, "initWithUTF8String:", v2);
    case 3u:
      v1 = objc_alloc((Class)NSString);
      v2 = "UpdateWiFiAddressIPv4";
      return objc_msgSend(v1, "initWithUTF8String:", v2);
    case 4u:
      v1 = objc_alloc((Class)NSString);
      v2 = "UpdateWiFiSignature";
      return objc_msgSend(v1, "initWithUTF8String:", v2);
    case 5u:
      v1 = objc_alloc((Class)NSString);
      v2 = "PreferWiFi";
      return objc_msgSend(v1, "initWithUTF8String:", v2);
    case 6u:
      v1 = objc_alloc((Class)NSString);
      v2 = "DeviceLinkState";
      return objc_msgSend(v1, "initWithUTF8String:", v2);
    case 7u:
      v1 = objc_alloc((Class)NSString);
      v2 = "PreferWiFiAck";
      return objc_msgSend(v1, "initWithUTF8String:", v2);
    case 8u:
      v1 = objc_alloc((Class)NSString);
      v2 = "ForceWoW";
      return objc_msgSend(v1, "initWithUTF8String:", v2);
    case 9u:
      v1 = objc_alloc((Class)NSString);
      v2 = "UpdateAWDLAddressIPv6";
      return objc_msgSend(v1, "initWithUTF8String:", v2);
    case 0xAu:
      v1 = objc_alloc((Class)NSString);
      v2 = "AWDLReachable";
      return objc_msgSend(v1, "initWithUTF8String:", v2);
    case 0xBu:
      v1 = objc_alloc((Class)NSString);
      v2 = "RequestFlags";
      return objc_msgSend(v1, "initWithUTF8String:", v2);
    case 0xCu:
      v1 = objc_alloc((Class)NSString);
      v2 = "NetInfo";
      return objc_msgSend(v1, "initWithUTF8String:", v2);
    case 0xDu:
      v1 = objc_alloc((Class)NSString);
      v2 = "LinkUpgrade";
      return objc_msgSend(v1, "initWithUTF8String:", v2);
    case 0xEu:
      v1 = objc_alloc((Class)NSString);
      v2 = "DeviceThermalPressureLevel";
      return objc_msgSend(v1, "initWithUTF8String:", v2);
    case 0xFu:
      v1 = objc_alloc((Class)NSString);
      v2 = "CountryCode";
      return objc_msgSend(v1, "initWithUTF8String:", v2);
    case 0x10u:
      v1 = objc_alloc((Class)NSString);
      v2 = "DNSProxy";
      return objc_msgSend(v1, "initWithUTF8String:", v2);
    case 0x11u:
      v1 = objc_alloc((Class)NSString);
      v2 = "DNSProxyUpdate";
      return objc_msgSend(v1, "initWithUTF8String:", v2);
    case 0x12u:
      v1 = objc_alloc((Class)NSString);
      v2 = "DiscoveryProxy";
      return objc_msgSend(v1, "initWithUTF8String:", v2);
    case 0x13u:
      v1 = objc_alloc((Class)NSString);
      v2 = "DiscoveryProxyUpdate";
      return objc_msgSend(v1, "initWithUTF8String:", v2);
    case 0x14u:
      v1 = objc_alloc((Class)NSString);
      v2 = "ApplicationServiceEndpointsRequest";
      return objc_msgSend(v1, "initWithUTF8String:", v2);
    case 0x15u:
      v1 = objc_alloc((Class)NSString);
      v2 = "ApplicationServiceEndpointsResponse";
      return objc_msgSend(v1, "initWithUTF8String:", v2);
    case 0x16u:
      v1 = objc_alloc((Class)NSString);
      v2 = "DevicePluggedIn";
      return objc_msgSend(v1, "initWithUTF8String:", v2);
    default:
      if (a1 != 255)
        return objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("Unknown(%lld)"), a1);
      v1 = objc_alloc((Class)NSString);
      v2 = "Test";
      return objc_msgSend(v1, "initWithUTF8String:", v2);
  }
}

unint64_t sub_100021BEC(uint64_t a1)
{
  unint64_t v1;
  int v2;
  uint64_t v3;
  id v5;
  int v6;
  id v7;
  uint64_t v8;
  char *v9;
  int *v10;
  uint64_t v11;
  id v12;
  int IsLevelEnabled;
  id v14;
  uint64_t v15;
  int *v16;
  uint64_t v17;
  id v18;
  uint64_t v19;

  if (!a1)
    return 0;
  v1 = *(_QWORD *)(a1 + 40);
  if (!v1)
  {
    v2 = *(unsigned __int8 *)(a1 + 10);
    if (*(_BYTE *)(a1 + 10))
    {
      v3 = *(_QWORD *)(a1 + 48);
      if (v3)
      {
        if (v2 == 2)
        {
          v1 = bswap64(*(_QWORD *)(v3 + 8));
          goto LABEL_10;
        }
        if (v2 == 1)
        {
          v1 = bswap32(*(unsigned __int16 *)(v3 + 4)) >> 16;
LABEL_10:
          *(_QWORD *)(a1 + 40) = v1;
          return v1;
        }
        return 0;
      }
      v12 = sub_100021E2C();
      IsLevelEnabled = _NRLogIsLevelEnabled(v12, 16);

      if (IsLevelEnabled)
      {
        v14 = sub_100021E2C();
        _NRLogWithArgs(v14, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (self.messageBufferPtr) != ((void *)0)", "", "-[NRLinkDirectorMessage identifier]", 554);

      }
      v15 = _os_log_pack_size(12);
      v9 = (char *)&v19 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
      v16 = __error();
      v17 = _os_log_pack_fill(v9, v15, *v16, &_mh_execute_header, "%{public}s Assertion Failed: (self.messageBufferPtr) != ((void *)0)");
      *(_DWORD *)v17 = 136446210;
      *(_QWORD *)(v17 + 4) = "-[NRLinkDirectorMessage identifier]";
    }
    else
    {
      v5 = sub_100021E2C();
      v6 = _NRLogIsLevelEnabled(v5, 16);

      if (v6)
      {
        v7 = sub_100021E2C();
        _NRLogWithArgs(v7, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: self.messageVersion != 0", "", "-[NRLinkDirectorMessage identifier]", 553);

      }
      v8 = _os_log_pack_size(12);
      v9 = (char *)&v19 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
      v10 = __error();
      v11 = _os_log_pack_fill(v9, v8, *v10, &_mh_execute_header, "%{public}s Assertion Failed: self.messageVersion != 0");
      *(_DWORD *)v11 = 136446210;
      *(_QWORD *)(v11 + 4) = "-[NRLinkDirectorMessage identifier]";
    }
    v18 = sub_100021E2C();
    _NRLogAbortWithPack(v18, v9);
  }
  return v1;
}

id sub_100021E2C()
{
  if (qword_1001E45B0 != -1)
    dispatch_once(&qword_1001E45B0, &stru_1001B6498);
  return (id)qword_1001E45A8;
}

void sub_100021E6C(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001E45A8;
  qword_1001E45A8 = (uint64_t)v1;

}

void sub_100021E9C(id a1)
{
  _QWORD *v1;
  void *v2;

  v1 = sub_100021EC8([NRLinkDirectorMessageManager alloc]);
  v2 = (void *)qword_1001E4598;
  qword_1001E4598 = (uint64_t)v1;

}

_QWORD *sub_100021EC8(void *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  id v3;
  void *v4;
  id v5;
  void *v6;
  id v8;
  int IsLevelEnabled;
  id v10;
  uint64_t v11;
  char *v12;
  int *v13;
  uint64_t v14;
  id v15;
  uint64_t v16;
  objc_super v17;

  if (!a1)
    return 0;
  v17.receiver = a1;
  v17.super_class = (Class)NRLinkDirectorMessageManager;
  v1 = objc_msgSendSuper2(&v17, "init");
  if (!v1)
  {
    v8 = sub_100021E2C();
    IsLevelEnabled = _NRLogIsLevelEnabled(v8, 16);

    if (IsLevelEnabled)
    {
      v10 = sub_100021E2C();
      _NRLogWithArgs(v10, 16, "%s%.30s:%-4d ABORTING: [super init] failed", "", "-[NRLinkDirectorMessageManager initManager]", 254);

    }
    v11 = _os_log_pack_size(12);
    v12 = (char *)&v16 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
    v13 = __error();
    v14 = _os_log_pack_fill(v12, v11, *v13, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)v14 = 136446210;
    *(_QWORD *)(v14 + 4) = "-[NRLinkDirectorMessageManager initManager]";
    v15 = sub_100021E2C();
    _NRLogAbortWithPack(v15, v12);
    return 0;
  }
  v2 = v1;
  v3 = sub_10014CFBC();
  v4 = (void *)v2[1];
  v2[1] = v3;

  v5 = objc_alloc_init((Class)NSMutableDictionary);
  v6 = (void *)v2[2];
  v2[2] = v5;

  return v2;
}

unint64_t sub_100022034(unint64_t a1, void *a2, unsigned int a3, char a4)
{
  id v8;
  void *v9;
  id *v10;
  id *v11;
  void *v12;
  int v13;
  __int16 v14;
  unint64_t v15;
  id v17;
  int IsLevelEnabled;
  id v19;
  id v20;
  int v21;
  id v22;
  uint64_t v23;
  int *v24;
  uint64_t v25;
  id v26;
  id v27;
  int v28;
  id v29;
  char *v30;
  int *v31;
  uint64_t v32;
  id v33;
  uint64_t v34;
  objc_super v35;

  v8 = a2;
  v9 = v8;
  if (!a1)
    goto LABEL_20;
  if (!v8)
  {
    v17 = sub_100021E2C();
    IsLevelEnabled = _NRLogIsLevelEnabled(v17, 17);

    if (IsLevelEnabled)
    {
      v19 = sub_100021E2C();
      _NRLogWithArgs(v19, 17, "%s called with null nrUUID", "-[NRLinkDirectorMessage initDirectorMessageWithNRUUID:messageLen:messageVersion:]");

      v15 = 0;
      goto LABEL_11;
    }
LABEL_20:
    v15 = 0;
    goto LABEL_11;
  }
  v35.receiver = (id)a1;
  v35.super_class = (Class)NRLinkDirectorMessage;
  v10 = (id *)objc_msgSendSuper2(&v35, "init");
  if (!v10)
  {
    v20 = sub_100021E2C();
    v21 = _NRLogIsLevelEnabled(v20, 16);

    if (v21)
    {
      v22 = sub_100021E2C();
      _NRLogWithArgs(v22, 16, "%s%.30s:%-4d ABORTING: [super init] failed", "", "-[NRLinkDirectorMessage initDirectorMessageWithNRUUID:messageLen:messageVersion:]", 399);

    }
    v23 = _os_log_pack_size(12);
    a1 = (unint64_t)&v34 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
    v24 = __error();
    v25 = _os_log_pack_fill(a1, v23, *v24, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)v25 = 136446210;
    *(_QWORD *)(v25 + 4) = "-[NRLinkDirectorMessage initDirectorMessageWithNRUUID:messageLen:messageVersion:]";
    v26 = sub_100021E2C();
    _NRLogAbortWithPack(v26, a1);
    goto LABEL_17;
  }
  v11 = v10;
  objc_storeStrong(v10 + 4, a2);
  *((_DWORD *)v11 + 4) = a3;
  *((_BYTE *)v11 + 10) = a4;
  a1 = a3;
  v12 = malloc_type_calloc(1uLL, a3, 0xF1748037uLL);
  if (!v12)
  {
LABEL_17:
    v27 = sub_100021E2C();
    v28 = _NRLogIsLevelEnabled(v27, 16);

    if (v28)
    {
      v29 = sub_100021E2C();
      _NRLogWithArgs(v29, 16, "%s%.30s:%-4d ABORTING: strict_calloc(%zu, %zu) failed", "", "strict_calloc", 108, 1uLL, a1);

    }
    v9 = (void *)_os_log_pack_size(32);
    v30 = (char *)&v34 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
    v31 = __error();
    v32 = _os_log_pack_fill(v30, v9, *v31, &_mh_execute_header, "%{public}s strict_calloc(%zu, %zu) failed");
    *(_DWORD *)v32 = 136446722;
    *(_QWORD *)(v32 + 4) = "strict_calloc";
    *(_WORD *)(v32 + 12) = 2048;
    *(_QWORD *)(v32 + 14) = 1;
    *(_WORD *)(v32 + 22) = 2048;
    *(_QWORD *)(v32 + 24) = a1;
    v33 = sub_100021E2C();
    _NRLogAbortWithPack(v33, v30);
    goto LABEL_20;
  }
  v11[6] = v12;
  v13 = *((unsigned __int8 *)v11 + 10);
  if (v13 == 1)
  {
    v14 = 8;
    goto LABEL_9;
  }
  if (v13 == 2)
  {
    v14 = 16;
LABEL_9:
    *((_WORD *)v11 + 6) = v14;
  }
  a1 = v11;
  v15 = a1;
LABEL_11:

  return v15;
}

uint64_t sub_10002235C(uint64_t result, char a2)
{
  _BYTE *v2;
  id v3;
  int v4;
  id v5;
  uint64_t v6;
  char *v7;
  int *v8;
  uint64_t v9;
  id v10;
  int IsLevelEnabled;
  id v12;
  uint64_t v13;
  int *v14;
  uint64_t v15;
  id v16;
  uint64_t v17;

  if (result)
  {
    if (*(_BYTE *)(result + 10))
    {
      v2 = *(_BYTE **)(result + 48);
      if (v2)
      {
        if (*(unsigned __int8 *)(result + 10) <= 2u)
          *v2 = a2;
        return result;
      }
      v10 = sub_100021E2C();
      IsLevelEnabled = _NRLogIsLevelEnabled(v10, 16);

      if (IsLevelEnabled)
      {
        v12 = sub_100021E2C();
        _NRLogWithArgs(v12, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (self.messageBufferPtr) != ((void *)0)", "", "-[NRLinkDirectorMessage writeMessageVersionToSendBuffer:]", 415);

      }
      v13 = _os_log_pack_size(12);
      v7 = (char *)&v17 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
      v14 = __error();
      v15 = _os_log_pack_fill(v7, v13, *v14, &_mh_execute_header, "%{public}s Assertion Failed: (self.messageBufferPtr) != ((void *)0)");
      *(_DWORD *)v15 = 136446210;
      *(_QWORD *)(v15 + 4) = "-[NRLinkDirectorMessage writeMessageVersionToSendBuffer:]";
    }
    else
    {
      v3 = sub_100021E2C();
      v4 = _NRLogIsLevelEnabled(v3, 16);

      if (v4)
      {
        v5 = sub_100021E2C();
        _NRLogWithArgs(v5, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: self.messageVersion != 0", "", "-[NRLinkDirectorMessage writeMessageVersionToSendBuffer:]", 414);

      }
      v6 = _os_log_pack_size(12);
      v7 = (char *)&v17 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
      v8 = __error();
      v9 = _os_log_pack_fill(v7, v6, *v8, &_mh_execute_header, "%{public}s Assertion Failed: self.messageVersion != 0");
      *(_DWORD *)v9 = 136446210;
      *(_QWORD *)(v9 + 4) = "-[NRLinkDirectorMessage writeMessageVersionToSendBuffer:]";
    }
    v16 = sub_100021E2C();
    _NRLogAbortWithPack(v16, v7);
  }
  return result;
}

void sub_100022548(uint64_t a1, _WORD *a2, size_t __n)
{
  int v4;
  uint64_t v5;
  int v6;
  void *v7;
  int v8;
  uint64_t v9;
  id v10;
  int IsLevelEnabled;
  id v12;
  uint64_t v13;
  char *v14;
  int *v15;
  uint64_t v16;
  id v17;
  int v18;
  id v19;
  uint64_t v20;
  int *v21;
  uint64_t v22;
  id v23;
  id v24;

  if (!a1)
    return;
  v4 = *(unsigned __int8 *)(a1 + 10);
  if (!*(_BYTE *)(a1 + 10))
  {
    v10 = sub_100021E2C();
    IsLevelEnabled = _NRLogIsLevelEnabled(v10, 16);

    if (IsLevelEnabled)
    {
      v12 = sub_100021E2C();
      _NRLogWithArgs(v12, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: self.messageVersion != 0", "", "-[NRLinkDirectorMessage writeMessageIdentifierNBOToSendBuffer:len:]", 438);

    }
    v13 = _os_log_pack_size(12);
    v14 = (char *)&v24 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
    v15 = __error();
    v16 = _os_log_pack_fill(v14, v13, *v15, &_mh_execute_header, "%{public}s Assertion Failed: self.messageVersion != 0");
    *(_DWORD *)v16 = 136446210;
    *(_QWORD *)(v16 + 4) = "-[NRLinkDirectorMessage writeMessageIdentifierNBOToSendBuffer:len:]";
LABEL_18:
    v23 = sub_100021E2C();
    _NRLogAbortWithPack(v23, v14);
  }
  v5 = *(_QWORD *)(a1 + 48);
  if (!v5)
  {
    v17 = sub_100021E2C();
    v18 = _NRLogIsLevelEnabled(v17, 16);

    if (v18)
    {
      v19 = sub_100021E2C();
      _NRLogWithArgs(v19, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (self.messageBufferPtr) != ((void *)0)", "", "-[NRLinkDirectorMessage writeMessageIdentifierNBOToSendBuffer:len:]", 439);

    }
    v20 = _os_log_pack_size(12);
    v14 = (char *)&v24 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
    v21 = __error();
    v22 = _os_log_pack_fill(v14, v20, *v21, &_mh_execute_header, "%{public}s Assertion Failed: (self.messageBufferPtr) != ((void *)0)");
    *(_DWORD *)v22 = 136446210;
    *(_QWORD *)(v22 + 4) = "-[NRLinkDirectorMessage writeMessageIdentifierNBOToSendBuffer:len:]";
    goto LABEL_18;
  }
  v6 = __n;
  if (v4 == 2)
  {
    memcpy((void *)(v5 + 8), a2, __n);
  }
  else if (v4 == 1)
  {
    if (__n >= 3)
    {
      v7 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
      v8 = _NRLogIsLevelEnabled(v7, 17);

      if (v8)
      {
        v24 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v9);
        _NRLogWithArgs(v24, 17, "Invalid buffer length for message identifier (%u > %zu)", v6, 2uLL);

      }
    }
    else
    {
      *(_WORD *)(v5 + 4) = *a2;
    }
  }
}

uint64_t sub_100022800(uint64_t result, __int16 a2)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  id v5;
  int IsLevelEnabled;
  id v7;
  uint64_t v8;
  char *v9;
  int *v10;
  uint64_t v11;
  id v12;
  int v13;
  id v14;
  uint64_t v15;
  int *v16;
  uint64_t v17;
  id v18;
  uint64_t v19;

  v2 = *(unsigned __int8 *)(result + 10);
  if (!*(_BYTE *)(result + 10))
  {
    v5 = sub_100021E2C();
    IsLevelEnabled = _NRLogIsLevelEnabled(v5, 16);

    if (IsLevelEnabled)
    {
      v7 = sub_100021E2C();
      _NRLogWithArgs(v7, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: self.messageVersion != 0", "", "-[NRLinkDirectorMessage writeMessagePayloadLengthNBOToSendBuffer:len:]", 464);

    }
    v8 = _os_log_pack_size(12);
    v9 = (char *)&v19 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
    v10 = __error();
    v11 = _os_log_pack_fill(v9, v8, *v10, &_mh_execute_header, "%{public}s Assertion Failed: self.messageVersion != 0");
    *(_DWORD *)v11 = 136446210;
    *(_QWORD *)(v11 + 4) = "-[NRLinkDirectorMessage writeMessagePayloadLengthNBOToSendBuffer:len:]";
LABEL_15:
    v18 = sub_100021E2C();
    _NRLogAbortWithPack(v18, v9);
  }
  v3 = *(_QWORD *)(result + 48);
  if (!v3)
  {
    v12 = sub_100021E2C();
    v13 = _NRLogIsLevelEnabled(v12, 16);

    if (v13)
    {
      v14 = sub_100021E2C();
      _NRLogWithArgs(v14, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (self.messageBufferPtr) != ((void *)0)", "", "-[NRLinkDirectorMessage writeMessagePayloadLengthNBOToSendBuffer:len:]", 465);

    }
    v15 = _os_log_pack_size(12);
    v9 = (char *)&v19 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
    v16 = __error();
    v17 = _os_log_pack_fill(v9, v15, *v16, &_mh_execute_header, "%{public}s Assertion Failed: (self.messageBufferPtr) != ((void *)0)");
    *(_DWORD *)v17 = 136446210;
    *(_QWORD *)(v17 + 4) = "-[NRLinkDirectorMessage writeMessagePayloadLengthNBOToSendBuffer:len:]";
    goto LABEL_15;
  }
  if (v2 == 1)
  {
    v4 = 6;
  }
  else
  {
    if (v2 != 2)
      return result;
    v4 = 2;
  }
  *(_WORD *)(v3 + v4) = a2;
  return result;
}

_QWORD *sub_1000229FC(_QWORD *a1, void *a2, int a3)
{
  id v5;
  uint64_t v6;
  void *v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t *v10;
  uint64_t v11;
  size_t v12;
  unsigned int v13;
  _QWORD *v14;
  void *v15;
  int IsLevelEnabled;
  uint64_t v17;
  void *v18;
  __int16 v20;
  unint64_t v21;

  v5 = a2;
  v7 = v5;
  if (!a1)
  {
LABEL_14:
    v14 = 0;
    goto LABEL_15;
  }
  if (a3 == 1)
  {
    v8 = (_QWORD *)sub_100022034((unint64_t)a1, v5, 8u, 1);
    sub_10002235C((uint64_t)v8, 1);
    do
      v13 = __ldxr(word_1001E3960);
    while (__stxr(v13 + 1, word_1001E3960));
    if (!v8)
      goto LABEL_11;
    v8[5] = v13;
    v20 = bswap32(sub_100021BEC((uint64_t)v8)) >> 16;
    v10 = (unint64_t *)&v20;
    v11 = (uint64_t)v8;
    v12 = 2;
    goto LABEL_10;
  }
  if (a3 != 2)
  {
    v15 = (void *)_NRCopyLogObjectForNRUUID(v5, v6);
    IsLevelEnabled = _NRLogIsLevelEnabled(v15, 17);

    if (IsLevelEnabled)
    {
      v18 = (void *)_NRCopyLogObjectForNRUUID(v7, v17);
      _NRLogWithArgs(v18, 17, "Invalid message version %d", a3);

    }
    goto LABEL_14;
  }
  v8 = (_QWORD *)sub_100022034((unint64_t)a1, v5, 0x10u, 2);
  sub_10002235C((uint64_t)v8, 2);
  v9 = sub_100107758();
  if (v8)
  {
    v8[5] = v9;
    v21 = bswap64(sub_100021BEC((uint64_t)v8));
    v10 = &v21;
    v11 = (uint64_t)v8;
    v12 = 8;
LABEL_10:
    sub_100022548(v11, v10, v12);
  }
LABEL_11:
  a1 = v8;
  v14 = a1;
LABEL_15:

  return v14;
}

_QWORD *sub_100022B68(_QWORD *a1, void *a2)
{
  id v3;
  void *v4;
  _QWORD *v5;
  id v7;
  int IsLevelEnabled;
  id v9;

  v3 = a2;
  v4 = v3;
  if (!a1)
  {
LABEL_7:
    v5 = 0;
    goto LABEL_4;
  }
  if (!v3)
  {
    v7 = sub_100021E2C();
    IsLevelEnabled = _NRLogIsLevelEnabled(v7, 17);

    if (IsLevelEnabled)
    {
      v9 = sub_100021E2C();
      _NRLogWithArgs(v9, 17, "%s called with null nrUUID", "-[NRLinkDirectorMessage initOutgoingDirectorMessageWithNRUUID:]");

    }
    goto LABEL_7;
  }
  a1 = sub_1000229FC(a1, v3, 2);
  v5 = a1;
LABEL_4:

  return v5;
}

_QWORD *sub_100022C18(_QWORD *a1, void *a2)
{
  id v3;
  void *v4;
  _BYTE *v5;
  _QWORD *v6;
  id v8;
  int IsLevelEnabled;
  id v10;

  v3 = a2;
  v4 = v3;
  if (!a1)
  {
LABEL_9:
    v6 = 0;
    goto LABEL_6;
  }
  if (!v3)
  {
    v8 = sub_100021E2C();
    IsLevelEnabled = _NRLogIsLevelEnabled(v8, 17);

    if (IsLevelEnabled)
    {
      v10 = sub_100021E2C();
      _NRLogWithArgs(v10, 17, "%s called with null nrUUID", "-[NRLinkDirectorMessage initBroadcastOutgoingDirectorMessageWithNRUUID:]");

    }
    goto LABEL_9;
  }
  v5 = sub_1000229FC(a1, v3, 2);
  if (v5)
    v5[8] = 1;
  a1 = v5;
  v6 = a1;
LABEL_6:

  return v6;
}

unint64_t sub_100022CD4(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  void *v10;
  int v11;
  uint64_t v12;
  void *v13;
  int IsLevelEnabled;
  uint64_t v15;
  void *v16;
  void *v17;
  int v18;
  void *v19;
  int v20;
  uint64_t v21;
  void *v22;
  __int16 v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  int v28;
  uint64_t v29;
  __int16 v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  void *v34;
  int v35;
  unint64_t v36;
  int v38;
  uint64_t v39;
  void *v40;
  NRLinkDirectorMessage *v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  void *v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  void *v53;
  NRLinkDirectorMessage *v54;
  unint64_t v55;
  uint64_t v56;
  unint64_t v57;
  void *v58;
  int v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unsigned __int8 v64;

  v5 = a2;
  v6 = a3;
  objc_opt_self(a1);
  v8 = objc_msgSend(v5, "length");
  v64 = 0;
  if (!v8)
  {
    v13 = (void *)_NRCopyLogObjectForNRUUID(v6, v7);
    IsLevelEnabled = _NRLogIsLevelEnabled(v13, 16);

    if (IsLevelEnabled)
    {
      v16 = (void *)_NRCopyLogObjectForNRUUID(v6, v15);
      _NRLogWithArgs(v16, 16, "%s%.30s:%-4d Received malformed message (%u < %zu)");
LABEL_20:

      goto LABEL_21;
    }
    goto LABEL_21;
  }
  objc_msgSend(v5, "getBytes:length:", &v64, 1);
  if (v64 == 2)
  {
    v62 = 0;
    v63 = 0;
    if (v8 <= 0xF)
    {
      v17 = (void *)_NRCopyLogObjectForNRUUID(v6, v9);
      v18 = _NRLogIsLevelEnabled(v17, 16);

      if (v18)
      {
LABEL_11:
        v16 = (void *)_NRCopyLogObjectForNRUUID(v6, v12);
        _NRLogWithArgs(v16, 16, "%s%.30s:%-4d Received malformed message (%u < %u)");
        goto LABEL_20;
      }
LABEL_21:
      v36 = 0;
      goto LABEL_22;
    }
    objc_msgSend(v5, "getBytes:length:", &v62, 16);
    v30 = WORD1(v62);
    v31 = __rev16(WORD1(v62));
    v33 = _NRCopyLogObjectForNRUUID(v6, v32);
    v34 = (void *)v33;
    if (v31 + 16 > v8)
    {
      v35 = _NRLogIsLevelEnabled(v33, 16);

      if (!v35)
        goto LABEL_21;
      goto LABEL_19;
    }
    v51 = _NRLogIsLevelEnabled(v33, 0);

    if (v51)
    {
      v53 = (void *)_NRCopyLogObjectForNRUUID(v6, v52);
      _NRLogWithArgs(v53, 0, "%s%.30s:%-4d Received message with version: %u, id: %u, length: %u", "", "+[NRLinkDirectorMessage createMessageWithData:nrUUID:]", 634, v64, bswap32((unsigned __int16)v63) >> 16, v31);

    }
    v54 = [NRLinkDirectorMessage alloc];
    v55 = sub_100022034((unint64_t)v54, v6, v31 + 16, v64);
    v36 = v55;
    if (v55)
    {
      *(_WORD *)(v55 + 14) = v31;
      sub_100022800(v55, v30);
      objc_msgSend(v5, "getBytes:length:", *(_QWORD *)(v36 + 48), v31 + 16);
      do
        v57 = __ldxr(&qword_1001E3968);
      while (__stxr(v57 + 1, &qword_1001E3968));
      *(_QWORD *)(v36 + 56) = v57;
    }
    else
    {
      objc_msgSend(v5, "getBytes:length:", 0, v31 + 16);
      do
        v61 = __ldxr(&qword_1001E3968);
      while (__stxr(v61 + 1, &qword_1001E3968));
    }
    v58 = (void *)_NRCopyLogObjectForNRUUID(v6, v56);
    v59 = _NRLogIsLevelEnabled(v58, 0);

    if (v59)
    {
      v48 = _NRCopyLogObjectForNRUUID(v6, v60);
      v49 = (void *)v48;
      v50 = 645;
      goto LABEL_37;
    }
  }
  else
  {
    if (v64 != 1)
    {
      v19 = (void *)_NRCopyLogObjectForNRUUID(v6, v9);
      v20 = _NRLogIsLevelEnabled(v19, 0);

      if (v20)
      {
        v22 = (void *)_NRCopyLogObjectForNRUUID(v6, v21);
        _NRLogWithArgs(v22, 0, "%s%.30s:%-4d Unsupported message version %u", "", "+[NRLinkDirectorMessage createMessageWithData:nrUUID:]", 647, v64);

      }
      goto LABEL_21;
    }
    v62 = 0;
    if (v8 <= 7)
    {
      v10 = (void *)_NRCopyLogObjectForNRUUID(v6, v9);
      v11 = _NRLogIsLevelEnabled(v10, 16);

      if (v11)
        goto LABEL_11;
      goto LABEL_21;
    }
    objc_msgSend(v5, "getBytes:length:", &v62, 8);
    v23 = HIWORD(v62);
    v24 = __rev16(HIWORD(v62));
    v26 = _NRCopyLogObjectForNRUUID(v6, v25);
    v27 = (void *)v26;
    if (v24 + 8 > v8)
    {
      v28 = _NRLogIsLevelEnabled(v26, 16);

      if (!v28)
        goto LABEL_21;
LABEL_19:
      v16 = (void *)_NRCopyLogObjectForNRUUID(v6, v29);
      _NRLogWithArgs(v16, 16, "%s%.30s:%-4d Received truncated message of total length %u with payloadLength %u");
      goto LABEL_20;
    }
    v38 = _NRLogIsLevelEnabled(v26, 0);

    if (v38)
    {
      v40 = (void *)_NRCopyLogObjectForNRUUID(v6, v39);
      _NRLogWithArgs(v40, 0, "%s%.30s:%-4d Received message with version: %u, id: %u, length: %u", "", "+[NRLinkDirectorMessage createMessageWithData:nrUUID:]", 603, v64, bswap32(WORD2(v62)) >> 16, v24);

    }
    v41 = [NRLinkDirectorMessage alloc];
    v42 = sub_100022034((unint64_t)v41, v6, v24 + 8, v64);
    v36 = v42;
    if (v42)
    {
      *(_WORD *)(v42 + 14) = v24;
      sub_100022800(v42, v23);
      v43 = *(_QWORD *)(v36 + 48);
    }
    else
    {
      v43 = 0;
    }
    objc_msgSend(v5, "getBytes:length:", v43, v24 + 8);
    v45 = (void *)_NRCopyLogObjectForNRUUID(v6, v44);
    v46 = _NRLogIsLevelEnabled(v45, 0);

    if (v46)
    {
      v48 = _NRCopyLogObjectForNRUUID(v6, v47);
      v49 = (void *)v48;
      v50 = 611;
LABEL_37:
      _NRLogWithArgs(v48, 0, "%s%.30s:%-4d Received message: %@", "", "+[NRLinkDirectorMessage createMessageWithData:nrUUID:]", v50, v36);

    }
  }
LABEL_22:

  return v36;
}

void sub_1000231F8(uint64_t a1, int a2, void *a3)
{
  id v5;
  uint64_t v6;
  id v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  size_t v12;
  char *v13;
  int v14;
  uint64_t v15;
  void *v16;
  int v17;
  id v18;
  uint64_t v19;
  void *v20;
  int v21;
  void *v22;
  int IsLevelEnabled;
  uint64_t v24;
  void *v25;
  char *v26;
  id v27;
  int v28;
  id v29;
  uint64_t v30;
  char *v31;
  int *v32;
  uint64_t v33;
  id v34;
  int v35;
  id v36;
  uint64_t v37;
  int *v38;
  uint64_t v39;
  id v40;
  id v41;
  int v42;
  id v43;
  uint64_t v44;
  char *v45;
  int *v46;
  uint64_t v47;
  int v48;
  id v49;
  uint64_t v50;
  id v51;

  v5 = a3;
  if (!a1)
    goto LABEL_21;
  v51 = v5;
  if (v5)
  {
    v7 = objc_msgSend(v5, "length");
    if ((unint64_t)v7 >= 0x10000)
    {
      v22 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v6);
      IsLevelEnabled = _NRLogIsLevelEnabled(v22, 17);

      v5 = v51;
      if (IsLevelEnabled)
      {
        v25 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v24);
        _NRLogWithArgs(v25, 17, "Tried to addType %u with dataLen %llu", a2, v7);

        goto LABEL_20;
      }
LABEL_21:

      return;
    }
  }
  else
  {
    LOWORD(v7) = 0;
  }
  v8 = *(unsigned __int16 *)(a1 + 14);
  v9 = *(_DWORD *)(a1 + 16);
  if (v9 != *(unsigned __int16 *)(a1 + 12) + (_DWORD)v8)
  {
    v16 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v6);
    v17 = _NRLogIsLevelEnabled(v16, 17);

    v5 = v51;
    if (v17)
    {
      v18 = *(id *)(a1 + 32);
      v20 = (void *)_NRCopyLogObjectForNRUUID(v18, v19);
      v21 = *(_DWORD *)(a1 + 16);

      _NRLogWithArgs(v20, 17, "Disconnect between messageLen %u and writtenPayloadLength %u", v21, v8);
LABEL_20:
      v5 = v51;
      goto LABEL_21;
    }
    goto LABEL_21;
  }
  v10 = (unsigned __int16)v7;
  v11 = (unsigned __int16)v7 + 3;
  v12 = v9 + (unsigned __int16)((_WORD)v7 + 3);
  *(_DWORD *)(a1 + 16) = v12;
  if (!(_DWORD)v12)
  {
    v27 = sub_100021E2C();
    v28 = _NRLogIsLevelEnabled(v27, 16);

    if (v28)
    {
      v29 = sub_100021E2C();
      _NRLogWithArgs(v29, 16, "%s%.30s:%-4d ABORTING: _strict_reallocf called with size 0", "", "_strict_reallocf", 134);

    }
    v30 = _os_log_pack_size(12);
    v31 = (char *)&v51 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
    v32 = __error();
    v33 = _os_log_pack_fill(v31, v30, *v32, &_mh_execute_header, "%{public}s _strict_reallocf called with size 0");
    *(_DWORD *)v33 = 136446210;
    *(_QWORD *)(v33 + 4) = "_strict_reallocf";
LABEL_28:
    v40 = sub_100021E2C();
    _NRLogAbortWithPack(v40, v31);
  }
  v13 = (char *)reallocf(*(void **)(a1 + 48), v12);
  if (!v13)
  {
    v34 = sub_100021E2C();
    v35 = _NRLogIsLevelEnabled(v34, 16);

    if (v35)
    {
      v36 = sub_100021E2C();
      _NRLogWithArgs(v36, 16, "%s%.30s:%-4d ABORTING: _strict_reallocf(%zu) failed", "", "_strict_reallocf", 139, v12);

    }
    v37 = _os_log_pack_size(22);
    v31 = (char *)&v51 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
    v38 = __error();
    v39 = _os_log_pack_fill(v31, v37, *v38, &_mh_execute_header, "%{public}s _strict_reallocf(%zu) failed");
    *(_DWORD *)v39 = 136446466;
    *(_QWORD *)(v39 + 4) = "_strict_reallocf";
    *(_WORD *)(v39 + 12) = 2048;
    *(_QWORD *)(v39 + 14) = v12;
    goto LABEL_28;
  }
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 48) = v13;
  v14 = *(unsigned __int8 *)(a1 + 10);
  if (v14 == 1)
  {
    v15 = 8;
    goto LABEL_17;
  }
  if (v14 == 2)
  {
    v15 = 16;
LABEL_17:
    v26 = &v13[v15 + v8];
    *v26 = a2;
    *(_WORD *)(v26 + 1) = __rev16(v10);
    if ((_DWORD)v10)
      objc_msgSend(v51, "getBytes:length:", v26 + 3, v10);
    *(_WORD *)(a1 + 14) = v8 + v11;
    sub_100022800(a1, bswap32(v8 + v11) >> 16);
    goto LABEL_20;
  }
  v41 = sub_100021E2C();
  v42 = _NRLogIsLevelEnabled(v41, 16);

  if (v42)
  {
    v43 = sub_100021E2C();
    _NRLogWithArgs(v43, 16, "%s%.30s:%-4d ABORTING: Unsupported message version: %u", "", "-[NRLinkDirectorMessage addType:data:]", 691, *(unsigned __int8 *)(a1 + 10));

  }
  v44 = _os_log_pack_size(18);
  v45 = (char *)&v51 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
  v46 = __error();
  v47 = _os_log_pack_fill(v45, v44, *v46, &_mh_execute_header, "%{public}s Unsupported message version: %u");
  v48 = *(unsigned __int8 *)(a1 + 10);
  *(_DWORD *)v47 = 136446466;
  *(_QWORD *)(v47 + 4) = "-[NRLinkDirectorMessage addType:data:]";
  *(_WORD *)(v47 + 12) = 1024;
  *(_DWORD *)(v47 + 14) = v48;
  v49 = sub_100021E2C();
  v50 = _NRLogAbortWithPack(v49, v45);
  sub_100023678(v50);
}

void sub_100023678(uint64_t a1, int a2, char a3)
{
  id v5;
  char v6;

  if (a1)
  {
    v6 = a3;
    v5 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &v6, 1);
    sub_1000231F8(a1, a2, v5);

  }
}

void sub_1000236E0(uint64_t a1, void *a2, unsigned int a3, int a4)
{
  id v7;
  id v8;
  uint64_t v9;
  id v10;
  int v11;
  id v12;
  uint64_t v13;
  void *v14;
  int IsLevelEnabled;
  uint64_t v16;
  void *v17;
  id v18;
  int v19;
  id v20;

  v7 = a2;
  v20 = v7;
  if (v7)
  {
    v8 = sub_10010A268(v7, a3, 1);
    v9 = objc_claimAutoreleasedReturnValue(v8);
    if (!v9)
    {
      if (qword_1001E45B0 != -1)
        dispatch_once(&qword_1001E45B0, &stru_1001B6498);
      if (_NRLogIsLevelEnabled(qword_1001E45A8, 17))
      {
        if (qword_1001E45B0 != -1)
          dispatch_once(&qword_1001E45B0, &stru_1001B6498);
        _NRLogWithArgs(qword_1001E45A8, 17, "NRCreateAddressData(%@) failed", v20);
        v10 = 0;
      }
      else
      {
        v10 = 0;
      }
      goto LABEL_23;
    }
    v10 = (id)v9;
    if (objc_msgSend(v20, "addressFamily") == (id)30)
    {
      if (a4)
        v11 = 9;
      else
        v11 = 2;
    }
    else
    {
      v12 = objc_msgSend(v20, "addressFamily");
      if (v12 == (id)2 && a4)
      {
        v14 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v13);
        IsLevelEnabled = _NRLogIsLevelEnabled(v14, 17);

        if (IsLevelEnabled)
        {
          v17 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v16);
          _NRLogWithArgs(v17, 17, "unsupported address family for AWDL");

        }
        goto LABEL_23;
      }
      if (v12 != (id)2)
      {
LABEL_23:

        goto LABEL_24;
      }
      v11 = 3;
    }
    sub_1000231F8(a1, v11, v10);
    goto LABEL_23;
  }
  v18 = sub_100021E2C();
  v19 = _NRLogIsLevelEnabled(v18, 17);

  if (v19)
  {
    v10 = sub_100021E2C();
    _NRLogWithArgs(v10, 17, "%s called with null addressEndpoint", "-[NRLinkDirectorMessage addUpdateAddressEndpointInner:portHBO:isAWDL:]");
    goto LABEL_23;
  }
LABEL_24:

}

unsigned __int16 *sub_1000238A4(_QWORD *a1, uint64_t a2)
{
  NRLinkDirectorMessageState *v2;
  uint64_t v5;
  unsigned __int16 *v6;
  void *v7;
  uint64_t v8;
  id v9;
  void *v10;
  uint64_t v11;
  void *v12;
  id *v13;
  uint64_t v14;
  id v15;
  void *v16;
  id v17;
  id v18;
  uint64_t v19;
  void *v20;
  void *v21;
  uint64_t v22;
  void *v23;
  unint64_t v24;
  void *v25;
  int v26;
  uint64_t v27;
  unsigned __int16 *v28;
  void *v29;
  char IsLevelEnabled;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  unsigned __int16 *v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  void *v38;
  int v39;
  id v40;
  uint64_t v41;
  void *v42;
  int v43;
  unsigned int v44;
  unsigned __int16 v45;
  uint64_t v46;
  unint64_t v47;
  id v48;
  void *v49;
  __int16 v50;
  void *v51;
  int v52;
  void *v53;
  unsigned __int8 *v54;
  unsigned __int8 *v55;
  unsigned int v56;
  uint64_t v57;
  unsigned __int16 *v58;
  void *v59;
  int v60;
  uint64_t v61;
  void *v62;
  id v63;
  uint64_t v64;
  char *v65;
  uint64_t v66;
  id v67;
  uint64_t v68;
  NSNumber *v69;
  void *v70;
  uint64_t v71;
  uint64_t v72;
  void *v73;
  int v74;
  id v75;
  uint64_t v76;
  void *v77;
  id v78;
  unint64_t v79;
  void *v80;
  int v81;
  id v82;
  uint64_t v83;
  void *v84;
  int v85;
  void *v86;
  int v87;
  id v88;
  uint64_t v89;
  void *v90;
  int v91;
  void *v92;
  int v93;
  uint64_t v94;
  NSNumber *v95;
  NSNumber *v96;
  unint64_t v97;
  uint64_t v98;
  void *v99;
  int v100;
  id v101;
  uint64_t v102;
  id v103;
  id v104;
  unint64_t v105;
  id v106;
  char v107;
  void *v108;
  uint64_t v109;
  void *v110;
  int v111;
  uint64_t v112;
  id v114;
  int v115;
  id v116;
  char *v117;
  int *v118;
  uint64_t v119;
  int v120;
  id v121;
  unsigned __int16 *v122;
  id v123;
  unsigned int v124;

  if (a1)
  {
    if (a1[6])
    {
      objc_opt_self(NRLinkDirectorMessageManager);
      if (qword_1001E45A0 != -1)
        dispatch_once(&qword_1001E45A0, &stru_1001B6438);
      v5 = qword_1001E4598;
      v6 = a1;
      if (!v5)
        goto LABEL_56;
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(v5 + 8));
      v7 = *(void **)(v5 + 16);
      v8 = *((_QWORD *)v6 + 4);
      v9 = v7;
      v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "objectForKeyedSubscript:", v8));

      if (!v10)
      {
        v29 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v6 + 4), v11);
        IsLevelEnabled = _NRLogIsLevelEnabled(v29, 17);

        if ((IsLevelEnabled & 1) != 0)
        {
          v32 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v6 + 4), v31);
          _NRLogWithArgs(v32, 17, "no registered uuid for incoming message");

          v28 = 0;
          goto LABEL_83;
        }
LABEL_56:
        v28 = 0;
        goto LABEL_83;
      }
      v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", a2));
      v13 = (id *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "objectForKeyedSubscript:", v12));
      if (v13)
      {
        v14 = objc_opt_class(NRLinkDirectorMessageState);
        if ((objc_opt_isKindOfClass(v13, v14) & 1) == 0)
        {
LABEL_55:

          goto LABEL_56;
        }
        v15 = v13[1];
        v16 = v15;
        if (v15)
        {
          v2 = (NRLinkDirectorMessageState *)objc_msgSend(v15, "unsignedLongLongValue");
          if ((unint64_t)v2 >= sub_100021BEC((uint64_t)v6))
          {
            v17 = v13[2];
            v18 = objc_msgSend(v16, "unsignedLongLongValue");
            if (v18 == (id)sub_100021BEC((uint64_t)v6) && objc_msgSend(v17, "unsignedLongLongValue") == *((id *)v6 + 7))
            {
              v20 = v17;
              v21 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v6 + 4), v19);
              v2 = (NRLinkDirectorMessageState *)_NRLogIsLevelEnabled(v21, 2);

              if ((_DWORD)v2)
              {
                v23 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v6 + 4), v22);
                v24 = sub_100021BEC((uint64_t)v6);
                _NRLogWithArgs(v23, 2, "%s%.30s:%-4d allowing access to message type %u for same message %llu", "", "-[NRLinkDirectorMessageManager isMessageTypeValid:forMessage:]", 374, a2, v24);

              }
              goto LABEL_22;
            }
            v73 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v6 + 4), v19);
            v74 = _NRLogIsLevelEnabled(v73, 0);

            if (v74)
            {
              v75 = *((id *)v6 + 4);
              v77 = (void *)_NRCopyLogObjectForNRUUID(v75, v76);
              v78 = objc_msgSend(v16, "unsignedLongLongValue");

              v79 = sub_100021BEC((uint64_t)v6);
              _NRLogWithArgs(v77, 0, "%s%.30s:%-4d Ignoring received message type %u, as it is stale (%llu >= %llu)", "", "-[NRLinkDirectorMessageManager isMessageTypeValid:forMessage:]", 377, a2, v78, v79);

            }
            goto LABEL_55;
          }
        }
      }
      else
      {
        v16 = 0;
      }
LABEL_22:

      v34 = (unsigned __int16 *)objc_alloc_init((Class)NSMutableArray);
      v35 = v6[7];
      if (*((_DWORD *)v6 + 4) == v6[6] + (_DWORD)v35)
      {
        v36 = *((unsigned __int8 *)v6 + 10);
        v124 = a2;
        if (v36 == 1)
        {
          v37 = 8;
          if (!(_DWORD)v35)
            goto LABEL_44;
        }
        else
        {
          if (v36 != 2)
          {
            v114 = sub_100021E2C();
            v115 = _NRLogIsLevelEnabled(v114, 16);

            v65 = "-[NRLinkDirectorMessage copyAllDataForType:]";
            if (v115)
            {
              v116 = sub_100021E2C();
              _NRLogWithArgs(v116, 16, "%s%.30s:%-4d ABORTING: Unsupported message version: %u", "", "-[NRLinkDirectorMessage copyAllDataForType:]", 902, *((unsigned __int8 *)v6 + 10));

            }
            v64 = _os_log_pack_size(18);
            v117 = (char *)&v122 - ((__chkstk_darwin(v64) + 15) & 0xFFFFFFFFFFFFFFF0);
            v118 = __error();
            v119 = _os_log_pack_fill(v117, v64, *v118, &_mh_execute_header, "%{public}s Unsupported message version: %u");
            v120 = *((unsigned __int8 *)v6 + 10);
            *(_DWORD *)v119 = 136446466;
            *(_QWORD *)(v119 + 4) = "-[NRLinkDirectorMessage copyAllDataForType:]";
            *(_WORD *)(v119 + 12) = 1024;
            *(_DWORD *)(v119 + 14) = v120;
            v121 = sub_100021E2C();
            _NRLogAbortWithPack(v121, v117);
            goto LABEL_88;
          }
          v37 = 16;
          if (!(_DWORD)v35)
          {
LABEL_44:
            if (!objc_msgSend(v34, "count"))
            {
LABEL_82:
              v6 = v34;
              v28 = v6;
              goto LABEL_83;
            }
            objc_opt_self(NRLinkDirectorMessageManager);
            if (qword_1001E45A0 != -1)
              dispatch_once(&qword_1001E45A0, &stru_1001B6438);
            v64 = qword_1001E4598;
            v65 = v6;
            if (!v64)
            {
LABEL_81:

              goto LABEL_82;
            }
            dispatch_assert_queue_V2(*(dispatch_queue_t *)(v64 + 8));
            v66 = *((_QWORD *)v6 + 4);
            v67 = *(id *)(v64 + 16);
            v35 = objc_claimAutoreleasedReturnValue(objc_msgSend(v67, "objectForKeyedSubscript:", v66));

            if (!v35)
            {
              v92 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v6 + 4), v68);
              v93 = _NRLogIsLevelEnabled(v92, 17);

              if (!v93)
              {
LABEL_80:

                goto LABEL_81;
              }
              v13 = (id *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v6 + 4), v94);
              _NRLogWithArgs(v13, 17, "no registered uuid for incoming message");
LABEL_79:

              goto LABEL_80;
            }
            v13 = (id *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", v124));
            v69 = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", sub_100021BEC((uint64_t)v65));
            v70 = (void *)objc_claimAutoreleasedReturnValue(v69);
            v2 = (NRLinkDirectorMessageState *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v35, "objectForKeyedSubscript:", v13));
            v122 = v34;
            if (v2)
            {
              v71 = objc_opt_class(NRLinkDirectorMessageState);
              if ((objc_opt_isKindOfClass(v2, v71) & 1) == 0)
              {
                v110 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v6 + 4), v72);
                v111 = _NRLogIsLevelEnabled(v110, 17);

                if (!v111)
                {
                  v106 = v70;
LABEL_78:

                  v34 = v122;
                  goto LABEL_79;
                }
                v96 = (NSNumber *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v6 + 4), v112);
                _NRLogWithArgs(v96, 17, "refusing to update message type %u, for invalid object %@", v124, v2);
                v106 = v70;
LABEL_77:

                goto LABEL_78;
              }
              v123 = v70;
              goto LABEL_64;
            }
            v123 = v70;
            v2 = objc_alloc_init(NRLinkDirectorMessageState);
            if (v2)
            {
LABEL_64:
              v95 = v2->_sequenceNum;
              v96 = v95;
              if (v95)
              {
                v97 = -[NSNumber unsignedLongLongValue](v95, "unsignedLongLongValue");
                if (v97 > sub_100021BEC((uint64_t)v65))
                {
                  v99 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v6 + 4), v98);
                  v100 = _NRLogIsLevelEnabled(v99, 17);

                  if (!v100)
                  {
                    v106 = v123;
                    goto LABEL_77;
                  }
                  v101 = *((id *)v6 + 4);
                  v103 = (id)_NRCopyLogObjectForNRUUID(v101, v102);
                  v104 = -[NSNumber unsignedLongLongValue](v96, "unsignedLongLongValue");

                  v105 = sub_100021BEC((uint64_t)v65);
                  _NRLogWithArgs(v103, 17, "refusing to update message type %u, as it is stale (%llu > %llu)", v124, v104, v105);
                  v106 = v123;
                  goto LABEL_72;
                }
              }
              v106 = v123;
              objc_storeStrong((id *)&v2->_sequenceNum, v123);
              v107 = 0;
LABEL_69:
              v108 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *((_QWORD *)v65 + 7), v122));
              if ((v107 & 1) == 0)
                objc_storeStrong((id *)&v2->_localReceiveID, v108);

              objc_msgSend((id)v35, "setObject:forKeyedSubscript:", v2, v13);
              v109 = *((_QWORD *)v6 + 4);
              v103 = *(id *)(v64 + 16);
              objc_msgSend(v103, "setObject:forKeyedSubscript:", v35, v109);
LABEL_72:

              goto LABEL_77;
            }
LABEL_88:
            v96 = 0;
            v107 = 1;
            v106 = v123;
            goto LABEL_69;
          }
        }
        v44 = 0;
        v45 = 0;
        v46 = a1[6] + v37;
        v47 = v46 + v35;
        v123 = (id)v35;
        while (1)
        {
          v51 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v6 + 4), v33);
          v52 = _NRLogIsLevelEnabled(v51, 2);

          if (v52)
          {
            v53 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v6 + 4), v33);
            _NRLogWithArgs(v53, 2, "%s%.30s:%-4d Payload traversed: %u, payload length: %u", "", "-[NRLinkDirectorMessage copyAllDataForType:]", 907, v44, v35);

          }
          v54 = (unsigned __int8 *)(v46 + v45);
          v55 = v54 + 3;
          if ((unint64_t)(v54 + 3) > v47)
            break;
          v56 = *(unsigned __int16 *)(v54 + 1);
          v57 = __rev16(v56);
          if ((unint64_t)&v55[v57] > v47)
          {
            v86 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v6 + 4), v33);
            v87 = _NRLogIsLevelEnabled(v86, 16);

            if (v87)
            {
              v88 = *((id *)v6 + 4);
              v90 = (void *)_NRCopyLogObjectForNRUUID(v88, v89);
              v91 = *v54;

              _NRLogWithArgs(v90, 16, "%s%.30s:%-4d Received malformed TLV of type: %u, length: %u", "", "-[NRLinkDirectorMessage copyAllDataForType:]", 920, v91, v57);
            }
            goto LABEL_29;
          }
          if (*v54 == v124)
          {
            v35 = v46;
            v58 = v34;
            v59 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v6 + 4), v33);
            v60 = _NRLogIsLevelEnabled(v59, 1);

            if (v60)
            {
              v62 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v6 + 4), v61);
              v63 = sub_100021848(v124);
              _NRLogWithArgs(v62, 1, "%s%.30s:%-4d Found TLV type: %@", "", "-[NRLinkDirectorMessage copyAllDataForType:]", 925, v63);

            }
            if (v56)
              v48 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", v55, v57);
            else
              v48 = (id)objc_claimAutoreleasedReturnValue(+[NSData data](NSData, "data"));
            v49 = v48;
            v34 = v58;
            objc_msgSend(v58, "addObject:", v48);

            v46 = v35;
            LODWORD(v35) = (_DWORD)v123;
          }
          v50 = v45 + v57;
          v45 += v57 + 3;
          v44 = (unsigned __int16)(v50 + 3);
          if (v44 >= v35)
            goto LABEL_44;
        }
        v80 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v6 + 4), v33);
        v81 = _NRLogIsLevelEnabled(v80, 16);

        if (v81)
        {
          v82 = *((id *)v6 + 4);
          v84 = (void *)_NRCopyLogObjectForNRUUID(v82, v83);
          v85 = *v54;

          _NRLogWithArgs(v84, 16, "%s%.30s:%-4d Received malformed TLV of type: %u", "", "-[NRLinkDirectorMessage copyAllDataForType:]", 912, v85);
        }
      }
      else
      {
        v38 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v6 + 4), v33);
        v39 = _NRLogIsLevelEnabled(v38, 17);

        if (v39)
        {
          v40 = *((id *)v6 + 4);
          v42 = (void *)_NRCopyLogObjectForNRUUID(v40, v41);
          v43 = *((_DWORD *)v6 + 4);

          _NRLogWithArgs(v42, 17, "Disconnect between messageLen %u and payloadLength %u", v43, v35);
        }
      }
LABEL_29:
      v28 = 0;
      v6 = v34;
LABEL_83:

      return v28;
    }
    v25 = (void *)_NRCopyLogObjectForNRUUID(a1[4], a2);
    v26 = _NRLogIsLevelEnabled(v25, 17);

    if (v26)
    {
      v6 = (unsigned __int16 *)_NRCopyLogObjectForNRUUID(a1[4], v27);
      _NRLogWithArgs(v6, 17, "No message");
      v28 = 0;
      goto LABEL_83;
    }
  }
  return 0;
}

int64_t sub_100024364(id a1, id a2, id a3)
{
  id v4;
  void *v5;
  id v6;
  void *v7;
  id v8;

  v4 = a3;
  v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", objc_msgSend(a2, "metric")));
  v6 = objc_msgSend(v4, "metric");

  v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", v6));
  v8 = objc_msgSend(v5, "compare:", v7);

  return (int64_t)v8;
}

id sub_1000243F8(_QWORD *a1, int a2, int a3)
{
  id v6;
  uint64_t v7;
  unsigned __int16 *v8;
  id v9;
  id v10;
  uint64_t v11;
  void *v12;
  id v13;
  void *v14;
  unsigned __int16 *v15;
  id v16;
  id v17;
  uint64_t v18;
  void *v19;
  id v20;
  void *v21;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  _BYTE v31[128];
  _BYTE v32[128];

  v6 = objc_alloc_init((Class)NSMutableArray);
  v27 = 0u;
  v28 = 0u;
  v29 = 0u;
  v30 = 0u;
  if (a3)
    v7 = 9;
  else
    v7 = 2;
  v8 = sub_1000238A4(a1, v7);
  v9 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v27, v32, 16);
  if (v9)
  {
    v10 = v9;
    v11 = *(_QWORD *)v28;
    do
    {
      v12 = 0;
      do
      {
        if (*(_QWORD *)v28 != v11)
          objc_enumerationMutation(v8);
        v13 = sub_10010A6B4(*(void **)(*((_QWORD *)&v27 + 1) + 8 * (_QWORD)v12), 0, 30, a2);
        v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
        if (v14)
          objc_msgSend(v6, "addObject:", v14);

        v12 = (char *)v12 + 1;
      }
      while (v10 != v12);
      v10 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v27, v32, 16);
    }
    while (v10);
  }

  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v15 = sub_1000238A4(a1, 3);
  v16 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v23, v31, 16);
  if (v16)
  {
    v17 = v16;
    v18 = *(_QWORD *)v24;
    do
    {
      v19 = 0;
      do
      {
        if (*(_QWORD *)v24 != v18)
          objc_enumerationMutation(v15);
        v20 = sub_10010A6B4(*(void **)(*((_QWORD *)&v23 + 1) + 8 * (_QWORD)v19), 0, 2, a2);
        v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
        if (v21)
          objc_msgSend(v6, "addObject:", v21, (_QWORD)v23);

        v19 = (char *)v19 + 1;
      }
      while (v17 != v19);
      v17 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v23, v31, 16);
    }
    while (v17);
  }

  return v6;
}

id sub_10002461C(uint64_t a1, uint64_t a2)
{
  int v3;
  void *v5;
  int v6;
  uint64_t v7;
  void *v8;
  void *v9;
  int IsLevelEnabled;
  uint64_t v11;
  void *v12;

  if (a1)
  {
    if (*(_QWORD *)(a1 + 48) && *(_WORD *)(a1 + 14))
    {
      v3 = *(unsigned __int16 *)(a1 + 14) + *(unsigned __int16 *)(a1 + 12);
      if (*(_DWORD *)(a1 + 16) == v3)
        return objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", *(_QWORD *)(a1 + 48), *(unsigned int *)(a1 + 16));
      v9 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
      IsLevelEnabled = _NRLogIsLevelEnabled(v9, 17);

      if (IsLevelEnabled)
      {
        v12 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v11);
        _NRLogWithArgs(v12, 17, "Disconnect between messageLen %u and totalLength %u", *(_DWORD *)(a1 + 16), v3);

      }
    }
    else
    {
      v5 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
      v6 = _NRLogIsLevelEnabled(v5, 17);

      if (v6)
      {
        v8 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v7);
        _NRLogWithArgs(v8, 17, "No message to send");

      }
    }
  }
  return 0;
}

uint64_t sub_100024728(uint64_t result)
{
  uint64_t v1;
  id *v2;
  void *v3;
  uint64_t v4;
  id v5;
  id v6;
  void *v7;
  uint64_t v8;
  id *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  id v16;
  char *v17;
  char *v18;
  void *v19;
  id v20;
  void *v21;
  uint64_t v22;
  id *v23;
  uint64_t v24;
  void *v25;
  int v26;
  id v27;
  uint64_t v28;
  void *v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  id v36;
  id v37;
  id v38;
  char v39;
  uint64_t v40;
  void *i;
  id v42;
  uint64_t v43;
  void *v44;
  void *v45;
  unsigned int v46;
  uint64_t v47;
  uint64_t v48;
  void *v49;
  int v50;
  int v51;
  uint64_t v52;
  id v53;
  int IsLevelEnabled;
  id v55;
  int v56;
  char *v57;
  id v58;
  id *v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  unsigned __int8 v64;
  _BYTE v65[128];
  id v66;

  if (result)
  {
    v1 = result;
    objc_opt_self(NRLinkDirector);
    if (qword_1001E4710 != -1)
      dispatch_once(&qword_1001E4710, &stru_1001B6E60);
    v2 = (id *)(id)qword_1001E4708;
    v3 = *(void **)(v1 + 24);
    if (v3)
    {
      v5 = v3;
      goto LABEL_14;
    }
    v6 = *(id *)(v1 + 32);
    v7 = v6;
    if (v2)
    {
      if (v6)
      {
        v8 = objc_claimAutoreleasedReturnValue(objc_msgSend(v2[25], "objectForKeyedSubscript:", v6));
        if (v8)
        {
          v9 = (id *)v8;
          dispatch_assert_queue_V2(*(dispatch_queue_t *)(v8 + 104));
          v5 = v9[16];
LABEL_12:

          goto LABEL_13;
        }
        v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "UUIDString"));
        sub_1000A25C4((uint64_t)v2, 1014, CFSTR("copyPrimaryLink %@"), v11, v12, v13, v14, v15, (uint64_t)v10);

        v9 = 0;
LABEL_11:
        v5 = 0;
        goto LABEL_12;
      }
      v53 = sub_1000A2640();
      IsLevelEnabled = _NRLogIsLevelEnabled(v53, 17);

      if (IsLevelEnabled)
      {
        v9 = (id *)sub_1000A2640();
        _NRLogWithArgs(v9, 17, "%s called with null nrUUID", "-[NRLinkDirector copyPrimaryLinkForNRUUID:]");
        goto LABEL_11;
      }
    }
    v5 = 0;
LABEL_13:

    if (objc_msgSend(v5, "state") != 8)
    {
      v25 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v1 + 32), v4);
      v26 = _NRLogIsLevelEnabled(v25, 16);

      if (v26)
      {
        v27 = *(id *)(v1 + 32);
        v29 = (void *)_NRCopyLogObjectForNRUUID(v27, v28);
        _NRLogWithArgs(v29, 16, "%s%.30s:%-4d No links to send the message %@", "", "-[NRLinkDirectorMessage send]", 1033, v1);

      }
      v64 = 0;
      goto LABEL_51;
    }
LABEL_14:
    v16 = sub_10002461C(v1, v4);
    if (!v16)
    {
      v64 = 0;
LABEL_50:

LABEL_51:
      return v64;
    }
    v17 = sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(v1 + 32));
    v18 = v17;
    if (!v17 || *((unsigned __int16 *)v17 + 14) <= 0x11u)
      *(_BYTE *)(v1 + 8) = 0;
    v58 = v5;
    v66 = v5;
    v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v66, 1));
    v57 = v18;
    if (!*(_BYTE *)(v1 + 8))
    {
LABEL_31:
      v59 = v2;
      v62 = 0u;
      v63 = 0u;
      v60 = 0u;
      v61 = 0u;
      v36 = v19;
      v37 = objc_msgSend(v36, "countByEnumeratingWithState:objects:count:", &v60, v65, 16);
      if (v37)
      {
        v38 = v37;
        v39 = 0;
        v40 = *(_QWORD *)v61;
        while (1)
        {
          for (i = 0; i != v38; i = (char *)i + 1)
          {
            if (*(_QWORD *)v61 != v40)
              objc_enumerationMutation(v36);
            v45 = *(void **)(*((_QWORD *)&v60 + 1) + 8 * (_QWORD)i);
            if (objc_msgSend(v45, "ikeClassDEstablished")
              && (!*(_BYTE *)(v1 + 9) || objc_msgSend(v45, "type") != 4))
            {
              v46 = objc_msgSend(v45, "sendControlData:", v16);
              v48 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(v1 + 32), v47);
              v49 = (void *)v48;
              if (v46)
              {
                v50 = _NRLogIsLevelEnabled(v48, 0);

                if (v50)
                {
                  v42 = *(id *)(v1 + 32);
                  v44 = (void *)_NRCopyLogObjectForNRUUID(v42, v43);
                  _NRLogWithArgs(v44, 0, "%s%.30s:%-4d Successfully sent %@ over %@", "", "-[NRLinkDirectorMessage send]", 1064, v1, v45);
                  v39 = 1;
LABEL_36:

                  continue;
                }
                v39 = 1;
              }
              else
              {
                v51 = _NRLogIsLevelEnabled(v48, 16);

                if (v51)
                {
                  v42 = *(id *)(v1 + 32);
                  v44 = (void *)_NRCopyLogObjectForNRUUID(v42, v52);
                  _NRLogWithArgs(v44, 16, "%s%.30s:%-4d Failed to send %@ over %@", "", "-[NRLinkDirectorMessage send]", 1066, v1, v45, v57);
                  goto LABEL_36;
                }
              }
            }
          }
          v38 = objc_msgSend(v36, "countByEnumeratingWithState:objects:count:", &v60, v65, 16);
          if (!v38)
            goto LABEL_49;
        }
      }
      v39 = 0;
LABEL_49:

      v64 = v39 & 1;
      v5 = v58;
      v2 = v59;
      goto LABEL_50;
    }
    v20 = *(id *)(v1 + 32);
    v21 = v20;
    if (v2)
    {
      if (v20)
      {
        v22 = objc_claimAutoreleasedReturnValue(objc_msgSend(v2[25], "objectForKeyedSubscript:", v20));
        if (v22)
        {
          v23 = (id *)v22;
          dispatch_assert_queue_V2(*(dispatch_queue_t *)(v22 + 104));
          v24 = objc_claimAutoreleasedReturnValue(objc_msgSend(v23[14], "allObjects"));
LABEL_29:

LABEL_30:
          v19 = (void *)v24;
          goto LABEL_31;
        }
        v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "UUIDString"));
        sub_1000A25C4((uint64_t)v2, 1014, CFSTR("copyPrimaryLink %@"), v31, v32, v33, v34, v35, (uint64_t)v30);

        v23 = 0;
LABEL_28:
        v24 = 0;
        goto LABEL_29;
      }
      v55 = sub_1000A2640();
      v56 = _NRLogIsLevelEnabled(v55, 17);

      if (v56)
      {
        v23 = (id *)sub_1000A2640();
        _NRLogWithArgs(v23, 17, "%s called with null nrUUID", "-[NRLinkDirector copyAllLinksForNRUUID:]");
        goto LABEL_28;
      }
    }
    v24 = 0;
    goto LABEL_30;
  }
  return result;
}

id sub_100024C54(uint64_t a1)
{
  uint32_t v1;
  size_t v2;
  void *v3;
  void *v4;
  id v5;
  id v7;
  int IsLevelEnabled;
  id v9;
  char *v10;
  int *v11;
  uint64_t v12;
  id v13;
  id v14;
  int v15;
  id v16;
  uint64_t v17;
  char *v18;
  int *v19;
  uint64_t v20;
  id v21;
  uint64_t v22;

  objc_opt_self(a1);
  v1 = arc4random_uniform(0x1770u);
  v2 = v1 + 3000;
  if (v1 == -3000)
  {
    v7 = sub_100021E2C();
    IsLevelEnabled = _NRLogIsLevelEnabled(v7, 16);

    if (IsLevelEnabled)
    {
      v9 = sub_100021E2C();
      _NRLogWithArgs(v9, 16, "%s%.30s:%-4d ABORTING: strict_malloc called with size 0", "", "strict_malloc", 74);

    }
    v2 = _os_log_pack_size(12);
    v10 = (char *)&v22 - ((__chkstk_darwin(v2) + 15) & 0xFFFFFFFFFFFFFFF0);
    v11 = __error();
    v12 = _os_log_pack_fill(v10, v2, *v11, &_mh_execute_header, "%{public}s strict_malloc called with size 0");
    *(_DWORD *)v12 = 136446210;
    *(_QWORD *)(v12 + 4) = "strict_malloc";
    v13 = sub_100021E2C();
    _NRLogAbortWithPack(v13, v10);
LABEL_7:
    v14 = sub_100021E2C();
    v15 = _NRLogIsLevelEnabled(v14, 16);

    if (v15)
    {
      v16 = sub_100021E2C();
      _NRLogWithArgs(v16, 16, "%s%.30s:%-4d ABORTING: strict_malloc(%zu) failed", "", "strict_malloc", 79, v2);

    }
    v17 = _os_log_pack_size(22);
    v18 = (char *)&v22 - ((__chkstk_darwin(v17) + 15) & 0xFFFFFFFFFFFFFFF0);
    v19 = __error();
    v20 = _os_log_pack_fill(v18, v17, *v19, &_mh_execute_header, "%{public}s strict_malloc(%zu) failed");
    *(_DWORD *)v20 = 136446466;
    *(_QWORD *)(v20 + 4) = "strict_malloc";
    *(_WORD *)(v20 + 12) = 2048;
    *(_QWORD *)(v20 + 14) = v2;
    v21 = sub_100021E2C();
    _NRLogAbortWithPack(v21, v18);
  }
  v3 = malloc_type_malloc(v1 + 3000, 0xA172743EuLL);
  if (!v3)
    goto LABEL_7;
  v4 = v3;
  arc4random_buf(v3, v2);
  v5 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", v4, v2);
  free(v4);
  return v5;
}

uint64_t sub_100024EB8(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  unsigned __int8 v5;
  unsigned __int8 v6;
  id v7;
  id v8;
  __CFString *v9;
  __CFString *v10;
  unsigned __int8 v11;
  unsigned __int8 v12;
  unsigned __int8 v13;
  id v14;
  id v15;
  __CFString *v16;
  __CFString *v17;
  id v18;
  char *v19;
  unsigned int v20;
  unsigned int v21;
  id v22;
  uint32_t v23;
  unsigned int v24;
  uint64_t v25;
  id v26;
  id v27;
  uint64_t v28;
  void *i;
  id v30;
  void *v31;
  unsigned int v32;
  id v33;
  void *v34;
  unsigned int v35;
  id v36;
  uint64_t v37;
  id v38;
  void *v39;
  _QWORD *v40;
  unsigned __int16 *v41;
  id v42;
  unsigned __int16 *v43;
  id v44;
  id v45;
  uint64_t v46;
  void *j;
  id *v48;
  id *v49;
  id v50;
  void *v51;
  uint64_t v52;
  int v53;
  id v54;
  id v55;
  id v56;
  id v57;
  unsigned int v58;
  void *v59;
  void *v60;
  uint64_t v61;
  void *k;
  void *v63;
  id v64;
  void *v65;
  _BOOL4 v66;
  unsigned __int16 *v67;
  void *v68;
  void *v69;
  uint64_t v70;
  unint64_t v71;
  unsigned __int16 *v72;
  void *v73;
  unsigned int v74;
  unsigned int v75;
  unsigned int v77;
  int v78;
  const char *v79;
  const char *v80;
  const char *v81;
  const char *v82;
  id v83;
  const char *v84;
  void *v85;
  const char *v86;
  void *v87;
  uint64_t v88;
  void *v89;
  const char *v90;
  const char *v91;
  void *v93;
  const char *v94;
  id v95;
  id v96;
  const char *v97;
  const char *v98;
  uint64_t v99;
  const char *v100;
  id v101;
  const char *v102;
  unsigned __int16 *v103;
  void *v104;
  unsigned int v105;
  id v106;
  uint32_t v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t v110;
  uint64_t v111;
  _QWORD *v112;
  void *v113;
  id v114;
  unsigned int v115;
  void *v116;
  void *v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  _BYTE v130[128];
  _BYTE v131[128];
  _BYTE v132[128];

  v112 = a2;
  objc_opt_self(a1);
  v3 = sub_100024C54((uint64_t)NRLinkDirectorMessage);
  v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  objc_opt_self(NRLinkDirectorMessage);
  LOBYTE(a1) = arc4random_uniform(0x100u);
  v5 = arc4random_uniform(0x100u);
  v6 = arc4random_uniform(0x100u);
  v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%u.%u.%u.%u"), arc4random_uniform(0x100u), v6, v5, a1);
  objc_opt_self(NRIKEv2Listener);
  if (qword_1001E44D8 != -1)
    dispatch_once(&qword_1001E44D8, &stru_1001B5E70);
  v8 = (id)qword_1001E44D0;
  if (v8)
    v9 = CFSTR("62743");
  else
    v9 = 0;
  v10 = v9;
  v117 = (void *)objc_claimAutoreleasedReturnValue(+[NWAddressEndpoint endpointWithHostname:port:](NWAddressEndpoint, "endpointWithHostname:port:", v7, v10));

  objc_opt_self(NRLinkDirectorMessage);
  v11 = arc4random_uniform(0x100u);
  v12 = arc4random_uniform(0x100u);
  v13 = arc4random_uniform(0x100u);
  v14 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("fd74::%u.%u.%u.%u"), arc4random_uniform(0x100u), v13, v12, v11);
  objc_opt_self(NRIKEv2Listener);
  if (qword_1001E44D8 != -1)
    dispatch_once(&qword_1001E44D8, &stru_1001B5E70);
  v15 = (id)qword_1001E44D0;
  if (v15)
    v16 = CFSTR("62743");
  else
    v16 = 0;
  v17 = v16;
  v116 = (void *)objc_claimAutoreleasedReturnValue(+[NWAddressEndpoint endpointWithHostname:port:](NWAddressEndpoint, "endpointWithHostname:port:", v14, v17));

  v107 = arc4random() & 1;
  v18 = v4;
  objc_opt_self(NRLinkDirectorMessage);
  v114 = objc_alloc_init((Class)NSMutableArray);
  v19 = (char *)objc_msgSend(v18, "bytes");
  v113 = v18;
  v20 = objc_msgSend(v18, "length");
  v21 = 0;
  do
  {
    do
      v23 = arc4random() % 0x64;
    while (!v23);
    v24 = v23 + v21;
    if (v23 + v21 <= v20)
      v25 = v23;
    else
      v25 = v20 - v21;
    if ((_DWORD)v25)
    {
      v22 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", v19, v25);
      objc_msgSend(v114, "addObject:", v22);

    }
    else
    {
      v25 = 0;
    }
    v19 += v25;
    v21 = v24;
  }
  while (v24 <= v20);

  v124 = 0u;
  v125 = 0u;
  v122 = 0u;
  v123 = 0u;
  v26 = objc_msgSend(v114, "countByEnumeratingWithState:objects:count:", &v122, v131, 16);
  if (v26)
  {
    v27 = v26;
    v28 = *(_QWORD *)v123;
    do
    {
      for (i = 0; i != v27; i = (char *)i + 1)
      {
        if (*(_QWORD *)v123 != v28)
          objc_enumerationMutation(v114);
        sub_1000231F8((uint64_t)v112, 255, *(void **)(*((_QWORD *)&v122 + 1) + 8 * (_QWORD)i));
      }
      v27 = objc_msgSend(v114, "countByEnumeratingWithState:objects:count:", &v122, v131, 16);
    }
    while (v27);
  }
  objc_opt_self(NRIKEv2Listener);
  if (qword_1001E44D8 != -1)
    dispatch_once(&qword_1001E44D8, &stru_1001B5E70);
  v30 = (id)qword_1001E44D0;
  v31 = v30;
  if (v112)
  {
    if (v30)
      v32 = 62743;
    else
      v32 = 0;
    sub_1000236E0((uint64_t)v112, v117, v32, 0);
  }

  objc_opt_self(NRIKEv2Listener);
  if (qword_1001E44D8 != -1)
    dispatch_once(&qword_1001E44D8, &stru_1001B5E70);
  v33 = (id)qword_1001E44D0;
  v34 = v33;
  if (v112)
  {
    if (v33)
      v35 = 62743;
    else
      v35 = 0;
    sub_1000236E0((uint64_t)v112, v116, v35, 0);

    v132[0] = v107 == 0;
    v36 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", v132, 1);
    sub_1000231F8((uint64_t)v112, 5, v36);

    sub_1000231F8((uint64_t)v112, 1, 0);
    v110 = *((unsigned __int8 *)v112 + 10);
    v109 = sub_100021BEC((uint64_t)v112);
    v38 = sub_10002461C((uint64_t)v112, v37);
    v39 = (void *)v112[4];
  }
  else
  {

    v109 = 0;
    v110 = 0;
    v38 = 0;
    v39 = 0;
  }
  v40 = (_QWORD *)sub_100022CD4((uint64_t)NRLinkDirectorMessage, v38, v39);
  v41 = sub_1000238A4(v40, 255);
  objc_opt_self(NRLinkDirectorMessage);
  v42 = objc_alloc_init((Class)NSMutableData);
  v126 = 0u;
  v127 = 0u;
  v128 = 0u;
  v129 = 0u;
  v43 = v41;
  v44 = objc_msgSend(v43, "countByEnumeratingWithState:objects:count:", &v126, v132, 16);
  if (v44)
  {
    v45 = v44;
    v46 = *(_QWORD *)v127;
    do
    {
      for (j = 0; j != v45; j = (char *)j + 1)
      {
        if (*(_QWORD *)v127 != v46)
          objc_enumerationMutation(v43);
        objc_msgSend(v42, "appendData:", *(_QWORD *)(*((_QWORD *)&v126 + 1) + 8 * (_QWORD)j));
      }
      v45 = objc_msgSend(v43, "countByEnumeratingWithState:objects:count:", &v126, v132, 16);
    }
    while (v45);
  }

  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v48 = (id *)(id)qword_1001E4708;
  v49 = v48;
  if (v48)
  {
    v50 = v48[6];
    v51 = v50;
    if (v50 && (v52 = *((_QWORD *)v50 + 13)) != 0)
      v53 = *(_DWORD *)(v52 + 12);
    else
      v53 = 0;
  }
  else
  {
    v51 = 0;
    v53 = 0;
  }
  v103 = v43;
  v104 = v38;
  if (v40)
    v54 = sub_1000243F8(v40, v53, 0);
  else
    v54 = 0;
  v111 = (uint64_t)v40;

  v120 = 0u;
  v121 = 0u;
  v118 = 0u;
  v119 = 0u;
  v55 = v54;
  v56 = objc_msgSend(v55, "countByEnumeratingWithState:objects:count:", &v118, v130, 16);
  if (v56)
  {
    v57 = v56;
    v58 = 0;
    v115 = 0;
    v59 = 0;
    v60 = 0;
    v61 = *(_QWORD *)v119;
    while (1)
    {
      for (k = 0; k != v57; k = (char *)k + 1)
      {
        if (*(_QWORD *)v119 != v61)
          objc_enumerationMutation(v55);
        v65 = *(void **)(*((_QWORD *)&v118 + 1) + 8 * (_QWORD)k);
        if (objc_msgSend(v65, "addressFamily") == (id)2)
        {
          v58 = objc_msgSend(v65, "isEqual:", v117);
          v63 = v59;
          v59 = v65;
LABEL_61:
          v64 = v65;

          continue;
        }
        if (objc_msgSend(v65, "addressFamily") == (id)30)
        {
          v115 = objc_msgSend(v65, "isEqual:", v116);
          v63 = v60;
          v60 = v65;
          goto LABEL_61;
        }
      }
      v57 = objc_msgSend(v55, "countByEnumeratingWithState:objects:count:", &v118, v130, 16);
      if (!v57)
        goto LABEL_69;
    }
  }
  v58 = 0;
  v115 = 0;
  v59 = 0;
  v60 = 0;
LABEL_69:

  v66 = v111;
  if (v111)
  {
    v67 = sub_1000238A4((_QWORD *)v111, 5);
    v68 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v67, "firstObject"));

    if (v68 && objc_msgSend(v68, "length"))
    {
      v132[0] = 0;
      objc_msgSend(v68, "getBytes:length:", v132, 1);
      if ((v132[0] & 1) != 0)
        v69 = &__kCFBooleanTrue;
      else
        v69 = &__kCFBooleanFalse;
    }
    else
    {
      v69 = 0;
    }

  }
  else
  {
    v69 = 0;
  }
  v106 = objc_msgSend(v69, "BOOLValue");

  v108 = v107 ^ 1;
  if (v111)
  {
    v70 = *(unsigned __int8 *)(v111 + 10);
    v71 = sub_100021BEC(v111);
    v72 = sub_1000238A4((_QWORD *)v111, 1);
    v73 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v72, "firstObject"));

    v66 = v73 != 0;
  }
  else
  {
    v71 = 0;
    v70 = 0;
  }
  v74 = objc_msgSend(v42, "isEqualToData:", v113);
  v75 = v74;
  if ((_DWORD)v70 == (_DWORD)v110 && v71 == v109)
    v77 = v74;
  else
    v77 = 0;
  v78 = v77 & v58 & v115 & v66;
  if ((_DWORD)v108 != (_DWORD)v106)
    v78 = 0;
  v105 = v78;
  if (qword_1001E45B0 != -1)
    dispatch_once(&qword_1001E45B0, &stru_1001B6498);
  if (_NRLogIsLevelEnabled(qword_1001E45A8, 0))
  {
    if (qword_1001E45B0 != -1)
      dispatch_once(&qword_1001E45B0, &stru_1001B6498);
    v79 = "FAILED to";
    if (v105)
      v79 = "Successfully";
    v102 = v79;
    if ((_DWORD)v70 == (_DWORD)v110)
      v80 = "Matched";
    else
      v80 = "Not matched";
    v99 = v70;
    v100 = v80;
    if (v71 == v109)
      v81 = "Matched";
    else
      v81 = "Not matched";
    if (v75)
      v82 = "Matched";
    else
      v82 = "Not matched";
    v97 = v82;
    v98 = v81;
    v101 = (id)qword_1001E45A8;
    v96 = objc_msgSend(v113, "length");
    v83 = objc_msgSend(v42, "length");
    if ((v58 & 1) != 0)
      v84 = "Matched";
    else
      v84 = "Not matched";
    v94 = v84;
    v95 = v83;
    v93 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v117, "hostname"));
    v85 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v59, "hostname"));
    if ((v115 & 1) != 0)
      v86 = "Matched";
    else
      v86 = "Not matched";
    v87 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v116, "hostname"));
    v88 = objc_claimAutoreleasedReturnValue(objc_msgSend(v60, "hostname"));
    v89 = (void *)v88;
    if ((_DWORD)v108 == (_DWORD)v106)
      v90 = "Matched";
    else
      v90 = "Not matched";
    if (v66)
      v91 = "Matched";
    else
      v91 = "Not matched";
    _NRLogWithArgs(v101, 0, "%s%.30s:%-4d %s verified NRLinkDirectorMessage: vers=%s(%u/%u), id=%s(%llu/%llu),data=%s(%zu/%zu), ipv4=%s(%@/%@), ipv6=%s(%@/%@), preferWiFi=%s(%u/%u), hello=%s", "", "+[NRLinkDirectorMessage testMessage:]", 1222, v102, v100, v110, v99, v98, v109, v71, v97, v96, v95, v94, v93,
      v85,
      v86,
      v87,
      v88,
      v90,
      v108,
      v106,
      v91);

  }
  return v105;
}

void sub_1000259E4(uint64_t a1, void *a2)
{
  void *v3;
  void *v4;
  id v5;

  v5 = a2;
  objc_opt_self(a1);
  objc_opt_self(NRLinkDirectorMessageManager);
  if (qword_1001E45A0 != -1)
    dispatch_once(&qword_1001E45A0, &stru_1001B6438);
  v3 = v5;
  if (qword_1001E4598)
  {
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(qword_1001E4598 + 16), "objectForKeyedSubscript:", v5));
    objc_msgSend(v4, "removeAllObjects");

    v3 = v5;
  }

}

void sub_100029434(id *a1)
{
  id v2;
  NSObject *v3;
  id v4;
  __CFString *v5;
  id v6;
  id v7;
  NSObject *v8;
  id v9;
  id v10;
  _QWORD v11[4];
  id v12;
  id v13;
  id v14;
  id *v15;

  if (a1)
    v2 = a1[3];
  else
    v2 = 0;
  v3 = v2;
  dispatch_assert_queue_V2(v3);

  if (a1[10])
  {
    v4 = sub_1001380F8((uint64_t)NRDLocalDevice);
    if (objc_msgSend(v4, "count"))
    {
      v5 = sub_100124B48(v4);
      objc_msgSend(a1, "reportEvent:details:", 4009, v5);

      v6 = a1[10];
      v7 = a1[3];
      if (qword_1001E48E8 != -1)
        dispatch_once(&qword_1001E48E8, &stru_1001B7D00);
      v8 = (id)qword_1001E48F0;
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 3221225472;
      v11[2] = sub_1000295BC;
      v11[3] = &unk_1001B7898;
      v12 = v6;
      v13 = v4;
      v14 = v7;
      v15 = a1;
      v9 = v7;
      v10 = v6;
      dispatch_async(v8, v11);

    }
    else
    {
      objc_msgSend(a1, "reportEvent:", 4011);
      sub_100029644((uint64_t)a1);
    }

  }
}

void sub_1000295BC(uint64_t a1)
{
  void *v2;
  NSObject *v3;
  id v4;
  _QWORD v5[5];
  id v6;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "retrievePeripheralsWithIdentifiers:", *(_QWORD *)(a1 + 40)));
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_100029878;
  v5[3] = &unk_1001B8778;
  v3 = *(NSObject **)(a1 + 48);
  v5[4] = *(_QWORD *)(a1 + 56);
  v6 = v2;
  v4 = v2;
  dispatch_async(v3, v5);

}

void sub_100029644(uint64_t a1)
{
  void *v2;
  NSObject *v3;
  id v4;
  id v5;
  id v6;
  uint64_t v7;
  void *i;
  void *v9;
  void *v10;
  void *v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _BYTE v16[128];

  if (a1)
    v2 = *(void **)(a1 + 24);
  else
    v2 = 0;
  v3 = v2;
  dispatch_assert_queue_V2(v3);

  if (*(_QWORD *)(a1 + 80))
  {
    v14 = 0u;
    v15 = 0u;
    v12 = 0u;
    v13 = 0u;
    v4 = *(id *)(a1 + 88);
    v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
    if (v5)
    {
      v6 = v5;
      v7 = *(_QWORD *)v13;
      do
      {
        for (i = 0; i != v6; i = (char *)i + 1)
        {
          if (*(_QWORD *)v13 != v7)
            objc_enumerationMutation(v4);
          v9 = *(void **)(*((_QWORD *)&v12 + 1) + 8 * (_QWORD)i);
          sub_1000297B8((id *)a1, v9);
          v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "description", (_QWORD)v12));
          objc_msgSend((id)a1, "reportEvent:details:", 4008, v10);

        }
        v6 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
      }
      while (v6);
    }

    v11 = *(void **)(a1 + 88);
    *(_QWORD *)(a1 + 88) = 0;

  }
}

void sub_1000297B8(id *a1, void *a2)
{
  id v3;
  NSObject *v4;
  BOOL v5;
  void *v6;
  id v7;

  v3 = a2;
  if (a1)
  {
    v7 = v3;
    v4 = a1[3];
    dispatch_assert_queue_V2(v4);

    v3 = v7;
    if (v7)
    {
      if (a1[10])
      {
        if (objc_msgSend(v7, "state") == (id)1 || (v5 = objc_msgSend(v7, "state") == (id)2, v3 = v7, v5))
        {
          v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "description"));
          objc_msgSend(a1, "reportEvent:details:", 4003, v6);

          objc_msgSend(a1[10], "cancelPeripheralConnection:", v7);
          v3 = v7;
        }
      }
    }
  }

}

void sub_100029878(uint64_t a1)
{
  _QWORD *v2;
  NSObject *v3;
  id v4;
  _QWORD *v5;
  char **v6;
  id v7;
  id v8;
  uint64_t v9;
  void *i;
  void *v11;
  void *v12;
  unsigned __int8 v13;
  id *v14;
  _QWORD *v15;
  id *v16;
  __CFString *v17;
  _QWORD *v18;
  _QWORD *v19;
  id v20;
  id v21;
  char v22;
  uint64_t v23;
  void *j;
  void *v25;
  void *v26;
  unsigned __int8 v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t v33;
  id v34;
  void *v35;
  void *v36;
  uint64_t v37;
  uint64_t v38;
  void *v39;
  _QWORD *obj;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  _BYTE v49[128];
  _BYTE v50[128];

  v2 = *(_QWORD **)(a1 + 32);
  if (v2)
    v2 = (_QWORD *)v2[3];
  v3 = v2;
  dispatch_assert_queue_V2(v3);

  v4 = sub_1001380F8((uint64_t)NRDLocalDevice);
  v5 = *(_QWORD **)(a1 + 32);
  v6 = &selRef_terminateDataSession_completionHandler_;
  if (v5)
    v5 = (_QWORD *)v5[11];
  v45 = 0u;
  v46 = 0u;
  v47 = 0u;
  v48 = 0u;
  obj = v5;
  v7 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v45, v50, 16);
  if (v7)
  {
    v8 = v7;
    v9 = *(_QWORD *)v46;
    do
    {
      for (i = 0; i != v8; i = (char *)i + 1)
      {
        if (*(_QWORD *)v46 != v9)
          objc_enumerationMutation(obj);
        v11 = *(void **)(*((_QWORD *)&v45 + 1) + 8 * (_QWORD)i);
        v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "identifier"));
        v13 = objc_msgSend(v4, "containsObject:", v12);

        if ((v13 & 1) == 0)
          sub_1000297B8(*(id **)(a1 + 32), v11);
      }
      v8 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v45, v50, 16);
    }
    while (v8);
  }
  v14 = *(id **)(a1 + 32);
  if (v14)
  {
    objc_storeStrong(v14 + 11, *(id *)(a1 + 40));
    v15 = *(_QWORD **)(a1 + 32);
    if (v15)
      v14 = (id *)v15[11];
    else
      v14 = 0;
  }
  else
  {
    v15 = 0;
  }
  v16 = v14;
  v17 = sub_100124B48(v16);
  objc_msgSend(v15, "reportEvent:details:", 4010, v17);

  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v18 = *(_QWORD **)(a1 + 32);
  if (v18)
    v18 = (_QWORD *)v18[11];
  v19 = v18;
  v20 = objc_msgSend(v19, "countByEnumeratingWithState:objects:count:", &v41, v49, 16);
  if (v20)
  {
    v21 = v20;
    v22 = 0;
    v23 = *(_QWORD *)v42;
    while (1)
    {
      for (j = 0; j != v21; j = (char *)j + 1)
      {
        if (*(_QWORD *)v42 != v23)
          objc_enumerationMutation(v19);
        v25 = *(void **)(*((_QWORD *)&v41 + 1) + 8 * (_QWORD)j);
        v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v25, "identifier"));
        v27 = objc_msgSend(v4, "containsObject:", v26);

        if ((v27 & 1) != 0)
        {
          if (objc_msgSend(v25, "state") == (id)1 || objc_msgSend(v25, "state") == (id)2)
          {
            v22 = 1;
            continue;
          }
          v28 = *(void **)(a1 + 32);
          v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v25, "description"));
          objc_msgSend(v28, "reportEvent:details:", 4000, v29);

          v30 = *(_QWORD *)(a1 + 32);
          if (v30)
            v31 = *(void **)(v30 + 80);
          else
            v31 = 0;
          objc_msgSend(v31, "connectPeripheral:options:", v25, 0);
          v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](NSDate, "date"));
          v33 = *(_QWORD *)(a1 + 32);
          if (v33)
            objc_storeStrong((id *)(v33 + 152), v32);
          v22 = 1;
        }
        else
        {
          if (qword_1001E45C0 != -1)
            dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
          if (_NRLogIsLevelEnabled(qword_1001E45B8, 0))
          {
            if (qword_1001E45C0 != -1)
              dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
            v34 = (id)qword_1001E45B8;
            v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v25, "description"));
            _NRLogWithArgs(v34, 0, "%s%.30s:%-4d Skipping over peripheral %@, as it is no longer enabled", "", "-[NRLinkManagerBluetooth connectToPeripherals]_block_invoke_2", 519, v35);

          }
          v36 = *(void **)(a1 + 32);
          v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v25, "description"));
          objc_msgSend(v36, "reportEvent:details:", 4006, v32);
        }

      }
      v21 = objc_msgSend(v19, "countByEnumeratingWithState:objects:count:", &v41, v49, 16);
      if (!v21)
      {

        v6 = &selRef_terminateDataSession_completionHandler_;
        if ((v22 & 1) != 0)
          goto LABEL_49;
        goto LABEL_47;
      }
    }
  }

LABEL_47:
  v37 = *(_QWORD *)(a1 + 32);
  if (v37)
  {
    v38 = *((int *)v6 + 803);
    v39 = *(void **)(v37 + v38);
    *(_QWORD *)(v37 + v38) = 0;

  }
LABEL_49:

}

void sub_100029CDC(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001E45B8;
  qword_1001E45B8 = (uint64_t)v1;

}

void sub_100029D0C(uint64_t a1)
{
  void *v2;
  NSObject *v3;
  uint64_t v4;
  dispatch_time_t v5;
  NSObject *v6;
  _QWORD v7[6];

  if (a1)
    v2 = *(void **)(a1 + 24);
  else
    v2 = 0;
  v3 = v2;
  dispatch_assert_queue_V2(v3);

  if (*(_QWORD *)(a1 + 80)
    && sub_100029E2C(a1)
    && (*(_BYTE *)(a1 + 39) == 2 || *(_BYTE *)(a1 + 45) == 2)
    && !objc_msgSend(*(id *)(a1 + 56), "count"))
  {
    v4 = *(_QWORD *)(a1 + 96) + 1;
    *(_QWORD *)(a1 + 96) = v4;
    v5 = dispatch_time(0x8000000000000000, 5000000000);
    v6 = *(id *)(a1 + 24);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    v7[2] = sub_100029F54;
    v7[3] = &unk_1001B74F8;
    v7[4] = a1;
    v7[5] = v4;
    dispatch_after(v5, v6, v7);

  }
}

uint64_t sub_100029E2C(uint64_t a1)
{
  NSObject *v2;
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  _BYTE v12[128];

  if (!a1)
    return 0;
  v2 = *(id *)(a1 + 24);
  dispatch_assert_queue_V2(v2);

  v10 = 0u;
  v11 = 0u;
  v8 = 0u;
  v9 = 0u;
  v3 = *(id *)(a1 + 88);
  v4 = (uint64_t)objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v8, v12, 16);
  if (v4)
  {
    v5 = *(_QWORD *)v9;
    while (2)
    {
      for (i = 0; i != v4; ++i)
      {
        if (*(_QWORD *)v9 != v5)
          objc_enumerationMutation(v3);
        if (objc_msgSend(*(id *)(*((_QWORD *)&v8 + 1) + 8 * i), "state", (_QWORD)v8) == (id)2)
        {
          v4 = 1;
          goto LABEL_12;
        }
      }
      v4 = (uint64_t)objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v8, v12, 16);
      if (v4)
        continue;
      break;
    }
  }
LABEL_12:

  return v4;
}

void sub_100029F54(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  uint64_t v5;
  CFIndex AppIntegerValue;
  uint64_t v7;
  _BOOL4 v8;
  const char *v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  NRAnalyticsLinkManagerBluetooth *v13;
  NRAnalyticsLinkManagerBluetooth *v14;
  Boolean keyExistsAndHasValidFormat;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(v2 + 96);
  if (v3)
    v4 = *(_QWORD *)(a1 + 40) == v3;
  else
    v4 = 0;
  if (v4 && sub_100029E2C(v2))
  {
    v5 = *(_QWORD *)(a1 + 32);
    if (v5)
    {
      if (*(_BYTE *)(v5 + 39) == 2 || *(_BYTE *)(v5 + 45) == 2 || objc_msgSend(*(id *)(v5 + 56), "count"))
        return;
    }
    else if (objc_msgSend(0, "count"))
    {
      return;
    }
    keyExistsAndHasValidFormat = 0;
    AppIntegerValue = CFPreferencesGetAppIntegerValue(CFSTR("EnableNRBTLMBackwardsCompatibility"), CFSTR("Apple Global Domain"), &keyExistsAndHasValidFormat);
    if (qword_1001E45C0 != -1)
      dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
    if (_NRLogIsLevelEnabled(qword_1001E45B8, 0))
    {
      if (qword_1001E45C0 != -1)
        dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
      _NRLogWithArgs(qword_1001E45B8, 0, "%s%.30s:%-4d Allows switching endpoint types: %d", "", "-[NRLinkManagerBluetooth startBluetoothWatchdog]_block_invoke", 618, AppIntegerValue == 1);
    }
    v7 = *(_QWORD *)(a1 + 32);
    if (AppIntegerValue == 1)
    {
      if (v7)
      {
        v8 = *(_BYTE *)(v7 + 36) != 0;
        *(_BYTE *)(v7 + 36) = *(_BYTE *)(v7 + 36) == 0;
      }
      else
      {
        v8 = 0;
      }
      if (qword_1001E45C0 != -1)
        dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
      if (_NRLogIsLevelEnabled(qword_1001E45B8, 0))
      {
        if (qword_1001E45C0 != -1)
          dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
        v9 = "LEGACY";
        if (v8)
          v10 = "NEW";
        else
          v10 = "LEGACY";
        v11 = *(_QWORD *)(a1 + 32);
        if (v11 && *(_BYTE *)(v11 + 36))
          v9 = "NEW";
        _NRLogWithArgs(qword_1001E45B8, 0, "%s%.30s:%-4d Switching endpoint types: %s -> %s", "", "-[NRLinkManagerBluetooth startBluetoothWatchdog]_block_invoke", 625, v10, v9);
      }
      v7 = *(_QWORD *)(a1 + 32);
      if ((*(_WORD *)(v7 + 39) & 0x800) == 0)
      {
        objc_msgSend(*(id *)(a1 + 32), "reportEvent:", 4214);
        *(_BYTE *)(v7 + 40) |= 8u;
        sub_10002A358(v7, 1, 0);
        v7 = *(_QWORD *)(a1 + 32);
      }
    }
    *(_QWORD *)(v7 + 96) = 0;
    objc_msgSend(*(id *)(a1 + 32), "reportEvent:", 4900);
    v12 = *(_QWORD *)(a1 + 32);
    if (*(_BYTE *)(v12 + 35))
    {
      if (qword_1001E45C0 != -1)
        dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
      if (_NRLogIsLevelEnabled(qword_1001E45B8, 16))
      {
        if (qword_1001E45C0 != -1)
          dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
        _NRLogWithArgs(qword_1001E45B8, 16, "%s%.30s:%-4d no BT callbacks received for pipe connect, sim crash already generated", "", "-[NRLinkManagerBluetooth startBluetoothWatchdog]_block_invoke", 633);
      }
    }
    else
    {
      *(_BYTE *)(v12 + 35) = 1;
      if (qword_1001E45C0 != -1)
        dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
      if (_NRLogIsLevelEnabled(qword_1001E45B8, 17))
      {
        if (qword_1001E45C0 != -1)
          dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
        _NRLogWithArgs(qword_1001E45B8, 17, "no BT callback received for pipe connect even after %llus of pipe registration", 5);
      }
      v13 = objc_alloc_init(NRAnalyticsLinkManagerBluetooth);
      v14 = v13;
      if (v13)
        v13->_noBTPipeCallbacks = 1;
      -[NRAnalyticsLinkManagerBluetooth submit](v13, "submit");

    }
  }
}

void sub_10002A358(uint64_t a1, uint64_t a2, int a3)
{
  NSObject *v6;
  int *v7;
  const __CFString *v8;

  if (!a1)
    return;
  v6 = *(id *)(a1 + 24);
  dispatch_assert_queue_V2(v6);

  if (a2 == 3)
  {
    if (a3)
    {
      *(_BYTE *)(a1 + 50) &= ~2u;
      if (*(unsigned __int8 *)(a1 + 49) - 1 > 1)
        return;
      goto LABEL_14;
    }
    *(_BYTE *)(a1 + 44) &= ~2u;
    if (*(unsigned __int8 *)(a1 + 43) - 1 > 1)
      return;
    goto LABEL_25;
  }
  if (a2 == 2)
  {
    if (a3)
    {
      *(_BYTE *)(a1 + 48) &= ~2u;
      if (*(unsigned __int8 *)(a1 + 47) - 1 > 1)
        return;
      objc_msgSend((id)a1, "reportEvent:detailsFormat:", 4206, CFSTR("%s %s"), "High", "p2pPipe");
      v7 = &OBJC_IVAR___NRLinkManagerBluetooth__p2pPipeRegistrationForHigh;
      v8 = CFSTR("com.apple.terminusLink.urgent.p2p");
    }
    else
    {
      *(_BYTE *)(a1 + 42) &= ~2u;
      if (*(unsigned __int8 *)(a1 + 41) - 1 > 1)
        return;
      objc_msgSend((id)a1, "reportEvent:detailsFormat:", 4206, CFSTR("%s %s"), "High", "pipe");
      v7 = &OBJC_IVAR___NRLinkManagerBluetooth__pipeRegistrationForHigh;
      v8 = CFSTR("com.apple.terminusLink.urgent");
    }
    goto LABEL_28;
  }
  if (a2 != 1)
    return;
  if (!a3)
  {
    *(_BYTE *)(a1 + 40) &= ~2u;
    if (*(unsigned __int8 *)(a1 + 39) - 1 <= 1)
    {
      objc_msgSend((id)a1, "reportEvent:detailsFormat:", 4206, CFSTR("%s %s"), "Medium", "pipe");
      objc_msgSend(*(id *)(a1 + 64), "unregisterEndpoint:", CFSTR("com.apple.terminusLink"));
      *(_BYTE *)(a1 + 39) = 3;
    }
    *(_BYTE *)(a1 + 42) &= ~2u;
    if (*(unsigned __int8 *)(a1 + 41) - 1 <= 1)
    {
      objc_msgSend((id)a1, "reportEvent:detailsFormat:", 4206, CFSTR("%s %s"), "High", "pipe");
      objc_msgSend(*(id *)(a1 + 64), "unregisterEndpoint:", CFSTR("com.apple.terminusLink.urgent"));
      *(_BYTE *)(a1 + 41) = 3;
    }
    *(_BYTE *)(a1 + 44) &= ~2u;
    if (*(unsigned __int8 *)(a1 + 43) - 1 > 1)
      return;
LABEL_25:
    objc_msgSend((id)a1, "reportEvent:detailsFormat:", 4206, CFSTR("%s %s"), "Isochronous", "pipe");
    v7 = &OBJC_IVAR___NRLinkManagerBluetooth__pipeRegistrationForIsochronous;
    v8 = CFSTR("com.apple.terminusLink.datagram");
    goto LABEL_28;
  }
  *(_BYTE *)(a1 + 46) &= ~2u;
  if (*(unsigned __int8 *)(a1 + 45) - 1 <= 1)
  {
    objc_msgSend((id)a1, "reportEvent:detailsFormat:", 4206, CFSTR("%s %s"), "Medium", "p2pPipe");
    objc_msgSend(*(id *)(a1 + 64), "unregisterEndpoint:", CFSTR("com.apple.terminusLink.p2p"));
    *(_BYTE *)(a1 + 45) = 3;
  }
  *(_BYTE *)(a1 + 48) &= ~2u;
  if (*(unsigned __int8 *)(a1 + 47) - 1 <= 1)
  {
    objc_msgSend((id)a1, "reportEvent:detailsFormat:", 4206, CFSTR("%s %s"), "High", "p2pPipe");
    objc_msgSend(*(id *)(a1 + 64), "unregisterEndpoint:", CFSTR("com.apple.terminusLink.urgent.p2p"));
    *(_BYTE *)(a1 + 47) = 3;
  }
  *(_BYTE *)(a1 + 50) &= ~2u;
  if (*(unsigned __int8 *)(a1 + 49) - 1 <= 1)
  {
LABEL_14:
    objc_msgSend((id)a1, "reportEvent:detailsFormat:", 4206, CFSTR("%s %s"), "Isochronous", "p2pPipe");
    v7 = &OBJC_IVAR___NRLinkManagerBluetooth__p2pPipeRegistrationForIsochronous;
    v8 = CFSTR("com.apple.terminusLink.datagram.p2p");
LABEL_28:
    objc_msgSend(*(id *)(a1 + 64), "unregisterEndpoint:", v8);
    *(_BYTE *)(a1 + *v7) = 3;
  }
}

void sub_10002A7C4(_QWORD *a1, uint64_t a2)
{
  id v4;

  if (a1[10])
  {
    if ((unint64_t)a2 >= 6)
      v4 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("UnknownState(%lld)"), a2);
    else
      v4 = *(&off_1001B6540 + a2);
    objc_msgSend(a1, "reportEvent:details:", 4100, v4);

    if (a2 == 5)
    {
      sub_100029434((id *)a1);
    }
    else if (a2 <= 3)
    {
      sub_100029644((uint64_t)a1);
    }
  }
}

id sub_10002A890()
{
  if (qword_1001E45C0 != -1)
    dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
  return (id)qword_1001E45B8;
}

void sub_10002A8D0(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  NRCBScalablePipeState *v6;
  NRCBScalablePipeState *v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  BOOL v12;
  unint64_t v13;
  NRAnalyticsLinkManagerBluetooth *v14;
  NRAnalyticsLinkManagerBluetooth *v15;
  id v16;
  int IsLevelEnabled;
  uint64_t v18;
  void *v19;

  v3 = a2;
  v4 = v3;
  if (a1)
  {
    if (!v3)
    {
      v19 = 0;
      v16 = sub_10002A890();
      IsLevelEnabled = _NRLogIsLevelEnabled(v16, 17);

      v4 = 0;
      if (!IsLevelEnabled)
        goto LABEL_26;
      v7 = (NRCBScalablePipeState *)sub_10002A890();
      _NRLogWithArgs(v7, 17, "%s called with null nrUUID", "-[NRLinkManagerBluetooth cleanupPipeStateIfNeededForNRUUID:]");
      goto LABEL_25;
    }
    v5 = *(void **)(a1 + 144);
    if (v5)
    {
      v19 = v4;
      v6 = (NRCBScalablePipeState *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", v4));
      if (v6)
      {
        v7 = v6;
        if (-[NRCBScalablePipeState state](v6, "state") == 1)
        {
          v8 = -[NRCBScalablePipeState timeOfConnect](v7, "timeOfConnect");
          v9 = mach_continuous_time();
          if (v8)
            v12 = v9 > v8;
          else
            v12 = 0;
          if (v12)
          {
            if (qword_1001E48A8 != -1)
            {
              v18 = v9;
              dispatch_once(&qword_1001E48A8, &stru_1001B7C30);
              v9 = v18;
            }
            LODWORD(v10) = dword_1001E48B0;
            LODWORD(v11) = *(_DWORD *)algn_1001E48B4;
            v13 = (unint64_t)((double)(v9 - v8) * (0.000000001 * (double)v10) / (double)v11);
          }
          else
          {
            v13 = 0;
          }
          v14 = objc_alloc_init(NRAnalyticsLinkManagerBluetooth);
          v15 = v14;
          if (v14)
            v14->_pipeConnectedDuration = v13;
          -[NRAnalyticsLinkManagerBluetooth submit](v14, "submit");

        }
        else
        {
          if (qword_1001E45C0 != -1)
            dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
          if (_NRLogIsLevelEnabled(qword_1001E45B8, 17))
          {
            if (qword_1001E45C0 != -1)
              dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
            _NRLogWithArgs(qword_1001E45B8, 17, "invalid pipe state %@", v7);
          }
        }
      }
      else
      {
        v7 = objc_alloc_init(NRCBScalablePipeState);
      }
      -[NRCBScalablePipeState setState:](v7, "setState:", 2);
      -[NRCBScalablePipeState setTimeOfDisconnect:](v7, "setTimeOfDisconnect:", mach_continuous_time());
      objc_msgSend(*(id *)(a1 + 144), "setObject:forKeyedSubscript:", v7, v19);
LABEL_25:

      v4 = v19;
    }
  }
LABEL_26:

}

void sub_10002AB14(uint64_t a1)
{
  void *v2;
  int v3;
  uint64_t v4;
  __CFString *v5;
  void *v6;
  id v7;
  id v8;
  id v9;
  unsigned int v10;
  id v11;
  void *v12;
  id v13;
  uint64_t v14;
  _UNKNOWN **v15;

  if (a1)
  {
    v2 = *(void **)(a1 + 72);
    if (v2)
    {
      v3 = *(unsigned __int8 *)(a1 + 32);
      if (v3 == 3)
      {
        if (qword_1001E45C0 != -1)
          dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
        if (_NRLogIsLevelEnabled(qword_1001E45B8, 0))
        {
          if (qword_1001E45C0 != -1)
            dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
          _NRLogWithArgs(qword_1001E45B8, 0, "%s%.30s:%-4d Ignoring start BT advertisement request, advertisement is restarting");
        }
      }
      else if (v3 == 4)
      {
        if (qword_1001E45C0 != -1)
          dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
        if (_NRLogIsLevelEnabled(qword_1001E45B8, 0))
        {
          if (qword_1001E45C0 != -1)
            dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
          _NRLogWithArgs(qword_1001E45B8, 0, "%s%.30s:%-4d Ignoring start BT advertisement request, device is already advertising");
        }
      }
      else if (objc_msgSend(v2, "state") == (id)5 && (sub_100138258((uint64_t)NRDLocalDevice) & 1) != 0)
      {
        *(_BYTE *)(a1 + 33) = 0;
        v4 = *(unsigned __int8 *)(a1 + 33);
        if (*(_BYTE *)(a1 + 33))
        {
          if ((_DWORD)v4 == 1)
            v5 = CFSTR("1 sec");
          else
            v5 = (__CFString *)objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("UnknownType(%lld)"), v4);
        }
        else
        {
          v5 = CFSTR("Default");
        }
        objc_msgSend((id)a1, "reportEvent:details:", 3501, v5);

        v11 = *(id *)(a1 + 72);
        if (*(_BYTE *)(a1 + 33) == 1)
        {
          v14 = CBPeripheralManagerAdvertisingInterval;
          v15 = &off_1001C4648;
          v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v15, &v14, 1));
        }
        else
        {
          v12 = 0;
        }
        objc_msgSend(v11, "startAdvertising:", v12);

        *(_BYTE *)(a1 + 32) = 1;
      }
      else
      {
        if (qword_1001E45C0 != -1)
          dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
        if (_NRLogIsLevelEnabled(qword_1001E45B8, 0))
        {
          if (qword_1001E45C0 != -1)
            dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
          v6 = (void *)qword_1001E45B8;
          v7 = *(id *)(a1 + 72);
          v13 = v6;
          v8 = objc_msgSend(v7, "state");
          if ((unint64_t)v8 >= 6)
            v9 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("UnknownState(%lld)"), v8);
          else
            v9 = *(&off_1001B6540 + (_QWORD)v8);
          v10 = sub_100138258((uint64_t)NRDLocalDevice);
          _NRLogWithArgs(v13, 0, "%s%.30s:%-4d Ignoring start BT advertisement request, device cannot start advertising (%@/%d)", "", "-[NRLinkManagerBluetooth startBTAdvertisement]", 1600, v9, v10);

        }
      }
    }
  }
}

void sub_10002AF0C(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  id *v4;
  id v5;
  void *v6;
  NSObject *v7;
  void *v8;
  void *v9;
  id v10;
  id v11;
  id v12;
  char *v13;
  id v14;
  unsigned __int8 v15;
  id v16;
  id v17;
  id v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  id v23;
  unsigned int v24;
  id v25;
  id v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  id v31;
  unsigned int v32;
  id v33;
  id v34;
  id v35;
  id v36;
  id v37;
  void *v38;
  uint64_t v39;
  void *v40;
  uint64_t v41;
  void *v42;
  void *v43;
  unsigned int v44;
  id v45;
  int8x8_t v46;
  id v47;
  void *v48;
  void *v49;
  id v50;
  id WeakRetained;
  id v52;
  NRLinkBluetooth *v53;
  id v54;
  id v55;
  char *v56;
  id v57;
  id v58;
  id v59;
  id v60;
  id v61;
  NRCBScalablePipeState *v62;
  char *v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  NRAnalyticsLinkManagerBluetooth *v70;
  NRAnalyticsLinkManagerBluetooth *v71;
  id v72;
  id v73;
  id v74;
  id v75;
  int IsLevelEnabled;
  id v77;
  int v78;
  id v79;
  id v80;
  int v81;
  id v82;
  char *v83;
  void *v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  _BYTE v89[128];
  int8x16_t v90;
  int8x16_t v91;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
    v3 = *(void **)(v2 + 104);
  else
    v3 = 0;
  if (objc_msgSend(v3, "containsObject:", *(_QWORD *)(a1 + 40)))
  {
    v4 = *(id **)(a1 + 32);
    v5 = *(id *)(a1 + 40);
    v6 = v5;
    if (!v4)
    {
LABEL_94:

      return;
    }
    if (!v5)
    {
      if (qword_1001E45C0 != -1)
        dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
      v75 = (id)qword_1001E45B8;
      IsLevelEnabled = _NRLogIsLevelEnabled(v75, 17);

      if (!IsLevelEnabled)
        goto LABEL_94;
      if (qword_1001E45C0 != -1)
        dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
      v12 = (id)qword_1001E45B8;
      _NRLogWithArgs(v12, 17, "%s called with null pipe", "-[NRLinkManagerBluetooth pipeisAvailable:]");
      goto LABEL_93;
    }
    v7 = v4[3];
    dispatch_assert_queue_V2(v7);

    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "peer"));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "identifier"));

    v10 = objc_msgSend(v6, "priority");
    v11 = objc_msgSend(v6, "priority");
    v12 = v9;
    objc_opt_self(NRDLocalDevice);
    v13 = sub_100134B14((uint64_t)NRDLocalDevice, v12, 1);

    if (!v13 || !v13[9])
    {
      if (qword_1001E45C0 != -1)
        dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
      v77 = (id)qword_1001E45B8;
      v78 = _NRLogIsLevelEnabled(v77, 16);

      if (v78)
      {
        if (qword_1001E45C0 != -1)
          dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
        v79 = (id)qword_1001E45B8;
        _NRLogWithArgs(v79, 16, "%s%.30s:%-4d Not creating link for disabled device %@ with pipe %@", "", "-[NRLinkManagerBluetooth pipeisAvailable:]", 839, v13, v6);

      }
      objc_msgSend(v4, "reportEvent:detailsFormat:", 3101, CFSTR("%@ is disabled for pipe %@"), v13, v6);
      goto LABEL_92;
    }
    v14 = *((id *)v13 + 4);
    v15 = objc_msgSend(v4, "shouldCreateLinkForNRUUID:", v14);

    if ((v15 & 1) == 0)
    {
      if (qword_1001E45C0 != -1)
        dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
      if (_NRLogIsLevelEnabled(qword_1001E45B8, 16))
      {
        if (qword_1001E45C0 != -1)
          dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
        _NRLogWithArgs(qword_1001E45B8, 16, "%s%.30s:%-4d Not creating link for unsupported device %@ with pipe %@", "", "-[NRLinkManagerBluetooth pipeisAvailable:]", 844, v13, v6);
      }
      objc_msgSend(v4, "reportEvent:detailsFormat:", 3101, CFSTR("%@ is unsupported for pipe %@"), v13, v6);
      goto LABEL_92;
    }
    v84 = v6;
    if (v10 == (id)3)
    {
      v87 = 0u;
      v88 = 0u;
      v85 = 0u;
      v86 = 0u;
      v16 = v4[7];
      v17 = objc_msgSend(v16, "countByEnumeratingWithState:objects:count:", &v85, v89, 16);
      if (v17)
      {
        v18 = v17;
        v19 = *(_QWORD *)v86;
LABEL_20:
        v20 = 0;
        while (1)
        {
          if (*(_QWORD *)v86 != v19)
            objc_enumerationMutation(v16);
          v21 = *(_QWORD *)(*((_QWORD *)&v85 + 1) + 8 * v20);
          if (v21)
            v22 = *(void **)(v21 + 327);
          else
            v22 = 0;
          v23 = v22;
          if (objc_msgSend(v23, "isEqual:", v12))
          {
            v24 = objc_msgSend((id)v21, "state");

            if (v24 != 255)
            {
              v6 = v84;
              sub_1000802A0(v21, v84);

              goto LABEL_92;
            }
          }
          else
          {

          }
          if (v18 == (id)++v20)
          {
            v18 = objc_msgSend(v16, "countByEnumeratingWithState:objects:count:", &v85, v89, 16);
            if (!v18)
              break;
            goto LABEL_20;
          }
        }
      }
LABEL_46:

LABEL_91:
      v6 = v84;
LABEL_92:

LABEL_93:
      goto LABEL_94;
    }
    if (v11 == (id)2)
    {
      v87 = 0u;
      v88 = 0u;
      v85 = 0u;
      v86 = 0u;
      v16 = v4[7];
      v25 = objc_msgSend(v16, "countByEnumeratingWithState:objects:count:", &v85, v89, 16);
      if (v25)
      {
        v26 = v25;
        v27 = *(_QWORD *)v86;
LABEL_35:
        v28 = 0;
        while (1)
        {
          if (*(_QWORD *)v86 != v27)
            objc_enumerationMutation(v16);
          v29 = *(_QWORD *)(*((_QWORD *)&v85 + 1) + 8 * v28);
          if (v29)
            v30 = *(void **)(v29 + 327);
          else
            v30 = 0;
          v31 = v30;
          if (objc_msgSend(v31, "isEqual:", v12))
          {
            v32 = objc_msgSend((id)v29, "state");

            if (v32 != 255)
            {
              v6 = v84;
              sub_1000812F0((char *)v29, (char *)v84);

              goto LABEL_92;
            }
          }
          else
          {

          }
          if (v26 == (id)++v28)
          {
            v26 = objc_msgSend(v16, "countByEnumeratingWithState:objects:count:", &v85, v89, 16);
            if (!v26)
              goto LABEL_46;
            goto LABEL_35;
          }
        }
      }
      goto LABEL_46;
    }
    v33 = v4[10];
    if (v33)
    {
      v83 = v13;
      v34 = v4[11];

      if (v34)
      {
        v87 = 0u;
        v88 = 0u;
        v85 = 0u;
        v86 = 0u;
        v35 = v4[11];
        v36 = objc_msgSend(v35, "countByEnumeratingWithState:objects:count:", &v85, v89, 16);
        if (v36)
        {
          v37 = v36;
          v38 = 0;
          v39 = *(_QWORD *)v86;
LABEL_52:
          v41 = 0;
          while (1)
          {
            if (*(_QWORD *)v86 != v39)
              objc_enumerationMutation(v35);
            v42 = *(void **)(*((_QWORD *)&v85 + 1) + 8 * v41);
            v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v42, "identifier"));
            v44 = objc_msgSend(v12, "isEqual:", v43);

            if (v44)
            {
              v40 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v42, "name"));

              v38 = v40;
              if (objc_msgSend(v40, "length"))
                break;
            }
            if (v37 == (id)++v41)
            {
              v37 = objc_msgSend(v35, "countByEnumeratingWithState:objects:count:", &v85, v89, 16);
              v40 = v38;
              if (!v37)
                break;
              goto LABEL_52;
            }
          }
        }
        else
        {
          v40 = 0;
        }

        v6 = v84;
      }
      else
      {
        v40 = 0;
      }
      v13 = v83;
    }
    else
    {
      v40 = 0;
    }
    if (!objc_msgSend(v40, "length"))
    {
      v45 = objc_alloc((Class)NSString);
      v90 = 0uLL;
      objc_msgSend(v12, "getUUIDBytes:", &v90);
      v91 = v90;
      v46 = veor_s8(*(int8x8_t *)v90.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v90, v90, 8uLL));
      v91.i32[0] = v46.i32[0] ^ v46.i32[1];
      v47 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &v91, 16);
      v48 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v47, "base64EncodedStringWithOptions:", 0));
      v49 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v48, "substringToIndex:", 6));

      v50 = objc_msgSend(v45, "initWithFormat:", CFSTR("?%@"), v49);
      v40 = v50;
    }
    WeakRetained = objc_loadWeakRetained(v4 + 16);
    v52 = *((id *)v13 + 4);
    objc_msgSend(WeakRetained, "pipeDidConnectForNRUUID:nrUUID:", 1, v52);

    v53 = [NRLinkBluetooth alloc];
    v54 = v4[3];
    v55 = *((id *)v13 + 4);
    v56 = sub_10009EAD8((char *)v53, v54, v4, v55, v6, v40);

    if (!v56)
    {
      if (qword_1001E45C0 != -1)
        dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
      v80 = (id)qword_1001E45B8;
      v81 = _NRLogIsLevelEnabled(v80, 16);

      if (v81)
      {
        if (qword_1001E45C0 != -1)
          dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
        v82 = (id)qword_1001E45B8;
        _NRLogWithArgs(v82, 16, "%s%.30s:%-4d Failed to create link for device %@ with pipe %@", "", "-[NRLinkManagerBluetooth pipeisAvailable:]", 897, v13, v84);

      }
      v62 = (NRCBScalablePipeState *)objc_claimAutoreleasedReturnValue(objc_msgSend(v84, "description"));
      objc_msgSend(v4, "reportEvent:details:", 3101, v62);
      goto LABEL_90;
    }
    if (!sub_10002BA34((uint64_t)v4))
      sub_10002BC58(v4);
    v57 = v4[18];
    if (!v57)
    {
      v58 = objc_alloc_init((Class)NSMutableDictionary);
      v59 = v4[18];
      v4[18] = v58;

      v57 = v4[18];
    }
    v60 = v57;
    v61 = *((id *)v13 + 4);
    v62 = (NRCBScalablePipeState *)objc_claimAutoreleasedReturnValue(objc_msgSend(v60, "objectForKeyedSubscript:", v61));

    if (v62)
    {
      v63 = v13;
      if (-[NRCBScalablePipeState state](v62, "state") == 2)
      {
        v64 = -[NRCBScalablePipeState timeOfDisconnect](v62, "timeOfDisconnect");
        v65 = mach_continuous_time();
        v68 = 0;
        if (v64)
        {
          v69 = v65 - v64;
          if (v65 > v64)
          {
            if (qword_1001E48A8 != -1)
              dispatch_once(&qword_1001E48A8, &stru_1001B7C30);
            LODWORD(v66) = dword_1001E48B0;
            LODWORD(v67) = *(_DWORD *)algn_1001E48B4;
            v68 = (unint64_t)((double)v69 * (0.000000001 * (double)v66) / (double)v67);
          }
        }
        v70 = objc_alloc_init(NRAnalyticsLinkManagerBluetooth);
        v71 = v70;
        if (v70)
          v70->_pipeDisconnectedDuration = v68;
        -[NRAnalyticsLinkManagerBluetooth submit](v70, "submit");

      }
      else
      {
        if (qword_1001E45C0 != -1)
          dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
        if (_NRLogIsLevelEnabled(qword_1001E45B8, 17))
        {
          if (qword_1001E45C0 != -1)
            dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
          v72 = (id)qword_1001E45B8;
          _NRLogWithArgs(v72, 17, "invalid pipe state %@", v62);

          goto LABEL_89;
        }
      }
      v13 = v63;
    }
    else
    {
      v62 = objc_alloc_init(NRCBScalablePipeState);
    }
LABEL_89:
    -[NRCBScalablePipeState setState:](v62, "setState:", 1);
    -[NRCBScalablePipeState setTimeOfConnect:](v62, "setTimeOfConnect:", mach_continuous_time());
    v73 = v4[18];
    v74 = *((id *)v13 + 4);
    objc_msgSend(v73, "setObject:forKeyedSubscript:", v62, v74);

LABEL_90:
    goto LABEL_91;
  }
}

BOOL sub_10002BA34(uint64_t a1)
{
  id v2;
  id v3;
  id v4;
  id v5;
  uint64_t v6;
  void *i;
  void *v8;
  void *v9;
  void *v10;
  id v11;
  id v12;
  id v13;
  id v14;
  id v15;
  uint64_t v16;
  void *j;
  id v18;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  _BYTE v28[128];
  _BYTE v29[128];

  v2 = objc_alloc_init((Class)NSMutableSet);
  v24 = 0u;
  v25 = 0u;
  v26 = 0u;
  v27 = 0u;
  v3 = *(id *)(a1 + 104);
  v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v24, v29, 16);
  if (v4)
  {
    v5 = v4;
    v6 = *(_QWORD *)v25;
    do
    {
      for (i = 0; i != v5; i = (char *)i + 1)
      {
        if (*(_QWORD *)v25 != v6)
          objc_enumerationMutation(v3);
        v8 = *(void **)(*((_QWORD *)&v24 + 1) + 8 * (_QWORD)i);
        if (objc_msgSend(v8, "priority") == (id)1)
        {
          v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "peer"));
          v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "identifier"));
          objc_msgSend(v2, "addObject:", v10);

        }
      }
      v5 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v24, v29, 16);
    }
    while (v5);
  }

  v11 = sub_1001380F8((uint64_t)NRDLocalDevice);
  v12 = objc_msgSend(v11, "mutableCopy");
  v20 = 0u;
  v21 = 0u;
  v22 = 0u;
  v23 = 0u;
  v13 = v2;
  v14 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v20, v28, 16);
  if (v14)
  {
    v15 = v14;
    v16 = *(_QWORD *)v21;
    do
    {
      for (j = 0; j != v15; j = (char *)j + 1)
      {
        if (*(_QWORD *)v21 != v16)
          objc_enumerationMutation(v13);
        objc_msgSend(v12, "removeObject:", *(_QWORD *)(*((_QWORD *)&v20 + 1) + 8 * (_QWORD)j), (_QWORD)v20);
      }
      v15 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v20, v28, 16);
    }
    while (v15);
  }

  v18 = objc_msgSend(v12, "count");
  return v18 != 0;
}

id *sub_10002BC58(id *result)
{
  id *v1;

  if (result[9])
  {
    v1 = result;
    switch(*((_BYTE *)result + 32))
    {
      case 0:
        if (qword_1001E45C0 != -1)
          dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
        result = (id *)_NRLogIsLevelEnabled(qword_1001E45B8, 0);
        if ((_DWORD)result)
        {
          if (qword_1001E45C0 != -1)
            dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
          result = (id *)_NRLogWithArgs(qword_1001E45B8, 0, "%s%.30s:%-4d Ignoring stop BT advertisement request, device is NOT advertising");
        }
        break;
      case 1:
      case 4:
        objc_msgSend(result, "reportEvent:", 3504);
        result = (id *)objc_msgSend(v1[9], "stopAdvertising");
        goto LABEL_4;
      case 2:
        if (qword_1001E45C0 != -1)
          dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
        result = (id *)_NRLogIsLevelEnabled(qword_1001E45B8, 0);
        if ((_DWORD)result)
        {
          if (qword_1001E45C0 != -1)
            dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
          result = (id *)_NRLogWithArgs(qword_1001E45B8, 0, "%s%.30s:%-4d Ignoring stop BT advertisement request, already stopping");
        }
        break;
      default:
LABEL_4:
        *((_BYTE *)v1 + 32) = 2;
        *((_BYTE *)v1 + 33) = 0;
        break;
    }
  }
  return result;
}

void sub_10002BE24(uint64_t a1, uint64_t a2, int a3)
{
  NSObject *v6;
  uint64_t v7;
  __CFString *v8;
  int v9;
  id v10;
  id v11;
  id v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  char *v16;
  void *v17;
  id v18;
  id v19;
  void *v20;
  id v21;
  id v22;
  id v23;
  id v24;
  id v25;
  id v26;
  uint64_t v27;
  void *i;
  int v29;
  int v30;
  id v31;
  int v32;
  int v33;
  int v34;
  id v35;
  void *v36;
  id v37;
  int v38;
  id v39;
  uint64_t v40;
  id v41;
  int v42;
  id v43;
  id v44;
  int IsLevelEnabled;
  id v46;
  id v47;
  id v48;
  int v49;
  id v50;
  int v51;
  id v52;
  int v53;
  id v54;
  int v55;
  id v56;
  int v57;
  id v58;
  id v59;
  int v60;
  id v61;
  int v62;
  id v63;
  void *v64;
  id v65;
  NSNumber *v66;
  void *v67;
  void *v68;
  const __CFString *v69;
  void *v70;
  NSNumber *v71;
  void *v72;
  uint64_t v73;
  uint64_t v74;
  void *v75;
  NSNumber *v76;
  void *v77;
  NSNumber *v78;
  void *v79;
  NSNumber *v80;
  void *v81;
  NSNumber *v82;
  uint64_t v83;
  int v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  _QWORD v93[2];
  _QWORD v94[2];
  _QWORD v95[2];
  _QWORD v96[2];
  _BYTE v97[128];
  _QWORD v98[2];
  _QWORD v99[2];
  _QWORD v100[2];
  _QWORD v101[2];
  _QWORD v102[2];
  _QWORD v103[2];
  _QWORD v104[2];
  _QWORD v105[2];
  _BYTE v106[128];

  if (!a1)
    return;
  v6 = *(id *)(a1 + 24);
  dispatch_assert_queue_V2(v6);

  if (a2 == 3)
  {
    if (a3)
    {
      if ((*(_WORD *)(a1 + 49) & 0x400) == 0)
        return;
      goto LABEL_10;
    }
    if ((*(_WORD *)(a1 + 43) & 0x400) == 0)
      return;
    if (*(_BYTE *)(a1 + 36))
      v7 = 1;
    else
      v7 = 2;
LABEL_24:
    if (!*(_BYTE *)(a1 + 37))
      return;
    v84 = a3;
    v89 = 0u;
    v90 = 0u;
    v91 = 0u;
    v92 = 0u;
    v10 = sub_100137B34((uint64_t)NRDLocalDevice);
    v11 = objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v89, v106, 16);
    if (v11)
    {
      v12 = v11;
      v13 = *(_QWORD *)v90;
      v83 = v7;
LABEL_27:
      v14 = 0;
      while (1)
      {
        if (*(_QWORD *)v90 != v13)
          objc_enumerationMutation(v10);
        v15 = sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(*((_QWORD *)&v89 + 1) + 8 * v14));
        v16 = v15;
        if (v15)
          v17 = (void *)*((_QWORD *)v15 + 16);
        else
          v17 = 0;
        v18 = v17;
        v19 = objc_msgSend(v18, "bluetoothEndpointType");

        if (v19 == (id)1)
        {

          v7 = 0;
          v8 = CFSTR("Client");
          goto LABEL_67;
        }
        v20 = v16 ? (void *)*((_QWORD *)v16 + 16) : 0;
        v21 = v20;
        v22 = objc_msgSend(v21, "bluetoothEndpointType");

        if (v22 == (id)2)
          break;
        if (v12 == (id)++v14)
        {
          v23 = objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v89, v106, 16);
          v12 = v23;
          v7 = v83;
          if (!v23)
            goto LABEL_41;
          goto LABEL_27;
        }
      }

      v8 = CFSTR("Server");
      v7 = 1;
    }
    else
    {
LABEL_41:

      if (v7 != 1)
      {
        a3 = v84;
        goto LABEL_11;
      }
      v8 = CFSTR("Server");
    }
LABEL_67:
    a3 = v84;
    if (a2 != 2)
      goto LABEL_12;
LABEL_68:
    if (a3)
    {
      v33 = *(unsigned __int8 *)(a1 + 47);
      if (v33 != 1)
      {
        if (v33 == 2)
        {
          if (qword_1001E45C0 != -1)
            dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
          if (!_NRLogIsLevelEnabled(qword_1001E45B8, 1))
            goto LABEL_149;
          goto LABEL_80;
        }
        if (objc_msgSend(*(id *)(a1 + 64), "state") != (id)5)
          goto LABEL_149;
        if (*(_BYTE *)(a1 + 47) == 3)
        {
          v44 = sub_10002A890();
          IsLevelEnabled = _NRLogIsLevelEnabled(v44, 0);

          if (IsLevelEnabled)
          {
            v46 = sub_10002A890();
            _NRLogWithArgs(v46, 0, "%s%.30s:%-4d Deferring registering %s priority %s as the pipe is being unregistered", "", "-[NRLinkManagerBluetooth registerPipeForPriority:isP2P:]", 1292, "High", "p2pPipe");

          }
          v40 = 47;
          goto LABEL_138;
        }
        *(_BYTE *)(a1 + 47) = 1;
        *(_BYTE *)(a1 + 48) &= ~2u;
        objc_msgSend((id)a1, "reportEvent:detailsFormat:", 4201, CFSTR("%s %s %@"), "High", "p2pPipe", v8);
        v75 = *(void **)(a1 + 64);
        v100[0] = CBScalablePipeOptionTransport;
        v65 = v75;
        v76 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", sub_10002CF4C());
        v67 = (void *)objc_claimAutoreleasedReturnValue(v76);
        v100[1] = CBScalablePipeOptionStayConnectedWhenIdle;
        v101[0] = v67;
        v101[1] = &__kCFBooleanTrue;
        v68 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v101, v100, 2));
        v69 = CFSTR("com.apple.terminusLink.urgent.p2p");
        goto LABEL_144;
      }
      if (qword_1001E45C0 != -1)
        dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
      if (!_NRLogIsLevelEnabled(qword_1001E45B8, 1))
        goto LABEL_149;
    }
    else
    {
      v34 = *(unsigned __int8 *)(a1 + 41);
      if (v34 != 1)
      {
        if (v34 == 2)
        {
          if (qword_1001E45C0 != -1)
            dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
          if (!_NRLogIsLevelEnabled(qword_1001E45B8, 1))
            goto LABEL_149;
          goto LABEL_80;
        }
        if (objc_msgSend(*(id *)(a1 + 64), "state") != (id)5)
          goto LABEL_149;
        if (*(_BYTE *)(a1 + 41) == 3)
        {
          v48 = sub_10002A890();
          v49 = _NRLogIsLevelEnabled(v48, 0);

          if (v49)
          {
            v50 = sub_10002A890();
            _NRLogWithArgs(v50, 0, "%s%.30s:%-4d Deferring registering %s priority %s as the pipe is being unregistered", "", "-[NRLinkManagerBluetooth registerPipeForPriority:isP2P:]", 1294, "High", "pipe");

          }
          v40 = 41;
          goto LABEL_138;
        }
        *(_BYTE *)(a1 + 41) = 1;
        *(_BYTE *)(a1 + 42) &= ~2u;
        objc_msgSend((id)a1, "reportEvent:detailsFormat:", 4201, CFSTR("%s %s %@"), "High", "pipe", v8);
        v77 = *(void **)(a1 + 64);
        v98[0] = CBScalablePipeOptionTransport;
        v65 = v77;
        v78 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", sub_10002CF4C());
        v67 = (void *)objc_claimAutoreleasedReturnValue(v78);
        v98[1] = CBScalablePipeOptionStayConnectedWhenIdle;
        v99[0] = v67;
        v99[1] = &__kCFBooleanTrue;
        v68 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v99, v98, 2));
        v69 = CFSTR("com.apple.terminusLink.urgent");
LABEL_144:
        v72 = v65;
        v73 = v7;
        v74 = 2;
        goto LABEL_148;
      }
      if (qword_1001E45C0 != -1)
        dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
      if (!_NRLogIsLevelEnabled(qword_1001E45B8, 1))
        goto LABEL_149;
    }
LABEL_111:
    v47 = sub_10002A890();
    v36 = v47;
LABEL_131:
    _NRLogWithArgs(v47, 1, "%s%.30s:%-4d %s %s already registering");
LABEL_132:

    goto LABEL_149;
  }
  if (*(_BYTE *)(a1 + 36))
    v7 = 1;
  else
    v7 = 2;
  if (!a3)
    goto LABEL_24;
LABEL_10:
  if (!*(_BYTE *)(a1 + 38))
    return;
LABEL_11:
  v8 = CFSTR("PeerToPeer");
  v7 = 2;
  if (a2 == 2)
    goto LABEL_68;
LABEL_12:
  if (a2 == 1)
  {
    if (a3)
    {
      v9 = *(unsigned __int8 *)(a1 + 45);
      if (v9 != 1)
      {
        if (v9 == 2)
        {
          if (qword_1001E45C0 != -1)
            dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
          if (!_NRLogIsLevelEnabled(qword_1001E45B8, 1))
            goto LABEL_149;
LABEL_80:
          v35 = sub_10002A890();
          v36 = v35;
LABEL_121:
          _NRLogWithArgs(v35, 1, "%s%.30s:%-4d %s %s already registered");
          goto LABEL_132;
        }
        if (objc_msgSend(*(id *)(a1 + 64), "state") != (id)5)
          goto LABEL_149;
        if (*(_BYTE *)(a1 + 45) == 3)
        {
          v37 = sub_10002A890();
          v38 = _NRLogIsLevelEnabled(v37, 0);

          if (v38)
          {
            v39 = sub_10002A890();
            _NRLogWithArgs(v39, 0, "%s%.30s:%-4d Deferring registering %s priority %s as the pipe is being unregistered", "", "-[NRLinkManagerBluetooth registerPipeForPriority:isP2P:]", 1286, "Medium", "p2pPipe");

          }
          v40 = 45;
LABEL_138:
          *(_BYTE *)(a1 + v40 + 1) |= 2u;
          goto LABEL_149;
        }
        *(_BYTE *)(a1 + 45) = 1;
        *(_BYTE *)(a1 + 46) &= ~2u;
        objc_msgSend((id)a1, "reportEvent:detailsFormat:", 4201, CFSTR("%s %s %@"), "Medium", "p2pPipe", v8);
        v64 = *(void **)(a1 + 64);
        v104[0] = CBScalablePipeOptionTransport;
        v65 = v64;
        v66 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", sub_10002CF4C());
        v67 = (void *)objc_claimAutoreleasedReturnValue(v66);
        v104[1] = CBScalablePipeOptionStayConnectedWhenIdle;
        v105[0] = v67;
        v105[1] = &__kCFBooleanTrue;
        v68 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v105, v104, 2));
        v69 = CFSTR("com.apple.terminusLink.p2p");
LABEL_141:
        v72 = v65;
        v73 = v7;
        v74 = 1;
LABEL_148:
        objc_msgSend(v72, "registerEndpoint:type:priority:options:", v69, v73, v74, v68);

        goto LABEL_149;
      }
      if (qword_1001E45C0 != -1)
        dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
      if (!_NRLogIsLevelEnabled(qword_1001E45B8, 1))
        goto LABEL_149;
    }
    else
    {
      v29 = *(unsigned __int8 *)(a1 + 39);
      if (v29 != 1)
      {
        if (v29 == 2)
        {
          if (qword_1001E45C0 != -1)
            dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
          if (!_NRLogIsLevelEnabled(qword_1001E45B8, 1))
            goto LABEL_149;
          goto LABEL_80;
        }
        if (objc_msgSend(*(id *)(a1 + 64), "state") != (id)5)
          goto LABEL_149;
        if (*(_BYTE *)(a1 + 39) == 3)
        {
          v41 = sub_10002A890();
          v42 = _NRLogIsLevelEnabled(v41, 0);

          if (v42)
          {
            v43 = sub_10002A890();
            _NRLogWithArgs(v43, 0, "%s%.30s:%-4d Deferring registering %s priority %s as the pipe is being unregistered", "", "-[NRLinkManagerBluetooth registerPipeForPriority:isP2P:]", 1288, "Medium", "pipe");

          }
          v40 = 39;
          goto LABEL_138;
        }
        *(_BYTE *)(a1 + 39) = 1;
        *(_BYTE *)(a1 + 40) &= ~2u;
        objc_msgSend((id)a1, "reportEvent:detailsFormat:", 4201, CFSTR("%s %s %@"), "Medium", "pipe", v8);
        v70 = *(void **)(a1 + 64);
        v102[0] = CBScalablePipeOptionTransport;
        v65 = v70;
        v71 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", sub_10002CF4C());
        v67 = (void *)objc_claimAutoreleasedReturnValue(v71);
        v102[1] = CBScalablePipeOptionStayConnectedWhenIdle;
        v103[0] = v67;
        v103[1] = &__kCFBooleanTrue;
        v68 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v103, v102, 2));
        v69 = CFSTR("com.apple.terminusLink");
        goto LABEL_141;
      }
      if (qword_1001E45C0 != -1)
        dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
      if (!_NRLogIsLevelEnabled(qword_1001E45B8, 1))
        goto LABEL_149;
    }
    goto LABEL_111;
  }
  if (a2 != 3)
    goto LABEL_149;
  v87 = 0u;
  v88 = 0u;
  v85 = 0u;
  v86 = 0u;
  v24 = *(id *)(a1 + 56);
  v25 = objc_msgSend(v24, "countByEnumeratingWithState:objects:count:", &v85, v97, 16);
  if (!v25)
    goto LABEL_52;
  v26 = v25;
  v27 = *(_QWORD *)v86;
  while (2)
  {
    for (i = 0; i != v26; i = (char *)i + 1)
    {
      if (*(_QWORD *)v86 != v27)
        objc_enumerationMutation(v24);
      if (objc_msgSend(*(id *)(*((_QWORD *)&v85 + 1) + 8 * (_QWORD)i), "state") == 8)
      {

        if (a3)
        {
          v30 = *(unsigned __int8 *)(a1 + 49);
          if (v30 != 1)
          {
            if (v30 == 2)
            {
              v31 = sub_10002A890();
              v32 = _NRLogIsLevelEnabled(v31, 1);

              if (!v32)
                goto LABEL_149;
LABEL_120:
              v35 = sub_10002A890();
              v36 = v35;
              goto LABEL_121;
            }
            if (objc_msgSend(*(id *)(a1 + 64), "state") != (id)5)
              goto LABEL_149;
            if (*(_BYTE *)(a1 + 49) == 3)
            {
              v56 = sub_10002A890();
              v57 = _NRLogIsLevelEnabled(v56, 0);

              if (v57)
              {
                v58 = sub_10002A890();
                _NRLogWithArgs(v58, 0, "%s%.30s:%-4d Deferring registering %s priority %s as the pipe is being unregistered", "", "-[NRLinkManagerBluetooth registerPipeForPriority:isP2P:]", 1317, "Isochronous", "p2pPipe");

              }
              v40 = 49;
              goto LABEL_138;
            }
            *(_BYTE *)(a1 + 49) = 1;
            *(_BYTE *)(a1 + 50) &= ~2u;
            objc_msgSend((id)a1, "reportEvent:detailsFormat:", 4201, CFSTR("%s %s %@"), "Isochronous", "p2pPipe", v8);
            v79 = *(void **)(a1 + 64);
            v95[0] = CBScalablePipeOptionTransport;
            v65 = v79;
            v80 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", sub_10002CF4C());
            v67 = (void *)objc_claimAutoreleasedReturnValue(v80);
            v95[1] = CBScalablePipeOptionStayConnectedWhenIdle;
            v96[0] = v67;
            v96[1] = &__kCFBooleanTrue;
            v68 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v96, v95, 2));
            v69 = CFSTR("com.apple.terminusLink.datagram.p2p");
            goto LABEL_147;
          }
          v54 = sub_10002A890();
          v55 = _NRLogIsLevelEnabled(v54, 1);

          if (!v55)
            goto LABEL_149;
        }
        else
        {
          v51 = *(unsigned __int8 *)(a1 + 43);
          if (v51 != 1)
          {
            if (v51 == 2)
            {
              v52 = sub_10002A890();
              v53 = _NRLogIsLevelEnabled(v52, 1);

              if (!v53)
                goto LABEL_149;
              goto LABEL_120;
            }
            if (objc_msgSend(*(id *)(a1 + 64), "state") != (id)5)
              goto LABEL_149;
            if (*(_BYTE *)(a1 + 43) == 3)
            {
              v61 = sub_10002A890();
              v62 = _NRLogIsLevelEnabled(v61, 0);

              if (v62)
              {
                v63 = sub_10002A890();
                _NRLogWithArgs(v63, 0, "%s%.30s:%-4d Deferring registering %s priority %s as the pipe is being unregistered", "", "-[NRLinkManagerBluetooth registerPipeForPriority:isP2P:]", 1319, "Isochronous", "pipe");

              }
              v40 = 43;
              goto LABEL_138;
            }
            *(_BYTE *)(a1 + 43) = 1;
            *(_BYTE *)(a1 + 44) &= ~2u;
            objc_msgSend((id)a1, "reportEvent:detailsFormat:", 4201, CFSTR("%s %s %@"), "Isochronous", "pipe", v8);
            v81 = *(void **)(a1 + 64);
            v93[0] = CBScalablePipeOptionTransport;
            v65 = v81;
            v82 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", sub_10002CF4C());
            v67 = (void *)objc_claimAutoreleasedReturnValue(v82);
            v93[1] = CBScalablePipeOptionStayConnectedWhenIdle;
            v94[0] = v67;
            v94[1] = &__kCFBooleanTrue;
            v68 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v94, v93, 2));
            v69 = CFSTR("com.apple.terminusLink.datagram");
LABEL_147:
            v72 = v65;
            v73 = v7;
            v74 = 3;
            goto LABEL_148;
          }
          v59 = sub_10002A890();
          v60 = _NRLogIsLevelEnabled(v59, 1);

          if (!v60)
            goto LABEL_149;
        }
        v47 = sub_10002A890();
        v36 = v47;
        goto LABEL_131;
      }
    }
    v26 = objc_msgSend(v24, "countByEnumeratingWithState:objects:count:", &v85, v97, 16);
    if (v26)
      continue;
    break;
  }
LABEL_52:

LABEL_149:
}

uint64_t sub_10002CF4C()
{
  _BYTE *v0;
  uint64_t v1;

  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v0 = (id)qword_1001E4708;
  if (v0)
  {
    if (v0[10])
      v1 = 2;
    else
      v1 = 1;
  }
  else
  {
    v1 = 1;
  }

  return v1;
}

void sub_10002CFC8(uint64_t a1, unint64_t a2)
{
  NSObject *v4;
  id v5;
  id v6;
  id v7;
  uint64_t v8;
  void *i;
  id v10;
  id WeakRetained;
  void *v12;
  void *v13;
  id obj;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  _BYTE v19[128];

  if (a1)
  {
    v4 = *(id *)(a1 + 24);
    dispatch_assert_queue_V2(v4);

    if (a2)
    {
      if (a2 == 5 && sub_100138258((uint64_t)NRDLocalDevice))
      {
        sub_10002BE24(a1, 1, 0);
        sub_10002BE24(a1, 1, 1);
      }
      else
      {
        if ((sub_100138258((uint64_t)NRDLocalDevice) & 1) == 0)
          *(_BYTE *)(a1 + 36) = 1;
        sub_10002A358(a1, 1, 0);
        sub_10002A358(a1, 1, 1);
        v5 = objc_msgSend(*(id *)(a1 + 56), "copy");
        v15 = 0u;
        v16 = 0u;
        v17 = 0u;
        v18 = 0u;
        obj = v5;
        v6 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v15, v19, 16);
        if (v6)
        {
          v7 = v6;
          v8 = *(_QWORD *)v16;
          do
          {
            for (i = 0; i != v7; i = (char *)i + 1)
            {
              if (*(_QWORD *)v16 != v8)
                objc_enumerationMutation(obj);
              v12 = *(void **)(*((_QWORD *)&v15 + 1) + 8 * (_QWORD)i);
              objc_msgSend(v12, "setNoTransport:", 1);
              v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "nrUUID"));
              if (a2 < 6)
                v10 = *(&off_1001B6540 + a2);
              else
                v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("UnknownState(%lld)"), a2);
              objc_msgSend(v12, "cancelWithReason:", CFSTR("pipe manager state %@"), v10);

              WeakRetained = objc_loadWeakRetained((id *)(a1 + 128));
              objc_msgSend(WeakRetained, "pipeDidConnectForNRUUID:nrUUID:", 0, v13);

              sub_10002A8D0(a1, v13);
            }
            v7 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v15, v19, 16);
          }
          while (v7);
        }

        objc_msgSend(*(id *)(a1 + 104), "removeAllObjects");
        if (a2 != 5)
        {
          if (qword_1001E45C0 != -1)
            dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
          if (_NRLogIsLevelEnabled(qword_1001E45B8, 0))
          {
            if (qword_1001E45C0 != -1)
              dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
            _NRLogWithArgs(qword_1001E45B8, 0, "%s%.30s:%-4d Resetting state", "", "-[NRLinkManagerBluetooth handleSPMStateChange:]", 1433);
          }
          *(_WORD *)(a1 + 39) = 0;
          *(_WORD *)(a1 + 41) = 0;
          *(_WORD *)(a1 + 43) = 0;
          *(_WORD *)(a1 + 45) = 0;
          *(_WORD *)(a1 + 47) = 0;
          *(_WORD *)(a1 + 49) = 0;
        }

      }
    }
  }
}

void sub_10002D33C(_QWORD *a1, unint64_t a2)
{
  id v3;
  void *v4;

  if (a1[9])
  {
    if (a2 >= 6)
      v3 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("UnknownState(%lld)"), a2);
    else
      v3 = *(&off_1001B6540 + a2);
    objc_msgSend(a1, "reportEvent:details:", 3500, v3);

    v4 = (void *)a1[9];
    if (v4 && objc_msgSend(v4, "state") == (id)5 && sub_100138258((uint64_t)NRDLocalDevice))
    {
      if (sub_10002BA34((uint64_t)a1))
      {
        sub_10002AB14((uint64_t)a1);
        return;
      }
      if (qword_1001E45C0 != -1)
        dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
      if (_NRLogIsLevelEnabled(qword_1001E45B8, 0))
      {
        if (qword_1001E45C0 != -1)
          dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
        _NRLogWithArgs(qword_1001E45B8, 0, "%s%.30s:%-4d Not starting BT advertisements as all enabled devices are connected", "", "-[NRLinkManagerBluetooth handlePMStateChange:]", 1687);
      }
    }
    sub_10002BC58((id *)a1);
  }
}

void sub_10002D4BC(_QWORD *a1)
{
  uint64_t v2;
  id WeakRetained;
  id v4;

  v2 = a1[4];
  if (v2)
    WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
  else
    WeakRetained = 0;
  v4 = WeakRetained;
  objc_msgSend(WeakRetained, "linkDidReceiveData:data:", a1[5], a1[6]);

}

void sub_10002D508(id *a1, void *a2, void *a3)
{
  id v5;
  uint64_t v6;
  void *v7;
  id v8;
  void *v9;
  id v10;
  void *v11;
  id v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  NRAnalyticsBluetoothAssertion *v16;
  id v17;
  unint64_t v18;
  unint64_t v19;
  double v20;
  unint64_t v21;
  id v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  id v26;
  char IsLevelEnabled;
  id v28;
  unint64_t v29;
  _QWORD handler[4];
  NSObject *v31;
  id v32;
  id location;

  v29 = a2;
  v5 = a3;
  if (a1)
  {
    v6 = objc_claimAutoreleasedReturnValue(objc_msgSend(a1[15], "objectForKeyedSubscript:", v5));
    if (v29 | v6 && !objc_msgSend((id)v29, "isEqual:", v6))
    {
      objc_msgSend(a1[15], "setObject:forKeyedSubscript:", v29, v5);
      v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v29, "inputBytesPerSecond"));
      v8 = objc_msgSend(v7, "unsignedIntValue");

      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v29, "outputBytesPerSecond"));
      v10 = objc_msgSend(v9, "unsignedIntValue");

      v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v29, "packetsPerSecond"));
      v12 = objc_msgSend(v11, "unsignedIntValue");

      if (qword_1001E45C0 != -1)
        dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
      if (_NRLogIsLevelEnabled(qword_1001E45B8, 0))
      {
        if (qword_1001E45C0 != -1)
          dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
        _NRLogWithArgs(qword_1001E45B8, 0, "%s%.30s:%-4d Applying BT link requirements %@ - InputBPS: %u, OutputBPS: %u, Packets/sec: %u", "", "-[NRLinkManagerBluetooth applyLinkRequirements:forBTUUID:]", 728, v5, v8, v10, v12);
      }
      objc_msgSend(a1[8], "setLinkRequirementsForPeer:withClientName:packetsPerSecond:inputBytesPerSecond:outputBytesPerSecond:", v5, CFSTR("com.apple.terminusLink"), v12, v8, v10);
      v13 = objc_msgSend((id)v29, "isNotEmpty");
      v14 = objc_msgSend((id)v6, "isNotEmpty");
      if (v13)
      {
        if (v14)
        {
          objc_msgSend((id)v29, "setStartTime:", objc_msgSend((id)v6, "startTime"));
          objc_msgSend((id)v29, "setReportedToABC:", objc_msgSend((id)v6, "reportedToABC"));
        }
        else
        {
          objc_msgSend((id)v29, "setStartTime:", mach_continuous_time());
        }
      }
      else if (v14)
      {
        v15 = mach_continuous_time();
        v16 = objc_alloc_init(NRAnalyticsBluetoothAssertion);
        v17 = objc_msgSend((id)v6, "startTime");
        v20 = 0.0;
        if (v17)
        {
          v21 = v15 - (_QWORD)v17;
          if (v15 > (unint64_t)v17)
          {
            if (qword_1001E48A8 != -1)
              dispatch_once(&qword_1001E48A8, &stru_1001B7C30);
            LODWORD(v18) = dword_1001E48B0;
            LODWORD(v19) = *(_DWORD *)algn_1001E48B4;
            v20 = (double)v21 * (0.000000001 * (double)v18) / (double)v19;
          }
        }
        if (v16)
          v16->_durationInSec = v20;
        v22 = objc_msgSend(a1[15], "count", v20);
        if (v16)
          v16->_multipleAssertions = v22 != 0;
        -[NRAnalyticsBluetoothAssertion submit](v16, "submit");
        sub_10002DAAC((void *)v6, 1, v15);

      }
      if (objc_msgSend(a1[15], "count"))
      {
        if (!a1[17])
        {
          v23 = a1[3];
          v24 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v23);

          dispatch_source_set_timer(v24, 0x8000000000000000, 0x8BB2C97000uLL, 0x12A05F200uLL);
          objc_initWeak(&location, a1);
          handler[0] = _NSConcreteStackBlock;
          handler[1] = 3221225472;
          handler[2] = sub_10002DD44;
          handler[3] = &unk_1001B87F0;
          objc_copyWeak(&v32, &location);
          v25 = v24;
          v31 = v25;
          dispatch_source_set_event_handler(v25, handler);
          dispatch_resume(v25);
          objc_storeStrong(a1 + 17, v24);
          if (qword_1001E45C0 != -1)
            dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
          v26 = (id)qword_1001E45B8;
          IsLevelEnabled = _NRLogIsLevelEnabled(v26, 0);

          if ((IsLevelEnabled & 1) != 0)
          {
            if (qword_1001E45C0 != -1)
              dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
            v28 = (id)qword_1001E45B8;
            _NRLogWithArgs(v28, 0, "%s%.30s:%-4d created timer source to monitor link requirements", "", "-[NRLinkManagerBluetooth armLinkRequirementsTimer]", 816);

          }
          objc_destroyWeak(&v32);
          objc_destroyWeak(&location);

        }
      }
      else
      {
        sub_10002DC4C((uint64_t)a1);
      }
    }
    else
    {
      if (qword_1001E45C0 != -1)
        dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
      if (_NRLogIsLevelEnabled(qword_1001E45B8, 1))
      {
        if (qword_1001E45C0 != -1)
          dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
        _NRLogWithArgs(qword_1001E45B8, 1, "%s%.30s:%-4d Not applying same BT link requirements", "", "-[NRLinkManagerBluetooth applyLinkRequirements:forBTUUID:]", 718);
      }
    }

  }
}

void sub_10002DA44(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 88));
  _Unwind_Resume(a1);
}

void sub_10002DA60(uint64_t a1)
{
  uint64_t v2;
  id WeakRetained;
  id v4;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
    WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
  else
    WeakRetained = 0;
  v4 = WeakRetained;
  objc_msgSend(WeakRetained, "linkIsUnavailable:", *(_QWORD *)(a1 + 40));

}

void sub_10002DAAC(void *a1, int a2, unint64_t a3)
{
  unsigned __int8 v5;
  void *v6;
  id v7;
  unint64_t v8;
  unint64_t v9;
  BOOL v10;
  unint64_t v11;
  double v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  id v17;

  v17 = a1;
  v5 = objc_msgSend(v17, "reportedToABC");
  v6 = v17;
  if ((v5 & 1) == 0)
  {
    v7 = objc_msgSend(v17, "startTime");
    v6 = v17;
    if (v7)
    {
      v10 = a3 > (unint64_t)v7;
      v11 = a3 - (_QWORD)v7;
      if (v10)
      {
        if (qword_1001E48A8 != -1)
          dispatch_once(&qword_1001E48A8, &stru_1001B7C30);
        LODWORD(v8) = dword_1001E48B0;
        LODWORD(v9) = *(_DWORD *)algn_1001E48B4;
        v12 = (double)v11 * (0.000000001 * (double)v8) / (double)v9;
        v6 = v17;
        if (v12 > 599.0)
        {
          if (qword_1001E45C0 != -1)
            dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
          if (_NRLogIsLevelEnabled(qword_1001E45B8, 0))
          {
            if (qword_1001E45C0 != -1)
              dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
            _NRLogWithArgs(qword_1001E45B8, 0, "%s%.30s:%-4d detected long magnet assertion %.2fs", "", "-[NRLinkManagerBluetooth triggerLinkRequirementsABCIfNeeded:shouldTrigger:now:]", 771, v12);
          }
          objc_msgSend(v17, "setReportedToABC:", 1);
          v6 = v17;
          if (a2)
          {
            sub_100109270(CFSTR("NRLinkManagerBluetooth"), CFSTR("Bluetooth Assertion"), CFSTR("exceeded threshold"), 0, 0, v13, v14, v15, v16);
            v6 = v17;
          }
        }
      }
    }
  }

}

void sub_10002DC4C(uint64_t a1)
{
  void *v2;

  if (*(_QWORD *)(a1 + 136))
  {
    if (qword_1001E45C0 != -1)
      dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
    if (_NRLogIsLevelEnabled(qword_1001E45B8, 0))
    {
      if (qword_1001E45C0 != -1)
        dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
      _NRLogWithArgs(qword_1001E45B8, 0, "%s%.30s:%-4d invalidating link requirements monitor source", "", "-[NRLinkManagerBluetooth invalidateLinkRequirementsTimer]", 822);
    }
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 136));
    v2 = *(void **)(a1 + 136);
    *(_QWORD *)(a1 + 136) = 0;

  }
}

void sub_10002DD44(uint64_t a1)
{
  id *WeakRetained;
  id *v3;
  uint64_t v4;
  id v5;
  id v6;
  id v7;
  int v8;
  uint64_t v9;
  void *i;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  _BYTE v19[128];

  WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 40));
  v3 = WeakRetained;
  if (WeakRetained && WeakRetained[17] == *(id *)(a1 + 32))
  {
    v4 = mach_continuous_time();
    v15 = 0u;
    v16 = 0u;
    v17 = 0u;
    v18 = 0u;
    v5 = v3[15];
    v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v15, v19, 16);
    if (v6)
    {
      v7 = v6;
      v8 = 0;
      v9 = *(_QWORD *)v16;
      do
      {
        for (i = 0; i != v7; i = (char *)i + 1)
        {
          if (*(_QWORD *)v16 != v9)
            objc_enumerationMutation(v5);
          v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3[15], "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v15 + 1) + 8 * (_QWORD)i), (_QWORD)v15));
          if ((objc_msgSend(v11, "reportedToABC") & 1) == 0)
          {
            sub_10002DAAC(v11, 0, v4);
            v8 |= objc_msgSend(v11, "reportedToABC");
          }

        }
        v7 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v15, v19, 16);
      }
      while (v7);

      if ((v8 & 1) != 0)
        sub_100109270(CFSTR("NRLinkManagerBluetooth"), CFSTR("Bluetooth Assertion"), CFSTR("exceeded threshold"), 0, 0, v12, v13, v14, v15);
    }
    else
    {

    }
  }

}

void sub_10002DEF8(uint64_t a1)
{
  uint64_t v2;
  id WeakRetained;
  id v4;

  if (objc_msgSend(*(id *)(a1 + 32), "state") == 9)
  {
    v2 = *(_QWORD *)(a1 + 40);
    if (v2)
      WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    else
      WeakRetained = 0;
    v4 = WeakRetained;
    objc_msgSend(WeakRetained, "linkIsSuspended:", *(_QWORD *)(a1 + 32));

  }
  else
  {
    if (qword_1001E45C0 != -1)
      dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
    if (_NRLogIsLevelEnabled(qword_1001E45B8, 16))
    {
      if (qword_1001E45C0 != -1)
        dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
      _NRLogWithArgs(qword_1001E45B8, 16, "%s%.30s:%-4d %@: link %@ is not in suspended state anymore", "", "-[NRLinkManagerBluetooth linkIsSuspended:]_block_invoke", 1107, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32));
    }
  }
}

void sub_10002E008(uint64_t a1)
{
  uint64_t v2;
  id WeakRetained;
  id v4;

  if (objc_msgSend(*(id *)(a1 + 32), "state") == 8)
  {
    v2 = *(_QWORD *)(a1 + 40);
    if (v2)
      WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    else
      WeakRetained = 0;
    v4 = WeakRetained;
    objc_msgSend(WeakRetained, "linkIsReady:", *(_QWORD *)(a1 + 32));

  }
  else
  {
    if (qword_1001E45C0 != -1)
      dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
    if (_NRLogIsLevelEnabled(qword_1001E45B8, 16))
    {
      if (qword_1001E45C0 != -1)
        dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
      _NRLogWithArgs(qword_1001E45B8, 16, "%s%.30s:%-4d %@: link %@ is not in ready state anymore", "", "-[NRLinkManagerBluetooth linkIsReady:]_block_invoke", 1076, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32));
    }
  }
}

void sub_10002E118(uint64_t a1)
{
  uint64_t v2;
  id WeakRetained;
  id v4;

  if (objc_msgSend(*(id *)(a1 + 32), "state") == 1)
  {
    v2 = *(_QWORD *)(a1 + 40);
    if (v2)
      WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    else
      WeakRetained = 0;
    v4 = WeakRetained;
    objc_msgSend(WeakRetained, "linkIsAvailable:", *(_QWORD *)(a1 + 32));

  }
  else
  {
    if (qword_1001E45C0 != -1)
      dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
    if (_NRLogIsLevelEnabled(qword_1001E45B8, 16))
    {
      if (qword_1001E45C0 != -1)
        dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
      _NRLogWithArgs(qword_1001E45B8, 16, "%s%.30s:%-4d %@: link %@ is not in initial state anymore", "", "-[NRLinkManagerBluetooth linkIsAvailable:]_block_invoke", 1020, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32));
    }
  }
}

void sub_10002E228(uint64_t a1)
{
  char **v2;
  char **v3;
  id v4;
  id v5;
  id v6;
  char **v7;
  id v8;
  uint64_t v9;
  __objc2_prot *v10;
  void *i;
  void *v12;
  id *v13;
  id WeakRetained;
  unsigned int v15;
  id v16;
  void *v17;
  id v18;
  int *v19;
  id v20;
  id v21;
  id v22;
  id v23;
  id v24;
  id v25;
  id v26;
  id v27;
  id v28;
  id v29;
  int v30;
  void *v31;
  char v32;
  uint64_t v33;
  void *v34;
  void *v35;
  id v36;
  id v37;
  void *v38;
  id v39;
  void *v40;
  id v41;
  id v42;
  id v43;
  void *v44;
  id v45;
  id v46;
  void *v47;
  id v48;
  void *v49;
  id v50;
  uint64_t v51;
  id obj;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  NSString *v57;
  void *v58;
  NSString *v59;
  void *v60;
  _BYTE v61[128];

  v2 = &selRef_terminateDataSession_completionHandler_;
  *(_BYTE *)(a1 + 38) = 0;
  v3 = &selRef_terminateDataSession_completionHandler_;
  *(_BYTE *)(a1 + 37) = 0;
  v4 = sub_100137B34((uint64_t)NRDLocalDevice);
  if (!objc_msgSend(v4, "count"))
    goto LABEL_68;
  v55 = 0u;
  v56 = 0u;
  v53 = 0u;
  v54 = 0u;
  v5 = v4;
  v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v53, v61, 16);
  v7 = &selRef_terminateDataSession_completionHandler_;
  if (!v6)
  {

    v32 = 0;
    goto LABEL_46;
  }
  v8 = v6;
  v51 = 0;
  obj = v5;
  v50 = v4;
  v9 = *(_QWORD *)v54;
  v10 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
  while (2)
  {
    for (i = 0; i != v8; i = (char *)i + 1)
    {
      if (*(_QWORD *)v54 != v9)
        objc_enumerationMutation(obj);
      v12 = *(void **)(*((_QWORD *)&v53 + 1) + 8 * (_QWORD)i);
      v13 = (id *)sub_10012FFF4((uint64_t)NRDLocalDevice, v12);
      if (a1)
        WeakRetained = objc_loadWeakRetained((id *)(a1 + 16));
      else
        WeakRetained = 0;
      v15 = objc_msgSend(WeakRetained, "perpetualStandaloneMeadowEnabledForNRUUID:", v12);

      if (!v15)
      {
        if (!v13)
        {
          v20 = 0;
          *(_BYTE *)(a1 + 37) = 1;
LABEL_26:
          v21 = v20;
          v22 = objc_msgSend(v21, "bluetoothRole");

          if (v22 == (id)1)
          {
            BYTE4(v51) = 1;
          }
          else
          {
            if (v13)
              v23 = v13[16];
            else
              v23 = 0;
            v24 = v23;
            v25 = objc_msgSend(v24, "bluetoothRole");

            if (v25 == (id)2)
            {
              LOBYTE(v51) = 1;
            }
            else
            {
              v30 = sub_10010DF88(v13);
              LOBYTE(v51) = (v30 == 2) | v51;
              BYTE4(v51) |= v30 != 2;
            }
          }
          goto LABEL_7;
        }
        v16 = v13[16];
        if (v16)
        {
          v17 = v16;
          v18 = v13[16];
          if (objc_msgSend(v18, "bluetoothEndpointType") != (id)1)
          {
            v26 = v13[16];
            v27 = objc_msgSend(v26, "bluetoothEndpointType");

            v10 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
            v19 = &OBJC_IVAR___NRLinkManagerBluetooth__hasEnabledDevicesUsingClientServer;
            if (v27 != (id)2)
            {
              v28 = v13[16];
              v29 = objc_msgSend(v28, "bluetoothEndpointType");

              v19 = &OBJC_IVAR___NRLinkManagerBluetooth__hasEnabledDevicesUsingP2P;
              if (v29 != (id)3)
                goto LABEL_25;
            }
            goto LABEL_24;
          }

        }
        v19 = &OBJC_IVAR___NRLinkManagerBluetooth__hasEnabledDevicesUsingClientServer;
LABEL_24:
        *(_BYTE *)(a1 + *v19) = 1;
LABEL_25:
        v20 = v13[16];
        goto LABEL_26;
      }
      if (qword_1001E45C0 != -1)
        dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
      if (_NRLogIsLevelEnabled(v10[20].inst_meths, 0))
      {
        if (qword_1001E45C0 != -1)
          dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
        _NRLogWithArgs(v10[20].inst_meths, 0, "%s%.30s:%-4d Deferring creating link for %@ as device is in perpetual standalone Meadow mode", "", "-[NRLinkManagerBluetooth setup]", 410, v13);
      }
LABEL_7:

    }
    v8 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v53, v61, 16);
    if (v8)
      continue;
    break;
  }

  if ((v51 & 0x100000000) == 0)
  {
    v4 = v50;
    v3 = &selRef_terminateDataSession_completionHandler_;
    v2 = &selRef_terminateDataSession_completionHandler_;
    v32 = v51;
    v7 = &selRef_terminateDataSession_completionHandler_;
LABEL_46:
    if (*(_QWORD *)(a1 + *((int *)v7 + 802)))
    {
      sub_100029644(a1);
      objc_msgSend(*(id *)(a1 + *((int *)v7 + 802)), "setDelegate:", 0);
      v33 = *((int *)v7 + 802);
      v34 = *(void **)(a1 + v33);
      *(_QWORD *)(a1 + v33) = 0;

    }
    v35 = *(void **)(a1 + 88);
    *(_QWORD *)(a1 + 88) = 0;

    if ((v32 & 1) != 0)
      goto LABEL_49;
    goto LABEL_41;
  }
  v4 = v50;
  v3 = &selRef_terminateDataSession_completionHandler_;
  v2 = &selRef_terminateDataSession_completionHandler_;
  if (!*(_QWORD *)(a1 + 80))
  {
    if (qword_1001E45C0 != -1)
      dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
    if (_NRLogIsLevelEnabled(qword_1001E45B8, 0))
    {
      if (qword_1001E45C0 != -1)
        dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
      _NRLogWithArgs(qword_1001E45B8, 0, "%s%.30s:%-4d initializing CBCentralManager", "", "-[NRLinkManagerBluetooth setup]", 448);
    }
    v45 = objc_alloc((Class)CBCentralManager);
    v46 = *(id *)(a1 + 24);
    v59 = CBCentralManagerOptionShowPowerAlertKey;
    v60 = &__kCFBooleanTrue;
    v47 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v60, &v59, 1));
    v48 = objc_msgSend(v45, "initWithDelegate:queue:options:", a1, v46, v47);
    v49 = *(void **)(a1 + 80);
    *(_QWORD *)(a1 + 80) = v48;

    if ((v51 & 1) != 0)
      goto LABEL_49;
LABEL_41:
    if (*(_QWORD *)(a1 + 72))
    {
      sub_10002BC58((id *)a1);
      objc_msgSend(*(id *)(a1 + 72), "setDelegate:", 0);
      v31 = *(void **)(a1 + 72);
      *(_QWORD *)(a1 + 72) = 0;

    }
    *(_BYTE *)(a1 + 33) = 0;
    goto LABEL_57;
  }
  if ((v51 & 1) == 0)
    goto LABEL_41;
LABEL_49:
  if (!*(_QWORD *)(a1 + 72))
  {
    if (qword_1001E45C0 != -1)
      dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
    if (_NRLogIsLevelEnabled(qword_1001E45B8, 0))
    {
      if (qword_1001E45C0 != -1)
        dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
      _NRLogWithArgs(qword_1001E45B8, 0, "%s%.30s:%-4d initializing CBPeripheralManager", "", "-[NRLinkManagerBluetooth setup]", 459);
    }
    v36 = objc_alloc((Class)CBPeripheralManager);
    v37 = *(id *)(a1 + 24);
    v57 = CBPeripheralManagerOptionShowPowerAlertKey;
    v58 = &__kCFBooleanTrue;
    v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v58, &v57, 1));
    v39 = objc_msgSend(v36, "initWithDelegate:queue:options:", a1, v37, v38);
    v40 = *(void **)(a1 + 72);
    *(_QWORD *)(a1 + 72) = v39;

  }
LABEL_57:
  if (!*(_QWORD *)(a1 + 64))
  {
    if (qword_1001E45C0 != -1)
      dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
    if (_NRLogIsLevelEnabled(qword_1001E45B8, 0))
    {
      if (qword_1001E45C0 != -1)
        dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
      _NRLogWithArgs(qword_1001E45B8, 0, "%s%.30s:%-4d initializing CBScalablePipeManager", "", "-[NRLinkManagerBluetooth setup]", 470);
    }
    v41 = objc_alloc((Class)CBScalablePipeManager);
    v42 = *(id *)(a1 + 24);
    v43 = objc_msgSend(v41, "initWithDelegate:queue:", a1, v42);
    v44 = *(void **)(a1 + 64);
    *(_QWORD *)(a1 + 64) = v43;

  }
  if (!*(_BYTE *)(a1 + *((int *)v2 + 811)) || !*(_BYTE *)(a1 + *((int *)v3 + 810)))
    sub_10002A358(a1, 1, *(unsigned __int8 *)(a1 + *((int *)v2 + 811)) == 0);
LABEL_68:

}

void sub_10002E9DC(uint64_t a1)
{
  __objc2_prot *v1;
  uint64_t v2;
  NSObject *v3;
  id v4;
  id v5;
  id v6;
  id v7;
  uint64_t v8;
  void *i;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  id v13;
  __objc2_prot *v14;
  __objc2_class *v15;
  id v16;
  int *v17;
  uint64_t v18;
  void *j;
  NRBluetoothPairerParameters *v20;
  id v21;
  void *v22;
  __objc2_prot *v23;
  id v24;
  id v25;
  id v26;
  void *v27;
  void *v28;
  char *v29;
  char *v30;
  id v31;
  id v32;
  id v33;
  id v34;
  id v35;
  __objc2_class *v36;
  id v37;
  __objc2_meth_list *class_meths;
  id obj;
  _QWORD v41[5];
  _QWORD v42[5];
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  _BYTE v51[128];
  _BYTE v52[128];

  if (a1 && _NRIsAppleInternal(a1))
  {
    v1 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
    if (qword_1001E45C0 != -1)
      dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
    if (_NRLogIsLevelEnabled(qword_1001E45B8, 1))
    {
      if (qword_1001E45C0 != -1)
        dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
      _NRLogWithArgs(qword_1001E45B8, 1, "%s%.30s:%-4d checking bluetooth pairing state", "", "-[NRLinkManagerBluetooth checkBluetoothPairingState]", 2042);
    }
    v2 = objc_opt_self(NRDLocalDevice);
    v3 = sub_10014CFBC();
    dispatch_assert_queue_V2(v3);

    sub_10012DFA0(v2);
    v4 = objc_alloc_init((Class)NSMutableArray);
    v47 = 0u;
    v48 = 0u;
    v49 = 0u;
    v50 = 0u;
    v5 = (id)qword_1001E4A38;
    v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v47, v52, 16);
    if (v6)
    {
      v7 = v6;
      v8 = *(_QWORD *)v48;
      do
      {
        for (i = 0; i != v7; i = (char *)i + 1)
        {
          if (*(_QWORD *)v48 != v8)
            objc_enumerationMutation(v5);
          v10 = *(_QWORD *)(*((_QWORD *)&v47 + 1) + 8 * (_QWORD)i);
          v11 = objc_claimAutoreleasedReturnValue(objc_msgSend((id)qword_1001E4A38, "objectForKeyedSubscript:", v10));
          v12 = (void *)v11;
          if (v11 && *(_BYTE *)(v11 + 20))
            objc_msgSend(v4, "addObject:", v10);

        }
        v7 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v47, v52, 16);
      }
      while (v7);
    }

    v43 = 0u;
    v44 = 0u;
    v45 = 0u;
    v46 = 0u;
    obj = v4;
    v13 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v43, v51, 16);
    v14 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
    v15 = &OBJC_METACLASS___NRAnalyticsLocalDevice;
    if (v13)
    {
      v16 = v13;
      v17 = &OBJC_IVAR___NRDLocalDevice__wasInitiallySetupUsingIDSPairing;
      v18 = *(_QWORD *)v44;
      do
      {
        for (j = 0; j != v16; j = (char *)j + 1)
        {
          if (*(_QWORD *)v44 != v18)
            objc_enumerationMutation(obj);
          v28 = *(void **)(*((_QWORD *)&v43 + 1) + 8 * (_QWORD)j);
          v29 = sub_10012FFF4((uint64_t)&v15[55], v28);
          v30 = v29;
          if (!v29)
          {
            objc_msgSend(v17 + 498, "removePairerForNRUUID:", 0);
            if (!objc_msgSend(v17 + 498, "hasPairerForNRUUID:", v28))
              goto LABEL_26;
LABEL_45:
            if (v1[20].class_meths != (__objc2_meth_list *)-1)
              dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
            if (_NRLogIsLevelEnabled(v14[20].inst_meths, 1))
            {
              if (v1[20].class_meths != (__objc2_meth_list *)-1)
                dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
              _NRLogWithArgs(v14[20].inst_meths, 1, "%s%.30s:%-4d already has pairer for %@", "", "-[NRLinkManagerBluetooth checkBluetoothPairingState]", 2067, v28);
            }
            goto LABEL_26;
          }
          if (v29[9])
          {
            if (!v29[20])
              goto LABEL_44;
          }
          else
          {
            v31 = *((id *)v29 + 4);
            objc_msgSend(v17 + 498, "removePairerForNRUUID:", v31);

            v15 = &OBJC_METACLASS___NRAnalyticsLocalDevice;
            if (!v30[20])
              goto LABEL_44;
          }
          if (!v30[8] && !v30[9] && v30[10])
          {
            if (v1[20].class_meths != (__objc2_meth_list *)-1)
              dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
            if (_NRLogIsLevelEnabled(v14[20].inst_meths, 1))
            {
              if (v1[20].class_meths != (__objc2_meth_list *)-1)
                dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
              _NRLogWithArgs(v14[20].inst_meths, 1, "%s%.30s:%-4d unpairing bluetooth for device %@", "", "-[NRLinkManagerBluetooth checkBluetoothPairingState]", 2054, v30);
            }
            v32 = objc_alloc((Class)(v17 + 498));
            v33 = *((id *)v30 + 4);
            v34 = objc_msgSend(v32, "initWithNRUUID:", v33);

            v35 = *(id *)(a1 + 24);
            v42[0] = _NSConcreteStackBlock;
            v42[1] = 3221225472;
            v42[2] = sub_10002F100;
            v42[3] = &unk_1001B64C0;
            v42[4] = v28;
            objc_msgSend(v34, "unpairWithCompletionQueue:completionBlock:", v35, v42);

            v15 = &OBJC_METACLASS___NRAnalyticsLocalDevice;
          }
LABEL_44:
          if ((objc_msgSend(v17 + 498, "hasPairerForNRUUID:", v28) & 1) != 0)
            goto LABEL_45;
          if (v30[9] && v30[20] && !v30[10])
          {
            v36 = v15 + 55;
            v37 = *((id *)v30 + 4);
            objc_opt_self(v36);
            v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)qword_1001E4A68, "objectForKeyedSubscript:", v37));

            class_meths = v1[20].class_meths;
            if (v27)
            {
              if (class_meths != (__objc2_meth_list *)-1)
                dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
              if (_NRLogIsLevelEnabled(v14[20].inst_meths, 1))
              {
                if (v1[20].class_meths != (__objc2_meth_list *)-1)
                  dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
                _NRLogWithArgs(v14[20].inst_meths, 1, "%s%.30s:%-4d pairing bluetooth for device %@", "", "-[NRLinkManagerBluetooth checkBluetoothPairingState]", 2076, v30);
              }
              v20 = objc_alloc_init(NRBluetoothPairerParameters);
              -[NRBluetoothPairerParameters setPairingType:](v20, "setPairingType:", 0);
              -[NRBluetoothPairerParameters setBluetoothUUID:](v20, "setBluetoothUUID:", v27);
              v21 = objc_alloc((Class)(v17 + 498));
              v22 = v27;
              v23 = v1;
              v24 = *((id *)v30 + 4);
              v25 = objc_msgSend(v21, "initWithNRUUID:", v24);

              v26 = *(id *)(a1 + 24);
              v41[0] = _NSConcreteStackBlock;
              v41[1] = 3221225472;
              v41[2] = sub_10002F2BC;
              v41[3] = &unk_1001B64C0;
              v41[4] = v28;
              objc_msgSend(v25, "pairWithParameters:completionQueue:completionBlock:", v20, v26, v41);

              v1 = v23;
              v27 = v22;
              v17 = &OBJC_IVAR___NRDLocalDevice__wasInitiallySetupUsingIDSPairing;

              v14 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
              v15 = &OBJC_METACLASS___NRAnalyticsLocalDevice;
            }
            else
            {
              if (class_meths != (__objc2_meth_list *)-1)
                dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
              v15 = &OBJC_METACLASS___NRAnalyticsLocalDevice;
              if (_NRLogIsLevelEnabled(v14[20].inst_meths, 1))
              {
                if (v1[20].class_meths != (__objc2_meth_list *)-1)
                  dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
                _NRLogWithArgs(v14[20].inst_meths, 1, "%s%.30s:%-4d no pairing candidate BT UUID for device %@", "", "-[NRLinkManagerBluetooth checkBluetoothPairingState]", 2073, v30);
              }
            }

          }
LABEL_26:

        }
        v16 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v43, v51, 16);
      }
      while (v16);
    }

  }
}

void sub_10002F100(uint64_t a1, int a2, void *a3)
{
  id v5;
  id v6;

  v6 = a3;
  if (a2)
  {
    if (qword_1001E45C0 != -1)
      dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
    if (_NRLogIsLevelEnabled(qword_1001E45B8, 1))
    {
      if (qword_1001E45C0 != -1)
        dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
      _NRLogWithArgs(qword_1001E45B8, 1, "%s%.30s:%-4d unpaired BT device %@", "", "-[NRLinkManagerBluetooth checkBluetoothPairingState]_block_invoke", 2058, v6);
    }
    sub_10013E73C((uint64_t)NRDLocalDevice, 0, *(void **)(a1 + 32));
  }
  else
  {
    if (qword_1001E45C0 != -1)
      dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
    if (_NRLogIsLevelEnabled(qword_1001E45B8, 16))
    {
      if (qword_1001E45C0 != -1)
        dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
      _NRLogWithArgs(qword_1001E45B8, 16, "%s%.30s:%-4d failed to unpair BT device", "", "-[NRLinkManagerBluetooth checkBluetoothPairingState]_block_invoke", 2061);
    }
  }
  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v5 = (id)qword_1001E4708;
  sub_1000A5428();

}

void sub_10002F2BC(uint64_t a1, int a2, void *a3)
{
  id v5;
  id v6;

  v6 = a3;
  if (a2)
  {
    if (qword_1001E45C0 != -1)
      dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
    if (_NRLogIsLevelEnabled(qword_1001E45B8, 1))
    {
      if (qword_1001E45C0 != -1)
        dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
      _NRLogWithArgs(qword_1001E45B8, 1, "%s%.30s:%-4d paired BT device %@", "", "-[NRLinkManagerBluetooth checkBluetoothPairingState]_block_invoke_2", 2083, v6);
    }
    sub_10013E73C((uint64_t)NRDLocalDevice, v6, *(void **)(a1 + 32));
  }
  else
  {
    if (qword_1001E45C0 != -1)
      dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
    if (_NRLogIsLevelEnabled(qword_1001E45B8, 16))
    {
      if (qword_1001E45C0 != -1)
        dispatch_once(&qword_1001E45C0, &stru_1001B64E0);
      _NRLogWithArgs(qword_1001E45B8, 16, "%s%.30s:%-4d failed to pair BT device", "", "-[NRLinkManagerBluetooth checkBluetoothPairingState]_block_invoke_2", 2086);
    }
  }
  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v5 = (id)qword_1001E4708;
  sub_1000A5428();

}

void sub_10002F478(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  id v3;
  id v4;
  id v5;
  uint64_t v6;
  void *i;
  const __CFString *v8;
  void *v9;
  id v10;
  uint64_t v11;
  void *v12;
  id v13;
  char *v14;
  id WeakRetained;
  uint64_t v16;
  id v17;
  void *v18;
  unsigned __int8 v19;
  void *v20;
  void *v21;
  void *v22;
  id v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  id obj;
  id *location;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  _BYTE v34[128];

  if (a1)
  {
    v1 = a1;
    v2 = *(id *)(a1 + 24);
    dispatch_assert_queue_V2(v2);

    sub_10002E228(v1);
    v3 = objc_msgSend(*(id *)(v1 + 56), "copy");
    v30 = 0u;
    v31 = 0u;
    v32 = 0u;
    v33 = 0u;
    obj = v3;
    v4 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v30, v34, 16);
    if (v4)
    {
      v5 = v4;
      v6 = *(_QWORD *)v31;
      location = (id *)(v1 + 16);
      do
      {
        for (i = 0; i != v5; i = (char *)i + 1)
        {
          if (*(_QWORD *)v31 != v6)
            objc_enumerationMutation(obj);
          v11 = *(_QWORD *)(*((_QWORD *)&v30 + 1) + 8 * (_QWORD)i);
          if (v11)
            v12 = *(void **)(v11 + 327);
          else
            v12 = 0;
          v13 = v12;
          objc_opt_self(NRDLocalDevice);
          v14 = sub_100134B14((uint64_t)NRDLocalDevice, v13, 1);

          WeakRetained = objc_loadWeakRetained((id *)(v1 + 128));
          if (!v14)
          {
            objc_msgSend((id)v11, "cancelWithReason:", CFSTR("Device has been disabled %@"), 0);
            v9 = 0;
            goto LABEL_8;
          }
          if (!v14[9])
          {
            v8 = CFSTR("Device has been disabled %@");
LABEL_7:
            objc_msgSend((id)v11, "cancelWithReason:", v8, v14);
            v9 = (void *)*((_QWORD *)v14 + 4);
LABEL_8:
            v10 = v9;
            objc_msgSend(WeakRetained, "pipeDidConnectForNRUUID:nrUUID:", 0, v10);

            goto LABEL_9;
          }
          v16 = v1;
          v17 = objc_loadWeakRetained(location);
          v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v11, "nrUUID"));
          v19 = objc_msgSend(v17, "perpetualStandaloneMeadowEnabledForNRUUID:", v18);

          v1 = v16;
          v8 = CFSTR("Perpetual standalone Meadow mode enabled for %@");
          if ((v19 & 1) != 0)
            goto LABEL_7;
LABEL_9:

        }
        v5 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v30, v34, 16);
      }
      while (v5);
    }

    v20 = *(void **)(v1 + 64);
    if (v20)
      sub_10002CFC8(v1, (unint64_t)objc_msgSend(v20, "state"));
    v21 = *(void **)(v1 + 80);
    if (v21)
      sub_10002A7C4((_QWORD *)v1, (uint64_t)objc_msgSend(v21, "state"));
    v22 = *(void **)(v1 + 72);
    if (v22)
      sub_10002D33C((_QWORD *)v1, (unint64_t)objc_msgSend(v22, "state"));
    v23 = sub_100137B34((uint64_t)NRDLocalDevice);
    if (!objc_msgSend(v23, "count"))
    {
      if (*(_QWORD *)(v1 + 80))
      {
        sub_100029644(v1);
        objc_msgSend(*(id *)(v1 + 80), "setDelegate:", 0);
        v24 = *(void **)(v1 + 80);
        *(_QWORD *)(v1 + 80) = 0;

      }
      v25 = *(void **)(v1 + 88);
      *(_QWORD *)(v1 + 88) = 0;

      if (*(_QWORD *)(v1 + 72))
      {
        sub_10002BC58((id *)v1);
        objc_msgSend(*(id *)(v1 + 72), "setDelegate:", 0);
        v26 = *(void **)(v1 + 72);
        *(_QWORD *)(v1 + 72) = 0;

      }
      *(_BYTE *)(v1 + 33) = 0;
      sub_10002DC4C(v1);
      v27 = *(void **)(v1 + 144);
      *(_QWORD *)(v1 + 144) = 0;

    }
    sub_10002E9DC(v1);

  }
}

void sub_10002FC8C(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  int v4;
  unsigned __int8 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  int v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *WeakRetained;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  int IsLevelEnabled;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  int v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  _QWORD *v35;

  v3 = *(_QWORD *)(a1 + 32);
  if (!v3)
  {
    v21 = 0;
LABEL_18:
    v22 = (void *)_NRCopyLogObjectForNRUUID(v21, a2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v22, 17);

    if (IsLevelEnabled)
    {
      v25 = *(_QWORD *)(a1 + 32);
      if (v25)
        v26 = *(_QWORD *)(v25 + 40);
      else
        v26 = 0;
      v35 = (_QWORD *)_NRCopyLogObjectForNRUUID(v26, v24);
      _NRLogWithArgs(v35, 17, "Received an unexpected unassertAgent call");
      goto LABEL_30;
    }
    return;
  }
  v4 = *(_DWORD *)(v3 + 16);
  if (!v4)
  {
    v21 = *(_QWORD *)(v3 + 40);
    goto LABEL_18;
  }
  *(_DWORD *)(v3 + 16) = v4 - 1;
  v5 = objc_msgSend(*(id *)(a1 + 32), "isActive");
  v7 = *(_QWORD *)(a1 + 32);
  if ((v5 & 1) != 0)
  {
    if (v7)
      v8 = *(_QWORD *)(v7 + 40);
    else
      v8 = 0;
    v9 = (void *)_NRCopyLogObjectForNRUUID(v8, v6);
    v10 = _NRLogIsLevelEnabled(v9, 0);

    if (v10)
    {
      v11 = *(_QWORD **)(a1 + 32);
      if (v11)
        v11 = (_QWORD *)v11[5];
      v12 = v11;
      v14 = _NRCopyLogObjectForNRUUID(v12, v13);
      v15 = (void *)v14;
      v16 = *(_QWORD *)(a1 + 32);
      if (v16)
        LODWORD(v16) = *(_DWORD *)(v16 + 16);
      _NRLogWithArgs(v14, 0, "%s%.30s:%-4d Quick relay agent un-asserted (Total remaining assertions: %u)", "", "-[NRQuickRelayAgent unassertAgentWithOptions:]_block_invoke", 241, v16);

    }
    v17 = *(_QWORD *)(a1 + 32);
    if (!v17)
    {
      WeakRetained = 0;
      v20 = 0;
LABEL_16:
      v35 = WeakRetained;
      objc_msgSend(WeakRetained, "deviceHasQuickRelayRequest:hasQuickRelayRequest:", v20, 0);
LABEL_30:

      return;
    }
    if (!*(_DWORD *)(v17 + 16))
    {
      WeakRetained = objc_loadWeakRetained((id *)(v17 + 64));
      v19 = *(_QWORD *)(a1 + 32);
      if (v19)
        v20 = *(_QWORD *)(v19 + 40);
      else
        v20 = 0;
      goto LABEL_16;
    }
  }
  else
  {
    if (v7)
      v27 = *(_QWORD *)(v7 + 40);
    else
      v27 = 0;
    v28 = (void *)_NRCopyLogObjectForNRUUID(v27, v6);
    v29 = _NRLogIsLevelEnabled(v28, 0);

    if (v29)
    {
      v30 = *(_QWORD **)(a1 + 32);
      if (v30)
        v30 = (_QWORD *)v30[5];
      v35 = v30;
      v32 = _NRCopyLogObjectForNRUUID(v35, v31);
      v33 = (void *)v32;
      v34 = *(_QWORD *)(a1 + 32);
      if (v34)
        LODWORD(v34) = *(_DWORD *)(v34 + 16);
      _NRLogWithArgs(v32, 0, "%s%.30s:%-4d Ignoring quick relay agent un-assert (Total remaining assertions: %u)", "", "-[NRQuickRelayAgent unassertAgentWithOptions:]_block_invoke", 237, v34);

      goto LABEL_30;
    }
  }
}

void sub_10002FEAC(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  unsigned __int8 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  int IsLevelEnabled;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *WeakRetained;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  int v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  _QWORD *v28;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
  {
    ++*(_DWORD *)(v2 + 16);
    v3 = *(void **)(a1 + 32);
  }
  else
  {
    v3 = 0;
  }
  v4 = objc_msgSend(v3, "isActive");
  v6 = *(_QWORD *)(a1 + 32);
  if ((v4 & 1) != 0)
  {
    if (v6)
      v7 = *(_QWORD *)(v6 + 40);
    else
      v7 = 0;
    v8 = (void *)_NRCopyLogObjectForNRUUID(v7, v5);
    IsLevelEnabled = _NRLogIsLevelEnabled(v8, 0);

    if (IsLevelEnabled)
    {
      v10 = *(_QWORD **)(a1 + 32);
      if (v10)
        v10 = (_QWORD *)v10[5];
      v11 = v10;
      v13 = _NRCopyLogObjectForNRUUID(v11, v12);
      v14 = (void *)v13;
      v15 = *(_QWORD *)(a1 + 32);
      if (v15)
        LODWORD(v15) = *(_DWORD *)(v15 + 16);
      _NRLogWithArgs(v13, 0, "%s%.30s:%-4d Quick relay agent asserted (Total active assertions: %u)", "", "-[NRQuickRelayAgent assertAgentWithOptions:]_block_invoke", 219, v15);

    }
    v16 = *(_QWORD *)(a1 + 32);
    if (v16)
    {
      WeakRetained = objc_loadWeakRetained((id *)(v16 + 64));
      v18 = *(_QWORD *)(a1 + 32);
      if (v18)
        v19 = *(_QWORD *)(v18 + 40);
      else
        v19 = 0;
    }
    else
    {
      WeakRetained = 0;
      v19 = 0;
    }
    v28 = WeakRetained;
    objc_msgSend(WeakRetained, "deviceHasQuickRelayRequest:hasQuickRelayRequest:", v19, 1);
LABEL_24:

    return;
  }
  if (v6)
    v20 = *(_QWORD *)(v6 + 40);
  else
    v20 = 0;
  v21 = (void *)_NRCopyLogObjectForNRUUID(v20, v5);
  v22 = _NRLogIsLevelEnabled(v21, 0);

  if (v22)
  {
    v23 = *(_QWORD **)(a1 + 32);
    if (v23)
      v23 = (_QWORD *)v23[5];
    v28 = v23;
    v25 = _NRCopyLogObjectForNRUUID(v28, v24);
    v26 = (void *)v25;
    v27 = *(_QWORD *)(a1 + 32);
    if (v27)
      LODWORD(v27) = *(_DWORD *)(v27 + 16);
    _NRLogWithArgs(v25, 0, "%s%.30s:%-4d Ignoring quick relay agent assert (Total active assertions: %u)", "", "-[NRQuickRelayAgent assertAgentWithOptions:]_block_invoke", 215, v27);

    goto LABEL_24;
  }
}

id *sub_1000300F0(id *a1, void *a2, void *a3, void *a4)
{
  id v8;
  id v9;
  id v10;
  id *v11;
  id *v12;
  void *v13;
  id v14;
  void *v15;
  void *v16;
  id v17;
  id v18;
  char *v19;
  char *v20;
  id v21;
  id v22;
  id v23;
  id v24;
  id v25;
  void *v26;
  void *v27;
  id v29;
  int v30;
  id v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  id v36;
  int v37;
  id v38;
  uint64_t v39;
  uint64_t v40;
  id v41;
  int v42;
  id v43;
  uint64_t v44;
  uint64_t v45;
  id v46;
  int IsLevelEnabled;
  id v48;
  uint64_t v49;
  int *v50;
  uint64_t v51;
  id v52;
  uint64_t v53;
  objc_super v54;

  v8 = a2;
  v9 = a3;
  v10 = a4;
  if (a1)
  {
    if (v8)
    {
      if (v9)
      {
        v54.receiver = a1;
        v54.super_class = (Class)NRQuickRelayAgent;
        v11 = (id *)objc_msgSendSuper2(&v54, "init");
        if (v11)
        {
          v12 = v11;
          objc_storeStrong(v11 + 6, a3);
          objc_storeStrong(v12 + 5, a2);
          v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](NSUUID, "UUID"));
          objc_msgSend(v12, "setAgentUUID:", v13);

          objc_msgSend(v12, "setUserActivated:", 1);
          objc_msgSend(v12, "setSpecificUseOnly:", 1);
          objc_msgSend(v12, "setAgentDescription:", CFSTR("Quick relay netagent"));
          objc_storeWeak(v12 + 8, v10);
          v14 = objc_alloc((Class)NSString);
          v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "agentUUID"));
          v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "UUIDString"));
          v17 = objc_msgSend(v14, "initWithFormat:", CFSTR("NRQuickRelayAgent-%@"), v16);
          v18 = v12[9];
          v12[9] = v17;

          v19 = sub_10012FFF4((uint64_t)NRDLocalDevice, v12[5]);
          if (v19)
          {
            v20 = v19;
            v21 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%@"), v19);
            v22 = v12[10];
            v12[10] = v21;

            v23 = v12[5];
            v24 = v12[10];
            v25 = v23;
            v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "agentUUID"));
            v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "UUIDString"));
            sub_100121E18(v25, 17001, v24, v27);

            a1 = v12;
            goto LABEL_7;
          }
          v46 = sub_1000305DC();
          IsLevelEnabled = _NRLogIsLevelEnabled(v46, 16);

          if (IsLevelEnabled)
          {
            v48 = sub_1000305DC();
            _NRLogWithArgs(v48, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)", "", "-[NRQuickRelayAgent initWithNRUUID:queue:delegate:]", 62);

          }
          v49 = _os_log_pack_size(12);
          v33 = (char *)&v53 - ((v49 + 15) & 0xFFFFFFFFFFFFFFF0);
          v50 = __error();
          v51 = _os_log_pack_fill(v33, v49, *v50, &_mh_execute_header, "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
          *(_DWORD *)v51 = 136446210;
          *(_QWORD *)(v51 + 4) = "-[NRQuickRelayAgent initWithNRUUID:queue:delegate:]";
LABEL_21:
          v52 = sub_1000305DC();
          _NRLogAbortWithPack(v52, v33);
        }
        v41 = sub_1000305DC();
        v42 = _NRLogIsLevelEnabled(v41, 16);

        if (v42)
        {
          v43 = sub_1000305DC();
          _NRLogWithArgs(v43, 16, "%s%.30s:%-4d ABORTING: [super init] failed", "", "-[NRQuickRelayAgent initWithNRUUID:queue:delegate:]", 49);

        }
        v44 = _os_log_pack_size(12);
        v33 = (char *)&v53 - ((v44 + 15) & 0xFFFFFFFFFFFFFFF0);
        v45 = *__error();
        v35 = _os_log_pack_fill(v33, v44, v45, &_mh_execute_header, "%{public}s [super init] failed");
      }
      else
      {
        v36 = sub_1000305DC();
        v37 = _NRLogIsLevelEnabled(v36, 16);

        if (v37)
        {
          v38 = sub_1000305DC();
          _NRLogWithArgs(v38, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (queue) != ((void *)0)", "", "-[NRQuickRelayAgent initWithNRUUID:queue:delegate:]", 47);

        }
        v39 = _os_log_pack_size(12);
        v33 = (char *)&v53 - ((v39 + 15) & 0xFFFFFFFFFFFFFFF0);
        v40 = *__error();
        v35 = _os_log_pack_fill(v33, v39, v40, &_mh_execute_header, "%{public}s Assertion Failed: (queue) != ((void *)0)");
      }
    }
    else
    {
      v29 = sub_1000305DC();
      v30 = _NRLogIsLevelEnabled(v29, 16);

      if (v30)
      {
        v31 = sub_1000305DC();
        _NRLogWithArgs(v31, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)", "", "-[NRQuickRelayAgent initWithNRUUID:queue:delegate:]", 46);

      }
      v32 = _os_log_pack_size(12);
      v33 = (char *)&v53 - ((v32 + 15) & 0xFFFFFFFFFFFFFFF0);
      v34 = *__error();
      v35 = _os_log_pack_fill(v33, v32, v34, &_mh_execute_header, "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
    }
    *(_DWORD *)v35 = 136446210;
    *(_QWORD *)(v35 + 4) = "-[NRQuickRelayAgent initWithNRUUID:queue:delegate:]";
    goto LABEL_21;
  }
LABEL_7:

  return a1;
}

id sub_1000305DC()
{
  if (qword_1001E45D0 != -1)
    dispatch_once(&qword_1001E45D0, &stru_1001B6570);
  return (id)qword_1001E45C8;
}

void sub_10003061C(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001E45C8;
  qword_1001E45C8 = (uint64_t)v1;

}

void sub_10003064C(uint64_t a1)
{
  void *v2;
  id v3;
  id v4;
  void *v5;
  void *v6;
  id WeakRetained;

  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 48));
    if (objc_msgSend((id)a1, "isActive"))
    {
      objc_msgSend((id)a1, "setActive:", 0);
      objc_msgSend(*(id *)(a1 + 56), "updateNetworkAgent:", a1);
      v2 = *(void **)(a1 + 40);
      v3 = *(id *)(a1 + 80);
      v4 = v2;
      v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "agentUUID"));
      v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "UUIDString"));
      sub_100121E18(v4, 17004, v3, v6);

      WeakRetained = objc_loadWeakRetained((id *)(a1 + 64));
      objc_msgSend(WeakRetained, "deviceHasQuickRelayRequest:hasQuickRelayRequest:", *(_QWORD *)(a1 + 40), 0);

    }
  }
}

void sub_10003073C(uint64_t a1)
{
  id WeakRetained;
  void *v3;
  id v4;
  void *v5;
  void *v6;
  id v7;

  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 48));
    if ((objc_msgSend((id)a1, "isActive") & 1) == 0)
    {
      objc_msgSend((id)a1, "setActive:", 1);
      objc_msgSend(*(id *)(a1 + 56), "updateNetworkAgent:", a1);
      if (*(_DWORD *)(a1 + 16))
      {
        WeakRetained = objc_loadWeakRetained((id *)(a1 + 64));
        objc_msgSend(WeakRetained, "deviceHasQuickRelayRequest:hasQuickRelayRequest:", *(_QWORD *)(a1 + 40), 1);

      }
      v3 = *(void **)(a1 + 40);
      v4 = *(id *)(a1 + 80);
      v7 = v3;
      v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "agentUUID"));
      v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "UUIDString"));
      sub_100121E18(v7, 17005, v4, v6);

    }
  }
}

void sub_100031EE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  id *v20;

  objc_destroyWeak(v20);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000321C4(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 56));
  _Unwind_Resume(a1);
}

void sub_100032BD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

id sub_100032FF0()
{
  if (qword_1001E45E0 != -1)
    dispatch_once(&qword_1001E45E0, &stru_1001B6608);
  return (id)qword_1001E45D8;
}

void sub_100033030(uint64_t a1, int a2)
{
  _QWORD *WeakRetained;
  BOOL v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  int v8;
  uint64_t v9;
  void *v10;
  id v11;
  int IsLevelEnabled;
  uint64_t v13;
  void *v14;
  id v15;
  _QWORD *v16;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v16 = WeakRetained;
    v4 = objc_msgSend(WeakRetained, "state") == 255;
    WeakRetained = v16;
    if (!v4)
    {
      v6 = _NRCopyLogObjectForNRUUID(v16[4], v5);
      v7 = (void *)v6;
      if (!a2)
      {
        IsLevelEnabled = _NRLogIsLevelEnabled(v6, 16);

        if (IsLevelEnabled)
        {
          v14 = (void *)_NRCopyLogObjectForNRUUID(v16[4], v13);
          v15 = objc_msgSend(v16, "copyDescription");
          _NRLogWithArgs(v14, 16, "%s%.30s:%-4d %@: Did not receive response to control notify", "", "-[NRLinkWiFi sendControlData:]_block_invoke", 1207, v15);

        }
        objc_msgSend(v16, "cancelWithReason:", CFSTR("peer is NOT available (Did not receive response to control notify)"));
        goto LABEL_9;
      }
      v8 = _NRLogIsLevelEnabled(v6, 0);

      WeakRetained = v16;
      if (v8)
      {
        v10 = (void *)_NRCopyLogObjectForNRUUID(v16[4], v9);
        v11 = objc_msgSend(v16, "copyDescription");
        _NRLogWithArgs(v10, 0, "%s%.30s:%-4d %@: Received response to control notify", "", "-[NRLinkWiFi sendControlData:]_block_invoke", 1205, v11);

LABEL_9:
        WeakRetained = v16;
      }
    }
  }

}

void sub_100033170(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001E45D8;
  qword_1001E45D8 = (uint64_t)v1;

}

void sub_1000331A0(uint64_t a1)
{
  void *v2;
  id v3;
  id v4;
  id v5;
  id v6;
  id v7;
  id v8;
  id v9;
  id v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  void *v14;
  id v15;
  id v16;
  int IsLevelEnabled;
  id *v18;
  id v19;
  void **v20;
  uint64_t v21;
  void (*v22)(uint64_t, void *);
  void *v23;
  id v24;
  id v25;
  _QWORD v26[4];
  id v27;
  id v28;
  _QWORD v29[4];
  id v30;
  id v31;
  _QWORD v32[4];
  id v33;
  id v34;
  _QWORD v35[4];
  id v36;
  id v37;
  _QWORD v38[4];
  id v39;
  id v40;
  _QWORD v41[4];
  id v42;
  id v43;
  id location[2];

  if (a1)
  {
    v2 = *(void **)(a1 + 255);
    if (v2)
    {
      objc_msgSend(v2, "setClientQueue:", *(_QWORD *)(a1 + 8));
      objc_initWeak(location, (id)a1);
      v3 = *(id *)(a1 + 255);
      v41[0] = _NSConcreteStackBlock;
      v41[1] = 3221225472;
      v41[2] = sub_100033618;
      v41[3] = &unk_1001B6C10;
      v18 = &v43;
      objc_copyWeak(&v43, location);
      v4 = v3;
      v42 = v4;
      objc_msgSend(*(id *)(a1 + 255), "setStateUpdateBlock:", v41);
      v38[0] = _NSConcreteStackBlock;
      v38[1] = 3221225472;
      v38[2] = sub_100033DD8;
      v38[3] = &unk_1001B6C38;
      objc_copyWeak(&v40, location);
      v5 = v4;
      v39 = v5;
      objc_msgSend(*(id *)(a1 + 255), "setChildStateUpdateBlock:", v38);
      v35[0] = _NSConcreteStackBlock;
      v35[1] = 3221225472;
      v35[2] = sub_100033F94;
      v35[3] = &unk_1001B6C60;
      objc_copyWeak(&v37, location);
      v6 = v5;
      v36 = v6;
      objc_msgSend(*(id *)(a1 + 255), "setConfigurationUpdateBlock:", v35);
      v32[0] = _NSConcreteStackBlock;
      v32[1] = 3221225472;
      v32[2] = sub_10003405C;
      v32[3] = &unk_1001B6C88;
      objc_copyWeak(&v34, location);
      v7 = v6;
      v33 = v7;
      objc_msgSend(*(id *)(a1 + 255), "setTrafficSelectorUpdateBlock:", v32);
      v29[0] = _NSConcreteStackBlock;
      v29[1] = 3221225472;
      v29[2] = sub_100034148;
      v29[3] = &unk_1001B6CB0;
      objc_copyWeak(&v31, location);
      v8 = v7;
      v30 = v8;
      objc_msgSend(*(id *)(a1 + 255), "setAdditionalAddressesUpdateBlock:", v29);
      v26[0] = _NSConcreteStackBlock;
      v26[1] = 3221225472;
      v26[2] = sub_100034210;
      v26[3] = &unk_1001B87F0;
      objc_copyWeak(&v28, location);
      v9 = v8;
      v27 = v9;
      objc_msgSend(*(id *)(a1 + 255), "setShortDPDEventBlock:", v26);
      v20 = _NSConcreteStackBlock;
      v21 = 3221225472;
      v22 = sub_1000342D0;
      v23 = &unk_1001B6CB0;
      objc_copyWeak(&v25, location);
      v10 = v9;
      v24 = v10;
      objc_msgSend(*(id *)(a1 + 255), "setPrivateNotifyStatusEvent:", &v20);
      v12 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v11);
      LOBYTE(v3) = _NRLogIsLevelEnabled(v12, 0);

      if ((v3 & 1) != 0)
      {
        v14 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v13);
        v15 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v14, 0, "%s%.30s:%-4d %@: Setup IKE classC callbacks %@", "", "-[NRLinkWiFi setupIKECallbacksClassC]", 984, v15, v10, &v43, v20, v21, v22, v23);

      }
      objc_destroyWeak(&v25);

      objc_destroyWeak(&v28);
      objc_destroyWeak(&v31);

      objc_destroyWeak(&v34);
      objc_destroyWeak(&v37);

      objc_destroyWeak(&v40);
      objc_destroyWeak(v18);

      objc_destroyWeak(location);
    }
    else
    {
      v16 = sub_100032FF0();
      IsLevelEnabled = _NRLogIsLevelEnabled(v16, 17);

      if (IsLevelEnabled)
      {
        v19 = sub_100032FF0();
        _NRLogWithArgs(v19, 17, "%s called with null _ikeSessionClassC", "-[NRLinkWiFi setupIKECallbacksClassC]");

      }
    }
  }
}

void sub_100033598(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id *location)
{
  id *v14;
  id *v15;
  id *v16;
  id *v17;
  id *v18;
  id *v19;
  uint64_t v20;

  objc_destroyWeak(v19);
  objc_destroyWeak(v18);
  objc_destroyWeak(v17);
  objc_destroyWeak(v16);
  objc_destroyWeak(v15);
  objc_destroyWeak(v14);
  objc_destroyWeak(location);
  objc_destroyWeak((id *)(v20 - 112));
  _Unwind_Resume(a1);
}

void sub_100033618(uint64_t a1, uint64_t a2, void *a3)
{
  char *WeakRetained;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  id v9;
  void *v10;
  unsigned int v11;
  uint64_t v12;
  void *SessionStateString;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  void *v17;
  int IsLevelEnabled;
  uint64_t v19;
  void *v20;
  id v21;
  uint64_t v22;
  void *v23;
  id v24;
  uint64_t v25;
  void *v26;
  id v27;
  void *v28;
  unsigned int v29;
  unsigned int v30;
  uint64_t v31;
  void *v32;
  int v33;
  uint64_t v34;
  void *v35;
  id v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;
  int v43;
  uint64_t v44;
  void *v45;
  id v46;
  void *v47;
  id v48;
  uint64_t v49;
  uint64_t v50;
  void *v51;
  void *v52;
  void *v53;
  char *v54;
  char *v55;
  void *v56;
  id v57;
  NRCompanionProxyAgent *v58;
  void *v59;
  void *v60;
  id *v61;
  void *v62;
  void *v63;
  uint64_t v64;
  char v65;
  uint64_t v66;
  int v67;
  uint64_t v68;
  void *v69;
  int v70;
  uint64_t v71;
  void *v72;
  id v73;
  uint64_t v74;
  uint64_t v75;
  id v76;

  v76 = a3;
  WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 40));
  if (!WeakRetained)
    goto LABEL_59;
  if (v76)
  {
    if ((objc_msgSend(WeakRetained, "ikeClassCEstablished") & 1) == 0)
    {
      v6 = mach_absolute_time();
      v7 = *(_QWORD *)(WeakRetained + 271);
      if (v7)
        *(_QWORD *)(v7 + 40) = v6;
    }
    objc_msgSend(WeakRetained, "setIkeClassDEstablished:", 0);
    objc_msgSend(WeakRetained, "setIkeClassCEstablished:", 0);
    WeakRetained[83] = 0;
    v8 = NEIKEv2ErrorDomain;
    v9 = v76;
    if (objc_msgSend(v9, "code") == (id)4)
    {
      v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "domain"));
      v11 = objc_msgSend(v10, "isEqualToString:", v8);

      if (v11)
      {
        v12 = *(_QWORD *)(a1 + 32);
        SessionStateString = (void *)NEIKEv2CreateSessionStateString(a2);
        objc_msgSend(WeakRetained, "cancelWithReason:", CFSTR("ClassC session %@ got IKE error %@ with state %@"), v12, v9, SessionStateString);
LABEL_58:

        goto LABEL_59;
      }
    }
    else
    {

    }
    v22 = *(_QWORD *)(a1 + 32);
    v23 = (void *)NEIKEv2CreateSessionStateString(a2);
    objc_msgSend(WeakRetained, "reportEvent:detailsFormat:", 3018, CFSTR("ClassC session %@ got IKE error %@ with state %@"), v22, v9, v23);

    objc_msgSend(WeakRetained, "processIKEDisconnection:error:", 3, v9);
    if (objc_msgSend(WeakRetained, "state") == 255)
      goto LABEL_59;
    v24 = v9;
    if (objc_msgSend(v24, "code") == (id)24)
    {
      v25 = NEIKEv2ProtocolErrorDomain;
      v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v24, "domain"));
      LOBYTE(v25) = objc_msgSend(v26, "isEqualToString:", v25);

      if ((v25 & 1) != 0)
        goto LABEL_22;
    }
    else
    {

    }
    v27 = v24;
    if (objc_msgSend(v27, "code") == (id)8)
    {
      v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v27, "domain"));
      v29 = objc_msgSend(v28, "isEqualToString:", v8);

      if (v29)
      {
LABEL_22:
        sub_100034568(WeakRetained);
        goto LABEL_59;
      }
    }
    else
    {

    }
    sub_100034690((uint64_t)WeakRetained);
    goto LABEL_59;
  }
  v14 = *(_QWORD *)(a1 + 32);
  v15 = (void *)NEIKEv2CreateSessionStateString(a2);
  objc_msgSend(WeakRetained, "reportEvent:detailsFormat:", 3009, CFSTR("ClassC session %@ changed state to %@"), v14, v15);

  switch(a2)
  {
    case 1:
      if (objc_msgSend(WeakRetained, "state") == 1)
      {
        v17 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 4), v16);
        IsLevelEnabled = _NRLogIsLevelEnabled(v17, 0);

        if (IsLevelEnabled)
        {
          v20 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 4), v19);
          v21 = objc_msgSend(WeakRetained, "copyDescription");
          _NRLogWithArgs(v20, 0, "%s%.30s:%-4d %@: ClassC IKE %@ now connecting", "", "-[NRLinkWiFi setupIKECallbacksClassC]_block_invoke", 836, v21, *(_QWORD *)(a1 + 32));

        }
        objc_msgSend(WeakRetained, "changeStateTo:", 5);
      }
      else
      {
        v39 = objc_msgSend(WeakRetained, "state");
        v41 = _NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 4), v40);
        v42 = (void *)v41;
        if (v39 == 5)
        {
          v43 = _NRLogIsLevelEnabled(v41, 0);

          if (!v43)
            break;
          v45 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 4), v44);
          v46 = objc_msgSend(WeakRetained, "copyDescription");
          _NRLogWithArgs(v45, 0, "%s%.30s:%-4d %@: ClassC IKE %@ already connecting", "", "-[NRLinkWiFi setupIKECallbacksClassC]_block_invoke", 839, v46, *(_QWORD *)(a1 + 32));
        }
        else
        {
          v67 = _NRLogIsLevelEnabled(v41, 16);

          if (!v67)
            break;
          v45 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 4), v68);
          v46 = objc_msgSend(WeakRetained, "copyDescription");
          _NRLogWithArgs(v45, 16, "%s%.30s:%-4d %@: ClassC IKE %@ connecting but weird state", "", "-[NRLinkWiFi setupIKECallbacksClassC]_block_invoke", 841, v46, *(_QWORD *)(a1 + 32));
        }

      }
      break;
    case 2:
      objc_msgSend(WeakRetained, "setIkeClassDEstablished:", 1);
      objc_msgSend(WeakRetained, "setIkeClassCEstablished:", 1);
      v30 = objc_msgSend(WeakRetained, "state");
      v32 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 4), v31);
      v33 = _NRLogIsLevelEnabled(v32, 0);

      if (v30 == 8)
      {
        if (v33)
        {
          v35 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 4), v34);
          v36 = objc_msgSend(WeakRetained, "copyDescription");
          _NRLogWithArgs(v35, 0, "%s%.30s:%-4d %@: ClassC IKE %@ already ready", "", "-[NRLinkWiFi setupIKECallbacksClassC]_block_invoke", 847, v36, *(_QWORD *)(a1 + 32));

        }
      }
      else
      {
        if (v33)
        {
          v47 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 4), v34);
          v48 = objc_msgSend(WeakRetained, "copyDescription");
          _NRLogWithArgs(v47, 0, "%s%.30s:%-4d %@: ClassC IKE %@ now connected from started", "", "-[NRLinkWiFi setupIKECallbacksClassC]_block_invoke", 849, v48, *(_QWORD *)(a1 + 32));

        }
        objc_msgSend(WeakRetained, "setPowerAssertionState:", 0);
        objc_msgSend(WeakRetained, "changeStateTo:detailsFormat:", 8, CFSTR("(ClassC IKE %@ connected after received first notify)"), *(_QWORD *)(a1 + 32));
        v49 = mach_absolute_time();
        v50 = *(_QWORD *)(WeakRetained + 271);
        if (v50)
          *(_QWORD *)(v50 + 40) = v49;
        *(_DWORD *)(WeakRetained + 223) = 0;
        sub_1000353EC(WeakRetained);
        if (objc_msgSend(WeakRetained, "shouldCreateCompanionProxyAgent"))
        {
          v51 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "companionProxyAgent"));

          if (!v51)
          {
            v52 = (void *)NEVirtualInterfaceCopyName(objc_msgSend(WeakRetained, "virtualInterface"));
            v53 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "nrUUID"));
            v54 = sub_10012FFF4((uint64_t)NRDLocalDevice, v53);
            v55 = v54;
            if (v54)
              v56 = (void *)*((_QWORD *)v54 + 14);
            else
              v56 = 0;
            v57 = v56;

            if (v52 && v57)
            {
              v58 = [NRCompanionProxyAgent alloc];
              v59 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "queue"));
              v60 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "nrUUID"));
              v61 = sub_10005E2AC((id *)&v58->super.isa, v59, v52, v57, v60);
              v62 = (void *)*((_QWORD *)WeakRetained + 11);
              *((_QWORD *)WeakRetained + 11) = v61;

              objc_msgSend(WeakRetained, "reportEvent:", 12001);
            }

          }
          v63 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "companionProxyAgent"));
          v65 = sub_10005E5B8((uint64_t)v63, v64);

          if ((v65 & 1) != 0)
          {
            objc_msgSend(WeakRetained, "reportEvent:", 12002);
          }
          else
          {
            v69 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 4), v66);
            v70 = _NRLogIsLevelEnabled(v69, 16);

            if (v70)
            {
              v72 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 4), v71);
              v73 = objc_msgSend(WeakRetained, "copyDescription");
              _NRLogWithArgs(v72, 16, "%s%.30s:%-4d %@: failed to register companion agent", "", "-[NRLinkWiFi setupIKECallbacksClassC]_block_invoke", 873, v73);

            }
          }
        }
      }
      SessionStateString = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "linkDelegate"));
      objc_msgSend(SessionStateString, "linkIsReady:", WeakRetained);
      goto LABEL_58;
    case 3:
      if ((objc_msgSend(WeakRetained, "ikeClassCEstablished") & 1) == 0)
      {
        v37 = mach_absolute_time();
        v38 = *(_QWORD *)(WeakRetained + 271);
        if (v38)
          *(_QWORD *)(v38 + 40) = v37;
      }
      objc_msgSend(WeakRetained, "setIkeClassDEstablished:", 0);
      objc_msgSend(WeakRetained, "setIkeClassCEstablished:", 0);
      WeakRetained[83] = 0;
      objc_msgSend(WeakRetained, "reportEvent:detailsFormat:", 3018, CFSTR("ClassC session %@ cancelled by peer"), *(_QWORD *)(a1 + 32));
      objc_msgSend(WeakRetained, "cancelWithReason:", CFSTR("ClassC session %@ cancelled by peer"));
      break;
    case 4:
      objc_msgSend(WeakRetained, "cancelWithReason:", CFSTR("ClassC session %@ got unexpected MOBIKE state"), *(_QWORD *)(a1 + 32));
      break;
    default:
      SessionStateString = (void *)NEIKEv2CreateSessionStateString(a2);
      objc_msgSend(WeakRetained, "cancelWithReason:", CFSTR("ClassC session %@ got bad IKE state %@"), SessionStateString, v74, v75);
      goto LABEL_58;
  }
LABEL_59:

}

void sub_100033DD8(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id WeakRetained;
  uint64_t v8;
  void *v9;
  id v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  id v14;
  uint64_t v15;
  void *v16;
  void *SessionStateString;
  id v18;

  v18 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    if (!v18)
    {
      v13 = *(_QWORD *)(a1 + 32);
      if (a3 != 3)
      {
        SessionStateString = (void *)NEIKEv2CreateSessionStateString(a3);
        objc_msgSend(WeakRetained, "reportEvent:detailsFormat:", 3009, CFSTR("ClassC session %@ child %u state update %@"), v13, a2, SessionStateString);

        goto LABEL_16;
      }
      objc_msgSend(WeakRetained, "reportEvent:detailsFormat:", 3018, CFSTR("ClassC session %@ got child %u Disconnected state with no error"), v13, a2);
      goto LABEL_15;
    }
    v8 = *(_QWORD *)(a1 + 32);
    v9 = (void *)NEIKEv2CreateSessionStateString(a3);
    objc_msgSend(WeakRetained, "reportEvent:detailsFormat:", 3018, CFSTR("ClassC session %@ got child %u state update %@ error %@"), v8, a2, v9, v18);

    objc_msgSend(WeakRetained, "processIKEDisconnection:error:", 3, v18);
    if (objc_msgSend(WeakRetained, "state") != 255)
    {
      v10 = v18;
      if (objc_msgSend(v10, "code") == (id)24)
      {
        v11 = NEIKEv2ProtocolErrorDomain;
        v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "domain"));
        LOBYTE(v11) = objc_msgSend(v12, "isEqualToString:", v11);

        if ((v11 & 1) != 0)
          goto LABEL_12;
      }
      else
      {

      }
      v14 = v10;
      if (objc_msgSend(v14, "code") == (id)8)
      {
        v15 = NEIKEv2ErrorDomain;
        v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "domain"));
        LODWORD(v15) = objc_msgSend(v16, "isEqualToString:", v15);

        if ((_DWORD)v15)
        {
LABEL_12:
          sub_100034568((char *)WeakRetained);
          goto LABEL_16;
        }
      }
      else
      {

      }
LABEL_15:
      sub_100034690((uint64_t)WeakRetained);
    }
  }
LABEL_16:

}

void sub_100033F94(uint64_t a1, void *a2)
{
  _QWORD *WeakRetained;
  uint64_t v4;
  _QWORD *v5;
  void *v6;
  int IsLevelEnabled;
  uint64_t v8;
  void *v9;
  id v10;
  id v11;

  v11 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v5 = WeakRetained;
  if (WeakRetained)
  {
    v6 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0);

    if (IsLevelEnabled)
    {
      v9 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v8);
      v10 = objc_msgSend(v5, "copyDescription");
      _NRLogWithArgs(v9, 0, "%s%.30s:%-4d %@: ClassC session %@ got config update %@", "", "-[NRLinkWiFi setupIKECallbacksClassC]_block_invoke_3", 943, v10, *(_QWORD *)(a1 + 32), v11);

    }
  }

}

void sub_10003405C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v7;
  _QWORD *WeakRetained;
  uint64_t v9;
  _QWORD *v10;
  void *v11;
  int IsLevelEnabled;
  uint64_t v13;
  void *v14;
  id v15;
  id v16;

  v16 = a3;
  v7 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v10 = WeakRetained;
  if (WeakRetained)
  {
    v11 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v9);
    IsLevelEnabled = _NRLogIsLevelEnabled(v11, 0);

    if (IsLevelEnabled)
    {
      v14 = (void *)_NRCopyLogObjectForNRUUID(v10[4], v13);
      v15 = objc_msgSend(v10, "copyDescription");
      _NRLogWithArgs(v14, 0, "%s%.30s:%-4d %@: ClassC session %@ got child %u traffic selector update local %@ remote %@", "", "-[NRLinkWiFi setupIKECallbacksClassC]_block_invoke_4", 954, v15, *(_QWORD *)(a1 + 32), a2, v16, v7);

    }
  }

}

void sub_100034148(uint64_t a1, void *a2)
{
  _QWORD *WeakRetained;
  uint64_t v4;
  _QWORD *v5;
  void *v6;
  int IsLevelEnabled;
  uint64_t v8;
  void *v9;
  id v10;
  id v11;

  v11 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v5 = WeakRetained;
  if (WeakRetained)
  {
    v6 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0);

    if (IsLevelEnabled)
    {
      v9 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v8);
      v10 = objc_msgSend(v5, "copyDescription");
      _NRLogWithArgs(v9, 0, "%s%.30s:%-4d %@: ClassC session %@ got additional addresses %@", "", "-[NRLinkWiFi setupIKECallbacksClassC]_block_invoke_5", 962, v10, *(_QWORD *)(a1 + 32), v11);

    }
  }

}

void sub_100034210(uint64_t a1)
{
  _QWORD *WeakRetained;
  uint64_t v3;
  void *v4;
  int IsLevelEnabled;
  uint64_t v6;
  void *v7;
  id v8;
  _QWORD *v9;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    v9 = WeakRetained;
    v4 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v3);
    IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0);

    WeakRetained = v9;
    if (IsLevelEnabled)
    {
      v7 = (void *)_NRCopyLogObjectForNRUUID(v9[4], v6);
      v8 = objc_msgSend(v9, "copyDescription");
      _NRLogWithArgs(v7, 0, "%s%.30s:%-4d %@: ClassC session %@ got short DPD", "", "-[NRLinkWiFi setupIKECallbacksClassC]_block_invoke_6", 970, v8, *(_QWORD *)(a1 + 32));

      WeakRetained = v9;
    }
  }

}

void sub_1000342D0(uint64_t a1, void *a2)
{
  id v3;
  void **WeakRetained;
  uint64_t v5;
  void **v6;
  void *v7;
  int IsLevelEnabled;
  uint64_t v9;
  void *v10;
  id v11;
  id v12;
  id v13;
  id v14;
  uint64_t v15;
  void *i;
  void *v17;
  unsigned int v18;
  id v19;
  uint64_t v20;
  void *v21;
  int v22;
  uint64_t v23;
  void *v24;
  id v25;
  void *v26;
  id v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  _BYTE v32[128];

  v3 = a2;
  WeakRetained = (void **)objc_loadWeakRetained((id *)(a1 + 40));
  v6 = WeakRetained;
  if (WeakRetained)
  {
    v7 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v5);
    IsLevelEnabled = _NRLogIsLevelEnabled(v7, 0);

    if (IsLevelEnabled)
    {
      v10 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v9);
      v11 = objc_msgSend(v6, "copyDescription");
      _NRLogWithArgs(v10, 0, "%s%.30s:%-4d %@: ClassC session %@ got private notifies %@", "", "-[NRLinkWiFi setupIKECallbacksClassC]_block_invoke_7", 978, v11, *(_QWORD *)(a1 + 32), v3);

    }
    v30 = 0u;
    v31 = 0u;
    v28 = 0u;
    v29 = 0u;
    v27 = v3;
    v12 = v3;
    v13 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v28, v32, 16);
    if (v13)
    {
      v14 = v13;
      v15 = *(_QWORD *)v29;
      do
      {
        for (i = 0; i != v14; i = (char *)i + 1)
        {
          if (*(_QWORD *)v29 != v15)
            objc_enumerationMutation(v12);
          v17 = *(void **)(*((_QWORD *)&v28 + 1) + 8 * (_QWORD)i);
          v18 = objc_msgSend(v17, "notifyStatus");
          v19 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "notifyData"));
          v21 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v20);
          v22 = _NRLogIsLevelEnabled(v21, 1);

          if (v22)
          {
            v24 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v23);
            v25 = objc_msgSend(v6, "copyDescription");
            _NRLogWithArgs(v24, 1, "%s%.30s:%-4d %@: Received notify code %u %@", "", "-[NRLinkWiFi handleNotifyCode:payload:]", 1218, v25, v18, v19);

          }
          if (v18 == 50701)
          {
            sub_10013C5A0((uint64_t)NRDLocalDevice, v19, v6[4]);
            objc_msgSend(v6, "checkProxyAgentWithForceUpdate:", 0);
          }
          else if (v18 == 50702)
          {
            v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "linkDelegate"));
            objc_msgSend(v26, "linkDidReceiveData:data:", v6, v19);

          }
        }
        v14 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v28, v32, 16);
      }
      while (v14);
    }

    v3 = v27;
  }

}

void sub_100034568(char *val)
{
  int v2;
  dispatch_time_t v3;
  NSObject *v4;
  _QWORD v5[4];
  id v6;
  id location;

  if (!val[209])
  {
    val[209] = 1;
    v2 = *(_DWORD *)(val + 223);
    if ((5 * v2) >= 0x1F)
    {
      *(_DWORD *)(val + 223) = 0;
      v2 = *(_DWORD *)(val + 223);
    }
    *(_DWORD *)(val + 223) = v2 + 1;
    objc_initWeak(&location, val);
    v3 = dispatch_time(0x8000000000000000, 1000000000 * (5 * *(_DWORD *)(val + 223)));
    v4 = objc_claimAutoreleasedReturnValue(objc_msgSend(val, "queue"));
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    v5[2] = sub_1000353B0;
    v5[3] = &unk_1001B7F28;
    objc_copyWeak(&v6, &location);
    dispatch_after(v3, v4, v5);

    objc_destroyWeak(&v6);
    objc_destroyWeak(&location);
  }
}

void sub_10003467C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100034690(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  const __CFString *v4;
  void *v5;
  int IsLevelEnabled;
  uint64_t v7;
  id v8;
  void *v9;
  int v10;
  uint64_t v11;
  void *v12;
  id v13;
  id v14;
  objc_super v15;

  if (objc_msgSend((id)a1, "state") == 255)
  {
    v5 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0);

    if (IsLevelEnabled)
    {
      v14 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v7);
      v8 = objc_msgSend((id)a1, "copyDescription");
      _NRLogWithArgs(v14, 0, "%s%.30s:%-4d %@: Not restarting ClassC session for cancelled link", "", "-[NRLinkWiFi restartIKESessionClassC]", 540, v8);

    }
  }
  else
  {
    if (objc_msgSend((id)a1, "state") == 8)
    {
      v4 = CFSTR("restarting IKE session while link is ready");
LABEL_10:
      objc_msgSend((id)a1, "cancelWithReason:", v4);
      return;
    }
    v9 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v3);
    v10 = _NRLogIsLevelEnabled(v9, 0);

    if (v10)
    {
      v12 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v11);
      v13 = objc_msgSend((id)a1, "copyDescription");
      _NRLogWithArgs(v12, 0, "%s%.30s:%-4d %@: Restarting ClassC session", "", "-[NRLinkWiFi restartIKESessionClassC]", 549, v13);

    }
    if (++*(_DWORD *)(a1 + 211) >= 0xAu)
    {
      v4 = CFSTR("ClassC session hit max retries");
      goto LABEL_10;
    }
    v15.receiver = (id)a1;
    v15.super_class = (Class)NRLinkWiFi;
    objc_msgSendSuper2(&v15, "invalidateIKESessionForClass:", 3);
    objc_msgSend((id)a1, "setIkeClassDEstablished:", 0);
    *(_BYTE *)(a1 + 83) = 0;
    objc_msgSend((id)a1, "invalidateIKESession:", a1 + 255);
    *(_DWORD *)(a1 + 219) = 0;
    sub_100034874(a1);
  }
}

void sub_100034874(_BYTE *a1)
{
  uint64_t v1;
  void *v2;
  void *v3;
  void *v4;
  id *v5;
  uint64_t v6;
  id v7;
  uint64_t v8;
  id v9;
  void *v10;
  void *v11;
  id v12;
  void *v13;
  id v14;
  uint64_t v15;
  id v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  _QWORD *v20;
  void *v21;
  int IsLevelEnabled;
  uint64_t v23;
  void *v24;
  id v25;
  id v26;
  int v27;
  id v28;
  int *v29;
  uint64_t v30;
  id v31;
  id v32;
  int v33;
  id v34;
  int *v35;
  uint64_t v36;
  id v37;
  void *v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  id v42;
  _QWORD v43[5];
  objc_super v44;
  uint64_t v45;
  int v46;

  v1 = (uint64_t)a1;
  if (!a1[208])
  {
    if (a1[112] == 2)
    {
      if (!objc_msgSend(a1, "hasCompanionDatapath") || objc_msgSend((id)v1, "virtualInterface"))
      {
        if (*(_QWORD *)(v1 + 255))
          return;
        v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v1, "nrUUID"));
        v5 = (id *)sub_10012FFF4((uint64_t)NRDLocalDevice, v4);

        if (v5)
        {
          v7 = v5[10];

          if (v7)
          {
            v9 = sub_100112198();
            sub_100111E90(v5, v9);
            v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v1, "localInterfaceName"));
            objc_msgSend(v9, "setOutgoingInterfaceName:", v10);

            v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v1, "remoteOuterEndpoint"));
            objc_msgSend(v9, "setRemoteEndpoint:", v11);

            objc_msgSend(v9, "setRequestChildlessSA:", objc_msgSend((id)v1, "hasCompanionDatapath") ^ 1);
            v12 = sub_100112420();
            objc_msgSend(v12, "setMode:", 2);
            objc_msgSend(v12, "setReplayWindowSize:", 4);
            sub_100112034(v5, v12);
            objc_msgSend(v9, "setRandomizeLocalPort:", 1);
            v13 = sub_100112798(1, v5, 3);
            v44.receiver = (id)v1;
            v44.super_class = (Class)NRLinkWiFi;
            objc_msgSendSuper2(&v44, "invalidateIKESessionForClass:", 3);
            objc_msgSend((id)v1, "setIkeClassDEstablished:", 0);
            *(_BYTE *)(v1 + 83) = 0;
            objc_msgSend((id)v1, "invalidateIKESession:", v1 + 255);
            v44.receiver = 0;
            v44.super_class = (Class)&v44;
            v46 = 0;
            v45 = 0x2020000000;
            v14 = objc_alloc((Class)NEIKEv2Session);
            v15 = *(_QWORD *)(v1 + 8);
            v43[0] = _NSConcreteStackBlock;
            v43[1] = 3221225472;
            v43[2] = sub_100034F18;
            v43[3] = &unk_1001B65E8;
            v43[4] = &v44;
            v16 = objc_msgSend(v14, "initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:kernelSASessionName:packetDelegate:", v9, v12, v13, v15, objc_msgSend((id)v1, "virtualInterface"), v43, CFSTR("terminusIKE-WiFi-ClassC"), 0);
            v17 = *(void **)(v1 + 255);
            *(_QWORD *)(v1 + 255) = v16;

            if (*(_QWORD *)(v1 + 255))
            {
              sub_1000331A0(v1);
              v18 = *(id *)(v1 + 271);
              if (v18)
                ++v18[8];

              v19 = mach_absolute_time();
              v20 = *(id *)(v1 + 271);
              if (v20)
                v20[4] = v19;

              objc_msgSend((id)v1, "reportEvent:detailsFormat:", 3015, CFSTR("ClassC %@"), *(_QWORD *)(v1 + 255));
              objc_msgSend(*(id *)(v1 + 255), "connect");
            }
            else
            {
              sub_100034F68(v1, *((unsigned int *)v44.super_class + 6));
            }
            _Block_object_dispose(&v44, 8);

            goto LABEL_21;
          }
          v21 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v1 + 32), v8);
          IsLevelEnabled = _NRLogIsLevelEnabled(v21, 0);

          if (!IsLevelEnabled)
          {
LABEL_21:

            return;
          }
          v24 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v1 + 32), v23);
          v25 = objc_msgSend((id)v1, "copyDescription");
          _NRLogWithArgs(v24, 0, "%s%.30s:%-4d %@: Not starting classC IKE initiator session because we do not have keys %@", "", "-[NRLinkWiFi setupIPsec]", 1010, v25, v5);
LABEL_20:

          goto LABEL_21;
        }
LABEL_30:
        v38 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v1 + 32), v6);
        v39 = _NRLogIsLevelEnabled(v38, 17);

        if (!v39)
          goto LABEL_21;
        v24 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v1 + 32), v40);
        v25 = objc_msgSend((id)v1, "copyDescription");
        _NRLogWithArgs(v24, 17, "%@: Not starting classC IKE initiator session because localDevice is missing", v25);
        goto LABEL_20;
      }
      v32 = sub_100032FF0();
      v33 = _NRLogIsLevelEnabled(v32, 16);

      if (v33)
      {
        v34 = sub_100032FF0();
        _NRLogWithArgs(v34, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (self.virtualInterface) != ((void *)0)", "", "-[NRLinkWiFi setupIPsec]", 997);

      }
      v1 = _os_log_pack_size(12);
      v5 = (id *)((char *)&v41 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0));
      v35 = __error();
      v36 = _os_log_pack_fill(v5, v1, *v35, &_mh_execute_header, "%{public}s Assertion Failed: (self.virtualInterface) != ((void *)0)");
      *(_DWORD *)v36 = 136446210;
      *(_QWORD *)(v36 + 4) = "-[NRLinkWiFi setupIPsec]";
      v37 = sub_100032FF0();
      _NRLogAbortWithPack(v37, v5);
    }
    else
    {
      v26 = sub_100032FF0();
      v27 = _NRLogIsLevelEnabled(v26, 16);

      if (v27)
      {
        v28 = sub_100032FF0();
        _NRLogWithArgs(v28, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: _ikev2Role == NRIKEv2RoleInitiator", "", "-[NRLinkWiFi setupIPsec]", 995);

      }
      v1 = _os_log_pack_size(12);
      v5 = (id *)((char *)&v41 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0));
      v29 = __error();
      v30 = _os_log_pack_fill(v5, v1, *v29, &_mh_execute_header, "%{public}s Assertion Failed: _ikev2Role == NRIKEv2RoleInitiator");
      *(_DWORD *)v30 = 136446210;
      *(_QWORD *)(v30 + 4) = "-[NRLinkWiFi setupIPsec]";
      v31 = sub_100032FF0();
      _NRLogAbortWithPack(v31, v5);
    }
    __break(1u);
    goto LABEL_30;
  }
  objc_opt_self(NRIKEv2Listener);
  if (qword_1001E44D8 != -1)
    dispatch_once(&qword_1001E44D8, &stru_1001B5E70);
  v42 = (id)qword_1001E44D0;
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v1, "localInterfaceName"));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v1, "localOuterEndpoint"));
  sub_10001013C((uint64_t)v42, (void *)v1, v2, v3);

}

void sub_100034EFC(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 104), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100034F18(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;

  v9 = getpid();
  return NEHelperGetIKESocketWithResult(a3, a4, a5, v9, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

void sub_100034F68(uint64_t a1, uint64_t a2)
{
  int64_t v4;
  id v5;
  id v6;
  id v7;
  id v8;
  id v9;
  id v10;
  dispatch_time_t v11;
  NSObject *v12;
  _QWORD block[4];
  id v14;
  id __strerrbuf[16];

  ++*(_DWORD *)(a1 + 219);
  if (objc_msgSend((id)a1, "subtype") == 103
    || objc_msgSend((id)a1, "subtype") == 102
    || objc_msgSend((id)a1, "subtype") == 104)
  {
    v4 = 1000000000;
  }
  else
  {
    v4 = 250000000;
  }
  if (*(_DWORD *)(a1 + 219) > 4u)
  {
    if (strerror_r(a2, (char *)__strerrbuf, 0x80uLL))
      LOBYTE(__strerrbuf[0]) = 0;
    if (qword_1001E45E0 != -1)
      dispatch_once(&qword_1001E45E0, &stru_1001B6608);
    if (_NRLogIsLevelEnabled(qword_1001E45D8, 17))
    {
      if (qword_1001E45E0 != -1)
        dispatch_once(&qword_1001E45E0, &stru_1001B6608);
      v7 = (id)qword_1001E45D8;
      v8 = objc_msgSend((id)a1, "copyDescription");
      _NRLogWithArgs(v7, 17, "%@ IKE session creation hit max retries after error: [%d] %s", v8, a2, __strerrbuf);

    }
    objc_msgSend((id)a1, "cancelWithReason:", CFSTR("IKE session creation hit max retries"));
  }
  else
  {
    if ((_DWORD)a2 == 2 || (_DWORD)a2 == 51)
    {
      if (strerror_r(a2, (char *)__strerrbuf, 0x80uLL))
        LOBYTE(__strerrbuf[0]) = 0;
      if (qword_1001E45E0 != -1)
        dispatch_once(&qword_1001E45E0, &stru_1001B6608);
      if (_NRLogIsLevelEnabled(qword_1001E45D8, 16))
      {
        if (qword_1001E45E0 != -1)
          dispatch_once(&qword_1001E45E0, &stru_1001B6608);
        v5 = (id)qword_1001E45D8;
        v6 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v5, 16, "%s%.30s:%-4d %@ IKE session creation retry %u after error: [%d] %s", "", "-[NRLinkWiFi retrySetupIPsec:]", 283, v6, *(unsigned int *)(a1 + 219), a2, __strerrbuf);

      }
    }
    else
    {
      if (strerror_r(a2, (char *)__strerrbuf, 0x80uLL))
        LOBYTE(__strerrbuf[0]) = 0;
      if (qword_1001E45E0 != -1)
        dispatch_once(&qword_1001E45E0, &stru_1001B6608);
      if (_NRLogIsLevelEnabled(qword_1001E45D8, 17))
      {
        if (qword_1001E45E0 != -1)
          dispatch_once(&qword_1001E45E0, &stru_1001B6608);
        v9 = (id)qword_1001E45D8;
        v10 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v9, 17, "%@ IKE session creation retry %u after error: [%d] %s", v10, *(unsigned int *)(a1 + 219), a2, __strerrbuf);

      }
    }
    objc_msgSend((id)a1, "reportEvent:", 3026);
    objc_initWeak(__strerrbuf, (id)a1);
    v11 = dispatch_time(0, v4);
    v12 = objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "queue"));
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10003536C;
    block[3] = &unk_1001B7F28;
    objc_copyWeak(&v14, __strerrbuf);
    dispatch_after(v11, v12, block);

    objc_destroyWeak(&v14);
    objc_destroyWeak(__strerrbuf);
  }
}

void sub_100035350(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10003536C(uint64_t a1)
{
  id WeakRetained;
  BOOL v2;
  id v3;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v3 = WeakRetained;
    v2 = objc_msgSend(WeakRetained, "state") == 255;
    WeakRetained = v3;
    if (!v2)
    {
      sub_100034874(v3);
      WeakRetained = v3;
    }
  }

}

void sub_1000353B0(uint64_t a1)
{
  _BYTE *WeakRetained;
  _BYTE *v2;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    WeakRetained[209] = 0;
    v2 = WeakRetained;
    sub_100034690((uint64_t)WeakRetained);
    WeakRetained = v2;
  }

}

char *sub_1000353EC(char *result)
{
  char *v1;
  uint64_t v2;
  void *v3;
  int IsLevelEnabled;
  uint64_t v5;
  void *v6;
  id v7;
  id v8;
  void *v9;
  void *v10;
  id v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;

  if (!result)
    return result;
  v1 = result;
  if (!objc_opt_class(NWNetworkOfInterestManager))
  {
    v3 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v1 + 4), v2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v3, 0);

    if (IsLevelEnabled)
    {
      v6 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v1 + 4), v5);
      v7 = objc_msgSend(v1, "copyDescription");
      _NRLogWithArgs(v6, 0, "%s%.30s:%-4d %@: SymptomPresentationFeed.framework not present, not starting NOI tracking.", "", "-[NRLinkWiFi startSymptomsNOIManagerTracking]", 565, v7);

    }
  }
  if (*(_QWORD *)(v1 + 263))
    goto LABEL_8;
  v8 = objc_alloc_init((Class)NWNetworkOfInterestManager);
  v9 = *(void **)(v1 + 263);
  *(_QWORD *)(v1 + 263) = v8;

  v10 = *(void **)(v1 + 263);
  if (v10)
  {
    v11 = v10;
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "queue"));
    objc_msgSend(v11, "setQueue:", v12);

    objc_msgSend(*(id *)(v1 + 263), "setDelegate:", v1);
LABEL_8:
    v13 = mach_absolute_time();
    v14 = *(_QWORD *)(v1 + 271);
    if (v14)
    {
      *(_QWORD *)(v14 + 104) = v13;
      v15 = *(id *)(v1 + 271);
      if (v15)
        ++v15[12];
    }
    else
    {
      v15 = 0;
    }

    return (char *)objc_msgSend(*(id *)(v1 + 263), "trackNOIAnyForInterfaceType:options:", 1, 0);
  }
  if (qword_1001E45E0 != -1)
    dispatch_once(&qword_1001E45E0, &stru_1001B6608);
  result = (char *)_NRLogIsLevelEnabled(qword_1001E45D8, 17);
  if ((_DWORD)result)
  {
    if (qword_1001E45E0 != -1)
      dispatch_once(&qword_1001E45E0, &stru_1001B6608);
    return (char *)_NRLogWithArgs(qword_1001E45D8, 17, "[[NWNetworkOfInterestManager alloc] init] failed");
  }
  return result;
}

void sub_100035610(uint64_t a1, int a2)
{
  char *WeakRetained;
  BOOL v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  void *v8;
  int v9;
  uint64_t v10;
  void *v11;
  id v12;
  void *v13;
  int IsLevelEnabled;
  uint64_t v15;
  void *v16;
  id v17;
  char *v18;

  WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v18 = WeakRetained;
    v4 = objc_msgSend(WeakRetained, "state") == 255;
    WeakRetained = v18;
    if (!v4)
    {
      v18[83] = 0;
      if (!a2)
      {
        v13 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v18 + 4), v5);
        IsLevelEnabled = _NRLogIsLevelEnabled(v13, 0);

        if (IsLevelEnabled)
        {
          v16 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v18 + 4), v15);
          v17 = objc_msgSend(v18, "copyDescription");
          _NRLogWithArgs(v16, 0, "%s%.30s:%-4d %@: peer is NOT available", "", "-[NRLinkWiFi checkPeerAvailabilityWithForceAggressive:]_block_invoke", 756, v17);

        }
        objc_msgSend(v18, "cancelWithReason:", CFSTR("Dead Peer Detection"));
        goto LABEL_11;
      }
      v6 = *(id *)(v18 + 271);
      if (v6)
        ++v6[15];

      v8 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v18 + 4), v7);
      v9 = _NRLogIsLevelEnabled(v8, 0);

      WeakRetained = v18;
      if (v9)
      {
        v11 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v18 + 4), v10);
        v12 = objc_msgSend(v18, "copyDescription");
        _NRLogWithArgs(v11, 0, "%s%.30s:%-4d %@: peer is available", "", "-[NRLinkWiFi checkPeerAvailabilityWithForceAggressive:]_block_invoke", 754, v12);

LABEL_11:
        WeakRetained = v18;
      }
    }
  }

}

void sub_100035790(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  int IsLevelEnabled;
  uint64_t v12;
  void *v13;
  id v14;
  void *v15;
  int v16;
  uint64_t v17;
  id v18;
  void *v19;
  int v20;
  uint64_t v21;
  void *v22;
  id v23;
  void *v24;
  int v25;
  uint64_t v26;
  id v27;

  if (a1 && *(_DWORD *)(a1 + 231) != -1)
  {
    if (&_symptom_new)
    {
      if (objc_msgSend((id)a1, "hasCompanionDatapath"))
      {
        v3 = NEVirtualInterfaceCopyName(objc_msgSend((id)a1, "virtualInterface"));
        if (v3)
          goto LABEL_6;
      }
      else
      {
        v3 = objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "localInterfaceName"));
        if (v3)
        {
LABEL_6:
          v27 = (id)v3;
          if (qword_1001E48C0 != -1)
            dispatch_once(&qword_1001E48C0, &stru_1001B7CA0);
          v5 = symptom_new(qword_1001E48B8, 438274);
          if (!v5)
          {
            if (qword_1001E45E0 != -1)
              dispatch_once(&qword_1001E45E0, &stru_1001B6608);
            if (_NRLogIsLevelEnabled(qword_1001E45D8, 17))
            {
              if (qword_1001E45E0 != -1)
                dispatch_once(&qword_1001E45E0, &stru_1001B6608);
              _NRLogWithArgs(qword_1001E45D8, 17, "symptom_new failed");
            }
            goto LABEL_29;
          }
          v6 = v5;
          symptom_set_additional_qualifier(v5, 0, objc_msgSend(v27, "length"), objc_msgSend(v27, "UTF8String"));
          v7 = symptom_send(v6);
          notify_cancel(*(_DWORD *)(a1 + 231));
          *(_DWORD *)(a1 + 231) = -1;
          v9 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v8);
          v10 = (void *)v9;
          if (v7)
          {
            IsLevelEnabled = _NRLogIsLevelEnabled(v9, 17);

            if (IsLevelEnabled)
            {
              v13 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v12);
              v14 = objc_msgSend((id)a1, "copyDescription");
              _NRLogWithArgs(v13, 17, "%@: failed to send symptom to stop link monitoring", v14);
LABEL_28:

            }
          }
          else
          {
            v25 = _NRLogIsLevelEnabled(v9, 0);

            if (v25)
            {
              v13 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v26);
              v14 = objc_msgSend((id)a1, "copyDescription");
              _NRLogWithArgs(v13, 0, "%s%.30s:%-4d %@: successfully sent symptom to stop link monitoring on interface: %@", "", "-[NRLinkWiFi stopSymptomsMonitor]", 699, v14, v27);
              goto LABEL_28;
            }
          }
LABEL_29:
          v24 = v27;
LABEL_30:

          return;
        }
      }
      v19 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v4);
      v20 = _NRLogIsLevelEnabled(v19, 17);

      if (v20)
      {
        v22 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v21);
        v23 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v22, 17, "%@: failed to send stop symptoms, since no interface found", v23);

      }
      v24 = 0;
      goto LABEL_30;
    }
    v15 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
    v16 = _NRLogIsLevelEnabled(v15, 16);

    if (v16)
    {
      v27 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v17);
      v18 = objc_msgSend((id)a1, "copyDescription");
      _NRLogWithArgs(v27, 16, "%s%.30s:%-4d %@: SymptomReporterFramework not present, skipping.", "", "-[NRLinkWiFi stopSymptomsMonitor]", 667, v18);

      goto LABEL_29;
    }
  }
}

void sub_100035AC8(uint64_t a1, uint64_t a2)
{
  char *WeakRetained;
  uint64_t v4;
  void *v5;
  int IsLevelEnabled;
  uint64_t v7;
  void *v8;
  id v9;
  void *v10;
  int v11;
  uint64_t v12;
  void *v13;
  id v14;
  char *v15;

  WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v15 = WeakRetained;
    if (objc_msgSend(WeakRetained, "state") == 255)
    {
      v5 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v15 + 4), v4);
      IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0);

      WeakRetained = v15;
      if (IsLevelEnabled)
      {
        v8 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v15 + 4), v7);
        v9 = objc_msgSend(v15, "copyDescription");
        _NRLogWithArgs(v8, 0, "%s%.30s:%-4d %@: Ignoring notify update as link is cancelled", "", "-[NRLinkWiFi startSymptomsMonitor]_block_invoke", 635, v9);

        goto LABEL_9;
      }
    }
    else
    {
      if (*(_DWORD *)(v15 + 231) == (_DWORD)a2)
      {
        objc_msgSend(v15, "reportEvent:detailsFormat:", 11004, CFSTR("#%u"), ++*(_DWORD *)(v15 + 227));
        objc_msgSend(v15, "checkPeerAvailabilityWithForceAggressive:", 0);
LABEL_9:
        WeakRetained = v15;
        goto LABEL_10;
      }
      v10 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v15 + 4), v4);
      v11 = _NRLogIsLevelEnabled(v10, 0);

      WeakRetained = v15;
      if (v11)
      {
        v13 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v15 + 4), v12);
        v14 = objc_msgSend(v15, "copyDescription");
        _NRLogWithArgs(v13, 0, "%s%.30s:%-4d %@: Ignoring notify update (%d != %d)", "", "-[NRLinkWiFi startSymptomsMonitor]_block_invoke", 641, v14, *(unsigned int *)(v15 + 231), a2);

        goto LABEL_9;
      }
    }
  }
LABEL_10:

}

void sub_100035C7C(uint64_t a1)
{
  char *v2;
  NRPairingParameters *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  id *v8;
  _QWORD *v9;
  void *v10;
  _QWORD *v11;
  id v12;
  uint64_t v13;
  void *v14;
  char IsLevelEnabled;
  uint64_t v16;
  void *v17;
  id v18;
  _QWORD v19[4];
  id v20;
  id v21;
  id from;
  id location;

  if (a1)
  {
    v2 = sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(a1 + 32));
    v3 = objc_alloc_init(NRPairingParameters);
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "localInterfaceName"));
    if (v3)
      objc_storeStrong((id *)&v3->_localInterfaceName, v4);

    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "localOuterEndpoint"));
    if (v3)
      objc_storeStrong((id *)&v3->_localEndpoint, v5);

    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "remoteOuterEndpoint"));
    v7 = v6;
    if (v3)
    {
      objc_storeStrong((id *)&v3->_remoteEndpoint, v6);

      v3->_isResponder = *(_BYTE *)(a1 + 208);
      v3->_serializeIKESessions = 1;
      v3->_deferIKESessionInvalidation = *(_BYTE *)(a1 + 208);
    }
    else
    {

    }
    objc_initWeak(&location, (id)a1);
    v8 = sub_10000BD14((id *)[NRPairingClient alloc], *(void **)(a1 + 8), *(void **)(a1 + 32), (__objc2_prot *)v3);
    objc_initWeak(&from, v8);
    v19[0] = _NSConcreteStackBlock;
    v19[1] = 3221225472;
    v19[2] = sub_100036644;
    v19[3] = &unk_1001B7268;
    objc_copyWeak(&v20, &location);
    objc_copyWeak(&v21, &from);
    v9 = v19;
    v10 = v9;
    if (v8 && !*((_BYTE *)v8 + 10))
    {
      v11 = objc_retainBlock(v9);
      v12 = v8[18];
      v8[18] = v11;

    }
    sub_10000C08C((uint64_t)v8);
    objc_storeStrong((id *)(a1 + 287), v8);
    v14 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v13);
    IsLevelEnabled = _NRLogIsLevelEnabled(v14, 0);

    if ((IsLevelEnabled & 1) != 0)
    {
      v17 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v16);
      v18 = objc_msgSend((id)a1, "copyDescription");
      _NRLogWithArgs(v17, 0, "%s%.30s:%-4d %@: initiated pairing with %@", "", "-[NRLinkWiFi initiatePairing]", 450, v18, v2);

    }
    objc_destroyWeak(&v21);
    objc_destroyWeak(&v20);
    objc_destroyWeak(&from);

    objc_destroyWeak(&location);
  }
}

void sub_100035EE4(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_destroyWeak((id *)(v1 - 72));
  _Unwind_Resume(a1);
}

void sub_100035F18(uint64_t a1, uint64_t a2)
{
  void *v3;
  int IsLevelEnabled;
  uint64_t v5;
  void *v6;
  id v7;
  void *v8;
  uint64_t v9;
  void *v10;
  int v11;
  uint64_t v12;
  void *v13;
  id v14;
  dispatch_time_t v15;
  NSObject *v16;
  void *v17;
  int v18;
  uint64_t v19;
  void *v20;
  id v21;
  _QWORD block[4];
  id v23;
  id location;

  if (a1)
  {
    v3 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v3, 0);

    if (IsLevelEnabled)
    {
      v6 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
      v7 = objc_msgSend((id)a1, "copyDescription");
      _NRLogWithArgs(v6, 0, "%s%.30s:%-4d %@: initiating connection with peer", "", "-[NRLinkWiFi initiateConnection]", 455, v7);

    }
    if (*(_BYTE *)(a1 + 208))
      goto LABEL_5;
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "remoteOuterEndpoint"));

    if (v8)
    {
      if ((objc_msgSend((id)a1, "setupVirtualInterface") & 1) != 0)
      {
        objc_msgSend((id)a1, "setPowerAssertionState:", 1);
LABEL_5:
        objc_msgSend((id)a1, "reportEvent:", 3001);
        sub_100034874((_BYTE *)a1);
        return;
      }
      if (objc_msgSend((id)a1, "state") != 255)
      {
        v10 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v9);
        v11 = _NRLogIsLevelEnabled(v10, 0);

        if (v11)
        {
          v13 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v12);
          v14 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v13, 0, "%s%.30s:%-4d %@: Retrying IPsec interface creation", "", "-[NRLinkWiFi retrySetupVirtualInterface]", 238, v14);

        }
        if (++*(_DWORD *)(a1 + 215) > 9u)
        {
          v17 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v12);
          v18 = _NRLogIsLevelEnabled(v17, 17);

          if (v18)
          {
            v20 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v19);
            v21 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v20, 17, "%@: IPsec interface setup hit max retries", v21);

          }
          objc_msgSend((id)a1, "cancelWithReason:", CFSTR("IPsec interface setup hit max retries"));
        }
        else
        {
          objc_msgSend((id)a1, "reportEvent:", 3025);
          objc_initWeak(&location, (id)a1);
          v15 = dispatch_time(0, 250000000);
          v16 = objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "queue"));
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472;
          block[2] = sub_1000365F4;
          block[3] = &unk_1001B7F28;
          objc_copyWeak(&v23, &location);
          dispatch_after(v15, v16, block);

          objc_destroyWeak(&v23);
          objc_destroyWeak(&location);
        }
      }
    }
    else
    {
      objc_msgSend((id)a1, "cancelWithReason:", CFSTR("No remote outer endpoint present"));
    }
  }
}

void sub_1000361F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_destroyWeak((id *)(v1 - 40));
  _Unwind_Resume(a1);
}

void sub_100036204(uint64_t a1)
{
  NSObject *bonjour_service;
  NSObject *v3;
  void *v4;
  NSObject *v5;
  NSObject *v6;
  NSObject *v7;
  uint64_t v8;
  void *v9;
  char IsLevelEnabled;
  uint64_t v11;
  void *v12;
  id v13;
  _QWORD handler[4];
  id v15;
  _QWORD state_changed_handler[4];
  id v17;
  id location;

  if (a1 && !*(_QWORD *)(a1 + 295))
  {
    bonjour_service = nw_browse_descriptor_create_bonjour_service("_nr._tcp", "local");
    v3 = nw_parameters_create();
    nw_parameters_set_use_awdl(v3, 1);
    v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "localInterfaceName"));
    v5 = nw_interface_create_with_name(objc_msgSend(v4, "UTF8String"));
    nw_parameters_require_interface(v3, v5);
    v6 = nw_browser_create(bonjour_service, v3);
    objc_initWeak(&location, (id)a1);
    state_changed_handler[0] = _NSConcreteStackBlock;
    state_changed_handler[1] = 3221225472;
    state_changed_handler[2] = sub_10003645C;
    state_changed_handler[3] = &unk_1001B6598;
    objc_copyWeak(&v17, &location);
    nw_browser_set_state_changed_handler(v6, state_changed_handler);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472;
    handler[2] = sub_100036534;
    handler[3] = &unk_1001B65C0;
    objc_copyWeak(&v15, &location);
    nw_browser_set_browse_results_changed_handler(v6, handler);
    v7 = objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "queue"));
    nw_browser_set_queue(v6, v7);

    nw_browser_start(v6);
    objc_storeStrong((id *)(a1 + 295), v6);
    v9 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v8);
    IsLevelEnabled = _NRLogIsLevelEnabled(v9, 0);

    if ((IsLevelEnabled & 1) != 0)
    {
      v12 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v11);
      v13 = objc_msgSend((id)a1, "copyDescription");
      _NRLogWithArgs(v12, 0, "%s%.30s:%-4d %@: started AWDL browser", "", "-[NRLinkWiFi startAWDLBrowser]", 534, v13);

    }
    objc_destroyWeak(&v15);
    objc_destroyWeak(&v17);
    objc_destroyWeak(&location);

  }
}

void sub_10003642C(_Unwind_Exception *a1)
{
  id *v1;
  id *v2;
  uint64_t v3;

  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v3 - 104));
  _Unwind_Resume(a1);
}

void sub_10003645C(uint64_t a1, uint64_t a2, void *a3)
{
  _QWORD *WeakRetained;
  _QWORD *v6;
  uint64_t v7;
  void *v8;
  int IsLevelEnabled;
  uint64_t v10;
  void *v11;
  id v12;
  id v13;

  v13 = a3;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v6 = WeakRetained;
  if (WeakRetained)
  {
    if (objc_msgSend(WeakRetained, "state") != 255)
    {
      v8 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v7);
      IsLevelEnabled = _NRLogIsLevelEnabled(v8, 0);

      if (IsLevelEnabled)
      {
        v11 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v10);
        v12 = objc_msgSend(v6, "copyDescription");
        _NRLogWithArgs(v11, 0, "%s%.30s:%-4d %@: browser entered state: %u (%@)", "", "-[NRLinkWiFi startAWDLBrowser]_block_invoke", 520, v12, a2, v13);

      }
    }
  }

}

void sub_100036534(uint64_t a1)
{
  _QWORD *WeakRetained;
  BOOL v2;
  uint64_t v3;
  void *v4;
  int IsLevelEnabled;
  uint64_t v6;
  void *v7;
  id v8;
  _QWORD *v9;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v9 = WeakRetained;
    v2 = objc_msgSend(WeakRetained, "state") == 255;
    WeakRetained = v9;
    if (!v2)
    {
      v4 = (void *)_NRCopyLogObjectForNRUUID(v9[4], v3);
      IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0);

      WeakRetained = v9;
      if (IsLevelEnabled)
      {
        v7 = (void *)_NRCopyLogObjectForNRUUID(v9[4], v6);
        v8 = objc_msgSend(v9, "copyDescription");
        _NRLogWithArgs(v7, 0, "%s%.30s:%-4d %@: browser results changed", "", "-[NRLinkWiFi startAWDLBrowser]_block_invoke_2", 529, v8);

        WeakRetained = v9;
      }
    }
  }

}

void sub_1000365F4(uint64_t a1)
{
  id WeakRetained;
  BOOL v2;
  id v3;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v3 = WeakRetained;
    v2 = objc_msgSend(WeakRetained, "state") == 255;
    WeakRetained = v3;
    if (!v2)
    {
      objc_msgSend(v3, "setStartRequested:", 0);
      objc_msgSend(v3, "start");
      WeakRetained = v3;
    }
  }

}

void sub_100036644(uint64_t a1, int a2, unsigned int a3)
{
  id WeakRetained;
  void *v7;
  unsigned int v8;
  _QWORD *v9;
  uint64_t v10;
  id v11;
  uint64_t v12;
  void *v13;
  __CFString *v14;
  void *v15;
  int IsLevelEnabled;
  uint64_t v17;
  void *v18;
  id v19;
  _QWORD *v20;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v7 = WeakRetained;
  if (WeakRetained)
  {
    v20 = WeakRetained;
    v8 = objc_msgSend(WeakRetained, "state");
    v7 = v20;
    if (v8 != 255)
    {
      v9 = objc_loadWeakRetained((id *)(a1 + 40));
      if (!v9 || *(_QWORD **)((char *)v20 + 287) != v9)
        goto LABEL_28;
      v10 = v9[6];
      v11 = objc_alloc_init((Class)NSMutableString);
      v13 = v11;
      if ((v10 & 1) != 0)
      {
        objc_msgSend(v11, "appendFormat:", CFSTR("PairingSessionConnected | "));
        if ((v10 & 2) == 0)
        {
LABEL_7:
          if ((v10 & 4) == 0)
            goto LABEL_8;
          goto LABEL_15;
        }
      }
      else if ((v10 & 2) == 0)
      {
        goto LABEL_7;
      }
      objc_msgSend(v13, "appendFormat:", CFSTR("ClassDVerified | "));
      if ((v10 & 4) == 0)
      {
LABEL_8:
        if ((v10 & 8) == 0)
          goto LABEL_9;
        goto LABEL_16;
      }
LABEL_15:
      objc_msgSend(v13, "appendFormat:", CFSTR("ClassCVerified | "));
      if ((v10 & 8) == 0)
      {
LABEL_9:
        if ((v10 & 0x10) == 0)
          goto LABEL_10;
        goto LABEL_17;
      }
LABEL_16:
      objc_msgSend(v13, "appendFormat:", CFSTR("ClassAVerified | "));
      if ((v10 & 0x10) == 0)
      {
LABEL_10:
        if (a3)
        {
LABEL_11:
          if (a3 > 8)
            v14 = CFSTR("None");
          else
            v14 = *(&off_1001B5DF8 + (a3 - 1));
          objc_msgSend(v20, "cancelWithReason:", CFSTR("pairing client error: %@ mask: %@"), v14, v13);
LABEL_27:

LABEL_28:
          v7 = v20;
          goto LABEL_29;
        }
LABEL_18:
        if ((a2 - 1) > 6)
          v14 = CFSTR("Invalid");
        else
          v14 = *(&off_1001B5E38 + (a2 - 1));
        v15 = (void *)_NRCopyLogObjectForNRUUID(v20[4], v12);
        IsLevelEnabled = _NRLogIsLevelEnabled(v15, 0);

        if (IsLevelEnabled)
        {
          v18 = (void *)_NRCopyLogObjectForNRUUID(v20[4], v17);
          v19 = objc_msgSend(v20, "copyDescription");
          _NRLogWithArgs(v18, 0, "%s%.30s:%-4d %@: pairing client state: %@ mask: %@", "", "-[NRLinkWiFi initiatePairing]_block_invoke", 443, v19, v14, v13);

        }
        if (a2 == 5)
          sub_100035F18((uint64_t)v20, v17);
        goto LABEL_27;
      }
LABEL_17:
      objc_msgSend(v13, "appendFormat:", CFSTR("PairingCompleted | "));
      if (a3)
        goto LABEL_11;
      goto LABEL_18;
    }
  }
LABEL_29:

}

void sub_1000385D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  id *v18;

  objc_destroyWeak(v18);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

id sub_10003BC58()
{
  if (qword_1001E45F0 != -1)
    dispatch_once(&qword_1001E45F0, &stru_1001B66A0);
  return (id)qword_1001E45E8;
}

void sub_10003BC98(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001E45E8;
  qword_1001E45E8 = (uint64_t)v1;

}

id sub_10003BCC8(id result)
{
  uint64_t v1;
  NSObject *v2;
  uint64_t v3;
  void *v4;
  int IsLevelEnabled;
  void *v6;
  id v7;

  if (result)
  {
    v1 = (uint64_t)result;
    v2 = objc_claimAutoreleasedReturnValue(objc_msgSend(result, "queue"));
    dispatch_assert_queue_V2(v2);

    objc_msgSend((id)v1, "reportEvent:", 10017);
    if (gNRPacketLoggingEnabled)
    {
      v4 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v1 + 32), v3);
      IsLevelEnabled = _NRLogIsLevelEnabled(v4, 1);

      if (IsLevelEnabled)
      {
        v6 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v1 + 32), v3);
        v7 = objc_msgSend((id)v1, "copyDescription");
        _NRLogWithArgs(v6, 1, "%s%.30s:%-4d %@: QR link has been idle. Invalidating IDSSession", "", "-[NRLinkQuickRelay handleLinkIdleTimeout]", 1008, v7);

      }
    }
    sub_10003BDD4(v1, v3);
    if (*(_BYTE *)(v1 + 209))
    {
      dispatch_resume(*(dispatch_object_t *)(v1 + 319));
      *(_BYTE *)(v1 + 209) = 0;
    }
    return objc_msgSend((id)v1, "suspend");
  }
  return result;
}

void sub_10003BDD4(uint64_t a1, uint64_t a2)
{
  void *v3;
  int IsLevelEnabled;
  uint64_t v5;
  void *v6;
  id v7;
  void *v8;
  id v9;
  void *v10;
  void *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  int *v15;
  NSObject *v16;
  void *v17;

  if (a1)
  {
    v3 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v3, 0);

    if (IsLevelEnabled)
    {
      v6 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
      v7 = objc_msgSend((id)a1, "copyDescription");
      _NRLogWithArgs(v6, 0, "%s%.30s:%-4d %@: Invalidating IDS session", "", "-[NRLinkQuickRelay invalidateIDSSession]", 720, v7);

    }
    *(_BYTE *)(a1 + 216) = 0;
    objc_msgSend((id)a1, "reportEvent:detailsFormat:", 10014, CFSTR("%@"), *(_QWORD *)(a1 + 231));
    v8 = *(void **)(a1 + 231);
    if (!v8)
      goto LABEL_19;
    v9 = v8;
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "queue"));
    objc_msgSend(v9, "setDelegate:queue:", 0, v10);

    objc_msgSend(*(id *)(a1 + 231), "endSession");
    v11 = *(void **)(a1 + 231);
    *(_QWORD *)(a1 + 231) = 0;

    v12 = *(_QWORD **)(a1 + 639);
    if (*(_BYTE *)(a1 + 212))
    {
      if (!v12)
        goto LABEL_18;
      if (!v12[18])
        goto LABEL_18;
      v13 = mach_absolute_time();
      v14 = *(_QWORD *)(a1 + 639);
      if (!v14)
        goto LABEL_18;
      v15 = &OBJC_IVAR___NRAnalyticsCmpnLinkQuickRelay__idsSessionEnd;
      goto LABEL_17;
    }
    if (v12)
    {
      if (!v12[14])
      {
        if (!v12[16])
          goto LABEL_18;
        v13 = mach_absolute_time();
        v14 = *(_QWORD *)(a1 + 639);
        if (!v14)
          goto LABEL_18;
        v15 = &OBJC_IVAR___NRAnalyticsCmpnLinkQuickRelay__idsSessionReceiveInvitationEnd;
        goto LABEL_17;
      }
      v13 = mach_absolute_time();
      v14 = *(_QWORD *)(a1 + 639);
      if (v14)
      {
        v15 = &OBJC_IVAR___NRAnalyticsCmpnLinkQuickRelay__idsSessionSendInvitationEnd;
LABEL_17:
        *(_QWORD *)(v14 + *v15) = v13;
      }
    }
LABEL_18:
    *(_BYTE *)(a1 + 212) = 0;
    *(_BYTE *)(a1 + 208) = 0;
    *(_BYTE *)(a1 + 213) = 0;
LABEL_19:
    sub_10003C004(a1);
    v16 = *(NSObject **)(a1 + 607);
    if (v16)
    {
      dispatch_source_cancel(v16);
      v17 = *(void **)(a1 + 607);
      *(_QWORD *)(a1 + 607) = 0;

    }
  }
}

void sub_10003C004(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  void *v4;
  int IsLevelEnabled;
  uint64_t v6;
  void *v7;
  id v8;
  void *v9;
  void *v10;

  if (a1)
  {
    if (*(_BYTE *)(a1 + 215))
    {
      objc_msgSend((id)a1, "removeObserver:forKeyPath:context:", a1, CFSTR("_connection.connectionState"), 0);
      *(_BYTE *)(a1 + 215) = 0;
    }
    v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "connection"));

    if (v2)
    {
      v4 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v3);
      IsLevelEnabled = _NRLogIsLevelEnabled(v4, 1);

      if (IsLevelEnabled)
      {
        v7 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v6);
        v8 = objc_msgSend((id)a1, "copyDescription");
        v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "connection"));
        _NRLogWithArgs(v7, 1, "%s%.30s:%-4d %@: Cancelling %@", "", "-[NRLinkQuickRelay invalidateConnection]", 711, v8, v9);

      }
      v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "connection"));
      objc_msgSend(v10, "cancel");

      objc_msgSend((id)a1, "setConnection:", 0);
    }
  }
}

void sub_10003C138(uint64_t a1)
{
  void *v2;
  unint64_t v3;
  void *v4;
  __CFString *v5;
  void *v6;
  void *v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  id v16;
  void *v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  id v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  NSObject *v34;
  NSObject *v35;
  void *v36;
  uint64_t v37;
  NSObject *v38;
  NSObject *v39;
  dispatch_time_t v40;
  void *v41;
  void *v42;
  int IsLevelEnabled;
  uint64_t v44;
  void *v45;
  id v46;
  _QWORD v47[4];
  id v48;
  _QWORD v49[4];
  id v50;
  id location[4];
  id v52;
  id from;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "connection"));
  v3 = (unint64_t)objc_msgSend(v2, "connectionState");

  v4 = *(void **)(a1 + 32);
  v5 = CFSTR("Invalid");
  v6 = v4;
  switch(v3)
  {
    case 0uLL:
      break;
    case 1uLL:
      v5 = CFSTR("Waiting");
      v6 = *(void **)(a1 + 32);
      break;
    case 2uLL:
      v5 = CFSTR("Preparing");
      v6 = *(void **)(a1 + 32);
      break;
    case 3uLL:
      v5 = CFSTR("Ready");
      v6 = *(void **)(a1 + 32);
      break;
    case 4uLL:
      v5 = CFSTR("Failed");
      v6 = *(void **)(a1 + 32);
      break;
    case 5uLL:
      v5 = CFSTR("Cancelled");
      v6 = *(void **)(a1 + 32);
      break;
    default:
      v5 = (__CFString *)objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("Unknown[%lld]"), v3);
      v6 = *(void **)(a1 + 32);
      break;
  }
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "connection"));
  objc_msgSend(v4, "reportEvent:detailsFormat:", 10020, CFSTR("%@ %@"), v5, v7);

  if (v3 == 3)
  {
    sub_10003C71C(*(_QWORD *)(a1 + 32));
    v9 = objc_msgSend(*(id *)(a1 + 32), "ikeClassDEstablished");
    v10 = *(_QWORD *)(a1 + 32);
    if (v9 && v10 && *(_QWORD *)(v10 + 263))
    {
      objc_initWeak(location, (id)v10);
      v11 = mach_absolute_time();
      v12 = *(_QWORD *)(a1 + 32);
      if (v12)
      {
        v13 = v11;
        v14 = *(id *)(v12 + 639);
        if (v14)
          v14[20] = v13;
      }
      else
      {
        v14 = 0;
      }

      v15 = *(_QWORD *)(a1 + 32);
      if (v15)
        v15 = *(_QWORD *)(v15 + 263);
      v16 = (id)v15;
      v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "queue"));
      v49[0] = _NSConcreteStackBlock;
      v49[1] = 3221225472;
      v49[2] = sub_10003C9D4;
      v49[3] = &unk_1001B7978;
      objc_copyWeak(&v50, location);
      objc_msgSend(v16, "sendKeepaliveWithRetries:retryIntervalInMilliseconds:callbackQueue:callback:", 3, 3000, v17, v49);

      objc_destroyWeak(&v50);
      objc_destroyWeak(location);
      v10 = *(_QWORD *)(a1 + 32);
    }
    v18 = objc_msgSend((id)v10, "ikeClassCEstablished");
    v19 = *(_QWORD *)(a1 + 32);
    if (v18 && v19 && *(_QWORD *)(v19 + 271))
    {
      objc_initWeak(location, (id)v19);
      v20 = mach_absolute_time();
      v21 = *(_QWORD *)(a1 + 32);
      if (v21)
      {
        v22 = v20;
        v23 = *(id *)(v21 + 639);
        if (v23)
          v23[22] = v22;
      }
      else
      {
        v23 = 0;
      }

      v24 = *(_QWORD *)(a1 + 32);
      if (v24)
        v24 = *(_QWORD *)(v24 + 271);
      v25 = (id)v24;
      v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "queue"));
      v47[0] = _NSConcreteStackBlock;
      v47[1] = 3221225472;
      v47[2] = sub_10003CAD8;
      v47[3] = &unk_1001B7978;
      objc_copyWeak(&v48, location);
      objc_msgSend(v25, "sendKeepaliveWithRetries:retryIntervalInMilliseconds:callbackQueue:callback:", 3, 3000, v26, v47);

      objc_destroyWeak(&v48);
      objc_destroyWeak(location);
      v19 = *(_QWORD *)(a1 + 32);
    }
    if (!objc_msgSend((id)v19, "ikeClassCEstablished")
      || (objc_msgSend(*(id *)(a1 + 32), "ikeClassDEstablished") & 1) == 0)
    {
      v27 = *(_QWORD *)(a1 + 32);
      if (v27 && (*(_BYTE *)(v27 + 218) = 0, (v28 = *(_QWORD *)(a1 + 32)) != 0))
      {
        *(_BYTE *)(v28 + 219) = 0;
        v29 = *(_QWORD *)(a1 + 32);
      }
      else
      {
        v29 = 0;
      }
      sub_10003CBDC(v29);
      v30 = *(_QWORD *)(a1 + 32);
      if (!v30)
        return;
      if (*(_BYTE *)(v30 + 211))
      {
        *(_BYTE *)(v30 + 211) = 0;
        v31 = *(_QWORD *)(a1 + 32);
        if (!v31)
          return;
        if (*(_BYTE *)(v31 + 209))
        {
          dispatch_resume(*(dispatch_object_t *)(v31 + 319));
          v32 = *(_QWORD *)(a1 + 32);
          if (!v32)
            return;
          *(_BYTE *)(v32 + 209) = 0;
        }
      }
    }
    v33 = *(_QWORD **)(a1 + 32);
    if (v33)
    {
      v34 = objc_claimAutoreleasedReturnValue(objc_msgSend(v33, "queue"));
      dispatch_assert_queue_V2(v34);

      v35 = *(NSObject **)((char *)v33 + 607);
      if (v35)
      {
        dispatch_source_cancel(v35);
        v36 = *(void **)((char *)v33 + 607);
        *(_QWORD *)((char *)v33 + 607) = 0;

      }
      if (objc_msgSend(v33, "state") == 255)
      {
        v42 = (void *)_NRCopyLogObjectForNRUUID(v33[4], v37);
        IsLevelEnabled = _NRLogIsLevelEnabled(v42, 0);

        if (IsLevelEnabled)
        {
          v45 = (void *)_NRCopyLogObjectForNRUUID(v33[4], v44);
          v46 = objc_msgSend(v33, "copyDescription");
          _NRLogWithArgs(v45, 0, "%s%.30s:%-4d %@: not arming link idle timer as link is cancelled", "", "-[NRLinkQuickRelay armLinkIdleTimer]", 967, v46);

        }
      }
      else if (!*(_QWORD *)((char *)v33 + 607))
      {
        v38 = objc_claimAutoreleasedReturnValue(objc_msgSend(v33, "queue"));
        v39 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v38);

        v40 = dispatch_time(0x8000000000000000, 10000000000);
        dispatch_source_set_timer(v39, v40, 0x2540BE400uLL, 0);
        objc_initWeak(&from, v33);
        location[0] = _NSConcreteStackBlock;
        location[1] = (id)3221225472;
        location[2] = sub_10003D308;
        location[3] = &unk_1001B7F28;
        objc_copyWeak(&v52, &from);
        dispatch_source_set_event_handler(v39, location);
        dispatch_resume(v39);
        v41 = *(void **)((char *)v33 + 607);
        *(_QWORD *)((char *)v33 + 607) = v39;

        objc_destroyWeak(&v52);
        objc_destroyWeak(&from);
      }
    }
  }
  else if ((v3 & 0xFFFFFFFFFFFFFFFELL) == 4)
  {
    sub_10003BDD4(*(_QWORD *)(a1 + 32), v8);
  }
}

void sub_10003C6F0(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 96));
  _Unwind_Resume(a1);
}

void sub_10003C71C(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  void *v4;
  void *v5;
  int IsLevelEnabled;
  uint64_t v7;
  id v8;
  void *v9;
  int v10;
  uint64_t v11;
  void *v12;
  id v13;
  id v14;
  uint64_t v15;
  void *v16;
  int v17;
  uint64_t v18;
  id v19;
  id v20;
  _QWORD v21[4];
  id v22;
  id location;

  if (!a1)
    return;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 8));
  if (*(unsigned __int8 *)(a1 + 16) == 255)
  {
    v5 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v5, 16);

    if (!IsLevelEnabled)
      return;
    v20 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v7);
    v8 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v20, 16, "%s%.30s:%-4d %@: Cannot read datagram as link is cancelled", "", "-[NRLinkQuickRelay readDatagramFromSession]", 1583, v8);
LABEL_10:

LABEL_16:
    return;
  }
  v3 = *(void **)(a1 + 647);
  if (!v3)
  {
    v9 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v2);
    v10 = _NRLogIsLevelEnabled(v9, 0);

    if (!v10)
      return;
    v20 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v11);
    v8 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v20, 0, "%s%.30s:%-4d %@: Ignoring reading datagrams as connection does not exist", "", "-[NRLinkQuickRelay readDatagramFromSession]", 1590, v8);
    goto LABEL_10;
  }
  if (objc_msgSend(v3, "connectionState") == (id)3)
  {
    objc_initWeak(&location, (id)a1);
    v4 = *(void **)(a1 + 647);
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 3221225472;
    v21[2] = sub_1000420CC;
    v21[3] = &unk_1001B6658;
    objc_copyWeak(&v22, &location);
    objc_msgSend(v4, "readDatagramsWithMinimumCount:maximumCount:completionHandler:", 1, 0xFFFFFFFFLL, v21);
    objc_destroyWeak(&v22);
    objc_destroyWeak(&location);
    return;
  }
  v12 = *(void **)(a1 + 647);
  v13 = objc_msgSend(v12, "connectionState");
  if ((unint64_t)v13 >= 6)
    v14 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("Unknown[%lld]"), v13);
  else
    v14 = *(&off_1001B66E8 + (_QWORD)v13);
  objc_msgSend((id)a1, "reportEvent:detailsFormat:", 10021, CFSTR("cannot read from connection %@ state %@"), v12, v14);

  v16 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v15);
  v17 = _NRLogIsLevelEnabled(v16, 17);

  if (v17)
  {
    v20 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v18);
    v19 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v20, 17, "%@: Cannot read from connection %@, state: %llu", v19, *(_QWORD *)(a1 + 647), objc_msgSend(*(id *)(a1 + 647), "connectionState"));

    goto LABEL_16;
  }
}

void sub_10003C9B8(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_10003C9D4(uint64_t a1, int a2)
{
  _QWORD *WeakRetained;
  uint64_t v4;
  void *v5;
  int IsLevelEnabled;
  uint64_t v7;
  void *v8;
  id v9;
  void *v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v14 = WeakRetained;
    v5 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0);

    if (IsLevelEnabled)
    {
      v8 = (void *)_NRCopyLogObjectForNRUUID(v14[4], v7);
      v9 = objc_msgSend(v14, "copyDescription");
      v10 = v9;
      v11 = "NO";
      if (a2)
        v11 = "YES";
      _NRLogWithArgs(v8, 0, "%s%.30s:%-4d %@: ClassD keepalive response received: %s", "", "-[NRLinkQuickRelay observeValueForKeyPath:ofObject:change:context:]_block_invoke_2", 2458, v9, v11);

    }
    WeakRetained = v14;
    if (a2)
    {
      v12 = mach_absolute_time();
      v13 = *(_QWORD *)((char *)v14 + 639);
      if (v13)
        *(_QWORD *)(v13 + 168) = v12;
      sub_10003EED4((uint64_t)v14);
      WeakRetained = v14;
    }
  }

}

void sub_10003CAD8(uint64_t a1, int a2)
{
  _QWORD *WeakRetained;
  uint64_t v4;
  void *v5;
  int IsLevelEnabled;
  uint64_t v7;
  void *v8;
  id v9;
  void *v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v14 = WeakRetained;
    v5 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0);

    if (IsLevelEnabled)
    {
      v8 = (void *)_NRCopyLogObjectForNRUUID(v14[4], v7);
      v9 = objc_msgSend(v14, "copyDescription");
      v10 = v9;
      v11 = "NO";
      if (a2)
        v11 = "YES";
      _NRLogWithArgs(v8, 0, "%s%.30s:%-4d %@: ClassC keepalive response received: %s", "", "-[NRLinkQuickRelay observeValueForKeyPath:ofObject:change:context:]_block_invoke_3", 2483, v9, v11);

    }
    WeakRetained = v14;
    if (a2)
    {
      v12 = mach_absolute_time();
      v13 = *(_QWORD *)((char *)v14 + 639);
      if (v13)
        *(_QWORD *)(v13 + 184) = v12;
      sub_10003EED4((uint64_t)v14);
      WeakRetained = v14;
    }
  }

}

void sub_10003CBDC(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;
  id v4;
  id v5;
  id v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  int v12;
  uint64_t v13;
  void *v14;
  id v15;
  uint64_t v16;
  void *v17;
  int v18;
  uint64_t v19;
  void *v20;
  id v21;
  void *v22;
  id v23;
  void *v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  char *v30;
  void *v31;
  id v32;
  NSObject *v33;
  NSObject *v34;
  _QWORD *v35;
  void *v36;
  id v37;
  NSObject *v38;
  NSObject *v39;
  _QWORD *v40;
  void *v41;
  uint64_t v42;
  void *v43;
  int v44;
  uint64_t v45;
  id v46;
  void *v47;
  int v48;
  uint64_t v49;
  void *v50;
  id v51;
  void *v52;
  int v53;
  uint64_t v54;
  void *v55;
  int v56;
  uint64_t v57;
  int v58;
  uint64_t v59;
  id v60;
  int IsLevelEnabled;
  id v62;
  uint64_t v63;
  char *v64;
  int *v65;
  uint64_t v66;
  id v67;
  void *v68;

  if (!a1)
    return;
  v2 = objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "queue"));
  dispatch_assert_queue_V2(v2);

  if (!*(_QWORD *)(a1 + 279))
  {
    v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 231), "sessionID"));
    v68 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Terminus QuickRelay link <%@>"), v22));

    v23 = sub_10011369C(v68, (void *)a1, 1, 0, 0, 0);
    v24 = *(void **)(a1 + 279);
    *(_QWORD *)(a1 + 279) = v23;

    v26 = *(void **)(a1 + 279);
    if (v26)
    {
      objc_msgSend((id)a1, "setVirtualInterface:", objc_msgSend(v26, "virtualInterface"));
      if ((objc_msgSend((id)a1, "setInterfaceSubfamily") & 1) != 0)
      {
        if ((objc_msgSend((id)a1, "setNoACKPrioritization") & 1) != 0)
        {
          v29 = sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(a1 + 32));
          if (!v29)
          {
            v60 = sub_10003BC58();
            IsLevelEnabled = _NRLogIsLevelEnabled(v60, 16);

            if (IsLevelEnabled)
            {
              v62 = sub_10003BC58();
              _NRLogWithArgs(v62, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)", "", "-[NRLinkQuickRelay setupIPsec]", 1474);

            }
            v63 = _os_log_pack_size(12);
            v64 = (char *)&v68 - ((v63 + 15) & 0xFFFFFFFFFFFFFFF0);
            v65 = __error();
            v66 = _os_log_pack_fill(v64, v63, *v65, &_mh_execute_header, "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
            *(_DWORD *)v66 = 136446210;
            *(_QWORD *)(v66 + 4) = "-[NRLinkQuickRelay setupIPsec]";
            v67 = sub_10003BC58();
            _NRLogAbortWithPack(v67, v64);
          }
          v30 = v29;
          v31 = (void *)sub_10013D578(v29);
          objc_msgSend(*(id *)(a1 + 279), "setLocalAddresses:", v31);

          v32 = objc_msgSend((id)a1, "virtualInterface");
          v33 = sub_10014CFBC();
          dispatch_assert_queue_V2(v33);

          v34 = sub_10014CFBC();
          dispatch_assert_queue_V2(v34);

          v35 = sub_100133714(v30, CFSTR("0"));
          v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v35, "hostname"));

          NEVirtualInterfaceAddIPv6Route(v32, v36, &off_1001C4660, 0, 0);
          v37 = objc_msgSend((id)a1, "virtualInterface");
          v38 = sub_10014CFBC();
          dispatch_assert_queue_V2(v38);

          v39 = sub_10014CFBC();
          dispatch_assert_queue_V2(v39);

          v40 = sub_100133AD8(v30, CFSTR("0"));
          v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v40, "hostname"));

          NEVirtualInterfaceAddIPv6Route(v37, v41, &off_1001C4660, 0, 0);
          NEVirtualInterfaceUpdateAdHocService(objc_msgSend((id)a1, "virtualInterface"));
          objc_msgSend(*(id *)(a1 + 279), "setAvailability:", 0);

          goto LABEL_3;
        }
        v55 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v28);
        v56 = _NRLogIsLevelEnabled(v55, 17);

        if (!v56)
          goto LABEL_30;
        v50 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v57);
        v51 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v50, 17, "%@: failed to setup no ack prioritization", v51);
      }
      else
      {
        v52 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v27);
        v53 = _NRLogIsLevelEnabled(v52, 17);

        if (!v53)
          goto LABEL_30;
        v50 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v54);
        v51 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v50, 17, "%@: failed to setup interface sub family", v51);
      }
    }
    else
    {
      v47 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v25);
      v48 = _NRLogIsLevelEnabled(v47, 16);

      if (!v48)
        goto LABEL_30;
      v50 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v49);
      v51 = objc_msgSend((id)a1, "copyDescription");
      _NRLogWithArgs(v50, 16, "%s%.30s:%-4d %@: failed to create packet nexus", "", "-[NRLinkQuickRelay setupIPsec]", 1458, v51);
    }

    goto LABEL_30;
  }
LABEL_3:
  v3 = objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "queue", v68));
  dispatch_assert_queue_V2(v3);

  if (!*(_BYTE *)(a1 + 214) || *(_QWORD *)(a1 + 255))
    goto LABEL_9;
  v4 = objc_alloc((Class)NEIKEv2Listener);
  v5 = sub_100112198();
  v6 = objc_msgSend(v4, "initWithListenerIKEConfig:kernelSASessionName:packetDelegate:listenerQueue:delegate:delegateQueue:", v5, CFSTR("terminusIKE-QuickRelay-Listener"), a1, *(_QWORD *)(a1 + 8), a1, *(_QWORD *)(a1 + 8));
  v7 = *(void **)(a1 + 255);
  *(_QWORD *)(a1 + 255) = v6;

  v8 = *(_QWORD *)(a1 + 255);
  v10 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v9);
  v11 = (void *)v10;
  if (v8)
  {
    v12 = _NRLogIsLevelEnabled(v10, 0);

    if (!v12)
      goto LABEL_9;
    v14 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v13);
    v15 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v14, 0, "%s%.30s:%-4d %@: Created IKE listener", "", "-[NRLinkQuickRelay setupIKEListener]", 1428, v15);
    goto LABEL_8;
  }
  v58 = _NRLogIsLevelEnabled(v10, 17);

  if (v58)
  {
    v14 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v59);
    v15 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v14, 17, "%@: Failed to create IKE listener", v15);
LABEL_8:

  }
LABEL_9:
  if (objc_msgSend((id)a1, "ikeClassDEstablished"))
  {
    v17 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v16);
    v18 = _NRLogIsLevelEnabled(v17, 0);

    if (v18)
    {
      v20 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v19);
      v21 = objc_msgSend((id)a1, "copyDescription");
      _NRLogWithArgs(v20, 0, "%s%.30s:%-4d %@: IKE classD already established", "", "-[NRLinkQuickRelay setupIPsecClassD]", 1434, v21);

    }
  }
  else
  {
    sub_10003D4EC(a1, 4);
  }
  if (!objc_msgSend((id)a1, "ikeClassCEstablished"))
  {
    sub_10003D4EC(a1, 3);
    return;
  }
  v43 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v42);
  v44 = _NRLogIsLevelEnabled(v43, 0);

  if (v44)
  {
    v68 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v45);
    v46 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v68, 0, "%s%.30s:%-4d %@: IKE classC already established", "", "-[NRLinkQuickRelay setupIPsecClassC]", 1444, v46);

LABEL_30:
  }
}

void sub_10003D308(uint64_t a1)
{
  char *WeakRetained;
  uint64_t v2;
  void *v3;
  id v4;
  void *v5;
  int IsLevelEnabled;
  uint64_t v7;
  void *v8;
  id v9;
  char *v10;
  char *v11;

  WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    if (*(_QWORD *)(WeakRetained + 415) == *(_QWORD *)(WeakRetained + 391)
      && *(_QWORD *)(WeakRetained + 423) == *(_QWORD *)(WeakRetained + 407)
      && *(_QWORD *)(WeakRetained + 375) == *(_QWORD *)(WeakRetained + 367))
    {
      v10 = WeakRetained;
      v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(WeakRetained + 231), "sessionID"));
      v4 = objc_alloc_init((Class)NSMutableDictionary);
      objc_msgSend(v4, "setObject:forKeyedSubscript:", &off_1001C46C0, CFSTR("State"));
      objc_msgSend(v4, "setObject:forKeyedSubscript:", v3, CFSTR("SessionID"));
      sub_100107BA4(CFSTR("IDS Session"), v4);

      sub_10003BCC8(v10);
      WeakRetained = v10;
    }
    else
    {
      if (gNRPacketLoggingEnabled)
      {
        v11 = WeakRetained;
        v5 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 4), v2);
        IsLevelEnabled = _NRLogIsLevelEnabled(v5, 1);

        WeakRetained = v11;
        if (IsLevelEnabled)
        {
          v8 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v11 + 4), v7);
          v9 = objc_msgSend(v11, "copyDescription");
          _NRLogWithArgs(v8, 1, "%s%.30s:%-4d %@: QR link has been active", "", "-[NRLinkQuickRelay armLinkIdleTimer]_block_invoke", 990, v9);

          WeakRetained = v11;
        }
      }
      *(_QWORD *)(WeakRetained + 423) = *(_QWORD *)(WeakRetained + 407);
      *(_QWORD *)(WeakRetained + 415) = *(_QWORD *)(WeakRetained + 391);
      *(_QWORD *)(WeakRetained + 375) = *(_QWORD *)(WeakRetained + 367);
    }
  }

}

void sub_10003D4EC(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  id *v5;
  id *v6;
  void *String;
  void *v8;
  char *v9;
  uint64_t v10;
  id v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  void *v15;
  id v16;
  id v17;
  id v18;
  void *v19;
  id v20;
  id v21;
  id v22;
  id v23;
  id v24;
  uint64_t v25;
  id v26;
  void *v27;
  void *v28;
  id v29;
  id v30;
  uint64_t v31;
  BOOL v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  int *v37;
  void *v38;
  int v39;
  uint64_t v40;
  void *v41;
  id v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  int v46;
  uint64_t v47;
  void *v48;
  int IsLevelEnabled;
  uint64_t v50;
  void *v51;
  id v52;
  void *v53;
  char *v54;
  _QWORD v55[2];

  v4 = objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "queue"));
  dispatch_assert_queue_V2(v4);

  if (!*(_BYTE *)(a1 + 214))
  {
    v5 = (id *)sub_10003D980(a1, a2);
    if (!*v5)
    {
      v6 = v5;
      String = (void *)NRDataProtectionClassCreateString(a2);
      v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "nrUUID"));
      v9 = sub_10012FFF4((uint64_t)NRDLocalDevice, v8);

      if (v9)
      {
        v11 = sub_100131288(v9, a2);

        if (v11)
        {
          v54 = v9;
          v13 = sub_100112798(1, v9, a2);
          v14 = objc_claimAutoreleasedReturnValue(+[NWAddressEndpoint endpointWithHostname:port:](NWAddressEndpoint, "endpointWithHostname:port:", CFSTR("::"), CFSTR("0")));
          v15 = String;
          v16 = objc_alloc((Class)NEIKEv2ConfigurationMessage);
          v17 = objc_msgSend(objc_alloc((Class)NEIKEv2InitiatorTransportIPv6Address), "initWithAddress:", v14);
          v55[0] = v17;
          v53 = (void *)v14;
          v18 = objc_msgSend(objc_alloc((Class)NEIKEv2ResponderTransportIPv6Address), "initWithAddress:", v14);
          v55[1] = v18;
          v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v55, 2));
          v20 = objc_msgSend(v16, "initWithWithAttributes:", v19);
          objc_msgSend(v13, "setConfigurationRequest:", v20);

          v21 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("terminusIKE-QuickRelay-%@"), v15);
          v22 = objc_alloc((Class)NEIKEv2Session);
          v23 = sub_100112198();
          v24 = sub_100112420();
          v25 = *(_QWORD *)(a1 + 8);
          v26 = objc_msgSend((id)a1, "virtualInterface");
          v27 = v22;
          v28 = v13;
          v29 = objc_msgSend(v27, "initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:kernelSASessionName:packetDelegate:", v23, v24, v13, v25, v26, 0, v21, a1);
          v30 = *v6;
          *v6 = v29;

          if (!*v6)
          {
            v48 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v31);
            IsLevelEnabled = _NRLogIsLevelEnabled(v48, 17);

            v28 = v13;
            String = v15;
            v33 = v53;
            v9 = v54;
            if (IsLevelEnabled)
            {
              v51 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v50);
              v52 = objc_msgSend((id)a1, "copyDescription");
              _NRLogWithArgs(v51, 17, "%@: Failed to create initiator %@ IKE session", v52, String);

              v28 = v13;
            }
            goto LABEL_21;
          }
          objc_msgSend((id)a1, "reportEvent:detailsFormat:", 3015, CFSTR("%@ %@"), v15, *v6);
          sub_10003DAF0(a1);
          String = v15;
          if ((_DWORD)a2 == 3)
          {
            v43 = mach_absolute_time();
            v44 = *(_QWORD *)(a1 + 639);
            v9 = v54;
            if (!v44)
            {
              v36 = 0;
              v33 = v53;
              goto LABEL_19;
            }
            *(_QWORD *)(v44 + 32) = v43;
            v36 = (char *)*(id *)(a1 + 639);
            v33 = v53;
            if (v36)
            {
              v37 = &OBJC_IVAR___NRAnalyticsCmpnLink__ikeClassCAttempts;
              goto LABEL_18;
            }
          }
          else
          {
            v32 = (_DWORD)a2 == 4;
            v33 = v53;
            v9 = v54;
            if (!v32)
              goto LABEL_20;
            v34 = mach_absolute_time();
            v35 = *(_QWORD *)(a1 + 639);
            if (!v35)
            {
              v36 = 0;
              goto LABEL_19;
            }
            *(_QWORD *)(v35 + 48) = v34;
            v36 = (char *)*(id *)(a1 + 639);
            if (v36)
            {
              v37 = &OBJC_IVAR___NRAnalyticsCmpnLink__ikeClassDAttempts;
LABEL_18:
              ++*(_QWORD *)&v36[*v37];
            }
          }
LABEL_19:

LABEL_20:
          objc_msgSend(*v6, "connect");
LABEL_21:

          goto LABEL_22;
        }
        v38 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v12);
        v39 = _NRLogIsLevelEnabled(v38, 0);

        if (!v39)
        {
LABEL_22:

          return;
        }
        v41 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v40);
        v42 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v41, 0, "%s%.30s:%-4d %@: Not starting %@ IKE initiator session because we do not have keys %@", "", "-[NRLinkQuickRelay setupIKEInitiatorSessionForClass:]", 1372, v42, String, v9);
      }
      else
      {
        v45 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v10);
        v46 = _NRLogIsLevelEnabled(v45, 17);

        if (!v46)
          goto LABEL_22;
        v41 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v47);
        v42 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v41, 17, "%@: Not starting %@ IKE initiator session because localDevice is missing", v42, String);
      }

      goto LABEL_22;
    }
  }
}

uint64_t sub_10003D980(uint64_t result, int a2)
{
  int *v2;
  id v3;
  int IsLevelEnabled;
  id v5;
  void *String;
  uint64_t v7;
  char *v8;
  int *v9;
  uint64_t v10;
  uint64_t v11;
  id v12;
  uint64_t v13;
  uint64_t v14;

  if (result)
  {
    if (a2 == 4)
    {
      v2 = &OBJC_IVAR___NRLinkQuickRelay__ikeSessionClassD;
      goto LABEL_6;
    }
    if (a2 == 3)
    {
      v2 = &OBJC_IVAR___NRLinkQuickRelay__ikeSessionClassC;
LABEL_6:
      result += *v2;
      return result;
    }
    HIDWORD(v14) = a2;
    v3 = sub_10003BC58();
    IsLevelEnabled = _NRLogIsLevelEnabled(v3, 16);

    if (IsLevelEnabled)
    {
      v5 = sub_10003BC58();
      String = (void *)NRDataProtectionClassCreateString(HIDWORD(v14));
      _NRLogWithArgs(v5, 16, "%s%.30s:%-4d ABORTING: Cannot copy IKE session pointer for %@", "", "-[NRLinkQuickRelay ikeSessionPointerForDataProtectionClass:]", 1107, String);

    }
    v7 = _os_log_pack_size(22);
    v8 = (char *)&v14 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
    v9 = __error();
    v10 = _os_log_pack_fill(v8, v7, *v9, &_mh_execute_header, "%{public}s Cannot copy IKE session pointer for %@");
    v11 = NRDataProtectionClassCreateString(HIDWORD(v14));
    *(_DWORD *)v10 = 136446466;
    *(_QWORD *)(v10 + 4) = "-[NRLinkQuickRelay ikeSessionPointerForDataProtectionClass:]";
    *(_WORD *)(v10 + 12) = 2112;
    *(_QWORD *)(v10 + 14) = v11;
    v12 = sub_10003BC58();
    v13 = _NRLogAbortWithPack(v12, v8);
    return sub_10003DAF0(v13);
  }
  return result;
}

void sub_10003DAF0(_QWORD *a1, uint64_t a2)
{
  NSObject *v4;
  void *String;
  id v6;
  void *v7;
  id v8;
  id v9;
  id v10;
  id v11;
  id v12;
  id v13;
  id v14;
  id v15;
  id v16;
  id v17;
  id v18;
  id v19;
  id v20;
  id v21;
  id v22;
  uint64_t v23;
  void *v24;
  char IsLevelEnabled;
  uint64_t v26;
  void *v27;
  id v28;
  id v29;
  int v30;
  id v31;
  _QWORD v32[4];
  id v33;
  id v34;
  id v35;
  _QWORD v36[4];
  id v37;
  id v38;
  id v39;
  _QWORD v40[4];
  id v41;
  id v42;
  id v43;
  _QWORD v44[4];
  id v45;
  id v46;
  id v47;
  _QWORD v48[4];
  id v49;
  id v50;
  id v51;
  _QWORD v52[4];
  id v53;
  id v54;
  id v55;
  char v56;
  _QWORD v57[4];
  id v58;
  id v59;
  id v60;
  char v61;
  id location[2];

  if (a1)
  {
    v4 = objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "queue"));
    dispatch_assert_queue_V2(v4);

    String = (void *)NRDataProtectionClassCreateString(a2);
    v6 = *(id *)sub_10003D980((uint64_t)a1, a2);
    v7 = v6;
    if (v6)
    {
      v8 = v6;
      objc_msgSend(v8, "setClientQueue:", a1[1]);
      objc_initWeak(location, a1);
      v57[0] = _NSConcreteStackBlock;
      v57[1] = 3221225472;
      v57[2] = sub_10003DFDC;
      v57[3] = &unk_1001B7290;
      objc_copyWeak(&v60, location);
      v9 = String;
      v58 = v9;
      v10 = v8;
      v59 = v10;
      v61 = a2;
      objc_msgSend(v10, "setStateUpdateBlock:", v57);
      v52[0] = _NSConcreteStackBlock;
      v52[1] = 3221225472;
      v52[2] = sub_10003E5F8;
      v52[3] = &unk_1001B72B8;
      objc_copyWeak(&v55, location);
      v11 = v9;
      v53 = v11;
      v12 = v10;
      v54 = v12;
      v56 = a2;
      objc_msgSend(v12, "setChildStateUpdateBlock:", v52);
      v48[0] = _NSConcreteStackBlock;
      v48[1] = 3221225472;
      v48[2] = sub_10003E748;
      v48[3] = &unk_1001B72E0;
      objc_copyWeak(&v51, location);
      v13 = v11;
      v49 = v13;
      v14 = v12;
      v50 = v14;
      objc_msgSend(v14, "setConfigurationUpdateBlock:", v48);
      v44[0] = _NSConcreteStackBlock;
      v44[1] = 3221225472;
      v44[2] = sub_10003E814;
      v44[3] = &unk_1001B7308;
      objc_copyWeak(&v47, location);
      v15 = v13;
      v45 = v15;
      v16 = v14;
      v46 = v16;
      objc_msgSend(v16, "setTrafficSelectorUpdateBlock:", v44);
      v40[0] = _NSConcreteStackBlock;
      v40[1] = 3221225472;
      v40[2] = sub_10003E900;
      v40[3] = &unk_1001B7330;
      objc_copyWeak(&v43, location);
      v17 = v15;
      v41 = v17;
      v18 = v16;
      v42 = v18;
      objc_msgSend(v18, "setAdditionalAddressesUpdateBlock:", v40);
      v36[0] = _NSConcreteStackBlock;
      v36[1] = 3221225472;
      v36[2] = sub_10003E9CC;
      v36[3] = &unk_1001B7928;
      objc_copyWeak(&v39, location);
      v19 = v17;
      v37 = v19;
      v20 = v18;
      v38 = v20;
      objc_msgSend(v20, "setShortDPDEventBlock:", v36);
      v32[0] = _NSConcreteStackBlock;
      v32[1] = 3221225472;
      v32[2] = sub_10003EA8C;
      v32[3] = &unk_1001B7330;
      objc_copyWeak(&v35, location);
      v21 = v19;
      v33 = v21;
      v22 = v20;
      v34 = v22;
      objc_msgSend(v22, "setPrivateNotifyStatusEvent:", v32);
      v24 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v23);
      IsLevelEnabled = _NRLogIsLevelEnabled(v24, 0);

      if ((IsLevelEnabled & 1) != 0)
      {
        v27 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v26);
        v28 = objc_msgSend(a1, "copyDescription");
        _NRLogWithArgs(v27, 0, "%s%.30s:%-4d %@: Setup IKE %@ %@ callbacks", "", "-[NRLinkQuickRelay setupIKECallbacksForClass:]", 1341, v28, v21, v22);

      }
      objc_destroyWeak(&v35);

      objc_destroyWeak(&v39);
      objc_destroyWeak(&v43);

      objc_destroyWeak(&v47);
      objc_destroyWeak(&v51);

      objc_destroyWeak(&v55);
      objc_destroyWeak(&v60);
      objc_destroyWeak(location);

    }
    else
    {
      v29 = sub_10003BC58();
      v30 = _NRLogIsLevelEnabled(v29, 17);

      if (v30)
      {
        v31 = sub_10003BC58();
        _NRLogWithArgs(v31, 17, "%s called with null ikeSession", "-[NRLinkQuickRelay setupIKECallbacksForClass:]");

      }
    }

  }
}

void sub_10003DF5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id *location, id *a18, id *a19)
{
  id *v19;
  id *v20;
  id *v21;
  id *v22;
  uint64_t v23;

  objc_destroyWeak(v19);
  objc_destroyWeak(v22);
  objc_destroyWeak(v21);
  objc_destroyWeak(v20);
  objc_destroyWeak(location);
  objc_destroyWeak(a18);
  objc_destroyWeak(a19);
  objc_destroyWeak((id *)(v23 - 112));
  _Unwind_Resume(a1);
}

void sub_10003DFDC(uint64_t a1, uint64_t a2, void *a3)
{
  char *WeakRetained;
  uint64_t v6;
  uint64_t v7;
  void *SessionStateString;
  int v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  int IsLevelEnabled;
  uint64_t v14;
  void *v15;
  id v16;
  uint64_t v17;
  void *v18;
  int v19;
  uint64_t v20;
  void *v21;
  id v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  id v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  void *v34;
  int v35;
  uint64_t v36;
  void *v37;
  id v38;
  const char *v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  void *v43;
  int v44;
  uint64_t v45;
  void *v46;
  id v47;
  void *v48;
  int v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  void *v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  id v57;
  uint64_t v58;
  uint64_t v59;
  id v60;

  v60 = a3;
  WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 48));
  if (!WeakRetained)
    goto LABEL_55;
  v6 = *(_QWORD *)(a1 + 32);
  v7 = *(_QWORD *)(a1 + 40);
  SessionStateString = (void *)NEIKEv2CreateSessionStateString(a2);
  if (!v60)
  {
    objc_msgSend(WeakRetained, "reportEvent:detailsFormat:", 3009, CFSTR("%@ session %@ changed state to %@"), v6, v7, SessionStateString);

    switch(a2)
    {
      case 1:
        if (objc_msgSend(WeakRetained, "state") == 1)
        {
          v12 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 4), v11);
          IsLevelEnabled = _NRLogIsLevelEnabled(v12, 0);

          if (IsLevelEnabled)
          {
            v15 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 4), v14);
            v16 = objc_msgSend(WeakRetained, "copyDescription");
            _NRLogWithArgs(v15, 0, "%s%.30s:%-4d %@: %@ IKE %@ now connecting", "", "-[NRLinkQuickRelay setupIKECallbacksForClass:]_block_invoke", 1204, v16, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));

          }
          objc_msgSend(WeakRetained, "changeStateTo:", 5);
        }
        else
        {
          v31 = objc_msgSend(WeakRetained, "state");
          v33 = _NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 4), v32);
          v34 = (void *)v33;
          if (v31 == 5)
          {
            v35 = _NRLogIsLevelEnabled(v33, 0);

            if (v35)
            {
              v37 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 4), v36);
              v38 = objc_msgSend(WeakRetained, "copyDescription");
              v58 = *(_QWORD *)(a1 + 32);
              v59 = *(_QWORD *)(a1 + 40);
              v56 = 1207;
              v57 = v38;
              v39 = "%s%.30s:%-4d %@: %@ IKE %@ already connecting";
              goto LABEL_53;
            }
          }
          else
          {
            v51 = _NRLogIsLevelEnabled(v33, 16);

            if (v51)
            {
              v37 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 4), v52);
              v38 = objc_msgSend(WeakRetained, "copyDescription");
              _NRLogWithArgs(v37, 16, "%s%.30s:%-4d %@: %@ IKE %@ connecting but weird state", "", "-[NRLinkQuickRelay setupIKECallbacksForClass:]_block_invoke", 1209, v38, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
              goto LABEL_54;
            }
          }
        }
        goto LABEL_55;
      case 2:
        v27 = *(unsigned __int8 *)(a1 + 56);
        if (v27 == 3)
        {
          v40 = mach_absolute_time();
          v41 = *(_QWORD *)(WeakRetained + 639);
          if (v41)
            *(_QWORD *)(v41 + 40) = v40;
          objc_msgSend(WeakRetained, "setIkeClassCEstablished:", 1);
          WeakRetained[219] = 0;
          v30 = objc_alloc_init((Class)NSDate);
          sub_10003EEC4((uint64_t)WeakRetained, v30);
        }
        else
        {
          if (v27 != 4)
            goto LABEL_41;
          v28 = mach_absolute_time();
          v29 = *(_QWORD *)(WeakRetained + 639);
          if (v29)
            *(_QWORD *)(v29 + 56) = v28;
          objc_msgSend(WeakRetained, "setIkeClassDEstablished:", 1);
          WeakRetained[218] = 0;
          v30 = objc_alloc_init((Class)NSDate);
          sub_10003EEB4((uint64_t)WeakRetained, v30);
        }

LABEL_41:
        v42 = WeakRetained[16];
        if ((v42 - 8) >= 2)
        {
          if (v42 != 5)
          {
            v53 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 4), v10);
            v54 = _NRLogIsLevelEnabled(v53, 0);

            if (v54)
            {
              v37 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 4), v55);
              v38 = objc_msgSend(WeakRetained, "copyDescription");
              v58 = *(_QWORD *)(a1 + 32);
              v59 = *(_QWORD *)(a1 + 40);
              v56 = 1231;
              v57 = v38;
              v39 = "%s%.30s:%-4d %@: %@ IKE %@ connected but weird state";
LABEL_53:
              _NRLogWithArgs(v37, 0, v39, "", "-[NRLinkQuickRelay setupIKECallbacksForClass:]_block_invoke", v56, v57, v58, v59);
LABEL_54:

            }
            goto LABEL_55;
          }
          v48 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 4), v10);
          v49 = _NRLogIsLevelEnabled(v48, 0);

          if (v49)
          {
            v46 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 4), v50);
            v47 = objc_msgSend(WeakRetained, "copyDescription");
            _NRLogWithArgs(v46, 0, "%s%.30s:%-4d %@: %@ IKE %@ connected", "", "-[NRLinkQuickRelay setupIKECallbacksForClass:]_block_invoke", 1225, v47, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
            goto LABEL_47;
          }
        }
        else
        {
          v43 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 4), v10);
          v44 = _NRLogIsLevelEnabled(v43, 0);

          if (v44)
          {
            v46 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 4), v45);
            v47 = objc_msgSend(WeakRetained, "copyDescription");
            _NRLogWithArgs(v46, 0, "%s%.30s:%-4d %@: %@ IKE %@ connected", "", "-[NRLinkQuickRelay setupIKECallbacksForClass:]_block_invoke", 1228, v47, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
LABEL_47:

          }
        }
        sub_10003EED4((uint64_t)WeakRetained);
        goto LABEL_55;
      case 3:
        v18 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 4), v10);
        v19 = _NRLogIsLevelEnabled(v18, 0);

        if (v19)
        {
          v21 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 4), v20);
          v22 = objc_msgSend(WeakRetained, "copyDescription");
          _NRLogWithArgs(v21, 0, "%s%.30s:%-4d %@: %@ IKE %@ disconnected", "", "-[NRLinkQuickRelay setupIKECallbacksForClass:]_block_invoke", 1236, v22, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));

        }
        v23 = *(unsigned __int8 *)(a1 + 56);
        if (v23 == 4)
        {
          objc_msgSend(WeakRetained, "setIkeClassDEstablished:", 0);
        }
        else if (v23 == 3)
        {
          objc_msgSend(WeakRetained, "setIkeClassCEstablished:", 0);
        }
        if (WeakRetained[212])
          sub_10003ECFC((uint64_t)WeakRetained, *(unsigned __int8 *)(a1 + 56));
        else
          objc_msgSend(WeakRetained, "invalidateIKESessionForClass:", *(unsigned __int8 *)(a1 + 56));
        goto LABEL_55;
      case 4:
        objc_msgSend(WeakRetained, "cancelWithReason:", CFSTR("%@ session %@ got unexpected MOBIKE state"), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
        goto LABEL_55;
      default:
        v24 = *(_QWORD *)(a1 + 32);
        v25 = *(_QWORD *)(a1 + 40);
        v26 = (void *)NEIKEv2CreateSessionStateString(a2);
        objc_msgSend(WeakRetained, "cancelWithReason:", CFSTR("%@ session %@ got bad IKE state %@"), v24, v25, v26);

        goto LABEL_55;
    }
  }
  objc_msgSend(WeakRetained, "reportEvent:detailsFormat:", 3018, CFSTR("%@ session %@ got IKE error %@ with state %@"), v6, v7, v60, SessionStateString);

  v9 = *(unsigned __int8 *)(a1 + 56);
  if (v9 == 3)
  {
    objc_msgSend(WeakRetained, "setIkeClassCEstablished:", 0);
  }
  else if (v9 == 4)
  {
    objc_msgSend(WeakRetained, "setIkeClassDEstablished:", 0);
  }
  v17 = *(unsigned __int8 *)(a1 + 56);
  if (!WeakRetained[208])
  {
    objc_msgSend(WeakRetained, "processIKEDisconnection:error:", v17, v60);
    if (objc_msgSend(WeakRetained, "state") == 255)
      goto LABEL_55;
    v17 = *(unsigned __int8 *)(a1 + 56);
  }
  if (WeakRetained[212])
    sub_10003ECFC((uint64_t)WeakRetained, v17);
  else
    objc_msgSend(WeakRetained, "invalidateIKESessionForClass:", v17);
LABEL_55:

}

void sub_10003E5F8(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  _BYTE *WeakRetained;
  uint64_t v8;
  uint64_t v9;
  void *SessionStateString;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  id v14;

  v14 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    if (v14)
    {
      v8 = *(_QWORD *)(a1 + 32);
      v9 = *(_QWORD *)(a1 + 40);
      SessionStateString = (void *)NEIKEv2CreateSessionStateString(a3);
      objc_msgSend(WeakRetained, "reportEvent:detailsFormat:", 3018, CFSTR("%@ session %@ got child %u state update %@ error %@"), v8, v9, a2, SessionStateString, v14);

      if (!WeakRetained[208])
      {
        objc_msgSend(WeakRetained, "processIKEDisconnection:error:", *(unsigned __int8 *)(a1 + 56), v14);
        if (objc_msgSend(WeakRetained, "state") == 255)
          goto LABEL_12;
      }
    }
    else
    {
      v11 = *(_QWORD *)(a1 + 32);
      v12 = *(_QWORD *)(a1 + 40);
      if (a3 != 3)
      {
        v13 = (void *)NEIKEv2CreateSessionStateString(a3);
        objc_msgSend(WeakRetained, "reportEvent:detailsFormat:", 3009, CFSTR("%@ session %@ child %u state update %@"), v11, v12, a2, v13);

        goto LABEL_12;
      }
      objc_msgSend(WeakRetained, "reportEvent:detailsFormat:", 3018, CFSTR("%@ session %@ got child %u Disconnected state with no error"), v11, *(_QWORD *)(a1 + 40), a2);
    }
    if (WeakRetained[212])
      sub_10003ECFC((uint64_t)WeakRetained, *(unsigned __int8 *)(a1 + 56));
    else
      objc_msgSend(WeakRetained, "invalidateIKESessionForClass:", *(unsigned __int8 *)(a1 + 56));
  }
LABEL_12:

}

void sub_10003E748(uint64_t a1, void *a2)
{
  _QWORD *WeakRetained;
  uint64_t v4;
  _QWORD *v5;
  void *v6;
  int IsLevelEnabled;
  uint64_t v8;
  void *v9;
  id v10;
  id v11;

  v11 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  v5 = WeakRetained;
  if (WeakRetained)
  {
    v6 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0);

    if (IsLevelEnabled)
    {
      v9 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v8);
      v10 = objc_msgSend(v5, "copyDescription");
      _NRLogWithArgs(v9, 0, "%s%.30s:%-4d %@: %@ session %@ got config update %@", "", "-[NRLinkQuickRelay setupIKECallbacksForClass:]_block_invoke_3", 1299, v10, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), v11);

    }
  }

}

void sub_10003E814(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v7;
  _QWORD *WeakRetained;
  uint64_t v9;
  _QWORD *v10;
  void *v11;
  int IsLevelEnabled;
  uint64_t v13;
  void *v14;
  id v15;
  id v16;

  v16 = a3;
  v7 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  v10 = WeakRetained;
  if (WeakRetained)
  {
    v11 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v9);
    IsLevelEnabled = _NRLogIsLevelEnabled(v11, 0);

    if (IsLevelEnabled)
    {
      v14 = (void *)_NRCopyLogObjectForNRUUID(v10[4], v13);
      v15 = objc_msgSend(v10, "copyDescription");
      _NRLogWithArgs(v14, 0, "%s%.30s:%-4d %@: %@ session %@ got child %u traffic selector update local %@ remote %@", "", "-[NRLinkQuickRelay setupIKECallbacksForClass:]_block_invoke_4", 1310, v15, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), a2, v16, v7);

    }
  }

}

void sub_10003E900(uint64_t a1, void *a2)
{
  _QWORD *WeakRetained;
  uint64_t v4;
  _QWORD *v5;
  void *v6;
  int IsLevelEnabled;
  uint64_t v8;
  void *v9;
  id v10;
  id v11;

  v11 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  v5 = WeakRetained;
  if (WeakRetained)
  {
    v6 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0);

    if (IsLevelEnabled)
    {
      v9 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v8);
      v10 = objc_msgSend(v5, "copyDescription");
      _NRLogWithArgs(v9, 0, "%s%.30s:%-4d %@: %@ session %@ got additional addresses %@", "", "-[NRLinkQuickRelay setupIKECallbacksForClass:]_block_invoke_5", 1319, v10, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), v11);

    }
  }

}

void sub_10003E9CC(uint64_t a1)
{
  _QWORD *WeakRetained;
  uint64_t v3;
  void *v4;
  int IsLevelEnabled;
  uint64_t v6;
  void *v7;
  id v8;
  _QWORD *v9;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    v9 = WeakRetained;
    v4 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v3);
    IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0);

    WeakRetained = v9;
    if (IsLevelEnabled)
    {
      v7 = (void *)_NRCopyLogObjectForNRUUID(v9[4], v6);
      v8 = objc_msgSend(v9, "copyDescription");
      _NRLogWithArgs(v7, 0, "%s%.30s:%-4d %@: %@ session %@ got short DPD", "", "-[NRLinkQuickRelay setupIKECallbacksForClass:]_block_invoke_6", 1327, v8, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));

      WeakRetained = v9;
    }
  }

}

void sub_10003EA8C(uint64_t a1, void *a2)
{
  id v3;
  _QWORD *WeakRetained;
  uint64_t v5;
  _QWORD *v6;
  void *v7;
  int IsLevelEnabled;
  uint64_t v9;
  void *v10;
  id v11;
  id v12;
  id v13;
  id v14;
  uint64_t v15;
  void *i;
  void *v17;
  unsigned int v18;
  id v19;
  uint64_t v20;
  void *v21;
  int v22;
  uint64_t v23;
  void *v24;
  id v25;
  void *v26;
  id v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  _BYTE v32[128];

  v3 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  v6 = WeakRetained;
  if (WeakRetained)
  {
    v7 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v5);
    IsLevelEnabled = _NRLogIsLevelEnabled(v7, 0);

    if (IsLevelEnabled)
    {
      v10 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v9);
      v11 = objc_msgSend(v6, "copyDescription");
      _NRLogWithArgs(v10, 0, "%s%.30s:%-4d %@: %@ session %@ got private notifies %@", "", "-[NRLinkQuickRelay setupIKECallbacksForClass:]_block_invoke_7", 1335, v11, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), v3);

    }
    v30 = 0u;
    v31 = 0u;
    v28 = 0u;
    v29 = 0u;
    v27 = v3;
    v12 = v3;
    v13 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v28, v32, 16);
    if (v13)
    {
      v14 = v13;
      v15 = *(_QWORD *)v29;
      do
      {
        for (i = 0; i != v14; i = (char *)i + 1)
        {
          if (*(_QWORD *)v29 != v15)
            objc_enumerationMutation(v12);
          v17 = *(void **)(*((_QWORD *)&v28 + 1) + 8 * (_QWORD)i);
          v18 = objc_msgSend(v17, "notifyStatus");
          v19 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "notifyData"));
          v21 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v20);
          v22 = _NRLogIsLevelEnabled(v21, 1);

          if (v22)
          {
            v24 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v23);
            v25 = objc_msgSend(v6, "copyDescription");
            _NRLogWithArgs(v24, 1, "%s%.30s:%-4d %@: Received notify code %u %@", "", "-[NRLinkQuickRelay handleNotifyCode:payload:]", 1346, v25, v18, v19);

          }
          if (v18 == 50702)
          {
            v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "linkDelegate"));
            objc_msgSend(v26, "linkDidReceiveData:data:", v6, v19);

          }
        }
        v14 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v28, v32, 16);
      }
      while (v14);
    }

    v3 = v27;
  }

}

void sub_10003ECFC(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  void *v6;
  int v7;
  uint64_t v8;
  void *v9;
  id v10;
  void *v11;
  uint64_t v12;
  void *v13;
  int IsLevelEnabled;
  uint64_t v15;
  void *v16;
  id v17;

  v4 = objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "queue"));
  dispatch_assert_queue_V2(v4);

  objc_msgSend((id)a1, "invalidateIKESessionForClass:", a2);
  if ((_DWORD)a2 == 4)
  {
    if (++*(_BYTE *)(a1 + 218) >= 3u)
    {
      v13 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
      IsLevelEnabled = _NRLogIsLevelEnabled(v13, 0);

      if (IsLevelEnabled)
      {
        v16 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v15);
        v17 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v16, 0, "%s%.30s:%-4d %@: hit max number of retries for ClassD IKE. Will retry when path changes", "", "-[NRLinkQuickRelay restartIKESessionForClass:]", 1137, v17);

      }
      v11 = (void *)a1;
      v12 = 10023;
      goto LABEL_11;
    }
  }
  else if ((_DWORD)a2 == 3 && ++*(_BYTE *)(a1 + 219) >= 3u)
  {
    v6 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
    v7 = _NRLogIsLevelEnabled(v6, 0);

    if (v7)
    {
      v9 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v8);
      v10 = objc_msgSend((id)a1, "copyDescription");
      _NRLogWithArgs(v9, 0, "%s%.30s:%-4d %@: hit max number of retries for ClassC IKE. Will retry when path changes", "", "-[NRLinkQuickRelay restartIKESessionForClass:]", 1130, v10);

    }
    v11 = (void *)a1;
    v12 = 10024;
LABEL_11:
    objc_msgSend(v11, "reportEvent:", v12);
    return;
  }
  sub_10003D4EC(a1, a2);
}

void sub_10003EEB4(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(a1 + 351), a2);
}

void sub_10003EEC4(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(a1 + 359), a2);
}

void sub_10003EED4(uint64_t a1)
{
  NSObject *v2;
  id v3;

  v2 = objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "queue"));
  dispatch_assert_queue_V2(v2);

  if (objc_msgSend((id)a1, "state") != 255)
  {
    sub_10003EFAC(a1);
    objc_msgSend(*(id *)(a1 + 279), "setAvailability:", 1);
    if (*(_BYTE *)(a1 + 211))
    {
      *(_BYTE *)(a1 + 211) = 0;
      if (*(_BYTE *)(a1 + 209))
      {
        dispatch_resume(*(dispatch_object_t *)(a1 + 319));
        *(_BYTE *)(a1 + 209) = 0;
      }
    }
    objc_msgSend((id)a1, "changeStateTo:", 8);
    v3 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "linkDelegate"));
    objc_msgSend(v3, "linkIsReady:", a1);

  }
}

void sub_10003EFAC(uint64_t a1)
{
  NSObject *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  int IsLevelEnabled;
  uint64_t v8;
  void *v9;
  id v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t extended;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  int v22;
  uint64_t v23;
  void *v24;
  id v25;
  int v26;
  uint64_t v27;
  void *v28;
  id v29;
  void *v30;
  int v31;
  uint64_t v32;
  void *v33;
  int v34;
  uint64_t v35;
  void *v36;
  id v37;
  int v38;
  id v39;
  int v40;
  uint64_t v41;
  void *v42;
  id v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  void *v47;
  int v48;
  uint64_t v49;
  void *v50;
  id v51;
  int v52;
  uint64_t v53;
  void *v54;
  id v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  void *v59;
  int v60;
  uint64_t v61;
  void *v62;
  id v63;
  int v64;
  uint64_t v65;
  void *v66;
  id v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  void *v71;
  int v72;
  uint64_t v73;
  void *v74;
  id v75;
  int v76;
  uint64_t v77;
  void *v78;
  id v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  void *v83;
  int v84;
  uint64_t v85;
  void *v86;
  id v87;
  int v88;
  uint64_t v89;
  void *v90;
  id v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  void *v95;
  int v96;
  uint64_t v97;
  void *v98;
  id v99;
  int v100;
  uint64_t v101;
  void *v102;
  id v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  void *v107;
  int v108;
  uint64_t v109;
  void *v110;
  id v111;
  int v112;
  uint64_t v113;
  void *v114;
  id v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  void *v119;
  int v120;
  uint64_t v121;
  void *v122;
  id v123;
  int v124;
  uint64_t v125;
  void *v126;
  id v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  void *v131;
  int v132;
  uint64_t v133;
  void *v134;
  id v135;
  int v136;
  uint64_t v137;
  void *v138;
  id v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  void *v143;
  int v144;
  uint64_t v145;
  void *v146;
  id v147;
  int v148;
  uint64_t v149;
  void *v150;
  id v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  void *v155;
  int v156;
  uint64_t v157;
  void *v158;
  id v159;
  int v160;
  uint64_t v161;
  void *v162;
  id v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  void *v167;
  int v168;
  uint64_t v169;
  void *v170;
  id v171;
  int v172;
  uint64_t v173;
  void *v174;
  id v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  void *v179;
  int v180;
  uint64_t v181;
  void *v182;
  id v183;
  int v184;
  uint64_t v185;
  void *v186;
  id v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  void *v191;
  int v192;
  uint64_t v193;
  void *v194;
  id v195;
  int v196;
  uint64_t v197;
  void *v198;
  id v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  void *v203;
  int v204;
  uint64_t v205;
  void *v206;
  id v207;
  int v208;
  uint64_t v209;
  void *v210;
  id v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  void *v215;
  int v216;
  uint64_t v217;
  void *v218;
  id v219;
  int v220;
  uint64_t v221;
  void *v222;
  id v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  void *v227;
  int v228;
  uint64_t v229;
  void *v230;
  id v231;
  int v232;
  uint64_t v233;
  void *v234;
  id v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  void *v239;
  int v240;
  uint64_t v241;
  void *v242;
  id v243;
  int v244;
  uint64_t v245;
  void *v246;
  id v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  void *v251;
  int v252;
  uint64_t v253;
  void *v254;
  id v255;
  int v256;
  uint64_t v257;
  void *v258;
  id v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  unsigned int fd;
  dispatch_group_t v268;
  NSObject *v269;
  dispatch_source_t v270;
  void *v271;
  NSObject *v272;
  NSObject *v273;
  NSObject *v274;
  dispatch_source_t v275;
  void *v276;
  NSObject *v277;
  NSObject *v278;
  NSObject *v279;
  NSObject *v280;
  void *v281;
  NSObject *v282;
  void *v283;
  int v284;
  uint64_t v285;
  void *v286;
  id v287;
  void *v288;
  int v289;
  uint64_t v290;
  void *v291;
  id v292;
  void *v293;
  int v294;
  uint64_t v295;
  void *v296;
  id v297;
  id v298;
  int v299;
  id v300;
  uint64_t v301;
  char *v302;
  int *v303;
  uint64_t v304;
  id v305;
  id v306;
  int v307;
  id v308;
  uint64_t v309;
  char *v310;
  int *v311;
  uint64_t v312;
  id v313;
  id v314;
  char v315;
  id v316;
  uint64_t v317;
  char *v318;
  int *v319;
  uint64_t v320;
  id v321;
  id *v322;
  _QWORD v323[5];
  _QWORD v324[4];
  NSObject *v325;
  _QWORD v326[4];
  id v327;
  _QWORD v328[4];
  NSObject *v329;
  _QWORD v330[4];
  id v331;
  id v332[16];
  _QWORD v333[2];

  v2 = objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "queue"));
  dispatch_assert_queue_V2(v2);

  if (!*(_QWORD *)(a1 + 295))
  {
    v333[0] = 0;
    v333[1] = 0;
    v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 279), "nexusInstances"));
    v5 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v4);
    v6 = (void *)v5;
    if (v3)
    {
      IsLevelEnabled = _NRLogIsLevelEnabled(v5, 1);

      if (IsLevelEnabled)
      {
        v9 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v8);
        v10 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v9, 1, "%s%.30s:%-4d %@: Created nexus instances: %@", "", "-[NRLinkQuickRelay setupNexus]", 787, v10, v3);

      }
      if (objc_msgSend(v3, "count") == 1)
      {
        v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "firstObject"));
        v13 = os_channel_attr_create(objc_msgSend(v12, "getUUIDBytes:", v333));
        v15 = v13;
        if (!v13)
        {
          v33 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v14);
          v34 = _NRLogIsLevelEnabled(v33, 17);

          if (v34)
          {
            v36 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v35);
            v37 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v36, 17, "%@: os_channel_attr_create failed", v37);

          }
          goto LABEL_25;
        }
        os_channel_attr_set(v13, 7, 1);
        extended = os_channel_create_extended(v333, 0, 0, 0xFFFFFFFFLL, v15);
        v17 = extended;
        if (!extended)
        {
          v38 = *__error();
          if (strerror_r(v38, (char *)v332, 0x80uLL))
            LOBYTE(v332[0]) = 0;
          if (qword_1001E45F0 != -1)
            dispatch_once(&qword_1001E45F0, &stru_1001B66A0);
          if (_NRLogIsLevelEnabled(qword_1001E45E8, 17))
          {
            v39 = sub_10003BC58();
            _NRLogWithArgs(v39, 17, "os_channel_create_extended failed: [%d] %s", v38, (const char *)v332);

          }
          NEVirtualInterfaceDisableChannel(objc_msgSend((id)a1, "virtualInterface"));
          os_channel_attr_destroy(v15);
          goto LABEL_25;
        }
        *(_QWORD *)(a1 + 295) = extended;
        v332[0] = 0;
        v18 = os_channel_attr_get(v15, 0, v332);
        v20 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v19);
        v21 = (void *)v20;
        if ((_DWORD)v18)
        {
          v22 = _NRLogIsLevelEnabled(v20, 17);

          if (v22)
          {
            v24 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v23);
            v25 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v24, 17, "%@: os_channel_attr_get(TX_RINGS) returned %d", v25, v18);

          }
          goto LABEL_25;
        }
        v40 = _NRLogIsLevelEnabled(v20, 1);

        if (v40)
        {
          v42 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v41);
          v43 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v42, 1, "%s%.30s:%-4d %@: Nexus Channel TX_RINGS = %llu", "", "-[NRLinkQuickRelay setupNexus]", 832, v43, v332[0]);

        }
        v332[0] = 0;
        v44 = os_channel_attr_get(v15, 1, v332);
        v46 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v45);
        v47 = (void *)v46;
        if ((_DWORD)v44)
        {
          v48 = _NRLogIsLevelEnabled(v46, 17);

          if (v48)
          {
            v50 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v49);
            v51 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v50, 17, "%@: os_channel_attr_get(RX_RINGS) returned %d", v51, v44);

          }
          goto LABEL_25;
        }
        v52 = _NRLogIsLevelEnabled(v46, 1);

        if (v52)
        {
          v54 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v53);
          v55 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v54, 1, "%s%.30s:%-4d %@: Nexus Channel RX_RINGS = %llu", "", "-[NRLinkQuickRelay setupNexus]", 833, v55, v332[0]);

        }
        v332[0] = 0;
        v56 = os_channel_attr_get(v15, 2, v332);
        v58 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v57);
        v59 = (void *)v58;
        if ((_DWORD)v56)
        {
          v60 = _NRLogIsLevelEnabled(v58, 17);

          if (v60)
          {
            v62 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v61);
            v63 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v62, 17, "%@: os_channel_attr_get(TX_SLOTS) returned %d", v63, v56);

          }
          goto LABEL_25;
        }
        v64 = _NRLogIsLevelEnabled(v58, 1);

        if (v64)
        {
          v66 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v65);
          v67 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v66, 1, "%s%.30s:%-4d %@: Nexus Channel TX_SLOTS = %llu", "", "-[NRLinkQuickRelay setupNexus]", 834, v67, v332[0]);

        }
        v332[0] = 0;
        v68 = os_channel_attr_get(v15, 3, v332);
        v70 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v69);
        v71 = (void *)v70;
        if ((_DWORD)v68)
        {
          v72 = _NRLogIsLevelEnabled(v70, 17);

          if (v72)
          {
            v74 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v73);
            v75 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v74, 17, "%@: os_channel_attr_get(RX_SLOTS) returned %d", v75, v68);

          }
          goto LABEL_25;
        }
        v76 = _NRLogIsLevelEnabled(v70, 1);

        if (v76)
        {
          v78 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v77);
          v79 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v78, 1, "%s%.30s:%-4d %@: Nexus Channel RX_SLOTS = %llu", "", "-[NRLinkQuickRelay setupNexus]", 835, v79, v332[0]);

        }
        v332[0] = 0;
        v80 = os_channel_attr_get(v15, 4, v332);
        v82 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v81);
        v83 = (void *)v82;
        if ((_DWORD)v80)
        {
          v84 = _NRLogIsLevelEnabled(v82, 17);

          if (v84)
          {
            v86 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v85);
            v87 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v86, 17, "%@: os_channel_attr_get(SLOT_BUF_SIZE) returned %d", v87, v80);

          }
          goto LABEL_25;
        }
        v88 = _NRLogIsLevelEnabled(v82, 1);

        if (v88)
        {
          v90 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v89);
          v91 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v90, 1, "%s%.30s:%-4d %@: Nexus Channel SLOT_BUF_SIZE = %llu", "", "-[NRLinkQuickRelay setupNexus]", 836, v91, v332[0]);

        }
        v332[0] = 0;
        v92 = os_channel_attr_get(v15, 5, v332);
        v94 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v93);
        v95 = (void *)v94;
        if ((_DWORD)v92)
        {
          v96 = _NRLogIsLevelEnabled(v94, 17);

          if (v96)
          {
            v98 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v97);
            v99 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v98, 17, "%@: os_channel_attr_get(SLOT_META_SIZE) returned %d", v99, v92);

          }
          goto LABEL_25;
        }
        v100 = _NRLogIsLevelEnabled(v94, 1);

        if (v100)
        {
          v102 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v101);
          v103 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v102, 1, "%s%.30s:%-4d %@: Nexus Channel SLOT_META_SIZE = %llu", "", "-[NRLinkQuickRelay setupNexus]", 837, v103, v332[0]);

        }
        v332[0] = 0;
        v104 = os_channel_attr_get(v15, 6, v332);
        v106 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v105);
        v107 = (void *)v106;
        if ((_DWORD)v104)
        {
          v108 = _NRLogIsLevelEnabled(v106, 17);

          if (v108)
          {
            v110 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v109);
            v111 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v110, 17, "%@: os_channel_attr_get(EXCLUSIVE) returned %d", v111, v104);

          }
          goto LABEL_25;
        }
        v112 = _NRLogIsLevelEnabled(v106, 1);

        if (v112)
        {
          v114 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v113);
          v115 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v114, 1, "%s%.30s:%-4d %@: Nexus Channel EXCLUSIVE = %llu", "", "-[NRLinkQuickRelay setupNexus]", 838, v115, v332[0]);

        }
        v332[0] = 0;
        v116 = os_channel_attr_get(v15, 7, v332);
        v118 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v117);
        v119 = (void *)v118;
        if ((_DWORD)v116)
        {
          v120 = _NRLogIsLevelEnabled(v118, 17);

          if (v120)
          {
            v122 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v121);
            v123 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v122, 17, "%@: os_channel_attr_get(NO_AUTO_SYNC) returned %d", v123, v116);

          }
          goto LABEL_25;
        }
        v124 = _NRLogIsLevelEnabled(v118, 1);

        if (v124)
        {
          v126 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v125);
          v127 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v126, 1, "%s%.30s:%-4d %@: Nexus Channel NO_AUTO_SYNC = %llu", "", "-[NRLinkQuickRelay setupNexus]", 839, v127, v332[0]);

        }
        v332[0] = 0;
        v128 = os_channel_attr_get(v15, 8, v332);
        v130 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v129);
        v131 = (void *)v130;
        if ((_DWORD)v128)
        {
          v132 = _NRLogIsLevelEnabled(v130, 17);

          if (v132)
          {
            v134 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v133);
            v135 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v134, 17, "%@: os_channel_attr_get(MONITOR) returned %d", v135, v128);

          }
          goto LABEL_25;
        }
        v136 = _NRLogIsLevelEnabled(v130, 1);

        if (v136)
        {
          v138 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v137);
          v139 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v138, 1, "%s%.30s:%-4d %@: Nexus Channel MONITOR = %llu", "", "-[NRLinkQuickRelay setupNexus]", 840, v139, v332[0]);

        }
        v332[0] = 0;
        v140 = os_channel_attr_get(v15, 9, v332);
        v142 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v141);
        v143 = (void *)v142;
        if ((_DWORD)v140)
        {
          v144 = _NRLogIsLevelEnabled(v142, 17);

          if (v144)
          {
            v146 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v145);
            v147 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v146, 17, "%@: os_channel_attr_get(TX_LOWAT_UNIT) returned %d", v147, v140);

          }
          goto LABEL_25;
        }
        v148 = _NRLogIsLevelEnabled(v142, 1);

        if (v148)
        {
          v150 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v149);
          v151 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v150, 1, "%s%.30s:%-4d %@: Nexus Channel TX_LOWAT_UNIT = %llu", "", "-[NRLinkQuickRelay setupNexus]", 841, v151, v332[0]);

        }
        v332[0] = 0;
        v152 = os_channel_attr_get(v15, 10, v332);
        v154 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v153);
        v155 = (void *)v154;
        if ((_DWORD)v152)
        {
          v156 = _NRLogIsLevelEnabled(v154, 17);

          if (v156)
          {
            v158 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v157);
            v159 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v158, 17, "%@: os_channel_attr_get(TX_LOWAT_VALUE) returned %d", v159, v152);

          }
          goto LABEL_25;
        }
        v160 = _NRLogIsLevelEnabled(v154, 1);

        if (v160)
        {
          v162 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v161);
          v163 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v162, 1, "%s%.30s:%-4d %@: Nexus Channel TX_LOWAT_VALUE = %llu", "", "-[NRLinkQuickRelay setupNexus]", 842, v163, v332[0]);

        }
        v332[0] = 0;
        v164 = os_channel_attr_get(v15, 11, v332);
        v166 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v165);
        v167 = (void *)v166;
        if ((_DWORD)v164)
        {
          v168 = _NRLogIsLevelEnabled(v166, 17);

          if (v168)
          {
            v170 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v169);
            v171 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v170, 17, "%@: os_channel_attr_get(RX_LOWAT_UNIT) returned %d", v171, v164);

          }
          goto LABEL_25;
        }
        v172 = _NRLogIsLevelEnabled(v166, 1);

        if (v172)
        {
          v174 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v173);
          v175 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v174, 1, "%s%.30s:%-4d %@: Nexus Channel RX_LOWAT_UNIT = %llu", "", "-[NRLinkQuickRelay setupNexus]", 843, v175, v332[0]);

        }
        v332[0] = 0;
        v176 = os_channel_attr_get(v15, 12, v332);
        v178 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v177);
        v179 = (void *)v178;
        if ((_DWORD)v176)
        {
          v180 = _NRLogIsLevelEnabled(v178, 17);

          if (v180)
          {
            v182 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v181);
            v183 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v182, 17, "%@: os_channel_attr_get(RX_LOWAT_VALUE) returned %d", v183, v176);

          }
          goto LABEL_25;
        }
        v184 = _NRLogIsLevelEnabled(v178, 1);

        if (v184)
        {
          v186 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v185);
          v187 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v186, 1, "%s%.30s:%-4d %@: Nexus Channel RX_LOWAT_VALUE = %llu", "", "-[NRLinkQuickRelay setupNexus]", 844, v187, v332[0]);

        }
        v332[0] = 0;
        v188 = os_channel_attr_get(v15, 13, v332);
        v190 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v189);
        v191 = (void *)v190;
        if ((_DWORD)v188)
        {
          v192 = _NRLogIsLevelEnabled(v190, 17);

          if (v192)
          {
            v194 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v193);
            v195 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v194, 17, "%@: os_channel_attr_get(NEXUS_TYPE) returned %d", v195, v188);

          }
          goto LABEL_25;
        }
        v196 = _NRLogIsLevelEnabled(v190, 1);

        if (v196)
        {
          v198 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v197);
          v199 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v198, 1, "%s%.30s:%-4d %@: Nexus Channel NEXUS_TYPE = %llu", "", "-[NRLinkQuickRelay setupNexus]", 845, v199, v332[0]);

        }
        v332[0] = 0;
        v200 = os_channel_attr_get(v15, 14, v332);
        v202 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v201);
        v203 = (void *)v202;
        if ((_DWORD)v200)
        {
          v204 = _NRLogIsLevelEnabled(v202, 17);

          if (v204)
          {
            v206 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v205);
            v207 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v206, 17, "%@: os_channel_attr_get(NEXUS_EXTENSIONS) returned %d", v207, v200);

          }
          goto LABEL_25;
        }
        v208 = _NRLogIsLevelEnabled(v202, 1);

        if (v208)
        {
          v210 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v209);
          v211 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v210, 1, "%s%.30s:%-4d %@: Nexus Channel NEXUS_EXTENSIONS = %llu", "", "-[NRLinkQuickRelay setupNexus]", 846, v211, v332[0]);

        }
        v332[0] = 0;
        v212 = os_channel_attr_get(v15, 15, v332);
        v214 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v213);
        v215 = (void *)v214;
        if ((_DWORD)v212)
        {
          v216 = _NRLogIsLevelEnabled(v214, 17);

          if (v216)
          {
            v218 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v217);
            v219 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v218, 17, "%@: os_channel_attr_get(NEXUS_MHINTS) returned %d", v219, v212);

          }
          goto LABEL_25;
        }
        v220 = _NRLogIsLevelEnabled(v214, 1);

        if (v220)
        {
          v222 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v221);
          v223 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v222, 1, "%s%.30s:%-4d %@: Nexus Channel NEXUS_MHINTS = %llu", "", "-[NRLinkQuickRelay setupNexus]", 847, v223, v332[0]);

        }
        v332[0] = 0;
        v224 = os_channel_attr_get(v15, 18, v332);
        v226 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v225);
        v227 = (void *)v226;
        if ((_DWORD)v224)
        {
          v228 = _NRLogIsLevelEnabled(v226, 17);

          if (v228)
          {
            v230 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v229);
            v231 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v230, 17, "%@: os_channel_attr_get(NEXUS_IFINDEX) returned %d", v231, v224);

          }
          goto LABEL_25;
        }
        v232 = _NRLogIsLevelEnabled(v226, 1);

        if (v232)
        {
          v234 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v233);
          v235 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v234, 1, "%s%.30s:%-4d %@: Nexus Channel NEXUS_IFINDEX = %llu", "", "-[NRLinkQuickRelay setupNexus]", 848, v235, v332[0]);

        }
        v332[0] = 0;
        v236 = os_channel_attr_get(v15, 19, v332);
        v238 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v237);
        v239 = (void *)v238;
        if ((_DWORD)v236)
        {
          v240 = _NRLogIsLevelEnabled(v238, 17);

          if (v240)
          {
            v242 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v241);
            v243 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v242, 17, "%@: os_channel_attr_get(NEXUS_STATS_SIZE) returned %d", v243, v236);

          }
          goto LABEL_25;
        }
        v244 = _NRLogIsLevelEnabled(v238, 1);

        if (v244)
        {
          v246 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v245);
          v247 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v246, 1, "%s%.30s:%-4d %@: Nexus Channel NEXUS_STATS_SIZE = %llu", "", "-[NRLinkQuickRelay setupNexus]", 849, v247, v332[0]);

        }
        v332[0] = 0;
        v248 = os_channel_attr_get(v15, 20, v332);
        v250 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v249);
        v251 = (void *)v250;
        if ((_DWORD)v248)
        {
          v252 = _NRLogIsLevelEnabled(v250, 17);

          if (v252)
          {
            v254 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v253);
            v255 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v254, 17, "%@: os_channel_attr_get(NEXUS_FLOWADV_MAX) returned %d", v255, v248);

          }
          goto LABEL_25;
        }
        v256 = _NRLogIsLevelEnabled(v250, 1);

        if (v256)
        {
          v258 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v257);
          v259 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v258, 1, "%s%.30s:%-4d %@: Nexus Channel NEXUS_FLOWADV_MAX = %llu", "", "-[NRLinkQuickRelay setupNexus]", 850, v259, v332[0]);

        }
        os_channel_attr_destroy(v15);
        v260 = os_channel_ring_id(*(_QWORD *)(a1 + 295), 2);
        v261 = os_channel_rx_ring(*(_QWORD *)(a1 + 295), v260);
        *(_QWORD *)(a1 + 303) = v261;
        if (!v261)
        {
          v283 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v262);
          v284 = _NRLogIsLevelEnabled(v283, 17);

          if (v284)
          {
            v286 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v285);
            v287 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v286, 17, "%@: _nexusInputRing is NULL", v287);

          }
          goto LABEL_25;
        }
        v263 = os_channel_ring_id(*(_QWORD *)(a1 + 295), 0);
        v264 = os_channel_tx_ring(*(_QWORD *)(a1 + 295), v263);
        *(_QWORD *)(a1 + 311) = v264;
        if (!v264)
        {
          v288 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v265);
          v289 = _NRLogIsLevelEnabled(v288, 17);

          if (v289)
          {
            v291 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v290);
            v292 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v291, 17, "%@: _nexusOutputRing is NULL", v292);

          }
          goto LABEL_25;
        }
        fd = os_channel_get_fd(*(_QWORD *)(a1 + 295));
        if ((fd & 0x80000000) != 0)
        {
          v293 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v266);
          v294 = _NRLogIsLevelEnabled(v293, 17);

          if (v294)
          {
            v296 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v295);
            v297 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v296, 17, "%@: os_channel_get_fd failed", v297);

          }
          goto LABEL_25;
        }
        v268 = dispatch_group_create();
        if (v268)
        {
          v269 = v268;
          v270 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, fd, 0, *(dispatch_queue_t *)(a1 + 8));
          v271 = *(void **)(a1 + 319);
          *(_QWORD *)(a1 + 319) = v270;

          if (*(_QWORD *)(a1 + 319))
          {
            objc_initWeak(v332, (id)a1);
            v272 = *(NSObject **)(a1 + 319);
            v330[0] = _NSConcreteStackBlock;
            v330[1] = 3221225472;
            v330[2] = sub_100040C80;
            v330[3] = &unk_1001B7F28;
            v322 = &v331;
            objc_copyWeak(&v331, v332);
            dispatch_source_set_event_handler(v272, v330);
            dispatch_group_enter(v269);
            v273 = *(NSObject **)(a1 + 319);
            v328[0] = _NSConcreteStackBlock;
            v328[1] = 3221225472;
            v328[2] = sub_1000411A4;
            v328[3] = &unk_1001B8AE0;
            v274 = v269;
            v329 = v274;
            dispatch_source_set_cancel_handler(v273, v328);
            dispatch_activate(*(dispatch_object_t *)(a1 + 319));
            v275 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_write, fd, 0, *(dispatch_queue_t *)(a1 + 8));
            v276 = *(void **)(a1 + 327);
            *(_QWORD *)(a1 + 327) = v275;

            v277 = *(NSObject **)(a1 + 327);
            if (v277)
            {
              v326[0] = _NSConcreteStackBlock;
              v326[1] = 3221225472;
              v326[2] = sub_1000411AC;
              v326[3] = &unk_1001B7F28;
              objc_copyWeak(&v327, v332);
              dispatch_source_set_event_handler(v277, v326);
              dispatch_group_enter(v274);
              v278 = *(NSObject **)(a1 + 327);
              v324[0] = _NSConcreteStackBlock;
              v324[1] = 3221225472;
              v324[2] = sub_1000417BC;
              v324[3] = &unk_1001B8AE0;
              v279 = v274;
              v325 = v279;
              dispatch_source_set_cancel_handler(v278, v324);
              *(_BYTE *)(a1 + 210) = 1;
              v280 = *(NSObject **)(a1 + 8);
              v323[0] = _NSConcreteStackBlock;
              v323[1] = 3221225472;
              v323[2] = sub_1000417C4;
              v323[3] = &unk_1001B85D0;
              v323[4] = v17;
              dispatch_group_notify(v279, v280, v323);
              v281 = *(void **)(a1 + 335);
              *(_QWORD *)(a1 + 335) = v279;
              v282 = v279;

              objc_destroyWeak(&v327);
              objc_destroyWeak(v322);
              objc_destroyWeak(v332);
LABEL_25:

              goto LABEL_26;
            }
            v314 = sub_10003BC58();
            v315 = _NRLogIsLevelEnabled(v314, 16);

            if ((v315 & 1) != 0)
            {
              v316 = sub_10003BC58();
              _NRLogWithArgs(v316, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (_dNexusWriteSource) != ((void *)0)", "", "-[NRLinkQuickRelay setupNexus]", 919);

            }
            v317 = _os_log_pack_size(12);
            v318 = (char *)&v323[-1] - ((__chkstk_darwin(v317) + 15) & 0xFFFFFFFFFFFFFFF0);
            v319 = __error();
            v320 = _os_log_pack_fill(v318, v317, *v319, &_mh_execute_header, "%{public}s Assertion Failed: (_dNexusWriteSource) != ((void *)0)", v322);
            *(_DWORD *)v320 = 136446210;
            *(_QWORD *)(v320 + 4) = "-[NRLinkQuickRelay setupNexus]";
            v321 = sub_10003BC58();
            _NRLogAbortWithPack(v321, v318);
          }
          else
          {
            v306 = sub_10003BC58();
            v307 = _NRLogIsLevelEnabled(v306, 16);

            if (v307)
            {
              v308 = sub_10003BC58();
              _NRLogWithArgs(v308, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (_dNexusReadSource) != ((void *)0)", "", "-[NRLinkQuickRelay setupNexus]", 884);

            }
            v309 = _os_log_pack_size(12);
            v310 = (char *)&v323[-1] - ((((uint64_t (*)(void))__chkstk_darwin)() + 15) & 0xFFFFFFFFFFFFFFF0);
            v311 = __error();
            v312 = _os_log_pack_fill(v310, v309, *v311, &_mh_execute_header, "%{public}s Assertion Failed: (_dNexusReadSource) != ((void *)0)");
            *(_DWORD *)v312 = 136446210;
            *(_QWORD *)(v312 + 4) = "-[NRLinkQuickRelay setupNexus]";
            v313 = sub_10003BC58();
            _NRLogAbortWithPack(v313, v310);
          }
        }
        else
        {
          v298 = sub_10003BC58();
          v299 = _NRLogIsLevelEnabled(v298, 16);

          if (v299)
          {
            v300 = sub_10003BC58();
            _NRLogWithArgs(v300, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (nexusGroup) != ((void *)0)", "", "-[NRLinkQuickRelay setupNexus]", 881);

          }
          v301 = _os_log_pack_size(12);
          v302 = (char *)&v323[-1] - ((((uint64_t (*)(void))__chkstk_darwin)() + 15) & 0xFFFFFFFFFFFFFFF0);
          v303 = __error();
          v304 = _os_log_pack_fill(v302, v301, *v303, &_mh_execute_header, "%{public}s Assertion Failed: (nexusGroup) != ((void *)0)");
          *(_DWORD *)v304 = 136446210;
          *(_QWORD *)(v304 + 4) = "-[NRLinkQuickRelay setupNexus]";
          v305 = sub_10003BC58();
          _NRLogAbortWithPack(v305, v302);
        }
        __break(1u);
        return;
      }
      v30 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v11);
      v31 = _NRLogIsLevelEnabled(v30, 17);

      if (v31)
      {
        v28 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v32);
        v29 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v28, 17, "%@: Expected to receive count: %@", v29, v3);
        goto LABEL_15;
      }
    }
    else
    {
      v26 = _NRLogIsLevelEnabled(v5, 17);

      if (v26)
      {
        v28 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v27);
        v29 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v28, 17, "%@: Failed to get nexus instances", v29);
LABEL_15:

      }
    }
LABEL_26:

  }
}

void sub_100040C58(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_destroyWeak(*(id **)v1);
  objc_destroyWeak((id *)(v1 + 208));
  _Unwind_Resume(a1);
}

void sub_100040C80(uint64_t a1)
{
  char *WeakRetained;
  uint64_t v2;
  char *v3;
  char *v4;
  NSObject *v5;
  uint64_t v6;
  int v7;
  void *v8;
  int v9;
  uint64_t v10;
  id v11;
  id v12;
  void *v13;
  int IsLevelEnabled;
  uint64_t v15;
  void *v16;
  void *v17;
  int v18;
  uint64_t v19;
  void *v20;
  int v21;
  uint64_t v22;
  void *v23;
  id v24;
  void *v25;
  int v26;
  uint64_t v27;
  const char *v28;
  id v29;
  void *v30;
  void *v31;
  id v32;
  void *v33;
  int v34;
  uint64_t v35;
  void *v36;
  id v37;
  void *v38;
  int v39;
  uint64_t v40;
  id v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _QWORD v45[4];
  id v46;
  id v47[2];
  id location;
  void *v49;

  WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 32));
  v3 = WeakRetained;
  if (WeakRetained)
  {
    if (WeakRetained[16] == 255)
    {
      v13 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 4), v2);
      IsLevelEnabled = _NRLogIsLevelEnabled(v13, 16);

      if (IsLevelEnabled)
      {
        v4 = (char *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v15);
        v11 = objc_msgSend(v3, "copyDescription");
        _NRLogWithArgs(v4, 16, "%s%.30s:%-4d %@: Nexus input available but cancelled", "", "-[NRLinkQuickRelay setupNexus]_block_invoke", 895, v11);
LABEL_26:

        goto LABEL_27;
      }
    }
    else
    {
      if (gNRPacketLoggingEnabled)
      {
        v33 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 4), v2);
        v34 = _NRLogIsLevelEnabled(v33, 1);

        if (v34)
        {
          v36 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v35);
          v37 = objc_msgSend(v3, "copyDescription");
          _NRLogWithArgs(v36, 1, "%s%.30s:%-4d %@: Nexus input available", "", "-[NRLinkQuickRelay setupNexus]_block_invoke", 899, v37);

        }
      }
      ++*(_QWORD *)(v3 + 447);
      if (*(_QWORD *)(v3 + 231))
      {
        v4 = v3;
        v5 = objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "queue"));
        dispatch_assert_queue_V2(v5);

        v7 = v3[16];
        if (v7 == 255)
        {
          v8 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v4 + 4), v6);
          v9 = _NRLogIsLevelEnabled(v8, 16);

          if (v9)
          {
            v11 = (id)_NRCopyLogObjectForNRUUID(*((_QWORD *)v4 + 4), v10);
            v12 = objc_msgSend(v4, "copyDescription");
            _NRLogWithArgs(v11, 16, "%s%.30s:%-4d %@: link is cancelled", "", "NRLinkLoopInterfaceToQR", 1894, v12);
LABEL_25:

            goto LABEL_26;
          }
LABEL_27:

          goto LABEL_28;
        }
        if (v7 == 1)
        {
          v38 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v4 + 4), v6);
          v39 = _NRLogIsLevelEnabled(v38, 17);

          if (!v39)
            goto LABEL_27;
          v11 = (id)_NRCopyLogObjectForNRUUID(*((_QWORD *)v4 + 4), v40);
          v12 = objc_msgSend(v4, "copyDescription");
          v41 = v12;
          v28 = "%@: Link not ready to accept packets";
        }
        else
        {
          if (*(_QWORD *)(v4 + 295))
          {
            v16 = *(void **)(v4 + 647);
            if (v16 && objc_msgSend(v16, "connectionState") == (id)3)
            {
              if (!v4[209])
              {
                v49 = 0;
                v29 = sub_100041824(v4, &v49);
                v30 = (void *)objc_claimAutoreleasedReturnValue(v29);
                objc_initWeak(&location, v4);
                *(_QWORD *)(v4 + 383) += v49;
                v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "connection"));
                v45[0] = _NSConcreteStackBlock;
                v45[1] = 3221225472;
                v45[2] = sub_100041E18;
                v45[3] = &unk_1001B66C8;
                objc_copyWeak(v47, &location);
                v32 = v30;
                v46 = v32;
                v47[1] = v49;
                objc_msgSend(v31, "writeDatagrams:completionHandler:", v32, v45);

                dispatch_suspend(*(dispatch_object_t *)(v4 + 319));
                v4[209] = 1;

                objc_destroyWeak(v47);
                objc_destroyWeak(&location);

                goto LABEL_27;
              }
              if (!gNRPacketLoggingEnabled)
                goto LABEL_27;
              v17 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v4 + 4), v6);
              v18 = _NRLogIsLevelEnabled(v17, 1);

              if (!v18)
                goto LABEL_27;
              v11 = (id)_NRCopyLogObjectForNRUUID(*((_QWORD *)v4 + 4), v19);
              v12 = objc_msgSend(v4, "copyDescription");
              _NRLogWithArgs(v11, 1, "%s%.30s:%-4d %@: Skipping writing to QR because source suspended", "", "NRLinkLoopInterfaceToQR", 1915, v12);
            }
            else
            {
              if (!gNRPacketLoggingEnabled)
                goto LABEL_27;
              v20 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v4 + 4), v6);
              v21 = _NRLogIsLevelEnabled(v20, 1);

              if (!v21)
                goto LABEL_27;
              v11 = (id)_NRCopyLogObjectForNRUUID(*((_QWORD *)v4 + 4), v22);
              v12 = objc_msgSend(v4, "copyDescription");
              v23 = *(void **)(v4 + 647);
              v24 = sub_1000417CC((unint64_t)objc_msgSend(v23, "connectionState"));
              _NRLogWithArgs(v11, 1, "%s%.30s:%-4d %@: Skipping writing to QR because connection %@ state %@", "", "NRLinkLoopInterfaceToQR", 1910, v12, v23, v24);

            }
            goto LABEL_25;
          }
          v25 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v4 + 4), v6);
          v26 = _NRLogIsLevelEnabled(v25, 17);

          if (!v26)
            goto LABEL_27;
          v11 = (id)_NRCopyLogObjectForNRUUID(*((_QWORD *)v4 + 4), v27);
          v12 = objc_msgSend(v4, "copyDescription");
          v41 = v12;
          v28 = "%@: No nexus channel";
        }
        _NRLogWithArgs(v11, 17, v28, v41, v42, v43, v44);
        goto LABEL_25;
      }
      v3[211] = 1;
      dispatch_suspend(*(dispatch_object_t *)(v3 + 319));
      v3[209] = 1;
    }
  }
LABEL_28:

}

void sub_100041180(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 64));
  _Unwind_Resume(a1);
}

void sub_1000411A4(uint64_t a1)
{
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_1000411AC(uint64_t a1)
{
  _QWORD *WeakRetained;
  uint64_t v2;
  _QWORD *v3;
  char *v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  id v9;
  uint64_t i;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  void *v15;
  id v16;
  char *v17;
  uint64_t next_slot;
  int v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  void *v26;
  void *v27;
  int v28;
  uint64_t v29;
  id v30;
  void *v31;
  int v32;
  uint64_t v33;
  void *v34;
  id v35;
  uint64_t v36;
  void *v37;
  int IsLevelEnabled;
  uint64_t v39;
  void *v40;
  id v41;
  void *v42;
  int v43;
  uint64_t v44;
  void *v45;
  id v46;
  void *v47;
  int v48;
  uint64_t v49;
  void *v50;
  id v51;
  int v52;
  id v53;
  id v54;
  id v55;
  uint64_t v56;
  id v57;
  uint64_t v58;
  int v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  void *__dst[2];
  __int128 v66;
  __int128 v67;
  _BYTE v68[128];

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v3 = WeakRetained;
  if (WeakRetained)
  {
    if (*((unsigned __int8 *)WeakRetained + 16) != 255)
    {
      if (gNRPacketLoggingEnabled)
      {
        v37 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v2);
        IsLevelEnabled = _NRLogIsLevelEnabled(v37, 1);

        if (IsLevelEnabled)
        {
          v40 = (void *)_NRCopyLogObjectForNRUUID(v3[4], v39);
          v41 = objc_msgSend(v3, "copyDescription");
          _NRLogWithArgs(v40, 1, "%s%.30s:%-4d %@: Nexus output available", "", "-[NRLinkQuickRelay setupNexus]_block_invoke", 931, v41);

        }
      }
      ++*(_QWORD *)((char *)v3 + 455);
      v4 = v3;
      v5 = objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "queue"));
      dispatch_assert_queue_V2(v5);

      if (*((unsigned __int8 *)v3 + 16) == 255)
      {
        v31 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v4 + 4), v6);
        v32 = _NRLogIsLevelEnabled(v31, 16);

        if (v32)
        {
          v34 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v4 + 4), v33);
          v35 = objc_msgSend(v4, "copyDescription");
          _NRLogWithArgs(v34, 16, "%s%.30s:%-4d %@: link is cancelled", "", "NRLinkLoopQRToInterface", 1965, v35);

        }
      }
      else if (objc_msgSend(*(id *)(v4 + 343), "count"))
      {
        v7 = os_channel_ring_id(*(_QWORD *)(v4 + 295), 0);
        v8 = os_channel_tx_ring(*(_QWORD *)(v4 + 295), v7);
        v66 = 0u;
        v67 = 0u;
        v64 = 0u;
        *(_OWORD *)__dst = 0u;
        v60 = 0u;
        v61 = 0u;
        v62 = 0u;
        v63 = 0u;
        v9 = *(id *)(v4 + 343);
        v57 = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v60, v68, 16);
        i = 0;
        v11 = 0;
        v12 = 0;
        if (v57)
        {
          v55 = v9;
          v56 = *(_QWORD *)v61;
          while (2)
          {
            v13 = 0;
            v14 = v12;
            v12 += (int)v57;
            do
            {
              if (*(_QWORD *)v61 != v56)
                objc_enumerationMutation(v9);
              v58 = v13;
              v15 = *(void **)(*((_QWORD *)&v60 + 1) + 8 * v13);
              v16 = objc_msgSend(v15, "length");
              v17 = (char *)objc_msgSend(v15, "bytes");
              next_slot = os_channel_get_next_slot(v8, i, &v64);
              if (!next_slot)
              {
                v12 = v14;
                goto LABEL_35;
              }
              v59 = v14;
              v19 = (int)v16;
              if ((int)v16 >= 1)
              {
                v54 = v16;
                for (i = next_slot; ; i = v23)
                {
                  if (v19 >= WORD1(v64))
                    v20 = WORD1(v64);
                  else
                    v20 = v19;
                  WORD1(v64) = v20;
                  memcpy(__dst[0], v17, (unsigned __int16)v20);
                  os_channel_set_slot_properties(v8, i, &v64);
                  v19 -= v20;
                  if (v19 < 1)
                  {
                    v11 = v20 + v11;
                    v16 = v54;
                    v9 = v55;
                    goto LABEL_24;
                  }
                  v21 = os_channel_get_next_slot(v8, i, &v64);
                  if (!v21)
                    break;
                  v23 = v21;
                  if (gNRPacketLoggingEnabled)
                  {
                    v24 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v4 + 4), v22);
                    v52 = _NRLogIsLevelEnabled(v24, 1);

                    if (v52)
                    {
                      v26 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v4 + 4), v25);
                      v53 = objc_msgSend(v4, "copyDescription");
                      _NRLogWithArgs(v26, 1, "%s%.30s:%-4d %@: Writing partial packet", "", "NRLinkLoopQRToInterface", 2005, v53);

                    }
                  }
                  v17 += v20;
                  v11 = v20 + v11;
                }
                if (gNRPacketLoggingEnabled)
                {
                  v47 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v4 + 4), v22);
                  v48 = _NRLogIsLevelEnabled(v47, 1);

                  if (v48)
                  {
                    v50 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v4 + 4), v49);
                    v51 = objc_msgSend(v4, "copyDescription");
                    _NRLogWithArgs(v50, 1, "%s%.30s:%-4d %@: No slot midway", "", "NRLinkLoopQRToInterface", 2002, v51);

                  }
                }
                v12 = v59;
                v9 = v55;
                goto LABEL_35;
              }
LABEL_24:
              if (v19)
              {
                v12 = v59;
                goto LABEL_35;
              }
              *(_QWORD *)(v4 + 439) += v16;
              v14 = v59 + 1;
              v13 = v58 + 1;
            }
            while ((id)(v58 + 1) != v57);
            v57 = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v60, v68, 16);
            if (v57)
              continue;
            break;
          }
        }
LABEL_35:

        if (gNRPacketLoggingEnabled)
        {
          v42 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v4 + 4), v36);
          v43 = _NRLogIsLevelEnabled(v42, 1);

          if (v43)
          {
            v45 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v4 + 4), v44);
            v46 = objc_msgSend(v4, "copyDescription");
            _NRLogWithArgs(v45, 1, "%s%.30s:%-4d %@: Read from QR: %d bytes", "", "NRLinkLoopQRToInterface", 2020, v46, v11);

          }
        }
        if (i)
        {
          os_channel_advance_slot(v8, i);
          os_channel_sync(*(_QWORD *)(v4 + 295), 0);
          if (v12 >= 1)
          {
            do
            {
              objc_msgSend(*(id *)(v4 + 343), "removeFirstObject");
              --v12;
            }
            while (v12);
          }
        }
      }
      else
      {
        dispatch_suspend(*(dispatch_object_t *)(v4 + 327));
        v4[210] = 1;
      }
      goto LABEL_39;
    }
    v27 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v2);
    v28 = _NRLogIsLevelEnabled(v27, 16);

    if (v28)
    {
      v4 = (char *)_NRCopyLogObjectForNRUUID(v3[4], v29);
      v30 = objc_msgSend(v3, "copyDescription");
      _NRLogWithArgs(v4, 16, "%s%.30s:%-4d %@: Nexus output available but cancelled", "", "-[NRLinkQuickRelay setupNexus]_block_invoke", 928, v30);

LABEL_39:
    }
  }

}

void sub_1000417BC(uint64_t a1)
{
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

uint64_t sub_1000417C4(uint64_t a1)
{
  return os_channel_destroy(*(_QWORD *)(a1 + 32));
}

id sub_1000417CC(unint64_t a1)
{
  if (a1 >= 6)
    return objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("Unknown[%lld]"), a1);
  else
    return *(&off_1001B66E8 + a1);
}

id sub_100041824(void *a1, _QWORD *a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  id v9;
  uint64_t next_slot;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  id v17;
  _BYTE *v18;
  _BYTE *v19;
  int v20;
  unsigned __int16 v21;
  _BYTE *v22;
  uint64_t v23;
  int *v24;
  unsigned int v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  void *v29;
  id v30;
  uint64_t v31;
  void *StringFromNRTLVType;
  void *v33;
  int IsLevelEnabled;
  uint64_t v35;
  void *v36;
  id v37;
  id v38;
  void *v39;
  int v40;
  uint64_t v41;
  void *v42;
  int v43;
  uint64_t v44;
  void *v45;
  id v46;
  id v48;
  int v49;
  id v50;
  uint64_t v51;
  char *v52;
  int *v53;
  uint64_t v54;
  id v55;
  uint64_t v56;
  uint64_t v57;
  _QWORD *v58;
  uint64_t v59;
  _BYTE *v60;
  int v61;
  int v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  _BYTE v67[2048];

  v3 = a1;
  v5 = v3;
  if (*((unsigned __int8 *)v3 + 16) == 255)
  {
    v33 = (void *)_NRCopyLogObjectForNRUUID(v3[4], v4);
    IsLevelEnabled = _NRLogIsLevelEnabled(v33, 16);

    if (IsLevelEnabled)
    {
      v36 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v35);
      v37 = objc_msgSend(v5, "copyDescription");
      _NRLogWithArgs(v36, 16, "%s%.30s:%-4d %@: link is cancelled", "", "NRLinkLoopInterfaceToQRInner", 1799, v37);
LABEL_33:

    }
LABEL_34:
    v38 = 0;
    goto LABEL_39;
  }
  v6 = *(_QWORD *)((char *)v3 + 295);
  if (!v6)
  {
    v39 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v4);
    v40 = _NRLogIsLevelEnabled(v39, 17);

    if (v40)
    {
      v36 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v41);
      v37 = objc_msgSend(v5, "copyDescription");
      _NRLogWithArgs(v36, 17, "%@: No nexus channel", v37);
      goto LABEL_33;
    }
    goto LABEL_34;
  }
  v7 = os_channel_ring_id(v6, 2);
  v8 = os_channel_rx_ring(*(_QWORD *)((char *)v5 + 295), v7);
  v9 = objc_alloc_init((Class)NSMutableArray);
  v65 = 0u;
  v66 = 0u;
  v63 = 0u;
  v64 = 0u;
  v59 = v8;
  next_slot = os_channel_get_next_slot(v8, 0, &v63);
  if (next_slot)
  {
    v12 = next_slot;
    v58 = a2;
    while (2)
    {
      v13 = v9;
      v14 = v12;
      v15 = v64;
      v16 = WORD1(v63);
      *(_QWORD *)((char *)v5 + 431) += WORD1(v63);
      v17 = objc_alloc_init((Class)NSMutableData);
      LODWORD(v12) = 2048;
      v18 = v67;
      bzero(v67, 0x800uLL);
      if (v16 >= 0x7FC)
      {
        v12 = v16 + 5;
        v19 = malloc_type_calloc(1uLL, v16 + 5, 0xF1748037uLL);
        if (!v19)
        {
          v48 = sub_10003BC58();
          v49 = _NRLogIsLevelEnabled(v48, 16);

          if (v49)
          {
            v50 = sub_10003BC58();
            _NRLogWithArgs(v50, 16, "%s%.30s:%-4d ABORTING: strict_calloc(%zu, %zu) failed", "", "strict_calloc", 108, 1uLL, v16 + 5);

          }
          v51 = _os_log_pack_size(32);
          v52 = (char *)&v56 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
          v53 = __error();
          v54 = _os_log_pack_fill(v52, v51, *v53, &_mh_execute_header, "%{public}s strict_calloc(%zu, %zu) failed");
          *(_DWORD *)v54 = 136446722;
          *(_QWORD *)(v54 + 4) = "strict_calloc";
          *(_WORD *)(v54 + 12) = 2048;
          *(_QWORD *)(v54 + 14) = 1;
          *(_WORD *)(v54 + 22) = 2048;
          *(_QWORD *)(v54 + 24) = v12;
          v55 = sub_10003BC58();
          _NRLogAbortWithPack(v55, v52);
        }
        v18 = v19;
      }
      v60 = v18;
      v62 = 0;
      v61 = v12;
      v20 = nrPacketToTLV(v15, v16, &v60, 1, (char *)v5 + 655, (char *)v5 + 671);
      v21 = v20;
      v61 = v20;
      v22 = v60;
      v23 = *v60;
      switch(*v60)
      {
        case 'd':
          v24 = &OBJC_IVAR___NRLinkQuickRelay__sentKnownIPv6Hdr_ESP;
          goto LABEL_20;
        case 'e':
          v24 = &OBJC_IVAR___NRLinkQuickRelay__sentKnownIPv6Hdr_ESP_ECT0;
          goto LABEL_20;
        case 'f':
          v24 = &OBJC_IVAR___NRLinkQuickRelay__sentKnownIPv6Hdr_TCP;
          goto LABEL_20;
        case 'g':
          v24 = &OBJC_IVAR___NRLinkQuickRelay__sentKnownIPv6Hdr_TCP_ECT0;
          goto LABEL_20;
        case 'h':
          v24 = &OBJC_IVAR___NRLinkQuickRelay__sentKnownIPv6Hdr_ESP_ClassC;
          goto LABEL_20;
        case 'i':
          v24 = &OBJC_IVAR___NRLinkQuickRelay__sentKnownIPv6Hdr_ESP_ClassC_ECT0;
          goto LABEL_20;
        default:
          if ((_DWORD)v23 == 2)
          {
            v24 = &OBJC_IVAR___NRLinkQuickRelay__sentUncompressedIP;
          }
          else
          {
            if ((_DWORD)v23 != 3)
              goto LABEL_21;
            v24 = &OBJC_IVAR___NRLinkQuickRelay__sentEncapsulated6LoWPAN;
          }
LABEL_20:
          ++*(_QWORD *)((char *)v5 + *v24);
LABEL_21:
          v25 = *(unsigned __int16 *)(v22 + 1);
          objc_msgSend(v17, "appendBytes:length:");
          if (v18 != v67)
            free(v18);
          if (gNRPacketLoggingEnabled)
          {
            v27 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v26);
            LODWORD(v57) = _NRLogIsLevelEnabled(v27, 1);

            if ((_DWORD)v57)
            {
              v57 = bswap32(v25) >> 16;
              v29 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v28);
              v30 = objc_msgSend(v5, "copyDescription");
              StringFromNRTLVType = (void *)createStringFromNRTLVType(v23, v31);
              _NRLogWithArgs(v29, 1, "%s%.30s:%-4d %@: Sending packet [%@(%u/%u), %llu]", "", "NRLinkLoopInterfaceToQRInner", 1870, v30, StringFromNRTLVType, v57, v16, objc_msgSend(v17, "length"));

            }
          }
          v9 = v13;
          objc_msgSend(v13, "addObject:", v17);
          v12 = os_channel_get_next_slot(v59, v14, &v63);
          if (v58)
            *v58 += v21;

          if (v12)
            continue;
          os_channel_advance_slot(v59, v14);
          os_channel_sync(*(_QWORD *)((char *)v5 + 295), 1);
          v38 = v13;
          break;
      }
      break;
    }
  }
  else
  {
    v42 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v11);
    v43 = _NRLogIsLevelEnabled(v42, 16);

    if (v43)
    {
      v45 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v44);
      v46 = objc_msgSend(v5, "copyDescription");
      _NRLogWithArgs(v45, 16, "%s%.30s:%-4d %@: Could not read any slot, when input available", "", "NRLinkLoopInterfaceToQRInner", 1881, v46);

    }
    v38 = 0;
  }

LABEL_39:
  return v38;
}

void sub_100041E18(uint64_t a1, void *a2)
{
  id v3;
  _QWORD *WeakRetained;
  uint64_t v5;
  _QWORD *v6;
  void *v7;
  int IsLevelEnabled;
  uint64_t v9;
  void *v10;
  id v11;
  void *v12;
  void *v13;
  id v14;
  id v15;
  NSObject *v16;
  _QWORD *v17;
  uint64_t v18;
  void *v19;
  int v20;
  uint64_t v21;
  void *v22;
  id v23;
  _QWORD block[4];
  id v25;

  v3 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v6 = WeakRetained;
  if (WeakRetained)
  {
    if (v3)
    {
      v7 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v5);
      IsLevelEnabled = _NRLogIsLevelEnabled(v7, 16);

      if (IsLevelEnabled)
      {
        v10 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v9);
        v11 = objc_msgSend(v6, "copyDescription");
        _NRLogWithArgs(v10, 16, "%s%.30s:%-4d %@: Failed to write datagram array of length %llu", "", "NRLinkLoopInterfaceToQR_block_invoke", 1934, v11, objc_msgSend(*(id *)(a1 + 32), "count"));

      }
      *(_QWORD *)((char *)v6 + 399) += *(_QWORD *)(a1 + 48);
      v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "connection"));
      v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "connection"));
      v14 = objc_msgSend(v13, "connectionState");
      if ((unint64_t)v14 >= 6)
        v15 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("Unknown[%lld]"), v14);
      else
        v15 = *(&off_1001B66E8 + (_QWORD)v14);
      objc_msgSend(v6, "reportEvent:detailsFormat:", 10022, CFSTR("connection %@ state %@ error %@"), v12, v15, v3);

    }
    else
    {
      *(_QWORD *)((char *)WeakRetained + 391) += *(_QWORD *)(a1 + 48);
    }
    v16 = objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "queue"));
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10004209C;
    block[3] = &unk_1001B8AE0;
    v17 = v6;
    v25 = v17;
    dispatch_async(v16, block);

    if (gNRPacketLoggingEnabled)
    {
      v19 = (void *)_NRCopyLogObjectForNRUUID(v17[4], v18);
      v20 = _NRLogIsLevelEnabled(v19, 1);

      if (v20)
      {
        v22 = (void *)_NRCopyLogObjectForNRUUID(v17[4], v21);
        v23 = objc_msgSend(v17, "copyDescription");
        _NRLogWithArgs(v22, 1, "%s%.30s:%-4d %@: Wrote to QR: %llu bytes, %llu datagrams", "", "NRLinkLoopInterfaceToQR_block_invoke", 1954, v23, *(_QWORD *)(a1 + 48), objc_msgSend(*(id *)(a1 + 32), "count"));

      }
    }

  }
}

void sub_10004209C(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(v1 + 209))
  {
    *(_BYTE *)(v1 + 209) = 0;
    dispatch_resume(*(dispatch_object_t *)(*(_QWORD *)(a1 + 32) + 319));
  }
}

void sub_1000420CC(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id WeakRetained;
  void *v8;
  NSObject *v9;
  _QWORD block[4];
  id v11;
  id v12;
  id v13;

  v5 = a2;
  v6 = a3;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v8 = WeakRetained;
  if (WeakRetained)
  {
    v9 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "queue"));
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000421A4;
    block[3] = &unk_1001B87A0;
    v11 = v6;
    v12 = v8;
    v13 = v5;
    dispatch_async(v9, block);

  }
}

void sub_1000421A4(uint64_t a1)
{
  unint64_t v1;
  void *v3;
  id v4;
  void *v5;
  unsigned int v6;
  uint64_t v7;
  void *v8;
  int v9;
  uint64_t v10;
  id v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  void *v16;
  void *v17;
  int IsLevelEnabled;
  uint64_t v19;
  void *v20;
  id v21;
  id v22;
  uint64_t v23;
  unsigned __int8 *v24;
  unsigned __int8 *v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  __int16 v34;
  unsigned int v35;
  __int16 v36;
  int *v37;
  void *v38;
  int v39;
  void *v40;
  id v41;
  id v42;
  id v43;
  uint64_t v44;
  void *IKEv2PacketString;
  void *v46;
  void *v47;
  id v48;
  id v49;
  unsigned __int16 v50;
  size_t v51;
  _WORD *v52;
  uint64_t v53;
  unsigned int v54;
  id v55;
  void *v56;
  int v57;
  id v58;
  uint64_t v59;
  void *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  void *v64;
  void *v65;
  int v66;
  uint64_t v67;
  void *v68;
  id v69;
  void *v70;
  int v71;
  void *v72;
  id v73;
  uint64_t v74;
  void *StringFromNRTLVType;
  void *v76;
  int v77;
  uint64_t v78;
  void *v79;
  id v80;
  void *v81;
  int v82;
  uint64_t v83;
  void *v84;
  int v85;
  uint64_t v86;
  id v87;
  int v88;
  id v89;
  void *v90;
  int v91;
  uint64_t v92;
  uint64_t v93;
  void *v94;
  void *v95;
  void *v96;
  void *v97;
  void *v98;
  id v99;
  id v100;
  uint64_t v101;
  void *v102;
  int v103;
  uint64_t v104;
  id v105;
  void *v106;
  void *v107;
  id v108;
  id v109;
  const char *v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  id v114;
  int v115;
  id v116;
  uint64_t v117;
  uint64_t v118;
  id v119;
  int v120;
  id v121;
  uint64_t v122;
  int *v123;
  uint64_t v124;
  id v125;
  id v126;
  int v127;
  id v128;
  uint64_t v129;
  char *v130;
  int *v131;
  uint64_t v132;
  id v133;
  id v134;
  int v135;
  id v136;
  void *v137;
  uint64_t v138;
  int *v139;
  uint64_t v140;
  uint64_t v141;
  _BOOL8 v142;
  id v143;
  int v144;
  id v145;
  void *v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  id v152;
  void *v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  id v157;
  id v158;
  unsigned __int8 *v159;
  uint64_t v160;
  id v161;
  id v162;
  uint64_t v163;
  unsigned __int8 *v164;
  unsigned __int8 *v165;
  unsigned __int8 *v166;
  uint64_t v167;
  __int128 v168;
  __int128 v169;
  __int128 v170;
  __int128 v171;
  _WORD v172[1024];
  _BYTE v173[128];

  v3 = *(void **)(a1 + 32);
  if (!v3)
  {
    v170 = 0u;
    v171 = 0u;
    v168 = 0u;
    v169 = 0u;
    v161 = *(id *)(a1 + 48);
    v162 = objc_msgSend(v161, "countByEnumeratingWithState:objects:count:", &v168, v173, 16);
    if (!v162)
      goto LABEL_88;
    v12 = 0;
    v13 = *(_QWORD *)v169;
    v160 = *(_QWORD *)v169;
    while (1)
    {
      if (v13 != v160)
        objc_enumerationMutation(v161);
      v163 = v12;
      v14 = *(void **)(*((_QWORD *)&v168 + 1) + 8 * v12);
      if ((unint64_t)objc_msgSend(v14, "length") <= 2)
      {
        v16 = v14;
        v17 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 32), v15);
        IsLevelEnabled = _NRLogIsLevelEnabled(v17, 17);

        if (!IsLevelEnabled)
          goto LABEL_86;
        v20 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 32), v19);
        v21 = objc_msgSend(*(id *)(a1 + 40), "copyDescription");
        _NRLogWithArgs(v20, 17, "%@: Invalid packet length received: %llu", v21, objc_msgSend(v16, "length"));
        goto LABEL_15;
      }
      v22 = objc_msgSend(v14, "length");
      v157 = v14;
      v158 = v22;
      v159 = (unsigned __int8 *)objc_msgSend(v14, "bytes");
      *(_QWORD *)(*(_QWORD *)(a1 + 40) + 407) += v22;
      if (!(_DWORD)v22)
        goto LABEL_86;
      v24 = v159;
      v25 = &v159[v22];
      v165 = v25;
      while (1)
      {
        if (v24 + 3 > v25)
        {
          v81 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 32), v23);
          v82 = _NRLogIsLevelEnabled(v81, 17);

          if (!v82)
            goto LABEL_86;
          v20 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 32), v83);
          v21 = objc_msgSend(*(id *)(a1 + 40), "copyDescription");
          _NRLogWithArgs(v20, 17, "%@: Received incomplete/malformed datagram: [%p + %zu > %p + %u]", v21, v24, 3, v159, v158);
LABEL_15:

          goto LABEL_16;
        }
        v166 = v24;
        v167 = 0;
        v26 = *v24;
        v27 = *(unsigned __int16 *)(v24 + 1);
        v28 = __rev16(v27);
        v29 = (v28 + 5);
        v167 = v29;
        if (&v24[v29] > v25)
        {
          v84 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 32), v23);
          v85 = _NRLogIsLevelEnabled(v84, 17);

          if (v85)
          {
            v20 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 32), v86);
            v1 = (unint64_t)objc_msgSend(*(id *)(a1 + 40), "copyDescription");
            _NRLogWithArgs(v20, 17, "%@: Received incomplete/malformed datagram: [%p + %lu + %u + %lu > %p + %u]", v1, v24, 3, v28, 2, v159, v158);
            goto LABEL_85;
          }
          goto LABEL_86;
        }
        if ((char)v26 >= 100)
        {
          v172[0] = 0;
          v1 = (v28 + 3);
          v30 = v167 - v1;
          if (v167 <= v1)
            goto LABEL_119;
          if (v30 >= 2)
            v31 = 2;
          else
            v31 = v30;
          __memcpy_chk(v172, &v166[v1], v31, 2);
          if (v30 <= 1)
            goto LABEL_120;
          if (v172[0] != (unsigned __int16)((v27 ^ (v26 >> 4)) | (unsigned __int16)(((unsigned __int16)(16 * v26) ^ (unsigned __int16)(v27 >> 8)) << 8)))
            goto LABEL_83;
          goto LABEL_40;
        }
        v32 = v167;
        if (v167 >= (int)v28 + 3)
          v33 = (v28 + 3);
        else
          v33 = v167;
        if (!(_DWORD)v33)
        {
          if (qword_1001E45F0 != -1)
            dispatch_once(&qword_1001E45F0, &stru_1001B66A0);
          v110 = "nrChecksumUpdate";
          if (_NRLogIsLevelEnabled(qword_1001E45E8, 16))
          {
            if (qword_1001E45F0 != -1)
              dispatch_once(&qword_1001E45F0, &stru_1001B66A0);
            _NRLogWithArgs(qword_1001E45E8, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: dataLen > 0", "", "nrChecksumUpdate", 69);
          }
          v111 = _os_log_pack_size(12);
          v51 = (size_t)&v156 - ((__chkstk_darwin(v111) + 15) & 0xFFFFFFFFFFFFFFF0);
          v112 = *__error();
          v113 = _os_log_pack_fill(v51, v111, v112, &_mh_execute_header, "%{public}s Assertion Failed: dataLen > 0");
LABEL_110:
          *(_DWORD *)v113 = 136446210;
          *(_QWORD *)(v113 + 4) = v110;
          goto LABEL_114;
        }
        v164 = (unsigned __int8 *)(v28 + 3);
        v34 = os_inet_checksum(v166, v33, 0);
        v1 = v28 + 3;
        if ((int)v28 + 3 > v32)
        {
          v114 = sub_10003BC58();
          v115 = _NRLogIsLevelEnabled(v114, 16);

          v110 = "nrChecksumIOVecInner";
          if (v115)
          {
            v116 = sub_10003BC58();
            _NRLogWithArgs(v116, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: computedBytes == writtenLength", "", "nrChecksumIOVecInner", 164);

          }
          v117 = _os_log_pack_size(12);
          v51 = (size_t)&v156 - ((__chkstk_darwin(v117) + 15) & 0xFFFFFFFFFFFFFFF0);
          v118 = *__error();
          v113 = _os_log_pack_fill(v51, v117, v118, &_mh_execute_header, "%{public}s Assertion Failed: computedBytes == writtenLength");
          goto LABEL_110;
        }
        v35 = v167;
        if (v167 < v29)
        {
          v142 = v33 >= v167;
          v143 = sub_10003BC58();
          v144 = _NRLogIsLevelEnabled(v143, 16);

          if (v35 < (int)v28 + 4)
          {
            if (v144)
            {
              v152 = sub_10003BC58();
              v153 = (void *)createIOVecString(&v166, 1);
              _NRLogWithArgs(v152, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: iovecs[iovecIndex].len >= bytesToCheckThisIOVec + 1; %@, iovecI"
                "ndex=%u bytesToCheckThisIOVec=%u",
                "",
                "nrChecksumIOVecInner",
                189,
                v153,
                v142,
                v164);

            }
            v154 = _os_log_pack_size(34);
            v130 = (char *)&v156 - ((__chkstk_darwin(v154) + 15) & 0xFFFFFFFFFFFFFFF0);
            v155 = *__error();
            v149 = _os_log_pack_fill(v130, v154, v155, &_mh_execute_header, "%{public}s Assertion Failed: iovecs[iovecIndex].len >= bytesToCheckThisIOVec + 1; %@, iovecIndex=%u"
                     " bytesToCheckThisIOVec=%u");
          }
          else
          {
            if (v144)
            {
              v145 = sub_10003BC58();
              v146 = (void *)createIOVecString(&v166, 1);
              _NRLogWithArgs(v145, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: iovecIndex + 1 < numIOVecs; %@, iovecIndex=%u bytesToCheckThisIOVec=%u",
                "",
                "nrChecksumIOVecInner",
                191,
                v146,
                v142,
                v164);

            }
            v147 = _os_log_pack_size(34);
            v130 = (char *)&v156 - ((__chkstk_darwin(v147) + 15) & 0xFFFFFFFFFFFFFFF0);
            v148 = *__error();
            v149 = _os_log_pack_fill(v130, v147, v148, &_mh_execute_header, "%{public}s Assertion Failed: iovecIndex + 1 < numIOVecs; %@, iovecIndex=%u bytesToCheckThisIOVec=%u");
          }
          v150 = v149;
          v151 = createIOVecString(&v166, 1);
          sub_1000435D0(v150, (uint64_t)"nrChecksumIOVecInner", v151, v142, (int)v164);
          goto LABEL_118;
        }
        v36 = ~v34;
        if (v164[(_QWORD)v166] != ~(_BYTE)v34
          || v164[(_QWORD)v166 + 1] != (unsigned __int16)(v36 & 0xFF00) >> 8)
        {
          break;
        }
LABEL_40:
        switch((int)v26)
        {
          case 'd':
            v37 = &OBJC_IVAR___NRLinkQuickRelay__recvKnownIPv6Hdr_ESP;
            break;
          case 'e':
            v37 = &OBJC_IVAR___NRLinkQuickRelay__recvKnownIPv6Hdr_ESP_ECT0;
            break;
          case 'f':
            v37 = &OBJC_IVAR___NRLinkQuickRelay__recvKnownIPv6Hdr_TCP;
            break;
          case 'g':
            v37 = &OBJC_IVAR___NRLinkQuickRelay__recvKnownIPv6Hdr_TCP_ECT0;
            break;
          case 'h':
            v37 = &OBJC_IVAR___NRLinkQuickRelay__recvKnownIPv6Hdr_ESP_ClassC;
            break;
          case 'i':
            v37 = &OBJC_IVAR___NRLinkQuickRelay__recvKnownIPv6Hdr_ESP_ClassC_ECT0;
            break;
          default:
            v37 = &OBJC_IVAR___NRLinkQuickRelay__recvUncompressedIP;
            switch((int)v26)
            {
              case 1:
                v38 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 32), v23);
                v39 = _NRLogIsLevelEnabled(v38, 1);

                if (v39)
                {
                  v40 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 32), v23);
                  v41 = objc_msgSend(*(id *)(a1 + 40), "copyDescription");
                  _NRLogWithArgs(v40, 1, "%s%.30s:%-4d %@: Handling PadN %u", "", "-[NRLinkQuickRelay readDatagramFromSession]_block_invoke_2", 1705, v41, v28);

                }
                goto LABEL_21;
              case 2:
                goto LABEL_53;
              case 3:
                v37 = &OBJC_IVAR___NRLinkQuickRelay__recvEncapsulated6LoWPAN;
                goto LABEL_53;
              case 4:
                v42 = objc_alloc((Class)NSData);
                v43 = objc_msgSend(v42, "initWithBytes:length:", v166 + 3, v28);
                v1 = *(_QWORD *)(a1 + 40);
                v44 = *(_QWORD *)(v1 + 471);
                IKEv2PacketString = (void *)createIKEv2PacketString(v43);
                v164 = (unsigned __int8 *)objc_msgSend(v43, "length");
                v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "connection"));
                v47 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "connection"));
                v48 = objc_msgSend(v47, "connectionState");
                if ((unint64_t)v48 >= 6)
                  v49 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("Unknown[%lld]"), v48);
                else
                  v49 = *(&off_1001B66E8 + (_QWORD)v48);
                objc_msgSend((id)v1, "reportEvent:detailsFormat:", 3007, CFSTR("Receiving IKEv2 packet #%llu %@ len %llu connection %@ state %@"), v44, IKEv2PacketString, v164, v46, v49);

                ++*(_QWORD *)(*(_QWORD *)(a1 + 40) + 471);
                v63 = *(_QWORD *)(a1 + 40);
                v64 = *(void **)(v63 + 287);
                if (v64)
                {
                  objc_msgSend(v64, "receivePacketData:", v43);
                }
                else
                {
                  v65 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v63 + 32), v62);
                  v66 = _NRLogIsLevelEnabled(v65, 16);

                  if (v66)
                  {
                    v68 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 32), v67);
                    v69 = objc_msgSend(*(id *)(a1 + 40), "copyDescription");
                    _NRLogWithArgs(v68, 16, "%s%.30s:%-4d %@: not ready to handle IKE yet", "", "-[NRLinkQuickRelay readDatagramFromSession]_block_invoke_2", 1774, v69);

                  }
                  objc_msgSend(*(id *)(*(_QWORD *)(a1 + 40) + 623), "addObject:", v43);
                }

                goto LABEL_21;
              default:
                goto LABEL_21;
            }
        }
LABEL_53:
        ++*(_QWORD *)(*(_QWORD *)(a1 + 40) + *v37);
        v50 = 2048;
        v1 = (unint64_t)v172;
        bzero(v172, 0x800uLL);
        if (v28 >= 0x7D9)
        {
          if ((_WORD)v28 == 0xFFD8)
          {
            v119 = sub_10003BC58();
            v120 = _NRLogIsLevelEnabled(v119, 16);

            if (v120)
            {
              v121 = sub_10003BC58();
              _NRLogWithArgs(v121, 16, "%s%.30s:%-4d ABORTING: strict_calloc called with size 0", "", "strict_calloc", 100);

            }
            v122 = _os_log_pack_size(12);
            v51 = (size_t)&v156 - ((__chkstk_darwin(v122) + 15) & 0xFFFFFFFFFFFFFFF0);
            v123 = __error();
            v124 = _os_log_pack_fill(v51, v122, *v123, &_mh_execute_header, "%{public}s strict_calloc called with size 0");
            *(_DWORD *)v124 = 136446210;
            *(_QWORD *)(v124 + 4) = "strict_calloc";
LABEL_114:
            v125 = sub_10003BC58();
            _NRLogAbortWithPack(v125, v51);
LABEL_115:
            v126 = sub_10003BC58();
            v127 = _NRLogIsLevelEnabled(v126, 16);

            if (v127)
            {
              v128 = sub_10003BC58();
              _NRLogWithArgs(v128, 16, "%s%.30s:%-4d ABORTING: strict_calloc(%zu, %zu) failed", "", "strict_calloc", 108, 1uLL, v51);

            }
            v129 = _os_log_pack_size(32);
            v130 = (char *)&v156 - ((__chkstk_darwin(v129) + 15) & 0xFFFFFFFFFFFFFFF0);
            v131 = __error();
            v132 = _os_log_pack_fill(v130, v129, *v131, &_mh_execute_header, "%{public}s strict_calloc(%zu, %zu) failed");
            *(_DWORD *)v132 = 136446722;
            *(_QWORD *)(v132 + 4) = "strict_calloc";
            *(_WORD *)(v132 + 12) = 2048;
            *(_QWORD *)(v132 + 14) = 1;
            *(_WORD *)(v132 + 22) = 2048;
            *(_QWORD *)(v132 + 24) = v51;
            while (1)
            {
LABEL_118:
              v133 = sub_10003BC58();
              _NRLogAbortWithPack(v133, v130);
LABEL_119:
              v31 = 0;
LABEL_120:
              v134 = sub_10003BC58();
              v135 = _NRLogIsLevelEnabled(v134, 16);

              if (v135)
              {
                v136 = sub_10003BC58();
                v137 = (void *)createIOVecString(&v166, 1);
                _NRLogWithArgs(v136, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: bytesWritten == length; bytesWritten (%u) != length (%u), off"
                  "set: %u, ioVec: %@",
                  "",
                  "nrWriteIOVecToBuffer",
                  342,
                  v31,
                  2,
                  v1,
                  v137);

              }
              v138 = _os_log_pack_size(40);
              v130 = (char *)&v156 - ((__chkstk_darwin(v138) + 15) & 0xFFFFFFFFFFFFFFF0);
              v139 = __error();
              v140 = _os_log_pack_fill(v130, v138, *v139, &_mh_execute_header, "%{public}s Assertion Failed: bytesWritten == length; bytesWritten (%u) != length (%u), offset: %u, ioVec: %@");
              v141 = createIOVecString(&v166, 1);
              sub_100043594(v140, (uint64_t)"nrWriteIOVecToBuffer", v31, 2, v1, v141);
            }
          }
          v51 = (unsigned __int16)(v28 + 40);
          v52 = malloc_type_calloc(1uLL, v51, 0xF1748037uLL);
          if (!v52)
            goto LABEL_115;
          v1 = (unint64_t)v52;
          v50 = v28 + 40;
        }
        v54 = nrTLVToPacket(&v166, 1, v26, v28, v1, v50, *(_QWORD *)(a1 + 40) + 671, *(_QWORD *)(a1 + 40) + 655);
        if (gNRPacketLoggingEnabled)
        {
          v70 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 32), v53);
          v71 = _NRLogIsLevelEnabled(v70, 1);

          if (v71)
          {
            v72 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 32), v53);
            v73 = objc_msgSend(*(id *)(a1 + 40), "copyDescription");
            StringFromNRTLVType = (void *)createStringFromNRTLVType(v26, v74);
            _NRLogWithArgs(v72, 1, "%s%.30s:%-4d %@: Receiving packet [%@(%u/%u), %llu]", "", "-[NRLinkQuickRelay readDatagramFromSession]_block_invoke_2", 1733, v73, StringFromNRTLVType, v28, v54, objc_msgSend(v157, "length"));

          }
        }
        if (v54)
        {
          v55 = objc_alloc_init((Class)NSMutableData);
          objc_msgSend(v55, "appendBytes:length:", v1, v54);
          objc_msgSend(*(id *)(*(_QWORD *)(a1 + 40) + 343), "addObject:", v55);
        }
        else
        {
          v56 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 32), v53);
          v57 = _NRLogIsLevelEnabled(v56, 17);

          if (!v57)
            goto LABEL_63;
          v55 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 32), v23);
          v58 = objc_msgSend(*(id *)(a1 + 40), "copyDescription");
          v60 = (void *)createStringFromNRTLVType(v26, v59);
          _NRLogWithArgs(v55, 17, "%@: failed to reinject %@ tlvLen=%u", v58, v60, v28);

        }
LABEL_63:
        if ((_WORD *)v1 != v172)
          free((void *)v1);
        v61 = *(_QWORD *)(a1 + 40);
        if (*(_BYTE *)(v61 + 210))
        {
          if (gNRPacketLoggingEnabled)
          {
            v76 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v61 + 32), v23);
            v77 = _NRLogIsLevelEnabled(v76, 1);

            v61 = *(_QWORD *)(a1 + 40);
            if (v77)
            {
              v79 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v61 + 32), v78);
              v80 = objc_msgSend(*(id *)(a1 + 40), "copyDescription");
              _NRLogWithArgs(v79, 1, "%s%.30s:%-4d %@: Resuming write source", "", "-[NRLinkQuickRelay readDatagramFromSession]_block_invoke_2", 1750, v80);

              v61 = *(_QWORD *)(a1 + 40);
            }
          }
          dispatch_resume(*(dispatch_object_t *)(v61 + 327));
          *(_BYTE *)(*(_QWORD *)(a1 + 40) + 210) = 0;
        }
LABEL_21:
        v24 += v167;
        v25 = v165;
        if (v24 >= v165)
          goto LABEL_86;
      }
      v87 = sub_10003BC58();
      v88 = _NRLogIsLevelEnabled(v87, 16);

      if (v88)
      {
        v89 = sub_10003BC58();
        _NRLogWithArgs(v89, 16, "%s%.30s:%-4d checksum failed same IOVec received 0x%02x%02x != computed 0x%02x%02x", "", "nrChecksumIOVecInner", 179, v164[(_QWORD)v166], v164[(_QWORD)v166 + 1], v36, HIBYTE(v36));

      }
LABEL_83:
      v90 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 32), v23);
      v91 = _NRLogIsLevelEnabled(v90, 17);

      if (v91)
      {
        v20 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 32), v92);
        v1 = (unint64_t)objc_msgSend(*(id *)(a1 + 40), "copyDescription");
        v94 = (void *)createStringFromNRTLVType(v26, v93);
        v95 = (void *)createIOVecString(&v166, 1);
        _NRLogWithArgs(v20, 17, "%@: Invalid checksum detected %@ len %u %@", v1, v94, v28, v95);

LABEL_85:
LABEL_16:

      }
LABEL_86:
      v12 = v163 + 1;
      if (v163 + 1 >= (unint64_t)v162)
      {
        v162 = objc_msgSend(v161, "countByEnumeratingWithState:objects:count:", &v168, v173, 16);
        if (!v162)
        {
LABEL_88:

          sub_10003C71C(*(_QWORD *)(a1 + 40));
          return;
        }
        v12 = 0;
      }
      v13 = *(_QWORD *)v169;
    }
  }
  v4 = v3;
  if (objc_msgSend(v4, "code") == (id)89)
  {
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "domain"));
    v6 = objc_msgSend(v5, "isEqualToString:", NSPOSIXErrorDomain);

    if (v6)
    {
      v8 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 32), v7);
      v9 = _NRLogIsLevelEnabled(v8, 16);

      if (v9)
      {
        v165 = (unsigned __int8 *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 32), v10);
        v11 = objc_msgSend(*(id *)(a1 + 40), "copyDescription");
        _NRLogWithArgs(v165, 16, "%s%.30s:%-4d %@: Read failed on cancelled connection", "", "-[NRLinkQuickRelay readDatagramFromSession]_block_invoke_2", 1615, v11);

LABEL_99:
        return;
      }
      return;
    }
  }
  else
  {

  }
  v96 = *(void **)(a1 + 40);
  v97 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v96, "connection"));
  v98 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "connection"));
  v99 = objc_msgSend(v98, "connectionState");
  if ((unint64_t)v99 >= 6)
    v100 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("Unknown[%lld]"), v99);
  else
    v100 = *(&off_1001B66E8 + (_QWORD)v99);
  objc_msgSend(v96, "reportEvent:detailsFormat:", 10021, CFSTR("connection %@ state %@ error %@"), v97, v100, *(_QWORD *)(a1 + 32));

  v102 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 32), v101);
  v103 = _NRLogIsLevelEnabled(v102, 17);

  if (v103)
  {
    v165 = (unsigned __int8 *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 32), v104);
    v105 = objc_msgSend(*(id *)(a1 + 40), "copyDescription");
    v106 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "connection"));
    v107 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "connection"));
    v108 = objc_msgSend(v107, "connectionState");
    if ((unint64_t)v108 >= 6)
      v109 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("Unknown[%lld]"), v108);
    else
      v109 = *(&off_1001B66E8 + (_QWORD)v108);
    _NRLogWithArgs(v165, 17, "%@: Failed to read data on connection %@ state %@: %@", v105, v106, v109, *(_QWORD *)(a1 + 32));

    goto LABEL_99;
  }
}

double sub_100043594(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6)
{
  double result;

  *(_QWORD *)&result = 136447234;
  *(_DWORD *)a1 = 136447234;
  *(_QWORD *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 1024;
  *(_DWORD *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 18) = 1024;
  *(_DWORD *)(a1 + 20) = a4;
  *(_WORD *)(a1 + 24) = 1024;
  *(_DWORD *)(a1 + 26) = a5;
  *(_WORD *)(a1 + 30) = 2112;
  *(_QWORD *)(a1 + 32) = a6;
  return result;
}

double sub_1000435D0(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  double result;

  *(_QWORD *)&result = 136446978;
  *(_DWORD *)a1 = 136446978;
  *(_QWORD *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 2112;
  *(_QWORD *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 22) = 1024;
  *(_DWORD *)(a1 + 24) = a4;
  *(_WORD *)(a1 + 28) = 1024;
  *(_DWORD *)(a1 + 30) = a5;
  return result;
}

void sub_100043604(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  id v5;
  NSObject *v6;
  id v7;
  id v8;
  _QWORD v9[5];
  id v10;
  id v11;
  id v12;
  id v13;
  id v14;

  v2 = *(void **)(a1 + 32);
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "destination"));
  v14 = 0;
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "datagramConnectionForSessionDestination:uid:error:", v3, 501, &v14));
  v5 = v14;

  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  v9[2] = sub_100043700;
  v9[3] = &unk_1001B6680;
  v6 = *(NSObject **)(a1 + 48);
  v9[4] = *(_QWORD *)(a1 + 56);
  v10 = *(id *)(a1 + 40);
  v11 = v4;
  v12 = *(id *)(a1 + 32);
  v13 = v5;
  v7 = v5;
  v8 = v4;
  dispatch_async(v6, v9);

}

void sub_100043700(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  id v5;
  void *v6;
  void *v7;
  uint64_t v8;
  void *v9;
  void *v10;
  unsigned __int8 v11;
  void *v12;
  uint64_t v13;
  void *v14;
  void *v15;
  id v16;
  void *v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  int IsLevelEnabled;
  uint64_t v24;
  id v25;
  void *v26;
  void *v27;
  int v28;
  uint64_t v29;
  void *v30;
  id v31;
  void *v32;
  uint64_t v33;
  void *v34;
  int v35;
  uint64_t v36;
  void *v37;
  id v38;
  id v39;

  v2 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "queue"));
  dispatch_assert_queue_V2(v2);

  v4 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(a1 + 40))
  {
    v5 = *(id *)(v4 + 231);
    if (v5)
    {
      v6 = v5;
      v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "sessionID"));
      v8 = *(_QWORD *)(a1 + 32);
      if (v8)
        v9 = *(void **)(v8 + 231);
      else
        v9 = 0;
      v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "sessionID"));
      v11 = objc_msgSend(v7, "isEqualToString:", v10);

      v4 = *(_QWORD *)(a1 + 32);
      if ((v11 & 1) != 0)
      {
        objc_msgSend((id)v4, "setConnection:", *(_QWORD *)(a1 + 48));
        v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "connection"));

        v13 = *(_QWORD *)(a1 + 32);
        if (v12)
        {
          if (v13)
            v14 = *(void **)(v13 + 231);
          else
            v14 = 0;
          v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "sessionID"));
          if (v13)
          {
            v16 = objc_alloc_init((Class)NSMutableDictionary);
            objc_msgSend(v16, "setObject:forKeyedSubscript:", &off_1001C46A8, CFSTR("State"));
            objc_msgSend(v16, "setObject:forKeyedSubscript:", v15, CFSTR("SessionID"));
            sub_100107BA4(CFSTR("IDS Session"), v16);

          }
          v17 = *(void **)(a1 + 32);
          v18 = *(_QWORD *)(a1 + 40);
          v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "connection"));
          objc_msgSend(v17, "reportEvent:detailsFormat:", 10008, CFSTR("session %@ connection %@"), v18, v19);

          v21 = *(_QWORD *)(a1 + 32);
          if (!v21 || !*(_BYTE *)(v21 + 215))
          {
            objc_msgSend((id)v21, "addObserver:forKeyPath:options:context:", *(_QWORD *)(a1 + 32), CFSTR("_connection.connectionState"), 5, 0);
            *(_BYTE *)(*(_QWORD *)(a1 + 32) + 215) = 1;
            v21 = *(_QWORD *)(a1 + 32);
          }
          v22 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v21 + 32), v20);
          IsLevelEnabled = _NRLogIsLevelEnabled(v22, 0);

          if (IsLevelEnabled)
          {
            v39 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v24);
            v25 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
            v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "connection"));
            _NRLogWithArgs(v39, 0, "%s%.30s:%-4d %@: Obtained connection: %@", "", "-[NRLinkQuickRelay sessionStarted:]_block_invoke_2", 2427, v25, v26);

          }
        }
        else
        {
          objc_msgSend((id)v13, "cancelWithReason:", CFSTR("No datagram connection for session %@ service %@ error %@"), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64));
        }
        return;
      }
    }
    else
    {
      v4 = *(_QWORD *)(a1 + 32);
    }
  }
  v27 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v3);
  v28 = _NRLogIsLevelEnabled(v27, 0);

  if (v28)
  {
    v30 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v29);
    v31 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    v32 = v31;
    v33 = *(_QWORD *)(a1 + 32);
    if (v33)
      v33 = *(_QWORD *)(v33 + 231);
    _NRLogWithArgs(v30, 0, "%s%.30s:%-4d %@: mismatched ids session: current %@, previous %@,skip adding KVO for previous connection", "", "-[NRLinkQuickRelay sessionStarted:]_block_invoke_2", 2400, v31, v33, *(_QWORD *)(a1 + 40));

  }
  if (*(_QWORD *)(a1 + 48))
  {
    v34 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v29);
    v35 = _NRLogIsLevelEnabled(v34, 1);

    if (v35)
    {
      v37 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v36);
      v38 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
      _NRLogWithArgs(v37, 1, "%s%.30s:%-4d %@: Cancelling %@", "", "-[NRLinkQuickRelay sessionStarted:]_block_invoke_2", 2402, v38, *(_QWORD *)(a1 + 48));

    }
    objc_msgSend(*(id *)(a1 + 48), "cancel");
  }
}

void sub_100043AC8(uint64_t a1, void *a2)
{
  if (a1)
    objc_storeStrong((id *)(a1 + 271), a2);
}

void sub_100043AE0(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  void *v5;
  unsigned int v6;
  uint64_t v7;
  void *v8;
  int v9;
  uint64_t v10;
  void *v11;
  id v12;
  void *v13;
  void *v14;
  void *v15;
  id v16;
  id v17;
  id v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  int v23;
  uint64_t v24;
  void *v25;
  id v26;
  void *v27;
  int IsLevelEnabled;
  uint64_t v29;
  void *v30;
  id v31;
  id v32;

  v3 = a2;
  v32 = v3;
  if (!v3)
  {
    if (gNRPacketLoggingEnabled)
    {
      v27 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v4);
      IsLevelEnabled = _NRLogIsLevelEnabled(v27, 1);

      if (IsLevelEnabled)
      {
        v30 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v29);
        v31 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
        _NRLogWithArgs(v30, 1, "%s%.30s:%-4d %@: Wrote %llu bytes", "", "-[NRLinkQuickRelay writeDatagramToSession:]_block_invoke", 1571, v31, objc_msgSend(*(id *)(a1 + 40), "length"));

      }
    }
    v18 = objc_msgSend(*(id *)(a1 + 40), "length");
    v19 = *(_QWORD *)(a1 + 32);
    v20 = 391;
    goto LABEL_14;
  }
  if (objc_msgSend(v3, "code") != (id)89
    || (v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v32, "domain")),
        v6 = objc_msgSend(v5, "isEqualToString:", NSPOSIXErrorDomain),
        v5,
        !v6))
  {
    v13 = *(void **)(a1 + 32);
    v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "connection"));
    v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "connection"));
    v16 = objc_msgSend(v15, "connectionState");
    if ((unint64_t)v16 >= 6)
      v17 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("Unknown[%lld]"), v16);
    else
      v17 = *(&off_1001B66E8 + (_QWORD)v16);
    objc_msgSend(v13, "reportEvent:detailsFormat:", 10022, CFSTR("connection %@ state %@ error %@"), v14, v17, v32);

    v22 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v21);
    v23 = _NRLogIsLevelEnabled(v22, 17);

    if (v23)
    {
      v25 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v24);
      v26 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
      _NRLogWithArgs(v25, 17, "%@: Failed to write %llu bytes, error %@", v26, objc_msgSend(*(id *)(a1 + 40), "length"), v32);

    }
    v18 = objc_msgSend(*(id *)(a1 + 40), "length");
    v19 = *(_QWORD *)(a1 + 32);
    v20 = 399;
LABEL_14:
    *(_QWORD *)(v19 + v20) += v18;
    goto LABEL_15;
  }
  v8 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v7);
  v9 = _NRLogIsLevelEnabled(v8, 16);

  if (v9)
  {
    v11 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v10);
    v12 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    _NRLogWithArgs(v11, 16, "%s%.30s:%-4d %@: Write failed on cancelled connection", "", "-[NRLinkQuickRelay writeDatagramToSession:]_block_invoke", 1561, v12);

  }
LABEL_15:

}

void sub_100043DAC(uint64_t a1, int a2)
{
  _QWORD *WeakRetained;
  uint64_t v4;
  void *v5;
  int IsLevelEnabled;
  uint64_t v7;
  void *v8;
  id v9;
  uint64_t v10;
  void *v11;
  int v12;
  uint64_t v13;
  _QWORD *v14;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v14 = WeakRetained;
    if (a2)
    {
      v5 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
      IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0);

      WeakRetained = v14;
      if (IsLevelEnabled)
      {
        v8 = (void *)_NRCopyLogObjectForNRUUID(v14[4], v7);
        v9 = objc_msgSend(v14, "copyDescription");
        _NRLogWithArgs(v8, 0, "%s%.30s:%-4d %@: Received response to control notify", "", "-[NRLinkQuickRelay sendControlData:]_block_invoke", 1522, v9);
LABEL_7:

        WeakRetained = v14;
      }
    }
    else
    {
      objc_msgSend(WeakRetained, "cancelWithReason:", CFSTR("Did not receive response to control notify"));
      v11 = (void *)_NRCopyLogObjectForNRUUID(v14[4], v10);
      v12 = _NRLogIsLevelEnabled(v11, 16);

      WeakRetained = v14;
      if (v12)
      {
        v8 = (void *)_NRCopyLogObjectForNRUUID(v14[4], v13);
        v9 = objc_msgSend(v14, "copyDescription");
        _NRLogWithArgs(v8, 16, "%s%.30s:%-4d %@: Did not receive response to control notify", "", "-[NRLinkQuickRelay sendControlData:]_block_invoke", 1525, v9);
        goto LABEL_7;
      }
    }
  }

}

void sub_100043EE0(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  id v4;
  uint64_t v5;
  void *v6;
  int IsLevelEnabled;
  uint64_t v8;
  void *v9;
  id v10;
  uint64_t v11;
  void *v12;
  int v13;
  uint64_t v14;
  id v15;
  void *v16;
  int v17;
  uint64_t v18;
  void *v19;
  int v20;
  uint64_t v21;
  id v22;
  void *v23;
  void *v24;
  NSObject *v25;
  id v26;
  id v27;
  id v28;
  id v29;
  _QWORD block[4];
  id v31;
  id v32;
  id v33;
  uint64_t v34;

  if (a1)
  {
    v2 = objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "queue"));
    dispatch_assert_queue_V2(v2);

    if (++*(_BYTE *)(a1 + 217) >= 3u)
    {
      objc_msgSend((id)a1, "reportEvent:", 10025);
      if (!*(_BYTE *)(a1 + 211))
        return;
      v4 = sub_100041824((void *)a1, 0);
      v29 = (id)objc_claimAutoreleasedReturnValue(v4);
      v6 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
      IsLevelEnabled = _NRLogIsLevelEnabled(v6, 1);

      if (IsLevelEnabled)
      {
        v9 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v8);
        v10 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v9, 1, "%s%.30s:%-4d %@: Drained %zu packets", "", "-[NRLinkQuickRelay setupIDSSessionAndSendInvitation]", 584, v10, objc_msgSend(v29, "count"));

      }
      *(_BYTE *)(a1 + 211) = 0;
      if (*(_BYTE *)(a1 + 209))
      {
        dispatch_resume(*(dispatch_object_t *)(a1 + 319));
        *(_BYTE *)(a1 + 209) = 0;
      }
      goto LABEL_16;
    }
    if (*(unsigned __int8 *)(a1 + 16) == 255)
    {
      v16 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v3);
      v17 = _NRLogIsLevelEnabled(v16, 16);

      if (!v17)
        return;
      v29 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v18);
      v15 = objc_msgSend((id)a1, "copyDescription");
      _NRLogWithArgs(v29, 16, "%s%.30s:%-4d %@: Asked to setup IDS session but cancelled", "", "-[NRLinkQuickRelay setupIDSSessionAndSendInvitation]", 596, v15);
      goto LABEL_15;
    }
    if (!sub_10004429C((void *)a1))
      return;
    if (*(_BYTE *)(a1 + 216))
    {
      v12 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v11);
      v13 = _NRLogIsLevelEnabled(v12, 0);

      if (!v13)
        return;
      v29 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v14);
      v15 = objc_msgSend((id)a1, "copyDescription");
      _NRLogWithArgs(v29, 0, "%s%.30s:%-4d %@: Tried to setup IDS Session but already in progress", "", "-[NRLinkQuickRelay setupIDSSessionAndSendInvitation]", 606, v15);
      goto LABEL_15;
    }
    if (*(_QWORD *)(a1 + 231))
    {
      v19 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v11);
      v20 = _NRLogIsLevelEnabled(v19, 17);

      if (v20)
      {
        v29 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v21);
        v15 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v29, 17, "%@: Tried to setup IDS Session but we already have one", v15);
LABEL_15:

LABEL_16:
      }
    }
    else
    {
      *(_BYTE *)(a1 + 216) = 1;
      v22 = *(id *)(a1 + 223);
      v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "queue"));
      v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "description"));
      if (qword_1001E48F8 != -1)
        dispatch_once(&qword_1001E48F8, &stru_1001B7D20);
      v25 = (id)qword_1001E4900;
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_1000444BC;
      block[3] = &unk_1001B7898;
      v31 = v24;
      v32 = v22;
      v33 = v23;
      v34 = a1;
      v26 = v23;
      v27 = v22;
      v28 = v24;
      dispatch_async(v25, block);

    }
  }
}

uint64_t sub_10004429C(void *a1)
{
  uint64_t v1;
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  int IsLevelEnabled;
  uint64_t v7;
  void *v8;
  id v9;
  void *v10;
  id v11;
  id v12;
  void *v13;

  v1 = (uint64_t)a1;
  if (a1)
  {
    v2 = objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "queue"));
    dispatch_assert_queue_V2(v2);

    v3 = *(_QWORD *)(v1 + 223);
    v5 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v1 + 32), v4);
    IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0);

    if (!v3)
    {
      if (IsLevelEnabled)
      {
        v10 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v1 + 32), v7);
        v11 = objc_msgSend((id)v1, "copyDescription");
        _NRLogWithArgs(v10, 0, "%s%.30s:%-4d %@: Bootstrapping IDSService", "", "-[NRLinkQuickRelay setupIDSService]", 557, v11);

      }
      v12 = objc_msgSend(objc_alloc((Class)IDSService), "initWithService:", CFSTR("com.apple.private.alloy.terminus"));
      if (!v12)
      {
        if (qword_1001E45F0 != -1)
          dispatch_once(&qword_1001E45F0, &stru_1001B66A0);
        if (_NRLogIsLevelEnabled(qword_1001E45E8, 17))
        {
          if (qword_1001E45F0 != -1)
            dispatch_once(&qword_1001E45F0, &stru_1001B66A0);
          _NRLogWithArgs(qword_1001E45E8, 17, "[IDSService alloc] initWithService:%@] failed", CFSTR("com.apple.private.alloy.terminus"));
        }
        v8 = 0;
        v1 = 0;
        goto LABEL_18;
      }
      v8 = v12;
      v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v1, "queue"));
      objc_msgSend(v8, "addDelegate:queue:", v1, v13);

      objc_storeStrong((id *)(v1 + 223), v8);
LABEL_9:
      v1 = 1;
LABEL_18:

      return v1;
    }
    if (IsLevelEnabled)
    {
      v8 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v1 + 32), v7);
      v9 = objc_msgSend((id)v1, "copyDescription");
      _NRLogWithArgs(v8, 0, "%s%.30s:%-4d %@: IDSService already exists: %@", "", "-[NRLinkQuickRelay setupIDSService]", 553, v9, *(_QWORD *)(v1 + 223));

      goto LABEL_9;
    }
    return 1;
  }
  return v1;
}

void sub_1000444BC(uint64_t a1)
{
  void *v2;
  id v3;
  id v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  id v8;
  void *v9;
  id v10;
  id v11;
  id v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  void *v18;
  void *v19;
  void *v20;
  id v21;
  void *v22;
  void *v23;
  id v24;
  NSObject *v25;
  id v26;
  id v27;
  NSObject *v28;
  void *v29;
  id v30;
  id v31;
  _QWORD v32[5];
  id v33;
  id v34;
  _QWORD v35[5];
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  _QWORD block[5];
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  _QWORD v45[2];
  _QWORD v46[2];
  _BYTE v47[128];
  _BYTE v48[128];

  if (qword_1001E45F0 != -1)
    dispatch_once(&qword_1001E45F0, &stru_1001B66A0);
  if (_NRLogIsLevelEnabled(qword_1001E45E8, 0))
  {
    if (qword_1001E45F0 != -1)
      dispatch_once(&qword_1001E45F0, &stru_1001B66A0);
    _NRLogWithArgs(qword_1001E45E8, 0, "%s%.30s:%-4d %@ Bootstrapping IDSSession", "", "-[NRLinkQuickRelay setupIDSSessionAndSendInvitation]_block_invoke", 621, *(_QWORD *)(a1 + 32));
  }
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "devices"));
  v3 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v41, v48, 16);
  if (v3)
  {
    v4 = v3;
    v5 = *(_QWORD *)v42;
LABEL_9:
    v6 = 0;
    while (1)
    {
      if (*(_QWORD *)v42 != v5)
        objc_enumerationMutation(v2);
      v7 = *(void **)(*((_QWORD *)&v41 + 1) + 8 * v6);
      if ((objc_msgSend(v7, "isDefaultPairedDevice") & 1) != 0)
        break;
      if (v4 == (id)++v6)
      {
        v4 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v41, v48, 16);
        if (v4)
          goto LABEL_9;
        goto LABEL_15;
      }
    }
    v8 = v7;

    if (!v8)
      goto LABEL_31;
    if (qword_1001E45F0 != -1)
      dispatch_once(&qword_1001E45F0, &stru_1001B66A0);
    if (_NRLogIsLevelEnabled(qword_1001E45E8, 1))
    {
      if (qword_1001E45F0 != -1)
        dispatch_once(&qword_1001E45F0, &stru_1001B66A0);
      _NRLogWithArgs(qword_1001E45E8, 1, "%s%.30s:%-4d %@ Default device: %@", "", "-[NRLinkQuickRelay setupIDSSessionAndSendInvitation]_block_invoke", 643, *(_QWORD *)(a1 + 32), v8);
    }
    v30 = objc_msgSend(objc_alloc((Class)IDSAccountController), "initWithService:", CFSTR("com.apple.private.alloy.terminus"));
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "accounts"));
    if (qword_1001E45F0 != -1)
      dispatch_once(&qword_1001E45F0, &stru_1001B66A0);
    if (_NRLogIsLevelEnabled(qword_1001E45E8, 1))
    {
      if (qword_1001E45F0 != -1)
        dispatch_once(&qword_1001E45F0, &stru_1001B66A0);
      _NRLogWithArgs(qword_1001E45E8, 1, "%s%.30s:%-4d %@ Received the following accounts: %@", "", "-[NRLinkQuickRelay setupIDSSessionAndSendInvitation]_block_invoke", 648, *(_QWORD *)(a1 + 32), v9);
    }
    v38 = 0u;
    v39 = 0u;
    v36 = 0u;
    v37 = 0u;
    v10 = v9;
    v11 = objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v36, v47, 16);
    if (v11)
    {
      v12 = v11;
      v13 = *(_QWORD *)v37;
LABEL_39:
      v15 = 0;
      while (1)
      {
        if (*(_QWORD *)v37 != v13)
          objc_enumerationMutation(v10);
        v16 = *(void **)(*((_QWORD *)&v36 + 1) + 8 * v15);
        if (v16)
        {
          if ((objc_msgSend(*(id *)(*((_QWORD *)&v36 + 1) + 8 * v15), "isActive") & 1) != 0)
            break;
        }
        if (v12 == (id)++v15)
        {
          v12 = objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v36, v47, 16);
          if (!v12)
            goto LABEL_58;
          goto LABEL_39;
        }
      }
      v31 = v16;

      if (qword_1001E45F0 != -1)
        dispatch_once(&qword_1001E45F0, &stru_1001B66A0);
      if (_NRLogIsLevelEnabled(qword_1001E45E8, 1))
      {
        if (qword_1001E45F0 != -1)
          dispatch_once(&qword_1001E45F0, &stru_1001B66A0);
        _NRLogWithArgs(qword_1001E45E8, 1, "%s%.30s:%-4d %@ Default account: %@", "", "-[NRLinkQuickRelay setupIDSSessionAndSendInvitation]_block_invoke", 668, *(_QWORD *)(a1 + 32), v31);
      }
      v17 = objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "pushToken"));
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "identities"));
      v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "service"));
      v29 = (void *)v17;
      v20 = (void *)_IDSCopyIDForPushTokenAndIdentitiesWithService(v17, v18, v19);
      v21 = objc_alloc((Class)IDSSession);
      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSSet setWithObject:](NSSet, "setWithObject:", v20));
      v45[0] = IDSSessionSingleChannelDirectModeKey;
      v45[1] = IDSSessionForceInternetInvitationKey;
      v46[0] = &__kCFBooleanTrue;
      v46[1] = &__kCFBooleanTrue;
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v46, v45, 2));
      v24 = objc_msgSend(v21, "initWithAccount:destinations:options:", v31, v22, v23);

      if (qword_1001E45F0 != -1)
        dispatch_once(&qword_1001E45F0, &stru_1001B66A0);
      if (_NRLogIsLevelEnabled(qword_1001E45E8, 1))
      {
        if (qword_1001E45F0 != -1)
          dispatch_once(&qword_1001E45F0, &stru_1001B66A0);
        _NRLogWithArgs(qword_1001E45E8, 1, "%s%.30s:%-4d %@ Default session: %@", "", "-[NRLinkQuickRelay setupIDSSessionAndSendInvitation]_block_invoke", 683, *(_QWORD *)(a1 + 32), v24);
      }
      v32[0] = _NSConcreteStackBlock;
      v32[1] = 3221225472;
      v32[2] = sub_100044CD8;
      v32[3] = &unk_1001B87A0;
      v25 = *(NSObject **)(a1 + 48);
      v32[4] = *(_QWORD *)(a1 + 56);
      v33 = v24;
      v34 = v20;
      v26 = v20;
      v27 = v24;
      dispatch_async(v25, v32);

    }
    else
    {
LABEL_58:

      if (qword_1001E45F0 != -1)
        dispatch_once(&qword_1001E45F0, &stru_1001B66A0);
      if (_NRLogIsLevelEnabled(qword_1001E45E8, 17))
      {
        if (qword_1001E45F0 != -1)
          dispatch_once(&qword_1001E45F0, &stru_1001B66A0);
        _NRLogWithArgs(qword_1001E45E8, 17, "Failed to find default account for service %@", CFSTR("com.apple.private.alloy.terminus"));
      }
      v35[0] = _NSConcreteStackBlock;
      v35[1] = 3221225472;
      v35[2] = sub_100044CA0;
      v35[3] = &unk_1001B8AE0;
      v28 = *(NSObject **)(a1 + 48);
      v35[4] = *(_QWORD *)(a1 + 56);
      dispatch_async(v28, v35);
    }

  }
  else
  {
LABEL_15:

LABEL_31:
    if (qword_1001E45F0 != -1)
      dispatch_once(&qword_1001E45F0, &stru_1001B66A0);
    if (_NRLogIsLevelEnabled(qword_1001E45E8, 16))
    {
      if (qword_1001E45F0 != -1)
        dispatch_once(&qword_1001E45F0, &stru_1001B66A0);
      _NRLogWithArgs(qword_1001E45E8, 16, "%s%.30s:%-4d Failed to find default device for service %@", "", "-[NRLinkQuickRelay setupIDSSessionAndSendInvitation]_block_invoke", 634, CFSTR("com.apple.private.alloy.terminus"));
    }
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100044C68;
    block[3] = &unk_1001B8AE0;
    v14 = *(NSObject **)(a1 + 48);
    block[4] = *(_QWORD *)(a1 + 56);
    dispatch_async(v14, block);
  }
}

id sub_100044C68(uint64_t a1)
{
  NSObject *v2;

  v2 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "queue"));
  dispatch_assert_queue_V2(v2);

  return objc_msgSend(*(id *)(a1 + 32), "suspend");
}

id sub_100044CA0(uint64_t a1)
{
  NSObject *v2;

  v2 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "queue"));
  dispatch_assert_queue_V2(v2);

  return objc_msgSend(*(id *)(a1 + 32), "suspend");
}

void sub_100044CD8(id *a1)
{
  NSObject *v2;
  uint64_t v3;
  _QWORD *v4;
  id v5;
  void *v6;
  char *v7;
  char *v8;
  char *v9;
  NSObject *v10;
  uint64_t v11;
  void *v12;
  int v13;
  uint64_t v14;
  void *v15;
  id v16;
  void *v17;
  id v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  int IsLevelEnabled;
  uint64_t v23;
  id v24;
  id v25;

  v2 = objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "queue"));
  dispatch_assert_queue_V2(v2);

  *((_BYTE *)a1[4] + 216) = 0;
  v4 = a1[4];
  if (*((unsigned __int8 *)v4 + 16) == 255)
  {
    v21 = (void *)_NRCopyLogObjectForNRUUID(v4[4], v3);
    IsLevelEnabled = _NRLogIsLevelEnabled(v21, 16);

    if (IsLevelEnabled)
    {
      v25 = (id)_NRCopyLogObjectForNRUUID(*((_QWORD *)a1[4] + 4), v23);
      v24 = objc_msgSend(a1[4], "copyDescription");
      _NRLogWithArgs(v25, 16, "%s%.30s:%-4d %@: Asked to finish setting up IDS session but cancelled", "", "-[NRLinkQuickRelay setupIDSSessionAndSendInvitation]_block_invoke_4", 689, v24);

    }
  }
  else
  {
    v5 = a1[5];
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1[4], "queue"));
    objc_msgSend(v5, "setDelegate:queue:", v4, v6);

    v7 = (char *)a1[4];
    if (v7)
    {
      objc_storeStrong((id *)(v7 + 231), a1[5]);
      v8 = (char *)a1[4];
      if (v8)
      {
        objc_storeStrong((id *)(v8 + 239), a1[6]);
        v9 = (char *)a1[4];
        if (v9)
        {
          v10 = objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "queue"));
          dispatch_assert_queue_V2(v10);

          v12 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v9 + 4), v11);
          v13 = _NRLogIsLevelEnabled(v12, 0);

          if (v13)
          {
            v15 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v9 + 4), v14);
            v16 = objc_msgSend(v9, "copyDescription");
            _NRLogWithArgs(v15, 0, "%s%.30s:%-4d %@: Sending session invitation", "", "-[NRLinkQuickRelay sendInvitation]", 764, v16);

          }
          v9[213] = 1;
          objc_msgSend(*(id *)(v9 + 231), "sendInvitation");
          v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v9 + 231), "sessionID"));
          v18 = objc_alloc_init((Class)NSMutableDictionary);
          objc_msgSend(v18, "setObject:forKeyedSubscript:", &off_1001C4678, CFSTR("State"));
          objc_msgSend(v18, "setObject:forKeyedSubscript:", v17, CFSTR("SessionID"));
          sub_100107BA4(CFSTR("IDS Session"), v18);

          objc_msgSend(v9, "reportEvent:detailsFormat:", 10003, CFSTR("%@"), *(_QWORD *)(v9 + 231));
          ++*(_QWORD *)(v9 + 367);
          v19 = mach_absolute_time();
          v20 = *(_QWORD *)(v9 + 639);
          if (v20)
            *(_QWORD *)(v20 + 112) = v19;
        }
      }
    }
  }
}

id sub_100044F8C(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "removeDelegate:", *(_QWORD *)(a1 + 40));
}

char *sub_10004504C(char *a1, void *a2, void *a3)
{
  id v5;
  char *v6;
  char *v7;
  id v8;
  const char *v9;
  void *v10;
  SEL v11;
  id v12;
  xpc_object_t reply;
  void *v14;
  SEL v15;
  char *v16;
  id v18;
  int IsLevelEnabled;
  id v20;
  id v21;
  int v22;
  id v23;
  uint64_t v24;
  uint64_t v25;
  id v26;
  int v27;
  id v28;
  uint64_t v29;
  id v30;
  uint64_t v31;
  objc_super v32;

  v5 = a2;
  v6 = a3;
  v7 = v6;
  if (!a1)
    goto LABEL_16;
  if (!v6)
  {
    v18 = sub_100045324();
    IsLevelEnabled = _NRLogIsLevelEnabled(v18, 17);

    if (IsLevelEnabled)
    {
      v20 = sub_100045324();
      _NRLogWithArgs(v20, 17, "%s called with null connection", "-[TXSContext initWithRequest:onConnection:]");

      v16 = 0;
      goto LABEL_6;
    }
LABEL_16:
    v16 = 0;
    goto LABEL_6;
  }
  v32.receiver = a1;
  v32.super_class = (Class)TXSContext;
  v8 = objc_msgSendSuper2(&v32, "init");
  if (!v8)
  {
    v21 = sub_100045324();
    v22 = _NRLogIsLevelEnabled(v21, 16);

    a1 = "-[TXSContext initWithRequest:onConnection:]";
    if (v22)
    {
      v23 = sub_100045324();
      _NRLogWithArgs(v23, 16, "%s%.30s:%-4d ABORTING: [super init] failed", "", "-[TXSContext initWithRequest:onConnection:]", 125);

    }
    v5 = (id)_os_log_pack_size(12);
    v7 = (char *)&v31 - ((__chkstk_darwin(v5) + 15) & 0xFFFFFFFFFFFFFFF0);
    v24 = *__error();
    v25 = _os_log_pack_fill(v7, v5, v24, &_mh_execute_header, "%{public}s [super init] failed");
    goto LABEL_15;
  }
  v10 = v8;
  objc_setProperty_atomic(v8, v9, v7, 8);
  objc_setProperty_atomic(v10, v11, v5, 16);
  v12 = v5;
  reply = xpc_dictionary_create_reply(v12);
  if (!reply)
  {
    v26 = sub_100045324();
    v27 = _NRLogIsLevelEnabled(v26, 16);

    a1 = "nr_xpc_dictionary_create_reply";
    if (v27)
    {
      v28 = sub_100045324();
      _NRLogWithArgs(v28, 16, "%s%.30s:%-4d ABORTING: xpc_dictionary_create_reply failed", "", "nr_xpc_dictionary_create_reply", 92);

    }
    v5 = (id)_os_log_pack_size(12);
    v7 = (char *)&v31 - ((__chkstk_darwin(v5) + 15) & 0xFFFFFFFFFFFFFFF0);
    v29 = *__error();
    v25 = _os_log_pack_fill(v7, v5, v29, &_mh_execute_header, "%{public}s xpc_dictionary_create_reply failed");
LABEL_15:
    *(_DWORD *)v25 = 136446210;
    *(_QWORD *)(v25 + 4) = a1;
    v30 = sub_100045324();
    _NRLogAbortWithPack(v30, v7);
    goto LABEL_16;
  }
  v14 = reply;

  objc_setProperty_atomic(v10, v15, v14, 24);
  a1 = v10;
  v16 = a1;
LABEL_6:

  return v16;
}

id sub_100045324()
{
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  return (id)qword_1001E4608;
}

void sub_100045364(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001E4608;
  qword_1001E4608 = (uint64_t)v1;

}

id sub_100045394(_QWORD *self, const char *a2)
{
  void *v3;
  _xpc_connection_s *Property;
  uint64_t pid;
  id v6;
  id v7;
  void *v8;
  _BYTE buffer[1024];

  if (!self)
    return 0;
  v3 = (void *)self[4];
  if (!v3)
  {
    Property = (_xpc_connection_s *)objc_getProperty(self, a2, 8, 1);
    pid = xpc_connection_get_pid(Property);
    v6 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
    bzero(buffer, 0x400uLL);
    if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1)
    {
      if (buffer[0])
      {
        v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

        v6 = v7;
      }
    }
    v8 = (void *)self[4];
    self[4] = v6;

    v3 = (void *)self[4];
  }
  return v3;
}

void *sub_1000454D8(void *a1, uint64_t a2, void *a3)
{
  id v5;
  _QWORD *v6;
  const char *v7;
  id v9;
  int IsLevelEnabled;
  id v11;
  uint64_t v12;
  char *v13;
  int *v14;
  uint64_t v15;
  id v16;
  uint64_t v17;
  objc_super v18;

  v5 = a3;
  if (a1)
  {
    v18.receiver = a1;
    v18.super_class = (Class)TXSHandler;
    v6 = objc_msgSendSuper2(&v18, "init");
    if (!v6)
    {
      v9 = sub_100045324();
      IsLevelEnabled = _NRLogIsLevelEnabled(v9, 16);

      if (IsLevelEnabled)
      {
        v11 = sub_100045324();
        _NRLogWithArgs(v11, 16, "%s%.30s:%-4d ABORTING: [super init] failed", "", "-[TXSHandler initWithHandlerFunction:allowedEntitlementGroup:]", 161);

      }
      v12 = _os_log_pack_size(12);
      v13 = (char *)&v17 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
      v14 = __error();
      v15 = _os_log_pack_fill(v13, v12, *v14, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)v15 = 136446210;
      *(_QWORD *)(v15 + 4) = "-[TXSHandler initWithHandlerFunction:allowedEntitlementGroup:]";
      v16 = sub_100045324();
      _NRLogAbortWithPack(v16, v13);
    }
    a1 = v6;
    v6[2] = a2;
    objc_setProperty_atomic(v6, v7, v5, 8);
  }

  return a1;
}

void *sub_100045638(void *a1)
{
  id v1;
  void *v2;
  id v3;
  SEL v4;
  SEL v5;
  NSObject *Property;
  id v7;
  SEL v8;
  id v9;
  SEL v10;
  id v11;
  SEL v12;
  id v13;
  SEL v14;
  SEL v15;
  id v16;
  id v17;
  const char *v18;
  id v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  id v23;
  id v24;
  void *v25;
  SEL v26;
  const char *v27;
  id v29;
  int IsLevelEnabled;
  id v31;
  uint64_t v32;
  char *v33;
  int *v34;
  uint64_t v35;
  id v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  objc_super v41;
  uint64_t v42;
  _BYTE v43[128];

  if (!a1)
    return 0;
  v41.receiver = a1;
  v41.super_class = (Class)TerminusdXPCServer;
  v1 = objc_msgSendSuper2(&v41, "init");
  if (!v1)
  {
    v29 = sub_100045324();
    IsLevelEnabled = _NRLogIsLevelEnabled(v29, 16);

    if (IsLevelEnabled)
    {
      v31 = sub_100045324();
      _NRLogWithArgs(v31, 16, "%s%.30s:%-4d ABORTING: [super init] failed", "", "-[TerminusdXPCServer initInternal]", 1362);

    }
    v32 = _os_log_pack_size(12);
    v33 = (char *)&v37 - ((v32 + 15) & 0xFFFFFFFFFFFFFFF0);
    v34 = __error();
    v35 = _os_log_pack_fill(v33, v32, *v34, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)v35 = 136446210;
    *(_QWORD *)(v35 + 4) = "-[TerminusdXPCServer initInternal]";
    v36 = sub_100045324();
    _NRLogAbortWithPack(v36, v33);
    return 0;
  }
  v2 = v1;
  v3 = sub_10014CFBC();
  objc_setProperty_atomic(v2, v4, v3, 8);

  Property = objc_getProperty(v2, v5, 8, 1);
  dispatch_assert_queue_V2(Property);
  v7 = objc_alloc_init((Class)NSMutableDictionary);
  objc_setProperty_atomic(v2, v8, v7, 32);

  v9 = objc_alloc_init((Class)NSMutableSet);
  objc_setProperty_atomic(v2, v10, v9, 40);

  v11 = objc_alloc_init((Class)NSMutableSet);
  objc_setProperty_atomic(v2, v12, v11, 24);

  sub_100045984(v2);
  v13 = objc_alloc_init((Class)NSMutableArray);
  objc_setProperty_atomic(v2, v14, v13, 48);

  v40 = 0u;
  v39 = 0u;
  v38 = 0u;
  v37 = 0u;
  v16 = objc_getProperty(v2, v15, 40, 1);
  v17 = objc_msgSend(v16, "countByEnumeratingWithState:objects:count:", &v37, v43, 16);
  if (v17)
  {
    v19 = v17;
    v20 = *(_QWORD *)v38;
    do
    {
      v21 = 0;
      do
      {
        if (*(_QWORD *)v38 != v20)
          objc_enumerationMutation(v16);
        v22 = *(_QWORD *)(*((_QWORD *)&v37 + 1) + 8 * (_QWORD)v21);
        v23 = objc_getProperty(v2, v18, 48, 1);
        v42 = v22;
        v24 = v23;
        v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v42, 1, (_QWORD)v37));
        objc_msgSend(v24, "addObject:", v25);

        v21 = (char *)v21 + 1;
      }
      while (v19 != v21);
      v19 = objc_msgSend(v16, "countByEnumeratingWithState:objects:count:", &v37, v43, 16);
    }
    while (v19);
  }

  objc_setProperty_atomic(v2, v26, 0, 40);
  sub_100046FF0(v2, v27);
  return v2;
}

void sub_100045984(void *a1)
{
  id v2;
  id v3;
  void *v4;
  void *v5;
  id v6;
  uint64_t v7;
  id v8;
  void *v9;
  void *v10;
  id v11;
  void *v12;
  void *v13;
  id v14;
  void *v15;
  void *v16;
  id v17;
  id v18;
  void *v19;
  void *v20;
  id v21;
  void *v22;
  void *v23;
  id v24;
  uint64_t v25;
  id v26;
  void *v27;
  void *v28;
  id v29;
  void *v30;
  void *v31;
  id v32;
  void *v33;
  void *v34;
  id v35;
  void *v36;
  void *v37;
  id v38;
  void *v39;
  void *v40;
  id v41;
  uint64_t v42;
  id v43;
  void *v44;
  void *v45;
  id v46;
  void *v47;
  void *v48;
  id v49;
  void *v50;
  void *v51;
  id v52;
  void *v53;
  void *v54;
  id v55;
  void *v56;
  void *v57;
  id v58;
  void *v59;
  void *v60;
  id v61;
  void *v62;
  void *v63;
  id v64;
  uint64_t v65;
  id v66;
  void *v67;
  void *v68;
  id v69;
  uint64_t v70;
  id v71;
  void *v72;
  void *v73;
  id v74;
  void *v75;
  void *v76;
  id v77;
  void *v78;
  void *v79;
  id v80;
  void *v81;
  void *v82;
  id v83;
  void *v84;
  void *v85;
  id v86;
  void *v87;
  void *v88;
  id v89;
  void *v90;
  void *v91;
  id v92;
  void *v93;
  void *v94;
  id v95;
  void *v96;
  void *v97;
  id v98;
  id v99;
  void *v100;
  void *v101;
  id v102;
  id v103;
  void *v104;
  void *v105;
  id v106;
  id v107;
  void *v108;
  void *v109;
  id v110;
  void *v111;
  void *v112;
  id v113;
  void *v114;
  void *v115;
  id v116;
  void *v117;
  void *v118;
  id v119;
  void *v120;
  void *v121;
  id v122;
  void *v123;
  void *v124;
  id v125;
  void *v126;
  void *v127;
  id v128;
  void *v129;
  void *v130;
  id v131;
  void *v132;
  void *v133;
  id v134;
  void *v135;
  void *v136;
  id v137;
  void *v138;
  void *v139;
  id v140;
  void *v141;
  void *v142;
  id v143;
  id v144;
  void *v145;
  void *v146;
  id v147;
  void *v148;
  void *v149;
  id v150;
  id v151;
  void *v152;
  void *v153;
  id v154;
  id v155;
  void *v156;
  void *v157;
  id v158;
  void *v159;
  void *v160;
  id v161;
  void *v162;
  void *v163;
  id v164;
  id v165;
  void *v166;
  void *v167;
  id v168;
  void *v169;
  id v170;
  void *v171;
  id v172;
  void *v173;
  id v174;
  void *v175;
  id v176;
  void *v177;
  id v178;
  void *v179;
  id v180;
  void *v181;
  id v182;
  void *v183;
  id v184;
  void *v185;
  id v186;
  void *v187;
  id v188;
  void *v189;
  id v190;
  void *v191;
  id v192;
  void *v193;
  id v194;
  void *v195;
  id v196;
  void *v197;
  id v198;
  void *v199;
  id v200;
  void *v201;
  id v202;
  void *v203;
  id v204;
  void *v205;
  id v206;
  void *v207;
  id v208;
  void *v209;
  id v210;
  void *v211;
  id v212;
  void *v213;
  id v214;
  void *v215;
  id v216;
  void *v217;
  id v218;
  void *v219;
  id v220;
  void *v221;
  id v222;
  void *v223;
  id v224;
  void *v225;
  id v226;
  void *v227;
  id v228;
  void *v229;
  id v230;
  void *v231;
  id v232;
  void *v233;
  id v234;
  void *v235;
  id v236;
  void *v237;
  id v238;
  void *v239;
  id v240;
  void *v241;
  id v242;
  void *v243;
  id v244;
  void *v245;
  id v246;
  void *v247;
  id v248;
  void *v249;
  id v250;
  void *v251;
  id v252;
  void *v253;
  id v254;
  void *v255;
  id v256;
  void *v257;
  id v258;
  void *v259;
  id v260;
  void *v261;
  id v262;
  void *v263;
  id v264;
  void *v265;

  v2 = objc_alloc((Class)NSString);
  v3 = objc_msgSend(v2, "initWithUTF8String:", nrXPCEntitlementPing);
  v264 = v3;
  v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v264, 1));
  v265 = v4;
  v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v265, 1));
  sub_100048D58(a1, (uint64_t)sub_100048B3C, 1, v5);

  v6 = objc_alloc((Class)NSString);
  v7 = nrXPCEntitlementCompanionLink;
  v8 = objc_msgSend(v6, "initWithUTF8String:", nrXPCEntitlementCompanionLink);
  v262 = v8;
  v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v262, 1));
  v263 = v9;
  v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v263, 1));
  sub_100048D58(a1, (uint64_t)sub_100049218, 25, v10);

  v11 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v7);
  v260 = v11;
  v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v260, 1));
  v261 = v12;
  v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v261, 1));
  sub_100048D58(a1, (uint64_t)sub_1000493F0, 2, v13);

  v14 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v7);
  v258 = v14;
  v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v258, 1));
  v259 = v15;
  v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v259, 1));
  sub_100048D58(a1, (uint64_t)sub_1000495C8, 3, v16);

  v17 = objc_alloc((Class)NSString);
  v18 = objc_msgSend(v17, "initWithUTF8String:", nrXPCEntitlementCompanionLinkIsEnabled);
  v256 = v18;
  v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v256, 1));
  v257 = v19;
  v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v257, 1));
  sub_100048D58(a1, (uint64_t)sub_1000497A0, 12, v20);

  v21 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v7);
  v254 = v21;
  v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v254, 1));
  v255 = v22;
  v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v255, 1));
  sub_100048D58(a1, (uint64_t)sub_1000499CC, 4, v23);

  v24 = objc_alloc((Class)NSString);
  v25 = nrXPCEntitlementDiagnostic;
  v26 = objc_msgSend(v24, "initWithUTF8String:", nrXPCEntitlementDiagnostic);
  v252 = v26;
  v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v252, 1));
  v253 = v27;
  v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v253, 1));
  sub_100048D58(a1, (uint64_t)sub_100049C08, 21, v28);

  v29 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v25);
  v250 = v29;
  v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v250, 1));
  v251 = v30;
  v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v251, 1));
  sub_100048D58(a1, (uint64_t)sub_10004A144, 22, v31);

  v32 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v25);
  v248 = v32;
  v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v248, 1));
  v249 = v33;
  v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v249, 1));
  sub_100048D58(a1, (uint64_t)sub_10004A6C8, 33, v34);

  v35 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v7);
  v246 = v35;
  v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v246, 1));
  v247 = v36;
  v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v247, 1));
  sub_100048D58(a1, (uint64_t)sub_10004AAD0, 5, v37);

  v38 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v7);
  v244 = v38;
  v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v244, 1));
  v245 = v39;
  v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v245, 1));
  sub_100048D58(a1, (uint64_t)sub_10004AD20, 48, v40);

  v41 = objc_alloc((Class)NSString);
  v42 = nrXPCEntitlementDevicesRead;
  v43 = objc_msgSend(v41, "initWithUTF8String:", nrXPCEntitlementDevicesRead);
  v242 = v43;
  v44 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v242, 1));
  v243 = v44;
  v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v243, 1));
  sub_100048D58(a1, (uint64_t)sub_10004B054, 6, v45);

  v46 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v7);
  v240 = v46;
  v47 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v240, 1));
  v241 = v47;
  v48 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v241, 1));
  sub_100048D58(a1, (uint64_t)sub_10004B8B0, 7, v48);

  v49 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v7);
  v238 = v49;
  v50 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v238, 1));
  v239 = v50;
  v51 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v239, 1));
  sub_100048D58(a1, (uint64_t)sub_10004BFE8, 31, v51);

  v52 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v42);
  v236 = v52;
  v53 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v236, 1));
  v237 = v53;
  v54 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v237, 1));
  sub_100048D58(a1, (uint64_t)sub_10004C664, 13, v54);

  v55 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v42);
  v234 = v55;
  v56 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v234, 1));
  v235 = v56;
  v57 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v235, 1));
  sub_100048D58(a1, (uint64_t)sub_10004CCEC, 50, v57);

  v58 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v42);
  v232 = v58;
  v59 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v232, 1));
  v233 = v59;
  v60 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v233, 1));
  sub_100048D58(a1, (uint64_t)sub_10004D408, 46, v60);

  v61 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v42);
  v230 = v61;
  v62 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v230, 1));
  v231 = v62;
  v63 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v231, 1));
  sub_100048D58(a1, (uint64_t)sub_10004DBE8, 45, v63);

  v64 = objc_alloc((Class)NSString);
  v65 = nrXPCEntitlementTesting;
  v66 = objc_msgSend(v64, "initWithUTF8String:", nrXPCEntitlementTesting);
  v228 = v66;
  v67 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v228, 1));
  v229 = v67;
  v68 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v229, 1));
  sub_100048D58(a1, (uint64_t)sub_10004DDF0, 20, v68);

  v69 = objc_alloc((Class)NSString);
  v70 = nrXPCEntitlementDevicesWrite;
  v71 = objc_msgSend(v69, "initWithUTF8String:", nrXPCEntitlementDevicesWrite);
  v226 = v71;
  v72 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v226, 1));
  v227 = v72;
  v73 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v227, 1));
  sub_100048D58(a1, (uint64_t)sub_10004E19C, 14, v73);

  v74 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v70);
  v224 = v74;
  v75 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v224, 1));
  v225 = v75;
  v76 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v225, 1));
  sub_100048D58(a1, (uint64_t)sub_10004F3A8, 15, v76);

  v77 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v70);
  v222 = v77;
  v78 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v222, 1));
  v223 = v78;
  v79 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v223, 1));
  sub_100048D58(a1, (uint64_t)sub_10004F978, 19, v79);

  v80 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v70);
  v220 = v80;
  v81 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v220, 1));
  v221 = v81;
  v82 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v221, 1));
  sub_100048D58(a1, (uint64_t)sub_10004FE6C, 16, v82);

  v83 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v70);
  v218 = v83;
  v84 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v218, 1));
  v219 = v84;
  v85 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v219, 1));
  sub_100048D58(a1, (uint64_t)sub_1000503C8, 17, v85);

  v86 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v65);
  v216 = v86;
  v87 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v216, 1));
  v217 = v87;
  v88 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v217, 1));
  sub_100048D58(a1, (uint64_t)sub_100050924, 18, v88);

  v89 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v65);
  v214 = v89;
  v90 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v214, 1));
  v215 = v90;
  v91 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v215, 1));
  sub_100048D58(a1, (uint64_t)sub_100050CD0, 47, v91);

  v92 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v65);
  v212 = v92;
  v93 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v212, 1));
  v213 = v93;
  v94 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v213, 1));
  sub_100048D58(a1, (uint64_t)sub_100050F38, 23, v94);

  v95 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v65);
  v210 = v95;
  v96 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v210, 1));
  v211 = v96;
  v97 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v211, 1));
  sub_100048D58(a1, (uint64_t)sub_100051158, 24, v97);

  v98 = objc_alloc((Class)NSString);
  v99 = objc_msgSend(v98, "initWithUTF8String:", nrXPCEntitlementDeviceMonitor);
  v208 = v99;
  v100 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v208, 1));
  v209 = v100;
  v101 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v209, 1));
  sub_100048D58(a1, (uint64_t)sub_100051378, 10, v101);

  v102 = objc_alloc((Class)NSString);
  v103 = objc_msgSend(v102, "initWithUTF8String:", nrXPCEntitlementDevicePreferences);
  v206 = v103;
  v104 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v206, 1));
  v207 = v104;
  v105 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v207, 1));
  sub_100048D58(a1, (uint64_t)sub_100051DD4, 11, v105);

  v106 = objc_alloc((Class)NSString);
  v107 = objc_msgSend(v106, "initWithUTF8String:", nrXPCEntitlementTestLinkRecommendation);
  v204 = v107;
  v108 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v204, 1));
  v205 = v108;
  v109 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v205, 1));
  sub_100048D58(a1, (uint64_t)sub_100052D10, 26, v109);

  v110 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v65);
  v202 = v110;
  v111 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v202, 1));
  v203 = v111;
  v112 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v203, 1));
  sub_100048D58(a1, (uint64_t)sub_100052EE0, 27, v112);

  v113 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v65);
  v200 = v113;
  v114 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v200, 1));
  v201 = v114;
  v115 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v201, 1));
  sub_100048D58(a1, (uint64_t)sub_100053108, 28, v115);

  v116 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v65);
  v198 = v116;
  v117 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v198, 1));
  v199 = v117;
  v118 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v199, 1));
  sub_100048D58(a1, (uint64_t)sub_100053774, 38, v118);

  v119 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v65);
  v196 = v119;
  v120 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v196, 1));
  v197 = v120;
  v121 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v197, 1));
  sub_100048D58(a1, (uint64_t)sub_1000539F0, 29, v121);

  v122 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v65);
  v194 = v122;
  v123 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v194, 1));
  v195 = v123;
  v124 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v195, 1));
  sub_100048D58(a1, (uint64_t)sub_100053DDC, 37, v124);

  v125 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v65);
  v192 = v125;
  v126 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v192, 1));
  v193 = v126;
  v127 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v193, 1));
  sub_100048D58(a1, (uint64_t)sub_100054060, 30, v127);

  v128 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v65);
  v190 = v128;
  v129 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v190, 1));
  v191 = v129;
  v130 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v191, 1));
  sub_100048D58(a1, (uint64_t)sub_10005444C, 51, v130);

  v131 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v65);
  v188 = v131;
  v132 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v188, 1));
  v189 = v132;
  v133 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v189, 1));
  sub_100048D58(a1, (uint64_t)sub_100054868, 39, v133);

  v134 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v65);
  v186 = v134;
  v135 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v186, 1));
  v187 = v135;
  v136 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v187, 1));
  sub_100048D58(a1, (uint64_t)sub_100054D5C, 40, v136);

  v137 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v65);
  v184 = v137;
  v138 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v184, 1));
  v185 = v138;
  v139 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v185, 1));
  sub_100048D58(a1, (uint64_t)sub_1000555A0, 43, v139);

  v140 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v65);
  v182 = v140;
  v141 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v182, 1));
  v183 = v141;
  v142 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v183, 1));
  sub_100048D58(a1, (uint64_t)sub_1000559C4, 34, v142);

  v143 = objc_alloc((Class)NSString);
  v144 = objc_msgSend(v143, "initWithUTF8String:", nrXPCEntitlementFixedInterfaceMode);
  v180 = v144;
  v145 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v180, 1));
  v181 = v145;
  v146 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v181, 1));
  sub_100048D58(a1, (uint64_t)sub_100055EE4, 32, v146);

  v147 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v42);
  v178 = v147;
  v148 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v178, 1));
  v179 = v148;
  v149 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v179, 1));
  sub_100048D58(a1, (uint64_t)sub_100056470, 35, v149);

  v150 = objc_alloc((Class)NSString);
  v151 = objc_msgSend(v150, "initWithUTF8String:", nrXPCEntitlementRetryConnections);
  v176 = v151;
  v152 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v176, 1));
  v177 = v152;
  v153 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v177, 1));
  sub_100048D58(a1, (uint64_t)sub_100056960, 36, v153);

  v154 = objc_alloc((Class)NSString);
  v155 = objc_msgSend(v154, "initWithUTF8String:", nrXPCEntitlementXPCComm);
  v174 = v155;
  v156 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v174, 1));
  v175 = v156;
  v157 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v175, 1));
  sub_100048D58(a1, (uint64_t)sub_100056D38, 41, v157);

  v158 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v65);
  v172 = v158;
  v159 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v172, 1));
  v173 = v159;
  v160 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v173, 1));
  sub_100048D58(a1, (uint64_t)sub_100057B54, 42, v160);

  v161 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v65);
  v170 = v161;
  v162 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v170, 1));
  v171 = v162;
  v163 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v171, 1));
  sub_100048D58(a1, (uint64_t)sub_100057EAC, 44, v163);

  v164 = objc_alloc((Class)NSString);
  v165 = objc_msgSend(v164, "initWithUTF8String:", nrXPCEntitlementPairing);
  v168 = v165;
  v166 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v168, 1));
  v169 = v166;
  v167 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v169, 1));
  sub_100048D58(a1, (uint64_t)sub_10005807C, 49, v167);

}

void sub_100046FF0(void *a1, const char *a2)
{
  NSObject *Property;
  const char *v4;
  SEL v5;
  NSObject *v6;
  xpc_connection_t mach_service;
  SEL v8;
  SEL v9;
  const char *v10;
  id v11;
  SEL v12;
  _xpc_connection_s *v13;
  SEL v14;
  _xpc_connection_s *v15;
  id v16;
  int IsLevelEnabled;
  id v18;
  uint64_t v19;
  char *v20;
  int *v21;
  uint64_t v22;
  id v23;
  id v24;
  int v25;
  id v26;
  uint64_t v27;
  char *v28;
  int *v29;
  uint64_t v30;
  id v31;
  _QWORD handler[5];
  id v33;
  id location;

  Property = objc_getProperty(a1, a2, 8, 1);
  dispatch_assert_queue_V2(Property);
  v4 = (const char *)nrXPCServiceName;
  v6 = objc_getProperty(a1, v5, 8, 1);
  mach_service = xpc_connection_create_mach_service(v4, v6, 1uLL);
  objc_setProperty_atomic(a1, v8, mach_service, 16);

  if (!objc_getProperty(a1, v9, 16, 1))
  {
    v16 = sub_100045324();
    IsLevelEnabled = _NRLogIsLevelEnabled(v16, 16);

    if (IsLevelEnabled)
    {
      v18 = sub_100045324();
      _NRLogWithArgs(v18, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (self.listener) != ((void *)0)", "", "-[TerminusdXPCServer startXPCListener]", 1591);

    }
    v19 = _os_log_pack_size(12);
    v20 = (char *)handler - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
    v21 = __error();
    v22 = _os_log_pack_fill(v20, v19, *v21, &_mh_execute_header, "%{public}s Assertion Failed: (self.listener) != ((void *)0)");
    *(_DWORD *)v22 = 136446210;
    *(_QWORD *)(v22 + 4) = "-[TerminusdXPCServer startXPCListener]";
    v23 = sub_100045324();
    _NRLogAbortWithPack(v23, v20);
LABEL_10:
    __break(1u);
  }
  v11 = objc_getProperty(a1, v10, 16, 1);
  if (xpc_get_type(v11) != (xpc_type_t)&_xpc_type_connection)
  {
    v24 = sub_100045324();
    v25 = _NRLogIsLevelEnabled(v24, 16);

    if (v25)
    {
      v26 = sub_100045324();
      _NRLogWithArgs(v26, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (&_xpc_type_connection) == xpc_get_type(self.listener)", "", "-[TerminusdXPCServer startXPCListener]", 1592);

    }
    v27 = _os_log_pack_size(12);
    v28 = (char *)handler - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
    v29 = __error();
    v30 = _os_log_pack_fill(v28, v27, *v29, &_mh_execute_header, "%{public}s Assertion Failed: (&_xpc_type_connection) == xpc_get_type(self.listener)");
    *(_DWORD *)v30 = 136446210;
    *(_QWORD *)(v30 + 4) = "-[TerminusdXPCServer startXPCListener]";
    v31 = sub_100045324();
    _NRLogAbortWithPack(v31, v28);
    goto LABEL_10;
  }
  objc_initWeak(&location, a1);
  v13 = (_xpc_connection_s *)objc_getProperty(a1, v12, 16, 1);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472;
  handler[2] = sub_100047340;
  handler[3] = &unk_1001B6768;
  objc_copyWeak(&v33, &location);
  handler[4] = a1;
  xpc_connection_set_event_handler(v13, handler);

  v15 = (_xpc_connection_s *)objc_getProperty(a1, v14, 16, 1);
  xpc_connection_resume(v15);

  objc_destroyWeak(&v33);
  objc_destroyWeak(&location);
}

void sub_100047304(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 48));
  _Unwind_Resume(a1);
}

void sub_100047340(uint64_t a1, void *a2)
{
  id v3;
  id WeakRetained;
  xpc_type_t type;
  char *v6;
  id v7;
  SEL v8;
  id v9;
  const char *v10;
  _xpc_connection_s *v11;
  id Property;
  NSObject *v13;
  _xpc_connection_s *v14;
  const char *v15;
  id v16;
  id v17;
  id v18;
  char IsLevelEnabled;
  id v20;
  pid_t pid;
  id v22;
  int v23;
  _QWORD handler[6];
  id v25;
  id location;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t (*v30)(uint64_t, uint64_t);
  void (*v31)(uint64_t);
  id v32;

  v3 = a2;
  if (v3)
  {
    WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
    if (WeakRetained)
    {
      type = xpc_get_type(v3);
      if (type == (xpc_type_t)&_xpc_type_connection)
      {
        v27 = 0;
        v28 = &v27;
        v29 = 0x3032000000;
        v30 = sub_1000476FC;
        v31 = sub_10004770C;
        v7 = v3;
        v32 = v7;
        v9 = objc_getProperty(WeakRetained, v8, 48, 1);
        LOBYTE(v7) = sub_100047714(v7, v9);

        if ((v7 & 1) != 0)
        {
          v11 = (_xpc_connection_s *)v28[5];
          Property = *(id *)(a1 + 32);
          if (Property)
            Property = objc_getProperty(Property, v10, 8, 1);
          v13 = Property;
          xpc_connection_set_target_queue(v11, v13);

          objc_initWeak(&location, WeakRetained);
          v14 = (_xpc_connection_s *)v28[5];
          handler[0] = _NSConcreteStackBlock;
          handler[1] = 3221225472;
          handler[2] = sub_100047958;
          handler[3] = &unk_1001B6740;
          handler[5] = &v27;
          objc_copyWeak(&v25, &location);
          handler[4] = *(_QWORD *)(a1 + 32);
          xpc_connection_set_event_handler(v14, handler);
          xpc_connection_resume((xpc_connection_t)v28[5]);
          v16 = *(id *)(a1 + 32);
          if (v16)
            v16 = objc_getProperty(v16, v15, 24, 1);
          v17 = v16;
          objc_msgSend(v17, "addObject:", v28[5]);

          objc_destroyWeak(&v25);
          objc_destroyWeak(&location);
        }
        else
        {
          if (qword_1001E4610 != -1)
            dispatch_once(&qword_1001E4610, &stru_1001B6788);
          v18 = (id)qword_1001E4608;
          IsLevelEnabled = _NRLogIsLevelEnabled(v18, 16);

          if ((IsLevelEnabled & 1) != 0)
          {
            if (qword_1001E4610 != -1)
              dispatch_once(&qword_1001E4610, &stru_1001B6788);
            v20 = (id)qword_1001E4608;
            pid = xpc_connection_get_pid((xpc_connection_t)v28[5]);
            _NRLogWithArgs(v20, 16, "%s%.30s:%-4d client pid %d does not have any known entitlement", "", "-[TerminusdXPCServer startXPCListener]_block_invoke", 1606, pid);

          }
          xpc_connection_cancel((xpc_connection_t)v28[5]);
        }
        _Block_object_dispose(&v27, 8);

      }
      else if (type == (xpc_type_t)&_xpc_type_error)
      {
        v6 = xpc_copy_description(v3);
        if (qword_1001E4610 != -1)
          dispatch_once(&qword_1001E4610, &stru_1001B6788);
        if (_NRLogIsLevelEnabled(qword_1001E4608, 17))
        {
          if (qword_1001E4610 != -1)
            dispatch_once(&qword_1001E4610, &stru_1001B6788);
          _NRLogWithArgs(qword_1001E4608, 17, "FATAL: XPC listener received error %s", v6);
        }
        if (v6)
          free(v6);
      }
    }
  }
  else
  {
    v22 = sub_100045324();
    v23 = _NRLogIsLevelEnabled(v22, 17);

    if (!v23)
      goto LABEL_28;
    WeakRetained = sub_100045324();
    _NRLogWithArgs(WeakRetained, 17, "%s called with null msg", "-[TerminusdXPCServer startXPCListener]_block_invoke");
  }

LABEL_28:
}

void sub_1000476C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location,char a21)
{
  id *v21;

  objc_destroyWeak(v21);
  objc_destroyWeak(&location);
  _Block_object_dispose(&a21, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000476FC(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_10004770C(uint64_t a1)
{

}

uint64_t sub_100047714(void *a1, void *a2)
{
  uint64_t v3;
  void *v4;
  id v5;
  id v6;
  id v7;
  id v8;
  id v9;
  uint64_t v10;
  uint64_t v11;
  id v12;
  id v13;
  void *v14;
  _BOOL4 value;
  uint64_t v16;
  id obj;
  uint64_t v19;
  id v20;
  id v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  _BYTE v30[128];
  _BYTE v31[128];

  v21 = a1;
  v22 = 0u;
  v23 = 0u;
  v24 = 0u;
  v25 = 0u;
  obj = a2;
  v20 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v22, v30, 16);
  if (v20)
  {
    v19 = *(_QWORD *)v23;
    while (2)
    {
      v3 = 0;
      while (2)
      {
        if (*(_QWORD *)v23 != v19)
          objc_enumerationMutation(obj);
        v4 = *(void **)(*((_QWORD *)&v22 + 1) + 8 * v3);
        v5 = v21;
        v6 = v4;
        v26 = 0u;
        v27 = 0u;
        v28 = 0u;
        v29 = 0u;
        v7 = v6;
        v8 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v26, v31, 16);
        if (!v8)
        {
LABEL_21:

          v16 = 1;
          goto LABEL_22;
        }
        v9 = v8;
        v10 = *(_QWORD *)v27;
LABEL_10:
        v11 = 0;
        while (1)
        {
          if (*(_QWORD *)v27 != v10)
            objc_enumerationMutation(v7);
          v12 = *(id *)(*((_QWORD *)&v26 + 1) + 8 * v11);
          v13 = v5;
          v14 = (void *)xpc_connection_copy_entitlement_value(v13, objc_msgSend(v12, "UTF8String"));

          if (!v14 || xpc_get_type(v14) != (xpc_type_t)&_xpc_type_BOOL)
            break;
          value = xpc_BOOL_get_value(v14);

          if (!value)
            goto LABEL_5;
          if (v9 == (id)++v11)
          {
            v9 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v26, v31, 16);
            if (v9)
              goto LABEL_10;
            goto LABEL_21;
          }
        }

LABEL_5:
        if ((id)++v3 != v20)
          continue;
        break;
      }
      v20 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v22, v30, 16);
      if (v20)
        continue;
      break;
    }
  }
  v16 = 0;
LABEL_22:

  return v16;
}

void sub_100047958(uint64_t a1, void *a2)
{
  id v3;
  id WeakRetained;
  xpc_type_t type;
  const char *v6;
  char *v7;
  void *v8;
  id v9;
  id v10;
  SEL v11;
  NSObject *v12;
  char *v13;
  uint64_t uint64;
  SEL v15;
  id v16;
  void *v17;
  uint64_t (**v18)(_QWORD);
  const char *v19;
  id v20;
  id v21;
  const char *v22;
  int64_t v23;
  id Property;
  id *v25;
  id v26;
  NSObject *v27;
  id v28;
  id v29;
  id v30;
  uint64_t v31;
  void *i;
  uint64_t v33;
  id v34;
  id v35;
  id v36;
  id v37;
  id v38;
  uint64_t v39;
  void *j;
  _QWORD *v41;
  void *v42;
  id v43;
  NSObject *v44;
  void *k;
  uint64_t v46;
  id v47;
  uint64_t v48;
  id v49;
  NSObject *v50;
  _xpc_connection_s *v51;
  NSObject *v52;
  void *context;
  void *v54;
  id v55;
  void *v56;
  id v57;
  void *v58;
  void *v59;
  void *v60;
  id v61;
  id v62;
  void *v63;
  void *v64;
  id v65;
  uint64_t pid;
  uint64_t v67;
  void *v68;
  int v69;
  uint64_t v70;
  void *v71;
  _xpc_connection_s *v72;
  NSObject *v73;
  void *v74;
  void *v75;
  id v76;
  id v77;
  void *v78;
  uint64_t v79;
  void *v80;
  int v81;
  uint64_t v82;
  void *v83;
  void *v84;
  uint64_t v85;
  id v86;
  int v87;
  id v88;
  id v89;
  id v90;
  id v91;
  id v92;
  uint64_t v93;
  void *m;
  _QWORD *v95;
  void *v96;
  id v97;
  id v98;
  id v99;
  id v100;
  uint64_t v101;
  void *n;
  uint64_t v103;
  void *v104;
  char *v105;
  id v106;
  const char *v107;
  id v108;
  void *v109;
  _xpc_connection_s *v110;
  uint64_t v111;
  id v112;
  id v113;
  void *v114;
  id v115;
  void *StringFromNRXPCType;
  const char *v117;
  void *v118;
  _xpc_connection_s *v119;
  uint64_t v120;
  id v121;
  id v122;
  void *v123;
  id v124;
  SEL v125;
  id v126;
  id v127;
  uint64_t v128;
  void *v129;
  id v130;
  int v131;
  id v132;
  int IsLevelEnabled;
  id v134;
  int v135;
  id v136;
  id v137;
  int v138;
  id v139;
  id v140;
  uint64_t v141;
  xpc_object_t object;
  uint64_t v143;
  id v144;
  id v145;
  id obj;
  id v147;
  uint64_t v148;
  id v149;
  id *v150;
  __int128 v151;
  __int128 v152;
  __int128 v153;
  __int128 v154;
  __int128 v155;
  __int128 v156;
  __int128 v157;
  __int128 v158;
  _BYTE buffer[1024];
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;

  v3 = a2;
  object = v3;
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40))
  {
    if (!v3)
    {
      v132 = sub_100045324();
      IsLevelEnabled = _NRLogIsLevelEnabled(v132, 17);

      if (!IsLevelEnabled)
        goto LABEL_165;
      WeakRetained = sub_100045324();
      _NRLogWithArgs(WeakRetained, 17, "%s called with null request", "-[TerminusdXPCServer startXPCListener]_block_invoke_2");
      goto LABEL_164;
    }
    WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
    if (WeakRetained)
    {
      type = xpc_get_type(object);
      if (type != (xpc_type_t)&_xpc_type_dictionary)
      {
        if (type != (xpc_type_t)&_xpc_type_error)
        {
          v7 = xpc_copy_description(object);
          if (qword_1001E4610 != -1)
            dispatch_once(&qword_1001E4610, &stru_1001B6788);
          if (_NRLogIsLevelEnabled(qword_1001E4608, 16))
          {
            if (qword_1001E4610 != -1)
              dispatch_once(&qword_1001E4610, &stru_1001B6788);
            _NRLogWithArgs(qword_1001E4608, 16, "%s%.30s:%-4d received unknown type for request: %s", "", "-[TerminusdXPCServer startXPCListener]_block_invoke_2", 1653, v7);
          }
          if (v7)
            free(v7);
          goto LABEL_164;
        }
        Property = *(id *)(a1 + 32);
        if (Property)
          Property = objc_getProperty(Property, v6, 24, 1);
        objc_msgSend(Property, "removeObject:", *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40));
        objc_opt_self(NRLinkDirector);
        if (qword_1001E4710 != -1)
          dispatch_once(&qword_1001E4710, &stru_1001B6E60);
        v25 = (id *)(id)qword_1001E4708;
        v26 = *(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
        v141 = a1;
        v150 = v25;
        if (v25)
        {
          v27 = sub_10014CFBC();
          dispatch_assert_queue_V2(v27);

          if (v26)
          {
            v157 = 0u;
            v158 = 0u;
            v155 = 0u;
            v156 = 0u;
            v28 = v150[25];
            v29 = objc_msgSend(v28, "countByEnumeratingWithState:objects:count:", &v155, buffer, 16);
            if (v29)
            {
              v30 = v29;
              v31 = *(_QWORD *)v156;
              do
              {
                for (i = 0; i != v30; i = (char *)i + 1)
                {
                  if (*(_QWORD *)v156 != v31)
                    objc_enumerationMutation(v28);
                  v33 = objc_claimAutoreleasedReturnValue(objc_msgSend(v150[25], "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v155 + 1) + 8 * (_QWORD)i)));
                  v34 = v26;
                  if (v33)
                  {
                    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v33 + 104));
                    objc_msgSend(*(id *)(v33 + 168), "removeObject:", v34);
                  }

                }
                v30 = objc_msgSend(v28, "countByEnumeratingWithState:objects:count:", &v155, buffer, 16);
              }
              while (v30);
            }

            v35 = objc_msgSend(v150[26], "copy");
            v151 = 0u;
            v152 = 0u;
            v153 = 0u;
            v154 = 0u;
            v36 = v35;
            v37 = objc_msgSend(v36, "countByEnumeratingWithState:objects:count:", &v151, &v160, 16);
            if (v37)
            {
              v38 = v37;
              v39 = *(_QWORD *)v152;
              do
              {
                for (j = 0; j != v38; j = (char *)j + 1)
                {
                  if (*(_QWORD *)v152 != v39)
                    objc_enumerationMutation(v36);
                  v41 = *(_QWORD **)(*((_QWORD *)&v151 + 1) + 8 * (_QWORD)j);
                  if (v41 && (id)v41[2] == v26)
                  {
                    objc_msgSend(v150[26], "removeObject:", *(_QWORD *)(*((_QWORD *)&v151 + 1) + 8 * (_QWORD)j));
                    v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v41, "description"));
                    sub_100121E18(0, 1017, 0, v42);

                  }
                }
                v38 = objc_msgSend(v36, "countByEnumeratingWithState:objects:count:", &v151, &v160, 16);
              }
              while (v38);
            }

            a1 = v141;
          }
          else
          {
            v134 = sub_1000A2640();
            v135 = _NRLogIsLevelEnabled(v134, 17);

            if (v135)
            {
              v136 = sub_1000A2640();
              _NRLogWithArgs(v136, 17, "%s called with null connection", "-[NRLinkDirector removeDeviceMonitorConnection:]");

            }
          }
        }

        v43 = *(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
        if (v150)
        {
          v44 = sub_10014CFBC();
          dispatch_assert_queue_V2(v44);

          if (v43)
          {
            v140 = WeakRetained;
            v157 = 0u;
            v158 = 0u;
            v155 = 0u;
            v156 = 0u;
            obj = v150[25];
            v149 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v155, buffer, 16);
            if (v149)
            {
              v147 = v43;
              v148 = *(_QWORD *)v156;
              do
              {
                for (k = 0; k != v149; k = (char *)k + 1)
                {
                  if (*(_QWORD *)v156 != v148)
                    objc_enumerationMutation(obj);
                  v46 = objc_claimAutoreleasedReturnValue(objc_msgSend(v150[25], "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v155 + 1) + 8 * (_QWORD)k)));
                  v47 = v43;
                  if (v46)
                  {
                    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v46 + 104));
                    v48 = *(_QWORD *)(v46 + 184);
                    v49 = v47;
                    if (v48)
                    {
                      v50 = *(NSObject **)(v48 + 24);
                      if (v50)
                        dispatch_assert_queue_V2(v50);
                      v51 = (_xpc_connection_s *)v49;
                      v52 = *(NSObject **)(v48 + 24);
                      if (v52)
                        dispatch_assert_queue_V2(v52);
                      if (objc_msgSend(*(id *)(v48 + 32), "count"))
                      {
                        context = xpc_connection_get_context(v51);
                        if (context)
                        {
                          v54 = context;
                          v55 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", context);
                          v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v48 + 32), "objectForKeyedSubscript:", v55));
                          if (v56)
                          {
                            v57 = v55;
                            v144 = v55;
                            v145 = v47;
                            if (v57)
                            {
                              v58 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", "-"));
                              v59 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v57, "componentsSeparatedByString:", v58));
                              v143 = v46;
                              v60 = v54;
                              v61 = v49;
                              v62 = v57;
                              v63 = v56;
                              v64 = v59;
                              v65 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v59, "firstObject"));

                              v56 = v63;
                              v57 = v62;
                              v49 = v61;
                              v54 = v60;
                              v46 = v143;

                              if (!v65)
                                goto LABEL_67;
                            }
                            else
                            {
                              if (qword_1001E4990 != -1)
                                dispatch_once(&qword_1001E4990, &stru_1001B7EB8);
                              v86 = (id)qword_1001E4988;
                              v87 = _NRLogIsLevelEnabled(v86, 17);

                              if (v87)
                              {
                                if (qword_1001E4990 != -1)
                                  dispatch_once(&qword_1001E4990, &stru_1001B7EB8);
                                v88 = (id)qword_1001E4988;
                                _NRLogWithArgs(v88, 17, "%s called with null contextKey", "NRDPMCopyClientNameFromContextString");

                              }
LABEL_67:
                              pid = xpc_connection_get_pid(v51);
                              v65 = sub_100109ADC(pid, 0);
                            }
                            sub_100114C4C(v48, v65);
                            free(v54);
                            xpc_connection_set_context(v51, 0);
                            v68 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v48 + 16), v67);
                            v69 = _NRLogIsLevelEnabled(v68, 0);

                            if (v69)
                            {
                              v71 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v48 + 16), v70);
                              _NRLogWithArgs(v71, 0, "%s%.30s:%-4d Removing preferences for %@ : %@", "", "-[NRDevicePreferencesManager removeLinkPreferencesForConnection:]", 210, v57, v56);

                            }
                            sub_100114E1C(v48, v57);

                            v55 = v144;
                            v47 = v145;
                          }

                        }
                      }

                      v72 = v51;
                      v73 = *(NSObject **)(v48 + 24);
                      if (v73)
                        dispatch_assert_queue_V2(v73);
                      if (objc_msgSend(*(id *)(v48 + 40), "count"))
                      {
                        v74 = xpc_connection_get_context(v72);
                        if (v74)
                        {
                          v75 = v74;
                          v76 = v47;
                          v77 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v74);
                          v78 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v48 + 40), "objectForKeyedSubscript:", v77));
                          if (v78)
                          {
                            free(v75);
                            xpc_connection_set_context(v72, 0);
                            v80 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v48 + 16), v79);
                            v81 = _NRLogIsLevelEnabled(v80, 0);

                            if (v81)
                            {
                              v83 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v48 + 16), v82);
                              v84 = (void *)_NRCopyPolicyTrafficClassifiersDescription(v78);
                              _NRLogWithArgs(v83, 0, "%s%.30s:%-4d Removing policy traffic classifiers for %@ : %@", "", "-[NRDevicePreferencesManager removePolicyTrafficClassifiersForConnection:]", 296, v77, v84);

                            }
                            objc_msgSend(*(id *)(v48 + 40), "setObject:forKeyedSubscript:", 0, v77);
                            sub_100114958(v48);
                          }

                          v47 = v76;
                        }
                      }

                      v43 = v147;
                    }

                    v85 = *(_QWORD *)(v46 + 184);
                    if (!v85 || !*(_BYTE *)(v85 + 8))
                      sub_1000D8FF0(v46, *(void **)(v46 + 616));
                  }

                }
                v149 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v155, buffer, 16);
              }
              while (v149);
            }

            v89 = objc_msgSend(v150[27], "copy");
            v151 = 0u;
            v152 = 0u;
            v153 = 0u;
            v154 = 0u;
            v90 = v89;
            v91 = objc_msgSend(v90, "countByEnumeratingWithState:objects:count:", &v151, &v160, 16);
            WeakRetained = v140;
            if (v91)
            {
              v92 = v91;
              v93 = *(_QWORD *)v152;
              do
              {
                for (m = 0; m != v92; m = (char *)m + 1)
                {
                  if (*(_QWORD *)v152 != v93)
                    objc_enumerationMutation(v90);
                  v95 = *(_QWORD **)(*((_QWORD *)&v151 + 1) + 8 * (_QWORD)m);
                  if (v95 && (id)v95[2] == v43)
                  {
                    objc_msgSend(v150[27], "removeObject:", *(_QWORD *)(*((_QWORD *)&v151 + 1) + 8 * (_QWORD)m));
                    v96 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v95, "description"));
                    sub_100121E18(0, 1024, 0, v96);

                  }
                }
                v92 = objc_msgSend(v90, "countByEnumeratingWithState:objects:count:", &v151, &v160, 16);
              }
              while (v92);
            }

            a1 = v141;
          }
          else
          {
            v137 = sub_1000A2640();
            v138 = _NRLogIsLevelEnabled(v137, 17);

            if (v138)
            {
              v139 = sub_1000A2640();
              _NRLogWithArgs(v139, 17, "%s called with null connection", "-[NRLinkDirector removeDevicePreferencesManagerConnection:]");

            }
          }
        }

        sub_1000AF574((uint64_t)v150, *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40));
        v97 = *(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
        if (v150)
        {
          v162 = 0u;
          v163 = 0u;
          v160 = 0u;
          v161 = 0u;
          v98 = v150[25];
          v99 = objc_msgSend(v98, "countByEnumeratingWithState:objects:count:", &v160, buffer, 16);
          if (v99)
          {
            v100 = v99;
            v101 = *(_QWORD *)v161;
            do
            {
              for (n = 0; n != v100; n = (char *)n + 1)
              {
                if (*(_QWORD *)v161 != v101)
                  objc_enumerationMutation(v98);
                v103 = objc_claimAutoreleasedReturnValue(objc_msgSend(v150[25], "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v160 + 1) + 8 * (_QWORD)n)));
                v104 = (void *)v103;
                if (v103)
                  objc_msgSend(*(id *)(v103 + 152), "removeObject:", v97);

              }
              v100 = objc_msgSend(v98, "countByEnumeratingWithState:objects:count:", &v160, buffer, 16);
            }
            while (v100);
          }

        }
        sub_1000AFB18((uint64_t)v150, 0, *(void **)(*(_QWORD *)(*(_QWORD *)(v141 + 40) + 8) + 40));
        if (object == &_xpc_error_connection_interrupted)
        {
          if (qword_1001E4610 != -1)
            dispatch_once(&qword_1001E4610, &stru_1001B6788);
          if (_NRLogIsLevelEnabled(qword_1001E4608, 2))
          {
            if (qword_1001E4610 != -1)
              dispatch_once(&qword_1001E4610, &stru_1001B6788);
            _NRLogWithArgs(qword_1001E4608, 2, "%s%.30s:%-4d received XPC_ERROR_CONNECTION_INTERRUPTED, removing connection", "", "-[TerminusdXPCServer startXPCListener]_block_invoke_2", 1636);
          }
        }
        else if (object != &_xpc_error_connection_invalid)
        {
          if (object == &_xpc_error_termination_imminent)
          {
            if (qword_1001E4610 != -1)
              dispatch_once(&qword_1001E4610, &stru_1001B6788);
            if (_NRLogIsLevelEnabled(qword_1001E4608, 2))
            {
              v127 = sub_100045324();
              _NRLogWithArgs(v127, 2, "%s%.30s:%-4d received XPC_ERROR_TERMINATION_IMMINENT, removing connection", "", "-[TerminusdXPCServer startXPCListener]_block_invoke_2", 1641);

            }
          }
          else
          {
            v105 = xpc_copy_description(object);
            if (qword_1001E4610 != -1)
              dispatch_once(&qword_1001E4610, &stru_1001B6788);
            if (_NRLogIsLevelEnabled(qword_1001E4608, 2))
            {
              v106 = sub_100045324();
              _NRLogWithArgs(v106, 2, "%s%.30s:%-4d received unknown XPC error %s, removing connection", "", "-[TerminusdXPCServer startXPCListener]_block_invoke_2", 1644, v105);

            }
            if (v105)
              free(v105);
          }
        }
        v128 = *(_QWORD *)(*(_QWORD *)(v141 + 40) + 8);
        v129 = *(void **)(v128 + 40);
        *(_QWORD *)(v128 + 40) = 0;

        goto LABEL_164;
      }
      v8 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
      v9 = object;
      v10 = v8;
      v12 = objc_getProperty(WeakRetained, v11, 8, 1);
      dispatch_assert_queue_V2(v12);
      v13 = sub_10004504C((char *)[TXSContext alloc], v9, v10);
      if (!v13)
        goto LABEL_158;
      uint64 = xpc_dictionary_get_uint64(v9, nrXPCKeyType);
      v16 = objc_getProperty(WeakRetained, v15, 32, 1);
      v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", uint64));
      v18 = (uint64_t (**)(_QWORD))objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "objectForKeyedSubscript:", v17));

      if (v18)
      {
        v20 = objc_getProperty(v18, v19, 8, 1);
        if ((sub_100047714(v10, v20) & 1) != 0)
        {
          v21 = WeakRetained;
          v23 = ((uint64_t (**)(char *))v18)[2](v13);
          if (v23 == -2000)
            goto LABEL_157;
          goto LABEL_156;
        }
        if (qword_1001E4610 != -1)
          dispatch_once(&qword_1001E4610, &stru_1001B6788);
        if (!_NRLogIsLevelEnabled(qword_1001E4608, 16))
        {
          v21 = WeakRetained;
          v23 = -2002;
          goto LABEL_156;
        }
        v21 = WeakRetained;
        if (qword_1001E4610 != -1)
          dispatch_once(&qword_1001E4610, &stru_1001B6788);
        v108 = (id)qword_1001E4608;
        v118 = (void *)*((_QWORD *)v13 + 4);
        if (!v118)
        {
          v119 = (_xpc_connection_s *)objc_getProperty(v13, v117, 8, 1);
          v120 = xpc_connection_get_pid(v119);
          v121 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), v120);
          bzero(buffer, 0x400uLL);
          if ((int)v120 >= 1 && proc_pidpath(v120, buffer, 0x400u) >= 1 && buffer[0])
          {
            v122 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, v120);

            v121 = v122;
          }
          v123 = (void *)*((_QWORD *)v13 + 4);
          *((_QWORD *)v13 + 4) = v121;

          v118 = (void *)*((_QWORD *)v13 + 4);
        }
        v115 = v118;
        StringFromNRXPCType = (void *)createStringFromNRXPCType(uint64);
        _NRLogWithArgs(v108, 16, "%s%.30s:%-4d Client %@ missing entitlements for type %@", "", "-[TerminusdXPCServer handleRequest:onConnection:]", 1685, v115, StringFromNRXPCType);
        v23 = -2002;
      }
      else
      {
        if (qword_1001E4610 != -1)
          dispatch_once(&qword_1001E4610, &stru_1001B6788);
        if (!_NRLogIsLevelEnabled(qword_1001E4608, 16))
        {
          v21 = WeakRetained;
          v23 = -2003;
          goto LABEL_156;
        }
        if (qword_1001E4610 != -1)
          dispatch_once(&qword_1001E4610, &stru_1001B6788);
        v21 = WeakRetained;
        v108 = (id)qword_1001E4608;
        v109 = (void *)*((_QWORD *)v13 + 4);
        if (!v109)
        {
          v110 = (_xpc_connection_s *)objc_getProperty(v13, v107, 8, 1);
          v111 = xpc_connection_get_pid(v110);
          v112 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), v111);
          bzero(buffer, 0x400uLL);
          if ((int)v111 >= 1 && proc_pidpath(v111, buffer, 0x400u) >= 1 && buffer[0])
          {
            v113 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, v111);

            v112 = v113;
          }
          v114 = (void *)*((_QWORD *)v13 + 4);
          *((_QWORD *)v13 + 4) = v112;

          v109 = (void *)*((_QWORD *)v13 + 4);
        }
        v115 = v109;
        StringFromNRXPCType = (void *)createStringFromNRXPCType(uint64);
        _NRLogWithArgs(v108, 16, "%s%.30s:%-4d Client %@ sent invalid type %@", "", "-[TerminusdXPCServer handleRequest:onConnection:]", 1689, v115, StringFromNRXPCType);
        v23 = -2003;
      }

LABEL_156:
      v124 = objc_getProperty(v13, v22, 24, 1);
      xpc_dictionary_set_int64(v124, nrXPCKeyResult, v23);
      v126 = objc_getProperty(v13, v125, 24, 1);
      xpc_connection_send_message((xpc_connection_t)v10, v126);
LABEL_157:

      WeakRetained = v21;
LABEL_158:

    }
  }
  else
  {
    v130 = sub_100045324();
    v131 = _NRLogIsLevelEnabled(v130, 2);

    if (!v131)
      goto LABEL_165;
    WeakRetained = sub_100045324();
    _NRLogWithArgs(WeakRetained, 2, "%s%.30s:%-4d received request on removed connection, ignoring", "", "-[TerminusdXPCServer startXPCListener]_block_invoke_2", 1615);
  }
LABEL_164:

LABEL_165:
}

uint64_t sub_100048B3C(void *a1)
{
  _QWORD *v1;
  const char *v2;
  id v3;
  void *v4;
  _xpc_connection_s *Property;
  uint64_t pid;
  id v7;
  id v8;
  void *v9;
  id v10;
  pid_t v11;
  const char *v12;
  xpc_object_t v13;
  id v14;
  _BYTE buffer[1024];

  v1 = a1;
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v3 = (id)qword_1001E4608;
    if (v1)
    {
      v4 = (void *)v1[4];
      if (!v4)
      {
        Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8, 1);
        pid = xpc_connection_get_pid(Property);
        v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v7 = v8;
        }
        v9 = (void *)v1[4];
        v1[4] = v7;

        v4 = (void *)v1[4];
      }
      v10 = v4;
    }
    else
    {
      v10 = 0;
    }
    _NRLogWithArgs(v3, 0, "%s%.30s:%-4d Received DaemonPing from %@", "", "handlePing", 188, v10);

  }
  v11 = getpid();
  v13 = xpc_string_create_with_format("PingReply(%d)", v11);
  if (v1)
    v14 = objc_getProperty(v1, v12, 24, 1);
  else
    v14 = 0;
  xpc_dictionary_set_value(v14, nrXPCKeyPingMessage, v13);

  return 0;
}

void sub_100048D58(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7;
  void *v8;
  id v9;
  SEL v10;
  id v11;
  void *v12;
  id v13;
  void *StringFromNRXPCType;
  id v15;
  char v16;
  uint64_t v17;
  void *i;
  void *v19;
  id v20;
  id v21;
  id v22;
  uint64_t v23;
  void *j;
  void *v25;
  const char *v26;
  const char *v27;
  id v28;
  void *v29;
  id v30;
  int v31;
  id v32;
  id v33;
  int IsLevelEnabled;
  uint64_t v35;
  id v36;
  void *v37;
  id v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  _BYTE v47[128];
  _BYTE v48[128];

  v7 = a4;
  if (a2)
  {
    v8 = sub_1000454D8([TXSHandler alloc], a2, v7);
    if (v8)
    {
      v9 = (id)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a3));
      v11 = objc_msgSend(objc_getProperty(a1, v10, 32, 1), "objectForKeyedSubscript:", v9);
      v12 = (void *)objc_claimAutoreleasedReturnValue(v11);

      if (v12)
      {
        if (qword_1001E4610 != -1)
          dispatch_once(&qword_1001E4610, &stru_1001B6788);
        if (!_NRLogIsLevelEnabled(qword_1001E4608, 17))
          goto LABEL_47;
        if (qword_1001E4610 != -1)
          dispatch_once(&qword_1001E4610, &stru_1001B6788);
        v13 = (id)qword_1001E4608;
        StringFromNRXPCType = (void *)createStringFromNRXPCType(a3);
        _NRLogWithArgs(v13, 17, "Trying to reregister handler for type %@", StringFromNRXPCType);
      }
      else
      {
        v45 = 0u;
        v46 = 0u;
        v43 = 0u;
        v44 = 0u;
        v15 = v7;
        v38 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v43, v48, 16);
        if (v38)
        {
          v36 = v7;
          v16 = 0;
          v17 = *(_QWORD *)v44;
          v37 = v15;
          v35 = *(_QWORD *)v44;
          do
          {
            for (i = 0; i != v38; i = (char *)i + 1)
            {
              if (*(_QWORD *)v44 != v17)
                objc_enumerationMutation(v15);
              v19 = *(void **)(*((_QWORD *)&v43 + 1) + 8 * (_QWORD)i);
              v39 = 0u;
              v40 = 0u;
              v41 = 0u;
              v42 = 0u;
              v20 = v19;
              v21 = objc_msgSend(v20, "countByEnumeratingWithState:objects:count:", &v39, v47, 16);
              if (v21)
              {
                v22 = v21;
                v23 = *(_QWORD *)v40;
                while (2)
                {
                  for (j = 0; j != v22; j = (char *)j + 1)
                  {
                    if (*(_QWORD *)v40 != v23)
                      objc_enumerationMutation(v20);
                    v25 = *(void **)(*((_QWORD *)&v39 + 1) + 8 * (_QWORD)j);
                    if ((objc_msgSend(v25, "hasPrefix:", CFSTR("com.apple.")) & 1) == 0)
                    {
                      if (qword_1001E4610 != -1)
                        dispatch_once(&qword_1001E4610, &stru_1001B6788);
                      v7 = v36;
                      if (_NRLogIsLevelEnabled(qword_1001E4608, 17))
                      {
                        if (qword_1001E4610 != -1)
                          dispatch_once(&qword_1001E4610, &stru_1001B6788);
                        v28 = (id)qword_1001E4608;
                        v29 = (void *)createStringFromNRXPCType(a3);
                        _NRLogWithArgs(v28, 17, "Refusing to register handler for type %@ with invalid entitlement %@", v29, v25);

                      }
                      goto LABEL_47;
                    }
                    objc_msgSend(objc_getProperty(a1, v26, 40, 1), "addObject:", v25);
                  }
                  v22 = objc_msgSend(v20, "countByEnumeratingWithState:objects:count:", &v39, v47, 16);
                  if (v22)
                    continue;
                  break;
                }
                v16 = 1;
                v15 = v37;
                v17 = v35;
              }

            }
            v38 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v43, v48, 16);
          }
          while (v38);

          v7 = v36;
          if ((v16 & 1) != 0)
          {
            objc_msgSend(objc_getProperty(a1, v27, 32, 1), "setObject:forKeyedSubscript:", v8, v9);
            goto LABEL_47;
          }
        }
        else
        {

        }
        if (qword_1001E4610 != -1)
          dispatch_once(&qword_1001E4610, &stru_1001B6788);
        if (!_NRLogIsLevelEnabled(qword_1001E4608, 17))
          goto LABEL_47;
        if (qword_1001E4610 != -1)
          dispatch_once(&qword_1001E4610, &stru_1001B6788);
        v13 = (id)qword_1001E4608;
        StringFromNRXPCType = (void *)createStringFromNRXPCType(a3);
        _NRLogWithArgs(v13, 17, "Refusing to register handler for type %@ without any entitlement", StringFromNRXPCType);
      }

    }
    else
    {
      v33 = sub_100045324();
      IsLevelEnabled = _NRLogIsLevelEnabled(v33, 17);

      if (!IsLevelEnabled)
      {
LABEL_48:

        goto LABEL_49;
      }
      v9 = sub_100045324();
      _NRLogWithArgs(v9, 17, "[TXSHandler initWithHandlerFunction:] failed");
    }
LABEL_47:

    goto LABEL_48;
  }
  v30 = sub_100045324();
  v31 = _NRLogIsLevelEnabled(v30, 17);

  if (v31)
  {
    v32 = sub_100045324();
    _NRLogWithArgs(v32, 17, "%s called with null handlerFunction", "-[TerminusdXPCServer registerHandlerFunction:type:allowedEntitlementGroup:]");

  }
LABEL_49:

}

uint64_t sub_100049218(void *a1)
{
  _QWORD *v1;
  const char *v2;
  id v3;
  void *v4;
  _xpc_connection_s *Property;
  uint64_t pid;
  id v7;
  id v8;
  void *v9;
  id v10;
  _BYTE buffer[1024];

  v1 = a1;
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v3 = (id)qword_1001E4608;
    if (v1)
    {
      v4 = (void *)v1[4];
      if (!v4)
      {
        Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8, 1);
        pid = xpc_connection_get_pid(Property);
        v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v7 = v8;
        }
        v9 = (void *)v1[4];
        v1[4] = v7;

        v4 = (void *)v1[4];
      }
      v10 = v4;
    }
    else
    {
      v10 = 0;
    }
    _NRLogWithArgs(v3, 0, "%s%.30s:%-4d Setting companion link to default due to request from %@", "", "handleCompanionLinkDefault", 196, v10);

  }
  sub_1000A0004(0);

  return 0;
}

uint64_t sub_1000493F0(void *a1)
{
  _QWORD *v1;
  const char *v2;
  id v3;
  void *v4;
  _xpc_connection_s *Property;
  uint64_t pid;
  id v7;
  id v8;
  void *v9;
  id v10;
  _BYTE buffer[1024];

  v1 = a1;
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v3 = (id)qword_1001E4608;
    if (v1)
    {
      v4 = (void *)v1[4];
      if (!v4)
      {
        Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8, 1);
        pid = xpc_connection_get_pid(Property);
        v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v7 = v8;
        }
        v9 = (void *)v1[4];
        v1[4] = v7;

        v4 = (void *)v1[4];
      }
      v10 = v4;
    }
    else
    {
      v10 = 0;
    }
    _NRLogWithArgs(v3, 0, "%s%.30s:%-4d Enabling companion link due to request from %@", "", "handleCompanionLinkEnable", 203, v10);

  }
  sub_1000A0004(1);

  return 0;
}

uint64_t sub_1000495C8(void *a1)
{
  _QWORD *v1;
  const char *v2;
  id v3;
  void *v4;
  _xpc_connection_s *Property;
  uint64_t pid;
  id v7;
  id v8;
  void *v9;
  id v10;
  _BYTE buffer[1024];

  v1 = a1;
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v3 = (id)qword_1001E4608;
    if (v1)
    {
      v4 = (void *)v1[4];
      if (!v4)
      {
        Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8, 1);
        pid = xpc_connection_get_pid(Property);
        v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v7 = v8;
        }
        v9 = (void *)v1[4];
        v1[4] = v7;

        v4 = (void *)v1[4];
      }
      v10 = v4;
    }
    else
    {
      v10 = 0;
    }
    _NRLogWithArgs(v3, 0, "%s%.30s:%-4d Disabling companion link due to request from %@", "", "handleCompanionLinkDisable", 210, v10);

  }
  sub_1000A0004(2);

  return 0;
}

uint64_t sub_1000497A0(void *a1)
{
  _QWORD *v1;
  const char *v2;
  int v3;
  id Property;
  const char *v5;
  id v6;
  void *v7;
  _xpc_connection_s *v8;
  uint64_t pid;
  id v10;
  id v11;
  void *v12;
  id v13;
  const char *v14;
  _BYTE buffer[1024];

  v1 = a1;
  v3 = sub_10009FF34((uint64_t)v1);
  if (v1)
    Property = objc_getProperty(v1, v2, 24, 1);
  else
    Property = 0;
  xpc_dictionary_set_BOOL(Property, nrXPCKeyCompanionLinkIsEnabled, v3);
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v6 = (id)qword_1001E4608;
    if (v1)
    {
      v7 = (void *)v1[4];
      if (!v7)
      {
        v8 = (_xpc_connection_s *)objc_getProperty(v1, v5, 8, 1);
        pid = xpc_connection_get_pid(v8);
        v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          v11 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v10 = v11;
        }
        v12 = (void *)v1[4];
        v1[4] = v10;

        v7 = (void *)v1[4];
      }
      v13 = v7;
    }
    else
    {
      v13 = 0;
    }
    v14 = "dis";
    if (v3)
      v14 = "en";
    _NRLogWithArgs(v6, 0, "%s%.30s:%-4d Informing %@ that companion link is %sabled", "", "handleCompanionLinkIsEnabled", 220, v13, v14);

  }
  return 0;
}

uint64_t sub_1000499CC(void *a1)
{
  _QWORD *v1;
  const char *v2;
  id v3;
  void *v4;
  _xpc_connection_s *Property;
  uint64_t pid;
  id v7;
  id v8;
  void *v9;
  id v10;
  id v11;
  const char *v12;
  void *v13;
  id v14;
  const char *v15;
  id v16;
  uint64_t v17;
  _BYTE buffer[1024];

  v1 = a1;
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v3 = (id)qword_1001E4608;
    if (v1)
    {
      v4 = (void *)v1[4];
      if (!v4)
      {
        Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8, 1);
        pid = xpc_connection_get_pid(Property);
        v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v7 = v8;
        }
        v9 = (void *)v1[4];
        v1[4] = v7;

        v4 = (void *)v1[4];
      }
      v10 = v4;
    }
    else
    {
      v10 = 0;
    }
    _NRLogWithArgs(v3, 0, "%s%.30s:%-4d Sending companion link status to %@", "", "handleCompanionLinkStatus", 396, v10);

  }
  v11 = sub_1000594C8();
  v13 = (void *)objc_claimAutoreleasedReturnValue(v11);
  if (v13)
  {
    if (v1)
      v14 = objc_getProperty(v1, v12, 24, 1);
    else
      v14 = 0;
    v15 = (const char *)nrXPCKeyCompanionLinkStatusMessage;
    v16 = v14;
    xpc_dictionary_set_string(v16, v15, (const char *)objc_msgSend(v13, "UTF8String"));

    v17 = 0;
  }
  else
  {
    v17 = -2004;
  }

  return v17;
}

uint64_t sub_100049C08(void *a1)
{
  _QWORD *Property;
  const char *v2;
  _QWORD *v3;
  const char *string;
  id v5;
  const char *v6;
  const char *v7;
  id v8;
  void *v9;
  _xpc_connection_s *v10;
  uint64_t pid;
  id v12;
  id v13;
  void *v14;
  id v15;
  id v16;
  const char *v17;
  const char *v18;
  uint64_t v19;
  const char *v20;
  void *v21;
  _xpc_connection_s *v22;
  uint64_t v23;
  id v24;
  id v25;
  void *v26;
  id v27;
  uint64_t v28;
  id v29;
  const char *v31;
  void *v32;
  _xpc_connection_s *v33;
  uint64_t v34;
  id v35;
  void *v36;
  id v37;
  _BYTE buffer[1024];

  Property = a1;
  v3 = Property;
  if (Property)
    Property = objc_getProperty(Property, v2, 16, 1);
  string = xpc_dictionary_get_string(Property, nrXPCKeyCompanionLinkStatusDumpToDirectoryPath);
  if (string)
  {
    v5 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", string);
    if ((objc_msgSend(v5, "hasPrefix:", CFSTR("/var/mobile/Library/Logs/")) & 1) != 0
      || (objc_msgSend(v5, "hasPrefix:", CFSTR("/private/var/mobile/Library/Logs/")) & 1) != 0
      || (objc_msgSend(v5, "hasPrefix:", CFSTR("/tmp/")) & 1) != 0
      || (objc_msgSend(v5, "hasPrefix:", CFSTR("/private/var/tmp/")) & 1) != 0)
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
      {
        if (qword_1001E4610 != -1)
          dispatch_once(&qword_1001E4610, &stru_1001B6788);
        v8 = (id)qword_1001E4608;
        if (v3)
        {
          v9 = (void *)v3[4];
          if (!v9)
          {
            v10 = (_xpc_connection_s *)objc_getProperty(v3, v7, 8, 1);
            pid = xpc_connection_get_pid(v10);
            v12 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
            bzero(buffer, 0x400uLL);
            if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
            {
              v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

              v12 = v13;
            }
            v14 = (void *)v3[4];
            v3[4] = v12;

            v9 = (void *)v3[4];
          }
          v15 = v9;
        }
        else
        {
          v15 = 0;
        }
        _NRLogWithArgs(v8, 0, "%s%.30s:%-4d Saving companion link status to \"%@\" for %@", "", "handleCompanionLinkStatusToDirectory", 307, v5, v15);

      }
      if (v3)
        v16 = objc_getProperty(v3, v6, 16, 1);
      else
        v16 = 0;
      v17 = xpc_dictionary_get_string(v16, nrXPCKeyCompanionLinkStatusSandboxExtensionToken);
      v18 = v17;
      if (v17)
        v19 = sandbox_extension_consume(v17);
      else
        v19 = -1;
      v29 = sub_10005A754(v5);
      v27 = (id)objc_claimAutoreleasedReturnValue(v29);
      if (v18 && (v19 & 0x8000000000000000) == 0)
        sandbox_extension_release(v19);
      if (objc_msgSend(v27, "count"))
        v28 = 0;
      else
        v28 = -2012;
    }
    else
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      if (!_NRLogIsLevelEnabled(qword_1001E4608, 17))
      {
        v28 = -2005;
        goto LABEL_48;
      }
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      v27 = (id)qword_1001E4608;
      if (v3)
      {
        v32 = (void *)v3[4];
        if (!v32)
        {
          v33 = (_xpc_connection_s *)objc_getProperty(v3, v31, 8, 1);
          v34 = xpc_connection_get_pid(v33);
          v35 = sub_100109ADC(v34, 1);
          v36 = (void *)v3[4];
          v3[4] = v35;

          v32 = (void *)v3[4];
        }
        v37 = v32;
      }
      else
      {
        v37 = 0;
      }
      _NRLogWithArgs(v27, 17, "Refusing to save companion link status to \"%@\" for %@", v5, v37);

      v28 = -2005;
    }
  }
  else
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    if (!_NRLogIsLevelEnabled(qword_1001E4608, 16))
    {
      v28 = -2005;
      goto LABEL_49;
    }
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v5 = (id)qword_1001E4608;
    if (v3)
    {
      v21 = (void *)v3[4];
      if (!v21)
      {
        v22 = (_xpc_connection_s *)objc_getProperty(v3, v20, 8, 1);
        v23 = xpc_connection_get_pid(v22);
        v24 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), v23);
        bzero(buffer, 0x400uLL);
        if ((int)v23 >= 1 && proc_pidpath(v23, buffer, 0x400u) >= 1 && buffer[0])
        {
          v25 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, v23);

          v24 = v25;
        }
        v26 = (void *)v3[4];
        v3[4] = v24;

        v21 = (void *)v3[4];
      }
      v27 = v21;
    }
    else
    {
      v27 = 0;
    }
    _NRLogWithArgs(v5, 16, "%s%.30s:%-4d Missing directory name from %@", "", "handleCompanionLinkStatusToDirectory", 295, v27);
    v28 = -2005;
  }

LABEL_48:
LABEL_49:

  return v28;
}

uint64_t sub_10004A144(void *a1)
{
  char *v1;
  __objc2_prot *v2;
  const char *v3;
  id v4;
  void *v5;
  _xpc_connection_s *Property;
  uint64_t pid;
  id v8;
  id v9;
  void *v10;
  id v11;
  id v12;
  void *v13;
  void *v14;
  id v15;
  id v16;
  void *v17;
  xpc_object_t v18;
  void *v19;
  id v20;
  id v21;
  id v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  xpc_object_t v26;
  void *v27;
  const char *v28;
  id v29;
  uint64_t v30;
  id v32;
  int v33;
  id v34;
  char *v35;
  int *v36;
  uint64_t v37;
  id v38;
  id v39;
  int IsLevelEnabled;
  id v41;
  int *v42;
  uint64_t v43;
  id v44;
  char *v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  _BYTE v50[128];
  _BYTE v51[1024];

  v1 = a1;
  v2 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
  if (qword_1001E4610 != -1)
    goto LABEL_39;
  while (1)
  {
    if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
    {
      if (v2[21].opt_inst_meths != (__objc2_meth_list *)-1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      v4 = (id)qword_1001E4608;
      if (v1)
      {
        v5 = (void *)*((_QWORD *)v1 + 4);
        if (!v5)
        {
          Property = (_xpc_connection_s *)objc_getProperty(v1, v3, 8, 1);
          pid = xpc_connection_get_pid(Property);
          v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
          bzero(v51, 0x400uLL);
          if ((int)pid >= 1 && proc_pidpath(pid, v51, 0x400u) >= 1 && v51[0])
          {
            v9 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), v51, pid);

            v8 = v9;
          }
          v10 = (void *)*((_QWORD *)v1 + 4);
          *((_QWORD *)v1 + 4) = v8;

          v5 = (void *)*((_QWORD *)v1 + 4);
        }
        v11 = v5;
      }
      else
      {
        v11 = 0;
      }
      _NRLogWithArgs(v4, 0, "%s%.30s:%-4d Saving companion link status to temp directory for %@", "", "handleCompanionLinkStatusToTempDirectory", 370, v11);

    }
    v12 = objc_alloc((Class)NSString);
    v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](NSUUID, "UUID"));
    v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "UUIDString"));
    v15 = objc_msgSend(v12, "initWithFormat:", CFSTR("/tmp/terminusd/%@"), v14);

    v16 = sub_10005A754(v15);
    v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
    if (!objc_msgSend(v17, "count"))
    {
      v30 = -2012;
      goto LABEL_30;
    }
    v18 = xpc_array_create(0, 0);
    if (v18)
      break;
    v39 = sub_100045324();
    IsLevelEnabled = _NRLogIsLevelEnabled(v39, 16);

    if (IsLevelEnabled)
    {
      v41 = sub_100045324();
      _NRLogWithArgs(v41, 16, "%s%.30s:%-4d ABORTING: xpc_array_create(%p, %u) failed", "", "nr_xpc_array_create", 56, 0, 0);

    }
    v2 = (__objc2_prot *)_os_log_pack_size(28);
    v35 = (char *)&v44 - ((__chkstk_darwin(v2) + 15) & 0xFFFFFFFFFFFFFFF0);
    v42 = __error();
    v43 = _os_log_pack_fill(v35, v2, *v42, &_mh_execute_header, "%{public}s xpc_array_create(%p, %u) failed");
    sub_10005ADB8(v43, (uint64_t)"nr_xpc_array_create");
LABEL_38:
    v38 = sub_100045324();
    _NRLogAbortWithPack(v38, v35);
LABEL_39:
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  }
  v19 = v18;
  v44 = v15;
  v45 = v1;
  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  v47 = 0u;
  v20 = v17;
  v21 = objc_msgSend(v20, "countByEnumeratingWithState:objects:count:", &v46, v50, 16);
  if (v21)
  {
    v22 = v21;
    v23 = *(_QWORD *)v47;
LABEL_19:
    v24 = 0;
    while (1)
    {
      if (*(_QWORD *)v47 != v23)
        objc_enumerationMutation(v20);
      v25 = (const char *)objc_msgSend(*(id *)(*((_QWORD *)&v46 + 1) + 8 * v24), "UTF8String");
      if (v25)
      {
        v1 = (char *)v25;
        v26 = xpc_string_create(v25);
        if (!v26)
        {
          if (qword_1001E4610 != -1)
            dispatch_once(&qword_1001E4610, &stru_1001B6788);
          v32 = (id)qword_1001E4608;
          v33 = _NRLogIsLevelEnabled(v32, 16);

          if (v33)
          {
            if (qword_1001E4610 != -1)
              dispatch_once(&qword_1001E4610, &stru_1001B6788);
            v34 = (id)qword_1001E4608;
            _NRLogWithArgs(v34, 16, "%s%.30s:%-4d ABORTING: xpc_string_create(%s) failed", "", "nr_xpc_string_create", 181, v1);

          }
          v2 = (__objc2_prot *)_os_log_pack_size(22);
          v35 = (char *)&v44 - ((__chkstk_darwin(v2) + 15) & 0xFFFFFFFFFFFFFFF0);
          v36 = __error();
          v37 = _os_log_pack_fill(v35, v2, *v36, &_mh_execute_header, "%{public}s xpc_string_create(%s) failed");
          *(_DWORD *)v37 = 136446466;
          *(_QWORD *)(v37 + 4) = "nr_xpc_string_create";
          *(_WORD *)(v37 + 12) = 2080;
          *(_QWORD *)(v37 + 14) = v1;
          goto LABEL_38;
        }
        v27 = v26;
        xpc_array_append_value(v19, v26);

      }
      if (v22 == (id)++v24)
      {
        v22 = objc_msgSend(v20, "countByEnumeratingWithState:objects:count:", &v46, v50, 16);
        if (!v22)
          break;
        goto LABEL_19;
      }
    }
  }

  v1 = v45;
  if (v45)
    v29 = objc_getProperty(v45, v28, 24, 1);
  else
    v29 = 0;
  v15 = v44;
  xpc_dictionary_set_value(v29, nrXPCKeyCompanionLinkStatusDumpFilePaths, v19);

  v30 = 0;
LABEL_30:

  return v30;
}

uint64_t sub_10004A6C8(void *a1)
{
  id Property;
  const char *v2;
  void *v3;
  const char *v4;
  int v5;
  id v6;
  const char *string;
  id v8;
  id v9;
  void *v10;
  id v11;
  id v12;
  void *v13;
  char v14;
  uint64_t v15;
  id v16;
  int IsLevelEnabled;
  id v18;
  id v19;
  int v20;
  id v21;
  int v22;

  Property = a1;
  v3 = Property;
  if (Property)
    Property = objc_getProperty(Property, v2, 16, 1);
  v5 = xpc_dictionary_dup_fd(Property, nrXPCKeyCompanionLinkStatusDumpToFileDescriptor);
  if (v5 == -1)
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    if (_NRLogIsLevelEnabled(qword_1001E4608, 17))
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      _NRLogWithArgs(qword_1001E4608, 17, "Missing file descriptor key failed");
    }
  }
  else
  {
    if (v3)
      v6 = objc_getProperty(v3, v4, 16, 1);
    else
      v6 = 0;
    string = xpc_dictionary_get_string(v6, nrXPCKeyCompanionLinkStatusDumpToFilePath);
    if (string)
    {
      v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", string);
      v9 = sub_1000594C8();
      v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
      if (!v10)
      {
        if (qword_1001E4610 != -1)
          dispatch_once(&qword_1001E4610, &stru_1001B6788);
        if (_NRLogIsLevelEnabled(qword_1001E4608, 17))
        {
          if (qword_1001E4610 != -1)
            dispatch_once(&qword_1001E4610, &stru_1001B6788);
          _NRLogWithArgs(qword_1001E4608, 17, "Companion link status is empty failed");
        }
        v15 = -2004;
        goto LABEL_48;
      }
      v11 = v8;
      v12 = v10;
      if (v5 < 0)
      {
        v16 = sub_100106E24();
        IsLevelEnabled = _NRLogIsLevelEnabled(v16, 17);

        if (!IsLevelEnabled)
          goto LABEL_40;
        v18 = sub_100106E24();
        _NRLogWithArgs(v18, 17, "%s called with null fd >= 0");
      }
      else
      {
        if (v11)
        {
          if (objc_msgSend(v11, "length"))
          {
            v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "dataUsingEncoding:", 4));
            v14 = sub_100106E64(v5, v11, v13);

            if ((v14 & 1) != 0)
            {
              v15 = 0;
LABEL_48:

              goto LABEL_49;
            }
LABEL_41:
            if (qword_1001E4610 != -1)
              dispatch_once(&qword_1001E4610, &stru_1001B6788);
            if (_NRLogIsLevelEnabled(qword_1001E4608, 16))
            {
              if (qword_1001E4610 != -1)
                dispatch_once(&qword_1001E4610, &stru_1001B6788);
              _NRLogWithArgs(qword_1001E4608, 16, "%s%.30s:%-4d Failed to write companion link status to fd \"%d\"", "", "handleCompanionLinkStatusToFileDescriptor", 357, v5);
            }
            v15 = -2012;
            goto LABEL_48;
          }
          v21 = sub_100106E24();
          v22 = _NRLogIsLevelEnabled(v21, 17);

          if (v22)
          {
            v18 = sub_100106E24();
            _NRLogWithArgs(v18, 17, "%s called with null filePath.length");
            goto LABEL_39;
          }
LABEL_40:

          goto LABEL_41;
        }
        v19 = sub_100106E24();
        v20 = _NRLogIsLevelEnabled(v19, 17);

        if (!v20)
          goto LABEL_40;
        v18 = sub_100106E24();
        _NRLogWithArgs(v18, 17, "%s called with null filePath");
      }
LABEL_39:

      goto LABEL_40;
    }
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    if (_NRLogIsLevelEnabled(qword_1001E4608, 17))
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      _NRLogWithArgs(qword_1001E4608, 17, "Missing file name key failed");
    }
  }
  v15 = -2005;
LABEL_49:
  close(v5);

  return v15;
}

uint64_t sub_10004AAD0(void *a1)
{
  _QWORD *v1;
  const char *v2;
  id v3;
  void *v4;
  _xpc_connection_s *Property;
  uint64_t pid;
  id v7;
  id v8;
  void *v9;
  id v10;
  id v11;
  unsigned int v12;
  const char *v13;
  id v14;
  _BYTE buffer[1024];

  v1 = a1;
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v3 = (id)qword_1001E4608;
    if (v1)
    {
      v4 = (void *)v1[4];
      if (!v4)
      {
        Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8, 1);
        pid = xpc_connection_get_pid(Property);
        v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v7 = v8;
        }
        v9 = (void *)v1[4];
        v1[4] = v7;

        v4 = (void *)v1[4];
      }
      v10 = v4;
    }
    else
    {
      v10 = 0;
    }
    _NRLogWithArgs(v3, 0, "%s%.30s:%-4d Cancelling companion link due to %@", "", "handleCompanionLinkCancel", 408, v10);

  }
  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v11 = (id)qword_1001E4708;
  v12 = sub_1000A5114((uint64_t)v11);

  if (v1)
    v14 = objc_getProperty(v1, v13, 24, 1);
  else
    v14 = 0;
  xpc_dictionary_set_uint64(v14, nrXPCKeyCompanionLinkCount, v12);

  return 0;
}

uint64_t sub_10004AD20(void *a1)
{
  _QWORD *v1;
  const char *v2;
  id v3;
  void *v4;
  _xpc_connection_s *Property;
  uint64_t pid;
  id v7;
  id v8;
  void *v9;
  id v10;
  id *v11;
  id *v12;
  id v13;
  id v14;
  id v15;
  uint64_t v16;
  void *i;
  uint64_t v18;
  void *v19;
  id v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  _BYTE buffer[1024];

  v1 = a1;
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v3 = (id)qword_1001E4608;
    if (v1)
    {
      v4 = (void *)v1[4];
      if (!v4)
      {
        Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8, 1);
        pid = xpc_connection_get_pid(Property);
        v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v7 = v8;
        }
        v9 = (void *)v1[4];
        v1[4] = v7;

        v4 = (void *)v1[4];
      }
      v10 = v4;
    }
    else
    {
      v10 = 0;
    }
    _NRLogWithArgs(v3, 0, "%s%.30s:%-4d Flushing BT pipe due to %@", "", "handleCompanionLinkFlushBTPipe", 416, v10);

  }
  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v11 = (id *)(id)qword_1001E4708;
  v12 = v11;
  if (v11)
  {
    v31 = 0u;
    v32 = 0u;
    v29 = 0u;
    v30 = 0u;
    v13 = v11[25];
    v14 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v29, buffer, 16);
    if (v14)
    {
      v15 = v14;
      v16 = *(_QWORD *)v30;
      do
      {
        for (i = 0; i != v15; i = (char *)i + 1)
        {
          if (*(_QWORD *)v30 != v16)
            objc_enumerationMutation(v13);
          v18 = objc_claimAutoreleasedReturnValue(objc_msgSend(v12[25], "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v29 + 1) + 8 * (_QWORD)i)));
          v19 = (void *)v18;
          if (v18)
          {
            dispatch_assert_queue_V2(*(dispatch_queue_t *)(v18 + 104));
            v20 = sub_1000D8AA8((uint64_t)v19, 1, 0);
          }
          else
          {
            v20 = 0;
          }

          if (objc_msgSend(v20, "state") == 8 || objc_msgSend(v20, "state") == 9)
            sub_100074F70(v20, CFSTR("Flushing pipe for testing"), v21, v22, v23, v24, v25, v26, v28);

        }
        v15 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v29, buffer, 16);
      }
      while (v15);
    }

  }
  return 0;
}

uint64_t sub_10004B054(void *a1)
{
  unsigned __int8 uint64;
  __objc2_prot *v2;
  _QWORD *Property;
  const char *v4;
  _QWORD *v5;
  const unsigned __int8 *uuid;
  const unsigned __int8 *v7;
  const char *v8;
  id v9;
  void *v10;
  _xpc_connection_s *v11;
  uint64_t pid;
  id v13;
  id v14;
  void *v15;
  id v16;
  uint64_t v17;
  char *v18;
  const char *v19;
  char *v20;
  id v21;
  id v22;
  const char *v23;
  void *String;
  void *v25;
  _xpc_connection_s *v26;
  uint64_t v27;
  id v28;
  id v29;
  void *v30;
  id v31;
  unsigned __int8 v32;
  char *v33;
  char *v34;
  const char *v35;
  const char *v36;
  id v37;
  void *v38;
  _xpc_connection_s *v39;
  uint64_t v40;
  id v41;
  id v42;
  void *v43;
  id v44;
  id v45;
  const char *v46;
  id v47;
  uint64_t v48;
  void *v49;
  _xpc_connection_s *v50;
  uint64_t v51;
  id v52;
  void *v53;
  id v54;
  id v55;
  int v56;
  const char *v57;
  id v59;
  int IsLevelEnabled;
  id v61;
  int *v62;
  uint64_t v63;
  id v64;
  _OWORD v65[64];

  Property = a1;
  v5 = Property;
  if (Property)
    Property = objc_getProperty(Property, v4, 16, 1);
  uuid = xpc_dictionary_get_uuid(Property, nrXPCKeyNRUUID);
  if (uuid)
  {
    v7 = uuid;
    if (uuid_is_null(uuid))
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      if (_NRLogIsLevelEnabled(qword_1001E4608, 16))
      {
        if (qword_1001E4610 != -1)
          dispatch_once(&qword_1001E4610, &stru_1001B6788);
        v9 = (id)qword_1001E4608;
        if (v5)
        {
          v10 = (void *)v5[4];
          if (!v10)
          {
            v11 = (_xpc_connection_s *)objc_getProperty(v5, v8, 8, 1);
            pid = xpc_connection_get_pid(v11);
            v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
            bzero(v65, 0x400uLL);
            if ((int)pid >= 1 && proc_pidpath(pid, v65, 0x400u) >= 1 && LOBYTE(v65[0]))
            {
              v14 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), v65, pid);

              v13 = v14;
            }
            v15 = (void *)v5[4];
            v5[4] = v13;

            v10 = (void *)v5[4];
          }
          v16 = v10;
        }
        else
        {
          v16 = 0;
        }
        _NRLogWithArgs(v9, 16, "%s%.30s:%-4d All-zero NRUUID from %@", "", "handleResolveEndpoint", 430, v16);
        goto LABEL_19;
      }
LABEL_76:
      v17 = -2005;
      goto LABEL_77;
    }
    v18 = (char *)objc_msgSend(objc_alloc((Class)NSUUID), "initWithUUIDBytes:", v7);
    if (v18)
    {
      v20 = v18;
      if (v5)
        v21 = objc_getProperty(v5, v19, 16, 1);
      else
        v21 = 0;
      uint64 = xpc_dictionary_get_uint64(v21, nrXPCKeyDataProtectionClass);
      v2 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
      if (qword_1001E4610 == -1)
      {
LABEL_24:
        if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
        {
          if (v2[21].opt_inst_meths != (__objc2_meth_list *)-1)
            dispatch_once(&qword_1001E4610, &stru_1001B6788);
          v22 = (id)qword_1001E4608;
          String = (void *)NRDataProtectionClassCreateString(uint64);
          if (v5)
          {
            v25 = (void *)v5[4];
            if (!v25)
            {
              v26 = (_xpc_connection_s *)objc_getProperty(v5, v23, 8, 1);
              v27 = xpc_connection_get_pid(v26);
              v28 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), v27);
              bzero(v65, 0x400uLL);
              if ((int)v27 >= 1 && proc_pidpath(v27, v65, 0x400u) >= 1 && LOBYTE(v65[0]))
              {
                v29 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), v65, v27);

                v28 = v29;
              }
              v30 = (void *)v5[4];
              v5[4] = v28;

              v25 = (void *)v5[4];
            }
            v31 = v25;
          }
          else
          {
            v31 = 0;
          }
          _NRLogWithArgs(v22, 0, "%s%.30s:%-4d Received resolution request for %@ %@ from %@", "", "handleResolveEndpoint", 440, v20, String, v31);

        }
        if (uint64 == 1)
          v32 = 3;
        else
          v32 = uint64;
        v33 = sub_1001300EC((uint64_t)NRDLocalDevice, v20, 0);
        v34 = v33;
        if (!v33)
        {
          if (v2[21].opt_inst_meths != (__objc2_meth_list *)-1)
            dispatch_once(&qword_1001E4610, &stru_1001B6788);
          if (_NRLogIsLevelEnabled(qword_1001E4608, 16))
          {
            if (v2[21].opt_inst_meths != (__objc2_meth_list *)-1)
              dispatch_once(&qword_1001E4610, &stru_1001B6788);
            v37 = (id)qword_1001E4608;
            if (v5)
            {
              v38 = (void *)v5[4];
              if (!v38)
              {
                v39 = (_xpc_connection_s *)objc_getProperty(v5, v36, 8, 1);
                v40 = xpc_connection_get_pid(v39);
                v41 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), v40);
                bzero(v65, 0x400uLL);
                if ((int)v40 >= 1 && proc_pidpath(v40, v65, 0x400u) >= 1 && LOBYTE(v65[0]))
                {
                  v42 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), v65, v40);

                  v41 = v42;
                }
                v43 = (void *)v5[4];
                v5[4] = v41;

                v38 = (void *)v5[4];
              }
              v44 = v38;
            }
            else
            {
              v44 = 0;
            }
            _NRLogWithArgs(v37, 16, "%s%.30s:%-4d Unknown NRUUID %@ from %@", "", "handleResolveEndpoint", 448, v20, v44);

            v17 = -2008;
          }
          else
          {
            v17 = -2008;
          }
          goto LABEL_73;
        }
        v65[0] = 0uLL;
        if (v32 == 4)
        {
          sub_100133C94(v33, v65);
        }
        else
        {
          if (v32 != 3)
          {
            if (v2[21].opt_inst_meths != (__objc2_meth_list *)-1)
              dispatch_once(&qword_1001E4610, &stru_1001B6788);
            if (_NRLogIsLevelEnabled(qword_1001E4608, 16))
            {
              if (v2[21].opt_inst_meths != (__objc2_meth_list *)-1)
                dispatch_once(&qword_1001E4610, &stru_1001B6788);
              v47 = (id)qword_1001E4608;
              v48 = v32;
              if (v5)
              {
                v49 = (void *)v5[4];
                if (!v49)
                {
                  v50 = (_xpc_connection_s *)objc_getProperty(v5, v46, 8, 1);
                  v51 = xpc_connection_get_pid(v50);
                  v52 = sub_100109ADC(v51, 1);
                  v53 = (void *)v5[4];
                  v5[4] = v52;

                  v49 = (void *)v5[4];
                }
                v54 = v49;
              }
              else
              {
                v54 = 0;
              }
              _NRLogWithArgs(v47, 16, "%s%.30s:%-4d Invalid data protection class %llu from %@", "", "handleResolveEndpoint", 459, v48, v54);

            }
            v17 = -2005;
            goto LABEL_73;
          }
          sub_10013CDB8(v33, v65);
        }
        if (v5)
          v45 = objc_getProperty(v5, v35, 24, 1);
        else
          v45 = 0;
        xpc_dictionary_set_data(v45, nrXPCKeyIPv6Address, v65, 0x10uLL);
        v17 = 0;
LABEL_73:

        goto LABEL_77;
      }
    }
    else
    {
      v59 = sub_100045324();
      IsLevelEnabled = _NRLogIsLevelEnabled(v59, 16);

      if (IsLevelEnabled)
      {
        v61 = sub_100045324();
        _NRLogWithArgs(v61, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)", "", "handleResolveEndpoint", 434);

      }
      v5 = (_QWORD *)_os_log_pack_size(12);
      v20 = (char *)v65 - ((__chkstk_darwin(v5) + 15) & 0xFFFFFFFFFFFFFFF0);
      v62 = __error();
      v63 = _os_log_pack_fill(v20, v5, *v62, &_mh_execute_header, "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
      *(_DWORD *)v63 = 136446210;
      *(_QWORD *)(v63 + 4) = "handleResolveEndpoint";
      v64 = sub_100045324();
      _NRLogAbortWithPack(v64, v20);
    }
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
    goto LABEL_24;
  }
  v55 = sub_100045324();
  v56 = _NRLogIsLevelEnabled(v55, 16);

  if (!v56)
    goto LABEL_76;
  v9 = sub_100045324();
  v16 = sub_100045394(v5, v57);
  _NRLogWithArgs(v9, 16, "%s%.30s:%-4d Missing NRUUID from %@", "", "handleResolveEndpoint", 426, v16);
LABEL_19:

  v17 = -2005;
LABEL_77:

  return v17;
}

uint64_t sub_10004B8B0(void *a1)
{
  _QWORD *Property;
  const char *v2;
  _QWORD *v3;
  xpc_object_t value;
  void *v5;
  uint64_t v6;
  _BOOL8 v7;
  const char *v8;
  const char *v9;
  id v10;
  void *v11;
  const char *v12;
  id v13;
  const char *v14;
  void *v15;
  _xpc_connection_s *v16;
  uint64_t pid;
  id v18;
  id v19;
  void *v20;
  id v21;
  unsigned __int8 *v22;
  int v23;
  id *v24;
  id *v25;
  id v26;
  id v27;
  uint64_t v28;
  void *i;
  void *v30;
  id v31;
  void *v32;
  void *v34;
  _QWORD *v35;
  id obj;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  _BYTE buffer[1024];

  Property = a1;
  v3 = Property;
  if (Property)
    Property = objc_getProperty(Property, v2, 16, 1);
  value = xpc_dictionary_get_value(Property, nrXPCKeyPacketLoggingVal);
  v5 = (void *)objc_claimAutoreleasedReturnValue(value);
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_BOOL)
  {
    v7 = xpc_BOOL_get_value(v5);
    if (qword_1001E4700 != -1)
      dispatch_once(&qword_1001E4700, &stru_1001B6E28);
    if (_NRLogIsLevelEnabled(qword_1001E46F8, 1))
    {
      if (qword_1001E4700 != -1)
        dispatch_once(&qword_1001E4700, &stru_1001B6E28);
      v8 = "Dis";
      if (v7)
        v8 = "En";
      if (gNRPacketLoggingEnabled)
        v9 = "en";
      else
        v9 = "dis";
      _NRLogWithArgs(qword_1001E46F8, 1, "%s%.30s:%-4d %sabling packet logging (was %sabled)", "", "terminusdSettingsSetPacketLoggingEnabled", 122, v8, v9);
    }
    os_unfair_lock_lock((os_unfair_lock_t)&unk_1001E46E0);
    gNRPacketLoggingEnabled = v7;
    v10 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithContentsOfFile:", CFSTR("/var/mobile/Library/terminus/com.apple.terminus.plist"));
    if (!v10)
      v10 = objc_alloc_init((Class)NSMutableDictionary);
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v7));
    objc_msgSend(v10, "setObject:forKeyedSubscript:", v11, CFSTR("PacketLogging"));

    LODWORD(v11) = sub_10010754C(CFSTR("/var/mobile/Library/terminus/com.apple.terminus.plist"), v10, 1);
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_1001E46E0);
    if ((_DWORD)v11)
    {
      if (qword_1001E4700 != -1)
        dispatch_once(&qword_1001E4700, &stru_1001B6E28);
      if (_NRLogIsLevelEnabled(qword_1001E46F8, 0))
      {
        if (qword_1001E4700 != -1)
          dispatch_once(&qword_1001E4700, &stru_1001B6E28);
        _NRLogWithArgs(qword_1001E46F8, 0, "%s%.30s:%-4d %sabled packet logging");
      }
    }
    else
    {
      if (qword_1001E4700 != -1)
        dispatch_once(&qword_1001E4700, &stru_1001B6E28);
      if (_NRLogIsLevelEnabled(qword_1001E46F8, 16))
      {
        if (qword_1001E4700 != -1)
          dispatch_once(&qword_1001E4700, &stru_1001B6E28);
        _NRLogWithArgs(qword_1001E46F8, 16, "%s%.30s:%-4d Failed to %sable packet logging");
      }
    }

    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      v13 = (id)qword_1001E4608;
      if (v7)
        v14 = "En";
      else
        v14 = "Dis";
      if (v3)
      {
        v15 = (void *)v3[4];
        if (!v15)
        {
          v16 = (_xpc_connection_s *)objc_getProperty(v3, v12, 8, 1);
          pid = xpc_connection_get_pid(v16);
          v18 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
          bzero(buffer, 0x400uLL);
          if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
          {
            v19 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

            v18 = v19;
          }
          v20 = (void *)v3[4];
          v3[4] = v18;

          v15 = (void *)v3[4];
        }
        v21 = v15;
      }
      else
      {
        v21 = 0;
      }
      _NRLogWithArgs(v13, 0, "%s%.30s:%-4d %sabled packet logging due to request from %@", "", "handleSetPacketLogging", 478, v14, v21);

    }
    objc_opt_self(NRLinkDirector);
    if (qword_1001E4710 != -1)
      dispatch_once(&qword_1001E4710, &stru_1001B6E60);
    v22 = (unsigned __int8 *)(id)qword_1001E4708;
    if (v22 && (v23 = v22[10], v22, v23))
    {
      objc_opt_self(NRLinkDirector);
      if (qword_1001E4710 != -1)
        dispatch_once(&qword_1001E4710, &stru_1001B6E60);
      v34 = v5;
      v35 = v3;
      v24 = (id *)(id)qword_1001E4708;
      v25 = v24;
      if (v24)
      {
        v39 = 0u;
        v40 = 0u;
        v37 = 0u;
        v38 = 0u;
        obj = v24[25];
        v26 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v37, buffer, 16);
        if (v26)
        {
          v27 = v26;
          v28 = *(_QWORD *)v38;
          do
          {
            for (i = 0; i != v27; i = (char *)i + 1)
            {
              if (*(_QWORD *)v38 != v28)
                objc_enumerationMutation(obj);
              v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v25[25], "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v37 + 1) + 8 * (_QWORD)i)));
              if (v30)
              {
                v31 = objc_alloc_init((Class)NSMutableDictionary);
                v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", gNRPacketLoggingEnabled));
                objc_msgSend(v31, "setObject:forKeyedSubscript:", v32, CFSTR("packet-logging"));

                sub_1000EF368((uint64_t)v30, v31);
              }

            }
            v27 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v37, buffer, 16);
          }
          while (v27);
        }

      }
      v6 = 0;
      v5 = v34;
      v3 = v35;
    }
    else
    {
      v6 = 0;
    }
  }
  else
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    if (_NRLogIsLevelEnabled(qword_1001E4608, 16))
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      _NRLogWithArgs(qword_1001E4608, 16, "%s%.30s:%-4d Received an invalid type for SetPacketLogging", "", "handleSetPacketLogging", 470);
      v6 = -2005;
    }
    else
    {
      v6 = -2005;
    }
  }

  return v6;
}

uint64_t sub_10004BFE8(void *a1)
{
  _QWORD *Property;
  const char *v2;
  _QWORD *v3;
  xpc_object_t value;
  void *v5;
  uint64_t v6;
  _BOOL8 v7;
  const char *v8;
  const char *v9;
  id v10;
  void *v11;
  id v12;
  void *v13;
  uint64_t v14;
  id v15;
  id v16;
  id v17;
  uint64_t v18;
  void *i;
  const char *v20;
  id v21;
  const char *v22;
  void *v23;
  _xpc_connection_s *v24;
  uint64_t pid;
  id v26;
  id v27;
  void *v28;
  id v29;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  _BYTE buffer[1024];

  Property = a1;
  v3 = Property;
  if (Property)
    Property = objc_getProperty(Property, v2, 16, 1);
  value = xpc_dictionary_get_value(Property, nrXPCKeyMPKLLoggingVal);
  v5 = (void *)objc_claimAutoreleasedReturnValue(value);
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_BOOL)
  {
    v7 = xpc_BOOL_get_value(v5);
    if (qword_1001E4700 != -1)
      dispatch_once(&qword_1001E4700, &stru_1001B6E28);
    if (_NRLogIsLevelEnabled(qword_1001E46F8, 1))
    {
      if (qword_1001E4700 != -1)
        dispatch_once(&qword_1001E4700, &stru_1001B6E28);
      if (v7)
        v8 = "En";
      else
        v8 = "Dis";
      if (gNRMPKLLoggingEnabled)
        v9 = "en";
      else
        v9 = "dis";
      _NRLogWithArgs(qword_1001E46F8, 1, "%s%.30s:%-4d %sabling MPKL logging (was %sabled)", "", "terminusdSettingsSetMPKLLoggingEnabled", 142, v8, v9);
    }
    os_unfair_lock_lock((os_unfair_lock_t)&unk_1001E46E0);
    gNRMPKLLoggingEnabled = v7;
    v10 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithContentsOfFile:", CFSTR("/var/mobile/Library/terminus/com.apple.terminus.plist"));
    if (!v10)
      v10 = objc_alloc_init((Class)NSMutableDictionary);
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v7));
    objc_msgSend(v10, "setObject:forKeyedSubscript:", v11, CFSTR("MPKLLogging"));

    LODWORD(v11) = sub_10010754C(CFSTR("/var/mobile/Library/terminus/com.apple.terminus.plist"), v10, 1);
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_1001E46E0);
    if ((_DWORD)v11)
    {
      if (qword_1001E4700 != -1)
        dispatch_once(&qword_1001E4700, &stru_1001B6E28);
      if (_NRLogIsLevelEnabled(qword_1001E46F8, 0))
      {
        if (qword_1001E4700 != -1)
          dispatch_once(&qword_1001E4700, &stru_1001B6E28);
        _NRLogWithArgs(qword_1001E46F8, 0, "%s%.30s:%-4d %sabled MPKL logging");
      }
    }
    else
    {
      if (qword_1001E4700 != -1)
        dispatch_once(&qword_1001E4700, &stru_1001B6E28);
      if (_NRLogIsLevelEnabled(qword_1001E46F8, 16))
      {
        if (qword_1001E4700 != -1)
          dispatch_once(&qword_1001E4700, &stru_1001B6E28);
        _NRLogWithArgs(qword_1001E46F8, 16, "%s%.30s:%-4d Failed to %sable MPKL logging");
      }
    }

    objc_opt_self(NRLinkDirector);
    if (qword_1001E4710 != -1)
      dispatch_once(&qword_1001E4710, &stru_1001B6E60);
    v12 = (id)qword_1001E4708;
    v13 = v12;
    if (v12)
    {
      v14 = *((_QWORD *)v12 + 5);
      if (v14)
      {
        v33 = 0u;
        v34 = 0u;
        v31 = 0u;
        v32 = 0u;
        v15 = *(id *)(v14 + 56);
        v16 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v31, buffer, 16);
        if (v16)
        {
          v17 = v16;
          v18 = *(_QWORD *)v32;
          do
          {
            for (i = 0; i != v17; i = (char *)i + 1)
            {
              if (*(_QWORD *)v32 != v18)
                objc_enumerationMutation(v15);
              objc_msgSend(*(id *)(*((_QWORD *)&v31 + 1) + 8 * (_QWORD)i), "virtualInterface");
            }
            v17 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v31, buffer, 16);
          }
          while (v17);
        }

      }
    }

    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      v21 = (id)qword_1001E4608;
      if (v7)
        v22 = "En";
      else
        v22 = "Dis";
      if (v3)
      {
        v23 = (void *)v3[4];
        if (!v23)
        {
          v24 = (_xpc_connection_s *)objc_getProperty(v3, v20, 8, 1);
          pid = xpc_connection_get_pid(v24);
          v26 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
          bzero(buffer, 0x400uLL);
          if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
          {
            v27 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

            v26 = v27;
          }
          v28 = (void *)v3[4];
          v3[4] = v26;

          v23 = (void *)v3[4];
        }
        v29 = v23;
      }
      else
      {
        v29 = 0;
      }
      _NRLogWithArgs(v21, 0, "%s%.30s:%-4d %sabled MPKL logging due to request from %@", "", "handleSetMPKLLogging", 499, v22, v29);

    }
    v6 = 0;
  }
  else
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    if (_NRLogIsLevelEnabled(qword_1001E4608, 16))
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      _NRLogWithArgs(qword_1001E4608, 16, "%s%.30s:%-4d Received an invalid type for SetMPKLLogging", "", "handleSetMPKLLogging", 491);
      v6 = -2005;
    }
    else
    {
      v6 = -2005;
    }
  }

  return v6;
}

uint64_t sub_10004C664(void *a1)
{
  id v1;
  char *v2;
  _QWORD *Property;
  const char *v4;
  _QWORD *v5;
  const unsigned __int8 *uuid;
  const unsigned __int8 *v7;
  const char *v8;
  id v9;
  void *v10;
  _xpc_connection_s *v11;
  uint64_t pid;
  id v13;
  id v14;
  void *v15;
  id v16;
  uint64_t v17;
  id v18;
  id v19;
  uint64_t v20;
  NSObject *v21;
  char *v22;
  void *v23;
  const char *v24;
  id v25;
  void *v26;
  _xpc_connection_s *v27;
  uint64_t v28;
  id v29;
  id v30;
  void *v31;
  id v32;
  void *v33;
  void *v34;
  const char *v35;
  id v36;
  id v38;
  int IsLevelEnabled;
  const char *v40;
  id v41;
  int v42;
  id v43;
  uint64_t v44;
  uint64_t v45;
  id v46;
  int v47;
  id v48;
  uint64_t v49;
  id v50;
  _QWORD v52[128];

  Property = a1;
  v5 = Property;
  if (Property)
    Property = objc_getProperty(Property, v4, 16, 1);
  uuid = xpc_dictionary_get_uuid(Property, nrXPCKeyBluetoothUUID);
  if (!uuid)
  {
    v38 = sub_100045324();
    IsLevelEnabled = _NRLogIsLevelEnabled(v38, 16);

    if (!IsLevelEnabled)
      goto LABEL_20;
    v9 = sub_100045324();
    v16 = sub_100045394(v5, v40);
    _NRLogWithArgs(v9, 16, "%s%.30s:%-4d Missing BluetoothUUID from %@", "", "handleCompanionLinkCopyNRUUIDForBluetoothUUID", 517, v16);
LABEL_19:

LABEL_20:
    v17 = -2005;
    goto LABEL_41;
  }
  v7 = uuid;
  if (uuid_is_null(uuid))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    if (!_NRLogIsLevelEnabled(qword_1001E4608, 16))
      goto LABEL_20;
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v9 = (id)qword_1001E4608;
    if (v5)
    {
      v10 = (void *)v5[4];
      if (!v10)
      {
        v11 = (_xpc_connection_s *)objc_getProperty(v5, v8, 8, 1);
        pid = xpc_connection_get_pid(v11);
        v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(v52, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, v52, 0x400u) >= 1 && LOBYTE(v52[0]))
        {
          v14 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), v52, pid);

          v13 = v14;
        }
        v15 = (void *)v5[4];
        v5[4] = v13;

        v10 = (void *)v5[4];
      }
      v16 = v10;
    }
    else
    {
      v16 = 0;
    }
    _NRLogWithArgs(v9, 16, "%s%.30s:%-4d All-zero BluetoothUUID from %@", "", "handleCompanionLinkCopyNRUUIDForBluetoothUUID", 521, v16);
    goto LABEL_19;
  }
  v18 = objc_msgSend(objc_alloc((Class)NSUUID), "initWithUUIDBytes:", v7);
  if (!v18)
  {
    v41 = sub_100045324();
    v42 = _NRLogIsLevelEnabled(v41, 16);

    if (v42)
    {
      v43 = sub_100045324();
      _NRLogWithArgs(v43, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (bluetoothUUID) != ((void *)0)", "", "handleCompanionLinkCopyNRUUIDForBluetoothUUID", 525);

    }
    v5 = (_QWORD *)_os_log_pack_size(12);
    v22 = (char *)&v52[-1] - ((__chkstk_darwin(v5) + 15) & 0xFFFFFFFFFFFFFFF0);
    v44 = *__error();
    v45 = _os_log_pack_fill(v22, v5, v44, &_mh_execute_header, "%{public}s Assertion Failed: (bluetoothUUID) != ((void *)0)");
    goto LABEL_50;
  }
  v19 = v18;
  v20 = objc_opt_self(NRDLocalDevice);
  v21 = sub_10014CFBC();
  dispatch_assert_queue_V2(v21);

  v22 = (char *)v19;
  objc_opt_self(v20);
  v2 = sub_100134B14((uint64_t)NRDLocalDevice, v22, 1);

  if (v2)
    v23 = (void *)*((_QWORD *)v2 + 4);
  else
    v23 = 0;
  v1 = v23;

  if (!v1)
  {
    v46 = sub_100045324();
    v47 = _NRLogIsLevelEnabled(v46, 16);

    if (v47)
    {
      v48 = sub_100045324();
      _NRLogWithArgs(v48, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)", "", "handleCompanionLinkCopyNRUUIDForBluetoothUUID", 527);

    }
    v5 = (_QWORD *)_os_log_pack_size(12);
    v22 = (char *)&v52[-1] - ((__chkstk_darwin(v5) + 15) & 0xFFFFFFFFFFFFFFF0);
    v49 = *__error();
    v45 = _os_log_pack_fill(v22, v5, v49, &_mh_execute_header, "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
LABEL_50:
    *(_DWORD *)v45 = 136446210;
    *(_QWORD *)(v45 + 4) = "handleCompanionLinkCopyNRUUIDForBluetoothUUID";
    v50 = sub_100045324();
    _NRLogAbortWithPack(v50, v22);
    goto LABEL_51;
  }
  v2 = (char *)&OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
  if (qword_1001E4610 != -1)
LABEL_51:
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (*((_QWORD *)v2 + 194) != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v25 = (id)qword_1001E4608;
    if (v5)
    {
      v26 = (void *)v5[4];
      if (!v26)
      {
        v27 = (_xpc_connection_s *)objc_getProperty(v5, v24, 8, 1);
        v28 = xpc_connection_get_pid(v27);
        v29 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), v28);
        bzero(v52, 0x400uLL);
        if ((int)v28 >= 1 && proc_pidpath(v28, v52, 0x400u) >= 1 && LOBYTE(v52[0]))
        {
          v30 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), v52, v28);

          v29 = v30;
        }
        v31 = (void *)v5[4];
        v5[4] = v29;

        v26 = (void *)v5[4];
      }
      v32 = v26;
    }
    else
    {
      v32 = 0;
    }
    v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "UUIDString"));
    v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "UUIDString"));
    _NRLogWithArgs(v25, 0, "%s%.30s:%-4d Informing %@ that BTUUID %@ maps to NRUUID %@", "", "handleCompanionLinkCopyNRUUIDForBluetoothUUID", 529, v32, v33, v34);

  }
  v52[0] = 0;
  v52[1] = 0;
  objc_msgSend(v1, "getUUIDBytes:", v52);
  if (v5)
    v36 = objc_getProperty(v5, v35, 24, 1);
  else
    v36 = 0;
  xpc_dictionary_set_uuid(v36, nrXPCKeyNRUUID, (const unsigned __int8 *)v52);

  v17 = 0;
LABEL_41:

  return v17;
}

uint64_t sub_10004CCEC(void *a1)
{
  __objc2_prot *v1;
  _QWORD *Property;
  const char *v3;
  _QWORD *v4;
  const unsigned __int8 *uuid;
  const unsigned __int8 *v6;
  const char *v7;
  __objc2_meth_list *v8;
  void *v9;
  _xpc_connection_s *v10;
  uint64_t pid;
  id v12;
  id v13;
  void *v14;
  id v15;
  uint64_t v16;
  id v17;
  void *v18;
  char *v19;
  char *v20;
  id v21;
  const char *v22;
  id v23;
  void *v24;
  _xpc_connection_s *v25;
  uint64_t v26;
  id v27;
  id v28;
  void *v29;
  id v30;
  void *v31;
  void *v32;
  const char *v33;
  id v34;
  const char *v35;
  id v36;
  void *v37;
  _xpc_connection_s *v38;
  uint64_t v39;
  id v40;
  id v41;
  void *v42;
  id v43;
  id v44;
  int IsLevelEnabled;
  const char *v46;
  id v48;
  int v49;
  id v50;
  char *v51;
  int *v52;
  uint64_t v53;
  id v54;
  _QWORD v56[128];

  Property = a1;
  v4 = Property;
  if (Property)
    Property = objc_getProperty(Property, v3, 16, 1);
  uuid = xpc_dictionary_get_uuid(Property, nrXPCKeyNRUUID);
  if (!uuid)
  {
    v44 = sub_100045324();
    IsLevelEnabled = _NRLogIsLevelEnabled(v44, 16);

    if (IsLevelEnabled)
    {
      v8 = (__objc2_meth_list *)sub_100045324();
      v15 = sub_100045394(v4, v46);
      _NRLogWithArgs(v8, 16, "%s%.30s:%-4d Missing nrUUID from %@", "", "handleCompanionLinkCopyBluetoothUUIDForNRUUID", 540, v15);
LABEL_18:

      v16 = -2005;
      goto LABEL_57;
    }
    goto LABEL_56;
  }
  v6 = uuid;
  if (uuid_is_null(uuid))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v1 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
    if (_NRLogIsLevelEnabled(qword_1001E4608, 16))
    {
      if (qword_1001E4610 == -1)
      {
LABEL_9:
        v8 = v1[21].class_meths;
        if (v4)
        {
          v9 = (void *)v4[4];
          if (!v9)
          {
            v10 = (_xpc_connection_s *)objc_getProperty(v4, v7, 8, 1);
            pid = xpc_connection_get_pid(v10);
            v12 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
            bzero(v56, 0x400uLL);
            if ((int)pid >= 1 && proc_pidpath(pid, v56, 0x400u) >= 1 && LOBYTE(v56[0]))
            {
              v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), v56, pid);

              v12 = v13;
            }
            v14 = (void *)v4[4];
            v4[4] = v12;

            v9 = (void *)v4[4];
          }
          v15 = v9;
        }
        else
        {
          v15 = 0;
        }
        _NRLogWithArgs(v8, 16, "%s%.30s:%-4d All-zero nrUUID from %@", "", "handleCompanionLinkCopyBluetoothUUIDForNRUUID", 544, v15);
        goto LABEL_18;
      }
LABEL_61:
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
      goto LABEL_9;
    }
LABEL_56:
    v16 = -2005;
    goto LABEL_57;
  }
  v17 = objc_msgSend(objc_alloc((Class)NSUUID), "initWithUUIDBytes:", v6);
  if (!v17)
  {
    v48 = sub_100045324();
    v49 = _NRLogIsLevelEnabled(v48, 16);

    if (v49)
    {
      v50 = sub_100045324();
      _NRLogWithArgs(v50, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)", "", "handleCompanionLinkCopyBluetoothUUIDForNRUUID", 548);

    }
    v4 = (_QWORD *)_os_log_pack_size(12);
    v51 = (char *)&v56[-1] - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0);
    v52 = __error();
    v53 = _os_log_pack_fill(v51, v4, *v52, &_mh_execute_header, "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
    *(_DWORD *)v53 = 136446210;
    *(_QWORD *)(v53 + 4) = "handleCompanionLinkCopyBluetoothUUIDForNRUUID";
    v54 = sub_100045324();
    _NRLogAbortWithPack(v54, v51);
    goto LABEL_61;
  }
  v18 = v17;
  v19 = sub_1001300EC((uint64_t)NRDLocalDevice, v17, 0);
  v20 = v19;
  if (v19)
  {
    v21 = *((id *)v19 + 5);
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      v23 = (id)qword_1001E4608;
      if (v4)
      {
        v24 = (void *)v4[4];
        if (!v24)
        {
          v25 = (_xpc_connection_s *)objc_getProperty(v4, v22, 8, 1);
          v26 = xpc_connection_get_pid(v25);
          v27 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), v26);
          bzero(v56, 0x400uLL);
          if ((int)v26 >= 1 && proc_pidpath(v26, v56, 0x400u) >= 1 && LOBYTE(v56[0]))
          {
            v28 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), v56, v26);

            v27 = v28;
          }
          v29 = (void *)v4[4];
          v4[4] = v27;

          v24 = (void *)v4[4];
        }
        v30 = v24;
      }
      else
      {
        v30 = 0;
      }
      v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "UUIDString"));
      v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "UUIDString"));
      _NRLogWithArgs(v23, 0, "%s%.30s:%-4d Informing %@ that NRUUID %@ maps to BTUUID %@", "", "handleCompanionLinkCopyBluetoothUUIDForNRUUID", 557, v30, v31, v32);

    }
    v56[0] = 0;
    v56[1] = 0;
    objc_msgSend(v21, "getUUIDBytes:", v56);
    if (v4)
      v34 = objc_getProperty(v4, v33, 24, 1);
    else
      v34 = 0;
    xpc_dictionary_set_uuid(v34, nrXPCKeyBluetoothUUID, (const unsigned __int8 *)v56);

    v16 = 0;
  }
  else
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    if (_NRLogIsLevelEnabled(qword_1001E4608, 16))
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      v36 = (id)qword_1001E4608;
      if (v4)
      {
        v37 = (void *)v4[4];
        if (!v37)
        {
          v38 = (_xpc_connection_s *)objc_getProperty(v4, v35, 8, 1);
          v39 = xpc_connection_get_pid(v38);
          v40 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), v39);
          bzero(v56, 0x400uLL);
          if ((int)v39 >= 1 && proc_pidpath(v39, v56, 0x400u) >= 1 && LOBYTE(v56[0]))
          {
            v41 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), v56, v39);

            v40 = v41;
          }
          v42 = (void *)v4[4];
          v4[4] = v40;

          v37 = (void *)v4[4];
        }
        v43 = v37;
      }
      else
      {
        v43 = 0;
      }
      _NRLogWithArgs(v36, 16, "%s%.30s:%-4d Unknown NRUUID %@ from %@", "", "handleCompanionLinkCopyBluetoothUUIDForNRUUID", 552, v18, v43);

    }
    v16 = -2008;
  }

LABEL_57:
  return v16;
}

uint64_t sub_10004D408(void *a1)
{
  char *v1;
  _QWORD *Property;
  const char *v3;
  _QWORD *v4;
  const char *string;
  const char *v6;
  const char *v7;
  id v8;
  __objc2_prot *v9;
  char *v10;
  char *v11;
  char *v12;
  char v13;
  id v14;
  id v15;
  const char *v16;
  id v17;
  void *v18;
  _xpc_connection_s *v19;
  uint64_t v20;
  id v21;
  id v22;
  void *v23;
  id v24;
  void *v25;
  const char *v26;
  id v27;
  const char *v28;
  id v29;
  void *v30;
  _xpc_connection_s *v31;
  uint64_t v32;
  id v33;
  id v34;
  void *v35;
  id v36;
  uint64_t v37;
  const char *v38;
  void *v39;
  _xpc_connection_s *v40;
  uint64_t pid;
  id v42;
  id v43;
  void *v44;
  id v45;
  id v47;
  int IsLevelEnabled;
  const char *v49;
  id v50;
  int v51;
  id v52;
  uint64_t v53;
  uint64_t v54;
  id v55;
  int v56;
  id v57;
  uint64_t v58;
  id v59;
  _QWORD v61[128];

  Property = a1;
  v4 = Property;
  if (Property)
    Property = objc_getProperty(Property, v3, 16, 1);
  string = xpc_dictionary_get_string(Property, nrXPCKeyIDSDeviceID);
  if (!string)
  {
    v47 = sub_100045324();
    IsLevelEnabled = _NRLogIsLevelEnabled(v47, 16);

    if (!IsLevelEnabled)
      goto LABEL_46;
    v29 = sub_100045324();
    v36 = sub_100045394(v4, v49);
    _NRLogWithArgs(v29, 16, "%s%.30s:%-4d Missing idsDeviceIDString from %@", "", "handleCompanionLinkCopyNRUUIDForIDSDeviceID", 568, v36);
    goto LABEL_45;
  }
  v7 = string;
  if (*string)
  {
    if (v4)
      v8 = objc_getProperty(v4, v6, 16, 1);
    else
      v8 = 0;
    v9 = (__objc2_prot *)xpc_dictionary_get_BOOL(v8, nrXPCKeyShouldCreateDevice);
    v10 = (char *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v7));
    if (v10)
    {
      v11 = v10;
      v12 = sub_100134EE8((uint64_t)NRDLocalDevice, v10, (int)v9);
      v1 = v12;
      if (v12)
        v13 = 1;
      else
        v13 = (char)v9;
      if ((v13 & 1) == 0)
      {
        v9 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
        if (qword_1001E4610 == -1)
        {
LABEL_48:
          if (!_NRLogIsLevelEnabled(qword_1001E4608, 0))
          {
LABEL_61:

            v37 = 0;
            goto LABEL_62;
          }
          if (v9[21].opt_inst_meths != (__objc2_meth_list *)-1)
            dispatch_once(&qword_1001E4610, &stru_1001B6788);
          v15 = (id)qword_1001E4608;
          if (v4)
          {
            v39 = (void *)v4[4];
            if (!v39)
            {
              v40 = (_xpc_connection_s *)objc_getProperty(v4, v38, 8, 1);
              pid = xpc_connection_get_pid(v40);
              v42 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
              bzero(v61, 0x400uLL);
              if ((int)pid >= 1 && proc_pidpath(pid, v61, 0x400u) >= 1 && LOBYTE(v61[0]))
              {
                v43 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), v61, pid);

                v42 = v43;
              }
              v44 = (void *)v4[4];
              v4[4] = v42;

              v39 = (void *)v4[4];
            }
            v45 = v39;
          }
          else
          {
            v45 = 0;
          }
          _NRLogWithArgs(v15, 0, "%s%.30s:%-4d Informing %@ that IDSDeviceID %@ does not map to any known device", "", "handleCompanionLinkCopyNRUUIDForIDSDeviceID", 582, v45, v11);

LABEL_60:
          goto LABEL_61;
        }
LABEL_72:
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
        goto LABEL_48;
      }
      if (v12)
      {
        v14 = *((id *)v12 + 4);
        if (v14)
        {
          v15 = v14;
          if (qword_1001E4610 != -1)
            dispatch_once(&qword_1001E4610, &stru_1001B6788);
          if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
          {
            if (qword_1001E4610 != -1)
              dispatch_once(&qword_1001E4610, &stru_1001B6788);
            v17 = (id)qword_1001E4608;
            if (v4)
            {
              v18 = (void *)v4[4];
              if (!v18)
              {
                v19 = (_xpc_connection_s *)objc_getProperty(v4, v16, 8, 1);
                v20 = xpc_connection_get_pid(v19);
                v21 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), v20);
                bzero(v61, 0x400uLL);
                if ((int)v20 >= 1 && proc_pidpath(v20, v61, 0x400u) >= 1 && LOBYTE(v61[0]))
                {
                  v22 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), v61, v20);

                  v21 = v22;
                }
                v23 = (void *)v4[4];
                v4[4] = v21;

                v18 = (void *)v4[4];
              }
              v24 = v18;
            }
            else
            {
              v24 = 0;
            }
            v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "UUIDString"));
            _NRLogWithArgs(v17, 0, "%s%.30s:%-4d Informing %@ that IDSDeviceID %@ maps to NRUUID %@", "", "handleCompanionLinkCopyNRUUIDForIDSDeviceID", 589, v24, v11, v25);

          }
          v61[0] = 0;
          v61[1] = 0;
          objc_msgSend(v15, "getUUIDBytes:", v61);
          if (v4)
            v27 = objc_getProperty(v4, v26, 24, 1);
          else
            v27 = 0;
          xpc_dictionary_set_uuid(v27, nrXPCKeyNRUUID, (const unsigned __int8 *)v61);
          goto LABEL_60;
        }
      }
      v55 = sub_100045324();
      v56 = _NRLogIsLevelEnabled(v55, 16);

      if (v56)
      {
        v57 = sub_100045324();
        _NRLogWithArgs(v57, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)", "", "handleCompanionLinkCopyNRUUIDForIDSDeviceID", 587);

      }
      v4 = (_QWORD *)_os_log_pack_size(12);
      v11 = (char *)&v61[-1] - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0);
      v58 = *__error();
      v54 = _os_log_pack_fill(v11, v4, v58, &_mh_execute_header, "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
    }
    else
    {
      v50 = sub_100045324();
      v51 = _NRLogIsLevelEnabled(v50, 16);

      if (v51)
      {
        v52 = sub_100045324();
        _NRLogWithArgs(v52, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (idsDeviceID) != ((void *)0)", "", "handleCompanionLinkCopyNRUUIDForIDSDeviceID", 577);

      }
      v4 = (_QWORD *)_os_log_pack_size(12);
      v11 = (char *)&v61[-1] - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0);
      v53 = *__error();
      v54 = _os_log_pack_fill(v11, v4, v53, &_mh_execute_header, "%{public}s Assertion Failed: (idsDeviceID) != ((void *)0)");
    }
    *(_DWORD *)v54 = 136446210;
    *(_QWORD *)(v54 + 4) = "handleCompanionLinkCopyNRUUIDForIDSDeviceID";
    v59 = sub_100045324();
    _NRLogAbortWithPack(v59, v11);
    goto LABEL_72;
  }
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 16))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v29 = (id)qword_1001E4608;
    if (v4)
    {
      v30 = (void *)v4[4];
      if (!v30)
      {
        v31 = (_xpc_connection_s *)objc_getProperty(v4, v28, 8, 1);
        v32 = xpc_connection_get_pid(v31);
        v33 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), v32);
        bzero(v61, 0x400uLL);
        if ((int)v32 >= 1 && proc_pidpath(v32, v61, 0x400u) >= 1 && LOBYTE(v61[0]))
        {
          v34 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), v61, v32);

          v33 = v34;
        }
        v35 = (void *)v4[4];
        v4[4] = v33;

        v30 = (void *)v4[4];
      }
      v36 = v30;
    }
    else
    {
      v36 = 0;
    }
    _NRLogWithArgs(v29, 16, "%s%.30s:%-4d Empty idsDeviceIDString from %@", "", "handleCompanionLinkCopyNRUUIDForIDSDeviceID", 572, v36);
LABEL_45:

  }
LABEL_46:
  v37 = -2005;
LABEL_62:

  return v37;
}

uint64_t sub_10004DBE8(void *a1)
{
  _QWORD *v1;
  const char *v2;
  const char *v3;
  id v4;
  void *v5;
  _xpc_connection_s *Property;
  uint64_t pid;
  id v8;
  id v9;
  void *v10;
  id v11;
  id v12;
  _BYTE buffer[1024];

  v1 = a1;
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v4 = (id)qword_1001E4608;
    if (v1)
    {
      v5 = (void *)v1[4];
      if (!v5)
      {
        Property = (_xpc_connection_s *)objc_getProperty(v1, v3, 8, 1);
        pid = xpc_connection_get_pid(Property);
        v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          v9 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v8 = v9;
        }
        v10 = (void *)v1[4];
        v1[4] = v8;

        v5 = (void *)v1[4];
      }
      v11 = v5;
    }
    else
    {
      v11 = 0;
    }
    _NRLogWithArgs(v4, 0, "%s%.30s:%-4d Informing %@ that the networkrelay version is %u", "", "handleCompanionLinkGetNetworkRelayVersion", 508, v11, 22);

  }
  if (v1)
    v12 = objc_getProperty(v1, v2, 24, 1);
  else
    v12 = 0;
  xpc_dictionary_set_uint64(v12, nrXPCKeyNetworkRelayVersion, 0x16uLL);

  return 0;
}

uint64_t sub_10004DDF0(void *a1)
{
  _QWORD *v1;
  id v2;
  const char *v3;
  id v4;
  void *v5;
  _xpc_connection_s *Property;
  uint64_t pid;
  id v8;
  id v9;
  void *v10;
  id v11;
  void *v12;
  const char *v13;
  id v14;
  uint64_t v15;
  const char *v16;
  id v17;
  void *v18;
  _xpc_connection_s *v19;
  uint64_t v20;
  id v21;
  id v22;
  void *v23;
  id v24;
  _QWORD buffer[128];

  v1 = a1;
  v2 = sub_1001383A0((uint64_t)NRDLocalDevice);
  if (v2)
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      v4 = (id)qword_1001E4608;
      if (v1)
      {
        v5 = (void *)v1[4];
        if (!v5)
        {
          Property = (_xpc_connection_s *)objc_getProperty(v1, v3, 8, 1);
          pid = xpc_connection_get_pid(Property);
          v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
          bzero(buffer, 0x400uLL);
          if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && LOBYTE(buffer[0]))
          {
            v9 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

            v8 = v9;
          }
          v10 = (void *)v1[4];
          v1[4] = v8;

          v5 = (void *)v1[4];
        }
        v11 = v5;
      }
      else
      {
        v11 = 0;
      }
      v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "UUIDString"));
      _NRLogWithArgs(v4, 0, "%s%.30s:%-4d Informing %@ that best testing NRUUID is %@", "", "handleCompanionLinkCopyBestTestingNRUUID", 604, v11, v12);

    }
    buffer[0] = 0;
    buffer[1] = 0;
    objc_msgSend(v2, "getUUIDBytes:", buffer);
    if (v1)
      v14 = objc_getProperty(v1, v13, 24, 1);
    else
      v14 = 0;
    xpc_dictionary_set_uuid(v14, nrXPCKeyNRUUID, (const unsigned __int8 *)buffer);
    v15 = 0;
  }
  else
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      v17 = (id)qword_1001E4608;
      if (v1)
      {
        v18 = (void *)v1[4];
        if (!v18)
        {
          v19 = (_xpc_connection_s *)objc_getProperty(v1, v16, 8, 1);
          v20 = xpc_connection_get_pid(v19);
          v21 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), v20);
          bzero(buffer, 0x400uLL);
          if ((int)v20 >= 1 && proc_pidpath(v20, buffer, 0x400u) >= 1 && LOBYTE(buffer[0]))
          {
            v22 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, v20);

            v21 = v22;
          }
          v23 = (void *)v1[4];
          v1[4] = v21;

          v18 = (void *)v1[4];
        }
        v24 = v18;
      }
      else
      {
        v24 = 0;
      }
      _NRLogWithArgs(v17, 0, "%s%.30s:%-4d Could not find a best test device for %@", "", "handleCompanionLinkCopyBestTestingNRUUID", 601, v24);

    }
    v15 = -2011;
  }

  return v15;
}

uint64_t sub_10004E19C(void *a1)
{
  _QWORD *v1;
  id v2;
  id v3;
  void *v4;
  _QWORD *Property;
  const char *v6;
  _QWORD *v7;
  const unsigned __int8 *uuid;
  const unsigned __int8 *v9;
  const char *v10;
  id v11;
  void *v12;
  _xpc_connection_s *v13;
  uint64_t pid;
  id v15;
  id v16;
  void *v17;
  id v18;
  uint64_t v19;
  id v20;
  void *v21;
  const char *v22;
  const char *v23;
  id v24;
  void *v25;
  _xpc_connection_s *v26;
  uint64_t v27;
  id v28;
  id v29;
  void *v30;
  id v31;
  void *v32;
  id v33;
  const char *v34;
  id v35;
  uint64_t uint64;
  const char *v37;
  uint64_t v38;
  int v39;
  int v40;
  id v41;
  const char *v42;
  id v43;
  const void *data;
  const char *v45;
  id v46;
  const char *v47;
  _BOOL4 v48;
  id v49;
  const char *v50;
  _BOOL4 v51;
  id v52;
  const void *v53;
  const void *v54;
  id v55;
  _QWORD *v56;
  unsigned __int8 *v57;
  const char *v58;
  int v59;
  id v60;
  xpc_object_t value;
  void *v62;
  void *v63;
  void *v64;
  const char *v65;
  id v66;
  xpc_object_t v67;
  void *v68;
  const char *v69;
  void *v70;
  id v71;
  const char *v72;
  id v73;
  uint64_t v74;
  NSObject *v75;
  char *v76;
  id v77;
  void *v78;
  char *v79;
  const char *v80;
  id v81;
  id v82;
  id v83;
  xpc_object_t v84;
  void *v85;
  id v86;
  void *v87;
  id v88;
  id v89;
  const void *bytes_ptr;
  id v91;
  void *v92;
  uint64_t v93;
  void *v94;
  void *v95;
  id v96;
  const void *v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  NSSet *v104;
  void *v105;
  uint64_t v106;
  const char *string_ptr;
  const __CFString *v108;
  void *v109;
  id v110;
  const char *v111;
  id v112;
  uint64_t v113;
  id v114;
  void *v115;
  id v116;
  void *v117;
  int v118;
  id v119;
  int v120;
  id v121;
  id v122;
  int v123;
  const char *v124;
  id v126;
  int IsLevelEnabled;
  id v128;
  uint64_t v129;
  uint64_t v130;
  id v131;
  int v132;
  id v133;
  id v134;
  int v135;
  id v136;
  id v137;
  int v138;
  id v139;
  uint64_t v140;
  id v141;
  _QWORD v142[2];
  id v143;
  _BOOL4 v144;
  _BOOL4 v145;
  unsigned int v146;
  int v147;
  int64_t int64;
  id v149;
  void *v150;
  id v151;
  id v152;
  void (**v153)(_QWORD, uint64_t, const __CFString *);
  void *v154;
  id v155;
  id v156;
  _QWORD v157[4];
  id v158;
  size_t v159;
  size_t v160[128];

  Property = a1;
  v7 = Property;
  if (Property)
    Property = objc_getProperty(Property, v6, 16, 1);
  uuid = xpc_dictionary_get_uuid(Property, nrXPCKeyNRUUID);
  if (uuid)
  {
    v9 = uuid;
    if (uuid_is_null(uuid))
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      if (_NRLogIsLevelEnabled(qword_1001E4608, 16))
      {
        if (qword_1001E4610 != -1)
          dispatch_once(&qword_1001E4610, &stru_1001B6788);
        v11 = (id)qword_1001E4608;
        if (v7)
        {
          v12 = (void *)v7[4];
          if (!v12)
          {
            v13 = (_xpc_connection_s *)objc_getProperty(v7, v10, 8, 1);
            pid = xpc_connection_get_pid(v13);
            v15 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
            bzero(v160, 0x400uLL);
            if ((int)pid >= 1 && proc_pidpath(pid, v160, 0x400u) >= 1 && LOBYTE(v160[0]))
            {
              v16 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), v160, pid);

              v15 = v16;
            }
            v17 = (void *)v7[4];
            v7[4] = v15;

            v12 = (void *)v7[4];
          }
          v18 = v12;
        }
        else
        {
          v18 = 0;
        }
        _NRLogWithArgs(v11, 16, "%s%.30s:%-4d All-zero NRUUID from %@", "", "handleRegisterDeviceByNRUUID", 619, v18);
        goto LABEL_19;
      }
LABEL_142:
      v19 = -2005;
      goto LABEL_143;
    }
    v20 = objc_msgSend(objc_alloc((Class)NSUUID), "initWithUUIDBytes:", v9);
    if (!v20)
    {
      v126 = sub_100045324();
      IsLevelEnabled = _NRLogIsLevelEnabled(v126, 16);

      if (IsLevelEnabled)
      {
        v128 = sub_100045324();
        _NRLogWithArgs(v128, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)", "", "handleRegisterDeviceByNRUUID", 623);

      }
      v7 = (_QWORD *)_os_log_pack_size(12);
      v76 = (char *)v142 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0);
      v129 = *__error();
      v130 = _os_log_pack_fill(v76, v7, v129, &_mh_execute_header, "%{public}s Assertion Failed: (nrUUID) != ((void *)0)", v142[0]);
      goto LABEL_155;
    }
    v21 = v20;
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      v24 = (id)qword_1001E4608;
      if (v7)
      {
        v25 = (void *)v7[4];
        if (!v25)
        {
          v26 = (_xpc_connection_s *)objc_getProperty(v7, v23, 8, 1);
          v27 = xpc_connection_get_pid(v26);
          v28 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), v27);
          bzero(v160, 0x400uLL);
          if ((int)v27 >= 1 && proc_pidpath(v27, v160, 0x400u) >= 1 && LOBYTE(v160[0]))
          {
            v29 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), v160, v27);

            v28 = v29;
          }
          v30 = (void *)v7[4];
          v7[4] = v28;

          v25 = (void *)v7[4];
        }
        v31 = v25;
      }
      else
      {
        v31 = 0;
      }
      v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "UUIDString"));
      _NRLogWithArgs(v24, 0, "%s%.30s:%-4d Client %@ registering %@", "", "handleRegisterDeviceByNRUUID", 624, v31, v32);

    }
    if (v7)
      v33 = objc_getProperty(v7, v22, 16, 1);
    else
      v33 = 0;
    int64 = xpc_dictionary_get_int64(v33, nrXPCKeyPairingProtocolVersion);
    if (v7)
      v35 = objc_getProperty(v7, v34, 16, 1);
    else
      v35 = 0;
    uint64 = xpc_dictionary_get_uint64(v35, nrXPCKeyPeerNetworkRelayVersion);
    v38 = uint64;
    if (uint64 < 0x10000)
    {
      v40 = uint64;
    }
    else
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      v39 = _NRLogIsLevelEnabled(qword_1001E4608, 0);
      v40 = 0;
      if (v39)
      {
        if (qword_1001E4610 != -1)
          dispatch_once(&qword_1001E4610, &stru_1001B6788);
        _NRLogWithArgs(qword_1001E4608, 0, "%s%.30s:%-4d ignoring invalid peer version %llu", "", "handleRegisterDeviceByNRUUID", 630, v38);
        v40 = 0;
      }
    }
    v147 = v40;
    if (v7)
      v41 = objc_getProperty(v7, v37, 16, 1);
    else
      v41 = 0;
    v146 = xpc_dictionary_get_BOOL(v41, nrXPCKeyWasInitiallySetupUsingIDSPairing);
    v160[0] = 0;
    v150 = v21;
    if (v7)
      v43 = objc_getProperty(v7, v42, 16, 1);
    else
      v43 = 0;
    data = xpc_dictionary_get_data(v43, nrXPCKeyOutOfBandKey, v160);
    if (data)
    {
      v2 = +[NSData _newZeroingDataWithBytes:length:](NSData, "_newZeroingDataWithBytes:length:", data, v160[0]);
      if (v7)
      {
LABEL_53:
        v46 = objc_getProperty(v7, v45, 16, 1);
        goto LABEL_54;
      }
    }
    else
    {
      v2 = 0;
      if (v7)
        goto LABEL_53;
    }
    v46 = 0;
LABEL_54:
    v48 = xpc_dictionary_get_BOOL(v46, nrXPCKeyPairWithSPPLink);
    if (v7)
      v49 = objc_getProperty(v7, v47, 16, 1);
    else
      v49 = 0;
    v51 = xpc_dictionary_get_BOOL(v49, nrXPCKeyIsAltAccountPairing);
    v159 = 0;
    if (v7)
      v52 = objc_getProperty(v7, v50, 16, 1);
    else
      v52 = 0;
    v53 = xpc_dictionary_get_data(v52, nrXPCKeyRemoteDeviceMACAddress, &v159);
    if (v53)
    {
      v54 = v53;
      v55 = objc_alloc((Class)NSData);
      v151 = objc_msgSend(v55, "initWithBytes:length:", v54, v159);
    }
    else
    {
      v151 = 0;
    }
    v157[0] = _NSConcreteStackBlock;
    v157[1] = 3221225472;
    v157[2] = sub_100059334;
    v157[3] = &unk_1001B7008;
    v1 = v7;
    v158 = v1;
    v56 = objc_retainBlock(v157);
    objc_opt_self(NRLinkDirector);
    if (qword_1001E4710 != -1)
      dispatch_once(&qword_1001E4710, &stru_1001B6E60);
    v57 = (unsigned __int8 *)(id)qword_1001E4708;
    if (v57)
    {
      v59 = v57[8];

      if (v59)
      {
        v131 = sub_100045324();
        v132 = _NRLogIsLevelEnabled(v131, 16);

        v4 = v150;
        if (v132)
        {
          v133 = sub_100045324();
          _NRLogWithArgs(v133, 16, "%s%.30s:%-4d Pairing was attempted while in fixed interface mode for NRUUID %@", "", "handleRegisterDeviceByNRUUID", 665, v150);

        }
        ((void (*)(_QWORD *, uint64_t, const __CFString *))v56[2])(v56, -2016, CFSTR("Pairing was attempted while in fixed interface mode"));
        v87 = v151;
        goto LABEL_112;
      }
    }
    v153 = (void (**)(_QWORD, uint64_t, const __CFString *))v56;
    v144 = v51;
    v145 = v48;
    if (v7)
      v60 = objc_getProperty(v1, v58, 16, 1);
    else
      v60 = 0;
    value = xpc_dictionary_get_value(v60, nrXPCKeyOperationalPropData);
    v62 = (void *)objc_claimAutoreleasedReturnValue(value);
    v149 = v62;
    if (!v62 || (v63 = v62, xpc_get_type(v62) != (xpc_type_t)&_xpc_type_data))
    {
      v64 = 0;
      goto LABEL_72;
    }
    v89 = objc_alloc((Class)NSData);
    bytes_ptr = xpc_data_get_bytes_ptr(v63);
    v3 = objc_msgSend(v89, "initWithBytes:length:", bytes_ptr, xpc_data_get_length(v63));
    v156 = 0;
    v91 = +[NSKeyedUnarchiver unarchivedObjectOfClass:fromData:error:](NSKeyedUnarchiver, "unarchivedObjectOfClass:fromData:error:", objc_opt_class(NRDeviceOperationalProperties), v3, &v156);
    v92 = (void *)objc_claimAutoreleasedReturnValue(v91);
    v152 = v156;
    if (v92
      && (v93 = objc_opt_class(NRDeviceOperationalProperties), (objc_opt_isKindOfClass(v92, v93) & 1) != 0)
      && !v152)
    {
      v94 = v92;
      v95 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v92, "allowedLinkTypes"));
      v154 = v94;
      if (objc_msgSend(v95, "count"))
      {
LABEL_102:

LABEL_130:
        v64 = v154;
LABEL_72:
        sub_10010B4E0(v64);
        if (v7)
          v66 = objc_getProperty(v1, v65, 16, 1);
        else
          v66 = 0;
        v67 = xpc_dictionary_get_value(v66, nrXPCKeyPeerIPAddressData);
        v68 = (void *)objc_claimAutoreleasedReturnValue(v67);
        v154 = v64;
        v152 = v68;
        if (v68 && (v70 = v68, xpc_get_type(v68) == (xpc_type_t)&_xpc_type_data))
        {
          v143 = v2;
          v96 = objc_alloc((Class)NSData);
          v97 = xpc_data_get_bytes_ptr(v70);
          v88 = objc_msgSend(v96, "initWithBytes:length:", v97, xpc_data_get_length(v70));
          v142[1] = NSSet;
          v142[0] = objc_opt_class(NSDictionary);
          v98 = objc_opt_class(NSArray);
          v99 = objc_opt_class(NSUUID);
          v100 = objc_opt_class(NSData);
          v101 = objc_opt_class(NSDate);
          v102 = objc_opt_class(NSNumber);
          v103 = objc_opt_class(NSString);
          v104 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", v142[0], v98, v99, v100, v101, v102, v103, objc_opt_class(NWAddressEndpoint), 0);
          v105 = (void *)objc_claimAutoreleasedReturnValue(v104);
          v155 = 0;
          v3 = (id)objc_claimAutoreleasedReturnValue(+[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:](NSKeyedUnarchiver, "unarchivedObjectOfClasses:fromData:error:", v105, v88, &v155));
          v86 = v155;
          if (!v3
            || (v106 = objc_opt_class(NSDictionary), (objc_opt_isKindOfClass(v3, v106) & 1) == 0)
            || v86)
          {
            v4 = v150;
            v56 = v153;
            if (qword_1001E4610 != -1)
              dispatch_once(&qword_1001E4610, &stru_1001B6788);
            v87 = v151;
            if (_NRLogIsLevelEnabled(qword_1001E4608, 17))
            {
              if (qword_1001E4610 != -1)
                dispatch_once(&qword_1001E4610, &stru_1001B6788);
              _NRLogWithArgs(qword_1001E4608, 17, "Failed to unarchive peer IP properties %@", v86);
            }
            v153[2](v153, -2005, CFSTR("Failed to unarchive peer IP properties"));

            v2 = v143;
            goto LABEL_110;
          }

          v4 = v150;
          v2 = v143;
          if (v7)
            goto LABEL_77;
        }
        else
        {
          v3 = 0;
          v4 = v150;
          if (v7)
          {
LABEL_77:
            v71 = objc_getProperty(v1, v69, 16, 1);
LABEL_78:
            v56 = v153;
            if (!xpc_dictionary_get_BOOL(v71, nrXPCKeyIsEphemeral))
            {
LABEL_93:
              if (v7)
                v83 = objc_getProperty(v1, v72, 16, 1);
              else
                v83 = 0;
              v84 = xpc_dictionary_get_value(v83, nrXPCKeyCandidateService);
              v85 = (void *)objc_claimAutoreleasedReturnValue(v84);
              v86 = v85;
              v87 = v151;
              if (v85 && xpc_get_type(v85) == (xpc_type_t)&_xpc_type_string)
              {
                string_ptr = xpc_string_get_string_ptr(v86);
                v87 = v151;
                v88 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", string_ptr));
              }
              else
              {
                v88 = 0;
              }
              sub_100135314((uint64_t)NRDLocalDevice, v4, int64, (unsigned __int16)v147, v146, v2, (void *)v145, v144, v87, v154, v3, v88, v56);
LABEL_110:

              v92 = v154;
LABEL_111:

LABEL_112:
              v19 = -2000;
              goto LABEL_143;
            }
            v73 = v4;
            v74 = objc_opt_self(NRDLocalDevice);
            if ((_NRIsUUIDNonZero(v73) & 1) != 0)
            {
              v75 = sub_10014CFBC();
              dispatch_assert_queue_V2(v75);

              sub_10012DFA0(v74);
              v76 = (char *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)qword_1001E4A38, "objectForKeyedSubscript:", v73));
              if (v76)
                goto LABEL_89;
              if (qword_1001E4A98 != -1)
                dispatch_once(&qword_1001E4A98, &stru_1001B8730);
              if (_NRLogIsLevelEnabled(qword_1001E4A90, 0))
              {
                if (qword_1001E4A98 != -1)
                  dispatch_once(&qword_1001E4A98, &stru_1001B8730);
                v77 = (id)qword_1001E4A90;
                v78 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v73, "UUIDString"));
                _NRLogWithArgs(v77, 0, "%s%.30s:%-4d Creating new ephemeral local device for query %@", "", "+[NRDLocalDevice createEphemeralLocalDeviceForNRUUID:]", 2143, v78);

              }
              v79 = sub_10012A18C((char *)[NRDLocalDevice alloc], v73);
              v76 = v79;
              if (v79)
              {
                v79[24] = 1;
                objc_msgSend((id)qword_1001E4A38, "setObject:forKeyedSubscript:", v79, v73);
LABEL_89:

                objc_opt_self(NRLinkDirector);
                if (qword_1001E4710 == -1)
                {
LABEL_90:
                  v56 = v153;
                  v81 = (id)qword_1001E4708;
                  if (v7)
                    v82 = objc_getProperty(v1, v80, 8, 1);
                  else
                    v82 = 0;
                  sub_1000AFB18((uint64_t)v81, v76, v82);

                  goto LABEL_93;
                }
LABEL_156:
                dispatch_once(&qword_1001E4710, &stru_1001B6E60);
                goto LABEL_90;
              }
              objc_msgSend((id)qword_1001E4A38, "setObject:forKeyedSubscript:", 0, v73);
            }
            else
            {
              v134 = sub_100128400();
              v135 = _NRLogIsLevelEnabled(v134, 17);

              if (v135)
              {
                v136 = sub_100128400();
                _NRLogWithArgs(v136, 17, "called with all-zero nrUUID");

              }
            }

            v137 = sub_100045324();
            v138 = _NRLogIsLevelEnabled(v137, 16);

            if (v138)
            {
              v139 = sub_100045324();
              _NRLogWithArgs(v139, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)", "", "handleRegisterDeviceByNRUUID", 723);

            }
            v7 = (_QWORD *)_os_log_pack_size(12);
            v76 = (char *)v142 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0);
            v140 = *__error();
            v130 = _os_log_pack_fill(v76, v7, v140, &_mh_execute_header, "%{public}s Assertion Failed: (localDevice) != ((void *)0)", v142[0]);
LABEL_155:
            *(_DWORD *)v130 = 136446210;
            *(_QWORD *)(v130 + 4) = "handleRegisterDeviceByNRUUID";
            v141 = sub_100045324();
            _NRLogAbortWithPack(v141, v76);
            goto LABEL_156;
          }
        }
        v71 = 0;
        goto LABEL_78;
      }
      v143 = v2;
      v109 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v94, "allowedLinkSubtypes"));
      v110 = objc_msgSend(v109, "count");

      if (v110)
      {
        v2 = v143;
        goto LABEL_130;
      }
      if (v7)
        v112 = objc_getProperty(v1, v111, 8, 1);
      else
        v112 = 0;
      v113 = nrXPCEntitlementTesting;
      v114 = v112;
      v115 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v113));
      LODWORD(v113) = sub_10005943C(v114, v115);

      v116 = sub_100045324();
      v117 = v116;
      if ((_DWORD)v113)
      {
        v118 = _NRLogIsLevelEnabled(v116, 0);

        v2 = v143;
        if (v118)
        {
          v119 = sub_100045324();
          _NRLogWithArgs(v119, 0, "%s%.30s:%-4d Ignoring operational properties", "", "handleRegisterDeviceByNRUUID", 688);

        }
        v95 = v154;
        v154 = 0;
        goto LABEL_102;
      }
      v120 = _NRLogIsLevelEnabled(v116, 17);

      v2 = v143;
      if (v120)
      {
        v121 = sub_100045324();
        _NRLogWithArgs(v121, 17, "Received invalid operational properties %@", v154);

        v92 = v154;
        v108 = CFSTR("Received invalid operational properties");
        v4 = v150;
        v87 = v151;
        v56 = v153;
      }
      else
      {
        v108 = CFSTR("Received invalid operational properties");
        v4 = v150;
        v87 = v151;
        v56 = v153;
        v92 = v154;
      }
    }
    else
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      v4 = v150;
      v87 = v151;
      v56 = v153;
      if (_NRLogIsLevelEnabled(qword_1001E4608, 17))
      {
        if (qword_1001E4610 != -1)
          dispatch_once(&qword_1001E4610, &stru_1001B6788);
        _NRLogWithArgs(qword_1001E4608, 17, "Failed to unarchive operational properties %@", v152);
      }
      v108 = CFSTR("Failed to unarchive operational properties");
    }
    ((void (*)(_QWORD *, uint64_t, const __CFString *))v56[2])(v56, -2005, v108);
    goto LABEL_111;
  }
  v122 = sub_100045324();
  v123 = _NRLogIsLevelEnabled(v122, 16);

  if (!v123)
    goto LABEL_142;
  v11 = sub_100045324();
  v18 = sub_100045394(v7, v124);
  _NRLogWithArgs(v11, 16, "%s%.30s:%-4d Missing NRUUID from %@", "", "handleRegisterDeviceByNRUUID", 615, v18);
LABEL_19:

  v19 = -2005;
LABEL_143:

  return v19;
}

uint64_t sub_10004F3A8(void *a1)
{
  __objc2_prot *v1;
  _QWORD *Property;
  const char *v3;
  _QWORD *v4;
  const unsigned __int8 *uuid;
  const unsigned __int8 *v6;
  const char *v7;
  id v8;
  void *v9;
  _xpc_connection_s *v10;
  uint64_t pid;
  id v12;
  id v13;
  void *v14;
  id v15;
  uint64_t v16;
  char *v17;
  char *v18;
  const char *v19;
  id v20;
  void *v21;
  _xpc_connection_s *v22;
  uint64_t v23;
  id v24;
  id v25;
  void *v26;
  id v27;
  void *v28;
  const char *v29;
  id v30;
  id v31;
  id v33;
  int IsLevelEnabled;
  const char *v35;
  id v36;
  int v37;
  id v38;
  int *v39;
  uint64_t v40;
  id v41;
  _QWORD v42[4];
  _QWORD *v43;
  _BYTE v44[1024];

  Property = a1;
  v4 = Property;
  if (Property)
    Property = objc_getProperty(Property, v3, 16, 1);
  uuid = xpc_dictionary_get_uuid(Property, nrXPCKeyNRUUID);
  if (!uuid)
  {
    v33 = sub_100045324();
    IsLevelEnabled = _NRLogIsLevelEnabled(v33, 16);

    if (!IsLevelEnabled)
      goto LABEL_20;
    v8 = sub_100045324();
    v15 = sub_100045394(v4, v35);
    _NRLogWithArgs(v8, 16, "%s%.30s:%-4d Missing NRUUID from %@", "", "handleUnregisterDeviceByNRUUID", 753, v15);
LABEL_19:

LABEL_20:
    v16 = -2005;
    goto LABEL_40;
  }
  v6 = uuid;
  if (uuid_is_null(uuid))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    if (!_NRLogIsLevelEnabled(qword_1001E4608, 16))
      goto LABEL_20;
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v8 = (id)qword_1001E4608;
    if (v4)
    {
      v9 = (void *)v4[4];
      if (!v9)
      {
        v10 = (_xpc_connection_s *)objc_getProperty(v4, v7, 8, 1);
        pid = xpc_connection_get_pid(v10);
        v12 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(v44, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, v44, 0x400u) >= 1 && v44[0])
        {
          v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), v44, pid);

          v12 = v13;
        }
        v14 = (void *)v4[4];
        v4[4] = v12;

        v9 = (void *)v4[4];
      }
      v15 = v9;
    }
    else
    {
      v15 = 0;
    }
    _NRLogWithArgs(v8, 16, "%s%.30s:%-4d All-zero NRUUID from %@", "", "handleUnregisterDeviceByNRUUID", 757, v15);
    goto LABEL_19;
  }
  v17 = (char *)objc_msgSend(objc_alloc((Class)NSUUID), "initWithUUIDBytes:", v6);
  if (!v17)
  {
    v36 = sub_100045324();
    v37 = _NRLogIsLevelEnabled(v36, 16);

    if (v37)
    {
      v38 = sub_100045324();
      _NRLogWithArgs(v38, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)", "", "handleUnregisterDeviceByNRUUID", 761);

    }
    v4 = (_QWORD *)_os_log_pack_size(12);
    v18 = (char *)v42 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0);
    v39 = __error();
    v40 = _os_log_pack_fill(v18, v4, *v39, &_mh_execute_header, "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
    *(_DWORD *)v40 = 136446210;
    *(_QWORD *)(v40 + 4) = "handleUnregisterDeviceByNRUUID";
    v41 = sub_100045324();
    _NRLogAbortWithPack(v41, v18);
    goto LABEL_46;
  }
  v18 = v17;
  v1 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
  if (qword_1001E4610 != -1)
LABEL_46:
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (v1[21].opt_inst_meths != (__objc2_meth_list *)-1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v20 = (id)qword_1001E4608;
    if (v4)
    {
      v21 = (void *)v4[4];
      if (!v21)
      {
        v22 = (_xpc_connection_s *)objc_getProperty(v4, v19, 8, 1);
        v23 = xpc_connection_get_pid(v22);
        v24 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), v23);
        bzero(v44, 0x400uLL);
        if ((int)v23 >= 1 && proc_pidpath(v23, v44, 0x400u) >= 1 && v44[0])
        {
          v25 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), v44, v23);

          v24 = v25;
        }
        v26 = (void *)v4[4];
        v4[4] = v24;

        v21 = (void *)v4[4];
      }
      v27 = v21;
    }
    else
    {
      v27 = 0;
    }
    v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "UUIDString"));
    _NRLogWithArgs(v20, 0, "%s%.30s:%-4d Client %@ unregistering %@", "", "handleUnregisterDeviceByNRUUID", 762, v27, v28);

  }
  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v30 = (id)qword_1001E4708;
  if (v4)
    v31 = objc_getProperty(v4, v29, 8, 1);
  else
    v31 = 0;
  sub_1000AFB18((uint64_t)v30, 0, v31);

  v42[0] = _NSConcreteStackBlock;
  v42[1] = 3221225472;
  v42[2] = sub_100059228;
  v42[3] = &unk_1001B7008;
  v43 = v4;
  sub_1001370D8((uint64_t)NRDLocalDevice, v18, v42);

  v16 = -2000;
LABEL_40:

  return v16;
}

uint64_t sub_10004F978(void *a1)
{
  _QWORD *v1;
  const char *v2;
  id v3;
  void *v4;
  _xpc_connection_s *Property;
  uint64_t pid;
  id v7;
  id v8;
  void *v9;
  id v10;
  uint64_t v11;
  NSObject *v12;
  id v13;
  id v14;
  id v15;
  uint64_t v16;
  void *i;
  char *v18;
  void *v19;
  char *v20;
  char *v21;
  id v22;
  void *v23;
  char *v24;
  uint64_t v25;
  NSObject *v26;
  id v27;
  uint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  id obj;
  _QWORD v33[2];
  void (*v34)(uint64_t, int64_t, void *);
  void *v35;
  id v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  _BYTE buffer[1024];

  v1 = a1;
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v3 = (id)qword_1001E4608;
    if (v1)
    {
      v4 = (void *)v1[4];
      if (!v4)
      {
        Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8, 1);
        pid = xpc_connection_get_pid(Property);
        v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v7 = v8;
        }
        v9 = (void *)v1[4];
        v1[4] = v7;

        v4 = (void *)v1[4];
      }
      v10 = v4;
    }
    else
    {
      v10 = 0;
    }
    _NRLogWithArgs(v3, 0, "%s%.30s:%-4d Client %@ unregistering all devices", "", "handleUnregisterAllDevices", 784, v10);

  }
  v33[0] = _NSConcreteStackBlock;
  v33[1] = 3221225472;
  v34 = sub_10005911C;
  v35 = &unk_1001B7008;
  v36 = v1;
  v31 = v1;
  v30 = v33;
  v11 = objc_opt_self(NRDLocalDevice);
  v12 = sub_10014CFBC();
  dispatch_assert_queue_V2(v12);

  v29 = v11;
  sub_10012DFA0(v11);
  v13 = objc_msgSend((id)qword_1001E4A38, "copy");
  v37 = 0u;
  v38 = 0u;
  v39 = 0u;
  v40 = 0u;
  obj = v13;
  v14 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v37, buffer, 16);
  if (v14)
  {
    v15 = v14;
    v16 = *(_QWORD *)v38;
    do
    {
      for (i = 0; i != v15; i = (char *)i + 1)
      {
        if (*(_QWORD *)v38 != v16)
          objc_enumerationMutation(obj);
        v19 = *(void **)(*((_QWORD *)&v37 + 1) + 8 * (_QWORD)i);
        v20 = sub_1001300EC((uint64_t)NRDLocalDevice, v19, 0);
        v21 = v20;
        if (v20)
        {
          v22 = *((id *)v20 + 4);
          v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "description"));
          sub_100121E18(v22, 5002, v23, 0);

          v24 = sub_1001323E0((uint64_t)NRDLocalDevice, v21);
          objc_msgSend((id)qword_1001E4A38, "setObject:forKeyedSubscript:", v24, v19);

          if (*((_QWORD *)v21 + 7))
            objc_msgSend((id)qword_1001E4A40, "setObject:forKeyedSubscript:", 0);
        }
        else
        {
          v18 = sub_1001323E0((uint64_t)NRDLocalDevice, 0);
          objc_msgSend((id)qword_1001E4A38, "setObject:forKeyedSubscript:", v18, v19);

        }
        sub_1000A04A0(v19, 0);
        sub_100131394((uint64_t)v21);

      }
      v15 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v37, buffer, 16);
    }
    while (v15);
  }

  v25 = objc_opt_self(v29);
  sub_10012EDB0(v25, 0);
  if (qword_1001E4A98 != -1)
    dispatch_once(&qword_1001E4A98, &stru_1001B8730);
  if (_NRLogIsLevelEnabled(qword_1001E4A90, 0))
  {
    if (qword_1001E4A98 != -1)
      dispatch_once(&qword_1001E4A98, &stru_1001B8730);
    _NRLogWithArgs(qword_1001E4A90, 0, "%s%.30s:%-4d Unregistered all devices", "", "+[NRDLocalDevice unregisterAllDevicesWithCompletionBlock:]", 2675);
  }
  v34((uint64_t)v30, 0, 0);
  v26 = sub_10014CFBC();
  dispatch_async(v26, &stru_1001B69F0);

  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v27 = (id)qword_1001E4708;
  sub_1000A5428((uint64_t)v27);

  return -2000;
}

uint64_t sub_10004FE6C(void *a1)
{
  __objc2_prot *v1;
  _QWORD *Property;
  const char *v3;
  _QWORD *v4;
  const unsigned __int8 *uuid;
  const unsigned __int8 *v6;
  const char *v7;
  id v8;
  void *v9;
  _xpc_connection_s *v10;
  uint64_t pid;
  id v12;
  id v13;
  void *v14;
  id v15;
  uint64_t v16;
  char *v17;
  char *v18;
  const char *v19;
  id v20;
  void *v21;
  _xpc_connection_s *v22;
  uint64_t v23;
  id v24;
  id v25;
  void *v26;
  id v27;
  void *v28;
  id v30;
  int IsLevelEnabled;
  const char *v32;
  id v33;
  int v34;
  id v35;
  int *v36;
  uint64_t v37;
  id v38;
  _QWORD v39[4];
  _QWORD *v40;
  _BYTE v41[1024];

  Property = a1;
  v4 = Property;
  if (Property)
    Property = objc_getProperty(Property, v3, 16, 1);
  uuid = xpc_dictionary_get_uuid(Property, nrXPCKeyNRUUID);
  if (!uuid)
  {
    v30 = sub_100045324();
    IsLevelEnabled = _NRLogIsLevelEnabled(v30, 16);

    if (!IsLevelEnabled)
      goto LABEL_20;
    v8 = sub_100045324();
    v15 = sub_100045394(v4, v32);
    _NRLogWithArgs(v8, 16, "%s%.30s:%-4d Missing NRUUID from %@", "", "handleEnableDeviceByNRUUID", 806, v15);
LABEL_19:

LABEL_20:
    v16 = -2005;
    goto LABEL_36;
  }
  v6 = uuid;
  if (uuid_is_null(uuid))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    if (!_NRLogIsLevelEnabled(qword_1001E4608, 16))
      goto LABEL_20;
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v8 = (id)qword_1001E4608;
    if (v4)
    {
      v9 = (void *)v4[4];
      if (!v9)
      {
        v10 = (_xpc_connection_s *)objc_getProperty(v4, v7, 8, 1);
        pid = xpc_connection_get_pid(v10);
        v12 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(v41, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, v41, 0x400u) >= 1 && v41[0])
        {
          v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), v41, pid);

          v12 = v13;
        }
        v14 = (void *)v4[4];
        v4[4] = v12;

        v9 = (void *)v4[4];
      }
      v15 = v9;
    }
    else
    {
      v15 = 0;
    }
    _NRLogWithArgs(v8, 16, "%s%.30s:%-4d All-zero NRUUID from %@", "", "handleEnableDeviceByNRUUID", 810, v15);
    goto LABEL_19;
  }
  v17 = (char *)objc_msgSend(objc_alloc((Class)NSUUID), "initWithUUIDBytes:", v6);
  if (!v17)
  {
    v33 = sub_100045324();
    v34 = _NRLogIsLevelEnabled(v33, 16);

    if (v34)
    {
      v35 = sub_100045324();
      _NRLogWithArgs(v35, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)", "", "handleEnableDeviceByNRUUID", 814);

    }
    v4 = (_QWORD *)_os_log_pack_size(12);
    v18 = (char *)v39 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0);
    v36 = __error();
    v37 = _os_log_pack_fill(v18, v4, *v36, &_mh_execute_header, "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
    *(_DWORD *)v37 = 136446210;
    *(_QWORD *)(v37 + 4) = "handleEnableDeviceByNRUUID";
    v38 = sub_100045324();
    _NRLogAbortWithPack(v38, v18);
    goto LABEL_42;
  }
  v18 = v17;
  v1 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
  if (qword_1001E4610 != -1)
LABEL_42:
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (v1[21].opt_inst_meths != (__objc2_meth_list *)-1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v20 = (id)qword_1001E4608;
    if (v4)
    {
      v21 = (void *)v4[4];
      if (!v21)
      {
        v22 = (_xpc_connection_s *)objc_getProperty(v4, v19, 8, 1);
        v23 = xpc_connection_get_pid(v22);
        v24 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), v23);
        bzero(v41, 0x400uLL);
        if ((int)v23 >= 1 && proc_pidpath(v23, v41, 0x400u) >= 1 && v41[0])
        {
          v25 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), v41, v23);

          v24 = v25;
        }
        v26 = (void *)v4[4];
        v4[4] = v24;

        v21 = (void *)v4[4];
      }
      v27 = v21;
    }
    else
    {
      v27 = 0;
    }
    v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "UUIDString"));
    _NRLogWithArgs(v20, 0, "%s%.30s:%-4d Client %@ enabling %@", "", "handleEnableDeviceByNRUUID", 815, v27, v28);

  }
  v39[0] = _NSConcreteStackBlock;
  v39[1] = 3221225472;
  v39[2] = sub_100059014;
  v39[3] = &unk_1001B7008;
  v40 = v4;
  sub_1001361B0((uint64_t)NRDLocalDevice, v18, v39);

  v16 = -2000;
LABEL_36:

  return v16;
}

uint64_t sub_1000503C8(void *a1)
{
  __objc2_prot *v1;
  _QWORD *Property;
  const char *v3;
  _QWORD *v4;
  const unsigned __int8 *uuid;
  const unsigned __int8 *v6;
  const char *v7;
  id v8;
  void *v9;
  _xpc_connection_s *v10;
  uint64_t pid;
  id v12;
  id v13;
  void *v14;
  id v15;
  uint64_t v16;
  char *v17;
  char *v18;
  const char *v19;
  id v20;
  void *v21;
  _xpc_connection_s *v22;
  uint64_t v23;
  id v24;
  id v25;
  void *v26;
  id v27;
  void *v28;
  id v30;
  int IsLevelEnabled;
  const char *v32;
  id v33;
  int v34;
  id v35;
  int *v36;
  uint64_t v37;
  id v38;
  _QWORD v39[4];
  _QWORD *v40;
  _BYTE v41[1024];

  Property = a1;
  v4 = Property;
  if (Property)
    Property = objc_getProperty(Property, v3, 16, 1);
  uuid = xpc_dictionary_get_uuid(Property, nrXPCKeyNRUUID);
  if (!uuid)
  {
    v30 = sub_100045324();
    IsLevelEnabled = _NRLogIsLevelEnabled(v30, 16);

    if (!IsLevelEnabled)
      goto LABEL_20;
    v8 = sub_100045324();
    v15 = sub_100045394(v4, v32);
    _NRLogWithArgs(v8, 16, "%s%.30s:%-4d Missing NRUUID from %@", "", "handleDisableDeviceByNRUUID", 836, v15);
LABEL_19:

LABEL_20:
    v16 = -2005;
    goto LABEL_36;
  }
  v6 = uuid;
  if (uuid_is_null(uuid))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    if (!_NRLogIsLevelEnabled(qword_1001E4608, 16))
      goto LABEL_20;
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v8 = (id)qword_1001E4608;
    if (v4)
    {
      v9 = (void *)v4[4];
      if (!v9)
      {
        v10 = (_xpc_connection_s *)objc_getProperty(v4, v7, 8, 1);
        pid = xpc_connection_get_pid(v10);
        v12 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(v41, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, v41, 0x400u) >= 1 && v41[0])
        {
          v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), v41, pid);

          v12 = v13;
        }
        v14 = (void *)v4[4];
        v4[4] = v12;

        v9 = (void *)v4[4];
      }
      v15 = v9;
    }
    else
    {
      v15 = 0;
    }
    _NRLogWithArgs(v8, 16, "%s%.30s:%-4d All-zero NRUUID from %@", "", "handleDisableDeviceByNRUUID", 840, v15);
    goto LABEL_19;
  }
  v17 = (char *)objc_msgSend(objc_alloc((Class)NSUUID), "initWithUUIDBytes:", v6);
  if (!v17)
  {
    v33 = sub_100045324();
    v34 = _NRLogIsLevelEnabled(v33, 16);

    if (v34)
    {
      v35 = sub_100045324();
      _NRLogWithArgs(v35, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)", "", "handleDisableDeviceByNRUUID", 844);

    }
    v4 = (_QWORD *)_os_log_pack_size(12);
    v18 = (char *)v39 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0);
    v36 = __error();
    v37 = _os_log_pack_fill(v18, v4, *v36, &_mh_execute_header, "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
    *(_DWORD *)v37 = 136446210;
    *(_QWORD *)(v37 + 4) = "handleDisableDeviceByNRUUID";
    v38 = sub_100045324();
    _NRLogAbortWithPack(v38, v18);
    goto LABEL_42;
  }
  v18 = v17;
  v1 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
  if (qword_1001E4610 != -1)
LABEL_42:
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (v1[21].opt_inst_meths != (__objc2_meth_list *)-1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v20 = (id)qword_1001E4608;
    if (v4)
    {
      v21 = (void *)v4[4];
      if (!v21)
      {
        v22 = (_xpc_connection_s *)objc_getProperty(v4, v19, 8, 1);
        v23 = xpc_connection_get_pid(v22);
        v24 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), v23);
        bzero(v41, 0x400uLL);
        if ((int)v23 >= 1 && proc_pidpath(v23, v41, 0x400u) >= 1 && v41[0])
        {
          v25 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), v41, v23);

          v24 = v25;
        }
        v26 = (void *)v4[4];
        v4[4] = v24;

        v21 = (void *)v4[4];
      }
      v27 = v21;
    }
    else
    {
      v27 = 0;
    }
    v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "UUIDString"));
    _NRLogWithArgs(v20, 0, "%s%.30s:%-4d Client %@ disabling %@", "", "handleDisableDeviceByNRUUID", 845, v27, v28);

  }
  v39[0] = _NSConcreteStackBlock;
  v39[1] = 3221225472;
  v39[2] = sub_100058F0C;
  v39[3] = &unk_1001B7008;
  v40 = v4;
  sub_100137528((uint64_t)NRDLocalDevice, v18, v39);

  v16 = -2000;
LABEL_36:

  return v16;
}

uint64_t sub_100050924(void *a1)
{
  _QWORD *v1;
  const char *v2;
  id v3;
  void *v4;
  _xpc_connection_s *Property;
  uint64_t pid;
  id v7;
  id v8;
  void *v9;
  id v10;
  uint64_t v11;
  NSObject *v12;
  id v13;
  id v14;
  id v15;
  id v16;
  id v17;
  uint64_t v18;
  void *i;
  id *v20;
  void *v21;
  const char *v22;
  id v23;
  const char *v24;
  id v25;
  uint64_t v26;
  id v28;
  int IsLevelEnabled;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  _BYTE buffer[1024];

  v1 = a1;
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v3 = (id)qword_1001E4608;
    if (v1)
    {
      v4 = (void *)v1[4];
      if (!v4)
      {
        Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8, 1);
        pid = xpc_connection_get_pid(Property);
        v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v7 = v8;
        }
        v9 = (void *)v1[4];
        v1[4] = v7;

        v4 = (void *)v1[4];
      }
      v10 = v4;
    }
    else
    {
      v10 = 0;
    }
    _NRLogWithArgs(v3, 0, "%s%.30s:%-4d Client %@ copying device list", "", "handleCopyDeviceListString", 1017, v10);

  }
  v11 = objc_opt_self(NRDLocalDevice);
  v12 = sub_10014CFBC();
  dispatch_assert_queue_V2(v12);

  sub_10012DFA0(v11);
  v13 = objc_msgSend((id)qword_1001E4A38, "copy");
  v14 = objc_alloc_init((Class)NSMutableString);
  objc_msgSend(v14, "appendFormat:", CFSTR("%llu devices:"), objc_msgSend(v13, "count"));
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v15 = v13;
  v16 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v30, buffer, 16);
  if (v16)
  {
    v17 = v16;
    v18 = *(_QWORD *)v31;
    do
    {
      for (i = 0; i != v17; i = (char *)i + 1)
      {
        if (*(_QWORD *)v31 != v18)
          objc_enumerationMutation(v15);
        v20 = (id *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v30 + 1) + 8 * (_QWORD)i)));
        v21 = (void *)sub_1001324D0(v20);
        objc_msgSend(v14, "appendFormat:", CFSTR("\n\t%@"), v21);

      }
      v17 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v30, buffer, 16);
    }
    while (v17);
  }

  if (v14)
  {
    if (v1)
      v23 = objc_getProperty(v1, v22, 24, 1);
    else
      v23 = 0;
    v24 = (const char *)nrXPCKeyDeviceListString;
    v25 = v23;
    xpc_dictionary_set_string(v25, v24, (const char *)objc_msgSend(v14, "UTF8String"));
    v26 = 0;
  }
  else
  {
    v28 = sub_100045324();
    IsLevelEnabled = _NRLogIsLevelEnabled(v28, 17);

    if (!IsLevelEnabled)
    {
      v26 = -2009;
      goto LABEL_27;
    }
    v25 = sub_100045324();
    _NRLogWithArgs(v25, 17, "[NRDLocalDevice copyDeviceListString] failed");
    v26 = -2009;
  }

LABEL_27:
  return v26;
}

uint64_t sub_100050CD0(void *a1)
{
  _QWORD *v1;
  const char *v2;
  id v3;
  void *v4;
  _xpc_connection_s *Property;
  uint64_t pid;
  id v7;
  id v8;
  void *v9;
  id v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD v14[4];
  id v15;
  _BYTE buffer[1024];

  v1 = a1;
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v3 = (id)qword_1001E4608;
    if (v1)
    {
      v4 = (void *)v1[4];
      if (!v4)
      {
        Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8, 1);
        pid = xpc_connection_get_pid(Property);
        v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v7 = v8;
        }
        v9 = (void *)v1[4];
        v1[4] = v7;

        v4 = (void *)v1[4];
      }
      v10 = v4;
    }
    else
    {
      v10 = 0;
    }
    _NRLogWithArgs(v3, 0, "%s%.30s:%-4d Client %@ copying IDS device ID", "", "handleCopyIDSDeviceID", 1029, v10);

  }
  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v11 = (id)qword_1001E4708;
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  v14[2] = sub_100058E20;
  v14[3] = &unk_1001B67B0;
  v15 = v1;
  v12 = v1;

  return -2000;
}

uint64_t sub_100050F38(void *a1)
{
  _QWORD *v1;
  const char *v2;
  id v3;
  void *v4;
  _xpc_connection_s *Property;
  uint64_t pid;
  id v7;
  id v8;
  void *v9;
  id v10;
  id v11;
  _BYTE buffer[1024];

  v1 = a1;
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v3 = (id)qword_1001E4608;
    if (v1)
    {
      v4 = (void *)v1[4];
      if (!v4)
      {
        Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8, 1);
        pid = xpc_connection_get_pid(Property);
        v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v7 = v8;
        }
        v9 = (void *)v1[4];
        v1[4] = v7;

        v4 = (void *)v1[4];
      }
      v10 = v4;
    }
    else
    {
      v10 = 0;
    }
    _NRLogWithArgs(v3, 0, "%s%.30s:%-4d Client %@ enabling cloud link", "", "handleEnableCloudLink", 864, v10);

  }
  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v11 = (id)qword_1001E4708;
  sub_1000AF028((uint64_t)v11, 1);

  return 0;
}

uint64_t sub_100051158(void *a1)
{
  _QWORD *v1;
  const char *v2;
  id v3;
  void *v4;
  _xpc_connection_s *Property;
  uint64_t pid;
  id v7;
  id v8;
  void *v9;
  id v10;
  id v11;
  _BYTE buffer[1024];

  v1 = a1;
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v3 = (id)qword_1001E4608;
    if (v1)
    {
      v4 = (void *)v1[4];
      if (!v4)
      {
        Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8, 1);
        pid = xpc_connection_get_pid(Property);
        v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v7 = v8;
        }
        v9 = (void *)v1[4];
        v1[4] = v7;

        v4 = (void *)v1[4];
      }
      v10 = v4;
    }
    else
    {
      v10 = 0;
    }
    _NRLogWithArgs(v3, 0, "%s%.30s:%-4d Client %@ disabling cloud link", "", "handleDisableCloudLink", 872, v10);

  }
  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v11 = (id)qword_1001E4708;
  sub_1000AF028((uint64_t)v11, 0);

  return 0;
}

uint64_t sub_100051378(void *a1)
{
  __objc2_prot *v1;
  _QWORD *Property;
  const char *v3;
  _QWORD *v4;
  const uint8_t *uuid;
  _BYTE *v6;
  _BYTE *v7;
  __objc2_prot *v8;
  id v9;
  const char *v10;
  void *v11;
  void *v12;
  _xpc_connection_s *v13;
  uint64_t pid;
  id v15;
  id v16;
  void *v17;
  id v18;
  id *v19;
  id v20;
  const char *v21;
  id v22;
  const char *v23;
  id v24;
  id v25;
  unsigned int v26;
  const char *v27;
  id v28;
  SEL v29;
  id v30;
  _BYTE *v31;
  id v32;
  void *v33;
  uint64_t v34;
  id v35;
  id v36;
  const char *v37;
  const char *v38;
  void *v39;
  _xpc_connection_s *v40;
  uint64_t v41;
  id v42;
  id v43;
  void *v44;
  uint64_t v45;
  const char *v46;
  void *v47;
  void *v48;
  _xpc_connection_s *v49;
  uint64_t v50;
  id v51;
  id v52;
  void *v53;
  id v54;
  _BYTE *v55;
  uint64_t v56;
  const char *v57;
  _xpc_connection_s *v58;
  id v59;
  int IsLevelEnabled;
  id v61;
  int *v62;
  uint64_t v63;
  id v64;
  id v65;
  int v66;
  __objc2_meth_list *v67;
  const char *v68;
  void *v69;
  void *v70;
  _xpc_connection_s *v71;
  uint64_t v72;
  id v73;
  id v74;
  void *v75;
  id v76;
  _BYTE v78[1024];

  Property = a1;
  v4 = Property;
  if (Property)
    Property = objc_getProperty(Property, v3, 16, 1);
  uuid = xpc_dictionary_get_uuid(Property, nrXPCKeyDeviceIdentifier);
  if (uuid)
  {
    v6 = objc_msgSend(objc_alloc((Class)NSUUID), "initWithUUIDBytes:", uuid);
    if (v6)
    {
      v7 = v6;
      v1 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
      if (qword_1001E4610 == -1)
        goto LABEL_6;
    }
    else
    {
      v59 = sub_100045324();
      IsLevelEnabled = _NRLogIsLevelEnabled(v59, 16);

      if (IsLevelEnabled)
      {
        v61 = sub_100045324();
        _NRLogWithArgs(v61, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (deviceIdentifier) != ((void *)0)", "", "handleDeviceMonitorStatusQuery", 1119);

      }
      v4 = (_QWORD *)_os_log_pack_size(12);
      v7 = &v78[-((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0)];
      v62 = __error();
      v63 = _os_log_pack_fill(v7, v4, *v62, &_mh_execute_header, "%{public}s Assertion Failed: (deviceIdentifier) != ((void *)0)");
      *(_DWORD *)v63 = 136446210;
      *(_QWORD *)(v63 + 4) = "handleDeviceMonitorStatusQuery";
      v64 = sub_100045324();
      _NRLogAbortWithPack(v64, v7);
    }
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
LABEL_6:
    v8 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
    if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
    {
      if (v1[21].opt_inst_meths != (__objc2_meth_list *)-1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      v9 = (id)qword_1001E4608;
      v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "UUIDString"));
      if (v4)
      {
        v12 = (void *)v4[4];
        if (!v12)
        {
          v13 = (_xpc_connection_s *)objc_getProperty(v4, v10, 8, 1);
          pid = xpc_connection_get_pid(v13);
          v15 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
          bzero(v78, 0x400uLL);
          if ((int)pid >= 1 && proc_pidpath(pid, v78, 0x400u) >= 1 && v78[0])
          {
            v16 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), v78, pid);

            v15 = v16;
          }
          v17 = (void *)v4[4];
          v4[4] = v15;

          v12 = (void *)v4[4];
        }
        v18 = v12;
      }
      else
      {
        v18 = 0;
      }
      _NRLogWithArgs(v9, 0, "%s%.30s:%-4d Received request for device monitor status query of %@ from %@", "", "handleDeviceMonitorStatusQuery", 1121, v11, v18);

    }
    objc_opt_self(NRLinkDirector);
    if (qword_1001E4710 != -1)
      dispatch_once(&qword_1001E4710, &stru_1001B6E60);
    v19 = (id *)(id)qword_1001E4708;
    objc_opt_self(TerminusdXPCServer);
    if (qword_1001E4600 != -1)
      dispatch_once(&qword_1001E4600, &stru_1001B6718);
    v20 = (id)qword_1001E45F8;
    v22 = v20;
    if (v20)
      v20 = objc_getProperty(v20, v21, 24, 1);
    v24 = v20;
    if (v4)
      v25 = objc_getProperty(v4, v23, 8, 1);
    else
      v25 = 0;
    v26 = objc_msgSend(v24, "containsObject:", v25);

    if (!v26)
    {
      if (v1[21].opt_inst_meths != (__objc2_meth_list *)-1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      if (!_NRLogIsLevelEnabled(qword_1001E4608, 16))
      {
        v45 = -2010;
LABEL_91:

        goto LABEL_92;
      }
      if (v1[21].opt_inst_meths != (__objc2_meth_list *)-1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      v36 = (id)qword_1001E4608;
      v47 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "UUIDString"));
      if (v4)
      {
        v48 = (void *)v4[4];
        if (!v48)
        {
          v49 = (_xpc_connection_s *)objc_getProperty(v4, v46, 8, 1);
          v50 = xpc_connection_get_pid(v49);
          v51 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), v50);
          bzero(v78, 0x400uLL);
          if ((int)v50 >= 1 && proc_pidpath(v50, v78, 0x400u) >= 1 && v78[0])
          {
            v52 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), v78, v50);

            v51 = v52;
          }
          v53 = (void *)v4[4];
          v4[4] = v51;

          v48 = (void *)v4[4];
        }
        v54 = v48;
      }
      else
      {
        v54 = 0;
      }
      _NRLogWithArgs(v36, 16, "%s%.30s:%-4d Connection lost before first update for %@ %@", "", "handleDeviceMonitorStatusQuery", 1140, v47, v54);

      v45 = -2010;
LABEL_90:

      goto LABEL_91;
    }
    if (v4)
    {
      v28 = objc_getProperty(v4, v27, 8, 1);
      sub_1000AF414((uint64_t)v19, v28, v7);
      v30 = objc_getProperty(v4, v29, 24, 1);
    }
    else
    {
      sub_1000AF414((uint64_t)v19, 0, v7);
      v30 = 0;
    }
    v31 = v7;
    v32 = v30;
    v33 = v32;
    if (v19)
    {
      if (v32)
      {
        v34 = objc_claimAutoreleasedReturnValue(objc_msgSend(v19[25], "objectForKeyedSubscript:", v31));
        if (v34)
        {
          v35 = (id)v34;
          sub_1000DAF7C(v34, v33);
          v36 = v33;
        }
        else
        {
          v36 = v33;
          v55 = v31;
          v56 = objc_opt_self(NRDDeviceConductor);
          sub_1000DB310(v56, v55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, v36);

          v8 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
          v35 = 0;
        }
LABEL_64:

        if (v36)
        {
          if (v4)
            v58 = (_xpc_connection_s *)objc_getProperty(v4, v57, 8, 1);
          else
            v58 = 0;
          xpc_connection_send_message(v58, v36);
          v45 = -2000;
          goto LABEL_90;
        }
LABEL_75:
        if (qword_1001E4610 != -1)
          dispatch_once(&qword_1001E4610, &stru_1001B6788);
        if (_NRLogIsLevelEnabled(v8[21].class_meths, 16))
        {
          if (qword_1001E4610 != -1)
            dispatch_once(&qword_1001E4610, &stru_1001B6788);
          v67 = v8[21].class_meths;
          v69 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v31, "UUIDString"));
          if (v4)
          {
            v70 = (void *)v4[4];
            if (!v70)
            {
              v71 = (_xpc_connection_s *)objc_getProperty(v4, v68, 8, 1);
              v72 = xpc_connection_get_pid(v71);
              v73 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), v72);
              bzero(v78, 0x400uLL);
              if ((int)v72 >= 1 && proc_pidpath(v72, v78, 0x400u) >= 1 && v78[0])
              {
                v74 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), v78, v72);

                v73 = v74;
              }
              v75 = (void *)v4[4];
              v4[4] = v73;

              v70 = (void *)v4[4];
            }
            v76 = v70;
          }
          else
          {
            v76 = 0;
          }
          _NRLogWithArgs(v67, 16, "%s%.30s:%-4d Could not get monitor status for %@ %@", "", "handleDeviceMonitorStatusQuery", 1135, v69, v76);

        }
        v36 = 0;
        v45 = -2008;
        goto LABEL_90;
      }
      v65 = sub_1000A2640();
      v66 = _NRLogIsLevelEnabled(v65, 17);

      if (v66)
      {
        v35 = sub_1000A2640();
        _NRLogWithArgs(v35, 17, "%s called with null replyDict", "-[NRLinkDirector copyDeviceMonitorStatusForNRUUID:replyDict:]");
        v36 = 0;
        goto LABEL_64;
      }
    }

    goto LABEL_75;
  }
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 16))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v7 = (id)qword_1001E4608;
    if (v4)
    {
      v19 = (id *)objc_getProperty(v4, v37, 16, 1);
      v39 = (void *)v4[4];
      if (!v39)
      {
        v40 = (_xpc_connection_s *)objc_getProperty(v4, v38, 8, 1);
        v41 = xpc_connection_get_pid(v40);
        v42 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), v41);
        bzero(v78, 0x400uLL);
        if ((int)v41 >= 1 && proc_pidpath(v41, v78, 0x400u) >= 1 && v78[0])
        {
          v43 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), v78, v41);

          v42 = v43;
        }
        v44 = (void *)v4[4];
        v4[4] = v42;

        v39 = (void *)v4[4];
      }
      v22 = v39;
    }
    else
    {
      v19 = 0;
      v22 = 0;
    }
    _NRLogWithArgs(v7, 16, "%s%.30s:%-4d No device identifier found in message %@ from %@", "", "handleDeviceMonitorStatusQuery", 1114, v19, v22);
    v45 = -2005;
    goto LABEL_91;
  }
  v45 = -2005;
LABEL_92:

  return v45;
}

uint64_t sub_100051DD4(void *a1)
{
  _QWORD *v1;
  const char *v2;
  const char *v3;
  id v4;
  void *v5;
  _xpc_connection_s *Property;
  uint64_t pid;
  id v8;
  id v9;
  void *v10;
  id v11;
  id v12;
  const uint8_t *uuid;
  const char *v14;
  id v15;
  id v16;
  xpc_object_t value;
  void *v18;
  const char *v19;
  id v20;
  id v21;
  id v22;
  const char *v23;
  const char *v24;
  id v25;
  void *v26;
  _xpc_connection_s *v27;
  uint64_t v28;
  id v29;
  id v30;
  void *v31;
  id v32;
  void *v33;
  id v34;
  xpc_object_t v35;
  void *v36;
  void *v37;
  id v38;
  id v39;
  const char *v40;
  const char *v41;
  id v42;
  id v43;
  unsigned int v44;
  const char *v45;
  id v46;
  uint64_t v47;
  SEL v48;
  id v49;
  id v50;
  id v51;
  id v52;
  id v53;
  NSObject *v54;
  uint64_t v55;
  uint64_t v56;
  id v57;
  id v58;
  uint64_t v59;
  id v60;
  id v61;
  id v62;
  NSObject *v63;
  id v64;
  uint64_t v65;
  void *v66;
  int IsLevelEnabled;
  uint64_t v68;
  void *v69;
  void *v70;
  const char *v71;
  const char *v72;
  void *v73;
  _xpc_connection_s *v74;
  uint64_t v75;
  id v76;
  id v77;
  void *v78;
  uint64_t v79;
  const char *v80;
  id v81;
  void *v82;
  void *v83;
  _xpc_connection_s *v84;
  uint64_t v85;
  id v86;
  id v87;
  void *v88;
  id v89;
  id v90;
  const char *v91;
  id v92;
  void *v93;
  _xpc_connection_s *v94;
  uint64_t v95;
  id v96;
  id v97;
  void *v98;
  id v99;
  NRDOrphanedConnection *v100;
  id *p_isa;
  void *v102;
  const char *v103;
  id v104;
  id v105;
  id v106;
  NSObject *v107;
  uint64_t v108;
  id *v109;
  id v110;
  NRDOrphanedConnection *v111;
  void *v112;
  id v114;
  int v115;
  id v116;
  int v117;
  id v118;
  int v119;
  id v120;
  id v121;
  id v122;
  void *v123;
  void *v124;
  void *v125;
  id v126;
  id v127;
  id v128;
  _BOOL4 v129;
  void *v130;
  id *v131;
  _QWORD applier[4];
  _QWORD *v133;
  id v134;
  _BYTE buffer[1024];

  v1 = a1;
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v4 = (id)qword_1001E4608;
    if (v1)
    {
      v5 = (void *)v1[4];
      if (!v5)
      {
        Property = (_xpc_connection_s *)objc_getProperty(v1, v3, 8, 1);
        pid = xpc_connection_get_pid(Property);
        v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          v9 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v8 = v9;
        }
        v10 = (void *)v1[4];
        v1[4] = v8;

        v5 = (void *)v1[4];
      }
      v11 = v5;
    }
    else
    {
      v11 = 0;
    }
    _NRLogWithArgs(v4, 0, "%s%.30s:%-4d Received request to set device preferences from %@", "", "handleDevicePreferences", 1040, v11);

  }
  if (v1)
    v12 = objc_getProperty(v1, v2, 16, 1);
  else
    v12 = 0;
  uuid = xpc_dictionary_get_uuid(v12, nrXPCKeyDeviceIdentifier);
  if (uuid)
  {
    v15 = objc_msgSend(objc_alloc((Class)NSUUID), "initWithUUIDBytes:", uuid);
    if (v1)
      v16 = objc_getProperty(v1, v14, 16, 1);
    else
      v16 = 0;
    value = xpc_dictionary_get_value(v16, nrXPCKeyDevicePreferencesPolicyTrafficClassifiers);
    v18 = (void *)objc_claimAutoreleasedReturnValue(value);
    v20 = v18;
    if (v18 && xpc_get_type(v18) == (xpc_type_t)&_xpc_type_array)
    {
      v90 = objc_alloc_init((Class)NSMutableSet);
      applier[0] = _NSConcreteStackBlock;
      applier[1] = 3221225472;
      applier[2] = sub_10005865C;
      applier[3] = &unk_1001B67D8;
      v133 = v1;
      v21 = v90;
      v134 = v21;
      xpc_array_apply(v20, applier);

      if (v1)
        goto LABEL_23;
    }
    else
    {
      v21 = 0;
      if (v1)
      {
LABEL_23:
        v22 = objc_getProperty(v1, v19, 16, 1);
        goto LABEL_24;
      }
    }
    v22 = 0;
LABEL_24:
    v129 = xpc_dictionary_get_BOOL(v22, nrXPCKeyDevicePreferencesIsDeviceSetupInProgress);
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      v25 = (id)qword_1001E4608;
      if (v1)
      {
        v26 = (void *)v1[4];
        if (!v26)
        {
          v27 = (_xpc_connection_s *)objc_getProperty(v1, v24, 8, 1);
          v28 = xpc_connection_get_pid(v27);
          v29 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), v28);
          bzero(buffer, 0x400uLL);
          if ((int)v28 >= 1 && proc_pidpath(v28, buffer, 0x400u) >= 1 && buffer[0])
          {
            v30 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, v28);

            v29 = v30;
          }
          v31 = (void *)v1[4];
          v1[4] = v29;

          v26 = (void *)v1[4];
        }
        v32 = v26;
      }
      else
      {
        v32 = 0;
      }
      v33 = (void *)_NRCopyPolicyTrafficClassifiersDescription(v21);
      _NRLogWithArgs(v25, 0, "%s%.30s:%-4d Received policy traffic classifiers from %@ for device %@ : %@", "", "handleDevicePreferences", 1082, v32, v15, v33);

    }
    if (v1)
      v34 = objc_getProperty(v1, v23, 16, 1);
    else
      v34 = 0;
    v35 = xpc_dictionary_get_value(v34, nrXPCKeyDevicePreferencesBTLinkPreferences);
    v36 = (void *)objc_claimAutoreleasedReturnValue(v35);
    v37 = v36;
    if (v36 && xpc_get_type(v36) == (xpc_type_t)&_xpc_type_dictionary)
    {
      v38 = +[NRLinkPreferences createFromEncodedXPCDict:](NRLinkPreferences, "createFromEncodedXPCDict:", v37);
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
      {
        if (qword_1001E4610 != -1)
          dispatch_once(&qword_1001E4610, &stru_1001B6788);
        v92 = (id)qword_1001E4608;
        if (v1)
        {
          v93 = (void *)v1[4];
          if (!v93)
          {
            v124 = v37;
            v94 = (_xpc_connection_s *)objc_getProperty(v1, v91, 8, 1);
            v95 = xpc_connection_get_pid(v94);
            v96 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), v95);
            bzero(buffer, 0x400uLL);
            if ((int)v95 >= 1 && proc_pidpath(v95, buffer, 0x400u) >= 1 && buffer[0])
            {
              v97 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, v95);

              v96 = v97;
            }
            v98 = (void *)v1[4];
            v1[4] = v96;

            v93 = (void *)v1[4];
            v37 = v124;
          }
          v99 = v93;
        }
        else
        {
          v99 = 0;
        }
        _NRLogWithArgs(v92, 0, "%s%.30s:%-4d Received link preferences from %@ for device %@ : %@", "", "handleDevicePreferences", 1090, v99, v15, v38);

      }
    }
    else
    {
      v38 = 0;
    }
    objc_opt_self(NRLinkDirector);
    if (qword_1001E4710 != -1)
      dispatch_once(&qword_1001E4710, &stru_1001B6E60);
    v131 = (id *)(id)qword_1001E4708;
    objc_opt_self(TerminusdXPCServer);
    if (qword_1001E4600 != -1)
      dispatch_once(&qword_1001E4600, &stru_1001B6718);
    v39 = (id)qword_1001E45F8;
    v130 = v39;
    if (v39)
      v39 = objc_getProperty(v39, v40, 24, 1);
    v42 = v39;
    if (v1)
      v43 = objc_getProperty(v1, v41, 8, 1);
    else
      v43 = 0;
    v44 = objc_msgSend(v42, "containsObject:", v43);

    if (!v44)
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      if (_NRLogIsLevelEnabled(qword_1001E4608, 16))
      {
        if (qword_1001E4610 != -1)
          dispatch_once(&qword_1001E4610, &stru_1001B6788);
        v81 = (id)qword_1001E4608;
        if (v1)
        {
          v82 = (void *)v1[4];
          if (!v82)
          {
            v83 = v37;
            v84 = (_xpc_connection_s *)objc_getProperty(v1, v80, 8, 1);
            v85 = xpc_connection_get_pid(v84);
            v86 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), v85);
            bzero(buffer, 0x400uLL);
            if ((int)v85 >= 1 && proc_pidpath(v85, buffer, 0x400u) >= 1 && buffer[0])
            {
              v87 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, v85);

              v86 = v87;
            }
            v88 = (void *)v1[4];
            v1[4] = v86;

            v82 = (void *)v1[4];
            v37 = v83;
          }
          v89 = v82;
        }
        else
        {
          v89 = 0;
        }
        _NRLogWithArgs(v81, 16, "%s%.30s:%-4d Connection lost before applying preference for %@", "", "handleDevicePreferences", 1104, v89);

      }
      goto LABEL_130;
    }
    v126 = v20;
    v127 = v38;
    if (v1)
    {
      v46 = objc_getProperty(v1, v45, 8, 1);
      v47 = (uint64_t)v131;
      sub_1000AF824((uint64_t)v131, v38, v46, v15);
      v49 = objc_getProperty(v1, v48, 8, 1);
    }
    else
    {
      v47 = (uint64_t)v131;
      sub_1000AF824((uint64_t)v131, v38, 0, v15);
      v49 = 0;
    }
    v50 = v21;
    v51 = v21;
    v52 = v49;
    v53 = v15;
    if (v47)
    {
      v54 = sub_10014CFBC();
      dispatch_assert_queue_V2(v54);

      v128 = v52;
      if (v52)
      {
        if (v53)
        {
          v55 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v47 + 200), "objectForKeyedSubscript:", v53));
          if (v55)
          {
            v56 = v55;
            v123 = v37;
            v121 = v51;
            v57 = v51;
            v58 = v52;
            dispatch_assert_queue_V2(*(dispatch_queue_t *)(v56 + 104));
            v59 = *(_QWORD *)(v56 + 184);
            v60 = v57;
            v61 = v58;
            if (v59)
            {
              v122 = v50;
              v62 = v15;
              v63 = *(NSObject **)(v59 + 24);
              if (v63)
                dispatch_assert_queue_V2(v63);
              v64 = sub_100114EE0(v61);
              v66 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v59 + 16), v65);
              IsLevelEnabled = _NRLogIsLevelEnabled(v66, 0);

              if (IsLevelEnabled)
              {
                v69 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v59 + 16), v68);
                v70 = (void *)_NRCopyPolicyTrafficClassifiersDescription(v60);
                _NRLogWithArgs(v69, 0, "%s%.30s:%-4d Setting policy traffic classifiers for %@ : %@", "", "-[NRDevicePreferencesManager setPolicyTrafficClassifiers:forConnection:]", 264, v64, v70);

              }
              objc_msgSend(*(id *)(v59 + 40), "setObject:forKeyedSubscript:", v60, v64);
              sub_100114958(v59);

              v15 = v62;
              v50 = v122;
            }

            v37 = v123;
            v47 = (uint64_t)v131;
            v51 = v121;
          }
          else
          {
            v100 = objc_alloc_init(NRDOrphanedConnection);
            p_isa = (id *)&v100->super.isa;
            if (v100)
            {
              objc_storeStrong((id *)&v100->_nrUUID, v15);
              objc_storeStrong(p_isa + 2, v49);
            }
            objc_msgSend(*(id *)(v47 + 216), "addObject:", p_isa);
            v102 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(p_isa, "description"));
            sub_100121E18(0, 1022, 0, v102);

            v56 = 0;
          }
          goto LABEL_113;
        }
        v116 = sub_1000A2640();
        v117 = _NRLogIsLevelEnabled(v116, 17);

        if (v117)
        {
          v56 = (uint64_t)sub_1000A2640();
          _NRLogWithArgs(v56, 17, "%s called with null nrUUID");
          goto LABEL_113;
        }
      }
      else
      {
        v114 = sub_1000A2640();
        v115 = _NRLogIsLevelEnabled(v114, 17);

        if (v115)
        {
          v56 = (uint64_t)sub_1000A2640();
          _NRLogWithArgs(v56, 17, "%s called with null connection");
LABEL_113:

          v52 = v128;
        }
      }
    }

    if (v129)
    {
      v21 = v50;
      if (v1)
        v104 = objc_getProperty(v1, v103, 8, 1);
      else
        v104 = 0;
      v105 = v104;
      v106 = v53;
      if (v131)
      {
        v107 = sub_10014CFBC();
        dispatch_assert_queue_V2(v107);

        v108 = objc_claimAutoreleasedReturnValue(objc_msgSend(v131[25], "objectForKeyedSubscript:", v106));
        if (v108)
        {
          v109 = (id *)v105;
          dispatch_assert_queue_V2(*(dispatch_queue_t *)(v108 + 104));
          if (v109)
          {
            objc_msgSend(*(id *)(v108 + 176), "addObject:", v109);
            if (objc_msgSend(*(id *)(v108 + 176), "count"))
              sub_1000EEF1C(v108, 1);
          }
          else
          {
            v125 = v37;
            if (qword_1001E4798 != -1)
              dispatch_once(&qword_1001E4798, &stru_1001B7628);
            v118 = (id)qword_1001E4790;
            v119 = _NRLogIsLevelEnabled(v118, 17);

            if (v119)
            {
              if (qword_1001E4798 != -1)
                dispatch_once(&qword_1001E4798, &stru_1001B7628);
              v120 = (id)qword_1001E4790;
              _NRLogWithArgs(v120, 17, "%s called with null connection", "-[NRDDeviceConductor addDeviceSetupInProgressConnection:]");

            }
            v37 = v125;
          }
        }
        else
        {
          v111 = objc_alloc_init(NRDOrphanedConnection);
          v109 = (id *)&v111->super.isa;
          if (v111)
          {
            objc_storeStrong((id *)&v111->_nrUUID, v15);
            objc_storeStrong(v109 + 2, v104);
          }
          objc_msgSend(v131[27], "addObject:", v109);
          v112 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v109, "description"));
          sub_100121E18(0, 1022, 0, v112);

        }
      }

      v20 = v126;
      v38 = v127;
    }
    else
    {
      v21 = v50;
      if (v1)
        v110 = objc_getProperty(v1, v103, 8, 1);
      else
        v110 = 0;
      v20 = v126;
      v38 = v127;
      sub_1000AF574(v47, v110);
    }
LABEL_130:

    v79 = 0;
LABEL_131:

    goto LABEL_132;
  }
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 16))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v15 = (id)qword_1001E4608;
    if (v1)
    {
      v21 = objc_getProperty(v1, v71, 16, 1);
      v73 = (void *)v1[4];
      if (!v73)
      {
        v74 = (_xpc_connection_s *)objc_getProperty(v1, v72, 8, 1);
        v75 = xpc_connection_get_pid(v74);
        v76 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), v75);
        bzero(buffer, 0x400uLL);
        if ((int)v75 >= 1 && proc_pidpath(v75, buffer, 0x400u) >= 1 && buffer[0])
        {
          v77 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, v75);

          v76 = v77;
        }
        v78 = (void *)v1[4];
        v1[4] = v76;

        v73 = (void *)v1[4];
      }
      v20 = v73;
    }
    else
    {
      v21 = 0;
      v20 = 0;
    }
    _NRLogWithArgs(v15, 16, "%s%.30s:%-4d No device identifier found in message %@ from %@", "", "handleDevicePreferences", 1044, v21, v20);
    v79 = -2005;
    goto LABEL_131;
  }
  v79 = -2005;
LABEL_132:

  return v79;
}

uint64_t sub_100052D10(void *a1)
{
  _QWORD *v1;
  const char *v2;
  id v3;
  void *v4;
  _xpc_connection_s *Property;
  uint64_t pid;
  id v7;
  id v8;
  void *v9;
  id v10;
  _BYTE buffer[1024];

  v1 = a1;
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v3 = (id)qword_1001E4608;
    if (v1)
    {
      v4 = (void *)v1[4];
      if (!v4)
      {
        Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8, 1);
        pid = xpc_connection_get_pid(Property);
        v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v7 = v8;
        }
        v9 = (void *)v1[4];
        v1[4] = v7;

        v4 = (void *)v1[4];
      }
      v10 = v4;
    }
    else
    {
      v10 = 0;
    }
    _NRLogWithArgs(v3, 0, "%s%.30s:%-4d Received a link recommendation: %@", "", "handleCompanionLinkRecommendation", 1147, v10);

  }
  return -2005;
}

uint64_t sub_100052EE0(void *a1)
{
  _QWORD *v1;
  const char *v2;
  const char *v3;
  id v4;
  void *v5;
  _xpc_connection_s *Property;
  uint64_t pid;
  id v8;
  id v9;
  void *v10;
  id v11;
  id v12;
  const char *v13;
  id v14;
  _BYTE buffer[1024];

  v1 = a1;
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v4 = (id)qword_1001E4608;
    if (v1)
    {
      v5 = (void *)v1[4];
      if (!v5)
      {
        Property = (_xpc_connection_s *)objc_getProperty(v1, v3, 8, 1);
        pid = xpc_connection_get_pid(Property);
        v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          v9 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v8 = v9;
        }
        v10 = (void *)v1[4];
        v1[4] = v8;

        v5 = (void *)v1[4];
      }
      v11 = v5;
    }
    else
    {
      v11 = 0;
    }
    _NRLogWithArgs(v4, 0, "%s%.30s:%-4d Sending babel routes to %@", "", "handleTestGetBabelRoutes", 1260, v11);

  }
  if (v1)
    v12 = objc_getProperty(v1, v2, 24, 1);
  else
    v12 = 0;
  v13 = (const char *)nrXPCKeyBabelRoutes;
  v14 = v12;
  xpc_dictionary_set_string(v14, v13, (const char *)objc_msgSend(CFSTR("BABEL_NOT_SUPPORTED"), "UTF8String"));

  return 0;
}

uint64_t sub_100053108(void *a1)
{
  __objc2_prot *v1;
  _QWORD *Property;
  const char *v3;
  _QWORD *v4;
  const unsigned __int8 *uuid;
  const unsigned __int8 *v6;
  const char *v7;
  id v8;
  void *v9;
  _xpc_connection_s *v10;
  uint64_t pid;
  id v12;
  id v13;
  void *v14;
  id v15;
  uint64_t v16;
  char *v17;
  char *v18;
  const char *v19;
  id v20;
  void *v21;
  _xpc_connection_s *v22;
  uint64_t v23;
  id v24;
  id v25;
  void *v26;
  id v27;
  id *v28;
  char *v29;
  _QWORD *v30;
  NSObject *v31;
  dispatch_queue_t *v32;
  _QWORD *v33;
  id v34;
  uint64_t v35;
  id v36;
  int IsLevelEnabled;
  const char *v38;
  id v40;
  int v41;
  id v42;
  int *v43;
  uint64_t v44;
  id v45;
  _QWORD v47[2];
  void (*v48)(uint64_t, uint64_t);
  void *v49;
  char *v50;
  _QWORD *v51;
  _BYTE v52[1024];

  Property = a1;
  v4 = Property;
  if (Property)
    Property = objc_getProperty(Property, v3, 16, 1);
  uuid = xpc_dictionary_get_uuid(Property, nrXPCKeyNRUUID);
  if (!uuid)
  {
    v36 = sub_100045324();
    IsLevelEnabled = _NRLogIsLevelEnabled(v36, 16);

    if (IsLevelEnabled)
    {
      v8 = sub_100045324();
      v15 = sub_100045394(v4, v38);
      _NRLogWithArgs(v8, 16, "%s%.30s:%-4d Missing NRUUID from %@", "", "handleMeasureBTLatency", 1273, v15);
LABEL_19:

      v16 = -2005;
      goto LABEL_49;
    }
LABEL_48:
    v16 = -2005;
    goto LABEL_49;
  }
  v6 = uuid;
  if (uuid_is_null(uuid))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    if (_NRLogIsLevelEnabled(qword_1001E4608, 16))
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      v8 = (id)qword_1001E4608;
      if (v4)
      {
        v9 = (void *)v4[4];
        if (!v9)
        {
          v10 = (_xpc_connection_s *)objc_getProperty(v4, v7, 8, 1);
          pid = xpc_connection_get_pid(v10);
          v12 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
          bzero(v52, 0x400uLL);
          if ((int)pid >= 1 && proc_pidpath(pid, v52, 0x400u) >= 1 && v52[0])
          {
            v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), v52, pid);

            v12 = v13;
          }
          v14 = (void *)v4[4];
          v4[4] = v12;

          v9 = (void *)v4[4];
        }
        v15 = v9;
      }
      else
      {
        v15 = 0;
      }
      _NRLogWithArgs(v8, 16, "%s%.30s:%-4d All-zero NRUUID from %@", "", "handleMeasureBTLatency", 1277, v15);
      goto LABEL_19;
    }
    goto LABEL_48;
  }
  v17 = (char *)objc_msgSend(objc_alloc((Class)NSUUID), "initWithUUIDBytes:", v6);
  if (!v17)
  {
    v40 = sub_100045324();
    v41 = _NRLogIsLevelEnabled(v40, 16);

    if (v41)
    {
      v42 = sub_100045324();
      _NRLogWithArgs(v42, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)", "", "handleMeasureBTLatency", 1281);

    }
    v4 = (_QWORD *)_os_log_pack_size(12);
    v18 = (char *)&v47[-1] - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0);
    v43 = __error();
    v44 = _os_log_pack_fill(v18, v4, *v43, &_mh_execute_header, "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
    *(_DWORD *)v44 = 136446210;
    *(_QWORD *)(v44 + 4) = "handleMeasureBTLatency";
    v45 = sub_100045324();
    _NRLogAbortWithPack(v45, v18);
    goto LABEL_53;
  }
  v18 = v17;
  v1 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
  if (qword_1001E4610 != -1)
LABEL_53:
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (v1[21].opt_inst_meths != (__objc2_meth_list *)-1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v20 = (id)qword_1001E4608;
    if (v4)
    {
      v21 = (void *)v4[4];
      if (!v21)
      {
        v22 = (_xpc_connection_s *)objc_getProperty(v4, v19, 8, 1);
        v23 = xpc_connection_get_pid(v22);
        v24 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), v23);
        bzero(v52, 0x400uLL);
        if ((int)v23 >= 1 && proc_pidpath(v23, v52, 0x400u) >= 1 && v52[0])
        {
          v25 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), v52, v23);

          v24 = v25;
        }
        v26 = (void *)v4[4];
        v4[4] = v24;

        v21 = (void *)v4[4];
      }
      v27 = v21;
    }
    else
    {
      v27 = 0;
    }
    _NRLogWithArgs(v20, 0, "%s%.30s:%-4d Received MeasureBTLatency %@ from %@", "", "handleMeasureBTLatency", 1282, v18, v27);

  }
  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v28 = (id *)(id)qword_1001E4708;
  v47[0] = _NSConcreteStackBlock;
  v47[1] = 3221225472;
  v48 = sub_1000583EC;
  v49 = &unk_1001B6800;
  v50 = v18;
  v51 = v4;
  v29 = v18;
  v30 = v47;
  if (v28)
  {
    v31 = sub_10014CFBC();
    dispatch_assert_queue_V2(v31);

    v32 = (dispatch_queue_t *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28[25], "objectForKeyedSubscript:", v29));
    if (v32)
    {
      v33 = v30;
      dispatch_assert_queue_V2(v32[13]);
      dispatch_assert_queue_V2(v32[13]);
      v34 = sub_1000D8AA8((uint64_t)v32, 1, 0);
      if (v34 && (v35 = objc_opt_class(NRLinkBluetooth), (objc_opt_isKindOfClass(v34, v35) & 1) != 0))
        sub_10009F1D4((uint64_t)v34, v33);
      else
        v48((uint64_t)v33, 0);

    }
    else
    {
      v48((uint64_t)v30, 0);
    }

  }
  v16 = -2000;
LABEL_49:

  return v16;
}

uint64_t sub_100053774(void *a1)
{
  _QWORD *Property;
  const char *v2;
  _QWORD *v3;
  _BOOL4 v4;
  const char *v5;
  id v6;
  void *v7;
  _xpc_connection_s *v8;
  uint64_t pid;
  id v10;
  id v11;
  void *v12;
  id v13;
  id v14;
  _BYTE buffer[1024];

  Property = a1;
  v3 = Property;
  if (Property)
    Property = objc_getProperty(Property, v2, 16, 1);
  v4 = xpc_dictionary_get_BOOL(Property, nrXPCKeyWatchRoleSwitchAllowed);
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v6 = (id)qword_1001E4608;
    if (v3)
    {
      v7 = (void *)v3[4];
      if (!v7)
      {
        v8 = (_xpc_connection_s *)objc_getProperty(v3, v5, 8, 1);
        pid = xpc_connection_get_pid(v8);
        v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          v11 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v10 = v11;
        }
        v12 = (void *)v3[4];
        v3[4] = v10;

        v7 = (void *)v3[4];
      }
      v13 = v7;
    }
    else
    {
      v13 = 0;
    }
    _NRLogWithArgs(v6, 0, "%s%.30s:%-4d Client %@ setting Watch Role switch allowed=%d", "", "handleSetWatchRoleSwitchAllowed", 881, v13, v4);

  }
  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v14 = (id)qword_1001E4708;
  if (v14)
  {
    if (v4)
      sub_1000A0244(0, CFSTR("EnableWatchRoleSwitch"), &__kCFBooleanTrue);
    else
      sub_1000A04A0(0, CFSTR("EnableWatchRoleSwitch"));
  }

  return 0;
}

uint64_t sub_1000539F0(void *a1)
{
  _QWORD *Property;
  const char *v2;
  _QWORD *v3;
  const char *v4;
  id v5;
  void *v6;
  _xpc_connection_s *v7;
  uint64_t pid;
  id v9;
  id v10;
  void *v11;
  id v12;
  id *v13;
  id *v14;
  id v15;
  id v16;
  id v17;
  uint64_t v18;
  const char *v19;
  void *i;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void **v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  int IsLevelEnabled;
  uint64_t v33;
  void *v34;
  void *v36;
  _BOOL4 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  _BYTE buffer[1024];

  Property = a1;
  v3 = Property;
  if (Property)
    Property = objc_getProperty(Property, v2, 16, 1);
  v37 = xpc_dictionary_get_BOOL(Property, nrXPCKeyWiFiRangeExtensionAllowed);
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v5 = (id)qword_1001E4608;
    if (v3)
    {
      v6 = (void *)v3[4];
      if (!v6)
      {
        v7 = (_xpc_connection_s *)objc_getProperty(v3, v4, 8, 1);
        pid = xpc_connection_get_pid(v7);
        v9 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v9 = v10;
        }
        v11 = (void *)v3[4];
        v3[4] = v9;

        v6 = (void *)v3[4];
      }
      v12 = v6;
    }
    else
    {
      v12 = 0;
    }
    _NRLogWithArgs(v5, 0, "%s%.30s:%-4d Client %@ setting Wi-Fi range extension allowed=%d", "", "handleSetWiFiRangeExtensionAllowed", 899, v12, v37);

  }
  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v36 = v3;
  v13 = (id *)(id)qword_1001E4708;
  v14 = v13;
  if (v13)
  {
    v40 = 0u;
    v41 = 0u;
    v38 = 0u;
    v39 = 0u;
    v15 = v13[25];
    v16 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v38, buffer, 16);
    if (v16)
    {
      v17 = v16;
      v18 = *(_QWORD *)v39;
      if (v37)
        v19 = "NO";
      else
        v19 = "YES";
      do
      {
        for (i = 0; i != v17; i = (char *)i + 1)
        {
          if (*(_QWORD *)v39 != v18)
            objc_enumerationMutation(v15);
          v27 = objc_claimAutoreleasedReturnValue(objc_msgSend(v14[25], "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v38 + 1) + 8 * (_QWORD)i)));
          v28 = (void **)v27;
          if (v27)
          {
            dispatch_assert_queue_V2(*(dispatch_queue_t *)(v27 + 104));
            if (_NRIsAppleInternal(v29))
            {
              v31 = (void *)_NRCopyLogObjectForNRUUID(v28[12], v30);
              IsLevelEnabled = _NRLogIsLevelEnabled(v31, 0);

              if (IsLevelEnabled)
              {
                v34 = (void *)_NRCopyLogObjectForNRUUID(v28[12], v33);
                _NRLogWithArgs(v34, 0, "%s%.30s:%-4d Setting Wi-Fi range extension allowed=%d", "", "-[NRDDeviceConductor setWiFiRangeExtensionAllowedForTesting:]", 2049, v37);

              }
              v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", !v37));
              sub_1000A0244(v28[12], CFSTR("DisableRangeExtension"), v21);
              sub_1000D5060((uint64_t)v28, 1025, CFSTR("%s"), v22, v23, v24, v25, v26, (uint64_t)v19);

            }
          }

        }
        v17 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v38, buffer, 16);
      }
      while (v17);
    }

  }
  return 0;
}

uint64_t sub_100053DDC(void *a1)
{
  _QWORD *Property;
  const char *v2;
  _QWORD *v3;
  _BOOL8 v4;
  const char *v5;
  id v6;
  void *v7;
  _xpc_connection_s *v8;
  uint64_t pid;
  id v10;
  id v11;
  void *v12;
  id v13;
  id v14;
  void *v15;
  _BYTE buffer[1024];

  Property = a1;
  v3 = Property;
  if (Property)
    Property = objc_getProperty(Property, v2, 16, 1);
  v4 = xpc_dictionary_get_BOOL(Property, nrXPCKeySimulateAltAccount);
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v6 = (id)qword_1001E4608;
    if (v3)
    {
      v7 = (void *)v3[4];
      if (!v7)
      {
        v8 = (_xpc_connection_s *)objc_getProperty(v3, v5, 8, 1);
        pid = xpc_connection_get_pid(v8);
        v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          v11 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v10 = v11;
        }
        v12 = (void *)v3[4];
        v3[4] = v10;

        v7 = (void *)v3[4];
      }
      v13 = v7;
    }
    else
    {
      v13 = 0;
    }
    _NRLogWithArgs(v6, 0, "%s%.30s:%-4d Client %@ setting simulate alt-account=%d", "", "handleSetSimulateAltAccount", 890, v13, v4);

  }
  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v14 = (id)qword_1001E4708;
  if (v14)
  {
    v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v4));
    sub_1000A0244(0, CFSTR("SimulateAltAccount"), v15);

  }
  return 0;
}

uint64_t sub_100054060(void *a1)
{
  _QWORD *Property;
  const char *v2;
  _QWORD *v3;
  const char *v4;
  id v5;
  void *v6;
  _xpc_connection_s *v7;
  uint64_t pid;
  id v9;
  id v10;
  void *v11;
  id v12;
  id *v13;
  id *v14;
  id v15;
  id v16;
  id v17;
  uint64_t v18;
  const char *v19;
  void *i;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void **v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  int IsLevelEnabled;
  uint64_t v33;
  void *v34;
  void *v36;
  _BOOL4 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  _BYTE buffer[1024];

  Property = a1;
  v3 = Property;
  if (Property)
    Property = objc_getProperty(Property, v2, 16, 1);
  v37 = xpc_dictionary_get_BOOL(Property, nrXPCKeyPreferWiFiAllowed);
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v5 = (id)qword_1001E4608;
    if (v3)
    {
      v6 = (void *)v3[4];
      if (!v6)
      {
        v7 = (_xpc_connection_s *)objc_getProperty(v3, v4, 8, 1);
        pid = xpc_connection_get_pid(v7);
        v9 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v9 = v10;
        }
        v11 = (void *)v3[4];
        v3[4] = v9;

        v6 = (void *)v3[4];
      }
      v12 = v6;
    }
    else
    {
      v12 = 0;
    }
    _NRLogWithArgs(v5, 0, "%s%.30s:%-4d Client %@ setting prefer Wi-Fi allowed=%d", "", "handleSetPreferWiFiAllowed", 934, v12, v37);

  }
  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v36 = v3;
  v13 = (id *)(id)qword_1001E4708;
  v14 = v13;
  if (v13)
  {
    v40 = 0u;
    v41 = 0u;
    v38 = 0u;
    v39 = 0u;
    v15 = v13[25];
    v16 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v38, buffer, 16);
    if (v16)
    {
      v17 = v16;
      v18 = *(_QWORD *)v39;
      if (v37)
        v19 = "NO";
      else
        v19 = "YES";
      do
      {
        for (i = 0; i != v17; i = (char *)i + 1)
        {
          if (*(_QWORD *)v39 != v18)
            objc_enumerationMutation(v15);
          v27 = objc_claimAutoreleasedReturnValue(objc_msgSend(v14[25], "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v38 + 1) + 8 * (_QWORD)i)));
          v28 = (void **)v27;
          if (v27)
          {
            dispatch_assert_queue_V2(*(dispatch_queue_t *)(v27 + 104));
            if (_NRIsAppleInternal(v29))
            {
              v31 = (void *)_NRCopyLogObjectForNRUUID(v28[12], v30);
              IsLevelEnabled = _NRLogIsLevelEnabled(v31, 0);

              if (IsLevelEnabled)
              {
                v34 = (void *)_NRCopyLogObjectForNRUUID(v28[12], v33);
                _NRLogWithArgs(v34, 0, "%s%.30s:%-4d Setting prefer Wi-Fi allowed=%d", "", "-[NRDDeviceConductor setPreferWiFiAllowedForTesting:]", 2060, v37);

              }
              v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", !v37));
              sub_1000A0244(v28[12], CFSTR("DisablePreferWiFi"), v21);
              sub_1000D5060((uint64_t)v28, 1026, CFSTR("%s"), v22, v23, v24, v25, v26, (uint64_t)v19);

            }
          }

        }
        v17 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v38, buffer, 16);
      }
      while (v17);
    }

  }
  return 0;
}

uint64_t sub_10005444C(void *a1)
{
  _QWORD *Property;
  const char *v2;
  _QWORD *v3;
  const char *string;
  id v5;
  void *v6;
  const char *v7;
  id v8;
  void *v9;
  _xpc_connection_s *v10;
  uint64_t pid;
  id v12;
  id v13;
  void *v14;
  id v15;
  const char *v16;
  void *v17;
  _xpc_connection_s *v18;
  uint64_t v19;
  id v20;
  id v21;
  void *v22;
  id v23;
  id v24;
  _BYTE buffer[1024];

  Property = a1;
  v3 = Property;
  if (Property)
    Property = objc_getProperty(Property, v2, 16, 1);
  string = xpc_dictionary_get_string(Property, nrXPCKeyTetheringBundleIDs);
  if (string)
  {
    v5 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", string));
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "componentsSeparatedByString:", CFSTR(",")));
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    if (!_NRLogIsLevelEnabled(qword_1001E4608, 0))
      goto LABEL_33;
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v8 = (id)qword_1001E4608;
    if (v3)
    {
      v9 = (void *)v3[4];
      if (!v9)
      {
        v10 = (_xpc_connection_s *)objc_getProperty(v3, v7, 8, 1);
        pid = xpc_connection_get_pid(v10);
        v12 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v12 = v13;
        }
        v14 = (void *)v3[4];
        v3[4] = v12;

        v9 = (void *)v3[4];
      }
      v15 = v9;
    }
    else
    {
      v15 = 0;
    }
    _NRLogWithArgs(v8, 0, "%s%.30s:%-4d Client %@ setting tethering bundle IDs to %@", "", "handleSetTetheringBundleIDs", 921, v15, v6);

LABEL_32:
LABEL_33:

    goto LABEL_34;
  }
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v5 = (id)qword_1001E4608;
    if (v3)
    {
      v17 = (void *)v3[4];
      if (!v17)
      {
        v18 = (_xpc_connection_s *)objc_getProperty(v3, v16, 8, 1);
        v19 = xpc_connection_get_pid(v18);
        v20 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), v19);
        bzero(buffer, 0x400uLL);
        if ((int)v19 >= 1 && proc_pidpath(v19, buffer, 0x400u) >= 1 && buffer[0])
        {
          v21 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, v19);

          v20 = v21;
        }
        v22 = (void *)v3[4];
        v3[4] = v20;

        v17 = (void *)v3[4];
      }
      v8 = v17;
    }
    else
    {
      v8 = 0;
    }
    _NRLogWithArgs(v5, 0, "%s%.30s:%-4d Client %@ setting tethering bundle IDs to nil", "", "handleSetTetheringBundleIDs", 923, v8);
    v6 = 0;
    goto LABEL_32;
  }
  v6 = 0;
LABEL_34:
  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v23 = (id)qword_1001E4708;
  v24 = v6;
  if (v23)
  {
    if (v24)
      sub_1000A0244(0, CFSTR("TetheringBundleIDs"), v24);
    else
      sub_1000A04A0(0, CFSTR("TetheringBundleIDs"));
  }

  return 0;
}

uint64_t sub_100054868(void *a1)
{
  _QWORD *Property;
  const char *v2;
  _QWORD *v3;
  _BOOL4 v4;
  const char *v5;
  id v6;
  void *v7;
  _xpc_connection_s *v8;
  uint64_t pid;
  id v10;
  id v11;
  void *v12;
  id v13;
  id v14;
  void *v15;
  NSObject *v16;
  id v17;
  id v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  id v23;
  void *v24;
  void *v25;
  void *v26;
  id v27;
  id v28;
  id v29;
  uint64_t v30;
  id v31;
  id v32;
  id *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v38;
  _OWORD buffer[64];

  Property = a1;
  v3 = Property;
  if (Property)
    Property = objc_getProperty(Property, v2, 16, 1);
  v4 = xpc_dictionary_get_BOOL(Property, nrXPCKeyBlockSHOESTraffic);
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v6 = (id)qword_1001E4608;
    if (v3)
    {
      v7 = (void *)v3[4];
      if (!v7)
      {
        v8 = (_xpc_connection_s *)objc_getProperty(v3, v5, 8, 1);
        pid = xpc_connection_get_pid(v8);
        v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && LOBYTE(buffer[0]))
        {
          v11 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v10 = v11;
        }
        v12 = (void *)v3[4];
        v3[4] = v10;

        v7 = (void *)v3[4];
      }
      v13 = v7;
    }
    else
    {
      v13 = 0;
    }
    _NRLogWithArgs(v6, 0, "%s%.30s:%-4d Client %@ blocking SHOES Traffic", "", "handleBlockSHOESTraffic", 944, v13);

  }
  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v14 = (id)qword_1001E4708;
  v15 = v14;
  if (v14 && _NRIsAppleInternal(v14))
  {
    if (v4)
    {
      objc_opt_self(NRDLocalDevice);
      v16 = sub_10014CFBC();
      dispatch_assert_queue_V2(v16);

      buffer[0] = xmmword_10015D090;
      v17 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", buffer, 16);
      v18 = sub_100133E24((uint64_t)NRDLocalDevice, v17, CFSTR("0"));
      v19 = (void *)objc_claimAutoreleasedReturnValue(v18);

      v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "hostname"));
      v21 = (void *)objc_claimAutoreleasedReturnValue(+[NWAddressEndpoint endpointWithHostname:port:](NWAddressEndpoint, "endpointWithHostname:port:", v20, CFSTR("62742")));

      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition remoteAddress:prefix:](NEPolicyCondition, "remoteAddress:prefix:", v21, 64));
      v23 = objc_alloc((Class)NEPolicy);
      v24 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult drop](NEPolicyResult, "drop"));
      *(_QWORD *)&buffer[0] = v22;
      v25 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](NEPolicyCondition, "allInterfaces"));
      *((_QWORD *)&buffer[0] + 1) = v25;
      v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", buffer, 2));
      v27 = objc_msgSend(v23, "initWithOrder:result:conditions:", 10, v24, v26);

      objc_opt_self(NRDPolicySessionManager);
      if (qword_1001E4A20 != -1)
        dispatch_once(&qword_1001E4A20, &stru_1001B8590);
      v28 = (id)qword_1001E4A18;
      v29 = sub_100127310((uint64_t)v28, CFSTR("TESTING-NRDLD-Drop-SHOES"), v27);

    }
    else
    {
      objc_opt_self(NRDPolicySessionManager);
      if (qword_1001E4A20 != -1)
        dispatch_once(&qword_1001E4A20, &stru_1001B8590);
      v31 = (id)qword_1001E4A18;
      sub_100127618((uint64_t)v31, CFSTR("TESTING-NRDLD-Drop-SHOES"));

    }
    objc_opt_self(NRDPolicySessionManager);
    if (qword_1001E4A20 != -1)
      dispatch_once(&qword_1001E4A20, &stru_1001B8590);
    v32 = (id)qword_1001E4A18;
    v33 = (id *)v32;
    if (v32)
    {
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v32 + 1));
      if ((objc_msgSend(v33[2], "apply") & 1) == 0)
        sub_100109270(CFSTR("NRPolicySessionManager"), CFSTR("ApplyPolicy Failed"), 0, 1, CFSTR("Failed to apply policies"), v34, v35, v36, v38);
    }

    v30 = 0;
  }
  else
  {
    v30 = -2001;
  }

  return v30;
}

uint64_t sub_100054D5C(void *a1)
{
  _QWORD *Property;
  const char *v2;
  _QWORD *v3;
  _BOOL4 v4;
  const char *v5;
  id v6;
  void *v7;
  _xpc_connection_s *v8;
  uint64_t pid;
  id v10;
  id v11;
  void *v12;
  id v13;
  id v14;
  void *v15;
  NSObject *v16;
  id v17;
  id v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  id v24;
  void *v25;
  void *v26;
  void *v27;
  id v28;
  id v29;
  id v30;
  id v31;
  void *v32;
  void *v33;
  void *v34;
  id v35;
  id v36;
  id v37;
  void *v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  id v42;
  void *v43;
  void *v44;
  void *v45;
  id v46;
  id v47;
  id v48;
  id v49;
  void *v50;
  void *v51;
  void *v52;
  void *v53;
  id v54;
  id v55;
  id v56;
  uint64_t v57;
  id v58;
  id v59;
  id *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v65;
  void *v66;
  void *v67;
  void *v68;
  void *v69;
  _OWORD buffer[64];
  _QWORD v71[2];
  _QWORD v72[2];
  _QWORD v73[2];

  Property = a1;
  v3 = Property;
  if (Property)
    Property = objc_getProperty(Property, v2, 16, 1);
  v4 = xpc_dictionary_get_BOOL(Property, nrXPCKeyBlockIDSTraffic);
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v6 = (id)qword_1001E4608;
    if (v3)
    {
      v7 = (void *)v3[4];
      if (!v7)
      {
        v8 = (_xpc_connection_s *)objc_getProperty(v3, v5, 8, 1);
        pid = xpc_connection_get_pid(v8);
        v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && LOBYTE(buffer[0]))
        {
          v11 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v10 = v11;
        }
        v12 = (void *)v3[4];
        v3[4] = v10;

        v7 = (void *)v3[4];
      }
      v13 = v7;
    }
    else
    {
      v13 = 0;
    }
    _NRLogWithArgs(v6, 0, "%s%.30s:%-4d Client %@ blocking IDS Traffic", "", "handleBlockIDSTraffic", 953, v13);

  }
  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v14 = (id)qword_1001E4708;
  v15 = v14;
  if (v14 && _NRIsAppleInternal(v14))
  {
    if (v4)
    {
      objc_opt_self(NRDLocalDevice);
      v16 = sub_10014CFBC();
      dispatch_assert_queue_V2(v16);

      buffer[0] = xmmword_10015D090;
      v17 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", buffer, 16);
      v18 = sub_100133E24((uint64_t)NRDLocalDevice, v17, CFSTR("0"));
      v19 = (void *)objc_claimAutoreleasedReturnValue(v18);

      v69 = v19;
      v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "hostname"));
      v21 = (void *)objc_claimAutoreleasedReturnValue(+[NWAddressEndpoint endpointWithHostname:port:](NWAddressEndpoint, "endpointWithHostname:port:", v20, CFSTR("61314")));

      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition localAddress:prefix:](NEPolicyCondition, "localAddress:prefix:", v21, 64));
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition remoteAddress:prefix:](NEPolicyCondition, "remoteAddress:prefix:", v21, 64));
      v24 = objc_alloc((Class)NEPolicy);
      v25 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult drop](NEPolicyResult, "drop"));
      *(_QWORD *)&buffer[0] = v23;
      v26 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](NEPolicyCondition, "allInterfaces"));
      *((_QWORD *)&buffer[0] + 1) = v26;
      v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", buffer, 2));
      v28 = objc_msgSend(v24, "initWithOrder:result:conditions:", 10, v25, v27);

      objc_opt_self(NRDPolicySessionManager);
      if (qword_1001E4A20 != -1)
        dispatch_once(&qword_1001E4A20, &stru_1001B8590);
      v29 = (id)qword_1001E4A18;
      v67 = v28;
      v30 = sub_100127310((uint64_t)v29, CFSTR("TESTING-NRDLD-Drop-IDS"), v28);

      v31 = objc_alloc((Class)NEPolicy);
      v32 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult drop](NEPolicyResult, "drop"));
      v73[0] = v22;
      v33 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](NEPolicyCondition, "allInterfaces"));
      v73[1] = v33;
      v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v73, 2));
      v35 = objc_msgSend(v31, "initWithOrder:result:conditions:", 10, v32, v34);

      objc_opt_self(NRDPolicySessionManager);
      if (qword_1001E4A20 != -1)
        dispatch_once(&qword_1001E4A20, &stru_1001B8590);
      v36 = (id)qword_1001E4A18;
      v68 = v35;
      v37 = sub_100127310((uint64_t)v36, CFSTR("TESTING-NRDLD-Drop-IDS"), v35);

      v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v69, "hostname"));
      v39 = (void *)objc_claimAutoreleasedReturnValue(+[NWAddressEndpoint endpointWithHostname:port:](NWAddressEndpoint, "endpointWithHostname:port:", v38, CFSTR("61315")));

      v40 = objc_claimAutoreleasedReturnValue(+[NEPolicyCondition localAddress:prefix:](NEPolicyCondition, "localAddress:prefix:", v39, 64));
      v41 = objc_claimAutoreleasedReturnValue(+[NEPolicyCondition remoteAddress:prefix:](NEPolicyCondition, "remoteAddress:prefix:", v39, 64));

      v42 = objc_alloc((Class)NEPolicy);
      v43 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult drop](NEPolicyResult, "drop"));
      v66 = (void *)v41;
      v72[0] = v41;
      v44 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](NEPolicyCondition, "allInterfaces"));
      v72[1] = v44;
      v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v72, 2));
      v46 = objc_msgSend(v42, "initWithOrder:result:conditions:", 10, v43, v45);

      objc_opt_self(NRDPolicySessionManager);
      if (qword_1001E4A20 != -1)
        dispatch_once(&qword_1001E4A20, &stru_1001B8590);
      v47 = (id)qword_1001E4A18;
      v48 = sub_100127310((uint64_t)v47, CFSTR("TESTING-NRDLD-Drop-IDS"), v46);

      v49 = objc_alloc((Class)NEPolicy);
      v50 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult drop](NEPolicyResult, "drop"));
      v51 = (void *)v40;
      v71[0] = v40;
      v52 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](NEPolicyCondition, "allInterfaces"));
      v71[1] = v52;
      v53 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v71, 2));
      v54 = objc_msgSend(v49, "initWithOrder:result:conditions:", 10, v50, v53);

      objc_opt_self(NRDPolicySessionManager);
      if (qword_1001E4A20 != -1)
        dispatch_once(&qword_1001E4A20, &stru_1001B8590);
      v55 = (id)qword_1001E4A18;
      v56 = sub_100127310((uint64_t)v55, CFSTR("TESTING-NRDLD-Drop-IDS"), v54);

    }
    else
    {
      objc_opt_self(NRDPolicySessionManager);
      if (qword_1001E4A20 != -1)
        dispatch_once(&qword_1001E4A20, &stru_1001B8590);
      v58 = (id)qword_1001E4A18;
      sub_100127618((uint64_t)v58, CFSTR("TESTING-NRDLD-Drop-IDS"));

    }
    objc_opt_self(NRDPolicySessionManager);
    if (qword_1001E4A20 != -1)
      dispatch_once(&qword_1001E4A20, &stru_1001B8590);
    v59 = (id)qword_1001E4A18;
    v60 = (id *)v59;
    if (v59)
    {
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v59 + 1));
      if ((objc_msgSend(v60[2], "apply") & 1) == 0)
        sub_100109270(CFSTR("NRPolicySessionManager"), CFSTR("ApplyPolicy Failed"), 0, 1, CFSTR("Failed to apply policies"), v61, v62, v63, v65);
    }

    v57 = 0;
  }
  else
  {
    v57 = -2001;
  }

  return v57;
}

uint64_t sub_1000555A0(void *a1)
{
  _QWORD *Property;
  const char *v2;
  _QWORD *v3;
  const char *v4;
  id v5;
  void *v6;
  _xpc_connection_s *v7;
  uint64_t pid;
  id v9;
  id v10;
  void *v11;
  id v12;
  const char *v13;
  _BYTE *v14;
  _BYTE *v15;
  uint64_t v16;
  unsigned __int8 *v17;
  int v18;
  id *v19;
  id *v20;
  id v21;
  id v22;
  uint64_t v23;
  void *i;
  void *v25;
  id v26;
  void *v27;
  _BYTE *v29;
  _QWORD *v30;
  id obj;
  _BOOL4 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  _BYTE buffer[1024];

  Property = a1;
  v3 = Property;
  if (Property)
    Property = objc_getProperty(Property, v2, 16, 1);
  v32 = xpc_dictionary_get_BOOL(Property, nrXPCKeySimulateWakePacket);
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v5 = (id)qword_1001E4608;
    if (v3)
    {
      v6 = (void *)v3[4];
      if (!v6)
      {
        v7 = (_xpc_connection_s *)objc_getProperty(v3, v4, 8, 1);
        pid = xpc_connection_get_pid(v7);
        v9 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v9 = v10;
        }
        v11 = (void *)v3[4];
        v3[4] = v9;

        v6 = (void *)v3[4];
      }
      v12 = v6;
    }
    else
    {
      v12 = 0;
    }
    v13 = "stop";
    if (v32)
      v13 = "start";
    _NRLogWithArgs(v5, 0, "%s%.30s:%-4d Client %@ requesting to %s simulating wake packets", "", "handleSimulateWakePacket", 963, v12, v13);

  }
  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v14 = (id)qword_1001E4708;
  v15 = v14;
  if (v14 && _NRIsAppleInternal(v14))
  {
    v16 = 0;
    v15[9] = v32;
  }
  else
  {
    v16 = -2001;
  }
  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v17 = (unsigned __int8 *)(id)qword_1001E4708;
  if (!v17)
  {
    v20 = 0;
LABEL_43:

    goto LABEL_44;
  }
  v18 = v17[10];

  if (v18)
  {
    objc_opt_self(NRLinkDirector);
    if (qword_1001E4710 != -1)
      dispatch_once(&qword_1001E4710, &stru_1001B6E60);
    v29 = v15;
    v30 = v3;
    v19 = (id *)(id)qword_1001E4708;
    v20 = v19;
    if (v19)
    {
      v35 = 0u;
      v36 = 0u;
      v33 = 0u;
      v34 = 0u;
      obj = v19[25];
      v21 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v33, buffer, 16);
      if (v21)
      {
        v22 = v21;
        v23 = *(_QWORD *)v34;
        do
        {
          for (i = 0; i != v22; i = (char *)i + 1)
          {
            if (*(_QWORD *)v34 != v23)
              objc_enumerationMutation(obj);
            v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20[25], "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v33 + 1) + 8 * (_QWORD)i)));
            if (v25)
            {
              v26 = objc_alloc_init((Class)NSMutableDictionary);
              v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v32));
              objc_msgSend(v26, "setObject:forKeyedSubscript:", v27, CFSTR("test-wake-pkt"));

              sub_1000EF368((uint64_t)v25, v26);
            }

          }
          v22 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v33, buffer, 16);
        }
        while (v22);
      }

    }
    v3 = v30;
    v15 = v29;
    goto LABEL_43;
  }
LABEL_44:

  return v16;
}

uint64_t sub_1000559C4(void *a1)
{
  _QWORD *v1;
  const char *v2;
  id v3;
  void *v4;
  _xpc_connection_s *Property;
  uint64_t pid;
  id v7;
  id v8;
  void *v9;
  id v10;
  id v11;
  void *v12;
  id v13;
  _QWORD *v14;
  char v15;
  _QWORD *v16;
  char v17;
  _QWORD *v18;
  char v19;
  const char *v20;
  id v21;
  uint64_t v22;
  const char *v23;
  id v24;
  const char *v25;
  id v26;
  void *v27;
  _xpc_connection_s *v28;
  uint64_t v29;
  id v30;
  id v31;
  void *v32;
  id v33;
  _BYTE buffer[1024];

  v1 = a1;
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v3 = (id)qword_1001E4608;
    if (v1)
    {
      v4 = (void *)v1[4];
      if (!v4)
      {
        Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8, 1);
        pid = xpc_connection_get_pid(Property);
        v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v7 = v8;
        }
        v9 = (void *)v1[4];
        v1[4] = v7;

        v4 = (void *)v1[4];
      }
      v10 = v4;
    }
    else
    {
      v10 = 0;
    }
    _NRLogWithArgs(v3, 0, "%s%.30s:%-4d Client %@ requesting to test NRLinkDirectorMessage", "", "handleTestNRLinkDirectorMessage", 974, v10);

  }
  v11 = sub_1001383A0((uint64_t)NRDLocalDevice);
  v12 = v11;
  if (v11)
  {
    v13 = v11;
    objc_opt_self(NRLinkDirectorMessage);
    if (qword_1001E45B0 != -1)
      dispatch_once(&qword_1001E45B0, &stru_1001B6498);
    if (_NRLogIsLevelEnabled(qword_1001E45A8, 0))
    {
      if (qword_1001E45B0 != -1)
        dispatch_once(&qword_1001E45B0, &stru_1001B6498);
      _NRLogWithArgs(qword_1001E45A8, 0, "%s%.30s:%-4d Testing NRLinkDirectorMessage send/receive", "", "+[NRLinkDirectorMessage testForNRUUID:]", 1236);
    }
    sub_1000259E4((uint64_t)NRLinkDirectorMessage, v13);
    v14 = sub_100022B68([NRLinkDirectorMessage alloc], v13);
    v15 = sub_100024EB8((uint64_t)NRLinkDirectorMessage, v14);
    sub_1000259E4((uint64_t)NRLinkDirectorMessage, v13);
    v16 = sub_1000229FC([NRLinkDirectorMessage alloc], v13, 1);

    v17 = sub_100024EB8((uint64_t)NRLinkDirectorMessage, v16);
    sub_1000259E4((uint64_t)NRLinkDirectorMessage, v13);
    v18 = sub_1000229FC([NRLinkDirectorMessage alloc], v13, 2);

    v19 = sub_100024EB8((uint64_t)NRLinkDirectorMessage, v18);
    sub_1000259E4((uint64_t)NRLinkDirectorMessage, v13);

    if (v1)
      v21 = objc_getProperty(v1, v20, 24, 1);
    else
      v21 = 0;
    xpc_dictionary_set_BOOL(v21, nrXPCKeyTestNRLinkDirectorMessage, v15 & v17 & v19);
    v22 = 0;
  }
  else
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    if (_NRLogIsLevelEnabled(qword_1001E4608, 16))
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      v24 = (id)qword_1001E4608;
      if (v1)
      {
        v26 = objc_getProperty(v1, v23, 16, 1);
        v27 = (void *)v1[4];
        if (!v27)
        {
          v28 = (_xpc_connection_s *)objc_getProperty(v1, v25, 8, 1);
          v29 = xpc_connection_get_pid(v28);
          v30 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), v29);
          bzero(buffer, 0x400uLL);
          if ((int)v29 >= 1 && proc_pidpath(v29, buffer, 0x400u) >= 1 && buffer[0])
          {
            v31 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, v29);

            v30 = v31;
          }
          v32 = (void *)v1[4];
          v1[4] = v30;

          v27 = (void *)v1[4];
        }
        v33 = v27;
      }
      else
      {
        v26 = 0;
        v33 = 0;
      }
      _NRLogWithArgs(v24, 16, "%s%.30s:%-4d No testing identifier found for message %@ from %@", "", "handleTestNRLinkDirectorMessage", 977, v26, v33);

    }
    v22 = -2011;
  }

  return v22;
}

uint64_t sub_100055EE4(void *a1)
{
  _QWORD *Property;
  const char *v2;
  _QWORD *v3;
  const char *v4;
  _BOOL4 v5;
  id v6;
  const char *v7;
  const char *string;
  id v9;
  const char *v10;
  const char *v11;
  id v12;
  const char *v13;
  const char *v14;
  BOOL v15;
  const char *v17;
  id v18;
  void *v19;
  _xpc_connection_s *v20;
  uint64_t v21;
  id v22;
  id v23;
  void *v24;
  id v25;
  const char *v26;
  void *v27;
  _xpc_connection_s *v28;
  uint64_t pid;
  id v30;
  id v31;
  void *v32;
  id v33;
  void *v34;
  void *v35;
  void *v36;
  uint64_t v37;
  _BYTE buffer[1024];

  Property = a1;
  v3 = Property;
  if (Property)
    Property = objc_getProperty(Property, v2, 16, 1);
  v5 = xpc_dictionary_get_BOOL(Property, nrXPCKeyFixedInterfaceModeSetEnabled);
  if (v3)
    v6 = objc_getProperty(v3, v4, 16, 1);
  else
    v6 = 0;
  string = xpc_dictionary_get_string(v6, nrXPCKeyFixedInterfaceModeInterfaceName);
  if (v3)
    v9 = objc_getProperty(v3, v7, 16, 1);
  else
    v9 = 0;
  v11 = xpc_dictionary_get_string(v9, nrXPCKeyFixedInterfaceModePeerAddress);
  if (v3)
    v12 = objc_getProperty(v3, v10, 16, 1);
  else
    v12 = 0;
  v13 = xpc_dictionary_get_string(v12, nrXPCKeyIDSDeviceID);
  v14 = v13;
  if (!v5)
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      v18 = (id)qword_1001E4608;
      if (v3)
      {
        v27 = (void *)v3[4];
        if (!v27)
        {
          v28 = (_xpc_connection_s *)objc_getProperty(v3, v26, 8, 1);
          pid = xpc_connection_get_pid(v28);
          v30 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
          bzero(buffer, 0x400uLL);
          if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
          {
            v31 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

            v30 = v31;
          }
          v32 = (void *)v3[4];
          v3[4] = v30;

          v27 = (void *)v3[4];
        }
        v25 = v27;
      }
      else
      {
        v25 = 0;
      }
      _NRLogWithArgs(v18, 0, "%s%.30s:%-4d Client %@ setting fixed-interface mode disabled", "", "handleSetFixedInterfaceMode", 1004, v25);
      goto LABEL_45;
    }
LABEL_46:
    objc_opt_self(NRLinkDirector);
    if (qword_1001E4710 != -1)
      dispatch_once(&qword_1001E4710, &stru_1001B6E60);
    v33 = (id)qword_1001E4708;
    if (string)
    {
      v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", string));
      if (v11)
        goto LABEL_50;
    }
    else
    {
      v34 = 0;
      if (v11)
      {
LABEL_50:
        v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v11));
        if (v14)
          goto LABEL_51;
        goto LABEL_58;
      }
    }
    v35 = 0;
    if (v14)
    {
LABEL_51:
      v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v14));
      sub_1000AF264((uint64_t)v33, v5, v34, v35, v36);

      if (!v11)
      {
LABEL_53:
        if (string)

        v37 = 0;
        goto LABEL_67;
      }
LABEL_52:

      goto LABEL_53;
    }
LABEL_58:
    sub_1000AF264((uint64_t)v33, v5, v34, v35, 0);
    if (!v11)
      goto LABEL_53;
    goto LABEL_52;
  }
  if (string)
    v15 = 0;
  else
    v15 = v11 == 0;
  if (!v15 || v13 != 0)
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      v18 = (id)qword_1001E4608;
      if (v3)
      {
        v19 = (void *)v3[4];
        if (!v19)
        {
          v20 = (_xpc_connection_s *)objc_getProperty(v3, v17, 8, 1);
          v21 = xpc_connection_get_pid(v20);
          v22 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), v21);
          bzero(buffer, 0x400uLL);
          if ((int)v21 >= 1 && proc_pidpath(v21, buffer, 0x400u) >= 1 && buffer[0])
          {
            v23 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, v21);

            v22 = v23;
          }
          v24 = (void *)v3[4];
          v3[4] = v22;

          v19 = (void *)v3[4];
        }
        v25 = v19;
      }
      else
      {
        v25 = 0;
      }
      _NRLogWithArgs(v18, 0, "%s%.30s:%-4d Client %@ setting fixed-interface mode enabled: %d, interface: %s, peer address: %s", "", "handleSetFixedInterfaceMode", 1002, v25, 1, string, v11);
LABEL_45:

      goto LABEL_46;
    }
    goto LABEL_46;
  }
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 16))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    _NRLogWithArgs(qword_1001E4608, 16, "%s%.30s:%-4d No interface name/address/idsDeviceID for fixed-interface mode", "", "handleSetFixedInterfaceMode", 998);
  }
  v37 = -2005;
LABEL_67:

  return v37;
}

uint64_t sub_100056470(void *a1)
{
  __objc2_prot *v1;
  _QWORD *Property;
  const char *v3;
  _QWORD *v4;
  const unsigned __int8 *uuid;
  const unsigned __int8 *v6;
  const char *v7;
  _BYTE *v8;
  void *v9;
  _xpc_connection_s *v10;
  uint64_t pid;
  id v12;
  id v13;
  void *v14;
  id v15;
  uint64_t v16;
  _BYTE *v17;
  const char *v18;
  const char *v19;
  id v20;
  void *v21;
  _xpc_connection_s *v22;
  uint64_t v23;
  id v24;
  id v25;
  void *v26;
  id v27;
  id v28;
  id v29;
  int v30;
  const char *v31;
  id v33;
  int IsLevelEnabled;
  id v35;
  int *v36;
  uint64_t v37;
  id v38;
  _BYTE v40[1024];

  Property = a1;
  v4 = Property;
  if (Property)
    Property = objc_getProperty(Property, v3, 16, 1);
  uuid = xpc_dictionary_get_uuid(Property, nrXPCKeyDeviceIdentifier);
  if (uuid)
  {
    v6 = uuid;
    if (uuid_is_null(uuid))
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      if (_NRLogIsLevelEnabled(qword_1001E4608, 17))
      {
        if (qword_1001E4610 != -1)
          dispatch_once(&qword_1001E4610, &stru_1001B6788);
        v8 = (id)qword_1001E4608;
        if (v4)
        {
          v9 = (void *)v4[4];
          if (!v9)
          {
            v10 = (_xpc_connection_s *)objc_getProperty(v4, v7, 8, 1);
            pid = xpc_connection_get_pid(v10);
            v12 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
            bzero(v40, 0x400uLL);
            if ((int)pid >= 1 && proc_pidpath(pid, v40, 0x400u) >= 1 && v40[0])
            {
              v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), v40, pid);

              v12 = v13;
            }
            v14 = (void *)v4[4];
            v4[4] = v12;

            v9 = (void *)v4[4];
          }
          v15 = v9;
        }
        else
        {
          v15 = 0;
        }
        _NRLogWithArgs(v8, 17, "All-zero NRUUID from %@", v15);
        goto LABEL_19;
      }
LABEL_40:
      v16 = -2005;
      goto LABEL_41;
    }
    v17 = objc_msgSend(objc_alloc((Class)NSUUID), "initWithUUIDBytes:", v6);
    if (v17)
    {
      v8 = v17;
      v1 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
      if (qword_1001E4610 == -1)
      {
LABEL_22:
        if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
        {
          if (v1[21].opt_inst_meths != (__objc2_meth_list *)-1)
            dispatch_once(&qword_1001E4610, &stru_1001B6788);
          v20 = (id)qword_1001E4608;
          if (v4)
          {
            v21 = (void *)v4[4];
            if (!v21)
            {
              v22 = (_xpc_connection_s *)objc_getProperty(v4, v19, 8, 1);
              v23 = xpc_connection_get_pid(v22);
              v24 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), v23);
              bzero(v40, 0x400uLL);
              if ((int)v23 >= 1 && proc_pidpath(v23, v40, 0x400u) >= 1 && v40[0])
              {
                v25 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), v40, v23);

                v24 = v25;
              }
              v26 = (void *)v4[4];
              v4[4] = v24;

              v21 = (void *)v4[4];
            }
            v27 = v21;
          }
          else
          {
            v27 = 0;
          }
          _NRLogWithArgs(v20, 0, "%s%.30s:%-4d Received SupportsRestrictedPorts %@ from %@", "", "handleSupportsRestrictedPorts", 1309, v8, v27);

        }
        if (v4)
          v28 = objc_getProperty(v4, v18, 24, 1);
        else
          v28 = 0;
        xpc_dictionary_set_BOOL(v28, nrXPCKeySupportsRestrictedPorts, 1);
        v16 = 0;
        goto LABEL_37;
      }
    }
    else
    {
      v33 = sub_100045324();
      IsLevelEnabled = _NRLogIsLevelEnabled(v33, 16);

      if (IsLevelEnabled)
      {
        v35 = sub_100045324();
        _NRLogWithArgs(v35, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)", "", "handleSupportsRestrictedPorts", 1308);

      }
      v4 = (_QWORD *)_os_log_pack_size(12);
      v8 = &v40[-((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0) - 8];
      v36 = __error();
      v37 = _os_log_pack_fill(v8, v4, *v36, &_mh_execute_header, "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
      *(_DWORD *)v37 = 136446210;
      *(_QWORD *)(v37 + 4) = "handleSupportsRestrictedPorts";
      v38 = sub_100045324();
      _NRLogAbortWithPack(v38, v8);
    }
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
    goto LABEL_22;
  }
  v29 = sub_100045324();
  v30 = _NRLogIsLevelEnabled(v29, 17);

  if (!v30)
    goto LABEL_40;
  v8 = sub_100045324();
  v15 = sub_100045394(v4, v31);
  _NRLogWithArgs(v8, 17, "Missing NRUUID from %@", v15);
LABEL_19:

  v16 = -2005;
LABEL_37:

LABEL_41:
  return v16;
}

uint64_t sub_100056960(void *a1)
{
  _QWORD *v1;
  const char *v2;
  id v3;
  void *v4;
  _xpc_connection_s *Property;
  uint64_t pid;
  id v7;
  id v8;
  void *v9;
  id v10;
  id *v11;
  void *v12;
  id v13;
  id v14;
  uint64_t v15;
  id v16;
  uint64_t v17;
  void *i;
  uint64_t v19;
  id v20;
  id v21;
  id v22;
  uint64_t v23;
  void *j;
  void *v25;
  int IsLevelEnabled;
  id *v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  _BYTE buffer[1024];
  _BYTE v38[128];

  v1 = a1;
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v3 = (id)qword_1001E4608;
    if (v1)
    {
      v4 = (void *)v1[4];
      if (!v4)
      {
        Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8, 1);
        pid = xpc_connection_get_pid(Property);
        v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v7 = v8;
        }
        v9 = (void *)v1[4];
        v1[4] = v7;

        v4 = (void *)v1[4];
      }
      v10 = v4;
    }
    else
    {
      v10 = 0;
    }
    _NRLogWithArgs(v3, 0, "%s%.30s:%-4d %@ requested a refresh of the companion link agent generation", "", "handleRefreshCompanionProxyAgent", 1316, v10);

  }
  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v11 = (id *)(id)qword_1001E4708;
  if (v11)
  {
    v28 = v11;
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11[25], "allValues"));
    v29 = 0u;
    v30 = 0u;
    v31 = 0u;
    v32 = 0u;
    v13 = v12;
    v14 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v29, v38, 16);
    if (v14)
    {
      v16 = v14;
      v17 = *(_QWORD *)v30;
      do
      {
        for (i = 0; i != v16; i = (char *)i + 1)
        {
          if (*(_QWORD *)v30 != v17)
            objc_enumerationMutation(v13);
          v19 = *(_QWORD *)(*((_QWORD *)&v29 + 1) + 8 * (_QWORD)i);
          if (v19)
          {
            if (*(_BYTE *)(v19 + 14))
            {
              v35 = 0u;
              v36 = 0u;
              v33 = 0u;
              v34 = 0u;
              v20 = *(id *)(v19 + 112);
              v21 = objc_msgSend(v20, "countByEnumeratingWithState:objects:count:", &v33, buffer, 16);
              if (v21)
              {
                v22 = v21;
                v23 = *(_QWORD *)v34;
                do
                {
                  for (j = 0; j != v22; j = (char *)j + 1)
                  {
                    if (*(_QWORD *)v34 != v23)
                      objc_enumerationMutation(v20);
                    objc_msgSend(*(id *)(*((_QWORD *)&v33 + 1) + 8 * (_QWORD)j), "refreshCompanionProxyAgent");
                  }
                  v22 = objc_msgSend(v20, "countByEnumeratingWithState:objects:count:", &v33, buffer, 16);
                }
                while (v22);
              }
              goto LABEL_22;
            }
            v25 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v19 + 96), v15);
            IsLevelEnabled = _NRLogIsLevelEnabled(v25, 1);

            if (IsLevelEnabled)
            {
              v20 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v19 + 96), v15);
              _NRLogWithArgs(v20, 1, "%s%.30s:%-4d Ignoring refreshCompanionProxyAgent as conductor is disabled", "", "-[NRDDeviceConductor refreshCompanionProxyAgent]", 2554);
LABEL_22:

              continue;
            }
          }
        }
        v16 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v29, v38, 16);
      }
      while (v16);
    }

    v11 = v28;
  }

  return 0;
}

uint64_t sub_100056D38(void *a1)
{
  id v1;
  _QWORD *Property;
  const char *v3;
  _QWORD *v4;
  const unsigned __int8 *uuid;
  const unsigned __int8 *v6;
  const char *v7;
  id v8;
  void *v9;
  _xpc_connection_s *v10;
  uint64_t pid;
  id v12;
  id v13;
  void *v14;
  id v15;
  uint64_t v16;
  id v17;
  __objc2_prot *v18;
  int v19;
  const char *v20;
  const char *v21;
  id v22;
  void *v23;
  _xpc_connection_s *v24;
  uint64_t v25;
  id v26;
  id v27;
  void *v28;
  id v29;
  id v30;
  xpc_object_t dictionary;
  id v32;
  _QWORD *v33;
  const char *v34;
  _QWORD *v35;
  id v36;
  void *v37;
  id v38;
  id v39;
  uint64_t v40;
  id v41;
  id v42;
  uint64_t v43;
  void *v44;
  int v45;
  uint64_t v46;
  void *v47;
  _QWORD *v48;
  uint64_t v49;
  char isKindOfClass;
  unsigned int v51;
  void *v52;
  void *v53;
  unsigned int v54;
  uint64_t v55;
  id v56;
  uint64_t v57;
  void *v58;
  int v59;
  uint64_t v60;
  void *v61;
  id v62;
  void *v63;
  int v64;
  uint64_t v65;
  void *v66;
  int v67;
  uint64_t v68;
  void *v69;
  void *v70;
  id v71;
  uint64_t v72;
  void *i;
  unint64_t v74;
  void *v75;
  uint64_t v76;
  void *v77;
  void *v78;
  uint64_t v79;
  unsigned __int8 v80;
  uint64_t v81;
  unsigned int v82;
  unsigned int v83;
  unsigned int v84;
  NSObject *v85;
  pid_t v86;
  id v87;
  void *v88;
  id v89;
  int v90;
  const char *v91;
  id v93;
  int IsLevelEnabled;
  id v95;
  int *v96;
  uint64_t v97;
  id v98;
  uint64_t v99;
  void *v100;
  id v101;
  id v102;
  id v103;
  id v104;
  id v105;
  id v106;
  _QWORD *v107;
  void *v108;
  _QWORD v109[6];
  uint64_t v110;
  uint64_t *v111;
  uint64_t v112;
  uint64_t (*v113)(uint64_t, uint64_t);
  void (*v114)(uint64_t);
  id v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  _QWORD v120[4];
  unsigned int v121;
  int v122;
  _BYTE v123[48];
  uint64_t v124;

  Property = a1;
  v4 = Property;
  if (Property)
    Property = objc_getProperty(Property, v3, 16, 1);
  uuid = xpc_dictionary_get_uuid(Property, nrXPCKeyDeviceIdentifier);
  if (uuid)
  {
    v6 = uuid;
    if (uuid_is_null(uuid))
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      if (_NRLogIsLevelEnabled(qword_1001E4608, 17))
      {
        if (qword_1001E4610 != -1)
          dispatch_once(&qword_1001E4610, &stru_1001B6788);
        v8 = (id)qword_1001E4608;
        if (v4)
        {
          v9 = (void *)v4[4];
          if (!v9)
          {
            v10 = (_xpc_connection_s *)objc_getProperty(v4, v7, 8, 1);
            pid = xpc_connection_get_pid(v10);
            v12 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
            bzero(v123, 0x400uLL);
            if ((int)pid >= 1 && proc_pidpath(pid, v123, 0x400u) >= 1 && v123[0])
            {
              v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), v123, pid);

              v12 = v13;
            }
            v14 = (void *)v4[4];
            v4[4] = v12;

            v9 = (void *)v4[4];
          }
          v15 = v9;
        }
        else
        {
          v15 = 0;
        }
        _NRLogWithArgs(v8, 17, "All-zero NRUUID from %@", v15);
        goto LABEL_19;
      }
LABEL_118:
      v16 = -2005;
      goto LABEL_119;
    }
    v17 = objc_msgSend(objc_alloc((Class)NSUUID), "initWithUUIDBytes:", v6);
    if (v17)
    {
      v1 = v17;
      v18 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
      if (qword_1001E4610 == -1)
        goto LABEL_22;
    }
    else
    {
      v93 = sub_100045324();
      IsLevelEnabled = _NRLogIsLevelEnabled(v93, 16);

      if (IsLevelEnabled)
      {
        v95 = sub_100045324();
        _NRLogWithArgs(v95, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)", "", "handleXPCComm", 1335);

      }
      v4 = (_QWORD *)_os_log_pack_size(12);
      v18 = (__objc2_prot *)((char *)&v99 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0));
      v96 = __error();
      v97 = _os_log_pack_fill(v18, v4, *v96, &_mh_execute_header, "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
      *(_DWORD *)v97 = 136446210;
      *(_QWORD *)(v97 + 4) = "handleXPCComm";
      v98 = sub_100045324();
      _NRLogAbortWithPack(v98, v18);
      __break(1u);
    }
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
LABEL_22:
    v19 = _NRLogIsLevelEnabled(qword_1001E4608, 0);
    v108 = v1;
    if (v19)
    {
      if (v18[21].opt_inst_meths != (__objc2_meth_list *)-1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      v22 = (id)qword_1001E4608;
      if (v4)
      {
        v23 = (void *)v4[4];
        if (!v23)
        {
          v24 = (_xpc_connection_s *)objc_getProperty(v4, v21, 8, 1);
          v25 = xpc_connection_get_pid(v24);
          v26 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), v25);
          bzero(v123, 0x400uLL);
          if ((int)v25 >= 1)
          {
            if (proc_pidpath(v25, v123, 0x400u) >= 1 && v123[0])
            {
              v27 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), v123, v25);

              v26 = v27;
            }
            v1 = v108;
          }
          v28 = (void *)v4[4];
          v4[4] = v26;

          v23 = (void *)v4[4];
        }
        v29 = v23;
      }
      else
      {
        v29 = 0;
      }
      _NRLogWithArgs(v22, 0, "%s%.30s:%-4d Received XPCComm %@ from %@", "", "handleXPCComm", 1336, v1, v29);

    }
    if (v4)
      v30 = objc_getProperty(v4, v20, 16, 1);
    else
      v30 = 0;
    dictionary = xpc_dictionary_get_dictionary(v30, nrXPCKeyXPCCommNotification);
    v32 = (id)objc_claimAutoreleasedReturnValue(dictionary);
    objc_opt_self(NRLinkDirector);
    if (qword_1001E4710 != -1)
      dispatch_once(&qword_1001E4710, &stru_1001B6E60);
    v33 = (id)qword_1001E4708;
    v35 = v33;
    if (v4)
    {
      v36 = objc_getProperty(v4, v34, 8, 1);
      if (v35)
      {
LABEL_41:
        v107 = v35;
        v37 = (void *)v35[25];
        v38 = v32;
        v39 = v36;
        v40 = objc_claimAutoreleasedReturnValue(objc_msgSend(v37, "objectForKeyedSubscript:", v108));
        v41 = v39;
        v42 = v38;
        if (!v40 || !*(_BYTE *)(v40 + 14))
        {
LABEL_105:

          v86 = xpc_connection_get_pid((xpc_connection_t)v41);
          v124 = 0;
          memset(v123, 0, sizeof(v123));
          if (proc_pidinfo(v86, 17, 1uLL, v123, 56) == 56)
          {
            v87 = objc_msgSend(objc_alloc((Class)NSUUID), "initWithUUIDBytes:", v123);
            v88 = (void *)v107[30];
            v107[30] = v87;

          }
          else
          {
            if (qword_1001E4738 != -1)
              dispatch_once(&qword_1001E4738, &stru_1001B7110);
            if (_NRLogIsLevelEnabled(qword_1001E4730, 17))
            {
              if (qword_1001E4738 != -1)
                dispatch_once(&qword_1001E4738, &stru_1001B7110);
              _NRLogWithArgs(qword_1001E4730, 17, "Failed to retrieve process UUID");
            }
          }
          v35 = v107;
          goto LABEL_114;
        }
        objc_msgSend(*(id *)(v40 + 152), "addObject:", v41);
        v44 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v40 + 96), v43);
        v45 = _NRLogIsLevelEnabled(v44, 0);

        if (v45)
        {
          v47 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v40 + 96), v46);
          _NRLogWithArgs(v47, 0, "%s%.30s:%-4d Received notification: %@", "", "-[NRDDeviceConductor processXPCCommNotificationForConnection:notificationDictionary:]", 7248, v42);

        }
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(v40 + 104));
        v48 = sub_1000D8AA8(v40, 1, 0);
        if (!v48
          || (v49 = objc_opt_class(NRLinkBluetooth), isKindOfClass = objc_opt_isKindOfClass(v48, v49),
                                                                   !v42)
          || (isKindOfClass & 1) == 0
          || objc_msgSend(v48, "state") == 255)
        {
LABEL_102:
          if (objc_msgSend(*(id *)(v40 + 160), "count"))
            sub_1000EF368(v40, 0);

          goto LABEL_105;
        }
        v110 = 0;
        v111 = &v110;
        v112 = 0x3032000000;
        v113 = sub_1000DF41C;
        v114 = sub_1000DF42C;
        v115 = 0;
        v109[0] = _NSConcreteStackBlock;
        v109[1] = 3221225472;
        v109[2] = sub_1000EF168;
        v109[3] = &unk_1001B7520;
        v109[4] = v40;
        v109[5] = &v110;
        xpc_dictionary_apply(v42, v109);
        v106 = (id)v111[5];
        v51 = objc_msgSend(v48, "state");
        if (!v106 || v51 == 255)
        {
LABEL_101:

          _Block_object_dispose(&v110, 8);
          goto LABEL_102;
        }
        v102 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v106, "objectForKeyedSubscript:", CFSTR("checkin")));
        if (objc_msgSend(v102, "BOOLValue") && objc_msgSend(v48, "state") == 8)
        {
          sub_10008F998(v48, 0, &off_1001C46D8);
          if (*(_QWORD *)((char *)v48 + 1111) && *((_BYTE *)v48 + 229))
            sub_10008F998(v48, 0, &off_1001C46F0);
          if (*(_QWORD *)((char *)v48 + 1031))
            sub_10008F998(v48, 0, &off_1001C4708);
          v52 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)((char *)v48 + 1335), "nexusInstances"));
          sub_100095EB0((uint64_t)v48, v52);

        }
        v104 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v106, "objectForKeyedSubscript:", CFSTR("message")));
        if (!v104)
        {
LABEL_77:
          v105 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v106, "objectForKeyedSubscript:", CFSTR("datapath-report")));
          if (v105)
          {
            v69 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v105, "objectForKeyedSubscript:", CFSTR("datapath-report-stall")));
            if (objc_msgSend(v69, "BOOLValue"))
            {
              v70 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v105, "objectForKeyedSubscript:", CFSTR("channel-id-list")));
              v118 = 0u;
              v119 = 0u;
              v116 = 0u;
              v117 = 0u;
              v71 = objc_msgSend(v70, "countByEnumeratingWithState:objects:count:", &v116, v123, 16);
              v100 = v69;
              v101 = v42;
              v103 = v32;
              if (v71)
              {
                v72 = *(_QWORD *)v117;
                do
                {
                  for (i = 0; i != v71; i = (char *)i + 1)
                  {
                    if (*(_QWORD *)v117 != v72)
                      objc_enumerationMutation(v70);
                    v74 = (unint64_t)objc_msgSend(*(id *)(*((_QWORD *)&v116 + 1) + 8 * (_QWORD)i), "integerValue")- 1;
                    if (v74 <= 2)
                      sub_100097568(v48, (&off_1001B6DD0)[v74]);
                  }
                  v71 = objc_msgSend(v70, "countByEnumeratingWithState:objects:count:", &v116, v123, 16);
                }
                while (v71);
              }

              v32 = v103;
              v69 = v100;
              v42 = v101;
            }
            v75 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v105, "objectForKeyedSubscript:", CFSTR("datapath-report-remediate")));
            if (objc_msgSend(v75, "BOOLValue"))
              sub_100097C68((uint64_t)v48);

          }
          v76 = objc_claimAutoreleasedReturnValue(objc_msgSend(v106, "objectForKeyedSubscript:", CFSTR("error")));
          v77 = (void *)v76;
          if (v76)
            objc_msgSend(v48, "cancelWithReason:", CFSTR("parser internal error: %@"), v76);
          v78 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v106, "objectForKeyedSubscript:", CFSTR("wake-pkt-sn")));
          v103 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v106, "objectForKeyedSubscript:", CFSTR("wake-pkt-spi")));
          if (v78)
          {
            v79 = objc_opt_class(NSNumber);
            v80 = objc_opt_isKindOfClass(v78, v79);
            if ((v80 & (v103 != 0)) == 1)
            {
              v81 = objc_opt_class(NSNumber);
              if ((objc_opt_isKindOfClass(v103, v81) & 1) != 0)
              {
                v82 = objc_msgSend(v78, "unsignedIntValue");
                v83 = objc_msgSend(v103, "unsignedIntValue");
                LODWORD(v100) = v82;
                v101 = v77;
                v84 = v83;
                if (qword_1001E48A0 != -1)
                  dispatch_once(&qword_1001E48A0, &stru_1001B7C10);
                v85 = (id)qword_1001E4898;
                v120[0] = _NSConcreteStackBlock;
                v120[1] = 3221225472;
                v120[2] = sub_10008C1F8;
                v120[3] = &unk_1001B85D0;
                v121 = v84;
                v122 = (int)v100;
                dispatch_async(v85, v120);

                v77 = v101;
              }
            }
          }

          goto LABEL_101;
        }
        v53 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v104, "objectForKeyedSubscript:", CFSTR("message-data")));
        if (!v53)
        {
LABEL_76:

          goto LABEL_77;
        }
        v105 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v104, "objectForKeyedSubscript:", CFSTR("channel-id")));
        v103 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v104, "objectForKeyedSubscript:", CFSTR("message-pre-act")));
        v54 = objc_msgSend(v103, "BOOLValue");
        v56 = objc_msgSend(v105, "integerValue");
        if (v56 == (id)1)
        {
          if (v54 && *((_BYTE *)v48 + 247))
          {
            v63 = (void *)_NRCopyLogObjectForNRUUID(v48[4], v55);
            v64 = _NRLogIsLevelEnabled(v63, 0);

            if (v64)
            {
              v61 = (void *)_NRCopyLogObjectForNRUUID(v48[4], v65);
              v62 = objc_msgSend(v48, "copyDescription");
              _NRLogWithArgs(v61, 0, "%s%.30s:%-4d %@: ignoring pre-activation message for medium", "", "-[NRLinkBluetooth processXPCCommDictionary:]", 5988, v62);
              goto LABEL_74;
            }
LABEL_75:

            goto LABEL_76;
          }
        }
        else
        {
          if (objc_msgSend(v105, "integerValue") != (id)2)
          {
            v66 = (void *)_NRCopyLogObjectForNRUUID(v48[4], v57);
            v67 = _NRLogIsLevelEnabled(v66, 17);

            if (v67)
            {
              v61 = (void *)_NRCopyLogObjectForNRUUID(v48[4], v68);
              v62 = objc_msgSend(v48, "copyDescription");
              _NRLogWithArgs(v61, 17, "%@: Invalid channel ID: %@", v62, v105);
              goto LABEL_74;
            }
            goto LABEL_75;
          }
          if (v54 && *((_BYTE *)v48 + 248))
          {
            v58 = (void *)_NRCopyLogObjectForNRUUID(v48[4], v57);
            v59 = _NRLogIsLevelEnabled(v58, 0);

            if (v59)
            {
              v61 = (void *)_NRCopyLogObjectForNRUUID(v48[4], v60);
              v62 = objc_msgSend(v48, "copyDescription");
              _NRLogWithArgs(v61, 0, "%s%.30s:%-4d %@: ignoring pre-activation message for high", "", "-[NRLinkBluetooth processXPCCommDictionary:]", 5994, v62);
LABEL_74:

              goto LABEL_75;
            }
            goto LABEL_75;
          }
        }
        sub_10009F568((uint64_t)v48, v53, v56 != (id)1);
        goto LABEL_75;
      }
    }
    else
    {
      v36 = 0;
      if (v33)
        goto LABEL_41;
    }
LABEL_114:

    v15 = v32;
    v16 = 0;
    v8 = v108;
    goto LABEL_115;
  }
  v89 = sub_100045324();
  v90 = _NRLogIsLevelEnabled(v89, 17);

  if (!v90)
    goto LABEL_118;
  v8 = sub_100045324();
  v15 = sub_100045394(v4, v91);
  _NRLogWithArgs(v8, 17, "Missing NRUUID from %@", v15);
LABEL_19:
  v16 = -2005;
LABEL_115:

LABEL_119:
  return v16;
}

void sub_100057B30(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 + 128), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100057B54(void *a1)
{
  _QWORD *Property;
  const char *v2;
  _QWORD *v3;
  _BOOL4 v4;
  const char *v5;
  id v6;
  void *v7;
  _xpc_connection_s *v8;
  uint64_t pid;
  id v10;
  id v11;
  void *v12;
  id v13;
  id v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  _BYTE buffer[1024];

  Property = a1;
  v3 = Property;
  if (Property)
    Property = objc_getProperty(Property, v2, 16, 1);
  v4 = xpc_dictionary_get_BOOL(Property, nrXPCKeyEnableBluetoothPacketParser);
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v6 = (id)qword_1001E4608;
    if (v3)
    {
      v7 = (void *)v3[4];
      if (!v7)
      {
        v8 = (_xpc_connection_s *)objc_getProperty(v3, v5, 8, 1);
        pid = xpc_connection_get_pid(v8);
        v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          v11 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v10 = v11;
        }
        v12 = (void *)v3[4];
        v3[4] = v10;

        v7 = (void *)v3[4];
      }
      v13 = v7;
    }
    else
    {
      v13 = 0;
    }
    _NRLogWithArgs(v6, 0, "%s%.30s:%-4d Client %@ setting bluetooth proxy path state enabled=%d", "", "handleEnableBluetoothPacketParser", 908, v13, v4);

  }
  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v14 = (id)qword_1001E4708;
  if (v14)
  {
    if (qword_1001E4738 != -1)
      dispatch_once(&qword_1001E4738, &stru_1001B7110);
    if (_NRLogIsLevelEnabled(qword_1001E4730, 0))
    {
      if (qword_1001E4738 != -1)
        dispatch_once(&qword_1001E4738, &stru_1001B7110);
      _NRLogWithArgs(qword_1001E4730, 0, "%s%.30s:%-4d Setting bluetooth proxy path state enabled=%d", "", "-[NRLinkDirector setEnableBluetoothPacketParserForTesting:]", 1108, v4);
    }
    if (v4)
    {
      v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", 1));
      sub_1000A0244(0, CFSTR("EnableBluetoothPacketParser"), v15);

      v21 = "YES";
    }
    else
    {
      sub_1000A04A0(0, CFSTR("EnableBluetoothPacketParser"));
      v21 = "NO";
    }
    sub_1000A25C4((uint64_t)v14, 1039, CFSTR("%s"), v16, v17, v18, v19, v20, (uint64_t)v21);
  }

  return 0;
}

uint64_t sub_100057EAC(void *a1)
{
  _QWORD *v1;
  const char *v2;
  id v3;
  void *v4;
  _xpc_connection_s *Property;
  uint64_t pid;
  id v7;
  id v8;
  void *v9;
  id v10;
  _BYTE buffer[1024];

  v1 = a1;
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v3 = (id)qword_1001E4608;
    if (v1)
    {
      v4 = (void *)v1[4];
      if (!v4)
      {
        Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8, 1);
        pid = xpc_connection_get_pid(Property);
        v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v7 = v8;
        }
        v9 = (void *)v1[4];
        v1[4] = v7;

        v4 = (void *)v1[4];
      }
      v10 = v4;
    }
    else
    {
      v10 = 0;
    }
    _NRLogWithArgs(v3, 0, "%s%.30s:%-4d Ignoring request to set companion link encryption type from %@", "", "handleCompanionLinkSetEncryptionType", 1253, v10);

  }
  return 0;
}

uint64_t sub_10005807C(void *a1)
{
  _QWORD *v1;
  const char *v2;
  id v3;
  void *v4;
  _xpc_connection_s *Property;
  uint64_t pid;
  id v7;
  id v8;
  void *v9;
  id v10;
  void *v11;
  NRDevicePairingDirector *v12;
  void *v13;
  const char *v14;
  id *v15;
  id v16;
  id v17;
  void *v18;
  _QWORD *v19;
  id v20;
  _QWORD buffer[5];
  id v23;

  v1 = a1;
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v3 = (id)qword_1001E4608;
    if (v1)
    {
      v4 = (void *)v1[4];
      if (!v4)
      {
        Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8, 1);
        pid = xpc_connection_get_pid(Property);
        v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && LOBYTE(buffer[0]))
        {
          v8 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v7 = v8;
        }
        v9 = (void *)v1[4];
        v1[4] = v7;

        v4 = (void *)v1[4];
      }
      v10 = v4;
    }
    else
    {
      v10 = 0;
    }
    _NRLogWithArgs(v3, 0, "%s%.30s:%-4d Received device pairing connection from %@", "", "handleDevicePairingConnection", 1348, v10);

  }
  objc_opt_self(NRDevicePairingDirector);
  v11 = (void *)qword_1001E4810;
  if (!qword_1001E4810)
  {
    v12 = objc_alloc_init(NRDevicePairingDirector);
    v13 = (void *)qword_1001E4810;
    qword_1001E4810 = (uint64_t)v12;

    v11 = (void *)qword_1001E4810;
  }
  v15 = v11;
  if (v1)
  {
    v16 = objc_getProperty(v1, v14, 8, 1);
    if (!v15)
      goto LABEL_26;
  }
  else
  {
    v16 = 0;
    if (!v15)
      goto LABEL_26;
  }
  v17 = v16;
  v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](NSUUID, "UUID"));
  v19 = sub_1000FF520([NRDevicePairingManagerConnection alloc], v17);
  objc_msgSend(v15[2], "setObject:forKeyedSubscript:", v19, v18);
  buffer[0] = _NSConcreteStackBlock;
  buffer[1] = 3221225472;
  buffer[2] = sub_100106200;
  buffer[3] = &unk_1001B7A90;
  buffer[4] = v15;
  v20 = v18;
  v23 = v20;
  xpc_connection_set_event_handler((xpc_connection_t)v17, buffer);

  if (qword_1001E4820 != -1)
    dispatch_once(&qword_1001E4820, &stru_1001B7AB0);
  if (_NRLogIsLevelEnabled(qword_1001E4818, 0))
  {
    if (qword_1001E4820 != -1)
      dispatch_once(&qword_1001E4820, &stru_1001B7AB0);
    _NRLogWithArgs(qword_1001E4818, 0, "%s%.30s:%-4d Registered device pairing connection %@", "", "-[NRDevicePairingDirector addDevicePairingConnection:]", 3077, v20);
  }

LABEL_26:
  return 0;
}

void sub_1000583EC(uint64_t a1, uint64_t a2)
{
  const char *v4;
  const char *v5;
  id v6;
  _QWORD *v7;
  uint64_t v8;
  void *v9;
  _xpc_connection_s *Property;
  uint64_t pid;
  id v12;
  id v13;
  void *v14;
  id v15;
  const char *v16;
  id v17;
  const char *v18;
  id v19;
  const char *v20;
  void *v21;
  id v22;
  _xpc_connection_s *connection;
  _BYTE buffer[1024];

  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v6 = (id)qword_1001E4608;
    v8 = *(_QWORD *)(a1 + 32);
    v7 = *(_QWORD **)(a1 + 40);
    if (v7)
    {
      v9 = (void *)v7[4];
      if (!v9)
      {
        Property = (_xpc_connection_s *)objc_getProperty(*(id *)(a1 + 40), v5, 8, 1);
        pid = xpc_connection_get_pid(Property);
        v12 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

          v12 = v13;
        }
        v14 = (void *)v7[4];
        v7[4] = v12;

        v9 = (void *)v7[4];
      }
      v7 = v9;
    }
    _NRLogWithArgs(v6, 0, "%s%.30s:%-4d Measured BT latency %lluns for %@ from %@", "", "handleMeasureBTLatency_block_invoke", 1288, a2, v8, v7);

  }
  v15 = *(id *)(a1 + 40);
  if (v15)
    v15 = objc_getProperty(v15, v4, 24, 1);
  xpc_dictionary_set_int64(v15, nrXPCKeyResult, 0);
  v17 = *(id *)(a1 + 40);
  if (v17)
    v17 = objc_getProperty(v17, v16, 24, 1);
  xpc_dictionary_set_uint64(v17, nrXPCKeyBTLatency, a2);
  v19 = *(id *)(a1 + 40);
  if (v19)
    v19 = objc_getProperty(v19, v18, 8, 1);
  connection = (_xpc_connection_s *)v19;
  v21 = *(void **)(a1 + 40);
  if (v21)
    v22 = objc_getProperty(v21, v20, 24, 1);
  else
    v22 = 0;
  xpc_connection_send_message(connection, v22);

}

uint64_t sub_10005865C(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  const char *v5;
  id v6;
  id Property;
  const char *v8;
  id v9;
  _QWORD *v10;
  void *v11;
  _xpc_connection_s *v12;
  uint64_t pid;
  id v14;
  id v15;
  void *v16;
  uint64_t v17;
  const char *string_ptr;
  id v19;
  const char *v20;
  id v21;
  const char *v22;
  void *v23;
  _xpc_connection_s *v24;
  uint64_t v25;
  id v26;
  id v27;
  void *v28;
  const char *v30;
  id v31;
  id v32;
  const char *v33;
  id v34;
  _QWORD *v35;
  void *v36;
  _xpc_connection_s *v37;
  uint64_t v38;
  id v39;
  void *v40;
  _BYTE buffer[1024];

  v4 = a3;
  if (xpc_get_type(v4) != (xpc_type_t)&_xpc_type_string)
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    if (_NRLogIsLevelEnabled(qword_1001E4608, 16))
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      v6 = (id)qword_1001E4608;
      Property = *(id *)(a1 + 32);
      if (Property)
        Property = objc_getProperty(Property, v5, 16, 1);
      v9 = Property;
      v10 = *(_QWORD **)(a1 + 32);
      if (v10)
      {
        v11 = (void *)v10[4];
        if (!v11)
        {
          v12 = (_xpc_connection_s *)objc_getProperty(v10, v8, 8, 1);
          pid = xpc_connection_get_pid(v12);
          v14 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), pid);
          bzero(buffer, 0x400uLL);
          if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
          {
            v15 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, pid);

            v14 = v15;
          }
          v16 = (void *)v10[4];
          v10[4] = v14;

          v11 = (void *)v10[4];
        }
        v10 = v11;
      }
      _NRLogWithArgs(v6, 16, "%s%.30s:%-4d Bad XPC type found in policy traffic class message %@ from %@", "", "handleDevicePreferences_block_invoke", 1058, v9, v10);
LABEL_18:

      goto LABEL_19;
    }
    goto LABEL_40;
  }
  string_ptr = xpc_string_get_string_ptr(v4);
  if (!string_ptr)
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    if (_NRLogIsLevelEnabled(qword_1001E4608, 16))
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      v6 = (id)qword_1001E4608;
      v21 = *(id *)(a1 + 32);
      if (v21)
        v21 = objc_getProperty(v21, v20, 16, 1);
      v9 = v21;
      v10 = *(_QWORD **)(a1 + 32);
      if (v10)
      {
        v23 = (void *)v10[4];
        if (!v23)
        {
          v24 = (_xpc_connection_s *)objc_getProperty(v10, v22, 8, 1);
          v25 = xpc_connection_get_pid(v24);
          v26 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("unknown:%d"), v25);
          bzero(buffer, 0x400uLL);
          if ((int)v25 >= 1 && proc_pidpath(v25, buffer, 0x400u) >= 1 && buffer[0])
          {
            v27 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%s:%d"), buffer, v25);

            v26 = v27;
          }
          v28 = (void *)v10[4];
          v10[4] = v26;

          v23 = (void *)v10[4];
        }
        v10 = v23;
      }
      _NRLogWithArgs(v6, 16, "%s%.30s:%-4d Bad XPC string found in policy traffic class message %@ from %@", "", "handleDevicePreferences_block_invoke", 1064, v9, v10);
      goto LABEL_18;
    }
LABEL_40:
    v17 = 0;
    goto LABEL_41;
  }
  v19 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", string_ptr);
  if (v19)
  {
    v6 = v19;
    objc_msgSend(*(id *)(a1 + 40), "addObject:", v19);
    v17 = 1;
    goto LABEL_23;
  }
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 16))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    v31 = (id)qword_1001E4608;
    v32 = *(id *)(a1 + 32);
    if (v32)
      v32 = objc_getProperty(v32, v30, 16, 1);
    v34 = v32;
    v35 = *(_QWORD **)(a1 + 32);
    if (v35)
    {
      v36 = (void *)v35[4];
      if (!v36)
      {
        v37 = (_xpc_connection_s *)objc_getProperty(v35, v33, 8, 1);
        v38 = xpc_connection_get_pid(v37);
        v39 = sub_100109ADC(v38, 1);
        v40 = (void *)v35[4];
        v35[4] = v39;

        v36 = (void *)v35[4];
      }
      v35 = v36;
    }
    _NRLogWithArgs(v31, 16, "%s%.30s:%-4d Bad string found in policy traffic class message %@ from %@", "", "handleDevicePreferences_block_invoke", 1070, v34, v35);

  }
  v6 = 0;
LABEL_19:
  v17 = 0;
LABEL_23:

LABEL_41:
  return v17;
}

void sub_100058B3C(id a1)
{
  void *v1;
  void *v2;

  v1 = sub_100045638([TerminusdXPCServer alloc]);
  v2 = (void *)qword_1001E45F8;
  qword_1001E45F8 = (uint64_t)v1;

  sub_100058B6C();
}

uint64_t sub_100058B6C()
{
  uint64_t v0;
  uint64_t result;
  int v2;

  if (dword_1001E3AF0 == -1)
  {
    result = notify_register_check("com.apple.networkrelay.endpointcache", &dword_1001E3AF0);
    if ((_DWORD)result)
    {
      v2 = result;
      dword_1001E3AF0 = -1;
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      result = _NRLogIsLevelEnabled(qword_1001E4608, 17);
      if ((_DWORD)result)
      {
        if (qword_1001E4610 != -1)
          dispatch_once(&qword_1001E4610, &stru_1001B6788);
        return _NRLogWithArgs(qword_1001E4608, 17, "notify_register_check(%s) failed: %u", "com.apple.networkrelay.endpointcache", v2);
      }
      return result;
    }
    if (dword_1001E3AF0 == -1)
      return result;
  }
  v0 = sub_100107758();
  if (qword_1001E4610 != -1)
    dispatch_once(&qword_1001E4610, &stru_1001B6788);
  if (_NRLogIsLevelEnabled(qword_1001E4608, 1))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    _NRLogWithArgs(qword_1001E4608, 1, "%s%.30s:%-4d Setting NREndpoint cache generation to %llu", "", "notifyNREndpointCacheChanged", 87, v0);
  }
  if (notify_set_state(dword_1001E3AF0, v0))
  {
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    if (_NRLogIsLevelEnabled(qword_1001E4608, 17))
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      _NRLogWithArgs(qword_1001E4608, 17, "notify_set_state(%s, %d) failed: %u");
    }
  }
  else
  {
    result = notify_post("com.apple.networkrelay.endpointcache");
    if (!(_DWORD)result)
      return result;
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    if (_NRLogIsLevelEnabled(qword_1001E4608, 17))
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      _NRLogWithArgs(qword_1001E4608, 17, "notify_post(%s) failed: %u");
    }
  }
  result = notify_cancel(dword_1001E3AF0);
  dword_1001E3AF0 = -1;
  return result;
}

void sub_100058E20(uint64_t a1, void *a2)
{
  const char *v3;
  id Property;
  const char *v5;
  id v6;
  const char *v7;
  id v8;
  const char *v9;
  id v10;
  const char *v11;
  _xpc_connection_s *v12;
  void *v13;
  id v14;
  id v15;

  v15 = a2;
  Property = *(id *)(a1 + 32);
  if (Property)
    Property = objc_getProperty(Property, v3, 24, 1);
  xpc_dictionary_set_int64(Property, nrXPCKeyResult, 0);
  v6 = *(id *)(a1 + 32);
  if (v6)
    v6 = objc_getProperty(v6, v5, 24, 1);
  v7 = (const char *)nrXPCKeyIDSDeviceID;
  v8 = v6;
  xpc_dictionary_set_string(v8, v7, (const char *)objc_msgSend(v15, "UTF8String"));

  v10 = *(id *)(a1 + 32);
  if (v10)
    v10 = objc_getProperty(v10, v9, 8, 1);
  v12 = (_xpc_connection_s *)v10;
  v13 = *(void **)(a1 + 32);
  if (v13)
    v14 = objc_getProperty(v13, v11, 24, 1);
  else
    v14 = 0;
  xpc_connection_send_message(v12, v14);

}

void sub_100058F0C(uint64_t a1, int64_t a2, void *a3)
{
  const char *v5;
  id Property;
  const char *v7;
  const char *v8;
  id v9;
  id v10;
  const char *v11;
  id v12;
  id v13;
  const char *v14;
  _xpc_connection_s *v15;
  void *v16;
  id v17;
  id v18;

  v18 = a3;
  Property = *(id *)(a1 + 32);
  if (Property)
    Property = objc_getProperty(Property, v5, 24, 1);
  xpc_dictionary_set_int64(Property, nrXPCKeyResult, a2);
  if (v18)
  {
    v9 = v18;
    v10 = *(id *)(a1 + 32);
    if (v10)
      v10 = objc_getProperty(v10, v8, 24, 1);
    v11 = (const char *)nrXPCKeyErrorDescription;
    v12 = v10;
    xpc_dictionary_set_string(v12, v11, (const char *)objc_msgSend(v9, "UTF8String"));

  }
  v13 = *(id *)(a1 + 32);
  if (v13)
    v13 = objc_getProperty(v13, v7, 8, 1);
  v15 = (_xpc_connection_s *)v13;
  v16 = *(void **)(a1 + 32);
  if (v16)
    v17 = objc_getProperty(v16, v14, 24, 1);
  else
    v17 = 0;
  xpc_connection_send_message(v15, v17);

}

void sub_100059014(uint64_t a1, int64_t a2, void *a3)
{
  const char *v5;
  id Property;
  const char *v7;
  const char *v8;
  id v9;
  id v10;
  const char *v11;
  id v12;
  id v13;
  const char *v14;
  _xpc_connection_s *v15;
  void *v16;
  id v17;
  id v18;

  v18 = a3;
  Property = *(id *)(a1 + 32);
  if (Property)
    Property = objc_getProperty(Property, v5, 24, 1);
  xpc_dictionary_set_int64(Property, nrXPCKeyResult, a2);
  if (v18)
  {
    v9 = v18;
    v10 = *(id *)(a1 + 32);
    if (v10)
      v10 = objc_getProperty(v10, v8, 24, 1);
    v11 = (const char *)nrXPCKeyErrorDescription;
    v12 = v10;
    xpc_dictionary_set_string(v12, v11, (const char *)objc_msgSend(v9, "UTF8String"));

  }
  v13 = *(id *)(a1 + 32);
  if (v13)
    v13 = objc_getProperty(v13, v7, 8, 1);
  v15 = (_xpc_connection_s *)v13;
  v16 = *(void **)(a1 + 32);
  if (v16)
    v17 = objc_getProperty(v16, v14, 24, 1);
  else
    v17 = 0;
  xpc_connection_send_message(v15, v17);

}

void sub_10005911C(uint64_t a1, int64_t a2, void *a3)
{
  const char *v5;
  id Property;
  const char *v7;
  const char *v8;
  id v9;
  id v10;
  const char *v11;
  id v12;
  id v13;
  const char *v14;
  _xpc_connection_s *v15;
  void *v16;
  id v17;
  id v18;

  v18 = a3;
  sub_100058B6C();
  Property = *(id *)(a1 + 32);
  if (Property)
    Property = objc_getProperty(Property, v5, 24, 1);
  xpc_dictionary_set_int64(Property, nrXPCKeyResult, a2);
  if (v18)
  {
    v9 = v18;
    v10 = *(id *)(a1 + 32);
    if (v10)
      v10 = objc_getProperty(v10, v8, 24, 1);
    v11 = (const char *)nrXPCKeyErrorDescription;
    v12 = v10;
    xpc_dictionary_set_string(v12, v11, (const char *)objc_msgSend(v9, "UTF8String"));

  }
  v13 = *(id *)(a1 + 32);
  if (v13)
    v13 = objc_getProperty(v13, v7, 8, 1);
  v15 = (_xpc_connection_s *)v13;
  v16 = *(void **)(a1 + 32);
  if (v16)
    v17 = objc_getProperty(v16, v14, 24, 1);
  else
    v17 = 0;
  xpc_connection_send_message(v15, v17);

}

void sub_100059228(uint64_t a1, int64_t a2, void *a3)
{
  const char *v5;
  id Property;
  const char *v7;
  const char *v8;
  id v9;
  id v10;
  const char *v11;
  id v12;
  id v13;
  const char *v14;
  _xpc_connection_s *v15;
  void *v16;
  id v17;
  id v18;

  v18 = a3;
  sub_100058B6C();
  Property = *(id *)(a1 + 32);
  if (Property)
    Property = objc_getProperty(Property, v5, 24, 1);
  xpc_dictionary_set_int64(Property, nrXPCKeyResult, a2);
  if (v18)
  {
    v9 = v18;
    v10 = *(id *)(a1 + 32);
    if (v10)
      v10 = objc_getProperty(v10, v8, 24, 1);
    v11 = (const char *)nrXPCKeyErrorDescription;
    v12 = v10;
    xpc_dictionary_set_string(v12, v11, (const char *)objc_msgSend(v9, "UTF8String"));

  }
  v13 = *(id *)(a1 + 32);
  if (v13)
    v13 = objc_getProperty(v13, v7, 8, 1);
  v15 = (_xpc_connection_s *)v13;
  v16 = *(void **)(a1 + 32);
  if (v16)
    v17 = objc_getProperty(v16, v14, 24, 1);
  else
    v17 = 0;
  xpc_connection_send_message(v15, v17);

}

void sub_100059334(uint64_t a1, int64_t a2, void *a3)
{
  const char *v5;
  id Property;
  const char *v7;
  const char *v8;
  id v9;
  id v10;
  const char *v11;
  id v12;
  id v13;
  const char *v14;
  _xpc_connection_s *v15;
  void *v16;
  id v17;
  id v18;

  v18 = a3;
  Property = *(id *)(a1 + 32);
  if (Property)
    Property = objc_getProperty(Property, v5, 24, 1);
  xpc_dictionary_set_int64(Property, nrXPCKeyResult, a2);
  if (v18)
  {
    v9 = v18;
    v10 = *(id *)(a1 + 32);
    if (v10)
      v10 = objc_getProperty(v10, v8, 24, 1);
    v11 = (const char *)nrXPCKeyErrorDescription;
    v12 = v10;
    xpc_dictionary_set_string(v12, v11, (const char *)objc_msgSend(v9, "UTF8String"));

  }
  v13 = *(id *)(a1 + 32);
  if (v13)
    v13 = objc_getProperty(v13, v7, 8, 1);
  v15 = (_xpc_connection_s *)v13;
  v16 = *(void **)(a1 + 32);
  if (v16)
    v17 = objc_getProperty(v16, v14, 24, 1);
  else
    v17 = 0;
  xpc_connection_send_message(v15, v17);

}

BOOL sub_10005943C(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  _BOOL8 v6;

  v3 = a2;
  v4 = a1;
  v5 = (void *)xpc_connection_copy_entitlement_value(v4, objc_msgSend(v3, "UTF8String"));

  v6 = v5 && xpc_get_type(v5) == (xpc_type_t)&_xpc_type_BOOL && xpc_BOOL_get_value(v5);
  return v6;
}

id sub_1000594C8()
{
  NSObject *v0;
  id v1;
  id v2;
  void *v3;
  void *v4;
  id v5;
  id v6;
  uint64_t v7;
  void *i;
  uint64_t v9;
  void *v10;
  void *v11;
  void *v12;
  id v13;
  uint64_t v14;
  NSObject *v15;
  id v16;
  id v17;
  id v18;
  id v19;
  const char *v20;
  id v21;
  id v22;
  id v23;
  id v24;
  uint64_t v25;
  void *j;
  id *v27;
  void *v28;
  _QWORD *v29;
  void *LogString;
  const char *v31;
  const char *v32;
  const char *v33;
  void *StringFromThermalPressureLevel;
  uint64_t port;
  id v36;
  id v37;
  void *v38;
  int v39;
  id v40;
  unsigned __int8 *v41;
  id v42;
  void *String;
  id v44;
  id v45;
  _QWORD *v46;
  id v47;
  id v48;
  void *v49;
  id v50;
  void *v51;
  id v52;
  void *v53;
  id v54;
  uint64_t v55;
  id v56;
  const char *v57;
  const char *v58;
  const char *v59;
  const char *v60;
  const char *v61;
  const char *v62;
  const char *v63;
  const char *v64;
  void *v65;
  _QWORD *v66;
  id v67;
  void *k;
  uint64_t v69;
  uint64_t v70;
  id v71;
  void *v72;
  id v73;
  uint64_t v74;
  __CFString *v75;
  const char *v76;
  const char *v77;
  const char *v78;
  const char *v79;
  const char *v80;
  const char *v81;
  const char *v82;
  const char *v83;
  const char *v84;
  const char *v85;
  const char *v86;
  const char *v87;
  id v88;
  const char *v89;
  void *v90;
  id v91;
  id v92;
  id v93;
  uint64_t v94;
  void *m;
  id v96;
  id v97;
  id v98;
  id v99;
  const char *v100;
  id v101;
  id v102;
  const char *v103;
  id v104;
  void *v106;
  id obj;
  id v108;
  uint64_t v109;
  unsigned int *v110;
  id v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  uint64_t v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  _BYTE v121[128];
  _BYTE v122[128];

  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v110 = (unsigned int *)(id)qword_1001E4708;
  if (!v110)
    goto LABEL_160;
  v0 = sub_10014CFBC();
  dispatch_assert_queue_V2(v0);

  v1 = objc_alloc((Class)NSMutableString);
  v2 = objc_alloc_init((Class)NSMutableString);
  os_unfair_lock_lock((os_unfair_lock_t)&unk_1001E49E0);
  v119 = 0u;
  v120 = 0u;
  v117 = 0u;
  v118 = 0u;
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)qword_1001E49D8, "allKeys"));
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "sortedArrayUsingSelector:", "compare:"));

  v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v117, v122, 16);
  if (v5)
  {
    v6 = v5;
    v7 = *(_QWORD *)v118;
    do
    {
      for (i = 0; i != v6; i = (char *)i + 1)
      {
        if (*(_QWORD *)v118 != v7)
          objc_enumerationMutation(v4);
        v9 = *(_QWORD *)(*((_QWORD *)&v117 + 1) + 8 * (_QWORD)i);
        v10 = (void *)_NRCopyTimeStringForDate(v9);
        v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)qword_1001E49D8, "objectForKeyedSubscript:", v9));
        objc_msgSend(v2, "appendFormat:", CFSTR("\n    %@ : %@"), v10, v11);

      }
      v6 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v117, v122, 16);
    }
    while (v6);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1001E49E0);
  v12 = (void *)_NRCopyTimeString();
  objc_msgSend(v2, "appendFormat:", CFSTR("\n    %@ : time of this status dump"), v12);

  v13 = objc_msgSend(v1, "initWithString:", v2);
  v14 = objc_opt_self(NRDLocalDevice);
  v15 = sub_10014CFBC();
  dispatch_assert_queue_V2(v15);

  sub_10012DFA0(v14);
  v16 = objc_msgSend((id)qword_1001E4A38, "copy");
  v17 = objc_alloc((Class)NSMutableString);
  v18 = objc_msgSend(v16, "count");
  v19 = objc_msgSend(v16, "count");
  v20 = "s";
  if (v19 == (id)1)
    v20 = "";
  v21 = objc_msgSend(v17, "initWithFormat:", CFSTR("--------- NRD Local Device Database Status (%llu device%s) ---------\n"), v18, v20);
  v117 = 0u;
  v118 = 0u;
  v119 = 0u;
  v120 = 0u;
  v22 = v16;
  v23 = objc_msgSend(v22, "countByEnumeratingWithState:objects:count:", &v117, v122, 16);
  if (v23)
  {
    v24 = v23;
    v25 = *(_QWORD *)v118;
    do
    {
      for (j = 0; j != v24; j = (char *)j + 1)
      {
        if (*(_QWORD *)v118 != v25)
          objc_enumerationMutation(v22);
        v27 = (id *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v117 + 1) + 8 * (_QWORD)j)));
        v28 = (void *)sub_1001324D0(v27);
        objc_msgSend(v21, "appendFormat:", CFSTR("\t%@\n"), v28);

      }
      v24 = objc_msgSend(v22, "countByEnumeratingWithState:objects:count:", &v117, v122, 16);
    }
    while (v24);
  }

  if (qword_1001E4A48)
  {
    objc_msgSend(v21, "appendFormat:", CFSTR("\n--------- NRD Device Identity ---------"));
    v29 = sub_10012B324((_QWORD *)qword_1001E4A48);
    LogString = (void *)_NRKeyCreateLogString(v29);
    objc_msgSend(v21, "appendFormat:", CFSTR("\nPublic Key: %@\n"), LogString);

  }
  objc_msgSend(v13, "appendFormat:", CFSTR("\n\n%@"), v21);

  objc_msgSend(v13, "appendFormat:", CFSTR("\n--------- Director status ---------"));
  objc_msgSend(v13, "appendFormat:", CFSTR("\nName: %@"), CFSTR("Link Director"));
  if (*((_BYTE *)v110 + 12))
    v31 = "YES";
  else
    v31 = "NO";
  objc_msgSend(v13, "appendFormat:", CFSTR("\nEnabled: %s"), v31);
  if (*((_BYTE *)v110 + 8))
    v32 = "YES";
  else
    v32 = "NO";
  objc_msgSend(v13, "appendFormat:", CFSTR("\nFixed Interface mode: %s"), v32);
  if (v110[6] == -1)
    v33 = "NO";
  else
    v33 = "YES";
  objc_msgSend(v13, "appendFormat:", CFSTR("\nThermal watcher registered: %s"), v33);
  StringFromThermalPressureLevel = (void *)createStringFromThermalPressureLevel(v110[5]);
  objc_msgSend(v13, "appendFormat:", CFSTR("\nThermal Pressure: %@"), StringFromThermalPressureLevel);

  objc_msgSend(v13, "appendFormat:", CFSTR("\nSOCKS port: %u"), 62742);
  objc_msgSend(v13, "appendFormat:", CFSTR("\nSOCKS server: %@"), *((_QWORD *)v110 + 16));
  port = *((_QWORD *)v110 + 17);
  if (port)
    port = nw_masque_server_get_port();
  objc_msgSend(v13, "appendFormat:", CFSTR("\nMASQUE port: %u"), port);
  objc_msgSend(v13, "appendFormat:", CFSTR("\nMASQUE server: %@"), *((_QWORD *)v110 + 17));
  v36 = objc_alloc_init((Class)NSMutableDictionary);
  sub_1000AABF8(v36);
  v106 = v36;
  objc_msgSend(v13, "appendFormat:", CFSTR("\nFD Usage: %@"), v36);
  v116 = 0;
  v37 = *((id *)v110 + 16);
  if (v37)
  {
    v38 = v37;
    v39 = nw_shoes_server_fillout_statistics(*((_QWORD *)v110 + 16), &v116, 8, 0);

    if (v39)
      objc_msgSend(v13, "appendFormat:", CFSTR("\nSOCKS Server Connections total: %u max simultaneous: %u"), HIDWORD(v116), v116);
  }
  objc_opt_self(NRDKeyManager);
  if (qword_1001E4AD8 != -1)
    dispatch_once(&qword_1001E4AD8, &stru_1001B8968);
  v40 = (id)qword_1001E4AD0;
  v41 = (unsigned __int8 *)v40;
  if (v40)
  {
    dispatch_assert_queue_V2(*((dispatch_queue_t *)v40 + 2));
    sub_10014A420((uint64_t)v41);
    v42 = objc_alloc((Class)NSString);
    String = (void *)NRDataProtectionClassCreateString(v41[8]);
    v44 = objc_msgSend(v42, "initWithFormat:", CFSTR("Unlocked data protection: %@"), String);

  }
  else
  {
    v44 = 0;
  }
  objc_msgSend(v13, "appendFormat:", CFSTR("\n%@\n"), v44);

  objc_msgSend(v13, "appendFormat:", CFSTR("\n--------- Manager status ---------"));
  objc_opt_self(NRDPolicySessionManager);
  if (qword_1001E4A20 != -1)
    dispatch_once(&qword_1001E4A20, &stru_1001B8590);
  v45 = (id)qword_1001E4A18;
  v46 = v45;
  if (v45)
  {
    dispatch_assert_queue_V2(*((dispatch_queue_t *)v45 + 1));
    v47 = objc_alloc_init((Class)NSMutableString);
    objc_msgSend(v47, "appendFormat:", CFSTR("\nName: %@"), CFSTR("Policy Session Manager"));
    objc_msgSend(v47, "appendFormat:", CFSTR("\nPolicy Session: %@"), v46[2]);
    objc_msgSend(v47, "appendFormat:", CFSTR("\nInstalled policies: %@"), v46[3]);
  }
  else
  {
    v47 = 0;
  }
  objc_msgSend(v13, "appendFormat:", CFSTR("\n%@"), v47);

  v48 = objc_msgSend(*((id *)v110 + 5), "copyStatusString");
  objc_msgSend(v13, "appendFormat:", CFSTR("\n%@"), v48);

  v49 = (void *)*((_QWORD *)v110 + 6);
  if (v49)
  {
    v50 = objc_msgSend(v49, "copyStatusString");
    objc_msgSend(v13, "appendFormat:", CFSTR("\n%@\n"), v50);

  }
  v51 = (void *)*((_QWORD *)v110 + 21);
  if (v51)
  {
    v52 = objc_msgSend(v51, "copyStatusString");
    objc_msgSend(v13, "appendFormat:", CFSTR("\n%@\n"), v52);

  }
  v53 = (void *)*((_QWORD *)v110 + 8);
  if (v53)
  {
    v54 = objc_msgSend(v53, "copyStatusString");
    objc_msgSend(v13, "appendFormat:", CFSTR("\n%@\n"), v54);

  }
  v55 = *((_QWORD *)v110 + 22);
  if (v55)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v55 + 32));
    v56 = objc_alloc_init((Class)NSMutableString);
    objc_msgSend(v56, "appendFormat:", CFSTR("\nName: %@"), CFSTR("Link Manager - On-demand link setup"));
    if (*(_BYTE *)(v55 + 8))
      v57 = "YES";
    else
      v57 = "NO";
    objc_msgSend(v56, "appendFormat:", CFSTR("\nstarted: %s"), v57);
    if (*(_BYTE *)(v55 + 9))
      v58 = "YES";
    else
      v58 = "NO";
    objc_msgSend(v56, "appendFormat:", CFSTR("\ncancelled: %s"), v58);
    if (*(_BYTE *)(v55 + 10))
      v59 = "YES";
    else
      v59 = "NO";
    objc_msgSend(v56, "appendFormat:", CFSTR("\nsubscribed for PHS updates: %s"), v59);
    if (*(_BYTE *)(v55 + 11))
      v60 = "YES";
    else
      v60 = "NO";
    objc_msgSend(v56, "appendFormat:", CFSTR("\nPHS active: %s"), v60);
    if (*(_BYTE *)(v55 + 12))
      v61 = "YES";
    else
      v61 = "NO";
    objc_msgSend(v56, "appendFormat:", CFSTR("\nLLPHS active: %s"), v61);
    if (*(_BYTE *)(v55 + 13))
      v62 = "YES";
    else
      v62 = "NO";
    objc_msgSend(v56, "appendFormat:", CFSTR("\nPHS provider: %s"), v62);
    if (*(_BYTE *)(v55 + 14))
      v63 = "YES";
    else
      v63 = "NO";
    objc_msgSend(v56, "appendFormat:", CFSTR("\nPHS client: %s"), v63);
    if (*(_BYTE *)(v55 + 15))
      v64 = "YES";
    else
      v64 = "NO";
    objc_msgSend(v56, "appendFormat:", CFSTR("\ncellular slicing: %s"), v64);
    objc_msgSend(v56, "appendFormat:", CFSTR("\nInternet relay valid peers: %@"), *(_QWORD *)(v55 + 88));
    objc_msgSend(v13, "appendFormat:", CFSTR("\n%@\n"), v56);

  }
  objc_opt_self(NRApplicationServiceManager);
  if (qword_1001E47D8 != -1)
    dispatch_once(&qword_1001E47D8, &stru_1001B7770);
  v65 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)qword_1001E47D0, "description"));
  objc_msgSend(v13, "appendFormat:", CFSTR("\n%@\n"), v65);

  objc_opt_self(NRIKEv2Listener);
  if (qword_1001E44D8 != -1)
    dispatch_once(&qword_1001E44D8, &stru_1001B5E70);
  v66 = (id)qword_1001E44D0;
  if (v66)
  {
    v67 = objc_alloc_init((Class)NSMutableString);
    objc_msgSend(v67, "appendFormat:", CFSTR("\n---- NRIKEv2Listener ----"));
    objc_msgSend(v67, "appendFormat:", CFSTR("\nIKEv2 Listener: %@"), v66[2]);
    objc_msgSend(v67, "appendFormat:", CFSTR("\nRegistered links: %@"), v66[3]);
    objc_msgSend(v67, "appendFormat:", CFSTR("\nRegistered pairing clients: %@"), v66[4]);
    objc_msgSend(v67, "appendFormat:", CFSTR("\nRegistered pairing manager: %@"), v66[5]);
    objc_msgSend(v67, "appendFormat:", CFSTR("\nPending sessions: %@"), v66[6]);
  }
  else
  {
    v67 = 0;
  }
  objc_msgSend(v13, "appendFormat:", CFSTR("\n%@\n"), v67);

  objc_msgSend(v13, "appendFormat:", CFSTR("\nOrphaned Device Monitor Connections: %@\n"), *((_QWORD *)v110 + 26));
  objc_msgSend(v13, "appendFormat:", CFSTR("\nOrphaned Device Preferences Connections: %@\n"), *((_QWORD *)v110 + 27));
  objc_msgSend(v13, "appendFormat:", CFSTR("\nEphemeral Device Connections: %@\n"), *((_QWORD *)v110 + 28));
  v114 = 0u;
  v115 = 0u;
  v112 = 0u;
  v113 = 0u;
  obj = *((id *)v110 + 25);
  v111 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v112, v121, 16);
  if (v111)
  {
    v108 = v13;
    v109 = *(_QWORD *)v113;
    do
    {
      for (k = 0; k != v111; k = (char *)k + 1)
      {
        if (*(_QWORD *)v113 != v109)
          objc_enumerationMutation(obj);
        v69 = objc_claimAutoreleasedReturnValue(objc_msgSend(*((id *)v110 + 25), "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v112 + 1) + 8 * (_QWORD)k)));
        v70 = v69;
        if (v69)
        {
          dispatch_assert_queue_V2(*(dispatch_queue_t *)(v69 + 104));
          v71 = objc_alloc((Class)NSMutableString);
          v72 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v70 + 96), "UUIDString"));
          v73 = objc_msgSend(v71, "initWithFormat:", CFSTR("--------- Conductor %@ status ---------"), v72);

          objc_msgSend(v73, "appendFormat:", CFSTR("\nPrimary Link: %@"), *(_QWORD *)(v70 + 128));
          objc_msgSend(v73, "appendFormat:", CFSTR("\nLinks: %@"), *(_QWORD *)(v70 + 112));
          v74 = *(_QWORD *)(v70 + 448);
          if (v74)
            v75 = (__CFString *)NEVirtualInterfaceCopyName(v74);
          else
            v75 = CFSTR("<nil>");
          objc_msgSend(v73, "appendFormat:", CFSTR("\nCatch-All Interface: %@"), v75);
          if (*(_BYTE *)(v70 + 23))
            v76 = "YES";
          else
            v76 = "NO";
          objc_msgSend(v73, "appendFormat:", CFSTR("\nDisable Range Extension: %s"), v76);
          if (*(_BYTE *)(v70 + 24))
            v77 = "YES";
          else
            v77 = "NO";
          objc_msgSend(v73, "appendFormat:", CFSTR("\nDisable Prefer Wi-Fi: %s"), v77);
          objc_msgSend(v73, "appendFormat:", CFSTR("\nPending requests: %@"), *(_QWORD *)(v70 + 120));
          if (*(_BYTE *)(v70 + 15))
            v78 = "YES";
          else
            v78 = "NO";
          objc_msgSend(v73, "appendFormat:", CFSTR("\nPrefer Wi-Fi request: %s"), v78);
          v79 = "Connected";
          if (!*(_BYTE *)(v70 + 32))
            v79 = "NOT connected";
          objc_msgSend(v73, "appendFormat:", CFSTR("\nAPS connection status: %s"), v79);
          if (*(_BYTE *)(v70 + 31))
            v80 = "YES";
          else
            v80 = "NO";
          objc_msgSend(v73, "appendFormat:", CFSTR("\nHas quick relay request: %s"), v80);
          if (*(_BYTE *)(v70 + 17))
            v81 = "YES";
          else
            v81 = "NO";
          objc_msgSend(v73, "appendFormat:", CFSTR("\nDevice setup in progress: %s"), v81);
          if ((*(_BYTE *)(v70 + 11) & 1) != 0)
            v82 = "YES";
          else
            v82 = "NO";
          objc_msgSend(v73, "appendFormat:", CFSTR("\nPerpetual standalone Meadow mode: %s"), v82);
          if (*(_BYTE *)(v70 + 30))
            v83 = "YES";
          else
            v83 = "NO";
          objc_msgSend(v73, "appendFormat:", CFSTR("\nHas phone call relay request: %s"), v83);
          if (sub_1000D7F4C(v70))
            v84 = "YES";
          else
            v84 = "NO";
          objc_msgSend(v73, "appendFormat:", CFSTR("\nAlways On Wi-Fi supported by peer: %s"), v84);
          objc_msgSend(v73, "appendFormat:", CFSTR("\nLast sent WiFi endpoint: %@"), *(_QWORD *)(v70 + 136));
          objc_msgSend(v73, "appendFormat:", CFSTR("\nLast sent WiFi signature: %@"), *(_QWORD *)(v70 + 144));
          if (*(_BYTE *)(v70 + 38))
            v85 = "YES";
          else
            v85 = "NO";
          objc_msgSend(v73, "appendFormat:", CFSTR("\nPermitted clients policies added: %s"), v85);
          if (*(_BYTE *)(v70 + 10))
            v86 = "YES";
          else
            v86 = "NO";
          objc_msgSend(v73, "appendFormat:", CFSTR("\nAWDL supported: %s"), v86);
          objc_msgSend(v73, "appendFormat:", CFSTR("\nDevice monitor(s): %@"), *(_QWORD *)(v70 + 168));
          objc_msgSend(v73, "appendFormat:", CFSTR("\nDevice Preferences Manager(s): %@"), *(_QWORD *)(v70 + 184));
          if (*(_BYTE *)(v70 + 42))
            v87 = "YES";
          else
            v87 = "NO";
          objc_msgSend(v73, "appendFormat:", CFSTR("\nBuffer limits set: %s"), v87);
          objc_opt_self(NRLinkDirectorMessageManager);
          if (qword_1001E45A0 != -1)
            dispatch_once(&qword_1001E45A0, &stru_1001B6438);
          v88 = (id)qword_1001E4598;
          objc_msgSend(v73, "appendFormat:", CFSTR("\nNRLinkDirectorMessage Manager: %@"), v88);

          objc_msgSend(v73, "appendFormat:", CFSTR("\nALU Monitor: %@"), *(_QWORD *)(v70 + 584));
          objc_msgSend(v73, "appendFormat:", CFSTR("\nAS Client: %@"), *(_QWORD *)(v70 + 632));
          if (*(_BYTE *)(v70 + 49))
            v89 = "YES";
          else
            v89 = "NO";
          objc_msgSend(v73, "appendFormat:", CFSTR("\nMonitoring LS: %s"), v89);
          v90 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v70 + 96), "UUIDString"));
          objc_msgSend(v73, "appendFormat:", CFSTR("\n\n--------- Links to %@ status ---------"), v90);

          v119 = 0u;
          v120 = 0u;
          v117 = 0u;
          v118 = 0u;
          v91 = *(id *)(v70 + 112);
          v92 = objc_msgSend(v91, "countByEnumeratingWithState:objects:count:", &v117, v122, 16);
          if (v92)
          {
            v93 = v92;
            v94 = *(_QWORD *)v118;
            do
            {
              for (m = 0; m != v93; m = (char *)m + 1)
              {
                if (*(_QWORD *)v118 != v94)
                  objc_enumerationMutation(v91);
                v96 = objc_msgSend(*(id *)(*((_QWORD *)&v117 + 1) + 8 * (_QWORD)m), "copyStatusString");
                objc_msgSend(v73, "appendFormat:", CFSTR("\n%@"), v96);

              }
              v93 = objc_msgSend(v91, "countByEnumeratingWithState:objects:count:", &v117, v122, 16);
            }
            while (v93);
          }

          v13 = v108;
        }
        else
        {
          v73 = 0;
        }
        objc_msgSend(v13, "appendFormat:", CFSTR("\n\n%@"), v73);

      }
      v111 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v112, v121, 16);
    }
    while (v111);
  }

  if (qword_1001E4738 != -1)
    dispatch_once(&qword_1001E4738, &stru_1001B7110);
  if (_NRLogIsLevelEnabled(qword_1001E4730, 2))
  {
    if (qword_1001E4738 != -1)
      dispatch_once(&qword_1001E4738, &stru_1001B7110);
    v97 = (id)qword_1001E4730;
    _NRLogWithArgs(v97, 2, "%s%.30s:%-4d Director created status string %llu characters long", "", "-[NRLinkDirector copyStatusString]", 710, objc_msgSend(v13, "length"));

  }
  if (v13)
  {
    if (qword_1001E46F0 != -1)
      dispatch_once(&qword_1001E46F0, &stru_1001B6E08);
    v98 = (id)qword_1001E46E8;
    if (v98)
    {
      v99 = objc_alloc((Class)NSString);
      if (sub_10009FF34((uint64_t)v99))
        v100 = "en";
      else
        v100 = "dis";
      v101 = objc_msgSend(v99, "initWithFormat:", CFSTR("\tCompanion link is currently %sabled on this device"), v100);
      v102 = objc_alloc((Class)NSString);
      if (gNRPacketLoggingEnabled)
        v103 = "en";
      else
        v103 = "dis";
      v104 = objc_msgSend(v102, "initWithFormat:", CFSTR("%@, packet logging %sabled\n%@\n%@"), v98, v103, v101, v13);

    }
    else
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      if (_NRLogIsLevelEnabled(qword_1001E4608, 17))
      {
        if (qword_1001E4610 != -1)
          dispatch_once(&qword_1001E4610, &stru_1001B6788);
        _NRLogWithArgs(qword_1001E4608, 17, "Failed to copy terminusd status");
      }
      v104 = 0;
    }

  }
  else
  {
LABEL_160:
    if (qword_1001E4610 != -1)
      dispatch_once(&qword_1001E4610, &stru_1001B6788);
    if (_NRLogIsLevelEnabled(qword_1001E4608, 17))
    {
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      _NRLogWithArgs(qword_1001E4608, 17, "Failed to copy status string from LinkDirector");
    }
    v13 = 0;
    v104 = 0;
  }

  return v104;
}

id sub_10005A754(void *a1)
{
  id v1;
  void *v2;
  id v3;
  void *v4;
  void *v5;
  void *v6;
  id v7;
  id v8;
  id v9;
  char v10;
  uint64_t v11;
  void *v12;
  id v13;
  id v14;
  int v15;
  id v16;
  id v17;
  int v18;
  id v19;
  int v20;
  id v21;
  int IsLevelEnabled;
  id v24;
  char v25;
  id v26;

  v1 = a1;
  v2 = v1;
  if (v1)
  {
    if (objc_msgSend(v1, "length"))
    {
      v3 = sub_1000594C8();
      v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
      if (!v4)
      {
        if (qword_1001E4610 != -1)
          dispatch_once(&qword_1001E4610, &stru_1001B6788);
        if (_NRLogIsLevelEnabled(qword_1001E4608, 17))
        {
          if (qword_1001E4610 != -1)
            dispatch_once(&qword_1001E4610, &stru_1001B6788);
          _NRLogWithArgs(qword_1001E4608, 17, "Companion link status is empty failed");
          v12 = 0;
        }
        else
        {
          v12 = 0;
        }
        goto LABEL_69;
      }
      v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](NSFileManager, "defaultManager"));
      v25 = 0;
      if (!objc_msgSend(v5, "fileExistsAtPath:isDirectory:", v2, &v25) || !v25)
      {
        if (qword_1001E4610 != -1)
          dispatch_once(&qword_1001E4610, &stru_1001B6788);
        if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
        {
          if (qword_1001E4610 != -1)
            dispatch_once(&qword_1001E4610, &stru_1001B6788);
          _NRLogWithArgs(qword_1001E4608, 0, "%s%.30s:%-4d Creating temporary directory at \"%@\"", "", "dumpLinkStatusToDirectoryAt", 262, v2);
        }
        v24 = 0;
        objc_msgSend(v5, "createDirectoryAtPath:withIntermediateDirectories:attributes:error:", v2, 1, 0, &v24);
        v13 = v24;
        if (v13)
        {
          v7 = v13;
          if (qword_1001E4610 != -1)
            dispatch_once(&qword_1001E4610, &stru_1001B6788);
          if (_NRLogIsLevelEnabled(qword_1001E4608, 16))
          {
            if (qword_1001E4610 != -1)
              dispatch_once(&qword_1001E4610, &stru_1001B6788);
            _NRLogWithArgs(qword_1001E4608, 16, "%s%.30s:%-4d Failed to create directory at \"%@\": %@", "", "dumpLinkStatusToDirectoryAt", 269, v2, v7);
          }
          goto LABEL_67;
        }
        if (qword_1001E4610 != -1)
          dispatch_once(&qword_1001E4610, &stru_1001B6788);
        if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
        {
          if (qword_1001E4610 != -1)
            dispatch_once(&qword_1001E4610, &stru_1001B6788);
          _NRLogWithArgs(qword_1001E4608, 0, "%s%.30s:%-4d Created temporary directory at \"%@\"", "", "dumpLinkStatusToDirectoryAt", 272, v2);
        }
      }
      v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "stringByAppendingPathComponent:", CFSTR("companion_link_status_phone.txt")));
      if (qword_1001E4610 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
      {
        if (qword_1001E4610 != -1)
          dispatch_once(&qword_1001E4610, &stru_1001B6788);
        _NRLogWithArgs(qword_1001E4608, 0, "%s%.30s:%-4d Writing companion link status to \"%@\"", "", "dumpLinkStatusToDirectoryAt", 279, v6);
      }
      v7 = v6;
      v8 = v4;
      if (v7)
      {
        if (objc_msgSend(v7, "length"))
        {
          v9 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "dataUsingEncoding:", 4));
          v10 = sub_100107290(v7, v9, 0);
          goto LABEL_15;
        }
        v21 = sub_100106E24();
        IsLevelEnabled = _NRLogIsLevelEnabled(v21, 17);

        if (IsLevelEnabled)
        {
          v9 = sub_100106E24();
          _NRLogWithArgs(v9, 17, "%s called with null filePath.length");
          goto LABEL_59;
        }
      }
      else
      {
        v19 = sub_100106E24();
        v20 = _NRLogIsLevelEnabled(v19, 17);

        if (v20)
        {
          v9 = sub_100106E24();
          _NRLogWithArgs(v9, 17, "%s called with null filePath");
LABEL_59:
          v10 = 0;
LABEL_15:

          v11 = qword_1001E4610;
          if ((v10 & 1) != 0)
          {
            if (qword_1001E4610 != -1)
              dispatch_once(&qword_1001E4610, &stru_1001B6788);
            if (_NRLogIsLevelEnabled(qword_1001E4608, 0))
            {
              if (qword_1001E4610 != -1)
                dispatch_once(&qword_1001E4610, &stru_1001B6788);
              _NRLogWithArgs(qword_1001E4608, 0, "%s%.30s:%-4d Wrote companion link status to \"%@\"", "", "dumpLinkStatusToDirectoryAt", 286, v7);
            }
            v26 = v7;
            v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v26, 1));
            goto LABEL_68;
          }
          goto LABEL_61;
        }
      }

      v11 = qword_1001E4610;
LABEL_61:
      if (v11 != -1)
        dispatch_once(&qword_1001E4610, &stru_1001B6788);
      if (_NRLogIsLevelEnabled(qword_1001E4608, 16))
      {
        if (qword_1001E4610 != -1)
          dispatch_once(&qword_1001E4610, &stru_1001B6788);
        _NRLogWithArgs(qword_1001E4608, 16, "%s%.30s:%-4d Failed to write companion link status to \"%@\"", "", "dumpLinkStatusToDirectoryAt", 283, v7);
      }
LABEL_67:
      v12 = 0;
LABEL_68:

LABEL_69:
      goto LABEL_70;
    }
    v17 = sub_100045324();
    v18 = _NRLogIsLevelEnabled(v17, 17);

    if (v18)
    {
      v16 = sub_100045324();
      _NRLogWithArgs(v16, 17, "%s called with null directoryPath.length");
      goto LABEL_53;
    }
  }
  else
  {
    v14 = sub_100045324();
    v15 = _NRLogIsLevelEnabled(v14, 17);

    if (v15)
    {
      v16 = sub_100045324();
      _NRLogWithArgs(v16, 17, "%s called with null directoryPath");
LABEL_53:

    }
  }
  v12 = 0;
LABEL_70:

  return v12;
}

double sub_10005ADB8(uint64_t a1, uint64_t a2)
{
  double result;

  *(_QWORD *)&result = 136446722;
  *(_DWORD *)a1 = 136446722;
  *(_QWORD *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 2048;
  *(_QWORD *)(a1 + 14) = 0;
  *(_WORD *)(a1 + 22) = 1024;
  *(_DWORD *)(a1 + 24) = 0;
  return result;
}

void sub_10005AF5C(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001E4618;
  qword_1001E4618 = (uint64_t)v1;

}

char *sub_10005AF8C(id *a1, void *a2)
{
  id v4;
  void *v5;
  id *v6;
  id *v7;
  id v8;
  id v9;
  id v10;
  id v11;
  id *v12;
  const char *v13;
  id v15;
  int IsLevelEnabled;
  id v17;
  int *v18;
  uint64_t v19;
  id v20;
  uint64_t v21;
  objc_super v22;

  v4 = a2;
  v5 = v4;
  if (!a1)
  {
LABEL_10:
    v12 = 0;
    goto LABEL_11;
  }
  if ((_NRIsAppleInternal(v4) & 1) == 0)
  {
    v13 = (const char *)&OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
    if (qword_1001E4620 == -1)
      goto LABEL_6;
    goto LABEL_15;
  }
  v22.receiver = a1;
  v22.super_class = (Class)NRDTestServer;
  v6 = (id *)objc_msgSendSuper2(&v22, "init");
  if (!v6)
  {
    v15 = sub_10005B1D8();
    IsLevelEnabled = _NRLogIsLevelEnabled(v15, 16);

    v13 = "-[NRDTestServer initTestServerWithQueue:]";
    if (IsLevelEnabled)
    {
      v17 = sub_10005B1D8();
      _NRLogWithArgs(v17, 16, "%s%.30s:%-4d ABORTING: [super init] failed", "", "-[NRDTestServer initTestServerWithQueue:]", 224);

    }
    v5 = (void *)_os_log_pack_size(12);
    a1 = (id *)((char *)&v21 - ((__chkstk_darwin(v5) + 15) & 0xFFFFFFFFFFFFFFF0));
    v18 = __error();
    v19 = _os_log_pack_fill(a1, v5, *v18, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)v19 = 136446210;
    *(_QWORD *)(v19 + 4) = "-[NRDTestServer initTestServerWithQueue:]";
    v20 = sub_10005B1D8();
    _NRLogAbortWithPack(v20, a1);
LABEL_15:
    dispatch_once(&qword_1001E4620, &stru_1001B6910);
LABEL_6:
    if (_NRLogIsLevelEnabled(qword_1001E4618, 17))
    {
      if (*((_QWORD *)v13 + 196) != -1)
        dispatch_once(&qword_1001E4620, &stru_1001B6910);
      _NRLogWithArgs(qword_1001E4618, 17, "Unsupported");
    }
    goto LABEL_10;
  }
  v7 = v6;
  objc_storeStrong(v6 + 2, a2);
  v8 = objc_alloc_init((Class)NSMutableDictionary);
  v9 = v7[5];
  v7[5] = v8;

  v10 = objc_alloc_init((Class)NSMutableDictionary);
  v11 = v7[8];
  v7[8] = v10;

  sub_10005B218((dispatch_source_t *)v7 + 6, v7[2], 0x464Fu);
  sub_10005B218((dispatch_source_t *)v7 + 7, v7[2], 0x4A37u);
  a1 = v7;
  v12 = a1;
LABEL_11:

  return (char *)v12;
}

id sub_10005B1D8()
{
  if (qword_1001E4620 != -1)
    dispatch_once(&qword_1001E4620, &stru_1001B6910);
  return (id)qword_1001E4618;
}

void sub_10005B218(dispatch_source_t *a1, void *a2, unsigned int a3)
{
  NSObject *v5;
  dispatch_source_t v6;
  int v7;
  unsigned int v8;
  int v9;
  int *v10;
  int *v11;
  int *v12;
  dispatch_source_t v13;
  int *v14;
  id v15;
  int *v16;
  id v17;
  int IsLevelEnabled;
  int *v19;
  id v20;
  int v21;
  int *v22;
  id v23;
  int v24;
  int *v25;
  id v26;
  int v27;
  id v28;
  int v29;
  id v30;
  int *v31;
  id v32;
  int v33;
  dispatch_source_t v34;
  dispatch_source_t v35;
  NSObject *v36;
  NSObject *v37;
  id v38;
  int v39;
  id v40;
  _QWORD v41[4];
  unsigned int v42;
  _QWORD handler[4];
  unsigned int v44;
  _BYTE v45[20];
  uint64_t v46;
  char __strerrbuf[128];

  v5 = a2;
  if (a1)
  {
    if (*a1)
    {
      dispatch_source_cancel(*a1);
      v6 = *a1;
      *a1 = 0;

    }
    v7 = socket(30, 2, 0);
    if ((v7 & 0x80000000) == 0)
    {
      v8 = v7;
      v9 = fcntl(v7, 3, 0);
      if (v9 < 0)
      {
        v11 = __error();
        if (strerror_r(*v11, __strerrbuf, 0x80uLL))
          __strerrbuf[0] = 0;
        if (qword_1001E4620 != -1)
          dispatch_once(&qword_1001E4620, &stru_1001B6910);
        if (_NRLogIsLevelEnabled(qword_1001E4618, 17))
        {
          if (qword_1001E4620 != -1)
            dispatch_once(&qword_1001E4620, &stru_1001B6910);
          _NRLogWithArgs(qword_1001E4618, 17, "fcntl(%d, F_GETFL, 0): [%d] %s");
        }
        goto LABEL_38;
      }
      if (fcntl(v8, 4, v9 | 4u))
      {
        v10 = __error();
        if (strerror_r(*v10, __strerrbuf, 0x80uLL))
          __strerrbuf[0] = 0;
        if (qword_1001E4620 != -1)
          dispatch_once(&qword_1001E4620, &stru_1001B6910);
        if (_NRLogIsLevelEnabled(qword_1001E4618, 17))
        {
          if (qword_1001E4620 != -1)
            dispatch_once(&qword_1001E4620, &stru_1001B6910);
          _NRLogWithArgs(qword_1001E4618, 17, "fcntl(%d, F_SETFL, %d): [%d] %s");
        }
        goto LABEL_38;
      }
      if (setsockopt(v8, 0xFFFF, 4, &unk_10015CFE0, 4u))
      {
        v12 = __error();
        if (strerror_r(*v12, __strerrbuf, 0x80uLL))
          __strerrbuf[0] = 0;
        if (qword_1001E4620 != -1)
          dispatch_once(&qword_1001E4620, &stru_1001B6910);
        if (_NRLogIsLevelEnabled(qword_1001E4618, 17))
        {
          if (qword_1001E4620 != -1)
            dispatch_once(&qword_1001E4620, &stru_1001B6910);
          _NRLogWithArgs(qword_1001E4618, 17, "SO_REUSEADDR failed: [%d] %s");
        }
        goto LABEL_38;
      }
      if (setsockopt(v8, 0xFFFF, 512, &unk_10015CFE0, 4u))
      {
        v14 = __error();
        if (strerror_r(*v14, __strerrbuf, 0x80uLL))
          __strerrbuf[0] = 0;
        if (qword_1001E4620 != -1)
          dispatch_once(&qword_1001E4620, &stru_1001B6910);
        if (!_NRLogIsLevelEnabled(qword_1001E4618, 17))
          goto LABEL_38;
        v15 = sub_10005B1D8();
        _NRLogWithArgs(v15, 17, "SO_REUSEPORT failed: [%d] %s");
      }
      else if (setsockopt(v8, 0xFFFF, 4356, &unk_10015CFE0, 4u))
      {
        v16 = __error();
        if (strerror_r(*v16, __strerrbuf, 0x80uLL))
          __strerrbuf[0] = 0;
        v17 = sub_10005B1D8();
        IsLevelEnabled = _NRLogIsLevelEnabled(v17, 17);

        if (!IsLevelEnabled)
          goto LABEL_38;
        v15 = sub_10005B1D8();
        _NRLogWithArgs(v15, 17, "SO_RECV_ANYIF failed: [%d] %s");
      }
      else if (setsockopt(v8, 41, 27, &unk_10015CFE0, 4u))
      {
        v19 = __error();
        if (strerror_r(*v19, __strerrbuf, 0x80uLL))
          __strerrbuf[0] = 0;
        v20 = sub_10005B1D8();
        v21 = _NRLogIsLevelEnabled(v20, 17);

        if (!v21)
          goto LABEL_38;
        v15 = sub_10005B1D8();
        _NRLogWithArgs(v15, 17, "IPV6_V6ONLY failed: [%d] %s");
      }
      else if (setsockopt(v8, 0xFFFF, 4130, &unk_10015CFE0, 4u))
      {
        v22 = __error();
        if (strerror_r(*v22, __strerrbuf, 0x80uLL))
          __strerrbuf[0] = 0;
        v23 = sub_10005B1D8();
        v24 = _NRLogIsLevelEnabled(v23, 17);

        if (!v24)
          goto LABEL_38;
        v15 = sub_10005B1D8();
        _NRLogWithArgs(v15, 17, "SO_NOSIGPIPE failed: [%d] %s");
      }
      else if (setsockopt(v8, 41, 61, &unk_10015CFE0, 4u))
      {
        v25 = __error();
        if (strerror_r(*v25, __strerrbuf, 0x80uLL))
          __strerrbuf[0] = 0;
        v26 = sub_10005B1D8();
        v27 = _NRLogIsLevelEnabled(v26, 17);

        if (!v27)
          goto LABEL_38;
        v15 = sub_10005B1D8();
        _NRLogWithArgs(v15, 17, "IPV6_RECVPKTINFO failed: [%d] %s");
      }
      else
      {
        *(_QWORD *)&v45[4] = 0;
        *(_QWORD *)&v45[12] = 0;
        v46 = 0;
        *(_WORD *)v45 = 7708;
        *(_WORD *)&v45[2] = __rev16(a3);
        if (!bind(v8, (const sockaddr *)v45, 0x1Cu))
        {
          v34 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, v8, 0, v5);
          v35 = *a1;
          *a1 = v34;

          v36 = *a1;
          if (*a1)
          {
            handler[0] = _NSConcreteStackBlock;
            handler[1] = 3221225472;
            handler[2] = sub_10005B9A8;
            handler[3] = &unk_1001B6930;
            v44 = v8;
            dispatch_source_set_event_handler(v36, handler);
            v37 = *a1;
            v41[0] = _NSConcreteStackBlock;
            v41[1] = 3221225472;
            v41[2] = sub_10005C000;
            v41[3] = &unk_1001B6930;
            v42 = v8;
            dispatch_source_set_cancel_handler(v37, v41);
            dispatch_activate(*a1);
            goto LABEL_41;
          }
          v38 = sub_10005B1D8();
          v39 = _NRLogIsLevelEnabled(v38, 17);

          if (v39)
          {
            v40 = sub_10005B1D8();
            _NRLogWithArgs(v40, 17, "dispatch_source_create failed");

          }
          goto LABEL_38;
        }
        v31 = __error();
        if (strerror_r(*v31, __strerrbuf, 0x80uLL))
          __strerrbuf[0] = 0;
        v32 = sub_10005B1D8();
        v33 = _NRLogIsLevelEnabled(v32, 17);

        if (!v33)
        {
LABEL_38:
          if (*a1)
          {
            dispatch_source_cancel(*a1);
            v13 = *a1;
            *a1 = 0;

          }
          else
          {
            close(v8);
          }
          goto LABEL_41;
        }
        v15 = sub_10005B1D8();
        _NRLogWithArgs(v15, 17, "bind failed: [%d] %s");
      }

      goto LABEL_38;
    }
    if (qword_1001E4620 != -1)
      dispatch_once(&qword_1001E4620, &stru_1001B6910);
    if (_NRLogIsLevelEnabled(qword_1001E4618, 17))
    {
      if (qword_1001E4620 != -1)
        dispatch_once(&qword_1001E4620, &stru_1001B6910);
      _NRLogWithArgs(qword_1001E4618, 17, "socket(AF_INET6, SOCK_DGRAM, 0) failed");
    }
  }
  else
  {
    v28 = sub_10005B1D8();
    v29 = _NRLogIsLevelEnabled(v28, 17);

    if (v29)
    {
      v30 = sub_10005B1D8();
      _NRLogWithArgs(v30, 17, "%s called with null udpInputSourcePtr", "NRDTSCreateUDPListeningSocket");

    }
  }
LABEL_41:

}

int *sub_10005B9A8(uint64_t a1)
{
  ssize_t v2;
  unsigned __int8 *msg_name;
  int v4;
  int *result;
  msghdr v6;
  _QWORD v7[2];
  msghdr v8;
  _QWORD v9[2];
  _QWORD v10[3];
  int v11;
  char __strerrbuf[128];
  _BYTE v13[2000];
  _OWORD v14[2];

  while (1)
  {
    memset(v14, 0, sizeof(v14));
    memset(v10, 0, sizeof(v10));
    v11 = 0;
    v9[0] = v13;
    v9[1] = 2000;
    *(_QWORD *)&v8.msg_namelen = 28;
    *(_QWORD *)&v8.msg_iovlen = 1;
    v8.msg_name = v10;
    v8.msg_iov = (iovec *)v9;
    v8.msg_control = v14;
    *(_QWORD *)&v8.msg_controllen = 32;
    v2 = recvmsg(*(_DWORD *)(a1 + 32), &v8, 0);
    if (v2 < 0)
      break;
    if (!v2)
    {
      if (qword_1001E4620 != -1)
        dispatch_once(&qword_1001E4620, &stru_1001B6910);
      result = (int *)_NRLogIsLevelEnabled(qword_1001E4618, 16);
      if ((_DWORD)result)
      {
        if (qword_1001E4620 != -1)
          dispatch_once(&qword_1001E4620, &stru_1001B6910);
        return (int *)_NRLogWithArgs(qword_1001E4618, 16, "%s%.30s:%-4d Received empty UDP datagram");
      }
      return result;
    }
    if (v8.msg_namelen >= 0x1C && (msg_name = (unsigned __int8 *)v8.msg_name) != 0)
    {
      if (*((_BYTE *)v8.msg_name + 1) == 30)
      {
        if (*(unsigned __int8 *)v8.msg_name > 0x1Bu)
        {
          if (v8.msg_controllen - 33 >= 0xFFFFFFF3 && v8.msg_control == v14)
          {
            if (DWORD2(v14[0]) == 46)
            {
              v7[0] = v13;
              v7[1] = v2;
              *(_QWORD *)&v6.msg_controllen = 0;
              memset(&v6.msg_namelen, 0, 32);
              v6.msg_name = v8.msg_name;
              v6.msg_namelen = *(unsigned __int8 *)v8.msg_name;
              v6.msg_iov = (iovec *)v7;
              v6.msg_iovlen = 1;
              v6.msg_control = v14;
              v6.msg_controllen = 32;
              if (sendmsg(*(_DWORD *)(a1 + 32), &v6, 0) <= 0)
              {
                v4 = *__error();
                if (strerror_r(v4, __strerrbuf, 0x80uLL))
                  __strerrbuf[0] = 0;
                if (qword_1001E4620 != -1)
                  dispatch_once(&qword_1001E4620, &stru_1001B6910);
                if (_NRLogIsLevelEnabled(qword_1001E4618, 17))
                {
                  if (qword_1001E4620 != -1)
                    dispatch_once(&qword_1001E4620, &stru_1001B6910);
                  _NRLogWithArgs(qword_1001E4618, 17, "sendmsg failed: [%d] %s", v4, __strerrbuf);
                }
              }
            }
            else
            {
              if (qword_1001E4620 != -1)
                dispatch_once(&qword_1001E4620, &stru_1001B6910);
              if (_NRLogIsLevelEnabled(qword_1001E4618, 16))
              {
                if (qword_1001E4620 != -1)
                  dispatch_once(&qword_1001E4620, &stru_1001B6910);
                _NRLogWithArgs(qword_1001E4618, 16, "%s%.30s:%-4d Invalid cmsg_type %d", "", "NRDTSCreateUDPListeningSocket_block_invoke", 162, DWORD2(v14[0]));
              }
            }
          }
          else
          {
            if (qword_1001E4620 != -1)
              dispatch_once(&qword_1001E4620, &stru_1001B6910);
            if (_NRLogIsLevelEnabled(qword_1001E4618, 16))
            {
              if (qword_1001E4620 != -1)
                dispatch_once(&qword_1001E4620, &stru_1001B6910);
              _NRLogWithArgs(qword_1001E4618, 16, "%s%.30s:%-4d missing control message %u %p %p", "", "NRDTSCreateUDPListeningSocket_block_invoke", 157, v8.msg_controllen, v8.msg_control, v14);
            }
          }
        }
        else
        {
          if (qword_1001E4620 != -1)
            dispatch_once(&qword_1001E4620, &stru_1001B6910);
          if (_NRLogIsLevelEnabled(qword_1001E4618, 16))
          {
            if (qword_1001E4620 != -1)
              dispatch_once(&qword_1001E4620, &stru_1001B6910);
            _NRLogWithArgs(qword_1001E4618, 16, "%s%.30s:%-4d packet source sin6_len too short %u < %zu", "", "NRDTSCreateUDPListeningSocket_block_invoke", 152, *msg_name, 0x1CuLL);
          }
        }
      }
      else
      {
        if (qword_1001E4620 != -1)
          dispatch_once(&qword_1001E4620, &stru_1001B6910);
        if (_NRLogIsLevelEnabled(qword_1001E4618, 16))
        {
          if (qword_1001E4620 != -1)
            dispatch_once(&qword_1001E4620, &stru_1001B6910);
          _NRLogWithArgs(qword_1001E4618, 16, "%s%.30s:%-4d packet came from wrong address family %u", "", "NRDTSCreateUDPListeningSocket_block_invoke", 148, msg_name[1]);
        }
      }
    }
    else
    {
      if (qword_1001E4620 != -1)
        dispatch_once(&qword_1001E4620, &stru_1001B6910);
      if (_NRLogIsLevelEnabled(qword_1001E4618, 16))
      {
        if (qword_1001E4620 != -1)
          dispatch_once(&qword_1001E4620, &stru_1001B6910);
        _NRLogWithArgs(qword_1001E4618, 16, "%s%.30s:%-4d missing name message %u %p", "", "NRDTSCreateUDPListeningSocket_block_invoke", 142, v8.msg_namelen, v8.msg_name);
      }
    }
  }
  result = __error();
  if (*result != 35)
  {
    if (strerror_r(*result, __strerrbuf, 0x80uLL))
      __strerrbuf[0] = 0;
    if (qword_1001E4620 != -1)
      dispatch_once(&qword_1001E4620, &stru_1001B6910);
    result = (int *)_NRLogIsLevelEnabled(qword_1001E4618, 17);
    if ((_DWORD)result)
    {
      if (qword_1001E4620 != -1)
        dispatch_once(&qword_1001E4620, &stru_1001B6910);
      return (int *)_NRLogWithArgs(qword_1001E4618, 17, "recvmsg failed: [%d] %s");
    }
  }
  return result;
}

uint64_t sub_10005C000(uint64_t a1)
{
  return close(*(_DWORD *)(a1 + 32));
}

id sub_10005C008(uint64_t a1, int a2)
{
  nw_parameters_t v4;
  id v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  id v9;
  uint64_t v10;
  uint64_t v11;
  id v12;
  _QWORD v14[4];
  id v15;
  uint64_t v16;

  v4 = nw_parameters_create();
  nw_parameters_set_required_interface_subtype(v4, 5001);
  v5 = *(id *)(a1 + 16);
  if (a2)
    v6 = 18999;
  else
    v6 = 17999;
  v7 = nw_service_connector_create(v6, v4, v5);
  v8 = (void *)objc_claimAutoreleasedReturnValue(v7);

  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  v14[2] = sub_10005C0E0;
  v14[3] = &unk_1001B6850;
  v9 = v8;
  v15 = v9;
  v16 = a1;
  nw_service_connector_set_service_available_block(v9, v14, v10, v11);
  nw_service_connector_start(v9);
  v12 = v9;

  return v12;
}

void sub_10005C0E0(uint64_t a1, void *a2, uint64_t a3)
{
  id v5;
  id v6;
  void *v7;
  id v8;
  id v9;
  _QWORD v10[5];
  id v11;
  id v12;
  id v13;
  uint64_t v14;

  v5 = a2;
  if (qword_1001E4620 != -1)
    dispatch_once(&qword_1001E4620, &stru_1001B6910);
  if (_NRLogIsLevelEnabled(qword_1001E4618, 1))
  {
    if (qword_1001E4620 != -1)
      dispatch_once(&qword_1001E4620, &stru_1001B6910);
    _NRLogWithArgs(qword_1001E4618, 1, "%s%.30s:%-4d Received service connection request: %s(%@)", "", "-[NRDTestServer createServiceConnector:]_block_invoke", 295, a3, v5);
  }
  v6 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", a3);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_10005C25C;
  v10[3] = &unk_1001B6828;
  v7 = *(void **)(a1 + 32);
  v10[4] = *(_QWORD *)(a1 + 40);
  v11 = v5;
  v14 = a3;
  v12 = v6;
  v13 = v7;
  v8 = v6;
  v9 = v5;
  nw_service_connector_start_request(v13, v9, a3, 0, v10);

}

void sub_10005C25C(_QWORD *a1, void *a2, uint64_t a3)
{
  id v5;
  void *v6;
  uint64_t v7;
  void *v8;
  void *v9;
  NSObject *v10;
  NSObject *v11;
  id v12;
  id v13;
  nw_path_t v14;
  uint64_t v15;
  uint64_t v16;
  id v17;
  char *v18;
  void *v19;
  id v20;
  id v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  char *v25;
  _QWORD *v26;
  id v27;
  id v28;
  id v29;
  NSObject *v30;
  id v31;
  NSObject *v32;
  NSObject *v33;
  id v34;
  id v35;
  id v36;
  NSObject *v37;
  NSObject *v38;
  void *v39;
  nw_path_t v40;
  id v41;
  id v42;
  NSObject *v43;
  _QWORD v44[4];
  id v45;
  id v46;
  uint64_t v47;
  id v48;
  NSObject *v49;
  NSObject *v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  _BYTE v55[128];

  v5 = a2;
  v41 = v5;
  if (a3)
  {
    if (qword_1001E4620 != -1)
      dispatch_once(&qword_1001E4620, &stru_1001B6910);
    if (_NRLogIsLevelEnabled(qword_1001E4618, 16))
    {
      if (qword_1001E4620 != -1)
        dispatch_once(&qword_1001E4620, &stru_1001B6910);
      _NRLogWithArgs(qword_1001E4618, 16, "%s%.30s:%-4d Cannot establish connection for service %s: %@", "", "-[NRDTestServer createServiceConnector:]_block_invoke_2", 301, a1[8], a3);
    }
  }
  else
  {
    v7 = a1[4];
    v6 = (void *)a1[5];
    v9 = (void *)a1[6];
    v8 = (void *)a1[7];
    v10 = v5;
    v11 = v6;
    v12 = v9;
    v13 = v8;
    if (v7)
    {
      v14 = nw_connection_copy_current_path(v10);
      v15 = nw_path_copy_interface(v14);
      v40 = v14;
      if (qword_1001E4620 != -1)
        dispatch_once(&qword_1001E4620, &stru_1001B6910);
      if (_NRLogIsLevelEnabled(qword_1001E4618, 1))
      {
        if (qword_1001E4620 != -1)
          dispatch_once(&qword_1001E4620, &stru_1001B6910);
        _NRLogWithArgs(qword_1001E4618, 1, "%s%.30s:%-4d Established connection on interface: %@ for service: %@", "", "-[NRDTestServer handleNewConnection:forPeerEndpoint:forService:forServiceConnector:]", 333, v15, v12);
      }
      objc_msgSend(*(id *)(v7 + 40), "setObject:forKeyedSubscript:", v10, v12);
      if (objc_msgSend(v12, "containsString:", CFSTR("-urgent")))
      {
        nw_connection_reset_traffic_class(v10, 700);
        v16 = 2;
      }
      else
      {
        v16 = 5;
      }
      v39 = (void *)v15;
      if (objc_msgSend(v12, "containsString:", CFSTR("-awdl")))
      {
        v38 = v10;
        v17 = objc_msgSend(objc_alloc((Class)NRCompanionLinkPreferences), "initForHighThroughputWithServiceClass:includeP2P:", v16, 1);
        v37 = v11;
        v18 = nw_endpoint_copy_address_string(v11);
        v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v18));
        if (v18)
          free(v18);
        v53 = 0u;
        v54 = 0u;
        v51 = 0u;
        v52 = 0u;
        v20 = sub_1001379CC((uint64_t)NRDLocalDevice);
        v21 = objc_msgSend(v20, "countByEnumeratingWithState:objects:count:", &v51, v55, 16);
        if (v21)
        {
          v34 = v17;
          v35 = v13;
          v36 = v12;
          v22 = *(_QWORD *)v52;
LABEL_23:
          v23 = 0;
          while (1)
          {
            if (*(_QWORD *)v52 != v22)
              objc_enumerationMutation(v20);
            v24 = *(void **)(*((_QWORD *)&v51 + 1) + 8 * v23);
            v25 = sub_10012FFF4((uint64_t)NRDLocalDevice, v24);
            v26 = sub_10013D34C(v25);
            if ((objc_msgSend(v26, "containsObject:", v19) & 1) != 0)
              break;

            if (v21 == (id)++v23)
            {
              v21 = objc_msgSend(v20, "countByEnumeratingWithState:objects:count:", &v51, v55, 16);
              if (v21)
                goto LABEL_23;
              v13 = v35;
              v12 = v36;
              v17 = v34;
              goto LABEL_35;
            }
          }
          v21 = v24;

          if (!v21)
          {
            v13 = v35;
            v12 = v36;
            v17 = v34;
            goto LABEL_37;
          }
          v20 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v7 + 64), "objectForKeyedSubscript:", v21));
          v12 = v36;
          v17 = v34;
          if (!v20)
          {
            v27 = objc_msgSend(objc_alloc((Class)NRDeviceIdentifier), "initWithUUID:", v21);
            v20 = objc_msgSend(objc_alloc((Class)NRDevicePreferences), "initWithDeviceIdentifier:", v27);

          }
          objc_msgSend(v20, "setIsNRDTestServer:", 1);
          objc_msgSend(v20, "setCompanionLinkPreferences:", v34);
          objc_msgSend(*(id *)(v7 + 64), "setObject:forKeyedSubscript:", v20, v21);
          v13 = v35;
        }
LABEL_35:

LABEL_37:
        v11 = v37;
        v10 = v38;
      }
      else
      {
        v21 = 0;
      }
      nw_connection_set_queue(v10, *(dispatch_queue_t *)(v7 + 16));
      v44[0] = _NSConcreteStackBlock;
      v44[1] = 3221225472;
      v44[2] = sub_10005C7A8;
      v44[3] = &unk_1001B6878;
      v28 = v12;
      v45 = v28;
      v46 = v21;
      v47 = v7;
      v48 = v13;
      v49 = v11;
      v29 = v13;
      v30 = v10;
      v50 = v30;
      v31 = v21;
      nw_connection_set_event_handler(v30, v44);
      v42 = v28;
      v32 = v30;
      v13 = v29;
      v33 = v32;
      v43 = v32;
      nw_connection_set_read_close_handler();
      nw_connection_start(v33);

    }
  }

}

void sub_10005C7A8(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;
  uint64_t v6;
  id v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  id v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  _QWORD v19[4];
  id v20;

  v5 = a3;
  if (qword_1001E4620 != -1)
    dispatch_once(&qword_1001E4620, &stru_1001B6910);
  if (_NRLogIsLevelEnabled(qword_1001E4618, 1))
  {
    if (qword_1001E4620 != -1)
      dispatch_once(&qword_1001E4620, &stru_1001B6910);
    v6 = *(_QWORD *)(a1 + 32);
    v7 = (id)qword_1001E4618;
    v8 = nw_connection_state_to_string(a2);
    _NRLogWithArgs(v7, 1, "%s%.30s:%-4d Connection for service %@ entered state %swith error %@", "", "-[NRDTestServer handleNewConnection:forPeerEndpoint:forService:forServiceConnector:]_block_invoke", 376, v6, v8, v5);

  }
  if ((a2 & 0xFFFFFFFE) == 4)
  {
    if (qword_1001E4620 != -1)
      dispatch_once(&qword_1001E4620, &stru_1001B6910);
    if (_NRLogIsLevelEnabled(qword_1001E4618, 1))
    {
      if (qword_1001E4620 != -1)
        dispatch_once(&qword_1001E4620, &stru_1001B6910);
      _NRLogWithArgs(qword_1001E4618, 1, "%s%.30s:%-4d Cancelling connection for key: %@", "", "-[NRDTestServer handleNewConnection:forPeerEndpoint:forService:forServiceConnector:]_block_invoke", 378, *(_QWORD *)(a1 + 32));
    }
    if (*(_QWORD *)(a1 + 40))
    {
      v9 = *(_QWORD *)(a1 + 48);
      if (v9)
        v10 = *(void **)(v9 + 64);
      else
        v10 = 0;
      v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "objectForKeyedSubscript:"));
      v12 = v11;
      if (v11)
        objc_msgSend(v11, "setCompanionLinkPreferences:", 0);

    }
    v13 = *(_QWORD *)(a1 + 56);
    v14 = *(_QWORD *)(a1 + 64);
    v15 = objc_msgSend(*(id *)(a1 + 32), "UTF8String");
    v19[0] = _NSConcreteStackBlock;
    v19[1] = 3221225472;
    v19[2] = sub_10005CB1C;
    v19[3] = &unk_1001B8AE0;
    v20 = *(id *)(a1 + 32);
    nw_service_connector_cancel_active_connection(v13, v14, v15, v19);
    v16 = *(_QWORD *)(a1 + 48);
    if (v16)
      v17 = *(void **)(v16 + 40);
    else
      v17 = 0;
    objc_msgSend(v17, "removeObjectForKey:", *(_QWORD *)(a1 + 32));

  }
  else if ((_DWORD)a2 == 3)
  {
    sub_10005CBDC(*(_QWORD *)(a1 + 48), *(void **)(a1 + 72), *(void **)(a1 + 32));
    if (objc_msgSend(*(id *)(a1 + 32), "hasPrefix:", CFSTR("Terminus download service")))
    {
      v18 = *(_QWORD *)(a1 + 48);
      if (v18)
        sub_10005CC8C(v18, 0, *(void **)(a1 + 72));
    }
  }

}

id sub_10005CA3C(uint64_t a1)
{
  uint64_t v2;
  void *v3;

  if (qword_1001E4620 != -1)
    dispatch_once(&qword_1001E4620, &stru_1001B6910);
  if (_NRLogIsLevelEnabled(qword_1001E4618, 1))
  {
    if (qword_1001E4620 != -1)
      dispatch_once(&qword_1001E4620, &stru_1001B6910);
    _NRLogWithArgs(qword_1001E4618, 1, "%s%.30s:%-4d Connection for service %@ got READ_CLOSE event", "", "-[NRDTestServer handleNewConnection:forPeerEndpoint:forService:forServiceConnector:]_block_invoke_3", 399, *(_QWORD *)(a1 + 32));
  }
  nw_connection_cancel(*(nw_connection_t *)(a1 + 40));
  v2 = *(_QWORD *)(a1 + 48);
  if (v2)
    v3 = *(void **)(v2 + 40);
  else
    v3 = 0;
  return objc_msgSend(v3, "removeObjectForKey:", *(_QWORD *)(a1 + 32));
}

uint64_t sub_10005CB1C(uint64_t a1)
{
  uint64_t result;

  if (qword_1001E4620 != -1)
    dispatch_once(&qword_1001E4620, &stru_1001B6910);
  result = _NRLogIsLevelEnabled(qword_1001E4618, 1);
  if ((_DWORD)result)
  {
    if (qword_1001E4620 != -1)
      dispatch_once(&qword_1001E4620, &stru_1001B6910);
    return _NRLogWithArgs(qword_1001E4618, 1, "%s%.30s:%-4d Cancelled connection for key: %@", "", "-[NRDTestServer handleNewConnection:forPeerEndpoint:forService:forServiceConnector:]_block_invoke_2", 387, *(_QWORD *)(a1 + 32));
  }
  return result;
}

void sub_10005CBDC(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  _QWORD completion[4];
  NSObject *v8;
  id v9;
  uint64_t v10;

  v5 = a2;
  v6 = a3;
  if (a1)
  {
    completion[0] = _NSConcreteStackBlock;
    completion[1] = 3221225472;
    completion[2] = sub_10005D008;
    completion[3] = &unk_1001B68C8;
    v8 = v5;
    v9 = v6;
    v10 = a1;
    nw_connection_receive(v8, 1u, 0xFFFFFFFF, completion);

  }
}

void sub_10005CC8C(uint64_t a1, void *a2, void *a3)
{
  dispatch_data_t v5;
  id v6;
  char *v7;
  void *v8;
  uint64_t v9;
  int8x16_t v10;
  int8x16_t v11;
  int8x16_t v12;
  int8x16_t *v13;
  id v14;
  int IsLevelEnabled;
  id v16;
  uint64_t v17;
  char *v18;
  int *v19;
  uint64_t v20;
  id v21;
  _QWORD completion[4];
  dispatch_data_t v23;
  uint64_t v24;
  NSObject *v25;

  v5 = a2;
  v6 = a3;
  if (a1)
  {
    if (!v5)
    {
      v7 = (char *)malloc_type_malloc(0x40000uLL, 0xA172743EuLL);
      if (!v7)
      {
        v14 = sub_10005B1D8();
        IsLevelEnabled = _NRLogIsLevelEnabled(v14, 16);

        if (IsLevelEnabled)
        {
          v16 = sub_10005B1D8();
          _NRLogWithArgs(v16, 16, "%s%.30s:%-4d ABORTING: strict_malloc(%zu) failed", "", "strict_malloc", 79, 0x40000uLL);

        }
        v17 = _os_log_pack_size(22);
        v18 = (char *)completion - ((__chkstk_darwin(v17) + 15) & 0xFFFFFFFFFFFFFFF0);
        v19 = __error();
        v20 = _os_log_pack_fill(v18, v17, *v19, &_mh_execute_header, "%{public}s strict_malloc(%zu) failed");
        *(_DWORD *)v20 = 136446466;
        *(_QWORD *)(v20 + 4) = "strict_malloc";
        *(_WORD *)(v20 + 12) = 2048;
        *(_QWORD *)(v20 + 14) = 0x40000;
        v21 = sub_10005B1D8();
        _NRLogAbortWithPack(v21, v18);
      }
      v8 = v7;
      v9 = 0;
      v10 = (int8x16_t)xmmword_10015D0A0;
      v11.i64[0] = 0x1010101010101010;
      v11.i64[1] = 0x1010101010101010;
      v12.i64[0] = 0x2020202020202020;
      v12.i64[1] = 0x2020202020202020;
      do
      {
        v13 = (int8x16_t *)&v7[v9];
        *v13 = v10;
        v13[1] = vaddq_s8(v10, v11);
        v9 += 32;
        v10 = vaddq_s8(v10, v12);
      }
      while (v9 != 0x40000);
      v5 = dispatch_data_create(v7, 0x40000uLL, *(dispatch_queue_t *)(a1 + 16), 0);
      free(v8);
    }
    completion[0] = _NSConcreteStackBlock;
    completion[1] = 3221225472;
    completion[2] = sub_10005CEC8;
    completion[3] = &unk_1001B68F0;
    v5 = v5;
    v23 = v5;
    v24 = a1;
    v25 = v6;
    nw_connection_send(v25, v5, _nw_content_context_default_stream, 0, completion);

  }
}

void sub_10005CEC8(_QWORD *a1, void *a2)
{
  NSObject *v3;
  NSObject *v4;
  uint64_t error_code;
  uint64_t v6;
  char __strerrbuf[128];

  v3 = a2;
  v4 = v3;
  if (v3 && (error_code = nw_error_get_error_code(v3), (_DWORD)error_code))
  {
    v6 = error_code;
    if (strerror_r(error_code, __strerrbuf, 0x80uLL))
      __strerrbuf[0] = 0;
    if (qword_1001E4620 != -1)
      dispatch_once(&qword_1001E4620, &stru_1001B6910);
    if (_NRLogIsLevelEnabled(qword_1001E4618, 16))
    {
      if (qword_1001E4620 != -1)
        dispatch_once(&qword_1001E4620, &stru_1001B6910);
      _NRLogWithArgs(qword_1001E4618, 16, "%s%.30s:%-4d Failed to write data: %@: [%d] %s", "", "-[NRDTestServer sendTokenOnConnection:connection:]_block_invoke", 498, a1[4], v6, __strerrbuf);
    }
  }
  else
  {
    sub_10005CC8C(a1[5], a1[4], a1[6]);
  }

}

void sub_10005D008(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v8;
  id v9;
  NSObject *v10;
  NSObject *v11;
  int error_code;
  NSObject *v13;
  uint64_t v14;
  size_t size;
  NSObject *v16;
  id v17;
  uint64_t v18;
  uint64_t v19;
  size_t v20;
  NSObject *v21;
  id v22;
  uint64_t v23;
  uint64_t v24;
  size_t v25;
  _QWORD v26[4];
  dispatch_data_t v27;
  id v28;
  id v29;
  uint64_t v30;
  int v31;
  _QWORD completion[4];
  dispatch_data_t v33;
  id v34;
  id v35;
  uint64_t v36;
  int v37;
  char __strerrbuf[128];

  v8 = a2;
  v9 = a3;
  v10 = a5;
  v11 = v10;
  if (v10)
  {
    error_code = nw_error_get_error_code(v10);
    if (!v8)
      goto LABEL_14;
  }
  else
  {
    error_code = 0;
    if (!v8)
    {
LABEL_14:
      if (strerror_r(error_code, __strerrbuf, 0x80uLL))
        __strerrbuf[0] = 0;
      if (qword_1001E4620 != -1)
        dispatch_once(&qword_1001E4620, &stru_1001B6910);
      if (_NRLogIsLevelEnabled(qword_1001E4618, 16))
      {
        if (qword_1001E4620 != -1)
          dispatch_once(&qword_1001E4620, &stru_1001B6910);
        _NRLogWithArgs(qword_1001E4618, 16, "%s%.30s:%-4d Failed to read data: [%d] %s", "", "-[NRDTestServer setReadHandlerOnConnection:forService:]_block_invoke", 415, error_code, __strerrbuf);
      }
      nw_connection_cancel(*(nw_connection_t *)(a1 + 32));
      goto LABEL_46;
    }
  }
  if (error_code)
    goto LABEL_14;
  v13 = v8;
  if (objc_msgSend(*(id *)(a1 + 40), "hasPrefix:", CFSTR("Terminus ping service")))
  {
    if (qword_1001E4620 != -1)
      dispatch_once(&qword_1001E4620, &stru_1001B6910);
    if (_NRLogIsLevelEnabled(qword_1001E4618, 2))
    {
      if (qword_1001E4620 != -1)
        dispatch_once(&qword_1001E4620, &stru_1001B6910);
      v14 = qword_1001E4618;
      size = dispatch_data_get_size(v13);
      _NRLogWithArgs(v14, 2, "%s%.30s:%-4d Service ping server echoing %zu bytes on %@", "", "-[NRDTestServer setReadHandlerOnConnection:forService:]_block_invoke", 423, size, *(_QWORD *)(a1 + 40));
    }
    v16 = *(NSObject **)(a1 + 32);
    completion[0] = _NSConcreteStackBlock;
    completion[1] = 3221225472;
    completion[2] = sub_10005D588;
    completion[3] = &unk_1001B68A0;
    v37 = 0;
    v33 = v13;
    v34 = *(id *)(a1 + 40);
    v17 = *(id *)(a1 + 32);
    v18 = *(_QWORD *)(a1 + 48);
    v35 = v17;
    v36 = v18;
    nw_connection_send(v16, v33, _nw_content_context_default_stream, 0, completion);

  }
  else if (objc_msgSend(*(id *)(a1 + 40), "hasPrefix:", CFSTR("Terminus read write service")))
  {
    if (qword_1001E4620 != -1)
      dispatch_once(&qword_1001E4620, &stru_1001B6910);
    if (_NRLogIsLevelEnabled(qword_1001E4618, 2))
    {
      if (qword_1001E4620 != -1)
        dispatch_once(&qword_1001E4620, &stru_1001B6910);
      v19 = qword_1001E4618;
      v20 = dispatch_data_get_size(v13);
      _NRLogWithArgs(v19, 2, "%s%.30s:%-4d Read-write server echoing %zu bytes on %@", "", "-[NRDTestServer setReadHandlerOnConnection:forService:]_block_invoke", 444, v20, *(_QWORD *)(a1 + 40));
    }
    v21 = *(NSObject **)(a1 + 32);
    v26[0] = _NSConcreteStackBlock;
    v26[1] = 3221225472;
    v26[2] = sub_10005D6D8;
    v26[3] = &unk_1001B68A0;
    v31 = 0;
    v27 = v13;
    v28 = *(id *)(a1 + 40);
    v22 = *(id *)(a1 + 32);
    v23 = *(_QWORD *)(a1 + 48);
    v29 = v22;
    v30 = v23;
    nw_connection_send(v21, v27, _nw_content_context_default_stream, 0, v26);

  }
  else
  {
    if (objc_msgSend(*(id *)(a1 + 40), "hasPrefix:", CFSTR("Terminus download service")))
    {
      if (qword_1001E4620 != -1)
        dispatch_once(&qword_1001E4620, &stru_1001B6910);
      if (_NRLogIsLevelEnabled(qword_1001E4618, 1))
      {
        if (qword_1001E4620 != -1)
          dispatch_once(&qword_1001E4620, &stru_1001B6910);
        v24 = qword_1001E4618;
        v25 = dispatch_data_get_size(v13);
        _NRLogWithArgs(v24, 1, "%s%.30s:%-4d Download server received %zu bytes on %@", "", "-[NRDTestServer setReadHandlerOnConnection:forService:]_block_invoke", 464, v25, *(_QWORD *)(a1 + 40));
      }
    }
    else
    {
      if (qword_1001E4620 != -1)
        dispatch_once(&qword_1001E4620, &stru_1001B6910);
      if (_NRLogIsLevelEnabled(qword_1001E4618, 16))
      {
        if (qword_1001E4620 != -1)
          dispatch_once(&qword_1001E4620, &stru_1001B6910);
        _NRLogWithArgs(qword_1001E4618, 16, "%s%.30s:%-4d No service to write into for connection: %@, %@", "", "-[NRDTestServer setReadHandlerOnConnection:forService:]_block_invoke", 468, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
      }
    }
    sub_10005CBDC(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
  }

LABEL_46:
}

void sub_10005D588(uint64_t a1, void *a2)
{
  NSObject *v3;
  NSObject *v4;
  uint64_t v5;
  char __strerrbuf[128];

  v3 = a2;
  v4 = v3;
  if (v3 && nw_error_get_error_code(v3))
  {
    v5 = *(unsigned int *)(a1 + 64);
    if (strerror_r(*(_DWORD *)(a1 + 64), __strerrbuf, 0x80uLL))
      __strerrbuf[0] = 0;
    if (qword_1001E4620 != -1)
      dispatch_once(&qword_1001E4620, &stru_1001B6910);
    if (_NRLogIsLevelEnabled(qword_1001E4618, 16))
    {
      if (qword_1001E4620 != -1)
        dispatch_once(&qword_1001E4620, &stru_1001B6910);
      _NRLogWithArgs(qword_1001E4618, 16, "%s%.30s:%-4d Failed to write data: %@ on %@: [%d] %s", "", "-[NRDTestServer setReadHandlerOnConnection:forService:]_block_invoke_2", 435, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), v5, __strerrbuf);
    }
    nw_connection_cancel(*(nw_connection_t *)(a1 + 48));
  }
  else
  {
    sub_10005CBDC(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 40));
  }

}

void sub_10005D6D8(uint64_t a1, void *a2)
{
  NSObject *v3;
  NSObject *v4;
  uint64_t v5;
  char __strerrbuf[128];

  v3 = a2;
  v4 = v3;
  if (v3 && nw_error_get_error_code(v3))
  {
    v5 = *(unsigned int *)(a1 + 64);
    if (strerror_r(*(_DWORD *)(a1 + 64), __strerrbuf, 0x80uLL))
      __strerrbuf[0] = 0;
    if (qword_1001E4620 != -1)
      dispatch_once(&qword_1001E4620, &stru_1001B6910);
    if (_NRLogIsLevelEnabled(qword_1001E4618, 16))
    {
      if (qword_1001E4620 != -1)
        dispatch_once(&qword_1001E4620, &stru_1001B6910);
      _NRLogWithArgs(qword_1001E4618, 16, "%s%.30s:%-4d Failed to write data: %@ on %@: [%d] %s", "", "-[NRDTestServer setReadHandlerOnConnection:forService:]_block_invoke_3", 455, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), v5, __strerrbuf);
    }
    nw_connection_cancel(*(nw_connection_t *)(a1 + 48));
  }
  else
  {
    sub_10005CBDC(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 40));
  }

}

uint64_t sub_10005DA9C(uint64_t a1, uint64_t a2)
{
  void *v3;
  int IsLevelEnabled;
  uint64_t v5;
  void *v6;
  id v7;
  id v8;
  id *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  id v14;
  id v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  int v21;
  uint64_t v22;
  const char *v24;
  void *v25;

  if (!a1)
    return 0;
  if (*(_BYTE *)(a1 + 15))
  {
    v3 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v3, 0);

    if (IsLevelEnabled)
    {
      v6 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
      v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "agentDescription"));
      v24 = "";
      _NRLogWithArgs(v6, 0, "%s%.30s:%-4d unregisterAgent: %@");

    }
    objc_opt_self(NRDPolicySessionManager);
    if (qword_1001E4A20 != -1)
      dispatch_once(&qword_1001E4A20, &stru_1001B8590);
    v7 = (id)qword_1001E4A18;
    sub_100127618((uint64_t)v7, *(void **)(a1 + 88));

    objc_opt_self(NRDPolicySessionManager);
    if (qword_1001E4A20 != -1)
      dispatch_once(&qword_1001E4A20, &stru_1001B8590);
    v8 = (id)qword_1001E4A18;
    v9 = (id *)v8;
    if (v8)
    {
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v8 + 1));
      if ((objc_msgSend(v9[2], "apply") & 1) == 0)
        sub_100109270(CFSTR("NRPolicySessionManager"), CFSTR("ApplyPolicy Failed"), 0, 1, CFSTR("Failed to apply policies"), v10, v11, v12, (uint64_t)v24);
    }

    v14 = objc_msgSend(*(id *)(a1 + 48), "unregisterNetworkAgent");
    if ((v14 & 1) != 0)
    {
      *(_BYTE *)(a1 + 15) = 0;
      objc_msgSend((id)a1, "setActive:", 0);
      v15 = *(id *)(a1 + 32);
      v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "agentUUID"));
      v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "UUIDString"));
      sub_100121E18(v15, 12003, 0, v17);

      objc_msgSend(*(id *)(a1 + 72), "unregisterNetworkAgent");
      objc_msgSend(*(id *)(a1 + 64), "setActive:", 0);
      v18 = *(void **)(a1 + 64);
      *(_QWORD *)(a1 + 64) = 0;

      v19 = *(void **)(a1 + 72);
      *(_QWORD *)(a1 + 72) = 0;
LABEL_17:

      return (uint64_t)v14;
    }
    v20 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v13);
    v21 = _NRLogIsLevelEnabled(v20, 16);

    if (v21)
    {
      v19 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v22);
      _NRLogWithArgs(v19, 16, "%s%.30s:%-4d unable to unregister agent", "", "-[NRCompanionProxyAgent unregisterAgent]", 254);
      goto LABEL_17;
    }
    return 0;
  }
  return 1;
}

void sub_10005DFE8(uint64_t a1, uint64_t a2)
{
  void *v3;
  int IsLevelEnabled;
  uint64_t v5;
  void *v6;
  id v7;
  id v8;
  id *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  id v14;
  void *v15;
  int v16;
  uint64_t v17;
  const char *v18;
  void *v19;
  id v20;

  if (a1 && *(_BYTE *)(a1 + 14))
  {
    v3 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v3, 0);

    if (IsLevelEnabled)
    {
      v6 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
      v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "agentDescription"));
      v18 = "";
      _NRLogWithArgs(v6, 0, "%s%.30s:%-4d unregisterAgent: %@");

    }
    objc_opt_self(NRDPolicySessionManager);
    if (qword_1001E4A20 != -1)
      dispatch_once(&qword_1001E4A20, &stru_1001B8590);
    v7 = (id)qword_1001E4A18;
    sub_100127618((uint64_t)v7, *(void **)(a1 + 64));

    objc_opt_self(NRDPolicySessionManager);
    if (qword_1001E4A20 != -1)
      dispatch_once(&qword_1001E4A20, &stru_1001B8590);
    v8 = (id)qword_1001E4A18;
    v9 = (id *)v8;
    if (v8)
    {
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v8 + 1));
      if ((objc_msgSend(v9[2], "apply") & 1) == 0)
        sub_100109270(CFSTR("NRPolicySessionManager"), CFSTR("ApplyPolicy Failed"), 0, 1, CFSTR("Failed to apply policies"), v10, v11, v12, (uint64_t)v18);
    }

    if ((objc_msgSend(*(id *)(a1 + 48), "unregisterNetworkAgent") & 1) != 0)
    {
      *(_BYTE *)(a1 + 14) = 0;
      objc_msgSend((id)a1, "setActive:", 0);
      v14 = *(id *)(a1 + 32);
      v20 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "agentDescription"));
      sub_100121E18(v14, 20003, 0, v20);

    }
    else
    {
      v15 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v13);
      v16 = _NRLogIsLevelEnabled(v15, 16);

      if (!v16)
        return;
      v20 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v17);
      _NRLogWithArgs(v20, 16, "%s%.30s:%-4d unable to unregister agent", "", "-[NRCompanionProxyConfigAgent unregisterAgent]", 424);
    }

  }
}

id *sub_10005E2AC(id *a1, void *a2, void *a3, void *a4, void *a5)
{
  id v10;
  id v11;
  id v12;
  id v13;
  id *v14;
  void *v15;
  id v16;
  id v17;
  void *v18;
  id v19;
  id v20;
  id v22;
  int IsLevelEnabled;
  id v24;
  uint64_t v25;
  char *v26;
  int *v27;
  uint64_t v28;
  id v29;
  uint64_t v30;
  objc_super v31;

  v10 = a2;
  v11 = a3;
  v12 = a4;
  v13 = a5;
  if (a1)
  {
    v31.receiver = a1;
    v31.super_class = (Class)NRCompanionProxyAgent;
    v14 = (id *)objc_msgSendSuper2(&v31, "init");
    if (!v14)
    {
      v22 = sub_10005E548();
      IsLevelEnabled = _NRLogIsLevelEnabled(v22, 16);

      if (IsLevelEnabled)
      {
        v24 = sub_10005E548();
        _NRLogWithArgs(v24, 16, "%s%.30s:%-4d ABORTING: [super init] failed", "", "-[NRCompanionProxyAgent initWithQueue:interfaceName:remoteDeviceName:nrUUID:]", 59);

      }
      v25 = _os_log_pack_size(12);
      v26 = (char *)&v30 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0);
      v27 = __error();
      v28 = _os_log_pack_fill(v26, v25, *v27, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)v28 = 136446210;
      *(_QWORD *)(v28 + 4) = "-[NRCompanionProxyAgent initWithQueue:interfaceName:remoteDeviceName:nrUUID:]";
      v29 = sub_10005E548();
      _NRLogAbortWithPack(v29, v26);
    }
    a1 = v14;
    objc_storeStrong(v14 + 4, a5);
    objc_msgSend(a1, "setActive:", 0);
    objc_msgSend(a1, "setKernelActivated:", 1);
    objc_msgSend(a1, "setUserActivated:", 1);
    objc_msgSend(a1, "setVoluntary:", 1);
    objc_msgSend(a1, "setNetworkProvider:", 1);
    v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](NSUUID, "UUID"));
    objc_msgSend(a1, "setAgentUUID:", v15);

    objc_storeStrong(a1 + 7, a3);
    v16 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("CompanionProxy via %@"), v12);
    objc_msgSend(a1, "setAgentDescription:", v16);

    objc_storeStrong(a1 + 5, a2);
    a1[10] = (id)1;
    v17 = objc_alloc((Class)NSString);
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "agentUUID"));
    v19 = objc_msgSend(v17, "initWithFormat:", CFSTR("CmpnProxy-%@"), v18);
    v20 = a1[11];
    a1[11] = v19;

  }
  return a1;
}

id sub_10005E548()
{
  if (qword_1001E4630 != -1)
    dispatch_once(&qword_1001E4630, &stru_1001B6950);
  return (id)qword_1001E4628;
}

void sub_10005E588(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001E4628;
  qword_1001E4628 = (uint64_t)v1;

}

uint64_t sub_10005E5B8(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  void *v3;
  int IsLevelEnabled;
  uint64_t v5;
  void *v6;
  void *v7;
  id v8;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  id v14;
  uint64_t v15;
  unsigned __int8 *v16;
  int v17;
  uint64_t v18;
  void *v19;
  int v20;
  uint64_t v21;
  void *v22;
  void *v23;
  int v24;
  uint64_t v25;
  id *v26;
  void *v27;
  int v28;
  uint64_t v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  int v36;
  id v37;
  uint64_t v38;
  void *v39;
  char *v40;
  id v41;
  void *v42;
  id v43;
  unsigned int v44;
  id *v45;
  id v46;
  NSObject *v47;
  void *v48;
  uint64_t v49;
  id v50;
  uint64_t v51;
  void *v52;
  id v53;
  int v54;
  id v55;
  int *v56;
  uint64_t v57;
  id v58;
  id v59;
  int v60;
  uint64_t v61;
  id v62;
  id v63;
  id v64;
  void *v65;
  void *v66;
  id v67;
  void *v68;
  uint64_t v69;
  void *v70;
  void *v71;
  void *v72;
  void *v73;
  void *v74;
  void *v75;
  id v76;
  void *v77;
  void *v78;
  id v79;
  id v80;
  id v81;
  void *v82;
  id v83;
  id *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  void *v88;
  uint64_t v89;
  void *v90;
  void *v91;
  int v92;
  uint64_t v93;
  void *v94;
  uint64_t v95;
  uint64_t v96;
  void *v97;
  int v98;
  uint64_t v99;
  void *v100;
  void *v101;
  int v102;
  uint64_t v103;
  id v104;
  void *v105;
  void *v106;
  uint64_t v107;
  void *v108;
  void *v109;
  _QWORD v110[2];

  if (!result)
    return result;
  v2 = result;
  if (*(_BYTE *)(result + 15))
    return 1;
  v3 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(result + 32), a2);
  IsLevelEnabled = _NRLogIsLevelEnabled(v3, 0);

  if (IsLevelEnabled)
  {
    v6 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v2 + 32), v5);
    v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v2, "agentDescription"));
    _NRLogWithArgs(v6, 0, "%s%.30s:%-4d registerAgent: %@", "", "-[NRCompanionProxyAgent registerAgent]", 187, v7);

  }
  v8 = objc_msgSend(objc_alloc((Class)NWNetworkAgentRegistration), "initWithNetworkAgentClass:", objc_opt_class(v2));
  v9 = *(void **)(v2 + 48);
  *(_QWORD *)(v2 + 48) = v8;

  v11 = *(void **)(v2 + 48);
  if (v11)
  {
    if ((objc_msgSend(v11, "registerNetworkAgent:", v2) & 1) != 0)
    {
      v13 = *(_QWORD *)(v2 + 56);
      v14 = *(id *)(v2 + 48);
      LOBYTE(v13) = objc_msgSend(v14, "addNetworkAgentToInterfaceNamed:", v13);

      if ((v13 & 1) == 0)
      {
        v35 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v2 + 32), v15);
        v36 = _NRLogIsLevelEnabled(v35, 16);

        if (v36)
        {
          v37 = *(id *)(v2 + 32);
          v39 = (void *)_NRCopyLogObjectForNRUUID(v37, v38);
          _NRLogWithArgs(v39, 16, "%s%.30s:%-4d unable to add network agent to interface %@", "", "-[NRCompanionProxyAgent registerAgent]", 201, *(_QWORD *)(v2 + 56));

        }
        goto LABEL_20;
      }
      objc_opt_self(NRLinkDirector);
      if (qword_1001E4710 != -1)
        dispatch_once(&qword_1001E4710, &stru_1001B6E60);
      v16 = (unsigned __int8 *)(id)qword_1001E4708;
      if (v16)
      {
        v17 = v16[8];

        if (v17)
        {
          v19 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v2 + 32), v18);
          v20 = _NRLogIsLevelEnabled(v19, 0);

          if (v20)
          {
            v22 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v2 + 32), v21);
            _NRLogWithArgs(v22, 0, "%s%.30s:%-4d Not registering fallback agents as fixed interface mode is enabled", "", "-[NRCompanionProxyAgent registerAgent]", 206);

          }
          *(_BYTE *)(v2 + 15) = 1;
          objc_msgSend((id)v2, "setActive:", 1);
          objc_msgSend(*(id *)(v2 + 48), "updateNetworkAgent:", v2);
          goto LABEL_20;
        }
      }
      *(_BYTE *)(v2 + 15) = 1;
      objc_msgSend((id)v2, "setActive:", 1);
      objc_msgSend(*(id *)(v2 + 48), "updateNetworkAgent:", v2);
      v40 = sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(v2 + 32));
      if (v40)
      {
        v26 = (id *)v40;
        v41 = *((id *)v40 + 16);
        if (v41)
        {
          v42 = v41;
          v43 = v26[16];
          v44 = objc_msgSend(v43, "allowsDirectToCloud");

          if (!v44)
            goto LABEL_70;
        }
        objc_opt_self(NRLinkDirector);
        if (qword_1001E4710 == -1)
        {
LABEL_34:
          v45 = (id *)(id)qword_1001E4708;
          v46 = *(id *)(v2 + 32);
          if (v45)
          {
            v47 = sub_10014CFBC();
            dispatch_assert_queue_V2(v47);

            if (v46)
            {
              v48 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v45[25], "objectForKeyedSubscript:", v46));

              if (v48)
              {
                v49 = objc_claimAutoreleasedReturnValue(objc_msgSend(v45[25], "objectForKeyedSubscript:", v46));
                v50 = (id)v49;
                if (v49)
                {
                  v51 = *(_QWORD *)(v49 + 448);
                  if (v51)
                  {
                    v52 = (void *)NEVirtualInterfaceCopyName(v51);
                    goto LABEL_47;
                  }
                }
LABEL_46:
                v52 = 0;
LABEL_47:

                if (v52)
                {
                  v62 = objc_alloc((Class)NEPathControllerNetworkAgent);
                  v63 = objc_msgSend(objc_alloc((Class)NWInterface), "initWithInterfaceName:", v52);
                  v64 = objc_msgSend(v62, "initWithAdvisoryInterface:advisoryMode:", v63, 2);
                  v65 = *(void **)(v2 + 64);
                  *(_QWORD *)(v2 + 64) = v64;

                  v66 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](NSUUID, "UUID"));
                  objc_msgSend(*(id *)(v2 + 64), "setAgentUUID:", v66);

                  objc_msgSend(*(id *)(v2 + 64), "setAgentDescription:", CFSTR("Fallback from any interface to CompanionProxy"));
                  objc_msgSend(*(id *)(v2 + 64), "setActive:", 1);
                  objc_msgSend(*(id *)(v2 + 64), "setVoluntary:", 0);
                  objc_msgSend(*(id *)(v2 + 64), "setUserActivated:", 0);
                  objc_msgSend(*(id *)(v2 + 64), "setKernelActivated:", 0);
                  v67 = objc_msgSend(objc_alloc((Class)NWNetworkAgentRegistration), "initWithNetworkAgentClass:", objc_opt_class(*(_QWORD *)(v2 + 64)));
                  v68 = *(void **)(v2 + 72);
                  *(_QWORD *)(v2 + 72) = v67;

                  if ((objc_msgSend(*(id *)(v2 + 72), "registerNetworkAgent:", *(_QWORD *)(v2 + 64)) & 1) != 0)
                  {
                    v70 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyRouteRule routeRuleWithAction:forType:](NEPolicyRouteRule, "routeRuleWithAction:forType:", 5, 0));
                    v71 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v2 + 64), "agentUUID"));
                    objc_msgSend(v70, "setNetworkAgentUUID:", v71);

                    v72 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyRouteRule routeRuleWithAction:forType:](NEPolicyRouteRule, "routeRuleWithAction:forType:", 6, 6));
                    v73 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v2 + 64), "agentUUID"));
                    objc_msgSend(v72, "setNetworkAgentUUID:", v73);

                    v108 = v70;
                    v110[0] = v70;
                    v110[1] = v72;
                    v74 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v110, 2));
                    v75 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult routeRules:](NEPolicyResult, "routeRules:", v74));

                    v76 = objc_alloc((Class)NEPolicy);
                    v77 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](NEPolicyCondition, "allInterfaces"));
                    v109 = v77;
                    v78 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v109, 1));
                    v79 = objc_msgSend(v76, "initWithOrder:result:conditions:", 10, v75, v78);

                    objc_opt_self(NRDPolicySessionManager);
                    if (qword_1001E4A20 != -1)
                      dispatch_once(&qword_1001E4A20, &stru_1001B8590);
                    v80 = (id)qword_1001E4A18;
                    v81 = sub_100127310((uint64_t)v80, *(void **)(v2 + 88), v79);

                    objc_opt_self(NRDPolicySessionManager);
                    if (qword_1001E4A20 != -1)
                      dispatch_once(&qword_1001E4A20, &stru_1001B8590);
                    v82 = v108;
                    v83 = (id)qword_1001E4A18;
                    v84 = (id *)v83;
                    if (v83)
                    {
                      dispatch_assert_queue_V2(*((dispatch_queue_t *)v83 + 1));
                      if ((objc_msgSend(v84[2], "apply") & 1) == 0)
                        sub_100109270(CFSTR("NRPolicySessionManager"), CFSTR("ApplyPolicy Failed"), 0, 1, CFSTR("Failed to apply policies"), v85, v86, v87, v107);
                    }

                    LOBYTE(v82) = 1;
                  }
                  else
                  {
                    v91 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v2 + 32), v69);
                    v92 = _NRLogIsLevelEnabled(v91, 16);

                    if (v92)
                    {
                      v94 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v2 + 32), v93);
                      _NRLogWithArgs(v94, 16, "%s%.30s:%-4d unable to register path controller agent", "", "-[NRCompanionProxyAgent registerPathControllerFallback]", 157);

                    }
                    LOBYTE(v82) = 0;
                  }
LABEL_64:

                  v96 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(v2 + 32), v95);
                  v97 = (void *)v96;
                  if ((v82 & 1) != 0)
                  {
                    v98 = _NRLogIsLevelEnabled(v96, 0);

                    if (v98)
                    {
                      v100 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v2 + 32), v99);
                      v101 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v2, "agentUUID"));
                      _NRLogWithArgs(v100, 0, "%s%.30s:%-4d Successfully added fallback path controller for agent (%@)", "", "-[NRCompanionProxyAgent registerAgent]", 224, v101);

LABEL_69:
                    }
                  }
                  else
                  {
                    v102 = _NRLogIsLevelEnabled(v96, 17);

                    if (v102)
                    {
                      v100 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v2 + 32), v103);
                      _NRLogWithArgs(v100, 17, "unable to register path controllers");
                      goto LABEL_69;
                    }
                  }
LABEL_70:
                  v104 = *(id *)(v2 + 32);
                  v105 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v2, "agentUUID"));
                  v106 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v105, "UUIDString"));
                  sub_100121E18(v104, 12002, 0, v106);

                  goto LABEL_19;
                }
LABEL_58:
                v88 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v2 + 32), v61);
                LODWORD(v82) = _NRLogIsLevelEnabled(v88, 17);

                if ((_DWORD)v82)
                {
                  v90 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v2 + 32), v89);
                  _NRLogWithArgs(v90, 17, "Attempting to register fallback path controller with invalid fallback interface");

                  v52 = 0;
                  LOBYTE(v82) = 0;
                }
                else
                {
                  v52 = 0;
                }
                goto LABEL_64;
              }
            }
            else
            {
              v59 = sub_1000A2640();
              v60 = _NRLogIsLevelEnabled(v59, 17);

              if (v60)
              {
                v50 = sub_1000A2640();
                _NRLogWithArgs(v50, 17, "%s called with null nrUUID", "-[NRLinkDirector copyCatchAllInterfaceNameForNRUUID:]");
                goto LABEL_46;
              }
            }
          }

          goto LABEL_58;
        }
      }
      else
      {
        v53 = sub_10005E548();
        v54 = _NRLogIsLevelEnabled(v53, 16);

        if (v54)
        {
          v55 = sub_10005E548();
          _NRLogWithArgs(v55, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)", "", "-[NRCompanionProxyAgent registerAgent]", 218);

        }
        v2 = _os_log_pack_size(12);
        v26 = (id *)((char *)&v107 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0));
        v56 = __error();
        v57 = _os_log_pack_fill(v26, v2, *v56, &_mh_execute_header, "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
        *(_DWORD *)v57 = 136446210;
        *(_QWORD *)(v57 + 4) = "-[NRCompanionProxyAgent registerAgent]";
        v58 = sub_10005E548();
        _NRLogAbortWithPack(v58, v26);
      }
      dispatch_once(&qword_1001E4710, &stru_1001B6E60);
      goto LABEL_34;
    }
    v27 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v2 + 32), v12);
    v28 = _NRLogIsLevelEnabled(v27, 16);

    if (v28)
    {
      v26 = (id *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v2 + 32), v29);
      _NRLogWithArgs(v26, 16, "%s%.30s:%-4d unable register network agent");
      goto LABEL_19;
    }
  }
  else
  {
    v23 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v2 + 32), v10);
    v24 = _NRLogIsLevelEnabled(v23, 16);

    if (v24)
    {
      v26 = (id *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v2 + 32), v25);
      _NRLogWithArgs(v26, 16, "%s%.30s:%-4d unable to allocate registration object");
LABEL_19:

    }
  }
LABEL_20:
  if (*(_BYTE *)(v2 + 15))
    return 1;
  v30 = *(void **)(v2 + 48);
  if (v30)
  {
    objc_msgSend(v30, "unregisterNetworkAgent");
    v31 = *(void **)(v2 + 48);
    *(_QWORD *)(v2 + 48) = 0;

  }
  v32 = *(void **)(v2 + 72);
  if (v32)
    objc_msgSend(v32, "unregisterNetworkAgent");
  v33 = *(void **)(v2 + 64);
  *(_QWORD *)(v2 + 64) = 0;

  v34 = *(void **)(v2 + 72);
  *(_QWORD *)(v2 + 72) = 0;

  return *(_BYTE *)(v2 + 15) != 0;
}

void sub_10005F064(uint64_t a1, uint64_t a2)
{
  void *v3;
  int IsLevelEnabled;
  id v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  void *v11;
  int v12;
  uint64_t v13;
  id v14;

  if (a1)
  {
    ++*(_QWORD *)(a1 + 80);
    v3 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v3, 0);

    if (IsLevelEnabled)
    {
      v5 = *(id *)(a1 + 32);
      v7 = (void *)_NRCopyLogObjectForNRUUID(v5, v6);
      v8 = *(_QWORD *)(a1 + 80);
      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "agentDescription"));

      _NRLogWithArgs(v7, 0, "%s%.30s:%-4d refreshGeneration to %llu: %@", "", "-[NRCompanionProxyAgent refreshGeneration]", 272, v8, v9);
    }
    if (*(_BYTE *)(a1 + 15) && (objc_msgSend(*(id *)(a1 + 48), "updateNetworkAgent:", a1) & 1) == 0)
    {
      v11 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v10);
      v12 = _NRLogIsLevelEnabled(v11, 16);

      if (v12)
      {
        v14 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v13);
        _NRLogWithArgs(v14, 16, "%s%.30s:%-4d unable to update agent", "", "-[NRCompanionProxyAgent refreshGeneration]", 277);

      }
    }
  }
}

id *sub_10005F1BC(id *a1, void *a2, void *a3, void *a4)
{
  id v8;
  id v9;
  id v10;
  id *v11;
  void *v12;
  id v13;
  id v14;
  id v15;
  id v16;
  id v17;
  id v18;
  void *v19;
  id v21;
  int IsLevelEnabled;
  id v23;
  uint64_t v24;
  char *v25;
  int *v26;
  uint64_t v27;
  id v28;
  uint64_t v29;
  objc_super v30;

  v8 = a2;
  v9 = a3;
  v10 = a4;
  if (a1)
  {
    v30.receiver = a1;
    v30.super_class = (Class)NRCompanionProxyConfigAgent;
    v11 = (id *)objc_msgSendSuper2(&v30, "init");
    if (!v11)
    {
      v21 = sub_10005E548();
      IsLevelEnabled = _NRLogIsLevelEnabled(v21, 16);

      if (IsLevelEnabled)
      {
        v23 = sub_10005E548();
        _NRLogWithArgs(v23, 16, "%s%.30s:%-4d ABORTING: [super init] failed", "", "-[NRCompanionProxyConfigAgent initWithQueue:parameters:nrUUID:]", 314);

      }
      v24 = _os_log_pack_size(12);
      v25 = (char *)&v29 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
      v26 = __error();
      v27 = _os_log_pack_fill(v25, v24, *v26, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)v27 = 136446210;
      *(_QWORD *)(v27 + 4) = "-[NRCompanionProxyConfigAgent initWithQueue:parameters:nrUUID:]";
      v28 = sub_10005E548();
      _NRLogAbortWithPack(v28, v25);
    }
    a1 = v11;
    objc_storeStrong(v11 + 4, a4);
    objc_storeStrong(a1 + 7, a3);
    objc_msgSend(a1, "setKernelActivated:", 1);
    objc_msgSend(a1, "setUserActivated:", 1);
    objc_msgSend(a1, "setVoluntary:", 1);
    v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](NSUUID, "UUID"));
    objc_msgSend(a1, "setAgentUUID:", v12);

    v13 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("CompanionProxyConfig for %@"), v10);
    objc_msgSend(a1, "setAgentDescription:", v13);

    v14 = objc_alloc((Class)NSString);
    v15 = a1[4];
    v16 = objc_msgSend(v14, "initWithFormat:", CFSTR("NRCompanionProxyConfigAgent-%@"), v15);
    v17 = a1[8];
    a1[8] = v16;

    objc_storeStrong(a1 + 5, a2);
    v18 = a1[4];
    v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "agentDescription"));
    sub_100121E18(v18, 20001, 0, v19);

  }
  return a1;
}

uint64_t sub_10005F454(uint64_t result, uint64_t a2)
{
  void *v2;
  void *v3;
  id v4;
  __objc2_class *v5;
  __objc2_prot *v6;
  uint64_t v7;
  int v8;
  void *v9;
  void *IsLevelEnabled;
  uint64_t v11;
  void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  char *v18;
  char *v19;
  void *v20;
  NSObject *v21;
  _QWORD *v22;
  _QWORD *v23;
  id v24;
  void *v25;
  void *v26;
  id v27;
  id v28;
  id v29;
  id *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  id v34;
  void *v35;
  void *v36;
  int v37;
  uint64_t v38;
  void *v39;
  int v40;
  uint64_t v41;
  void *v42;
  void *v43;
  id v44;
  int v45;
  id v46;
  int *v47;
  uint64_t v48;
  id v49;
  uint64_t v50[3];

  if (result)
  {
    v7 = result;
    v8 = *(unsigned __int8 *)(result + 14);
    if (*(_BYTE *)(result + 14))
      return v8 != 0;
    v9 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(result + 32), a2);
    IsLevelEnabled = (void *)_NRLogIsLevelEnabled(v9, 0);

    if ((_DWORD)IsLevelEnabled)
    {
      v12 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v7 + 32), v11);
      IsLevelEnabled = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v7, "agentDescription"));
      _NRLogWithArgs(v12, 0, "%s%.30s:%-4d registerAgent: %@", "", "-[NRCompanionProxyConfigAgent registerAgent]", 372, IsLevelEnabled);

    }
    v13 = objc_msgSend(objc_alloc((Class)NWNetworkAgentRegistration), "initWithNetworkAgentClass:", objc_opt_class(v7));
    v14 = *(void **)(v7 + 48);
    *(_QWORD *)(v7 + 48) = v13;

    v16 = *(void **)(v7 + 48);
    if (!v16)
    {
      v36 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v7 + 32), v15);
      v37 = _NRLogIsLevelEnabled(v36, 16);

      if (!v37)
        goto LABEL_20;
      v19 = (char *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v7 + 32), v38);
      _NRLogWithArgs(v19, 16, "%s%.30s:%-4d unable to allocate registration object");
      goto LABEL_19;
    }
    if ((objc_msgSend(v16, "registerNetworkAgent:", v7) & 1) == 0)
    {
      v39 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v7 + 32), v17);
      v40 = _NRLogIsLevelEnabled(v39, 16);

      if (!v40)
        goto LABEL_20;
      v19 = (char *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v7 + 32), v41);
      _NRLogWithArgs(v19, 16, "%s%.30s:%-4d unable register network agent");
LABEL_19:

LABEL_20:
      v8 = *(unsigned __int8 *)(v7 + 14);
      if (!*(_BYTE *)(v7 + 14))
      {
        v42 = *(void **)(v7 + 48);
        if (v42)
        {
          objc_msgSend(v42, "unregisterNetworkAgent");
          v43 = *(void **)(v7 + 48);
          *(_QWORD *)(v7 + 48) = 0;

          v8 = *(unsigned __int8 *)(v7 + 14);
        }
        else
        {
          v8 = 0;
        }
      }
      return v8 != 0;
    }
    *(_BYTE *)(v7 + 14) = 1;
    objc_msgSend((id)v7, "setActive:", 1);
    objc_msgSend(*(id *)(v7 + 48), "updateNetworkAgent:", v7);
    v18 = sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(v7 + 32));
    if (v18)
    {
      v19 = v18;
      v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v7, "agentUUID"));
      IsLevelEnabled = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult netAgentUUID:](NEPolicyResult, "netAgentUUID:", v20));

      v21 = sub_10014CFBC();
      dispatch_assert_queue_V2(v21);

      v22 = sub_100133714(v19, CFSTR("0"));
      v2 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition flowRemoteAddress:prefix:](NEPolicyCondition, "flowRemoteAddress:prefix:", v22, 128));

      v23 = sub_1001331E8(v19, CFSTR("62742"));
      v3 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition flowLocalAddress:prefix:](NEPolicyCondition, "flowLocalAddress:prefix:", v23, 128));

      v24 = objc_alloc((Class)NEPolicy);
      v50[0] = (uint64_t)v2;
      v50[1] = (uint64_t)v3;
      v25 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](NEPolicyCondition, "allInterfaces"));
      v50[2] = (uint64_t)v25;
      v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v50, 3));
      v4 = objc_msgSend(v24, "initWithOrder:result:conditions:", 10, IsLevelEnabled, v26);

      v5 = &OBJC_METACLASS___NRAnalyticsLocalDevice;
      objc_opt_self(NRDPolicySessionManager);
      v6 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
      if (qword_1001E4A20 == -1)
      {
LABEL_9:
        v27 = (id)qword_1001E4A18;
        v28 = sub_100127310((uint64_t)v27, *(void **)(v7 + 64), v4);

        objc_opt_self(&v5[54]);
        if (v6[36].isa != (void *)-1)
          dispatch_once(&qword_1001E4A20, &stru_1001B8590);
        v29 = (id)qword_1001E4A18;
        v30 = (id *)v29;
        if (v29)
        {
          dispatch_assert_queue_V2(*((dispatch_queue_t *)v29 + 1));
          if ((objc_msgSend(v30[2], "apply") & 1) == 0)
            sub_100109270(CFSTR("NRPolicySessionManager"), CFSTR("ApplyPolicy Failed"), 0, 1, CFSTR("Failed to apply policies"), v31, v32, v33, v50[0]);
        }

        v34 = *(id *)(v7 + 32);
        v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v7, "agentDescription"));
        sub_100121E18(v34, 20002, 0, v35);

        goto LABEL_19;
      }
    }
    else
    {
      v44 = sub_10005E548();
      v45 = _NRLogIsLevelEnabled(v44, 16);

      if (v45)
      {
        v46 = sub_10005E548();
        _NRLogWithArgs(v46, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)", "", "-[NRCompanionProxyConfigAgent registerAgent]", 390);

      }
      v7 = _os_log_pack_size(12);
      v19 = (char *)v50 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
      v47 = __error();
      v48 = _os_log_pack_fill(v19, v7, *v47, &_mh_execute_header, "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
      *(_DWORD *)v48 = 136446210;
      *(_QWORD *)(v48 + 4) = "-[NRCompanionProxyConfigAgent registerAgent]";
      v49 = sub_10005E548();
      _NRLogAbortWithPack(v49, v19);
    }
    dispatch_once(&qword_1001E4A20, &stru_1001B8590);
    goto LABEL_9;
  }
  return result;
}

void sub_10005FF3C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100060198(uint64_t a1)
{
  id v2;
  _BYTE *v3;
  int v4;
  uint64_t v5;
  void *v6;
  NSObject *v7;
  id v8;
  void *v9;
  id v10;
  id v11;
  id *v12;
  id *v13;
  uint64_t v14;
  NSObject *v15;
  int v16;
  id WeakRetained;
  int v18;
  id *v19;

  objc_opt_self(NRDKeyManager);
  if (qword_1001E4AD8 != -1)
    dispatch_once(&qword_1001E4AD8, &stru_1001B8968);
  v2 = (id)qword_1001E4AD0;
  if (v2)
  {
    v3 = v2;
    dispatch_assert_queue_V2(*((dispatch_queue_t *)v2 + 2));
    if (!v3[10])
    {
      v3[10] = 1;
      if (v3[8] == 4)
      {
        sub_10014A63C((uint64_t)v3);
        if (v3[9])
        {
          v3[8] = 3;
          sub_10014A8AC((uint64_t)v3);
        }
      }
    }
    v4 = v3[8] & 0xFD;

    if (v4 == 1)
    {
      v5 = *(_QWORD *)(a1 + 32);
      if (v5)
      {
        v6 = *(void **)(a1 + 40);
        v7 = *(NSObject **)(v5 + 40);
        v8 = v6;
        dispatch_assert_queue_V2(v7);
        v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "objectForKeyedSubscript:", NWNetworkAgentStartOptionClientUUID));

        if (v9)
        {
          objc_msgSend(*(id *)(v5 + 64), "setObject:forKeyedSubscript:", 0, v9);
          if (qword_1001E4640 != -1)
            dispatch_once(&qword_1001E4640, &stru_1001B6970);
          if (_NRLogIsLevelEnabled(qword_1001E4638, 1))
          {
            if (qword_1001E4640 != -1)
              dispatch_once(&qword_1001E4640, &stru_1001B6970);
            v10 = (id)qword_1001E4638;
            v11 = sub_10006062C(v5);
            _NRLogWithArgs(v10, 1, "%s%.30s:%-4d prefer wi-fi clients: %@", "", "-[NRPreferWiFiAgent removeClientIdentifier:]", 274, v11);

          }
        }
        else
        {
          if (qword_1001E4640 != -1)
            dispatch_once(&qword_1001E4640, &stru_1001B6970);
          if (_NRLogIsLevelEnabled(qword_1001E4638, 17))
          {
            if (qword_1001E4640 != -1)
              dispatch_once(&qword_1001E4640, &stru_1001B6970);
            _NRLogWithArgs(qword_1001E4638, 17, "no client UUID");
          }
        }

      }
      objc_opt_self(NRLinkDirector);
      if (qword_1001E4710 != -1)
        dispatch_once(&qword_1001E4710, &stru_1001B6E60);
      v12 = (id *)(id)qword_1001E4708;
      v19 = v12;
      if (v12)
      {
        v13 = (id *)v12[6];
        v14 = (uint64_t)v13;
        if (v13)
        {
          v15 = v13[3];
          dispatch_assert_queue_V2(v15);

          if (qword_1001E4AB8 != -1)
            dispatch_once(&qword_1001E4AB8, &stru_1001B8928);
          if (_NRLogIsLevelEnabled(qword_1001E4AB0, 0))
          {
            if (qword_1001E4AB8 != -1)
              dispatch_once(&qword_1001E4AB8, &stru_1001B8928);
            _NRLogWithArgs(qword_1001E4AB0, 0, "%s%.30s:%-4d prefer Wi-Fi request unavailable. Current state - active=%d, cleared=%d", "", "-[NRLinkManagerWiFi preferWiFiRequestUnavailable]", 2112, *(_DWORD *)(v14 + 40), *(_DWORD *)(v14 + 48));
          }
          v16 = *(_DWORD *)(v14 + 48);
          if (v16 > 0)
          {
            *(_DWORD *)(v14 + 48) = v16 - 1;
LABEL_36:
            if (!*(_DWORD *)(v14 + 40))
            {
              WeakRetained = objc_loadWeakRetained((id *)(v14 + 160));
              objc_msgSend(WeakRetained, "preferWiFiRequestUnavailable");

            }
            goto LABEL_49;
          }
          v18 = *(_DWORD *)(v14 + 40);
          if (v18 > 0)
          {
            sub_100143440(v14, v18 - 1);
            if (*(int *)(v14 + 40) >= 1)
              sub_100149458(v14);
            goto LABEL_36;
          }
        }
      }
      else
      {
        v14 = 0;
      }
LABEL_49:

      return;
    }
  }
  if (qword_1001E4640 != -1)
    dispatch_once(&qword_1001E4640, &stru_1001B6970);
  if (_NRLogIsLevelEnabled(qword_1001E4638, 17))
  {
    if (qword_1001E4640 != -1)
      dispatch_once(&qword_1001E4640, &stru_1001B6970);
    _NRLogWithArgs(qword_1001E4638, 17, "Wi-Fi agent unassert before class C unlock");
  }
}

id sub_10006062C(uint64_t a1)
{
  id v2;
  void *v3;
  id v4;
  id v5;
  uint64_t v6;
  void *i;
  void *v8;
  id v9;
  uint64_t account_id;
  id v11;
  uint64_t pid;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  _BYTE v18[128];

  if (!a1 || *(_BYTE *)(a1 + 15) || !*(_QWORD *)(a1 + 64))
    return 0;
  v2 = objc_alloc_init((Class)NSMutableArray);
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v17 = 0u;
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 64), "allValues", 0));
  v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v14, v18, 16);
  if (v4)
  {
    v5 = v4;
    v6 = *(_QWORD *)v15;
    do
    {
      for (i = 0; i != v5; i = (char *)i + 1)
      {
        if (*(_QWORD *)v15 != v6)
          objc_enumerationMutation(v3);
        v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((_QWORD *)&v14 + 1) + 8 * (_QWORD)i), "parameters"));
        v9 = objc_msgSend(v8, "copyCParameters");

        account_id = nw_parameters_get_account_id(v9);
        if (account_id)
        {
          v11 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", account_id));
LABEL_11:
          objc_msgSend(v2, "addObject:", v11);
LABEL_12:

          goto LABEL_13;
        }
        pid = nw_parameters_get_pid(v9);
        if ((int)pid >= 1)
        {
          v11 = sub_100109ADC(pid, 0);
          if (!v11)
            goto LABEL_12;
          goto LABEL_11;
        }
LABEL_13:

      }
      v5 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v14, v18, 16);
    }
    while (v5);
  }

  return v2;
}

void sub_1000607D8(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001E4638;
  qword_1001E4638 = (uint64_t)v1;

}

void sub_100060808(uint64_t a1)
{
  id v2;
  _BYTE *v3;
  int v4;
  uint64_t v5;
  void *v6;
  NSObject *v7;
  id v8;
  void *v9;
  void *v10;
  id v11;
  id v12;
  id *v13;
  id *v14;
  uint64_t v15;
  NSObject *v16;
  int v17;
  id WeakRetained;
  unsigned int v19;
  id *v20;

  objc_opt_self(NRDKeyManager);
  if (qword_1001E4AD8 != -1)
    dispatch_once(&qword_1001E4AD8, &stru_1001B8968);
  v2 = (id)qword_1001E4AD0;
  if (!v2)
    goto LABEL_34;
  v3 = v2;
  dispatch_assert_queue_V2(*((dispatch_queue_t *)v2 + 2));
  if (!v3[10])
  {
    v3[10] = 1;
    if (v3[8] == 4)
    {
      sub_10014A63C((uint64_t)v3);
      if (v3[9])
      {
        v3[8] = 3;
        sub_10014A8AC((uint64_t)v3);
      }
    }
  }
  v4 = v3[8] & 0xFD;

  if (v4 == 1)
  {
    v5 = *(_QWORD *)(a1 + 32);
    if (v5)
    {
      v6 = *(void **)(a1 + 40);
      v7 = *(NSObject **)(v5 + 40);
      v8 = v6;
      dispatch_assert_queue_V2(v7);
      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "objectForKeyedSubscript:", NWNetworkAgentStartOptionClientUUID));

      if (v9)
      {
        v10 = (void *)objc_claimAutoreleasedReturnValue(+[NWPath pathForClientID:](NWPath, "pathForClientID:", v9));
        objc_msgSend(*(id *)(v5 + 64), "setObject:forKeyedSubscript:", v10, v9);

        if (qword_1001E4640 != -1)
          dispatch_once(&qword_1001E4640, &stru_1001B6970);
        if (_NRLogIsLevelEnabled(qword_1001E4638, 1))
        {
          if (qword_1001E4640 != -1)
            dispatch_once(&qword_1001E4640, &stru_1001B6970);
          v11 = (id)qword_1001E4638;
          v12 = sub_10006062C(v5);
          _NRLogWithArgs(v11, 1, "%s%.30s:%-4d prefer wi-fi clients: %@", "", "-[NRPreferWiFiAgent addClientIdentifier:]", 259, v12);

        }
      }
      else
      {
        if (qword_1001E4640 != -1)
          dispatch_once(&qword_1001E4640, &stru_1001B6970);
        if (_NRLogIsLevelEnabled(qword_1001E4638, 17))
        {
          if (qword_1001E4640 != -1)
            dispatch_once(&qword_1001E4640, &stru_1001B6970);
          _NRLogWithArgs(qword_1001E4638, 17, "no client UUID");
        }
      }

    }
    objc_opt_self(NRLinkDirector);
    if (qword_1001E4710 != -1)
      dispatch_once(&qword_1001E4710, &stru_1001B6E60);
    v13 = (id *)(id)qword_1001E4708;
    v20 = v13;
    if (v13)
    {
      v14 = (id *)v13[6];
      v15 = (uint64_t)v14;
      if (v14)
      {
        v16 = v14[3];
        dispatch_assert_queue_V2(v16);

        v17 = *(_DWORD *)(v15 + 40);
        if (v17)
        {
          sub_100143440(v15, v17 + 1);
          sub_100149458(v15);
        }
        else
        {
          WeakRetained = objc_loadWeakRetained((id *)(v15 + 160));
          v19 = objc_msgSend(WeakRetained, "preferWiFiRequestAvailable");

          if (v19)
            sub_100143440(v15, *(_DWORD *)(v15 + 40) + 1);
          else
            ++*(_DWORD *)(v15 + 48);
        }
      }
    }
    else
    {
      v15 = 0;
    }

  }
  else
  {
LABEL_34:
    if (qword_1001E4640 != -1)
      dispatch_once(&qword_1001E4640, &stru_1001B6970);
    if (_NRLogIsLevelEnabled(qword_1001E4638, 17))
    {
      if (qword_1001E4640 != -1)
        dispatch_once(&qword_1001E4640, &stru_1001B6970);
      _NRLogWithArgs(qword_1001E4638, 17, "Wi-Fi agent assert before class C unlock");
    }
  }
}

id sub_100060BFC()
{
  if (qword_1001E4640 != -1)
    dispatch_once(&qword_1001E4640, &stru_1001B6970);
  return (id)qword_1001E4638;
}

void sub_100060CBC(uint64_t a1)
{
  _BYTE *WeakRetained;
  id v2;
  uint64_t v3;
  const char *v4;
  uint64_t v5;
  id v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  id v14;
  void *v15;
  void *v16;
  id v17;
  id v18;
  id v19;
  id v20;
  id *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  void *v26;
  id v27;
  const char *v28;
  const char *v29;
  uint64_t v30;
  _QWORD v31[4];
  id v32;
  id location;
  _QWORD v34[2];

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v2 = WeakRetained;
  if (WeakRetained)
  {
    if (WeakRetained[15])
    {
      if (qword_1001E4640 != -1)
        dispatch_once(&qword_1001E4640, &stru_1001B6970);
      if (_NRLogIsLevelEnabled(qword_1001E4638, 1))
      {
        if (qword_1001E4640 != -1)
          dispatch_once(&qword_1001E4640, &stru_1001B6970);
        v3 = qword_1001E4638;
        v30 = 112;
        v28 = "";
        v29 = "-[NRPreferWiFiAgent registerAgentOnQueue:]_block_invoke";
        v4 = "%s%.30s:%-4d Ignoring prefer Wi-Fi agent registration as it is invalidated";
LABEL_15:
        v5 = 1;
LABEL_16:
        _NRLogWithArgs(v3, v5, v4, v28, v29, v30);
        goto LABEL_17;
      }
      goto LABEL_17;
    }
    v6 = objc_msgSend(objc_alloc((Class)NWNetworkAgentRegistration), "initWithNetworkAgentClass:", objc_opt_class(WeakRetained));
    v7 = (void *)*((_QWORD *)v2 + 6);
    *((_QWORD *)v2 + 6) = v6;

    v8 = (void *)*((_QWORD *)v2 + 6);
    if (!v8)
    {
      if (qword_1001E4640 != -1)
        dispatch_once(&qword_1001E4640, &stru_1001B6970);
      if (!_NRLogIsLevelEnabled(qword_1001E4638, 17))
        goto LABEL_17;
      if (qword_1001E4640 != -1)
        dispatch_once(&qword_1001E4640, &stru_1001B6970);
      v3 = qword_1001E4638;
      v4 = "[[NWNetworkAgentRegistration alloc] initWithNetworkAgentClass:] failed";
LABEL_42:
      v5 = 17;
      goto LABEL_16;
    }
    if ((objc_msgSend(v8, "registerNetworkAgent:", v2) & 1) != 0)
    {
      v9 = (void *)objc_claimAutoreleasedReturnValue(+[NRPreferWiFiAgent agentDomain](NRPreferWiFiAgent, "agentDomain"));
      v10 = (void *)objc_claimAutoreleasedReturnValue(+[NRPreferWiFiAgent agentType](NRPreferWiFiAgent, "agentType"));
      v11 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition requiredAgentDomain:agentType:](NEPolicyCondition, "requiredAgentDomain:agentType:", v9, v10));

      v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "agentUUID"));
      v13 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult netAgentUUID:](NEPolicyResult, "netAgentUUID:", v12));

      v14 = objc_alloc((Class)NEPolicy);
      v34[0] = v11;
      v15 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](NEPolicyCondition, "allInterfaces"));
      v34[1] = v15;
      v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v34, 2));
      v17 = objc_msgSend(v14, "initWithOrder:result:conditions:", 10, v13, v16);

      objc_opt_self(NRDPolicySessionManager);
      if (qword_1001E4A20 != -1)
        dispatch_once(&qword_1001E4A20, &stru_1001B8590);
      v18 = (id)qword_1001E4A18;
      v19 = sub_100127310((uint64_t)v18, *((void **)v2 + 7), v17);

      objc_opt_self(NRDPolicySessionManager);
      if (qword_1001E4A20 != -1)
        dispatch_once(&qword_1001E4A20, &stru_1001B8590);
      v20 = (id)qword_1001E4A18;
      v21 = (id *)v20;
      if (v20)
      {
        dispatch_assert_queue_V2(*((dispatch_queue_t *)v20 + 1));
        if ((objc_msgSend(v21[2], "apply") & 1) == 0)
          sub_100109270(CFSTR("NRPolicySessionManager"), CFSTR("ApplyPolicy Failed"), 0, 1, CFSTR("Failed to apply policies"), v22, v23, v24, (uint64_t)v28);
      }

      *((_BYTE *)v2 + 14) = 1;
      v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "agentUUID"));
      v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v25, "UUIDString"));
      sub_100121E18(0, 15002, 0, v26);

      objc_initWeak(&location, v2);
      objc_opt_self(NRLinkDirector);
      if (qword_1001E4710 != -1)
        dispatch_once(&qword_1001E4710, &stru_1001B6E60);
      v27 = (id)qword_1001E4708;
      v31[0] = _NSConcreteStackBlock;
      v31[1] = 3221225472;
      v31[2] = sub_100061264;
      v31[3] = &unk_1001B7F28;
      objc_copyWeak(&v32, &location);
      sub_1000AEC6C((uint64_t)v27, v31);

      objc_destroyWeak(&v32);
      objc_destroyWeak(&location);

      goto LABEL_17;
    }
    if (qword_1001E4640 != -1)
      dispatch_once(&qword_1001E4640, &stru_1001B6970);
    if (_NRLogIsLevelEnabled(qword_1001E4638, 17))
    {
      if (qword_1001E4640 != -1)
        dispatch_once(&qword_1001E4640, &stru_1001B6970);
      v3 = qword_1001E4638;
      v4 = "-registerNetworkAgent: failed";
      goto LABEL_42;
    }
  }
  else
  {
    if (qword_1001E4640 != -1)
      dispatch_once(&qword_1001E4640, &stru_1001B6970);
    if (_NRLogIsLevelEnabled(qword_1001E4638, 1))
    {
      if (qword_1001E4640 != -1)
        dispatch_once(&qword_1001E4640, &stru_1001B6970);
      v3 = qword_1001E4638;
      v30 = 107;
      v28 = "";
      v29 = "-[NRPreferWiFiAgent registerAgentOnQueue:]_block_invoke";
      v4 = "%s%.30s:%-4d Ignoring prefer Wi-Fi agent registration as it is dealloc'd";
      goto LABEL_15;
    }
  }
LABEL_17:

}

void sub_100061238(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  id *v17;

  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100061264(uint64_t a1)
{
  id *WeakRetained;
  void *v2;
  void *v3;
  id *v4;

  WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  v4 = WeakRetained;
  if (WeakRetained)
  {
    if (*((_BYTE *)WeakRetained + 15))
    {
      if (qword_1001E4640 != -1)
        dispatch_once(&qword_1001E4640, &stru_1001B6970);
      if (_NRLogIsLevelEnabled(qword_1001E4638, 1))
      {
        if (qword_1001E4640 != -1)
          dispatch_once(&qword_1001E4640, &stru_1001B6970);
        _NRLogWithArgs(qword_1001E4638, 1, "%s%.30s:%-4d Ignoring prefer Wi-Fi agent activation as it is invalidated");
      }
    }
    else if ((objc_msgSend(WeakRetained, "isActive") & 1) == 0)
    {
      objc_msgSend(v4, "setActive:", 1);
      objc_msgSend(v4[6], "updateNetworkAgent:");
      v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "agentUUID"));
      v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "UUIDString"));
      sub_100121E18(0, 15004, 0, v3);

    }
  }
  else
  {
    if (qword_1001E4640 != -1)
      dispatch_once(&qword_1001E4640, &stru_1001B6970);
    if (_NRLogIsLevelEnabled(qword_1001E4638, 1))
    {
      if (qword_1001E4640 != -1)
        dispatch_once(&qword_1001E4640, &stru_1001B6970);
      _NRLogWithArgs(qword_1001E4638, 1, "%s%.30s:%-4d Ignoring prefer Wi-Fi agent activation as it is dealloc'd");
    }
  }

}

void sub_100061418(uint64_t a1)
{
  id v2;
  id v3;
  id *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void *v9;
  uint64_t v10;
  id v11;

  *(_BYTE *)(a1 + 15) = 1;
  if (*(_BYTE *)(a1 + 14))
  {
    *(_BYTE *)(a1 + 14) = 0;
    objc_opt_self(NRDPolicySessionManager);
    if (qword_1001E4A20 != -1)
      dispatch_once(&qword_1001E4A20, &stru_1001B8590);
    v2 = (id)qword_1001E4A18;
    sub_100127618((uint64_t)v2, *(void **)(a1 + 56));

    objc_opt_self(NRDPolicySessionManager);
    if (qword_1001E4A20 != -1)
      dispatch_once(&qword_1001E4A20, &stru_1001B8590);
    v3 = (id)qword_1001E4A18;
    v4 = (id *)v3;
    if (v3)
    {
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v3 + 1));
      if ((objc_msgSend(v4[2], "apply") & 1) == 0)
        sub_100109270(CFSTR("NRPolicySessionManager"), CFSTR("ApplyPolicy Failed"), 0, 1, CFSTR("Failed to apply policies"), v5, v6, v7, v10);
    }

    v8 = *(void **)(a1 + 48);
    if (v8)
    {
      if (objc_msgSend(v8, "unregisterNetworkAgent"))
      {
        objc_msgSend((id)a1, "setActive:", 0);
        v11 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "agentUUID"));
        v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "UUIDString"));
        sub_100121E18(0, 15003, 0, v9);

      }
    }
  }
}

uint64_t sub_100061594(uint64_t a1, BOOL *a2)
{
  void *v3;
  id v4;
  id v5;
  BOOL v6;
  char v7;
  uint64_t v8;
  void *i;
  void *v10;
  id v11;
  char use_p2p;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  _BYTE v18[128];

  if (a1)
  {
    v16 = 0u;
    v17 = 0u;
    v14 = 0u;
    v15 = 0u;
    v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 64), "allValues", 0));
    v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v14, v18, 16);
    if (v4)
    {
      v5 = v4;
      v6 = 0;
      v7 = 0;
      v8 = *(_QWORD *)v15;
      do
      {
        for (i = 0; i != v5; i = (char *)i + 1)
        {
          if (*(_QWORD *)v15 != v8)
            objc_enumerationMutation(v3);
          v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((_QWORD *)&v14 + 1) + 8 * (_QWORD)i), "parameters"));
          v11 = objc_msgSend(v10, "copyCParameters");

          use_p2p = nw_parameters_get_use_p2p(v11);
          v6 = v6 || nw_parameters_get_traffic_class(v11) > 0x12B;
          v7 |= use_p2p;

        }
        v5 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v14, v18, 16);
      }
      while (v5);
    }
    else
    {
      v6 = 0;
      v7 = 0;
    }

    if (a2)
      *a2 = v6;
  }
  else
  {
    v7 = 0;
  }
  return v7 & 1;
}

void sub_100061E48(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 80));
  _Unwind_Resume(a1);
}

void sub_100062924(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

id sub_100062CF4()
{
  if (qword_1001E4650 != -1)
    dispatch_once(&qword_1001E4650, &stru_1001B6990);
  return (id)qword_1001E4648;
}

void sub_100062D34(uint64_t a1, int a2)
{
  _QWORD *WeakRetained;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  int IsLevelEnabled;
  uint64_t v8;
  void *v9;
  id v10;
  int v11;
  uint64_t v12;
  _QWORD *v13;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v13 = WeakRetained;
    v5 = _NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    v6 = (void *)v5;
    if (a2)
    {
      IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0);

      WeakRetained = v13;
      if (IsLevelEnabled)
      {
        v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v8);
        v10 = objc_msgSend(v13, "copyDescription");
        _NRLogWithArgs(v9, 0, "%s%.30s:%-4d %@: Received response to control notify", "", "-[NRLinkFixedInterface sendControlData:]_block_invoke", 627, v10);
LABEL_7:

        WeakRetained = v13;
      }
    }
    else
    {
      v11 = _NRLogIsLevelEnabled(v5, 16);

      WeakRetained = v13;
      if (v11)
      {
        v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v12);
        v10 = objc_msgSend(v13, "copyDescription");
        _NRLogWithArgs(v9, 16, "%s%.30s:%-4d %@: Did not receive response to control notify", "", "-[NRLinkFixedInterface sendControlData:]_block_invoke", 629, v10);
        goto LABEL_7;
      }
    }
  }

}

void sub_100062E44(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001E4648;
  qword_1001E4648 = (uint64_t)v1;

}

void sub_100062E74(_QWORD *a1)
{
  void *String;
  void *v3;
  id v4;
  id v5;
  id v6;
  id v7;
  id v8;
  id v9;
  id v10;
  id v11;
  id v12;
  id v13;
  id v14;
  id v15;
  id v16;
  id v17;
  id v18;
  uint64_t v19;
  void *v20;
  char IsLevelEnabled;
  uint64_t v22;
  void *v23;
  id v24;
  id v25;
  int v26;
  id v27;
  _QWORD v28[4];
  id v29;
  id v30;
  id v31;
  _QWORD v32[4];
  id v33;
  id v34;
  id v35;
  _QWORD v36[4];
  id v37;
  id v38;
  id v39;
  _QWORD v40[4];
  id v41;
  id v42;
  id v43;
  _QWORD v44[4];
  id v45;
  id v46;
  id v47;
  _QWORD v48[4];
  id v49;
  id v50;
  id v51;
  char v52;
  _QWORD v53[4];
  id v54;
  id v55;
  id v56;
  char v57;
  id location[2];

  if (a1)
  {
    String = (void *)NRDataProtectionClassCreateString(4);
    v3 = *(void **)((char *)a1 + 231);
    if (v3)
    {
      v4 = v3;
      objc_msgSend(v4, "setClientQueue:", a1[1]);
      objc_initWeak(location, a1);
      v53[0] = _NSConcreteStackBlock;
      v53[1] = 3221225472;
      v53[2] = sub_10006334C;
      v53[3] = &unk_1001B7290;
      objc_copyWeak(&v56, location);
      v57 = 4;
      v5 = String;
      v54 = v5;
      v6 = v4;
      v55 = v6;
      objc_msgSend(v6, "setStateUpdateBlock:", v53);
      v48[0] = _NSConcreteStackBlock;
      v48[1] = 3221225472;
      v48[2] = sub_100063B08;
      v48[3] = &unk_1001B72B8;
      objc_copyWeak(&v51, location);
      v7 = v5;
      v49 = v7;
      v8 = v6;
      v50 = v8;
      v52 = 4;
      objc_msgSend(v8, "setChildStateUpdateBlock:", v48);
      v44[0] = _NSConcreteStackBlock;
      v44[1] = 3221225472;
      v44[2] = sub_100063C2C;
      v44[3] = &unk_1001B72E0;
      objc_copyWeak(&v47, location);
      v9 = v7;
      v45 = v9;
      v10 = v8;
      v46 = v10;
      objc_msgSend(v10, "setConfigurationUpdateBlock:", v44);
      v40[0] = _NSConcreteStackBlock;
      v40[1] = 3221225472;
      v40[2] = sub_100063CF8;
      v40[3] = &unk_1001B7308;
      objc_copyWeak(&v43, location);
      v11 = v9;
      v41 = v11;
      v12 = v10;
      v42 = v12;
      objc_msgSend(v12, "setTrafficSelectorUpdateBlock:", v40);
      v36[0] = _NSConcreteStackBlock;
      v36[1] = 3221225472;
      v36[2] = sub_100063DE4;
      v36[3] = &unk_1001B7330;
      objc_copyWeak(&v39, location);
      v13 = v11;
      v37 = v13;
      v14 = v12;
      v38 = v14;
      objc_msgSend(v14, "setAdditionalAddressesUpdateBlock:", v36);
      v32[0] = _NSConcreteStackBlock;
      v32[1] = 3221225472;
      v32[2] = sub_100063EB0;
      v32[3] = &unk_1001B7928;
      objc_copyWeak(&v35, location);
      v15 = v13;
      v33 = v15;
      v16 = v14;
      v34 = v16;
      objc_msgSend(v16, "setShortDPDEventBlock:", v32);
      v28[0] = _NSConcreteStackBlock;
      v28[1] = 3221225472;
      v28[2] = sub_100063F70;
      v28[3] = &unk_1001B7330;
      objc_copyWeak(&v31, location);
      v17 = v15;
      v29 = v17;
      v18 = v16;
      v30 = v18;
      objc_msgSend(v18, "setPrivateNotifyStatusEvent:", v28);
      v20 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v19);
      IsLevelEnabled = _NRLogIsLevelEnabled(v20, 0);

      if ((IsLevelEnabled & 1) != 0)
      {
        v23 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v22);
        v24 = objc_msgSend(a1, "copyDescription");
        _NRLogWithArgs(v23, 0, "%s%.30s:%-4d %@: Setup IKE %@ %@ callbacks", "", "-[NRLinkFixedInterface setupIKECallbacks:]", 459, v24, v17, v18);

      }
      objc_destroyWeak(&v31);

      objc_destroyWeak(&v35);
      objc_destroyWeak(&v39);

      objc_destroyWeak(&v43);
      objc_destroyWeak(&v47);

      objc_destroyWeak(&v51);
      objc_destroyWeak(&v56);
      objc_destroyWeak(location);

    }
    else
    {
      v25 = sub_100062CF4();
      v26 = _NRLogIsLevelEnabled(v25, 17);

      if (v26)
      {
        v27 = sub_100062CF4();
        _NRLogWithArgs(v27, 17, "%s called with null _ikeSessionClassD", "-[NRLinkFixedInterface setupIKECallbacks:]");

      }
      v18 = 0;
    }

  }
}

void sub_1000632CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id *location, id *a17)
{
  id *v17;
  id *v18;
  id *v19;
  id *v20;
  id *v21;
  uint64_t v22;

  objc_destroyWeak(v21);
  objc_destroyWeak(v20);
  objc_destroyWeak(v19);
  objc_destroyWeak(v18);
  objc_destroyWeak(v17);
  objc_destroyWeak(location);
  objc_destroyWeak(a17);
  objc_destroyWeak((id *)(v22 - 112));
  _Unwind_Resume(a1);
}

void sub_10006334C(uint64_t a1, uint64_t a2, void *a3)
{
  _QWORD *WeakRetained;
  _QWORD *v6;
  void *v7;
  id v8;
  uint64_t v9;
  id v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  void *SessionStateString;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  int IsLevelEnabled;
  uint64_t v23;
  void *v24;
  id v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  void *v29;
  int v30;
  uint64_t v31;
  void *v32;
  id v33;
  uint64_t v34;
  void *v35;
  int v36;
  uint64_t v37;
  void *v38;
  id v39;
  uint64_t v40;
  unsigned int v41;
  uint64_t v42;
  uint64_t v43;
  void *v44;
  int v45;
  uint64_t v46;
  void *v47;
  id v48;
  uint64_t v49;
  void *v50;
  int v51;
  uint64_t v52;
  void *v53;
  id v54;
  void *v55;
  id v56;
  int v57;
  id v58;
  void *v59;
  void *v60;
  char *v61;
  char *v62;
  void *v63;
  id v64;
  NRCompanionProxyAgent *v65;
  void *v66;
  void *v67;
  id *v68;
  void *v69;
  void *v70;
  uint64_t v71;
  char v72;
  uint64_t v73;
  int v74;
  uint64_t v75;
  void *v76;
  int v77;
  uint64_t v78;
  id v79;
  uint64_t v80;
  uint64_t v81;
  id v82;

  v82 = a3;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  v6 = WeakRetained;
  if (WeakRetained)
  {
    v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "linkDelegate"));
    v8 = v82;
    if (!v82)
    {
      v16 = *(_QWORD *)(a1 + 32);
      v17 = *(_QWORD *)(a1 + 40);
      SessionStateString = (void *)NEIKEv2CreateSessionStateString(a2);
      objc_msgSend(v6, "reportEvent:detailsFormat:", 3009, CFSTR("%@ session %@ changed state to %@"), v16, v17, SessionStateString);

      switch(a2)
      {
        case 1:
          if (objc_msgSend(v6, "state") == 1)
          {
            v21 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v20);
            IsLevelEnabled = _NRLogIsLevelEnabled(v21, 0);

            if (IsLevelEnabled)
            {
              v24 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v23);
              v25 = objc_msgSend(v6, "copyDescription");
              _NRLogWithArgs(v24, 0, "%s%.30s:%-4d %@: %@ IKE %@ now connecting", "", "-[NRLinkFixedInterface setupIKECallbacks:]_block_invoke", 313, v25, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));

            }
            objc_msgSend(v6, "changeStateTo:", 5);
          }
          else
          {
            v41 = objc_msgSend(v6, "state");
            v43 = _NRCopyLogObjectForNRUUID(v6[4], v42);
            v44 = (void *)v43;
            if (v41 == 5)
            {
              v45 = _NRLogIsLevelEnabled(v43, 0);

              if (!v45)
                goto LABEL_31;
              v47 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v46);
              v48 = objc_msgSend(v6, "copyDescription");
              _NRLogWithArgs(v47, 0, "%s%.30s:%-4d %@: %@ IKE %@ already connecting", "", "-[NRLinkFixedInterface setupIKECallbacks:]_block_invoke", 316, v48, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
            }
            else
            {
              v74 = _NRLogIsLevelEnabled(v43, 16);

              if (!v74)
                goto LABEL_31;
              v47 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v75);
              v48 = objc_msgSend(v6, "copyDescription");
              _NRLogWithArgs(v47, 16, "%s%.30s:%-4d %@: %@ IKE %@ connecting but weird state", "", "-[NRLinkFixedInterface setupIKECallbacks:]_block_invoke", 318, v48, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
            }

          }
          goto LABEL_31;
        case 2:
          v29 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v19);
          v30 = _NRLogIsLevelEnabled(v29, 0);

          if (v30)
          {
            v32 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v31);
            v33 = objc_msgSend(v6, "copyDescription");
            _NRLogWithArgs(v32, 0, "%s%.30s:%-4d %@: %@ IKE %@ now connected from started", "", "-[NRLinkFixedInterface setupIKECallbacks:]_block_invoke", 321, v33, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));

          }
          if (objc_msgSend(v6, "state") == 8)
          {
            v35 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v34);
            v36 = _NRLogIsLevelEnabled(v35, 0);

            if (v36)
            {
              v38 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v37);
              v39 = objc_msgSend(v6, "copyDescription");
              _NRLogWithArgs(v38, 0, "%s%.30s:%-4d %@: %@ IKE %@ already ready", "", "-[NRLinkFixedInterface setupIKECallbacks:]_block_invoke", 323, v39, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));

            }
            if (*(_BYTE *)(a1 + 56) == 4)
            {
              objc_msgSend(v6, "setIkeClassDEstablished:", 1);
              objc_msgSend(v6, "setIkeClassCEstablished:", 1);
            }
            objc_msgSend(v7, "linkIsReady:", v6);
          }
          else
          {
            if (objc_msgSend(v6, "state") != 5)
            {
              v50 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v49);
              v51 = _NRLogIsLevelEnabled(v50, 0);

              if (v51)
              {
                v53 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v52);
                v54 = objc_msgSend(v6, "copyDescription");
                _NRLogWithArgs(v53, 0, "%s%.30s:%-4d %@: %@ IKE %@ ready but weird state", "", "-[NRLinkFixedInterface setupIKECallbacks:]_block_invoke", 331, v54, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));

              }
            }
            objc_msgSend(v6, "changeStateTo:", 8);
            if (*(_BYTE *)(a1 + 56) == 4)
            {
              objc_msgSend(v6, "setIkeClassDEstablished:", 1);
              objc_msgSend(v6, "setIkeClassCEstablished:", 1);
            }
            objc_msgSend(v7, "linkIsReady:", v6);
            if (objc_msgSend(v6, "shouldCreateCompanionProxyAgent"))
            {
              v55 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "companionProxyAgent"));

              if (!v55)
              {
                v56 = sub_100062CF4();
                v57 = _NRLogIsLevelEnabled(v56, 0);

                if (v57)
                {
                  v58 = sub_100062CF4();
                  _NRLogWithArgs(v58, 0, "%s%.30s:%-4d Adding companion proxy agent", "", "-[NRLinkFixedInterface setupIKECallbacks:]_block_invoke", 341);

                }
                v59 = (void *)NEVirtualInterfaceCopyName(objc_msgSend(v6, "virtualInterface"));
                v60 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "nrUUID"));
                v61 = sub_10012FFF4((uint64_t)NRDLocalDevice, v60);
                v62 = v61;
                if (v61)
                  v63 = (void *)*((_QWORD *)v61 + 14);
                else
                  v63 = 0;
                v64 = v63;

                if (v59 && v64)
                {
                  v65 = [NRCompanionProxyAgent alloc];
                  v66 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "queue"));
                  v67 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "nrUUID"));
                  v68 = sub_10005E2AC((id *)&v65->super.isa, v66, v59, v64, v67);
                  v69 = (void *)v6[11];
                  v6[11] = v68;

                  objc_msgSend(v6, "reportEvent:", 12001);
                }

              }
              v70 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "companionProxyAgent"));
              v72 = sub_10005E5B8((uint64_t)v70, v71);

              if ((v72 & 1) != 0)
              {
                objc_msgSend(v6, "reportEvent:", 12002);
                goto LABEL_31;
              }
              v76 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v73);
              v77 = _NRLogIsLevelEnabled(v76, 16);

              if (v77)
              {
                v15 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v78);
                v79 = objc_msgSend(v6, "copyDescription");
                _NRLogWithArgs(v15, 16, "%s%.30s:%-4d %@: failed to register companion agent", "", "-[NRLinkFixedInterface setupIKECallbacks:]_block_invoke", 353, v79);

                goto LABEL_30;
              }
            }
          }
          break;
        case 3:
          if (*(_BYTE *)(a1 + 56) == 4)
          {
            objc_msgSend(v6, "setIkeClassDEstablished:", 0);
            objc_msgSend(v6, "setIkeClassCEstablished:", 0);
          }
          objc_msgSend(v6, "reportEvent:detailsFormat:", 3018, CFSTR("%@ session %@ cancelled by peer"), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
          goto LABEL_27;
        case 4:
          objc_msgSend(v6, "cancelWithReason:", CFSTR("%@ session %@ got unexpected MOBIKE state"), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
          goto LABEL_31;
        default:
          v40 = *(_QWORD *)(a1 + 32);
          v15 = (void *)NEIKEv2CreateSessionStateString(a2);
          objc_msgSend(v6, "cancelWithReason:", CFSTR("%@ session %@ got bad IKE state %@"), v40, v15, v80, v81);
          goto LABEL_30;
      }
      goto LABEL_31;
    }
    v9 = *(unsigned __int8 *)(a1 + 56);
    if ((_DWORD)v9 == 4)
    {
      objc_msgSend(v6, "setIkeClassDEstablished:", 0);
      objc_msgSend(v6, "setIkeClassCEstablished:", 0);
      v8 = v82;
      v9 = *(unsigned __int8 *)(a1 + 56);
    }
    objc_msgSend(v6, "processIKEDisconnection:error:", v9, v8);
    if (objc_msgSend(v6, "state") != 255)
    {
      v10 = v82;
      if (objc_msgSend(v10, "code") == (id)4)
      {
        v11 = NEIKEv2ErrorDomain;
        v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "domain"));
        LODWORD(v11) = objc_msgSend(v12, "isEqualToString:", v11);

        if ((_DWORD)v11)
        {
          v13 = *(_QWORD *)(a1 + 32);
          v14 = *(_QWORD *)(a1 + 40);
          v15 = (void *)NEIKEv2CreateSessionStateString(a2);
          objc_msgSend(v6, "cancelWithReason:", CFSTR("%@ session %@ got IKE error %@ with state %@"), v13, v14, v10, v15);
LABEL_30:

          goto LABEL_31;
        }
      }
      else
      {

      }
      v26 = *(_QWORD *)(a1 + 32);
      v27 = *(_QWORD *)(a1 + 40);
      v28 = (void *)NEIKEv2CreateSessionStateString(a2);
      objc_msgSend(v6, "reportEvent:detailsFormat:", 3018, CFSTR("%@ session %@ got IKE error %@ with state %@"), v26, v27, v10, v28);

LABEL_27:
      sub_100064270((uint64_t)v6, *(unsigned __int8 *)(a1 + 56));
    }
LABEL_31:

  }
}

void sub_100063B08(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id WeakRetained;
  uint64_t v8;
  uint64_t v9;
  void *SessionStateString;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  id v14;

  v14 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    if (v14)
    {
      v8 = *(_QWORD *)(a1 + 32);
      v9 = *(_QWORD *)(a1 + 40);
      SessionStateString = (void *)NEIKEv2CreateSessionStateString(a3);
      objc_msgSend(WeakRetained, "reportEvent:detailsFormat:", 3018, CFSTR("%@ session %@ got child %u state update %@ error %@"), v8, v9, a2, SessionStateString, v14);

      objc_msgSend(WeakRetained, "processIKEDisconnection:error:", *(unsigned __int8 *)(a1 + 56), v14);
      if (objc_msgSend(WeakRetained, "state") == 255)
        goto LABEL_9;
    }
    else
    {
      v11 = *(_QWORD *)(a1 + 32);
      v12 = *(_QWORD *)(a1 + 40);
      if (a3 != 3)
      {
        v13 = (void *)NEIKEv2CreateSessionStateString(a3);
        objc_msgSend(WeakRetained, "reportEvent:detailsFormat:", 3009, CFSTR("%@ session %@ child %u state update %@"), v11, v12, a2, v13);

        goto LABEL_9;
      }
      objc_msgSend(WeakRetained, "reportEvent:detailsFormat:", 3018, CFSTR("%@ session %@ got child %u Disconnected state with no error"), v11, *(_QWORD *)(a1 + 40), a2);
    }
    sub_100064270((uint64_t)WeakRetained, *(unsigned __int8 *)(a1 + 56));
  }
LABEL_9:

}

void sub_100063C2C(uint64_t a1, void *a2)
{
  _QWORD *WeakRetained;
  uint64_t v4;
  _QWORD *v5;
  void *v6;
  int IsLevelEnabled;
  uint64_t v8;
  void *v9;
  id v10;
  id v11;

  v11 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  v5 = WeakRetained;
  if (WeakRetained)
  {
    v6 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0);

    if (IsLevelEnabled)
    {
      v9 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v8);
      v10 = objc_msgSend(v5, "copyDescription");
      _NRLogWithArgs(v9, 0, "%s%.30s:%-4d %@: %@ session %@ got config update %@", "", "-[NRLinkFixedInterface setupIKECallbacks:]_block_invoke_3", 413, v10, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), v11);

    }
  }

}

void sub_100063CF8(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v7;
  _QWORD *WeakRetained;
  uint64_t v9;
  _QWORD *v10;
  void *v11;
  int IsLevelEnabled;
  uint64_t v13;
  void *v14;
  id v15;
  id v16;

  v16 = a3;
  v7 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  v10 = WeakRetained;
  if (WeakRetained)
  {
    v11 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v9);
    IsLevelEnabled = _NRLogIsLevelEnabled(v11, 0);

    if (IsLevelEnabled)
    {
      v14 = (void *)_NRCopyLogObjectForNRUUID(v10[4], v13);
      v15 = objc_msgSend(v10, "copyDescription");
      _NRLogWithArgs(v14, 0, "%s%.30s:%-4d %@: %@ session %@ got child %u traffic selector update local %@ remote %@", "", "-[NRLinkFixedInterface setupIKECallbacks:]_block_invoke_4", 424, v15, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), a2, v16, v7);

    }
  }

}

void sub_100063DE4(uint64_t a1, void *a2)
{
  _QWORD *WeakRetained;
  uint64_t v4;
  _QWORD *v5;
  void *v6;
  int IsLevelEnabled;
  uint64_t v8;
  void *v9;
  id v10;
  id v11;

  v11 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  v5 = WeakRetained;
  if (WeakRetained)
  {
    v6 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0);

    if (IsLevelEnabled)
    {
      v9 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v8);
      v10 = objc_msgSend(v5, "copyDescription");
      _NRLogWithArgs(v9, 0, "%s%.30s:%-4d %@: %@ session %@ got additional addresses %@", "", "-[NRLinkFixedInterface setupIKECallbacks:]_block_invoke_5", 433, v10, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), v11);

    }
  }

}

void sub_100063EB0(uint64_t a1)
{
  _QWORD *WeakRetained;
  uint64_t v3;
  void *v4;
  int IsLevelEnabled;
  uint64_t v6;
  void *v7;
  id v8;
  _QWORD *v9;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    v9 = WeakRetained;
    v4 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v3);
    IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0);

    WeakRetained = v9;
    if (IsLevelEnabled)
    {
      v7 = (void *)_NRCopyLogObjectForNRUUID(v9[4], v6);
      v8 = objc_msgSend(v9, "copyDescription");
      _NRLogWithArgs(v7, 0, "%s%.30s:%-4d %@: %@ session %@ got short DPD", "", "-[NRLinkFixedInterface setupIKECallbacks:]_block_invoke_6", 441, v8, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));

      WeakRetained = v9;
    }
  }

}

void sub_100063F70(uint64_t a1, void *a2)
{
  id v3;
  void **WeakRetained;
  void *v5;
  void *v6;
  uint64_t v7;
  void *v8;
  int IsLevelEnabled;
  uint64_t v10;
  void *v11;
  id v12;
  id v13;
  id v14;
  id v15;
  uint64_t v16;
  void *i;
  void *v18;
  unsigned int v19;
  id v20;
  uint64_t v21;
  void *v22;
  int v23;
  uint64_t v24;
  void *v25;
  id v26;
  void *v27;
  id v28;
  id v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  _BYTE v34[128];
  id v35;

  v3 = a2;
  WeakRetained = (void **)objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    v28 = objc_msgSend(objc_alloc((Class)NSSortDescriptor), "initWithKey:ascending:", CFSTR("notifyStatus"), 1);
    v35 = v28;
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v35, 1));
    v29 = v3;
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "sortedArrayUsingDescriptors:", v5));

    v8 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v7);
    IsLevelEnabled = _NRLogIsLevelEnabled(v8, 0);

    if (IsLevelEnabled)
    {
      v11 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v10);
      v12 = objc_msgSend(WeakRetained, "copyDescription");
      _NRLogWithArgs(v11, 0, "%s%.30s:%-4d %@: %@ session %@ got private notifies %@", "", "-[NRLinkFixedInterface setupIKECallbacks:]_block_invoke_7", 453, v12, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), v6);

    }
    v32 = 0u;
    v33 = 0u;
    v30 = 0u;
    v31 = 0u;
    v13 = v6;
    v14 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v30, v34, 16);
    if (v14)
    {
      v15 = v14;
      v16 = *(_QWORD *)v31;
      do
      {
        for (i = 0; i != v15; i = (char *)i + 1)
        {
          if (*(_QWORD *)v31 != v16)
            objc_enumerationMutation(v13);
          v18 = *(void **)(*((_QWORD *)&v30 + 1) + 8 * (_QWORD)i);
          v19 = objc_msgSend(v18, "notifyStatus");
          v20 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "notifyData"));
          v22 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v21);
          v23 = _NRLogIsLevelEnabled(v22, 1);

          if (v23)
          {
            v25 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v24);
            v26 = objc_msgSend(WeakRetained, "copyDescription");
            _NRLogWithArgs(v25, 1, "%s%.30s:%-4d %@: Received notify code %u %@", "", "-[NRLinkFixedInterface handleNotifyCode:payload:]", 637, v26, v19, v20);

          }
          if (v19 == 50701)
          {
            sub_10013C5A0((uint64_t)NRDLocalDevice, v20, WeakRetained[4]);
            objc_msgSend(WeakRetained, "checkProxyAgentWithForceUpdate:", 0);
          }
          else if (v19 == 50702)
          {
            v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "linkDelegate"));
            objc_msgSend(v27, "linkDidReceiveData:data:", WeakRetained, v20);

          }
        }
        v15 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v30, v34, 16);
      }
      while (v15);
    }

    v3 = v29;
  }

}

void sub_100064270(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  int v8;
  uint64_t v9;
  void *v10;
  id v11;
  void *v12;
  int IsLevelEnabled;
  uint64_t v14;
  void *v15;
  id v16;
  int v17;
  uint64_t v18;
  id String;

  String = (id)NRDataProtectionClassCreateString(a2);
  if (*(unsigned __int8 *)(a1 + 16) == 255)
  {
    v12 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v4);
    IsLevelEnabled = _NRLogIsLevelEnabled(v12, 0);

    if (!IsLevelEnabled)
      goto LABEL_11;
    v15 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v14);
    v16 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v15, 0, "%s%.30s:%-4d %@: Not restarting %@ session because cancelled", "", "-[NRLinkFixedInterface restartIKESessionForDataProtectionClass:]", 249, v16, String);
LABEL_10:

    goto LABEL_11;
  }
  objc_msgSend((id)a1, "invalidateIKESessionForClass:", a2);
  v6 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
  v7 = (void *)v6;
  if ((_DWORD)a2 != 4)
  {
    v17 = _NRLogIsLevelEnabled(v6, 17);

    if (!v17)
      goto LABEL_11;
    v15 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v18);
    v16 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v15, 17, "%@: %@ session as unsupported", v16, String);
    goto LABEL_10;
  }
  v8 = _NRLogIsLevelEnabled(v6, 0);

  if (v8)
  {
    v10 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v9);
    v11 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v10, 0, "%s%.30s:%-4d %@: Restarting %@ session", "", "-[NRLinkFixedInterface restartIKESessionForDataProtectionClass:]", 257, v11, String);

  }
  sub_100064414(a1);
LABEL_11:

}

void sub_100064414(char *a1, uint64_t a2)
{
  void **v2;
  int v3;
  char *v4;
  id v5;
  void *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  id v12;
  uint64_t v13;
  void *v14;
  void *v15;
  id v16;
  id v17;
  id v18;
  id v19;
  id v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  int v25;
  uint64_t v26;
  void *v27;
  id v28;
  void *v29;
  int IsLevelEnabled;
  uint64_t v31;
  void *v32;
  int v33;
  uint64_t v34;
  id v35;
  int v36;
  id v37;
  int *v38;
  uint64_t v39;
  id v40;
  void *v41;
  int v42;
  uint64_t v43;
  void *v44;
  int v45;
  uint64_t v46;
  void *v47;
  id v48;
  id String;

  if (a1)
  {
    v2 = (void **)a1;
    v3 = a1[112];
    if ((v3 - 1) < 2)
    {
      if (v3 == 1)
      {
        objc_opt_self(NRIKEv2Listener);
        if (qword_1001E44D8 != -1)
          dispatch_once(&qword_1001E44D8, &stru_1001B5E70);
        String = (id)qword_1001E44D0;
        v4 = (char *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "localInterfaceName"));
        v5 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "localOuterEndpoint"));
        sub_10001013C((uint64_t)String, v2, v4, v5);
        goto LABEL_7;
      }
      if (v3 == 2)
      {
        if (*(_QWORD *)(a1 + 231))
          return;
        String = (id)NRDataProtectionClassCreateString(4);
        if (*((unsigned __int8 *)v2 + 16) == 255)
        {
          v29 = (void *)_NRCopyLogObjectForNRUUID(v2[4], v9);
          IsLevelEnabled = _NRLogIsLevelEnabled(v29, 0);

          if (!IsLevelEnabled)
            goto LABEL_11;
          v4 = (char *)_NRCopyLogObjectForNRUUID(v2[4], v31);
          v5 = objc_msgSend(v2, "copyDescription");
          _NRLogWithArgs(v4, 0, "%s%.30s:%-4d %@: Not starting %@ initiator session because cancelled", "", "-[NRLinkFixedInterface setupIPsecIfNecessary:]", 484, v5, String);
          goto LABEL_7;
        }
        v10 = sub_10012FFF4((uint64_t)NRDLocalDevice, v2[4]);
        v4 = v10;
        if (v10)
        {
          v12 = *((id *)v10 + 9);

          if (v12)
          {
            v5 = sub_100112198();
            objc_msgSend(v5, "setRandomizeLocalPort:", 1);
            v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "localInterfaceName"));
            objc_msgSend(v5, "setOutgoingInterfaceName:", v14);

            v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "remoteOuterEndpoint"));
            objc_msgSend(v5, "setRemoteEndpoint:", v15);

            objc_msgSend(v5, "setRequestChildlessSA:", objc_msgSend(v2, "hasCompanionDatapath") ^ 1);
            v16 = sub_100112798(1, v4, 4);
            objc_msgSend(v2, "invalidateIKESessionForClass:", 4);
            v17 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("terminus-FixedInterface-%@"), String);
            v18 = objc_alloc((Class)NEIKEv2Session);
            v19 = sub_100112420();
            objc_msgSend(v19, "setMode:", 2);
            objc_msgSend(v19, "setReplayWindowSize:", 4);
            v20 = objc_msgSend(v18, "initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:kernelSASessionName:packetDelegate:", v5, v19, v16, v2[1], objc_msgSend(v2, "virtualInterface"), 0, v17, 0);
            v21 = *(void **)((char *)v2 + 231);
            *(void **)((char *)v2 + 231) = v20;

            if (*(void **)((char *)v2 + 231))
            {
              objc_msgSend(v2, "reportEvent:detailsFormat:", 3015, CFSTR("%@ %@"), String, *(void **)((char *)v2 + 231));
              sub_100062E74(v2);
              v24 = (void *)_NRCopyLogObjectForNRUUID(v2[4], v23);
              v25 = _NRLogIsLevelEnabled(v24, 0);

              if (v25)
              {
                v27 = (void *)_NRCopyLogObjectForNRUUID(v2[4], v26);
                v28 = objc_msgSend(v2, "copyDescription");
                _NRLogWithArgs(v27, 0, "%s%.30s:%-4d %@: Connecting initiator %@ session %@", "", "-[NRLinkFixedInterface setupIPsecIfNecessary:]", 522, v28, String, *(void **)((char *)v2 + 231));

              }
              objc_msgSend(*(void **)((char *)v2 + 231), "connect", String);
            }
            else
            {
              v44 = (void *)_NRCopyLogObjectForNRUUID(v2[4], v22);
              v45 = _NRLogIsLevelEnabled(v44, 17);

              if (v45)
              {
                v47 = (void *)_NRCopyLogObjectForNRUUID(v2[4], v46);
                v48 = objc_msgSend(v2, "copyDescription");
                _NRLogWithArgs(v47, 17, "%@: Failed to create initiator %@ IKE session", v48, String);

              }
            }

          }
          else
          {
            v32 = (void *)_NRCopyLogObjectForNRUUID(v2[4], v13);
            v33 = _NRLogIsLevelEnabled(v32, 0);

            if (!v33)
              goto LABEL_10;
            v5 = (id)_NRCopyLogObjectForNRUUID(v2[4], v34);
            v16 = objc_msgSend(v2, "copyDescription");
            _NRLogWithArgs(v5, 0, "%s%.30s:%-4d %@: Not starting %@ IKE initiator session because we do not have keys %@", "", "-[NRLinkFixedInterface setupIPsecIfNecessary:]", 493, v16, String, v4);
          }
          goto LABEL_27;
        }
      }
      else
      {
        v35 = sub_100062CF4();
        v36 = _NRLogIsLevelEnabled(v35, 16);

        if (v36)
        {
          v37 = sub_100062CF4();
          _NRLogWithArgs(v37, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: _ikev2Role == NRIKEv2RoleInitiator", "", "-[NRLinkFixedInterface setupIPsecIfNecessary:]", 477);

        }
        v4 = (char *)_os_log_pack_size(12);
        v2 = (id *)((char *)&String - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0));
        v38 = __error();
        v39 = _os_log_pack_fill(v2, v4, *v38, &_mh_execute_header, "%{public}s Assertion Failed: _ikev2Role == NRIKEv2RoleInitiator");
        *(_DWORD *)v39 = 136446210;
        *(_QWORD *)(v39 + 4) = "-[NRLinkFixedInterface setupIPsecIfNecessary:]";
        v40 = sub_100062CF4();
        _NRLogAbortWithPack(v40, v2);
      }
      v41 = (void *)_NRCopyLogObjectForNRUUID(v2[4], v11);
      v42 = _NRLogIsLevelEnabled(v41, 17);

      if (!v42)
      {
        v4 = 0;
        goto LABEL_10;
      }
      v5 = (id)_NRCopyLogObjectForNRUUID(v2[4], v43);
      v16 = objc_msgSend(v2, "copyDescription");
      _NRLogWithArgs(v5, 17, "%@: Not starting %@ IKE initiator session because localDevice is missing", v16, String);
LABEL_27:

LABEL_7:
LABEL_10:

LABEL_11:
      return;
    }
    v6 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)a1 + 4), a2);
    v7 = _NRLogIsLevelEnabled(v6, 17);

    if (v7)
    {
      String = (id)_NRCopyLogObjectForNRUUID(v2[4], v8);
      v4 = (char *)objc_msgSend(v2, "copyDescription");
      _NRLogWithArgs(String, 17, "%@: Unsupported ikev2 role %u", v4, *((unsigned __int8 *)v2 + 112));
      goto LABEL_10;
    }
  }
}

uint64_t sub_100064A94(uint64_t result, int a2)
{
  id v2;
  int IsLevelEnabled;
  id v4;
  void *String;
  uint64_t v6;
  char *v7;
  int *v8;
  uint64_t v9;
  uint64_t v10;
  id v11;
  uint64_t v12;

  if (result)
  {
    if (a2 != 4)
    {
      HIDWORD(v12) = a2;
      v2 = sub_100062CF4();
      IsLevelEnabled = _NRLogIsLevelEnabled(v2, 16);

      if (IsLevelEnabled)
      {
        v4 = sub_100062CF4();
        String = (void *)NRDataProtectionClassCreateString(HIDWORD(v12));
        _NRLogWithArgs(v4, 16, "%s%.30s:%-4d ABORTING: Cannot copy IKE session pointer for %@", "", "-[NRLinkFixedInterface ikeSessionPointerForDataProtectionClass:]", 232, String);

      }
      v6 = _os_log_pack_size(22);
      v7 = (char *)&v12 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
      v8 = __error();
      v9 = _os_log_pack_fill(v7, v6, *v8, &_mh_execute_header, "%{public}s Cannot copy IKE session pointer for %@");
      v10 = NRDataProtectionClassCreateString(HIDWORD(v12));
      *(_DWORD *)v9 = 136446466;
      *(_QWORD *)(v9 + 4) = "-[NRLinkFixedInterface ikeSessionPointerForDataProtectionClass:]";
      *(_WORD *)(v9 + 12) = 2112;
      *(_QWORD *)(v9 + 14) = v10;
      v11 = sub_100062CF4();
      _NRLogAbortWithPack(v11, v7);
    }
    result += 231;
  }
  return result;
}

void sub_100064BEC(uint64_t a1, void *a2)
{
  _QWORD *WeakRetained;
  _QWORD *v4;
  unsigned int v5;
  uint64_t v6;
  void *v7;
  int IsLevelEnabled;
  uint64_t v9;
  void *v10;
  id v11;
  NSObject *path;

  path = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v4 = WeakRetained;
  if (WeakRetained)
  {
    v5 = objc_msgSend(WeakRetained, "state");
    if (path)
    {
      if (v5 != 255 && nw_path_get_status(path) == nw_path_status_satisfied)
      {
        v7 = (void *)_NRCopyLogObjectForNRUUID(v4[4], v6);
        IsLevelEnabled = _NRLogIsLevelEnabled(v7, 0);

        if (IsLevelEnabled)
        {
          v10 = (void *)_NRCopyLogObjectForNRUUID(v4[4], v9);
          v11 = objc_msgSend(v4, "copyDescription");
          _NRLogWithArgs(v10, 0, "%s%.30s:%-4d %@: Restarting IKE session as path is satisfied", "", "-[NRLinkFixedInterface start]_block_invoke", 182, v11);

        }
        sub_100064414((char *)v4, v9);
      }
    }
  }

}

void sub_100064F40(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  int IsLevelEnabled;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  void *v19;
  void *v20;
  uint64_t v21;
  void *v22;
  void *v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  id v33;
  uint64_t v34;
  void *v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  id v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  int v46;
  uint64_t v47;
  _QWORD *v48;
  _QWORD *v49;
  uint64_t v50;
  void *v51;
  _QWORD *v52;
  _QWORD *v53;
  id v54;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  void *v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  void *v64;
  id WeakRetained;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2 && *(_BYTE *)(v2 + 14))
  {
    if (*(_DWORD *)(v2 + 16))
    {
      WeakRetained = objc_loadWeakRetained((id *)(v2 + 64));
      v5 = *(_QWORD *)(a1 + 32);
      if (v5 && (--*(_DWORD *)(v5 + 16), (v6 = *(_QWORD *)(a1 + 32)) != 0))
        v7 = *(_QWORD *)(v6 + 40);
      else
        v7 = 0;
      v8 = (void *)_NRCopyLogObjectForNRUUID(v7, v4);
      IsLevelEnabled = _NRLogIsLevelEnabled(v8, 0);

      if (IsLevelEnabled)
      {
        v10 = *(_QWORD **)(a1 + 32);
        if (v10)
          v10 = (_QWORD *)v10[5];
        v11 = v10;
        v13 = _NRCopyLogObjectForNRUUID(v11, v12);
        v14 = (void *)v13;
        v15 = *(_QWORD *)(a1 + 32);
        if (v15)
          LODWORD(v15) = *(_DWORD *)(v15 + 16);
        _NRLogWithArgs(v13, 0, "%s%.30s:%-4d Link preferences agent un-asserted (Total remaining assertions: %u)", "", "-[NRBTLinkPreferencesAgent unassertAgentWithOptions:]_block_invoke", 220, v15);

      }
      v16 = *(_QWORD *)(a1 + 32);
      if (!v16 || !*(_DWORD *)(v16 + 16))
        objc_msgSend(WeakRetained, "deviceHasBTLinkUpgradeRequest:", 0);
      v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "objectForKeyedSubscript:", NWNetworkAgentStartOptionClientUUID));
      if (v17)
      {
        v18 = *(_QWORD *)(a1 + 32);
        v19 = v18 ? *(void **)(v18 + 80) : 0;
        v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "objectForKeyedSubscript:", v17));

        if (v20)
        {
          v21 = *(_QWORD *)(a1 + 32);
          if (v21)
            v22 = *(void **)(v21 + 80);
          else
            v22 = 0;
          v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "objectForKeyedSubscript:", v17));
          v24 = *(_QWORD *)(a1 + 32);
          if (v24)
            v25 = *(void **)(v24 + 88);
          else
            v25 = 0;
          if (objc_msgSend(v25, "countForObject:", v17))
          {
            v26 = *(_QWORD *)(a1 + 32);
            v27 = v26 ? *(void **)(v26 + 88) : 0;
            objc_msgSend(v27, "removeObject:", v17);
            v28 = *(_QWORD *)(a1 + 32);
            v29 = v28 ? *(void **)(v28 + 88) : 0;
            if (!objc_msgSend(v29, "countForObject:", v17))
            {
              v30 = *(_QWORD *)(a1 + 32);
              if (v30)
                v31 = *(void **)(v30 + 80);
              else
                v31 = 0;
              objc_msgSend(v31, "setObject:forKeyedSubscript:", 0, v17);
              objc_msgSend(WeakRetained, "reportBTLinkUpgradeClientRemoved:", v23);
            }
          }

        }
      }
      v32 = *(_QWORD *)(a1 + 32);
      if (v32)
      {
        if (*(_DWORD *)(v32 + 16))
          goto LABEL_63;
        v32 = *(_QWORD *)(v32 + 88);
      }
      v33 = (id)v32;
      if (objc_msgSend(v33, "count"))
      {

LABEL_47:
        v43 = *(_QWORD *)(a1 + 32);
        if (v43)
          v44 = *(_QWORD *)(v43 + 40);
        else
          v44 = 0;
        v45 = (void *)_NRCopyLogObjectForNRUUID(v44, v34);
        v46 = _NRLogIsLevelEnabled(v45, 16);

        if (v46)
        {
          v48 = *(_QWORD **)(a1 + 32);
          if (v48)
            v48 = (_QWORD *)v48[5];
          v49 = v48;
          v51 = (void *)_NRCopyLogObjectForNRUUID(v49, v50);
          v52 = *(_QWORD **)(a1 + 32);
          if (v52)
            v52 = (_QWORD *)v52[11];
          v53 = v52;
          v54 = objc_msgSend(v53, "count");
          v55 = *(_QWORD *)(a1 + 32);
          if (v55)
            v56 = *(void **)(v55 + 80);
          else
            v56 = 0;
          _NRLogWithArgs(v51, 16, "%s%.30s:%-4d non-empty client dictionaries without valid agent assert count (%zu/%zu)", "", "-[NRBTLinkPreferencesAgent unassertAgentWithOptions:]_block_invoke", 239, (size_t)v54, (size_t)objc_msgSend(v56, "count"));

        }
        v57 = *(_QWORD *)(a1 + 32);
        if (v57)
          v58 = *(_QWORD *)(v57 + 40);
        else
          v58 = 0;
        v59 = (void *)_NRCopyLogObjectForNRUUID(v58, v47);
        v60 = _NRLogIsLevelEnabled(v59, 17);

        if (v60)
        {
          v62 = *(_QWORD *)(a1 + 32);
          if (v62)
            v63 = *(_QWORD *)(v62 + 40);
          else
            v63 = 0;
          v64 = (void *)_NRCopyLogObjectForNRUUID(v63, v61);
          _NRLogWithArgs(v64, 17, "non-empty client dictionaries without valid agent assert count");

        }
        goto LABEL_63;
      }
      v40 = *(_QWORD *)(a1 + 32);
      if (v40)
        v41 = *(void **)(v40 + 80);
      else
        v41 = 0;
      v42 = objc_msgSend(v41, "count");

      if (v42)
        goto LABEL_47;
LABEL_63:

LABEL_64:
      return;
    }
    v35 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v2 + 40), a2);
    v36 = _NRLogIsLevelEnabled(v35, 17);

    if (v36)
    {
      v38 = *(_QWORD *)(a1 + 32);
      if (v38)
        v39 = *(_QWORD *)(v38 + 40);
      else
        v39 = 0;
      WeakRetained = (id)_NRCopyLogObjectForNRUUID(v39, v37);
      _NRLogWithArgs(WeakRetained, 17, "Received an unexpected unassertAgent call");
      goto LABEL_64;
    }
  }
}

void sub_100065334(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  int IsLevelEnabled;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  id v19;
  void *v20;
  id v21;
  id v22;
  uint64_t v23;
  void *v24;
  void *v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  void *v33;
  id v34;
  uint64_t pid;
  id v36;
  int v37;
  id WeakRetained;

  v1 = *(_QWORD *)(a1 + 32);
  if (v1 && *(_BYTE *)(v1 + 14))
  {
    WeakRetained = objc_loadWeakRetained((id *)(v1 + 64));
    v4 = *(_QWORD *)(a1 + 32);
    if (!v4 || (v5 = *(_DWORD *)(v4 + 16)) == 0)
    {
      objc_msgSend(WeakRetained, "deviceHasBTLinkUpgradeRequest:", 1);
      v4 = *(_QWORD *)(a1 + 32);
      if (!v4)
        goto LABEL_51;
      v5 = *(_DWORD *)(v4 + 16);
    }
    *(_DWORD *)(v4 + 16) = v5 + 1;
    v6 = *(_QWORD *)(a1 + 32);
    if (v6)
    {
      v7 = *(_QWORD *)(v6 + 40);
      goto LABEL_9;
    }
LABEL_51:
    v7 = 0;
LABEL_9:
    v8 = (void *)_NRCopyLogObjectForNRUUID(v7, v3);
    IsLevelEnabled = _NRLogIsLevelEnabled(v8, 0);

    if (IsLevelEnabled)
    {
      v10 = *(_QWORD **)(a1 + 32);
      if (v10)
        v10 = (_QWORD *)v10[5];
      v11 = v10;
      v13 = _NRCopyLogObjectForNRUUID(v11, v12);
      v14 = (void *)v13;
      v15 = *(_QWORD *)(a1 + 32);
      if (v15)
        LODWORD(v15) = *(_DWORD *)(v15 + 16);
      _NRLogWithArgs(v13, 0, "%s%.30s:%-4d Link preferences agent asserted (Total active assertions: %u)", "", "-[NRBTLinkPreferencesAgent assertAgentWithOptions:]_block_invoke", 186, v15);

    }
    v16 = NWNetworkAgentStartOptionClientUUID;
    v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "objectForKeyedSubscript:", NWNetworkAgentStartOptionClientUUID));
    v18 = *(_QWORD *)(a1 + 32);
    v19 = *(id *)(a1 + 40);
    v20 = v19;
    if (v18)
    {
      if (v19)
      {
        v21 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "objectForKeyedSubscript:", NWNetworkAgentStartOptionPID));
        if (v21)
          goto LABEL_18;
        v22 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "objectForKeyedSubscript:", v16));
        if (!v22)
        {
          v21 = 0;
          goto LABEL_19;
        }
        v32 = (void *)objc_claimAutoreleasedReturnValue(+[NWPath pathForClientID:](NWPath, "pathForClientID:", v22));
        v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v32, "parameters"));
        v34 = objc_msgSend(v33, "copyCParameters");

        if (v34 && (pid = nw_parameters_get_pid(v34), (int)pid >= 1))
          v21 = (id)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", pid));
        else
          v21 = 0;

        if (v21)
LABEL_18:
          v22 = sub_100109ADC((uint64_t)objc_msgSend(v21, "intValue"), 0);
        else
          v22 = 0;
LABEL_19:

        if (v22 && v17)
        {
          v23 = *(_QWORD *)(a1 + 32);
          if (v23)
            v24 = *(void **)(v23 + 80);
          else
            v24 = 0;
          v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v24, "objectForKeyedSubscript:", v17));

          if (!v25)
          {
            v26 = *(_QWORD *)(a1 + 32);
            if (v26)
              v27 = *(void **)(v26 + 80);
            else
              v27 = 0;
            objc_msgSend(v27, "setObject:forKeyedSubscript:", v22, v17);
          }
          v28 = *(_QWORD *)(a1 + 32);
          if (v28)
            v29 = *(void **)(v28 + 88);
          else
            v29 = 0;
          if (!objc_msgSend(v29, "countForObject:", v17))
            objc_msgSend(WeakRetained, "reportBTLinkUpgradeClientAdded:", v22);
          v30 = *(_QWORD *)(a1 + 32);
          if (v30)
            v31 = *(void **)(v30 + 88);
          else
            v31 = 0;
          objc_msgSend(v31, "addObject:", v17);
        }
        goto LABEL_34;
      }
      v36 = sub_100065674();
      v37 = _NRLogIsLevelEnabled(v36, 17);

      if (v37)
      {
        v21 = sub_100065674();
        _NRLogWithArgs(v21, 17, "%s called with null options", "-[NRBTLinkPreferencesAgent retrieveClientNameFromOptions:]");
        v22 = 0;
        goto LABEL_19;
      }
    }
    v22 = 0;

LABEL_34:
  }
}

id sub_100065674()
{
  if (qword_1001E4660 != -1)
    dispatch_once(&qword_1001E4660, &stru_1001B69B0);
  return (id)qword_1001E4658;
}

void sub_1000656B4(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001E4658;
  qword_1001E4658 = (uint64_t)v1;

}

void sub_1000656E4(uint64_t a1)
{
  id v2;
  id v3;
  id *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  int IsLevelEnabled;
  uint64_t v11;
  void *v12;
  void *v13;
  id v14;
  void *v15;
  uint64_t v16;
  id v17;

  if (a1 && *(_BYTE *)(a1 + 14))
  {
    objc_opt_self(NRDPolicySessionManager);
    if (qword_1001E4A20 != -1)
      dispatch_once(&qword_1001E4A20, &stru_1001B8590);
    v2 = (id)qword_1001E4A18;
    sub_100127618((uint64_t)v2, *(void **)(a1 + 72));

    objc_opt_self(NRDPolicySessionManager);
    if (qword_1001E4A20 != -1)
      dispatch_once(&qword_1001E4A20, &stru_1001B8590);
    v3 = (id)qword_1001E4A18;
    v4 = (id *)v3;
    if (v3)
    {
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v3 + 1));
      if ((objc_msgSend(v4[2], "apply") & 1) == 0)
        sub_100109270(CFSTR("NRPolicySessionManager"), CFSTR("ApplyPolicy Failed"), 0, 1, CFSTR("Failed to apply policies"), v5, v6, v7, v16);
    }

    if ((objc_msgSend(*(id *)(a1 + 56), "unregisterNetworkAgent") & 1) == 0)
    {
      v9 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 40), v8);
      IsLevelEnabled = _NRLogIsLevelEnabled(v9, 17);

      if (IsLevelEnabled)
      {
        v12 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 40), v11);
        _NRLogWithArgs(v12, 17, "Failed to unregister BTLinkPreferences agent");

      }
    }
    v13 = *(void **)(a1 + 56);
    *(_QWORD *)(a1 + 56) = 0;

    *(_BYTE *)(a1 + 14) = 0;
    v14 = *(id *)(a1 + 40);
    v17 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "agentUUID"));
    v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "UUIDString"));
    sub_100121E18(v14, 18003, 0, v15);

  }
}

id *sub_100065914(id *a1, void *a2, void *a3, void *a4)
{
  id v8;
  id v9;
  id v10;
  id *v11;
  void *v12;
  id v13;
  void *v14;
  void *v15;
  id v16;
  id v17;
  id v18;
  id v19;
  id v20;
  id v21;
  id v22;
  void *v23;
  void *v24;
  id v26;
  int IsLevelEnabled;
  id v28;
  uint64_t v29;
  char *v30;
  int *v31;
  uint64_t v32;
  id v33;
  uint64_t v34;
  objc_super v35;

  v8 = a2;
  v9 = a3;
  v10 = a4;
  if (a1)
  {
    v35.receiver = a1;
    v35.super_class = (Class)NRBTLinkPreferencesAgent;
    v11 = (id *)objc_msgSendSuper2(&v35, "init");
    if (!v11)
    {
      v26 = sub_100065674();
      IsLevelEnabled = _NRLogIsLevelEnabled(v26, 16);

      if (IsLevelEnabled)
      {
        v28 = sub_100065674();
        _NRLogWithArgs(v28, 16, "%s%.30s:%-4d ABORTING: [super init] failed", "", "-[NRBTLinkPreferencesAgent initWithNRUUID:queue:delegate:]", 41);

      }
      v29 = _os_log_pack_size(12);
      v30 = (char *)&v34 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0);
      v31 = __error();
      v32 = _os_log_pack_fill(v30, v29, *v31, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)v32 = 136446210;
      *(_QWORD *)(v32 + 4) = "-[NRBTLinkPreferencesAgent initWithNRUUID:queue:delegate:]";
      v33 = sub_100065674();
      _NRLogAbortWithPack(v33, v30);
    }
    a1 = v11;
    objc_storeStrong(v11 + 6, a3);
    objc_storeStrong(a1 + 5, a2);
    v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](NSUUID, "UUID"));
    objc_msgSend(a1, "setAgentUUID:", v12);

    objc_msgSend(a1, "setUserActivated:", 1);
    objc_msgSend(a1, "setAgentDescription:", CFSTR("Link preferences netagent"));
    objc_storeWeak(a1 + 8, v10);
    v13 = objc_alloc((Class)NSString);
    v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "agentUUID"));
    v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "UUIDString"));
    v16 = objc_msgSend(v13, "initWithFormat:", CFSTR("NRBTLinkPreferencesAgent-%@"), v15);
    v17 = a1[9];
    a1[9] = v16;

    v18 = objc_alloc_init((Class)NSMutableDictionary);
    v19 = a1[10];
    a1[10] = v18;

    v20 = objc_alloc_init((Class)NSCountedSet);
    v21 = a1[11];
    a1[11] = v20;

    v22 = a1[5];
    v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "agentUUID"));
    v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v23, "UUIDString"));
    sub_100121E18(v22, 18001, 0, v24);

  }
  return a1;
}

void sub_100065BCC()
{
  NSObject *v0;
  uint64_t v1;
  void *v2;
  void *v3;
  unsigned __int8 v4;
  id v5;

  v0 = sub_10014CFBC();
  dispatch_assert_queue_V2(v0);

  if (!qword_1001E4668)
  {
    v1 = os_transaction_create("com.apple.terminusd.keepalive");
    v2 = (void *)qword_1001E4668;
    qword_1001E4668 = v1;

  }
  v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](NSFileManager, "defaultManager"));
  v4 = objc_msgSend(v3, "fileExistsAtPath:", CFSTR("/var/mobile/Library/terminus/com.apple.terminusd.keepalive"));

  if ((v4 & 1) == 0)
  {
    sub_100107290(CFSTR("/var/mobile/Library/terminus/com.apple.terminusd.keepalive"), 0, 0);
    if (qword_1001E4678 != -1)
      dispatch_once(&qword_1001E4678, &stru_1001B6A30);
    if (_NRLogIsLevelEnabled(qword_1001E4670, 0))
    {
      if (qword_1001E4678 != -1)
        dispatch_once(&qword_1001E4678, &stru_1001B6A30);
      _NRLogWithArgs(qword_1001E4670, 0, "%s%.30s:%-4d new keepalive file added", "", "terminusdKeepAliveEnable", 37);
    }
  }
  objc_opt_self(NRDKeyManager);
  if (qword_1001E4AD8 != -1)
    dispatch_once(&qword_1001E4AD8, &stru_1001B8968);
  v5 = (id)qword_1001E4AD0;
  sub_10014ACE0((uint64_t)v5, &stru_1001B6A10);

}

void sub_100065D44(id a1)
{
  sub_100107D4C(CFSTR("/var/mobile/Library/terminus/com.apple.terminusd.keepalive"));
}

void sub_100065D50(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001E4670;
  qword_1001E4670 = (uint64_t)v1;

}

void sub_100065D80(id a1)
{
  NSObject *v1;
  dispatch_time_t v2;
  NSObject *v3;

  if (sub_10009FF34((uint64_t)a1) && sub_100137894((uint64_t)NRDLocalDevice))
  {
    sub_100065BCC();
  }
  else
  {
    v1 = sub_10014CFBC();
    dispatch_assert_queue_V2(v1);

    if ((byte_1001E4680 & 1) == 0)
    {
      byte_1001E4680 = 1;
      v2 = dispatch_time(0, 2000000000);
      v3 = sub_10014CFBC();
      dispatch_after(v2, v3, &stru_1001B6A50);

    }
  }
}

void sub_100065E30(id a1)
{
  NSObject *v1;
  uint64_t v2;
  id v3;
  void *v4;
  void *v5;
  unsigned __int8 v6;
  id v7;
  id v8;
  void *v9;
  void *v10;
  unsigned __int8 v11;
  id v12;

  v1 = sub_10014CFBC();
  dispatch_assert_queue_V2(v1);

  byte_1001E4680 = 0;
  if (!sub_10009FF34(v2) || (sub_100137894((uint64_t)NRDLocalDevice) & 1) == 0)
  {
    v3 = (id)qword_1001E4668;
    v4 = (void *)qword_1001E4668;
    qword_1001E4668 = 0;

    ne_session_clear_caches();
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](NSFileManager, "defaultManager"));
    v12 = 0;
    v6 = objc_msgSend(v5, "removeItemAtPath:error:", CFSTR("/var/mobile/Library/terminus/com.apple.terminusd.keepalive"), &v12);
    v7 = v12;

    if ((v6 & 1) == 0)
    {
      v8 = v7;
      v9 = v8;
      if (v8 && objc_msgSend(v8, "code") == (id)4)
      {
        v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "domain"));
        v11 = objc_msgSend(v10, "isEqualToString:", NSCocoaErrorDomain);

        if ((v11 & 1) != 0)
          goto LABEL_15;
      }
      else
      {

      }
      if (qword_1001E4678 != -1)
        dispatch_once(&qword_1001E4678, &stru_1001B6A30);
      if (_NRLogIsLevelEnabled(qword_1001E4670, 17))
      {
        if (qword_1001E4678 != -1)
          dispatch_once(&qword_1001E4678, &stru_1001B6A30);
        _NRLogWithArgs(qword_1001E4670, 17, "Deleting empty keep alive file \"%s\" failed: %@", "/var/mobile/Library/terminus/com.apple.terminusd.keepalive", v9);
      }
    }
LABEL_15:

  }
}

void sub_100066C24(uint64_t a1)
{
  id WeakRetained;
  void *v3;
  unsigned __int8 v4;
  void *v5;
  void *v6;
  id v7;
  NRAnalyticsALUAdviceAggregateStats *v8;
  id v9;
  double v10;
  double v11;
  double v12;
  id v13;
  double v14;
  double v15;
  double v16;
  id v17;
  double v18;
  double v19;
  double v20;
  id v21;
  void *v22;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v3 = WeakRetained;
  if (WeakRetained)
  {
    v22 = WeakRetained;
    v4 = objc_msgSend(WeakRetained, "cancelled");
    v3 = v22;
    if ((v4 & 1) == 0)
    {
      v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "aggregateStatsTimerSource"));
      v6 = *(void **)(a1 + 32);

      v3 = v22;
      if (v5 == v6)
      {
        v7 = objc_msgSend(v22, "totalReceivedUpdates");
        v3 = v22;
        if (v7)
        {
          v8 = objc_alloc_init(NRAnalyticsALUAdviceAggregateStats);
          v9 = objc_msgSend(v22, "totalReceivedUpdates");
          if (v8)
          {
            v8->_totalAdviceCount = (unint64_t)v9;
            v8->_totalAdviceCountForWiFi = (unint64_t)objc_msgSend(v22, "totalCountForWiFiAdvice");
            v8->_totalAdviceCountForBTClassic = (unint64_t)objc_msgSend(v22, "totalCountForBTClassicAdvice");
          }
          else
          {
            objc_msgSend(v22, "totalCountForWiFiAdvice");
            objc_msgSend(v22, "totalCountForBTClassicAdvice");
          }
          objc_msgSend(v22, "totalDurationForWiFiAdvice");
          if (v10 > 0.0)
          {
            if (objc_msgSend(v22, "totalCountForWiFiAdvice"))
            {
              objc_msgSend(v22, "totalDurationForWiFiAdvice");
              v12 = v11;
              v13 = objc_msgSend(v22, "totalCountForWiFiAdvice");
              if (v8)
                v8->_avgDurationForWiFiAdvice = v12 / (double)(unint64_t)v13;
            }
          }
          objc_msgSend(v22, "totalDurationForBTClassicAdvice");
          if (v14 > 0.0)
          {
            if (objc_msgSend(v22, "totalCountForBTClassicAdvice"))
            {
              objc_msgSend(v22, "totalDurationForBTClassicAdvice");
              v16 = v15;
              v17 = objc_msgSend(v22, "totalCountForBTClassicAdvice");
              if (v8)
                v8->_avgDurationForBTClassicAdvice = v16 / (double)(unint64_t)v17;
            }
          }
          objc_msgSend(v22, "totalIntervalForNonDefaultAdvice");
          if (v18 > 0.0)
          {
            if (objc_msgSend(v22, "totalCountForNonDefaultAdvice"))
            {
              objc_msgSend(v22, "totalIntervalForNonDefaultAdvice");
              v20 = v19;
              v21 = objc_msgSend(v22, "totalCountForNonDefaultAdvice");
              if (v8)
                v8->_avgIntervalForNonDefaultAdvice = v20 / (double)(unint64_t)v21;
            }
          }
          -[NRAnalyticsALUAdviceAggregateStats submit](v8, "submit");
          objc_msgSend(v22, "setTotalReceivedUpdates:", 0);
          objc_msgSend(v22, "setTotalCountForWiFiAdvice:", 0);
          objc_msgSend(v22, "setTotalDurationForWiFiAdvice:", 0.0);
          objc_msgSend(v22, "setTotalCountForBTClassicAdvice:", 0);
          objc_msgSend(v22, "setTotalDurationForBTClassicAdvice:", 0.0);
          objc_msgSend(v22, "setTotalCountForNonDefaultAdvice:", 0);
          objc_msgSend(v22, "setTotalIntervalForNonDefaultAdvice:", 0.0);

          v3 = v22;
        }
      }
    }
  }

}

void sub_100066E48(uint64_t a1)
{
  id WeakRetained;
  void *v3;
  unsigned __int8 v4;
  void *v5;
  void *v6;
  id v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v3 = WeakRetained;
  if (WeakRetained)
  {
    v11 = WeakRetained;
    v4 = objc_msgSend(WeakRetained, "cancelled");
    v3 = v11;
    if ((v4 & 1) == 0)
    {
      v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "wifiAdviceMonitorTimerSource"));
      v6 = *(void **)(a1 + 32);

      v3 = v11;
      if (v5 == v6)
      {
        v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("Advice exceeds %u seconds"));
        sub_100109270(CFSTR("NRAutoLinkUpgrade"), CFSTR("WiFiAdvice"), v7, 0, 0, v8, v9, v10, 1800);

        v3 = v11;
      }
    }
  }

}

uint64_t sub_100066F00(void *a1, char a2)
{
  _BYTE *v3;
  uint64_t v4;
  __objc2_class *v5;
  const char *v6;
  _DWORD *v7;
  unsigned int v8;
  char v9;
  char v10;
  char v11;
  char v12;
  int v13;
  char v14;
  unsigned __int8 *v15;
  int v16;
  id v18;
  int IsLevelEnabled;
  id v20;
  int *v21;
  uint64_t v22;
  id v23;
  objc_super v24;
  int v25;

  if (!a1)
    return 0;
  v24.receiver = a1;
  v24.super_class = (Class)NRLinkUpgradeReport;
  v3 = objc_msgSendSuper2(&v24, "init");
  if (!v3)
  {
    v18 = sub_100067170();
    IsLevelEnabled = _NRLogIsLevelEnabled(v18, 16);

    v6 = "-[NRLinkUpgradeReport initWithUpgradeType:]";
    if (IsLevelEnabled)
    {
      v20 = sub_100067170();
      _NRLogWithArgs(v20, 16, "%s%.30s:%-4d ABORTING: [super init] failed", "", "-[NRLinkUpgradeReport initWithUpgradeType:]", 226);

    }
    v4 = _os_log_pack_size(12);
    v5 = (__objc2_class *)((char *)&v24 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0));
    v21 = __error();
    v22 = _os_log_pack_fill(v5, v4, *v21, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)v22 = 136446210;
    *(_QWORD *)(v22 + 4) = "-[NRLinkUpgradeReport initWithUpgradeType:]";
    v23 = sub_100067170();
    _NRLogAbortWithPack(v23, v5);
    goto LABEL_30;
  }
  v4 = (uint64_t)v3;
  v3[8] = a2;
  v5 = &OBJC_METACLASS___NRAnalyticsLocalDevice;
  objc_opt_self(NRLinkDirector);
  v6 = (const char *)&OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
  if (qword_1001E4710 != -1)
LABEL_30:
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v7 = (id)qword_1001E4708;
  if (v7)
  {
    v8 = v7[5];

    if (v8 >= 0x29)
      v9 = 50;
    else
      v9 = 40;
    if (v8 >= 0x1F)
      v10 = v9;
    else
      v10 = 30;
    if (v8 >= 0x15)
      v11 = v10;
    else
      v11 = 20;
    if (v8 >= 0xB)
      v12 = v11;
    else
      v12 = 10;
    if (!v8)
      v12 = 0;
  }
  else
  {
    v12 = 0;
  }
  *(_BYTE *)(v4 + 9) = v12;
  v25 = 0;
  v13 = IOPSGetPercentRemaining(&v25, 0, 0);
  v14 = v25;
  if (v13)
    v14 = 0;
  *(_BYTE *)(v4 + 10) = v14;
  objc_opt_self(&v5[45]);
  if (*((_QWORD *)v6 + 226) != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v15 = (unsigned __int8 *)(id)qword_1001E4708;
  if (v15)
  {
    v16 = v15[11];

    if (v16)
      *(_DWORD *)(v4 + 16) |= 0x20u;
  }
  return v4;
}

id sub_100067170()
{
  if (qword_1001E4690 != -1)
    dispatch_once(&qword_1001E4690, &stru_1001B6A70);
  return (id)qword_1001E4688;
}

void sub_1000671B0(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001E4688;
  qword_1001E4688 = (uint64_t)v1;

}

__CFString *sub_1000671E0(uint64_t a1)
{
  id v2;
  void *v3;
  __CFString *v4;

  v2 = objc_alloc_init((Class)NSMutableArray);
  v3 = v2;
  if ((a1 & 0x100) != 0)
  {
    objc_msgSend(v2, "addObject:", CFSTR("TxSml"));
    if ((a1 & 0x200) == 0)
    {
LABEL_3:
      if ((a1 & 0x400) == 0)
        goto LABEL_4;
      goto LABEL_30;
    }
  }
  else if ((a1 & 0x200) == 0)
  {
    goto LABEL_3;
  }
  objc_msgSend(v3, "addObject:", CFSTR("TxMed"));
  if ((a1 & 0x400) == 0)
  {
LABEL_4:
    if ((a1 & 0x4000) == 0)
      goto LABEL_5;
    goto LABEL_31;
  }
LABEL_30:
  objc_msgSend(v3, "addObject:", CFSTR("TxLrg"));
  if ((a1 & 0x4000) == 0)
  {
LABEL_5:
    if ((a1 & 0x8000) == 0)
      goto LABEL_6;
    goto LABEL_32;
  }
LABEL_31:
  objc_msgSend(v3, "addObject:", CFSTR("SvcVo"));
  if ((a1 & 0x8000) == 0)
  {
LABEL_6:
    if ((a1 & 0x40000) == 0)
      goto LABEL_7;
    goto LABEL_33;
  }
LABEL_32:
  objc_msgSend(v3, "addObject:", CFSTR("SvcVi"));
  if ((a1 & 0x40000) == 0)
  {
LABEL_7:
    if ((a1 & 0x80000) == 0)
      goto LABEL_8;
    goto LABEL_34;
  }
LABEL_33:
  objc_msgSend(v3, "addObject:", CFSTR("RdPoor"));
  if ((a1 & 0x80000) == 0)
  {
LABEL_8:
    if ((a1 & 0x100000) == 0)
      goto LABEL_9;
    goto LABEL_35;
  }
LABEL_34:
  objc_msgSend(v3, "addObject:", CFSTR("RdFair"));
  if ((a1 & 0x100000) == 0)
  {
LABEL_9:
    if ((a1 & 0x200000) == 0)
      goto LABEL_10;
    goto LABEL_36;
  }
LABEL_35:
  objc_msgSend(v3, "addObject:", CFSTR("RdGood"));
  if ((a1 & 0x200000) == 0)
  {
LABEL_10:
    if ((a1 & 0x400000) == 0)
      goto LABEL_11;
    goto LABEL_37;
  }
LABEL_36:
  objc_msgSend(v3, "addObject:", CFSTR("RdBest"));
  if ((a1 & 0x400000) == 0)
  {
LABEL_11:
    if ((a1 & 0x800000) == 0)
      goto LABEL_12;
    goto LABEL_38;
  }
LABEL_37:
  objc_msgSend(v3, "addObject:", CFSTR("CngHi"));
  if ((a1 & 0x800000) == 0)
  {
LABEL_12:
    if ((a1 & 0x1000000) == 0)
      goto LABEL_13;
    goto LABEL_39;
  }
LABEL_38:
  objc_msgSend(v3, "addObject:", CFSTR("NotCngHi"));
  if ((a1 & 0x1000000) == 0)
  {
LABEL_13:
    if ((a1 & 0x2000000) == 0)
      goto LABEL_14;
    goto LABEL_40;
  }
LABEL_39:
  objc_msgSend(v3, "addObject:", CFSTR("Plgd"));
  if ((a1 & 0x2000000) == 0)
  {
LABEL_14:
    if ((a1 & 0x4000000) == 0)
      goto LABEL_15;
    goto LABEL_41;
  }
LABEL_40:
  objc_msgSend(v3, "addObject:", CFSTR("NotPlgd"));
  if ((a1 & 0x4000000) == 0)
  {
LABEL_15:
    if ((a1 & 0x8000000) == 0)
      goto LABEL_16;
    goto LABEL_42;
  }
LABEL_41:
  objc_msgSend(v3, "addObject:", CFSTR("BtryPoor"));
  if ((a1 & 0x8000000) == 0)
  {
LABEL_16:
    if ((a1 & 0x10000000) == 0)
      goto LABEL_17;
    goto LABEL_43;
  }
LABEL_42:
  objc_msgSend(v3, "addObject:", CFSTR("BtryFair"));
  if ((a1 & 0x10000000) == 0)
  {
LABEL_17:
    if ((a1 & 0x20000000) == 0)
      goto LABEL_18;
    goto LABEL_44;
  }
LABEL_43:
  objc_msgSend(v3, "addObject:", CFSTR("BtryGood"));
  if ((a1 & 0x20000000) == 0)
  {
LABEL_18:
    if ((a1 & 0x100000000000000) == 0)
      goto LABEL_19;
    goto LABEL_45;
  }
LABEL_44:
  objc_msgSend(v3, "addObject:", CFSTR("BtryBest"));
  if ((a1 & 0x100000000000000) == 0)
  {
LABEL_19:
    if ((a1 & 0x200000000000000) == 0)
      goto LABEL_20;
    goto LABEL_46;
  }
LABEL_45:
  objc_msgSend(v3, "addObject:", CFSTR("TxDone"));
  if ((a1 & 0x200000000000000) == 0)
  {
LABEL_20:
    if ((a1 & 0x400000000000000) == 0)
      goto LABEL_21;
    goto LABEL_47;
  }
LABEL_46:
  objc_msgSend(v3, "addObject:", CFSTR("Rst"));
  if ((a1 & 0x400000000000000) == 0)
  {
LABEL_21:
    if ((a1 & 0x800000000000000) == 0)
      goto LABEL_22;
    goto LABEL_48;
  }
LABEL_47:
  objc_msgSend(v3, "addObject:", CFSTR("UnexpLnkSwtch"));
  if ((a1 & 0x800000000000000) == 0)
  {
LABEL_22:
    if ((a1 & 0x1000000000000000) == 0)
      goto LABEL_23;
    goto LABEL_49;
  }
LABEL_48:
  objc_msgSend(v3, "addObject:", CFSTR("Inactv"));
  if ((a1 & 0x1000000000000000) == 0)
  {
LABEL_23:
    if ((a1 & 0x2000000000000000) == 0)
      goto LABEL_24;
    goto LABEL_50;
  }
LABEL_49:
  objc_msgSend(v3, "addObject:", CFSTR("RdDtr"));
  if ((a1 & 0x2000000000000000) == 0)
  {
LABEL_24:
    if ((a1 & 0x4000000000000000) == 0)
      goto LABEL_26;
    goto LABEL_25;
  }
LABEL_50:
  objc_msgSend(v3, "addObject:", CFSTR("BtryDtr"));
  if ((a1 & 0x4000000000000000) != 0)
LABEL_25:
    objc_msgSend(v3, "addObject:", CFSTR("LnkSwtchFlr"));
LABEL_26:
  if (objc_msgSend(v3, "count"))
    v4 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "componentsJoinedByString:", CFSTR("_")));
  else
    v4 = CFSTR("<none>");

  return v4;
}

id *sub_100067484(id *a1, void *a2, void *a3)
{
  id v6;
  id v7;
  id *v8;
  unint64_t v9;
  id v11;
  int IsLevelEnabled;
  id v13;
  uint64_t v14;
  char *v15;
  int *v16;
  uint64_t v17;
  id v18;
  uint64_t v19;
  objc_super v20;

  v6 = a2;
  v7 = a3;
  if (a1)
  {
    v20.receiver = a1;
    v20.super_class = (Class)NRAutoLinkUpgradeMonitor;
    v8 = (id *)objc_msgSendSuper2(&v20, "init");
    if (!v8)
    {
      v11 = sub_100067170();
      IsLevelEnabled = _NRLogIsLevelEnabled(v11, 16);

      if (IsLevelEnabled)
      {
        v13 = sub_100067170();
        _NRLogWithArgs(v13, 16, "%s%.30s:%-4d ABORTING: [super init] failed", "", "-[NRAutoLinkUpgradeMonitor initWithQueue:nrUUID:]", 379);

      }
      v14 = _os_log_pack_size(12);
      v15 = (char *)&v19 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
      v16 = __error();
      v17 = _os_log_pack_fill(v15, v14, *v16, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)v17 = 136446210;
      *(_QWORD *)(v17 + 4) = "-[NRAutoLinkUpgradeMonitor initWithQueue:nrUUID:]";
      v18 = sub_100067170();
      _NRLogAbortWithPack(v18, v15);
    }
    a1 = v8;
    do
      v9 = __ldxr(&qword_1001E3AF8);
    while (__stxr(v9 + 1, &qword_1001E3AF8));
    v8[4] = (id)v9;
    objc_storeStrong(v8 + 5, a2);
    objc_storeStrong(a1 + 2, a3);
    objc_msgSend(a1, "reportEvent:", 30001);
  }

  return a1;
}

void sub_10006762C(_QWORD *a1, void *a2)
{
  uint64_t v3;
  void *v4;
  int IsLevelEnabled;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  void *v9;
  int v10;
  uint64_t v11;
  id v12;

  v12 = a2;
  if (a1)
  {
    if (objc_msgSend(a1, "cancelled"))
    {
      v4 = (void *)_NRCopyLogObjectForNRUUID(a1[2], v3);
      IsLevelEnabled = _NRLogIsLevelEnabled(v4, 2);

      if (IsLevelEnabled)
      {
        v7 = (void *)_NRCopyLogObjectForNRUUID(a1[2], v6);
        _NRLogWithArgs(v7, 2, "%s%.30s:%-4d %@: cancelled, ignoring request", "", "-[NRAutoLinkUpgradeMonitor reportWiFiAdviceUpgraded:forAdviceID:]", 495, a1);
LABEL_8:

      }
    }
    else
    {
      if (!objc_msgSend(a1, "hasReportedUpgradeStatusToSymptoms"))
      {
        objc_msgSend(a1, "setHasReportedUpgradeStatusToSymptoms:", 1);
        goto LABEL_10;
      }
      v9 = (void *)_NRCopyLogObjectForNRUUID(a1[2], v8);
      v10 = _NRLogIsLevelEnabled(v9, 1);

      if (v10)
      {
        v7 = (void *)_NRCopyLogObjectForNRUUID(a1[2], v11);
        _NRLogWithArgs(v7, 1, "%s%.30s:%-4d %@: already reported upgrade status, returning", "", "-[NRAutoLinkUpgradeMonitor reportWiFiAdviceUpgraded:forAdviceID:]", 500, a1);
        goto LABEL_8;
      }
    }
  }
LABEL_10:

}

void sub_100067AF0(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  void *v5;
  int IsLevelEnabled;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  id v10;

  v3 = *(_QWORD *)(a1 + 32);
  if (v3)
    v4 = *(_QWORD *)(v3 + 32);
  else
    v4 = 0;
  v5 = (void *)_NRCopyLogObjectForNRUUID(v4, a2);
  IsLevelEnabled = _NRLogIsLevelEnabled(v5, 17);

  if (IsLevelEnabled)
  {
    v8 = *(_QWORD *)(a1 + 32);
    if (v8)
      v9 = *(_QWORD *)(v8 + 32);
    else
      v9 = 0;
    v10 = (id)_NRCopyLogObjectForNRUUID(v9, v7);
    _NRLogWithArgs(v10, 17, "Unexpected un-assert received");

  }
}

void sub_100067B90(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  void *v5;
  int IsLevelEnabled;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  id v10;

  v3 = *(_QWORD *)(a1 + 32);
  if (v3)
    v4 = *(_QWORD *)(v3 + 32);
  else
    v4 = 0;
  v5 = (void *)_NRCopyLogObjectForNRUUID(v4, a2);
  IsLevelEnabled = _NRLogIsLevelEnabled(v5, 17);

  if (IsLevelEnabled)
  {
    v8 = *(_QWORD *)(a1 + 32);
    if (v8)
      v9 = *(_QWORD *)(v8 + 32);
    else
      v9 = 0;
    v10 = (id)_NRCopyLogObjectForNRUUID(v9, v7);
    _NRLogWithArgs(v10, 17, "Unexpected assert received");

  }
}

id *sub_100067CB0(id *a1, void *a2, void *a3)
{
  id v6;
  id v7;
  void *v8;
  id *v9;
  id *v10;
  void *v11;
  id v12;
  void *v13;
  void *v14;
  id v15;
  id v16;
  char *v17;
  char *v18;
  id v19;
  id v20;
  id v21;
  id v22;
  id v23;
  void *v24;
  void *v25;
  id v27;
  int v28;
  id v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  id v34;
  int v35;
  id v36;
  uint64_t v37;
  uint64_t v38;
  id v39;
  int v40;
  id v41;
  uint64_t v42;
  uint64_t v43;
  id v44;
  int IsLevelEnabled;
  id v46;
  uint64_t v47;
  int *v48;
  uint64_t v49;
  id v50;
  uint64_t v51;
  objc_super v52;

  v6 = a2;
  v7 = a3;
  v8 = v7;
  if (a1)
  {
    if (v6)
    {
      if (v7)
      {
        v52.receiver = a1;
        v52.super_class = (Class)NRCompanionLinkViabilityAgent;
        v9 = (id *)objc_msgSendSuper2(&v52, "init");
        if (v9)
        {
          v10 = v9;
          objc_storeStrong(v9 + 5, a3);
          objc_storeStrong(v10 + 4, a2);
          v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](NSUUID, "UUID"));
          objc_msgSend(v10, "setAgentUUID:", v11);

          objc_msgSend(v10, "setAgentDescription:", CFSTR("Companion link viability netagent"));
          v12 = objc_alloc((Class)NSString);
          v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "agentUUID"));
          v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "UUIDString"));
          v15 = objc_msgSend(v12, "initWithFormat:", CFSTR("NRCompanionLinkViabilityAgent-%@"), v14);
          v16 = v10[7];
          v10[7] = v15;

          v17 = sub_10012FFF4((uint64_t)NRDLocalDevice, v10[4]);
          if (v17)
          {
            v18 = v17;
            v19 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%@"), v17);
            v20 = v10[8];
            v10[8] = v19;

            v21 = v10[4];
            v22 = v10[8];
            v23 = v21;
            v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "agentUUID"));
            v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v24, "UUIDString"));
            sub_100121E18(v23, 19001, v22, v25);

            a1 = v10;
            goto LABEL_7;
          }
          v44 = sub_100068160();
          IsLevelEnabled = _NRLogIsLevelEnabled(v44, 16);

          if (IsLevelEnabled)
          {
            v46 = sub_100068160();
            _NRLogWithArgs(v46, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)", "", "-[NRCompanionLinkViabilityAgent initWithNRUUID:queue:]", 54);

          }
          v47 = _os_log_pack_size(12);
          v31 = (char *)&v51 - ((v47 + 15) & 0xFFFFFFFFFFFFFFF0);
          v48 = __error();
          v49 = _os_log_pack_fill(v31, v47, *v48, &_mh_execute_header, "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
          *(_DWORD *)v49 = 136446210;
          *(_QWORD *)(v49 + 4) = "-[NRCompanionLinkViabilityAgent initWithNRUUID:queue:]";
LABEL_21:
          v50 = sub_100068160();
          _NRLogAbortWithPack(v50, v31);
        }
        v39 = sub_100068160();
        v40 = _NRLogIsLevelEnabled(v39, 16);

        if (v40)
        {
          v41 = sub_100068160();
          _NRLogWithArgs(v41, 16, "%s%.30s:%-4d ABORTING: [super init] failed", "", "-[NRCompanionLinkViabilityAgent initWithNRUUID:queue:]", 43);

        }
        v42 = _os_log_pack_size(12);
        v31 = (char *)&v51 - ((v42 + 15) & 0xFFFFFFFFFFFFFFF0);
        v43 = *__error();
        v33 = _os_log_pack_fill(v31, v42, v43, &_mh_execute_header, "%{public}s [super init] failed");
      }
      else
      {
        v34 = sub_100068160();
        v35 = _NRLogIsLevelEnabled(v34, 16);

        if (v35)
        {
          v36 = sub_100068160();
          _NRLogWithArgs(v36, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (queue) != ((void *)0)", "", "-[NRCompanionLinkViabilityAgent initWithNRUUID:queue:]", 41);

        }
        v37 = _os_log_pack_size(12);
        v31 = (char *)&v51 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0);
        v38 = *__error();
        v33 = _os_log_pack_fill(v31, v37, v38, &_mh_execute_header, "%{public}s Assertion Failed: (queue) != ((void *)0)");
      }
    }
    else
    {
      v27 = sub_100068160();
      v28 = _NRLogIsLevelEnabled(v27, 16);

      if (v28)
      {
        v29 = sub_100068160();
        _NRLogWithArgs(v29, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)", "", "-[NRCompanionLinkViabilityAgent initWithNRUUID:queue:]", 40);

      }
      v30 = _os_log_pack_size(12);
      v31 = (char *)&v51 - ((v30 + 15) & 0xFFFFFFFFFFFFFFF0);
      v32 = *__error();
      v33 = _os_log_pack_fill(v31, v30, v32, &_mh_execute_header, "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
    }
    *(_DWORD *)v33 = 136446210;
    *(_QWORD *)(v33 + 4) = "-[NRCompanionLinkViabilityAgent initWithNRUUID:queue:]";
    goto LABEL_21;
  }
LABEL_7:

  return a1;
}

id sub_100068160()
{
  if (qword_1001E46A0 != -1)
    dispatch_once(&qword_1001E46A0, &stru_1001B6A90);
  return (id)qword_1001E4698;
}

void sub_1000681A0(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001E4698;
  qword_1001E4698 = (uint64_t)v1;

}

void sub_1000681D0(uint64_t a1)
{
  id v2;
  id v3;
  id *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  void *v10;
  int IsLevelEnabled;
  uint64_t v12;
  void *v13;
  void *v14;
  void *v15;
  id v16;
  id v17;
  void *v18;
  void *v19;
  uint64_t v20;

  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 40));
    objc_opt_self(NRDPolicySessionManager);
    if (qword_1001E4A20 != -1)
      dispatch_once(&qword_1001E4A20, &stru_1001B8590);
    v2 = (id)qword_1001E4A18;
    sub_100127618((uint64_t)v2, *(void **)(a1 + 56));

    objc_opt_self(NRDPolicySessionManager);
    if (qword_1001E4A20 != -1)
      dispatch_once(&qword_1001E4A20, &stru_1001B8590);
    v3 = (id)qword_1001E4A18;
    v4 = (id *)v3;
    if (v3)
    {
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v3 + 1));
      if ((objc_msgSend(v4[2], "apply") & 1) == 0)
        sub_100109270(CFSTR("NRPolicySessionManager"), CFSTR("ApplyPolicy Failed"), 0, 1, CFSTR("Failed to apply policies"), v5, v6, v7, v20);
    }

    v8 = *(void **)(a1 + 48);
    if (v8)
    {
      if ((objc_msgSend(v8, "unregisterNetworkAgent") & 1) == 0)
      {
        v10 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v9);
        IsLevelEnabled = _NRLogIsLevelEnabled(v10, 17);

        if (IsLevelEnabled)
        {
          v13 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v12);
          _NRLogWithArgs(v13, 17, "Failed to unregister CompanionLinkViability agent");

        }
      }
      v14 = *(void **)(a1 + 48);
      *(_QWORD *)(a1 + 48) = 0;

      v15 = *(void **)(a1 + 32);
      v16 = *(id *)(a1 + 64);
      v17 = v15;
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "agentUUID"));
      v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "UUIDString"));
      sub_100121E18(v17, 19003, v16, v19);

    }
    *(_BYTE *)(a1 + 14) = 0;
  }
}

void sub_10006869C(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  void *v11;
  id v12;
  uint64_t v13;
  id v14;
  void *v15;
  uint64_t v16;
  id v17;
  void *v18;
  void *v19;
  id *v20;
  void *v21;
  uint64_t v22;
  void *v23;
  void *v24;
  id v25;
  void *v26;
  void *v27;
  id v28;
  id v29;
  void *v30;
  void *v31;
  _QWORD *v32;
  void *v33;
  id v34;
  id v35;
  id v36;

  v2 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:", NWNetworkAgentStartOptionClientUUID));
  v36 = (id)v2;
  if (!v2)
  {
    if (qword_1001E46B0 != -1)
      dispatch_once(&qword_1001E46B0, &stru_1001B6AD8);
    if (_NRLogIsLevelEnabled(qword_1001E46A8, 17))
    {
      if (qword_1001E46B0 != -1)
        dispatch_once(&qword_1001E46B0, &stru_1001B6AD8);
      _NRLogWithArgs(qword_1001E46A8, 17, "Unassert message did not contain client UUID");
    }
    goto LABEL_73;
  }
  v3 = v2;
  v4 = *(_QWORD *)(a1 + 40);
  if (v4)
    v5 = *(void **)(v4 + 56);
  else
    v5 = 0;
  if (!objc_msgSend(v5, "containsObject:", v3))
    goto LABEL_73;
  v6 = *(_QWORD *)(a1 + 40);
  if (v6)
    v7 = *(void **)(v6 + 56);
  else
    v7 = 0;
  if (!objc_msgSend(v7, "count"))
  {
    if (qword_1001E46B0 != -1)
      dispatch_once(&qword_1001E46B0, &stru_1001B6AD8);
    if (_NRLogIsLevelEnabled(qword_1001E46A8, 17))
    {
      if (qword_1001E46B0 != -1)
        dispatch_once(&qword_1001E46B0, &stru_1001B6AD8);
      _NRLogWithArgs(qword_1001E46A8, 17, "Unexpected agent unassert received");
    }
    goto LABEL_73;
  }
  v8 = *(_QWORD *)(a1 + 40);
  if (v8)
    v9 = *(void **)(v8 + 56);
  else
    v9 = 0;
  objc_msgSend(v9, "removeObject:", v36);
  v10 = *(_QWORD *)(a1 + 40);
  if (v10)
  {
    v11 = *(void **)(v10 + 64);
    if (v11)
      objc_msgSend(v11, "removeObjectForKey:", v36);
  }
  if (qword_1001E46B0 != -1)
    dispatch_once(&qword_1001E46B0, &stru_1001B6AD8);
  if (_NRLogIsLevelEnabled(qword_1001E46A8, 1))
  {
    if (qword_1001E46B0 != -1)
      dispatch_once(&qword_1001E46B0, &stru_1001B6AD8);
    v12 = (id)qword_1001E46A8;
    v13 = *(_QWORD *)(a1 + 40);
    if (v13)
    {
      v14 = *(id *)(v13 + 64);
      v13 = *(_QWORD *)(a1 + 40);
      if (v14)
      {
        v15 = v14;
        if (v13)
          v13 = *(_QWORD *)(v13 + 64);
        _NRLogWithArgs(v12, 1, "%s%.30s:%-4d Direct to cloud request went away. Remaining clients: %@", "", "-[NRDirectToCloudAgent unassertAgentWithOptions:]_block_invoke", 274, v13);

        goto LABEL_38;
      }
      if (v13)
        v13 = *(_QWORD *)(v13 + 56);
    }
    _NRLogWithArgs(v12, 1, "%s%.30s:%-4d Direct to cloud request went away. Remaining clients: %@", "", "-[NRDirectToCloudAgent unassertAgentWithOptions:]_block_invoke", 274, v13);
LABEL_38:

  }
  v16 = *(_QWORD *)(a1 + 40);
  if (v16)
  {
    if (objc_msgSend(*(id *)(v16 + 56), "count"))
    {
LABEL_41:
      objc_opt_self(NRLinkDirector);
      if (qword_1001E4710 != -1)
        dispatch_once(&qword_1001E4710, &stru_1001B6E60);
      v17 = (id)qword_1001E4708;
      v18 = v17;
      if (v17)
        v19 = (void *)*((_QWORD *)v17 + 6);
      else
        v19 = 0;
      v20 = v19;
      v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "agentUUID"));
      v22 = *(_QWORD *)(a1 + 40);
      if (v22)
        v23 = *(void **)(v22 + 64);
      else
        v23 = 0;
      v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v23, "allValues"));
      sub_100148BF4(v20, 64, v21, v24);

      goto LABEL_73;
    }
  }
  else if (objc_msgSend(0, "count"))
  {
    goto LABEL_41;
  }
  if (qword_1001E46B0 != -1)
    dispatch_once(&qword_1001E46B0, &stru_1001B6AD8);
  if (_NRLogIsLevelEnabled(qword_1001E46A8, 0))
  {
    if (qword_1001E46B0 != -1)
      dispatch_once(&qword_1001E46B0, &stru_1001B6AD8);
    _NRLogWithArgs(qword_1001E46A8, 0, "%s%.30s:%-4d Direct To Cloud requests went away", "", "-[NRDirectToCloudAgent unassertAgentWithOptions:]_block_invoke", 276);
  }
  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v25 = (id)qword_1001E4708;
  v26 = v25;
  if (v25)
    v27 = (void *)*((_QWORD *)v25 + 6);
  else
    v27 = 0;
  v28 = v27;
  sub_100148D6C((uint64_t)v28, 0);

  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v29 = (id)qword_1001E4708;
  v30 = v29;
  if (v29)
    v31 = (void *)*((_QWORD *)v29 + 6);
  else
    v31 = 0;
  v32 = v31;
  v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "agentUUID"));
  sub_100148B30(v32, v33);

  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v34 = (id)qword_1001E4708;
  objc_msgSend(v34, "directToCloudRequestUnavailable");

  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v35 = (id)qword_1001E4708;
  if (v35)
    sub_100121E18(0, 14005, 0, 0);

LABEL_73:
}

void sub_100068C20(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001E46A8;
  qword_1001E46A8 = (uint64_t)v1;

}

void sub_100068C50(uint64_t a1)
{
  uint64_t v2;
  id v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  void *v7;
  id v8;
  void *v9;
  void *v10;
  id v11;
  id v12;
  void *v13;
  void *v14;
  id *v15;
  void *v16;
  uint64_t v17;
  void *v18;
  void *v19;
  id v20;
  id v21;
  uint64_t v22;
  id v23;
  void *v24;
  void *v25;
  void *v26;
  id v27;
  void *v28;
  void *v29;
  id v30;
  uint64_t v31;
  id v32;
  void *v33;
  uint64_t pid;
  id v35;
  void *v36;
  id v37;
  void *v38;
  id v39;
  int v40;
  id v41;
  _QWORD applier[5];
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  char v46;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(id *)(a1 + 40);
  if (!v2)
    goto LABEL_54;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v2 + 32));
  v4 = objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", NWNetworkAgentStartOptionClientUUID));
  if (!v4)
  {
    if (qword_1001E46B0 != -1)
      dispatch_once(&qword_1001E46B0, &stru_1001B6AD8);
    if (_NRLogIsLevelEnabled(qword_1001E46A8, 17))
    {
      if (qword_1001E46B0 != -1)
        dispatch_once(&qword_1001E46B0, &stru_1001B6AD8);
      _NRLogWithArgs(qword_1001E46A8, 17, "no client UUID");
    }
    goto LABEL_54;
  }
  v5 = (void *)v4;
  if (objc_msgSend(*(id *)(v2 + 56), "containsObject:", v4))
  {

    goto LABEL_5;
  }
  v43 = 0;
  v44 = &v43;
  v45 = 0x2020000000;
  v46 = 0;
  v25 = (void *)objc_claimAutoreleasedReturnValue(+[NWPath pathForClientID:](NWPath, "pathForClientID:", v5));
  v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v25, "parameters"));
  v27 = objc_msgSend(v26, "copyCParameters");

  if (!v27)
  {
LABEL_53:

    _Block_object_dispose(&v43, 8);
LABEL_54:

    return;
  }
  v28 = (void *)nw_parameters_copy_avoided_netagent_types(v27);
  v29 = v28;
  if (!v28)
  {

    goto LABEL_53;
  }
  applier[0] = _NSConcreteStackBlock;
  applier[1] = 3221225472;
  applier[2] = sub_1000692C8;
  applier[3] = &unk_1001B6AB8;
  applier[4] = &v43;
  xpc_array_apply(v28, applier);
  if (*((_BYTE *)v44 + 24))
  {
    v30 = *(id *)(v2 + 56);
    objc_msgSend(v30, "addObject:", v5);

    if (_NRIsAppleInternal(v31))
    {
      if (!*(_QWORD *)(v2 + 64))
      {
        v32 = objc_alloc_init((Class)NSMutableDictionary);
        v33 = *(void **)(v2 + 64);
        *(_QWORD *)(v2 + 64) = v32;

      }
      pid = nw_parameters_get_pid(v27);
      v35 = sub_100109ADC(pid, 0);
      v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v25, "effectiveRemoteEndpoint"));

      if (v36)
      {
        v37 = objc_msgSend(objc_alloc((Class)NSMutableString), "initWithString:", v35);
        v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v25, "effectiveRemoteEndpoint"));
        objc_msgSend(v37, "appendFormat:", CFSTR(" (%@)"), v38);

      }
      else
      {
        v37 = v35;
      }
      v39 = *(id *)(v2 + 64);
      objc_msgSend(v39, "setObject:forKeyedSubscript:", v37, v5);

    }
  }
  v40 = *((unsigned __int8 *)v44 + 24);

  _Block_object_dispose(&v43, 8);
  if (v40)
  {
LABEL_5:
    v6 = *(_QWORD *)(a1 + 32);
    if (v6)
      v7 = *(void **)(v6 + 56);
    else
      v7 = 0;
    if (objc_msgSend(v7, "count") == (id)1)
    {
      if (qword_1001E46B0 != -1)
        dispatch_once(&qword_1001E46B0, &stru_1001B6AD8);
      if (_NRLogIsLevelEnabled(qword_1001E46A8, 0))
      {
        if (qword_1001E46B0 != -1)
          dispatch_once(&qword_1001E46B0, &stru_1001B6AD8);
        _NRLogWithArgs(qword_1001E46A8, 0, "%s%.30s:%-4d Direct To Cloud request received", "", "-[NRDirectToCloudAgent assertAgentWithOptions:]_block_invoke", 235);
      }
      objc_opt_self(NRLinkDirector);
      if (qword_1001E4710 != -1)
        dispatch_once(&qword_1001E4710, &stru_1001B6E60);
      v8 = (id)qword_1001E4708;
      v9 = v8;
      if (v8)
        v10 = (void *)*((_QWORD *)v8 + 6);
      else
        v10 = 0;
      v11 = v10;
      sub_100148D6C((uint64_t)v11, 1);

    }
    objc_opt_self(NRLinkDirector);
    if (qword_1001E4710 != -1)
      dispatch_once(&qword_1001E4710, &stru_1001B6E60);
    v12 = (id)qword_1001E4708;
    v13 = v12;
    if (v12)
      v14 = (void *)*((_QWORD *)v12 + 6);
    else
      v14 = 0;
    v15 = v14;
    v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "agentUUID"));
    v17 = *(_QWORD *)(a1 + 32);
    if (v17)
      v18 = *(void **)(v17 + 64);
    else
      v18 = 0;
    v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "allValues"));
    sub_100148BF4(v15, 64, v16, v19);

    objc_opt_self(NRLinkDirector);
    if (qword_1001E4710 != -1)
      dispatch_once(&qword_1001E4710, &stru_1001B6E60);
    v20 = (id)qword_1001E4708;
    objc_msgSend(v20, "directToCloudRequestAvailable");

    if (qword_1001E46B0 != -1)
      dispatch_once(&qword_1001E46B0, &stru_1001B6AD8);
    if (!_NRLogIsLevelEnabled(qword_1001E46A8, 1))
      goto LABEL_59;
    if (qword_1001E46B0 != -1)
      dispatch_once(&qword_1001E46B0, &stru_1001B6AD8);
    v21 = (id)qword_1001E46A8;
    v22 = *(_QWORD *)(a1 + 32);
    if (v22)
    {
      v23 = *(id *)(v22 + 64);
      v22 = *(_QWORD *)(a1 + 32);
      if (v23)
      {
        v24 = v23;
        if (v22)
          v22 = *(_QWORD *)(v22 + 64);
        _NRLogWithArgs(v21, 1, "%s%.30s:%-4d Direct To Cloud clients: %@", "", "-[NRDirectToCloudAgent assertAgentWithOptions:]_block_invoke", 245, v22);

        goto LABEL_58;
      }
      if (v22)
        v22 = *(_QWORD *)(v22 + 56);
    }
    _NRLogWithArgs(v21, 1, "%s%.30s:%-4d Direct To Cloud clients: %@", "", "-[NRDirectToCloudAgent assertAgentWithOptions:]_block_invoke", 245, v22);
LABEL_58:

LABEL_59:
    objc_opt_self(NRLinkDirector);
    if (qword_1001E4710 != -1)
      dispatch_once(&qword_1001E4710, &stru_1001B6E60);
    v41 = (id)qword_1001E4708;
    if (v41)
      sub_100121E18(0, 14004, 0, 0);

  }
}

void sub_10006929C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000692C8(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  uint64_t v5;
  const char *string_ptr;

  v4 = a3;
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = xpc_string_get_string_ptr(v4);
    v5 = 1;
    if (!strcmp("CompanionProxy", string_ptr))
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
      v5 = 0;
    }
  }
  else
  {
    v5 = 1;
  }

  return v5;
}

uint64_t sub_100069348(uint64_t result)
{
  uint64_t v1;
  id v2;
  void *v3;
  uint64_t v4;
  id v5;
  id v6;
  void *v7;
  void *v8;
  id v9;
  id v10;
  void *v11;
  void *v12;
  _QWORD *v13;
  void *v14;
  void *v15;
  void *v16;

  if (result)
  {
    v1 = result;
    if (!*(_BYTE *)(result + 14))
      return 1;
    if (qword_1001E46B0 != -1)
      dispatch_once(&qword_1001E46B0, &stru_1001B6AD8);
    if (_NRLogIsLevelEnabled(qword_1001E46A8, 0))
    {
      if (qword_1001E46B0 != -1)
        dispatch_once(&qword_1001E46B0, &stru_1001B6AD8);
      v2 = (id)qword_1001E46A8;
      v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v1, "agentDescription"));
      _NRLogWithArgs(v2, 0, "%s%.30s:%-4d unregisterAgent: %@", "", "-[NRDirectToCloudAgent invalidateAgent]", 139, v3);

    }
    objc_msgSend((id)v1, "setActive:", 0);
    v4 = *(_QWORD *)(v1 + 48);
    v5 = *(id *)(v1 + 40);
    objc_msgSend(v5, "removeNetworkAgentFromInterfaceNamed:", v4);

    objc_opt_self(NRLinkDirector);
    if (qword_1001E4710 != -1)
      dispatch_once(&qword_1001E4710, &stru_1001B6E60);
    v6 = (id)qword_1001E4708;
    v7 = v6;
    if (v6)
      v8 = (void *)*((_QWORD *)v6 + 6);
    else
      v8 = 0;
    v9 = v8;
    sub_100148D6C((uint64_t)v9, 0);

    objc_opt_self(NRLinkDirector);
    if (qword_1001E4710 != -1)
      dispatch_once(&qword_1001E4710, &stru_1001B6E60);
    v10 = (id)qword_1001E4708;
    v11 = v10;
    if (v10)
      v12 = (void *)*((_QWORD *)v10 + 6);
    else
      v12 = 0;
    v13 = v12;
    v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v1, "agentUUID"));
    sub_100148B30(v13, v14);

    if ((objc_msgSend(*(id *)(v1 + 40), "unregisterNetworkAgent") & 1) != 0)
    {
      *(_BYTE *)(v1 + 14) = 0;
      v15 = *(void **)(v1 + 40);
      *(_QWORD *)(v1 + 40) = 0;

      v16 = *(void **)(v1 + 56);
      *(_QWORD *)(v1 + 56) = 0;

      sub_100121E18(0, 14003, 0, 0);
      return 1;
    }
    if (qword_1001E46B0 != -1)
      dispatch_once(&qword_1001E46B0, &stru_1001B6AD8);
    result = _NRLogIsLevelEnabled(qword_1001E46A8, 17);
    if ((_DWORD)result)
    {
      if (qword_1001E46B0 != -1)
        dispatch_once(&qword_1001E46B0, &stru_1001B6AD8);
      _NRLogWithArgs(qword_1001E46A8, 17, "unable to unregister agent");
      return 0;
    }
  }
  return result;
}

id *sub_100069680(id *a1, void *a2)
{
  NSObject *v4;
  id *v5;
  void *v6;
  void *v7;
  id v8;
  id v9;
  id v11;
  int v12;
  id v13;
  uint64_t v14;
  char *v15;
  int *v16;
  uint64_t v17;
  id v18;
  int IsLevelEnabled;
  id v20;
  uint64_t v21;
  int *v22;
  uint64_t v23;
  id v24;
  uint64_t v25;
  objc_super v26;

  v4 = a2;
  if (a1)
  {
    v26.receiver = a1;
    v26.super_class = (Class)NRDirectToCloudAgent;
    v5 = (id *)objc_msgSendSuper2(&v26, "init");
    if (v5)
    {
      if (v4)
      {
        a1 = v5;
        dispatch_assert_queue_V2(v4);
        objc_msgSend(a1, "setActive:", 0);
        objc_msgSend(a1, "setKernelActivated:", 1);
        objc_msgSend(a1, "setUserActivated:", 1);
        objc_msgSend(a1, "setVoluntary:", 1);
        objc_msgSend(a1, "setNetworkProvider:", 0);
        objc_msgSend(a1, "setSpecificUseOnly:", 0);
        v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](NSUUID, "UUID"));
        objc_msgSend(a1, "setAgentUUID:", v6);

        v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Direct-To-Cloud agent")));
        objc_msgSend(a1, "setAgentDescription:", v7);

        objc_storeStrong(a1 + 4, a2);
        v8 = objc_alloc_init((Class)NSMutableSet);
        v9 = a1[7];
        a1[7] = v8;

        goto LABEL_5;
      }
      v18 = sub_100069954();
      IsLevelEnabled = _NRLogIsLevelEnabled(v18, 16);

      if (IsLevelEnabled)
      {
        v20 = sub_100069954();
        _NRLogWithArgs(v20, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: queue", "", "-[NRDirectToCloudAgent initWithQueue:]", 49);

      }
      v21 = _os_log_pack_size(12);
      v15 = (char *)&v25 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
      v22 = __error();
      v23 = _os_log_pack_fill(v15, v21, *v22, &_mh_execute_header, "%{public}s Assertion Failed: queue");
      *(_DWORD *)v23 = 136446210;
      *(_QWORD *)(v23 + 4) = "-[NRDirectToCloudAgent initWithQueue:]";
    }
    else
    {
      v11 = sub_100069954();
      v12 = _NRLogIsLevelEnabled(v11, 16);

      if (v12)
      {
        v13 = sub_100069954();
        _NRLogWithArgs(v13, 16, "%s%.30s:%-4d ABORTING: [super init] failed", "", "-[NRDirectToCloudAgent initWithQueue:]", 48);

      }
      v14 = _os_log_pack_size(12);
      v15 = (char *)&v25 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
      v16 = __error();
      v17 = _os_log_pack_fill(v15, v14, *v16, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)v17 = 136446210;
      *(_QWORD *)(v17 + 4) = "-[NRDirectToCloudAgent initWithQueue:]";
    }
    v24 = sub_100069954();
    _NRLogAbortWithPack(v24, v15);
  }
LABEL_5:

  return a1;
}

id sub_100069954()
{
  if (qword_1001E46B0 != -1)
    dispatch_once(&qword_1001E46B0, &stru_1001B6AD8);
  return (id)qword_1001E46A8;
}

void sub_10006F2A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

id sub_100070AC8()
{
  if (qword_1001E46D8 != -1)
    dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
  return (id)qword_1001E46D0;
}

void sub_100070B08(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001E46D0;
  qword_1001E46D0 = (uint64_t)v1;

}

uint64_t sub_100070B38(uint64_t a1, void *a2)
{
  const __CFString *v2;
  id v4;
  void *v5;
  id v6;
  uint64_t v7;
  void *IKEv2PacketString;
  size_t v9;
  uint64_t v10;
  void *v11;
  int *IsLevelEnabled;
  uint64_t v13;
  id v14;
  id v15;
  unsigned int v16;
  id v17;
  id v18;
  id v19;
  id v20;
  id v21;
  _UNKNOWN **v22;
  uint64_t v23;
  void *v24;
  int v25;
  uint64_t v26;
  void *v27;
  id v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  id v35;
  int v36;
  id v37;
  uint64_t v38;
  int *v39;
  uint64_t v40;
  id v41;
  void *v42;
  int v43;
  uint64_t v44;
  void *v45;
  id v46;
  id v47;
  uint64_t v48;
  uint64_t v49;
  id v50;
  id v51;
  id v52;
  size_t v53;
  void *v54;
  __int16 v55;
  __int16 v56;

  v4 = a2;
  v5 = v4;
  if (a1)
  {
    if (*(unsigned __int8 *)(a1 + 16) == 255)
      goto LABEL_22;
    v6 = objc_msgSend(v4, "length");
    v7 = *(_QWORD *)(a1 + 1583);
    IKEv2PacketString = (void *)createIKEv2PacketString(v5);
    v9 = (unsigned __int16)v6;
    objc_msgSend((id)a1, "reportEvent:detailsFormat:", 3006, CFSTR("Sending IKEv2 packet #%llu %@ len %llu"), v7, IKEv2PacketString, (unsigned __int16)v6);

    ++*(_QWORD *)(a1 + 1583);
    v11 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v10);
    IsLevelEnabled = (int *)_NRLogIsLevelEnabled(v11, 1);

    if ((_DWORD)IsLevelEnabled)
    {
      v53 = (unsigned __int16)v6;
      v51 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v13);
      v14 = objc_msgSend((id)a1, "copyDescription");
      v49 = *(_QWORD *)(a1 + 1583);
      v50 = v14;
      v52 = v6;
      v48 = (unsigned __int16)v6;
      v54 = v5;
      v15 = v5;
      v16 = objc_msgSend(v15, "length");
      v47 = v15;
      v17 = objc_msgSend(v15, "bytes");
      v18 = objc_alloc_init((Class)NSMutableString);
      if (v16)
      {
        IsLevelEnabled = 0;
        v2 = CFSTR(" ");
        do
        {
          objc_msgSend(v18, "appendFormat:", CFSTR("%02X"), *((unsigned __int8 *)IsLevelEnabled + (_QWORD)v17));
          if ((~(_DWORD)IsLevelEnabled & 0xF) == 0 || (~(_DWORD)IsLevelEnabled & 3) == 0)
            objc_msgSend(v18, "appendString:");
          IsLevelEnabled = (int *)((char *)IsLevelEnabled + 1);
        }
        while ((int *)v16 != IsLevelEnabled);
      }

      _NRLogWithArgs(v51, 1, "%s%.30s:%-4d %@: IKE #%llu SENDING dataLen=%u data=[\n%@]", "", "-[NRLinkBluetooth sendIKEData:]", 7196, v50, v49, v48, v18);
      v9 = v53;
      v5 = v54;
      LODWORD(v6) = (_DWORD)v52;
    }
    if (*(_BYTE *)(a1 + 246))
    {
      v56 = bswap32(v6) >> 16;
      v19 = objc_msgSend(objc_alloc((Class)NSMutableData), "initWithCapacity:", v9 + 5);
      objc_msgSend(v19, "appendBytes:length:", &unk_10015CFEC, 1);
      objc_msgSend(v19, "appendBytes:length:", &v56, 2);
      objc_msgSend(v19, "appendData:", v5);
      v20 = objc_msgSend(v19, "bytes");
      v21 = objc_msgSend(v19, "length");
      if ((_DWORD)v21)
      {
        v55 = ~(unsigned __int16)os_inet_checksum(v20, v21, 0);
        objc_msgSend(v19, "appendBytes:length:", &v55, 2);
        if (*(unsigned __int16 *)(a1 + 261) >= 0x15u && *(_BYTE *)(a1 + 229))
          v22 = &off_1001C46F0;
        else
          v22 = &off_1001C46D8;
        sub_10007118C(a1, v19, v22);

        goto LABEL_25;
      }
      v35 = sub_100070AC8();
      v36 = _NRLogIsLevelEnabled(v35, 16);

      if (v36)
      {
        v37 = sub_100070AC8();
        _NRLogWithArgs(v37, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: dataLen > 0", "", "nrChecksumFull", 109);

      }
      v38 = _os_log_pack_size(12);
      a1 = (uint64_t)&v47 - ((__chkstk_darwin(v38) + 15) & 0xFFFFFFFFFFFFFFF0);
      v39 = __error();
      v40 = _os_log_pack_fill(a1, v38, *v39, &_mh_execute_header, "%{public}s Assertion Failed: dataLen > 0");
      *(_DWORD *)v40 = 136446210;
      *(_QWORD *)(v40 + 4) = "nrChecksumFull";
      v41 = sub_100070AC8();
      _NRLogAbortWithPack(v41, a1);
      goto LABEL_30;
    }
    IsLevelEnabled = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
    v23 = *(unsigned int *)(a1 + 287);
    v2 = (const __CFString *)(unsigned __int16)v6;
    if (*(_DWORD *)(a1 + 279) >= (unsigned __int16)v6 + 5 + v23)
    {
      v29 = *(_QWORD *)(a1 + 447) + v23;
      *(_BYTE *)v29 = 4;
      *(_WORD *)(v29 + 1) = bswap32(v6) >> 16;
      memcpy((void *)(*(_QWORD *)(a1 + 447) + (*(_DWORD *)(a1 + 287) + 3)), objc_msgSend(v5, "bytes"), v9);
      v30 = (unsigned __int16)v6 + 3;
      v31 = *(_QWORD *)(a1 + 447);
      v32 = v30 + *(_DWORD *)(a1 + 287);
      *(_WORD *)(v31 + v32) = ~(unsigned __int16)os_inet_checksum(v29, v30, 0);
      *(_DWORD *)(a1 + 287) += (unsigned __int16)v6 + 5;
      if (!gNRPacketLoggingEnabled)
      {
LABEL_24:
        sub_100071380((void *)a1, *(_QWORD *)(a1 + 367));
LABEL_25:
        a1 = 1;
        goto LABEL_26;
      }
LABEL_30:
      v42 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v33);
      v43 = _NRLogIsLevelEnabled(v42, 1);

      if (v43)
      {
        v45 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v44);
        v46 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v45, 1, "%s%.30s:%-4d %@: Wrote IKE packet #%llu of length %u to linkWriteBuffer filledIn=%u handled=%u", "", "-[NRLinkBluetooth sendIKEData:]", 7236, v46, *(_QWORD *)(a1 + 1583), v2, *(unsigned int *)(a1 + IsLevelEnabled[119]), *(unsigned int *)(a1 + 291));

      }
      goto LABEL_24;
    }
    v24 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v13);
    v25 = _NRLogIsLevelEnabled(v24, 16);

    if (!v25)
    {
LABEL_22:
      a1 = 0;
    }
    else
    {
      v27 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v26);
      v28 = objc_msgSend((id)a1, "copyDescription");
      _NRLogWithArgs(v27, 16, "%s%.30s:%-4d %@: no room for IKEv2 packet, dropping it NR_LINK_WRITE_BUFFER_LEN=%u handledLinkWriteBufferBytes=%udiff=%u totalDataLen=%u ", "", "-[NRLinkBluetooth sendIKEData:]", 7225, v28, *(unsigned int *)(a1 + 287), *(unsigned int *)(a1 + 291), (*(_DWORD *)(a1 + 279) - *(_DWORD *)(a1 + 291)), ((_DWORD)v2 + 5));

      a1 = 0;
    }
  }
LABEL_26:

  return a1;
}

void sub_10007118C(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id v7;
  id v8;
  void *v9;
  _BOOL8 v10;
  void *v11;
  void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  void *v16;
  id v17;
  void *v18;
  id v19;

  if (a1)
  {
    v5 = a3;
    v6 = a2;
    v19 = objc_alloc_init((Class)NSMutableDictionary);
    objc_msgSend(v19, "setObject:forKeyedSubscript:", v6, CFSTR("message-data"));

    objc_msgSend(v19, "setObject:forKeyedSubscript:", v5, CFSTR("channel-id"));
    v7 = objc_alloc_init((Class)NSMutableDictionary);
    objc_msgSend(v7, "setObject:forKeyedSubscript:", v19, CFSTR("message"));
    objc_opt_self(NRLinkDirector);
    if (qword_1001E4710 != -1)
      dispatch_once(&qword_1001E4710, &stru_1001B6E60);
    v8 = (id)qword_1001E4708;
    v9 = v8;
    if (v8)
      v10 = *((_BYTE *)v8 + 9) != 0;
    else
      v10 = 0;
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v10));
    objc_msgSend(v7, "setObject:forKeyedSubscript:", v11, CFSTR("test-wake-pkt"));

    v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", gNRPacketLoggingEnabled));
    objc_msgSend(v7, "setObject:forKeyedSubscript:", v12, CFSTR("packet-logging"));

    objc_opt_self(NRLinkDirector);
    if (qword_1001E4710 != -1)
      dispatch_once(&qword_1001E4710, &stru_1001B6E60);
    v13 = (id)qword_1001E4708;
    v14 = v13;
    if (v13)
    {
      v15 = *(_QWORD *)(a1 + 32);
      v16 = (void *)*((_QWORD *)v13 + 25);
      v17 = v7;
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "objectForKeyedSubscript:", v15));
      sub_1000EF368((uint64_t)v18, v17);

    }
  }
}

void sub_100071380(void *a1, uint64_t a2)
{
  unsigned __int8 *v3;
  uint64_t v4;
  char *v5;
  int *v6;
  uint64_t v7;
  void *v8;
  int IsLevelEnabled;
  uint64_t v10;
  void *v11;
  id v12;
  void *v13;
  int v14;
  uint64_t v15;
  int *v16;
  int *v17;
  int *v18;
  int *v19;
  char *v20;
  char *v21;
  int *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t next_slot;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  BOOL v35;
  unsigned int DSCPFromPacket;
  _BOOL4 v37;
  _BOOL4 v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int v42;
  int v43;
  unint64_t v44;
  unsigned int v45;
  uint64_t v46;
  unsigned int v47;
  unsigned int v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  BOOL v52;
  int v53;
  void *v54;
  int v55;
  void *v56;
  id v57;
  void *v58;
  int v59;
  uint64_t v60;
  void *v61;
  id v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t packet;
  uint64_t next_buflet;
  uint64_t object_address;
  unsigned int data_limit;
  uint64_t v72;
  uint64_t v73;
  int v74;
  uint64_t v75;
  int *v76;
  uint64_t v77;
  int v78;
  uint64_t v79;
  unsigned int v80;
  unsigned int v81;
  uint64_t v82;
  uint64_t v83;
  unsigned int *v84;
  unsigned int v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  unsigned int v90;
  unsigned int v91;
  unsigned int v92;
  int v93;
  uint64_t v94;
  int *v95;
  void *v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  unsigned int v103;
  uint64_t v104;
  int v105;
  uint64_t v106;
  uint64_t v107;
  unsigned int v108;
  int v109;
  uint64_t v110;
  int v111;
  uint64_t v112;
  id v113;
  uint64_t v114;
  char *v115;
  uint64_t v116;
  _QWORD *v117;
  uint64_t v118;
  void *v119;
  int v120;
  void *v121;
  id v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  void *v126;
  int v127;
  uint64_t v128;
  void *v129;
  id v130;
  void *v131;
  int v132;
  uint64_t v133;
  void *v134;
  id v135;
  unsigned int v136;
  void *v137;
  int v138;
  uint64_t v139;
  void *v140;
  id v141;
  void *v142;
  int v143;
  uint64_t v144;
  void *v145;
  id v146;
  void *v147;
  uint64_t v148;
  id v149;
  void *v150;
  int v151;
  uint64_t v152;
  void *v153;
  id v154;
  void *v155;
  int v156;
  uint64_t v157;
  void *v158;
  id v159;
  int v160;
  uint64_t v161;
  uint64_t v162;
  int v163;
  uint64_t v164;
  unsigned int v165;
  unsigned int v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  _QWORD *v170;
  void *v171;
  int v172;
  void *v173;
  id v174;
  int v175;
  void *v176;
  int v177;
  void *v178;
  id v179;
  void *v180;
  int v181;
  void *v182;
  id v183;
  uint64_t v184;
  void *v185;
  int v186;
  uint64_t v187;
  void *v188;
  id v189;
  uint64_t v190;
  void *v191;
  void *v192;
  int v193;
  void *v194;
  id v195;
  void *v196;
  int v197;
  uint64_t v198;
  void *v199;
  id v200;
  void *v201;
  int v202;
  uint64_t v203;
  void *v204;
  id v205;
  uint64_t v206;
  void *v207;
  void *v208;
  int v209;
  uint64_t v210;
  void *v211;
  id v212;
  uint64_t v213;
  void *v214;
  void *v215;
  int v216;
  void *v217;
  int v218;
  uint64_t v219;
  void *v220;
  id v221;
  void *v222;
  int v223;
  uint64_t v224;
  void *v225;
  id v226;
  void *v227;
  int v228;
  void *v229;
  id v230;
  id v231;
  int v232;
  id v233;
  uint64_t v234;
  char *v235;
  uint64_t v236;
  uint64_t i;
  id v238;
  int v239;
  id v240;
  uint64_t v241;
  uint64_t v242;
  id v243;
  uint64_t v244;
  uint64_t v245;
  id v246;
  id v247;
  uint64_t v248;
  uint64_t v249;
  id v250;
  uint64_t v251;
  uint64_t v252;
  id v253;
  id v254;
  int v255;
  id v256;
  uint64_t v257;
  uint64_t v258;
  id v259;
  int v260;
  id v261;
  void *v262;
  uint64_t v263;
  int *v264;
  uint64_t v265;
  uint64_t v266;
  id v267;
  int v268;
  id v269;
  uint64_t v270;
  uint64_t v271;
  id v272;
  int v273;
  id v274;
  uint64_t v275;
  uint64_t v276;
  int v277;
  id v278;
  int v279;
  id v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  void *v284;
  int v285;
  void *v286;
  id v287;
  void *v288;
  int v289;
  void *v290;
  int v291;
  int v292;
  id v293;
  int v294;
  id v295;
  char *v296;
  uint64_t v297;
  uint64_t v298;
  id v299;
  void *v300;
  int v301;
  uint64_t v302;
  void *v303;
  id v304;
  void *v305;
  int v306;
  uint64_t v307;
  void *v308;
  id v309;
  void *v310;
  int v311;
  void *v312;
  int v313;
  uint64_t v314;
  void *v315;
  id v316;
  void *v317;
  int v318;
  uint64_t v319;
  void *v320;
  id v321;
  id v322;
  int v323;
  id v324;
  id v325;
  int v326;
  id v327;
  id v328;
  int v329;
  id v330;
  uint64_t v331;
  uint64_t v332;
  uint64_t v333;
  char *v334;
  char *v335;
  char *v336;
  char *v337;
  void (*v338)(uint64_t, uint64_t);
  int v339;
  _BOOL8 v340;
  void *v341;
  uint64_t v342;
  void (*v343)(uint64_t, uint64_t);
  uint64_t v344;
  uint64_t v345;
  uint64_t v346;
  uint64_t v347;
  uint64_t ESPSequenceNumberFromPacket;
  uint64_t v349;
  uint64_t v350;
  uint64_t v351;
  id v352;
  char *v353;
  uint64_t v354;
  char *v355;
  uint64_t v356;
  uint64_t v357;
  uint64_t v358;
  uint64_t v359;
  uint64_t v360;
  _QWORD v361[8];
  __int128 v362;
  __int128 v363;
  __int128 v364;
  __int128 v365;
  _BYTE v366[64];
  __int128 v367;
  __int128 v368;
  __int128 v369;
  __int128 v370;
  __int128 v371;
  __int128 v372;
  __int128 v373;
  __int128 v374;
  __int128 v375;
  __int128 v376;
  __int128 v377;
  __int128 v378;
  __int128 v379;
  __int128 v380;
  __int128 v381;
  __int128 v382;
  uint64_t v383;
  uint64_t v384;

  v3 = a1;
  v5 = (char *)v3;
  if (v3[16] == 255)
  {
    v8 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v4);
    IsLevelEnabled = _NRLogIsLevelEnabled(v8, 16);

    if (!IsLevelEnabled)
      goto LABEL_266;
    v11 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v10);
    v12 = objc_msgSend(v5, "copyDescription");
    _NRLogWithArgs(v11, 16, "%s%.30s:%-4d %@: nexusToLinkLoop but cancelled", "", "NRLinkNexusToLinkLoop", 3578, v12);
    goto LABEL_10;
  }
  v6 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
  if (!*(_QWORD *)(v3 + 975))
  {
    if (v3[246])
      goto LABEL_266;
    v13 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v4);
    v14 = _NRLogIsLevelEnabled(v13, 17);

    if (!v14)
      goto LABEL_266;
    v11 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v15);
    v12 = objc_msgSend(v5, "copyDescription");
    _NRLogWithArgs(v11, 17, "%@: Tried to nexusToLinkLoop but _linkOutputRing is NULL", v12);
LABEL_10:

    goto LABEL_266;
  }
  v349 = *(_QWORD *)(v3 + 527);
  v350 = a2;
  v353 = (char *)v3;
  if (v349 == a2)
  {
    if (gNRPacketLoggingEnabled)
    {
      v284 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v4);
      v285 = _NRLogIsLevelEnabled(v284, 1);

      if (v285)
      {
        v286 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v4);
        v287 = objc_msgSend(v5, "copyDescription");
        _NRLogWithArgs(v286, 1, "%s%.30s:%-4d %@: Serving voice channel", "", "NRLinkNexusToLinkLoop", 3603, v287);
        v343 = sub_100074E68;
        v338 = sub_100074A4C;
        v16 = &OBJC_IVAR___NRLinkBluetooth__syncNexusVOInput;
        v17 = &OBJC_IVAR___NRLinkBluetooth__bytesFromNexusVO;
        v18 = &OBJC_IVAR___NRLinkBluetooth__packetsFromNexusVO;
        v19 = &OBJC_IVAR___NRLinkBluetooth__nexusVOInputRing;
        goto LABEL_338;
      }
    }
    v343 = sub_100074E68;
    v338 = sub_100074A4C;
    v16 = &OBJC_IVAR___NRLinkBluetooth__syncNexusVOInput;
    v17 = &OBJC_IVAR___NRLinkBluetooth__bytesFromNexusVO;
    v18 = &OBJC_IVAR___NRLinkBluetooth__packetsFromNexusVO;
    v19 = &OBJC_IVAR___NRLinkBluetooth__nexusVOInputRing;
  }
  else if (*(_QWORD *)(v3 + 671) == a2)
  {
    if (gNRPacketLoggingEnabled)
    {
      v288 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v4);
      v289 = _NRLogIsLevelEnabled(v288, 1);

      if (!v289)
      {
        v343 = sub_100074D60;
        v338 = sub_100074948;
        v16 = &OBJC_IVAR___NRLinkBluetooth__syncNexusVIInput;
        v17 = &OBJC_IVAR___NRLinkBluetooth__bytesFromNexusVI;
        v18 = &OBJC_IVAR___NRLinkBluetooth__packetsFromNexusVI;
        v19 = &OBJC_IVAR___NRLinkBluetooth__nexusVIInputRing;
        v5 = v353;
        goto LABEL_22;
      }
      v5 = v353;
      v286 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v353 + 4), v4);
      v287 = objc_msgSend(v353, "copyDescription");
      _NRLogWithArgs(v286, 1, "%s%.30s:%-4d %@: Serving video channel", "", "NRLinkNexusToLinkLoop", 3614, v287);
      v343 = sub_100074D60;
      v338 = sub_100074948;
      v16 = &OBJC_IVAR___NRLinkBluetooth__syncNexusVIInput;
      v17 = &OBJC_IVAR___NRLinkBluetooth__bytesFromNexusVI;
      v18 = &OBJC_IVAR___NRLinkBluetooth__packetsFromNexusVI;
      v19 = &OBJC_IVAR___NRLinkBluetooth__nexusVIInputRing;
      goto LABEL_338;
    }
    v343 = sub_100074D60;
    v338 = sub_100074948;
    v16 = &OBJC_IVAR___NRLinkBluetooth__syncNexusVIInput;
    v17 = &OBJC_IVAR___NRLinkBluetooth__bytesFromNexusVI;
    v18 = &OBJC_IVAR___NRLinkBluetooth__packetsFromNexusVI;
    v19 = &OBJC_IVAR___NRLinkBluetooth__nexusVIInputRing;
  }
  else
  {
    if (*(_QWORD *)(v3 + 815) != a2)
    {
      if (*(_QWORD *)(v3 + 367) != a2)
      {
        v332 = 0;
        v333 = 0;
        v337 = 0;
        v338 = 0;
        v343 = 0;
        v335 = 0;
        v336 = 0;
        v7 = 0;
        goto LABEL_23;
      }
      if (!gNRPacketLoggingEnabled)
      {
        v343 = sub_100074B50;
        v338 = sub_100074740;
        v16 = &OBJC_IVAR___NRLinkBluetooth__syncNexusInput;
        v17 = &OBJC_IVAR___NRLinkBluetooth__bytesFromNexus;
        v18 = &OBJC_IVAR___NRLinkBluetooth__packetsFromNexus;
        v19 = &OBJC_IVAR___NRLinkBluetooth__nexusInputRing;
        goto LABEL_22;
      }
      v310 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v4);
      v311 = _NRLogIsLevelEnabled(v310, 1);

      if (!v311)
      {
        v343 = sub_100074B50;
        v338 = sub_100074740;
        v16 = &OBJC_IVAR___NRLinkBluetooth__syncNexusInput;
        v17 = &OBJC_IVAR___NRLinkBluetooth__bytesFromNexus;
        v18 = &OBJC_IVAR___NRLinkBluetooth__packetsFromNexus;
        v19 = &OBJC_IVAR___NRLinkBluetooth__nexusInputRing;
        v5 = v353;
        goto LABEL_22;
      }
      v5 = v353;
      v286 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v353 + 4), v4);
      v287 = objc_msgSend(v353, "copyDescription");
      _NRLogWithArgs(v286, 1, "%s%.30s:%-4d %@: Serving BestEffort channel", "", "NRLinkNexusToLinkLoop", 3634, v287);
      v343 = sub_100074B50;
      v338 = sub_100074740;
      v16 = &OBJC_IVAR___NRLinkBluetooth__syncNexusInput;
      v17 = &OBJC_IVAR___NRLinkBluetooth__bytesFromNexus;
      v18 = &OBJC_IVAR___NRLinkBluetooth__packetsFromNexus;
      v19 = &OBJC_IVAR___NRLinkBluetooth__nexusInputRing;
LABEL_338:

      goto LABEL_22;
    }
    if (gNRPacketLoggingEnabled)
    {
      v290 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v4);
      v291 = _NRLogIsLevelEnabled(v290, 1);

      if (!v291)
      {
        v343 = sub_100074C58;
        v338 = sub_100074844;
        v16 = &OBJC_IVAR___NRLinkBluetooth__syncNexusBKInput;
        v17 = &OBJC_IVAR___NRLinkBluetooth__bytesFromNexusBK;
        v18 = &OBJC_IVAR___NRLinkBluetooth__packetsFromNexusBK;
        v19 = &OBJC_IVAR___NRLinkBluetooth__nexusBKInputRing;
        v5 = v353;
        goto LABEL_22;
      }
      v5 = v353;
      v286 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v353 + 4), v4);
      v287 = objc_msgSend(v353, "copyDescription");
      _NRLogWithArgs(v286, 1, "%s%.30s:%-4d %@: Serving Background channel", "", "NRLinkNexusToLinkLoop", 3624, v287);
      v343 = sub_100074C58;
      v338 = sub_100074844;
      v16 = &OBJC_IVAR___NRLinkBluetooth__syncNexusBKInput;
      v17 = &OBJC_IVAR___NRLinkBluetooth__bytesFromNexusBK;
      v18 = &OBJC_IVAR___NRLinkBluetooth__packetsFromNexusBK;
      v19 = &OBJC_IVAR___NRLinkBluetooth__nexusBKInputRing;
      goto LABEL_338;
    }
    v343 = sub_100074C58;
    v338 = sub_100074844;
    v16 = &OBJC_IVAR___NRLinkBluetooth__syncNexusBKInput;
    v17 = &OBJC_IVAR___NRLinkBluetooth__bytesFromNexusBK;
    v18 = &OBJC_IVAR___NRLinkBluetooth__packetsFromNexusBK;
    v19 = &OBJC_IVAR___NRLinkBluetooth__nexusBKInputRing;
  }
LABEL_22:
  v20 = &v5[*v17];
  v7 = *(_QWORD *)&v5[*v19];
  v21 = &v5[*v16];
  v336 = &v5[*v18];
  v337 = v21;
  v335 = v20;
  v333 = *(_QWORD *)v20;
  v332 = *(_QWORD *)v336;
LABEL_23:
  v339 = 0;
  v334 = (char *)&v367 + 8;
  v22 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
  v354 = v7;
  while (2)
  {
    v23 = 0;
    v347 = 0;
    ESPSequenceNumberFromPacket = 0;
    v24 = 0;
    v355 = 0;
    v356 = 0;
    v25 = 0;
    v352 = 0;
    v26 = 0;
    memset(v366, 0, sizeof(v366));
    v383 = 0;
    v384 = 0;
    v27 = *(_QWORD *)(v5 + 951);
    v357 = 0;
    v358 = v27;
LABEL_27:
    v28 = v354;
    while (1)
    {
      v29 = v23;
      v360 = 1919;
      *(_QWORD *)(v5 + 1919) = 2;
      v369 = 0u;
      v370 = 0u;
      v367 = 0u;
      v368 = 0u;
      if (v28)
      {
        v30 = v24;
        next_slot = os_channel_get_next_slot(v28, v352, &v367);
        if (next_slot && v349 == v350)
        {
          LODWORD(v24) = v30;
          if (v5[225])
          {
            v32 = (void *)next_slot;
            v351 = v25;
            v33 = v26;
            v34 = 0;
            if ((_QWORD)v368)
            {
              v4 = WORD1(v367);
              v35 = 0;
              if (WORD1(v367))
              {
                if (isPacketValidIPv6())
                {
                  DSCPFromPacket = getDSCPFromPacket(v368, WORD1(v367));
                  v37 = DSCPFromPacket == 46;
                  v38 = WORD1(v367) < 0x2A4u;
                  v35 = v37 && v38;
                  if (v37 && v38)
                    v34 = 46;
                  else
                    v34 = DSCPFromPacket;
                }
                else
                {
                  v34 = 0;
                  v35 = 0;
                }
                LODWORD(v24) = v30;
              }
            }
            else
            {
              v35 = 0;
            }
            if (gNRPacketLoggingEnabled)
            {
              ESPSequenceNumberFromPacket = getESPSequenceNumberFromPacket(v368, WORD1(v367));
              if (gNRPacketLoggingEnabled)
                getESPSPIFromPacket(v368, WORD1(v367));
              LODWORD(v24) = v30;
              if (v35)
              {
LABEL_74:
                v364 = 0u;
                v365 = 0u;
                v362 = 0u;
                v363 = 0u;
                v63 = os_channel_get_next_slot(*(_QWORD *)(v5 + 1055), v347, &v362);
                if (!v63)
                {
                  v26 = v33;
                  v25 = v351;
                  v6 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                  if (v5[224] && *(_QWORD *)(v5 + 1071))
                  {
                    v5[224] = 0;
                    ++*(_QWORD *)(v5 + 1087);
                    if (gNRPacketLoggingEnabled)
                    {
                      v155 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v64);
                      v156 = _NRLogIsLevelEnabled(v155, 1);

                      v22 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                      if (v156)
                      {
                        v158 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v157);
                        v159 = objc_msgSend(v5, "copyDescription");
                        _NRLogWithArgs(v158, 1, "%s%.30s:%-4d %@: source-resume: DatagramLinkOutput", "", "NRLinkResumeDatagramLinkOutputSource", 825, v159);

                        v22 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                      }
                    }
                    dispatch_resume(*(dispatch_object_t *)(v5 + 1071));
                  }
                  ((void (*)(char *))v343)(v5);
                  *(_QWORD *)&v5[v360] |= 4uLL;
                  LODWORD(v75) = 31;
                  v76 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                  v24 = v30;
                  v23 = v29;
                  goto LABEL_154;
                }
                v65 = v63;
                v26 = v33;
                if (!v5[224] && *(_QWORD *)(v5 + 1071))
                {
                  v66 = v63;
                  v5[224] = 1;
                  ++*(_QWORD *)(v5 + 1087);
                  if (gNRPacketLoggingEnabled)
                  {
                    v150 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v64);
                    v151 = _NRLogIsLevelEnabled(v150, 1);

                    if (v151)
                    {
                      v153 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v152);
                      v154 = objc_msgSend(v5, "copyDescription");
                      _NRLogWithArgs(v153, 1, "%s%.30s:%-4d %@: source-suspend: DatagramLinkOutput", "", "NRLinkSuspendDatagramLinkOutputSource", 817, v154);

                    }
                  }
                  dispatch_suspend(*(dispatch_object_t *)(v5 + 1071));
                  v65 = v66;
                }
                v67 = *(_QWORD *)(v5 + 1055);
                v359 = v65;
                packet = os_channel_slot_get_packet(v67, v65);
                next_buflet = os_packet_get_next_buflet(packet, 0);
                object_address = os_buflet_get_object_address();
                data_limit = os_buflet_get_data_limit(next_buflet);
                if (data_limit >= 0x10000)
                {
                  v272 = sub_100070AC8();
                  v273 = _NRLogIsLevelEnabled(v272, 16);

                  if (v273)
                  {
                    v274 = sub_100070AC8();
                    _NRLogWithArgs(v274, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: datagramBufferLength <= 65535", "", "NRLinkNexusToLinkLoop", 3763);

                  }
                  v275 = _os_log_pack_size(12);
                  v235 = (char *)&v331 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
                  v276 = *__error();
                  for (i = _os_log_pack_fill(v235, v275, v276, &_mh_execute_header, "%{public}s Assertion Failed: datagramBufferLength <= 65535");
                        ;
                        i = _os_log_pack_fill(v235, v257, v258, &_mh_execute_header, "%{public}s Assertion Failed: curLinkOutputSlot == highestLinkOutputSlotWrittenTo"))
                  {
LABEL_305:
                    *(_DWORD *)i = 136446210;
                    *(_QWORD *)(i + 4) = "NRLinkNexusToLinkLoop";
LABEL_306:
                    v253 = sub_100070AC8();
                    _NRLogAbortWithPack(v253, v235);
LABEL_307:
                    v254 = sub_100070AC8();
                    v255 = _NRLogIsLevelEnabled(v254, 16);

                    if (v255)
                    {
                      v256 = sub_100070AC8();
                      _NRLogWithArgs(v256, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: curLinkOutputSlot == highestLinkOutputSlotWrittenTo", "", "NRLinkNexusToLinkLoop", 4080);

                    }
                    v257 = _os_log_pack_size(12);
                    v235 = (char *)&v331 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
                    v258 = *__error();
                  }
                }
                v361[0] = object_address;
                v361[1] = data_limit;
                v72 = nrPacketToTLV(v368, WORD1(v367), v361, 1, v5 + 1951, v5 + 1967);
                *(_QWORD *)(v5 + 1399) += v72;
                *(_QWORD *)v335 += WORD1(v367);
                ++*(_QWORD *)v336;
                *(_QWORD *)&v5[v360] |= 0x10uLL;
                if (gNRPacketLoggingEnabled)
                {
                  v360 = v72;
                  v147 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v73);
                  LODWORD(v352) = _NRLogIsLevelEnabled(v147, 1);

                  LOWORD(v72) = v360;
                  if ((_DWORD)v352)
                  {
                    v352 = (id)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v148);
                    v149 = objc_msgSend(v5, "copyDescription");
                    _NRLogWithArgs(v352, 1, "%s%.30s:%-4d %@: wrote payload of length: %u, dscp: %u, uncompressedLen = %u", "", "NRLinkNexusToLinkLoop", 3782, v149, v360, v34, WORD1(v367));

                    LOWORD(v72) = v360;
                  }
                }
                os_buflet_set_data_length(next_buflet, (unsigned __int16)v72);
                v384 = ++v358;
                os_packet_set_flow_uuid(packet, &v383);
                v74 = os_packet_finalize(packet);
                if (!v74)
                {
                  LODWORD(v75) = 30;
                  v347 = v359;
                  v352 = v32;
                  v22 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                  v76 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                  v25 = v351;
                  v24 = v30;
                  v6 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                  v23 = v29;
                  goto LABEL_154;
                }
                v277 = v74;
                v328 = sub_100070AC8();
                v329 = _NRLogIsLevelEnabled(v328, 16);

                if (v329)
                {
                  v330 = sub_100070AC8();
                  _NRLogWithArgs(v330, 16, "%s%.30s:%-4d ABORTING: os_packet_finalize returned %d", "", "NRLinkNexusToLinkLoop", 3786, v277);

                }
LABEL_321:
                v281 = _os_log_pack_size(18);
                v235 = (char *)&v331 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
                v282 = *__error();
                v283 = _os_log_pack_fill(v235, v281, v282, &_mh_execute_header, "%{public}s os_packet_finalize returned %d");
                *(_DWORD *)v283 = 136446466;
                *(_QWORD *)(v283 + 4) = "NRLinkNexusToLinkLoop";
                *(_WORD *)(v283 + 12) = 1024;
                *(_DWORD *)(v283 + 14) = v277;
                goto LABEL_306;
              }
            }
            else
            {
              ESPSequenceNumberFromPacket = 0;
              if (v35)
                goto LABEL_74;
            }
            v26 = v33;
            v25 = v351;
            v6 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
          }
        }
        else
        {
          LODWORD(v24) = v30;
        }
      }
      v23 = v29;
      if ((_WORD)v29)
      {
        *(_QWORD *)&v5[v360] |= 0x40uLL;
        if (!v26)
          goto LABEL_177;
        goto LABEL_51;
      }
      v39 = v24;
      v40 = os_channel_get_next_slot(*(_QWORD *)&v5[v6[73]], v25, v366);
      if (!v40)
        break;
      v26 = v40;
      *(_QWORD *)&v5[v360] |= 0x20uLL;
      v357 = os_channel_slot_get_packet(*(_QWORD *)&v5[v6[73]], v40);
      v41 = os_packet_get_next_buflet(v357, 0);
      v355 = (char *)os_buflet_get_object_address();
      v356 = v41;
      v42 = os_buflet_get_data_limit(v41);
      if (v42 >= 0x10000)
      {
        v238 = sub_100070AC8();
        v239 = _NRLogIsLevelEnabled(v238, 16);

        if (v239)
        {
          v240 = sub_100070AC8();
          _NRLogWithArgs(v240, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: outputBufferLength <= 65535", "", "NRLinkNexusToLinkLoop", 3809);

        }
        goto LABEL_284;
      }
      LODWORD(v24) = v42;
LABEL_51:
      v43 = v5[222];
      LODWORD(v359) = v24;
      if (!v43 && *(_QWORD *)(v5 + 991))
      {
        v5[222] = 1;
        ++*(_QWORD *)(v5 + 1007);
        if (gNRPacketLoggingEnabled)
        {
          v58 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v4);
          v59 = _NRLogIsLevelEnabled(v58, 1);

          v22 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
          if (v59)
          {
            v61 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v60);
            v62 = objc_msgSend(v5, "copyDescription");
            _NRLogWithArgs(v61, 1, "%s%.30s:%-4d %@: source-suspend: LinkOutput", "", "NRLinkSuspendLinkOutputSource", 815, v62);

            v22 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
          }
        }
        dispatch_suspend(*(dispatch_object_t *)(v5 + 991));
        LODWORD(v24) = v359;
      }
      v44 = (unsigned __int16)v24;
      v45 = *(_DWORD *)(v5 + 287);
      v46 = *(unsigned int *)&v5[v22[120]];
      if (v45 <= v46)
        goto LABEL_84;
      v47 = v45 - v46;
      if (v47 >= (unsigned __int16)(v24 - v29))
        v48 = v24 - v29;
      else
        v48 = v47;
      v49 = v24;
      memcpy(v355, (const void *)(*(_QWORD *)(v5 + 447) + v46), (unsigned __int16)v48);
      *(_DWORD *)&v5[v22[120]] += (unsigned __int16)v48;
      *(_QWORD *)(v5 + 1383) += (unsigned __int16)v48;
      ++*(_DWORD *)(v5 + 295);
      v50 = v25;
      v25 = v26;
      v51 = v358;
      if (v50 != v26)
        v51 = v358 + 1;
      *(_QWORD *)&v5[v360] |= 0x100uLL;
      v358 = v51;
      if (gNRPacketLoggingEnabled)
      {
        v54 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v353 + 4), v4);
        v55 = _NRLogIsLevelEnabled(v54, 1);

        v51 = v358;
        if (v55)
        {
          v56 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v353 + 4), v4);
          v57 = objc_msgSend(v353, "copyDescription");
          _NRLogWithArgs(v56, 1, "%s%.30s:%-4d %@: wrote %u bytes from linkWriteBuffer to link, filledIn=%u handled=%u", "", "NRLinkNexusToLinkLoop", 3865, v57, (unsigned __int16)v48, *(unsigned int *)(v353 + 287), *(unsigned int *)(v353 + 291));

          v51 = v358;
        }
      }
      v23 = v48 + v23;
      v52 = (unsigned __int16)v23 == (unsigned __int16)v49;
      if ((unsigned __int16)v23 < (unsigned __int16)v49)
      {
        LODWORD(v24) = v49;
        v6 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
        v5 = v353;
        v28 = v354;
        v22 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
LABEL_84:
        if (!v28)
        {
          v175 = v5[16];
          v345 = v26;
          if (v175 == 8)
          {
            v176 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v4);
            v177 = _NRLogIsLevelEnabled(v176, 17);

            if (v177)
            {
              v178 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v4);
              v179 = objc_msgSend(v5, "copyDescription");
              _NRLogWithArgs(v178, 17, "%@: Tried to nexusToLinkLoop but _nexusInputRing is NULL", v179);

            }
            v76 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
            v161 = v347;
            LODWORD(v24) = v359;
          }
          else
          {
            *(_QWORD *)&v5[v360] |= 0x400uLL;
            v76 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
LABEL_225:
            v161 = v347;
          }
          goto LABEL_184;
        }
        v364 = 0u;
        v365 = 0u;
        v362 = 0u;
        v363 = 0u;
        v77 = os_channel_get_next_slot(v28, v352, &v362);
        if (!v77)
        {
          ((void (*)(char *))v338)(v5);
          *(_QWORD *)&v5[v360] |= 0x800uLL;
          LODWORD(v75) = 31;
          v339 = 1;
          v76 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
          v24 = v359;
          goto LABEL_154;
        }
        v78 = (unsigned __int16)v23;
        v340 = (unsigned __int16)v23 == 0;
        v341 = (void *)v77;
        v79 = v358;
        if (!(_WORD)v23)
          v79 = v358 + 1;
        v344 = v79;
        ((void (*)(char *))v343)(v5);
        v342 = v23;
        if (!gNRPacketLoggingEnabled)
        {
          ESPSequenceNumberFromPacket = 0;
          goto LABEL_90;
        }
        v351 = v25;
        ESPSequenceNumberFromPacket = getESPSequenceNumberFromPacket(v363, WORD1(v362));
        if (!gNRPacketLoggingEnabled)
          goto LABEL_175;
        v123 = v26;
        getESPSPIFromPacket(v363, WORD1(v362));
        if (!gNRPacketLoggingEnabled)
        {
          v22 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
LABEL_175:
          v25 = v351;
          LOWORD(v23) = v342;
          v5 = v353;
          goto LABEL_90;
        }
        v125 = WORD1(v362);
        v5 = v353;
        v126 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v353 + 4), v124);
        v127 = _NRLogIsLevelEnabled(v126, 1);

        LOWORD(v23) = v342;
        if (v127)
        {
          v129 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v353 + 4), v128);
          v130 = objc_msgSend(v353, "copyDescription");
          _NRLogWithArgs(v129, 1, "%s%.30s:%-4d %@: Sending ESP sequence number - to be sent: %u (%u bytes)", "", "NRLinkNexusToLinkLoop", 3918, v130, ESPSequenceNumberFromPacket, v125);

        }
        v22 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
        v26 = v123;
        v25 = v351;
LABEL_90:
        v346 = nrMaxTLVLengthForPacket(v363, WORD1(v362));
        v381 = 0u;
        v382 = 0u;
        v379 = 0u;
        v380 = 0u;
        v377 = 0u;
        v378 = 0u;
        v375 = 0u;
        v376 = 0u;
        v373 = 0u;
        v374 = 0u;
        v371 = 0u;
        v372 = 0u;
        v369 = 0u;
        v370 = 0u;
        v24 = v359;
        v367 = 0u;
        v368 = 0u;
        if ((unsigned __int16)v359 <= (unsigned __int16)v23)
        {
          v80 = 0;
          v81 = 0;
        }
        else
        {
          *(_QWORD *)&v367 = &v355[(unsigned __int16)v23];
          v80 = v44 - v78;
          DWORD2(v367) = v44 - v78;
          v81 = 1;
        }
        if (v80 < v346)
        {
          v351 = v25;
          v82 = v26;
          v83 = v81;
          v345 = v82;
          v84 = (unsigned int *)&v334[16 * v81];
          v85 = v346;
          do
          {
            memset(v361, 0, sizeof(v361));
            v86 = os_channel_get_next_slot(*(_QWORD *)(v5 + 975), v82, v361);
            if (!v86)
              break;
            v82 = v86;
            v87 = os_channel_slot_get_packet(*(_QWORD *)(v5 + 975), v86);
            v88 = os_packet_get_next_buflet(v87, 0);
            v89 = os_buflet_get_object_address();
            v90 = os_buflet_get_data_limit(v88);
            if (v90 >= 0x10000)
            {
              if (qword_1001E46D8 != -1)
                dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
              if (_NRLogIsLevelEnabled(qword_1001E46D0, 16))
              {
                v247 = sub_100070AC8();
                _NRLogWithArgs(v247, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: lookAheadLinkOutputBufferLength <= 65535", "", "NRLinkNexusToLinkLoop", 3946);

              }
              v248 = _os_log_pack_size(12);
              v235 = (char *)&v331 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
              v249 = *__error();
              i = _os_log_pack_fill(v235, v248, v249, &_mh_execute_header, "%{public}s Assertion Failed: lookAheadLinkOutputBufferLength <= 65535");
              goto LABEL_305;
            }
            *((_QWORD *)v84 - 1) = v89;
            if (!v90)
            {
              if (qword_1001E46D8 != -1)
                dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
              if (_NRLogIsLevelEnabled(qword_1001E46D0, 16))
              {
                v250 = sub_100070AC8();
                _NRLogWithArgs(v250, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: lookAheadLinkOutputBufferLength > 0", "", "NRLinkNexusToLinkLoop", 3949);

              }
              v251 = _os_log_pack_size(12);
              v235 = (char *)&v331 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
              v252 = *__error();
              i = _os_log_pack_fill(v235, v251, v252, &_mh_execute_header, "%{public}s Assertion Failed: lookAheadLinkOutputBufferLength > 0");
              goto LABEL_305;
            }
            *v84 = v90;
            *(_QWORD *)&v5[v360] |= 0x1000uLL;
            if (v83 == 15)
            {
              v96 = (void *)createIOVecString(&v367, 16);
              sub_100074F70(v5, CFSTR("NtL not enough ioVecs %@ for %u"), v97, v98, v99, v100, v101, v102, (uint64_t)v96);

              LODWORD(v75) = 1;
              v6 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
              v22 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
              v76 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
              v26 = v345;
              v25 = v351;
              v24 = v359;
              v23 = v342;
              goto LABEL_153;
            }
            ++v83;
            v80 += v90;
            v84 += 4;
          }
          while (v80 < v85);
          LOWORD(v81) = v83;
          v22 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
          v26 = v345;
          v25 = v351;
          v24 = v359;
        }
        if (v80 < v346)
        {
          *(_QWORD *)&v5[v360] |= 0x2000uLL;
          v6 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
          if (v5[222])
          {
            v76 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
            v23 = v342;
            if (*(_QWORD *)(v5 + 991))
            {
              v5[222] = 0;
              ++*(_QWORD *)(v5 + 1007);
              if (gNRPacketLoggingEnabled)
              {
                v142 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v4);
                v143 = _NRLogIsLevelEnabled(v142, 1);

                v22 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                if (v143)
                {
                  v145 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v144);
                  v146 = objc_msgSend(v5, "copyDescription");
                  _NRLogWithArgs(v145, 1, "%s%.30s:%-4d %@: source-resume: LinkOutput", "", "NRLinkResumeLinkOutputSource", 823, v146);

                  v22 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                }
              }
              dispatch_resume(*(dispatch_object_t *)(v5 + 991));
              LODWORD(v75) = 31;
              v24 = v359;
            }
            else
            {
              LODWORD(v75) = 31;
            }
          }
          else
          {
            LODWORD(v75) = 31;
            v76 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
            v23 = v342;
          }
          goto LABEL_153;
        }
        if (!(_QWORD)v367)
        {
          v259 = sub_100070AC8();
          v260 = _NRLogIsLevelEnabled(v259, 16);

          if (v260)
          {
            v261 = sub_100070AC8();
            v262 = (void *)createIOVecString(&v367, (unsigned __int16)v81);
            _NRLogWithArgs(v261, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: ioVecs[0].buf != ((void *)0); We have enough content but first ioVec is NULL: %@",
              "",
              "NRLinkNexusToLinkLoop",
              3978,
              v262);

          }
          v263 = _os_log_pack_size(22);
          v235 = (char *)&v331 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
          v264 = __error();
          v265 = _os_log_pack_fill(v235, v263, *v264, &_mh_execute_header, "%{public}s Assertion Failed: ioVecs[0].buf != ((void *)0); We have enough content but first ioVec is NULL: %@");
          v266 = createIOVecString(&v367, (unsigned __int16)v81);
          *(_DWORD *)v265 = 136446466;
          *(_QWORD *)(v265 + 4) = "NRLinkNexusToLinkLoop";
          *(_WORD *)(v265 + 12) = 2112;
          *(_QWORD *)(v265 + 14) = v266;
          goto LABEL_306;
        }
        if (gNRPacketLoggingEnabled)
        {
          v131 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v4);
          v132 = _NRLogIsLevelEnabled(v131, 1);

          if (v132)
          {
            v134 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v133);
            v135 = objc_msgSend(v5, "copyDescription");
            v136 = getDSCPFromPacket(v363, WORD1(v362));
            _NRLogWithArgs(v134, 1, "%s%.30s:%-4d %@: DSCP: %u", "", "NRLinkNexusToLinkLoop", 3982, v135, v136);

          }
        }
        v91 = nrPacketToTLV(v363, WORD1(v362), &v367, (unsigned __int16)v81, v5 + 1951, v5 + 1967);
        v92 = v91;
        v93 = *(unsigned __int8 *)v367;
        v94 = v344;
        v24 = v359;
        switch(*(_BYTE *)v367)
        {
          case 'd':
            v95 = &OBJC_IVAR___NRLinkBluetooth__sentKnownIPv6Hdr_ESP;
            goto LABEL_128;
          case 'e':
            v95 = &OBJC_IVAR___NRLinkBluetooth__sentKnownIPv6Hdr_ESP_ECT0;
            goto LABEL_128;
          case 'f':
            v95 = &OBJC_IVAR___NRLinkBluetooth__sentKnownIPv6Hdr_TCP;
            goto LABEL_128;
          case 'g':
            v95 = &OBJC_IVAR___NRLinkBluetooth__sentKnownIPv6Hdr_TCP_ECT0;
            goto LABEL_128;
          case 'h':
            v95 = &OBJC_IVAR___NRLinkBluetooth__sentKnownIPv6Hdr_ESP_ClassC;
            goto LABEL_128;
          case 'i':
            v95 = &OBJC_IVAR___NRLinkBluetooth__sentKnownIPv6Hdr_ESP_ClassC_ECT0;
            goto LABEL_128;
          default:
            v24 = v359;
            if (v93 == 2)
            {
              v95 = &OBJC_IVAR___NRLinkBluetooth__sentUncompressedIP;
            }
            else
            {
              if (v93 != 3)
                goto LABEL_129;
              v95 = &OBJC_IVAR___NRLinkBluetooth__sentEncapsulated6LoWPAN;
            }
LABEL_128:
            ++*(_QWORD *)&v5[*v95];
LABEL_129:
            *(_QWORD *)(v5 + 1383) += v91;
            v103 = (unsigned __int16)(v24 - v342);
            if (v91 <= v103)
            {
              v114 = v342 + v91;
              goto LABEL_143;
            }
            v104 = v26;
            *(_QWORD *)&v5[v360] |= 0x4000uLL;
            if (gNRPacketLoggingEnabled)
            {
              v137 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v4);
              v138 = _NRLogIsLevelEnabled(v137, 1);

              if (v138)
              {
                v140 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v139);
                v141 = objc_msgSend(v5, "copyDescription");
                _NRLogWithArgs(v140, 1, "%s%.30s:%-4d %@: Sending ESP sequence number %u (2)", "", "NRLinkNexusToLinkLoop", 4025, v141, ESPSequenceNumberFromPacket);

              }
            }
            v384 = v94;
            os_buflet_set_data_length(v356, v44);
            os_packet_set_flow_uuid(v357, &v383);
            v105 = os_packet_finalize(v357);
            if (v105)
            {
              v292 = v105;
              v325 = sub_100070AC8();
              v326 = _NRLogIsLevelEnabled(v325, 16);

              if (v326)
              {
                v327 = sub_100070AC8();
                _NRLogWithArgs(v327, 16, "%s%.30s:%-4d ABORTING: os_packet_finalize returned %d", "", "NRLinkNexusToLinkLoop", 4029, v292);

              }
LABEL_331:
              v5 = (char *)_os_log_pack_size(18);
              v296 = (char *)&v331 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
              v297 = *__error();
              v298 = _os_log_pack_fill(v296, v5, v297, &_mh_execute_header, "%{public}s os_packet_finalize returned %d");
              *(_DWORD *)v298 = 136446466;
              *(_QWORD *)(v298 + 4) = "NRLinkNexusToLinkLoop";
              *(_WORD *)(v298 + 12) = 1024;
              *(_DWORD *)(v298 + 14) = v292;
              v299 = sub_100070AC8();
              _NRLogAbortWithPack(v299, v296);
LABEL_332:
              v300 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v4);
              v301 = _NRLogIsLevelEnabled(v300, 1);

              if (v301)
              {
                v303 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v302);
                v304 = objc_msgSend(v5, "copyDescription");
                _NRLogWithArgs(v303, 1, "%s%.30s:%-4d %@: source-resume: NexusInput", "", "NRLinkResumeNexusInputSource", 842, v304);

              }
LABEL_261:
              dispatch_resume(*(dispatch_object_t *)&v5[*(int *)(v44 + 812)]);
              goto LABEL_262;
            }
            v94 = v358 + v340 + 1;
            while (1)
            {
              v106 = os_channel_get_next_slot(*(_QWORD *)(v5 + 975), v104, v366);
              if (!v106)
              {
                if (qword_1001E46D8 != -1)
                  dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
                if (_NRLogIsLevelEnabled(qword_1001E46D0, 16))
                {
                  v243 = sub_100070AC8();
                  _NRLogWithArgs(v243, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (curLinkOutputSlot) != ((void *)0)", "", "NRLinkNexusToLinkLoop", 4037);

                }
                v244 = _os_log_pack_size(12);
                v235 = (char *)&v331 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
                v245 = *__error();
                i = _os_log_pack_fill(v235, v244, v245, &_mh_execute_header, "%{public}s Assertion Failed: (curLinkOutputSlot) != ((void *)0)");
                goto LABEL_305;
              }
              v26 = v106;
              v357 = os_channel_slot_get_packet(*(_QWORD *)(v5 + 975), v106);
              v44 = os_packet_get_next_buflet(v357, 0);
              v355 = (char *)os_buflet_get_object_address();
              v356 = v44;
              v107 = os_buflet_get_data_limit(v44);
              if (v107 >= 0x10000)
              {
                if (qword_1001E46D8 != -1)
                  dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
                if (_NRLogIsLevelEnabled(qword_1001E46D0, 16))
                {
                  v246 = sub_100070AC8();
                  _NRLogWithArgs(v246, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: outputBufferLength <= 65535", "", "NRLinkNexusToLinkLoop", 4044);

                }
LABEL_284:
                v241 = _os_log_pack_size(12);
                v235 = (char *)&v331 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
                v242 = *__error();
                i = _os_log_pack_fill(v235, v241, v242, &_mh_execute_header, "%{public}s Assertion Failed: outputBufferLength <= 65535");
                goto LABEL_305;
              }
              v24 = v107;
              v108 = v107 + v103;
              if (v107 + v103 >= v92)
                break;
              v104 = v26;
              *(_QWORD *)&v5[v360] |= 0x8000uLL;
              if (gNRPacketLoggingEnabled)
              {
                v110 = v107;
                v44 = _NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v4);
                v111 = _NRLogIsLevelEnabled(v44, 1);

                v24 = v110;
                if (v111)
                {
                  v44 = _NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v112);
                  v113 = objc_msgSend(v5, "copyDescription");
                  _NRLogWithArgs(v44, 1, "%s%.30s:%-4d %@: Sending ESP sequence number %u (3)", "", "NRLinkNexusToLinkLoop", 4057, v113, ESPSequenceNumberFromPacket);

                  v24 = v110;
                }
              }
              v384 = v94;
              os_buflet_set_data_length(v356, v24);
              os_packet_set_flow_uuid(v357, &v383);
              v109 = os_packet_finalize(v357);
              ++v94;
              v103 = v108;
              if (v109)
              {
                v292 = v109;
                v293 = sub_100070AC8();
                v294 = _NRLogIsLevelEnabled(v293, 16);

                if (v294)
                {
                  v295 = sub_100070AC8();
                  _NRLogWithArgs(v295, 16, "%s%.30s:%-4d ABORTING: os_packet_finalize returned %d", "", "NRLinkNexusToLinkLoop", 4061, v292);

                }
                goto LABEL_331;
              }
            }
            v114 = v92 - v103;
LABEL_143:
            v344 = v94;
            v115 = v335;
            ++*(_QWORD *)v336;
            *(_QWORD *)v115 += WORD1(v362);
            *(_QWORD *)&v5[v360] |= 0x10000uLL;
            v75 = *(_QWORD *)(v5 + 1919);
            v22 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
            v6 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
            if (!v75)
            {
              v25 = v26;
              v352 = v341;
              v76 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
              v23 = v114;
              goto LABEL_153;
            }
            v76 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
            v75 = *(_QWORD *)(v5 + 1927);
            v23 = v114;
            if (!v75)
              goto LABEL_152;
            v5[257] = v5[257] % v5[256];
            v116 = *(_QWORD *)(v5 + 1927);
            v117 = (_QWORD *)(v116 + 8 * v5[257]);
            if ((unint64_t)(v117 + 1) <= v116 + 8 * (unint64_t)v5[256])
            {
              LODWORD(v75) = 0;
              if ((v117 & 7) == 0)
              {
                *v117 = *(_QWORD *)(v5 + 1919);
                ++v5[257];
                *(_QWORD *)(v5 + 1919) = 0;
              }
LABEL_152:
              v25 = v26;
              v352 = v341;
              goto LABEL_153;
            }
            v118 = v24;
            v119 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v4);
            v120 = _NRLogIsLevelEnabled(v119, 17);

            if (v120)
            {
              v121 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v4);
              v122 = objc_msgSend(v5, "copyDescription");
              _NRLogWithArgs(v121, 17, "%@: invalid index for ntl log list (curIdx: %u)", v122, v5[257]);

            }
            LODWORD(v75) = 0;
            v25 = v26;
            v352 = v341;
            v22 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
            v24 = v118;
            v23 = v114;
LABEL_153:
            v358 = v344;
LABEL_154:
            if ((_DWORD)v75 && (_DWORD)v75 != 30)
            {
              if ((_DWORD)v75 == 31)
              {
                v345 = v26;
                goto LABEL_225;
              }
              goto LABEL_25;
            }
            break;
        }
        goto LABEL_27;
      }
      v6 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
      v5 = v353;
      v28 = v354;
      if (!v52)
      {
        if (qword_1001E46D8 != -1)
          dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
        v231 = (id)qword_1001E46D0;
        v232 = _NRLogIsLevelEnabled(v231, 16);

        if (v232)
        {
          if (qword_1001E46D8 != -1)
            dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
          v233 = (id)qword_1001E46D0;
          _NRLogWithArgs(v233, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: curLinkOutputSlotPartialBytesAlreadyWritten == linkOutputBufferLength", "", "NRLinkNexusToLinkLoop", 3868);

        }
        v234 = _os_log_pack_size(12);
        v235 = (char *)&v331 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
        v236 = *__error();
        i = _os_log_pack_fill(v235, v234, v236, &_mh_execute_header, "%{public}s Assertion Failed: curLinkOutputSlotPartialBytesAlreadyWritten == linkOutputBufferLength");
        goto LABEL_305;
      }
      os_buflet_set_data_length(v356, v44);
      v384 = v51;
      os_packet_set_flow_uuid(v357, &v383);
      v53 = os_packet_finalize(v357);
      if (v53)
      {
        v277 = v53;
        v278 = sub_100070AC8();
        v279 = _NRLogIsLevelEnabled(v278, 16);

        if (v279)
        {
          v280 = sub_100070AC8();
          _NRLogWithArgs(v280, 16, "%s%.30s:%-4d ABORTING: os_packet_finalize returned %d", "", "NRLinkNexusToLinkLoop", 3876, v277);

        }
        goto LABEL_321;
      }
      v23 = 0;
      *(_QWORD *)&v353[v360] |= 0x200uLL;
      v22 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
      v24 = v359;
    }
    LODWORD(v29) = 0;
    LODWORD(v24) = v39;
LABEL_177:
    v160 = v24;
    v161 = v347;
    if (v5[222] && *(_QWORD *)(v5 + 991))
    {
      v5[222] = 0;
      ++*(_QWORD *)(v5 + 1007);
      if (gNRPacketLoggingEnabled)
      {
        v217 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v4);
        v218 = _NRLogIsLevelEnabled(v217, 1);

        v161 = v347;
        if (v218)
        {
          v220 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v219);
          v221 = objc_msgSend(v5, "copyDescription");
          _NRLogWithArgs(v220, 1, "%s%.30s:%-4d %@: source-resume: LinkOutput", "", "NRLinkResumeLinkOutputSource", 823, v221);

          v161 = v347;
        }
      }
      dispatch_resume(*(dispatch_object_t *)(v5 + 991));
    }
    ((void (*)(char *))v343)(v5);
    *(_QWORD *)&v5[v360] |= 0x80uLL;
    if (gNRPacketLoggingEnabled)
    {
      v180 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v4);
      v181 = _NRLogIsLevelEnabled(v180, 1);

      v76 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
      if (v181)
      {
        v182 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v4);
        v183 = objc_msgSend(v5, "copyDescription");
        _NRLogWithArgs(v182, 1, "%s%.30s:%-4d %@: no link output slot", "", "NRLinkNexusToLinkLoop", 3823, v183);

      }
      v345 = 0;
      v161 = v347;
    }
    else
    {
      v345 = 0;
      v76 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
    }
    LODWORD(v24) = v160;
    LODWORD(v23) = v29;
LABEL_184:
    if (v25)
    {
      if (v345 != v25)
        goto LABEL_307;
      v347 = v161;
      v162 = 0x40000;
      if ((unsigned __int16)v23 != (unsigned __int16)v24 && (unsigned __int16)v23 != 0)
      {
        v162 = 0x20000;
        v44 = v23;
      }
      else
      {
        v44 = v24;
      }
      *(_QWORD *)(v5 + 1919) |= v162;
      if (gNRPacketLoggingEnabled)
      {
        v196 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v4);
        v197 = _NRLogIsLevelEnabled(v196, 1);

        if (v197)
        {
          v199 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v198);
          v200 = objc_msgSend(v5, "copyDescription");
          _NRLogWithArgs(v199, 1, "%s%.30s:%-4d %@: Sending ESP sequence number %u (4)", "", "NRLinkNexusToLinkLoop", 4094, v200, ESPSequenceNumberFromPacket);

        }
      }
      v384 = v358;
      os_buflet_set_data_length(v356, (unsigned __int16)v44);
      os_packet_set_flow_uuid(v357, &v383);
      v163 = os_packet_finalize(v357);
      if (v163)
      {
        v292 = v163;
        v322 = sub_100070AC8();
        v323 = _NRLogIsLevelEnabled(v322, 16);

        if (v323)
        {
          v324 = sub_100070AC8();
          _NRLogWithArgs(v324, 16, "%s%.30s:%-4d ABORTING: os_packet_finalize returned %d", "", "NRLinkNexusToLinkLoop", 4098, v292);

        }
        goto LABEL_331;
      }
      v165 = *(_DWORD *)(v5 + 287);
      v166 = *(_DWORD *)(v5 + 291);
      if (v165 <= v166)
      {
        if (v165 != v166)
        {
          v267 = sub_100070AC8();
          v268 = _NRLogIsLevelEnabled(v267, 16);

          if (v268)
          {
            v269 = sub_100070AC8();
            _NRLogWithArgs(v269, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: self->_filledInLinkWriteBufferBytes == self->_handledLinkWriteBufferBytes", "", "NRLinkNexusToLinkLoop", 4112);

          }
          v270 = _os_log_pack_size(12);
          v235 = (char *)&v331 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
          v271 = *__error();
          i = _os_log_pack_fill(v235, v270, v271, &_mh_execute_header, "%{public}s Assertion Failed: self->_filledInLinkWriteBufferBytes == self->_handledLinkWriteBufferBytes");
          goto LABEL_305;
        }
        if (gNRPacketLoggingEnabled)
        {
          if (v165)
          {
            *(_QWORD *)(v5 + 1919) |= 0x100000uLL;
            v227 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v164);
            v228 = _NRLogIsLevelEnabled(v227, 1);

            if (v228)
            {
              v229 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v164);
              v230 = objc_msgSend(v5, "copyDescription");
              _NRLogWithArgs(v229, 1, "%s%.30s:%-4d %@: resetting the linkWriteBuffer from filledIn=%u handled=%u", "", "NRLinkNexusToLinkLoop", 4115, v230, *(unsigned int *)(v5 + 287), *(unsigned int *)(v5 + 291));

            }
          }
        }
        *(_DWORD *)(v5 + 287) = 0;
      }
      else
      {
        *(_QWORD *)(v5 + 1919) |= 0x80000uLL;
        if (gNRPacketLoggingEnabled)
        {
          v222 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v164);
          v223 = _NRLogIsLevelEnabled(v222, 1);

          if (v223)
          {
            v225 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v224);
            v226 = objc_msgSend(v5, "copyDescription");
            _NRLogWithArgs(v225, 1, "%s%.30s:%-4d %@: memmoving the linkWriteBuffer from filledIn=%u handled=%u", "", "NRLinkNexusToLinkLoop", 4106, v226, *(unsigned int *)(v5 + 287), *(unsigned int *)(v5 + 291));

          }
        }
        memmove(*(void **)(v5 + 447), (const void *)(*(_QWORD *)(v5 + 447) + *(unsigned int *)(v5 + 291)), (*(_DWORD *)(v5 + 287) - *(_DWORD *)(v5 + 291)));
        *(_DWORD *)(v5 + 287) -= *(_DWORD *)(v5 + 291);
      }
      *(_DWORD *)(v5 + 291) = 0;
      *(_QWORD *)(v5 + 1919) |= 0x200000uLL;
      v167 = v345;
      if (gNRPacketLoggingEnabled)
      {
        v201 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v164);
        v202 = _NRLogIsLevelEnabled(v201, 1);

        if (v202)
        {
          v204 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v203);
          v205 = objc_msgSend(v5, "copyDescription");
          _NRLogWithArgs(v204, 1, "%s%.30s:%-4d %@: advancing past linkOutputSlot=%p and syncing link output", "", "NRLinkNexusToLinkLoop", 4121, v205, v345);

        }
        v167 = v345;
        if (gNRPacketLoggingEnabled)
        {
          v206 = objc_claimAutoreleasedReturnValue(+[NSDate date](NSDate, "date"));
          v207 = *(void **)(v5 + 1687);
          *(_QWORD *)(v5 + 1687) = v206;

        }
      }
      os_channel_advance_slot(*(_QWORD *)&v5[v6[73]], v167);
      os_channel_sync(*(_QWORD *)(v5 + 959), 0);
      ++*(_QWORD *)(v5 + 1431);
      v161 = v347;
    }
    if (v161)
    {
      *(_QWORD *)(v5 + 1919) |= 0x800000uLL;
      if (gNRPacketLoggingEnabled)
      {
        v184 = v161;
        v185 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v4);
        v186 = _NRLogIsLevelEnabled(v185, 1);

        if (v186)
        {
          v188 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v187);
          v189 = objc_msgSend(v5, "copyDescription");
          _NRLogWithArgs(v188, 1, "%s%.30s:%-4d %@: DatagramLink:advancing past linkOutputSlot=%p and syncing datagram link output", "", "NRLinkNexusToLinkLoop", 4132, v189, v184);

        }
        v161 = v184;
        if (gNRPacketLoggingEnabled)
        {
          v190 = objc_claimAutoreleasedReturnValue(+[NSDate date](NSDate, "date"));
          v191 = *(void **)(v5 + 1703);
          *(_QWORD *)(v5 + 1703) = v190;

        }
      }
      os_channel_advance_slot(*(_QWORD *)(v5 + 1055), v161);
      os_channel_sync(*(_QWORD *)(v5 + 1039), 0);
      ++*(_QWORD *)(v5 + 1447);
    }
    v168 = v161;
    if (v352)
    {
      if (v354)
      {
        *(_QWORD *)(v5 + 1919) |= 0x1000000uLL;
        if (gNRPacketLoggingEnabled)
        {
          v208 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v4);
          v209 = _NRLogIsLevelEnabled(v208, 1);

          if (v209)
          {
            v211 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v210);
            v212 = objc_msgSend(v5, "copyDescription");
            _NRLogWithArgs(v211, 1, "%s%.30s:%-4d %@: advancing past nexusInputSlot=%p and syncing nexus input", "", "NRLinkNexusToLinkLoop", 4142, v212, v352);

          }
          if (gNRPacketLoggingEnabled)
          {
            v213 = objc_claimAutoreleasedReturnValue(+[NSDate date](NSDate, "date"));
            v214 = *(void **)(v5 + 1663);
            *(_QWORD *)(v5 + 1663) = v213;

          }
        }
        os_channel_advance_slot(v354, v352);
        os_channel_sync(v350, 1);
        ++*(_QWORD *)v337;
        if (gNRPacketLoggingEnabled)
        {
          v215 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v4);
          v216 = _NRLogIsLevelEnabled(v215, 1);

          if (v216)
          {
            v194 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v4);
            v195 = objc_msgSend(v5, "copyDescription");
            _NRLogWithArgs(v194, 1, "%s%.30s:%-4d %@: Served %llu packets, %llu bytes", "", "NRLinkNexusToLinkLoop", 4148, v195, *(_QWORD *)v336 - v332, *(_QWORD *)v335 - v333);
LABEL_247:

          }
        }
      }
      else
      {
        v192 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v4);
        v193 = _NRLogIsLevelEnabled(v192, 17);

        if (v193)
        {
          v194 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v4);
          v195 = objc_msgSend(v5, "copyDescription");
          _NRLogWithArgs(v194, 17, "%@: Tried to sync nexus input but _nexusInputRing is NULL", v195);
          goto LABEL_247;
        }
      }
    }
    *(_QWORD *)(v5 + 951) = v358;
    if (*(_QWORD *)(v5 + 1919) && *(_QWORD *)&v5[v76[196]])
    {
      v5[257] = v5[257] % v5[256];
      v169 = *(_QWORD *)&v5[v76[196]];
      v170 = (_QWORD *)(v169 + 8 * v5[257]);
      if ((unint64_t)(v170 + 1) <= v169 + 8 * (unint64_t)v5[256])
      {
        if ((v170 & 7) == 0)
        {
          *v170 = *(_QWORD *)(v5 + 1919);
          ++v5[257];
          *(_QWORD *)(v5 + 1919) = 0;
        }
      }
      else
      {
        v171 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v4);
        v172 = _NRLogIsLevelEnabled(v171, 17);

        if (v172)
        {
          v173 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v4);
          v174 = objc_msgSend(v5, "copyDescription");
          _NRLogWithArgs(v173, 17, "%@: invalid index for ntl log list (curIdx: %u)", v174, v5[257]);

        }
      }
    }
    LODWORD(v75) = 0;
    if (v352)
    {
      v22 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
      goto LABEL_25;
    }
    v22 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
    if (v25 || v168)
    {
LABEL_25:
      if ((_DWORD)v75)
        goto LABEL_266;
      continue;
    }
    break;
  }
  if ((v339 & 1) != 0)
  {
    if (!*(_QWORD *)(v5 + 1111))
    {
      if (v5[214] && *(_QWORD *)(v5 + 551))
      {
        v5[214] = 0;
        ++*(_QWORD *)(v5 + 567);
        if (gNRPacketLoggingEnabled)
        {
          v312 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v4);
          v313 = _NRLogIsLevelEnabled(v312, 1);

          if (v313)
          {
            v315 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v314);
            v316 = objc_msgSend(v5, "copyDescription");
            _NRLogWithArgs(v315, 1, "%s%.30s:%-4d %@: source-resume: NexusVOInput", "", "NRLinkResumeNexusVOInputSource", 844, v316);

          }
        }
        dispatch_resume(*(dispatch_object_t *)(v5 + 551));
      }
      if (v5[216] && *(_QWORD *)(v5 + 695))
      {
        v5[216] = 0;
        ++*(_QWORD *)(v5 + 711);
        if (gNRPacketLoggingEnabled)
        {
          v317 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v4);
          v318 = _NRLogIsLevelEnabled(v317, 1);

          if (v318)
          {
            v320 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v319);
            v321 = objc_msgSend(v5, "copyDescription");
            _NRLogWithArgs(v320, 1, "%s%.30s:%-4d %@: source-resume: NexusVIInput", "", "NRLinkResumeNexusVIInputSource", 846, v321);

          }
        }
        dispatch_resume(*(dispatch_object_t *)(v5 + 695));
      }
    }
    if (v5[212])
    {
      v44 = (unint64_t)&OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
      if (*(_QWORD *)(v5 + 391))
      {
        v5[212] = 0;
        ++*(_QWORD *)(v5 + 415);
        if (gNRPacketLoggingEnabled)
          goto LABEL_332;
        goto LABEL_261;
      }
    }
LABEL_262:
    if (v5[218] && *(_QWORD *)(v5 + 839))
    {
      v5[218] = 0;
      ++*(_QWORD *)(v5 + 855);
      if (gNRPacketLoggingEnabled)
      {
        v305 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v4);
        v306 = _NRLogIsLevelEnabled(v305, 1);

        if (v306)
        {
          v308 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v5 + 4), v307);
          v309 = objc_msgSend(v5, "copyDescription");
          _NRLogWithArgs(v308, 1, "%s%.30s:%-4d %@: source-resume: NexusBKInput", "", "NRLinkResumeNexusBKInputSource", 848, v309);

        }
      }
      dispatch_resume(*(dispatch_object_t *)(v5 + 839));
    }
  }
LABEL_266:

}

void sub_100074740(uint64_t a1, uint64_t a2)
{
  void *v3;
  int IsLevelEnabled;
  uint64_t v5;
  void *v6;
  id v7;

  if (*(_BYTE *)(a1 + 212) && *(_QWORD *)(a1 + 391))
  {
    *(_BYTE *)(a1 + 212) = 0;
    ++*(_QWORD *)(a1 + 415);
    if (gNRPacketLoggingEnabled)
    {
      v3 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
      IsLevelEnabled = _NRLogIsLevelEnabled(v3, 1);

      if (IsLevelEnabled)
      {
        v6 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
        v7 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v6, 1, "%s%.30s:%-4d %@: source-resume: NexusInput", "", "NRLinkResumeNexusInputSource", 842, v7);

      }
    }
    dispatch_resume(*(dispatch_object_t *)(a1 + 391));
  }
}

void sub_100074844(uint64_t a1, uint64_t a2)
{
  void *v3;
  int IsLevelEnabled;
  uint64_t v5;
  void *v6;
  id v7;

  if (*(_BYTE *)(a1 + 218) && *(_QWORD *)(a1 + 839))
  {
    *(_BYTE *)(a1 + 218) = 0;
    ++*(_QWORD *)(a1 + 855);
    if (gNRPacketLoggingEnabled)
    {
      v3 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
      IsLevelEnabled = _NRLogIsLevelEnabled(v3, 1);

      if (IsLevelEnabled)
      {
        v6 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
        v7 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v6, 1, "%s%.30s:%-4d %@: source-resume: NexusBKInput", "", "NRLinkResumeNexusBKInputSource", 848, v7);

      }
    }
    dispatch_resume(*(dispatch_object_t *)(a1 + 839));
  }
}

void sub_100074948(uint64_t a1, uint64_t a2)
{
  void *v3;
  int IsLevelEnabled;
  uint64_t v5;
  void *v6;
  id v7;

  if (*(_BYTE *)(a1 + 216) && *(_QWORD *)(a1 + 695))
  {
    *(_BYTE *)(a1 + 216) = 0;
    ++*(_QWORD *)(a1 + 711);
    if (gNRPacketLoggingEnabled)
    {
      v3 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
      IsLevelEnabled = _NRLogIsLevelEnabled(v3, 1);

      if (IsLevelEnabled)
      {
        v6 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
        v7 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v6, 1, "%s%.30s:%-4d %@: source-resume: NexusVIInput", "", "NRLinkResumeNexusVIInputSource", 846, v7);

      }
    }
    dispatch_resume(*(dispatch_object_t *)(a1 + 695));
  }
}

void sub_100074A4C(uint64_t a1, uint64_t a2)
{
  void *v3;
  int IsLevelEnabled;
  uint64_t v5;
  void *v6;
  id v7;

  if (*(_BYTE *)(a1 + 214) && *(_QWORD *)(a1 + 551))
  {
    *(_BYTE *)(a1 + 214) = 0;
    ++*(_QWORD *)(a1 + 567);
    if (gNRPacketLoggingEnabled)
    {
      v3 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
      IsLevelEnabled = _NRLogIsLevelEnabled(v3, 1);

      if (IsLevelEnabled)
      {
        v6 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
        v7 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v6, 1, "%s%.30s:%-4d %@: source-resume: NexusVOInput", "", "NRLinkResumeNexusVOInputSource", 844, v7);

      }
    }
    dispatch_resume(*(dispatch_object_t *)(a1 + 551));
  }
}

void sub_100074B50(uint64_t a1, uint64_t a2)
{
  void *v3;
  int IsLevelEnabled;
  uint64_t v5;
  void *v6;
  id v7;

  if (!*(_BYTE *)(a1 + 212) && *(_QWORD *)(a1 + 391))
  {
    *(_BYTE *)(a1 + 212) = 1;
    ++*(_QWORD *)(a1 + 415);
    if (gNRPacketLoggingEnabled)
    {
      v3 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
      IsLevelEnabled = _NRLogIsLevelEnabled(v3, 1);

      if (IsLevelEnabled)
      {
        v6 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
        v7 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v6, 1, "%s%.30s:%-4d %@: source-suspend: NexusInput", "", "NRLinkSuspendNexusInputSource", 832, v7);

      }
    }
    dispatch_suspend(*(dispatch_object_t *)(a1 + 391));
  }
}

void sub_100074C58(uint64_t a1, uint64_t a2)
{
  void *v3;
  int IsLevelEnabled;
  uint64_t v5;
  void *v6;
  id v7;

  if (!*(_BYTE *)(a1 + 218) && *(_QWORD *)(a1 + 839))
  {
    *(_BYTE *)(a1 + 218) = 1;
    ++*(_QWORD *)(a1 + 855);
    if (gNRPacketLoggingEnabled)
    {
      v3 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
      IsLevelEnabled = _NRLogIsLevelEnabled(v3, 1);

      if (IsLevelEnabled)
      {
        v6 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
        v7 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v6, 1, "%s%.30s:%-4d %@: source-suspend: NexusBKInput", "", "NRLinkSuspendNexusBKInputSource", 838, v7);

      }
    }
    dispatch_suspend(*(dispatch_object_t *)(a1 + 839));
  }
}

void sub_100074D60(uint64_t a1, uint64_t a2)
{
  void *v3;
  int IsLevelEnabled;
  uint64_t v5;
  void *v6;
  id v7;

  if (!*(_BYTE *)(a1 + 216) && *(_QWORD *)(a1 + 695))
  {
    *(_BYTE *)(a1 + 216) = 1;
    ++*(_QWORD *)(a1 + 711);
    if (gNRPacketLoggingEnabled)
    {
      v3 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
      IsLevelEnabled = _NRLogIsLevelEnabled(v3, 1);

      if (IsLevelEnabled)
      {
        v6 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
        v7 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v6, 1, "%s%.30s:%-4d %@: source-suspend: NexusVIInput", "", "NRLinkSuspendNexusVIInputSource", 836, v7);

      }
    }
    dispatch_suspend(*(dispatch_object_t *)(a1 + 695));
  }
}

void sub_100074E68(uint64_t a1, uint64_t a2)
{
  void *v3;
  int IsLevelEnabled;
  uint64_t v5;
  void *v6;
  id v7;

  if (!*(_BYTE *)(a1 + 214) && *(_QWORD *)(a1 + 551))
  {
    *(_BYTE *)(a1 + 214) = 1;
    ++*(_QWORD *)(a1 + 567);
    if (gNRPacketLoggingEnabled)
    {
      v3 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
      IsLevelEnabled = _NRLogIsLevelEnabled(v3, 1);

      if (IsLevelEnabled)
      {
        v6 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
        v7 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v6, 1, "%s%.30s:%-4d %@: source-suspend: NexusVOInput", "", "NRLinkSuspendNexusVOInputSource", 834, v7);

      }
    }
    dispatch_suspend(*(dispatch_object_t *)(a1 + 551));
  }
}

void sub_100074F70(void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  id v10;
  id v11;

  if (a1)
  {
    v10 = a2;
    v11 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:arguments:", v10, &a9);

    objc_msgSend(a1, "cancelWithReason:", CFSTR("flushing pipe: %@"), v11);
  }
}

void **sub_100074FEC(void **a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  uint64_t (**v9)(id, void *);
  void *String;
  char *v11;
  _QWORD *v12;
  void *v13;
  void *v14;
  id v15;
  void *v16;
  void *v17;
  unsigned __int8 v18;
  uint64_t (**v19)(id, void *);
  void *v20;
  void *v21;
  NRDDecryptedIdentifier *v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  int IsLevelEnabled;
  uint64_t v27;
  void *v28;
  id v29;
  NSUUID *v30;
  NSUUID *v31;
  uint64_t v32;
  NSUUID *v33;
  void *v34;
  unsigned __int8 v35;
  uint64_t v36;
  NSObject *v37;
  void *v38;
  NSObject *v39;
  _QWORD *v40;
  _BOOL4 v41;
  NSObject *v42;
  NSObject *v43;
  _QWORD *v44;
  id v45;
  id v46;
  void *v47;
  id v48;
  void *v49;
  id v50;
  _BOOL4 v51;
  char *v52;
  unsigned int v53;
  id v54;
  void *v55;
  void *v56;
  id *v57;
  int v59;
  uint64_t v60;
  void *v61;
  id v62;
  void *v63;
  int v64;
  uint64_t v65;
  NSUUID *v66;
  void *v67;
  int v68;
  uint64_t v69;
  NSUUID *v70;
  NSUUID *v71;
  void *v72;
  uint64_t (**v73)(id, void *);
  unsigned __int8 v74;
  void *v75;
  void *v76;
  _QWORD *v77;
  void *v78;
  void *v80;
  id v81;
  id v82;
  _QWORD v83[2];

  v82 = a2;
  v81 = a3;
  v9 = a5;
  if (a1)
  {
    String = (void *)NRDataProtectionClassCreateString(a4);
    v11 = sub_10012FFF4((uint64_t)NRDLocalDevice, a1[4]);
    v12 = sub_100131288(v11, a4);
    v13 = sub_100112798(0, v11, a4);
    if (v12)
      v14 = (void *)v12[1];
    else
      v14 = 0;
    v15 = v14;

    if (!v15)
    {
      objc_msgSend(a1, "reportEvent:detailsFormat:", 3019, CFSTR("%@ %@ %@"), String, v82, v11);
      goto LABEL_11;
    }
    v80 = v13;
    v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v81, "localIdentifier"));
    v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v81, "remoteIdentifier"));
    v18 = objc_msgSend(v16, "isEqual:", v17);

    v77 = v12;
    v74 = v18;
    if ((v18 & 1) != 0)
    {
      if (!v11)
      {
        v78 = 0;
        v38 = 0;
        v41 = a4 == 4;
        goto LABEL_28;
      }
      v13 = v80;
      if (_os_feature_enabled_impl("terminus", "EncryptedIdentity") && v11[11])
      {
        objc_msgSend(a1, "reportEvent:detailsFormat:", 3022, CFSTR("%@ %@ %@"), String, v82, v11);
LABEL_11:
        a1 = 0;
LABEL_38:

        goto LABEL_39;
      }
LABEL_18:
      if ((_DWORD)a4 == 4)
      {
        if (!v11)
        {
          v78 = 0;
          v38 = 0;
          v41 = 1;
          goto LABEL_28;
        }
        v37 = sub_10014CFBC();
        dispatch_assert_queue_V2(v37);

        v38 = sub_1001331E8(v11, CFSTR("0"));
        v39 = sub_10014CFBC();
        dispatch_assert_queue_V2(v39);

        v40 = sub_100133714(v11, CFSTR("0"));
      }
      else
      {
        v38 = 0;
        v41 = 0;
        v78 = 0;
        if ((_DWORD)a4 != 3 || !v11)
          goto LABEL_29;
        v42 = sub_10014CFBC();
        dispatch_assert_queue_V2(v42);

        v38 = (void *)sub_100133920(v11, CFSTR("0"));
        v43 = sub_10014CFBC();
        dispatch_assert_queue_V2(v43);

        v40 = sub_100133AD8(v11, CFSTR("0"));
      }
      v44 = v40;
      v78 = v40;
      if (v38 && v40)
      {
        v73 = v9;
        v45 = objc_alloc((Class)NEIKEv2ConfigurationMessage);
        v46 = objc_msgSend(objc_alloc((Class)NEIKEv2InitiatorTransportIPv6Address), "initWithAddress:", v44);
        v83[0] = v46;
        v76 = String;
        v47 = v38;
        v48 = objc_msgSend(objc_alloc((Class)NEIKEv2ResponderTransportIPv6Address), "initWithAddress:", v38);
        v83[1] = v48;
        v49 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v83, 2));
        v50 = objc_msgSend(v45, "initWithWithAttributes:", v49);
        v13 = v80;
        objc_msgSend(v80, "setConfigurationReply:", v50);

        v9 = v73;
        v38 = v47;
        String = v76;

        v41 = a4 == 4;
        goto LABEL_29;
      }
      v41 = a4 == 4;
LABEL_28:
      v13 = v80;
LABEL_29:
      v51 = sub_100112F4C(v11);
      v52 = sub_10007630C((char *)a1, v51);
      v53 = objc_msgSend(a1, "suspendWhenReady");
      if (v41 && v53)
      {
        v54 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50901, 0);
        objc_msgSend(v52, "addObject:", v54);

      }
      objc_msgSend(v13, "setCustomIKEAuthPrivateNotifies:", v52);
      if ((v9[2](v9, v13) & 1) != 0)
      {
        if ((v74 & 1) == 0)
        {
          v55 = v38;
          v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "nrUUID"));
          sub_10013C890((uint64_t)NRDLocalDevice, v56);

          v38 = v55;
          v13 = v80;
        }
        objc_msgSend(a1, "invalidateIKESessionForClass:", a4);
        v57 = (id *)sub_100077D08((uint64_t)a1, a4);
        objc_storeStrong(v57, a2);
        sub_100077E8C(a1, a4);
        objc_msgSend(a1, "reportEvent:detailsFormat:", 3016, CFSTR("%@ %@"), String, v82);
        a1 = v13;
      }
      else
      {
        objc_msgSend(a1, "reportEvent:detailsFormat:", 3021, CFSTR("%@ %@"), String, v82);
        a1 = 0;
      }
      v12 = v77;

      goto LABEL_38;
    }
    v75 = String;
    v19 = v9;
    v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v81, "remoteIdentifier"));
    v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v81, "localIdentifier"));
    v22 = sub_100130BF8((uint64_t)NRDLocalDevice, v20, v21, v82);

    v24 = _NRCopyLogObjectForNRUUID(a1[4], v23);
    v25 = (void *)v24;
    if (v22)
    {
      IsLevelEnabled = _NRLogIsLevelEnabled(v24, 1);

      if (IsLevelEnabled)
      {
        v28 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v27);
        v29 = objc_msgSend(a1, "copyDescription");
        v30 = v22->_identity;
        _NRLogWithArgs(v28, 1, "%s%.30s:%-4d %@: Decrypted device identity %@", "", "-[NRLinkBluetooth respondToIKESession:sessionConfig:dataProtectionClass:validateAuthBlock:]", 9126, v29, v30);

      }
      v31 = v22->_nrUUID;

      if (v31)
      {
        v33 = v22->_nrUUID;
        v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "nrUUID"));
        v35 = -[NSUUID isEqual:](v33, "isEqual:", v34);

        if ((v35 & 1) != 0)
        {

          v9 = v19;
          String = v75;
          v13 = v80;
          goto LABEL_18;
        }
        v67 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v36);
        v68 = _NRLogIsLevelEnabled(v67, 16);

        v9 = v19;
        if (v68)
        {
          v61 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v69);
          v62 = objc_msgSend(a1, "copyDescription");
          v70 = v22->_identity;
          v71 = v22->_nrUUID;
          v72 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "nrUUID"));
          _NRLogWithArgs(v61, 16, "%s%.30s:%-4d %@: Different device found for identity %@ (%@ != %@)", "", "-[NRLinkBluetooth respondToIKESession:sessionConfig:dataProtectionClass:validateAuthBlock:]", 9137, v62, v70, v71, v72);

          v9 = v19;
          goto LABEL_46;
        }
LABEL_47:
        String = v75;
        objc_msgSend(a1, "reportEvent:detailsFormat:", 3023, CFSTR("%@ %@ %@"), v75, v82, v11);

        a1 = 0;
        v12 = v77;
        v13 = v80;
        goto LABEL_38;
      }
      v63 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v32);
      v64 = _NRLogIsLevelEnabled(v63, 16);

      v9 = v19;
      if (!v64)
        goto LABEL_47;
      v61 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v65);
      v62 = objc_msgSend(a1, "copyDescription");
      v66 = v22->_identity;
      _NRLogWithArgs(v61, 16, "%s%.30s:%-4d %@: No device found for identity %@", "", "-[NRLinkBluetooth respondToIKESession:sessionConfig:dataProtectionClass:validateAuthBlock:]", 9130, v62, v66);

    }
    else
    {
      v59 = _NRLogIsLevelEnabled(v24, 16);

      v9 = v19;
      if (!v59)
        goto LABEL_47;
      v61 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v60);
      v62 = objc_msgSend(a1, "copyDescription");
      _NRLogWithArgs(v61, 16, "%s%.30s:%-4d %@: Failed to decrypt device identity", "", "-[NRLinkBluetooth respondToIKESession:sessionConfig:dataProtectionClass:validateAuthBlock:]", 9122, v62);
    }
LABEL_46:

    goto LABEL_47;
  }
LABEL_39:

  return a1;
}

void sub_1000757B4(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  id v4;
  id v5;
  id v6;
  id v7;
  id v8;
  id v9;
  id v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  void *v14;
  id v15;
  id v16;
  int IsLevelEnabled;
  id *v18;
  id v19;
  void **v20;
  uint64_t v21;
  void (*v22)(uint64_t, void *);
  void *v23;
  id v24;
  id v25;
  _QWORD v26[4];
  id v27;
  id v28;
  _QWORD v29[4];
  id v30;
  id v31;
  _QWORD v32[4];
  id v33;
  id v34;
  _QWORD v35[4];
  id v36;
  id v37;
  _QWORD v38[4];
  id v39;
  id v40;
  _QWORD v41[4];
  id v42;
  id v43;
  id location[2];

  if (a1)
  {
    v2 = *(void **)(a1 + 1247);
    if (v2)
    {
      v3 = objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "description"));
      objc_msgSend(*(id *)(a1 + 1247), "setClientQueue:", *(_QWORD *)(a1 + 8));
      objc_initWeak(location, (id)a1);
      v41[0] = _NSConcreteStackBlock;
      v41[1] = 3221225472;
      v41[2] = sub_10007D35C;
      v41[3] = &unk_1001B6C10;
      v18 = &v43;
      objc_copyWeak(&v43, location);
      v4 = (id)v3;
      v42 = v4;
      objc_msgSend(*(id *)(a1 + 1247), "setStateUpdateBlock:", v41);
      v38[0] = _NSConcreteStackBlock;
      v38[1] = 3221225472;
      v38[2] = sub_10007D8FC;
      v38[3] = &unk_1001B6C38;
      objc_copyWeak(&v40, location);
      v5 = v4;
      v39 = v5;
      objc_msgSend(*(id *)(a1 + 1247), "setChildStateUpdateBlock:", v38);
      v35[0] = _NSConcreteStackBlock;
      v35[1] = 3221225472;
      v35[2] = sub_10007DA4C;
      v35[3] = &unk_1001B6C60;
      objc_copyWeak(&v37, location);
      v6 = v5;
      v36 = v6;
      objc_msgSend(*(id *)(a1 + 1247), "setConfigurationUpdateBlock:", v35);
      v32[0] = _NSConcreteStackBlock;
      v32[1] = 3221225472;
      v32[2] = sub_10007DB14;
      v32[3] = &unk_1001B6C88;
      objc_copyWeak(&v34, location);
      v7 = v6;
      v33 = v7;
      objc_msgSend(*(id *)(a1 + 1247), "setTrafficSelectorUpdateBlock:", v32);
      v29[0] = _NSConcreteStackBlock;
      v29[1] = 3221225472;
      v29[2] = sub_10007DC00;
      v29[3] = &unk_1001B6CB0;
      objc_copyWeak(&v31, location);
      v8 = v7;
      v30 = v8;
      objc_msgSend(*(id *)(a1 + 1247), "setAdditionalAddressesUpdateBlock:", v29);
      v26[0] = _NSConcreteStackBlock;
      v26[1] = 3221225472;
      v26[2] = sub_10007DCC8;
      v26[3] = &unk_1001B87F0;
      objc_copyWeak(&v28, location);
      v9 = v8;
      v27 = v9;
      objc_msgSend(*(id *)(a1 + 1247), "setShortDPDEventBlock:", v26);
      v20 = _NSConcreteStackBlock;
      v21 = 3221225472;
      v22 = sub_10007DD88;
      v23 = &unk_1001B6CB0;
      objc_copyWeak(&v25, location);
      v10 = v9;
      v24 = v10;
      objc_msgSend(*(id *)(a1 + 1247), "setPrivateNotifyStatusEvent:", &v20);
      v12 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v11);
      LOBYTE(v3) = _NRLogIsLevelEnabled(v12, 0);

      if ((v3 & 1) != 0)
      {
        v14 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v13);
        v15 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v14, 0, "%s%.30s:%-4d %@: Setup IKE pairing %@ callbacks", "", "-[NRLinkBluetooth setupIKECallbacksPairing]", 8708, v15, v10, &v43, v20, v21, v22, v23);

      }
      objc_destroyWeak(&v25);

      objc_destroyWeak(&v28);
      objc_destroyWeak(&v31);

      objc_destroyWeak(&v34);
      objc_destroyWeak(&v37);

      objc_destroyWeak(&v40);
      objc_destroyWeak(v18);
      objc_destroyWeak(location);

    }
    else
    {
      v16 = sub_100070AC8();
      IsLevelEnabled = _NRLogIsLevelEnabled(v16, 17);

      if (IsLevelEnabled)
      {
        v19 = sub_100070AC8();
        _NRLogWithArgs(v19, 17, "%s called with null _ikeSessionPairing", "-[NRLinkBluetooth setupIKECallbacksPairing]");

      }
    }
  }
}

void sub_100075BB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id *location)
{
  id *v14;
  id *v15;
  id *v16;
  id *v17;
  id *v18;
  id *v19;
  uint64_t v20;

  objc_destroyWeak(v19);
  objc_destroyWeak(v18);
  objc_destroyWeak(v17);
  objc_destroyWeak(v16);
  objc_destroyWeak(v15);
  objc_destroyWeak(v14);
  objc_destroyWeak(location);
  objc_destroyWeak((id *)(v20 - 112));
  _Unwind_Resume(a1);
}

void sub_100075C30(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  char *v12;
  void *v13;
  char *v14;
  id v15;
  id v16;
  id v17;
  id v18;
  void *v19;
  void *v20;
  void *LogString;
  void *v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  id v26;
  void *v27;
  int IsLevelEnabled;
  uint64_t v29;
  id v30;

  v30 = a2;
  v7 = a3;
  v8 = a4;
  v10 = objc_msgSend(*(id *)(a1 + 32), "state");
  v11 = *(_QWORD *)(a1 + 32);
  if (v10 != 255)
  {
    v12 = sub_10007630C((char *)v11, 0);
    if (_os_feature_enabled_impl("terminus", "EncryptedIdentity"))
    {
      v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "nrUUID"));
      v14 = sub_100138520((uint64_t)NRDLocalDevice, v13);

      if (v14)
      {
        v15 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50351, v14);
        objc_msgSend(v12, "addObject:", v15);

      }
    }
    if (v30)
    {
      v16 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50411, v30);
      objc_msgSend(v12, "addObject:", v16);

    }
    if (v7)
    {
      v17 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50412, v7);
      objc_msgSend(v12, "addObject:", v17);

    }
    if (v8)
    {
      v18 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50413, v8);
      objc_msgSend(v12, "addObject:", v18);

    }
    objc_msgSend(*(id *)(a1 + 40), "setCustomIKEAuthPrivateNotifies:", v12);
    if (qword_1001E46D8 != -1)
      dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
    if (_NRLogIsLevelEnabled(qword_1001E46D0, 0))
    {
      if (qword_1001E46D8 != -1)
        dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
      _NRLogWithArgs(qword_1001E46D0, 0, "%s%.30s:%-4d Responding to session for pairing with OOBK", "", "-[NRLinkBluetooth requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBlock:]_block_invoke", 9379);
    }
    v19 = *(void **)(a1 + 32);
    v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "sharedSecret"));
    LogString = (void *)_NRKeyCreateLogString(v20);
    objc_msgSend(v19, "reportEvent:details:", 3014, LogString);

    v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "nrUUID"));
    v23 = sub_10012FFF4((uint64_t)NRDLocalDevice, v22);

    v24 = *(_QWORD *)(a1 + 56);
    v25 = *(_QWORD *)(a1 + 40);
    if (*(_QWORD *)(a1 + 48))
    {
      v26 = sub_100112420();
      objc_msgSend(v26, "setSequencePerTrafficClass:", 1);
      objc_msgSend(v26, "setReplayWindowSize:", 16);
      (*(void (**)(uint64_t, uint64_t, id, _QWORD))(v24 + 16))(v24, v25, v26, 0);

    }
    else
    {
      (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD))(v24 + 16))(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 40), 0, 0);
    }
    goto LABEL_23;
  }
  v27 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v11 + 32), v9);
  IsLevelEnabled = _NRLogIsLevelEnabled(v27, 0);

  if (IsLevelEnabled)
  {
    v12 = (char *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v29);
    v23 = (char *)objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    _NRLogWithArgs(v12, 0, "%s%.30s:%-4d %@: Ignoring result as link is cancelled", "", "-[NRLinkBluetooth requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBlock:]_block_invoke", 9342, v23);
LABEL_23:

  }
}

void sub_100075F88(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6)
{
  id v11;
  id v12;
  uint64_t v13;
  void *v14;
  int IsLevelEnabled;
  uint64_t v16;
  void *v17;
  id v18;
  char *v19;
  void *v20;
  char *v21;
  id v22;
  id v23;
  uint64_t v24;
  id v25;
  uint64_t v26;
  id v27;
  void *v28;
  int v29;
  uint64_t v30;
  id v31;
  void *v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  id v36;
  id v37;

  v37 = a4;
  v11 = a5;
  v12 = a6;
  if (objc_msgSend(*(id *)(a1 + 32), "state") != 255)
  {
    if (!a2 || !a3 || !v37)
    {
      (*(void (**)(void))(*(_QWORD *)(a1 + 64) + 16))();
      goto LABEL_23;
    }
    v14 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v13);
    IsLevelEnabled = _NRLogIsLevelEnabled(v14, 0);

    if (IsLevelEnabled)
    {
      v17 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v16);
      v18 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
      _NRLogWithArgs(v17, 0, "%s%.30s:%-4d %@: Responder %@ queried IDS keys for pairing", "", "-[NRLinkBluetooth requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBlock:]_block_invoke_2", 9410, v18, *(_QWORD *)(a1 + 40));

    }
    objc_msgSend(*(id *)(a1 + 48), "setLocalPrivateKeyRef:", a3);
    objc_msgSend(*(id *)(a1 + 48), "setRemotePublicKeyRef:", a2);
    v19 = sub_10007630C(*(char **)(a1 + 32), 0);
    if (_os_feature_enabled_impl("terminus", "EncryptedIdentity"))
    {
      v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "nrUUID"));
      v21 = sub_100138520((uint64_t)NRDLocalDevice, v20);

      if (v21)
      {
        v22 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50351, v21);
        objc_msgSend(v19, "addObject:", v22);

      }
    }
    v23 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50401, v37);
    objc_msgSend(v19, "addObject:", v23);

    if (v11)
    {
      v25 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50402, v11);
      objc_msgSend(v19, "addObject:", v25);

      if (v12)
      {
LABEL_13:
        v27 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50403, v12);
        objc_msgSend(v19, "addObject:", v27);

LABEL_18:
        objc_msgSend(*(id *)(a1 + 48), "setCustomIKEAuthPrivateNotifies:", v19);
        objc_msgSend(*(id *)(a1 + 32), "reportEvent:", 3012);
        v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "nrUUID"));
        v33 = sub_10012FFF4((uint64_t)NRDLocalDevice, v32);

        v34 = *(_QWORD *)(a1 + 64);
        v35 = *(_QWORD *)(a1 + 48);
        if (*(_QWORD *)(a1 + 56))
        {
          v36 = sub_100112420();
          objc_msgSend(v36, "setSequencePerTrafficClass:", 1);
          objc_msgSend(v36, "setReplayWindowSize:", 16);
          (*(void (**)(uint64_t, uint64_t, id, _QWORD))(v34 + 16))(v34, v35, v36, 0);

        }
        else
        {
          (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD))(v34 + 16))(*(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 48), 0, 0);
        }

        goto LABEL_22;
      }
    }
    else
    {
      sub_100076AF8(*(_QWORD *)(a1 + 32), v24);
      if (v12)
        goto LABEL_13;
    }
    sub_100076CE8(*(_QWORD *)(a1 + 32), v26);
    goto LABEL_18;
  }
  v28 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v13);
  v29 = _NRLogIsLevelEnabled(v28, 0);

  if (v29)
  {
    v19 = (char *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v30);
    v31 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    _NRLogWithArgs(v19, 0, "%s%.30s:%-4d %@: Ignoring result as link is cancelled", "", "-[NRLinkBluetooth requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBlock:]_block_invoke_2", 9399, v31);

LABEL_22:
  }
LABEL_23:

}

char *sub_10007630C(char *a1, int a2)
{
  char *v2;
  const char *v3;
  id v4;
  id v5;
  id v6;
  id v7;
  void *v8;
  id v9;
  id v10;
  void *v11;
  id v12;
  id v13;
  id v14;
  id v15;
  char *v16;
  char *v17;
  id v18;
  id v19;
  id v20;
  id v21;
  char *v22;
  BOOL i;
  id v24;
  id v25;
  char *v26;
  char *v27;
  char *v28;
  char *v29;
  id v30;
  id v31;
  id v32;
  id v33;
  id v34;
  id v35;
  id v36;
  id v37;
  id v39;
  int IsLevelEnabled;
  id v41;
  uint64_t v42;
  uint64_t v43;
  id v44;
  int v45;
  id v46;
  int *v47;
  uint64_t v48;
  id v49;
  int v50;
  id v51;
  uint64_t v52;
  id v53;
  uint64_t v54;
  __int128 v55;

  v2 = a1;
  if (!a1)
    return v2;
  LODWORD(v3) = a2;
  v4 = objc_alloc_init((Class)NSMutableArray);
  LOWORD(v55) = 5632;
  v5 = objc_msgSend(objc_alloc((Class)NSMutableData), "initWithBytes:length:", &v55, 2);
  v6 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 48602, v5);
  objc_msgSend(v4, "addObject:", v6);

  if (qword_1001E4860 != -1)
    dispatch_once(&qword_1001E4860, &stru_1001B7B90);
  v7 = (id)qword_1001E4858;
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "dataUsingEncoding:", 4));

  v9 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 48603, v8);
  objc_msgSend(v4, "addObject:", v9);

  if (qword_1001E4850 != -1)
    dispatch_once(&qword_1001E4850, &stru_1001B7B70);
  v10 = (id)qword_1001E4848;
  v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "dataUsingEncoding:", 4));

  v12 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 48604, v11);
  objc_msgSend(v4, "addObject:", v12);

  if (qword_1001E48E0 != -1)
    dispatch_once(&qword_1001E48E0, &stru_1001B7CE0);
  LOBYTE(v55) = byte_1001E48D8;
  v13 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &v55, 1);
  v14 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 48606, v13);
  objc_msgSend(v4, "addObject:", v14);

  v15 = sub_100112E3C();
  objc_msgSend(v4, "addObject:", v15);

  v16 = sub_10012FFF4((uint64_t)NRDLocalDevice, *((void **)v2 + 4));
  if (!v16)
  {
    v39 = sub_100070AC8();
    IsLevelEnabled = _NRLogIsLevelEnabled(v39, 16);

    if (IsLevelEnabled)
    {
      v41 = sub_100070AC8();
      _NRLogWithArgs(v41, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)", "", "-[NRLinkBluetooth copyNotifyPayloadsToSendWithProxy:]", 7359);

    }
    v4 = (id)_os_log_pack_size(12);
    v2 = (char *)&v54 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
    v42 = *__error();
    v43 = _os_log_pack_fill(v2, v4, v42, &_mh_execute_header, "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
    goto LABEL_31;
  }
  v17 = v16;
  *(_QWORD *)&v55 = *((_QWORD *)v16 + 17);
  v18 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &v55, 8);
  v19 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 48605, v18);

  objc_msgSend(v4, "addObject:", v19);
  objc_opt_self(NRLinkManagerWiFi);
  LOBYTE(v55) = 1;
  v20 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &v55, 1);
  v21 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 51401, v20);
  objc_msgSend(v4, "addObject:", v21);

  v22 = sub_10012FFF4((uint64_t)NRDLocalDevice, *((void **)v2 + 4));
  v15 = v22;
  if (!v22)
    goto LABEL_33;
  for (i = v22[16] != 0; ; i = 0)
  {
    LOBYTE(v55) = i;
    v24 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &v55, 1);
    v25 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 51501, v24);
    objc_msgSend(v4, "addObject:", v25);

    if (!*(_QWORD *)(v2 + 351))
      break;
    v15 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 48601, *(_QWORD *)(v2 + 351));
    objc_msgSend(v4, "addObject:", v15);

    if ((_DWORD)v3)
    {
      v26 = sub_10012FFF4((uint64_t)NRDLocalDevice, *((void **)v2 + 4));
      if (!v26)
      {
        v49 = sub_100070AC8();
        v50 = _NRLogIsLevelEnabled(v49, 16);

        if (v50)
        {
          v51 = sub_100070AC8();
          _NRLogWithArgs(v51, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)", "", "-[NRLinkBluetooth copyNotifyPayloadsToSendWithProxy:]", 7409);

        }
        v4 = (id)_os_log_pack_size(12);
        v2 = (char *)&v54 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
        v52 = *__error();
        v43 = _os_log_pack_fill(v2, v4, v52, &_mh_execute_header, "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
LABEL_31:
        *(_DWORD *)v43 = 136446210;
        *(_QWORD *)(v43 + 4) = "-[NRLinkBluetooth copyNotifyPayloadsToSendWithProxy:]";
        goto LABEL_32;
      }
      v27 = v26;
      v15 = sub_100112FCC(v26, 0);
      objc_msgSend(v4, "addObject:", v15);

    }
    if (!v2[242])
      goto LABEL_18;
    v28 = sub_10012FFF4((uint64_t)NRDLocalDevice, *((void **)v2 + 4));
    if (v28)
    {
      v29 = v28;
      v55 = 0uLL;
      sub_100133C94(v28, &v55);
      v30 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &v55, 16);
      v31 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50801, v30);
      objc_msgSend(v4, "addObject:", v31);

      v55 = 0uLL;
      sub_10013453C(v29, &v55);
      v32 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &v55, 16);
      v33 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50802, v32);
      objc_msgSend(v4, "addObject:", v33);

      v55 = 0uLL;
      sub_10013CDB8(v29, &v55);
      v34 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &v55, 16);
      v35 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50811, v34);
      objc_msgSend(v4, "addObject:", v35);

      v55 = 0uLL;
      sub_10013CC28(v29, &v55);
      v36 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &v55, 16);
      v37 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50812, v36);
      objc_msgSend(v4, "addObject:", v37);

LABEL_18:
      v2 = (char *)v4;
      goto LABEL_20;
    }
    v44 = sub_100070AC8();
    v45 = _NRLogIsLevelEnabled(v44, 16);

    v3 = "-[NRLinkBluetooth copyNotifyPayloadsToSendWithProxy:]";
    if (v45)
    {
      v46 = sub_100070AC8();
      _NRLogWithArgs(v46, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)", "", "-[NRLinkBluetooth copyNotifyPayloadsToSendWithProxy:]", 7415);

    }
    v4 = (id)_os_log_pack_size(12);
    v2 = (char *)&v54 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
    v47 = __error();
    v48 = _os_log_pack_fill(v2, v4, *v47, &_mh_execute_header, "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
    *(_DWORD *)v48 = 136446210;
    *(_QWORD *)(v48 + 4) = "-[NRLinkBluetooth copyNotifyPayloadsToSendWithProxy:]";
LABEL_32:
    v53 = sub_100070AC8();
    _NRLogAbortWithPack(v53, v2);
LABEL_33:
    ;
  }
  objc_msgSend(v2, "cancelWithReason:", CFSTR("Trying to generate notify payloads but sentPrelude is nil"));
  v2 = 0;
LABEL_20:

  return v2;
}

void sub_100076AF8(uint64_t a1, uint64_t a2)
{
  char *v3;
  id v4;
  void *v5;
  void *v6;
  uint64_t v7;
  void *v8;
  int IsLevelEnabled;
  uint64_t v10;
  id v11;
  void *v12;
  id v13;
  _QWORD v14[5];
  _QWORD v15[5];

  if (a1)
  {
    if (*(unsigned __int8 *)(a1 + 16) == 255)
    {
      v8 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
      IsLevelEnabled = _NRLogIsLevelEnabled(v8, 0);

      if (IsLevelEnabled)
      {
        v13 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v10);
        v11 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v13, 0, "%s%.30s:%-4d %@: Not sending encrypted classC because cancelled", "", "-[NRLinkBluetooth sendlocalPublicClassCKeysEncryptedWithIDS]", 8273, v11);

      }
    }
    else if (*(_QWORD *)(a1 + 1295))
    {
      objc_msgSend((id)a1, "reportEvent:details:", 3402, CFSTR("ClassC"));
      v3 = sub_10007630C((char *)a1, 0);
      v4 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50402, *(_QWORD *)(a1 + 1295));
      objc_msgSend(v3, "addObject:", v4);
      v5 = *(void **)(a1 + 1295);
      *(_QWORD *)(a1 + 1295) = 0;

      v6 = *(void **)(a1 + 1247);
      v7 = *(_QWORD *)(a1 + 8);
      v14[0] = _NSConcreteStackBlock;
      v14[1] = 3221225472;
      v14[2] = sub_10007D20C;
      v14[3] = &unk_1001B6E88;
      v14[4] = a1;
      objc_msgSend(v6, "sendPrivateNotifies:maxRetries:retryIntervalInMilliseconds:callbackQueue:callback:", v3, 10, 10000, v7, v14);

    }
    else if (!*(_BYTE *)(a1 + 240))
    {
      *(_BYTE *)(a1 + 240) = 1;
      v12 = *(void **)(a1 + 32);
      v15[0] = _NSConcreteStackBlock;
      v15[1] = 3221225472;
      v15[2] = sub_10007D0C8;
      v15[3] = &unk_1001B6BC0;
      v15[4] = a1;
      sub_1001390B8((uint64_t)NRDLocalDevice, v12, 3, v15);
    }
  }
}

void sub_100076CE8(uint64_t a1, uint64_t a2)
{
  void *v3;
  unsigned __int16 *v4;
  uint64_t v5;
  void *v6;
  int IsLevelEnabled;
  uint64_t v8;
  char *v9;
  id v10;
  void *v11;
  int v12;
  uint64_t v13;
  id v14;
  id v15;
  void *v16;
  void *v17;
  uint64_t v18;
  void *v19;
  id v20;
  _QWORD v21[5];
  _QWORD v22[5];

  if (a1)
  {
    if (*(unsigned __int8 *)(a1 + 16) != 255)
    {
      v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "nrUUID"));
      v4 = (unsigned __int16 *)sub_10012FFF4((uint64_t)NRDLocalDevice, v3);

      if (v4 && v4[14] >= 0x13u)
      {
        v6 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
        IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0);

        if (!IsLevelEnabled)
        {
LABEL_12:

          return;
        }
        v9 = (char *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v8);
        v10 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v9, 0, "%s%.30s:%-4d %@: Not sending encrypted ClassA because peer supports skipping ClassA pairing", "", "-[NRLinkBluetooth sendlocalPublicClassAKeysEncryptedWithIDS]", 8330, v10);

      }
      else
      {
        if (!*(_QWORD *)(a1 + 1303))
        {
          if (!*(_BYTE *)(a1 + 241))
          {
            *(_BYTE *)(a1 + 241) = 1;
            v19 = *(void **)(a1 + 32);
            v22[0] = _NSConcreteStackBlock;
            v22[1] = 3221225472;
            v22[2] = sub_100076F90;
            v22[3] = &unk_1001B6BC0;
            v22[4] = a1;
            sub_1001390B8((uint64_t)NRDLocalDevice, v19, 1, v22);
          }
          goto LABEL_12;
        }
        objc_msgSend((id)a1, "reportEvent:details:", 3402, CFSTR("ClassA"));
        v9 = sub_10007630C((char *)a1, 0);
        v15 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50403, *(_QWORD *)(a1 + 1303));
        objc_msgSend(v9, "addObject:", v15);
        v16 = *(void **)(a1 + 1303);
        *(_QWORD *)(a1 + 1303) = 0;

        v17 = *(void **)(a1 + 1247);
        v18 = *(_QWORD *)(a1 + 8);
        v21[0] = _NSConcreteStackBlock;
        v21[1] = 3221225472;
        v21[2] = sub_1000770D4;
        v21[3] = &unk_1001B6E88;
        v21[4] = a1;
        objc_msgSend(v17, "sendPrivateNotifies:maxRetries:retryIntervalInMilliseconds:callbackQueue:callback:", v9, 10, 10000, v18, v21);

      }
      goto LABEL_12;
    }
    v11 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
    v12 = _NRLogIsLevelEnabled(v11, 0);

    if (v12)
    {
      v20 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v13);
      v14 = objc_msgSend((id)a1, "copyDescription");
      _NRLogWithArgs(v20, 0, "%s%.30s:%-4d %@: Not sending encrypted ClassA because cancelled", "", "-[NRLinkBluetooth sendlocalPublicClassAKeysEncryptedWithIDS]", 8325, v14);

    }
  }
}

void sub_100076F90(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  int IsLevelEnabled;
  uint64_t v13;
  void *v14;
  id v15;
  id v16;
  int v17;
  id v18;
  id v19;

  v19 = a6;
  if (objc_msgSend(*(id *)(a1 + 32), "state") == 255)
  {
    v11 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v8);
    IsLevelEnabled = _NRLogIsLevelEnabled(v11, 0);

    if (IsLevelEnabled)
    {
      v14 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v13);
      v15 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
      _NRLogWithArgs(v14, 0, "%s%.30s:%-4d %@: Ignoring result as link is cancelled", "", "-[NRLinkBluetooth sendlocalPublicClassAKeysEncryptedWithIDS]_block_invoke", 8348, v15);

    }
  }
  else if (v19)
  {
    v9 = *(_QWORD *)(a1 + 32);
    if (v9)
    {
      objc_storeStrong((id *)(v9 + 1303), a6);
      v10 = *(_QWORD *)(a1 + 32);
    }
    else
    {
      v10 = 0;
    }
    sub_100076CE8(v10);
  }
  else
  {
    v16 = sub_100070AC8();
    v17 = _NRLogIsLevelEnabled(v16, 17);

    if (v17)
    {
      v18 = sub_100070AC8();
      _NRLogWithArgs(v18, 17, "%s called with null localPublicClassAKeysEncryptedWithIDS", "-[NRLinkBluetooth sendlocalPublicClassAKeysEncryptedWithIDS]_block_invoke");

    }
  }

}

void sub_1000770D4(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v4;
  void *v5;
  int IsLevelEnabled;
  uint64_t v7;
  void *v8;
  id v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  id v13;
  id v14;

  v2 = a2;
  v4 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), a2);
  v5 = (void *)v4;
  if (v2)
  {
    IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0);

    if (IsLevelEnabled)
    {
      v8 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v7);
      v9 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
      _NRLogWithArgs(v8, 0, "%s%.30s:%-4d %@: localPublicClassAKeysEncryptedWithIDS was received", "", "-[NRLinkBluetooth sendlocalPublicClassAKeysEncryptedWithIDS]_block_invoke_2", 8371, v9);

    }
    v10 = *(_QWORD *)(a1 + 32);
    if (v10)
      sub_100077224(v10, 1, 0, 0);
  }
  else
  {
    v11 = _NRLogIsLevelEnabled(v4, 16);

    if (v11)
    {
      v14 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v12);
      v13 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
      _NRLogWithArgs(v14, 16, "%s%.30s:%-4d %@: localPublicClassAKeysEncryptedWithIDS was not received", "", "-[NRLinkBluetooth sendlocalPublicClassAKeysEncryptedWithIDS]_block_invoke_2", 8374, v13);

    }
  }
}

void sub_100077224(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  void *v10;
  int v11;
  uint64_t v12;
  void *v13;
  id v14;
  void *v15;
  int IsLevelEnabled;
  uint64_t v17;
  void *v18;
  int v19;
  uint64_t v20;
  void *v21;
  id v22;
  int *v23;
  void *v24;
  int v25;
  uint64_t v26;
  _BYTE *v27;
  void *v28;
  uint64_t v29;
  void *v30;
  int v31;
  uint64_t v32;
  void *v33;
  id v34;
  dispatch_time_t v35;
  NSObject *v36;
  id v37;
  id String;
  _QWORD block[4];
  id v40;
  id v41[2];
  id location;

  String = (id)NRDataProtectionClassCreateString(a2);
  if (*(unsigned __int8 *)(a1 + 16) == 255)
  {
    v15 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v8);
    IsLevelEnabled = _NRLogIsLevelEnabled(v15, 0);

    if (IsLevelEnabled)
    {
      v13 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v17);
      v14 = objc_msgSend((id)a1, "copyDescription");
      _NRLogWithArgs(v13, 0, "%s%.30s:%-4d %@: Not restarting %@ session because cancelled", "", "-[NRLinkBluetooth restartIKESessionForDataProtectionClass:authFailure:afterDisconnection:]", 8993, v14, String);
      goto LABEL_20;
    }
  }
  else
  {
    objc_msgSend((id)a1, "invalidateIKESessionForClass:", a2);
    if ((_DWORD)a2 == 4 || !a3 || *(_BYTE *)(a1 + 236))
    {
      if ((_DWORD)a2 == 1 && *(_BYTE *)(a1 + 235))
      {
        v10 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v9);
        v11 = _NRLogIsLevelEnabled(v10, 0);

        if (v11)
        {
          v13 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v12);
          v14 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v13, 0, "%s%.30s:%-4d %@: Not restarting ClassA session because attempt failed once. Will retry at next unlock", "", "-[NRLinkBluetooth restartIKESessionForDataProtectionClass:authFailure:afterDisconnection:]", 9004, v14);
LABEL_20:

        }
      }
      else
      {
        v18 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v9);
        v19 = _NRLogIsLevelEnabled(v18, 0);

        if (v19)
        {
          v21 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v20);
          v22 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v21, 0, "%s%.30s:%-4d %@: Restarting %@ session", "", "-[NRLinkBluetooth restartIKESessionForDataProtectionClass:authFailure:afterDisconnection:]", 9009, v22, String);

        }
        sub_10007762C(a1, a2);
        if (a4 && *(_BYTE *)(a1 + 242))
        {
          if ((_DWORD)a2 == 4)
          {
            v23 = &OBJC_IVAR___NRLinkBluetooth__reconnectionTimerStartedClassD;
          }
          else
          {
            if ((_DWORD)a2 != 3)
              goto LABEL_21;
            v23 = &OBJC_IVAR___NRLinkBluetooth__reconnectionTimerStartedClassC;
          }
          v27 = (_BYTE *)(a1 + *v23);
          if (!*v27)
          {
            v28 = (void *)NRDataProtectionClassCreateString(a2);
            v30 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v29);
            v31 = _NRLogIsLevelEnabled(v30, 0);

            if (v31)
            {
              v33 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v32);
              v34 = objc_msgSend((id)a1, "copyDescription");
              _NRLogWithArgs(v33, 0, "%s%.30s:%-4d %@: Starting %@ reconnection timer", "", "-[NRLinkBluetooth startReconnectionTimer:]", 9035, v34, v28);

            }
            *v27 = 1;
            objc_msgSend((id)a1, "setPowerAssertionState:", 1);
            objc_initWeak(&location, (id)a1);
            v35 = dispatch_time(0x8000000000000000, 10000000000);
            v36 = objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "queue"));
            block[0] = _NSConcreteStackBlock;
            block[1] = 3221225472;
            block[2] = sub_100077C9C;
            block[3] = &unk_1001B6D28;
            objc_copyWeak(v41, &location);
            v41[1] = v27;
            v40 = v28;
            v37 = v28;
            dispatch_after(v35, v36, block);

            objc_destroyWeak(v41);
            objc_destroyWeak(&location);
          }
        }
      }
    }
    else
    {
      v24 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v9);
      v25 = _NRLogIsLevelEnabled(v24, 0);

      if (v25)
      {
        v13 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v26);
        v14 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v13, 0, "%s%.30s:%-4d %@: Not restarting %@ session because remote not unlocked", "", "-[NRLinkBluetooth restartIKESessionForDataProtectionClass:authFailure:afterDisconnection:]", 8998, v14, String);
        goto LABEL_20;
      }
    }
  }
LABEL_21:

}

void sub_100077618(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_destroyWeak((id *)(v1 - 56));
  _Unwind_Resume(a1);
}

void sub_10007762C(uint64_t a1, uint64_t a2)
{
  id *v4;
  id *v5;
  uint64_t v6;
  void *String;
  char *v8;
  uint64_t v9;
  char *v10;
  void *v11;
  int v12;
  uint64_t v13;
  void *v14;
  id v15;
  const char *v16;
  void *v17;
  int IsLevelEnabled;
  uint64_t v19;
  id v20;
  id v21;
  id v22;
  uint64_t v23;
  void *v24;
  void *v25;
  id v26;
  id v27;
  id v28;
  void *v29;
  id v30;
  void *v31;
  void *v32;
  id v33;
  void *v34;
  int v35;
  uint64_t v36;
  unsigned int v37;
  id v38;
  void *v39;
  id v40;
  id v41;
  id v42;
  id v43;
  id v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  int *v50;
  uint64_t v51;
  uint64_t v52;
  void *v53;
  int v54;
  uint64_t v55;
  void *v56;
  id v57;
  void *v58;
  int v59;
  uint64_t v60;
  void *v61;
  int v62;
  uint64_t v63;
  void *v64;
  id v65;
  uint64_t v66;
  id v67;
  char *v68;
  char *v69;
  void *v70;
  _QWORD v71[2];

  if (!*(_BYTE *)(a1 + 242))
  {
    v4 = (id *)sub_100077D08(a1, a2);
    if (!*v4)
    {
      v5 = v4;
      String = (void *)NRDataProtectionClassCreateString(a2);
      if (*(unsigned __int8 *)(a1 + 16) == 255)
      {
        v17 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v6);
        IsLevelEnabled = _NRLogIsLevelEnabled(v17, 0);

        if (!IsLevelEnabled)
        {
LABEL_44:

          return;
        }
        v10 = (char *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v19);
        v20 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v10, 0, "%s%.30s:%-4d %@: Not starting %@ initiator session because cancelled", "", "-[NRLinkBluetooth setupIPsecInitiatorIfNecessary:]", 8859, v20, String);

        goto LABEL_43;
      }
      v8 = sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(a1 + 32));
      v10 = v8;
      if (!v8)
      {
        v58 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v9);
        v59 = _NRLogIsLevelEnabled(v58, 17);

        if (!v59)
          goto LABEL_43;
        v14 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v60);
        v15 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v14, 17, "%@: Not starting %@ IKE initiator session because localDevice is missing", v15, String);
        goto LABEL_21;
      }
      if ((_DWORD)a2 == 1)
      {
        if (*((unsigned __int16 *)v8 + 14) > 0x12u)
        {
          v11 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v9);
          v12 = _NRLogIsLevelEnabled(v11, 0);

          if (v12)
          {
            v14 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v13);
            v15 = objc_msgSend((id)a1, "copyDescription");
            v67 = v15;
            v68 = v10;
            v66 = 8869;
            v16 = "%s%.30s:%-4d %@: Not starting ClassA IKE initiator session because peer supports skipping ClassA pairing %@";
LABEL_20:
            _NRLogWithArgs(v14, 0, v16, "", "-[NRLinkBluetooth setupIPsecInitiatorIfNecessary:]", v66, v67, v68, v69);
LABEL_21:

            goto LABEL_43;
          }
          goto LABEL_43;
        }
        v21 = *((id *)v8 + 11);
      }
      else
      {
        v21 = sub_100131288(v8, a2);
      }
      v22 = v21;

      if (!v22)
      {
        v34 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v23);
        v35 = _NRLogIsLevelEnabled(v34, 0);

        if (v35)
        {
          v14 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v36);
          v15 = objc_msgSend((id)a1, "copyDescription");
          v68 = (char *)String;
          v69 = v10;
          v66 = 8873;
          v67 = v15;
          v16 = "%s%.30s:%-4d %@: Not starting %@ IKE initiator session because we do not have keys %@";
          goto LABEL_20;
        }
LABEL_43:

        goto LABEL_44;
      }
      v24 = sub_100112798(1, v10, a2);
      v70 = v24;
      if ((_DWORD)a2 != 1)
      {
        v25 = (void *)objc_claimAutoreleasedReturnValue(+[NWAddressEndpoint endpointWithHostname:port:](NWAddressEndpoint, "endpointWithHostname:port:", CFSTR("::"), CFSTR("0")));
        v26 = objc_alloc((Class)NEIKEv2ConfigurationMessage);
        v27 = objc_msgSend(objc_alloc((Class)NEIKEv2InitiatorTransportIPv6Address), "initWithAddress:", v25);
        v71[0] = v27;
        v28 = objc_msgSend(objc_alloc((Class)NEIKEv2ResponderTransportIPv6Address), "initWithAddress:", v25);
        v71[1] = v28;
        v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v71, 2));
        v30 = objc_msgSend(v26, "initWithWithAttributes:", v29);
        objc_msgSend(v70, "setConfigurationRequest:", v30);

        v24 = v70;
      }
      v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v24, "customIKEAuthPrivateNotifies"));

      if (v31)
      {
        v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v24, "customIKEAuthPrivateNotifies"));
        v33 = objc_msgSend(v32, "mutableCopy");

      }
      else
      {
        v33 = objc_alloc_init((Class)NSMutableArray);
      }
      v37 = objc_msgSend((id)a1, "suspendWhenReady");
      if ((_DWORD)a2 == 4 && v37)
      {
        v38 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50901, 0);
        objc_msgSend(v33, "addObject:", v38);

      }
      if (objc_msgSend(v33, "count"))
        objc_msgSend(v24, "setCustomIKEAuthPrivateNotifies:", v33);
      v39 = v24;
      v40 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("terminusIKE-Bluetooth-%@"), String);
      v41 = sub_100112198();
      sub_100111E90(v10, v41);
      v42 = sub_100112420();
      objc_msgSend(v42, "setSequencePerTrafficClass:", 1);
      objc_msgSend(v42, "setReplayWindowSize:", 16);
      sub_100112034(v10, v42);
      v43 = objc_msgSend(objc_alloc((Class)NEIKEv2Session), "initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:kernelSASessionName:packetDelegate:", v41, v42, v39, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 56), 0, v40, a1);
      v44 = *v5;
      *v5 = v43;

      if (!*v5)
      {
        v61 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v45);
        v62 = _NRLogIsLevelEnabled(v61, 17);

        if (v62)
        {
          v64 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v63);
          v65 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v64, 17, "%@: Failed to create initiator %@ IKE session", v65, String);

        }
        goto LABEL_42;
      }
      objc_msgSend((id)a1, "reportEvent:detailsFormat:", 3015, CFSTR("%@ %@"), String, *v5);
      sub_100077E8C((_QWORD *)a1, a2);
      if ((_DWORD)a2 == 4)
      {
        v47 = mach_absolute_time();
        v48 = *(_QWORD *)(a1 + 1863);
        if (v48)
        {
          *(_QWORD *)(v48 + 48) = v47;
          v49 = (char *)*(id *)(a1 + 1863);
          if (v49)
          {
            v50 = &OBJC_IVAR___NRAnalyticsCmpnLink__ikeClassDAttempts;
LABEL_37:
            ++*(_QWORD *)&v49[*v50];
            goto LABEL_38;
          }
          goto LABEL_38;
        }
      }
      else
      {
        if ((_DWORD)a2 != 3)
        {
LABEL_39:
          v53 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v46);
          v54 = _NRLogIsLevelEnabled(v53, 0);

          if (v54)
          {
            v56 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v55);
            v57 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v56, 0, "%s%.30s:%-4d %@: Connecting initiator %@ session %@", "", "-[NRLinkBluetooth setupIPsecInitiatorIfNecessary:]", 8934, v57, String, *v5);

          }
          objc_msgSend(*v5, "connect");
LABEL_42:

          goto LABEL_43;
        }
        v51 = mach_absolute_time();
        v52 = *(_QWORD *)(a1 + 1863);
        if (v52)
        {
          *(_QWORD *)(v52 + 32) = v51;
          v49 = (char *)*(id *)(a1 + 1863);
          if (v49)
          {
            v50 = &OBJC_IVAR___NRAnalyticsCmpnLink__ikeClassCAttempts;
            goto LABEL_37;
          }
LABEL_38:

          goto LABEL_39;
        }
      }
      v49 = 0;
      goto LABEL_38;
    }
  }
}

void sub_100077C9C(uint64_t a1)
{
  id WeakRetained;
  BOOL v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  id v10;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    v10 = WeakRetained;
    v3 = objc_msgSend(WeakRetained, "state") == 255;
    WeakRetained = v10;
    if (!v3)
    {
      if (**(_BYTE **)(a1 + 48))
      {
        sub_100074F70(v10, CFSTR("%@ reconnection timed out"), v4, v5, v6, v7, v8, v9, *(_QWORD *)(a1 + 32));
        WeakRetained = v10;
      }
    }
  }

}

uint64_t sub_100077D08(uint64_t result, int a2)
{
  int *v2;
  id v3;
  int IsLevelEnabled;
  id v5;
  void *String;
  uint64_t v7;
  char *v8;
  int *v9;
  uint64_t v10;
  uint64_t v11;
  id v12;
  uint64_t v13;
  uint64_t v14;

  if (result)
  {
    switch(a2)
    {
      case 1:
        v2 = &OBJC_IVAR___NRLinkBluetooth__ikeSessionClassA;
        goto LABEL_8;
      case 4:
        v2 = &OBJC_IVAR___NRLinkBluetooth__ikeSessionClassD;
        goto LABEL_8;
      case 3:
        v2 = &OBJC_IVAR___NRLinkBluetooth__ikeSessionClassC;
LABEL_8:
        result += *v2;
        return result;
    }
    HIDWORD(v14) = a2;
    v3 = sub_100070AC8();
    IsLevelEnabled = _NRLogIsLevelEnabled(v3, 16);

    if (IsLevelEnabled)
    {
      v5 = sub_100070AC8();
      String = (void *)NRDataProtectionClassCreateString(HIDWORD(v14));
      _NRLogWithArgs(v5, 16, "%s%.30s:%-4d ABORTING: Cannot copy IKE session pointer for %@", "", "-[NRLinkBluetooth ikeSessionPointerForDataProtectionClass:]", 1460, String);

    }
    v7 = _os_log_pack_size(22);
    v8 = (char *)&v14 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
    v9 = __error();
    v10 = _os_log_pack_fill(v8, v7, *v9, &_mh_execute_header, "%{public}s Cannot copy IKE session pointer for %@");
    v11 = NRDataProtectionClassCreateString(HIDWORD(v14));
    *(_DWORD *)v10 = 136446466;
    *(_QWORD *)(v10 + 4) = "-[NRLinkBluetooth ikeSessionPointerForDataProtectionClass:]";
    *(_WORD *)(v10 + 12) = 2112;
    *(_QWORD *)(v10 + 14) = v11;
    v12 = sub_100070AC8();
    v13 = _NRLogAbortWithPack(v12, v8);
    return sub_100077E8C(v13);
  }
  return result;
}

void sub_100077E8C(_QWORD *a1, uint64_t a2)
{
  int v2;
  void *String;
  void *v5;
  id v6;
  int v7;
  id v8;
  id v9;
  int IsLevelEnabled;
  id v11;
  id v12;
  id v13;
  id v14;
  id v15;
  id v16;
  id v17;
  id v18;
  id v19;
  id v20;
  id v21;
  id v22;
  id v23;
  id v24;
  id v25;
  uint64_t v26;
  void *v27;
  char v28;
  uint64_t v29;
  void *v30;
  id v31;
  id v32;
  int v33;
  void *v34;
  _QWORD v35[4];
  id v36;
  id v37;
  id v38;
  char v39;
  _QWORD v40[4];
  id v41;
  id v42;
  id v43;
  _QWORD v44[4];
  id v45;
  id v46;
  id v47;
  _QWORD v48[4];
  id v49;
  id v50;
  id v51;
  _QWORD v52[4];
  id v53;
  id v54;
  id v55;
  _QWORD v56[4];
  id v57;
  id v58;
  id v59;
  char v60;
  _QWORD v61[4];
  id v62;
  id v63;
  _QWORD *v64;
  id v65;
  char v66;
  id location[2];

  v2 = a2;
  String = (void *)NRDataProtectionClassCreateString(a2);
  if (v2 == 1)
  {
    v5 = *(void **)((char *)a1 + 1239);
    if (!v5)
    {
      v9 = sub_100070AC8();
      IsLevelEnabled = _NRLogIsLevelEnabled(v9, 17);

      if (IsLevelEnabled)
      {
        v8 = sub_100070AC8();
        _NRLogWithArgs(v8, 17, "%s called with null _ikeSessionClassA");
        goto LABEL_24;
      }
      goto LABEL_20;
    }
    goto LABEL_11;
  }
  if (v2 == 3)
  {
    v5 = *(void **)((char *)a1 + 1231);
    if (v5)
      goto LABEL_11;
    v32 = sub_100070AC8();
    v33 = _NRLogIsLevelEnabled(v32, 17);

    if (v33)
    {
      v8 = sub_100070AC8();
      _NRLogWithArgs(v8, 17, "%s called with null _ikeSessionClassC");
      goto LABEL_24;
    }
LABEL_20:
    v25 = 0;
    goto LABEL_21;
  }
  if (v2 != 4)
  {
    if (qword_1001E46D8 != -1)
      dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
    if (_NRLogIsLevelEnabled(qword_1001E46D0, 17))
    {
      if (qword_1001E46D8 != -1)
        dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
      _NRLogWithArgs(qword_1001E46D0, 17, "Cannot setup IKE callbacks for %@", String);
    }
    goto LABEL_20;
  }
  v5 = *(void **)((char *)a1 + 1223);
  if (!v5)
  {
    v6 = sub_100070AC8();
    v7 = _NRLogIsLevelEnabled(v6, 17);

    if (v7)
    {
      v8 = sub_100070AC8();
      _NRLogWithArgs(v8, 17, "%s called with null _ikeSessionClassD");
LABEL_24:

      v25 = 0;
      goto LABEL_21;
    }
    goto LABEL_20;
  }
LABEL_11:
  v11 = v5;
  objc_msgSend(v11, "setClientQueue:", a1[1]);
  objc_initWeak(location, a1);
  v61[0] = _NSConcreteStackBlock;
  v61[1] = 3221225472;
  v61[2] = sub_100078498;
  v61[3] = &unk_1001B6B70;
  objc_copyWeak(&v65, location);
  v66 = v2;
  v12 = String;
  v62 = v12;
  v13 = v11;
  v63 = v13;
  v64 = a1;
  objc_msgSend(v13, "setStateUpdateBlock:", v61);
  v56[0] = _NSConcreteStackBlock;
  v56[1] = 3221225472;
  v56[2] = sub_1000790C0;
  v56[3] = &unk_1001B72B8;
  objc_copyWeak(&v59, location);
  v14 = v12;
  v57 = v14;
  v15 = v13;
  v58 = v15;
  v60 = v2;
  objc_msgSend(v15, "setChildStateUpdateBlock:", v56);
  v52[0] = _NSConcreteStackBlock;
  v52[1] = 3221225472;
  v52[2] = sub_1000792A0;
  v52[3] = &unk_1001B72E0;
  objc_copyWeak(&v55, location);
  v16 = v14;
  v53 = v16;
  v17 = v15;
  v54 = v17;
  objc_msgSend(v17, "setConfigurationUpdateBlock:", v52);
  v48[0] = _NSConcreteStackBlock;
  v48[1] = 3221225472;
  v48[2] = sub_10007936C;
  v48[3] = &unk_1001B7308;
  objc_copyWeak(&v51, location);
  v18 = v16;
  v49 = v18;
  v19 = v17;
  v50 = v19;
  objc_msgSend(v19, "setTrafficSelectorUpdateBlock:", v48);
  v34 = String;
  v44[0] = _NSConcreteStackBlock;
  v44[1] = 3221225472;
  v44[2] = sub_100079458;
  v44[3] = &unk_1001B7330;
  objc_copyWeak(&v47, location);
  v20 = v18;
  v45 = v20;
  v21 = v19;
  v46 = v21;
  objc_msgSend(v21, "setAdditionalAddressesUpdateBlock:", v44);
  v40[0] = _NSConcreteStackBlock;
  v40[1] = 3221225472;
  v40[2] = sub_100079524;
  v40[3] = &unk_1001B7928;
  objc_copyWeak(&v43, location);
  v22 = v20;
  v41 = v22;
  v23 = v21;
  v42 = v23;
  objc_msgSend(v23, "setShortDPDEventBlock:", v40);
  v35[0] = _NSConcreteStackBlock;
  v35[1] = 3221225472;
  v35[2] = sub_1000795E4;
  v35[3] = &unk_1001B6B98;
  objc_copyWeak(&v38, location);
  v24 = v22;
  v36 = v24;
  v25 = v23;
  v37 = v25;
  v39 = v2;
  objc_msgSend(v25, "setPrivateNotifyStatusEvent:", v35);
  v27 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v26);
  v28 = _NRLogIsLevelEnabled(v27, 0);

  if ((v28 & 1) != 0)
  {
    v30 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v29);
    v31 = objc_msgSend(a1, "copyDescription");
    _NRLogWithArgs(v30, 0, "%s%.30s:%-4d %@: Setup IKE %@ %@ callbacks", "", "-[NRLinkBluetooth setupIKECallbacks:]", 8252, v31, v24, v25);

  }
  objc_destroyWeak(&v38);

  objc_destroyWeak(&v43);
  objc_destroyWeak(&v47);

  objc_destroyWeak(&v51);
  objc_destroyWeak(&v55);

  objc_destroyWeak(&v59);
  objc_destroyWeak(&v65);
  objc_destroyWeak(location);

  String = v34;
LABEL_21:

}

void sub_100078418(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id *location, id *a18, id *a19)
{
  id *v19;
  id *v20;
  id *v21;
  id *v22;
  uint64_t v23;

  objc_destroyWeak(v19);
  objc_destroyWeak(v22);
  objc_destroyWeak(v21);
  objc_destroyWeak(v20);
  objc_destroyWeak(location);
  objc_destroyWeak(a18);
  objc_destroyWeak(a19);
  objc_destroyWeak((id *)(v23 - 112));
  _Unwind_Resume(a1);
}

void sub_100078498(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;
  char *WeakRetained;
  char *v7;
  void *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  int v17;
  void *v18;
  int v19;
  uint64_t v20;
  void *v21;
  id v22;
  uint64_t v23;
  uint64_t v24;
  void *SessionStateString;
  id v26;
  uint64_t v27;
  void *v28;
  id v29;
  uint64_t v30;
  void *v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  int v46;
  void *v47;
  id v48;
  void *v49;
  int IsLevelEnabled;
  uint64_t v51;
  void *v52;
  id v53;
  void *v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  void *v60;
  int v61;
  uint64_t v62;
  void *v63;
  id v64;
  id v65;
  uint64_t v66;
  void *v67;
  int v68;
  uint64_t v69;
  void *v70;
  id v71;
  void *v72;
  int v73;
  uint64_t v74;
  void *v75;
  id v76;
  void *v77;
  int v78;
  uint64_t v79;
  void *v80;
  id v81;
  void *v82;
  int v83;
  uint64_t v84;
  void *v85;
  id v86;
  void *v87;
  int v88;
  uint64_t v89;
  void *v90;
  char *v91;
  void *v92;
  uint64_t v93;
  void *v94;
  _QWORD *v95;
  void **v96;
  uint64_t v97;
  void (*v98)(uint64_t);
  void *v99;
  id v100;
  id location;
  uint64_t v102;
  void *v103;
  void *v104;
  char *v105;
  id v106;
  id from;

  v5 = a3;
  WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 56));
  v7 = WeakRetained;
  if (WeakRetained)
  {
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "linkDelegate"));
    if (v5)
    {
      v9 = *(unsigned __int8 *)(a1 + 64);
      if (v9 == 1)
      {
        sub_10007C580(v7);
        goto LABEL_18;
      }
      if (v9 == 3)
      {
        objc_msgSend(v7, "setIkeClassCEstablished:", 0);
        v10 = mach_absolute_time();
        v11 = *(_QWORD *)(v7 + 1863);
        if (!v11)
          goto LABEL_18;
        v12 = 40;
      }
      else
      {
        if (v9 != 4
          || (objc_msgSend(v7, "setIkeClassDEstablished:", 0),
              v10 = mach_absolute_time(),
              (v11 = *(_QWORD *)(v7 + 1863)) == 0))
        {
LABEL_18:
          v23 = *(_QWORD *)(a1 + 32);
          v24 = *(_QWORD *)(a1 + 40);
          SessionStateString = (void *)NEIKEv2CreateSessionStateString(a2);
          objc_msgSend(v7, "reportEvent:detailsFormat:", 3018, CFSTR("%@ session %@ got IKE error %@ with state %@"), v23, v24, v5, SessionStateString);

          objc_msgSend(v7, "processIKEDisconnection:error:", *(unsigned __int8 *)(a1 + 64), v5);
          if (objc_msgSend(v7, "state") != 255)
          {
            v26 = v5;
            if (objc_msgSend(v26, "code") == (id)24)
            {
              v27 = NEIKEv2ProtocolErrorDomain;
              v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "domain"));
              LOBYTE(v27) = objc_msgSend(v28, "isEqualToString:", v27);

              if ((v27 & 1) != 0)
                goto LABEL_25;
            }
            else
            {

            }
            v29 = v26;
            if (objc_msgSend(v29, "code") == (id)8)
            {
              v30 = NEIKEv2ErrorDomain;
              v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v29, "domain"));
              LODWORD(v30) = objc_msgSend(v31, "isEqualToString:", v30);

              if ((_DWORD)v30)
              {
LABEL_25:
                v32 = 1;
                goto LABEL_28;
              }
            }
            else
            {

            }
            v32 = 0;
LABEL_28:
            v33 = *(unsigned __int8 *)(a1 + 64);
            v34 = (uint64_t)v7;
LABEL_29:
            sub_100077224(v34, v33, v32, 1);
          }
LABEL_30:

          goto LABEL_31;
        }
        v12 = 56;
      }
      *(_QWORD *)(v11 + v12) = v10;
      goto LABEL_18;
    }
    v13 = *(_QWORD *)(a1 + 32);
    v14 = *(_QWORD *)(a1 + 40);
    v15 = (void *)NEIKEv2CreateSessionStateString(a2);
    objc_msgSend(v7, "reportEvent:detailsFormat:", 3009, CFSTR("%@ session %@ changed state to %@"), v13, v14, v15);

    switch(a2)
    {
      case 1:
        v17 = v7[16];
        if (v17 == 5)
        {
          v49 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v7 + 4), v16);
          IsLevelEnabled = _NRLogIsLevelEnabled(v49, 0);

          if (!IsLevelEnabled)
            goto LABEL_30;
          v52 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v7 + 4), v51);
          v53 = objc_msgSend(v7, "copyDescription");
          _NRLogWithArgs(v52, 0, "%s%.30s:%-4d %@: %@ IKE %@ already connecting", "", "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke", 8039, v53, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
        }
        else
        {
          if (v17 == 4)
          {
            v18 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v7 + 4), v16);
            v19 = _NRLogIsLevelEnabled(v18, 0);

            if (v19)
            {
              v21 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v7 + 4), v20);
              v22 = objc_msgSend(v7, "copyDescription");
              _NRLogWithArgs(v21, 0, "%s%.30s:%-4d %@: %@ IKE %@ now connecting", "", "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke", 8036, v22, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));

            }
            objc_msgSend(v7, "changeStateTo:", 5);
            goto LABEL_30;
          }
          v54 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v7 + 4), v16);
          v55 = _NRLogIsLevelEnabled(v54, 16);

          if (!v55)
            goto LABEL_30;
          v52 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v7 + 4), v56);
          v53 = objc_msgSend(v7, "copyDescription");
          _NRLogWithArgs(v52, 16, "%s%.30s:%-4d %@: %@ IKE %@ connecting but weird state", "", "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke", 8041, v53, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
        }

        goto LABEL_30;
      case 2:
        v42 = *(unsigned __int8 *)(a1 + 64);
        if (v42 == 4)
        {
          objc_msgSend(v7, "setIkeClassDEstablished:", 1);
          v57 = mach_absolute_time();
          v59 = *(_QWORD *)(v7 + 1863);
          if (v59)
            *(_QWORD *)(v59 + 56) = v57;
          if (v7[238])
          {
            v60 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v7 + 4), v58);
            v61 = _NRLogIsLevelEnabled(v60, 0);

            if (v61)
            {
              v63 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v7 + 4), v62);
              v64 = objc_msgSend(v7, "copyDescription");
              _NRLogWithArgs(v63, 0, "%s%.30s:%-4d %@: Stopping %@ reconnection timer", "", "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke", 8058, v64, *(_QWORD *)(a1 + 32));

            }
            v7[238] = 0;
            if (!v7[239])
              objc_msgSend(v7, "setPowerAssertionState:", 0);
          }
          v65 = sub_10014A154((uint64_t)NRDKeyManager);
          if (!sub_10014AC6C((_BOOL8)v65) && !v7[237])
          {
            v66 = *(_QWORD *)(a1 + 48);
            if (v66)
              *(_BYTE *)(v66 + 237) = 1;
            objc_initWeak(&location, v7);
            v96 = _NSConcreteStackBlock;
            v97 = 3221225472;
            v98 = sub_10007C7E8;
            v99 = &unk_1001B7F28;
            objc_copyWeak(&v100, &location);
            sub_10014ACE0((uint64_t)v65, &v96);
            objc_destroyWeak(&v100);
            objc_destroyWeak(&location);
          }

        }
        else if (v42 == 3)
        {
          objc_msgSend(v7, "setIkeClassCEstablished:", 1);
          v43 = mach_absolute_time();
          v44 = *(_QWORD *)(v7 + 1863);
          if (v44)
            *(_QWORD *)(v44 + 40) = v43;
          if (v7[239])
          {
            v45 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v7 + 4), v16);
            v46 = _NRLogIsLevelEnabled(v45, 0);

            if (v46)
            {
              v47 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v7 + 4), v16);
              v48 = objc_msgSend(v7, "copyDescription");
              _NRLogWithArgs(v47, 0, "%s%.30s:%-4d %@: Stopping %@ reconnection timer", "", "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke", 8048, v48, *(_QWORD *)(a1 + 32));

            }
            v7[239] = 0;
            if (!v7[238])
              objc_msgSend(v7, "setPowerAssertionState:", 0);
          }
        }
        switch(v7[16])
        {
          case 5:
            v67 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v7 + 4), v16);
            v68 = _NRLogIsLevelEnabled(v67, 0);

            if (v68)
            {
              v70 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v7 + 4), v69);
              v71 = objc_msgSend(v7, "copyDescription");
              _NRLogWithArgs(v70, 0, "%s%.30s:%-4d %@: %@ IKE %@ now connected from started", "", "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke", 8104, v71, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));

            }
            objc_msgSend(v7, "changeStateTo:", 6);
            break;
          case 6:
            v72 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v7 + 4), v16);
            v73 = _NRLogIsLevelEnabled(v72, 0);

            if (v73)
            {
              v75 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v7 + 4), v74);
              v76 = objc_msgSend(v7, "copyDescription");
              _NRLogWithArgs(v75, 0, "%s%.30s:%-4d %@: %@ IKE %@ already connected", "", "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke", 8116, v76, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), v96, v97, v98, v99);
              goto LABEL_85;
            }
            break;
          case 7:
            v77 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v7 + 4), v16);
            v78 = _NRLogIsLevelEnabled(v77, 0);

            if (v78)
            {
              v80 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v7 + 4), v79);
              v81 = objc_msgSend(v7, "copyDescription");
              _NRLogWithArgs(v80, 0, "%s%.30s:%-4d %@: %@ IKE %@ now connected and ready from first notify", "", "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke", 8108, v81, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));

            }
            objc_msgSend(v7, "changeStateTo:detailsFormat:", 8, CFSTR("(%@ IKE %@ connected after received first notify)"), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
            objc_msgSend(v8, "linkIsReady:", v7);
            objc_msgSend(v7, "checkProxyAgentWithForceUpdate:", 0);
            break;
          case 8:
            v82 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v7 + 4), v16);
            v83 = _NRLogIsLevelEnabled(v82, 0);

            if (v83)
            {
              v85 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v7 + 4), v84);
              v86 = objc_msgSend(v7, "copyDescription");
              _NRLogWithArgs(v85, 0, "%s%.30s:%-4d %@: %@ IKE %@ already ready", "", "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke", 8118, v86, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));

            }
            objc_msgSend(v8, "linkIsReady:", v7);
            break;
          default:
            v87 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v7 + 4), v16);
            v88 = _NRLogIsLevelEnabled(v87, 0);

            if (v88)
            {
              v75 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v7 + 4), v89);
              v76 = objc_msgSend(v7, "copyDescription");
              _NRLogWithArgs(v75, 0, "%s%.30s:%-4d %@: %@ IKE %@ connected but weird state", "", "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke", 8121, v76, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), v96, v97, v98, v99);
LABEL_85:

            }
            break;
        }
        if (!v7[242])
        {
          objc_initWeak(&from, v7);
          v90 = *(void **)(v7 + 1223);
          v91 = sub_10007630C(v7, 0);
          v92 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "queue"));
          location = _NSConcreteStackBlock;
          v102 = 3221225472;
          v103 = sub_10007CD10;
          v104 = &unk_1001B7978;
          objc_copyWeak((id *)&v105, &from);
          objc_msgSend(v90, "sendPrivateNotifies:maxRetries:retryIntervalInMilliseconds:callbackQueue:callback:", v91, 10, 10000, v92, &location);

          objc_destroyWeak((id *)&v105);
          objc_destroyWeak(&from);
        }
        v93 = *(unsigned __int8 *)(a1 + 64);
        v94 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "nrUUID"));
        sub_1001364DC((uint64_t)NRDLocalDevice, v93, v94);

        if (objc_msgSend(v7, "state") != 255)
        {
          objc_initWeak(&from, v7);
          objc_opt_self(NRLinkDirector);
          if (qword_1001E4710 != -1)
            dispatch_once(&qword_1001E4710, &stru_1001B6E60);
          v95 = (id)qword_1001E4708;
          location = _NSConcreteStackBlock;
          v102 = 3221225472;
          v103 = sub_10007C964;
          v104 = &unk_1001B6B20;
          objc_copyWeak(&v106, &from);
          v105 = v7;

          objc_destroyWeak(&v106);
          objc_destroyWeak(&from);
        }
        goto LABEL_30;
      case 3:
        v35 = *(unsigned __int8 *)(a1 + 64);
        switch(v35)
        {
          case 1:
            sub_10007C580(v7);
            break;
          case 3:
            objc_msgSend(v7, "setIkeClassCEstablished:", 0);
            v36 = mach_absolute_time();
            v37 = *(_QWORD *)(v7 + 1863);
            if (v37)
            {
              v38 = 40;
LABEL_73:
              *(_QWORD *)(v37 + v38) = v36;
            }
            break;
          case 4:
            objc_msgSend(v7, "setIkeClassDEstablished:", 0);
            v36 = mach_absolute_time();
            v37 = *(_QWORD *)(v7 + 1863);
            if (!v37)
              break;
            v38 = 56;
            goto LABEL_73;
          default:
            break;
        }
        objc_msgSend(v7, "reportEvent:detailsFormat:", 3018, CFSTR("%@ session %@ got IKE Disconnected state with no error"), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
        v33 = *(unsigned __int8 *)(a1 + 64);
        v34 = (uint64_t)v7;
        v32 = 0;
        goto LABEL_29;
      case 4:
        objc_msgSend(v7, "cancelWithReason:", CFSTR("%@ session %@ got unexpected MOBIKE state"), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
        goto LABEL_30;
      default:
        v39 = *(_QWORD *)(a1 + 32);
        v40 = *(_QWORD *)(a1 + 40);
        v41 = (void *)NEIKEv2CreateSessionStateString(a2);
        objc_msgSend(v7, "cancelWithReason:", CFSTR("%@ session %@ got bad IKE state %@"), v39, v40, v41);

        goto LABEL_30;
    }
  }
LABEL_31:

}

void sub_100079058(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  id *v20;

  objc_destroyWeak(v20);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000790C0(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id WeakRetained;
  uint64_t v8;
  uint64_t v9;
  void *SessionStateString;
  id v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  id v19;
  uint64_t v20;
  void *v21;
  void *v22;
  id v23;

  v23 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    if (v23)
    {
      v8 = *(_QWORD *)(a1 + 32);
      v9 = *(_QWORD *)(a1 + 40);
      SessionStateString = (void *)NEIKEv2CreateSessionStateString(a3);
      objc_msgSend(WeakRetained, "reportEvent:detailsFormat:", 3018, CFSTR("%@ session %@ got child %u state update %@ error %@"), v8, v9, a2, SessionStateString, v23);

      objc_msgSend(WeakRetained, "processIKEDisconnection:error:", *(unsigned __int8 *)(a1 + 56), v23);
      if (objc_msgSend(WeakRetained, "state") != 255)
      {
        v11 = v23;
        if (objc_msgSend(v11, "code") == (id)24)
        {
          v12 = NEIKEv2ProtocolErrorDomain;
          v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "domain"));
          LOBYTE(v12) = objc_msgSend(v13, "isEqualToString:", v12);

          if ((v12 & 1) != 0)
            goto LABEL_12;
        }
        else
        {

        }
        v19 = v11;
        if (objc_msgSend(v19, "code") == (id)8)
        {
          v20 = NEIKEv2ErrorDomain;
          v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "domain"));
          LODWORD(v20) = objc_msgSend(v21, "isEqualToString:", v20);

          if ((_DWORD)v20)
          {
LABEL_12:
            v18 = 1;
LABEL_16:
            v16 = *(unsigned __int8 *)(a1 + 56);
            v17 = (uint64_t)WeakRetained;
            goto LABEL_17;
          }
        }
        else
        {

        }
        v18 = 0;
        goto LABEL_16;
      }
    }
    else
    {
      v14 = *(_QWORD *)(a1 + 32);
      v15 = *(_QWORD *)(a1 + 40);
      if (a3 == 3)
      {
        objc_msgSend(WeakRetained, "reportEvent:detailsFormat:", 3018, CFSTR("%@ session %@ got child %u Disconnected state with no error"), v14, *(_QWORD *)(a1 + 40), a2);
        v16 = *(unsigned __int8 *)(a1 + 56);
        v17 = (uint64_t)WeakRetained;
        v18 = 0;
LABEL_17:
        sub_100077224(v17, v16, v18, 1);
        goto LABEL_18;
      }
      v22 = (void *)NEIKEv2CreateSessionStateString(a3);
      objc_msgSend(WeakRetained, "reportEvent:detailsFormat:", 3009, CFSTR("%@ session %@ child %u state update %@"), v14, v15, a2, v22);

    }
  }
LABEL_18:

}

void sub_1000792A0(uint64_t a1, void *a2)
{
  _QWORD *WeakRetained;
  uint64_t v4;
  _QWORD *v5;
  void *v6;
  int IsLevelEnabled;
  uint64_t v8;
  void *v9;
  id v10;
  id v11;

  v11 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  v5 = WeakRetained;
  if (WeakRetained)
  {
    v6 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0);

    if (IsLevelEnabled)
    {
      v9 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v8);
      v10 = objc_msgSend(v5, "copyDescription");
      _NRLogWithArgs(v9, 0, "%s%.30s:%-4d %@: %@ session %@ got config update %@", "", "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke_5", 8204, v10, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), v11);

    }
  }

}

void sub_10007936C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v7;
  _QWORD *WeakRetained;
  uint64_t v9;
  _QWORD *v10;
  void *v11;
  int IsLevelEnabled;
  uint64_t v13;
  void *v14;
  id v15;
  id v16;

  v16 = a3;
  v7 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  v10 = WeakRetained;
  if (WeakRetained)
  {
    v11 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v9);
    IsLevelEnabled = _NRLogIsLevelEnabled(v11, 0);

    if (IsLevelEnabled)
    {
      v14 = (void *)_NRCopyLogObjectForNRUUID(v10[4], v13);
      v15 = objc_msgSend(v10, "copyDescription");
      _NRLogWithArgs(v14, 0, "%s%.30s:%-4d %@: %@ session %@ got child %u traffic selector update local %@ remote %@", "", "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke_6", 8215, v15, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), a2, v16, v7);

    }
  }

}

void sub_100079458(uint64_t a1, void *a2)
{
  _QWORD *WeakRetained;
  uint64_t v4;
  _QWORD *v5;
  void *v6;
  int IsLevelEnabled;
  uint64_t v8;
  void *v9;
  id v10;
  id v11;

  v11 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  v5 = WeakRetained;
  if (WeakRetained)
  {
    v6 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0);

    if (IsLevelEnabled)
    {
      v9 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v8);
      v10 = objc_msgSend(v5, "copyDescription");
      _NRLogWithArgs(v9, 0, "%s%.30s:%-4d %@: %@ session %@ got additional addresses %@", "", "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke_7", 8224, v10, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), v11);

    }
  }

}

void sub_100079524(uint64_t a1)
{
  _QWORD *WeakRetained;
  uint64_t v3;
  void *v4;
  int IsLevelEnabled;
  uint64_t v6;
  void *v7;
  id v8;
  _QWORD *v9;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    v9 = WeakRetained;
    v4 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v3);
    IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0);

    WeakRetained = v9;
    if (IsLevelEnabled)
    {
      v7 = (void *)_NRCopyLogObjectForNRUUID(v9[4], v6);
      v8 = objc_msgSend(v9, "copyDescription");
      _NRLogWithArgs(v7, 0, "%s%.30s:%-4d %@: %@ session %@ got short DPD", "", "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke_8", 8232, v8, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));

      WeakRetained = v9;
    }
  }

}

void sub_1000795E4(uint64_t a1, void *a2)
{
  id v3;
  _QWORD *WeakRetained;
  id v5;
  void *v6;
  void *v7;
  uint64_t v8;
  void *v9;
  int IsLevelEnabled;
  uint64_t v11;
  void *v12;
  id v13;
  id v14;
  id v15;
  id v16;
  uint64_t v17;
  void *i;
  void *v19;
  id v20;
  void *v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  _BYTE v26[128];
  id v27;

  v3 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    v5 = objc_msgSend(objc_alloc((Class)NSSortDescriptor), "initWithKey:ascending:", CFSTR("notifyStatus"), 1);
    v27 = v5;
    v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v27, 1));
    v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "sortedArrayUsingDescriptors:", v6));

    v9 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v8);
    IsLevelEnabled = _NRLogIsLevelEnabled(v9, 0);

    if (IsLevelEnabled)
    {
      v12 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v11);
      v13 = objc_msgSend(WeakRetained, "copyDescription");
      _NRLogWithArgs(v12, 0, "%s%.30s:%-4d %@: %@ session %@ got private notifies %@", "", "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke_9", 8244, v13, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), v7);

    }
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    v14 = v7;
    v15 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v22, v26, 16);
    if (v15)
    {
      v16 = v15;
      v17 = *(_QWORD *)v23;
      do
      {
        for (i = 0; i != v16; i = (char *)i + 1)
        {
          if (*(_QWORD *)v23 != v17)
            objc_enumerationMutation(v14);
          v19 = *(void **)(*((_QWORD *)&v22 + 1) + 8 * (_QWORD)i);
          v20 = objc_msgSend(v19, "notifyStatus");
          v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "notifyData"));
          sub_100079814((uint64_t)WeakRetained, (uint64_t)v20, v21, *(unsigned __int8 *)(a1 + 56));

        }
        v16 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v22, v26, 16);
      }
      while (v16);
    }

  }
}

void sub_100079814(uint64_t a1, uint64_t a2, void *a3, int a4)
{
  int *v4;
  char *v8;
  int v9;
  uint64_t v10;
  __objc2_class *v11;
  int IsLevelEnabled;
  uint64_t v13;
  void *v14;
  void *v15;
  id v16;
  void *v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  int v22;
  uint64_t v23;
  void *v24;
  int v25;
  uint64_t v26;
  id v27;
  id v28;
  void *v29;
  int v30;
  uint64_t v31;
  const char *v32;
  uint64_t v33;
  void *v34;
  int v35;
  uint64_t v36;
  void *v37;
  id v38;
  uint64_t v39;
  void *v40;
  int v41;
  uint64_t v42;
  void *v43;
  id v44;
  _BOOL8 v45;
  void *v46;
  id v47;
  int v48;
  void *v49;
  int v50;
  uint64_t v51;
  void *v52;
  id v53;
  void *v54;
  int v55;
  uint64_t v56;
  void *v57;
  int v58;
  uint64_t v59;
  void *v60;
  int v61;
  uint64_t v62;
  void *v63;
  int v64;
  void *v65;
  id v66;
  void *v67;
  int v68;
  uint64_t v69;
  uint64_t v70;
  void *v71;
  int v72;
  uint64_t v73;
  void *v74;
  id v75;
  char *v76;
  void *v77;
  id v78;
  uint64_t v79;
  void *v80;
  int v81;
  uint64_t v82;
  void *v83;
  id v84;
  id v85;
  void *v86;
  uint64_t v87;
  void *v88;
  int v89;
  uint64_t v90;
  void *v91;
  id v92;
  uint64_t v93;
  void *v94;
  int v95;
  uint64_t v96;
  void *v97;
  id v98;
  char *v99;
  char *v100;
  unsigned int v101;
  uint64_t v102;
  char *v103;
  void *v104;
  unsigned int v105;
  unsigned int v106;
  void *v107;
  id v108;
  _BOOL4 v109;
  id v110;
  void *v111;
  uint64_t v112;
  void *v113;
  int v114;
  uint64_t v115;
  void *v116;
  id v117;
  char *v118;
  void *v119;
  uint64_t v120;
  void *v121;
  int v122;
  uint64_t v123;
  void *v124;
  id v125;
  void *LogString;
  id v127;
  int v128;
  uint64_t v129;
  void *v130;
  int v131;
  uint64_t v132;
  uint64_t v133;
  void *v134;
  int v135;
  uint64_t v136;
  uint64_t v137;
  void *v138;
  int v139;
  uint64_t v140;
  uint64_t v141;
  void *v142;
  int v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  void *v147;
  int v148;
  uint64_t v149;
  void *v150;
  id v151;
  uint64_t v152;
  void *v153;
  uint64_t v154;
  void *v155;
  uint64_t v156;
  uint64_t v157;
  void *v158;
  int v159;
  uint64_t v160;
  void *v161;
  id v162;
  uint64_t v163;
  void *v164;
  uint64_t v165;
  void *v166;
  void *v167;
  uint64_t v168;
  void *v169;
  int v170;
  uint64_t v171;
  void *v172;
  id v173;
  void *v174;
  uint64_t v175;
  uint64_t v176;
  void *v177;
  int v178;
  uint64_t v179;
  void *v180;
  id v181;
  uint64_t v182;
  void *IPv6AddrString;
  uint64_t v184;
  void *v185;
  uint64_t v186;
  void *v187;
  int v188;
  uint64_t v189;
  void *v190;
  id v191;
  void *v192;
  uint64_t v193;
  uint64_t v194;
  void *v195;
  int v196;
  uint64_t v197;
  void *v198;
  id v199;
  uint64_t v200;
  void *v201;
  uint64_t v202;
  void *v203;
  void *v204;
  int v205;
  uint64_t v206;
  void *v207;
  id v208;
  uint64_t v209;
  void *v210;
  void *v211;
  int v212;
  uint64_t v213;
  void *v214;
  id v215;
  uint64_t v216;
  void *v217;
  void *v218;
  int v219;
  uint64_t v220;
  void *v221;
  id v222;
  uint64_t v223;
  void *v224;
  void *v225;
  int v226;
  uint64_t v227;
  void *v228;
  id v229;
  uint64_t v230;
  void *v231;
  id v232;
  int v233;
  id v234;
  id v235;
  int v236;
  id v237;
  id v238;
  int v239;
  id v240;
  id v241;
  int v242;
  id v243;
  int *v244;
  uint64_t v245;
  id v246;
  uint64_t v247;
  uint64_t v248;
  id v249;
  _QWORD v250[5];
  id location;
  uint64_t v252;
  _QWORD v253[4];
  id v254;
  char v255;

  v8 = a3;
  v9 = *(unsigned __int8 *)(a1 + 16);
  v11 = (__objc2_class *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v10);
  IsLevelEnabled = _NRLogIsLevelEnabled(v11, 0);

  if (v9 == 255)
  {
    if (IsLevelEnabled)
    {
      v15 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v13);
      v16 = objc_msgSend((id)a1, "copyDescription");
      _NRLogWithArgs(v15, 0, "%s%.30s:%-4d %@: Cancelled, ignoring notify code %u %@", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7652, v16, a2, v8);
LABEL_12:

    }
  }
  else
  {
    if ((IsLevelEnabled & 1) != 0)
    {
      v14 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v13);
      v11 = (__objc2_class *)objc_msgSend((id)a1, "copyDescription");
      _NRLogWithArgs(v14, 0, "%s%.30s:%-4d %@: Received notify code %u len %llu", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7655, v11, a2, objc_msgSend(v8, "length"));

    }
    if ((_DWORD)a2 == 50901 && a4 == 4)
    {
      objc_msgSend((id)a1, "setSuspendWhenReady:", 1);
      goto LABEL_13;
    }
    if ((_DWORD)a2 != 50000)
    {
LABEL_13:
      v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "linkDelegate"));
      v22 = *(unsigned __int8 *)(a1 + 16);
      if ((v22 - 5) <= 1)
      {
        if (v22 == 5)
        {
          objc_msgSend((id)a1, "changeStateTo:", 7);
        }
        else if (v22 == 6)
        {
          objc_msgSend((id)a1, "changeStateTo:details:", 8, CFSTR("(IKE received first notify after connected)"));
          objc_msgSend(v21, "linkIsReady:", a1);
          objc_msgSend((id)a1, "checkProxyAgentWithForceUpdate:", 0);
        }
      }
      if ((int)a2 <= 50500)
      {
        if ((int)a2 <= 50350)
        {
          switch((int)a2)
          {
            case 48601:
              if ((objc_msgSend(v8, "isEqual:", *(_QWORD *)(a1 + 359)) & 1) == 0)
              {
                objc_msgSend((id)a1, "cancelWithReason:", CFSTR("Received encrypted payload %@ does not match unencrypted %@"), v8, *(_QWORD *)(a1 + 359));
                goto LABEL_132;
              }
              v24 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v23);
              v25 = _NRLogIsLevelEnabled(v24, 0);

              if (!v25)
                goto LABEL_132;
              v27 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v26);
              v28 = objc_msgSend((id)a1, "copyDescription");
              _NRLogWithArgs(v27, 0, "%s%.30s:%-4d %@: Validated encrypted remote prelude", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7788, v28);
              goto LABEL_130;
            case 48602:
              LOWORD(location) = 0;
              if ((unint64_t)objc_msgSend(v8, "length") <= 1)
              {
                objc_msgSend((id)a1, "cancelWithReason:", CFSTR("Private notify Terminus Version too short %@"), v8, v248);
                goto LABEL_132;
              }
              objc_msgSend(v8, "getBytes:length:", &location, 2);
              v4 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
              *(_WORD *)(a1 + 261) = bswap32((unsigned __int16)location) >> 16;
              v94 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v93);
              v95 = _NRLogIsLevelEnabled(v94, 0);

              if (v95)
              {
                v97 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v96);
                v98 = objc_msgSend((id)a1, "copyDescription");
                _NRLogWithArgs(v97, 0, "%s%.30s:%-4d %@: Received remote terminus version %u", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7687, v98, *(unsigned __int16 *)(a1 + 261));

              }
              v11 = &OBJC_METACLASS___NRAnalyticsLocalDevice;
              v99 = sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(a1 + 32));
              v100 = v99;
              if (v99)
              {
                v101 = *((unsigned __int16 *)v99 + 14);
                goto LABEL_89;
              }
              goto LABEL_181;
            case 48603:
              v78 = objc_msgSend(objc_alloc((Class)NSString), "initWithData:encoding:", v8, 4);
              sub_10007BA00(a1, v78);

              v80 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v79);
              v81 = _NRLogIsLevelEnabled(v80, 0);

              if (v81)
              {
                v83 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v82);
                v84 = objc_msgSend((id)a1, "copyDescription");
                _NRLogWithArgs(v83, 0, "%s%.30s:%-4d %@: Received remote device name \"%@\"", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7711, v84, *(_QWORD *)(a1 + 343));

              }
              v85 = *(id *)(a1 + 343);
              v86 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "nrUUID"));
              sub_10013BF60((uint64_t)NRDLocalDevice, v85, v86);

              goto LABEL_132;
            case 48604:
              v27 = objc_msgSend(objc_alloc((Class)NSString), "initWithData:encoding:", v8, 4);
              v88 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v87);
              v89 = _NRLogIsLevelEnabled(v88, 0);

              if (v89)
              {
                v91 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v90);
                v92 = objc_msgSend((id)a1, "copyDescription");
                _NRLogWithArgs(v91, 0, "%s%.30s:%-4d %@: Received remote build version \"%@\"", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7717, v92, v27);

              }
              v28 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "nrUUID"));
              sub_10013C194((uint64_t)NRDLocalDevice, v27, v28);
              goto LABEL_130;
            case 48605:
              location = 0;
              if (objc_msgSend(v8, "length") == (id)8)
              {
                objc_msgSend(v8, "getBytes:length:", &location, 8);
                v71 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v70);
                v72 = _NRLogIsLevelEnabled(v71, 0);

                if (v72)
                {
                  v74 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v73);
                  v75 = objc_msgSend((id)a1, "copyDescription");
                  _NRLogWithArgs(v74, 0, "%s%.30s:%-4d %@: Received remote device flags %#llx", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7922, v75, location);

                }
                v76 = (char *)location;
                v77 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "nrUUID"));
                sub_10013CA58((uint64_t)NRDLocalDevice, v76, v77);

                goto LABEL_132;
              }
              v127 = sub_100070AC8();
              v128 = _NRLogIsLevelEnabled(v127, 16);

              if (!v128)
                goto LABEL_132;
              v27 = sub_100070AC8();
              _NRLogWithArgs(v27, 16, "%s%.30s:%-4d %@: Invalid NRLinkIKEPrivateNotifyCodeDeviceFlags payload length %zu", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7918, a1, objc_msgSend(v8, "length"));
              break;
            case 48606:
              LOBYTE(location) = 0;
              if (objc_msgSend(v8, "length") == (id)1)
              {
                objc_msgSend(v8, "getBytes:length:", &location, 1);
                v113 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v112);
                v114 = _NRLogIsLevelEnabled(v113, 0);

                if (v114)
                {
                  v116 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v115);
                  v117 = objc_msgSend((id)a1, "copyDescription");
                  _NRLogWithArgs(v116, 0, "%s%.30s:%-4d %@: Received remote device type %u", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7725, v117, location);

                }
                v118 = (char *)location;
                v119 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "nrUUID"));
                sub_10013BD90((uint64_t)NRDLocalDevice, v118, v119);

              }
              goto LABEL_132;
            case 48607:
              v27 = objc_msgSend(objc_alloc((Class)NSString), "initWithData:encoding:", v8, 4);
              v121 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v120);
              v122 = _NRLogIsLevelEnabled(v121, 0);

              if (v122)
              {
                v124 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v123);
                v125 = objc_msgSend((id)a1, "copyDescription");
                LogString = (void *)_NRKeyCreateLogString(v8);
                _NRLogWithArgs(v124, 0, "%s%.30s:%-4d %@: Received remote IDS device ID %@", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7732, v125, LogString);

              }
              v28 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "nrUUID"));
              sub_10013E9C0((uint64_t)NRDLocalDevice, v27, v28);
              goto LABEL_130;
            default:
              if (!(_DWORD)a2)
                goto LABEL_57;
              if ((_DWORD)a2 != 48701)
                goto LABEL_72;
              v255 = 0;
              if (objc_msgSend(v8, "length"))
              {
                objc_msgSend(v8, "getBytes:length:", &v255, 1);
                if (v255 < 0 && !*(_BYTE *)(a1 + 236))
                {
                  *(_BYTE *)(a1 + 236) = 1;
                  objc_initWeak(&location, (id)a1);
                  v47 = sub_10014A154((uint64_t)NRDKeyManager);
                  v253[0] = _NSConcreteStackBlock;
                  v253[1] = 3221225472;
                  v253[2] = sub_10007BA10;
                  v253[3] = &unk_1001B7F28;
                  objc_copyWeak(&v254, &location);
                  sub_10014ACE0((uint64_t)v47, v253);

                  objc_destroyWeak(&v254);
                  objc_destroyWeak(&location);
                }
              }
              goto LABEL_132;
          }
LABEL_131:

          goto LABEL_132;
        }
        v33 = (a2 - 50351);
        if (v33 <= 0x3E)
        {
          if (((1 << (a2 + 81)) & 0x701C000000000000) == 0)
          {
            if ((_DWORD)a2 == 50351)
            {
              objc_msgSend((id)a1, "reportEvent:details:", 3401, CFSTR("Identity"));
              v111 = *(void **)(a1 + 32);
              v250[0] = _NSConcreteStackBlock;
              v250[1] = 3221225472;
              v250[2] = sub_10007BDD8;
              v250[3] = &unk_1001B6B48;
              v250[4] = a1;
              sub_100139818((uint64_t)NRDLocalDevice, v8, v111, v250);
              goto LABEL_132;
            }
            if (v33 == 1)
            {
              v34 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v20);
              v35 = _NRLogIsLevelEnabled(v34, 0);

              if (v35)
              {
                v37 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v36);
                v38 = objc_msgSend((id)a1, "copyDescription");
                _NRLogWithArgs(v37, 0, "%s%.30s:%-4d %@: Received request for device identity", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7911, v38);

              }
              sub_10007C02C((_QWORD *)a1);
              goto LABEL_132;
            }
            goto LABEL_72;
          }
          goto LABEL_57;
        }
        goto LABEL_72;
      }
      if ((int)a2 <= 50800)
      {
        if ((a2 - 50501) >= 5)
        {
          if ((_DWORD)a2 == 50701)
          {
            sub_10013C5A0((uint64_t)NRDLocalDevice, v8, *(void **)(a1 + 32));
            objc_msgSend((id)a1, "checkProxyAgentWithForceUpdate:", 0);
            goto LABEL_132;
          }
          if ((_DWORD)a2 == 50702)
          {
            objc_msgSend(v21, "linkDidReceiveData:data:", a1, v8);
            goto LABEL_132;
          }
          goto LABEL_72;
        }
      }
      else
      {
        if ((int)a2 <= 51300)
        {
          switch((int)a2)
          {
            case 50801:
              if (*(_BYTE *)(a1 + 242))
              {
                v29 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v20);
                v30 = _NRLogIsLevelEnabled(v29, 16);

                if (!v30)
                  goto LABEL_132;
                v27 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v31);
                v28 = objc_msgSend((id)a1, "copyDescription");
                v247 = 7798;
                v249 = v28;
                v32 = "%s%.30s:%-4d %@: Did not expect InnerAddressInitiatorClassD as responder";
                goto LABEL_69;
              }
              location = 0;
              v252 = 0;
              if ((unint64_t)objc_msgSend(v8, "length") <= 0xF)
              {
                v138 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v137);
                v139 = _NRLogIsLevelEnabled(v138, 16);

                if (!v139)
                  goto LABEL_132;
                v27 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v140);
                v28 = objc_msgSend((id)a1, "copyDescription");
                _NRLogWithArgs(v27, 16, "%s%.30s:%-4d %@: InnerAddressInitiatorClassD payload too short %@", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7803, v28, v8);
                goto LABEL_130;
              }
              objc_msgSend(v8, "getBytes:length:", &location, 16);
              if (!sub_10013D69C((uint64_t)NRDLocalDevice, (uint64_t)&location, *(void **)(a1 + 32)))
              {
                v218 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v175);
                v219 = _NRLogIsLevelEnabled(v218, 0);

                if (v219)
                {
                  v221 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v220);
                  v222 = objc_msgSend((id)a1, "copyDescription");
                  v224 = (void *)createIPv6AddrString(&location, v223);
                  _NRLogWithArgs(v221, 0, "%s%.30s:%-4d %@: received local classD address %@", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7819, v222, v224);

                }
                goto LABEL_132;
              }
              v100 = sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(a1 + 32));
              if (v100)
              {
                v177 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v176);
                v178 = _NRLogIsLevelEnabled(v177, 0);

                if (v178)
                {
                  v180 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v179);
                  v181 = objc_msgSend((id)a1, "copyDescription");
                  IPv6AddrString = (void *)createIPv6AddrString(a1 + 1951, v182);
                  v185 = (void *)createIPv6AddrString(&location, v184);
                  _NRLogWithArgs(v180, 0, "%s%.30s:%-4d %@: updated local classD address from %@ to %@", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7811, v181, IPv6AddrString, v185);

                }
                sub_10013453C(v100, (_OWORD *)(a1 + 1951));
                sub_10007BA44(a1);
                v167 = (void *)sub_10013D578(v100);
                objc_msgSend(*(id *)(a1 + 1335), "setLocalAddresses:", v167);
                v187 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v186);
                v188 = _NRLogIsLevelEnabled(v187, 0);

                if (v188)
                {
                  v190 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v189);
                  v191 = objc_msgSend((id)a1, "copyDescription");
                  v192 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 1335), "interfaceName"));
                  _NRLogWithArgs(v190, 0, "%s%.30s:%-4d %@: updated interface \"%@\" with addresses %@ (classD)", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7817, v191, v192, v167);

                }
                goto LABEL_145;
              }
              v238 = sub_100070AC8();
              v239 = _NRLogIsLevelEnabled(v238, 16);

              if (v239)
              {
                v240 = sub_100070AC8();
                _NRLogWithArgs(v240, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7809);

              }
              goto LABEL_180;
            case 50802:
              if (*(_BYTE *)(a1 + 242))
              {
                v54 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v20);
                v55 = _NRLogIsLevelEnabled(v54, 16);

                if (!v55)
                  goto LABEL_132;
                v27 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v56);
                v28 = objc_msgSend((id)a1, "copyDescription");
                v247 = 7851;
                v249 = v28;
                v32 = "%s%.30s:%-4d %@: Did not expect InnerAddressResponderClassD as responder";
                goto LABEL_69;
              }
              location = 0;
              v252 = 0;
              if ((unint64_t)objc_msgSend(v8, "length") <= 0xF)
              {
                v130 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v129);
                v131 = _NRLogIsLevelEnabled(v130, 16);

                if (!v131)
                  goto LABEL_132;
                v27 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v132);
                v28 = objc_msgSend((id)a1, "copyDescription");
                _NRLogWithArgs(v27, 16, "%s%.30s:%-4d %@: InnerAddressResponderClassD payload too short %@", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7856, v28, v8);
                goto LABEL_130;
              }
              objc_msgSend(v8, "getBytes:length:", &location, 16);
              if (!sub_10013DEEC((uint64_t)NRDLocalDevice, (uint64_t)&location, *(void **)(a1 + 32)))
              {
                v204 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v145);
                v205 = _NRLogIsLevelEnabled(v204, 0);

                if (v205)
                {
                  v207 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v206);
                  v208 = objc_msgSend((id)a1, "copyDescription");
                  v210 = (void *)createIPv6AddrString(&location, v209);
                  _NRLogWithArgs(v207, 0, "%s%.30s:%-4d %@: received remote classD address %@", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7869, v208, v210);

                }
                goto LABEL_132;
              }
              v100 = sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(a1 + 32));
              if (v100)
              {
                v147 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v146);
                v148 = _NRLogIsLevelEnabled(v147, 0);

                if (v148)
                {
                  v150 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v149);
                  v151 = objc_msgSend((id)a1, "copyDescription");
                  v153 = (void *)createIPv6AddrString(a1 + 1967, v152);
                  v155 = (void *)createIPv6AddrString(&location, v154);
                  _NRLogWithArgs(v150, 0, "%s%.30s:%-4d %@: updated remote classD address from %@ to %@", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7864, v151, v153, v155);

                }
                sub_100133C94(v100, (_OWORD *)(a1 + 1967));
                sub_10007BA44(a1);
                sub_10007BBAC(a1);

                goto LABEL_132;
              }
              v232 = sub_100070AC8();
              v233 = _NRLogIsLevelEnabled(v232, 16);

              if (v233)
              {
                v234 = sub_100070AC8();
                _NRLogWithArgs(v234, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7862);

              }
              goto LABEL_180;
            case 50803:
            case 50804:
            case 50805:
            case 50806:
            case 50807:
            case 50808:
            case 50809:
            case 50810:
              goto LABEL_72;
            case 50811:
              if (*(_BYTE *)(a1 + 242))
              {
                v57 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v20);
                v58 = _NRLogIsLevelEnabled(v57, 16);

                if (!v58)
                  goto LABEL_132;
                v27 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v59);
                v28 = objc_msgSend((id)a1, "copyDescription");
                v247 = 7825;
                v249 = v28;
                v32 = "%s%.30s:%-4d %@: Did not expect InnerAddressInitiatorClassC as responder";
                goto LABEL_69;
              }
              location = 0;
              v252 = 0;
              if ((unint64_t)objc_msgSend(v8, "length") <= 0xF)
              {
                v134 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v133);
                v135 = _NRLogIsLevelEnabled(v134, 16);

                if (!v135)
                  goto LABEL_132;
                v27 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v136);
                v28 = objc_msgSend((id)a1, "copyDescription");
                _NRLogWithArgs(v27, 16, "%s%.30s:%-4d %@: InnerAddressInitiatorClassC payload too short %@", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7830, v28, v8);
                goto LABEL_130;
              }
              objc_msgSend(v8, "getBytes:length:", &location, 16);
              if (sub_10013DAC4((uint64_t)NRDLocalDevice, (uint64_t)&location, *(void **)(a1 + 32)))
              {
                v100 = sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(a1 + 32));
                if (!v100)
                {
                  v235 = sub_100070AC8();
                  v236 = _NRLogIsLevelEnabled(v235, 16);

                  if (v236)
                  {
                    v237 = sub_100070AC8();
                    _NRLogWithArgs(v237, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7836);

                  }
                  goto LABEL_180;
                }
                v158 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v157);
                v159 = _NRLogIsLevelEnabled(v158, 0);

                if (v159)
                {
                  v161 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v160);
                  v162 = objc_msgSend((id)a1, "copyDescription");
                  v164 = (void *)createIPv6AddrString(a1 + 1983, v163);
                  v166 = (void *)createIPv6AddrString(&location, v165);
                  _NRLogWithArgs(v161, 0, "%s%.30s:%-4d %@: updated local classC address from %@ to %@", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7838, v162, v164, v166);

                }
                sub_10013CC28(v100, (_OWORD *)(a1 + 1983));
                v167 = (void *)sub_10013D578(v100);
                objc_msgSend(*(id *)(a1 + 1335), "setLocalAddresses:", v167);
                v169 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v168);
                v170 = _NRLogIsLevelEnabled(v169, 0);

                if (v170)
                {
                  v172 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v171);
                  v173 = objc_msgSend((id)a1, "copyDescription");
                  v174 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 1335), "interfaceName"));
                  _NRLogWithArgs(v172, 0, "%s%.30s:%-4d %@: updated interface \"%@\" with addresses %@ (classC)", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7843, v173, v174, v167);

                }
LABEL_145:

              }
              else
              {
                v211 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v156);
                v212 = _NRLogIsLevelEnabled(v211, 0);

                if (v212)
                {
                  v214 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v213);
                  v215 = objc_msgSend((id)a1, "copyDescription");
                  v217 = (void *)createIPv6AddrString(&location, v216);
                  _NRLogWithArgs(v214, 0, "%s%.30s:%-4d %@: received local classC address %@", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7845, v215, v217);

                }
              }
              goto LABEL_132;
            case 50812:
              if (*(_BYTE *)(a1 + 242))
              {
                v60 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v20);
                v61 = _NRLogIsLevelEnabled(v60, 16);

                if (!v61)
                  goto LABEL_132;
                v27 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v62);
                v28 = objc_msgSend((id)a1, "copyDescription");
                v247 = 7875;
                v249 = v28;
                v32 = "%s%.30s:%-4d %@: Did not expect InnerAddressResponderClassC as responder";
LABEL_69:
                _NRLogWithArgs(v27, 16, v32, "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", v247, v249);
LABEL_130:

                goto LABEL_131;
              }
              location = 0;
              v252 = 0;
              if ((unint64_t)objc_msgSend(v8, "length") <= 0xF)
              {
                v142 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v141);
                v143 = _NRLogIsLevelEnabled(v142, 16);

                if (!v143)
                  goto LABEL_132;
                v27 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v144);
                v28 = objc_msgSend((id)a1, "copyDescription");
                _NRLogWithArgs(v27, 16, "%s%.30s:%-4d %@: InnerAddressResponderClassC payload too short %@", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7880, v28, v8);
                goto LABEL_130;
              }
              objc_msgSend(v8, "getBytes:length:", &location, 16);
              if (!sub_10013E314((uint64_t)NRDLocalDevice, (uint64_t)&location, *(void **)(a1 + 32)))
              {
                v225 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v193);
                v226 = _NRLogIsLevelEnabled(v225, 0);

                if (v226)
                {
                  v228 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v227);
                  v229 = objc_msgSend((id)a1, "copyDescription");
                  v231 = (void *)createIPv6AddrString(&location, v230);
                  _NRLogWithArgs(v228, 0, "%s%.30s:%-4d %@: received remote classC address %@", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7893, v229, v231);

                }
                goto LABEL_132;
              }
              v100 = sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(a1 + 32));
              if (v100)
              {
                v195 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v194);
                v196 = _NRLogIsLevelEnabled(v195, 0);

                if (v196)
                {
                  v198 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v197);
                  v199 = objc_msgSend((id)a1, "copyDescription");
                  v201 = (void *)createIPv6AddrString(a1 + 1999, v200);
                  v203 = (void *)createIPv6AddrString(&location, v202);
                  _NRLogWithArgs(v198, 0, "%s%.30s:%-4d %@: updated remote classC address from %@ to %@", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7888, v199, v201, v203);

                }
                sub_100133C94(v100, (_OWORD *)(a1 + 1999));
                sub_10007BBAC(a1);

                goto LABEL_132;
              }
              v241 = sub_100070AC8();
              v242 = _NRLogIsLevelEnabled(v241, 16);

              if (v242)
              {
                v243 = sub_100070AC8();
                _NRLogWithArgs(v243, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7886);

              }
LABEL_180:
              v21 = (void *)_os_log_pack_size(12);
              v8 = (char *)v250 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
              v244 = __error();
              v245 = _os_log_pack_fill(v8, v21, *v244, &_mh_execute_header, "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
              *(_DWORD *)v245 = 136446210;
              *(_QWORD *)(v245 + 4) = "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]";
              v246 = sub_100070AC8();
              _NRLogAbortWithPack(v246, v8);
              __break(1u);
LABEL_181:
              v101 = 0;
LABEL_89:
              v102 = (uint64_t)&v11[55];
              v103 = (char *)*(unsigned __int16 *)(a1 + v4[299]);
              v104 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "nrUUID"));
              sub_10013BBC0(v102, v103, v104);

              if (v100)
              {
                v105 = *((unsigned __int16 *)v100 + 14);
                if (v101 >= v105)
                  v106 = *((unsigned __int16 *)v100 + 14);
                else
                  v106 = v101;
                if (v101 <= v105)
                  v101 = *((unsigned __int16 *)v100 + 14);
                if (a4 != 4)
                  goto LABEL_168;
              }
              else
              {
                v106 = 0;
                if (a4 != 4)
                {
LABEL_168:

                  goto LABEL_132;
                }
              }
              if (v106 <= 0x10 && v101 >= 0x11)
              {
                v107 = v100 ? (void *)*((_QWORD *)v100 + 16) : 0;
                v108 = v107;
                v109 = objc_msgSend(v108, "proxyCapability") == (id)1;

                if (v109)
                  sub_10007B624(a1);
              }
              if (v100)
              {
                v110 = *((id *)v100 + 8);
                if (v110)
                {

                }
                else if (*((unsigned __int16 *)v100 + 14) >= 0x14u)
                {
                  sub_10007B810((_QWORD *)a1);
                }
              }
              goto LABEL_168;
            default:
              v48 = 50901;
              goto LABEL_56;
          }
        }
        if ((int)a2 > 51500)
        {
          if ((_DWORD)a2 == 51501)
          {
            v63 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v20);
            v64 = _NRLogIsLevelEnabled(v63, 16);

            if (v64)
            {
              v65 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v20);
              v66 = objc_msgSend((id)a1, "copyDescription");
              _NRLogWithArgs(v65, 16, "%s%.30s:%-4d %@: Did not expect IsAltAccountDevice", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7744, v66);

            }
            goto LABEL_72;
          }
          v48 = 51601;
LABEL_56:
          if ((_DWORD)a2 != v48)
          {
LABEL_72:
            v67 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v20);
            v68 = _NRLogIsLevelEnabled(v67, 1);

            if (!v68)
              goto LABEL_132;
            v52 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v69);
            v53 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v52, 1, "%s%.30s:%-4d %@: Received unknown notify code %u", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7945, v53, a2);
            goto LABEL_59;
          }
        }
        else if ((_DWORD)a2 != 51301)
        {
          if ((_DWORD)a2 == 51401)
          {
            LOBYTE(location) = 0;
            objc_msgSend(v8, "getBytes:length:", &location, 1);
            v40 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v39);
            v41 = _NRLogIsLevelEnabled(v40, 0);

            if (v41)
            {
              v43 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v42);
              v44 = objc_msgSend((id)a1, "copyDescription");
              _NRLogWithArgs(v43, 0, "%s%.30s:%-4d %@: Received Always On Wi-Fi supported: %u", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7739, v44, location);

            }
            v45 = location == 1;
            v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "nrUUID"));
            sub_10013C3C8((uint64_t)NRDLocalDevice, (char *)v45, v46);

            goto LABEL_132;
          }
          goto LABEL_72;
        }
      }
LABEL_57:
      v49 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v20);
      v50 = _NRLogIsLevelEnabled(v49, 1);

      if (v50)
      {
        v52 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v51);
        v53 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v52, 1, "%s%.30s:%-4d %@: Received unexpected notify code %u", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7941, v53, a2);
LABEL_59:

      }
LABEL_132:

      goto LABEL_133;
    }
    v17 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v13);
    v18 = _NRLogIsLevelEnabled(v17, 1);

    if (v18)
    {
      v15 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v19);
      v16 = objc_msgSend((id)a1, "copyDescription");
      _NRLogWithArgs(v15, 1, "%s%.30s:%-4d %@: Received seq per TC notify", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]", 7661, v16);
      goto LABEL_12;
    }
  }
LABEL_133:

}

void sub_10007B5F8(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 152));
  _Unwind_Resume(a1);
}

void sub_10007B624(uint64_t a1)
{
  char *v2;
  uint64_t v3;
  void *v4;
  int IsLevelEnabled;
  uint64_t v6;
  void *v7;
  id v8;
  void *v9;
  id v10;
  void *v11;
  void *v12;
  _QWORD v13[4];
  id v14;
  id location;
  id v16;

  v2 = sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(a1 + 32));
  if (sub_100112F4C(v2))
  {
    v4 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v3);
    IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0);

    if (IsLevelEnabled)
    {
      v7 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v6);
      v8 = objc_msgSend((id)a1, "copyDescription");
      _NRLogWithArgs(v7, 0, "%s%.30s:%-4d %@: Sending proxy config to peer", "", "-[NRLinkBluetooth sendProxyConfig]", 7543, v8);

    }
    objc_initWeak(&location, (id)a1);
    v9 = *(void **)(a1 + 1223);
    v10 = sub_100112FCC(v2, 0);
    v16 = v10;
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v16, 1));
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "queue"));
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 3221225472;
    v13[2] = sub_10007C470;
    v13[3] = &unk_1001B7978;
    objc_copyWeak(&v14, &location);
    objc_msgSend(v9, "sendPrivateNotifies:maxRetries:retryIntervalInMilliseconds:callbackQueue:callback:", v11, 10, 10000, v12, v13);

    objc_destroyWeak(&v14);
    objc_destroyWeak(&location);
  }

}

void sub_10007B7E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  id *v18;

  objc_destroyWeak(v18);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10007B810(_QWORD *a1)
{
  uint64_t v2;
  void *v3;
  int IsLevelEnabled;
  uint64_t v5;
  void *v6;
  id v7;
  id v8;
  void *v9;
  void *v10;
  void *v11;
  _QWORD v12[4];
  id v13;
  id location;
  id v15;

  if (_os_feature_enabled_impl("terminus", "EncryptedIdentity"))
  {
    v3 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v3, 0);

    if (IsLevelEnabled)
    {
      v6 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v5);
      v7 = objc_msgSend(a1, "copyDescription");
      _NRLogWithArgs(v6, 0, "%s%.30s:%-4d %@: Requesting device identity from peer", "", "-[NRLinkBluetooth sendDeviceIdentityRequest]", 7592, v7);

    }
    objc_initWeak(&location, a1);
    v8 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50352, 0);
    v9 = *(void **)((char *)a1 + 1223);
    v15 = v8;
    v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v15, 1));
    v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "queue"));
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472;
    v12[2] = sub_10007C360;
    v12[3] = &unk_1001B7978;
    objc_copyWeak(&v13, &location);
    objc_msgSend(v9, "sendPrivateNotifies:maxRetries:retryIntervalInMilliseconds:callbackQueue:callback:", v10, 10, 10000, v11, v12);

    objc_destroyWeak(&v13);
    objc_destroyWeak(&location);
  }
}

void sub_10007B9D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  id *v18;

  objc_destroyWeak(v18);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10007BA00(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(a1 + 343), a2);
}

void sub_10007BA10(uint64_t a1)
{
  id WeakRetained;
  id v2;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v2 = WeakRetained;
    sub_10007762C(WeakRetained, 3);
    WeakRetained = v2;
  }

}

void sub_10007BA44(uint64_t a1)
{
  id v2;
  id v3;
  id v4;
  void *v5;
  uint64_t v6;
  void *v7;
  id v8;
  void *v9;
  id v10;

  if (*(_BYTE *)(a1 + 246))
  {
    v10 = objc_alloc_init((Class)NSMutableDictionary);
    v2 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", a1 + 1951, 16);
    v3 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", a1 + 1967, 16);
    objc_msgSend(v10, "setObject:forKeyedSubscript:", v2, CFSTR("source-address-bytes"));
    objc_msgSend(v10, "setObject:forKeyedSubscript:", v3, CFSTR("destination-address-bytes"));
    objc_opt_self(NRLinkDirector);
    if (qword_1001E4710 != -1)
      dispatch_once(&qword_1001E4710, &stru_1001B6E60);
    v4 = (id)qword_1001E4708;
    v5 = v4;
    if (v4)
    {
      v6 = *(_QWORD *)(a1 + 32);
      v7 = (void *)*((_QWORD *)v4 + 25);
      v8 = v10;
      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", v6));
      sub_1000EF368((uint64_t)v9, v8);

    }
  }
}

void sub_10007BBAC(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  NSObject *v4;
  _QWORD *v5;
  void *v6;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  _QWORD *v10;
  void *v11;
  id v12;
  int IsLevelEnabled;
  id v14;
  uint64_t v15;
  char *v16;
  int *v17;
  uint64_t v18;
  id v19;
  char *v20;

  v20 = sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(a1 + 32));
  if (!v20)
  {
    v12 = sub_100070AC8();
    IsLevelEnabled = _NRLogIsLevelEnabled(v12, 16);

    if (IsLevelEnabled)
    {
      v14 = sub_100070AC8();
      _NRLogWithArgs(v14, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)", "", "-[NRLinkBluetooth addVirtualInterfaceRoutes]", 5800);

    }
    v15 = _os_log_pack_size(12);
    v16 = (char *)&v20 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
    v17 = __error();
    v18 = _os_log_pack_fill(v16, v15, *v17, &_mh_execute_header, "%{public}s Assertion Failed: (localDevice) != ((void *)0)", v20);
    *(_DWORD *)v18 = 136446210;
    *(_QWORD *)(v18 + 4) = "-[NRLinkBluetooth addVirtualInterfaceRoutes]";
    v19 = sub_100070AC8();
    _NRLogAbortWithPack(v19, v16);
  }
  NEVirtualInterfaceRemoveAllRoutes(*(_QWORD *)(a1 + 56), 1, 0);
  v2 = *(_QWORD *)(a1 + 56);
  v3 = sub_10014CFBC();
  dispatch_assert_queue_V2(v3);

  v4 = sub_10014CFBC();
  dispatch_assert_queue_V2(v4);

  v5 = sub_100133714(v20, CFSTR("0"));
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "hostname"));

  NEVirtualInterfaceAddIPv6Route(v2, v6, &off_1001C4720, 0, 0);
  v7 = *(_QWORD *)(a1 + 56);
  v8 = sub_10014CFBC();
  dispatch_assert_queue_V2(v8);

  v9 = sub_10014CFBC();
  dispatch_assert_queue_V2(v9);

  v10 = sub_100133AD8(v20, CFSTR("0"));
  v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "hostname"));

  NEVirtualInterfaceAddIPv6Route(v7, v11, &off_1001C4720, 0, 0);
  NEVirtualInterfaceUpdateAdHocService(*(_QWORD *)(a1 + 56));
  objc_msgSend((id)a1, "checkProxyAgentWithForceUpdate:", 1);

}

void sub_10007BDD8(uint64_t a1, void *a2)
{
  uint64_t v3;
  void *v4;
  int IsLevelEnabled;
  uint64_t v6;
  void *v7;
  id v8;
  void *v9;
  int v10;
  uint64_t v11;
  void *v12;
  id v13;
  id v14;
  void *v15;
  void *v16;
  id v17;
  void *v18;
  void *v19;
  int v20;
  uint64_t v21;
  void *v22;
  id v23;
  id v24;
  void *v25;
  void *v26;
  id v27;
  void *LogString;
  id *v29;

  v29 = a2;
  v4 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v3);
  IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0);

  if (IsLevelEnabled)
  {
    v7 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v6);
    v8 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    _NRLogWithArgs(v7, 0, "%s%.30s:%-4d %@: Plumbed device identity %@", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]_block_invoke", 7902, v8, v29);

  }
  v9 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v6);
  v10 = _NRLogIsLevelEnabled(v9, 0);

  if (v10)
  {
    v12 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v11);
    v13 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    if (v29)
    {
      v14 = v29[8];
      v15 = v14;
      if (v14)
        v16 = (void *)*((_QWORD *)v14 + 1);
      else
        v16 = 0;
    }
    else
    {
      v15 = 0;
      v16 = 0;
    }
    v17 = v16;
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "UUIDString"));
    _NRLogWithArgs(v12, 0, "%s%.30s:%-4d %@: deviceIdentityUUID=%@", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]_block_invoke", 7904, v13, v18);

  }
  v19 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v11);
  v20 = _NRLogIsLevelEnabled(v19, 0);

  if (v20)
  {
    v22 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v21);
    v23 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    if (v29)
    {
      v24 = v29[8];
      v25 = v24;
      if (v24)
        v26 = (void *)*((_QWORD *)v24 + 2);
      else
        v26 = 0;
    }
    else
    {
      v25 = 0;
      v26 = 0;
    }
    v27 = v26;
    LogString = (void *)_NRKeyCreateLogString(v27);
    _NRLogWithArgs(v22, 0, "%s%.30s:%-4d %@: deviceIdentityPublicKey=%@", "", "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]_block_invoke", 7906, v23, LogString);

  }
}

void sub_10007C02C(_QWORD *a1)
{
  void *v2;
  char *v3;
  uint64_t v4;
  void *v5;
  int IsLevelEnabled;
  uint64_t v7;
  void *v8;
  id v9;
  id v10;
  void *v11;
  void *v12;
  void *v13;
  _QWORD v14[4];
  id v15;
  id location;
  id v17;

  if (_os_feature_enabled_impl("terminus", "EncryptedIdentity"))
  {
    v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "nrUUID"));
    v3 = sub_100138520((uint64_t)NRDLocalDevice, v2);

    if (v3)
    {
      v5 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v4);
      IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0);

      if (IsLevelEnabled)
      {
        v8 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v7);
        v9 = objc_msgSend(a1, "copyDescription");
        _NRLogWithArgs(v8, 0, "%s%.30s:%-4d %@: Sending device identity to peer", "", "-[NRLinkBluetooth sendDeviceIdentity]", 7625, v9);

      }
      objc_initWeak(&location, a1);
      v10 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50351, v3);
      v11 = *(void **)((char *)a1 + 1223);
      v17 = v10;
      v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v17, 1));
      v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "queue"));
      v14[0] = _NSConcreteStackBlock;
      v14[1] = 3221225472;
      v14[2] = sub_10007C250;
      v14[3] = &unk_1001B7978;
      objc_copyWeak(&v15, &location);
      objc_msgSend(v11, "sendPrivateNotifies:maxRetries:retryIntervalInMilliseconds:callbackQueue:callback:", v12, 10, 10000, v13, v14);

      objc_destroyWeak(&v15);
      objc_destroyWeak(&location);
    }

  }
}

void sub_10007C224(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  id *v18;

  objc_destroyWeak(v18);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10007C250(uint64_t a1, int a2)
{
  _QWORD *WeakRetained;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  int IsLevelEnabled;
  uint64_t v8;
  void *v9;
  id v10;
  int v11;
  uint64_t v12;
  _QWORD *v13;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v13 = WeakRetained;
    v5 = _NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    v6 = (void *)v5;
    if (a2)
    {
      IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0);

      WeakRetained = v13;
      if (IsLevelEnabled)
      {
        v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v8);
        v10 = objc_msgSend(v13, "copyDescription");
        _NRLogWithArgs(v9, 0, "%s%.30s:%-4d %@: Received response to device identity message", "", "-[NRLinkBluetooth sendDeviceIdentity]_block_invoke", 7640, v10);
LABEL_7:

        WeakRetained = v13;
      }
    }
    else
    {
      v11 = _NRLogIsLevelEnabled(v5, 16);

      WeakRetained = v13;
      if (v11)
      {
        v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v12);
        v10 = objc_msgSend(v13, "copyDescription");
        _NRLogWithArgs(v9, 16, "%s%.30s:%-4d %@: Did not receive response to device identity message", "", "-[NRLinkBluetooth sendDeviceIdentity]_block_invoke", 7642, v10);
        goto LABEL_7;
      }
    }
  }

}

void sub_10007C360(uint64_t a1, int a2)
{
  _QWORD *WeakRetained;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  int IsLevelEnabled;
  uint64_t v8;
  void *v9;
  id v10;
  int v11;
  uint64_t v12;
  _QWORD *v13;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v13 = WeakRetained;
    v5 = _NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    v6 = (void *)v5;
    if (a2)
    {
      IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0);

      WeakRetained = v13;
      if (IsLevelEnabled)
      {
        v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v8);
        v10 = objc_msgSend(v13, "copyDescription");
        _NRLogWithArgs(v9, 0, "%s%.30s:%-4d %@: Received response to device identity request", "", "-[NRLinkBluetooth sendDeviceIdentityRequest]_block_invoke", 7608, v10);
LABEL_7:

        WeakRetained = v13;
      }
    }
    else
    {
      v11 = _NRLogIsLevelEnabled(v5, 16);

      WeakRetained = v13;
      if (v11)
      {
        v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v12);
        v10 = objc_msgSend(v13, "copyDescription");
        _NRLogWithArgs(v9, 16, "%s%.30s:%-4d %@: Did not receive response to device identity request", "", "-[NRLinkBluetooth sendDeviceIdentityRequest]_block_invoke", 7610, v10);
        goto LABEL_7;
      }
    }
  }

}

void sub_10007C470(uint64_t a1, int a2)
{
  _QWORD *WeakRetained;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  int IsLevelEnabled;
  uint64_t v8;
  void *v9;
  id v10;
  int v11;
  uint64_t v12;
  _QWORD *v13;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v13 = WeakRetained;
    v5 = _NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    v6 = (void *)v5;
    if (a2)
    {
      IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0);

      WeakRetained = v13;
      if (IsLevelEnabled)
      {
        v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v8);
        v10 = objc_msgSend(v13, "copyDescription");
        _NRLogWithArgs(v9, 0, "%s%.30s:%-4d %@: Received response to proxy notify payload", "", "-[NRLinkBluetooth sendProxyConfig]_block_invoke", 7555, v10);
LABEL_7:

        WeakRetained = v13;
      }
    }
    else
    {
      v11 = _NRLogIsLevelEnabled(v5, 16);

      WeakRetained = v13;
      if (v11)
      {
        v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v12);
        v10 = objc_msgSend(v13, "copyDescription");
        _NRLogWithArgs(v9, 16, "%s%.30s:%-4d %@: Did not receive response to proxy notify payload", "", "-[NRLinkBluetooth sendProxyConfig]_block_invoke", 7557, v10);
        goto LABEL_7;
      }
    }
  }

}

void sub_10007C580(_BYTE *a1)
{
  void *v2;
  char *v3;
  id v4;
  id v5;
  int IsLevelEnabled;
  id v7;
  char *v8;
  int *v9;
  uint64_t v10;
  id v11;
  _QWORD v13[4];
  id v14;
  id location;

  if (!a1[242])
  {
    a1[235] = 1;
    v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "nrUUID"));
    v3 = sub_10012FFF4((uint64_t)NRDLocalDevice, v2);

    if (v3)
    {
      if (v3[14] || *((unsigned __int16 *)v3 + 14) > 0x12u)
        goto LABEL_7;
      objc_initWeak(&location, a1);
      objc_opt_self(NRDKeyManager);
      if (qword_1001E4AD8 == -1)
      {
LABEL_6:
        v4 = (id)qword_1001E4AD0;
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 3221225472;
        v13[2] = sub_10007CF30;
        v13[3] = &unk_1001B7F28;
        objc_copyWeak(&v14, &location);
        sub_10014B110((uint64_t)v4, v13);

        objc_destroyWeak(&v14);
        objc_destroyWeak(&location);
LABEL_7:

        return;
      }
    }
    else
    {
      v5 = sub_100070AC8();
      IsLevelEnabled = _NRLogIsLevelEnabled(v5, 16);

      if (IsLevelEnabled)
      {
        v7 = sub_100070AC8();
        _NRLogWithArgs(v7, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)", "", "-[NRLinkBluetooth scheduleIKESessionClassADueToConnectFailure]", 8968);

      }
      v3 = (char *)_os_log_pack_size(12);
      v8 = (char *)&v13[-1] - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
      v9 = __error();
      v10 = _os_log_pack_fill(v8, v3, *v9, &_mh_execute_header, "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
      *(_DWORD *)v10 = 136446210;
      *(_QWORD *)(v10 + 4) = "-[NRLinkBluetooth scheduleIKESessionClassADueToConnectFailure]";
      v11 = sub_100070AC8();
      _NRLogAbortWithPack(v11, v8);
      __break(1u);
    }
    dispatch_once(&qword_1001E4AD8, &stru_1001B8968);
    goto LABEL_6;
  }
}

void sub_10007C7BC(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 48));
  _Unwind_Resume(a1);
}

void sub_10007C7E8(uint64_t a1)
{
  unsigned __int8 *WeakRetained;
  char *v2;
  void *v3;
  id v4;
  void *v5;
  void *v6;
  _QWORD v7[4];
  id v8;
  id location;
  id v10;

  WeakRetained = (unsigned __int8 *)objc_loadWeakRetained((id *)(a1 + 32));
  v2 = (char *)WeakRetained;
  if (WeakRetained && WeakRetained[16] != 255 && *(_QWORD *)(WeakRetained + 1223))
  {
    objc_initWeak(&location, WeakRetained);
    v3 = *(void **)(v2 + 1223);
    v4 = sub_100112E3C();
    v10 = v4;
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v10, 1));
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "queue"));
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    v7[2] = sub_10007CE20;
    v7[3] = &unk_1001B7978;
    objc_copyWeak(&v8, &location);
    objc_msgSend(v3, "sendPrivateNotifies:maxRetries:retryIntervalInMilliseconds:callbackQueue:callback:", v5, 10, 10000, v6, v7);

    objc_destroyWeak(&v8);
    objc_destroyWeak(&location);
  }

}

void sub_10007C938(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10007C964(uint64_t a1, void *a2)
{
  id v3;
  id *v4;
  char *WeakRetained;
  char *v6;
  uint64_t v7;
  void *v8;
  id v9;
  uint64_t v10;
  void *v11;
  int IsLevelEnabled;
  uint64_t v13;
  void *v14;
  id v15;
  id v16;
  void *v17;
  void *v18;
  void *v19;
  int v20;
  uint64_t v21;
  void *v22;
  id v23;
  _QWORD v24[4];
  id v25;
  id v26;

  v3 = a2;
  v4 = (id *)(a1 + 40);
  WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 40));
  v6 = WeakRetained;
  if (WeakRetained && objc_msgSend(WeakRetained, "state") != 255)
  {
    if (v3)
    {
      v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "dataUsingEncoding:", 4));
      v9 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 48607, v8);
      v11 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v10);
      IsLevelEnabled = _NRLogIsLevelEnabled(v11, 0);

      if (IsLevelEnabled)
      {
        v14 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v13);
        v15 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
        _NRLogWithArgs(v14, 0, "%s%.30s:%-4d %@: Sending IDS device ID to peer", "", "-[NRLinkBluetooth sendIDSDeviceID]_block_invoke", 7518, v15);

      }
      v16 = *(id *)(v6 + 1223);
      v26 = v9;
      v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v26, 1));
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "queue"));
      v24[0] = _NSConcreteStackBlock;
      v24[1] = 3221225472;
      v24[2] = sub_10007CC00;
      v24[3] = &unk_1001B7978;
      objc_copyWeak(&v25, v4);
      objc_msgSend(v16, "sendPrivateNotifies:maxRetries:retryIntervalInMilliseconds:callbackQueue:callback:", v17, 10, 10000, v18, v24);

      objc_destroyWeak(&v25);
    }
    else
    {
      v19 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v6 + 4), v7);
      v20 = _NRLogIsLevelEnabled(v19, 16);

      if (v20)
      {
        v22 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v6 + 4), v21);
        v23 = objc_msgSend(v6, "copyDescription");
        _NRLogWithArgs(v22, 16, "%s%.30s:%-4d %@: No IDS Device ID to send to peer", "", "-[NRLinkBluetooth sendIDSDeviceID]_block_invoke", 7511, v23);

      }
    }
  }

}

void sub_10007CBE4(_Unwind_Exception *a1)
{
  id *v1;

  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_10007CC00(uint64_t a1, int a2)
{
  _QWORD *WeakRetained;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  int IsLevelEnabled;
  uint64_t v8;
  void *v9;
  id v10;
  int v11;
  uint64_t v12;
  _QWORD *v13;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v13 = WeakRetained;
    v5 = _NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    v6 = (void *)v5;
    if (a2)
    {
      IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0);

      WeakRetained = v13;
      if (IsLevelEnabled)
      {
        v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v8);
        v10 = objc_msgSend(v13, "copyDescription");
        _NRLogWithArgs(v9, 0, "%s%.30s:%-4d %@: Received response to IDS device ID notify payload", "", "-[NRLinkBluetooth sendIDSDeviceID]_block_invoke_2", 7529, v10);
LABEL_7:

        WeakRetained = v13;
      }
    }
    else
    {
      v11 = _NRLogIsLevelEnabled(v5, 16);

      WeakRetained = v13;
      if (v11)
      {
        v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v12);
        v10 = objc_msgSend(v13, "copyDescription");
        _NRLogWithArgs(v9, 16, "%s%.30s:%-4d %@: Did not receive response to IDS device ID notify payload", "", "-[NRLinkBluetooth sendIDSDeviceID]_block_invoke_2", 7531, v10);
        goto LABEL_7;
      }
    }
  }

}

void sub_10007CD10(uint64_t a1, int a2)
{
  _QWORD *WeakRetained;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  int IsLevelEnabled;
  uint64_t v8;
  void *v9;
  id v10;
  int v11;
  uint64_t v12;
  _QWORD *v13;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v13 = WeakRetained;
    v5 = _NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    v6 = (void *)v5;
    if (a2)
    {
      IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0);

      WeakRetained = v13;
      if (IsLevelEnabled)
      {
        v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v8);
        v10 = objc_msgSend(v13, "copyDescription");
        _NRLogWithArgs(v9, 0, "%s%.30s:%-4d %@: Received response to notify payloads", "", "-[NRLinkBluetooth sendNotifyPayload]_block_invoke", 7580, v10);
LABEL_7:

        WeakRetained = v13;
      }
    }
    else
    {
      v11 = _NRLogIsLevelEnabled(v5, 16);

      WeakRetained = v13;
      if (v11)
      {
        v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v12);
        v10 = objc_msgSend(v13, "copyDescription");
        _NRLogWithArgs(v9, 16, "%s%.30s:%-4d %@: Did not receive response to notify payloads", "", "-[NRLinkBluetooth sendNotifyPayload]_block_invoke", 7582, v10);
        goto LABEL_7;
      }
    }
  }

}

void sub_10007CE20(uint64_t a1, int a2)
{
  _QWORD *WeakRetained;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  int IsLevelEnabled;
  uint64_t v8;
  void *v9;
  id v10;
  int v11;
  uint64_t v12;
  _QWORD *v13;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v13 = WeakRetained;
    v5 = _NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    v6 = (void *)v5;
    if (a2)
    {
      IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0);

      WeakRetained = v13;
      if (IsLevelEnabled)
      {
        v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v8);
        v10 = objc_msgSend(v13, "copyDescription");
        _NRLogWithArgs(v9, 0, "%s%.30s:%-4d %@: Received response to classC unlock", "", "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke_3", 8094, v10);
LABEL_7:

        WeakRetained = v13;
      }
    }
    else
    {
      v11 = _NRLogIsLevelEnabled(v5, 16);

      WeakRetained = v13;
      if (v11)
      {
        v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v12);
        v10 = objc_msgSend(v13, "copyDescription");
        _NRLogWithArgs(v9, 16, "%s%.30s:%-4d %@: Did not receive response to classC unlock", "", "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke_3", 8096, v10);
        goto LABEL_7;
      }
    }
  }

}

void sub_10007CF30(uint64_t a1)
{
  _BYTE *WeakRetained;
  BOOL v2;
  void *v3;
  char *v4;
  id v5;
  int IsLevelEnabled;
  id v7;
  uint64_t v8;
  char *v9;
  int *v10;
  uint64_t v11;
  id v12;
  _BYTE *v13;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v13 = WeakRetained;
    v2 = objc_msgSend(WeakRetained, "state") == 255;
    WeakRetained = v13;
    if (!v2)
    {
      v13[235] = 0;
      v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "nrUUID"));
      v4 = sub_10012FFF4((uint64_t)NRDLocalDevice, v3);

      if (!v4)
      {
        v5 = sub_100070AC8();
        IsLevelEnabled = _NRLogIsLevelEnabled(v5, 16);

        if (IsLevelEnabled)
        {
          v7 = sub_100070AC8();
          _NRLogWithArgs(v7, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice2) != ((void *)0)", "", "-[NRLinkBluetooth scheduleIKESessionClassADueToConnectFailure]_block_invoke", 8979);

        }
        v8 = _os_log_pack_size(12);
        v9 = (char *)&v13 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
        v10 = __error();
        v11 = _os_log_pack_fill(v9, v8, *v10, &_mh_execute_header, "%{public}s Assertion Failed: (localDevice2) != ((void *)0)");
        *(_DWORD *)v11 = 136446210;
        *(_QWORD *)(v11 + 4) = "-[NRLinkBluetooth scheduleIKESessionClassADueToConnectFailure]_block_invoke";
        v12 = sub_100070AC8();
        _NRLogAbortWithPack(v12, v9);
      }
      if (!v4[14] && *((unsigned __int16 *)v4 + 14) <= 0x12u)
        sub_100077224((uint64_t)v13, 1, 0, 0);

      WeakRetained = v13;
    }
  }

}

void sub_10007D0C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  int IsLevelEnabled;
  uint64_t v12;
  void *v13;
  id v14;
  id v15;
  int v16;
  id v17;
  id v18;

  v18 = a5;
  if (objc_msgSend(*(id *)(a1 + 32), "state") == 255)
  {
    v10 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v7);
    IsLevelEnabled = _NRLogIsLevelEnabled(v10, 0);

    if (IsLevelEnabled)
    {
      v13 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v12);
      v14 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
      _NRLogWithArgs(v13, 0, "%s%.30s:%-4d %@: Ignoring result as link is cancelled", "", "-[NRLinkBluetooth sendlocalPublicClassCKeysEncryptedWithIDS]_block_invoke", 8291, v14);

    }
  }
  else if (v18)
  {
    v8 = *(_QWORD *)(a1 + 32);
    if (v8)
    {
      objc_storeStrong((id *)(v8 + 1295), a5);
      v9 = *(_QWORD *)(a1 + 32);
    }
    else
    {
      v9 = 0;
    }
    sub_100076AF8(v9);
  }
  else
  {
    v15 = sub_100070AC8();
    v16 = _NRLogIsLevelEnabled(v15, 17);

    if (v16)
    {
      v17 = sub_100070AC8();
      _NRLogWithArgs(v17, 17, "%s called with null localPublicClassCKeysEncryptedWithIDS", "-[NRLinkBluetooth sendlocalPublicClassCKeysEncryptedWithIDS]_block_invoke");

    }
  }

}

void sub_10007D20C(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v4;
  void *v5;
  int IsLevelEnabled;
  uint64_t v7;
  void *v8;
  id v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  id v13;
  id v14;

  v2 = a2;
  v4 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), a2);
  v5 = (void *)v4;
  if (v2)
  {
    IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0);

    if (IsLevelEnabled)
    {
      v8 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v7);
      v9 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
      _NRLogWithArgs(v8, 0, "%s%.30s:%-4d %@: localPublicClassCKeysEncryptedWithIDS was received", "", "-[NRLinkBluetooth sendlocalPublicClassCKeysEncryptedWithIDS]_block_invoke_2", 8314, v9);

    }
    v10 = *(_QWORD *)(a1 + 32);
    if (v10)
      sub_100077224(v10, 3, 0, 0);
  }
  else
  {
    v11 = _NRLogIsLevelEnabled(v4, 16);

    if (v11)
    {
      v14 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v12);
      v13 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
      _NRLogWithArgs(v14, 16, "%s%.30s:%-4d %@: localPublicClassCKeysEncryptedWithIDS was not received", "", "-[NRLinkBluetooth sendlocalPublicClassCKeysEncryptedWithIDS]_block_invoke_2", 8317, v13);

    }
  }
}

void sub_10007D35C(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;
  char *WeakRetained;
  id v7;
  uint64_t v8;
  void *SessionStateString;
  id v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  id v18;
  void *v19;
  char *v20;
  id v21;
  void *v22;
  void *v23;
  uint64_t v24;
  char *v25;
  id v26;
  uint64_t v27;
  uint64_t v28;
  id v29;
  id v30;
  id v31;
  void *v32;
  char *v33;
  id v34;
  char *v35;
  void *v36;
  uint64_t v37;
  _QWORD v38[4];
  char *v39;
  _QWORD v40[4];
  char *v41;
  id v42;

  v5 = a3;
  WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    if (v5)
    {
      v7 = objc_alloc((Class)NSString);
      v8 = *(_QWORD *)(a1 + 32);
      SessionStateString = (void *)NEIKEv2CreateSessionStateString(a2);
      v10 = objc_msgSend(v7, "initWithFormat:", CFSTR("pairing session %@ got IKE error %@ with state %@"), v8, v5, SessionStateString);

LABEL_4:
      v11 = mach_absolute_time();
      v12 = *(_QWORD *)(WeakRetained + 1863);
      if (v12)
        *(_QWORD *)(v12 + 120) = v11;
      if (WeakRetained[234])
      {
        objc_msgSend(WeakRetained, "reportEvent:details:", 3009, v10);
      }
      else
      {
        sub_100136BA4((uint64_t)NRDLocalDevice, -2013, v10, *((void **)WeakRetained + 4));
        objc_msgSend(WeakRetained, "cancelWithReason:", CFSTR("%@"), v10);
      }
LABEL_32:

      goto LABEL_33;
    }
    v13 = *(_QWORD *)(a1 + 32);
    v14 = (void *)NEIKEv2CreateSessionStateString(a2);
    objc_msgSend(WeakRetained, "reportEvent:detailsFormat:", 3009, CFSTR("pairing session %@ changed state to %@"), v13, v14);

    if (a2 == 3)
    {
      v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("pairing session IKE %@ disconnected"), *(_QWORD *)(a1 + 32));
      goto LABEL_4;
    }
    if (a2 == 2)
    {
      v15 = mach_absolute_time();
      v16 = *(_QWORD *)(WeakRetained + 1863);
      if (v16)
        *(_QWORD *)(v16 + 120) = v15;
      WeakRetained[234] = 1;
      if (!WeakRetained[242])
      {
        if (*(_QWORD *)(WeakRetained + 1287))
        {
          v17 = sub_10007630C(WeakRetained, 0);
          objc_msgSend(WeakRetained, "reportEvent:details:", 3402, CFSTR("ClassD"));
          v18 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50401, *(_QWORD *)(WeakRetained + 1287));
          objc_msgSend(v17, "addObject:", v18);
          if (_os_feature_enabled_impl("terminus", "EncryptedIdentity"))
          {
            v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "nrUUID"));
            v20 = sub_100138520((uint64_t)NRDLocalDevice, v19);

            if (v20)
            {
              objc_msgSend(WeakRetained, "reportEvent:details:", 3400, CFSTR("Identity"));
              v21 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50351, v20);
              objc_msgSend(v17, "addObject:", v21);

            }
          }
          sub_10007F894((uint64_t)WeakRetained);
          v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(WeakRetained + 1247), "description"));
          v23 = *(void **)(WeakRetained + 1247);
          v24 = *((_QWORD *)WeakRetained + 1);
          v40[0] = _NSConcreteStackBlock;
          v40[1] = 3221225472;
          v40[2] = sub_10007F8A8;
          v40[3] = &unk_1001B6BE8;
          v25 = WeakRetained;
          v41 = v25;
          v42 = v22;
          v26 = v22;
          objc_msgSend(v23, "sendPrivateNotifies:maxRetries:retryIntervalInMilliseconds:callbackQueue:callback:", v17, 10, 10000, v24, v40);
          sub_100076AF8((uint64_t)v25, v27);
          sub_100076CE8((uint64_t)v25, v28);

        }
        v10 = objc_alloc_init((Class)NSMutableArray);
        if (*(_QWORD *)(WeakRetained + 1263))
        {
          objc_msgSend(WeakRetained, "reportEvent:details:", 3400, CFSTR("ClassD"));
          v29 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50411, *(_QWORD *)(WeakRetained + 1263));
          objc_msgSend(v10, "addObject:", v29);
          sub_10007F994((uint64_t)WeakRetained);

        }
        if (*(_QWORD *)(WeakRetained + 1271))
        {
          objc_msgSend(WeakRetained, "reportEvent:details:", 3400, CFSTR("ClassC"));
          v30 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50412, *(_QWORD *)(WeakRetained + 1271));
          objc_msgSend(v10, "addObject:", v30);
          sub_10007F9A8((uint64_t)WeakRetained);

        }
        if (*(_QWORD *)(WeakRetained + 1279))
        {
          objc_msgSend(WeakRetained, "reportEvent:details:", 3400, CFSTR("ClassA"));
          v31 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50413, *(_QWORD *)(WeakRetained + 1279));
          objc_msgSend(v10, "addObject:", v31);
          sub_10007F9BC((uint64_t)WeakRetained);

        }
        if (objc_msgSend(v10, "count"))
        {
          if (_os_feature_enabled_impl("terminus", "EncryptedIdentity"))
          {
            v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "nrUUID"));
            v33 = sub_100138520((uint64_t)NRDLocalDevice, v32);

            if (v33)
            {
              objc_msgSend(WeakRetained, "reportEvent:details:", 3400, CFSTR("Identity"));
              v34 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 50351, v33);
              objc_msgSend(v10, "addObject:", v34);

            }
          }
          v35 = sub_10007630C(WeakRetained, 0);
          objc_msgSend(v10, "addObjectsFromArray:", v35);

          v36 = *(void **)(WeakRetained + 1247);
          v37 = *((_QWORD *)WeakRetained + 1);
          v38[0] = _NSConcreteStackBlock;
          v38[1] = 3221225472;
          v38[2] = sub_10007F9D0;
          v38[3] = &unk_1001B6E88;
          v39 = WeakRetained;
          objc_msgSend(v36, "sendPrivateNotifies:maxRetries:retryIntervalInMilliseconds:callbackQueue:callback:", v10, 10, 10000, v37, v38);

        }
        goto LABEL_32;
      }
    }
  }
LABEL_33:

}

void sub_10007D8FC(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  _QWORD *WeakRetained;
  uint64_t v8;
  _QWORD *v9;
  void *v10;
  int IsLevelEnabled;
  uint64_t v12;
  void *v13;
  id v14;
  uint64_t v15;
  void *SessionStateString;
  uint64_t v17;
  id v18;

  v18 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v9 = WeakRetained;
  if (WeakRetained)
  {
    v10 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v8);
    IsLevelEnabled = _NRLogIsLevelEnabled(v10, 0);

    if (v18)
    {
      if (IsLevelEnabled)
      {
        v13 = (void *)_NRCopyLogObjectForNRUUID(v9[4], v12);
        v14 = objc_msgSend(v9, "copyDescription");
        v15 = *(_QWORD *)(a1 + 32);
        SessionStateString = (void *)NEIKEv2CreateSessionStateString(a3);
        _NRLogWithArgs(v13, 0, "%s%.30s:%-4d %@: pairing session %@ got child %u state update %@ error %@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_4", 8540, v14, v15, a2, SessionStateString, v18);
LABEL_7:

      }
    }
    else if (IsLevelEnabled)
    {
      v13 = (void *)_NRCopyLogObjectForNRUUID(v9[4], v12);
      v14 = objc_msgSend(v9, "copyDescription");
      v17 = *(_QWORD *)(a1 + 32);
      SessionStateString = (void *)NEIKEv2CreateSessionStateString(a3);
      _NRLogWithArgs(v13, 0, "%s%.30s:%-4d %@: pairing session %@ got child %u state update %@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_4", 8543, v14, v17, a2, SessionStateString);
      goto LABEL_7;
    }
  }

}

void sub_10007DA4C(uint64_t a1, void *a2)
{
  _QWORD *WeakRetained;
  uint64_t v4;
  _QWORD *v5;
  void *v6;
  int IsLevelEnabled;
  uint64_t v8;
  void *v9;
  id v10;
  id v11;

  v11 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v5 = WeakRetained;
  if (WeakRetained)
  {
    v6 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0);

    if (IsLevelEnabled)
    {
      v9 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v8);
      v10 = objc_msgSend(v5, "copyDescription");
      _NRLogWithArgs(v9, 0, "%s%.30s:%-4d %@: pairing session %@ got config update %@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_5", 8553, v10, *(_QWORD *)(a1 + 32), v11);

    }
  }

}

void sub_10007DB14(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v7;
  _QWORD *WeakRetained;
  uint64_t v9;
  _QWORD *v10;
  void *v11;
  int IsLevelEnabled;
  uint64_t v13;
  void *v14;
  id v15;
  id v16;

  v16 = a3;
  v7 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v10 = WeakRetained;
  if (WeakRetained)
  {
    v11 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v9);
    IsLevelEnabled = _NRLogIsLevelEnabled(v11, 0);

    if (IsLevelEnabled)
    {
      v14 = (void *)_NRCopyLogObjectForNRUUID(v10[4], v13);
      v15 = objc_msgSend(v10, "copyDescription");
      _NRLogWithArgs(v14, 0, "%s%.30s:%-4d %@: pairing session %@ got child %u traffic selector update local %@ remote %@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_6", 8564, v15, *(_QWORD *)(a1 + 32), a2, v16, v7);

    }
  }

}

void sub_10007DC00(uint64_t a1, void *a2)
{
  _QWORD *WeakRetained;
  uint64_t v4;
  _QWORD *v5;
  void *v6;
  int IsLevelEnabled;
  uint64_t v8;
  void *v9;
  id v10;
  id v11;

  v11 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v5 = WeakRetained;
  if (WeakRetained)
  {
    v6 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0);

    if (IsLevelEnabled)
    {
      v9 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v8);
      v10 = objc_msgSend(v5, "copyDescription");
      _NRLogWithArgs(v9, 0, "%s%.30s:%-4d %@: pairing session %@ got additional addresses %@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_7", 8573, v10, *(_QWORD *)(a1 + 32), v11);

    }
  }

}

void sub_10007DCC8(uint64_t a1)
{
  _QWORD *WeakRetained;
  uint64_t v3;
  void *v4;
  int IsLevelEnabled;
  uint64_t v6;
  void *v7;
  id v8;
  _QWORD *v9;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    v9 = WeakRetained;
    v4 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v3);
    IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0);

    WeakRetained = v9;
    if (IsLevelEnabled)
    {
      v7 = (void *)_NRCopyLogObjectForNRUUID(v9[4], v6);
      v8 = objc_msgSend(v9, "copyDescription");
      _NRLogWithArgs(v7, 0, "%s%.30s:%-4d %@: pairing session %@ got short DPD", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_8", 8581, v8, *(_QWORD *)(a1 + 32));

      WeakRetained = v9;
    }
  }

}

void sub_10007DD88(uint64_t a1, void *a2)
{
  id v3;
  _QWORD *WeakRetained;
  void *v5;
  void *v6;
  uint64_t v7;
  void *v8;
  int IsLevelEnabled;
  uint64_t v10;
  void *v11;
  id v12;
  id v13;
  id v14;
  id v15;
  uint64_t v16;
  void *i;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  id v34;
  id v35;
  id v36;
  _QWORD v37[4];
  _QWORD *v38;
  _QWORD v39[4];
  _QWORD *v40;
  _QWORD v41[4];
  _QWORD *v42;
  _QWORD v43[4];
  _QWORD *v44;
  _QWORD v45[4];
  _QWORD *v46;
  _QWORD v47[4];
  _QWORD *v48;
  _QWORD v49[4];
  _QWORD *v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  _BYTE v55[128];
  id v56;

  v3 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    v35 = objc_msgSend(objc_alloc((Class)NSSortDescriptor), "initWithKey:ascending:", CFSTR("notifyStatus"), 1);
    v56 = v35;
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v56, 1));
    v36 = v3;
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "sortedArrayUsingDescriptors:", v5));

    v8 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v7);
    IsLevelEnabled = _NRLogIsLevelEnabled(v8, 0);

    if (IsLevelEnabled)
    {
      v11 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v10);
      v12 = objc_msgSend(WeakRetained, "copyDescription");
      _NRLogWithArgs(v11, 0, "%s%.30s:%-4d %@: pairing session %@ got private notifies %@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_9", 8593, v12, *(_QWORD *)(a1 + 32), v6);

    }
    v53 = 0u;
    v54 = 0u;
    v51 = 0u;
    v52 = 0u;
    v13 = v6;
    v14 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v51, v55, 16);
    if (v14)
    {
      v15 = v14;
      v16 = *(_QWORD *)v52;
      do
      {
        for (i = 0; i != v15; i = (char *)i + 1)
        {
          if (*(_QWORD *)v52 != v16)
            objc_enumerationMutation(v13);
          v21 = *(void **)(*((_QWORD *)&v51 + 1) + 8 * (_QWORD)i);
          if (objc_msgSend(v21, "notifyStatus") == 50351)
          {
            objc_msgSend(WeakRetained, "reportEvent:details:", 3401, CFSTR("Identity"));
            v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "notifyData"));
            v19 = (void *)WeakRetained[4];
            v49[0] = _NSConcreteStackBlock;
            v49[1] = 3221225472;
            v49[2] = sub_10007E360;
            v49[3] = &unk_1001B6B48;
            v50 = WeakRetained;
            sub_100139818((uint64_t)NRDLocalDevice, v18, v19, v49);

            v20 = v50;
          }
          else if (objc_msgSend(v21, "notifyStatus") == 50411)
          {
            objc_msgSend(WeakRetained, "reportEvent:details:", 3401, CFSTR("ClassD"));
            v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "notifyData"));
            v23 = (void *)WeakRetained[4];
            v47[0] = _NSConcreteStackBlock;
            v47[1] = 3221225472;
            v47[2] = sub_10007E5B4;
            v47[3] = &unk_1001B6B48;
            v48 = WeakRetained;
            sub_100139B60((uint64_t)NRDLocalDevice, v22, v23, v47);

            v20 = v48;
          }
          else if (objc_msgSend(v21, "notifyStatus") == 50412)
          {
            objc_msgSend(WeakRetained, "reportEvent:details:", 3401, CFSTR("ClassC"));
            v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "notifyData"));
            v25 = (void *)WeakRetained[4];
            v45[0] = _NSConcreteStackBlock;
            v45[1] = 3221225472;
            v45[2] = sub_10007E8D8;
            v45[3] = &unk_1001B6B48;
            v46 = WeakRetained;
            sub_100139EF8((uint64_t)NRDLocalDevice, v24, v25, v45);

            v20 = v46;
          }
          else if (objc_msgSend(v21, "notifyStatus") == 50413)
          {
            objc_msgSend(WeakRetained, "reportEvent:details:", 3401, CFSTR("ClassA"));
            v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "notifyData"));
            v27 = (void *)WeakRetained[4];
            v43[0] = _NSConcreteStackBlock;
            v43[1] = 3221225472;
            v43[2] = sub_10007EBF8;
            v43[3] = &unk_1001B6B48;
            v44 = WeakRetained;
            sub_10013A37C((uint64_t)NRDLocalDevice, v26, v27, v43);

            v20 = v44;
          }
          else if (objc_msgSend(v21, "notifyStatus") == 50401)
          {
            objc_msgSend(WeakRetained, "reportEvent:details:", 3403, CFSTR("ClassD"));
            v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "notifyData"));
            v29 = (void *)WeakRetained[4];
            v41[0] = _NSConcreteStackBlock;
            v41[1] = 3221225472;
            v41[2] = sub_10007EF18;
            v41[3] = &unk_1001B6B48;
            v42 = WeakRetained;
            sub_10013A800((uint64_t)NRDLocalDevice, v28, v29, v41);

            v20 = v42;
          }
          else if (objc_msgSend(v21, "notifyStatus") == 50402)
          {
            objc_msgSend(WeakRetained, "reportEvent:details:", 3403, CFSTR("ClassC"));
            v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "notifyData"));
            v31 = (void *)WeakRetained[4];
            v39[0] = _NSConcreteStackBlock;
            v39[1] = 3221225472;
            v39[2] = sub_10007F23C;
            v39[3] = &unk_1001B6B48;
            v40 = WeakRetained;
            sub_10013AC9C((uint64_t)NRDLocalDevice, v30, v31, v39);

            v20 = v40;
          }
          else if (objc_msgSend(v21, "notifyStatus") == 50403)
          {
            objc_msgSend(WeakRetained, "reportEvent:details:", 3403, CFSTR("ClassA"));
            v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "notifyData"));
            v33 = (void *)WeakRetained[4];
            v37[0] = _NSConcreteStackBlock;
            v37[1] = 3221225472;
            v37[2] = sub_10007F560;
            v37[3] = &unk_1001B6B48;
            v38 = WeakRetained;
            sub_10013B2E4((uint64_t)NRDLocalDevice, v32, v33, v37);

            v20 = v38;
          }
          else
          {
            v34 = objc_msgSend(v21, "notifyStatus");
            v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "notifyData"));
            sub_100079814((uint64_t)WeakRetained, (uint64_t)v34, v20, 0);
          }

        }
        v15 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v51, v55, 16);
      }
      while (v15);
    }

    v3 = v36;
  }

}

void sub_10007E360(uint64_t a1, void *a2)
{
  uint64_t v3;
  void *v4;
  int IsLevelEnabled;
  uint64_t v6;
  void *v7;
  id v8;
  void *v9;
  int v10;
  uint64_t v11;
  void *v12;
  id v13;
  id v14;
  void *v15;
  void *v16;
  id v17;
  void *v18;
  void *v19;
  int v20;
  uint64_t v21;
  void *v22;
  id v23;
  id v24;
  void *v25;
  void *v26;
  id v27;
  void *LogString;
  id *v29;

  v29 = a2;
  v4 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v3);
  IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0);

  if (IsLevelEnabled)
  {
    v7 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v6);
    v8 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    _NRLogWithArgs(v7, 0, "%s%.30s:%-4d %@: Plumbed device identity %@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_10", 8600, v8, v29);

  }
  v9 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v6);
  v10 = _NRLogIsLevelEnabled(v9, 0);

  if (v10)
  {
    v12 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v11);
    v13 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    if (v29)
    {
      v14 = v29[8];
      v15 = v14;
      if (v14)
        v16 = (void *)*((_QWORD *)v14 + 1);
      else
        v16 = 0;
    }
    else
    {
      v15 = 0;
      v16 = 0;
    }
    v17 = v16;
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "UUIDString"));
    _NRLogWithArgs(v12, 0, "%s%.30s:%-4d %@: deviceIdentityUUID=%@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_10", 8602, v13, v18);

  }
  v19 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v11);
  v20 = _NRLogIsLevelEnabled(v19, 0);

  if (v20)
  {
    v22 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v21);
    v23 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    if (v29)
    {
      v24 = v29[8];
      v25 = v24;
      if (v24)
        v26 = (void *)*((_QWORD *)v24 + 2);
      else
        v26 = 0;
    }
    else
    {
      v25 = 0;
      v26 = 0;
    }
    v27 = v26;
    LogString = (void *)_NRKeyCreateLogString(v27);
    _NRLogWithArgs(v22, 0, "%s%.30s:%-4d %@: deviceIdentityPublicKey=%@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_10", 8604, v23, LogString);

  }
}

void sub_10007E5B4(uint64_t a1, void *a2)
{
  uint64_t v3;
  void *v4;
  int IsLevelEnabled;
  uint64_t v6;
  void *v7;
  id v8;
  void *v9;
  id v10;
  uint64_t v11;
  void *v12;
  int v13;
  uint64_t v14;
  void *v15;
  id v16;
  void *v17;
  _QWORD *v18;
  _QWORD *v19;
  void *LogString;
  void *v21;
  int v22;
  uint64_t v23;
  void *v24;
  id v25;
  void *v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  void *v30;
  int v31;
  uint64_t v32;
  void *v33;
  id v34;
  id v35;
  void *v36;
  void *v37;
  id v38;
  void *v39;
  uint64_t v40;
  _QWORD *v41;

  v41 = a2;
  v4 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v3);
  IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0);

  if (IsLevelEnabled)
  {
    v7 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v6);
    v8 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    _NRLogWithArgs(v7, 0, "%s%.30s:%-4d %@: Plumbed classD keys with OOBK %@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_11", 8611, v8, v41);

  }
  if (v41)
    v9 = (void *)v41[9];
  else
    v9 = 0;
  v10 = v9;
  v12 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v11);
  v13 = _NRLogIsLevelEnabled(v12, 0);

  if (v13)
  {
    v15 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v14);
    v16 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    if (v10)
      v17 = (void *)*((_QWORD *)v10 + 1);
    else
      v17 = 0;
    v18 = v17;
    v19 = sub_10012B324(v18);
    LogString = (void *)_NRKeyCreateLogString(v19);
    _NRLogWithArgs(v15, 0, "%s%.30s:%-4d %@: classDRemotePublicKey=%@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_11", 8614, v16, LogString);

  }
  v21 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v14);
  v22 = _NRLogIsLevelEnabled(v21, 0);

  if (v22)
  {
    v24 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v23);
    v25 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    if (v10)
      v26 = (void *)*((_QWORD *)v10 + 2);
    else
      v26 = 0;
    v27 = v26;
    v28 = sub_10012B324(v27);
    v29 = (void *)_NRKeyCreateLogString(v28);
    _NRLogWithArgs(v24, 0, "%s%.30s:%-4d %@: classDLocalPublicKey=%@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_11", 8616, v25, v29);

  }
  v30 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v23);
  v31 = _NRLogIsLevelEnabled(v30, 0);

  if (v31)
  {
    v33 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v32);
    v34 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    if (v10)
    {
      v35 = *((id *)v10 + 3);
      v36 = v35;
      if (v35)
      {
        v37 = (void *)*((_QWORD *)v35 + 2);
LABEL_17:
        v38 = v37;
        v39 = (void *)_NRKeyCreateLogString(v38);
        _NRLogWithArgs(v33, 0, "%s%.30s:%-4d %@: classDSharedSecret=%@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_11", 8618, v34, v39);

        goto LABEL_18;
      }
    }
    else
    {
      v36 = 0;
    }
    v37 = 0;
    goto LABEL_17;
  }
LABEL_18:
  v40 = *(_QWORD *)(a1 + 32);
  if (v40)
    sub_100077224(v40, 4, 0, 0);

}

void sub_10007E8D8(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  id v5;
  uint64_t v6;
  void *v7;
  int IsLevelEnabled;
  uint64_t v9;
  void *v10;
  id v11;
  void *v12;
  int v13;
  uint64_t v14;
  void *v15;
  id v16;
  void *v17;
  _QWORD *v18;
  _QWORD *v19;
  void *LogString;
  void *v21;
  int v22;
  uint64_t v23;
  void *v24;
  id v25;
  void *v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  void *v30;
  int v31;
  uint64_t v32;
  void *v33;
  id v34;
  id v35;
  void *v36;
  void *v37;
  id v38;
  void *v39;
  uint64_t v40;
  id v41;

  v3 = a2;
  v41 = v3;
  if (v3)
    v4 = (void *)*((_QWORD *)v3 + 10);
  else
    v4 = 0;
  v5 = v4;
  v7 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v6);
  IsLevelEnabled = _NRLogIsLevelEnabled(v7, 0);

  if (IsLevelEnabled)
  {
    v10 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v9);
    v11 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    _NRLogWithArgs(v10, 0, "%s%.30s:%-4d %@: Plumbed classC keys with OOBK %@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_12", 8627, v11, v41);

  }
  v12 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v9);
  v13 = _NRLogIsLevelEnabled(v12, 0);

  if (v13)
  {
    v15 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v14);
    v16 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    if (v5)
      v17 = (void *)*((_QWORD *)v5 + 1);
    else
      v17 = 0;
    v18 = v17;
    v19 = sub_10012B324(v18);
    LogString = (void *)_NRKeyCreateLogString(v19);
    _NRLogWithArgs(v15, 0, "%s%.30s:%-4d %@: classCRemotePublicKey=%@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_12", 8629, v16, LogString);

  }
  v21 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v14);
  v22 = _NRLogIsLevelEnabled(v21, 0);

  if (v22)
  {
    v24 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v23);
    v25 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    if (v5)
      v26 = (void *)*((_QWORD *)v5 + 2);
    else
      v26 = 0;
    v27 = v26;
    v28 = sub_10012B324(v27);
    v29 = (void *)_NRKeyCreateLogString(v28);
    _NRLogWithArgs(v24, 0, "%s%.30s:%-4d %@: classCLocalPublicKey=%@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_12", 8631, v25, v29);

  }
  v30 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v23);
  v31 = _NRLogIsLevelEnabled(v30, 0);

  if (v31)
  {
    v33 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v32);
    v34 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    if (v5)
    {
      v35 = *((id *)v5 + 3);
      v36 = v35;
      if (v35)
      {
        v37 = (void *)*((_QWORD *)v35 + 2);
LABEL_17:
        v38 = v37;
        v39 = (void *)_NRKeyCreateLogString(v38);
        _NRLogWithArgs(v33, 0, "%s%.30s:%-4d %@: classCSharedSecret=%@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_12", 8633, v34, v39);

        goto LABEL_18;
      }
    }
    else
    {
      v36 = 0;
    }
    v37 = 0;
    goto LABEL_17;
  }
LABEL_18:
  v40 = *(_QWORD *)(a1 + 32);
  if (v40)
    sub_100077224(v40, 3, 0, 0);

}

void sub_10007EBF8(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  id v5;
  uint64_t v6;
  void *v7;
  int IsLevelEnabled;
  uint64_t v9;
  void *v10;
  id v11;
  void *v12;
  int v13;
  uint64_t v14;
  void *v15;
  id v16;
  void *v17;
  _QWORD *v18;
  _QWORD *v19;
  void *LogString;
  void *v21;
  int v22;
  uint64_t v23;
  void *v24;
  id v25;
  void *v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  void *v30;
  int v31;
  uint64_t v32;
  void *v33;
  id v34;
  id v35;
  void *v36;
  void *v37;
  id v38;
  void *v39;
  uint64_t v40;
  id v41;

  v3 = a2;
  v41 = v3;
  if (v3)
    v4 = (void *)*((_QWORD *)v3 + 11);
  else
    v4 = 0;
  v5 = v4;
  v7 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v6);
  IsLevelEnabled = _NRLogIsLevelEnabled(v7, 0);

  if (IsLevelEnabled)
  {
    v10 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v9);
    v11 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    _NRLogWithArgs(v10, 0, "%s%.30s:%-4d %@: Plumbed classA keys with OOBK %@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_13", 8642, v11, v41);

  }
  v12 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v9);
  v13 = _NRLogIsLevelEnabled(v12, 0);

  if (v13)
  {
    v15 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v14);
    v16 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    if (v5)
      v17 = (void *)*((_QWORD *)v5 + 1);
    else
      v17 = 0;
    v18 = v17;
    v19 = sub_10012B324(v18);
    LogString = (void *)_NRKeyCreateLogString(v19);
    _NRLogWithArgs(v15, 0, "%s%.30s:%-4d %@: classARemotePublicKey=%@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_13", 8644, v16, LogString);

  }
  v21 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v14);
  v22 = _NRLogIsLevelEnabled(v21, 0);

  if (v22)
  {
    v24 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v23);
    v25 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    if (v5)
      v26 = (void *)*((_QWORD *)v5 + 2);
    else
      v26 = 0;
    v27 = v26;
    v28 = sub_10012B324(v27);
    v29 = (void *)_NRKeyCreateLogString(v28);
    _NRLogWithArgs(v24, 0, "%s%.30s:%-4d %@: classALocalPublicKey=%@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_13", 8646, v25, v29);

  }
  v30 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v23);
  v31 = _NRLogIsLevelEnabled(v30, 0);

  if (v31)
  {
    v33 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v32);
    v34 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    if (v5)
    {
      v35 = *((id *)v5 + 3);
      v36 = v35;
      if (v35)
      {
        v37 = (void *)*((_QWORD *)v35 + 2);
LABEL_17:
        v38 = v37;
        v39 = (void *)_NRKeyCreateLogString(v38);
        _NRLogWithArgs(v33, 0, "%s%.30s:%-4d %@: classASharedSecret=%@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_13", 8648, v34, v39);

        goto LABEL_18;
      }
    }
    else
    {
      v36 = 0;
    }
    v37 = 0;
    goto LABEL_17;
  }
LABEL_18:
  v40 = *(_QWORD *)(a1 + 32);
  if (v40)
    sub_100077224(v40, 1, 0, 0);

}

void sub_10007EF18(uint64_t a1, void *a2)
{
  uint64_t v3;
  void *v4;
  int IsLevelEnabled;
  uint64_t v6;
  void *v7;
  id v8;
  void *v9;
  id v10;
  uint64_t v11;
  void *v12;
  int v13;
  uint64_t v14;
  void *v15;
  id v16;
  void *v17;
  _QWORD *v18;
  _QWORD *v19;
  void *LogString;
  void *v21;
  int v22;
  uint64_t v23;
  void *v24;
  id v25;
  void *v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  void *v30;
  int v31;
  uint64_t v32;
  void *v33;
  id v34;
  id v35;
  void *v36;
  void *v37;
  id v38;
  void *v39;
  uint64_t v40;
  _QWORD *v41;

  v41 = a2;
  v4 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v3);
  IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0);

  if (IsLevelEnabled)
  {
    v7 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v6);
    v8 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    _NRLogWithArgs(v7, 0, "%s%.30s:%-4d %@: Plumbed classD keys with IDS keys %@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_14", 8657, v8, v41);

  }
  if (v41)
    v9 = (void *)v41[9];
  else
    v9 = 0;
  v10 = v9;
  v12 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v11);
  v13 = _NRLogIsLevelEnabled(v12, 0);

  if (v13)
  {
    v15 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v14);
    v16 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    if (v10)
      v17 = (void *)*((_QWORD *)v10 + 1);
    else
      v17 = 0;
    v18 = v17;
    v19 = sub_10012B324(v18);
    LogString = (void *)_NRKeyCreateLogString(v19);
    _NRLogWithArgs(v15, 0, "%s%.30s:%-4d %@: classDRemotePublicKey=%@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_14", 8660, v16, LogString);

  }
  v21 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v14);
  v22 = _NRLogIsLevelEnabled(v21, 0);

  if (v22)
  {
    v24 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v23);
    v25 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    if (v10)
      v26 = (void *)*((_QWORD *)v10 + 2);
    else
      v26 = 0;
    v27 = v26;
    v28 = sub_10012B324(v27);
    v29 = (void *)_NRKeyCreateLogString(v28);
    _NRLogWithArgs(v24, 0, "%s%.30s:%-4d %@: classDLocalPublicKey=%@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_14", 8662, v25, v29);

  }
  v30 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v23);
  v31 = _NRLogIsLevelEnabled(v30, 0);

  if (v31)
  {
    v33 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v32);
    v34 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    if (v10)
    {
      v35 = *((id *)v10 + 3);
      v36 = v35;
      if (v35)
      {
        v37 = (void *)*((_QWORD *)v35 + 2);
LABEL_17:
        v38 = v37;
        v39 = (void *)_NRKeyCreateLogString(v38);
        _NRLogWithArgs(v33, 0, "%s%.30s:%-4d %@: classDSharedSecret=%@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_14", 8664, v34, v39);

        goto LABEL_18;
      }
    }
    else
    {
      v36 = 0;
    }
    v37 = 0;
    goto LABEL_17;
  }
LABEL_18:
  v40 = *(_QWORD *)(a1 + 32);
  if (v40)
    sub_100077224(v40, 4, 0, 0);

}

void sub_10007F23C(uint64_t a1, void *a2)
{
  uint64_t v3;
  void *v4;
  int IsLevelEnabled;
  uint64_t v6;
  void *v7;
  id v8;
  void *v9;
  id v10;
  uint64_t v11;
  void *v12;
  int v13;
  uint64_t v14;
  void *v15;
  id v16;
  void *v17;
  _QWORD *v18;
  _QWORD *v19;
  void *LogString;
  void *v21;
  int v22;
  uint64_t v23;
  void *v24;
  id v25;
  void *v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  void *v30;
  int v31;
  uint64_t v32;
  void *v33;
  id v34;
  id v35;
  void *v36;
  void *v37;
  id v38;
  void *v39;
  uint64_t v40;
  _QWORD *v41;

  v41 = a2;
  v4 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v3);
  IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0);

  if (IsLevelEnabled)
  {
    v7 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v6);
    v8 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    _NRLogWithArgs(v7, 0, "%s%.30s:%-4d %@: Plumbed classC keys with IDS keys %@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_15", 8673, v8, v41);

  }
  if (v41)
    v9 = (void *)v41[10];
  else
    v9 = 0;
  v10 = v9;
  v12 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v11);
  v13 = _NRLogIsLevelEnabled(v12, 0);

  if (v13)
  {
    v15 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v14);
    v16 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    if (v10)
      v17 = (void *)*((_QWORD *)v10 + 1);
    else
      v17 = 0;
    v18 = v17;
    v19 = sub_10012B324(v18);
    LogString = (void *)_NRKeyCreateLogString(v19);
    _NRLogWithArgs(v15, 0, "%s%.30s:%-4d %@: classCRemotePublicKey=%@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_15", 8676, v16, LogString);

  }
  v21 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v14);
  v22 = _NRLogIsLevelEnabled(v21, 0);

  if (v22)
  {
    v24 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v23);
    v25 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    if (v10)
      v26 = (void *)*((_QWORD *)v10 + 2);
    else
      v26 = 0;
    v27 = v26;
    v28 = sub_10012B324(v27);
    v29 = (void *)_NRKeyCreateLogString(v28);
    _NRLogWithArgs(v24, 0, "%s%.30s:%-4d %@: classCLocalPublicKey=%@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_15", 8678, v25, v29);

  }
  v30 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v23);
  v31 = _NRLogIsLevelEnabled(v30, 0);

  if (v31)
  {
    v33 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v32);
    v34 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    if (v10)
    {
      v35 = *((id *)v10 + 3);
      v36 = v35;
      if (v35)
      {
        v37 = (void *)*((_QWORD *)v35 + 2);
LABEL_17:
        v38 = v37;
        v39 = (void *)_NRKeyCreateLogString(v38);
        _NRLogWithArgs(v33, 0, "%s%.30s:%-4d %@: classCSharedSecret=%@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_15", 8680, v34, v39);

        goto LABEL_18;
      }
    }
    else
    {
      v36 = 0;
    }
    v37 = 0;
    goto LABEL_17;
  }
LABEL_18:
  v40 = *(_QWORD *)(a1 + 32);
  if (v40)
    sub_100077224(v40, 3, 0, 0);

}

void sub_10007F560(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  id v5;
  uint64_t v6;
  void *v7;
  int IsLevelEnabled;
  uint64_t v9;
  void *v10;
  id v11;
  void *v12;
  int v13;
  uint64_t v14;
  void *v15;
  id v16;
  void *v17;
  _QWORD *v18;
  _QWORD *v19;
  void *LogString;
  void *v21;
  int v22;
  uint64_t v23;
  void *v24;
  id v25;
  void *v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  void *v30;
  int v31;
  uint64_t v32;
  void *v33;
  id v34;
  id v35;
  void *v36;
  void *v37;
  id v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  id v42;

  v3 = a2;
  v42 = v3;
  if (v3)
    v4 = (void *)*((_QWORD *)v3 + 11);
  else
    v4 = 0;
  v5 = v4;
  v7 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v6);
  IsLevelEnabled = _NRLogIsLevelEnabled(v7, 0);

  if (IsLevelEnabled)
  {
    v10 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v9);
    v11 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    _NRLogWithArgs(v10, 0, "%s%.30s:%-4d %@: Plumbed classA keys with IDS keys %@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_16", 8690, v11, v42);

  }
  v12 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v9);
  v13 = _NRLogIsLevelEnabled(v12, 0);

  if (v13)
  {
    v15 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v14);
    v16 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    if (v5)
      v17 = (void *)*((_QWORD *)v5 + 1);
    else
      v17 = 0;
    v18 = v17;
    v19 = sub_10012B324(v18);
    LogString = (void *)_NRKeyCreateLogString(v19);
    _NRLogWithArgs(v15, 0, "%s%.30s:%-4d %@: classARemotePublicKey=%@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_16", 8692, v16, LogString);

  }
  v21 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v14);
  v22 = _NRLogIsLevelEnabled(v21, 0);

  if (v22)
  {
    v24 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v23);
    v25 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    if (v5)
      v26 = (void *)*((_QWORD *)v5 + 2);
    else
      v26 = 0;
    v27 = v26;
    v28 = sub_10012B324(v27);
    v29 = (void *)_NRKeyCreateLogString(v28);
    _NRLogWithArgs(v24, 0, "%s%.30s:%-4d %@: classALocalPublicKey=%@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_16", 8694, v25, v29);

  }
  v30 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v23);
  v31 = _NRLogIsLevelEnabled(v30, 0);

  if (v31)
  {
    v33 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v32);
    v34 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    if (v5)
    {
      v35 = *((id *)v5 + 3);
      v36 = v35;
      if (v35)
      {
        v37 = (void *)*((_QWORD *)v35 + 2);
LABEL_17:
        v38 = v37;
        v39 = (void *)_NRKeyCreateLogString(v38);
        _NRLogWithArgs(v33, 0, "%s%.30s:%-4d %@: classASharedSecret=%@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_16", 8696, v34, v39);

        goto LABEL_18;
      }
    }
    else
    {
      v36 = 0;
    }
    v37 = 0;
    goto LABEL_17;
  }
LABEL_18:
  v40 = *(_QWORD *)(a1 + 32);
  if (v40)
  {
    *(_BYTE *)(v40 + 235) = 0;
    v41 = *(_QWORD *)(a1 + 32);
    if (v41)
      sub_100077224(v41, 1, 0, 0);
  }

}

void sub_10007F894(uint64_t a1)
{
  objc_storeStrong((id *)(a1 + 1287), 0);
}

void sub_10007F8A8(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  void *v4;
  int IsLevelEnabled;
  uint64_t v6;
  void *v7;
  id v8;
  uint64_t v9;

  v3 = *(_QWORD **)(a1 + 32);
  if ((_DWORD)a2)
  {
    v4 = (void *)_NRCopyLogObjectForNRUUID(v3[4], a2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0);

    if (IsLevelEnabled)
    {
      v7 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v6);
      v8 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
      _NRLogWithArgs(v7, 0, "%s%.30s:%-4d %@: initiatorLocalPublicClassDKeysEncryptedWithIDS was received on %@", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_2", 8448, v8, *(_QWORD *)(a1 + 40));

    }
    v9 = *(_QWORD *)(a1 + 32);
    if (v9)
      sub_100077224(v9, 4, 0, 0);
  }
  else
  {
    objc_msgSend(v3, "cancelWithReason:", CFSTR("initiatorLocalPublicClassDKeysEncryptedWithIDS was not received on %@"), *(_QWORD *)(a1 + 40));
  }
}

void sub_10007F994(uint64_t a1)
{
  objc_storeStrong((id *)(a1 + 1263), 0);
}

void sub_10007F9A8(uint64_t a1)
{
  objc_storeStrong((id *)(a1 + 1271), 0);
}

void sub_10007F9BC(uint64_t a1)
{
  objc_storeStrong((id *)(a1 + 1279), 0);
}

void sub_10007F9D0(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v4;
  void *v5;
  int IsLevelEnabled;
  uint64_t v7;
  void *v8;
  id v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  id v13;
  id v14;

  v2 = a2;
  v4 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), a2);
  v5 = (void *)v4;
  if (v2)
  {
    IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0);

    if (IsLevelEnabled)
    {
      v8 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v7);
      v9 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
      _NRLogWithArgs(v8, 0, "%s%.30s:%-4d %@: initiatorLocalPublicKeys were received", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_3", 8507, v9);

    }
    v10 = *(_QWORD *)(a1 + 32);
    if (v10)
      sub_100077224(v10, 4, 0, 0);
  }
  else
  {
    v11 = _NRLogIsLevelEnabled(v4, 16);

    if (v11)
    {
      v14 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v12);
      v13 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
      _NRLogWithArgs(v14, 16, "%s%.30s:%-4d %@: initiatorLocalPublicKeys were not received", "", "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_3", 8512, v13);

    }
  }
}

void sub_10007FB20(uint64_t a1, int a2)
{
  char *WeakRetained;
  uint64_t v4;
  void *v5;
  int IsLevelEnabled;
  void *v7;
  id v8;
  uint64_t v9;
  void *v10;
  int v11;
  uint64_t v12;
  void *v13;
  id v14;
  int v15;
  uint64_t v16;
  void *v17;
  id v18;
  char *v19;

  WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    --*(_DWORD *)(WeakRetained + 307);
    v19 = WeakRetained;
    if ((*(_DWORD *)(WeakRetained + 307) & 0x80000000) != 0)
    {
      v5 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 4), v4);
      IsLevelEnabled = _NRLogIsLevelEnabled(v5, 17);

      if (IsLevelEnabled)
      {
        v7 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v19 + 4), v4);
        v8 = objc_msgSend(v19, "copyDescription");
        _NRLogWithArgs(v7, 17, "%@: Invalid control data send queue length: %d", v8, *(unsigned int *)(v19 + 307));

      }
      WeakRetained = v19;
      *(_DWORD *)(v19 + 307) = 0;
    }
    v9 = _NRCopyLogObjectForNRUUID(*((_QWORD *)WeakRetained + 4), v4);
    v10 = (void *)v9;
    if (a2)
    {
      v11 = _NRLogIsLevelEnabled(v9, 0);

      if (v11)
      {
        v13 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v19 + 4), v12);
        v14 = objc_msgSend(v19, "copyDescription");
        _NRLogWithArgs(v13, 0, "%s%.30s:%-4d %@: Received response to control notify", "", "-[NRLinkBluetooth sendControlData:]_block_invoke", 7295, v14);

      }
      WeakRetained = v19;
      if (v19[231] && !*(_DWORD *)(v19 + 307))
      {
        sub_10007FD08((uint64_t)v19, 1);
LABEL_14:
        WeakRetained = v19;
      }
    }
    else
    {
      v15 = _NRLogIsLevelEnabled(v9, 16);

      WeakRetained = v19;
      if (v15)
      {
        v17 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v19 + 4), v16);
        v18 = objc_msgSend(v19, "copyDescription");
        _NRLogWithArgs(v17, 16, "%s%.30s:%-4d %@: Did not receive response to control notify", "", "-[NRLinkBluetooth sendControlData:]_block_invoke", 7302, v18);

        goto LABEL_14;
      }
    }
  }

}

void sub_10007FD08(uint64_t a1, uint64_t a2)
{
  void *v4;
  int IsLevelEnabled;
  uint64_t v6;
  void *v7;
  id v8;

  if (a1)
  {
    *(_BYTE *)(a1 + 231) = 0;
    if (*(unsigned __int8 *)(a1 + 232) != (_DWORD)a2)
    {
      v4 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
      IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0);

      if (IsLevelEnabled)
      {
        v7 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v6);
        v8 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v7, 0, "%s%.30s:%-4d %@: Setting isSuspended: %d -> %d", "", "-[NRLinkBluetooth setIsSuspended:]", 1743, v8, *(unsigned __int8 *)(a1 + 232), a2);

      }
      *(_BYTE *)(a1 + 232) = a2;
      sub_10007FE04(a1, v6);
    }
  }
}

void sub_10007FE04(uint64_t a1, uint64_t a2)
{
  void *v3;
  int IsLevelEnabled;
  uint64_t v5;
  void *v6;
  id v7;
  uint64_t v8;
  void *v9;
  BOOL v10;
  void *v11;
  id v12;
  uint64_t v13;
  id v14;
  void *v15;
  id v16;
  char v17;
  uint64_t v18;
  void *v19;
  int v20;
  uint64_t v21;
  void *v22;
  id v23;
  id v24;
  int v25;
  id v26;
  uint64_t v27;
  char *v28;
  int *v29;
  uint64_t v30;
  id v31;
  id *v32;

  if (a1)
  {
    if (*(_BYTE *)(a1 + 232))
    {
      v3 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
      IsLevelEnabled = _NRLogIsLevelEnabled(v3, 0);

      if (IsLevelEnabled)
      {
        v6 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
        v7 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v6, 0, "%s%.30s:%-4d %@: Setting packetNexus.availability: %zu -> %zu", "", "-[NRLinkBluetooth setPacketNexusAvailability]", 5838, v7, objc_msgSend(*(id *)(a1 + 1335), "availability"), 0);

      }
      objc_msgSend(*(id *)(a1 + 1335), "setAvailability:", 0);
    }
    else
    {
      v8 = objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "proxyAgentRegistration"));
      if (v8)
      {
        v9 = (void *)v8;
        v10 = objc_msgSend((id)a1, "state") == 8;

      }
      else
      {
        v10 = 0;
      }
      v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "nrUUID"));
      v32 = (id *)sub_10012FFF4((uint64_t)NRDLocalDevice, v11);

      if (v32)
      {
        v12 = v32[16];

        if (v12 && (v14 = v32[16]) != 0)
        {
          v15 = v14;
          v16 = v32[16];
          v17 = objc_msgSend(v16, "requiresReachability") & v10;

          if ((v17 & 1) != 0)
            v18 = 2;
          else
            v18 = 1;
        }
        else
        {
          v18 = 1;
        }
        v19 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v13);
        v20 = _NRLogIsLevelEnabled(v19, 0);

        if (v20)
        {
          v22 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v21);
          v23 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v22, 0, "%s%.30s:%-4d %@: Setting packetNexus.availability: %zu -> %zu", "", "-[NRLinkBluetooth setPacketNexusAvailability]", 5870, v23, objc_msgSend(*(id *)(a1 + 1335), "availability"), v18);

        }
        objc_msgSend(*(id *)(a1 + 1335), "setAvailability:", v18, v32);

      }
      else
      {
        v24 = sub_100070AC8();
        v25 = _NRLogIsLevelEnabled(v24, 16);

        if (v25)
        {
          v26 = sub_100070AC8();
          _NRLogWithArgs(v26, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)", "", "-[NRLinkBluetooth setPacketNexusAvailability]", 5854);

        }
        v27 = _os_log_pack_size(12);
        v28 = (char *)&v32 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
        v29 = __error();
        v30 = _os_log_pack_fill(v28, v27, *v29, &_mh_execute_header, "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
        *(_DWORD *)v30 = 136446210;
        *(_QWORD *)(v30 + 4) = "-[NRLinkBluetooth setPacketNexusAvailability]";
        v31 = sub_100070AC8();
        _NRLogAbortWithPack(v31, v28);
      }
    }
  }
}

void sub_100080188(uint64_t a1)
{
  void *v2;
  void *v3;
  id v4;
  _BOOL8 v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  void *v9;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "linkDelegate"));
  if (!v2)
    goto LABEL_13;
  v3 = *(void **)(a1 + 40);
  v9 = v2;
  if (v3)
  {
    v4 = objc_msgSend(v3, "hostState");
    v5 = v4 == (id)1;
    v6 = *(_QWORD *)(a1 + 32);
    if (v6)
    {
      v2 = v9;
      if ((v4 == (id)1) != (*(_BYTE *)(v6 + 243) != 0))
      {
LABEL_9:
        *(_BYTE *)(v6 + 243) = v5;
        v7 = *(_QWORD *)(a1 + 32);
        if (v7)
          *(_BYTE *)(v7 + 244) = 1;
        goto LABEL_11;
      }
LABEL_8:
      if (*(_BYTE *)(v6 + 244))
        goto LABEL_13;
      goto LABEL_9;
    }
    v2 = v9;
  }
  else
  {
    v6 = *(_QWORD *)(a1 + 32);
    if (v6)
    {
      v5 = 0;
      if (*(_BYTE *)(v6 + 243))
        goto LABEL_9;
      goto LABEL_8;
    }
    v5 = 0;
  }
LABEL_11:
  v8 = objc_opt_respondsToSelector(v2, "linkPeerIsAsleep:isAsleep:");
  v2 = v9;
  if ((v8 & 1) != 0)
  {
    objc_msgSend(v9, "linkPeerIsAsleep:isAsleep:", *(_QWORD *)(a1 + 32), v5);
    v2 = v9;
  }
LABEL_13:

}

void sub_1000802A0(uint64_t a1, void *a2)
{
  id v4;
  uint64_t v5;
  void *v6;
  void *v7;
  int IsLevelEnabled;
  uint64_t v9;
  void *v10;
  id v11;
  NSObject *v12;
  void *v13;
  NSObject *v14;
  void *v15;
  id v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t attr;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  int v25;
  uint64_t v26;
  void *v27;
  id v28;
  void *v29;
  NSObject *v30;
  void *v31;
  void *v32;
  void *v33;
  int v34;
  uint64_t v35;
  void *v36;
  int v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int fd;
  uint64_t v47;
  uintptr_t v48;
  dispatch_source_t v49;
  void *v50;
  uint64_t v51;
  NSObject *v52;
  NSObject *v53;
  id v54;
  dispatch_source_t v55;
  void *v56;
  uint64_t v57;
  NSObject *v58;
  NSObject *v59;
  uint64_t v60;
  uint64_t v61;
  void *v62;
  int v63;
  uint64_t v64;
  void *v65;
  int v66;
  uint64_t v67;
  void *v68;
  int v69;
  uint64_t v70;
  void *v71;
  int v72;
  uint64_t v73;
  void *v74;
  int v75;
  uint64_t v76;
  void *v77;
  id v78;
  void *v79;
  int v80;
  uint64_t v81;
  void *v82;
  id v83;
  void *v84;
  int v85;
  uint64_t v86;
  void *v87;
  id v88;
  void *v89;
  int v90;
  uint64_t v91;
  void *v92;
  id v93;
  void *v94;
  int v95;
  uint64_t v96;
  void *v97;
  id v98;
  void *v99;
  int v100;
  uint64_t v101;
  void *v102;
  id v103;
  void *v104;
  int v105;
  uint64_t v106;
  void *v107;
  id v108;
  void *v109;
  int v110;
  uint64_t v111;
  void *v112;
  id v113;
  void *v114;
  int v115;
  uint64_t v116;
  void *v117;
  id v118;
  void *v119;
  int v120;
  uint64_t v121;
  void *v122;
  id v123;
  id v124;
  int v125;
  id v126;
  uint64_t v127;
  char *v128;
  int *v129;
  uint64_t v130;
  id v131;
  char *v132;
  char *v133;
  uint64_t v134;
  uintptr_t v135;
  _QWORD v136[4];
  id v137;
  _QWORD v138[5];
  _QWORD v139[4];
  id v140;
  _QWORD handler[5];
  void *memptr;

  v4 = a2;
  v6 = v4;
  if (!a1 || *(id *)(a1 + 1031) == v4)
    goto LABEL_63;
  if (*(_BYTE *)(a1 + 246))
  {
LABEL_4:
    v7 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
    IsLevelEnabled = _NRLogIsLevelEnabled(v7, 1);

    if (IsLevelEnabled)
    {
      v10 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v9);
      v11 = objc_msgSend((id)a1, "copyDescription");
      _NRLogWithArgs(v10, 1, "%s%.30s:%-4d %@: Updating datagram pipe: %@ -> %@", "", "-[NRLinkBluetooth updateDatagramPipe:]", 2790, v11, *(_QWORD *)(a1 + 1031), v6);

    }
    objc_storeStrong((id *)(a1 + 1031), a2);
    *(_BYTE *)(a1 + 225) = *(_QWORD *)(a1 + 1031) != 0;
    if (*(_BYTE *)(a1 + 246))
    {
      if (*(_BYTE *)(a1 + 225))
        sub_10008F998((_QWORD *)a1, 0, &off_1001C4708);
      else
        sub_100083C98(a1, &off_1001C4708);
    }
    goto LABEL_63;
  }
  v12 = *(NSObject **)(a1 + 1063);
  if (!v6)
  {
    if (v12)
    {
      if (*(_BYTE *)(a1 + 223))
      {
        *(_BYTE *)(a1 + 223) = 0;
        ++*(_QWORD *)(a1 + 1079);
        if (gNRPacketLoggingEnabled)
        {
          v89 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
          v90 = _NRLogIsLevelEnabled(v89, 1);

          if (v90)
          {
            v92 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v91);
            v93 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v92, 1, "%s%.30s:%-4d %@: source-resume: DatagramLinkInput", "", "NRLinkResumeDatagramLinkInputSource", 824, v93);

          }
        }
        dispatch_resume(*(dispatch_object_t *)(a1 + 1063));
        v12 = *(NSObject **)(a1 + 1063);
      }
      dispatch_source_cancel(v12);
      v29 = *(void **)(a1 + 1063);
      *(_QWORD *)(a1 + 1063) = 0;

    }
    v30 = *(NSObject **)(a1 + 1071);
    if (v30)
    {
      if (*(_BYTE *)(a1 + 224))
      {
        *(_BYTE *)(a1 + 224) = 0;
        ++*(_QWORD *)(a1 + 1087);
        if (gNRPacketLoggingEnabled)
        {
          v94 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
          v95 = _NRLogIsLevelEnabled(v94, 1);

          if (v95)
          {
            v97 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v96);
            v98 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v97, 1, "%s%.30s:%-4d %@: source-resume: DatagramLinkOutput", "", "NRLinkResumeDatagramLinkOutputSource", 825, v98);

          }
        }
        dispatch_resume(*(dispatch_object_t *)(a1 + 1071));
        v30 = *(NSObject **)(a1 + 1071);
      }
      dispatch_source_cancel(v30);
      v31 = *(void **)(a1 + 1071);
      *(_QWORD *)(a1 + 1071) = 0;

    }
    if (!*(_BYTE *)(a1 + 215) && *(_QWORD *)(a1 + 559))
    {
      *(_BYTE *)(a1 + 215) = 1;
      ++*(_QWORD *)(a1 + 575);
      if (gNRPacketLoggingEnabled)
      {
        v119 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
        v120 = _NRLogIsLevelEnabled(v119, 1);

        if (v120)
        {
          v122 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v121);
          v123 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v122, 1, "%s%.30s:%-4d %@: source-suspend: NexusVOOutput", "", "NRLinkSuspendNexusVOOutputSource", 835, v123);

        }
      }
      dispatch_suspend(*(dispatch_object_t *)(a1 + 559));
    }
    if (*(_BYTE *)(a1 + 212) && *(_QWORD *)(a1 + 391))
    {
      *(_BYTE *)(a1 + 212) = 0;
      ++*(_QWORD *)(a1 + 415);
      if (gNRPacketLoggingEnabled)
      {
        v99 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
        v100 = _NRLogIsLevelEnabled(v99, 1);

        if (v100)
        {
          v102 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v101);
          v103 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v102, 1, "%s%.30s:%-4d %@: source-resume: NexusInput", "", "NRLinkResumeNexusInputSource", 842, v103);

        }
      }
      dispatch_resume(*(dispatch_object_t *)(a1 + 391));
    }
    if (*(_BYTE *)(a1 + 216) && *(_QWORD *)(a1 + 695))
    {
      *(_BYTE *)(a1 + 216) = 0;
      ++*(_QWORD *)(a1 + 711);
      if (gNRPacketLoggingEnabled)
      {
        v104 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
        v105 = _NRLogIsLevelEnabled(v104, 1);

        if (v105)
        {
          v107 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v106);
          v108 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v107, 1, "%s%.30s:%-4d %@: source-resume: NexusVIInput", "", "NRLinkResumeNexusVIInputSource", 846, v108);

        }
      }
      dispatch_resume(*(dispatch_object_t *)(a1 + 695));
    }
    if (*(_BYTE *)(a1 + 218) && *(_QWORD *)(a1 + 839))
    {
      *(_BYTE *)(a1 + 218) = 0;
      ++*(_QWORD *)(a1 + 855);
      if (gNRPacketLoggingEnabled)
      {
        v109 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
        v110 = _NRLogIsLevelEnabled(v109, 1);

        if (v110)
        {
          v112 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v111);
          v113 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v112, 1, "%s%.30s:%-4d %@: source-resume: NexusBKInput", "", "NRLinkResumeNexusBKInputSource", 848, v113);

        }
      }
      dispatch_resume(*(dispatch_object_t *)(a1 + 839));
    }
    if (*(_BYTE *)(a1 + 214) && *(_QWORD *)(a1 + 551))
    {
      *(_BYTE *)(a1 + 214) = 0;
      ++*(_QWORD *)(a1 + 567);
      if (gNRPacketLoggingEnabled)
      {
        v114 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
        v115 = _NRLogIsLevelEnabled(v114, 1);

        if (v115)
        {
          v117 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v116);
          v118 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v117, 1, "%s%.30s:%-4d %@: source-resume: NexusVOInput", "", "NRLinkResumeNexusVOInputSource", 844, v118);

        }
      }
      dispatch_resume(*(dispatch_object_t *)(a1 + 551));
    }
    *(_QWORD *)(a1 + 1039) = 0;
    *(_QWORD *)(a1 + 1055) = 0;
    *(_QWORD *)(a1 + 1047) = 0;
    *(_QWORD *)(a1 + 1079) = 0;
    *(_QWORD *)(a1 + 1087) = 0;
    v32 = *(void **)(a1 + 1911);
    if (v32)
    {
      free(v32);
      *(_QWORD *)(a1 + 1911) = 0;
    }
    goto LABEL_4;
  }
  if (v12)
  {
    if (*(_BYTE *)(a1 + 223))
    {
      *(_BYTE *)(a1 + 223) = 0;
      ++*(_QWORD *)(a1 + 1079);
      if (gNRPacketLoggingEnabled)
      {
        v79 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
        v80 = _NRLogIsLevelEnabled(v79, 1);

        if (v80)
        {
          v82 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v81);
          v83 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v82, 1, "%s%.30s:%-4d %@: source-resume: DatagramLinkInput", "", "NRLinkResumeDatagramLinkInputSource", 824, v83);

        }
      }
      dispatch_resume(*(dispatch_object_t *)(a1 + 1063));
      v12 = *(NSObject **)(a1 + 1063);
    }
    dispatch_source_cancel(v12);
    v13 = *(void **)(a1 + 1063);
    *(_QWORD *)(a1 + 1063) = 0;

  }
  v14 = *(NSObject **)(a1 + 1071);
  if (v14)
  {
    if (*(_BYTE *)(a1 + 224))
    {
      *(_BYTE *)(a1 + 224) = 0;
      ++*(_QWORD *)(a1 + 1087);
      if (gNRPacketLoggingEnabled)
      {
        v84 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
        v85 = _NRLogIsLevelEnabled(v84, 1);

        if (v85)
        {
          v87 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v86);
          v88 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v87, 1, "%s%.30s:%-4d %@: source-resume: DatagramLinkOutput", "", "NRLinkResumeDatagramLinkOutputSource", 825, v88);

        }
      }
      dispatch_resume(*(dispatch_object_t *)(a1 + 1071));
      v14 = *(NSObject **)(a1 + 1071);
    }
    dispatch_source_cancel(v14);
    v15 = *(void **)(a1 + 1071);
    *(_QWORD *)(a1 + 1071) = 0;

  }
  *(_QWORD *)(a1 + 1039) = 0;
  *(_QWORD *)(a1 + 1055) = 0;
  *(_QWORD *)(a1 + 1047) = 0;
  v16 = objc_msgSend(v6, "channel");
  *(_QWORD *)(a1 + 1039) = v16;
  if (!v16)
  {
    v33 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v17);
    v34 = _NRLogIsLevelEnabled(v33, 17);

    if (v34)
    {
      v27 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v35);
      v28 = objc_msgSend((id)a1, "copyDescription");
      _NRLogWithArgs(v27, 17, "%@: _datagramLinkChannel is NULL", v28, v134);
      goto LABEL_62;
    }
LABEL_63:

    return;
  }
  v18 = os_channel_attr_create();
  if (!v18)
  {
    v36 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v19);
    v37 = _NRLogIsLevelEnabled(v36, 17);

    if (v37)
    {
      v27 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v38);
      v28 = objc_msgSend((id)a1, "copyDescription");
      _NRLogWithArgs(v27, 17, "%@: os_channel_attr_create failed", v28, v134);
      goto LABEL_62;
    }
    goto LABEL_63;
  }
  v20 = v18;
  attr = os_channel_read_attr(*(_QWORD *)(a1 + 1039), v18);
  if ((_DWORD)attr)
  {
    v23 = attr;
    v24 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v22);
    v25 = _NRLogIsLevelEnabled(v24, 17);

    if (v25)
    {
      v27 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v26);
      v28 = objc_msgSend((id)a1, "copyDescription");
      _NRLogWithArgs(v27, 17, "%@: os_channel_read_attr returned %d", v28, v23);
LABEL_62:

      goto LABEL_63;
    }
    goto LABEL_63;
  }
  v39 = sub_1000827B0((_QWORD *)a1, v20);
  os_channel_attr_destroy(v20);
  if (!v39)
    goto LABEL_63;
  v40 = os_channel_ring_id(*(_QWORD *)(a1 + 1039), 2);
  v41 = os_channel_rx_ring(*(_QWORD *)(a1 + 1039), v40);
  *(_QWORD *)(a1 + 1047) = v41;
  if (!v41)
  {
    v62 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v42);
    v63 = _NRLogIsLevelEnabled(v62, 17);

    if (!v63)
      goto LABEL_63;
    v27 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v64);
    v28 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v27, 17, "%@: _datagramLinkInputRing is NULL", v28, v134);
    goto LABEL_62;
  }
  v43 = os_channel_ring_id(*(_QWORD *)(a1 + 1039), 0);
  v44 = os_channel_tx_ring(*(_QWORD *)(a1 + 1039), v43);
  *(_QWORD *)(a1 + 1055) = v44;
  if (!v44)
  {
    v65 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v45);
    v66 = _NRLogIsLevelEnabled(v65, 17);

    if (!v66)
      goto LABEL_63;
    v27 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v67);
    v28 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v27, 17, "%@: _datagramLinkOutputRing is NULL", v28, v134);
    goto LABEL_62;
  }
  fd = os_channel_get_fd(*(_QWORD *)(a1 + 1039));
  if ((fd & 0x80000000) != 0)
  {
    v68 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v47);
    v69 = _NRLogIsLevelEnabled(v68, 17);

    if (!v69)
      goto LABEL_63;
    v27 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v70);
    v28 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v27, 17, "%@: os_channel_get_fd failed", v28, v134);
    goto LABEL_62;
  }
  v48 = fd;
  v49 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, fd, 0, *(dispatch_queue_t *)(a1 + 8));
  v50 = *(void **)(a1 + 1063);
  *(_QWORD *)(a1 + 1063) = v49;

  v52 = *(NSObject **)(a1 + 1063);
  if (!v52)
  {
    v71 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v51);
    v72 = _NRLogIsLevelEnabled(v71, 17);

    if (!v72)
      goto LABEL_63;
    v27 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v73);
    v28 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v27, 17, "%@: _dDatagramLinkInputSource is NULL", v28, v134);
    goto LABEL_62;
  }
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472;
  v135 = v48;
  handler[2] = sub_10009E144;
  handler[3] = &unk_1001B8AE0;
  handler[4] = a1;
  dispatch_source_set_event_handler(v52, handler);
  v53 = *(NSObject **)(a1 + 1063);
  v139[0] = _NSConcreteStackBlock;
  v139[1] = 3221225472;
  v139[2] = nullsub_8;
  v139[3] = &unk_1001B8AE0;
  v54 = v6;
  v140 = v54;
  dispatch_source_set_cancel_handler(v53, v139);
  dispatch_activate(*(dispatch_object_t *)(a1 + 1063));
  v55 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_write, v48, 0, *(dispatch_queue_t *)(a1 + 8));
  v56 = *(void **)(a1 + 1071);
  *(_QWORD *)(a1 + 1071) = v55;

  v58 = *(NSObject **)(a1 + 1071);
  if (!v58)
  {
    v74 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v57);
    v75 = _NRLogIsLevelEnabled(v74, 17);

    if (v75)
    {
      v77 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v76);
      v78 = objc_msgSend((id)a1, "copyDescription");
      _NRLogWithArgs(v77, 17, "%@: _dDatagramLinkOutputSource is NULL", v78);

    }
    goto LABEL_63;
  }
  v138[0] = _NSConcreteStackBlock;
  v138[1] = 3221225472;
  v138[2] = sub_10009E328;
  v138[3] = &unk_1001B8AE0;
  v138[4] = a1;
  dispatch_source_set_event_handler(v58, v138);
  v59 = *(NSObject **)(a1 + 1071);
  v136[0] = _NSConcreteStackBlock;
  v136[1] = 3221225472;
  v136[2] = nullsub_9;
  v136[3] = &unk_1001B8AE0;
  v137 = v54;
  dispatch_source_set_cancel_handler(v59, v136);
  *(_BYTE *)(a1 + 224) = 1;
  *(_BYTE *)(a1 + 254) = 10;
  v60 = *(unsigned __int8 *)(a1 + 254);
  if (!*(_BYTE *)(a1 + 254))
  {
LABEL_74:

    goto LABEL_4;
  }
  v61 = 8 * v60;
  memptr = 0;
  if (!malloc_type_posix_memalign(&memptr, 8uLL, 8 * v60, 0xD5FEC036uLL) && memptr)
  {
    *(_QWORD *)(a1 + 1911) = memptr;
    goto LABEL_74;
  }
  v124 = sub_100070AC8();
  v125 = _NRLogIsLevelEnabled(v124, 16);

  if (v125)
  {
    v126 = sub_100070AC8();
    _NRLogWithArgs(v126, 16, "%s%.30s:%-4d ABORTING: posix_memalign(..., %zu, %zu) failed", "", "strict_memalign", 183, 8uLL, v61);

  }
  v127 = _os_log_pack_size(32);
  v128 = (char *)&v136[-1] - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
  v129 = __error();
  v130 = _os_log_pack_fill(v128, v127, *v129, &_mh_execute_header, "%{public}s posix_memalign(..., %zu, %zu) failed");
  *(_DWORD *)v130 = 136446722;
  *(_QWORD *)(v130 + 4) = "strict_memalign";
  *(_WORD *)(v130 + 12) = 2048;
  *(_QWORD *)(v130 + 14) = 8;
  *(_WORD *)(v130 + 22) = 2048;
  *(_QWORD *)(v130 + 24) = v61;
  v131 = sub_100070AC8();
  v132 = (char *)_NRLogAbortWithPack(v131, v128);
  sub_1000812F0(v132, v133);
}

void sub_1000812F0(char *a1, char *a2)
{
  uint64_t v2;
  char *v3;
  char *v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  void *v11;
  char v12;
  char *v13;
  uint64_t v14;
  char v15;
  __int128 v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  void *v22;
  int v23;
  uint64_t v24;
  void *v25;
  id v26;
  void *v27;
  int IsLevelEnabled;
  uint64_t v29;
  void *v30;
  id v31;
  id v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t attr;
  uint64_t v38;
  uint64_t v39;
  void *v40;
  int v41;
  uint64_t v42;
  void *v43;
  int v44;
  uint64_t v45;
  void *v46;
  int v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unsigned int fd;
  uint64_t v57;
  uintptr_t v58;
  dispatch_source_t v59;
  void *v60;
  uint64_t v61;
  NSObject *v62;
  NSObject *v63;
  char *v64;
  dispatch_source_t v65;
  void *v66;
  uint64_t v67;
  NSObject *v68;
  NSObject *v69;
  uint64_t v70;
  uint64_t v71;
  void *v72;
  int v73;
  uint64_t v74;
  void *v75;
  int v76;
  uint64_t v77;
  void *v78;
  int v79;
  uint64_t v80;
  void *v81;
  int v82;
  uint64_t v83;
  void *v84;
  int v85;
  uint64_t v86;
  void *v87;
  id v88;
  id v89;
  int v90;
  id v91;
  int *v92;
  uint64_t v93;
  id v94;
  int v95;
  id v96;
  id v97;
  int v98;
  id v99;
  int *v100;
  uint64_t v101;
  uint64_t v102;
  id v103;
  int v104;
  id v105;
  int *v106;
  uint64_t v107;
  id v108;
  void *v109;
  int v110;
  uint64_t v111;
  void *v112;
  id v113;
  id v114;
  int v115;
  id v116;
  int *v117;
  id v118;
  int v119;
  id v120;
  int *v121;
  id v122;
  int v123;
  id v124;
  int *v125;
  uint64_t v126;
  _QWORD block[5];
  char *v128;
  _QWORD v129[4];
  char *v130;
  _QWORD v131[5];
  _QWORD v132[4];
  char *v133;
  _QWORD handler[5];
  void *memptr[2];

  v3 = a2;
  v5 = a2;
  v7 = v5;
  if (!a1 || *(char **)(a1 + 1111) == v5)
    goto LABEL_29;
  if (!v5)
  {
    if (objc_msgSend(a1, "state") != 255)
    {
      v21 = *(id *)(a1 + 1863);
      if (v21)
        ++v21[16];

    }
    sub_100082348((uint64_t)a1, v20);
    goto LABEL_21;
  }
  sub_100082348((uint64_t)a1, v6);
  if (objc_msgSend(v7, "priority") != (id)2)
  {
    v27 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)a1 + 4), v8);
    IsLevelEnabled = _NRLogIsLevelEnabled(v27, 17);

    if (!IsLevelEnabled)
      goto LABEL_29;
    v30 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)a1 + 4), v29);
    v31 = objc_msgSend(a1, "copyDescription");
    _NRLogWithArgs(v30, 17, "%@: invalid urgent pipe: %@", v31, v7);
LABEL_28:

    goto LABEL_29;
  }
  if (a1[246])
    goto LABEL_6;
  v32 = objc_msgSend(v7, "channel");
  *(_QWORD *)(a1 + 1119) = v32;
  if (!v32)
  {
    v43 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)a1 + 4), v33);
    v44 = _NRLogIsLevelEnabled(v43, 17);

    if (!v44)
      goto LABEL_29;
    v30 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)a1 + 4), v45);
    v31 = objc_msgSend(a1, "copyDescription");
    _NRLogWithArgs(v30, 17, "%@: _urgentLinkChannel is NULL", v31);
    goto LABEL_28;
  }
  v34 = os_channel_attr_create();
  if (!v34)
  {
    v46 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)a1 + 4), v35);
    v47 = _NRLogIsLevelEnabled(v46, 17);

    if (!v47)
      goto LABEL_29;
    v30 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)a1 + 4), v48);
    v31 = objc_msgSend(a1, "copyDescription");
    _NRLogWithArgs(v30, 17, "%@: os_channel_attr_create failed", v31);
    goto LABEL_28;
  }
  v36 = v34;
  attr = os_channel_read_attr(*(_QWORD *)(a1 + 1119), v34);
  if ((_DWORD)attr)
  {
    v39 = attr;
    v40 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)a1 + 4), v38);
    v41 = _NRLogIsLevelEnabled(v40, 17);

    if (!v41)
      goto LABEL_29;
    v30 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)a1 + 4), v42);
    v31 = objc_msgSend(a1, "copyDescription");
    _NRLogWithArgs(v30, 17, "%@: os_channel_read_attr returned %d", v31, v39);
    goto LABEL_28;
  }
  v49 = sub_1000827B0(a1, v36);
  os_channel_attr_destroy(v36);
  if (!v49)
    goto LABEL_29;
  v50 = os_channel_ring_id(*(_QWORD *)(a1 + 1119), 2);
  v51 = os_channel_rx_ring(*(_QWORD *)(a1 + 1119), v50);
  *(_QWORD *)(a1 + 1127) = v51;
  if (!v51)
  {
    v72 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)a1 + 4), v52);
    v73 = _NRLogIsLevelEnabled(v72, 17);

    if (!v73)
      goto LABEL_29;
    v30 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)a1 + 4), v74);
    v31 = objc_msgSend(a1, "copyDescription");
    _NRLogWithArgs(v30, 17, "%@: _urgentLinkInputRing is NULL", v31);
    goto LABEL_28;
  }
  v53 = os_channel_ring_id(*(_QWORD *)(a1 + 1119), 0);
  v54 = os_channel_tx_ring(*(_QWORD *)(a1 + 1119), v53);
  *(_QWORD *)(a1 + 1135) = v54;
  if (!v54)
  {
    v75 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)a1 + 4), v55);
    v76 = _NRLogIsLevelEnabled(v75, 17);

    if (!v76)
      goto LABEL_29;
    v30 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)a1 + 4), v77);
    v31 = objc_msgSend(a1, "copyDescription");
    _NRLogWithArgs(v30, 17, "%@: _urgentLinkOutputRing is NULL", v31);
    goto LABEL_28;
  }
  fd = os_channel_get_fd(*(_QWORD *)(a1 + 1119));
  if ((fd & 0x80000000) != 0)
  {
    v78 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)a1 + 4), v57);
    v79 = _NRLogIsLevelEnabled(v78, 17);

    if (!v79)
      goto LABEL_29;
    v30 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)a1 + 4), v80);
    v31 = objc_msgSend(a1, "copyDescription");
    _NRLogWithArgs(v30, 17, "%@: os_channel_get_fd failed", v31);
    goto LABEL_28;
  }
  v58 = fd;
  v59 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, fd, 0, *((dispatch_queue_t *)a1 + 1));
  v60 = *(void **)(a1 + 1143);
  *(_QWORD *)(a1 + 1143) = v59;

  v62 = *(NSObject **)(a1 + 1143);
  if (!v62)
  {
    v81 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)a1 + 4), v61);
    v82 = _NRLogIsLevelEnabled(v81, 17);

    if (!v82)
      goto LABEL_29;
    v30 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)a1 + 4), v83);
    v31 = objc_msgSend(a1, "copyDescription");
    _NRLogWithArgs(v30, 17, "%@: _dUrgentLinkInputSource is NULL", v31);
    goto LABEL_28;
  }
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472;
  handler[2] = sub_100083780;
  handler[3] = &unk_1001B8AE0;
  handler[4] = a1;
  dispatch_source_set_event_handler(v62, handler);
  v63 = *(NSObject **)(a1 + 1143);
  v132[0] = _NSConcreteStackBlock;
  v132[1] = 3221225472;
  v132[2] = nullsub_6;
  v132[3] = &unk_1001B8AE0;
  v64 = v7;
  v133 = v64;
  dispatch_source_set_cancel_handler(v63, v132);
  dispatch_activate(*(dispatch_object_t *)(a1 + 1143));
  v65 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_write, v58, 0, *((dispatch_queue_t *)a1 + 1));
  v66 = *(void **)(a1 + 1151);
  *(_QWORD *)(a1 + 1151) = v65;

  v68 = *(NSObject **)(a1 + 1151);
  if (v68)
  {
    v131[0] = _NSConcreteStackBlock;
    v131[1] = 3221225472;
    v131[2] = sub_1000839A0;
    v131[3] = &unk_1001B8AE0;
    v131[4] = a1;
    dispatch_source_set_event_handler(v68, v131);
    v69 = *(NSObject **)(a1 + 1151);
    v129[0] = _NSConcreteStackBlock;
    v129[1] = 3221225472;
    v129[2] = nullsub_7;
    v129[3] = &unk_1001B8AE0;
    v130 = v64;
    dispatch_source_set_cancel_handler(v69, v129);
    a1[228] = 1;
    v2 = 10;
    a1[252] = 10;
    v70 = a1[252];
    if (a1[252])
    {
      v9 = 8 * v70;
      memptr[0] = 0;
      if (malloc_type_posix_memalign(memptr, 8uLL, 8 * v70, 0xD5FEC036uLL) || !memptr[0])
      {
        v114 = sub_100070AC8();
        v115 = _NRLogIsLevelEnabled(v114, 16);

        v3 = "strict_memalign";
        if (v115)
        {
          v116 = sub_100070AC8();
          _NRLogWithArgs(v116, 16, "%s%.30s:%-4d ABORTING: posix_memalign(..., %zu, %zu) failed", "", "strict_memalign", 183, 8uLL, v9);

        }
        v7 = (char *)_os_log_pack_size(32);
        a1 = (char *)block - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
        v117 = __error();
        v101 = _os_log_pack_fill(a1, v7, *v117, &_mh_execute_header, "%{public}s posix_memalign(..., %zu, %zu) failed");
        *(_DWORD *)v101 = 136446722;
        *(_QWORD *)(v101 + 4) = "strict_memalign";
        goto LABEL_87;
      }
      *(void **)(a1 + 1895) = memptr[0];
    }
    a1[258] = 10;
    v71 = a1[258];
    if (!a1[258])
    {
LABEL_53:

LABEL_6:
      v9 = *(unsigned int *)(a1 + 267);
      if ((_DWORD)v9)
      {
        v2 = (uint64_t)block;
        v10 = malloc_type_calloc(1uLL, *(unsigned int *)(a1 + 267), 0xF1748037uLL);
        if (!v10)
        {
          v94 = sub_100070AC8();
          v95 = _NRLogIsLevelEnabled(v94, 16);

          if (v95)
          {
            v96 = sub_100070AC8();
            _NRLogWithArgs(v96, 16, "%s%.30s:%-4d ABORTING: strict_calloc(%zu, %zu) failed", "", "strict_calloc", 108, 1uLL, v9);

          }
LABEL_73:
          v7 = (char *)_os_log_pack_size(32);
          a1 = (char *)block - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
          v100 = __error();
          v101 = _os_log_pack_fill(a1, v7, *v100, &_mh_execute_header, "%{public}s strict_calloc(%zu, %zu) failed");
          *(_DWORD *)v101 = 136446722;
          *(_QWORD *)(v101 + 4) = "strict_calloc";
          *(_WORD *)(v101 + 12) = 2048;
          v102 = 1;
LABEL_74:
          *(_QWORD *)(v101 + 14) = v102;
          *(_WORD *)(v101 + 22) = 2048;
          *(_QWORD *)(v101 + 24) = v9;
          goto LABEL_78;
        }
        *(_QWORD *)(a1 + 1319) = v10;
        *(_DWORD *)(a1 + 323) = 0;
        *(_DWORD *)(a1 + 319) = 0;
        v9 = *(unsigned int *)(a1 + 283);
        if ((_DWORD)v9)
        {
          v2 = (uint64_t)block;
          v11 = malloc_type_calloc(1uLL, *(unsigned int *)(a1 + 283), 0xF1748037uLL);
          if (v11)
          {
            *(_QWORD *)(a1 + 1191) = v11;
            *(_DWORD *)(a1 + 299) = 0;
            *(_DWORD *)(a1 + 303) = 0;
            v12 = a1[208];
            v9 = a1;
            v13 = (char *)malloc_type_malloc(0x21uLL, 0xA172743EuLL);
            if (v13)
            {
              v2 = (uint64_t)v13;
              *(_QWORD *)v13 = 0x53554E494D524554;
              v13[8] = 1;
              v13[9] = v12;
              *((_WORD *)v13 + 5) = 4864;
              v13[12] = 4;
              *(_WORD *)(v13 + 13) = 4096;
              memptr[0] = 0;
              memptr[1] = 0;
              objc_msgSend(*(id *)(v9 + 1359), "getUUIDBytes:", memptr);
              *(_OWORD *)(v2 + 15) = *(_OWORD *)memptr;
              *(_WORD *)(v2 + 31) = ~(unsigned __int16)os_inet_checksum(v2, 31, 0);

              if (*(_DWORD *)(v9 + 283) > 0x20u)
              {
                v14 = *(_QWORD *)(v9 + 1191);
                v15 = *(_BYTE *)(v2 + 32);
                v16 = *(_OWORD *)(v2 + 16);
                *(_OWORD *)v14 = *(_OWORD *)v2;
                *(_OWORD *)(v14 + 16) = v16;
                *(_BYTE *)(v14 + 32) = v15;
                free((void *)v2);
                *(_DWORD *)(v9 + 299) += 33;
                v2 = (uint64_t)objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", *(_QWORD *)(v9 + 1191), 33);
                if (!gNRPacketLoggingEnabled)
                {
LABEL_13:
                  if (*(_BYTE *)(v9 + 246))
                    sub_10007118C(v9, (void *)v2, &off_1001C46F0);
                  v18 = *(NSObject **)(v9 + 8);
                  block[0] = _NSConcreteStackBlock;
                  block[1] = 3221225472;
                  block[2] = sub_100083B40;
                  block[3] = &unk_1001B8778;
                  block[4] = v9;
                  v128 = v7;
                  dispatch_async(v18, block);

LABEL_21:
                  v22 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)a1 + 4), v19);
                  v23 = _NRLogIsLevelEnabled(v22, 1);

                  if (v23)
                  {
                    v25 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)a1 + 4), v24);
                    v26 = objc_msgSend(a1, "copyDescription");
                    _NRLogWithArgs(v25, 1, "%s%.30s:%-4d %@: Updating urgent pipe: %@ -> %@", "", "-[NRLinkBluetooth updateUrgentPipe:]", 2623, v26, *(_QWORD *)(a1 + 1111), v7);

                  }
                  objc_storeStrong((id *)(a1 + 1111), v3);
                  if (!*(_QWORD *)(a1 + 1111) && a1[246])
                    sub_100083C98((uint64_t)a1, &off_1001C46F0);
                  goto LABEL_29;
                }
LABEL_79:
                v109 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v9 + 32), v17);
                v110 = _NRLogIsLevelEnabled(v109, 1);

                if (v110)
                {
                  v112 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v9 + 32), v111);
                  v113 = objc_msgSend((id)v9, "copyDescription");
                  _NRLogWithArgs(v112, 1, "%s%.30s:%-4d %@: UrgentLink:sending urgent prelude: %@", "", "-[NRLinkBluetooth updateUrgentPipe:]", 2581, v113, v2);

                }
                goto LABEL_13;
              }
              v122 = sub_100070AC8();
              v123 = _NRLogIsLevelEnabled(v122, 16);

              if (v123)
              {
                v124 = sub_100070AC8();
                _NRLogWithArgs(v124, 16, "%s%.30s:%-4d ABORTING: well this is absurd & urgent %u", "", "-[NRLinkBluetooth updateUrgentPipe:]", 2574, 33);

              }
              v7 = (char *)_os_log_pack_size(18);
              a1 = (char *)block - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
              v125 = __error();
              v126 = _os_log_pack_fill(a1, v7, *v125, &_mh_execute_header, "%{public}s well this is absurd & urgent %u");
              *(_DWORD *)v126 = 136446466;
              *(_QWORD *)(v126 + 4) = "-[NRLinkBluetooth updateUrgentPipe:]";
              *(_WORD *)(v126 + 12) = 1024;
              *(_DWORD *)(v126 + 14) = 33;
            }
            else
            {
              v103 = sub_100070AC8();
              v104 = _NRLogIsLevelEnabled(v103, 16);

              v3 = "strict_malloc";
              if (v104)
              {
                v105 = sub_100070AC8();
                _NRLogWithArgs(v105, 16, "%s%.30s:%-4d ABORTING: strict_malloc(%zu) failed", "", "strict_malloc", 79, 0x21uLL);

              }
              v7 = (char *)_os_log_pack_size(22);
              a1 = (char *)block - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
              v106 = __error();
              v107 = _os_log_pack_fill(a1, v7, *v106, &_mh_execute_header, "%{public}s strict_malloc(%zu) failed");
              *(_DWORD *)v107 = 136446466;
              *(_QWORD *)(v107 + 4) = "strict_malloc";
              *(_WORD *)(v107 + 12) = 2048;
              *(_QWORD *)(v107 + 14) = 33;
            }
LABEL_78:
            v108 = sub_100070AC8();
            _NRLogAbortWithPack(v108, a1);
            goto LABEL_79;
          }
          v97 = sub_100070AC8();
          v98 = _NRLogIsLevelEnabled(v97, 16);

          v3 = "strict_calloc";
          if (v98)
          {
            v99 = sub_100070AC8();
            _NRLogWithArgs(v99, 16, "%s%.30s:%-4d ABORTING: strict_calloc(%zu, %zu) failed", "", "strict_calloc", 108, 1uLL, v9);

          }
          goto LABEL_73;
        }
      }
      v89 = sub_100070AC8();
      v90 = _NRLogIsLevelEnabled(v89, 16);

      if (v90)
      {
        v91 = sub_100070AC8();
        _NRLogWithArgs(v91, 16, "%s%.30s:%-4d ABORTING: strict_calloc called with size 0", "", "strict_calloc", 100);

      }
      v7 = (char *)_os_log_pack_size(12);
      a1 = (char *)block - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
      v92 = __error();
      v93 = _os_log_pack_fill(a1, v7, *v92, &_mh_execute_header, "%{public}s strict_calloc called with size 0");
      *(_DWORD *)v93 = 136446210;
      *(_QWORD *)(v93 + 4) = "strict_calloc";
      goto LABEL_78;
    }
    v2 = (uint64_t)block;
    v9 = 8 * v71;
    memptr[0] = 0;
    if (!malloc_type_posix_memalign(memptr, 8uLL, 8 * v71, 0xD5FEC036uLL) && memptr[0])
    {
      *(void **)(a1 + 1943) = memptr[0];
      goto LABEL_53;
    }
    v118 = sub_100070AC8();
    v119 = _NRLogIsLevelEnabled(v118, 16);

    if (v119)
    {
      v120 = sub_100070AC8();
      _NRLogWithArgs(v120, 16, "%s%.30s:%-4d ABORTING: posix_memalign(..., %zu, %zu) failed", "", "strict_memalign", 183, 8uLL, v9);

    }
    v7 = (char *)_os_log_pack_size(32);
    a1 = (char *)block - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
    v121 = __error();
    v101 = _os_log_pack_fill(a1, v7, *v121, &_mh_execute_header, "%{public}s posix_memalign(..., %zu, %zu) failed");
    *(_DWORD *)v101 = 136446722;
    *(_QWORD *)(v101 + 4) = "strict_memalign";
LABEL_87:
    *(_WORD *)(v101 + 12) = 2048;
    v102 = 8;
    goto LABEL_74;
  }
  v84 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)a1 + 4), v67);
  v85 = _NRLogIsLevelEnabled(v84, 17);

  if (v85)
  {
    v87 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)a1 + 4), v86);
    v88 = objc_msgSend(a1, "copyDescription");
    _NRLogWithArgs(v87, 17, "%@: _dUrgentLinkOutputSource is NULL", v88);

  }
LABEL_29:

}

void sub_100082348(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  void *v4;
  NSObject *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  int IsLevelEnabled;
  uint64_t v13;
  void *v14;
  id v15;
  void *v16;
  int v17;
  uint64_t v18;
  void *v19;
  id v20;
  void *v21;
  int v22;
  uint64_t v23;
  void *v24;
  id v25;
  void *v26;
  int v27;
  uint64_t v28;
  void *v29;
  id v30;

  v3 = *(NSObject **)(a1 + 1143);
  if (v3)
  {
    if (*(_BYTE *)(a1 + 227))
    {
      *(_BYTE *)(a1 + 227) = 0;
      ++*(_QWORD *)(a1 + 1159);
      if (gNRPacketLoggingEnabled)
      {
        v11 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
        IsLevelEnabled = _NRLogIsLevelEnabled(v11, 1);

        if (IsLevelEnabled)
        {
          v14 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v13);
          v15 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v14, 1, "%s%.30s:%-4d %@: source-resume: UrgentLinkInput", "", "NRLinkResumeUrgentLinkInputSource", 826, v15);

        }
      }
      dispatch_resume(*(dispatch_object_t *)(a1 + 1143));
      v3 = *(NSObject **)(a1 + 1143);
    }
    dispatch_source_cancel(v3);
    v4 = *(void **)(a1 + 1143);
    *(_QWORD *)(a1 + 1143) = 0;

  }
  v5 = *(NSObject **)(a1 + 1151);
  if (v5)
  {
    if (*(_BYTE *)(a1 + 228))
    {
      *(_BYTE *)(a1 + 228) = 0;
      ++*(_QWORD *)(a1 + 1167);
      if (gNRPacketLoggingEnabled)
      {
        v16 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
        v17 = _NRLogIsLevelEnabled(v16, 1);

        if (v17)
        {
          v19 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v18);
          v20 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v19, 1, "%s%.30s:%-4d %@: source-resume: UrgentLinkOutput", "", "NRLinkResumeUrgentLinkOutputSource", 827, v20);

        }
      }
      dispatch_resume(*(dispatch_object_t *)(a1 + 1151));
      v5 = *(NSObject **)(a1 + 1151);
    }
    dispatch_source_cancel(v5);
    v6 = *(void **)(a1 + 1151);
    *(_QWORD *)(a1 + 1151) = 0;

  }
  if (*(_BYTE *)(a1 + 216) && *(_QWORD *)(a1 + 695))
  {
    *(_BYTE *)(a1 + 216) = 0;
    ++*(_QWORD *)(a1 + 711);
    if (gNRPacketLoggingEnabled)
    {
      v21 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
      v22 = _NRLogIsLevelEnabled(v21, 1);

      if (v22)
      {
        v24 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v23);
        v25 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v24, 1, "%s%.30s:%-4d %@: source-resume: NexusVIInput", "", "NRLinkResumeNexusVIInputSource", 846, v25);

      }
    }
    dispatch_resume(*(dispatch_object_t *)(a1 + 695));
  }
  if (*(_BYTE *)(a1 + 214) && *(_QWORD *)(a1 + 551))
  {
    *(_BYTE *)(a1 + 214) = 0;
    ++*(_QWORD *)(a1 + 567);
    if (gNRPacketLoggingEnabled)
    {
      v26 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
      v27 = _NRLogIsLevelEnabled(v26, 1);

      if (v27)
      {
        v29 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v28);
        v30 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v29, 1, "%s%.30s:%-4d %@: source-resume: NexusVOInput", "", "NRLinkResumeNexusVOInputSource", 844, v30);

      }
    }
    dispatch_resume(*(dispatch_object_t *)(a1 + 551));
  }
  *(_QWORD *)(a1 + 1119) = 0;
  *(_QWORD *)(a1 + 1135) = 0;
  *(_QWORD *)(a1 + 1127) = 0;
  *(_BYTE *)(a1 + 229) = 0;
  *(_QWORD *)(a1 + 1159) = 0;
  *(_QWORD *)(a1 + 1167) = 0;
  v7 = *(void **)(a1 + 1895);
  if (v7)
  {
    free(v7);
    *(_QWORD *)(a1 + 1895) = 0;
  }
  v8 = *(void **)(a1 + 1943);
  if (v8)
  {
    free(v8);
    *(_QWORD *)(a1 + 1943) = 0;
  }
  v9 = *(void **)(a1 + 1319);
  if (v9)
  {
    free(v9);
    *(_QWORD *)(a1 + 1319) = 0;
  }
  *(_DWORD *)(a1 + 323) = 0;
  *(_DWORD *)(a1 + 319) = 0;
  v10 = *(void **)(a1 + 1191);
  if (v10)
  {
    free(v10);
    *(_QWORD *)(a1 + 1191) = 0;
  }
  *(_DWORD *)(a1 + 323) = 0;
  *(_DWORD *)(a1 + 299) = 0;
}

uint64_t sub_1000827B0(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  int IsLevelEnabled;
  uint64_t v9;
  void *v10;
  id v11;
  int v12;
  uint64_t v13;
  void *v14;
  id v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  void *v24;
  id v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  int v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  void *v34;
  id v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  void *v39;
  int v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  void *v44;
  id v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  void *v49;
  int v50;
  uint64_t v51;
  int v52;
  uint64_t v53;
  void *v54;
  id v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  void *v59;
  int v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  void *v64;
  id v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  void *v69;
  int v70;
  uint64_t v71;
  int v72;
  uint64_t v73;
  void *v74;
  id v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  void *v79;
  int v80;
  uint64_t v81;
  int v82;
  uint64_t v83;
  void *v84;
  id v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  void *v89;
  int v90;
  uint64_t v91;
  int v92;
  uint64_t v93;
  void *v94;
  id v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  void *v99;
  int v100;
  uint64_t v101;
  int v102;
  uint64_t v103;
  void *v104;
  id v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  void *v109;
  int v110;
  uint64_t v111;
  int v112;
  uint64_t v113;
  void *v114;
  id v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  void *v119;
  int v120;
  uint64_t v121;
  int v122;
  uint64_t v123;
  void *v124;
  id v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  void *v129;
  int v130;
  uint64_t v131;
  int v132;
  uint64_t v133;
  void *v134;
  id v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  void *v139;
  int v140;
  uint64_t v141;
  int v142;
  uint64_t v143;
  void *v144;
  id v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  void *v149;
  int v150;
  uint64_t v151;
  int v152;
  uint64_t v153;
  void *v154;
  id v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  void *v159;
  int v160;
  uint64_t v161;
  int v162;
  uint64_t v163;
  void *v164;
  id v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  void *v169;
  int v170;
  uint64_t v171;
  int v172;
  uint64_t v173;
  void *v174;
  id v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  void *v179;
  int v180;
  uint64_t v181;
  int v183;
  uint64_t v184;
  void *v185;
  id v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  void *v190;
  int v191;
  uint64_t v192;
  void *v193;
  id v194;
  int v195;
  uint64_t v196;
  void *v197;
  id v198;
  uint64_t v199;

  v199 = 0;
  v4 = os_channel_attr_get(a2, 0, &v199);
  v6 = _NRCopyLogObjectForNRUUID(a1[4], v5);
  v7 = (void *)v6;
  if ((_DWORD)v4)
  {
    IsLevelEnabled = _NRLogIsLevelEnabled(v6, 17);

    if (IsLevelEnabled)
    {
      v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v9);
      v11 = objc_msgSend(a1, "copyDescription");
      _NRLogWithArgs(v10, 17, "%@: os_channel_attr_get(TX_RINGS) returned %d", v11, v4);
LABEL_89:

      return 0;
    }
    return 0;
  }
  v12 = _NRLogIsLevelEnabled(v6, 2);

  if (v12)
  {
    v14 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v13);
    v15 = objc_msgSend(a1, "copyDescription");
    _NRLogWithArgs(v14, 2, "%s%.30s:%-4d %@: Nexus Channel TX_RINGS = %llu", "", "-[NRLinkBluetooth validateChannelAttributes:]", 1880, v15, v199);

  }
  v199 = 0;
  v16 = os_channel_attr_get(a2, 1, &v199);
  v18 = _NRCopyLogObjectForNRUUID(a1[4], v17);
  v19 = (void *)v18;
  if ((_DWORD)v16)
  {
    v20 = _NRLogIsLevelEnabled(v18, 17);

    if (v20)
    {
      v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v21);
      v11 = objc_msgSend(a1, "copyDescription");
      _NRLogWithArgs(v10, 17, "%@: os_channel_attr_get(RX_RINGS) returned %d", v11, v16);
      goto LABEL_89;
    }
    return 0;
  }
  v22 = _NRLogIsLevelEnabled(v18, 2);

  if (v22)
  {
    v24 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v23);
    v25 = objc_msgSend(a1, "copyDescription");
    _NRLogWithArgs(v24, 2, "%s%.30s:%-4d %@: Nexus Channel RX_RINGS = %llu", "", "-[NRLinkBluetooth validateChannelAttributes:]", 1881, v25, v199);

  }
  v199 = 0;
  v26 = os_channel_attr_get(a2, 2, &v199);
  v28 = _NRCopyLogObjectForNRUUID(a1[4], v27);
  v29 = (void *)v28;
  if ((_DWORD)v26)
  {
    v30 = _NRLogIsLevelEnabled(v28, 17);

    if (v30)
    {
      v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v31);
      v11 = objc_msgSend(a1, "copyDescription");
      _NRLogWithArgs(v10, 17, "%@: os_channel_attr_get(TX_SLOTS) returned %d", v11, v26);
      goto LABEL_89;
    }
    return 0;
  }
  v32 = _NRLogIsLevelEnabled(v28, 2);

  if (v32)
  {
    v34 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v33);
    v35 = objc_msgSend(a1, "copyDescription");
    _NRLogWithArgs(v34, 2, "%s%.30s:%-4d %@: Nexus Channel TX_SLOTS = %llu", "", "-[NRLinkBluetooth validateChannelAttributes:]", 1882, v35, v199);

  }
  v199 = 0;
  v36 = os_channel_attr_get(a2, 3, &v199);
  v38 = _NRCopyLogObjectForNRUUID(a1[4], v37);
  v39 = (void *)v38;
  if ((_DWORD)v36)
  {
    v40 = _NRLogIsLevelEnabled(v38, 17);

    if (v40)
    {
      v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v41);
      v11 = objc_msgSend(a1, "copyDescription");
      _NRLogWithArgs(v10, 17, "%@: os_channel_attr_get(RX_SLOTS) returned %d", v11, v36);
      goto LABEL_89;
    }
    return 0;
  }
  v42 = _NRLogIsLevelEnabled(v38, 2);

  if (v42)
  {
    v44 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v43);
    v45 = objc_msgSend(a1, "copyDescription");
    _NRLogWithArgs(v44, 2, "%s%.30s:%-4d %@: Nexus Channel RX_SLOTS = %llu", "", "-[NRLinkBluetooth validateChannelAttributes:]", 1883, v45, v199);

  }
  v199 = 0;
  v46 = os_channel_attr_get(a2, 4, &v199);
  v48 = _NRCopyLogObjectForNRUUID(a1[4], v47);
  v49 = (void *)v48;
  if ((_DWORD)v46)
  {
    v50 = _NRLogIsLevelEnabled(v48, 17);

    if (v50)
    {
      v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v51);
      v11 = objc_msgSend(a1, "copyDescription");
      _NRLogWithArgs(v10, 17, "%@: os_channel_attr_get(SLOT_BUF_SIZE) returned %d", v11, v46);
      goto LABEL_89;
    }
    return 0;
  }
  v52 = _NRLogIsLevelEnabled(v48, 2);

  if (v52)
  {
    v54 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v53);
    v55 = objc_msgSend(a1, "copyDescription");
    _NRLogWithArgs(v54, 2, "%s%.30s:%-4d %@: Nexus Channel SLOT_BUF_SIZE = %llu", "", "-[NRLinkBluetooth validateChannelAttributes:]", 1884, v55, v199);

  }
  v199 = 0;
  v56 = os_channel_attr_get(a2, 5, &v199);
  v58 = _NRCopyLogObjectForNRUUID(a1[4], v57);
  v59 = (void *)v58;
  if ((_DWORD)v56)
  {
    v60 = _NRLogIsLevelEnabled(v58, 17);

    if (v60)
    {
      v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v61);
      v11 = objc_msgSend(a1, "copyDescription");
      _NRLogWithArgs(v10, 17, "%@: os_channel_attr_get(SLOT_META_SIZE) returned %d", v11, v56);
      goto LABEL_89;
    }
    return 0;
  }
  v62 = _NRLogIsLevelEnabled(v58, 2);

  if (v62)
  {
    v64 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v63);
    v65 = objc_msgSend(a1, "copyDescription");
    _NRLogWithArgs(v64, 2, "%s%.30s:%-4d %@: Nexus Channel SLOT_META_SIZE = %llu", "", "-[NRLinkBluetooth validateChannelAttributes:]", 1885, v65, v199);

  }
  v199 = 0;
  v66 = os_channel_attr_get(a2, 6, &v199);
  v68 = _NRCopyLogObjectForNRUUID(a1[4], v67);
  v69 = (void *)v68;
  if ((_DWORD)v66)
  {
    v70 = _NRLogIsLevelEnabled(v68, 17);

    if (v70)
    {
      v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v71);
      v11 = objc_msgSend(a1, "copyDescription");
      _NRLogWithArgs(v10, 17, "%@: os_channel_attr_get(EXCLUSIVE) returned %d", v11, v66);
      goto LABEL_89;
    }
    return 0;
  }
  v72 = _NRLogIsLevelEnabled(v68, 2);

  if (v72)
  {
    v74 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v73);
    v75 = objc_msgSend(a1, "copyDescription");
    _NRLogWithArgs(v74, 2, "%s%.30s:%-4d %@: Nexus Channel EXCLUSIVE = %llu", "", "-[NRLinkBluetooth validateChannelAttributes:]", 1886, v75, v199);

  }
  v199 = 0;
  v76 = os_channel_attr_get(a2, 7, &v199);
  v78 = _NRCopyLogObjectForNRUUID(a1[4], v77);
  v79 = (void *)v78;
  if ((_DWORD)v76)
  {
    v80 = _NRLogIsLevelEnabled(v78, 17);

    if (v80)
    {
      v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v81);
      v11 = objc_msgSend(a1, "copyDescription");
      _NRLogWithArgs(v10, 17, "%@: os_channel_attr_get(NO_AUTO_SYNC) returned %d", v11, v76);
      goto LABEL_89;
    }
    return 0;
  }
  v82 = _NRLogIsLevelEnabled(v78, 2);

  if (v82)
  {
    v84 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v83);
    v85 = objc_msgSend(a1, "copyDescription");
    _NRLogWithArgs(v84, 2, "%s%.30s:%-4d %@: Nexus Channel NO_AUTO_SYNC = %llu", "", "-[NRLinkBluetooth validateChannelAttributes:]", 1887, v85, v199);

  }
  v199 = 0;
  v86 = os_channel_attr_get(a2, 8, &v199);
  v88 = _NRCopyLogObjectForNRUUID(a1[4], v87);
  v89 = (void *)v88;
  if ((_DWORD)v86)
  {
    v90 = _NRLogIsLevelEnabled(v88, 17);

    if (v90)
    {
      v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v91);
      v11 = objc_msgSend(a1, "copyDescription");
      _NRLogWithArgs(v10, 17, "%@: os_channel_attr_get(MONITOR) returned %d", v11, v86);
      goto LABEL_89;
    }
    return 0;
  }
  v92 = _NRLogIsLevelEnabled(v88, 2);

  if (v92)
  {
    v94 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v93);
    v95 = objc_msgSend(a1, "copyDescription");
    _NRLogWithArgs(v94, 2, "%s%.30s:%-4d %@: Nexus Channel MONITOR = %llu", "", "-[NRLinkBluetooth validateChannelAttributes:]", 1888, v95, v199);

  }
  v199 = 0;
  v96 = os_channel_attr_get(a2, 9, &v199);
  v98 = _NRCopyLogObjectForNRUUID(a1[4], v97);
  v99 = (void *)v98;
  if ((_DWORD)v96)
  {
    v100 = _NRLogIsLevelEnabled(v98, 17);

    if (v100)
    {
      v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v101);
      v11 = objc_msgSend(a1, "copyDescription");
      _NRLogWithArgs(v10, 17, "%@: os_channel_attr_get(TX_LOWAT_UNIT) returned %d", v11, v96);
      goto LABEL_89;
    }
    return 0;
  }
  v102 = _NRLogIsLevelEnabled(v98, 2);

  if (v102)
  {
    v104 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v103);
    v105 = objc_msgSend(a1, "copyDescription");
    _NRLogWithArgs(v104, 2, "%s%.30s:%-4d %@: Nexus Channel TX_LOWAT_UNIT = %llu", "", "-[NRLinkBluetooth validateChannelAttributes:]", 1889, v105, v199);

  }
  v199 = 0;
  v106 = os_channel_attr_get(a2, 10, &v199);
  v108 = _NRCopyLogObjectForNRUUID(a1[4], v107);
  v109 = (void *)v108;
  if ((_DWORD)v106)
  {
    v110 = _NRLogIsLevelEnabled(v108, 17);

    if (v110)
    {
      v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v111);
      v11 = objc_msgSend(a1, "copyDescription");
      _NRLogWithArgs(v10, 17, "%@: os_channel_attr_get(TX_LOWAT_VALUE) returned %d", v11, v106);
      goto LABEL_89;
    }
    return 0;
  }
  v112 = _NRLogIsLevelEnabled(v108, 2);

  if (v112)
  {
    v114 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v113);
    v115 = objc_msgSend(a1, "copyDescription");
    _NRLogWithArgs(v114, 2, "%s%.30s:%-4d %@: Nexus Channel TX_LOWAT_VALUE = %llu", "", "-[NRLinkBluetooth validateChannelAttributes:]", 1890, v115, v199);

  }
  v199 = 0;
  v116 = os_channel_attr_get(a2, 11, &v199);
  v118 = _NRCopyLogObjectForNRUUID(a1[4], v117);
  v119 = (void *)v118;
  if ((_DWORD)v116)
  {
    v120 = _NRLogIsLevelEnabled(v118, 17);

    if (v120)
    {
      v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v121);
      v11 = objc_msgSend(a1, "copyDescription");
      _NRLogWithArgs(v10, 17, "%@: os_channel_attr_get(RX_LOWAT_UNIT) returned %d", v11, v116);
      goto LABEL_89;
    }
    return 0;
  }
  v122 = _NRLogIsLevelEnabled(v118, 2);

  if (v122)
  {
    v124 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v123);
    v125 = objc_msgSend(a1, "copyDescription");
    _NRLogWithArgs(v124, 2, "%s%.30s:%-4d %@: Nexus Channel RX_LOWAT_UNIT = %llu", "", "-[NRLinkBluetooth validateChannelAttributes:]", 1891, v125, v199);

  }
  v199 = 0;
  v126 = os_channel_attr_get(a2, 12, &v199);
  v128 = _NRCopyLogObjectForNRUUID(a1[4], v127);
  v129 = (void *)v128;
  if ((_DWORD)v126)
  {
    v130 = _NRLogIsLevelEnabled(v128, 17);

    if (v130)
    {
      v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v131);
      v11 = objc_msgSend(a1, "copyDescription");
      _NRLogWithArgs(v10, 17, "%@: os_channel_attr_get(RX_LOWAT_VALUE) returned %d", v11, v126);
      goto LABEL_89;
    }
    return 0;
  }
  v132 = _NRLogIsLevelEnabled(v128, 2);

  if (v132)
  {
    v134 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v133);
    v135 = objc_msgSend(a1, "copyDescription");
    _NRLogWithArgs(v134, 2, "%s%.30s:%-4d %@: Nexus Channel RX_LOWAT_VALUE = %llu", "", "-[NRLinkBluetooth validateChannelAttributes:]", 1892, v135, v199);

  }
  v199 = 0;
  v136 = os_channel_attr_get(a2, 13, &v199);
  v138 = _NRCopyLogObjectForNRUUID(a1[4], v137);
  v139 = (void *)v138;
  if ((_DWORD)v136)
  {
    v140 = _NRLogIsLevelEnabled(v138, 17);

    if (v140)
    {
      v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v141);
      v11 = objc_msgSend(a1, "copyDescription");
      _NRLogWithArgs(v10, 17, "%@: os_channel_attr_get(NEXUS_TYPE) returned %d", v11, v136);
      goto LABEL_89;
    }
    return 0;
  }
  v142 = _NRLogIsLevelEnabled(v138, 2);

  if (v142)
  {
    v144 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v143);
    v145 = objc_msgSend(a1, "copyDescription");
    _NRLogWithArgs(v144, 2, "%s%.30s:%-4d %@: Nexus Channel NEXUS_TYPE = %llu", "", "-[NRLinkBluetooth validateChannelAttributes:]", 1893, v145, v199);

  }
  v199 = 0;
  v146 = os_channel_attr_get(a2, 14, &v199);
  v148 = _NRCopyLogObjectForNRUUID(a1[4], v147);
  v149 = (void *)v148;
  if ((_DWORD)v146)
  {
    v150 = _NRLogIsLevelEnabled(v148, 17);

    if (v150)
    {
      v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v151);
      v11 = objc_msgSend(a1, "copyDescription");
      _NRLogWithArgs(v10, 17, "%@: os_channel_attr_get(NEXUS_EXTENSIONS) returned %d", v11, v146);
      goto LABEL_89;
    }
    return 0;
  }
  v152 = _NRLogIsLevelEnabled(v148, 2);

  if (v152)
  {
    v154 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v153);
    v155 = objc_msgSend(a1, "copyDescription");
    _NRLogWithArgs(v154, 2, "%s%.30s:%-4d %@: Nexus Channel NEXUS_EXTENSIONS = %llu", "", "-[NRLinkBluetooth validateChannelAttributes:]", 1894, v155, v199);

  }
  v199 = 0;
  v156 = os_channel_attr_get(a2, 15, &v199);
  v158 = _NRCopyLogObjectForNRUUID(a1[4], v157);
  v159 = (void *)v158;
  if ((_DWORD)v156)
  {
    v160 = _NRLogIsLevelEnabled(v158, 17);

    if (v160)
    {
      v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v161);
      v11 = objc_msgSend(a1, "copyDescription");
      _NRLogWithArgs(v10, 17, "%@: os_channel_attr_get(NEXUS_MHINTS) returned %d", v11, v156);
      goto LABEL_89;
    }
    return 0;
  }
  v162 = _NRLogIsLevelEnabled(v158, 2);

  if (v162)
  {
    v164 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v163);
    v165 = objc_msgSend(a1, "copyDescription");
    _NRLogWithArgs(v164, 2, "%s%.30s:%-4d %@: Nexus Channel NEXUS_MHINTS = %llu", "", "-[NRLinkBluetooth validateChannelAttributes:]", 1895, v165, v199);

  }
  v199 = 0;
  v166 = os_channel_attr_get(a2, 18, &v199);
  v168 = _NRCopyLogObjectForNRUUID(a1[4], v167);
  v169 = (void *)v168;
  if ((_DWORD)v166)
  {
    v170 = _NRLogIsLevelEnabled(v168, 17);

    if (v170)
    {
      v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v171);
      v11 = objc_msgSend(a1, "copyDescription");
      _NRLogWithArgs(v10, 17, "%@: os_channel_attr_get(NEXUS_IFINDEX) returned %d", v11, v166);
      goto LABEL_89;
    }
    return 0;
  }
  v172 = _NRLogIsLevelEnabled(v168, 2);

  if (v172)
  {
    v174 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v173);
    v175 = objc_msgSend(a1, "copyDescription");
    _NRLogWithArgs(v174, 2, "%s%.30s:%-4d %@: Nexus Channel NEXUS_IFINDEX = %llu", "", "-[NRLinkBluetooth validateChannelAttributes:]", 1896, v175, v199);

  }
  v199 = 0;
  v176 = os_channel_attr_get(a2, 19, &v199);
  v178 = _NRCopyLogObjectForNRUUID(a1[4], v177);
  v179 = (void *)v178;
  if ((_DWORD)v176)
  {
    v180 = _NRLogIsLevelEnabled(v178, 17);

    if (v180)
    {
      v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v181);
      v11 = objc_msgSend(a1, "copyDescription");
      _NRLogWithArgs(v10, 17, "%@: os_channel_attr_get(NEXUS_STATS_SIZE) returned %d", v11, v176);
      goto LABEL_89;
    }
    return 0;
  }
  v183 = _NRLogIsLevelEnabled(v178, 2);

  if (v183)
  {
    v185 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v184);
    v186 = objc_msgSend(a1, "copyDescription");
    _NRLogWithArgs(v185, 2, "%s%.30s:%-4d %@: Nexus Channel NEXUS_STATS_SIZE = %llu", "", "-[NRLinkBluetooth validateChannelAttributes:]", 1897, v186, v199);

  }
  v199 = 0;
  v187 = os_channel_attr_get(a2, 20, &v199);
  v189 = _NRCopyLogObjectForNRUUID(a1[4], v188);
  v190 = (void *)v189;
  if ((_DWORD)v187)
  {
    v191 = _NRLogIsLevelEnabled(v189, 17);

    if (v191)
    {
      v193 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v192);
      v194 = objc_msgSend(a1, "copyDescription");
      _NRLogWithArgs(v193, 17, "%@: os_channel_attr_get(NEXUS_FLOWADV_MAX) returned %d", v194, v187);

    }
    return 0;
  }
  v195 = _NRLogIsLevelEnabled(v189, 2);

  if (v195)
  {
    v197 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v196);
    v198 = objc_msgSend(a1, "copyDescription");
    _NRLogWithArgs(v197, 2, "%s%.30s:%-4d %@: Nexus Channel NEXUS_FLOWADV_MAX = %llu", "", "-[NRLinkBluetooth validateChannelAttributes:]", 1898, v198, v199);

  }
  return 1;
}

void sub_100083780(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  void *v5;
  int IsLevelEnabled;
  uint64_t v7;
  id v8;
  void *v9;
  int v10;
  uint64_t v11;
  void *v12;
  id v13;
  void *v14;
  int v15;
  uint64_t v16;
  void *v17;
  id v18;
  id v19;

  v3 = *(_QWORD *)(a1 + 32);
  if (*(unsigned __int8 *)(v3 + 16) == 255)
  {
    v5 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), a2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v5, 16);

    if (IsLevelEnabled)
    {
      v19 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v7);
      v8 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
      _NRLogWithArgs(v19, 16, "%s%.30s:%-4d %@: Urgent link input available but cancelled", "", "-[NRLinkBluetooth updateUrgentPipe:]_block_invoke", 2510, v8);

    }
  }
  else
  {
    ++*(_QWORD *)(v3 + 1503);
    v4 = *(_QWORD *)(a1 + 32);
    if (*(_BYTE *)(v4 + 229))
    {
      if (gNRPacketLoggingEnabled)
      {
        v14 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), a2);
        v15 = _NRLogIsLevelEnabled(v14, 1);

        v4 = *(_QWORD *)(a1 + 32);
        if (v15)
        {
          v17 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v16);
          v18 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
          _NRLogWithArgs(v17, 1, "%s%.30s:%-4d %@: Urgent link input available after prelude", "", "-[NRLinkBluetooth updateUrgentPipe:]_block_invoke", 2518, v18);

          v4 = *(_QWORD *)(a1 + 32);
        }
      }
      sub_100086FF4((void *)v4);
    }
    else
    {
      v9 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), a2);
      v10 = _NRLogIsLevelEnabled(v9, 1);

      if (v10)
      {
        v12 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v11);
        v13 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
        _NRLogWithArgs(v12, 1, "%s%.30s:%-4d %@: Urgent link input available before prelude", "", "-[NRLinkBluetooth updateUrgentPipe:]_block_invoke", 2515, v13);

      }
      sub_100086D44(*(_QWORD *)(a1 + 32), 1);
    }
  }
}

void sub_1000839A0(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  int IsLevelEnabled;
  uint64_t v6;
  id v7;
  void *v8;
  int v9;
  uint64_t v10;
  void *v11;
  id v12;
  id v13;

  v3 = *(_QWORD *)(a1 + 32);
  if (*(unsigned __int8 *)(v3 + 16) == 255)
  {
    v4 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), a2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v4, 16);

    if (IsLevelEnabled)
    {
      v13 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v6);
      v7 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
      _NRLogWithArgs(v13, 16, "%s%.30s:%-4d %@: Urgent link output available but cancelled", "", "-[NRLinkBluetooth updateUrgentPipe:]_block_invoke_3", 2538, v7);

    }
  }
  else
  {
    ++*(_QWORD *)(v3 + 1511);
    if (gNRPacketLoggingEnabled)
    {
      v8 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), a2);
      v9 = _NRLogIsLevelEnabled(v8, 1);

      if (v9)
      {
        v11 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v10);
        v12 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
        _NRLogWithArgs(v11, 1, "%s%.30s:%-4d %@: Urgent link output available", "", "-[NRLinkBluetooth updateUrgentPipe:]_block_invoke_3", 2542, v12);

      }
    }
    sub_100083E50(*(void **)(a1 + 32), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 527));
    sub_100083E50(*(void **)(a1 + 32), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 671));
  }
}

void sub_100083B40(uint64_t a1, uint64_t a2)
{
  void *v3;
  int IsLevelEnabled;
  uint64_t v5;
  void *v6;
  id v7;
  dispatch_time_t v8;
  NSObject *v9;
  _QWORD block[4];
  id v11;
  id v12;
  id location;

  v3 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), a2);
  IsLevelEnabled = _NRLogIsLevelEnabled(v3, 1);

  if (IsLevelEnabled)
  {
    v6 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v5);
    v7 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    _NRLogWithArgs(v6, 1, "%s%.30s:%-4d %@: NtL-U LOOP async start after async", "", "-[NRLinkBluetooth updateUrgentPipe:]_block_invoke", 2589, v7);

  }
  sub_100083E50(*(void **)(a1 + 32), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 671));
  objc_initWeak(&location, *(id *)(a1 + 32));
  v8 = dispatch_time(0x8000000000000000, 10000000000);
  v9 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 8);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100086C8C;
  block[3] = &unk_1001B87F0;
  objc_copyWeak(&v12, &location);
  v11 = *(id *)(a1 + 40);
  dispatch_after(v8, v9, block);

  objc_destroyWeak(&v12);
  objc_destroyWeak(&location);
}

void sub_100083C98(uint64_t a1, void *a2)
{
  id v3;
  id v4;
  id v5;
  void *v6;
  uint64_t v7;
  void *v8;
  id v9;
  void *v10;
  id v11;
  uint64_t v12;
  void *v13;
  int IsLevelEnabled;
  uint64_t v15;
  void *v16;
  id v17;
  id v18;

  v18 = a2;
  v3 = objc_alloc_init((Class)NSMutableDictionary);
  objc_msgSend(v3, "setObject:forKeyedSubscript:", v18, CFSTR("channel-id"));
  v4 = objc_alloc_init((Class)NSMutableDictionary);
  objc_msgSend(v4, "setObject:forKeyedSubscript:", v3, CFSTR("deactivate-datapath"));
  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v5 = (id)qword_1001E4708;
  v6 = v5;
  if (v5)
  {
    v7 = *(_QWORD *)(a1 + 32);
    v8 = (void *)*((_QWORD *)v5 + 25);
    v9 = v4;
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "objectForKeyedSubscript:", v7));
    sub_1000EF368((uint64_t)v10, v9);

  }
  v11 = objc_msgSend(v18, "integerValue");
  if (v11 == (id)3)
  {
    *(_BYTE *)(a1 + 249) = 0;
  }
  else if (v11 == (id)2)
  {
    *(_BYTE *)(a1 + 248) = 0;
  }
  else if (v11 == (id)1)
  {
    *(_BYTE *)(a1 + 247) = 0;
  }
  else
  {
    v13 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v12);
    IsLevelEnabled = _NRLogIsLevelEnabled(v13, 17);

    if (IsLevelEnabled)
    {
      v16 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v15);
      v17 = objc_msgSend((id)a1, "copyDescription");
      _NRLogWithArgs(v16, 17, "%@: unsupported channel id %@", v17, v18);

    }
  }

}

void sub_100083E50(void *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  int v7;
  uint64_t v8;
  void *v9;
  id v10;
  void *v11;
  int IsLevelEnabled;
  uint64_t v13;
  void *v14;
  int v15;
  uint64_t v16;
  int *v17;
  int *v18;
  int *v19;
  int *v20;
  void (*v21)(uint64_t, uint64_t);
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int *v25;
  uint64_t v26;
  uint64_t v27;
  id v28;
  uint64_t v29;
  uint64_t next_slot;
  uint64_t v31;
  uint64_t v32;
  BOOL v33;
  unsigned int DSCPFromPacket;
  _BOOL4 v35;
  _BOOL4 v36;
  uint64_t v37;
  uint64_t next_buflet;
  uint64_t data_limit;
  uint64_t v40;
  uint64_t v41;
  unsigned int v42;
  uint64_t v43;
  unsigned int v44;
  unsigned int v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  unsigned int v49;
  unsigned int v50;
  uint64_t v51;
  id v52;
  uint64_t v53;
  uint64_t v54;
  unsigned int *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unsigned int v60;
  int *v61;
  int v62;
  unsigned int v63;
  unsigned int v64;
  int v65;
  int *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unsigned int v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  void *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  unsigned int v85;
  id v86;
  int v87;
  unint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  unsigned int v93;
  int v94;
  void *v95;
  int v96;
  uint64_t v97;
  void *v98;
  id v99;
  uint64_t v100;
  uint64_t v101;
  _QWORD *v102;
  void *v103;
  int v104;
  void *v105;
  id v106;
  void *v107;
  int v108;
  void *v109;
  id v110;
  void *v111;
  int v112;
  uint64_t v113;
  void *v114;
  id v115;
  uint64_t v116;
  uint64_t v117;
  void *v118;
  int v119;
  uint64_t v120;
  void *v121;
  id v122;
  void *v123;
  int v124;
  uint64_t v125;
  void *v126;
  id v127;
  void *v128;
  int v129;
  uint64_t v130;
  void *v131;
  id v132;
  void *v133;
  int v134;
  uint64_t v135;
  void *v136;
  id v137;
  void *v138;
  uint64_t v139;
  void *v140;
  void *v141;
  int v142;
  uint64_t v143;
  void *v144;
  id v145;
  id v146;
  unsigned int v147;
  id v148;
  id v149;
  uint64_t v150;
  int v151;
  uint64_t v152;
  unsigned int v153;
  unsigned int v154;
  uint64_t v155;
  uint64_t v156;
  _QWORD *v157;
  void *v158;
  int v159;
  void *v160;
  id v161;
  void *v162;
  int v163;
  void *v164;
  id v165;
  void *v166;
  int v167;
  void *v168;
  id v169;
  void *v170;
  int v171;
  uint64_t v172;
  void *v173;
  id v174;
  uint64_t v175;
  void *v176;
  void *v177;
  int v178;
  void *v179;
  id v180;
  void *v181;
  int v182;
  uint64_t v183;
  void *v184;
  id v185;
  void *v186;
  int v187;
  uint64_t v188;
  void *v189;
  id v190;
  uint64_t v191;
  void *v192;
  void *v193;
  int v194;
  void *v195;
  id v196;
  void *v197;
  int v198;
  uint64_t v199;
  void *v200;
  id v201;
  uint64_t v202;
  void *v203;
  void *v204;
  int v205;
  void *v206;
  int v207;
  uint64_t v208;
  void *v209;
  id v210;
  void *v211;
  int v212;
  uint64_t v213;
  void *v214;
  id v215;
  void *v216;
  int v217;
  void *v218;
  id v219;
  id v220;
  int v221;
  id v222;
  uint64_t v223;
  char *v224;
  uint64_t v225;
  uint64_t v226;
  id v227;
  int v228;
  id v229;
  uint64_t v230;
  uint64_t v231;
  id v232;
  int v233;
  id v234;
  uint64_t v235;
  uint64_t v236;
  id v237;
  int v238;
  id v239;
  id v240;
  int v241;
  id v242;
  uint64_t v243;
  uint64_t v244;
  id v245;
  int v246;
  id v247;
  uint64_t v248;
  uint64_t v249;
  id v250;
  id v251;
  int v252;
  id v253;
  uint64_t v254;
  uint64_t v255;
  id v256;
  int v257;
  id v258;
  void *v259;
  uint64_t v260;
  int *v261;
  uint64_t v262;
  uint64_t v263;
  id v264;
  int v265;
  id v266;
  uint64_t v267;
  uint64_t v268;
  id v269;
  int v270;
  id v271;
  uint64_t v272;
  uint64_t v273;
  void *v274;
  int v275;
  void *v276;
  id v277;
  void (*v278)(uint64_t, uint64_t);
  void *v279;
  int v280;
  uint64_t v281;
  int v282;
  id v283;
  int v284;
  id v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  void *v289;
  int v290;
  int v291;
  id v292;
  int v293;
  id v294;
  char *v295;
  uint64_t v296;
  uint64_t v297;
  id v298;
  void *v299;
  int v300;
  uint64_t v301;
  void *v302;
  id v303;
  void *v304;
  int v305;
  uint64_t v306;
  void *v307;
  id v308;
  id v309;
  int v310;
  id v311;
  id v312;
  int v313;
  id v314;
  id v315;
  int v316;
  id v317;
  uint64_t v318;
  uint64_t v319;
  char *v320;
  uint64_t v321;
  uint64_t v322;
  uint64_t v323;
  void (*v324)(uint64_t, uint64_t);
  int v325;
  unsigned int v326;
  uint64_t v327;
  uint64_t v328;
  void (*v329)(uint64_t, uint64_t);
  uint64_t v330;
  uint64_t ESPSequenceNumberFromPacket;
  uint64_t v332;
  uint64_t v333;
  uint64_t v334;
  uint64_t v335;
  uint64_t v336;
  char *object_address;
  uint64_t v338;
  uint64_t packet;
  id v340;
  id v341;
  uint64_t v342;
  _QWORD v343[8];
  __int128 v344;
  __int128 v345;
  __int128 v346;
  __int128 v347;
  _BYTE v348[64];
  __int128 v349;
  __int128 v350;
  __int128 v351;
  __int128 v352;
  __int128 v353;
  __int128 v354;
  __int128 v355;
  __int128 v356;
  __int128 v357;
  __int128 v358;
  __int128 v359;
  __int128 v360;
  __int128 v361;
  __int128 v362;
  __int128 v363;
  __int128 v364;
  uint64_t v365;
  uint64_t v366;

  v3 = a1;
  v5 = (uint64_t)v3;
  if (*((unsigned __int8 *)v3 + 16) == 255)
  {
    v11 = (void *)_NRCopyLogObjectForNRUUID(v3[4], v4);
    IsLevelEnabled = _NRLogIsLevelEnabled(v11, 16);

    if (IsLevelEnabled)
    {
      v9 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v13);
      v10 = objc_msgSend((id)v5, "copyDescription");
      _NRLogWithArgs(v9, 16, "%s%.30s:%-4d %@: nexusToLinkLoopUrgent but cancelled", "", "NRLinkNexusToLinkLoopUrgent", 3004, v10);
      goto LABEL_14;
    }
    goto LABEL_257;
  }
  if (!*(_QWORD *)((char *)v3 + 1111))
  {
    sub_100071380(v3, a2);
    goto LABEL_257;
  }
  if (*(_QWORD *)((char *)v3 + 1135))
  {
    v333 = *(_QWORD *)((char *)v3 + 527);
    v334 = a2;
    if (v333 == a2)
    {
      if (gNRPacketLoggingEnabled)
      {
        v274 = (void *)_NRCopyLogObjectForNRUUID(v3[4], v4);
        v275 = _NRLogIsLevelEnabled(v274, 1);

        if (v275)
        {
          v276 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v4);
          v277 = objc_msgSend((id)v5, "copyDescription");
          _NRLogWithArgs(v276, 1, "%s%.30s:%-4d %@: UrgentLink:Serving voice channel", "", "NRLinkNexusToLinkLoopUrgent", 3035, v277);
          v17 = &OBJC_IVAR___NRLinkBluetooth__nexusVOInputRing;
          v18 = &OBJC_IVAR___NRLinkBluetooth__packetsFromNexusVO;
          v19 = &OBJC_IVAR___NRLinkBluetooth__bytesFromNexusVO;
          v20 = &OBJC_IVAR___NRLinkBluetooth__syncNexusVOInput;
          v329 = sub_100074E68;
          v278 = sub_100074A4C;
LABEL_299:
          v324 = v278;

LABEL_20:
          v325 = 0;
          v22 = *(_QWORD *)(v5 + *v17);
          v322 = *v19;
          v23 = *(_QWORD *)(v5 + v322);
          v321 = *v18;
          v318 = *(_QWORD *)(v5 + v321);
          v319 = v23;
          v320 = (char *)&v349 + 8;
          v323 = *v20;
          v24 = v22;
          v25 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
          v336 = v22;
LABEL_23:
          v26 = 0;
          v330 = 0;
          ESPSequenceNumberFromPacket = 0;
          v27 = 0;
          object_address = 0;
          v338 = 0;
          packet = 0;
          v340 = 0;
          v335 = 0;
          v28 = 0;
          memset(v348, 0, sizeof(v348));
          v365 = 0;
          v366 = 0;
          v342 = *(_QWORD *)(v5 + 951);
          while (1)
          {
            while (1)
            {
              v29 = v27;
              *(_QWORD *)(v5 + 1935) = 2;
              v351 = 0u;
              v352 = 0u;
              v349 = 0u;
              v350 = 0u;
              if (v24)
              {
                next_slot = os_channel_get_next_slot(v24, v335, &v349);
                if (next_slot)
                {
                  if (v333 == v334 && *(_BYTE *)(v5 + 225))
                    break;
                }
              }
LABEL_40:
              if ((_WORD)v26)
              {
                *(_QWORD *)(v5 + 1935) |= 0x40uLL;
                if (!v28)
                  goto LABEL_167;
                v27 = v29;
              }
              else
              {
                v37 = os_channel_get_next_slot(*(_QWORD *)(v5 + 1135), v340, v348);
                if (!v37)
                {
                  LODWORD(v26) = 0;
LABEL_167:
                  LODWORD(v27) = v29;
                  if (*(_BYTE *)(v5 + 228) && *(_QWORD *)(v5 + 1151))
                  {
                    *(_BYTE *)(v5 + 228) = 0;
                    ++*(_QWORD *)(v5 + 1167);
                    if (gNRPacketLoggingEnabled)
                    {
                      v206 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v4);
                      v207 = _NRLogIsLevelEnabled(v206, 1);

                      if (v207)
                      {
                        v209 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v208);
                        v210 = objc_msgSend((id)v5, "copyDescription");
                        _NRLogWithArgs(v209, 1, "%s%.30s:%-4d %@: source-resume: UrgentLinkOutput", "", "NRLinkResumeUrgentLinkOutputSource", 827, v210);

                      }
                    }
                    dispatch_resume(*(dispatch_object_t *)(v5 + 1151));
                  }
                  ((void (*)(uint64_t))v329)(v5);
                  *(_QWORD *)(v5 + 1935) |= 0x80uLL;
                  if (!gNRPacketLoggingEnabled)
                  {
                    v28 = 0;
                    goto LABEL_173;
                  }
                  v166 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v4);
                  v167 = _NRLogIsLevelEnabled(v166, 1);

                  v61 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                  if (v167)
                  {
                    v168 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v4);
                    v169 = objc_msgSend((id)v5, "copyDescription");
                    _NRLogWithArgs(v168, 1, "%s%.30s:%-4d %@: no urgent link output slot", "", "NRLinkNexusToLinkLoopUrgent", 3222, v169);

                  }
                  v28 = 0;
LABEL_174:
                  v146 = v340;
                  if (v340)
                  {
                    if (v28 != v340)
                      goto LABEL_278;
                    v147 = v27;
                    v148 = v28;
                    v149 = v340;
                    v150 = 0x40000;
                    if ((unsigned __int16)v26 != (unsigned __int16)v147 && (unsigned __int16)v26 != 0)
                    {
                      v150 = 0x20000;
                      v88 = v26;
                    }
                    else
                    {
                      v88 = v147;
                    }
                    *(_QWORD *)(v5 + 1935) |= v150;
                    if (gNRPacketLoggingEnabled)
                    {
                      v181 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v4);
                      v182 = _NRLogIsLevelEnabled(v181, 1);

                      if (v182)
                      {
                        v184 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v183);
                        v185 = objc_msgSend((id)v5, "copyDescription");
                        _NRLogWithArgs(v184, 1, "%s%.30s:%-4d %@: UrgentLink:Sending ESP sequence number %u (4)", "", "NRLinkNexusToLinkLoopUrgent", 3488, v185, ESPSequenceNumberFromPacket);

                      }
                    }
                    v366 = v342;
                    os_buflet_set_data_length(v338, (unsigned __int16)v88);
                    os_packet_set_flow_uuid(packet, &v365);
                    v151 = os_packet_finalize(packet);
                    if (v151)
                    {
                      v291 = v151;
                      v309 = sub_100070AC8();
                      v310 = _NRLogIsLevelEnabled(v309, 16);

                      if (v310)
                      {
                        v311 = sub_100070AC8();
                        _NRLogWithArgs(v311, 16, "%s%.30s:%-4d ABORTING: os_packet_finalize returned %d", "", "NRLinkNexusToLinkLoopUrgent", 3492, v291);

                      }
                      goto LABEL_302;
                    }
                    v153 = *(_DWORD *)(v5 + 299);
                    v154 = *(_DWORD *)(v5 + 303);
                    if (v153 <= v154)
                    {
                      if (v153 != v154)
                      {
                        v264 = sub_100070AC8();
                        v265 = _NRLogIsLevelEnabled(v264, 16);

                        if (v265)
                        {
                          v266 = sub_100070AC8();
                          _NRLogWithArgs(v266, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: self->_filledInUrgentLinkWriteBufferBytes == self->_handledUrgentLinkWriteBufferBytes", "", "NRLinkNexusToLinkLoopUrgent", 3507);

                        }
                        v267 = _os_log_pack_size(12);
                        v224 = (char *)&v318 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
                        v268 = *__error();
                        v226 = _os_log_pack_fill(v224, v267, v268, &_mh_execute_header, "%{public}s Assertion Failed: self->_filledInUrgentLinkWriteBufferBytes == self->_handledUrgentLinkWriteBufferBytes", v318, v319);
                        goto LABEL_276;
                      }
                      if (gNRPacketLoggingEnabled)
                      {
                        if (v153)
                        {
                          *(_QWORD *)(v5 + 1935) |= 0x100000uLL;
                          v216 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v152);
                          v217 = _NRLogIsLevelEnabled(v216, 1);

                          if (v217)
                          {
                            v218 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v152);
                            v219 = objc_msgSend((id)v5, "copyDescription");
                            _NRLogWithArgs(v218, 1, "%s%.30s:%-4d %@: UrgentLink:resetting the linkWriteBuffer from filledIn=%u handled=%u", "", "NRLinkNexusToLinkLoopUrgent", 3511, v219, *(unsigned int *)(v5 + 299), *(unsigned int *)(v5 + 303));

                          }
                        }
                      }
                      *(_DWORD *)(v5 + 299) = 0;
                    }
                    else
                    {
                      *(_QWORD *)(v5 + 1935) |= 0x80000uLL;
                      if (gNRPacketLoggingEnabled)
                      {
                        v211 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v152);
                        v212 = _NRLogIsLevelEnabled(v211, 1);

                        if (v212)
                        {
                          v214 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v213);
                          v215 = objc_msgSend((id)v5, "copyDescription");
                          _NRLogWithArgs(v214, 1, "%s%.30s:%-4d %@: UrgentLink:memmoving the linkWriteBuffer from filledIn=%u handled=%u", "", "NRLinkNexusToLinkLoopUrgent", 3500, v215, *(unsigned int *)(v5 + 299), *(unsigned int *)(v5 + 303));

                        }
                      }
                      memmove(*(void **)(v5 + 1191), (const void *)(*(_QWORD *)(v5 + 1191) + *(unsigned int *)(v5 + 303)), (*(_DWORD *)(v5 + 299) - *(_DWORD *)(v5 + 303)));
                      *(_DWORD *)(v5 + 299) -= *(_DWORD *)(v5 + 303);
                    }
                    *(_DWORD *)(v5 + 303) = 0;
                    *(_QWORD *)(v5 + 1935) |= 0x200000uLL;
                    v146 = v149;
                    if (gNRPacketLoggingEnabled)
                    {
                      v186 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v152);
                      v187 = _NRLogIsLevelEnabled(v186, 1);

                      if (v187)
                      {
                        v189 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v188);
                        v190 = objc_msgSend((id)v5, "copyDescription");
                        _NRLogWithArgs(v189, 1, "%s%.30s:%-4d %@: UrgentLink:advancing past urgentLinkOutputSlot=%p and syncing urgent link output", "", "NRLinkNexusToLinkLoopUrgent", 3517, v190, v148);

                      }
                      if (gNRPacketLoggingEnabled)
                      {
                        v191 = objc_claimAutoreleasedReturnValue(+[NSDate date](NSDate, "date"));
                        v192 = *(void **)(v5 + 1719);
                        *(_QWORD *)(v5 + 1719) = v191;

                      }
                    }
                    os_channel_advance_slot(*(_QWORD *)(v5 + 1135), v148);
                    os_channel_sync(*(_QWORD *)(v5 + 1119), 0);
                    ++*(_QWORD *)(v5 + 1463);
                    if (gNRPacketLoggingEnabled)
                    {
                      v193 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v4);
                      v194 = _NRLogIsLevelEnabled(v193, 1);

                      if (v194)
                      {
                        v195 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v4);
                        v196 = objc_msgSend((id)v5, "copyDescription");
                        _NRLogWithArgs(v195, 1, "%s%.30s:%-4d %@: UrgentLink:Wrote to urgent pipe", "", "NRLinkNexusToLinkLoopUrgent", 3522, v196);

                      }
                    }
                  }
                  v155 = v330;
                  if (v330)
                  {
                    *(_QWORD *)(v5 + 1935) |= 0x800000uLL;
                    if (gNRPacketLoggingEnabled)
                    {
                      v170 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v4);
                      v171 = _NRLogIsLevelEnabled(v170, 1);

                      if (v171)
                      {
                        v173 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v172);
                        v174 = objc_msgSend((id)v5, "copyDescription");
                        _NRLogWithArgs(v173, 1, "%s%.30s:%-4d %@: DatagramLink:advancing past linkOutputSlot=%p and syncing datagram link output", "", "NRLinkNexusToLinkLoopUrgent", 3529, v174, v330);

                      }
                      v155 = v330;
                      if (gNRPacketLoggingEnabled)
                      {
                        v175 = objc_claimAutoreleasedReturnValue(+[NSDate date](NSDate, "date"));
                        v176 = *(void **)(v5 + 1703);
                        *(_QWORD *)(v5 + 1703) = v175;

                      }
                    }
                    os_channel_advance_slot(*(_QWORD *)(v5 + 1055), v155);
                    os_channel_sync(*(_QWORD *)(v5 + 1039), 0);
                    ++*(_QWORD *)(v5 + 1447);
                  }
                  if (v335)
                  {
                    if (v24)
                    {
                      *(_QWORD *)(v5 + 1935) |= 0x1000000uLL;
                      if (gNRPacketLoggingEnabled)
                      {
                        v197 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v4);
                        v198 = _NRLogIsLevelEnabled(v197, 1);

                        if (v198)
                        {
                          v200 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v199);
                          v201 = objc_msgSend((id)v5, "copyDescription");
                          _NRLogWithArgs(v200, 1, "%s%.30s:%-4d %@: UrgentLink:advancing past nexusInputSlot=%p and syncing nexus input", "", "NRLinkNexusToLinkLoopUrgent", 3539, v201, v335);

                        }
                        if (gNRPacketLoggingEnabled)
                        {
                          v202 = objc_claimAutoreleasedReturnValue(+[NSDate date](NSDate, "date"));
                          v203 = *(void **)(v5 + 1663);
                          *(_QWORD *)(v5 + 1663) = v202;

                        }
                      }
                      os_channel_advance_slot(v24, v335);
                      os_channel_sync(v334, 1);
                      ++*(_QWORD *)(v5 + v323);
                      if (gNRPacketLoggingEnabled)
                      {
                        v204 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v4);
                        v205 = _NRLogIsLevelEnabled(v204, 1);

                        if (v205)
                        {
                          v179 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v4);
                          v180 = objc_msgSend((id)v5, "copyDescription");
                          _NRLogWithArgs(v179, 1, "%s%.30s:%-4d %@: UrgentLink:Served %llu packets, %llu bytes", "", "NRLinkNexusToLinkLoopUrgent", 3545, v180, *(_QWORD *)(v5 + v321) - v318, *(_QWORD *)(v5 + v322) - v319);
LABEL_238:

                        }
                      }
                    }
                    else
                    {
                      v177 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v4);
                      v178 = _NRLogIsLevelEnabled(v177, 17);

                      if (v178)
                      {
                        v179 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v4);
                        v180 = objc_msgSend((id)v5, "copyDescription");
                        _NRLogWithArgs(v179, 17, "%@: Tried to sync nexus input but _nexusInputRing is NULL", v180);
                        goto LABEL_238;
                      }
                    }
                  }
                  *(_QWORD *)(v5 + 951) = v342;
                  if (*(_QWORD *)(v5 + 1935) && *(_QWORD *)(v5 + v61[236]))
                  {
                    *(_BYTE *)(v5 + 259) %= *(_BYTE *)(v5 + 258);
                    v156 = *(_QWORD *)(v5 + v61[236]);
                    v157 = (_QWORD *)(v156 + 8 * *(unsigned __int8 *)(v5 + 259));
                    if ((unint64_t)(v157 + 1) <= v156 + 8 * (unint64_t)*(unsigned __int8 *)(v5 + 258))
                    {
                      if ((v157 & 7) == 0)
                      {
                        *v157 = *(_QWORD *)(v5 + 1935);
                        ++*(_BYTE *)(v5 + 259);
                        *(_QWORD *)(v5 + 1935) = 0;
                      }
                    }
                    else
                    {
                      v158 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v4);
                      v159 = _NRLogIsLevelEnabled(v158, 17);

                      if (v159)
                      {
                        v160 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v4);
                        v161 = objc_msgSend((id)v5, "copyDescription");
                        _NRLogWithArgs(v160, 17, "%@: invalid index for ntl log list (curIdx: %u)", v161, *(unsigned __int8 *)(v5 + 259));

                      }
                    }
                  }
                  LODWORD(v51) = 0;
                  if (v335)
                  {
                    v25 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                    goto LABEL_22;
                  }
                  v25 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                  if (v146 || v330)
                  {
LABEL_22:
                    if ((_DWORD)v51)
                      goto LABEL_257;
                    goto LABEL_23;
                  }
                  if ((v325 & 1) != 0)
                  {
                    if (*(_BYTE *)(v5 + 216))
                    {
                      v88 = (unint64_t)&OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                      if (*(_QWORD *)(v5 + 695))
                      {
                        *(_BYTE *)(v5 + 216) = 0;
                        ++*(_QWORD *)(v5 + 711);
                        if (!gNRPacketLoggingEnabled)
                          goto LABEL_251;
                        goto LABEL_303;
                      }
                    }
LABEL_252:
                    if (*(_BYTE *)(v5 + 214) && *(_QWORD *)(v5 + 551))
                    {
                      *(_BYTE *)(v5 + 214) = 0;
                      ++*(_QWORD *)(v5 + 567);
                      if (gNRPacketLoggingEnabled)
                      {
                        v304 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v4);
                        v305 = _NRLogIsLevelEnabled(v304, 1);

                        if (v305)
                        {
                          v307 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v306);
                          v308 = objc_msgSend((id)v5, "copyDescription");
                          _NRLogWithArgs(v307, 1, "%s%.30s:%-4d %@: source-resume: NexusVOInput", "", "NRLinkResumeNexusVOInputSource", 844, v308);

                        }
                      }
                      dispatch_resume(*(dispatch_object_t *)(v5 + 551));
                    }
                  }
                  if (gNRPacketLoggingEnabled)
                  {
                    v279 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v4);
                    v280 = _NRLogIsLevelEnabled(v279, 1);

                    if (v280)
                    {
                      v9 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v281);
                      v10 = objc_msgSend((id)v5, "copyDescription");
                      _NRLogWithArgs(v9, 1, "%s%.30s:%-4d %@: UrgentLink:out of NtL-U outer loop", "", "NRLinkNexusToLinkLoopUrgent", 3566, v10);
LABEL_14:

                    }
                  }
                  goto LABEL_257;
                }
                v28 = (id)v37;
                *(_QWORD *)(v5 + 1935) |= 0x20uLL;
                packet = os_channel_slot_get_packet(*(_QWORD *)(v5 + 1135), v37);
                next_buflet = os_packet_get_next_buflet(packet, 0);
                object_address = (char *)os_buflet_get_object_address();
                v338 = next_buflet;
                data_limit = os_buflet_get_data_limit(next_buflet);
                if (data_limit >= 0x10000)
                {
                  v227 = sub_100070AC8();
                  v228 = _NRLogIsLevelEnabled(v227, 16);

                  if (v228)
                  {
                    v229 = sub_100070AC8();
                    _NRLogWithArgs(v229, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: outputBufferLength <= 65535", "", "NRLinkNexusToLinkLoopUrgent", 3210);

                  }
LABEL_263:
                  v230 = _os_log_pack_size(12);
                  v224 = (char *)&v318 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
                  v231 = *__error();
                  v226 = _os_log_pack_fill(v224, v230, v231, &_mh_execute_header, "%{public}s Assertion Failed: outputBufferLength <= 65535", v318, v319);
                  goto LABEL_276;
                }
                v27 = data_limit;
                v40 = v342;
                if (v340 != v28)
                  v40 = v342 + 1;
                v342 = v40;
              }
              if (!*(_BYTE *)(v5 + 228) && *(_QWORD *)(v5 + 1151))
              {
                *(_BYTE *)(v5 + 228) = 1;
                ++*(_QWORD *)(v5 + 1167);
                if (gNRPacketLoggingEnabled)
                {
                  v111 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v4);
                  v112 = _NRLogIsLevelEnabled(v111, 1);

                  if (v112)
                  {
                    v114 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v113);
                    v115 = objc_msgSend((id)v5, "copyDescription");
                    _NRLogWithArgs(v114, 1, "%s%.30s:%-4d %@: source-suspend: UrgentLinkOutput", "", "NRLinkSuspendUrgentLinkOutputSource", 819, v115);

                  }
                }
                dispatch_suspend(*(dispatch_object_t *)(v5 + 1151));
                v25 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
              }
              v341 = v28;
              v41 = (unsigned __int16)v27;
              v42 = *(_DWORD *)(v5 + 299);
              v43 = *(unsigned int *)(v5 + v25[122]);
              if (v42 <= v43)
              {
                v24 = v336;
                if (!v336)
                {
LABEL_210:
                  if (*(_BYTE *)(v5 + 16) != 8)
                  {
                    *(_QWORD *)(v5 + 1935) |= 0x400uLL;
                    v61 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                    v28 = v341;
                    goto LABEL_174;
                  }
                  v162 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v4);
                  v163 = _NRLogIsLevelEnabled(v162, 17);

                  v28 = v341;
                  if (v163)
                  {
                    v164 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v4);
                    v165 = objc_msgSend((id)v5, "copyDescription");
                    _NRLogWithArgs(v164, 17, "%@: Tried to nexusToLinkLoopUrgent but _nexusInputRing is NULL", v165);

                  }
LABEL_173:
                  v61 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                  goto LABEL_174;
                }
LABEL_65:
                v346 = 0u;
                v347 = 0u;
                v344 = 0u;
                v345 = 0u;
                v47 = os_channel_get_next_slot(v24, v335, &v344);
                if (!v47)
                {
                  ((void (*)(uint64_t))v324)(v5);
                  *(_QWORD *)(v5 + 1935) |= 0x800uLL;
                  LODWORD(v51) = 25;
                  v325 = 1;
                  goto LABEL_100;
                }
                v48 = v47;
                ((void (*)(uint64_t))v329)(v5);
                v328 = v26;
                if (gNRPacketLoggingEnabled)
                {
                  ESPSequenceNumberFromPacket = getESPSequenceNumberFromPacket(v345, WORD1(v344));
                  if (gNRPacketLoggingEnabled)
                  {
                    v327 = v48;
                    getESPSPIFromPacket(v345, WORD1(v344));
                    if (gNRPacketLoggingEnabled)
                    {
                      v117 = WORD1(v344);
                      v118 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v116);
                      v119 = _NRLogIsLevelEnabled(v118, 1);

                      if (v119)
                      {
                        v121 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v120);
                        v122 = objc_msgSend((id)v5, "copyDescription");
                        _NRLogWithArgs(v121, 1, "%s%.30s:%-4d %@: UrgentLink:Sending ESP sequence number - to be sent on urgent pipe: %u (%u bytes)", "", "NRLinkNexusToLinkLoopUrgent", 3309, v122, ESPSequenceNumberFromPacket, v117);

                      }
                    }
                    v48 = v327;
                    LOWORD(v26) = v328;
                  }
                  else
                  {
                    LOWORD(v26) = v328;
                  }
                }
                else
                {
                  ESPSequenceNumberFromPacket = 0;
                }
                v332 = nrMaxTLVLengthForPacket(v345, WORD1(v344));
                v363 = 0u;
                v364 = 0u;
                v361 = 0u;
                v362 = 0u;
                v359 = 0u;
                v360 = 0u;
                v357 = 0u;
                v358 = 0u;
                v355 = 0u;
                v356 = 0u;
                v353 = 0u;
                v354 = 0u;
                v351 = 0u;
                v352 = 0u;
                v349 = 0u;
                v350 = 0u;
                if ((unsigned __int16)v27 <= (unsigned __int16)v26)
                {
                  v49 = 0;
                  v50 = 0;
                }
                else
                {
                  *(_QWORD *)&v349 = &object_address[(unsigned __int16)v26];
                  v49 = (unsigned __int16)v27 - (unsigned __int16)v26;
                  DWORD2(v349) = v49;
                  v50 = 1;
                }
                v52 = v340;
                if (v49 < v332)
                {
                  v327 = v48;
                  v326 = v27;
                  v53 = v50;
                  v54 = (uint64_t)v341;
                  v55 = (unsigned int *)&v320[16 * v50];
                  do
                  {
                    memset(v343, 0, sizeof(v343));
                    v56 = os_channel_get_next_slot(*(_QWORD *)(v5 + 1135), v54, v343);
                    if (!v56)
                      break;
                    v54 = v56;
                    v57 = os_channel_slot_get_packet(*(_QWORD *)(v5 + 1135), v56);
                    v58 = os_packet_get_next_buflet(v57, 0);
                    v59 = os_buflet_get_object_address();
                    v60 = os_buflet_get_data_limit(v58);
                    if (v60 >= 0x10000)
                    {
                      v240 = sub_100070AC8();
                      v241 = _NRLogIsLevelEnabled(v240, 16);

                      if (v241)
                      {
                        v242 = sub_100070AC8();
                        _NRLogWithArgs(v242, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: lookAheadLinkOutputBufferLength <= 65535", "", "NRLinkNexusToLinkLoopUrgent", 3338);

                      }
                      v243 = _os_log_pack_size(12);
                      v224 = (char *)&v318 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
                      v244 = *__error();
                      v226 = _os_log_pack_fill(v224, v243, v244, &_mh_execute_header, "%{public}s Assertion Failed: lookAheadLinkOutputBufferLength <= 65535", v318, v319);
                      goto LABEL_276;
                    }
                    *((_QWORD *)v55 - 1) = v59;
                    if (!v60)
                    {
                      v245 = sub_100070AC8();
                      v246 = _NRLogIsLevelEnabled(v245, 16);

                      if (v246)
                      {
                        v247 = sub_100070AC8();
                        _NRLogWithArgs(v247, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: lookAheadLinkOutputBufferLength > 0", "", "NRLinkNexusToLinkLoopUrgent", 3341);

                      }
                      v248 = _os_log_pack_size(12);
                      v224 = (char *)&v318 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
                      v249 = *__error();
                      v226 = _os_log_pack_fill(v224, v248, v249, &_mh_execute_header, "%{public}s Assertion Failed: lookAheadLinkOutputBufferLength > 0", v318, v319);
                      goto LABEL_276;
                    }
                    *v55 = v60;
                    *(_QWORD *)(v5 + 1935) |= 0x1000uLL;
                    if (v53 == 15)
                    {
                      v78 = (void *)createIOVecString(&v349, 16);
                      sub_100074F70((void *)v5, CFSTR("NtL-U not enough ioVecs %@ for %u"), v79, v80, v81, v82, v83, v84, (uint64_t)v78);

                      LODWORD(v51) = 1;
                      v24 = v336;
                      v25 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                      v61 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                      v28 = v341;
                      v27 = v326;
                      v26 = v328;
                      goto LABEL_101;
                    }
                    ++v53;
                    v49 += v60;
                    v55 += 4;
                  }
                  while (v49 < v332);
                  LOWORD(v50) = v53;
                  v24 = v336;
                  v52 = v340;
                  v27 = v326;
                  v48 = v327;
                }
                v340 = v52;
                if (v49 < v332)
                {
                  *(_QWORD *)(v5 + 1935) |= 0x2000uLL;
                  v26 = v328;
                  if (*(_BYTE *)(v5 + 228))
                  {
                    v61 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                    v28 = v341;
                    if (*(_QWORD *)(v5 + 1151))
                    {
                      *(_BYTE *)(v5 + 228) = 0;
                      ++*(_QWORD *)(v5 + 1167);
                      if (gNRPacketLoggingEnabled)
                      {
                        v128 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v4);
                        v129 = _NRLogIsLevelEnabled(v128, 1);

                        if (v129)
                        {
                          v131 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v130);
                          v132 = objc_msgSend((id)v5, "copyDescription");
                          _NRLogWithArgs(v131, 1, "%s%.30s:%-4d %@: source-resume: UrgentLinkOutput", "", "NRLinkResumeUrgentLinkOutputSource", 827, v132);

                        }
                      }
                      dispatch_resume(*(dispatch_object_t *)(v5 + 1151));
                    }
                    LODWORD(v51) = 25;
                    v25 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                    goto LABEL_101;
                  }
                  LODWORD(v51) = 25;
                  v25 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
LABEL_100:
                  v61 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                  v28 = v341;
                  goto LABEL_101;
                }
                v62 = v328;
                if (!(_QWORD)v349)
                {
                  v256 = sub_100070AC8();
                  v257 = _NRLogIsLevelEnabled(v256, 16);

                  if (v257)
                  {
                    v258 = sub_100070AC8();
                    v259 = (void *)createIOVecString(&v349, (unsigned __int16)v50);
                    _NRLogWithArgs(v258, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: ioVecs[0].buf != ((void *)0); We have enough content but "
                      "first ioVec is NULL: %@",
                      "",
                      "NRLinkNexusToLinkLoopUrgent",
                      3370,
                      v259);

                  }
                  v260 = _os_log_pack_size(22);
                  v224 = (char *)&v318 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
                  v261 = __error();
                  v262 = _os_log_pack_fill(v224, v260, *v261, &_mh_execute_header, "%{public}s Assertion Failed: ioVecs[0].buf != ((void *)0); We have enough content but first i"
                           "oVec is NULL: %@");
                  v263 = createIOVecString(&v349, (unsigned __int16)v50);
                  *(_DWORD *)v262 = 136446466;
                  *(_QWORD *)(v262 + 4) = "NRLinkNexusToLinkLoopUrgent";
                  *(_WORD *)(v262 + 12) = 2112;
                  *(_QWORD *)(v262 + 14) = v263;
                  goto LABEL_277;
                }
                v63 = nrPacketToTLV(v345, WORD1(v344), &v349, (unsigned __int16)v50, v5 + 1951, v5 + 1967);
                v64 = v63;
                v65 = *(unsigned __int8 *)v349;
                switch(*(_BYTE *)v349)
                {
                  case 'd':
                    v66 = &OBJC_IVAR___NRLinkBluetooth__sentKnownIPv6Hdr_ESP;
                    goto LABEL_118;
                  case 'e':
                    v66 = &OBJC_IVAR___NRLinkBluetooth__sentKnownIPv6Hdr_ESP_ECT0;
                    goto LABEL_118;
                  case 'f':
                    v66 = &OBJC_IVAR___NRLinkBluetooth__sentKnownIPv6Hdr_TCP;
                    goto LABEL_118;
                  case 'g':
                    v66 = &OBJC_IVAR___NRLinkBluetooth__sentKnownIPv6Hdr_TCP_ECT0;
                    goto LABEL_118;
                  case 'h':
                    v66 = &OBJC_IVAR___NRLinkBluetooth__sentKnownIPv6Hdr_ESP_ClassC;
                    goto LABEL_118;
                  case 'i':
                    v66 = &OBJC_IVAR___NRLinkBluetooth__sentKnownIPv6Hdr_ESP_ClassC_ECT0;
                    goto LABEL_118;
                  default:
                    if (v65 == 2)
                    {
                      v66 = &OBJC_IVAR___NRLinkBluetooth__sentUncompressedIP;
                    }
                    else
                    {
                      if (v65 != 3)
                        goto LABEL_119;
                      v66 = &OBJC_IVAR___NRLinkBluetooth__sentEncapsulated6LoWPAN;
                    }
LABEL_118:
                    ++*(_QWORD *)(v5 + *v66);
LABEL_119:
                    *(_QWORD *)(v5 + 1415) += v63;
                    v85 = (unsigned __int16)(v27 - v62);
                    if (v63 <= v85)
                    {
                      v26 = v62 + v63;
                      v28 = v341;
                      goto LABEL_134;
                    }
                    v327 = v48;
                    v86 = v340;
                    *(_QWORD *)(v5 + 1935) |= 0x4000uLL;
                    if (gNRPacketLoggingEnabled)
                    {
                      v123 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v4);
                      v124 = _NRLogIsLevelEnabled(v123, 1);

                      if (v124)
                      {
                        v126 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v125);
                        v127 = objc_msgSend((id)v5, "copyDescription");
                        _NRLogWithArgs(v126, 1, "%s%.30s:%-4d %@: UrgentLink:Sending ESP sequence number %u (2)", "", "NRLinkNexusToLinkLoopUrgent", 3415, v127, ESPSequenceNumberFromPacket);

                      }
                    }
                    v366 = v342;
                    os_buflet_set_data_length(v338, v41);
                    os_packet_set_flow_uuid(packet, &v365);
                    v87 = os_packet_finalize(packet);
                    v28 = v341;
                    v88 = (unint64_t)&OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                    if (v87)
                    {
                      v291 = v87;
                      v312 = sub_100070AC8();
                      v313 = _NRLogIsLevelEnabled(v312, 16);

                      if (v313)
                      {
                        v314 = sub_100070AC8();
                        _NRLogWithArgs(v314, 16, "%s%.30s:%-4d ABORTING: os_packet_finalize returned %d", "", "NRLinkNexusToLinkLoopUrgent", 3419, v291);

                      }
LABEL_302:
                      v5 = _os_log_pack_size(18);
                      v295 = (char *)&v318 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
                      v296 = *__error();
                      v297 = _os_log_pack_fill(v295, v5, v296, &_mh_execute_header, "%{public}s os_packet_finalize returned %d", v318, v319);
                      *(_DWORD *)v297 = 136446466;
                      *(_QWORD *)(v297 + 4) = "NRLinkNexusToLinkLoopUrgent";
                      *(_WORD *)(v297 + 12) = 1024;
                      *(_DWORD *)(v297 + 14) = v291;
                      v298 = sub_100070AC8();
                      _NRLogAbortWithPack(v298, v295);
LABEL_303:
                      v299 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v4);
                      v300 = _NRLogIsLevelEnabled(v299, 1);

                      if (v300)
                      {
                        v302 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v301);
                        v303 = objc_msgSend((id)v5, "copyDescription");
                        _NRLogWithArgs(v302, 1, "%s%.30s:%-4d %@: source-resume: NexusVIInput", "", "NRLinkResumeNexusVIInputSource", 846, v303);

                      }
LABEL_251:
                      dispatch_resume(*(dispatch_object_t *)(v5 + *(int *)(v88 + 832)));
                      goto LABEL_252;
                    }
                    while (1)
                    {
                      v89 = os_channel_get_next_slot(*(_QWORD *)(v5 + *(int *)(v88 + 924)), v28, v348);
                      if (!v89)
                        break;
                      v28 = (id)v89;
                      v90 = v342;
                      if (v86 != (id)v89)
                        v90 = v342 + 1;
                      v342 = v90;
                      packet = os_channel_slot_get_packet(*(_QWORD *)(v5 + *(int *)(v88 + 924)), v89);
                      v91 = os_packet_get_next_buflet(packet, 0);
                      object_address = (char *)os_buflet_get_object_address();
                      v338 = v91;
                      v92 = os_buflet_get_data_limit(v91);
                      if (v92 >= 0x10000)
                      {
                        v237 = sub_100070AC8();
                        v238 = _NRLogIsLevelEnabled(v237, 16);

                        if (v238)
                        {
                          v239 = sub_100070AC8();
                          _NRLogWithArgs(v239, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: outputBufferLength <= 65535", "", "NRLinkNexusToLinkLoopUrgent", 3437);

                        }
                        goto LABEL_263;
                      }
                      v27 = v92;
                      v93 = v92 + v85;
                      if (v92 + v85 >= v64)
                      {
                        v26 = v64 - v85;
                        v48 = v327;
LABEL_134:
                        v100 = v322;
                        ++*(_QWORD *)(v5 + v321);
                        *(_QWORD *)(v5 + v100) += WORD1(v344);
                        *(_QWORD *)(v5 + 1935) |= 0x10000uLL;
                        v51 = *(_QWORD *)(v5 + 1935);
                        v24 = v336;
                        v25 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                        if (!v51)
                        {
                          v340 = v28;
                          v335 = v48;
                          v61 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                          goto LABEL_101;
                        }
                        v61 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                        v51 = *(_QWORD *)(v5 + 1943);
                        if (v51)
                        {
                          *(_BYTE *)(v5 + 259) %= *(_BYTE *)(v5 + 258);
                          v101 = *(_QWORD *)(v5 + 1943);
                          v102 = (_QWORD *)(v101 + 8 * *(unsigned __int8 *)(v5 + 259));
                          if ((unint64_t)(v102 + 1) > v101
                                                            + 8 * (unint64_t)*(unsigned __int8 *)(v5 + 258))
                          {
                            v103 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v4);
                            v104 = _NRLogIsLevelEnabled(v103, 17);

                            if (v104)
                            {
                              v105 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v4);
                              v106 = objc_msgSend((id)v5, "copyDescription");
                              _NRLogWithArgs(v105, 17, "%@: invalid index for ntl log list (curIdx: %u)", v106, *(unsigned __int8 *)(v5 + 259));

                            }
                            LODWORD(v51) = 0;
                            v340 = v28;
                            v335 = v48;
                            v25 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                            goto LABEL_101;
                          }
                          LODWORD(v51) = 0;
                          if ((v102 & 7) == 0)
                          {
                            *v102 = *(_QWORD *)(v5 + 1935);
                            ++*(_BYTE *)(v5 + 259);
                            *(_QWORD *)(v5 + 1935) = 0;
                          }
                        }
                        v340 = v28;
                        v335 = v48;
                        goto LABEL_101;
                      }
                      *(_QWORD *)(v5 + 1935) |= 0x8000uLL;
                      if (gNRPacketLoggingEnabled)
                      {
                        v95 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v4);
                        v96 = _NRLogIsLevelEnabled(v95, 1);

                        if (v96)
                        {
                          v98 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v97);
                          v99 = objc_msgSend((id)v5, "copyDescription");
                          _NRLogWithArgs(v98, 1, "%s%.30s:%-4d %@: UrgentLink:Sending ESP sequence number %u (3)", "", "NRLinkNexusToLinkLoopUrgent", 3450, v99, ESPSequenceNumberFromPacket);

                        }
                      }
                      v366 = v342;
                      os_buflet_set_data_length(v338, v27);
                      os_packet_set_flow_uuid(packet, &v365);
                      v94 = os_packet_finalize(packet);
                      v85 = v93;
                      v88 = 0x1001E0000;
                      if (v94)
                      {
                        v291 = v94;
                        v292 = sub_100070AC8();
                        v293 = _NRLogIsLevelEnabled(v292, 16);

                        if (v293)
                        {
                          v294 = sub_100070AC8();
                          _NRLogWithArgs(v294, 16, "%s%.30s:%-4d ABORTING: os_packet_finalize returned %d", "", "NRLinkNexusToLinkLoopUrgent", 3457, v291);

                        }
                        goto LABEL_302;
                      }
                    }
                    v232 = sub_100070AC8();
                    v233 = _NRLogIsLevelEnabled(v232, 16);

                    if (v233)
                    {
                      v234 = sub_100070AC8();
                      _NRLogWithArgs(v234, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (curLinkOutputSlot) != ((void *)0)", "", "NRLinkNexusToLinkLoopUrgent", 3427);

                    }
                    v235 = _os_log_pack_size(12);
                    v224 = (char *)&v318 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
                    v236 = *__error();
                    v226 = _os_log_pack_fill(v224, v235, v236, &_mh_execute_header, "%{public}s Assertion Failed: (curLinkOutputSlot) != ((void *)0)", v318, v319);
                    break;
                }
                while (1)
                {
LABEL_276:
                  *(_DWORD *)v226 = 136446210;
                  *(_QWORD *)(v226 + 4) = "NRLinkNexusToLinkLoopUrgent";
LABEL_277:
                  v250 = sub_100070AC8();
                  _NRLogAbortWithPack(v250, v224);
LABEL_278:
                  v251 = sub_100070AC8();
                  v252 = _NRLogIsLevelEnabled(v251, 16);

                  if (v252)
                  {
                    v253 = sub_100070AC8();
                    _NRLogWithArgs(v253, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: curLinkOutputSlot == highestLinkOutputSlotWrittenTo", "", "NRLinkNexusToLinkLoopUrgent", 3473);

                  }
                  v254 = _os_log_pack_size(12);
                  v224 = (char *)&v318 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
                  v255 = *__error();
                  v226 = _os_log_pack_fill(v224, v254, v255, &_mh_execute_header, "%{public}s Assertion Failed: curLinkOutputSlot == highestLinkOutputSlotWrittenTo", v318, v319);
                }
              }
              v44 = v42 - v43;
              if (v44 >= (unsigned __int16)(v27 - v26))
                v45 = v27 - v26;
              else
                v45 = v44;
              memcpy(object_address, (const void *)(*(_QWORD *)(v5 + 1191) + v43), (unsigned __int16)v45);
              *(_DWORD *)(v5 + v25[122]) += (unsigned __int16)v45;
              *(_QWORD *)(v5 + 1415) += (unsigned __int16)v45;
              ++*(_DWORD *)(v5 + 295);
              *(_QWORD *)(v5 + 1935) |= 0x100uLL;
              if (gNRPacketLoggingEnabled)
              {
                v107 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v4);
                v108 = _NRLogIsLevelEnabled(v107, 1);

                if (v108)
                {
                  v109 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v4);
                  v110 = objc_msgSend((id)v5, "copyDescription");
                  _NRLogWithArgs(v109, 1, "%s%.30s:%-4d %@: wrote %u bytes from linkWriteBuffer to link, filledIn=%u handled=%u", "", "NRLinkNexusToLinkLoopUrgent", 3260, v110, (unsigned __int16)v45, *(unsigned int *)(v5 + 299), *(unsigned int *)(v5 + 303));

                }
              }
              v26 = v45 + v26;
              v24 = v336;
              if ((unsigned __int16)v26 < (unsigned __int16)v27)
              {
                v340 = v341;
                v25 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                if (!v336)
                  goto LABEL_210;
                goto LABEL_65;
              }
              if ((unsigned __int16)v26 != (unsigned __int16)v27)
              {
                v220 = sub_100070AC8();
                v221 = _NRLogIsLevelEnabled(v220, 16);

                if (v221)
                {
                  v222 = sub_100070AC8();
                  _NRLogWithArgs(v222, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: curLinkOutputSlotPartialBytesAlreadyWritten == linkOutputBufferLength", "", "NRLinkNexusToLinkLoopUrgent", 3263);

                }
                v223 = _os_log_pack_size(12);
                v224 = (char *)&v318 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
                v225 = *__error();
                v226 = _os_log_pack_fill(v224, v223, v225, &_mh_execute_header, "%{public}s Assertion Failed: curLinkOutputSlotPartialBytesAlreadyWritten == linkOutputBufferLength", v318, v319);
                goto LABEL_276;
              }
              os_buflet_set_data_length(v338, (unsigned __int16)v27);
              v366 = v342;
              os_packet_set_flow_uuid(packet, &v365);
              v46 = os_packet_finalize(packet);
              if (v46)
              {
                v282 = v46;
                v283 = sub_100070AC8();
                v284 = _NRLogIsLevelEnabled(v283, 16);

                if (v284)
                {
                  v285 = sub_100070AC8();
                  _NRLogWithArgs(v285, 16, "%s%.30s:%-4d ABORTING: os_packet_finalize returned %d", "", "NRLinkNexusToLinkLoopUrgent", 3271, v282);

                }
                goto LABEL_296;
              }
              v26 = 0;
              *(_QWORD *)(v5 + 1935) |= 0x200uLL;
              v28 = v341;
              v340 = v341;
              v25 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
            }
            v31 = next_slot;
            v32 = 0;
            if ((_QWORD)v350)
            {
              v4 = WORD1(v349);
              v33 = 0;
              if (WORD1(v349))
              {
                if (isPacketValidIPv6())
                {
                  DSCPFromPacket = getDSCPFromPacket(v350, WORD1(v349));
                  v35 = DSCPFromPacket == 46;
                  v36 = WORD1(v349) < 0x2A4u;
                  v33 = v35 && v36;
                  if (v35 && v36)
                    v32 = 46;
                  else
                    v32 = DSCPFromPacket;
                }
                else
                {
                  v32 = 0;
                  v33 = 0;
                }
              }
            }
            else
            {
              v33 = 0;
            }
            if (gNRPacketLoggingEnabled)
            {
              ESPSequenceNumberFromPacket = getESPSequenceNumberFromPacket(v350, WORD1(v349));
              if (gNRPacketLoggingEnabled)
                getESPSPIFromPacket(v350, WORD1(v349));
            }
            else
            {
              ESPSequenceNumberFromPacket = 0;
            }
            if (!v33)
            {
              v25 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
              goto LABEL_40;
            }
            v346 = 0u;
            v347 = 0u;
            v344 = 0u;
            v345 = 0u;
            v67 = os_channel_get_next_slot(*(_QWORD *)(v5 + 1055), v330, &v344);
            if (v67)
            {
              v69 = v67;
              if (!*(_BYTE *)(v5 + 224) && *(_QWORD *)(v5 + 1071))
              {
                v70 = v67;
                *(_BYTE *)(v5 + 224) = 1;
                ++*(_QWORD *)(v5 + 1087);
                if (gNRPacketLoggingEnabled)
                {
                  v138 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v68);
                  LODWORD(v341) = _NRLogIsLevelEnabled(v138, 1);

                  if ((_DWORD)v341)
                  {
                    v140 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v139);
                    v341 = objc_msgSend((id)v5, "copyDescription");
                    _NRLogWithArgs(v140, 1, "%s%.30s:%-4d %@: source-suspend: DatagramLinkOutput", "", "NRLinkSuspendDatagramLinkOutputSource", 817, v341);

                  }
                }
                dispatch_suspend(*(dispatch_object_t *)(v5 + 1071));
                v69 = v70;
              }
              v71 = *(_QWORD *)(v5 + 1055);
              v335 = v69;
              v341 = (id)os_channel_slot_get_packet(v71, v69);
              v72 = os_packet_get_next_buflet(v341, 0);
              v73 = os_buflet_get_object_address();
              v74 = os_buflet_get_data_limit(v72);
              if (v74 < 0x10000)
              {
                v343[0] = v73;
                v343[1] = v74;
                v75 = nrPacketToTLV(v350, WORD1(v349), v343, 1, v5 + 1951, v5 + 1967);
                *(_QWORD *)(v5 + 1399) += v75;
                *(_QWORD *)(v5 + v322) += WORD1(v349);
                ++*(_QWORD *)(v5 + v321);
                *(_QWORD *)(v5 + 1935) |= 0x10uLL;
                if (gNRPacketLoggingEnabled)
                {
                  v332 = v75;
                  v133 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v76);
                  v134 = _NRLogIsLevelEnabled(v133, 1);

                  LOWORD(v75) = v332;
                  if (v134)
                  {
                    v136 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v135);
                    v137 = objc_msgSend((id)v5, "copyDescription");
                    _NRLogWithArgs(v136, 1, "%s%.30s:%-4d %@: wrote payload of length: %u, dscp: %u, uncompressedLen = %u", "", "NRLinkNexusToLinkLoopUrgent", 3180, v137, v332, v32, WORD1(v349));

                    LOWORD(v75) = v332;
                  }
                }
                os_buflet_set_data_length(v72, (unsigned __int16)v75);
                v366 = ++v342;
                os_packet_set_flow_uuid(v341, &v365);
                v77 = os_packet_finalize(v341);
                if (!v77)
                {
                  LODWORD(v51) = 24;
                  v24 = v336;
                  v330 = v335;
                  v335 = v31;
                  v25 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                  v61 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                  v27 = v29;
                  goto LABEL_101;
                }
                v282 = v77;
                v315 = sub_100070AC8();
                v316 = _NRLogIsLevelEnabled(v315, 16);

                if (v316)
                {
                  v317 = sub_100070AC8();
                  _NRLogWithArgs(v317, 16, "%s%.30s:%-4d ABORTING: os_packet_finalize returned %d", "", "NRLinkNexusToLinkLoopUrgent", 3184, v282);

                }
LABEL_296:
                v286 = _os_log_pack_size(18);
                v224 = (char *)&v318 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
                v287 = *__error();
                v288 = _os_log_pack_fill(v224, v286, v287, &_mh_execute_header, "%{public}s os_packet_finalize returned %d", v318, v319);
                *(_DWORD *)v288 = 136446466;
                *(_QWORD *)(v288 + 4) = "NRLinkNexusToLinkLoopUrgent";
                *(_WORD *)(v288 + 12) = 1024;
                *(_DWORD *)(v288 + 14) = v282;
                goto LABEL_277;
              }
              v269 = sub_100070AC8();
              v270 = _NRLogIsLevelEnabled(v269, 16);

              if (v270)
              {
                v271 = sub_100070AC8();
                _NRLogWithArgs(v271, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: datagramBufferLength <= 65535", "", "NRLinkNexusToLinkLoopUrgent", 3160);

              }
              v272 = _os_log_pack_size(12);
              v224 = (char *)&v318 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
              v273 = *__error();
              v226 = _os_log_pack_fill(v224, v272, v273, &_mh_execute_header, "%{public}s Assertion Failed: datagramBufferLength <= 65535", v318, v319);
              goto LABEL_276;
            }
            v25 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
            v27 = v29;
            if (*(_BYTE *)(v5 + 224) && *(_QWORD *)(v5 + 1071))
            {
              *(_BYTE *)(v5 + 224) = 0;
              ++*(_QWORD *)(v5 + 1087);
              if (gNRPacketLoggingEnabled)
              {
                v141 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v68);
                v142 = _NRLogIsLevelEnabled(v141, 1);

                if (v142)
                {
                  v144 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v143);
                  v145 = objc_msgSend((id)v5, "copyDescription");
                  _NRLogWithArgs(v144, 1, "%s%.30s:%-4d %@: source-resume: DatagramLinkOutput", "", "NRLinkResumeDatagramLinkOutputSource", 825, v145);

                }
              }
              dispatch_resume(*(dispatch_object_t *)(v5 + 1071));
              v25 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
            }
            ((void (*)(uint64_t))v329)(v5);
            *(_QWORD *)(v5 + 1935) |= 4uLL;
            LODWORD(v51) = 25;
            v61 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
LABEL_101:
            if ((_DWORD)v51 && (_DWORD)v51 != 24)
            {
              if ((_DWORD)v51 == 25)
                goto LABEL_174;
              goto LABEL_22;
            }
          }
        }
      }
      v17 = &OBJC_IVAR___NRLinkBluetooth__nexusVOInputRing;
      v18 = &OBJC_IVAR___NRLinkBluetooth__packetsFromNexusVO;
      v19 = &OBJC_IVAR___NRLinkBluetooth__bytesFromNexusVO;
      v20 = &OBJC_IVAR___NRLinkBluetooth__syncNexusVOInput;
      v329 = sub_100074E68;
      v21 = sub_100074A4C;
    }
    else
    {
      if (*(_QWORD *)((char *)v3 + 671) != a2)
      {
        v6 = (void *)_NRCopyLogObjectForNRUUID(v3[4], v4);
        v7 = _NRLogIsLevelEnabled(v6, 17);

        if (v7)
        {
          v9 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v8);
          v10 = objc_msgSend((id)v5, "copyDescription");
          _NRLogWithArgs(v9, 17, "%@: channel %p not eligible for urgent link", v10, a2);
          goto LABEL_14;
        }
        goto LABEL_257;
      }
      if (gNRPacketLoggingEnabled)
      {
        v289 = (void *)_NRCopyLogObjectForNRUUID(v3[4], v4);
        v290 = _NRLogIsLevelEnabled(v289, 1);

        if (v290)
        {
          v276 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v4);
          v277 = objc_msgSend((id)v5, "copyDescription");
          _NRLogWithArgs(v276, 1, "%s%.30s:%-4d %@: UrgentLink:Serving video channel", "", "NRLinkNexusToLinkLoopUrgent", 3046, v277);
          v17 = &OBJC_IVAR___NRLinkBluetooth__nexusVIInputRing;
          v18 = &OBJC_IVAR___NRLinkBluetooth__packetsFromNexusVI;
          v19 = &OBJC_IVAR___NRLinkBluetooth__bytesFromNexusVI;
          v20 = &OBJC_IVAR___NRLinkBluetooth__syncNexusVIInput;
          v329 = sub_100074D60;
          v278 = sub_100074948;
          goto LABEL_299;
        }
      }
      v17 = &OBJC_IVAR___NRLinkBluetooth__nexusVIInputRing;
      v18 = &OBJC_IVAR___NRLinkBluetooth__packetsFromNexusVI;
      v19 = &OBJC_IVAR___NRLinkBluetooth__bytesFromNexusVI;
      v20 = &OBJC_IVAR___NRLinkBluetooth__syncNexusVIInput;
      v329 = sub_100074D60;
      v21 = sub_100074948;
    }
    v324 = v21;
    goto LABEL_20;
  }
  if (!*((_BYTE *)v3 + 246))
  {
    v14 = (void *)_NRCopyLogObjectForNRUUID(v3[4], v4);
    v15 = _NRLogIsLevelEnabled(v14, 17);

    if (v15)
    {
      v9 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v5 + 32), v16);
      v10 = objc_msgSend((id)v5, "copyDescription");
      _NRLogWithArgs(v9, 17, "%@: Tried to nexusToLinkLoop but _urgentLinkOutputRing is NULL", v10);
      goto LABEL_14;
    }
  }
LABEL_257:

}

void sub_100086C8C(uint64_t a1)
{
  char *WeakRetained;
  void *v3;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 40));
  v3 = WeakRetained;
  if (WeakRetained)
  {
    v13 = (uint64_t)WeakRetained;
    v4 = *(id *)(WeakRetained + 1111);
    v3 = (void *)v13;
    if (v4)
    {
      v5 = *(_QWORD *)(v13 + 1111);
      v6 = *(_QWORD *)(a1 + 32);

      v3 = (void *)v13;
      if (v5 == v6 && !*(_BYTE *)(v13 + 229))
      {
        v12 = *(_QWORD *)(v13 + 1863);
        if (v12)
          *(_BYTE *)(v12 + 102) = 1;
        sub_100074F70((void *)v13, CFSTR("Did not receive prelude after %ds on urgent pipe"), v13, v7, v8, v9, v10, v11, 10);
        v3 = (void *)v13;
      }
    }
  }

}

void sub_100086D44(uint64_t a1, uint64_t a2)
{
  int v2;
  int *v4;
  int *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  uint64_t next_slot;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  int IsLevelEnabled;
  uint64_t v14;
  id v15;
  void *v16;
  const char *v17;
  void *v18;
  int v19;
  uint64_t v20;
  id v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  int v26;
  uint64_t v27;
  void *v28;
  id v29;
  id v30;
  size_t __n[2];
  void *__src[2];
  __int128 v33;
  __int128 v34;

  if (!a1)
    return;
  v2 = a2;
  v4 = &OBJC_IVAR___NRLinkBluetooth__urgentLinkInputRing;
  if (!(_DWORD)a2)
    v4 = &OBJC_IVAR___NRLinkBluetooth__linkInputRing;
  v5 = &OBJC_IVAR___NRLinkBluetooth__linkChannel;
  if ((_DWORD)a2)
    v5 = &OBJC_IVAR___NRLinkBluetooth__urgentLinkChannel;
  v6 = *(_QWORD *)(a1 + *v4);
  if (!v6)
  {
    v12 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v12, 17);

    if (!IsLevelEnabled)
      return;
    v30 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v14);
    v15 = objc_msgSend((id)a1, "copyDescription");
    v16 = v15;
    v17 = "";
    if (v2)
      v17 = "urgent ";
    _NRLogWithArgs(v30, 17, "%@: Tried to read but %slinkInputRingToRead is NULL", v15, v17);
LABEL_22:

    return;
  }
  v7 = *(_QWORD *)(a1 + *v5);
  if (!v7)
  {
    v18 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
    v19 = _NRLogIsLevelEnabled(v18, 17);

    if (!v19)
      return;
    v30 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v20);
    v21 = objc_msgSend((id)a1, "copyDescription");
    v16 = v21;
    v22 = "";
    if (v2)
      v22 = "urgent ";
    _NRLogWithArgs(v30, 17, "%@: Tried to read but %slinkChannelToRead is NULL", v21, v22);
    goto LABEL_22;
  }
  if ((a2 & 1) != 0)
  {
    i = 0;
    while (1)
    {
      v33 = 0u;
      v34 = 0u;
      *(_OWORD *)__n = 0u;
      *(_OWORD *)__src = 0u;
      next_slot = os_channel_get_next_slot(v6, i, __n);
      if (!next_slot)
        break;
      v10 = next_slot;
      sub_10008CD70(a1, __src[0], WORD1(__n[0]), 1);
      if (*(unsigned __int8 *)(a1 + 16) == 255)
        goto LABEL_30;
      i = v10;
      if (*(_BYTE *)(a1 + 229))
        goto LABEL_28;
    }
  }
  else
  {
    for (i = 0; ; i = v24)
    {
      v33 = 0u;
      v34 = 0u;
      *(_OWORD *)__n = 0u;
      *(_OWORD *)__src = 0u;
      v23 = os_channel_get_next_slot(v6, i, __n);
      if (!v23)
        break;
      v24 = v23;
      sub_10008CD70(a1, __src[0], WORD1(__n[0]), 0);
      if (*(unsigned __int8 *)(a1 + 16) == 255)
      {
LABEL_30:
        v25 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v11);
        v26 = _NRLogIsLevelEnabled(v25, 16);

        if (v26)
        {
          v28 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v27);
          v29 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v28, 16, "%s%.30s:%-4d %@: Tried to read but we are cancelled", "", "-[NRLinkBluetooth readDataFromChannelWithIsUrgent:]", 6963, v29);

        }
        return;
      }
    }
  }
  v10 = i;
  if (i)
LABEL_28:
    os_channel_advance_slot(v6, v10);
  os_channel_sync(v7, 1);
}

void sub_100086FF4(void *a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  void *v5;
  int v6;
  uint64_t v7;
  void *StringFromNRTLVType;
  id v9;
  int v10;
  uint64_t v11;
  void *v12;
  int v13;
  uint64_t v14;
  int *v15;
  unint64_t v16;
  int *v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t next_slot;
  uint64_t v22;
  uint64_t v23;
  uint64_t packet;
  uint64_t next_buflet;
  uint64_t object_address;
  unsigned int data_offset;
  unsigned int data_length;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  unsigned int v33;
  int v34;
  void *v35;
  int v36;
  void *v37;
  id v38;
  void *v39;
  int v40;
  void *v41;
  id v42;
  uint64_t v43;
  uint64_t v44;
  unsigned int v45;
  uint64_t v46;
  size_t v47;
  int v48;
  uint64_t v49;
  unsigned __int16 v50;
  unsigned int v51;
  void *v52;
  int v53;
  void *v54;
  id v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  _BOOL4 v64;
  unint64_t v65;
  unsigned int v66;
  char v67;
  int *v68;
  uint64_t v69;
  int v70;
  uint64_t *v71;
  int v72;
  unsigned int v73;
  int v74;
  unsigned int v75;
  unsigned int v76;
  unint64_t v77;
  _DWORD *v78;
  uint64_t v79;
  BOOL v80;
  unsigned int v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  unsigned int v88;
  unsigned int v89;
  unsigned int v90;
  uint64_t *v91;
  uint64_t *v92;
  _BOOL4 v93;
  uint64_t *v94;
  int v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  char v99;
  int *v100;
  unsigned int v101;
  int v102;
  unsigned int v103;
  int v104;
  unsigned int v105;
  unsigned int v106;
  unsigned int v107;
  unsigned int v108;
  unint64_t v109;
  uint64_t v110;
  __int128 *v111;
  int v112;
  unint64_t v113;
  char *i;
  char v115;
  uint64_t *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  unsigned int v121;
  unsigned int v122;
  unsigned int v123;
  _BOOL4 v124;
  int v125;
  unint64_t v126;
  uint64_t v127;
  char v128;
  uint64_t v129;
  unsigned int v130;
  int v131;
  unsigned int v132;
  unsigned __int8 *v133;
  unsigned int v134;
  unsigned int v135;
  unsigned int v136;
  unint64_t v137;
  uint64_t v138;
  __int128 *v139;
  int v140;
  uint64_t v141;
  uint64_t v142;
  BOOL v143;
  uint64_t v144;
  unsigned int v145;
  int v146;
  uint64_t v147;
  unsigned int v148;
  unsigned int v149;
  unsigned int v150;
  size_t v151;
  uint64_t v152;
  unsigned int v153;
  int v154;
  uint64_t v155;
  unsigned int v156;
  uint64_t v157;
  unsigned int v158;
  uint64_t v159;
  unsigned __int8 *v160;
  unsigned __int8 *v161;
  uint64_t v162;
  int v163;
  int v164;
  __int128 *v165;
  unsigned int v166;
  unsigned __int8 **v167;
  unsigned __int8 *v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  int *v172;
  void *v173;
  int v174;
  void *v175;
  id v176;
  int *v177;
  unsigned int v178;
  unsigned int v179;
  uint64_t v180;
  uint64_t v181;
  unsigned int v182;
  uint64_t v183;
  uint64_t v184;
  unsigned int *v185;
  uint64_t v186;
  size_t v187;
  unsigned int v188;
  void *v189;
  uint64_t v190;
  void *v191;
  char *v192;
  char *v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  unsigned int v197;
  unsigned int v198;
  unsigned int v199;
  size_t v200;
  unsigned __int16 v201;
  uint64_t v202;
  uint64_t v203;
  unsigned int v204;
  uint64_t ESPSequenceNumberFromPacket;
  uint64_t v206;
  _QWORD *v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  unsigned int v211;
  unsigned int ESPSPIFromPacket;
  NSObject *v213;
  void *v214;
  int v215;
  uint64_t v216;
  void *v217;
  uint64_t v218;
  _QWORD *v219;
  void *v220;
  int v221;
  void *v222;
  id v223;
  unsigned __int8 *v224;
  unsigned __int8 *v225;
  uint64_t v226;
  uint64_t v227;
  unsigned int v228;
  unsigned int v229;
  unsigned int v230;
  size_t v231;
  id v232;
  id v233;
  NSObject *v234;
  uint64_t v235;
  uint64_t v236;
  void *v237;
  int v238;
  uint64_t v239;
  void *v240;
  id v241;
  void *v242;
  int v243;
  void *v244;
  id v245;
  uint64_t v246;
  void *v247;
  int v248;
  uint64_t v249;
  void *v250;
  id v251;
  void *v252;
  int v253;
  uint64_t v254;
  void *v255;
  id v256;
  void *v257;
  int v258;
  uint64_t v259;
  void *v260;
  id v261;
  void *v262;
  int v263;
  void *v264;
  id v265;
  unsigned __int16 v266;
  unsigned __int16 v267;
  uint64_t *v268;
  unsigned __int16 v269;
  unsigned int v270;
  unsigned int v271;
  unint64_t v272;
  unsigned int *v273;
  unsigned int v274;
  void *v275;
  int v276;
  uint64_t v277;
  void *v278;
  id v279;
  unsigned int v280;
  unsigned int v281;
  uint64_t v282;
  int v283;
  void *v284;
  int v285;
  uint64_t v286;
  void *v287;
  id v288;
  uint64_t v289;
  unint64_t v290;
  void *v291;
  int v292;
  void *v293;
  id v294;
  uint64_t v295;
  _QWORD *v296;
  void *v297;
  int v298;
  void *v299;
  id v300;
  void *v301;
  int v302;
  void *v303;
  id v304;
  uint64_t v305;
  void *v306;
  void *v307;
  int v308;
  void *v309;
  id v310;
  void *v311;
  int v312;
  uint64_t v313;
  void *v314;
  id v315;
  uint64_t v316;
  void *v317;
  void *v318;
  int v319;
  void *v320;
  int v321;
  void *v322;
  id v323;
  void *v324;
  int v325;
  uint64_t v326;
  void *v327;
  id v328;
  uint64_t *v329;
  unsigned __int16 v330;
  unsigned __int16 v331;
  void *v332;
  int v333;
  unsigned __int16 v334;
  void *v335;
  uint64_t v336;
  unsigned __int16 v337;
  unsigned __int16 v338;
  id v339;
  uint64_t v340;
  void *v341;
  void *v342;
  void *v343;
  int v344;
  void *v345;
  int v346;
  uint64_t v347;
  void *v348;
  id v349;
  void *v350;
  int v351;
  uint64_t v352;
  void *v353;
  id v354;
  void *v355;
  int v356;
  uint64_t v357;
  void *v358;
  id v359;
  void *v360;
  int v361;
  uint64_t v362;
  void *v363;
  id v364;
  int v365;
  uint64_t v366;
  uint64_t v367;
  uint64_t v368;
  uint64_t v369;
  uint64_t v370;
  uint64_t v371;
  uint64_t v372;
  void *v373;
  int v374;
  uint64_t v375;
  uint64_t v376;
  uint64_t v377;
  uint64_t v378;
  uint64_t v379;
  uint64_t v380;
  uint64_t v381;
  id v382;
  int v383;
  const char *v384;
  id v385;
  uint64_t v386;
  char *v387;
  uint64_t v388;
  uint64_t v389;
  uint64_t v390;
  uint64_t v391;
  uint64_t v392;
  uint64_t v393;
  uint64_t v394;
  uint64_t v395;
  uint64_t v396;
  uint64_t v397;
  uint64_t v398;
  uint64_t v399;
  uint64_t v400;
  const char *v401;
  id v402;
  uint64_t v403;
  uint64_t v404;
  uint64_t v405;
  uint64_t v406;
  uint64_t v407;
  uint64_t v408;
  unint64_t v409;
  id v410;
  char v411;
  id v412;
  unsigned __int16 v413;
  void *v414;
  int v415;
  id v416;
  int v417;
  id v418;
  uint64_t v419;
  char *v420;
  int *v421;
  uint64_t v422;
  id v423;
  id v424;
  int v425;
  id v426;
  uint64_t v427;
  uint64_t v428;
  void *v429;
  int IsLevelEnabled;
  void *v431;
  id v432;
  id v433;
  char v434;
  id v435;
  uint64_t v436;
  char *v437;
  int *v438;
  uint64_t v439;
  id v440;
  id v441;
  int v442;
  id v443;
  uint64_t v444;
  int *v445;
  id v446;
  int v447;
  id v448;
  uint64_t v449;
  int *v450;
  id v451;
  int v452;
  uint64_t *v453;
  id v454;
  void *v455;
  uint64_t v456;
  int *v457;
  uint64_t v458;
  id v459;
  int v460;
  id v461;
  uint64_t v462;
  uint64_t v463;
  id v464;
  int v465;
  id v466;
  uint64_t v467;
  int *v468;
  uint64_t v469;
  id v470;
  int v471;
  id v472;
  void *v473;
  int v474;
  uint64_t v475;
  id v476;
  int v477;
  id v478;
  id v479;
  int v480;
  id v481;
  void *v482;
  uint64_t v483;
  int *v484;
  uint64_t v485;
  void *v486;
  id v487;
  int v488;
  id v489;
  void *v490;
  uint64_t v491;
  int *v492;
  id v493;
  int v494;
  id v495;
  void *v496;
  uint64_t v497;
  int *v498;
  id v499;
  id v500;
  int v501;
  _BYTE *v502;
  unsigned __int16 v503;
  uint64_t v504;
  void *v505;
  char v506;
  uint64_t v507;
  void *v508;
  id v509;
  uint64_t v510;
  void *v511;
  unsigned __int16 v512;
  uint64_t v513;
  void *v514;
  uint64_t v515;
  uint64_t v516;
  uint64_t v517;
  uint64_t v518;
  uint64_t v519;
  uint64_t v520;
  id v521;
  int v522;
  id v523;
  uint64_t v524;
  uint64_t v525;
  id v526;
  int v527;
  id v528;
  uint64_t v529;
  uint64_t v530;
  unint64_t v531;
  id v532;
  int v533;
  id v534;
  void *v535;
  uint64_t v536;
  int *v537;
  uint64_t v538;
  uint64_t v539;
  id v540;
  int v541;
  id v542;
  uint64_t v543;
  int *v544;
  id v545;
  int v546;
  id v547;
  void *v548;
  uint64_t v549;
  uint64_t v550;
  uint64_t v551;
  id v552;
  int v553;
  id v554;
  void *v555;
  uint64_t v556;
  uint64_t v557;
  uint64_t v558;
  id v559;
  int v560;
  id v561;
  void *v562;
  uint64_t v563;
  uint64_t v564;
  uint64_t v565;
  uint64_t v566;
  id v567;
  int v568;
  id v569;
  id v570;
  int v571;
  id v572;
  void *v573;
  unint64_t v574;
  id v575;
  int v576;
  id v577;
  void *v578;
  uint64_t v579;
  int *v580;
  uint64_t v581;
  uint64_t v582;
  id v583;
  int v584;
  id v585;
  void *v586;
  uint64_t v587;
  uint64_t v588;
  id v589;
  int v590;
  id v591;
  void *v592;
  uint64_t v593;
  uint64_t v594;
  id v595;
  int v596;
  id v597;
  uint64_t v598;
  int *v599;
  id v600;
  int v601;
  id v602;
  uint64_t v603;
  int *v604;
  uint64_t v605;
  id v606;
  int v607;
  id v608;
  void *v609;
  uint64_t v610;
  int *v611;
  uint64_t v612;
  id v613;
  id v614;
  int v615;
  id v616;
  void *v617;
  uint64_t v618;
  uint64_t v619;
  uint64_t v620;
  uint64_t v621;
  uint64_t v622;
  _BYTE *v623;
  char *v624;
  uint64_t v625;
  uint64_t v626;
  unsigned int v627;
  char *v628;
  uint64_t v629;
  uint64_t *v630;
  uint64_t v631;
  unsigned int v632;
  unint64_t v633;
  uint64_t v634;
  unsigned int v635;
  uint64_t v636;
  unint64_t v637;
  unint64_t v638;
  uint64_t *v639;
  size_t v640;
  uint64_t v641;
  uint64_t v642;
  uint64_t *v643;
  uint64_t v644;
  uint64_t v645;
  __int128 v646;
  __int128 v647;
  __int128 v648;
  __int128 v649;
  _QWORD v650[2];
  __int128 v651;
  __int128 v652;
  __int128 v653;
  __int128 v654;
  void **v655;
  uint64_t v656;
  void (*v657)(uint64_t);
  void *v658;
  unint64_t v659;
  char v660;
  _BYTE v661[7];
  __int128 v662;
  __int128 v663;
  __int128 v664;
  __int128 v665;
  __int128 v666;
  __int128 v667;
  __int128 v668;
  __int128 v669;
  __int128 v670;
  __int128 v671;
  __int128 v672;
  __int128 v673;
  __int128 v674;
  __int128 v675;
  __int128 v676;
  __int128 v677;

  v1 = a1;
  v3 = (uint64_t)v1;
  if (gNRPacketLoggingEnabled)
  {
    v429 = (void *)_NRCopyLogObjectForNRUUID(v1[4], v2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v429, 1);

    if (IsLevelEnabled)
    {
      v431 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
      v432 = objc_msgSend((id)v3, "copyDescription");
      _NRLogWithArgs(v431, 1, "%s%.30s:%-4d %@: UrgentLink:start LtN-U loop function", "", "NRLinkLinkToNexusLoopUrgent", 4364, v432);

    }
  }
  v4 = *(unsigned __int8 *)(v3 + 16);
  if (v4 == 255)
  {
    v5 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
    v6 = _NRLogIsLevelEnabled(v5, 16);

    if (!v6)
      goto LABEL_458;
    StringFromNRTLVType = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v7);
    v9 = objc_msgSend((id)v3, "copyDescription");
    _NRLogWithArgs(StringFromNRTLVType, 16, "%s%.30s:%-4d %@: LinkToNexusLoopUrgent but cancelled", "", "NRLinkLinkToNexusLoopUrgent", 4367, v9);
    goto LABEL_456;
  }
  if (!*(_QWORD *)(v3 + 1127))
  {
    v473 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
    v474 = _NRLogIsLevelEnabled(v473, 17);

    if (!v474)
      goto LABEL_458;
    StringFromNRTLVType = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v475);
    v9 = objc_msgSend((id)v3, "copyDescription");
    _NRLogWithArgs(StringFromNRTLVType, 17, "%@: Tried to linkToNexusLoopUrgent but _urgentLinkInputRing is NULL", v9);
    goto LABEL_456;
  }
  if ((v4 - 1) < 2)
  {
    v10 = *(unsigned __int8 *)(v3 + 229);
    v11 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
    v12 = (void *)v11;
    if (v10)
    {
      v13 = _NRLogIsLevelEnabled(v11, 0);

      if (!v13)
        goto LABEL_458;
      StringFromNRTLVType = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v14);
      v9 = objc_msgSend((id)v3, "copyDescription");
      _NRLogWithArgs(StringFromNRTLVType, 0, "%s%.30s:%-4d %@: Tried to linkToNexusLoopUrgent after receiving urgent prelude", "", "NRLinkLinkToNexusLoopUrgent", 4379, v9);
    }
    else
    {
      v365 = _NRLogIsLevelEnabled(v11, 17);

      if (!v365)
        goto LABEL_458;
      StringFromNRTLVType = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v366);
      v9 = objc_msgSend((id)v3, "copyDescription");
      _NRLogWithArgs(StringFromNRTLVType, 17, "%@: Tried to linkToNexusLoopUrgent but bad state", v9);
    }
    goto LABEL_456;
  }
  v625 = 0;
  v626 = 0;
  v623 = v661;
  v624 = (char *)&v663 + 8;
  v628 = (char *)&v662 + 8;
  v15 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
  v16 = 0x1001E0000;
  v17 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
  v636 = v3;
LABEL_14:
  v18 = 0;
  v19 = 0;
  v644 = 0;
  v631 = 0;
  v633 = 0;
  v639 = 0;
  v653 = 0u;
  v654 = 0u;
  v651 = 0u;
  v652 = 0u;
  v650[0] = 0;
  v650[1] = 0;
  LODWORD(v638) = *(_BYTE *)(v3 + v15[316]) != 0;
  while (1)
  {
    while (1)
    {
LABEL_15:
      v20 = 1887;
      *(_QWORD *)(v3 + 1887) = 4;
      v642 = 1887;
      if ((_WORD)v18 && (unsigned __int16)v18 >= (unsigned __int16)v19)
      {
        if ((unsigned __int16)v18 != (unsigned __int16)v19)
        {
          v424 = sub_100070AC8();
          v425 = _NRLogIsLevelEnabled(v424, 16);

          if (v425)
          {
            v426 = sub_100070AC8();
            _NRLogWithArgs(v426, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: curLinkInputSlotPartialBytesAlreadyRead == linkInputBufferLength", "", "NRLinkLinkToNexusLoopUrgent", 4420);

          }
          goto LABEL_493;
        }
        *(_QWORD *)(v3 + 1887) = 12;
      }
      else if ((_WORD)v18)
      {
        *(_QWORD *)(v3 + 1887) = 36;
        if (!v639)
          goto LABEL_363;
        LODWORD(v645) = v19;
        goto LABEL_28;
      }
      next_slot = os_channel_get_next_slot(*(_QWORD *)(v3 + 1127), v633, &v651);
      v20 = v642;
      *(_QWORD *)(v3 + v642) |= 0x10uLL;
      if (!next_slot)
      {
LABEL_363:
        if (*(_BYTE *)(v3 + 227) && *(_QWORD *)(v3 + 1143))
        {
          *(_BYTE *)(v3 + 227) = 0;
          ++*(_QWORD *)(v3 + 1159);
          if (gNRPacketLoggingEnabled)
          {
            v345 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
            v346 = _NRLogIsLevelEnabled(v345, 1);

            if (v346)
            {
              v348 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v347);
              v349 = objc_msgSend((id)v3, "copyDescription");
              _NRLogWithArgs(v348, 1, "%s%.30s:%-4d %@: source-resume: UrgentLinkInput", "", "NRLinkResumeUrgentLinkInputSource", 826, v349);

            }
          }
          dispatch_resume(*(dispatch_object_t *)(v3 + 1143));
          v20 = v642;
        }
        if (!*(_BYTE *)(v3 + 217) && *(_QWORD *)(v3 + 703))
        {
          *(_BYTE *)(v3 + 217) = 1;
          ++*(_QWORD *)(v3 + 719);
          if (gNRPacketLoggingEnabled)
          {
            v355 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
            v356 = _NRLogIsLevelEnabled(v355, 1);

            if (v356)
            {
              v358 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v357);
              v359 = objc_msgSend((id)v3, "copyDescription");
              _NRLogWithArgs(v358, 1, "%s%.30s:%-4d %@: source-suspend: NexusVIOutput", "", "NRLinkSuspendNexusVIOutputSource", 837, v359);

            }
          }
          dispatch_suspend(*(dispatch_object_t *)(v3 + 703));
          v20 = v642;
        }
        *(_QWORD *)(v3 + v20) |= 0x40uLL;
        goto LABEL_390;
      }
      v22 = next_slot;
      v23 = *(_QWORD *)(v3 + 1127);
      v639 = (uint64_t *)v22;
      packet = os_channel_slot_get_packet(v23, v22);
      next_buflet = os_packet_get_next_buflet(packet, 0);
      object_address = os_buflet_get_object_address();
      data_offset = os_buflet_get_data_offset(next_buflet);
      data_length = os_buflet_get_data_length(next_buflet);
      if (data_length >= 0x10000)
      {
        v416 = sub_100070AC8();
        v417 = _NRLogIsLevelEnabled(v416, 16);

        if (v417)
        {
          v418 = sub_100070AC8();
          _NRLogWithArgs(v418, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: inputBufferLength <= 65535", "", "NRLinkLinkToNexusLoopUrgent", 4436);

        }
        goto LABEL_470;
      }
      LODWORD(v645) = data_length;
      v644 = object_address + data_offset;
      os_packet_get_flow_uuid(packet, v650);
      v17 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
      v18 = 0;
      if (*(_BYTE *)(v3 + 245))
      {
        *(_BYTE *)(v3 + 245) = 0;
        LODWORD(v638) = 1;
      }
      else
      {
        LODWORD(v638) = v638 | BYTE2(v650[0]);
      }
LABEL_28:
      if (!*(_BYTE *)(v3 + 227) && *(_QWORD *)(v3 + 1143))
      {
        *(_BYTE *)(v3 + 227) = 1;
        ++*(_QWORD *)(v3 + 1159);
        if (gNRPacketLoggingEnabled)
        {
          v236 = v18;
          v237 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
          v238 = _NRLogIsLevelEnabled(v237, 1);

          v18 = v236;
          if (v238)
          {
            v240 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v239);
            v241 = objc_msgSend((id)v3, "copyDescription");
            _NRLogWithArgs(v240, 1, "%s%.30s:%-4d %@: source-suspend: UrgentLinkInput", "", "NRLinkSuspendUrgentLinkInputSource", 818, v241);

            v18 = v236;
          }
        }
        dispatch_suspend(*(dispatch_object_t *)(v3 + 1143));
      }
      v29 = *(_DWORD *)(v3 + *(int *)(v16 + 956));
      if (v29 <= *(_DWORD *)(v3 + v17[238]))
        break;
      v30 = v18;
      v31 = *(unsigned int *)(v3 + v17[238]);
      v32 = *(unsigned __int8 *)(*(_QWORD *)(v3 + 1319) + v31);
      if (*(_BYTE *)(*(_QWORD *)(v3 + 1319) + v31))
        goto LABEL_45;
      while (1)
      {
        v39 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
        v40 = _NRLogIsLevelEnabled(v39, 1);

        if (v40)
        {
          v41 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
          v42 = objc_msgSend((id)v3, "copyDescription");
          _NRLogWithArgs(v41, 1, "%s%.30s:%-4d %@: Handling Pad0 in linkReadBuffer", "", "NRLinkLinkToNexusLoopUrgent", 4485, v42);

        }
        ++*(_DWORD *)(v3 + v17[238]);
        v29 = *(_DWORD *)(v3 + *(int *)(v16 + 956));
        v43 = *(unsigned int *)(v3 + v17[238]);
        if (v29 <= v43)
          break;
        v32 = *(unsigned __int8 *)(*(_QWORD *)(v3 + 1319) + v43);
        if (*(_BYTE *)(*(_QWORD *)(v3 + 1319) + v43))
        {
          v18 = v30;
          v31 = *(unsigned int *)(v3 + v17[238]);
          goto LABEL_45;
        }
      }
      if (v29 != (_DWORD)v43)
      {
        v526 = sub_100070AC8();
        v527 = _NRLogIsLevelEnabled(v526, 16);

        if (v527)
        {
          v528 = sub_100070AC8();
          _NRLogWithArgs(v528, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: self->_filledInUrgentLinkReadBufferBytes == self->_handledUrgentLinkReadBufferBytes", "", "NRLinkLinkToNexusLoopUrgent", 4489);

        }
        v529 = _os_log_pack_size(12);
        v387 = (char *)&v622 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
        v530 = *__error();
        v398 = _os_log_pack_fill(v387, v529, v530, &_mh_execute_header, "%{public}s Assertion Failed: self->_filledInUrgentLinkReadBufferBytes == self->_handledUrgentLinkReadBufferBytes");
        goto LABEL_478;
      }
      v52 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
      v53 = _NRLogIsLevelEnabled(v52, 1);

      v18 = v30;
      v19 = v645;
      if (v53)
      {
        v54 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
        v55 = objc_msgSend((id)v3, "copyDescription");
        _NRLogWithArgs(v54, 1, "%s%.30s:%-4d %@: Ended linkReadBuffer on a Pad0 handled=%u filledIn=%u", "", "NRLinkLinkToNexusLoopUrgent", 4491, v55, *(unsigned int *)(v3 + v17[238]), *(unsigned int *)(v3 + *(int *)(v16 + 956)));

        v19 = v645;
        v18 = v30;
      }
    }
    while (1)
    {
      v32 = *(unsigned __int8 *)(v644 + (unsigned __int16)v18);
      if (*(_BYTE *)(v644 + (unsigned __int16)v18))
        break;
      v34 = v18;
      v35 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
      v36 = _NRLogIsLevelEnabled(v35, 1);

      if (v36)
      {
        v37 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
        v38 = objc_msgSend((id)v3, "copyDescription");
        _NRLogWithArgs(v37, 1, "%s%.30s:%-4d %@: Handling Pad0 in linkInputSlot alreadyRead=%u", "", "NRLinkLinkToNexusLoopUrgent", 4509, v38, (unsigned __int16)v34);

      }
      v18 = (v34 + 1);
      v33 = (unsigned __int16)(v34 + 1);
      if (v33 >= (unsigned __int16)v645)
      {
        if (v33 == (unsigned __int16)v645)
        {
          v262 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
          v263 = _NRLogIsLevelEnabled(v262, 1);

          if (v263)
          {
            v264 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
            v265 = objc_msgSend((id)v3, "copyDescription");
            _NRLogWithArgs(v264, 1, "%s%.30s:%-4d %@: Ended linkInputSlot on a Pad0 handled=%u filledIn=%u", "", "NRLinkLinkToNexusLoopUrgent", 4515, v265, *(unsigned int *)(v3 + v17[238]), *(unsigned int *)(v3 + *(int *)(v16 + 956)));

          }
          goto LABEL_390;
        }
        v470 = sub_100070AC8();
        v471 = _NRLogIsLevelEnabled(v470, 16);

        if (v471)
        {
          v472 = sub_100070AC8();
          _NRLogWithArgs(v472, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: curLinkInputSlotPartialBytesAlreadyRead == linkInputBufferLength", "", "NRLinkLinkToNexusLoopUrgent", 4513);

        }
LABEL_493:
        v427 = _os_log_pack_size(12);
        v387 = (char *)&v622 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
        v428 = *__error();
        v398 = _os_log_pack_fill(v387, v427, v428, &_mh_execute_header, "%{public}s Assertion Failed: curLinkInputSlotPartialBytesAlreadyRead == linkInputBufferLength");
LABEL_478:
        *(_DWORD *)v398 = 136446210;
        v401 = "NRLinkLinkToNexusLoopUrgent";
        goto LABEL_479;
      }
    }
    v31 = *(unsigned int *)(v3 + v17[238]);
    v29 = *(_DWORD *)(v3 + *(int *)(v16 + 956));
LABEL_45:
    v635 = v32;
    v44 = v642;
    v632 = v29;
    if (v29 <= (int)v31 + 2)
    {
      if (v29 == (_DWORD)v31 + 2)
      {
        v47 = *(unsigned __int8 *)(*(_QWORD *)(v3 + 1319) + (v31 + 1));
        if ((unsigned __int16)v18 >= (unsigned __int16)v645)
        {
          v46 = 0;
          v48 = 0;
          v49 = 512;
        }
        else
        {
          v46 = *(unsigned __int8 *)(v644 + (unsigned __int16)v18);
          v48 = 1;
          v49 = 256;
        }
      }
      else
      {
        if (v29 == (_DWORD)v31 + 1)
          v50 = v18;
        else
          v50 = v18 + 1;
        if (v50 + 2 >= (unsigned __int16)v645)
        {
          v47 = 0;
          v46 = 0;
          v48 = 0;
          v49 = 2048;
        }
        else
        {
          v51 = bswap32(*(unsigned __int16 *)(v644 + v50));
          v46 = BYTE2(v51);
          v47 = HIBYTE(v51);
          v48 = 1;
          v49 = 1024;
        }
      }
    }
    else
    {
      v45 = bswap32(*(unsigned __int16 *)(*(_QWORD *)(v3 + 1319) + (v31 + 1)));
      v46 = BYTE2(v45);
      v47 = HIBYTE(v45);
      v48 = 1;
      v49 = 128;
    }
    v56 = *(_QWORD *)(v3 + v642) | v49;
    *(_QWORD *)(v3 + v642) = v56;
    v676 = 0u;
    v677 = 0u;
    v674 = 0u;
    v675 = 0u;
    v672 = 0u;
    v673 = 0u;
    v670 = 0u;
    v671 = 0u;
    v668 = 0u;
    v669 = 0u;
    v666 = 0u;
    v667 = 0u;
    v664 = 0u;
    v665 = 0u;
    v662 = 0u;
    v663 = 0u;
    v57 = v632 - v31;
    v629 = v31;
    if (v632 > v31)
    {
      v58 = v18;
      *(_QWORD *)&v662 = *(_QWORD *)(v3 + 1319) + v31;
      v59 = v46 | ((_DWORD)v47 << 8);
      if (v59 + 5 < v57)
        v57 = v59 + 5;
      if (!(_DWORD)v57)
      {
        v433 = sub_100070AC8();
        v434 = _NRLogIsLevelEnabled(v433, 16);

        if ((v434 & 1) != 0)
        {
          v435 = sub_100070AC8();
          _NRLogWithArgs(v435, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: lrbIOVecLen > 0; tlvLen=%u filledInLinkReadBufferBytes=%u handledLi"
            "nkReadBufferBytes=%u",
            "",
            "NRLinkLinkToNexusLoopUrgent",
            4597,
            v59,
            *(_DWORD *)(v3 + *(int *)(v16 + 956)),
            *(_DWORD *)(v3 + v17[238]));

        }
        v436 = _os_log_pack_size(30);
        v437 = (char *)&v622 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
        v438 = __error();
        v439 = _os_log_pack_fill(v437, v436, *v438, &_mh_execute_header, "%{public}s Assertion Failed: lrbIOVecLen > 0; tlvLen=%u filledInLinkReadBufferBytes=%u handledLinkReadBufferBytes=%u");
        sub_10008C184(v439, (uint64_t)"NRLinkLinkToNexusLoopUrgent", v59, *(_DWORD *)(v3 + *(int *)(v16 + 956)), *(_DWORD *)(v3 + v17[238]));
        goto LABEL_499;
      }
      v60 = v57;
      DWORD2(v662) = v57;
      v56 |= 0x1000uLL;
      *(_QWORD *)(v3 + v44) = v56;
      v61 = 1;
      v18 = v58;
    }
    else
    {
      v60 = 0;
      v61 = 0;
    }
    v62 = (unsigned __int16)v18;
    v63 = (unsigned __int16)v645;
    v64 = (unsigned __int16)v18 < (unsigned __int16)v645;
    if ((unsigned __int16)v18 >= (unsigned __int16)v645)
    {
      if (!v48)
      {
        LODWORD(v634) = (unsigned __int16)v18 < (unsigned __int16)v645;
        v640 = v47;
        v641 = v46;
        v643 = (uint64_t *)v60;
        v69 = v18;
        v66 = v61;
        v68 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
        goto LABEL_80;
      }
LABEL_78:
      v70 = 0;
      v68 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
      goto LABEL_96;
    }
    if (v48 && (v46 | ((unint64_t)v47 << 8)) + 5 <= v60)
      goto LABEL_78;
    *((_QWORD *)&v662 + 2 * v61) = v644 + (unsigned __int16)v18;
    if ((unsigned __int16)v645 == (unsigned __int16)v18)
    {
      v464 = sub_100070AC8();
      v465 = _NRLogIsLevelEnabled(v464, 16);

      if (v465)
      {
        v466 = sub_100070AC8();
        _NRLogWithArgs(v466, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: clisIOVecLen > 0; urgentLinkInputBufferLength=%u curLinkInputSlotPart"
          "ialBytesAlreadyRead=%u",
          "",
          "NRLinkLinkToNexusLoopUrgent",
          4612,
          v63,
          v62);

      }
      v467 = _os_log_pack_size(24);
      v387 = (char *)&v622 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
      v468 = __error();
      v469 = _os_log_pack_fill(v387, v467, *v468, &_mh_execute_header, "%{public}s Assertion Failed: clisIOVecLen > 0; urgentLinkInputBufferLength=%u curLinkInputSlotPartialBytesAlreadyRead=%u");
      *(_DWORD *)v469 = 136446722;
      *(_QWORD *)(v469 + 4) = "NRLinkLinkToNexusLoopUrgent";
      *(_WORD *)(v469 + 12) = 1024;
      *(_DWORD *)(v469 + 14) = v63;
      *(_WORD *)(v469 + 18) = 1024;
      *(_DWORD *)(v469 + 20) = v62;
      goto LABEL_480;
    }
    v65 = (unint64_t)(&v662 + v61);
    *(_DWORD *)(v65 + 8) = v63 - (unsigned __int16)v18;
    v60 = v60 + (_DWORD)v63 - (unsigned __int16)v18;
    *(_QWORD *)(v3 + v44) = v56 | 0x2000;
    v66 = v61 + 1;
    if (v60 < 3)
      v67 = 1;
    else
      v67 = v48;
    if ((v67 & 1) != 0)
    {
      v68 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
      if (!v48)
      {
        LODWORD(v634) = v64;
        v640 = v47;
        v641 = v46;
        v643 = (uint64_t *)v60;
        *(_QWORD *)(v3 + v44) = v56 | 0xA000;
        v69 = v645;
LABEL_80:
        v71 = v639;
        v72 = 0;
        v637 = v66;
        LODWORD(v61) = v66;
        v18 = v69;
        goto LABEL_102;
      }
      goto LABEL_92;
    }
    v68 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
    if (DWORD2(v662) < 3)
    {
      if (DWORD2(v662) == 2)
      {
        if (v632 <= v629)
          goto LABEL_553;
        v74 = *(unsigned __int8 *)(v662 + 1);
        v75 = *(unsigned __int8 *)v663;
        goto LABEL_91;
      }
      if (DWORD2(v662) != 1)
      {
        v552 = sub_100070AC8();
        v553 = _NRLogIsLevelEnabled(v552, 16);

        if (v553)
        {
          v554 = sub_100070AC8();
          v555 = (void *)createIOVecString(&v662, (v61 + 1));
          _NRLogWithArgs(v554, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: ioVecs[0].len == 1; %@",
            "",
            "nrReadTLVLenHBOFromIOVec",
            269,
            v555);

        }
        v556 = _os_log_pack_size(22);
        v420 = (char *)&v622 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
        v557 = *__error();
        v558 = _os_log_pack_fill(v420, v556, v557, &_mh_execute_header, "%{public}s Assertion Failed: ioVecs[0].len == 1; %@");
        goto LABEL_566;
      }
      if (DWORD2(v663) < 2)
      {
        v614 = sub_100070AC8();
        v615 = _NRLogIsLevelEnabled(v614, 16);

        if (v615)
        {
          v616 = sub_100070AC8();
          v617 = (void *)createIOVecString(&v662, (v61 + 1));
          _NRLogWithArgs(v616, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: numIOVecs > 2; %@",
            "",
            "nrReadTLVLenHBOFromIOVec",
            274,
            v617);

        }
        v618 = _os_log_pack_size(22);
        v420 = (char *)&v622 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
        v619 = *__error();
        v558 = _os_log_pack_fill(v420, v618, v619, &_mh_execute_header, "%{public}s Assertion Failed: numIOVecs > 2; %@");
        goto LABEL_566;
      }
      if (v632 <= v629)
      {
        v559 = sub_100070AC8();
        v560 = _NRLogIsLevelEnabled(v559, 16);

        if (v560)
        {
          v561 = sub_100070AC8();
          v562 = (void *)createIOVecString(&v662, (v61 + 1));
          _NRLogWithArgs(v561, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: numIOVecs > 1; %@",
            "",
            "nrReadTLVLenHBOFromIOVec",
            271,
            v562);

        }
        v563 = _os_log_pack_size(22);
        v420 = (char *)&v622 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
        v564 = *__error();
        v558 = _os_log_pack_fill(v420, v563, v564, &_mh_execute_header, "%{public}s Assertion Failed: numIOVecs > 1; %@");
LABEL_566:
        v565 = v558;
        v566 = createIOVecString(&v662, (v61 + 1));
        *(_DWORD *)v565 = 136446466;
        *(_QWORD *)(v565 + 4) = "nrReadTLVLenHBOFromIOVec";
        *(_WORD *)(v565 + 12) = 2112;
        *(_QWORD *)(v565 + 14) = v566;
        goto LABEL_533;
      }
      v73 = *(unsigned __int16 *)v663;
    }
    else
    {
      v73 = *(unsigned __int16 *)(v662 + 1);
    }
    v74 = v73;
    v75 = v73 >> 8;
LABEL_91:
    v76 = bswap32(v74 | (v75 << 8));
    v46 = BYTE2(v76);
    v47 = HIBYTE(v76);
LABEL_92:
    v77 = (v46 | ((unint64_t)v47 << 8)) + 5;
    if (v77 >= v60)
    {
      v56 = *(_QWORD *)(v3 + v44) | 0x8000;
      *(_QWORD *)(v3 + v44) = v56;
      v70 = 1;
      v61 = (v61 + 1);
      v18 = v645;
    }
    else
    {
      v78 = (_DWORD *)(v65 | 8);
      v79 = v3;
      v3 = (v60 - v77);
      v56 = *(_QWORD *)(v79 + v44) | 0x4000;
      *(_QWORD *)(v79 + v44) = v56;
      v80 = *v78 == (_DWORD)v3;
      *v78 -= v3;
      if (v80)
      {
        v531 = v60;
        v532 = sub_100070AC8();
        v533 = _NRLogIsLevelEnabled(v532, 16);

        if (v533)
        {
          v534 = sub_100070AC8();
          v535 = (void *)createIOVecString(&v662, (v61 + 1));
          _NRLogWithArgs(v534, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: ioVecs[iovecIndex - 1].len > 0; Shrunk ioVecs[%u] down by %u to 0 -"
            " %@ ioVecContentLen=%u alreadyRead=%u",
            "",
            "NRLinkLinkToNexusLoopUrgent",
            4636,
            v61,
            v3,
            v535,
            v531,
            v63);

        }
        v536 = _os_log_pack_size(46);
        v420 = (char *)&v622 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
        v537 = __error();
        v538 = _os_log_pack_fill(v420, v536, *v537, &_mh_execute_header, "%{public}s Assertion Failed: ioVecs[iovecIndex - 1].len > 0; Shrunk ioVecs[%u] down by %u to 0 - %@ ioV"
                 "ecContentLen=%u alreadyRead=%u");
        v539 = createIOVecString(&v662, (v61 + 1));
        sub_10008C1B4(v538, (uint64_t)"NRLinkLinkToNexusLoopUrgent", v61, v3, v539, v531, v63);
        goto LABEL_533;
      }
      v70 = 1;
      v61 = (v61 + 1);
      v18 = (v645 - v3);
      v60 = (v46 | ((unint64_t)v47 << 8)) + 5;
      v3 = v636;
    }
LABEL_96:
    if (v635 - 100 < 6 || v635 - 2 < 4)
    {
      v81 = 2000;
      goto LABEL_99;
    }
    if (v635 == 1)
    {
      v81 = 255;
LABEL_99:
      v82 = v46 | ((_DWORD)v47 << 8);
      if (v82 > v81)
      {
        StringFromNRTLVType = (void *)((uint64_t (*)(void))createStringFromNRTLVType)();
        v9 = (id)createIOVecStringWithContents(&v662, v61);
        sub_100074F70((void *)v3, CFSTR("Received invalid TLV len %u for %@ (max=%u) %@"), v367, v368, v369, v370, v371, v372, v82);
        goto LABEL_456;
      }
    }
    v637 = v61;
    if ((v46 | ((unint64_t)v47 << 8)) + 5 <= v60)
    {
      v91 = v639;
      v92 = v639;
      v17 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
      v93 = v638;
      goto LABEL_107;
    }
    LODWORD(v634) = v70;
    v640 = v47;
    v641 = v46;
    v643 = (uint64_t *)v60;
    v72 = 1;
    v71 = v639;
LABEL_102:
    v648 = 0uLL;
    v649 = 0uLL;
    v646 = 0uLL;
    v647 = 0uLL;
    v3 = v636;
    v83 = os_channel_get_next_slot(*(_QWORD *)(v636 + v68[232]), v71, &v646);
    if (!v83)
    {
      v94 = v71;
      v16 = 0x1001E0000;
      v93 = v638;
      v92 = v71;
      v70 = v634;
LABEL_175:
      v44 = v642;
      v60 = (unint64_t)v643;
      v56 = *(_QWORD *)(v636 + v642) | 0x10000;
      *(_QWORD *)(v636 + v642) = v56;
      v17 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
      LODWORD(v47) = v640;
      LODWORD(v46) = v641;
      if ((v72 & 1) == 0)
        goto LABEL_377;
      goto LABEL_176;
    }
    v84 = (uint64_t *)v83;
    v634 = v18;
    v85 = os_channel_slot_get_packet(*(_QWORD *)(v3 + v68[232]), v83);
    v86 = os_packet_get_next_buflet(v85, 0);
    v87 = os_buflet_get_object_address();
    v88 = os_buflet_get_data_offset(v86);
    v89 = os_buflet_get_data_length(v86);
    if (HIWORD(v89))
    {
LABEL_464:
      if (qword_1001E46D8 != -1)
        dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
      if (_NRLogIsLevelEnabled(qword_1001E46D0, 16))
      {
        if (qword_1001E46D8 != -1)
          dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
        _NRLogWithArgs(qword_1001E46D0, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: inputBufferLength <= 65535", "", "NRLinkLinkToNexusLoopUrgent", 4677);
      }
LABEL_470:
      v396 = _os_log_pack_size(12);
      v387 = (char *)&v622 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
      v397 = *__error();
      v398 = _os_log_pack_fill(v387, v396, v397, &_mh_execute_header, "%{public}s Assertion Failed: inputBufferLength <= 65535");
      goto LABEL_478;
    }
    v90 = v89;
    os_packet_get_flow_uuid(v85, v650);
    if (*(_BYTE *)(v3 + 245))
    {
      *(_BYTE *)(v3 + 245) = 0;
      v2 = 1;
    }
    else
    {
      v2 = (v638 | BYTE2(v650[0])) & 1;
    }
    v44 = v642;
    v95 = (int)v643;
    v3 = v636;
    v47 = v640;
    v46 = v641;
    v96 = v87 + v88;
    *((_QWORD *)&v662 + 2 * v637) = v96;
    if (!v90)
    {
LABEL_471:
      if (qword_1001E46D8 != -1)
        dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
      if (_NRLogIsLevelEnabled(qword_1001E46D0, 16))
      {
        if (qword_1001E46D8 != -1)
          dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
        _NRLogWithArgs(qword_1001E46D0, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: lookAheadLinkInputBufferLength > 0", "", "NRLinkLinkToNexusLoopUrgent", 4689);
      }
      v399 = _os_log_pack_size(12);
      v387 = (char *)&v622 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
      v400 = *__error();
      v398 = _os_log_pack_fill(v387, v399, v400, &_mh_execute_header, "%{public}s Assertion Failed: lookAheadLinkInputBufferLength > 0");
      goto LABEL_478;
    }
    v97 = v637;
    *((_DWORD *)&v662 + 4 * v637 + 2) = v90;
    v98 = *(_QWORD *)(v3 + v44) | 0x20000;
    *(_QWORD *)(v3 + v44) = v98;
    v60 = v90 + v95;
    if (v60 < 3)
      v99 = 1;
    else
      v99 = v72;
    if ((v99 & 1) == 0)
    {
      v16 = 0x1001E0000;
      v100 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
      if (DWORD2(v662) > 2)
      {
        v101 = *(unsigned __int16 *)(v662 + 1);
LABEL_119:
        v102 = v101;
        v103 = v101 >> 8;
        goto LABEL_126;
      }
      if (DWORD2(v662) == 2)
      {
        if (!(_DWORD)v61)
        {
LABEL_553:
          v540 = sub_100070AC8();
          v541 = _NRLogIsLevelEnabled(v540, 16);

          if (v541)
          {
            v542 = sub_100070AC8();
            _NRLogWithArgs(v542, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: numIOVecs > 1", "", "nrReadTLVLenHBOFromIOVec", 265);

          }
          v543 = _os_log_pack_size(12);
          v387 = (char *)&v622 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
          v544 = __error();
          v398 = _os_log_pack_fill(v387, v543, *v544, &_mh_execute_header, "%{public}s Assertion Failed: numIOVecs > 1");
          *(_DWORD *)v398 = 136446210;
          v401 = "nrReadTLVLenHBOFromIOVec";
          goto LABEL_479;
        }
        v102 = *(unsigned __int8 *)(v662 + 1);
        v103 = *(unsigned __int8 *)v663;
LABEL_126:
        v105 = v102 | (v103 << 8);
        v106 = bswap32(v105);
        v46 = BYTE2(v106);
        v47 = HIBYTE(v106);
        if (v635 - 100 >= 6 && v635 - 2 >= 4)
        {
          if (v635 != 1)
            goto LABEL_130;
          v107 = 255;
        }
        else
        {
          v107 = 2000;
        }
        v108 = __rev16(v105);
        if (v108 > v107)
        {
          v638 = v97 + 1;
LABEL_455:
          StringFromNRTLVType = (void *)createStringFromNRTLVType(v635, v2);
          v9 = (id)createIOVecStringWithContents(&v662, (unsigned __int16)v638);
          sub_100074F70((void *)v3, CFSTR("LookAhead received invalid TLV len %u for %@ (max=%u) %@"), v376, v377, v378, v379, v380, v381, v108);
          goto LABEL_456;
        }
        goto LABEL_130;
      }
      if (DWORD2(v662) == 1)
      {
        if (DWORD2(v663) > 1)
        {
          if ((_DWORD)v61)
          {
            v101 = *(unsigned __int16 *)v663;
            goto LABEL_119;
          }
          v574 = v97 + 1;
          v575 = sub_100070AC8();
          v576 = _NRLogIsLevelEnabled(v575, 16);

          if (v576)
          {
            v577 = sub_100070AC8();
            v578 = (void *)createIOVecString(&v662, v574);
            _NRLogWithArgs(v577, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: numIOVecs > 1; %@",
              "",
              "nrReadTLVLenHBOFromIOVec",
              271,
              v578);

          }
          v579 = _os_log_pack_size(22);
          v387 = (char *)&v622 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
          v580 = __error();
          v581 = _os_log_pack_fill(v387, v579, *v580, &_mh_execute_header, "%{public}s Assertion Failed: numIOVecs > 1; %@");
          v582 = createIOVecString(&v662, v574);
          *(_DWORD *)v581 = 136446466;
          *(_QWORD *)(v581 + 4) = "nrReadTLVLenHBOFromIOVec";
LABEL_585:
          *(_WORD *)(v581 + 12) = 2112;
          *(_QWORD *)(v581 + 14) = v582;
          goto LABEL_480;
        }
        if (v61 < 2)
        {
          v638 = v97 + 1;
LABEL_577:
          v583 = sub_100070AC8();
          v584 = _NRLogIsLevelEnabled(v583, 16);

          if (v584)
          {
            v585 = sub_100070AC8();
            v586 = (void *)createIOVecString(&v662, (unsigned __int16)v638);
            _NRLogWithArgs(v585, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: numIOVecs > 2; %@",
              "",
              "nrReadTLVLenHBOFromIOVec",
              274,
              v586);

          }
          v587 = _os_log_pack_size(22);
          v387 = (char *)&v622 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
          v588 = *__error();
          v551 = _os_log_pack_fill(v387, v587, v588, &_mh_execute_header, "%{public}s Assertion Failed: numIOVecs > 2; %@");
        }
        else
        {
          if (DWORD2(v663) == 1)
          {
            v102 = *(unsigned __int8 *)v663;
            v103 = *(unsigned __int8 *)v664;
            goto LABEL_126;
          }
          v638 = v97 + 1;
LABEL_581:
          v589 = sub_100070AC8();
          v590 = _NRLogIsLevelEnabled(v589, 16);

          if (v590)
          {
            v591 = sub_100070AC8();
            v592 = (void *)createIOVecString(&v662, (unsigned __int16)v638);
            _NRLogWithArgs(v591, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: ioVecs[1].len == 1; %@",
              "",
              "nrReadTLVLenHBOFromIOVec",
              275,
              v592);

          }
          v593 = _os_log_pack_size(22);
          v387 = (char *)&v622 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
          v594 = *__error();
          v551 = _os_log_pack_fill(v387, v593, v594, &_mh_execute_header, "%{public}s Assertion Failed: ioVecs[1].len == 1; %@");
        }
      }
      else
      {
        v638 = v97 + 1;
LABEL_557:
        v545 = sub_100070AC8();
        v546 = _NRLogIsLevelEnabled(v545, 16);

        if (v546)
        {
          v547 = sub_100070AC8();
          v548 = (void *)createIOVecString(&v662, (unsigned __int16)v638);
          _NRLogWithArgs(v547, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: ioVecs[0].len == 1; %@",
            "",
            "nrReadTLVLenHBOFromIOVec",
            269,
            v548);

        }
        v549 = _os_log_pack_size(22);
        v387 = (char *)&v622 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
        v550 = *__error();
        v551 = _os_log_pack_fill(v387, v549, v550, &_mh_execute_header, "%{public}s Assertion Failed: ioVecs[0].len == 1; %@");
      }
      v581 = v551;
      v582 = createIOVecString(&v662, (unsigned __int16)v638);
      *(_DWORD *)v581 = 136446466;
      *(_QWORD *)(v581 + 4) = "nrReadTLVLenHBOFromIOVec";
      goto LABEL_585;
    }
    v16 = 0x1001E0000;
    v100 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
    if (!v72)
    {
      v104 = 0;
      goto LABEL_132;
    }
LABEL_130:
    v109 = (v46 | ((unint64_t)v47 << 8)) + 5;
    v98 = *(_QWORD *)(v3 + v44);
    if (v109 <= v60)
    {
      v56 = v98 | 0x40000;
      *(_QWORD *)(v3 + v44) = v56;
      v110 = (v60 - v109);
      v16 = v97;
      v111 = &v662 + v97;
      v112 = *((_DWORD *)v111 + 2) - v110;
      *((_DWORD *)v111 + 2) = v112;
      if (!v112)
      {
        v638 = v97 + 1;
        v409 = v60;
        goto LABEL_484;
      }
      v634 = v90 - v110;
      v651 = v646;
      v652 = v647;
      v104 = 1;
      v653 = v648;
      v654 = v649;
      v60 = (v46 | ((unint64_t)v47 << 8)) + 5;
      LODWORD(v645) = v90;
      v644 = v96;
      v630 = v84;
      v16 = 0x1001E0000;
      v91 = v639;
      goto LABEL_135;
    }
    v104 = 1;
LABEL_132:
    v91 = v639;
    v56 = v98 | 0x80000;
    *(_QWORD *)(v3 + v44) = v56;
    v630 = v91;
LABEL_135:
    v113 = v97 + 2;
    for (i = &v624[16 * v97]; ; i += 16)
    {
      v637 = v113 - 1;
      v93 = v2 != 0;
      if ((v104 & 1) != 0
        && ((unint64_t)(unsigned __int16)v47 << 8) + (unsigned __int16)v46 + 5 <= v60)
      {
        break;
      }
      LODWORD(v639) = v104;
      v115 = v2;
      v638 = v113;
      v640 = v47;
      v641 = v46;
      v643 = (uint64_t *)v60;
      v648 = 0u;
      v649 = 0u;
      v646 = 0u;
      v647 = 0u;
      v116 = v84;
      v117 = os_channel_get_next_slot(*(_QWORD *)(v3 + v100[232]), v84, &v646);
      if (!v117)
      {
        v70 = 1;
        v92 = v630;
        v18 = v634;
        v94 = v84;
        LOBYTE(v72) = (_BYTE)v639;
        goto LABEL_175;
      }
      v84 = (uint64_t *)v117;
      v118 = os_channel_slot_get_packet(*(_QWORD *)(v3 + v100[232]), v117);
      v119 = os_packet_get_next_buflet(v118, 0);
      v120 = os_buflet_get_object_address();
      v121 = os_buflet_get_data_offset(v119);
      v122 = os_buflet_get_data_length(v119);
      if (v122 >= 0x10000)
        goto LABEL_464;
      v123 = v122;
      v124 = v115 != 0;
      os_packet_get_flow_uuid(v118, v650);
      if (*(_BYTE *)(v3 + 245))
      {
        *(_BYTE *)(v3 + 245) = 0;
        v2 = 1;
      }
      else
      {
        v2 = (v124 | BYTE2(v650[0])) & 1;
      }
      v44 = v642;
      v125 = (int)v643;
      v47 = v640;
      v46 = v641;
      v126 = v638;
      v94 = v116;
      v127 = v120 + v121;
      *((_QWORD *)i - 1) = v127;
      v3 = v636;
      v128 = (char)v639;
      if (!v123)
        goto LABEL_471;
      *(_DWORD *)i = v123;
      v129 = *(_QWORD *)(v3 + v44);
      *(_QWORD *)(v3 + v44) = v129 | 0x20000;
      v60 = v123 + v125;
      if (v128 & 1 | (v60 < 3))
      {
        v16 = 0x1001E0000;
        if ((v128 & 1) == 0)
        {
          v56 = v129 | 0xA0000;
          *(_QWORD *)(v3 + v44) = v56;
          if (v126 == 16)
            goto LABEL_482;
          v104 = 0;
          goto LABEL_138;
        }
        goto LABEL_166;
      }
      v16 = (unint64_t)&OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
      if (DWORD2(v662) >= 3)
      {
        v130 = *(unsigned __int16 *)(v662 + 1);
LABEL_152:
        v131 = v130;
        v132 = v130 >> 8;
        goto LABEL_162;
      }
      if (DWORD2(v662) == 2)
      {
        v133 = (unsigned __int8 *)v663;
        v131 = *(unsigned __int8 *)(v662 + 1);
      }
      else
      {
        if (DWORD2(v662) != 1)
          goto LABEL_557;
        if (DWORD2(v663) > 1)
        {
          v130 = *(unsigned __int16 *)v663;
          goto LABEL_152;
        }
        if (v637 <= 1)
          goto LABEL_577;
        if (DWORD2(v663) != 1)
          goto LABEL_581;
        v133 = (unsigned __int8 *)v664;
        v131 = *(unsigned __int8 *)v663;
      }
      v132 = *v133;
LABEL_162:
      v134 = v131 | (v132 << 8);
      v135 = bswap32(v134);
      v46 = BYTE2(v135);
      v47 = HIBYTE(v135);
      if (v635 - 100 >= 6 && v635 - 2 >= 4)
      {
        if (v635 != 1)
          goto LABEL_166;
        v136 = 255;
      }
      else
      {
        v136 = 2000;
      }
      v108 = __rev16(v134);
      if (v108 > v136)
        goto LABEL_455;
LABEL_166:
      v137 = ((unint64_t)(unsigned __int16)v47 << 8) + (unsigned __int16)v46 + 5;
      v138 = *(_QWORD *)(v3 + v44);
      if (v137 <= v60)
      {
        v56 = v138 | 0x40000;
        *(_QWORD *)(v3 + v44) = v56;
        v110 = (v60 - v137);
        v139 = &v662 + (int)v126 - 1;
        v140 = *((_DWORD *)v139 + 2) - v110;
        *((_DWORD *)v139 + 2) = v140;
        if (!v140)
        {
          v409 = v60;
          v16 = (v126 - 1);
LABEL_484:
          v410 = sub_100070AC8();
          v411 = _NRLogIsLevelEnabled(v410, 16);

          if ((v411 & 1) != 0)
          {
            v412 = sub_100070AC8();
            v413 = v638;
            v414 = (void *)createIOVecString(&v662, (unsigned __int16)v638);
            v415 = (unsigned __int16)v634;
            _NRLogWithArgs(v412, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: ioVecs[iovecIndex - 1].len > 0; Shrunk last ioVecs[%u] down by %u"
              " to 0 - %@ ioVecContentLen=%u alreadyRead=%u",
              "",
              "NRLinkLinkToNexusLoopUrgent",
              4726,
              v16,
              v110,
              v414,
              v409,
              (unsigned __int16)v634);

          }
          else
          {
            v415 = (unsigned __int16)v634;
            v413 = v638;
          }
          v419 = _os_log_pack_size(46);
          v420 = (char *)&v622 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
          v421 = __error();
          v422 = _os_log_pack_fill(v420, v419, *v421, &_mh_execute_header, "%{public}s Assertion Failed: ioVecs[iovecIndex - 1].len > 0; Shrunk last ioVecs[%u] down by %u to 0 -"
                   " %@ ioVecContentLen=%u alreadyRead=%u");
          v423 = (id)createIOVecString(&v662, v413);
          sub_10008C1B4(v422, (uint64_t)"NRLinkLinkToNexusLoopUrgent", v16, v110, (uint64_t)v423, v409, v415);
          goto LABEL_532;
        }
        v634 = v123 - v110;
        v651 = v646;
        v652 = v647;
        v653 = v648;
        v654 = v649;
        if (v126 == 16)
        {
          v644 = v127;
          LODWORD(v645) = v123;
          v60 = ((unint64_t)(unsigned __int16)v47 << 8) + (unsigned __int16)v46 + 5;
          goto LABEL_189;
        }
        v104 = 1;
        v630 = v84;
        v644 = v127;
        LODWORD(v645) = v123;
        v60 = ((unint64_t)(unsigned __int16)v47 << 8) + (unsigned __int16)v46 + 5;
      }
      else
      {
        v56 = v138 | 0x80000;
        *(_QWORD *)(v3 + v44) = v56;
        if (v126 == 16)
        {
          v143 = v137 > v60;
          v137 = v60;
          v84 = v630;
          if (v143)
            goto LABEL_481;
LABEL_189:
          v93 = v2 != 0;
          v640 = (unsigned __int16)(v46 | ((_WORD)v47 << 8));
          v637 = 16;
          if (v640 + 5 <= v137)
          {
            v141 = v46 | ((_DWORD)v47 << 8);
            v639 = v84;
            v18 = v634;
LABEL_191:
            v142 = v56 | 0x200000;
            v633 = (unint64_t)v84;
            goto LABEL_192;
          }
          v17 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
LABEL_377:
          v268 = v94;
          LODWORD(v638) = v93;
          if (gNRPacketLoggingEnabled)
          {
            v329 = (uint64_t *)v60;
            v330 = v46;
            v331 = v47;
            v332 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v636 + 32), v2);
            v333 = _NRLogIsLevelEnabled(v332, 1);

            if (v333)
            {
              v334 = v330;
              v335 = (void *)v636;
              v336 = *(_QWORD *)(v636 + 32);
              v643 = v329;
              v337 = v334;
              v338 = v331;
              v645 = _NRCopyLogObjectForNRUUID(v336, v2);
              v339 = objc_msgSend(v335, "copyDescription");
              v341 = (void *)createStringFromNRTLVType(v635, v340);
              v621 = v337 | (v338 << 8);
              v342 = (void *)v645;
              _NRLogWithArgs(v645, 1, "%s%.30s:%-4d %@: UrgentLink:LtN-U not enough input bytes from linkInputSlot %u to fit %@ tlvLen %u", "", "NRLinkLinkToNexusLoopUrgent", 4764, v339, v643, v341, v621);

            }
          }
          v3 = v636;
          v269 = v637;
          v270 = v632;
          v271 = v629;
          if (*(_BYTE *)(v636 + 227) && *(_QWORD *)(v636 + 1143))
          {
            *(_BYTE *)(v636 + 227) = 0;
            ++*(_QWORD *)(v3 + 1159);
            if (gNRPacketLoggingEnabled)
            {
              v350 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
              v351 = _NRLogIsLevelEnabled(v350, 1);

              if (v351)
              {
                v353 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v352);
                v354 = objc_msgSend((id)v3, "copyDescription");
                _NRLogWithArgs(v353, 1, "%s%.30s:%-4d %@: source-resume: UrgentLinkInput", "", "NRLinkResumeUrgentLinkInputSource", 826, v354);

              }
            }
            dispatch_resume(*(dispatch_object_t *)(v3 + 1143));
            v270 = v632;
          }
          if ((v270 > v271) < v269)
          {
            v272 = v269 - (unint64_t)(v270 > v271);
            v273 = (unsigned int *)&v628[16 * (v270 > v271)];
            do
            {
              if (gNRPacketLoggingEnabled)
              {
                v275 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
                v276 = _NRLogIsLevelEnabled(v275, 1);

                if (v276)
                {
                  v278 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v277);
                  v279 = objc_msgSend((id)v3, "copyDescription");
                  _NRLogWithArgs(v278, 1, "%s%.30s:%-4d %@: partial TLV - consolidating %u bytes from linkInputSlot buf %p to linkReadBuffer filledIn=%u handled=%u", "", "NRLinkLinkToNexusLoopUrgent", 4771, v279, *v273, *((_QWORD *)v273 - 1), *(unsigned int *)(v3 + *(int *)(v16 + 956)), *(unsigned int *)(v3 + v17[238]));

                }
              }
              memcpy((void *)(*(_QWORD *)(v3 + 1319) + *(unsigned int *)(v3 + *(int *)(v16 + 956))), *((const void **)v273 - 1), *v273);
              v274 = *v273;
              v273 += 4;
              *(_DWORD *)(v3 + *(int *)(v16 + 956)) += v274;
              --v272;
            }
            while (v272);
          }
          *(_QWORD *)(v3 + v642) |= 0x100000uLL;
          v633 = (unint64_t)v268;
LABEL_390:
          if (!v633)
            goto LABEL_411;
          v280 = *(_DWORD *)(v3 + *(int *)(v16 + 956));
          v281 = *(_DWORD *)(v3 + v17[238]);
          if (v280 <= v281)
          {
            if (v281 == v280)
            {
              *(_QWORD *)(v3 + 1887) |= 0x400000000uLL;
              if (gNRPacketLoggingEnabled)
              {
                v320 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
                v321 = _NRLogIsLevelEnabled(v320, 1);

                if (v321)
                {
                  v322 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
                  v323 = objc_msgSend((id)v3, "copyDescription");
                  _NRLogWithArgs(v322, 1, "%s%.30s:%-4d %@: UrgentLink:resetting the linkReadBuffer (filledIn=%u)", "", "NRLinkLinkToNexusLoopUrgent", 5043, v323, *(unsigned int *)(v3 + *(int *)(v16 + 956)));

                }
              }
              *(_DWORD *)(v3 + *(int *)(v16 + 956)) = 0;
LABEL_398:
              *(_DWORD *)(v3 + v17[238]) = 0;
              goto LABEL_399;
            }
            v521 = sub_100070AC8();
            v522 = _NRLogIsLevelEnabled(v521, 16);

            if (v522)
            {
              v523 = sub_100070AC8();
              _NRLogWithArgs(v523, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: self->_handledUrgentLinkReadBufferBytes == self->_filledInUrgentLinkReadBufferBytes", "", "NRLinkLinkToNexusLoopUrgent", 5040);

            }
            v524 = _os_log_pack_size(12);
            v387 = (char *)&v622 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
            v525 = *__error();
            v398 = _os_log_pack_fill(v387, v524, v525, &_mh_execute_header, "%{public}s Assertion Failed: self->_handledUrgentLinkReadBufferBytes == self->_filledInUrgentLinkReadBufferBytes");
            goto LABEL_478;
          }
          if (v281 > *(_DWORD *)(v3 + 275))
          {
            *(_QWORD *)(v3 + 1887) |= 0x80000000uLL;
            if (gNRPacketLoggingEnabled)
            {
              v324 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
              v325 = _NRLogIsLevelEnabled(v324, 1);

              if (v325)
              {
                v327 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v326);
                v328 = objc_msgSend((id)v3, "copyDescription");
                _NRLogWithArgs(v327, 1, "%s%.30s:%-4d %@: UrgentLink:memmoving the linkReadBuffer by handled=%u (filledIn=%u) thresh=%u", "", "NRLinkLinkToNexusLoopUrgent", 5021, v328, *(unsigned int *)(v3 + v17[238]), *(unsigned int *)(v3 + *(int *)(v16 + 956)), *(unsigned int *)(v3 + 275));

              }
            }
            v282 = *(unsigned int *)(v3 + v17[238]);
            memmove(*(void **)(v3 + 1319), (const void *)(*(_QWORD *)(v3 + 1319) + v282), (*(_DWORD *)(v3 + *(int *)(v16 + 956)) - v282));
            *(_DWORD *)(v3 + *(int *)(v16 + 956)) -= *(_DWORD *)(v3 + v17[238]);
            goto LABEL_398;
          }
          v289 = *(_QWORD *)(v3 + 1887);
          if (v281)
          {
            v290 = v289 | (unint64_t)&_mh_execute_header;
            *(_QWORD *)(v3 + 1887) = v289 | (unint64_t)&_mh_execute_header;
            if (gNRPacketLoggingEnabled)
            {
              v291 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
              v292 = _NRLogIsLevelEnabled(v291, 1);

              if (v292)
              {
                v293 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
                v294 = objc_msgSend((id)v3, "copyDescription");
                _NRLogWithArgs(v293, 1, "%s%.30s:%-4d %@: UrgentLink:not memmoving the linkReadBuffer thresh handled=%u filledIn=%u thresh=%u", "", "NRLinkLinkToNexusLoopUrgent", 5031, v294, *(unsigned int *)(v3 + v17[238]), *(unsigned int *)(v3 + *(int *)(v16 + 956)), *(unsigned int *)(v3 + 275));
                goto LABEL_439;
              }
              goto LABEL_399;
            }
LABEL_407:
            *(_QWORD *)(v3 + 1887) = v290 | 0x800000000;
          }
          else
          {
            v290 = v289 | 0x200000000;
            *(_QWORD *)(v3 + 1887) = v289 | 0x200000000;
            if (!gNRPacketLoggingEnabled)
              goto LABEL_407;
            v343 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
            v344 = _NRLogIsLevelEnabled(v343, 1);

            if (v344)
            {
              v293 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
              v294 = objc_msgSend((id)v3, "copyDescription");
              _NRLogWithArgs(v293, 1, "%s%.30s:%-4d %@: UrgentLink:not memmoving the linkReadBuffer zero handled=%u filledIn=%u thresh=%u", "", "NRLinkLinkToNexusLoopUrgent", 5037, v294, *(unsigned int *)(v3 + v17[238]), *(unsigned int *)(v3 + *(int *)(v16 + 956)), *(unsigned int *)(v3 + 275));
LABEL_439:

            }
LABEL_399:
            v283 = gNRPacketLoggingEnabled;
            *(_QWORD *)(v3 + 1887) |= 0x800000000uLL;
            if (v283)
            {
              v284 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
              v285 = _NRLogIsLevelEnabled(v284, 1);

              if (v285)
              {
                v287 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v286);
                v288 = objc_msgSend((id)v3, "copyDescription");
                _NRLogWithArgs(v287, 1, "%s%.30s:%-4d %@: UrgentLink:advancing past linkInputSlot=%p and syncing urgent link input", "", "NRLinkLinkToNexusLoopUrgent", 5049, v288, v633);

              }
            }
          }
          if (gNRPacketLoggingEnabled)
          {
            v305 = objc_claimAutoreleasedReturnValue(+[NSDate date](NSDate, "date"));
            v306 = *(void **)(v3 + 1711);
            *(_QWORD *)(v3 + 1711) = v305;

          }
          os_channel_advance_slot(*(_QWORD *)(v3 + 1127), v633);
          os_channel_sync(*(_QWORD *)(v3 + 1119), 1);
          ++*(_QWORD *)(v3 + 1455);
          if (gNRPacketLoggingEnabled)
          {
            v307 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
            v308 = _NRLogIsLevelEnabled(v307, 1);

            if (v308)
            {
              v309 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
              v310 = objc_msgSend((id)v3, "copyDescription");
              _NRLogWithArgs(v309, 1, "%s%.30s:%-4d %@: UrgentLink:read from urgent pipe", "", "NRLinkLinkToNexusLoopUrgent", 5054, v310);

            }
          }
LABEL_411:
          if (v631)
          {
            if (*(_QWORD *)(v3 + 687))
            {
              *(_QWORD *)(v3 + 1887) |= 0x1000000000uLL;
              if (gNRPacketLoggingEnabled)
              {
                v311 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
                v312 = _NRLogIsLevelEnabled(v311, 1);

                if (v312)
                {
                  v314 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v313);
                  v315 = objc_msgSend((id)v3, "copyDescription");
                  _NRLogWithArgs(v314, 1, "%s%.30s:%-4d %@: UrgentLink:advancing past nexusVIOutputSlot=%p and syncing nexus VI output", "", "NRLinkLinkToNexusLoopUrgent", 5061, v315, v631);

                }
                if (gNRPacketLoggingEnabled)
                {
                  v316 = objc_claimAutoreleasedReturnValue(+[NSDate date](NSDate, "date"));
                  v317 = *(void **)(v3 + 1671);
                  *(_QWORD *)(v3 + 1671) = v316;

                }
              }
              os_channel_advance_slot(*(_QWORD *)(v3 + 687), v631);
              os_channel_sync(*(_QWORD *)(v3 + 671), 0);
              ++*(_QWORD *)(v3 + 767);
              if (gNRPacketLoggingEnabled)
              {
                v318 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
                v319 = _NRLogIsLevelEnabled(v318, 1);

                if (v319)
                {
                  v303 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
                  v304 = objc_msgSend((id)v3, "copyDescription");
                  _NRLogWithArgs(v303, 1, "%s%.30s:%-4d %@: UrgentLink:read from urgent pipe: %llu packets, %llu bytes", "", "NRLinkLinkToNexusLoopUrgent", 5066, v304, v626, v625);
LABEL_430:

                }
              }
            }
            else
            {
              v301 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
              v302 = _NRLogIsLevelEnabled(v301, 17);

              if (v302)
              {
                v303 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
                v304 = objc_msgSend((id)v3, "copyDescription");
                _NRLogWithArgs(v303, 17, "%@: Tried to sync nexus output but _nexusOutputRing is NULL", v304);
                goto LABEL_430;
              }
            }
          }
          if (*(_QWORD *)(v3 + 1887) && *(_QWORD *)(v3 + 1895))
          {
            *(_BYTE *)(v3 + 253) %= *(_BYTE *)(v3 + 252);
            v295 = *(_QWORD *)(v3 + 1895);
            v296 = (_QWORD *)(v295 + 8 * *(unsigned __int8 *)(v3 + 253));
            if ((unint64_t)(v296 + 1) <= v295 + 8 * (unint64_t)*(unsigned __int8 *)(v3 + 252))
            {
              if ((v296 & 7) == 0)
              {
                *v296 = *(_QWORD *)(v3 + 1887);
                ++*(_BYTE *)(v3 + 253);
                *(_QWORD *)(v3 + 1887) = 0;
              }
            }
            else
            {
              v297 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
              v298 = _NRLogIsLevelEnabled(v297, 17);

              if (v298)
              {
                v299 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
                v300 = objc_msgSend((id)v3, "copyDescription");
                _NRLogWithArgs(v299, 17, "%@: invalid index for link log list (curIdx: %u)", v300, *(unsigned __int8 *)(v3 + 253));

              }
            }
          }
          v15 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
          *(_BYTE *)(v3 + 226) = v638 & 1;
          if (v633 | v631)
            goto LABEL_14;
          if (!gNRPacketLoggingEnabled)
            goto LABEL_458;
          v373 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
          v374 = _NRLogIsLevelEnabled(v373, 1);

          if (!v374)
            goto LABEL_458;
          StringFromNRTLVType = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v375);
          v9 = objc_msgSend((id)v3, "copyDescription");
          _NRLogWithArgs(StringFromNRTLVType, 1, "%s%.30s:%-4d %@: UrgentLink:out of LtN-U outer loop", "", "NRLinkLinkToNexusLoopUrgent", 5085, v9);
LABEL_456:

          goto LABEL_457;
        }
        v104 = 1;
      }
LABEL_138:
      v100 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
      v113 = v126 + 1;
      v91 = v94;
    }
    v70 = 1;
    v17 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
    v18 = v634;
    v92 = v630;
LABEL_107:
    v94 = v91;
LABEL_176:
    v639 = v92;
    v137 = v60;
    v141 = v46 | ((_DWORD)v47 << 8);
    v640 = (unsigned __int16)(v46 | ((_WORD)v47 << 8));
    if (v640 + 5 > v60)
      goto LABEL_377;
    if (v70)
    {
      v84 = v639;
      v3 = v636;
      goto LABEL_191;
    }
    v142 = v56 | 0x400000;
    v3 = v636;
LABEL_192:
    v643 = (uint64_t *)v60;
    v634 = v18;
    *(_QWORD *)(v3 + v44) = v142;
    *(_QWORD *)(v3 + 1407) += v137;
    LODWORD(v638) = v93;
    v641 = v141;
    if ((char)v635 < 100)
    {
      if (!(_WORD)v637)
      {
        v446 = sub_100070AC8();
        v447 = _NRLogIsLevelEnabled(v446, 16);

        if (v447)
        {
          v448 = sub_100070AC8();
          _NRLogWithArgs(v448, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: numIOVecs > 0", "", "nrChecksumIOVecInner", 143);

        }
        v449 = _os_log_pack_size(12);
        v387 = (char *)&v622 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
        v450 = __error();
        v398 = _os_log_pack_fill(v387, v449, *v450, &_mh_execute_header, "%{public}s Assertion Failed: numIOVecs > 0");
        *(_DWORD *)v398 = 136446210;
        v401 = "nrChecksumIOVecInner";
        goto LABEL_479;
      }
      v627 = (unsigned __int16)v637;
      v630 = &v622;
      v152 = 0;
      v153 = 0;
      v154 = 0;
      v155 = 0;
      v156 = (unsigned __int16)v141 + 3;
      v157 = (unsigned __int16)v637;
      v3 = (uint64_t)v628;
      while (1)
      {
        v158 = v156 - v153;
        if (v156 <= v153)
        {
          v159 = 0;
          goto LABEL_228;
        }
        if (*(_DWORD *)v3 >= v158)
          v159 = v158;
        else
          v159 = *(unsigned int *)v3;
        if (!(_DWORD)v159)
        {
          v382 = sub_100070AC8();
          v383 = _NRLogIsLevelEnabled(v382, 16);

          v384 = "nrChecksumUpdate";
          if (v383)
          {
            v385 = sub_100070AC8();
            _NRLogWithArgs(v385, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: dataLen > 0", "", "nrChecksumUpdate", 69);

          }
          v386 = _os_log_pack_size(12);
          v387 = (char *)&v622 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
          v388 = *__error();
          v389 = _os_log_pack_fill(v387, v386, v388, &_mh_execute_header, "%{public}s Assertion Failed: dataLen > 0");
          goto LABEL_462;
        }
        v160 = *(unsigned __int8 **)(v3 - 8);
        if (v154)
        {
          LOWORD(v646) = 0;
          LOWORD(v646) = *v160 << 8;
          v155 = os_inet_checksum(&v646, 2, v155);
          if (v159 < 2)
            goto LABEL_216;
          v161 = v160 + 1;
          v162 = (v159 - 1);
        }
        else
        {
          v161 = *(unsigned __int8 **)(v3 - 8);
          v162 = v159;
        }
        v155 = os_inet_checksum(v161, v162, v155);
LABEL_216:
        if ((v159 & 1) != 0)
          v154 ^= 1u;
        v153 += v159;
        if (v153 >= v156 && v159 < *(_DWORD *)v3)
          goto LABEL_228;
        ++v152;
        v3 += 16;
        if (v157 == v152)
        {
          LOWORD(v152) = v637;
LABEL_228:
          v3 = v636;
          v16 = (unint64_t)&OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
          if (v153 == v156)
          {
            v163 = ~(_BYTE)v155;
            v164 = ((unsigned __int16)~(_WORD)v155 >> 8);
            v165 = &v662 + (unsigned __int16)v152;
            v166 = *((_DWORD *)v165 + 2);
            if (v166 >= (int)v159 + 2)
            {
              v168 = (unsigned __int8 *)(*(_QWORD *)v165 + v159);
              if (*v168 == v163 && v168[1] == v164)
                goto LABEL_238;
              v476 = sub_100070AC8();
              v477 = _NRLogIsLevelEnabled(v476, 16);

              if (!v477)
                goto LABEL_537;
              v478 = sub_100070AC8();
              _NRLogWithArgs(v478, 16, "%s%.30s:%-4d checksum failed same IOVec received 0x%02x%02x != computed 0x%02x%02x", "");
              goto LABEL_536;
            }
            if (v166 < (int)v159 + 1)
            {
              v479 = sub_100070AC8();
              v480 = _NRLogIsLevelEnabled(v479, 16);

              if (v480)
              {
                v481 = sub_100070AC8();
                v482 = (void *)createIOVecString(&v662, (unsigned __int16)v637);
                _NRLogWithArgs(v481, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: iovecs[iovecIndex].len >= bytesToCheckThisIOVec + 1; %@, iove"
                  "cIndex=%u bytesToCheckThisIOVec=%u",
                  "",
                  "nrChecksumIOVecInner",
                  189,
                  v482,
                  (unsigned __int16)v152,
                  v159);

              }
              v483 = _os_log_pack_size(34);
              v420 = (char *)&v622 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
              v484 = __error();
              v485 = _os_log_pack_fill(v420, v483, *v484, &_mh_execute_header, "%{public}s Assertion Failed: iovecs[iovecIndex].len >= bytesToCheckThisIOVec + 1; %@, iovecIndex="
                       "%u bytesToCheckThisIOVec=%u");
              v486 = (void *)createIOVecString(&v662, (unsigned __int16)v637);
            }
            else if ((unsigned __int16)v152 + 1 >= v627)
            {
              v487 = sub_100070AC8();
              v488 = _NRLogIsLevelEnabled(v487, 16);

              if (v488)
              {
                v489 = sub_100070AC8();
                v490 = (void *)createIOVecString(&v662, (unsigned __int16)v637);
                _NRLogWithArgs(v489, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: iovecIndex + 1 < numIOVecs; %@, iovecIndex=%u bytesToCheckThisIOVec=%u",
                  "",
                  "nrChecksumIOVecInner",
                  191,
                  v490,
                  (unsigned __int16)v152,
                  v159);

              }
              v491 = _os_log_pack_size(34);
              v420 = (char *)&v622 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
              v492 = __error();
              v485 = _os_log_pack_fill(v420, v491, *v492, &_mh_execute_header, "%{public}s Assertion Failed: iovecIndex + 1 < numIOVecs; %@, iovecIndex=%u bytesToCheckThisIOVec=%u");
              v486 = (void *)createIOVecString(&v662, (unsigned __int16)v637);
            }
            else
            {
              v167 = (unsigned __int8 **)(&v662 + (unsigned __int16)v152 + 1);
              if (*((_DWORD *)v167 + 2))
              {
                if (*(unsigned __int8 *)(*(_QWORD *)v165 + v159) == v163 && **v167 == v164)
                  goto LABEL_238;
LABEL_534:
                v500 = sub_100070AC8();
                v501 = _NRLogIsLevelEnabled(v500, 16);

                if (!v501)
                  goto LABEL_537;
                v478 = sub_100070AC8();
                _NRLogWithArgs(v478, 16, "%s%.30s:%-4d checksum failed disjoint IOVec received 0x%02x%02x != computed 0x%02x%02x", "");
LABEL_536:

                goto LABEL_537;
              }
              v493 = sub_100070AC8();
              v494 = _NRLogIsLevelEnabled(v493, 16);

              if (v494)
              {
                v495 = sub_100070AC8();
                v496 = (void *)createIOVecString(&v662, (unsigned __int16)v637);
                _NRLogWithArgs(v495, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: iovecs[iovecIndex + 1].len >= 1; %@, iovecIndex=%u bytesToCheckThisIOVec=%u",
                  "",
                  "nrChecksumIOVecInner",
                  193,
                  v496,
                  (unsigned __int16)v152,
                  v159);

              }
              v497 = _os_log_pack_size(34);
              v420 = (char *)&v622 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
              v498 = __error();
              v485 = _os_log_pack_fill(v420, v497, *v498, &_mh_execute_header, "%{public}s Assertion Failed: iovecs[iovecIndex + 1].len >= 1; %@, iovecIndex=%u bytesToCheckThisIOVec=%u");
              v486 = (void *)createIOVecString(&v662, (unsigned __int16)v637);
            }
            v423 = v486;
            sub_1000435D0(v485, (uint64_t)"nrChecksumIOVecInner", (uint64_t)v423, (unsigned __int16)v152, v159);
LABEL_532:

LABEL_533:
            v499 = sub_100070AC8();
            _NRLogAbortWithPack(v499, v420);
            goto LABEL_534;
          }
          v459 = sub_100070AC8();
          v460 = _NRLogIsLevelEnabled(v459, 16);

          v384 = "nrChecksumIOVecInner";
          if (v460)
          {
            v461 = sub_100070AC8();
            _NRLogWithArgs(v461, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: computedBytes == writtenLength", "", "nrChecksumIOVecInner", 164);

          }
          v462 = _os_log_pack_size(12);
          v387 = (char *)&v622 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
          v463 = *__error();
          v389 = _os_log_pack_fill(v387, v462, v463, &_mh_execute_header, "%{public}s Assertion Failed: computedBytes == writtenLength");
LABEL_462:
          *(_DWORD *)v389 = 136446210;
          *(_QWORD *)(v389 + 4) = v384;
          goto LABEL_480;
        }
      }
    }
    LOWORD(v646) = 0;
    if (!(_WORD)v637)
      goto LABEL_500;
    v16 = 0;
    v144 = 0;
    v145 = bswap32(v141);
    v146 = (v635 >> 4) ^ HIWORD(v145);
    v3 = (16 * v635) ^ HIBYTE(v145);
    v147 = 16 * (unsigned __int16)v637;
    v630 = (uint64_t *)((unsigned __int16)v141 + 3);
    v148 = (unsigned __int16)v141 + 3;
    while (1)
    {
      v149 = *(_DWORD *)((char *)&v662 + v16 + 8);
      if (!v148)
        goto LABEL_200;
      if (v148 <= v149)
        break;
      v148 -= v149;
LABEL_196:
      v16 += 16;
      if (v147 == v16)
        goto LABEL_223;
    }
    if (v148 >= v149)
    {
LABEL_204:
      v148 = 0;
      goto LABEL_196;
    }
LABEL_200:
    v150 = v149 - v148;
    if (v150 >= 2 - (int)v144)
      v151 = (2 - v144);
    else
      v151 = v150;
    memcpy((char *)&v646 + v144, (const void *)(*(_QWORD *)((char *)&v662 + v16) + v148), v151);
    v144 = (v151 + v144);
    if (v144 <= 1)
      goto LABEL_204;
LABEL_223:
    if ((_DWORD)v144 != 2)
    {
      v451 = sub_100070AC8();
      v452 = _NRLogIsLevelEnabled(v451, 16);

      v453 = v630;
      if (v452)
      {
        v454 = sub_100070AC8();
        v455 = (void *)createIOVecString(&v662, (unsigned __int16)v637);
        _NRLogWithArgs(v454, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: bytesWritten == length; bytesWritten (%u) != length (%u), offset: %u, ioVec: %@",
          "",
          "nrWriteIOVecToBuffer",
          342,
          v144,
          2,
          v453,
          v455);

      }
      v456 = _os_log_pack_size(40);
      v420 = (char *)&v622 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
      v457 = __error();
      v458 = _os_log_pack_fill(v420, v456, *v457, &_mh_execute_header, "%{public}s Assertion Failed: bytesWritten == length; bytesWritten (%u) != length (%u), offset: %u, ioVec: %@");
      v423 = (id)createIOVecString(&v662, (unsigned __int16)v637);
      sub_100043594(v458, (uint64_t)"nrWriteIOVecToBuffer", v144, 2, (int)v453, (uint64_t)v423);
      goto LABEL_532;
    }
    v80 = (unsigned __int16)v646 == (unsigned __int16)(v146 | (unsigned __int16)((_WORD)v3 << 8));
    v3 = v636;
    v16 = 0x1001E0000;
    if (!v80)
    {
LABEL_537:
      v502 = *(id *)(v3 + 1863);
      v503 = v641;
      if (v502)
        v502[96] = 1;

      v505 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v504);
      v506 = _NRLogIsLevelEnabled(v505, 17);

      if ((v506 & 1) != 0)
      {
        v508 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v507);
        v509 = objc_msgSend((id)v3, "copyDescription");
        v511 = (void *)createStringFromNRTLVType(v635, v510);
        v644 = v503;
        v642 = *(unsigned int *)(v3 + *(int *)(v16 + 956));
        v512 = v637;
        v513 = *(unsigned int *)(v636 + 323);
        v514 = (void *)createIOVecString(&v662, (unsigned __int16)v637);
        v645 = (unsigned __int16)v634;
        v620 = v513;
        v3 = v636;
        _NRLogWithArgs(v508, 17, "%@: Invalid checksum detected in urgent loop on read type %@ len %u filledIn=%u handled=%u in %@ ioVecContentLen=%u alreadyRead=%u curLinkInputSlot=%p", v509, v511, v503, v642, v620, v514, v643, (unsigned __int16)v634, v639);

      }
      else
      {
        v645 = (unsigned __int16)v634;
        v512 = v637;
      }
      StringFromNRTLVType = (void *)createStringFromNRTLVType(v635, v507);
      v9 = (id)createIOVecString(&v662, v512);
      sub_100074F70((void *)v3, CFSTR("Invalid checksum detected in urgent loop on read type %@ len %u filledIn=%u handled=%u in %@ ioVecContentLen=%u alreadyRead=%u curLinkInputSlot=%p"), v515, v516, v517, v518, v519, v520, (uint64_t)StringFromNRTLVType);
      goto LABEL_456;
    }
LABEL_238:
    v648 = 0u;
    v649 = 0u;
    v646 = 0u;
    v647 = 0u;
    v169 = os_channel_get_next_slot(*(_QWORD *)(v3 + 687), v631, &v646);
    v17 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
    if (v169)
      break;
    v177 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
    v178 = v632;
    v179 = v629;
    if (*(_BYTE *)(v3 + 217) && *(_QWORD *)(v3 + 703))
    {
      *(_BYTE *)(v3 + 217) = 0;
      ++*(_QWORD *)(v3 + 719);
      if (gNRPacketLoggingEnabled)
      {
        v252 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
        v253 = _NRLogIsLevelEnabled(v252, 1);

        v177 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
        if (v253)
        {
          v255 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v254);
          v256 = objc_msgSend((id)v3, "copyDescription");
          _NRLogWithArgs(v255, 1, "%s%.30s:%-4d %@: source-resume: NexusVIOutput", "", "NRLinkResumeNexusVIOutputSource", 847, v256);

          v177 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
        }
      }
      dispatch_resume(*(dispatch_object_t *)(v3 + 703));
      v178 = v632;
    }
    v180 = v642;
    v181 = *(_QWORD *)(v3 + v642) | 0x800000;
    *(_QWORD *)(v3 + v642) = v181;
    if ((v178 > v179) < (unsigned __int16)v637)
    {
      v182 = v179;
      v183 = v178 > v179;
      v184 = (unsigned __int16)v637;
      v185 = (unsigned int *)&v628[16 * v183];
      do
      {
        if (gNRPacketLoggingEnabled)
        {
          v189 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
          LODWORD(v643) = _NRLogIsLevelEnabled(v189, 1);

          v177 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
          if ((_DWORD)v643)
          {
            v191 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v190);
            v643 = (uint64_t *)objc_msgSend((id)v3, "copyDescription");
            _NRLogWithArgs(v191, 1, "%s%.30s:%-4d %@: UrgentLink:no nexusOutputSlot - consolidating %u bytes from linkInputSlot ioVecs[%u].buf=%p to linkReadBuffer filledIn=%u handled=%u", "", "NRLinkLinkToNexusLoopUrgent", 4836, v643, *v185, v183, *((_QWORD *)v185 - 1), *(unsigned int *)(v3 + *(int *)(v16 + 956)), *(unsigned int *)(v3 + 323));

            v177 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
          }
        }
        v186 = *(unsigned int *)(v3 + *(int *)(v16 + 956));
        v187 = *v185;
        if ((v187 + v186) >= *(_DWORD *)(v3 + v177[183]))
        {
          *(_QWORD *)(v3 + v642) |= 0x1000000uLL;
          StringFromNRTLVType = (void *)createIOVecString(&v662, (unsigned __int16)v637);
          sub_100074F70((void *)v3, CFSTR("no nexusOutputSlot and linkReadBuffer is full %@ filledIn=%u handled=%u"), v390, v391, v392, v393, v394, v395, (uint64_t)StringFromNRTLVType);
          goto LABEL_457;
        }
        memcpy((void *)(*(_QWORD *)(v3 + 1319) + v186), *((const void **)v185 - 1), v187);
        v188 = *v185;
        v185 += 4;
        *(_DWORD *)(v3 + *(int *)(v16 + 956)) += v188;
        ++v183;
      }
      while (v184 != v183);
      v180 = v642;
      v181 = *(_QWORD *)(v3 + v642);
      v178 = v632;
      v179 = v182;
    }
    if (v178 > v179 && (unsigned __int16)v637 == 1)
    {
      *(_QWORD *)(v3 + v180) = v181 | 0x2000000;
      v266 = v634;
      if ((_WORD)v634 && (unsigned __int16)v645 > (unsigned __int16)v634)
      {
        v267 = v645 - v634;
        if (gNRPacketLoggingEnabled)
        {
          v360 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
          v361 = _NRLogIsLevelEnabled(v360, 1);

          v266 = v634;
          if (v361)
          {
            v363 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v362);
            v364 = objc_msgSend((id)v3, "copyDescription");
            _NRLogWithArgs(v363, 1, "%s%.30s:%-4d %@: UrgentLink:no nexusOutputSlot - tail consolidating %u bytes from linkInputSlot to linkReadBuffer filledIn=%u handled=%u and marking curLinkInputSlot=%p as completed", "", "NRLinkLinkToNexusLoopUrgent", 4870, v364, v267, *(unsigned int *)(v3 + *(int *)(v16 + 956)), *(unsigned int *)(v3 + 323), v639);

            v266 = v634;
          }
        }
        memcpy((void *)(*(_QWORD *)(v3 + 1319) + *(unsigned int *)(v3 + *(int *)(v16 + 956))), (const void *)(v644 + v266), v267);
        *(_DWORD *)(v3 + *(int *)(v16 + 956)) += v267;
        v633 = (unint64_t)v639;
      }
      goto LABEL_390;
    }
    *(_QWORD *)(v3 + v180) = v181 | 0x4000000;
    v633 = (unint64_t)v639;
    v18 = v634;
    v19 = v645;
  }
  v170 = v169;
  if (v632 > v629)
  {
    if (gNRPacketLoggingEnabled)
    {
      v242 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
      v243 = _NRLogIsLevelEnabled(v242, 1);

      if (v243)
      {
        v244 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
        v245 = objc_msgSend((id)v3, "copyDescription");
        _NRLogWithArgs(v244, 1, "%s%.30s:%-4d %@: UrgentLink:Advancing linkReadBuffer handled by %u handled=%u filledIn=%u", "", "NRLinkLinkToNexusLoopUrgent", 4893, v245, DWORD2(v662), *(unsigned int *)(v3 + 323), *(unsigned int *)(v3 + *(int *)(v16 + 956)));

      }
    }
    v17 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
    *(_DWORD *)(v3 + 323) += DWORD2(v662);
  }
  v171 = v642;
  v172 = &OBJC_IVAR___NRLinkBluetooth__recvUncompressedIP;
  switch(v635)
  {
    case 1u:
      v173 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
      v174 = _NRLogIsLevelEnabled(v173, 1);

      if (!v174)
        goto LABEL_301;
      v175 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
      v176 = objc_msgSend((id)v3, "copyDescription");
      _NRLogWithArgs(v175, 1, "%s%.30s:%-4d %@: Handling PadN %u", "", "NRLinkLinkToNexusLoopUrgent", 4922, v176, (unsigned __int16)v641);
      goto LABEL_297;
    case 2u:
      goto LABEL_286;
    case 3u:
      v172 = &OBJC_IVAR___NRLinkBluetooth__recvEncapsulated6LoWPAN;
      goto LABEL_286;
    case 4u:
      if (!(_WORD)v641)
      {
        v233 = objc_alloc_init((Class)NSData);
LABEL_335:
        if ((v638 & 1) != 0)
        {
          objc_msgSend(v233, "bytes");
          objc_msgSend(v233, "length");
          if (qword_1001E48A0 != -1)
            dispatch_once(&qword_1001E48A0, &stru_1001B7C10);
          v234 = (id)qword_1001E4898;
          v655 = _NSConcreteStackBlock;
          v656 = 3221225472;
          v657 = sub_10008C1F8;
          v658 = &unk_1001B85D0;
          v659 = 0;
          dispatch_async(v234, &v655);

        }
        v235 = v642;
        *(_QWORD *)(v3 + v642) |= 0x20000000uLL;
        sub_10008C2A4(v3, v233);

        v171 = v235;
        LODWORD(v638) = 0;
        goto LABEL_302;
      }
      v192 = (char *)malloc_type_malloc(v640, 0xA172743EuLL);
      if (!v192)
      {
        v567 = sub_100070AC8();
        v568 = _NRLogIsLevelEnabled(v567, 16);

        if (v568)
        {
          v569 = sub_100070AC8();
          _NRLogWithArgs(v569, 16, "%s%.30s:%-4d ABORTING: strict_malloc(%zu) failed", "", "strict_malloc", 79, v640);

        }
LABEL_591:
        v603 = _os_log_pack_size(22);
        v387 = (char *)&v622 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
        v604 = __error();
        v605 = _os_log_pack_fill(v387, v603, *v604, &_mh_execute_header, "%{public}s strict_malloc(%zu) failed");
        *(_DWORD *)v605 = 136446466;
        *(_QWORD *)(v605 + 4) = "strict_malloc";
        *(_WORD *)(v605 + 12) = 2048;
        *(_QWORD *)(v605 + 14) = v640;
        goto LABEL_480;
      }
      if (!(_WORD)v637)
        goto LABEL_500;
      v193 = v192;
      v643 = &v622;
      v194 = 0;
      v195 = 0;
      v196 = (unsigned __int16)v641;
      v3 = 16 * (unsigned __int16)v637;
      v197 = 3;
      while (1)
      {
        v198 = *(_DWORD *)((char *)&v662 + v194 + 8);
        if (!v197)
          break;
        if (v197 <= v198)
        {
          if (v197 >= v198)
          {
            v197 = 0;
            goto LABEL_266;
          }
          break;
        }
        v197 -= v198;
LABEL_266:
        v194 += 16;
        if (v3 == v194)
          goto LABEL_333;
      }
      v199 = v198 - v197;
      if (v199 >= (int)v196 - (int)v195)
        v200 = (v196 - v195);
      else
        v200 = v199;
      memcpy(&v193[v195], (const void *)(*(_QWORD *)((char *)&v662 + v194) + v197), v200);
      v195 = (v200 + v195);
      if (v195 < v196)
      {
        v197 = 0;
        v17 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
        goto LABEL_266;
      }
      v17 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
LABEL_333:
      if ((_DWORD)v195 == (_DWORD)v196)
      {
        v232 = objc_alloc((Class)NSData);
        v233 = objc_msgSend(v232, "initWithBytesNoCopy:length:freeWhenDone:", v193, v640, 1);
        v3 = v636;
        goto LABEL_335;
      }
      v570 = sub_100070AC8();
      v571 = _NRLogIsLevelEnabled(v570, 16);

      if (v571)
      {
        v572 = sub_100070AC8();
        v573 = (void *)createIOVecString(&v662, (unsigned __int16)v637);
        _NRLogWithArgs(v572, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: bytesWritten == length; bytesWritten (%u) != length (%u), offset: %u, ioVec: %@",
          "",
          "nrWriteIOVecToBuffer",
          342,
          v195,
          v196,
          3,
          v573);

      }
LABEL_594:
      v610 = _os_log_pack_size(40);
      v437 = (char *)&v622 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
      v611 = __error();
      v612 = _os_log_pack_fill(v437, v610, *v611, &_mh_execute_header, "%{public}s Assertion Failed: bytesWritten == length; bytesWritten (%u) != length (%u), offset: %u, ioVec: %@");
      v613 = (id)createIOVecString(&v662, (unsigned __int16)v637);
      sub_100043594(v612, (uint64_t)"nrWriteIOVecToBuffer", v195, v196, 3, (uint64_t)v613);

LABEL_499:
      v440 = sub_100070AC8();
      _NRLogAbortWithPack(v440, v437);
LABEL_500:
      v441 = sub_100070AC8();
      v442 = _NRLogIsLevelEnabled(v441, 16);

      if (v442)
      {
        v443 = sub_100070AC8();
        _NRLogWithArgs(v443, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: numIOVecs > 0", "", "nrWriteIOVecToBuffer", 313);

      }
      v444 = _os_log_pack_size(12);
      v387 = (char *)&v622 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
      v445 = __error();
      v398 = _os_log_pack_fill(v387, v444, *v445, &_mh_execute_header, "%{public}s Assertion Failed: numIOVecs > 0");
      *(_DWORD *)v398 = 136446210;
      v401 = "nrWriteIOVecToBuffer";
LABEL_479:
      *(_QWORD *)(v398 + 4) = v401;
LABEL_480:
      v402 = sub_100070AC8();
      _NRLogAbortWithPack(v402, v387);
LABEL_481:
      v640 = v47;
      v641 = v46;
LABEL_482:
      StringFromNRTLVType = (void *)createIOVecStringWithContents(&v662, 16);
      sub_100074F70((void *)v3, CFSTR("LtN not enough ioVecs %@ for %u"), v403, v404, v405, v406, v407, v408, (uint64_t)StringFromNRTLVType);
LABEL_457:

LABEL_458:
      return;
    case 5u:
      if ((unsigned __int16)v637 == 1 && DWORD2(v662) >= 5 && !HIWORD(DWORD2(v662)))
      {
        sub_10008C5F8((void *)v3, (unsigned __int8 *)(v662 + 3), (unsigned __int16)(WORD4(v662) - 5));
        goto LABEL_301;
      }
      if (!v640)
      {
        v595 = sub_100070AC8();
        v596 = _NRLogIsLevelEnabled(v595, 16);

        if (v596)
        {
          v597 = sub_100070AC8();
          _NRLogWithArgs(v597, 16, "%s%.30s:%-4d ABORTING: strict_malloc called with size 0", "", "strict_malloc", 74);

        }
        v598 = _os_log_pack_size(12);
        v387 = (char *)&v622 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
        v599 = __error();
        v398 = _os_log_pack_fill(v387, v598, *v599, &_mh_execute_header, "%{public}s strict_malloc called with size 0");
        *(_DWORD *)v398 = 136446210;
        v401 = "strict_malloc";
        goto LABEL_479;
      }
      v224 = (unsigned __int8 *)malloc_type_malloc(v640, 0xA172743EuLL);
      if (!v224)
      {
        v600 = sub_100070AC8();
        v601 = _NRLogIsLevelEnabled(v600, 16);

        if (v601)
        {
          v602 = sub_100070AC8();
          _NRLogWithArgs(v602, 16, "%s%.30s:%-4d ABORTING: strict_malloc(%zu) failed", "", "strict_malloc", 79, v640);

        }
        goto LABEL_591;
      }
      v225 = v224;
      v196 = (unsigned __int16)v641;
      if (!(_WORD)v641)
      {

        goto LABEL_343;
      }
      v643 = &v622;
      if (!(_WORD)v637)
        goto LABEL_500;
      v226 = 0;
      v195 = 0;
      v227 = 16 * (unsigned __int16)v637;
      v228 = 3;
      break;
    case 0x64u:
      v172 = &OBJC_IVAR___NRLinkBluetooth__recvKnownIPv6Hdr_ESP;
      goto LABEL_286;
    case 0x65u:
      v172 = &OBJC_IVAR___NRLinkBluetooth__recvKnownIPv6Hdr_ESP_ECT0;
      goto LABEL_286;
    case 0x66u:
      v172 = &OBJC_IVAR___NRLinkBluetooth__recvKnownIPv6Hdr_TCP;
      goto LABEL_286;
    case 0x67u:
      v172 = &OBJC_IVAR___NRLinkBluetooth__recvKnownIPv6Hdr_TCP_ECT0;
      goto LABEL_286;
    case 0x68u:
      v172 = &OBJC_IVAR___NRLinkBluetooth__recvKnownIPv6Hdr_ESP_ClassC;
      goto LABEL_286;
    case 0x69u:
      v172 = &OBJC_IVAR___NRLinkBluetooth__recvKnownIPv6Hdr_ESP_ClassC_ECT0;
LABEL_286:
      ++*(_QWORD *)(v3 + *v172);
      v201 = v641;
      v202 = nrTLVToPacket(&v662, (unsigned __int16)v637, v635, (unsigned __int16)v641, v647, WORD1(v646), v3 + 1967, v3 + 1951);
      if ((_DWORD)v202)
      {
        v204 = v202;
        *(_QWORD *)(v3 + v642) |= 0x8000000uLL;
        WORD1(v646) = v202;
        if (gNRPacketLoggingEnabled)
        {
          ESPSequenceNumberFromPacket = getESPSequenceNumberFromPacket(v647, v202);
          if (gNRPacketLoggingEnabled)
          {
            getESPSPIFromPacket(v647, WORD1(v646));
            if (gNRPacketLoggingEnabled)
            {
              v247 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v246);
              v248 = _NRLogIsLevelEnabled(v247, 1);

              if (v248)
              {
                v250 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v249);
                v251 = objc_msgSend((id)v3, "copyDescription");
                _NRLogWithArgs(v250, 1, "%s%.30s:%-4d %@: UrgentLink:Received ESP sequence number: %u", "", "NRLinkLinkToNexusLoopUrgent", 4947, v251, ESPSequenceNumberFromPacket);

              }
              v17 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
            }
          }
        }
        else
        {
          ESPSequenceNumberFromPacket = 0;
        }
        v206 = os_channel_slot_get_packet(*(_QWORD *)(v3 + 687), v170);
        if ((v638 & 1) != 0)
        {
          v207 = v623;
          *(_QWORD *)(v623 + 7) = 0;
          *v207 = 0;
          v660 = 1;
          if (v206)
          {
            os_packet_set_flow_uuid(v206, &v660);
            *(_QWORD *)(v3 + v642) |= 0x10000000uLL;
            if (gNRPacketLoggingEnabled)
            {
              v257 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v208);
              v258 = _NRLogIsLevelEnabled(v257, 1);

              if (v258)
              {
                v260 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v259);
                v261 = objc_msgSend((id)v3, "copyDescription");
                _NRLogWithArgs(v260, 1, "%s%.30s:%-4d %@: UrgentLink:Set waking metadata for packet w/ ESP sequence number: %u", "", "NRLinkLinkToNexusLoopUrgent", 4955, v261, ESPSequenceNumberFromPacket);

              }
            }
          }
          v209 = v647;
          v210 = WORD1(v646);
          v211 = getESPSequenceNumberFromPacket(v647, WORD1(v646));
          ESPSPIFromPacket = getESPSPIFromPacket(v209, v210);
          if (qword_1001E48A0 != -1)
            dispatch_once(&qword_1001E48A0, &stru_1001B7C10);
          v213 = (id)qword_1001E4898;
          v655 = _NSConcreteStackBlock;
          v656 = 3221225472;
          v657 = sub_10008C1F8;
          v658 = &unk_1001B85D0;
          v659 = __PAIR64__(v211, ESPSPIFromPacket);
          dispatch_async(v213, &v655);

          v17 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
        }
        else if (v206)
        {
          os_packet_clear_flow_uuid();
        }
        os_channel_set_slot_properties(*(_QWORD *)(v3 + 687), v170, &v646);
        LODWORD(v638) = 0;
        ++*(_QWORD *)(v3 + 783);
        *(_QWORD *)(v3 + 799) += v204;
        v625 += v204;
        ++v626;
        v631 = v170;
      }
      else
      {
        v214 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v203);
        v215 = _NRLogIsLevelEnabled(v214, 17);

        if (v215)
        {
          v175 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
          v176 = objc_msgSend((id)v3, "copyDescription");
          v217 = (void *)createStringFromNRTLVType(v635, v216);
          _NRLogWithArgs(v175, 17, "%@: failed to reinject %@ tlvLen=%u slotLen=%u", v176, v217, v201, WORD1(v646));

LABEL_297:
        }
      }
      goto LABEL_301;
    default:
      goto LABEL_302;
  }
  while (2)
  {
    v229 = *(_DWORD *)((char *)&v662 + v226 + 8);
    if (v228)
    {
      if (v228 > v229)
      {
        v228 -= v229;
      }
      else
      {
        if (v228 < v229)
          goto LABEL_326;
        v228 = 0;
      }
    }
    else
    {
LABEL_326:
      v230 = v229 - v228;
      if (v230 >= (int)v196 - (int)v195)
        v231 = (v196 - v195);
      else
        v231 = v230;
      memcpy(&v225[v195], (const void *)(*(_QWORD *)((char *)&v662 + v226) + v228), v231);
      v195 = (v231 + v195);
      if (v195 >= v196)
      {
        v17 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
LABEL_341:
        if ((_DWORD)v195 != (_DWORD)v196)
        {
          v606 = sub_100070AC8();
          v607 = _NRLogIsLevelEnabled(v606, 16);

          if (v607)
          {
            v608 = sub_100070AC8();
            v609 = (void *)createIOVecString(&v662, (unsigned __int16)v637);
            _NRLogWithArgs(v608, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: bytesWritten == length; bytesWritten (%u) != length (%u), offset: %u, ioVec: %@",
              "",
              "nrWriteIOVecToBuffer",
              342,
              v195,
              v196,
              3,
              v609);

          }
          goto LABEL_594;
        }
        sub_10008C5F8((void *)v3, v225, (unsigned __int16)v641);
LABEL_343:
        free(v225);
LABEL_301:
        v171 = v642;
LABEL_302:
        *(_QWORD *)(v3 + v171) |= 0x40000000uLL;
        if (!*(_QWORD *)(v3 + 1887))
          goto LABEL_307;
        v18 = v634;
        if (*(_QWORD *)(v3 + 1895))
        {
          *(_BYTE *)(v3 + 253) %= *(_BYTE *)(v3 + 252);
          v218 = *(_QWORD *)(v3 + 1895);
          v219 = (_QWORD *)(v218 + 8 * *(unsigned __int8 *)(v3 + 253));
          if ((unint64_t)(v219 + 1) > v218 + 8 * (unint64_t)*(unsigned __int8 *)(v3 + 252))
          {
            v220 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
            v221 = _NRLogIsLevelEnabled(v220, 17);

            if (v221)
            {
              v222 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
              v223 = objc_msgSend((id)v3, "copyDescription");
              _NRLogWithArgs(v222, 17, "%@: invalid index for link log list (curIdx: %u)", v223, *(unsigned __int8 *)(v3 + 253));

              v18 = v634;
              v19 = v645;
              goto LABEL_15;
            }
LABEL_307:
            v18 = v634;
            v19 = v645;
            goto LABEL_15;
          }
          if ((v219 & 7) == 0)
          {
            *v219 = *(_QWORD *)(v3 + 1887);
            ++*(_BYTE *)(v3 + 253);
            *(_QWORD *)(v3 + 1887) = 0;
          }
        }
        v19 = v645;
        goto LABEL_15;
      }
      v228 = 0;
      v17 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
    }
    v226 += 16;
    if (v227 == v226)
      goto LABEL_341;
    continue;
  }
}

double sub_10008C184(uint64_t a1, uint64_t a2, int a3, int a4, int a5)
{
  double result;

  *(_QWORD *)&result = 136446978;
  *(_DWORD *)a1 = 136446978;
  *(_QWORD *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 1024;
  *(_DWORD *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 18) = 1024;
  *(_DWORD *)(a1 + 20) = a4;
  *(_WORD *)(a1 + 24) = 1024;
  *(_DWORD *)(a1 + 26) = a5;
  return result;
}

double sub_10008C1B4(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, int a6, int a7)
{
  double result;

  *(_QWORD *)&result = 136447490;
  *(_DWORD *)a1 = 136447490;
  *(_QWORD *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 1024;
  *(_DWORD *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 18) = 1024;
  *(_DWORD *)(a1 + 20) = a4;
  *(_WORD *)(a1 + 24) = 2112;
  *(_QWORD *)(a1 + 26) = a5;
  *(_WORD *)(a1 + 34) = 1024;
  *(_DWORD *)(a1 + 36) = a6;
  *(_WORD *)(a1 + 40) = 1024;
  *(_DWORD *)(a1 + 42) = a7;
  return result;
}

void sub_10008C1F8(uint64_t a1)
{
  void *v2;
  void *v3;
  id v4;

  v4 = objc_alloc_init((Class)NSMutableDictionary);
  v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 32)));
  objc_msgSend(v4, "setObject:forKeyedSubscript:", v2, CFSTR("Packet SPI"));

  v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 36)));
  objc_msgSend(v4, "setObject:forKeyedSubscript:", v3, CFSTR("Packet sequence number"));

  sub_100107BA4(CFSTR("NetworkRelay waking packet"), v4);
}

void sub_10008C2A4(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  void *IKEv2PacketString;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  id v9;
  id v10;
  unsigned int v11;
  unsigned __int8 *v12;
  id v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  int IsLevelEnabled;
  uint64_t v19;
  void *v20;
  id v21;
  int v22;
  uint64_t v23;
  void *v24;
  id v25;
  id v26;
  int v27;
  id v28;
  id v29;
  uint64_t v30;
  void *v31;
  void *v32;
  void *v33;

  v3 = a2;
  if (a1)
  {
    v33 = v3;
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 1655);
      IKEv2PacketString = (void *)createIKEv2PacketString();
      objc_msgSend((id)a1, "reportEvent:detailsFormat:", 3007, CFSTR("Receiving IKEv2 packet #%llu %@ len %llu"), v4, IKEv2PacketString, objc_msgSend(v33, "length"));

      ++*(_QWORD *)(a1 + 1655);
      v7 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v6);
      LODWORD(v4) = _NRLogIsLevelEnabled(v7, 1);

      if ((_DWORD)v4)
      {
        v32 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v8);
        v9 = objc_msgSend((id)a1, "copyDescription");
        v30 = *(_QWORD *)(a1 + 1655);
        v31 = v9;
        v29 = objc_msgSend(v33, "length");
        v10 = v33;
        v11 = objc_msgSend(v10, "length");
        v12 = (unsigned __int8 *)objc_msgSend(v10, "bytes");
        v13 = objc_alloc_init((Class)NSMutableString);
        if (v11)
        {
          v14 = 0;
          do
          {
            objc_msgSend(v13, "appendFormat:", CFSTR("%02X"), v12[v14]);
            if ((~(_DWORD)v14 & 0xF) == 0 || (~(_DWORD)v14 & 3) == 0)
              objc_msgSend(v13, "appendString:");
            ++v14;
          }
          while (v11 != v14);
        }

        _NRLogWithArgs(v32, 1, "%s%.30s:%-4d %@: IKE #%llu RECEIVING dataLen=%u data=[\n%@]", "", "-[NRLinkBluetooth handleIncomingIKEData:]", 7254, v31, v30, v29, v13);
      }
      v15 = *(_QWORD *)(a1 + 1255);
      v16 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v8);
      v17 = (void *)v16;
      if (v15)
      {
        IsLevelEnabled = _NRLogIsLevelEnabled(v16, 1);

        if (IsLevelEnabled)
        {
          v20 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v19);
          v21 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v20, 1, "%s%.30s:%-4d %@: handling uIKE packet of %llu bytes", "", "-[NRLinkBluetooth handleIncomingIKEData:]", 7261, v21, objc_msgSend(v33, "length"));

        }
        objc_msgSend(*(id *)(a1 + 1255), "receivePacketData:", v33);
      }
      else
      {
        v22 = _NRLogIsLevelEnabled(v16, 16);

        if (v22)
        {
          v24 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v23);
          v25 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v24, 16, "%s%.30s:%-4d %@: not ready to handle IKE yet", "", "-[NRLinkBluetooth handleIncomingIKEData:]", 7257, v25);

        }
        objc_msgSend(*(id *)(a1 + 1199), "addObject:", v33);
      }
    }
    else
    {
      v26 = sub_100070AC8();
      v27 = _NRLogIsLevelEnabled(v26, 17);

      v3 = 0;
      if (!v27)
        goto LABEL_20;
      v28 = sub_100070AC8();
      _NRLogWithArgs(v28, 17, "%s called with null data", "-[NRLinkBluetooth handleIncomingIKEData:]");

    }
    v3 = v33;
  }
LABEL_20:

}

void sub_10008C5F8(void *a1, unsigned __int8 *a2, unsigned int a3)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  void *v11;
  int v12;
  uint64_t v13;
  void *v14;
  id v15;
  void *v16;
  int IsLevelEnabled;
  uint64_t v18;
  void *v19;
  id v20;
  _QWORD *v21;

  v5 = a1;
  if (a2 && a3)
  {
    v7 = *a2;
    v21 = v5;
    if ((_DWORD)v7 == 2)
    {
      v9 = mach_absolute_time();
      if (a3 < 9)
        v10 = 0;
      else
        v10 = *(_QWORD *)(a2 + 1);
      v16 = (void *)_NRCopyLogObjectForNRUUID(v21[4], v8);
      IsLevelEnabled = _NRLogIsLevelEnabled(v16, 1);

      if (IsLevelEnabled)
      {
        v19 = (void *)_NRCopyLogObjectForNRUUID(v21[4], v18);
        v20 = objc_msgSend(v21, "copyDescription");
        _NRLogWithArgs(v19, 1, "%s%.30s:%-4d %@: Received pong seq %llu", "", "NRLBTHandleIncomingControlMessage", 2905, v20, v10);

      }
      sub_10008CB98((uint64_t)v21, bswap64(v10), v9);
      goto LABEL_14;
    }
    if ((_DWORD)v7 == 1)
    {
      *a2 = 2;
      sub_10008C79C(v5, a2, a3, 0);
LABEL_14:
      v5 = v21;
      goto LABEL_15;
    }
    v11 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v6);
    v12 = _NRLogIsLevelEnabled(v11, 16);

    v5 = v21;
    if (v12)
    {
      v14 = (void *)_NRCopyLogObjectForNRUUID(v21[4], v13);
      v15 = objc_msgSend(v21, "copyDescription");
      _NRLogWithArgs(v14, 16, "%s%.30s:%-4d %@: Received unknown message type %u", "", "NRLBTHandleIncomingControlMessage", 2911, v15, v7);

      goto LABEL_14;
    }
  }
LABEL_15:

}

uint64_t sub_10008C79C(void *a1, const void *a2, unsigned int a3, int a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t next_slot;
  unsigned int v13;
  void *v14;
  int v15;
  uint64_t v16;
  id v17;
  id v18;
  void *v19;
  int v20;
  uint64_t v21;
  void *v22;
  int v23;
  uint64_t v24;
  void *v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  id v32;
  int IsLevelEnabled;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;

  v7 = a1;
  v9 = (char *)v7;
  if (!a2)
  {
    v32 = sub_100070AC8();
    IsLevelEnabled = _NRLogIsLevelEnabled(v32, 17);

    if (IsLevelEnabled)
    {
      v17 = sub_100070AC8();
      _NRLogWithArgs(v17, 17, "%s called with null messageData", "NRLBTSendControlMessage");
      goto LABEL_20;
    }
    goto LABEL_31;
  }
  if (*((unsigned __int8 *)v7 + 16) == 255)
  {
    v19 = (void *)_NRCopyLogObjectForNRUUID(v7[4], v8);
    v20 = _NRLogIsLevelEnabled(v19, 16);

    if (v20)
    {
      v17 = (id)_NRCopyLogObjectForNRUUID(*((_QWORD *)v9 + 4), v21);
      v18 = objc_msgSend(v9, "copyDescription");
      _NRLogWithArgs(v17, 16, "%s%.30s:%-4d %@: NRLBTSendControlMessage but cancelled", "", "NRLBTSendControlMessage", 2824, v18);
      goto LABEL_19;
    }
LABEL_31:
    v28 = 0;
    goto LABEL_32;
  }
  v10 = *(_QWORD *)((char *)v7 + 975);
  if (!v10)
  {
    v22 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v9 + 4), v8);
    v23 = _NRLogIsLevelEnabled(v22, 16);

    if (v23)
    {
      v17 = (id)_NRCopyLogObjectForNRUUID(*((_QWORD *)v9 + 4), v24);
      v18 = objc_msgSend(v9, "copyDescription");
      _NRLogWithArgs(v17, 16, "%s%.30s:%-4d %@: Tried to NRLBTSendControlMessage but _linkOutputRing is NULL", "", "NRLBTSendControlMessage", 2828, v18);
      goto LABEL_19;
    }
    goto LABEL_31;
  }
  v11 = *(_DWORD *)(v9 + 287);
  if (v11 <= *(_DWORD *)(v9 + 291))
  {
    v37 = 0u;
    v38 = 0u;
    v35 = 0u;
    v36 = 0u;
    next_slot = os_channel_get_next_slot(v10, 0, &v35);
    if (next_slot && WORD1(v35) >= 5u && WORD1(v35) - 5 >= a3)
    {
      v30 = next_slot;
      v31 = v36;
      *(_BYTE *)v36 = 5;
      *(_WORD *)(v31 + 1) = __rev16(a3);
      memcpy((void *)(v31 + 3), a2, a3);
      *(_WORD *)(v31 + a3 + 3) = ~(unsigned __int16)os_inet_checksum(v31, a3 + 3, 0);
      WORD1(v35) = a3 + 5;
      os_channel_set_slot_properties(*(_QWORD *)(v9 + 975), v30, &v35);
      os_channel_advance_slot(*(_QWORD *)(v9 + 975), v30);
      if (a4)
        v28 = mach_absolute_time();
      else
        v28 = 0;
      os_channel_sync(*(_QWORD *)(v9 + 959), 0);
      goto LABEL_32;
    }
    v11 = *(_DWORD *)(v9 + 287);
  }
  v13 = *(_DWORD *)(v9 + 279) - v11;
  if (v13 <= 4)
  {
    v14 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v9 + 4), v8);
    v15 = _NRLogIsLevelEnabled(v14, 16);

    if (v15)
    {
      v17 = (id)_NRCopyLogObjectForNRUUID(*((_QWORD *)v9 + 4), v16);
      v18 = objc_msgSend(v9, "copyDescription");
      _NRLogWithArgs(v17, 16, "%s%.30s:%-4d %@: NRLBTSendControlMessage but out of room1", "", "NRLBTSendControlMessage", 2863, v18);
LABEL_19:

LABEL_20:
      v28 = 0;
      goto LABEL_32;
    }
    goto LABEL_31;
  }
  if (v13 - 5 < a3)
  {
    v25 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v9 + 4), v8);
    v26 = _NRLogIsLevelEnabled(v25, 16);

    if (v26)
    {
      v17 = (id)_NRCopyLogObjectForNRUUID(*((_QWORD *)v9 + 4), v27);
      v18 = objc_msgSend(v9, "copyDescription");
      _NRLogWithArgs(v17, 16, "%s%.30s:%-4d %@: NRLBTSendControlMessage but out of room2", "", "NRLBTSendControlMessage", 2867, v18);
      goto LABEL_19;
    }
    goto LABEL_31;
  }
  v29 = *(_QWORD *)(v9 + 447) + v11;
  *(_BYTE *)v29 = 5;
  *(_WORD *)(v29 + 1) = __rev16(a3);
  memcpy((void *)(v29 + 3), a2, a3);
  *(_WORD *)(v29 + a3 + 3) = ~(unsigned __int16)os_inet_checksum(v29, a3 + 3, 0);
  *(_DWORD *)(v9 + 287) += a3;
  if (a4)
    v28 = mach_absolute_time();
  else
    v28 = 0;
  sub_100071380(v9, *(_QWORD *)(v9 + 367));
LABEL_32:

  return v28;
}

void sub_10008CB98(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v6;
  id v7;
  id v8;
  uint64_t v9;
  void *i;
  unint64_t v11;
  SEL v12;
  _QWORD *v13;
  uint64_t v14;
  void *v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  _BYTE v20[128];

  if (a1)
  {
    if (qword_1001E46C8 != -1)
      dispatch_once(&qword_1001E46C8, &stru_1001B6AF8);
    v18 = 0u;
    v19 = 0u;
    v16 = 0u;
    v17 = 0u;
    v6 = objc_msgSend(*(id *)(a1 + 1207), "copy", 0);
    v7 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v16, v20, 16);
    if (v7)
    {
      v8 = v7;
      v9 = *(_QWORD *)v17;
      do
      {
        for (i = 0; i != v8; i = (char *)i + 1)
        {
          if (*(_QWORD *)v17 != v9)
            objc_enumerationMutation(v6);
          v13 = *(_QWORD **)(*((_QWORD *)&v16 + 1) + 8 * (_QWORD)i);
          if (v13)
          {
            if (v13[2] == a2)
            {
              v14 = v13[1];
              if (v14)
              {
                if (a3)
                  v11 = (a3 - v13[3])
                      * (unint64_t)dword_1001E46C0
                      / *(unsigned int *)algn_1001E46C4;
                else
                  v11 = 0;
                (*(void (**)(uint64_t, unint64_t))(v14 + 16))(v14, v11);
                objc_setProperty_nonatomic_copy(v13, v12, 0, 8);
              }
LABEL_10:
              objc_msgSend(*(id *)(a1 + 1207), "removeObject:", v13);
              continue;
            }
          }
          else if (!a2)
          {
            goto LABEL_10;
          }
        }
        v8 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v16, v20, 16);
      }
      while (v8);
    }

    if (!objc_msgSend(*(id *)(a1 + 1207), "count"))
    {
      v15 = *(void **)(a1 + 1207);
      *(_QWORD *)(a1 + 1207) = 0;

    }
  }
}

void sub_10008CD64(id a1)
{
  mach_timebase_info((mach_timebase_info_t)&dword_1001E46C0);
}

void sub_10008CD70(uint64_t a1, void *__src, size_t __n, uint64_t a4)
{
  int *v8;
  int *v9;
  uint64_t v10;
  void *v11;
  void *v12;
  int v13;
  uint64_t v14;
  void *v15;
  id v16;
  void *v17;
  const char *v18;
  void *v19;
  int IsLevelEnabled;
  uint64_t v21;
  void *v22;
  id v23;
  void *v24;
  int v25;
  uint64_t v26;

  if (gNRPacketLoggingEnabled)
  {
    v10 = objc_claimAutoreleasedReturnValue(+[NSDate date](NSDate, "date"));
    v11 = *(void **)(a1 + 1679);
    *(_QWORD *)(a1 + 1679) = v10;

    if (!__src)
      goto LABEL_13;
  }
  else if (!__src)
  {
    goto LABEL_13;
  }
  if (__n)
  {
    if ((_DWORD)a4)
    {
      *(_QWORD *)(a1 + 1407) += __n;
      if (!gNRPacketLoggingEnabled)
      {
        v8 = &OBJC_IVAR___NRLinkBluetooth__filledInUrgentLinkReadBufferBytes;
LABEL_7:
        v9 = &OBJC_IVAR___NRLinkBluetooth__urgentLinkReadBuffer;
LABEL_11:
        memcpy((void *)(*(_QWORD *)(a1 + *v9) + *(unsigned int *)(a1 + *v8)), __src, __n);
        *(_DWORD *)(a1 + *v8) += __n;
        sub_10008D068(a1, a4);
        return;
      }
      v19 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), __src);
      IsLevelEnabled = _NRLogIsLevelEnabled(v19, 1);

      v8 = &OBJC_IVAR___NRLinkBluetooth__filledInUrgentLinkReadBufferBytes;
      if (!IsLevelEnabled)
        goto LABEL_7;
      v22 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v21);
      v23 = objc_msgSend((id)a1, "copyDescription");
      _NRLogWithArgs(v22, 1, "%s%.30s:%-4d %@: filling in urgentLinkReadBuffer by %u from %u to %u (handled %u)", "", "-[NRLinkBluetooth readIncomingData:length:isUrgentLink:]", 6911, v23, __n, *(unsigned int *)(a1 + 319), (*(_DWORD *)(a1 + 319) + __n), *(unsigned int *)(a1 + 323));
      v9 = &OBJC_IVAR___NRLinkBluetooth__urgentLinkReadBuffer;
LABEL_22:

      goto LABEL_11;
    }
    *(_QWORD *)(a1 + 1375) += __n;
    if (gNRPacketLoggingEnabled)
    {
      v24 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), __src);
      v25 = _NRLogIsLevelEnabled(v24, 1);

      v8 = &OBJC_IVAR___NRLinkBluetooth__filledInLinkReadBufferBytes;
      if (v25)
      {
        v22 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v26);
        v23 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v22, 1, "%s%.30s:%-4d %@: filling in linkReadBuffer by %u from %u to %u (handled %u)", "", "-[NRLinkBluetooth readIncomingData:length:isUrgentLink:]", 6920, v23, __n, *(unsigned int *)(a1 + 311), (*(_DWORD *)(a1 + 311) + __n), *(unsigned int *)(a1 + 315));
        v9 = &OBJC_IVAR___NRLinkBluetooth__linkReadBuffer;
        goto LABEL_22;
      }
    }
    else
    {
      v8 = &OBJC_IVAR___NRLinkBluetooth__filledInLinkReadBufferBytes;
    }
    v9 = &OBJC_IVAR___NRLinkBluetooth__linkReadBuffer;
    goto LABEL_11;
  }
LABEL_13:
  v12 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), __src);
  v13 = _NRLogIsLevelEnabled(v12, 17);

  if (v13)
  {
    v15 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v14);
    v16 = objc_msgSend((id)a1, "copyDescription");
    v17 = v16;
    v18 = "";
    if ((_DWORD)a4)
      v18 = "urgent ";
    _NRLogWithArgs(v15, 17, "%@: %spipe received no data", v16, v18);

  }
  objc_msgSend((id)a1, "cancelWithReason:", CFSTR("pipe received no data"));
}

void sub_10008D068(uint64_t a1, uint64_t a2)
{
  char *v2;
  _BYTE *v3;
  uint64_t v4;
  int *v5;
  int *v6;
  int *v7;
  unint64_t v8;
  id v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  void *v13;
  int v14;
  uint64_t v15;
  id v16;
  id v17;
  unsigned int v18;
  int *v19;
  unsigned int *v20;
  unsigned int v21;
  unsigned int v22;
  void *v23;
  int v24;
  uint64_t v25;
  id v26;
  char *v27;
  id v28;
  void *v29;
  const char *v30;
  unsigned int v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t v34;
  int v35;
  unsigned __int8 *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unsigned __int8 *v41;
  unsigned __int8 *v42;
  unsigned __int8 *v43;
  int v44;
  int v45;
  void *v46;
  int v47;
  void *v48;
  id v49;
  int *v50;
  unsigned int v51;
  uint64_t v52;
  int v53;
  unsigned int v54;
  uint64_t v55;
  uint64_t v56;
  void *v57;
  int v58;
  void *v59;
  id v60;
  uint64_t v61;
  void *v62;
  int v63;
  uint64_t v64;
  void *v65;
  id v66;
  id v67;
  id v68;
  uint64_t v69;
  void *v70;
  int v71;
  char *v72;
  uint64_t v73;
  void *v74;
  id v75;
  uint64_t v76;
  id v77;
  id v78;
  void *v79;
  int v80;
  uint64_t v81;
  void *v82;
  id v83;
  id v84;
  id v85;
  __CFString *v86;
  id v87;
  __CFString *v88;
  id v89;
  __CFString *v90;
  __CFString *v91;
  id v92;
  void *v93;
  int v94;
  uint64_t v95;
  void *v96;
  id v97;
  NSObject *v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  __CFString *v107;
  unsigned int v108;
  unsigned int v109;
  id v110;
  __CFString *v111;
  uint64_t v112;
  int *v113;
  uint64_t v114;
  void *v115;
  int v116;
  uint64_t v117;
  void *v118;
  id v119;
  id v120;
  id v121;
  unsigned int v122;
  int v123;
  uint64_t v124;
  unsigned int v125;
  void *v126;
  int v127;
  uint64_t v128;
  void *v129;
  id v130;
  id v131;
  id v132;
  void *v133;
  int *v134;
  unint64_t v135;
  unsigned int v136;
  uint64_t v137;
  unint64_t v138;
  unsigned int v139;
  unsigned int v140;
  unsigned int v141;
  unsigned int v142;
  unsigned int v143;
  unsigned int v144;
  unsigned int v145;
  unsigned int v146;
  unsigned int v147;
  unsigned int v148;
  unsigned int v149;
  unsigned int v150;
  unsigned int v151;
  unsigned int v152;
  unsigned int v153;
  unsigned int v154;
  void *v155;
  int v156;
  void *v157;
  id v158;
  id v159;
  void *v160;
  id v161;
  void *v162;
  uint64_t v163;
  void *v164;
  id v165;
  void *v166;
  void *v167;
  id v168;
  uint64_t v169;
  void *v170;
  const char *v171;
  void *v172;
  id v173;
  int v174;
  id v175;
  __int16 v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  unsigned __int16 v180;
  void *v181;
  char v182;
  uint64_t v183;
  int *v184;
  id v185;
  id v186;
  void *v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  void *v191;
  char *v192;
  id v193;
  uint64_t v194;
  void *v195;
  id v196;
  uint64_t v197;
  void *v198;
  unsigned int v199;
  char *v200;
  uint64_t v201;
  uint64_t v202;
  void *v203;
  int v204;
  uint64_t v205;
  void *v206;
  id v207;
  NSObject *v208;
  id v209;
  int IsLevelEnabled;
  id v211;
  char *v212;
  int *v213;
  uint64_t v214;
  int v215;
  int v216;
  id v217;
  void *v218;
  int v219;
  void *v220;
  id v221;
  uint64_t v222;
  void *v223;
  int v224;
  uint64_t v225;
  void *v226;
  id v227;
  uint64_t v228;
  void *StringFromNRTLVType;
  void *v230;
  int v231;
  uint64_t v232;
  void *v233;
  id v234;
  id v235;
  int v236;
  id v237;
  uint64_t v238;
  char *v239;
  int *v240;
  uint64_t v241;
  id v242;
  void *v243;
  int v244;
  void *v245;
  id v246;
  id v247;
  int v248;
  id v249;
  uint64_t v250;
  int *v251;
  uint64_t v252;
  id v253;
  void *v254;
  int v255;
  uint64_t v256;
  void *v257;
  id v258;
  id v259;
  int v260;
  id v261;
  int *v262;
  uint64_t v263;
  void *v264;
  int v265;
  uint64_t v266;
  void *v267;
  id v268;
  id v269;
  unsigned __int16 *v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  id v275;
  uint64_t v276;
  id v277;
  uint64_t v278;
  char *v279;
  unint64_t v280;
  id v281;
  char *v282;
  id v283;
  uint64_t v284;
  _QWORD v285[5];
  _QWORD block[5];
  unsigned __int8 v287;
  unsigned __int8 v288;
  unsigned __int8 v289;
  unsigned __int8 v290;
  unsigned __int8 v291;
  unsigned __int8 v292;
  unsigned __int8 v293;
  unsigned __int8 v294;
  unsigned __int8 v295;
  unsigned __int8 v296;
  unsigned __int8 v297;
  unsigned __int8 v298;
  unsigned __int8 v299;
  unsigned __int8 v300;
  unsigned __int8 v301;
  unsigned __int8 v302;
  int8x16_t v303;

  v4 = a1;
  v5 = &OBJC_IVAR___NRLinkBluetooth__filledInUrgentLinkReadBufferBytes;
  if (!(_DWORD)a2)
    v5 = &OBJC_IVAR___NRLinkBluetooth__filledInLinkReadBufferBytes;
  v6 = &OBJC_IVAR___NRLinkBluetooth__handledUrgentLinkReadBufferBytes;
  if (!(_DWORD)a2)
    v6 = &OBJC_IVAR___NRLinkBluetooth__handledLinkReadBufferBytes;
  v7 = &OBJC_IVAR___NRLinkBluetooth__linkReadBuffer;
  if ((_DWORD)a2)
    v7 = &OBJC_IVAR___NRLinkBluetooth__urgentLinkReadBuffer;
  v8 = *v6;
  v9 = (id)*v5;
  if (*(_DWORD *)(a1 + v8) > *(_DWORD *)((char *)v9 + a1))
  {
    v209 = sub_100070AC8();
    IsLevelEnabled = _NRLogIsLevelEnabled(v209, 16);

    if (IsLevelEnabled)
    {
      v211 = sub_100070AC8();
      _NRLogWithArgs(v211, 16, "%s%.30s:%-4d ABORTING: handledLinkReadBufferBytes=%u > filledInLinkReadBufferBytes=%u", "", "-[NRLinkBluetooth handleReadData:]", 6448, *(_DWORD *)(v4 + v8), *(_DWORD *)((char *)v9 + v4));

    }
    v10 = _os_log_pack_size(24);
    v212 = (char *)&v275 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
    v213 = __error();
    v214 = _os_log_pack_fill(v212, v10, *v213, &_mh_execute_header, "%{public}s handledLinkReadBufferBytes=%u > filledInLinkReadBufferBytes=%u");
    v215 = *(_DWORD *)(v4 + v8);
    v216 = *(_DWORD *)((char *)v9 + v4);
    *(_DWORD *)v214 = 136446722;
    *(_QWORD *)(v214 + 4) = "-[NRLinkBluetooth handleReadData:]";
    *(_WORD *)(v214 + 12) = 1024;
    *(_DWORD *)(v214 + 14) = v215;
    *(_WORD *)(v214 + 18) = 1024;
    *(_DWORD *)(v214 + 20) = v216;
LABEL_252:
    v217 = sub_100070AC8();
    _NRLogAbortWithPack(v217, v212);
  }
  else
  {
    LODWORD(v10) = a2;
    v2 = *(char **)(a1 + *v7);
    v3 = &gNRPacketLoggingEnabled;
    if (!gNRPacketLoggingEnabled)
      goto LABEL_9;
  }
  v218 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), a2);
  v219 = _NRLogIsLevelEnabled(v218, 1);

  if (v219)
  {
    v220 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), a2);
    v221 = objc_msgSend((id)v4, "copyDescription");
    _NRLogWithArgs(v220, 1, "%s%.30s:%-4d %@: handling %u bytes (handled %u)", "", "-[NRLinkBluetooth handleReadData:]", 6450, v221, *(unsigned int *)((char *)v9 + v4), *(unsigned int *)(v4 + v8));

  }
LABEL_9:
  if ((_DWORD)v10)
  {
    if (*(_BYTE *)(v4 + 229))
    {
      v11 = *(unsigned __int8 *)(v4 + 16);
LABEL_16:
      if ((v11 - 4) <= 5)
      {
        v18 = *(_DWORD *)(v4 + 311);
        v19 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
        v20 = (unsigned int *)(v4 + 315);
        v21 = *(_DWORD *)(v4 + 315);
        v22 = v21 + 1;
        if (v18 < v21 + 1)
        {
LABEL_18:
          sub_10009097C(v4, 1);
          return;
        }
        v284 = v4;
        while (1)
        {
          v36 = (unsigned __int8 *)(*(_QWORD *)(v4 + 1311) + v21);
          v37 = *v36;
          if (*v36)
          {
            if (v18 < v21 + 3)
            {
              sub_10009097C(v4, 3);
              return;
            }
            v38 = bswap32(*(unsigned __int16 *)(v36 + 1)) >> 16;
            if (v18 < v21 + v38 + 5)
            {
              if (*v3)
              {
                v222 = v38;
                v223 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), a2);
                v224 = _NRLogIsLevelEnabled(v223, 1);

                LODWORD(v38) = v222;
                if (v224)
                {
                  v226 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v225);
                  v227 = objc_msgSend((id)v4, "copyDescription");
                  StringFromNRTLVType = (void *)createStringFromNRTLVType(v37, v228);
                  _NRLogWithArgs(v226, 1, "%s%.30s:%-4d %@: Got %@ len %u but only have %u", "", "-[NRLinkBluetooth handleReadData:]", 6728, v227, StringFromNRTLVType, v222, (*(_DWORD *)(v4 + 311) - *(_DWORD *)(v4 + v19[138])));

                  LODWORD(v38) = v222;
                }
              }
              sub_10009097C(v4, (v38 + 5));
              return;
            }
            if (*v3)
            {
              v69 = v38;
              v70 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), a2);
              v71 = _NRLogIsLevelEnabled(v70, 1);

              v38 = v69;
              if (v71)
              {
                v283 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), a2);
                v72 = (char *)objc_msgSend((id)v4, "copyDescription");
                v282 = v72;
                v74 = (void *)createStringFromNRTLVType(v37, v73);
                v270 = (unsigned __int16 *)v72;
                v75 = v283;
                _NRLogWithArgs(v283, 1, "%s%.30s:%-4d %@: Handling %@ len %u since we have %u", "", "-[NRLinkBluetooth handleReadData:]", 6733, v270, v74, v69, (*(_DWORD *)(v4 + 311) - *(_DWORD *)(v4 + v19[138])));

                v38 = v69;
              }
            }
            v39 = v19[138];
            v40 = *(unsigned int *)(v4 + v39);
            v41 = (unsigned __int8 *)(*(_QWORD *)(v4 + 1311) + v40);
            v42 = v41 + 3;
            if ((char)v37 < 100)
            {
              v50 = v19;
              v43 = v41 + 3;
              v51 = *(unsigned __int16 *)&v42[v38];
              v52 = v38;
              v53 = os_inet_checksum(v41, (v38 + 3), 0);
              v54 = ~v53;
              if (v51 != (unsigned __int16)~(_WORD)v53)
              {
                if (qword_1001E46D8 != -1)
                  dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
                if (_NRLogIsLevelEnabled(qword_1001E46D0, 16))
                {
                  if (qword_1001E46D8 != -1)
                    dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
                  _NRLogWithArgs(qword_1001E46D0, 16, "%s%.30s:%-4d checksum failed computed 0x%04x != observed 0x%04x", "", "nrChecksumVerify", 133, bswap32(v54) >> 16, __rev16(v51));
                }
                v99 = v50[138];
                v4 = v284;
                *(_DWORD *)(v284 + v99) += v52 + 5;
LABEL_98:
                v100 = *(_QWORD *)(v4 + 1863);
                if (v100)
                  *(_BYTE *)(v100 + 98) = 1;
                v283 = (id)createStringFromNRTLVType(v37, a2);
                sub_100074F70((void *)v4, CFSTR("Invalid checksum detected in buffer on read type %@ len %u filledIn=%u handled=%u"), v101, v102, v103, v104, v105, v106, (uint64_t)v283);
                goto LABEL_25;
              }
              v19 = v50;
              v55 = v50[138];
              v4 = v284;
              *(_DWORD *)(v284 + v55) += v52 + 5;
              v38 = v52;
            }
            else
            {
              v43 = v41 + 3;
              v44 = *(unsigned __int16 *)&v42[v38];
              v45 = (*v41 << 12) ^ (v41[2] << 8) | v41[1] ^ (*v41 >> 4);
              *(_DWORD *)(v4 + v39) = v38 + v40 + 5;
              if (v44 != (unsigned __int16)v45)
                goto LABEL_98;
            }
            switch((int)v37)
            {
              case 1:
                v56 = v38;
                v57 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), a2);
                v58 = _NRLogIsLevelEnabled(v57, 1);

                if (v58)
                {
                  v59 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), a2);
                  v60 = objc_msgSend((id)v4, "copyDescription");
                  _NRLogWithArgs(v59, 1, "%s%.30s:%-4d %@: Handling PadN %u", "", "-[NRLinkBluetooth handleReadData:]", 6757, v60, v56);

                }
                break;
              case 2:
                v61 = v38;
                ++*(_QWORD *)(v4 + 1591);
                v62 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), a2);
                v63 = _NRLogIsLevelEnabled(v62, 1);

                if (v63)
                {
                  v65 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v64);
                  v66 = objc_msgSend((id)v4, "copyDescription");
                  _NRLogWithArgs(v65, 1, "%s%.30s:%-4d %@: Reinjecting uncompressed packet len %u", "", "-[NRLinkBluetooth handleReadData:]", 6761, v66, v61);

                }
                v67 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", v43, v61);
                sub_100090B74(v4, v67);

                break;
              case 3:
              case 100:
              case 101:
              case 102:
              case 103:
              case 104:
              case 105:
                sub_100090C58((char *)v4, (uint64_t)v41, (unsigned __int16)(v38 + 5), v38, v37);
                break;
              case 4:
                v68 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", v43, v38);
                sub_10008C2A4(v4, v68);

                break;
              case 5:
                sub_10008C5F8((void *)v4, v43, v38);
                break;
              default:
                break;
            }
          }
          else
          {
            *v20 = v22;
            v46 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), a2);
            v47 = _NRLogIsLevelEnabled(v46, 1);

            if (v47)
            {
              v48 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), a2);
              v49 = objc_msgSend((id)v4, "copyDescription");
              _NRLogWithArgs(v48, 1, "%s%.30s:%-4d %@: Handling Pad0", "", "-[NRLinkBluetooth handleReadData:]", 6718, v49);

            }
          }
          v18 = *(_DWORD *)(v4 + 311);
          v20 = (unsigned int *)(v4 + v19[138]);
          v21 = *v20;
          v22 = *v20 + 1;
          if (v18 < v22)
            goto LABEL_18;
        }
      }
      v23 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), a2);
      v24 = _NRLogIsLevelEnabled(v23, 1);

      if (!v24)
        return;
      v283 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v25);
      v26 = objc_msgSend((id)v4, "copyDescription");
      _NRLogWithArgs(v283, 1, "%s%.30s:%-4d %@: Ignoring bytes due to unknown state", "", "-[NRLinkBluetooth handleReadData:]", 6791, v26);

LABEL_25:
      return;
    }
  }
  else
  {
    v11 = *(unsigned __int8 *)(v4 + 16);
    if ((v11 - 1) > 1)
      goto LABEL_16;
  }
  v12 = *(unsigned int *)(v4 + v8);
  if ((*(_DWORD *)((char *)v9 + v4) - v12) <= 0xB)
  {
    v13 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), a2);
    v14 = _NRLogIsLevelEnabled(v13, 1);

    if (!v14)
      return;
    v283 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v15);
    v16 = objc_msgSend((id)v4, "copyDescription");
    v17 = sub_10010E200(*(unsigned __int8 *)(v4 + 16));
    _NRLogWithArgs(v283, 1, "%s%.30s:%-4d %@: State %@ not enough prelude bytes %u - %u < %zu", "", "-[NRLinkBluetooth handleReadData:]", 6466, v16, v17, *(unsigned int *)((char *)v9 + v4), *(unsigned int *)(v4 + v8), 12);

    goto LABEL_25;
  }
  v27 = &v2[v12];
  if (*(_QWORD *)&v2[v12] != 0x53554E494D524554)
  {
    v283 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", v27, 8);
    v28 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &unk_10015CFE4, 8);
    v29 = v28;
    v30 = "";
    if ((_DWORD)v10)
      v30 = "urgent ";
    objc_msgSend((id)v4, "cancelWithReason:", CFSTR("invalid %sprelude: received %@, expected %@, filledIn=%u, handled=%u"), v30, v283, v28, *(unsigned int *)((char *)v9 + v4), *(unsigned int *)(v4 + v8));

    goto LABEL_25;
  }
  v31 = (bswap32(*((unsigned __int16 *)v27 + 5)) >> 16) + 14;
  if (!(_DWORD)v10)
  {
    v76 = v27[8];
    if ((_DWORD)v76 == 1)
    {
      if (qword_1001E46D8 != -1)
        dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
      if (_NRLogIsLevelEnabled(qword_1001E46D0, 0))
      {
        v77 = sub_100070AC8();
        _NRLogWithArgs(v77, 0, "%s%.30s:%-4d We both speak terminus version %u", "", "-[NRLinkBluetooth handleReadData:]", 6534, 1);

      }
      v78 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("version %u"), 1, v273);
    }
    else
    {
      if (qword_1001E46D8 != -1)
        dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
      if (_NRLogIsLevelEnabled(qword_1001E46D0, 0))
      {
        v84 = sub_100070AC8();
        _NRLogWithArgs(v84, 0, "%s%.30s:%-4d Remote device speaks terminus version %u while we speak %u", "", "-[NRLinkBluetooth handleReadData:]", 6529, v76, 1);

      }
      v78 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("localVersion %u remoteVersion %u"), 1, v76);
    }
    v283 = v78;
    *(_BYTE *)(v4 + 209) = v27[9];
    if (*(unsigned __int8 *)(v4 + 208) == *(unsigned __int8 *)(v4 + 209))
    {
      if (qword_1001E46D8 != -1)
        dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
      if (_NRLogIsLevelEnabled(qword_1001E46D0, 0))
      {
        v85 = sub_100070AC8();
        v86 = (__CFString *)sub_10008FC2C(*(unsigned __int8 *)(v4 + 209));
        _NRLogWithArgs(v85, 0, "%s%.30s:%-4d We are both in prelude state %@", "", "-[NRLinkBluetooth handleReadData:]", 6547, v86);

      }
      v87 = objc_alloc((Class)NSString);
      v88 = CFSTR("Invalid");
      switch(*(_BYTE *)(v4 + 209))
      {
        case 0:
          break;
        case 0xA:
          v88 = CFSTR("PairWithOOBKey");
          break;
        case 0xB:
          v88 = CFSTR("PairWithIDSKeys");
          break;
        case 0xC:
          v88 = CFSTR("PairWithOOBKeyOrIDSKeys");
          break;
        case 0x14:
          v88 = CFSTR("HasCompletedPairing");
          break;
        default:
          v88 = (__CFString *)objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("Unknown(%lld)"), *(unsigned __int8 *)(v4 + 209));
          break;
      }
      v9 = objc_msgSend(v87, "initWithFormat:", CFSTR("state %@"), v88);
    }
    else
    {
      if (qword_1001E46D8 != -1)
        dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
      if (_NRLogIsLevelEnabled(qword_1001E46D0, 0))
      {
        v89 = sub_100070AC8();
        v90 = (__CFString *)sub_10008FC2C(*(unsigned __int8 *)(v4 + 209));
        v91 = (__CFString *)sub_10008FC2C(*(unsigned __int8 *)(v4 + 208));
        _NRLogWithArgs(v89, 0, "%s%.30s:%-4d Received remote prelude state %@ while we are %@", "", "-[NRLinkBluetooth handleReadData:]", 6542, v90, v91);

      }
      v92 = objc_alloc((Class)NSString);
      v88 = CFSTR("Invalid");
      switch(*(_BYTE *)(v4 + 208))
      {
        case 0:
          break;
        case 0xA:
          v88 = CFSTR("PairWithOOBKey");
          break;
        case 0xB:
          v88 = CFSTR("PairWithIDSKeys");
          break;
        case 0xC:
          v88 = CFSTR("PairWithOOBKeyOrIDSKeys");
          break;
        case 0x14:
          v88 = CFSTR("HasCompletedPairing");
          break;
        default:
          v88 = (__CFString *)objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("Unknown(%lld)"), *(unsigned __int8 *)(v4 + 208));
          break;
      }
      v107 = CFSTR("Invalid");
      switch(*(_BYTE *)(v4 + 209))
      {
        case 0:
          break;
        case 0xA:
          v107 = CFSTR("PairWithOOBKey");
          break;
        case 0xB:
          v107 = CFSTR("PairWithIDSKeys");
          break;
        case 0xC:
          v107 = CFSTR("PairWithOOBKeyOrIDSKeys");
          break;
        case 0x14:
          v107 = CFSTR("HasCompletedPairing");
          break;
        default:
          v107 = (__CFString *)objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("Unknown(%lld)"), *(unsigned __int8 *)(v4 + 209));
          break;
      }
      v9 = objc_msgSend(v92, "initWithFormat:", CFSTR("localState %@ remoteState %@"), v88, v107);

      v3 = &gNRPacketLoggingEnabled;
    }

    v108 = *(unsigned __int8 *)(v4 + 209);
    v109 = *(unsigned __int8 *)(v4 + 208);
    v110 = v283;
    if (v108 != v109)
    {
      if (v108 == 10 && v109 != 12 || v108 != 12 && (!*(_BYTE *)(v4 + 209) || v109 == 10))
      {
        objc_msgSend((id)v4, "cancelWithReason:", CFSTR("Incompatible pairing prelude states %@, %@"), v9, v283);
        goto LABEL_247;
      }
      if (v109 < v108)
        LOBYTE(v108) = *(_BYTE *)(v4 + 208);
    }
    *(_BYTE *)(v4 + 210) = v108;
    v111 = CFSTR("Invalid");
    switch(*(_BYTE *)(v4 + 210))
    {
      case 0:
        break;
      case 0xA:
        v111 = CFSTR("PairWithOOBKey");
        break;
      case 0xB:
        v111 = CFSTR("PairWithIDSKeys");
        break;
      case 0xC:
        v111 = CFSTR("PairWithOOBKeyOrIDSKeys");
        break;
      case 0x14:
        v111 = CFSTR("HasCompletedPairing");
        break;
      default:
        v111 = (__CFString *)objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("Unknown(%lld)"), *(unsigned __int8 *)(v4 + 210));
        break;
    }
    objc_msgSend((id)v4, "reportEvent:detailsFormat:", 3010, CFSTR("%@, %@, using %@"), v110, v9, v111);

    v113 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
    v114 = (unsigned __int16)v31;
    if (*(_DWORD *)(v4 + 311) - *(_DWORD *)(v4 + 315) < (unsigned __int16)v31)
    {
      v115 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v112);
      v116 = _NRLogIsLevelEnabled(v115, 1);

      if (v116)
      {
        v118 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v117);
        v119 = objc_msgSend((id)v4, "copyDescription");
        v120 = sub_10010E200(*(unsigned __int8 *)(v4 + 16));
        _NRLogWithArgs(v118, 1, "%s%.30s:%-4d %@: State %@ not enough prelude and TLVs bytes %u - %u < %u", "", "-[NRLinkBluetooth handleReadData:]", 6575, v119, v120, *(unsigned int *)(v4 + 311), *(unsigned int *)(v4 + 315), (unsigned __int16)v31);

      }
      goto LABEL_247;
    }
    v281 = v9;
    v121 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", v27, (unsigned __int16)v31);
    sub_10008FCC4(v4, v121);

    v8 = (unsigned __int16)v31 - 2;
    if ((unsigned __int16)v31 == 2)
    {
      v247 = sub_100070AC8();
      v248 = _NRLogIsLevelEnabled(v247, 16);

      if (v248)
      {
        v249 = sub_100070AC8();
        _NRLogWithArgs(v249, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: dataLen > 0", "", "nrChecksumVerify", 126);

      }
      v250 = _os_log_pack_size(12);
      v34 = (uint64_t)&v275 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
      v251 = __error();
      v252 = _os_log_pack_fill(v34, v250, *v251, &_mh_execute_header, "%{public}s Assertion Failed: dataLen > 0");
      *(_DWORD *)v252 = 136446210;
      *(_QWORD *)(v252 + 4) = "nrChecksumVerify";
      v253 = sub_100070AC8();
      _NRLogAbortWithPack(v253, v34);
      goto LABEL_267;
    }
    v279 = (char *)((unsigned __int16)v31 - 2);
    v280 = (unsigned __int16)v31;
    v282 = &v279[(_QWORD)v27];
    v122 = *(unsigned __int16 *)&v279[(_QWORD)v27];
    v123 = os_inet_checksum(v27, (unsigned __int16)v31 - 2, 0);
    v125 = ~v123;
    if (v122 != (unsigned __int16)~(_WORD)v123)
    {
      v173 = sub_100070AC8();
      v174 = _NRLogIsLevelEnabled(v173, 16);

      if (v174)
      {
        v175 = sub_100070AC8();
        _NRLogWithArgs(v175, 16, "%s%.30s:%-4d checksum failed computed 0x%04x != observed 0x%04x", "", "nrChecksumVerify", 133, bswap32(v125) >> 16, __rev16(v122));

      }
      v176 = os_inet_checksum(v27, v8, 0);
      v178 = *(unsigned __int16 *)v282;
      v179 = *(_QWORD *)(v4 + 1863);
      if (v179)
        *(_BYTE *)(v179 + 99) = 1;
      v180 = ~v176;
      v181 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v177);
      v182 = _NRLogIsLevelEnabled(v181, 16);

      v184 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
      if ((v182 & 1) != 0)
      {
        v282 = (char *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v183);
        v280 = (unint64_t)objc_msgSend((id)v4, "copyDescription");
        v185 = *(id *)(v4 + 359);
        v279 = (char *)objc_msgSend(v185, "length");
        v186 = *(id *)(v4 + 359);
        v187 = (void *)((uint64_t (*)(void))_NRCreateDataString)();
        v188 = *(unsigned int *)(v4 + 311);
        v189 = *(unsigned int *)(v4 + 315);

        v190 = v180;
        v274 = v180;
        v271 = v188;
        v272 = v189;
        v184 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
        v191 = (void *)v280;
        v192 = v282;
        _NRLogWithArgs(v282, 16, "%s%.30s:%-4d %@: Prelude checksum failed: received %llu bytes %@, filledIn=%u, handled=%u, receivedChecksum=0x%04x expectedChecksum=0x%04x", "", "-[NRLinkBluetooth handleReadData:]", 6591, v280, v279, v187, v271, v272, v178, v274);

      }
      else
      {
        v190 = v180;
      }
      v110 = v283;
      v193 = *(id *)(v4 + v184[301]);
      objc_msgSend((id)v4, "cancelWithReason:", CFSTR("prelude checksum failed: received %llu bytes, filledIn=%u, handled=%u, receivedChecksum=0x%04x expectedChecksum=0x%04x"), objc_msgSend(v193, "length"), *(unsigned int *)(v4 + 311), *(unsigned int *)(v4 + 315), v178, v190);

      v9 = v281;
      goto LABEL_247;
    }
    v126 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v124);
    v127 = _NRLogIsLevelEnabled(v126, 1);

    if (v127)
    {
      v129 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v128);
      v130 = objc_msgSend((id)v4, "copyDescription");
      v131 = *(id *)(v4 + 359);
      v132 = objc_msgSend(v131, "length");
      v133 = (void *)_NRCreateDataString(*(_QWORD *)(v4 + 359));
      _NRLogWithArgs(v129, 1, "%s%.30s:%-4d %@: Received prelude %llu bytes %@", "", "-[NRLinkBluetooth handleReadData:]", 6599, v130, v132, v133);

      v114 = (unsigned __int16)v31;
    }
    v134 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
    v8 = (unint64_t)v282;
    if ((unsigned __int16)v31 < 0xFu)
      goto LABEL_230;
    v135 = (unint64_t)(v27 + 12);
    v278 = v114;
    while (1)
    {
      if (!*(_BYTE *)v135)
        goto LABEL_143;
      if (v135 + 2 > v8)
      {
        v194 = v114;
        v195 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v128);
        v8 = _NRLogIsLevelEnabled(v195, 16);

        v114 = v194;
        if (!(_DWORD)v8)
          goto LABEL_230;
        v8 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v128);
        v196 = objc_msgSend((id)v4, "copyDescription");
        _NRLogWithArgs(v8, 16, "%s%.30s:%-4d %@: TLV len is off the edge %lld > %lld", "", "-[NRLinkBluetooth handleReadData:]", 6610, v196, v135 + 2 - (_QWORD)v27, v279);
        goto LABEL_229;
      }
      v136 = *(unsigned __int16 *)(v135 + 1);
      v137 = __rev16(v136);
      v138 = v135 + 3 + v137;
      if (v138 > v8)
      {
        v197 = v114;
        v198 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v128);
        v8 = _NRLogIsLevelEnabled(v198, 16);

        v114 = v197;
        if (!(_DWORD)v8)
          goto LABEL_230;
        v8 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v128);
        v196 = objc_msgSend((id)v4, "copyDescription");
        _NRLogWithArgs(v8, 16, "%s%.30s:%-4d %@: TLV is off the edge %lld + 3 + %u = %lld > %lld", "", "-[NRLinkBluetooth handleReadData:]", 6621, v196, v135 - (_QWORD)v27, v137, v138 - (_QWORD)v27, v279);
LABEL_229:

LABEL_230:
        v199 = *(_DWORD *)(v4 + 311) - *(_DWORD *)(v4 + v134[138]);
        if (v199 > v114)
        {
          v9 = v281;
          v200 = &v27[v280];
          if (*v3)
          {
            v254 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v128);
            v255 = _NRLogIsLevelEnabled(v254, 1);

            if (v255)
            {
              v257 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v256);
              v258 = objc_msgSend((id)v4, "copyDescription");
              _NRLogWithArgs(v257, 1, "%s%.30s:%-4d %@: memmoving the linkReadBuffer by preludeLenFull=%u filledIn=%u handled=%u", "", "-[NRLinkBluetooth handleReadData:]", 6660, v258, v114, *(unsigned int *)(v4 + 311), *(unsigned int *)(v4 + v134[138]));

            }
          }
          memmove(*(void **)(v4 + 1311), v200, (*(_DWORD *)(v4 + 311) - (*(_DWORD *)(v4 + v134[138]) + v114)));
          *(_DWORD *)(v4 + 311) -= *(_DWORD *)(v4 + v134[138]) + v114;
          v110 = v283;
          goto LABEL_237;
        }
        v9 = v281;
        if (v199 != (_DWORD)v114)
        {
          v2 = (char *)v114;
          v259 = sub_100070AC8();
          v260 = _NRLogIsLevelEnabled(v259, 16);

          if (v260)
          {
            v261 = sub_100070AC8();
            _NRLogWithArgs(v261, 16, "%s%.30s:%-4d ABORTING: Bad prelude post-processing preludeLenFull=%u filledIn=%u handled=%u", "", "-[NRLinkBluetooth handleReadData:]", 6668, v114, *(_DWORD *)(v4 + 311), *(_DWORD *)(v4 + 315));

          }
          v10 = _os_log_pack_size(30);
          v212 = (char *)&v275 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
          v262 = __error();
          v263 = _os_log_pack_fill(v212, v10, *v262, &_mh_execute_header, "%{public}s Bad prelude post-processing preludeLenFull=%u filledIn=%u handled=%u");
          sub_10008C184(v263, (uint64_t)"-[NRLinkBluetooth handleReadData:]", v114, *(_DWORD *)(v4 + 311), *(_DWORD *)(v4 + 315));
          goto LABEL_252;
        }
        v110 = v283;
        if (*v3)
        {
          v264 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v128);
          v265 = _NRLogIsLevelEnabled(v264, 1);

          if (v265)
          {
            v267 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v266);
            v268 = objc_msgSend((id)v4, "copyDescription");
            _NRLogWithArgs(v267, 1, "%s%.30s:%-4d %@: not memmoving the linkReadBuffer by preludeLenFull=%u filledIn=%u handled=%u", "", "-[NRLinkBluetooth handleReadData:]", 6671, v268, v114, *(unsigned int *)(v4 + 311), *(unsigned int *)(v4 + v134[138]));

          }
        }
        *(_DWORD *)(v4 + 311) = 0;
LABEL_237:
        *(_DWORD *)(v4 + v134[138]) = 0;
        if (*(_BYTE *)(v4 + 16) == 1)
        {
          objc_msgSend((id)v4, "changeStateTo:", 3);
LABEL_240:
          if (*(_BYTE *)(v4 + 246))
          {
            if (*(_BYTE *)(v4 + 16) == 4)
              sub_10008F998((_QWORD *)v4, v114, &off_1001C46D8);
          }
          else
          {
            v203 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v201);
            v204 = _NRLogIsLevelEnabled(v203, 1);

            if (v204)
            {
              v206 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v205);
              v207 = objc_msgSend((id)v4, "copyDescription");
              _NRLogWithArgs(v206, 1, "%s%.30s:%-4d %@: Starting LtN since received prelude, about to async", "", "-[NRLinkBluetooth handleReadData:]", 6692, v207);

            }
            v208 = *(NSObject **)(v4 + 8);
            v285[0] = _NSConcreteStackBlock;
            v285[1] = 3221225472;
            v285[2] = sub_1000908D4;
            v285[3] = &unk_1001B8AE0;
            v285[4] = v4;
            dispatch_async(v208, v285);
          }
        }
        else
        {
          objc_msgSend((id)v4, "changeStateTo:", 4);
          if ((sub_10008FCD4((char *)v4, v202) & 1) != 0)
            goto LABEL_240;
          objc_msgSend((id)v4, "cancelWithReason:", CFSTR("failed to setup nexus"));
        }
LABEL_247:

        return;
      }
      if (*(_BYTE *)v135 == 4)
        break;
LABEL_142:
      v135 += (v137 + 3);
LABEL_143:
      if (v135 >= v8)
        goto LABEL_230;
    }
    if (v136 != 4096)
    {
      v155 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v128);
      v156 = _NRLogIsLevelEnabled(v155, 16);

      if (v156)
      {
        v157 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v128);
        v158 = objc_msgSend((id)v4, "copyDescription");
        _NRLogWithArgs(v157, 16, "%s%.30s:%-4d %@: ignoring RandomUUID with invalid length %u", "", "-[NRLinkBluetooth handleReadData:]", 6651, v158, v137);

      }
      goto LABEL_142;
    }
    objc_msgSend(*(id *)(v4 + 1359), "getUUIDBytes:", &v287);
    v139 = *(unsigned __int8 *)(v135 + 3);
    v303.i8[0] = v139 ^ v287;
    if (v287 == v139)
    {
      v140 = *(unsigned __int8 *)(v135 + 4);
      v303.i8[1] = v140 ^ v288;
      if (v288 == v140)
      {
        v141 = *(unsigned __int8 *)(v135 + 5);
        v303.i8[2] = v141 ^ v289;
        if (v289 == v141)
        {
          v142 = *(unsigned __int8 *)(v135 + 6);
          v303.i8[3] = v142 ^ v290;
          if (v290 == v142)
          {
            v143 = *(unsigned __int8 *)(v135 + 7);
            v303.i8[4] = v143 ^ v291;
            if (v291 == v143)
            {
              v144 = *(unsigned __int8 *)(v135 + 8);
              v303.i8[5] = v144 ^ v292;
              if (v292 == v144)
              {
                v145 = *(unsigned __int8 *)(v135 + 9);
                v303.i8[6] = v145 ^ v293;
                if (v293 == v145)
                {
                  v146 = *(unsigned __int8 *)(v135 + 10);
                  v303.i8[7] = v146 ^ v294;
                  if (v294 == v146)
                  {
                    v147 = *(unsigned __int8 *)(v135 + 11);
                    v303.i8[8] = v147 ^ v295;
                    if (v295 == v147)
                    {
                      v148 = *(unsigned __int8 *)(v135 + 12);
                      v303.i8[9] = v148 ^ v296;
                      if (v296 == v148)
                      {
                        v149 = *(unsigned __int8 *)(v135 + 13);
                        v303.i8[10] = v149 ^ v297;
                        if (v297 == v149)
                        {
                          v150 = *(unsigned __int8 *)(v135 + 14);
                          v303.i8[11] = v150 ^ v298;
                          if (v298 == v150)
                          {
                            v151 = *(unsigned __int8 *)(v135 + 15);
                            v303.i8[12] = v151 ^ v299;
                            if (v299 == v151)
                            {
                              v152 = *(unsigned __int8 *)(v135 + 16);
                              v303.i8[13] = v152 ^ v300;
                              if (v300 == v152)
                              {
                                v153 = *(unsigned __int8 *)(v135 + 17);
                                v303.i8[14] = v153 ^ v301;
                                if (v301 == v153)
                                {
                                  v154 = *(unsigned __int8 *)(v135 + 18);
                                  v303.i8[15] = v154 ^ v302;
                                  v134 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                                  if (v302 > v154)
                                    *(_BYTE *)(v4 + 242) = 1;
                                  goto LABEL_185;
                                }
                                v134 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                                if (v301 > v153)
                                  *(_BYTE *)(v4 + 242) = 1;
LABEL_184:
                                v303.i8[15] = *(_BYTE *)(v135 + 18) ^ v302;
LABEL_185:
                                v159 = objc_alloc((Class)NSString);
                                v160 = (void *)sub_100111BA0(&v303);
                                v161 = objc_msgSend(v159, "initWithFormat:", CFSTR(" %@"), v160);
                                v162 = *(void **)(v4 + 1367);
                                *(_QWORD *)(v4 + 1367) = v161;

                                v164 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v163);
                                LODWORD(v160) = _NRLogIsLevelEnabled(v164, 1);

                                if ((_DWORD)v160)
                                {
                                  v276 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v128);
                                  v165 = objc_msgSend((id)v4, "copyDescription");
                                  v275 = v165;
                                  v277 = objc_msgSend(objc_alloc((Class)NSUUID), "initWithUUIDBytes:", v135 + 3);
                                  v166 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v277, "UUIDString"));
                                  v167 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v4 + 1359), "UUIDString"));
                                  v168 = objc_msgSend(objc_alloc((Class)NSUUID), "initWithUUIDBytes:", &v303);
                                  v169 = objc_claimAutoreleasedReturnValue(objc_msgSend(v168, "UUIDString"));
                                  v170 = (void *)v169;
                                  v171 = "Responder";
                                  if (!*(_BYTE *)(v4 + 242))
                                    v171 = "Initiator";
                                  v269 = v165;
                                  v172 = (void *)v276;
                                  _NRLogWithArgs(v276, 1, "%s%.30s:%-4d %@: received randomUUID %@, local %@, joint %@ hash%@, we are %s", "", "-[NRLinkBluetooth handleReadData:]", 6649, v269, v166, v167, v169, *(_QWORD *)(v4 + 1367), v171);

                                  v134 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                                }
                                v114 = v278;
                                v8 = (unint64_t)v282;
                                goto LABEL_142;
                              }
                              v134 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                              if (v300 > v152)
                                *(_BYTE *)(v4 + 242) = 1;
LABEL_183:
                              v303.i8[14] = *(_BYTE *)(v135 + 17) ^ v301;
                              goto LABEL_184;
                            }
                            v134 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                            if (v299 > v151)
                              *(_BYTE *)(v4 + 242) = 1;
LABEL_182:
                            v303.i8[13] = *(_BYTE *)(v135 + 16) ^ v300;
                            goto LABEL_183;
                          }
                          v134 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                          if (v298 > v150)
                            *(_BYTE *)(v4 + 242) = 1;
LABEL_181:
                          v303.i8[12] = *(_BYTE *)(v135 + 15) ^ v299;
                          goto LABEL_182;
                        }
                        v134 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                        if (v297 > v149)
                          *(_BYTE *)(v4 + 242) = 1;
LABEL_180:
                        v303.i8[11] = *(_BYTE *)(v135 + 14) ^ v298;
                        goto LABEL_181;
                      }
                      v134 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                      if (v296 > v148)
                        *(_BYTE *)(v4 + 242) = 1;
LABEL_179:
                      v303.i8[10] = *(_BYTE *)(v135 + 13) ^ v297;
                      goto LABEL_180;
                    }
                    v134 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                    if (v295 > v147)
                      *(_BYTE *)(v4 + 242) = 1;
LABEL_178:
                    v303.i8[9] = *(_BYTE *)(v135 + 12) ^ v296;
                    goto LABEL_179;
                  }
                  v134 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
                  if (v294 > v146)
                    *(_BYTE *)(v4 + 242) = 1;
LABEL_177:
                  v303.i8[8] = *(_BYTE *)(v135 + 11) ^ v295;
                  goto LABEL_178;
                }
                if (v293 > v145)
                  *(_BYTE *)(v4 + 242) = 1;
LABEL_176:
                v303.i8[7] = *(_BYTE *)(v135 + 10) ^ v294;
                goto LABEL_177;
              }
              if (v292 > v144)
                *(_BYTE *)(v4 + 242) = 1;
LABEL_175:
              v303.i8[6] = *(_BYTE *)(v135 + 9) ^ v293;
              goto LABEL_176;
            }
            if (v291 > v143)
              *(_BYTE *)(v4 + 242) = 1;
LABEL_174:
            v303.i8[5] = *(_BYTE *)(v135 + 8) ^ v292;
            goto LABEL_175;
          }
          if (v290 > v142)
            *(_BYTE *)(v4 + 242) = 1;
LABEL_173:
          v303.i8[4] = *(_BYTE *)(v135 + 7) ^ v291;
          goto LABEL_174;
        }
        if (v289 > v141)
          *(_BYTE *)(v4 + 242) = 1;
LABEL_172:
        v303.i8[3] = *(_BYTE *)(v135 + 6) ^ v290;
        goto LABEL_173;
      }
      if (v288 > v140)
        *(_BYTE *)(v4 + 242) = 1;
    }
    else
    {
      if (v287 > v139)
        *(_BYTE *)(v4 + 242) = 1;
      v303.i8[1] = *(_BYTE *)(v135 + 4) ^ v288;
    }
    v303.i8[2] = *(_BYTE *)(v135 + 5) ^ v289;
    goto LABEL_172;
  }
  *(_BYTE *)(v4 + 229) = 1;
  objc_msgSend((id)v4, "reportEvent:", 4217);
  v33 = *(_DWORD *)((char *)v9 + v4) - *(_DWORD *)(v4 + v8);
  v34 = (unsigned __int16)v31;
  if (v33 > (unsigned __int16)v31)
  {
    if (*v3)
    {
      v230 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v32);
      v231 = _NRLogIsLevelEnabled(v230, 1);

      if (v231)
      {
        v233 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v232);
        v234 = objc_msgSend((id)v4, "copyDescription");
        _NRLogWithArgs(v233, 1, "%s%.30s:%-4d %@: memmoving the urgent linkReadBuffer by preludeLenFull=%u filledIn=%u handled=%u", "", "-[NRLinkBluetooth handleReadData:]", 6490, v234, (unsigned __int16)v31, *(unsigned int *)(v4 + 311), *(unsigned int *)(v4 + 315));

      }
    }
    memmove(v2, &v27[(unsigned __int16)v31], *(_DWORD *)((char *)v9 + v4) - *(_DWORD *)(v4 + v8) - (unsigned __int16)v31);
    v35 = *(_DWORD *)((char *)v9 + v4) - *(_DWORD *)(v4 + v8) - (unsigned __int16)v31;
    goto LABEL_66;
  }
  if (v33 != (unsigned __int16)v31)
  {
    v235 = sub_100070AC8();
    v236 = _NRLogIsLevelEnabled(v235, 16);

    if (v236)
    {
      v237 = sub_100070AC8();
      _NRLogWithArgs(v237, 16, "%s%.30s:%-4d ABORTING: Bad prelude post-processing preludeLenFull=%u filledIn=%u handled=%u", "", "-[NRLinkBluetooth handleReadData:]", 6499, (unsigned __int16)v31, *(_DWORD *)((char *)v9 + v4), *(_DWORD *)(v4 + v8));

    }
    v238 = _os_log_pack_size(30);
    v239 = (char *)&v275 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
    v240 = __error();
    v241 = _os_log_pack_fill(v239, v238, *v240, &_mh_execute_header, "%{public}s Bad prelude post-processing preludeLenFull=%u filledIn=%u handled=%u");
    sub_10008C184(v241, (uint64_t)"-[NRLinkBluetooth handleReadData:]", (unsigned __int16)v31, *(_DWORD *)((char *)v9 + v4), *(_DWORD *)(v4 + v8));
    v242 = sub_100070AC8();
    _NRLogAbortWithPack(v242, v239);
LABEL_262:
    v113 = (int *)v4;
    v243 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v32);
    v244 = _NRLogIsLevelEnabled(v243, 1);

    if (v244)
    {
      v245 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v32);
      v246 = objc_msgSend((id)v4, "copyDescription");
      _NRLogWithArgs(v245, 1, "%s%.30s:%-4d %@: not memmoving the urgent linkReadBuffer by preludeLenFull=%u filledIn=%u handled=%u", "", "-[NRLinkBluetooth handleReadData:]", 6502, v246, (unsigned __int16)v31, *(unsigned int *)((char *)v9 + v4), *(unsigned int *)(v4 + v8));

      v35 = 0;
      goto LABEL_66;
    }
LABEL_267:
    v35 = 0;
    v4 = (uint64_t)v113;
    goto LABEL_66;
  }
  v35 = *v3;
  if (*v3)
    goto LABEL_262;
LABEL_66:
  *(_DWORD *)((char *)v9 + v4) = v35;
  *(_DWORD *)(v4 + v8) = 0;
  v79 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v32);
  v80 = _NRLogIsLevelEnabled(v79, 1);

  if (v80)
  {
    v82 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v81);
    v83 = objc_msgSend((id)v4, "copyDescription");
    _NRLogWithArgs(v82, 1, "%s%.30s:%-4d %@: Successfully received prelude for urgent link", "", "-[NRLinkBluetooth handleReadData:]", 6507, v83);

  }
  if (*(_BYTE *)(v4 + 246))
  {
    sub_10008F998((_QWORD *)v4, v34, &off_1001C46F0);
  }
  else
  {
    v93 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v81);
    v94 = _NRLogIsLevelEnabled(v93, 1);

    if (v94)
    {
      v96 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v95);
      v97 = objc_msgSend((id)v4, "copyDescription");
      _NRLogWithArgs(v96, 1, "%s%.30s:%-4d %@: Starting LtN-U since received prelude, about to async", "", "-[NRLinkBluetooth handleReadData:]", 6513, v97);

    }
    v98 = *(NSObject **)(v4 + 8);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10008FB84;
    block[3] = &unk_1001B8AE0;
    block[4] = v4;
    dispatch_async(v98, block);
  }
}

void sub_10008F998(_QWORD *a1, uint64_t a2, void *a3)
{
  id v5;
  id v6;
  id v7;
  id v8;
  void *v9;
  uint64_t v10;
  void *v11;
  id v12;
  void *v13;
  id v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  int IsLevelEnabled;
  uint64_t v19;
  void *v20;
  id v21;
  id v22;

  v22 = a3;
  v5 = objc_alloc_init((Class)NSMutableDictionary);
  v6 = objc_msgSend(objc_alloc((Class)NSNumber), "initWithUnsignedInt:", a2);
  objc_msgSend(v5, "setObject:forKeyedSubscript:", v6, CFSTR("activate-datapath-offset"));

  objc_msgSend(v5, "setObject:forKeyedSubscript:", v22, CFSTR("channel-id"));
  v7 = objc_alloc_init((Class)NSMutableDictionary);
  objc_msgSend(v7, "setObject:forKeyedSubscript:", v5, CFSTR("activate-datapath"));
  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v8 = (id)qword_1001E4708;
  v9 = v8;
  if (v8)
  {
    v10 = a1[4];
    v11 = (void *)*((_QWORD *)v8 + 25);
    v12 = v7;
    v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "objectForKeyedSubscript:", v10));
    sub_1000EF368((uint64_t)v13, v12);

  }
  v14 = objc_msgSend(v22, "integerValue");
  if (v14 == (id)3)
  {
    v16 = 249;
    goto LABEL_11;
  }
  if (v14 == (id)2)
  {
    v16 = 248;
    goto LABEL_11;
  }
  if (v14 == (id)1)
  {
    v16 = 247;
LABEL_11:
    *((_BYTE *)a1 + v16) = 1;
    goto LABEL_12;
  }
  v17 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v15);
  IsLevelEnabled = _NRLogIsLevelEnabled(v17, 17);

  if (IsLevelEnabled)
  {
    v20 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v19);
    v21 = objc_msgSend(a1, "copyDescription");
    _NRLogWithArgs(v20, 17, "%@: unsupported channel id %@", v21, v22);

  }
LABEL_12:

}

void sub_10008FB84(uint64_t a1, uint64_t a2)
{
  void *v3;
  int IsLevelEnabled;
  uint64_t v5;
  void *v6;
  id v7;

  v3 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), a2);
  IsLevelEnabled = _NRLogIsLevelEnabled(v3, 1);

  if (IsLevelEnabled)
  {
    v6 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v5);
    v7 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    _NRLogWithArgs(v6, 1, "%s%.30s:%-4d %@: Starting LtN-U since received prelude, in async block", "", "-[NRLinkBluetooth handleReadData:]_block_invoke", 6517, v7);

  }
  sub_100086FF4(*(void **)(a1 + 32));
}

const __CFString *sub_10008FC2C(unsigned int a1)
{
  uint64_t v1;
  const __CFString *result;

  v1 = a1;
  result = CFSTR("Invalid");
  switch(a1)
  {
    case 0u:
      return result;
    case 0xAu:
      result = CFSTR("PairWithOOBKey");
      break;
    case 0xBu:
      result = CFSTR("PairWithIDSKeys");
      break;
    case 0xCu:
      result = CFSTR("PairWithOOBKeyOrIDSKeys");
      break;
    case 0x14u:
      result = CFSTR("HasCompletedPairing");
      break;
    default:
      result = (const __CFString *)objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("Unknown(%lld)"), v1);
      break;
  }
  return result;
}

void sub_10008FCC4(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(a1 + 359), a2);
}

uint64_t sub_10008FCD4(char *a1, uint64_t a2)
{
  char *v2;
  void *v3;
  int IsLevelEnabled;
  uint64_t v5;
  void *v6;
  id v7;
  uint64_t v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  void *v16;
  id v17;
  id v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  id *v22;
  id *v23;
  id v24;
  id v25;
  void *v26;
  void *v27;
  id v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  void *v32;
  int v33;
  uint64_t v34;
  void *v35;
  id v36;
  int v37;
  id v38;
  id v39;
  void *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  void *v44;
  int v45;
  uint64_t v46;
  void *v47;
  id v48;
  void *v49;
  int v50;
  uint64_t v51;
  char *v52;
  id v53;
  uint64_t v54;
  void *v55;
  int v56;
  uint64_t v57;
  void *v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  void *v63;
  int v64;
  uint64_t v65;
  void *v66;
  id v67;
  uint64_t v68;
  id v69;
  char *v70;
  uint64_t v71;
  void *v72;
  int v73;
  uint64_t v74;
  void *v75;
  id v76;
  void *v77;
  int v78;
  uint64_t v79;
  id v80;
  void *v81;
  int v82;
  uint64_t v83;
  uint64_t v84;
  void *v85;
  int v86;
  uint64_t v87;
  id v88;
  int v89;
  id v90;
  int *v91;
  uint64_t v92;
  id v93;
  int v94;
  uint64_t v95;
  void *v96;
  id v97;
  uint64_t v98;
  void *v99;
  int v100;
  uint64_t v101;
  _QWORD v104[4];
  id v105;
  id location;

  v2 = a1;
  v3 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)a1 + 4), a2);
  IsLevelEnabled = _NRLogIsLevelEnabled(v3, 1);

  if (IsLevelEnabled)
  {
    v6 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v2 + 4), v5);
    v7 = objc_msgSend(v2, "copyDescription");
    _NRLogWithArgs(v6, 1, "%s%.30s:%-4d %@: setting up nexus", "", "-[NRLinkBluetooth setupNexus]", 5877, v7);

  }
  v8 = *(_QWORD *)(v2 + 343);
  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v2 + 335), "peer"));
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "identifier"));
  v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "UUIDString"));
  v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Terminus Bluetooth link to \"%@\" <%@>"), v8, v11));

  v14 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v2 + 4), v13);
  LODWORD(v10) = _NRLogIsLevelEnabled(v14, 0);

  if ((_DWORD)v10)
  {
    v16 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v2 + 4), v15);
    v17 = objc_msgSend(v2, "copyDescription");
    _NRLogWithArgs(v16, 0, "%s%.30s:%-4d %@: setup IPsec over BT with ring sizes if: %u kpipe tx: %u kpipe rx: %u", "", "-[NRLinkBluetooth setupNexus]", 5883, v17, dword_1001E40C8, dword_1001E40CC, dword_1001E40D0);

  }
  if (v2[246])
  {
    v18 = objc_alloc((Class)NEIPsecNexus);
    v19 = dword_1001E40C8;
    v20 = dword_1001E40CC;
    v21 = dword_1001E40D0;
    objc_opt_self(NRLinkDirector);
    if (qword_1001E4710 != -1)
      dispatch_once(&qword_1001E4710, &stru_1001B6E60);
    v22 = (id *)(id)qword_1001E4708;
    v23 = v22;
    if (v22)
      v24 = v22[30];
    else
      v24 = 0;
    v25 = objc_msgSend(v18, "initWithName:delegate:enableWithChannelCount:netifRingSize:kernelPipeTxRingSize:kernelPipeRxRingSize:execUUID:", v12, v2, 4, v19, v20, v21, v24);
    v26 = *(void **)(v2 + 1335);
    *(_QWORD *)(v2 + 1335) = v25;

    v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v2 + 1335), "nexusInstances"));
    sub_100095EB0((uint64_t)v2, v27);
  }
  else
  {
    v28 = sub_10011369C(v12, v2, 4, dword_1001E40C8, dword_1001E40CC, (const char *)dword_1001E40D0);
    v27 = *(void **)(v2 + 1335);
    *(_QWORD *)(v2 + 1335) = v28;
  }

  objc_msgSend(v2, "setVirtualInterface:", objc_msgSend(*(id *)(v2 + 1335), "virtualInterface"));
  if ((objc_msgSend(v2, "setInterfaceSubfamily") & 1) != 0)
  {
    if ((sub_10009609C(v2) & 1) == 0)
    {
      v55 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v2 + 4), v30);
      v56 = _NRLogIsLevelEnabled(v55, 16);

      if (!v56)
        goto LABEL_68;
      v52 = (char *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v2 + 4), v57);
      v53 = objc_msgSend(v2, "copyDescription");
      _NRLogWithArgs(v52, 16, "%s%.30s:%-4d %@: failed to setup QoS marking", "", "-[NRLinkBluetooth setupNexus]", 5916, v53);
      goto LABEL_32;
    }
    if ((objc_msgSend(v2, "setNoACKPrioritization") & 1) != 0)
    {
      v31 = *(void **)(v2 + 1335);
      if (v31)
      {
        if (v2[246])
        {
          v32 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v2 + 4), v29);
          v33 = _NRLogIsLevelEnabled(v32, 0);

          if (!v33)
          {
LABEL_20:
            v37 = v2[210];
            if (!v2[242] || *(_QWORD *)(v2 + 1215))
            {
LABEL_26:
              if ((v37 - 10) > 9)
              {
                sub_10007762C((uint64_t)v2, 4);
                objc_initWeak(&location, v2);
                objc_opt_self(NRDKeyManager);
                if (qword_1001E4AD8 != -1)
                  goto LABEL_63;
                goto LABEL_45;
              }
              sub_10009958C((uint64_t)v2);
              while (1)
              {
                v70 = sub_10012FFF4((uint64_t)NRDLocalDevice, *((void **)v2 + 4));
                if (v70)
                  break;
                v88 = sub_100070AC8();
                v89 = _NRLogIsLevelEnabled(v88, 16);

                if (v89)
                {
                  v90 = sub_100070AC8();
                  _NRLogWithArgs(v90, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)", "", "-[NRLinkBluetooth setupNexus]", 5947);

                }
                v12 = (void *)_os_log_pack_size(12);
                v2 = (char *)&v104[-1] - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
                v91 = __error();
                v92 = _os_log_pack_fill(v2, v12, *v91, &_mh_execute_header, "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
                *(_DWORD *)v92 = 136446210;
                *(_QWORD *)(v92 + 4) = "-[NRLinkBluetooth setupNexus]";
                v93 = sub_100070AC8();
                _NRLogAbortWithPack(v93, v2);
                __break(1u);
LABEL_63:
                dispatch_once(&qword_1001E4AD8, &stru_1001B8968);
LABEL_45:
                v69 = (id)qword_1001E4AD0;
                v104[0] = _NSConcreteStackBlock;
                v104[1] = 3221225472;
                v104[2] = sub_1000998A4;
                v104[3] = &unk_1001B7F28;
                objc_copyWeak(&v105, &location);
                sub_10014ACE0((uint64_t)v69, v104);

                objc_destroyWeak(&v105);
                objc_destroyWeak(&location);
              }
              v52 = v70;
              v53 = (id)sub_10013D578(v70);
              objc_msgSend(*(id *)(v2 + 1335), "setLocalAddresses:", v53);
              sub_10007BBAC((uint64_t)v2);
              sub_10009683C((uint64_t)v2, 0);
              v72 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v2 + 4), v71);
              v73 = _NRLogIsLevelEnabled(v72, 1);

              if (v73)
              {
                v75 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v2 + 4), v74);
                v76 = objc_msgSend(v2, "copyDescription");
                v77 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v2 + 1335), "interfaceName"));
                _NRLogWithArgs(v75, 1, "%s%.30s:%-4d %@: created interface \"%@\" with addresses %@ for nexus %@", "", "-[NRLinkBluetooth setupNexus]", 5957, v76, v77, v53, v12);

              }
              sub_100096A48((uint64_t)v2);
              v54 = 1;
              goto LABEL_50;
            }
            v38 = sub_100112198();
            objc_msgSend(v38, "setRequestChildlessSA:", 1);
            v39 = objc_msgSend(objc_alloc((Class)NEIKEv2Listener), "initWithListenerIKEConfig:kernelSASessionName:packetDelegate:listenerQueue:delegate:delegateQueue:", v38, CFSTR("terminusIKE-Bluetooth-Listener"), v2, *((_QWORD *)v2 + 1), v2, *((_QWORD *)v2 + 1));
            v40 = *(void **)(v2 + 1215);
            *(_QWORD *)(v2 + 1215) = v39;

            v41 = *(_QWORD *)(v2 + 1215);
            v43 = _NRCopyLogObjectForNRUUID(*((_QWORD *)v2 + 4), v42);
            v44 = (void *)v43;
            if (v41)
            {
              v45 = _NRLogIsLevelEnabled(v43, 0);

              if (v45)
              {
                v47 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v2 + 4), v46);
                v48 = objc_msgSend(v2, "copyDescription");
                _NRLogWithArgs(v47, 0, "%s%.30s:%-4d %@: Created IKE listener", "", "-[NRLinkBluetooth setupIPsec]", 9067, v48);

              }
              goto LABEL_26;
            }
            v94 = _NRLogIsLevelEnabled(v43, 17);

            if (v94)
            {
              v96 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v2 + 4), v95);
              v97 = objc_msgSend(v2, "copyDescription");
              _NRLogWithArgs(v96, 17, "%@: Failed to create IKE listener", v97);

            }
            v99 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v2 + 4), v98);
            v100 = _NRLogIsLevelEnabled(v99, 16);

            if (v100)
            {
              v52 = (char *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v2 + 4), v101);
              v53 = objc_msgSend(v2, "copyDescription");
              _NRLogWithArgs(v52, 16, "%s%.30s:%-4d %@: failed to setup IPsec", "", "-[NRLinkBluetooth setupNexus]", 5942, v53);
              goto LABEL_32;
            }
LABEL_68:
            v54 = 0;
            goto LABEL_69;
          }
          v35 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v2 + 4), v34);
          v36 = objc_msgSend(v2, "copyDescription");
          _NRLogWithArgs(v35, 0, "%s%.30s:%-4d %@: Deferring nexus setup to the packet parser", "", "-[NRLinkBluetooth setupNexusChannel]", 1812, v36);
LABEL_19:

          goto LABEL_20;
        }
        v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v31, "nexusInstances"));
        v62 = _NRCopyLogObjectForNRUUID(*((_QWORD *)v2 + 4), v61);
        v63 = (void *)v62;
        if (v35)
        {
          v64 = _NRLogIsLevelEnabled(v62, 1);

          if (v64)
          {
            v66 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v2 + 4), v65);
            v67 = objc_msgSend(v2, "copyDescription");
            _NRLogWithArgs(v66, 1, "%s%.30s:%-4d %@: Created nexus instances: %@", "", "-[NRLinkBluetooth setupNexusChannel]", 1823, v67, v35);

          }
          if (objc_msgSend(v35, "count") == 4)
          {
            v36 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v35, "objectAtIndexedSubscript:", 0));
            if (sub_10009A548((uint64_t)v2, v36))
            {

              v36 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v35, "objectAtIndexedSubscript:", 1));
              if (sub_10009AC8C((uint64_t)v2, v36))
              {

                v36 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v35, "objectAtIndexedSubscript:", 2));
                if (sub_10009B3D0((uint64_t)v2, v36))
                {

                  v36 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v35, "objectAtIndexedSubscript:", 3));
                  if ((sub_10009BB14((uint64_t)v2, v36) & 1) != 0)
                    goto LABEL_19;
                }
              }
            }
            goto LABEL_56;
          }
          v81 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v2 + 4), v68);
          v82 = _NRLogIsLevelEnabled(v81, 17);

          if (!v82)
          {
LABEL_58:

            v85 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v2 + 4), v84);
            v86 = _NRLogIsLevelEnabled(v85, 16);

            if (!v86)
              goto LABEL_68;
            v52 = (char *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v2 + 4), v87);
            v53 = objc_msgSend(v2, "copyDescription");
            _NRLogWithArgs(v52, 16, "%s%.30s:%-4d %@: failed to setup nexus channel", "", "-[NRLinkBluetooth setupNexus]", 5937, v53);
            goto LABEL_32;
          }
          v36 = (id)_NRCopyLogObjectForNRUUID(*((_QWORD *)v2 + 4), v83);
          v80 = objc_msgSend(v2, "copyDescription");
          _NRLogWithArgs(v36, 17, "%@: Expected to receive only %d nexus instances: %@", v80, 4, v35);
        }
        else
        {
          v78 = _NRLogIsLevelEnabled(v62, 17);

          if (!v78)
          {
            v35 = 0;
            goto LABEL_58;
          }
          v36 = (id)_NRCopyLogObjectForNRUUID(*((_QWORD *)v2 + 4), v79);
          v80 = objc_msgSend(v2, "copyDescription");
          _NRLogWithArgs(v36, 17, "%@: Failed to get nexus instances", v80);
          v35 = 0;
        }

LABEL_56:
        goto LABEL_58;
      }
      v58 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v2 + 4), v29);
      v59 = _NRLogIsLevelEnabled(v58, 16);

      if (!v59)
        goto LABEL_68;
      v52 = (char *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v2 + 4), v60);
      v53 = objc_msgSend(v2, "copyDescription");
      _NRLogWithArgs(v52, 16, "%s%.30s:%-4d %@: failed to create packet nexus", "", "-[NRLinkBluetooth setupNexus]", 5932, v53);
LABEL_32:
      v54 = 0;
      goto LABEL_50;
    }
  }
  v49 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v2 + 4), v29);
  v50 = _NRLogIsLevelEnabled(v49, 17);

  if (!v50)
    goto LABEL_68;
  v52 = (char *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v2 + 4), v51);
  v53 = objc_msgSend(v2, "copyDescription");
  _NRLogWithArgs(v52, 17, "%@: failed to setup interface sub family", v53);
  v54 = 0;
LABEL_50:

LABEL_69:
  return v54;
}

void sub_1000908A8(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 96));
  _Unwind_Resume(a1);
}

void sub_1000908D4(uint64_t a1, uint64_t a2)
{
  void *v3;
  int IsLevelEnabled;
  uint64_t v5;
  void *v6;
  id v7;

  v3 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), a2);
  IsLevelEnabled = _NRLogIsLevelEnabled(v3, 1);

  if (IsLevelEnabled)
  {
    v6 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v5);
    v7 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    _NRLogWithArgs(v6, 1, "%s%.30s:%-4d %@: Starting LtN since received prelude, in async block", "", "-[NRLinkBluetooth handleReadData:]_block_invoke", 6695, v7);

  }
  sub_100091008(*(void **)(a1 + 32));
}

void sub_10009097C(uint64_t a1, uint64_t a2)
{
  unsigned int v3;
  int v4;
  int *v5;
  unsigned int v6;
  int *v7;
  void *v8;
  int IsLevelEnabled;
  uint64_t v10;
  void *v11;
  id v12;
  void *v13;
  int v14;
  uint64_t v15;
  void *v16;
  id v17;

  v3 = *(_DWORD *)(a1 + 315);
  if (a2 <= 0x800)
    v4 = 2048;
  else
    v4 = a2;
  v5 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
  v6 = *(_DWORD *)(a1 + 311);
  if (v3 == v6)
  {
    if (gNRPacketLoggingEnabled)
    {
      v8 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
      IsLevelEnabled = _NRLogIsLevelEnabled(v8, 1);

      if (IsLevelEnabled)
      {
        v11 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v10);
        v12 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v11, 1, "%s%.30s:%-4d %@: resetting the linkReadBuffer", "", "-[NRLinkBluetooth cleanupLinkReadBufferWithExtra:]", 6406, v12);

      }
    }
    *(_DWORD *)(a1 + 315) = 0;
    v7 = &OBJC_IVAR___NRLinkBluetooth__filledInLinkReadBufferBytes;
LABEL_11:
    *(_DWORD *)(a1 + *v7) = 0;
    return;
  }
  if (v6 > v3 && v3 + v4 >= *(_DWORD *)(a1 + 263))
  {
    if (gNRPacketLoggingEnabled)
    {
      v13 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
      v14 = _NRLogIsLevelEnabled(v13, 1);

      v5 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
      if (v14)
      {
        v16 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v15);
        v17 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v16, 1, "%s%.30s:%-4d %@: memmoving the linkReadBuffer by %u", "", "-[NRLinkBluetooth cleanupLinkReadBufferWithExtra:]", 6411, v17, *(unsigned int *)(a1 + 315));

        v5 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
      }
    }
    v7 = &OBJC_IVAR___NRLinkBluetooth__handledLinkReadBufferBytes;
    memmove(*(void **)(a1 + 1311), (const void *)(*(_QWORD *)(a1 + 1311) + *(unsigned int *)(a1 + 315)), (*(_DWORD *)(a1 + v5[137]) - *(_DWORD *)(a1 + 315)));
    *(_DWORD *)(a1 + v5[137]) -= *(_DWORD *)(a1 + 315);
    goto LABEL_11;
  }
}

void sub_100090B74(uint64_t a1, void *a2)
{
  id v3;
  uint64_t next_slot;
  uint64_t v5;
  unsigned __int16 v6;
  unsigned __int16 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;

  v3 = a2;
  v10 = 0u;
  v11 = 0u;
  v8 = 0u;
  v9 = 0u;
  next_slot = os_channel_get_next_slot(*(_QWORD *)(a1 + 383), 0, &v8);
  if (next_slot)
  {
    v5 = next_slot;
    v6 = (unsigned __int16)objc_msgSend(v3, "length");
    v7 = WORD1(v8);
    if (WORD1(v8) > v6)
      v7 = (unsigned __int16)objc_msgSend(v3, "length");
    memcpy((void *)v9, objc_msgSend(v3, "bytes"), v7);
    WORD1(v8) = v7;
    os_channel_set_slot_properties(*(_QWORD *)(a1 + 383), v5, &v8);
    os_channel_advance_slot(*(_QWORD *)(a1 + 383), v5);
    os_channel_sync(*(_QWORD *)(a1 + 367), 0);
  }

}

void sub_100090C58(char *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  unsigned int v8;
  uint64_t v9;
  void *v10;
  void *v11;
  unsigned int v12;
  uint64_t v13;
  id v14;
  uint64_t v15;
  void *v16;
  int v17;
  uint64_t v18;
  void *v19;
  id v20;
  uint64_t v21;
  void *StringFromNRTLVType;
  id v23;
  int IsLevelEnabled;
  id v25;
  uint64_t v26;
  char *v27;
  int *v28;
  uint64_t v29;
  id v30;
  int v31;
  id v32;
  uint64_t v33;
  int *v34;
  uint64_t v35;
  id v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  int v40;

  v38 = a2;
  v39 = a3;
  v40 = 0;
  v8 = nrMaxPacketLengthForTLV(a5, a4);
  if (!v8)
  {
    v23 = sub_100070AC8();
    IsLevelEnabled = _NRLogIsLevelEnabled(v23, 16);

    if (IsLevelEnabled)
    {
      v25 = sub_100070AC8();
      _NRLogWithArgs(v25, 16, "%s%.30s:%-4d ABORTING: strict_malloc called with size 0", "", "strict_malloc", 74);

    }
    v26 = _os_log_pack_size(12);
    v27 = (char *)&v37 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
    v28 = __error();
    v29 = _os_log_pack_fill(v27, v26, *v28, &_mh_execute_header, "%{public}s strict_malloc called with size 0");
    *(_DWORD *)v29 = 136446210;
    *(_QWORD *)(v29 + 4) = "strict_malloc";
LABEL_24:
    v36 = sub_100070AC8();
    _NRLogAbortWithPack(v36, v27);
  }
  v9 = v8;
  v10 = malloc_type_malloc(v8, 0xA172743EuLL);
  if (!v10)
  {
    v30 = sub_100070AC8();
    v31 = _NRLogIsLevelEnabled(v30, 16);

    if (v31)
    {
      v32 = sub_100070AC8();
      _NRLogWithArgs(v32, 16, "%s%.30s:%-4d ABORTING: strict_malloc(%zu) failed", "", "strict_malloc", 79, v9);

    }
    v33 = _os_log_pack_size(22);
    v27 = (char *)&v37 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
    v34 = __error();
    v35 = _os_log_pack_fill(v27, v33, *v34, &_mh_execute_header, "%{public}s strict_malloc(%zu) failed");
    *(_DWORD *)v35 = 136446466;
    *(_QWORD *)(v35 + 4) = "strict_malloc";
    *(_WORD *)(v35 + 12) = 2048;
    *(_QWORD *)(v35 + 14) = v9;
    goto LABEL_24;
  }
  v11 = v10;
  v12 = nrTLVToPacket(&v38, 1, a5, a4, v10, v9, a1 + 1967, a1 + 1951);
  if (v12)
  {
    v14 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", v11, v12);
    switch((int)a5)
    {
      case 'd':
        v15 = 1607;
        goto LABEL_13;
      case 'e':
        v15 = 1615;
        goto LABEL_13;
      case 'f':
        v15 = 1639;
        goto LABEL_13;
      case 'g':
        v15 = 1647;
        goto LABEL_13;
      case 'h':
        v15 = 1623;
        goto LABEL_13;
      case 'i':
        v15 = 1631;
        goto LABEL_13;
      default:
        if ((_DWORD)a5 == 3)
        {
          v15 = 1599;
LABEL_13:
          ++*(_QWORD *)&a1[v15];
        }
        else
        {
          v16 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)a1 + 4), v13);
          v17 = _NRLogIsLevelEnabled(v16, 17);

          if (v17)
          {
            v19 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)a1 + 4), v18);
            v20 = objc_msgSend(a1, "copyDescription");
            StringFromNRTLVType = (void *)createStringFromNRTLVType(a5, v21);
            _NRLogWithArgs(v19, 17, "%@: Invalid type %@", v20, StringFromNRTLVType);

          }
        }
        sub_100090B74((uint64_t)a1, v14);

        break;
    }
  }
  free(v11);
}

void sub_100091008(void *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;
  int v4;
  void *v5;
  int IsLevelEnabled;
  uint64_t v7;
  void *StringFromNRTLVType;
  id v9;
  int *v10;
  void *v11;
  int v12;
  uint64_t v13;
  id v14;
  void *v15;
  int v16;
  uint64_t v17;
  int *v18;
  const char *v19;
  int *v20;
  int *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t next_slot;
  uint64_t v25;
  uint64_t v26;
  uint64_t packet;
  uint64_t next_buflet;
  uint64_t object_address;
  unsigned int data_offset;
  unsigned int data_length;
  unsigned int v32;
  uint64_t v33;
  void *v34;
  int v35;
  void *v36;
  id v37;
  uint64_t v38;
  void *v39;
  int v40;
  void *v41;
  id v42;
  unsigned int v43;
  size_t v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  unsigned __int16 v48;
  unsigned int v49;
  void *v50;
  int v51;
  void *v52;
  id v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  _BOOL4 v61;
  unint64_t v62;
  char v63;
  int *v64;
  _QWORD *v65;
  int v66;
  unsigned int v67;
  int v68;
  unsigned int v69;
  unsigned int v70;
  unint64_t v71;
  _DWORD *v72;
  uint64_t v73;
  BOOL v74;
  unsigned int v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unsigned int v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  unsigned int v84;
  uint64_t v85;
  int v86;
  _QWORD *v87;
  _QWORD *v88;
  uint64_t v89;
  int v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  char v94;
  int *v95;
  unsigned int v96;
  int v97;
  unsigned int v98;
  unsigned __int8 *v99;
  unsigned int v100;
  unsigned int v101;
  unsigned int v102;
  unsigned int v103;
  unint64_t v104;
  uint64_t v105;
  uint64_t v106;
  __int128 *v107;
  int v108;
  const char *v109;
  char *v110;
  _BOOL4 v111;
  char v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  unsigned int v117;
  unsigned int v118;
  unsigned int v119;
  int v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  unsigned int v124;
  int v125;
  unsigned int v126;
  unsigned __int8 *v127;
  unsigned int v128;
  unsigned int v129;
  unsigned int v130;
  unint64_t v131;
  uint64_t v132;
  __int128 *v133;
  int v134;
  uint64_t v135;
  _QWORD *v136;
  _BOOL4 v137;
  uint64_t v138;
  BOOL v139;
  uint64_t v140;
  uint64_t v141;
  unsigned int v142;
  int v143;
  int v144;
  uint64_t v145;
  uint64_t v146;
  unsigned int v147;
  unsigned int v148;
  unsigned int v149;
  size_t v150;
  uint64_t v151;
  unsigned int v152;
  int v153;
  uint64_t v154;
  unsigned int v155;
  unsigned int *v156;
  unsigned int v157;
  uint64_t v158;
  unsigned __int8 *v159;
  unsigned __int8 *v160;
  uint64_t v161;
  int v162;
  int v163;
  __int128 *v164;
  unsigned int v165;
  unsigned __int8 **v166;
  unsigned __int8 *v167;
  uint64_t v168;
  uint64_t v169;
  int *v170;
  void *v171;
  int v172;
  void *v173;
  id v174;
  unsigned int v175;
  unsigned int v176;
  unsigned int v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  unsigned int *v181;
  uint64_t v182;
  size_t v183;
  unsigned int v184;
  void *v185;
  int v186;
  uint64_t v187;
  void *v188;
  id v189;
  char *v190;
  char *v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  unsigned int v195;
  unsigned int v196;
  unsigned int v197;
  size_t v198;
  uint64_t v199;
  uint64_t v200;
  unsigned int v201;
  uint64_t ESPSequenceNumberFromPacket;
  uint64_t v203;
  _QWORD *v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  unsigned int v208;
  unsigned int ESPSPIFromPacket;
  NSObject *v210;
  void *v211;
  int v212;
  void *v213;
  id v214;
  uint64_t v215;
  void *v216;
  uint64_t v217;
  _QWORD *v218;
  void *v219;
  int v220;
  unsigned __int8 *v221;
  unsigned __int8 *v222;
  uint64_t v223;
  uint64_t v224;
  unsigned int v225;
  unsigned int v226;
  unsigned int v227;
  size_t v228;
  id v229;
  id v230;
  NSObject *v231;
  void *v232;
  int v233;
  uint64_t v234;
  void *v235;
  id v236;
  void *v237;
  int v238;
  void *v239;
  id v240;
  uint64_t v241;
  void *v242;
  int v243;
  uint64_t v244;
  void *v245;
  id v246;
  void *v247;
  int v248;
  uint64_t v249;
  void *v250;
  id v251;
  void *v252;
  int v253;
  uint64_t v254;
  void *v255;
  id v256;
  void *v257;
  int v258;
  void *v259;
  id v260;
  char v261;
  unsigned int v262;
  unsigned int v263;
  uint64_t v264;
  int v265;
  void *v266;
  int v267;
  uint64_t v268;
  void *v269;
  id v270;
  uint64_t v271;
  unint64_t v272;
  void *v273;
  int v274;
  void *v275;
  id v276;
  uint64_t v277;
  _QWORD *v278;
  void *v279;
  int v280;
  void *v281;
  id v282;
  unsigned __int16 v283;
  _QWORD *v284;
  unsigned int v285;
  __int16 v286;
  unint64_t v287;
  unsigned int *v288;
  unsigned int v289;
  void *v290;
  int v291;
  uint64_t v292;
  void *v293;
  id v294;
  void *v295;
  int v296;
  void *v297;
  id v298;
  uint64_t v299;
  void *v300;
  void *v301;
  int v302;
  uint64_t v303;
  void *v304;
  id v305;
  uint64_t v306;
  void *v307;
  void *v308;
  int v309;
  void *v310;
  id v311;
  void *v312;
  int v313;
  void *v314;
  id v315;
  void *v316;
  int v317;
  uint64_t v318;
  void *v319;
  id v320;
  __int16 v321;
  unint64_t v322;
  unsigned __int16 v323;
  unsigned __int16 v324;
  void *v325;
  int v326;
  unsigned __int16 v327;
  uint64_t v328;
  unsigned __int16 v329;
  unsigned __int16 v330;
  void *v331;
  id v332;
  uint64_t v333;
  void *v334;
  void *v335;
  int v336;
  void *v337;
  int v338;
  uint64_t v339;
  void *v340;
  id v341;
  void *v342;
  int v343;
  uint64_t v344;
  void *v345;
  id v346;
  void *v347;
  int v348;
  uint64_t v349;
  void *v350;
  id v351;
  void *v352;
  int v353;
  uint64_t v354;
  void *v355;
  id v356;
  uint64_t v357;
  uint64_t v358;
  uint64_t v359;
  uint64_t v360;
  uint64_t v361;
  uint64_t v362;
  uint64_t v363;
  uint64_t v364;
  uint64_t v365;
  uint64_t v366;
  uint64_t v367;
  uint64_t v368;
  id v369;
  int v370;
  const char *v371;
  id v372;
  uint64_t v373;
  char *v374;
  uint64_t v375;
  uint64_t v376;
  uint64_t v377;
  uint64_t v378;
  uint64_t v379;
  uint64_t v380;
  uint64_t v381;
  uint64_t v382;
  uint64_t v383;
  uint64_t v384;
  uint64_t v385;
  uint64_t v386;
  uint64_t v387;
  const char *v388;
  id v389;
  uint64_t v390;
  uint64_t v391;
  uint64_t v392;
  uint64_t v393;
  uint64_t v394;
  uint64_t v395;
  unint64_t v396;
  id v397;
  char v398;
  unsigned __int16 v399;
  id v400;
  void *v401;
  int v402;
  id v403;
  int v404;
  id v405;
  uint64_t v406;
  char *v407;
  int *v408;
  uint64_t v409;
  id v410;
  id v411;
  id v412;
  int v413;
  id v414;
  uint64_t v415;
  uint64_t v416;
  id v417;
  int v418;
  id v419;
  void *v420;
  uint64_t v421;
  uint64_t v422;
  uint64_t v423;
  id v424;
  char v425;
  id v426;
  uint64_t v427;
  char *v428;
  int *v429;
  uint64_t v430;
  id v431;
  id v432;
  int v433;
  id v434;
  uint64_t v435;
  int *v436;
  id v437;
  int v438;
  id v439;
  uint64_t v440;
  int *v441;
  id v442;
  int v443;
  id v444;
  void *v445;
  uint64_t v446;
  int *v447;
  uint64_t v448;
  id v449;
  id v450;
  int v451;
  id v452;
  uint64_t v453;
  uint64_t v454;
  id v455;
  int v456;
  id v457;
  uint64_t v458;
  int *v459;
  uint64_t v460;
  id v461;
  int v462;
  id v463;
  id v464;
  int v465;
  id v466;
  void *v467;
  uint64_t v468;
  uint64_t v469;
  id v470;
  int v471;
  id v472;
  void *v473;
  uint64_t v474;
  uint64_t v475;
  uint64_t v476;
  uint64_t v477;
  uint64_t v478;
  id v479;
  int v480;
  id v481;
  id v482;
  int v483;
  id v484;
  void *v485;
  uint64_t v486;
  int *v487;
  uint64_t v488;
  void *v489;
  id v490;
  int v491;
  id v492;
  void *v493;
  uint64_t v494;
  int *v495;
  id v496;
  int v497;
  id v498;
  void *v499;
  uint64_t v500;
  int *v501;
  id v502;
  id v503;
  int v504;
  _BYTE *v505;
  uint64_t v506;
  void *v507;
  char v508;
  uint64_t v509;
  unsigned __int16 v510;
  void *v511;
  id v512;
  uint64_t v513;
  void *v514;
  uint64_t v515;
  uint64_t v516;
  unsigned __int16 v517;
  void *v518;
  void *v519;
  uint64_t v520;
  uint64_t v521;
  uint64_t v522;
  uint64_t v523;
  uint64_t v524;
  uint64_t v525;
  id v526;
  int v527;
  id v528;
  uint64_t v529;
  uint64_t v530;
  id v531;
  int v532;
  id v533;
  uint64_t v534;
  uint64_t v535;
  uint64_t v536;
  unint64_t v537;
  id v538;
  int v539;
  id v540;
  void *v541;
  uint64_t v542;
  int *v543;
  uint64_t v544;
  uint64_t v545;
  id v546;
  int v547;
  id v548;
  uint64_t v549;
  int *v550;
  id v551;
  int v552;
  id v553;
  void *v554;
  uint64_t v555;
  uint64_t v556;
  uint64_t v557;
  id v558;
  int v559;
  id v560;
  void *v561;
  uint64_t v562;
  uint64_t v563;
  id v564;
  int v565;
  id v566;
  id v567;
  int v568;
  id v569;
  void *v570;
  id v571;
  int v572;
  id v573;
  void *v574;
  uint64_t v575;
  int *v576;
  id v577;
  int v578;
  id v579;
  uint64_t v580;
  int *v581;
  id v582;
  int v583;
  id v584;
  uint64_t v585;
  int *v586;
  uint64_t v587;
  id v588;
  int v589;
  id v590;
  void *v591;
  uint64_t v592;
  int *v593;
  uint64_t v594;
  id v595;
  id v596;
  int v597;
  id v598;
  void *v599;
  uint64_t v600;
  uint64_t v601;
  uint64_t v602;
  uint64_t v603;
  _BYTE *v604;
  char *v605;
  uint64_t v606;
  uint64_t v607;
  char *v608;
  _QWORD *v609;
  uint64_t v610;
  uint64_t v611;
  unsigned int v612;
  uint64_t v613;
  uint64_t v614;
  unsigned int v615;
  char *v616;
  uint64_t *v617;
  const char *v618;
  _QWORD *v619;
  unint64_t v620;
  size_t v621;
  uint64_t v622;
  unint64_t v623;
  uint64_t v624;
  uint64_t v625;
  uint64_t v626;
  __int128 v627;
  __int128 v628;
  __int128 v629;
  __int128 v630;
  _QWORD v631[2];
  __int128 v632;
  __int128 v633;
  __int128 v634;
  __int128 v635;
  void **v636;
  uint64_t v637;
  void (*v638)(uint64_t);
  void *v639;
  unint64_t v640;
  char v641;
  _BYTE v642[7];
  __int128 v643;
  __int128 v644;
  __int128 v645;
  __int128 v646;
  __int128 v647;
  __int128 v648;
  __int128 v649;
  __int128 v650;
  __int128 v651;
  __int128 v652;
  __int128 v653;
  __int128 v654;
  __int128 v655;
  __int128 v656;
  __int128 v657;
  __int128 v658;

  v1 = a1;
  v3 = (uint64_t)v1;
  v4 = *((unsigned __int8 *)v1 + 16);
  if (v4 == 255)
  {
    v5 = (void *)_NRCopyLogObjectForNRUUID(v1[4], v2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v5, 16);

    if (!IsLevelEnabled)
      goto LABEL_450;
    StringFromNRTLVType = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v7);
    v9 = objc_msgSend((id)v3, "copyDescription");
    _NRLogWithArgs(StringFromNRTLVType, 16, "%s%.30s:%-4d %@: LinkToNexusLoop but cancelled", "", "NRLinkLinkToNexusLoop", 5094, v9);
    goto LABEL_448;
  }
  v10 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
  if (!*(_QWORD *)((char *)v1 + 967))
  {
    v15 = (void *)_NRCopyLogObjectForNRUUID(v1[4], v2);
    v16 = _NRLogIsLevelEnabled(v15, 17);

    if (!v16)
      goto LABEL_450;
    StringFromNRTLVType = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v17);
    v14 = objc_msgSend((id)v3, "copyDescription");
    _NRLogWithArgs(StringFromNRTLVType, 17, "%@: Tried to linkToNexusLoop but _linkInputRing is NULL", v14);
    goto LABEL_10;
  }
  if ((v4 - 1) < 2)
  {
    v11 = (void *)_NRCopyLogObjectForNRUUID(v1[4], v2);
    v12 = _NRLogIsLevelEnabled(v11, 17);

    if (!v12)
      goto LABEL_450;
    StringFromNRTLVType = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v13);
    v14 = objc_msgSend((id)v3, "copyDescription");
    _NRLogWithArgs(StringFromNRTLVType, 17, "%@: Tried to linkToNexusLoop but bad state", v14);
LABEL_10:

    goto LABEL_449;
  }
  v606 = 0;
  v607 = 0;
  v604 = v642;
  v605 = (char *)&v644 + 8;
  v608 = (char *)&v643 + 8;
  v18 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
  v19 = "";
  v20 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
  v21 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
  v616 = (char *)v1;
LABEL_15:
  v22 = 0;
  LODWORD(v626) = 0;
  v625 = 0;
  v611 = 0;
  v613 = 0;
  v619 = 0;
  v634 = 0u;
  v635 = 0u;
  v632 = 0u;
  v633 = 0u;
  v631[0] = 0;
  v631[1] = 0;
  LODWORD(v618) = *(_BYTE *)(v3 + v18[312]) != 0;
  while (1)
  {
LABEL_16:
    v624 = 1871;
    *(_QWORD *)(v3 + 1871) = 4;
    if ((_WORD)v22 && (unsigned __int16)v22 >= (unsigned __int16)v626)
    {
      if ((unsigned __int16)v22 != (unsigned __int16)v626)
        goto LABEL_483;
      v23 = v624;
      *(_QWORD *)(v3 + v624) = 12;
    }
    else
    {
      v23 = v624;
      if ((_WORD)v22)
      {
        *(_QWORD *)(v3 + v624) = 36;
        if (!v619)
          goto LABEL_378;
        goto LABEL_28;
      }
    }
    next_slot = os_channel_get_next_slot(*(_QWORD *)(v3 + v10[72]), v613, &v632);
    *(_QWORD *)(v3 + v23) |= 0x10uLL;
    if (!next_slot)
    {
LABEL_378:
      v261 = (char)v618;
      if (*(_BYTE *)(v3 + 221) && *(_QWORD *)(v3 + 983))
      {
        *(_BYTE *)(v3 + 221) = 0;
        ++*(_QWORD *)(v3 + 999);
        if (gNRPacketLoggingEnabled)
        {
          v337 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
          v338 = _NRLogIsLevelEnabled(v337, 1);

          if (v338)
          {
            v340 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v339);
            v341 = objc_msgSend((id)v3, "copyDescription");
            _NRLogWithArgs(v340, 1, "%s%.30s:%-4d %@: source-resume: LinkInput", "", "NRLinkResumeLinkInputSource", 822, v341);

          }
        }
        dispatch_resume(*(dispatch_object_t *)(v3 + 983));
      }
      if (!*(_BYTE *)(v3 + 213) && *(_QWORD *)(v3 + 399))
      {
        *(_BYTE *)(v3 + 213) = 1;
        ++*(_QWORD *)(v3 + 423);
        if (gNRPacketLoggingEnabled)
        {
          v347 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
          v348 = _NRLogIsLevelEnabled(v347, 1);

          if (v348)
          {
            v350 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v349);
            v351 = objc_msgSend((id)v3, "copyDescription");
            _NRLogWithArgs(v350, 1, "%s%.30s:%-4d %@: source-suspend: NexusOutput", "", "NRLinkSuspendNexusOutputSource", 833, v351);

          }
        }
        dispatch_suspend(*(dispatch_object_t *)(v3 + 399));
      }
      *(_QWORD *)(v3 + v624) |= 0x40uLL;
      goto LABEL_363;
    }
    v25 = next_slot;
    v26 = *(_QWORD *)(v3 + v10[72]);
    v619 = (_QWORD *)v25;
    packet = os_channel_slot_get_packet(v26, v25);
    next_buflet = os_packet_get_next_buflet(packet, 0);
    object_address = os_buflet_get_object_address();
    data_offset = os_buflet_get_data_offset(next_buflet);
    data_length = os_buflet_get_data_length(next_buflet);
    if (data_length >= 0x10000)
    {
      v403 = sub_100070AC8();
      v404 = _NRLogIsLevelEnabled(v403, 16);

      if (v404)
      {
        v405 = sub_100070AC8();
        _NRLogWithArgs(v405, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: inputBufferLength <= 65535", "", "NRLinkLinkToNexusLoop", 5154);

      }
      goto LABEL_462;
    }
    LODWORD(v626) = data_length;
    v625 = object_address + data_offset;
    os_packet_get_flow_uuid(packet, v631);
    v20 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
    v22 = 0;
    if (*(_BYTE *)(v3 + 245))
    {
      *(_BYTE *)(v3 + 245) = 0;
      LODWORD(v618) = 1;
    }
    else
    {
      LODWORD(v618) = v618 | BYTE2(v631[0]);
    }
LABEL_28:
    if (!*(_BYTE *)(v3 + 221) && *(_QWORD *)(v3 + 983))
    {
      *(_BYTE *)(v3 + 221) = 1;
      ++*(_QWORD *)(v3 + 999);
      if (gNRPacketLoggingEnabled)
      {
        v232 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
        v233 = _NRLogIsLevelEnabled(v232, 1);

        if (v233)
        {
          v235 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v234);
          v236 = objc_msgSend((id)v3, "copyDescription");
          _NRLogWithArgs(v235, 1, "%s%.30s:%-4d %@: source-suspend: LinkInput", "", "NRLinkSuspendLinkInputSource", 814, v236);

        }
      }
      dispatch_suspend(*(dispatch_object_t *)(v3 + 983));
    }
    v32 = *(_DWORD *)(v3 + v20[137]);
    v33 = *(unsigned int *)(v3 + v21[138]);
    if (v32 <= v33)
      break;
    if (*(_BYTE *)(*(_QWORD *)(v3 + 1311) + v33))
    {
      v615 = *(unsigned __int8 *)(*(_QWORD *)(v3 + 1311) + v33);
      goto LABEL_46;
    }
    while (1)
    {
      v34 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
      v35 = _NRLogIsLevelEnabled(v34, 1);

      if (v35)
      {
        v36 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
        v37 = objc_msgSend((id)v3, "copyDescription");
        _NRLogWithArgs(v36, 1, "%s%.30s:%-4d %@: Handling Pad0 in linkReadBuffer", "", "NRLinkLinkToNexusLoop", 5203, v37);

      }
      ++*(_DWORD *)(v3 + v21[138]);
      v32 = *(_DWORD *)(v3 + v20[137]);
      v38 = *(unsigned int *)(v3 + v21[138]);
      if (v32 <= v38)
        break;
      if (*(_BYTE *)(*(_QWORD *)(v3 + 1311) + v38))
      {
        v615 = *(unsigned __int8 *)(*(_QWORD *)(v3 + 1311) + v38);
        v33 = v38;
        goto LABEL_46;
      }
    }
    if (v32 != (_DWORD)v38)
    {
      v531 = sub_100070AC8();
      v532 = _NRLogIsLevelEnabled(v531, 16);

      if (v532)
      {
        v533 = sub_100070AC8();
        _NRLogWithArgs(v533, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: self->_filledInLinkReadBufferBytes == self->_handledLinkReadBufferBytes", "", "NRLinkLinkToNexusLoop", 5207);

      }
      v534 = _os_log_pack_size(12);
      v374 = (char *)&v603 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
      v535 = *__error();
      v385 = _os_log_pack_fill(v374, v534, v535, &_mh_execute_header, "%{public}s Assertion Failed: self->_filledInLinkReadBufferBytes == self->_handledLinkReadBufferBytes");
      goto LABEL_470;
    }
    v50 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
    v51 = _NRLogIsLevelEnabled(v50, 1);

    if (v51)
    {
      v52 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
      v53 = objc_msgSend((id)v3, "copyDescription");
      _NRLogWithArgs(v52, 1, "%s%.30s:%-4d %@: Ended linkReadBuffer on a Pad0 handled=%u filledIn=%u", "", "NRLinkLinkToNexusLoop", 5209, v53, *(unsigned int *)(v3 + v21[138]), *(unsigned int *)(v3 + v20[137]));
      goto LABEL_311;
    }
  }
  while (!*(_BYTE *)(v625 + (unsigned __int16)v22))
  {
    v39 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
    v40 = _NRLogIsLevelEnabled(v39, 1);

    if (v40)
    {
      v41 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
      v42 = objc_msgSend((id)v3, "copyDescription");
      _NRLogWithArgs(v41, 1, "%s%.30s:%-4d %@: Handling Pad0 in linkInputSlot alreadyRead=%u", "", "NRLinkLinkToNexusLoop", 5227, v42, (unsigned __int16)v22);

    }
    v22 = (v22 + 1);
    if ((unsigned __int16)v22 >= (unsigned __int16)v626)
    {
      if ((unsigned __int16)v22 != (unsigned __int16)v626)
      {
        v461 = sub_100070AC8();
        v462 = _NRLogIsLevelEnabled(v461, 16);

        if (v462)
        {
          v463 = sub_100070AC8();
          _NRLogWithArgs(v463, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: curLinkInputSlotPartialBytesAlreadyRead == linkInputBufferLength", "", "NRLinkLinkToNexusLoop", 5231);

        }
LABEL_485:
        v415 = _os_log_pack_size(12);
        v374 = (char *)&v603 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
        v416 = *__error();
        v385 = _os_log_pack_fill(v374, v415, v416, &_mh_execute_header, "%{public}s Assertion Failed: curLinkInputSlotPartialBytesAlreadyRead == linkInputBufferLength");
LABEL_470:
        *(_DWORD *)v385 = 136446210;
        v388 = "NRLinkLinkToNexusLoop";
        goto LABEL_471;
      }
      v257 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
      v258 = _NRLogIsLevelEnabled(v257, 1);

      if (v258)
      {
        v259 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
        v260 = objc_msgSend((id)v3, "copyDescription");
        _NRLogWithArgs(v259, 1, "%s%.30s:%-4d %@: Ended linkInputSlot on a Pad0 handled=%u filledIn=%u", "", "NRLinkLinkToNexusLoop", 5233, v260, *(unsigned int *)(v3 + v21[138]), *(unsigned int *)(v3 + v20[137]));

      }
LABEL_362:
      v261 = (char)v618;
LABEL_363:
      if (v613)
      {
        v262 = *(_DWORD *)(v3 + v20[137]);
        v263 = *(_DWORD *)(v3 + v21[138]);
        if (v262 <= v263)
        {
          if (v263 != v262)
          {
            v526 = sub_100070AC8();
            v527 = _NRLogIsLevelEnabled(v526, 16);

            if (v527)
            {
              v528 = sub_100070AC8();
              _NRLogWithArgs(v528, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: self->_handledLinkReadBufferBytes == self->_filledInLinkReadBufferBytes", "", "NRLinkLinkToNexusLoop", 5752);

            }
            v529 = _os_log_pack_size(12);
            v374 = (char *)&v603 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
            v530 = *__error();
            v385 = _os_log_pack_fill(v374, v529, v530, &_mh_execute_header, "%{public}s Assertion Failed: self->_handledLinkReadBufferBytes == self->_filledInLinkReadBufferBytes");
            goto LABEL_470;
          }
          *(_QWORD *)(v3 + 1871) |= 0x400000000uLL;
          if (gNRPacketLoggingEnabled)
          {
            v312 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
            v313 = _NRLogIsLevelEnabled(v312, 1);

            if (v313)
            {
              v314 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
              v315 = objc_msgSend((id)v3, "copyDescription");
              _NRLogWithArgs(v314, 1, "%s%.30s:%-4d %@: resetting the linkReadBuffer (filledIn=%u)", "", "NRLinkLinkToNexusLoop", 5754, v315, *(unsigned int *)(v3 + v20[137]));

            }
          }
          *(_DWORD *)(v3 + v20[137]) = 0;
          *(_DWORD *)(v3 + v21[138]) = 0;
LABEL_371:
          v265 = gNRPacketLoggingEnabled;
          *(_QWORD *)(v3 + 1871) |= 0x800000000uLL;
          if (v265)
          {
            v266 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
            v267 = _NRLogIsLevelEnabled(v266, 1);

            if (v267)
            {
              v269 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v268);
              v270 = objc_msgSend((id)v3, "copyDescription");
              _NRLogWithArgs(v269, 1, "%s%.30s:%-4d %@: advancing past linkInputSlot=%p and syncing link input", "", "NRLinkLinkToNexusLoop", 5758, v270, v613);

            }
          }
        }
        else
        {
          if (v263 > *(_DWORD *)(v3 + 271))
          {
            *(_QWORD *)(v3 + 1871) |= 0x80000000uLL;
            if (gNRPacketLoggingEnabled)
            {
              v316 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
              v317 = _NRLogIsLevelEnabled(v316, 1);

              if (v317)
              {
                v319 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v318);
                v320 = objc_msgSend((id)v3, "copyDescription");
                _NRLogWithArgs(v319, 1, "%s%.30s:%-4d %@: memmoving the linkReadBuffer by handled=%u (filledIn=%u) thresh=%u", "", "NRLinkLinkToNexusLoop", 5734, v320, *(unsigned int *)(v3 + v21[138]), *(unsigned int *)(v3 + v20[137]), *(unsigned int *)(v3 + 271));

              }
            }
            v264 = *(unsigned int *)(v3 + v21[138]);
            memmove(*(void **)(v3 + 1311), (const void *)(*(_QWORD *)(v3 + 1311) + v264), (*(_DWORD *)(v3 + v20[137]) - v264));
            *(_DWORD *)(v3 + v20[137]) -= *(_DWORD *)(v3 + v21[138]);
            *(_DWORD *)(v3 + v21[138]) = 0;
            goto LABEL_371;
          }
          v271 = *(_QWORD *)(v3 + 1871);
          if (v263)
          {
            v272 = v271 | (unint64_t)&_mh_execute_header;
            *(_QWORD *)(v3 + 1871) = v271 | (unint64_t)&_mh_execute_header;
            if (gNRPacketLoggingEnabled)
            {
              v273 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
              v274 = _NRLogIsLevelEnabled(v273, 1);

              if (!v274)
                goto LABEL_371;
              v275 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
              v276 = objc_msgSend((id)v3, "copyDescription");
              _NRLogWithArgs(v275, 1, "%s%.30s:%-4d %@: not memmoving the linkReadBuffer thresh handled=%u filledIn=%u thresh=%u", "", "NRLinkLinkToNexusLoop", 5743, v276, *(unsigned int *)(v3 + v21[138]), *(unsigned int *)(v3 + v20[137]), *(unsigned int *)(v3 + 271));
LABEL_436:

              goto LABEL_371;
            }
          }
          else
          {
            v272 = v271 | 0x200000000;
            *(_QWORD *)(v3 + 1871) = v271 | 0x200000000;
            if (gNRPacketLoggingEnabled)
            {
              v335 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
              v336 = _NRLogIsLevelEnabled(v335, 1);

              if (!v336)
                goto LABEL_371;
              v275 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
              v276 = objc_msgSend((id)v3, "copyDescription");
              _NRLogWithArgs(v275, 1, "%s%.30s:%-4d %@: not memmoving the linkReadBuffer zero handled=%u filledIn=%u thresh=%u", "", "NRLinkLinkToNexusLoop", 5749, v276, *(unsigned int *)(v3 + v21[138]), *(unsigned int *)(v3 + v20[137]), *(unsigned int *)(v3 + 271));
              goto LABEL_436;
            }
          }
          *(_QWORD *)(v3 + 1871) = v272 | 0x800000000;
        }
        if (gNRPacketLoggingEnabled)
        {
          v299 = objc_claimAutoreleasedReturnValue(+[NSDate date](NSDate, "date"));
          v300 = *(void **)(v3 + 1679);
          *(_QWORD *)(v3 + 1679) = v299;

        }
        os_channel_advance_slot(*(_QWORD *)(v3 + 967), v613);
        os_channel_sync(*(_QWORD *)(v3 + 959), 1);
        ++*(_QWORD *)(v3 + 1423);
      }
      if (v611)
      {
        if (*(_QWORD *)(v3 + 383))
        {
          *(_QWORD *)(v3 + 1871) |= 0x1000000000uLL;
          if (gNRPacketLoggingEnabled)
          {
            v301 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
            v302 = _NRLogIsLevelEnabled(v301, 1);

            if (v302)
            {
              v304 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v303);
              v305 = objc_msgSend((id)v3, "copyDescription");
              _NRLogWithArgs(v304, 1, "%s%.30s:%-4d %@: advancing past nexusOutputSlot=%p and syncing nexus output", "", "NRLinkLinkToNexusLoop", 5769, v305, v611);

            }
            if (gNRPacketLoggingEnabled)
            {
              v306 = objc_claimAutoreleasedReturnValue(+[NSDate date](NSDate, "date"));
              v307 = *(void **)(v3 + 1671);
              *(_QWORD *)(v3 + 1671) = v306;

            }
          }
          os_channel_advance_slot(*(_QWORD *)(v3 + 383), v611);
          os_channel_sync(*(_QWORD *)(v3 + 367), 0);
          if (gNRPacketLoggingEnabled)
          {
            v308 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
            v309 = _NRLogIsLevelEnabled(v308, 1);

            if (v309)
            {
              v310 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
              v311 = objc_msgSend((id)v3, "copyDescription");
              _NRLogWithArgs(v310, 1, "%s%.30s:%-4d %@: Read %llu packets, %llu bytes", "", "NRLinkLinkToNexusLoop", 5773, v311, v606, v607);

            }
          }
          ++*(_QWORD *)(v3 + 479);
        }
        else
        {
          v295 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
          v296 = _NRLogIsLevelEnabled(v295, 17);

          if (v296)
          {
            v297 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
            v298 = objc_msgSend((id)v3, "copyDescription");
            _NRLogWithArgs(v297, 17, "%@: Tried to sync nexus output but _nexusOutputRing is NULL", v298);

          }
        }
      }
      if (*(_QWORD *)(v3 + 1871) && *(_QWORD *)(v3 + 1879))
      {
        *(_BYTE *)(v3 + 251) %= *(_BYTE *)(v3 + 250);
        v277 = *(_QWORD *)(v3 + 1879);
        v278 = (_QWORD *)(v277 + 8 * *(unsigned __int8 *)(v3 + 251));
        if ((unint64_t)(v278 + 1) <= v277 + 8 * (unint64_t)*(unsigned __int8 *)(v3 + 250))
        {
          if ((v278 & 7) == 0)
          {
            *v278 = *(_QWORD *)(v3 + 1871);
            ++*(_BYTE *)(v3 + 251);
            *(_QWORD *)(v3 + 1871) = 0;
          }
        }
        else
        {
          v279 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
          v280 = _NRLogIsLevelEnabled(v279, 17);

          if (v280)
          {
            v281 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
            v282 = objc_msgSend((id)v3, "copyDescription");
            _NRLogWithArgs(v281, 17, "%@: invalid index for link log list (curIdx: %u)", v282, *(unsigned __int8 *)(v3 + 251));

          }
        }
      }
      *(_BYTE *)(v3 + 220) = v261 & 1;
      v18 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
      v19 = "";
      v10 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
      if (!(v613 | v611))
        goto LABEL_450;
      goto LABEL_15;
    }
  }
  v615 = *(unsigned __int8 *)(v625 + (unsigned __int16)v22);
  v33 = *(unsigned int *)(v3 + v21[138]);
  v32 = *(_DWORD *)(v3 + v20[137]);
LABEL_46:
  v612 = v32;
  v610 = v33;
  if (v32 <= (int)v33 + 2)
  {
    if (v32 == (_DWORD)v33 + 2)
    {
      v45 = *(unsigned __int8 *)(*(_QWORD *)(v3 + 1311) + (v33 + 1));
      if ((unsigned __int16)v22 >= (unsigned __int16)v626)
      {
        v44 = 0;
        v46 = 0;
        v47 = 512;
      }
      else
      {
        v44 = *(unsigned __int8 *)(v625 + (unsigned __int16)v22);
        v46 = 1;
        v47 = 256;
      }
    }
    else
    {
      if (v32 == (_DWORD)v33 + 1)
        v48 = v22;
      else
        v48 = v22 + 1;
      if (v48 + 2 >= (unsigned __int16)v626)
      {
        v45 = 0;
        v44 = 0;
        v46 = 0;
        v47 = 2048;
      }
      else
      {
        v49 = bswap32(*(unsigned __int16 *)(v625 + v48));
        v44 = BYTE2(v49);
        v45 = HIBYTE(v49);
        v46 = 1;
        v47 = 1024;
      }
    }
    LODWORD(v33) = v610;
  }
  else
  {
    v43 = bswap32(*(unsigned __int16 *)(*(_QWORD *)(v3 + 1311) + (v33 + 1)));
    v44 = BYTE2(v43);
    v45 = HIBYTE(v43);
    v46 = 1;
    v47 = 128;
  }
  v54 = *(_QWORD *)(v3 + v624) | v47;
  *(_QWORD *)(v3 + v624) = v54;
  v657 = 0u;
  v658 = 0u;
  v655 = 0u;
  v656 = 0u;
  v653 = 0u;
  v654 = 0u;
  v651 = 0u;
  v652 = 0u;
  v649 = 0u;
  v650 = 0u;
  v647 = 0u;
  v648 = 0u;
  v645 = 0u;
  v646 = 0u;
  v643 = 0u;
  v644 = 0u;
  v55 = v612 - v33;
  if (v612 > v33)
  {
    v56 = v22;
    *(_QWORD *)&v643 = *(_QWORD *)(v3 + 1311) + v33;
    v57 = v44 | ((_DWORD)v45 << 8);
    if (v57 + 5 < v55)
      v55 = v57 + 5;
    if (!(_DWORD)v55)
    {
      v424 = sub_100070AC8();
      v425 = _NRLogIsLevelEnabled(v424, 16);

      if ((v425 & 1) != 0)
      {
        v426 = sub_100070AC8();
        _NRLogWithArgs(v426, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: lrbIOVecLen > 0; tlvLen=%u filledInLinkReadBufferBytes=%u handledLink"
          "ReadBufferBytes=%u",
          "",
          "NRLinkLinkToNexusLoop",
          5312,
          v57,
          *(_DWORD *)(v3 + v20[137]),
          *(_DWORD *)(v3 + v21[138]));

      }
      v427 = _os_log_pack_size(30);
      v428 = (char *)&v603 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
      v429 = __error();
      v430 = _os_log_pack_fill(v428, v427, *v429, &_mh_execute_header, "%{public}s Assertion Failed: lrbIOVecLen > 0; tlvLen=%u filledInLinkReadBufferBytes=%u handledLinkReadBufferBytes=%u");
      sub_10008C184(v430, (uint64_t)"NRLinkLinkToNexusLoop", v57, *(_DWORD *)(v3 + v20[137]), *(_DWORD *)(v3 + v21[138]));
      goto LABEL_492;
    }
    v58 = v55;
    DWORD2(v643) = v55;
    v54 |= 0x1000uLL;
    *(_QWORD *)(v3 + v624) = v54;
    v59 = 1;
    v22 = v56;
  }
  else
  {
    v58 = 0;
    v59 = 0;
  }
  v60 = (unsigned __int16)v626;
  v61 = (unsigned __int16)v22 < (unsigned __int16)v626;
  if ((unsigned __int16)v22 < (unsigned __int16)v626)
  {
    if (!v46 || (v44 | ((unint64_t)v45 << 8)) + 5 > v58)
    {
      *((_QWORD *)&v643 + 2 * v59) = v625 + (unsigned __int16)v22;
      if ((unsigned __int16)v626 == (unsigned __int16)v22)
      {
        v455 = sub_100070AC8();
        v456 = _NRLogIsLevelEnabled(v455, 16);

        if (v456)
        {
          v457 = sub_100070AC8();
          _NRLogWithArgs(v457, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: clisIOVecLen > 0; linkInputBufferLength=%u curLinkInputSlotPartialB"
            "ytesAlreadyRead=%u",
            "",
            "NRLinkLinkToNexusLoop",
            5326,
            v60,
            (unsigned __int16)v22);

        }
        v458 = _os_log_pack_size(24);
        v374 = (char *)&v603 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
        v459 = __error();
        v460 = _os_log_pack_fill(v374, v458, *v459, &_mh_execute_header, "%{public}s Assertion Failed: clisIOVecLen > 0; linkInputBufferLength=%u curLinkInputSlotPartialBytesAlreadyRead=%u");
        *(_DWORD *)v460 = 136446722;
        *(_QWORD *)(v460 + 4) = "NRLinkLinkToNexusLoop";
        *(_WORD *)(v460 + 12) = 1024;
        *(_DWORD *)(v460 + 14) = v60;
        *(_WORD *)(v460 + 18) = 1024;
        *(_DWORD *)(v460 + 20) = (unsigned __int16)v22;
        goto LABEL_472;
      }
      v62 = (unint64_t)(&v643 + v59);
      *(_DWORD *)(v62 + 8) = v60 - (unsigned __int16)v22;
      v58 = v58 + (_DWORD)v60 - (unsigned __int16)v22;
      *(_QWORD *)(v3 + v624) = v54 | 0x2000;
      v22 = (v59 + 1);
      if (v58 < 3)
        v63 = 1;
      else
        v63 = v46;
      if ((v63 & 1) != 0)
      {
        v64 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
        v65 = v619;
        if (!v46)
        {
          v621 = v44;
          v622 = v45;
          v623 = v58;
          *(_QWORD *)(v3 + v624) = v54 | 0xA000;
          v614 = v626;
          goto LABEL_82;
        }
LABEL_94:
        v71 = (v44 | ((unint64_t)v45 << 8)) + 5;
        if (v71 >= v58)
        {
          v54 = *(_QWORD *)(v3 + v624) | 0x8000;
          *(_QWORD *)(v3 + v624) = v54;
          v61 = 1;
          v59 = (v59 + 1);
          v22 = v626;
        }
        else
        {
          v72 = (_DWORD *)(v62 | 8);
          v73 = v3;
          v3 = (v58 - v71);
          v54 = *(_QWORD *)(v73 + v624) | 0x4000;
          *(_QWORD *)(v73 + v624) = v54;
          v74 = *v72 == (_DWORD)v3;
          *v72 -= v3;
          if (v74)
          {
            v536 = v59;
            v537 = v58;
            v538 = sub_100070AC8();
            v539 = _NRLogIsLevelEnabled(v538, 16);

            if (v539)
            {
              v540 = sub_100070AC8();
              v541 = (void *)createIOVecString(&v643, v22);
              _NRLogWithArgs(v540, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: ioVecs[iovecIndex - 1].len > 0; Shrunk ioVecs[%u] down by %u to"
                " 0 - %@ ioVecContentLen=%u alreadyRead=%u",
                "",
                "NRLinkLinkToNexusLoop",
                5350,
                v536,
                v3,
                v541,
                v537,
                v60);

            }
            v542 = _os_log_pack_size(46);
            v374 = (char *)&v603 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
            v543 = __error();
            v544 = _os_log_pack_fill(v374, v542, *v543, &_mh_execute_header, "%{public}s Assertion Failed: ioVecs[iovecIndex - 1].len > 0; Shrunk ioVecs[%u] down by %u to 0 - %@"
                     " ioVecContentLen=%u alreadyRead=%u");
            v545 = createIOVecString(&v643, v22);
            sub_10008C1B4(v544, (uint64_t)"NRLinkLinkToNexusLoop", v536, v3, v545, v537, v60);
            goto LABEL_472;
          }
          v61 = 1;
          v59 = (v59 + 1);
          v22 = (v626 - v3);
          v58 = (v44 | ((unint64_t)v45 << 8)) + 5;
          v3 = (uint64_t)v616;
        }
LABEL_98:
        v614 = v22;
        if (v615 - 100 >= 6 && v615 - 2 >= 4)
        {
          if (v615 == 1)
          {
            v75 = 255;
            goto LABEL_101;
          }
        }
        else
        {
          v75 = 2000;
LABEL_101:
          v76 = v44 | ((_DWORD)v45 << 8);
          if (v76 > v75)
          {
            StringFromNRTLVType = (void *)createStringFromNRTLVType(v615, v2);
            v9 = (id)createIOVecStringWithContents(&v643, v59);
            sub_100074F70((void *)v3, CFSTR("Received invalid TLV len %u for %@ (max=%u) %@"), v357, v358, v359, v360, v361, v362, v76);
            goto LABEL_448;
          }
        }
        v77 = v59;
        if ((v44 | ((unint64_t)v45 << 8)) + 5 > v58)
        {
          v621 = v44;
          v622 = v45;
          v623 = v58;
          v620 = v59;
          v66 = 1;
          goto LABEL_104;
        }
        v87 = v65;
LABEL_109:
        v88 = v65;
        v65 = v87;
        goto LABEL_185;
      }
      v64 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
      v65 = v619;
      if (DWORD2(v643) >= 3)
      {
        v67 = *(unsigned __int16 *)(v643 + 1);
        goto LABEL_92;
      }
      if (DWORD2(v643) == 2)
      {
        if (v612 <= v610)
          goto LABEL_551;
        v68 = *(unsigned __int8 *)(v643 + 1);
        v69 = *(unsigned __int8 *)v644;
        goto LABEL_93;
      }
      if (DWORD2(v643) == 1)
      {
        if (DWORD2(v644) < 2)
        {
          v596 = sub_100070AC8();
          v597 = _NRLogIsLevelEnabled(v596, 16);

          if (v597)
          {
            v598 = sub_100070AC8();
            v599 = (void *)createIOVecString(&v643, v22);
            _NRLogWithArgs(v598, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: numIOVecs > 2; %@",
              "",
              "nrReadTLVLenHBOFromIOVec",
              274,
              v599);

          }
          v600 = _os_log_pack_size(22);
          v374 = (char *)&v603 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
          v601 = *__error();
          v557 = _os_log_pack_fill(v374, v600, v601, &_mh_execute_header, "%{public}s Assertion Failed: numIOVecs > 2; %@");
        }
        else
        {
          if (v612 > v610)
          {
            v67 = *(unsigned __int16 *)v644;
LABEL_92:
            v68 = v67;
            v69 = v67 >> 8;
LABEL_93:
            v70 = bswap32(v68 | (v69 << 8));
            v44 = BYTE2(v70);
            v45 = HIBYTE(v70);
            goto LABEL_94;
          }
          v558 = sub_100070AC8();
          v559 = _NRLogIsLevelEnabled(v558, 16);

          if (v559)
          {
            v560 = sub_100070AC8();
            v561 = (void *)createIOVecString(&v643, v22);
            _NRLogWithArgs(v560, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: numIOVecs > 1; %@",
              "",
              "nrReadTLVLenHBOFromIOVec",
              271,
              v561);

          }
          v562 = _os_log_pack_size(22);
          v374 = (char *)&v603 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
          v563 = *__error();
          v557 = _os_log_pack_fill(v374, v562, v563, &_mh_execute_header, "%{public}s Assertion Failed: numIOVecs > 1; %@");
        }
      }
      else
      {
        v551 = sub_100070AC8();
        v552 = _NRLogIsLevelEnabled(v551, 16);

        if (v552)
        {
          v553 = sub_100070AC8();
          v554 = (void *)createIOVecString(&v643, v22);
          _NRLogWithArgs(v553, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: ioVecs[0].len == 1; %@",
            "",
            "nrReadTLVLenHBOFromIOVec",
            269,
            v554);

        }
        v555 = _os_log_pack_size(22);
        v374 = (char *)&v603 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
        v556 = *__error();
        v557 = _os_log_pack_fill(v374, v555, v556, &_mh_execute_header, "%{public}s Assertion Failed: ioVecs[0].len == 1; %@");
      }
      v476 = v557;
      v477 = v22;
LABEL_518:
      v478 = createIOVecString(&v643, v477);
      *(_DWORD *)v476 = 136446466;
      *(_QWORD *)(v476 + 4) = "nrReadTLVLenHBOFromIOVec";
LABEL_519:
      *(_WORD *)(v476 + 12) = 2112;
      *(_QWORD *)(v476 + 14) = v478;
      goto LABEL_472;
    }
LABEL_80:
    v61 = 0;
    v64 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
    v65 = v619;
    goto LABEL_98;
  }
  if (v46)
    goto LABEL_80;
  v621 = v44;
  v622 = v45;
  v623 = v58;
  v614 = v22;
  LODWORD(v22) = v59;
  v64 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
  v65 = v619;
LABEL_82:
  v66 = 0;
  v620 = v22;
  LODWORD(v59) = v22;
LABEL_104:
  v629 = 0uLL;
  v630 = 0uLL;
  v627 = 0uLL;
  v628 = 0uLL;
  v78 = os_channel_get_next_slot(*(_QWORD *)(v3 + v64[72]), v65, &v627);
  if (!v78)
  {
    v88 = v65;
    v20 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
    goto LABEL_184;
  }
  v79 = v59;
  v80 = v78;
  v81 = os_channel_slot_get_packet(*(_QWORD *)(v3 + v64[72]), v78);
  v82 = v3;
  v3 = os_packet_get_next_buflet(v81, 0);
  v83 = os_buflet_get_object_address();
  v84 = os_buflet_get_data_offset(v3);
  v85 = os_buflet_get_data_length(v3);
  if (WORD1(v85))
  {
LABEL_456:
    if (qword_1001E46D8 != -1)
      dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
    if (_NRLogIsLevelEnabled(qword_1001E46D0, 16))
    {
      if (qword_1001E46D8 != -1)
        dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
      _NRLogWithArgs(qword_1001E46D0, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: inputBufferLength <= 65535", "", "NRLinkLinkToNexusLoop", 5391);
    }
LABEL_462:
    v383 = _os_log_pack_size(12);
    v374 = (char *)&v603 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
    v384 = *__error();
    v385 = _os_log_pack_fill(v374, v383, v384, &_mh_execute_header, "%{public}s Assertion Failed: inputBufferLength <= 65535");
    goto LABEL_470;
  }
  v3 = v85;
  os_packet_get_flow_uuid(v81, v631);
  if (*(_BYTE *)(v82 + 245))
  {
    *(_BYTE *)(v82 + 245) = 0;
    LOBYTE(v86) = 1;
  }
  else
  {
    LOBYTE(v86) = (v618 | BYTE2(v631[0])) & 1;
  }
  v90 = v623;
  v89 = v624;
  v44 = v621;
  v45 = v622;
  v91 = v83 + v84;
  *((_QWORD *)&v643 + 2 * v620) = v91;
  if (!(_DWORD)v3)
  {
LABEL_463:
    if (qword_1001E46D8 != -1)
      dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
    if (_NRLogIsLevelEnabled(qword_1001E46D0, 16))
    {
      if (qword_1001E46D8 != -1)
        dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
      _NRLogWithArgs(qword_1001E46D0, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: lookAheadLinkInputBufferLength > 0", "", "NRLinkLinkToNexusLoop", 5403);
    }
    v386 = _os_log_pack_size(12);
    v374 = (char *)&v603 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
    v387 = *__error();
    v385 = _os_log_pack_fill(v374, v386, v387, &_mh_execute_header, "%{public}s Assertion Failed: lookAheadLinkInputBufferLength > 0");
    goto LABEL_470;
  }
  v92 = v620;
  *((_DWORD *)&v643 + 4 * v620 + 2) = v3;
  v93 = *(_QWORD *)&v616[v89] | 0x20000;
  *(_QWORD *)&v616[v89] = v93;
  v58 = (v3 + v90);
  v19 = (const char *)(v92 + 1);
  if (v58 < 3)
    v94 = 1;
  else
    v94 = v66;
  if ((v94 & 1) == 0)
  {
    v95 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
    v65 = v619;
    if (DWORD2(v643) > 2)
    {
      v96 = *(unsigned __int16 *)(v643 + 1);
LABEL_121:
      v97 = v96;
      v98 = v96 >> 8;
LABEL_135:
      v100 = v97 | (v98 << 8);
      v101 = bswap32(v100);
      v44 = BYTE2(v101);
      v45 = HIBYTE(v101);
      if (v615 - 100 >= 6 && v615 - 2 >= 4)
      {
        if (v615 != 1)
          goto LABEL_139;
        v102 = 255;
      }
      else
      {
        v102 = 2000;
      }
      v103 = __rev16(v100);
      if (v103 > v102)
      {
        v3 = (uint64_t)v616;
LABEL_447:
        StringFromNRTLVType = (void *)createStringFromNRTLVType(v615, v2);
        v9 = (id)createIOVecStringWithContents(&v643, (unsigned __int16)v19);
        sub_100074F70((void *)v3, CFSTR("LookAhead received invalid TLV len %u for %@ (max=%u) %@"), v363, v364, v365, v366, v367, v368, v103);
LABEL_448:

        goto LABEL_449;
      }
      goto LABEL_139;
    }
    if (DWORD2(v643) == 2)
    {
      if (!v79)
      {
LABEL_551:
        v546 = sub_100070AC8();
        v547 = _NRLogIsLevelEnabled(v546, 16);

        if (v547)
        {
          v548 = sub_100070AC8();
          _NRLogWithArgs(v548, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: numIOVecs > 1", "", "nrReadTLVLenHBOFromIOVec", 265);

        }
        v549 = _os_log_pack_size(12);
        v374 = (char *)&v603 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
        v550 = __error();
        v385 = _os_log_pack_fill(v374, v549, *v550, &_mh_execute_header, "%{public}s Assertion Failed: numIOVecs > 1");
        *(_DWORD *)v385 = 136446210;
        v388 = "nrReadTLVLenHBOFromIOVec";
        goto LABEL_471;
      }
      v99 = (unsigned __int8 *)v644;
      v97 = *(unsigned __int8 *)(v643 + 1);
      goto LABEL_134;
    }
    if (DWORD2(v643) == 1)
    {
      if (DWORD2(v644) > 1)
      {
        if (!v79)
        {
          v571 = sub_100070AC8();
          v572 = _NRLogIsLevelEnabled(v571, 16);

          if (v572)
          {
            v573 = sub_100070AC8();
            v574 = (void *)createIOVecString(&v643, v19);
            _NRLogWithArgs(v573, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: numIOVecs > 1; %@",
              "",
              "nrReadTLVLenHBOFromIOVec",
              271,
              v574);

          }
          v575 = _os_log_pack_size(22);
          v374 = (char *)&v603 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
          v576 = __error();
          v476 = _os_log_pack_fill(v374, v575, *v576, &_mh_execute_header, "%{public}s Assertion Failed: numIOVecs > 1; %@");
          v478 = createIOVecString(&v643, v19);
          *(_DWORD *)v476 = 136446466;
          *(_QWORD *)(v476 + 4) = "nrReadTLVLenHBOFromIOVec";
          goto LABEL_519;
        }
        v96 = *(unsigned __int16 *)v644;
        goto LABEL_121;
      }
      if (v79 < 2)
      {
LABEL_511:
        v464 = sub_100070AC8();
        v465 = _NRLogIsLevelEnabled(v464, 16);

        if (v465)
        {
          v466 = sub_100070AC8();
          v467 = (void *)createIOVecString(&v643, (unsigned __int16)v19);
          _NRLogWithArgs(v466, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: numIOVecs > 2; %@",
            "",
            "nrReadTLVLenHBOFromIOVec",
            274,
            v467);

        }
        v468 = _os_log_pack_size(22);
        v374 = (char *)&v603 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
        v469 = *__error();
        v423 = _os_log_pack_fill(v374, v468, v469, &_mh_execute_header, "%{public}s Assertion Failed: numIOVecs > 2; %@");
      }
      else
      {
        if (DWORD2(v644) == 1)
        {
          v99 = (unsigned __int8 *)v645;
          v97 = *(unsigned __int8 *)v644;
LABEL_134:
          v98 = *v99;
          goto LABEL_135;
        }
LABEL_514:
        v470 = sub_100070AC8();
        v471 = _NRLogIsLevelEnabled(v470, 16);

        if (v471)
        {
          v472 = sub_100070AC8();
          v473 = (void *)createIOVecString(&v643, (unsigned __int16)v19);
          _NRLogWithArgs(v472, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: ioVecs[1].len == 1; %@",
            "",
            "nrReadTLVLenHBOFromIOVec",
            275,
            v473);

        }
        v474 = _os_log_pack_size(22);
        v374 = (char *)&v603 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
        v475 = *__error();
        v423 = _os_log_pack_fill(v374, v474, v475, &_mh_execute_header, "%{public}s Assertion Failed: ioVecs[1].len == 1; %@");
      }
    }
    else
    {
LABEL_486:
      v417 = sub_100070AC8();
      v418 = _NRLogIsLevelEnabled(v417, 16);

      if (v418)
      {
        v419 = sub_100070AC8();
        v420 = (void *)createIOVecString(&v643, (unsigned __int16)v19);
        _NRLogWithArgs(v419, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: ioVecs[0].len == 1; %@",
          "",
          "nrReadTLVLenHBOFromIOVec",
          269,
          v420);

      }
      v421 = _os_log_pack_size(22);
      v374 = (char *)&v603 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
      v422 = *__error();
      v423 = _os_log_pack_fill(v374, v421, v422, &_mh_execute_header, "%{public}s Assertion Failed: ioVecs[0].len == 1; %@");
    }
    v476 = v423;
    v477 = (unsigned __int16)v19;
    goto LABEL_518;
  }
  v95 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
  v65 = v619;
  if (!v66)
  {
LABEL_141:
    v20 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
    v2 = (_QWORD *)v80;
    v54 = v93 | 0x80000;
    v3 = (uint64_t)v616;
    *(_QWORD *)&v616[v89] = v54;
    v609 = v65;
    goto LABEL_144;
  }
LABEL_139:
  v104 = (v44 | ((unint64_t)v45 << 8)) + 5;
  v93 = *(_QWORD *)&v616[v89];
  if (v104 > v58)
  {
    LOBYTE(v66) = 1;
    goto LABEL_141;
  }
  v54 = v93 | 0x40000;
  *(_QWORD *)&v616[v89] = v54;
  v105 = (v58 - v104);
  v106 = v92;
  v107 = &v643 + v92;
  v108 = *((_DWORD *)v107 + 2) - v105;
  *((_DWORD *)v107 + 2) = v108;
  if (!v108)
  {
    v396 = v58;
LABEL_476:
    v397 = sub_100070AC8();
    v398 = _NRLogIsLevelEnabled(v397, 16);

    v399 = v614;
    if ((v398 & 1) != 0)
    {
      v400 = sub_100070AC8();
      v401 = (void *)createIOVecString(&v643, (unsigned __int16)v19);
      v402 = v399;
      _NRLogWithArgs(v400, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: ioVecs[iovecIndex - 1].len > 0; Shrunk last ioVecs[%u] down by %u to 0 "
        "- %@ ioVecContentLen=%u alreadyRead=%u",
        "",
        "NRLinkLinkToNexusLoop",
        5440,
        v106,
        v105,
        v401,
        v396,
        v399);

    }
    else
    {
      v402 = (unsigned __int16)v614;
    }
    v406 = _os_log_pack_size(46);
    v407 = (char *)&v603 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
    v408 = __error();
    v409 = _os_log_pack_fill(v407, v406, *v408, &_mh_execute_header, "%{public}s Assertion Failed: ioVecs[iovecIndex - 1].len > 0; Shrunk last ioVecs[%u] down by %u to 0 - %@ io"
             "VecContentLen=%u alreadyRead=%u");
    v410 = (id)createIOVecString(&v643, (unsigned __int16)v19);
    sub_10008C1B4(v409, (uint64_t)"NRLinkLinkToNexusLoop", v106, v105, (uint64_t)v410, v396, v402);

    v411 = sub_100070AC8();
    _NRLogAbortWithPack(v411, v407);
LABEL_483:
    v412 = sub_100070AC8();
    v413 = _NRLogIsLevelEnabled(v412, 16);

    if (v413)
    {
      v414 = sub_100070AC8();
      _NRLogWithArgs(v414, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: curLinkInputSlotPartialBytesAlreadyRead == linkInputBufferLength", v19, "NRLinkLinkToNexusLoop", 5138);

    }
    goto LABEL_485;
  }
  v614 = (v3 - v105);
  v632 = v627;
  v633 = v628;
  LOBYTE(v66) = 1;
  v634 = v629;
  v635 = v630;
  v58 = (v44 | ((unint64_t)v45 << 8)) + 5;
  LODWORD(v626) = v3;
  v625 = v91;
  v2 = (_QWORD *)v80;
  v609 = (_QWORD *)v80;
  v3 = (uint64_t)v616;
  v20 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
  v65 = v619;
LABEL_144:
  v109 = (const char *)(v620 + 2);
  v110 = &v605[16 * v620];
  while (2)
  {
    v77 = (uint64_t)(v109 - 1);
    v111 = v86 != 0;
    if ((v66 & 1) != 0
      && ((unint64_t)(unsigned __int16)v45 << 8) + (unsigned __int16)v44 + 5 <= v58)
    {
      LODWORD(v618) = v86 != 0;
      v61 = 1;
      v87 = v609;
      goto LABEL_109;
    }
    v112 = v86;
    v621 = v44;
    v622 = v45;
    v623 = v58;
    v619 = v2;
    v620 = (unint64_t)(v109 - 1);
    v629 = 0u;
    v630 = 0u;
    v627 = 0u;
    v628 = 0u;
    v113 = os_channel_get_next_slot(*(_QWORD *)(v3 + v95[72]), v2, &v627);
    if (v113)
    {
      v617 = (uint64_t *)v113;
      v618 = v109;
      v114 = os_channel_slot_get_packet(*(_QWORD *)(v3 + v95[72]), v113);
      v115 = os_packet_get_next_buflet(v114, 0);
      v116 = os_buflet_get_object_address();
      v117 = os_buflet_get_data_offset(v115);
      v118 = os_buflet_get_data_length(v115);
      if (v118 >= 0x10000)
        goto LABEL_456;
      v119 = v118;
      os_packet_get_flow_uuid(v114, v631);
      if (*(_BYTE *)(v3 + 245))
      {
        *(_BYTE *)(v3 + 245) = 0;
        v86 = 1;
      }
      else
      {
        v86 = (v112 != 0) | BYTE2(v631[0]) & 1;
      }
      v45 = v622;
      v120 = v623;
      v44 = v621;
      v121 = v116 + v117;
      *((_QWORD *)v110 - 1) = v121;
      v122 = v624;
      if (!v119)
        goto LABEL_463;
      *(_DWORD *)v110 = v119;
      v3 = (uint64_t)v616;
      v123 = *(_QWORD *)&v616[v122];
      *(_QWORD *)&v616[v122] = v123 | 0x20000;
      v58 = v119 + v120;
      if (v66 & 1 | (v58 < 3))
      {
        v19 = v618;
        if ((v66 & 1) == 0)
        {
          v54 = v123 | 0xA0000;
          *(_QWORD *)(v3 + v122) = v54;
          v20 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
          if (v19 == (const char *)16)
            goto LABEL_474;
          LOBYTE(v66) = 0;
          goto LABEL_147;
        }
        goto LABEL_177;
      }
      v19 = v618;
      if (DWORD2(v643) >= 3)
      {
        v124 = *(unsigned __int16 *)(v643 + 1);
        goto LABEL_163;
      }
      if (DWORD2(v643) == 2)
      {
        v127 = (unsigned __int8 *)v644;
        v125 = *(unsigned __int8 *)(v643 + 1);
        goto LABEL_172;
      }
      if (DWORD2(v643) != 1)
        goto LABEL_486;
      if (DWORD2(v644) <= 1)
      {
        if (v620 <= 1)
          goto LABEL_511;
        if (DWORD2(v644) != 1)
          goto LABEL_514;
        v127 = (unsigned __int8 *)v645;
        v125 = *(unsigned __int8 *)v644;
LABEL_172:
        v126 = *v127;
      }
      else
      {
        v124 = *(unsigned __int16 *)v644;
LABEL_163:
        v125 = v124;
        v126 = v124 >> 8;
      }
      v128 = v125 | (v126 << 8);
      v129 = bswap32(v128);
      v44 = BYTE2(v129);
      v45 = HIBYTE(v129);
      if (v615 - 100 >= 6 && v615 - 2 >= 4)
      {
        if (v615 != 1)
          goto LABEL_177;
        v130 = 255;
      }
      else
      {
        v130 = 2000;
      }
      v103 = __rev16(v128);
      if (v103 > v130)
        goto LABEL_447;
LABEL_177:
      v131 = ((unint64_t)(unsigned __int16)v45 << 8) + (unsigned __int16)v44 + 5;
      v132 = *(_QWORD *)(v3 + v122);
      if (v131 > v58)
      {
        v54 = v132 | 0x80000;
        *(_QWORD *)(v3 + v122) = v54;
        if (v19 == (const char *)16)
        {
          v139 = v131 > v58;
          v131 = v58;
          v20 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
          if (v139)
            goto LABEL_473;
LABEL_194:
          v137 = v86 != 0;
          v621 = (unsigned __int16)(v44 | ((_WORD)v45 << 8));
          v77 = 16;
          if (v621 + 5 <= v131)
          {
            v135 = v44 | ((_DWORD)v45 << 8);
            v136 = v609;
            v65 = v609;
LABEL_196:
            v138 = v54 | 0x200000;
            v613 = (uint64_t)v136;
            goto LABEL_197;
          }
          LODWORD(v618) = v86 != 0;
          v88 = v619;
LABEL_407:
          v284 = v88;
          if (gNRPacketLoggingEnabled)
          {
            v321 = v77;
            v322 = v58;
            v323 = v44;
            v324 = v45;
            v325 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
            v326 = _NRLogIsLevelEnabled(v325, 1);

            LOWORD(v77) = v321;
            if (v326)
            {
              v327 = v324;
              v328 = *(_QWORD *)(v3 + 32);
              v623 = v322;
              v329 = v323;
              v330 = v327;
              v331 = (void *)_NRCopyLogObjectForNRUUID(v328, v2);
              v332 = objc_msgSend((id)v3, "copyDescription");
              v334 = (void *)createStringFromNRTLVType(v615, v333);
              _NRLogWithArgs(v331, 1, "%s%.30s:%-4d %@: LtN not enough input bytes from linkInputSlot %u to fit %@ tlvLen %u", "", "NRLinkLinkToNexusLoop", 5478, v332, v623, v334, v329 | (v330 << 8));

              LOWORD(v77) = v321;
            }
          }
          v21 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
          v285 = v612;
          v261 = (char)v618;
          if (*(_BYTE *)(v3 + 221) && *(_QWORD *)(v3 + 983))
          {
            v286 = v77;
            *(_BYTE *)(v3 + 221) = 0;
            ++*(_QWORD *)(v3 + 999);
            if (gNRPacketLoggingEnabled)
            {
              v342 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
              v343 = _NRLogIsLevelEnabled(v342, 1);

              if (v343)
              {
                v345 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v344);
                v346 = objc_msgSend((id)v3, "copyDescription");
                _NRLogWithArgs(v345, 1, "%s%.30s:%-4d %@: source-resume: LinkInput", "", "NRLinkResumeLinkInputSource", 822, v346);

              }
            }
            dispatch_resume(*(dispatch_object_t *)(v3 + 983));
            v285 = v612;
            LOWORD(v77) = v286;
          }
          if ((v285 > v610) < (unsigned __int16)v77)
          {
            v287 = (unsigned __int16)v77 - (unint64_t)(v285 > v610);
            v288 = (unsigned int *)&v608[16 * (v285 > v610)];
            do
            {
              if (gNRPacketLoggingEnabled)
              {
                v290 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
                v291 = _NRLogIsLevelEnabled(v290, 1);

                if (v291)
                {
                  v293 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v292);
                  v294 = objc_msgSend((id)v3, "copyDescription");
                  _NRLogWithArgs(v293, 1, "%s%.30s:%-4d %@: partial TLV - consolidating %u bytes from linkInputSlot buf %p to linkReadBuffer filledIn=%u handled=%u", "", "NRLinkLinkToNexusLoop", 5485, v294, *v288, *((_QWORD *)v288 - 1), *(unsigned int *)(v3 + v20[137]), *(unsigned int *)(v3 + 315));

                }
              }
              memcpy((void *)(*(_QWORD *)(v3 + 1311) + *(unsigned int *)(v3 + v20[137])), *((const void **)v288 - 1), *v288);
              v289 = *v288;
              v288 += 4;
              *(_DWORD *)(v3 + v20[137]) += v289;
              --v287;
            }
            while (v287);
          }
          *(_QWORD *)(v3 + v624) |= 0x100000uLL;
          v613 = (uint64_t)v284;
          goto LABEL_363;
        }
        LOBYTE(v66) = 1;
        v20 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
LABEL_147:
        v95 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
        v2 = v617;
      }
      else
      {
        v54 = v132 | 0x40000;
        *(_QWORD *)(v3 + v122) = v54;
        v105 = (v58 - v131);
        v133 = &v643 + (int)v19 - 1;
        v134 = *((_DWORD *)v133 + 2) - v105;
        *((_DWORD *)v133 + 2) = v134;
        if (!v134)
        {
          v396 = v58;
          v106 = ((_DWORD)v19 - 1);
          goto LABEL_476;
        }
        v614 = v119 - v105;
        v632 = v627;
        v633 = v628;
        v634 = v629;
        v635 = v630;
        if (v19 == (const char *)16)
        {
          v609 = v617;
          v625 = v121;
          LODWORD(v626) = v119;
          v58 = ((unint64_t)(unsigned __int16)v45 << 8) + (unsigned __int16)v44 + 5;
          v20 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
          goto LABEL_194;
        }
        LOBYTE(v66) = 1;
        v2 = v617;
        v609 = v617;
        v625 = v121;
        LODWORD(v626) = v119;
        v58 = ((unint64_t)(unsigned __int16)v45 << 8) + (unsigned __int16)v44 + 5;
        v20 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
        v95 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
      }
      v109 = v19 + 1;
      v110 += 16;
      v65 = v619;
      continue;
    }
    break;
  }
  LODWORD(v618) = v111;
  v61 = 1;
  v65 = v609;
  v88 = v619;
LABEL_184:
  v58 = v623;
  v54 = *(_QWORD *)(v3 + v624) | 0x10000;
  *(_QWORD *)(v3 + v624) = v54;
  v77 = v620;
  LODWORD(v44) = v621;
  LODWORD(v45) = v622;
  if ((v66 & 1) == 0)
    goto LABEL_407;
LABEL_185:
  v131 = v58;
  v135 = v44 | ((_DWORD)v45 << 8);
  v621 = (unsigned __int16)(v44 | ((_WORD)v45 << 8));
  if (v621 + 5 > v58)
    goto LABEL_407;
  if (v61)
  {
    v136 = v65;
    v137 = (int)v618;
    goto LABEL_196;
  }
  v138 = v54 | 0x400000;
  v137 = (int)v618;
LABEL_197:
  v622 = v135;
  v623 = v58;
  *(_QWORD *)(v3 + v624) = v138;
  *(_QWORD *)(v3 + 1375) += v131;
  LODWORD(v618) = v137;
  v619 = v65;
  v620 = v77;
  if ((char)v615 < 100)
  {
    if (!(_WORD)v77)
    {
      v437 = sub_100070AC8();
      v438 = _NRLogIsLevelEnabled(v437, 16);

      if (v438)
      {
        v439 = sub_100070AC8();
        _NRLogWithArgs(v439, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: numIOVecs > 0", "", "nrChecksumIOVecInner", 143);

      }
      v440 = _os_log_pack_size(12);
      v374 = (char *)&v603 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
      v441 = __error();
      v385 = _os_log_pack_fill(v374, v440, *v441, &_mh_execute_header, "%{public}s Assertion Failed: numIOVecs > 0");
      *(_DWORD *)v385 = 136446210;
      v388 = "nrChecksumIOVecInner";
      goto LABEL_471;
    }
    LODWORD(v609) = (unsigned __int16)v77;
    v617 = &v603;
    v151 = 0;
    v152 = 0;
    v153 = 0;
    v154 = 0;
    v155 = (unsigned __int16)v135 + 3;
    v3 = (unsigned __int16)v77;
    v156 = (unsigned int *)v608;
    while (1)
    {
      v157 = v155 - v152;
      if (v155 <= v152)
      {
        v158 = 0;
        goto LABEL_233;
      }
      if (*v156 >= v157)
        v158 = v157;
      else
        v158 = *v156;
      if (!(_DWORD)v158)
      {
        v369 = sub_100070AC8();
        v370 = _NRLogIsLevelEnabled(v369, 16);

        v371 = "nrChecksumUpdate";
        if (v370)
        {
          v372 = sub_100070AC8();
          _NRLogWithArgs(v372, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: dataLen > 0", "", "nrChecksumUpdate", 69);

        }
        v373 = _os_log_pack_size(12);
        v374 = (char *)&v603 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
        v375 = *__error();
        v376 = _os_log_pack_fill(v374, v373, v375, &_mh_execute_header, "%{public}s Assertion Failed: dataLen > 0");
        goto LABEL_454;
      }
      v159 = (unsigned __int8 *)*((_QWORD *)v156 - 1);
      if (v153)
      {
        LOWORD(v627) = 0;
        LOWORD(v627) = *v159 << 8;
        v154 = os_inet_checksum(&v627, 2, v154);
        if (v158 < 2)
          goto LABEL_221;
        v160 = v159 + 1;
        v161 = (v158 - 1);
      }
      else
      {
        v160 = (unsigned __int8 *)*((_QWORD *)v156 - 1);
        v161 = v158;
      }
      v154 = os_inet_checksum(v160, v161, v154);
LABEL_221:
      if ((v158 & 1) != 0)
        v153 ^= 1u;
      v152 += v158;
      if (v152 >= v155 && v158 < *v156)
        goto LABEL_233;
      ++v151;
      v156 += 4;
      if (v3 == v151)
      {
        LOWORD(v151) = v620;
LABEL_233:
        v19 = "";
        v3 = (uint64_t)v616;
        if (v152 == v155)
        {
          v162 = ~(_BYTE)v154;
          v163 = ((unsigned __int16)~(_WORD)v154 >> 8);
          v164 = &v643 + (unsigned __int16)v151;
          v165 = *((_DWORD *)v164 + 2);
          if (v165 < (int)v158 + 2)
          {
            if (v165 < (int)v158 + 1)
            {
              v482 = sub_100070AC8();
              v483 = _NRLogIsLevelEnabled(v482, 16);

              if (v483)
              {
                v484 = sub_100070AC8();
                v485 = (void *)createIOVecString(&v643, (unsigned __int16)v620);
                _NRLogWithArgs(v484, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: iovecs[iovecIndex].len >= bytesToCheckThisIOVec + 1; %@, iove"
                  "cIndex=%u bytesToCheckThisIOVec=%u",
                  "",
                  "nrChecksumIOVecInner",
                  189,
                  v485,
                  (unsigned __int16)v151,
                  v158);

              }
              v486 = _os_log_pack_size(34);
              v374 = (char *)&v603 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
              v487 = __error();
              v488 = _os_log_pack_fill(v374, v486, *v487, &_mh_execute_header, "%{public}s Assertion Failed: iovecs[iovecIndex].len >= bytesToCheckThisIOVec + 1; %@, iovecIndex="
                       "%u bytesToCheckThisIOVec=%u");
              v489 = (void *)createIOVecString(&v643, (unsigned __int16)v620);
            }
            else if ((unsigned __int16)v151 + 1 >= v609)
            {
              v490 = sub_100070AC8();
              v491 = _NRLogIsLevelEnabled(v490, 16);

              if (v491)
              {
                v492 = sub_100070AC8();
                v493 = (void *)createIOVecString(&v643, (unsigned __int16)v620);
                _NRLogWithArgs(v492, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: iovecIndex + 1 < numIOVecs; %@, iovecIndex=%u bytesToCheckThisIOVec=%u",
                  "",
                  "nrChecksumIOVecInner",
                  191,
                  v493,
                  (unsigned __int16)v151,
                  v158);

              }
              v494 = _os_log_pack_size(34);
              v374 = (char *)&v603 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
              v495 = __error();
              v488 = _os_log_pack_fill(v374, v494, *v495, &_mh_execute_header, "%{public}s Assertion Failed: iovecIndex + 1 < numIOVecs; %@, iovecIndex=%u bytesToCheckThisIOVec=%u");
              v489 = (void *)createIOVecString(&v643, (unsigned __int16)v620);
            }
            else
            {
              v166 = (unsigned __int8 **)(&v643 + (unsigned __int16)v151 + 1);
              if (*((_DWORD *)v166 + 2))
              {
                if (*(unsigned __int8 *)(*(_QWORD *)v164 + v158) == v162 && **v166 == v163)
                  goto LABEL_243;
                v503 = sub_100070AC8();
                v504 = _NRLogIsLevelEnabled(v503, 16);

                if (v504)
                {
                  v481 = sub_100070AC8();
                  _NRLogWithArgs(v481, 16, "%s%.30s:%-4d checksum failed disjoint IOVec received 0x%02x%02x != computed 0x%02x%02x", "");
LABEL_534:

                }
                goto LABEL_535;
              }
              v496 = sub_100070AC8();
              v497 = _NRLogIsLevelEnabled(v496, 16);

              if (v497)
              {
                v498 = sub_100070AC8();
                v499 = (void *)createIOVecString(&v643, (unsigned __int16)v620);
                _NRLogWithArgs(v498, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: iovecs[iovecIndex + 1].len >= 1; %@, iovecIndex=%u bytesToCheckThisIOVec=%u",
                  "",
                  "nrChecksumIOVecInner",
                  193,
                  v499,
                  (unsigned __int16)v151,
                  v158);

              }
              v500 = _os_log_pack_size(34);
              v374 = (char *)&v603 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
              v501 = __error();
              v488 = _os_log_pack_fill(v374, v500, *v501, &_mh_execute_header, "%{public}s Assertion Failed: iovecs[iovecIndex + 1].len >= 1; %@, iovecIndex=%u bytesToCheckThisIOVec=%u");
              v489 = (void *)createIOVecString(&v643, (unsigned __int16)v620);
            }
            v502 = v489;
            sub_1000435D0(v488, (uint64_t)"nrChecksumIOVecInner", (uint64_t)v502, (unsigned __int16)v151, v158);

            goto LABEL_472;
          }
          v167 = (unsigned __int8 *)(*(_QWORD *)v164 + v158);
          if (*v167 == v162 && v167[1] == v163)
            goto LABEL_243;
          v479 = sub_100070AC8();
          v480 = _NRLogIsLevelEnabled(v479, 16);

          if (v480)
          {
            v481 = sub_100070AC8();
            _NRLogWithArgs(v481, 16, "%s%.30s:%-4d checksum failed same IOVec received 0x%02x%02x != computed 0x%02x%02x", "");
            goto LABEL_534;
          }
LABEL_535:
          v505 = *(id *)(v3 + 1863);
          if (v505)
            v505[97] = 1;

          v507 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v506);
          v508 = _NRLogIsLevelEnabled(v507, 17);

          v510 = v622;
          if ((v508 & 1) != 0)
          {
            v511 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v509);
            v512 = objc_msgSend((id)v3, "copyDescription");
            v514 = (void *)createStringFromNRTLVType(v615, v513);
            v625 = v510;
            v515 = *(unsigned int *)(v3 + 311);
            v516 = *(unsigned int *)(v616 + 315);
            v517 = v620;
            v518 = (void *)createIOVecString(&v643, (unsigned __int16)v620);
            v626 = (unsigned __int16)v614;
            v602 = v516;
            v3 = (uint64_t)v616;
            _NRLogWithArgs(v511, 17, "%@: Invalid checksum detected in loop on read type %@ len %u filledIn=%u handled=%u in %@ ioVecContentLen=%u alreadyRead=%u curLinkInputSlot=%p", v512, v514, v510, v515, v602, v518, v623, (unsigned __int16)v614, v619);

          }
          else
          {
            v626 = (unsigned __int16)v614;
            v517 = v620;
          }
          StringFromNRTLVType = (void *)createStringFromNRTLVType(v615, v509);
          v519 = (void *)createIOVecString(&v643, v517);
          sub_100074F70((void *)v3, CFSTR("Invalid checksum detected in loop on read type %@ len %u filledIn=%u handled=%u in %@ ioVecContentLen=%u alreadyRead=%u curLinkInputSlot=%p"), v520, v521, v522, v523, v524, v525, (uint64_t)StringFromNRTLVType);

          goto LABEL_449;
        }
        v450 = sub_100070AC8();
        v451 = _NRLogIsLevelEnabled(v450, 16);

        v371 = "nrChecksumIOVecInner";
        if (v451)
        {
          v452 = sub_100070AC8();
          _NRLogWithArgs(v452, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: computedBytes == writtenLength", "", "nrChecksumIOVecInner", 164);

        }
        v453 = _os_log_pack_size(12);
        v374 = (char *)&v603 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
        v454 = *__error();
        v376 = _os_log_pack_fill(v374, v453, v454, &_mh_execute_header, "%{public}s Assertion Failed: computedBytes == writtenLength");
LABEL_454:
        *(_DWORD *)v376 = 136446210;
        *(_QWORD *)(v376 + 4) = v371;
        goto LABEL_472;
      }
    }
  }
  LOWORD(v627) = 0;
  if (!(_WORD)v77)
    goto LABEL_493;
  v140 = 0;
  v141 = 0;
  v142 = bswap32(v135);
  v143 = (v615 >> 4) ^ HIWORD(v142);
  v144 = (16 * v615) ^ HIBYTE(v142);
  v145 = (unsigned __int16)v135 + 3;
  v146 = 16 * (unsigned __int16)v77;
  v147 = (unsigned __int16)v135 + 3;
  while (1)
  {
    v148 = *(_DWORD *)((char *)&v643 + v140 + 8);
    if (!v147)
      goto LABEL_205;
    if (v147 <= v148)
      break;
    v147 -= v148;
LABEL_201:
    v140 += 16;
    if (v146 == v140)
      goto LABEL_228;
  }
  if (v147 >= v148)
  {
LABEL_209:
    v147 = 0;
    goto LABEL_201;
  }
LABEL_205:
  v149 = v148 - v147;
  if (v149 >= 2 - (int)v141)
    v150 = (2 - v141);
  else
    v150 = v149;
  memcpy((char *)&v627 + v141, (const void *)(*(_QWORD *)((char *)&v643 + v140) + v147), v150);
  v141 = (v150 + v141);
  if (v141 <= 1)
    goto LABEL_209;
LABEL_228:
  v3 = (uint64_t)v616;
  if ((_DWORD)v141 != 2)
  {
    v442 = sub_100070AC8();
    v443 = _NRLogIsLevelEnabled(v442, 16);

    if (v443)
    {
      v444 = sub_100070AC8();
      v445 = (void *)createIOVecString(&v643, (unsigned __int16)v620);
      _NRLogWithArgs(v444, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: bytesWritten == length; bytesWritten (%u) != length (%u), offset: %u, ioVec: %@",
        "",
        "nrWriteIOVecToBuffer",
        342,
        v141,
        2,
        v145,
        v445);

    }
    v446 = _os_log_pack_size(40);
    v374 = (char *)&v603 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
    v447 = __error();
    v448 = _os_log_pack_fill(v374, v446, *v447, &_mh_execute_header, "%{public}s Assertion Failed: bytesWritten == length; bytesWritten (%u) != length (%u), offset: %u, ioVec: %@");
    v449 = (id)createIOVecString(&v643, (unsigned __int16)v620);
    sub_100043594(v448, (uint64_t)"nrWriteIOVecToBuffer", v141, 2, v145, (uint64_t)v449);

    goto LABEL_472;
  }
  v19 = "";
  if ((unsigned __int16)v627 != (unsigned __int16)(v143 | (unsigned __int16)((_WORD)v144 << 8)))
    goto LABEL_535;
LABEL_243:
  v629 = 0u;
  v630 = 0u;
  v627 = 0u;
  v628 = 0u;
  v168 = os_channel_get_next_slot(*(_QWORD *)(v3 + 383), v611, &v627);
  v21 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
  v20 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
  v22 = v614;
  if (!v168)
  {
    v10 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
    v175 = v612;
    if (*(_BYTE *)(v3 + 213) && *(_QWORD *)(v3 + 399))
    {
      *(_BYTE *)(v3 + 213) = 0;
      ++*(_QWORD *)(v3 + 423);
      if (gNRPacketLoggingEnabled)
      {
        v247 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
        v248 = _NRLogIsLevelEnabled(v247, 1);

        if (v248)
        {
          v250 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v249);
          v251 = objc_msgSend((id)v3, "copyDescription");
          _NRLogWithArgs(v250, 1, "%s%.30s:%-4d %@: source-resume: NexusOutput", "", "NRLinkResumeNexusOutputSource", 843, v251);

        }
      }
      dispatch_resume(*(dispatch_object_t *)(v3 + 399));
      v175 = v612;
    }
    v176 = v610;
    v177 = v175 > v610;
    v178 = *(_QWORD *)(v3 + v624) | 0x800000;
    *(_QWORD *)(v3 + v624) = v178;
    if (v177 < (unsigned __int16)v620)
    {
      v179 = v175 > v176;
      v180 = (unsigned __int16)v620;
      v181 = (unsigned int *)&v608[16 * v179];
      do
      {
        if (gNRPacketLoggingEnabled)
        {
          v185 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
          v186 = _NRLogIsLevelEnabled(v185, 1);

          if (v186)
          {
            v188 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v187);
            v189 = objc_msgSend((id)v3, "copyDescription");
            _NRLogWithArgs(v188, 1, "%s%.30s:%-4d %@: no nexusOutputSlot - consolidating %u bytes from linkInputSlot ioVecs[%u].buf=%p to linkReadBuffer filledIn=%u handled=%u", "", "NRLinkLinkToNexusLoop", 5549, v189, *v181, v179, *((_QWORD *)v181 - 1), *(unsigned int *)(v3 + 311), *(unsigned int *)(v3 + 315));

          }
        }
        v182 = *(unsigned int *)(v3 + 311);
        v183 = *v181;
        if ((v183 + v182) >= *(_DWORD *)(v3 + 263))
        {
          *(_QWORD *)(v3 + v624) |= 0x1000000uLL;
          StringFromNRTLVType = (void *)createIOVecString(&v643, (unsigned __int16)v620);
          sub_100074F70((void *)v3, CFSTR("no nexusOutputSlot and linkReadBuffer is full %@ filledIn=%u handled=%u"), v377, v378, v379, v380, v381, v382, (uint64_t)StringFromNRTLVType);
          goto LABEL_449;
        }
        memcpy((void *)(*(_QWORD *)(v3 + 1311) + v182), *((const void **)v181 - 1), v183);
        v184 = *v181;
        v181 += 4;
        *(_DWORD *)(v3 + 311) += v184;
        ++v179;
      }
      while (v180 != v179);
      v178 = *(_QWORD *)(v3 + v624);
      v10 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
      v22 = v614;
      v175 = v612;
      v176 = v610;
    }
    if (v175 <= v176 || (unsigned __int16)v620 != 1)
    {
      *(_QWORD *)(v3 + v624) = v178 | 0x4000000;
      v613 = (uint64_t)v619;
      goto LABEL_16;
    }
    *(_QWORD *)(v3 + v624) = v178 | 0x2000000;
    if ((_WORD)v22 && (unsigned __int16)v626 > (unsigned __int16)v22)
    {
      v283 = v626 - v22;
      if (gNRPacketLoggingEnabled)
      {
        v352 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
        v353 = _NRLogIsLevelEnabled(v352, 1);

        if (v353)
        {
          v355 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v354);
          v356 = objc_msgSend((id)v3, "copyDescription");
          _NRLogWithArgs(v355, 1, "%s%.30s:%-4d %@: no nexusOutputSlot - tail consolidating %u bytes from linkInputSlot to linkReadBuffer filledIn=%u handled=%u and marking curLinkInputSlot=%p as completed", "", "NRLinkLinkToNexusLoop", 5583, v356, v283, *(unsigned int *)(v3 + 311), *(unsigned int *)(v3 + 315), v619);

        }
      }
      memcpy((void *)(*(_QWORD *)(v3 + 1311) + *(unsigned int *)(v3 + 311)), (const void *)(v625 + (unsigned __int16)v22), v283);
      *(_DWORD *)(v3 + 311) += v283;
      v613 = (uint64_t)v619;
    }
    goto LABEL_362;
  }
  v169 = v168;
  v10 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
  if (v612 > v610)
  {
    if (gNRPacketLoggingEnabled)
    {
      v237 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
      v238 = _NRLogIsLevelEnabled(v237, 1);

      v22 = v614;
      if (v238)
      {
        v239 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
        v240 = objc_msgSend((id)v3, "copyDescription");
        _NRLogWithArgs(v239, 1, "%s%.30s:%-4d %@: Advancing linkReadBuffer handled by %u handled=%u filledIn=%u", "", "NRLinkLinkToNexusLoop", 5605, v240, DWORD2(v643), *(unsigned int *)(v3 + 315), *(unsigned int *)(v3 + 311));

        v22 = v614;
      }
    }
    *(_DWORD *)(v3 + 315) += DWORD2(v643);
    v20 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
  }
  v170 = &OBJC_IVAR___NRLinkBluetooth__recvUncompressedIP;
  switch(v615)
  {
    case 1u:
      v171 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
      v172 = _NRLogIsLevelEnabled(v171, 1);

      if (v172)
      {
        v173 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
        v174 = objc_msgSend((id)v3, "copyDescription");
        _NRLogWithArgs(v173, 1, "%s%.30s:%-4d %@: Handling PadN %u", "", "NRLinkLinkToNexusLoop", 5634, v174, (unsigned __int16)v622);

      }
      goto LABEL_306;
    case 2u:
      goto LABEL_291;
    case 3u:
      v170 = &OBJC_IVAR___NRLinkBluetooth__recvEncapsulated6LoWPAN;
      goto LABEL_291;
    case 4u:
      if (!(_WORD)v622)
      {
        v230 = objc_alloc_init((Class)NSData);
LABEL_335:
        v10 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
        v22 = v614;
        if ((v618 & 1) != 0)
        {
          objc_msgSend(v230, "bytes");
          objc_msgSend(v230, "length");
          if (qword_1001E48A0 != -1)
            dispatch_once(&qword_1001E48A0, &stru_1001B7C10);
          v231 = (id)qword_1001E4898;
          v636 = _NSConcreteStackBlock;
          v637 = 3221225472;
          v638 = sub_10008C1F8;
          v639 = &unk_1001B85D0;
          v640 = 0;
          dispatch_async(v231, &v636);

        }
        *(_QWORD *)(v3 + v624) |= 0x20000000uLL;
        sub_10008C2A4(v3, v230);

        LODWORD(v618) = 0;
        goto LABEL_306;
      }
      v190 = (char *)malloc_type_malloc(v621, 0xA172743EuLL);
      if (!v190)
      {
        v564 = sub_100070AC8();
        v565 = _NRLogIsLevelEnabled(v564, 16);

        if (v565)
        {
          v566 = sub_100070AC8();
          _NRLogWithArgs(v566, 16, "%s%.30s:%-4d ABORTING: strict_malloc(%zu) failed", "", "strict_malloc", 79, v621);

        }
LABEL_575:
        v585 = _os_log_pack_size(22);
        v374 = (char *)&v603 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
        v586 = __error();
        v587 = _os_log_pack_fill(v374, v585, *v586, &_mh_execute_header, "%{public}s strict_malloc(%zu) failed");
        *(_DWORD *)v587 = 136446466;
        *(_QWORD *)(v587 + 4) = "strict_malloc";
        *(_WORD *)(v587 + 12) = 2048;
        *(_QWORD *)(v587 + 14) = v621;
        goto LABEL_472;
      }
      if (!(_WORD)v620)
        goto LABEL_493;
      v191 = v190;
      v192 = 0;
      v193 = 0;
      v194 = (unsigned __int16)v622;
      v3 = 16 * (unsigned __int16)v620;
      v195 = 3;
      while (1)
      {
        v196 = *(_DWORD *)((char *)&v643 + v192 + 8);
        if (!v195)
          break;
        if (v195 <= v196)
        {
          if (v195 >= v196)
          {
            v195 = 0;
            goto LABEL_271;
          }
          break;
        }
        v195 -= v196;
LABEL_271:
        v192 += 16;
        if (v3 == v192)
          goto LABEL_333;
      }
      v197 = v196 - v195;
      if (v197 >= (int)v194 - (int)v193)
        v198 = (v194 - v193);
      else
        v198 = v197;
      memcpy(&v191[v193], (const void *)(*(_QWORD *)((char *)&v643 + v192) + v195), v198);
      v193 = (v198 + v193);
      if (v193 < v194)
      {
        v195 = 0;
        v20 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
        goto LABEL_271;
      }
      v20 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
LABEL_333:
      v21 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
      if ((_DWORD)v193 == (_DWORD)v194)
      {
        v229 = objc_alloc((Class)NSData);
        v230 = objc_msgSend(v229, "initWithBytesNoCopy:length:freeWhenDone:", v191, v621, 1);
        v3 = (uint64_t)v616;
        goto LABEL_335;
      }
      v567 = sub_100070AC8();
      v568 = _NRLogIsLevelEnabled(v567, 16);

      if (v568)
      {
        v569 = sub_100070AC8();
        v570 = (void *)createIOVecString(&v643, (unsigned __int16)v620);
        _NRLogWithArgs(v569, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: bytesWritten == length; bytesWritten (%u) != length (%u), offset: %u, ioVec: %@",
          "",
          "nrWriteIOVecToBuffer",
          342,
          v193,
          v194,
          3,
          v570);

      }
LABEL_578:
      v592 = _os_log_pack_size(40);
      v428 = (char *)&v603 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
      v593 = __error();
      v594 = _os_log_pack_fill(v428, v592, *v593, &_mh_execute_header, "%{public}s Assertion Failed: bytesWritten == length; bytesWritten (%u) != length (%u), offset: %u, ioVec: %@");
      v595 = (id)createIOVecString(&v643, (unsigned __int16)v620);
      sub_100043594(v594, (uint64_t)"nrWriteIOVecToBuffer", v193, v194, 3, (uint64_t)v595);

LABEL_492:
      v431 = sub_100070AC8();
      _NRLogAbortWithPack(v431, v428);
LABEL_493:
      v432 = sub_100070AC8();
      v433 = _NRLogIsLevelEnabled(v432, 16);

      if (v433)
      {
        v434 = sub_100070AC8();
        _NRLogWithArgs(v434, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: numIOVecs > 0", "", "nrWriteIOVecToBuffer", 313);

      }
      v435 = _os_log_pack_size(12);
      v374 = (char *)&v603 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
      v436 = __error();
      v385 = _os_log_pack_fill(v374, v435, *v436, &_mh_execute_header, "%{public}s Assertion Failed: numIOVecs > 0");
      *(_DWORD *)v385 = 136446210;
      v388 = "nrWriteIOVecToBuffer";
LABEL_471:
      *(_QWORD *)(v385 + 4) = v388;
LABEL_472:
      v389 = sub_100070AC8();
      _NRLogAbortWithPack(v389, v374);
LABEL_473:
      v621 = v44;
      v622 = v45;
LABEL_474:
      StringFromNRTLVType = (void *)createIOVecStringWithContents(&v643, 16);
      sub_100074F70((void *)v3, CFSTR("LtN not enough ioVecs %@ for %u"), v390, v391, v392, v393, v394, v395, (uint64_t)StringFromNRTLVType);
LABEL_449:

LABEL_450:
      return;
    case 5u:
      if ((unsigned __int16)v620 == 1 && DWORD2(v643) >= 5 && !HIWORD(DWORD2(v643)))
      {
        sub_10008C5F8((void *)v3, (unsigned __int8 *)(v643 + 3), (unsigned __int16)(WORD4(v643) - 5));
        goto LABEL_306;
      }
      if (!v621)
      {
        v577 = sub_100070AC8();
        v578 = _NRLogIsLevelEnabled(v577, 16);

        if (v578)
        {
          v579 = sub_100070AC8();
          _NRLogWithArgs(v579, 16, "%s%.30s:%-4d ABORTING: strict_malloc called with size 0", "", "strict_malloc", 74);

        }
        v580 = _os_log_pack_size(12);
        v374 = (char *)&v603 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
        v581 = __error();
        v385 = _os_log_pack_fill(v374, v580, *v581, &_mh_execute_header, "%{public}s strict_malloc called with size 0");
        *(_DWORD *)v385 = 136446210;
        v388 = "strict_malloc";
        goto LABEL_471;
      }
      v221 = (unsigned __int8 *)malloc_type_malloc(v621, 0xA172743EuLL);
      if (!v221)
      {
        v582 = sub_100070AC8();
        v583 = _NRLogIsLevelEnabled(v582, 16);

        if (v583)
        {
          v584 = sub_100070AC8();
          _NRLogWithArgs(v584, 16, "%s%.30s:%-4d ABORTING: strict_malloc(%zu) failed", "", "strict_malloc", 79, v621);

        }
        goto LABEL_575;
      }
      v222 = v221;
      v194 = (unsigned __int16)v622;
      if (!(_WORD)v622)
      {

        goto LABEL_343;
      }
      if (!(_WORD)v620)
        goto LABEL_493;
      v223 = 0;
      v193 = 0;
      v224 = 16 * (unsigned __int16)v620;
      v225 = 3;
      break;
    case 0x64u:
      v170 = &OBJC_IVAR___NRLinkBluetooth__recvKnownIPv6Hdr_ESP;
      goto LABEL_291;
    case 0x65u:
      v170 = &OBJC_IVAR___NRLinkBluetooth__recvKnownIPv6Hdr_ESP_ECT0;
      goto LABEL_291;
    case 0x66u:
      v170 = &OBJC_IVAR___NRLinkBluetooth__recvKnownIPv6Hdr_TCP;
      goto LABEL_291;
    case 0x67u:
      v170 = &OBJC_IVAR___NRLinkBluetooth__recvKnownIPv6Hdr_TCP_ECT0;
      goto LABEL_291;
    case 0x68u:
      v170 = &OBJC_IVAR___NRLinkBluetooth__recvKnownIPv6Hdr_ESP_ClassC;
      goto LABEL_291;
    case 0x69u:
      v170 = &OBJC_IVAR___NRLinkBluetooth__recvKnownIPv6Hdr_ESP_ClassC_ECT0;
LABEL_291:
      ++*(_QWORD *)(v3 + *v170);
      v199 = nrTLVToPacket(&v643, (unsigned __int16)v620, v615, (unsigned __int16)v622, v628, WORD1(v627), v3 + 1967, v3 + 1951);
      if ((_DWORD)v199)
      {
        v201 = v199;
        *(_QWORD *)(v3 + v624) |= 0x8000000uLL;
        WORD1(v627) = v199;
        if (gNRPacketLoggingEnabled)
        {
          ESPSequenceNumberFromPacket = getESPSequenceNumberFromPacket(v628, v199);
          if (gNRPacketLoggingEnabled)
          {
            v242 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v241);
            v243 = _NRLogIsLevelEnabled(v242, 1);

            if (v243)
            {
              v245 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v244);
              v246 = objc_msgSend((id)v3, "copyDescription");
              _NRLogWithArgs(v245, 1, "%s%.30s:%-4d %@: Received ESP sequence number: %u", "", "NRLinkLinkToNexusLoop", 5661, v246, ESPSequenceNumberFromPacket);

            }
            v21 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
            v20 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
          }
        }
        else
        {
          ESPSequenceNumberFromPacket = 0;
        }
        v203 = os_channel_slot_get_packet(*(_QWORD *)(v3 + 383), v169);
        if ((v618 & 1) != 0)
        {
          v204 = v604;
          *(_QWORD *)(v604 + 7) = 0;
          *v204 = 0;
          v641 = 1;
          if (v203)
          {
            os_packet_set_flow_uuid(v203, &v641);
            *(_QWORD *)(v3 + v624) |= 0x10000000uLL;
            if (gNRPacketLoggingEnabled)
            {
              v252 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v205);
              v253 = _NRLogIsLevelEnabled(v252, 1);

              if (v253)
              {
                v255 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v254);
                v256 = objc_msgSend((id)v3, "copyDescription");
                _NRLogWithArgs(v255, 1, "%s%.30s:%-4d %@: Set waking metadata for packet w/ ESP sequence number: %u", "", "NRLinkLinkToNexusLoop", 5669, v256, ESPSequenceNumberFromPacket);

              }
            }
          }
          v206 = v628;
          v207 = WORD1(v627);
          v208 = getESPSequenceNumberFromPacket(v628, WORD1(v627));
          ESPSPIFromPacket = getESPSPIFromPacket(v206, v207);
          if (qword_1001E48A0 != -1)
            dispatch_once(&qword_1001E48A0, &stru_1001B7C10);
          v210 = (id)qword_1001E4898;
          v636 = _NSConcreteStackBlock;
          v637 = 3221225472;
          v638 = sub_10008C1F8;
          v639 = &unk_1001B85D0;
          v640 = __PAIR64__(v208, ESPSPIFromPacket);
          dispatch_async(v210, &v636);

          v21 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
          v20 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
        }
        else if (v203)
        {
          os_packet_clear_flow_uuid();
        }
        os_channel_set_slot_properties(*(_QWORD *)(v3 + 383), v169, &v627);
        LODWORD(v618) = 0;
        ++*(_QWORD *)(v3 + 495);
        *(_QWORD *)(v3 + 511) += v201;
        ++v606;
        v607 += v201;
        v611 = v169;
      }
      else
      {
        v211 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v200);
        v212 = _NRLogIsLevelEnabled(v211, 17);

        if (v212)
        {
          v213 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
          v214 = objc_msgSend((id)v3, "copyDescription");
          v216 = (void *)createStringFromNRTLVType(v615, v215);
          _NRLogWithArgs(v213, 17, "%@: failed to reinject %@ tlvLen=%u slotLen=%u", v214, v216, (unsigned __int16)v622, WORD1(v627));

        }
      }
      goto LABEL_305;
    default:
      goto LABEL_306;
  }
  while (2)
  {
    v226 = *(_DWORD *)((char *)&v643 + v223 + 8);
    if (v225)
    {
      if (v225 > v226)
      {
        v225 -= v226;
      }
      else
      {
        if (v225 < v226)
          goto LABEL_326;
        v225 = 0;
      }
    }
    else
    {
LABEL_326:
      v227 = v226 - v225;
      if (v227 >= (int)v194 - (int)v193)
        v228 = (v194 - v193);
      else
        v228 = v227;
      memcpy(&v222[v193], (const void *)(*(_QWORD *)((char *)&v643 + v223) + v225), v228);
      v193 = (v228 + v193);
      if (v193 >= v194)
      {
        v20 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
LABEL_341:
        if ((_DWORD)v193 != (_DWORD)v194)
        {
          v588 = sub_100070AC8();
          v589 = _NRLogIsLevelEnabled(v588, 16);

          if (v589)
          {
            v590 = sub_100070AC8();
            v591 = (void *)createIOVecString(&v643, (unsigned __int16)v620);
            _NRLogWithArgs(v590, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: bytesWritten == length; bytesWritten (%u) != length (%u), offset: %u, ioVec: %@",
              "",
              "nrWriteIOVecToBuffer",
              342,
              v193,
              v194,
              3,
              v591);

          }
          goto LABEL_578;
        }
        sub_10008C5F8((void *)v3, v222, (unsigned __int16)v622);
        v21 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
        v10 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
LABEL_343:
        free(v222);
LABEL_305:
        v22 = v614;
LABEL_306:
        *(_QWORD *)(v3 + v624) |= 0x40000000uLL;
        if (*(_QWORD *)(v3 + 1871) && *(_QWORD *)(v3 + 1879))
        {
          *(_BYTE *)(v3 + 251) %= *(_BYTE *)(v3 + 250);
          v217 = *(_QWORD *)(v3 + 1879);
          v218 = (_QWORD *)(v217 + 8 * *(unsigned __int8 *)(v3 + 251));
          if ((unint64_t)(v218 + 1) <= v217 + 8 * (unint64_t)*(unsigned __int8 *)(v3 + 250))
          {
            if ((v218 & 7) == 0)
            {
              *v218 = *(_QWORD *)(v3 + 1871);
              ++*(_BYTE *)(v3 + 251);
              *(_QWORD *)(v3 + 1871) = 0;
            }
          }
          else
          {
            v219 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
            v220 = _NRLogIsLevelEnabled(v219, 17);

            if (v220)
            {
              v52 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), v2);
              v53 = objc_msgSend((id)v3, "copyDescription");
              _NRLogWithArgs(v52, 17, "%@: invalid index for link log list (curIdx: %u)", v53, *(unsigned __int8 *)(v3 + 251));
LABEL_311:

            }
          }
        }
        goto LABEL_16;
      }
      v225 = 0;
      v20 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
    }
    v223 += 16;
    if (v224 == v223)
      goto LABEL_341;
    continue;
  }
}

void sub_100095EB0(uint64_t a1, void *a2)
{
  id v3;
  id v4;
  id v5;
  id v6;
  id v7;
  id v8;
  uint64_t v9;
  void *i;
  void *v11;
  id v12;
  void *v13;
  uint64_t v14;
  void *v15;
  id v16;
  void *v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  _BYTE v22[128];

  v3 = a2;
  v4 = objc_alloc_init((Class)NSMutableDictionary);
  v5 = objc_alloc_init((Class)NSMutableArray);
  v18 = 0u;
  v19 = 0u;
  v20 = 0u;
  v21 = 0u;
  v6 = v3;
  v7 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v18, v22, 16);
  if (v7)
  {
    v8 = v7;
    v9 = *(_QWORD *)v19;
    do
    {
      for (i = 0; i != v8; i = (char *)i + 1)
      {
        if (*(_QWORD *)v19 != v9)
          objc_enumerationMutation(v6);
        v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((_QWORD *)&v18 + 1) + 8 * (_QWORD)i), "UUIDString", (_QWORD)v18));
        objc_msgSend(v5, "addObject:", v11);

      }
      v8 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v18, v22, 16);
    }
    while (v8);
  }

  objc_msgSend(v4, "setObject:forKeyedSubscript:", v5, CFSTR("nexus-instances"));
  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v12 = (id)qword_1001E4708;
  v13 = v12;
  if (v12)
  {
    v14 = *(_QWORD *)(a1 + 32);
    v15 = (void *)*((_QWORD *)v12 + 25);
    v16 = v4;
    v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "objectForKeyedSubscript:", v14));
    sub_1000EF368((uint64_t)v17, v16);

  }
  sub_10007BA44(a1);

}

uint64_t sub_10009609C(_QWORD *a1)
{
  const char *v1;
  uint64_t v3;
  int v4;
  uint64_t v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  uint64_t v10;
  id v11;
  void *v12;
  uint64_t v13;
  void *v14;
  id v15;
  int v16;
  int *v17;
  int *v18;
  id v20;
  int v21;
  id v22;
  int *v23;
  uint64_t v24;
  id v25;
  int IsLevelEnabled;
  id v27;
  int *v28;
  uint64_t v29;
  id v30;
  char v31;
  char v32;
  char v33;
  char v34;
  char v35;
  char v36;
  char v37;
  char v38;
  char v39;
  char v40;
  char v41;
  char v42;
  char v43;
  char v44;
  char v45;
  char v46;
  __int128 v47;
  char __strerrbuf[128];

  if (objc_msgSend(a1, "virtualInterface"))
  {
    v4 = socket(2, 2, 0);
    if ((v4 & 0x80000000) == 0)
    {
      LODWORD(v5) = v4;
      v6 = (char *)NEVirtualInterfaceCopyName(objc_msgSend(a1, "virtualInterface"));
      v7 = v6;
      if (v6)
      {
        v8 = (char *)objc_msgSend(v6, "UTF8String", 0, 0, 0, 0);
        if (v8)
        {
          v31 = *v8;
          if (v31)
          {
            v32 = v8[1];
            if (v32)
            {
              v33 = v8[2];
              if (v33)
              {
                v34 = v8[3];
                if (v34)
                {
                  v35 = v8[4];
                  if (v35)
                  {
                    v36 = v8[5];
                    if (v36)
                    {
                      v37 = v8[6];
                      if (v37)
                      {
                        v38 = v8[7];
                        if (v38)
                        {
                          v39 = v8[8];
                          if (v39)
                          {
                            v40 = v8[9];
                            if (v40)
                            {
                              v41 = v8[10];
                              if (v41)
                              {
                                v42 = v8[11];
                                if (v42)
                                {
                                  v43 = v8[12];
                                  if (v43)
                                  {
                                    v44 = v8[13];
                                    if (v44)
                                    {
                                      v45 = v8[14];
                                      if (v45)
                                        v46 = 0;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          LODWORD(v47) = 2;
          if (ioctl(v5, 0xC02069B4uLL, &v31) < 0)
          {
            v17 = __error();
            if (strerror_r(*v17, __strerrbuf, 0x80uLL))
              __strerrbuf[0] = 0;
            if (qword_1001E46D8 != -1)
              dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
            if (_NRLogIsLevelEnabled(qword_1001E46D0, 17))
            {
              if (qword_1001E46D8 != -1)
                dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
              _NRLogWithArgs(qword_1001E46D0, 17, "ioctl SIOCSQOSMARKINGMODE failed: [%d] %s");
            }
            goto LABEL_78;
          }
          v9 = (char *)objc_msgSend(v7, "UTF8String", 0, 0, 0, 0);
          if (v9)
          {
            v31 = *v9;
            if (v31)
            {
              v32 = v9[1];
              if (v32)
              {
                v33 = v9[2];
                if (v33)
                {
                  v34 = v9[3];
                  if (v34)
                  {
                    v35 = v9[4];
                    if (v35)
                    {
                      v36 = v9[5];
                      if (v36)
                      {
                        v37 = v9[6];
                        if (v37)
                        {
                          v38 = v9[7];
                          if (v38)
                          {
                            v39 = v9[8];
                            if (v39)
                            {
                              v40 = v9[9];
                              if (v40)
                              {
                                v41 = v9[10];
                                if (v41)
                                {
                                  v42 = v9[11];
                                  if (v42)
                                  {
                                    v43 = v9[12];
                                    if (v43)
                                    {
                                      v44 = v9[13];
                                      if (v44)
                                      {
                                        v45 = v9[14];
                                        if (v45)
                                          v46 = 0;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            LODWORD(v47) = 1;
            if ((ioctl(v5, 0xC02069B5uLL, &v31) & 0x80000000) == 0)
            {
              if (qword_1001E46D8 != -1)
                dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
              v10 = 1;
              if (_NRLogIsLevelEnabled(qword_1001E46D0, 1))
              {
                if (qword_1001E46D8 != -1)
                  dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
                v11 = (id)qword_1001E46D0;
                _NRLogWithArgs(v11, 1, "%s%.30s:%-4d Successfully enabled QoS marking on interface %s", "", "-[NRLinkBluetooth setQosMarkingEnabled]", 2390, (const char *)objc_msgSend(v7, "UTF8String"));

              }
              goto LABEL_79;
            }
            v18 = __error();
            if (strerror_r(*v18, __strerrbuf, 0x80uLL))
              __strerrbuf[0] = 0;
            if (qword_1001E46D8 != -1)
              dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
            if (_NRLogIsLevelEnabled(qword_1001E46D0, 17))
            {
              if (qword_1001E46D8 != -1)
                dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
              _NRLogWithArgs(qword_1001E46D0, 17, "ioctl SIOCSQOSMARKINGENABLED failed: [%d] %s");
            }
LABEL_78:
            v10 = 0;
LABEL_79:

            close(v5);
            return v10;
          }
          v25 = sub_100070AC8();
          IsLevelEnabled = _NRLogIsLevelEnabled(v25, 16);

          v1 = "_strict_strlcpy";
          if (IsLevelEnabled)
          {
            v27 = sub_100070AC8();
            _NRLogWithArgs(v27, 16, "%s%.30s:%-4d ABORTING: strict_strlcpy called with NULL src", "", "_strict_strlcpy", 240);

          }
          v5 = _os_log_pack_size(12);
          v7 = &v31 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
          v28 = __error();
          v29 = _os_log_pack_fill(v7, v5, *v28, &_mh_execute_header, "%{public}s strict_strlcpy called with NULL src");
          *(_DWORD *)v29 = 136446210;
          *(_QWORD *)(v29 + 4) = "_strict_strlcpy";
        }
        else
        {
          v20 = sub_100070AC8();
          v21 = _NRLogIsLevelEnabled(v20, 16);

          if (v21)
          {
            v22 = sub_100070AC8();
            _NRLogWithArgs(v22, 16, "%s%.30s:%-4d ABORTING: strict_strlcpy called with NULL src", "", "_strict_strlcpy", 240);

          }
          v5 = _os_log_pack_size(12);
          v7 = &v31 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
          v23 = __error();
          v24 = _os_log_pack_fill(v7, v5, *v23, &_mh_execute_header, "%{public}s strict_strlcpy called with NULL src");
          *(_DWORD *)v24 = 136446210;
          *(_QWORD *)(v24 + 4) = "_strict_strlcpy";
        }
        v30 = sub_100070AC8();
        _NRLogAbortWithPack(v30, v7);
      }
      else
      {
        v1 = (const char *)&OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
        if (qword_1001E46D8 == -1)
          goto LABEL_58;
      }
      dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
LABEL_58:
      if (_NRLogIsLevelEnabled(qword_1001E46D0, 17))
      {
        if (*((_QWORD *)v1 + 219) != -1)
          dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
        _NRLogWithArgs(qword_1001E46D0, 17, "Failed to copy virtual interface name");
      }
      goto LABEL_78;
    }
    v16 = *__error();
    if (strerror_r(v16, __strerrbuf, 0x80uLL))
      __strerrbuf[0] = 0;
    if (qword_1001E46D8 != -1)
      dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
    if (_NRLogIsLevelEnabled(qword_1001E46D0, 17))
    {
      if (qword_1001E46D8 != -1)
        dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
      _NRLogWithArgs(qword_1001E46D0, 17, "Failed to create socket for setting QoS marking flags: [%d] %s", v16, __strerrbuf);
    }
    return 0;
  }
  else
  {
    v12 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v3);
    v10 = _NRLogIsLevelEnabled(v12, 17);

    if ((_DWORD)v10)
    {
      v14 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v13);
      v15 = objc_msgSend(a1, "copyDescription");
      _NRLogWithArgs(v14, 17, "%@: No virtualInterface to set QoS marking mode enabled", v15);

      return 0;
    }
  }
  return v10;
}

void sub_10009683C(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  int *v4;
  int *v5;
  void *v6;
  void *v7;
  int v8;
  uint64_t v9;
  void *v10;
  id v11;
  void *v12;
  int IsLevelEnabled;
  uint64_t v14;
  void *v15;
  id v16;

  sub_100098F0C(a1, a2);
  if (!*(_QWORD *)(a1 + 1327))
  {
    if (!*(_BYTE *)(a1 + 222))
    {
      v4 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
      if (*(_QWORD *)(a1 + 991))
      {
        *(_BYTE *)(a1 + 222) = 1;
        ++*(_QWORD *)(a1 + 1007);
        if (gNRPacketLoggingEnabled)
        {
          v12 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v3);
          IsLevelEnabled = _NRLogIsLevelEnabled(v12, 1);

          v4 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
          if (IsLevelEnabled)
          {
            v15 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v14);
            v16 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v15, 1, "%s%.30s:%-4d %@: source-suspend: LinkOutput", "", "NRLinkSuspendLinkOutputSource", 815, v16);

            v4 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
          }
        }
        dispatch_suspend(*(dispatch_object_t *)(a1 + v4[75]));
      }
    }
    if (*(_BYTE *)(a1 + 212))
    {
      v5 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
      if (*(_QWORD *)(a1 + 391))
      {
        *(_BYTE *)(a1 + 212) = 0;
        ++*(_QWORD *)(a1 + 415);
        if (gNRPacketLoggingEnabled)
        {
          v7 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v3);
          v8 = _NRLogIsLevelEnabled(v7, 1);

          v5 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
          if (v8)
          {
            v10 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v9);
            v11 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v10, 1, "%s%.30s:%-4d %@: source-resume: NexusInput", "", "NRLinkResumeNexusInputSource", 842, v11);

            v5 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
          }
        }
        dispatch_resume(*(dispatch_object_t *)(a1 + v5[203]));
      }
    }
    v6 = *(void **)(a1 + 1351);
    if (v6)
      objc_msgSend(v6, "setReceiveWindowPacketCount:", 32);
  }
}

void sub_100096A48(uint64_t a1)
{
  NSObject *v2;
  dispatch_source_t v3;
  void *v4;
  NSObject *v5;
  _QWORD handler[4];
  id v7[2];
  id location;

  if (!*(_QWORD *)(a1 + 1727))
  {
    v2 = objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "queue"));
    v3 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v2);
    v4 = *(void **)(a1 + 1727);
    *(_QWORD *)(a1 + 1727) = v3;

    dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 1727), 0, 0x12A05F200uLL, 0x2FAF080uLL);
    objc_initWeak(&location, (id)a1);
    v5 = *(NSObject **)(a1 + 1727);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472;
    handler[2] = sub_100096B64;
    handler[3] = &unk_1001B87C8;
    objc_copyWeak(v7, &location);
    v7[1] = (id)5;
    dispatch_source_set_event_handler(v5, handler);
    dispatch_resume(*(dispatch_object_t *)(a1 + 1727));
    objc_destroyWeak(v7);
    objc_destroyWeak(&location);
  }
}

void sub_100096B64(uint64_t a1)
{
  _QWORD *WeakRetained;
  _QWORD *v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  int IsLevelEnabled;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  int v30;
  void *v31;
  void *v32;
  int v33;
  uint64_t v34;
  void *v35;
  unsigned __int8 *v36;
  int v37;
  uint64_t v38;
  NRAnalyticsDataStall *v39;
  uint64_t v40;
  uint64_t v41;
  NRAnalyticsDataStall *v42;
  int v43;
  _BOOL4 v44;
  char v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _BOOL4 v54;
  uint64_t v55;
  id v56;
  int v57;
  id v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v3 = WeakRetained;
  if (WeakRetained)
  {
    v80 = (uint64_t)WeakRetained;
    v4 = objc_msgSend(WeakRetained, "state");
    v3 = (_QWORD *)v80;
    if (v4 != 255)
    {
      v79 = a1;
      v5 = *(_QWORD *)(v80 + 1383);
      v6 = *(_QWORD *)(v80 + 1735);
      *(_QWORD *)(v80 + 1735) = v5;
      v7 = *(_QWORD *)(v80 + 1375);
      v8 = *(_QWORD *)(v80 + 1759);
      *(_QWORD *)(v80 + 1759) = v7;
      v68 = *(_QWORD *)(v80 + 1743);
      v69 = *(_QWORD *)(v80 + 1415);
      *(_QWORD *)(v80 + 1743) = v69;
      v78 = *(_QWORD *)(v80 + 1767);
      v67 = *(_QWORD *)(v80 + 1407);
      *(_QWORD *)(v80 + 1767) = v67;
      v72 = *(_QWORD *)(v80 + 1751);
      v73 = *(_QWORD *)(v80 + 1399);
      *(_QWORD *)(v80 + 1751) = v73;
      v70 = *(_QWORD *)(v80 + 1775);
      v71 = *(_QWORD *)(v80 + 1391);
      *(_QWORD *)(v80 + 1775) = v71;
      v9 = *(_QWORD *)(v80 + 487);
      v10 = *(_QWORD *)(v80 + 1815);
      *(_QWORD *)(v80 + 1815) = v9;
      v11 = *(_QWORD *)(v80 + 495);
      v12 = *(_QWORD *)(v80 + 1823);
      *(_QWORD *)(v80 + 1823) = v11;
      v13 = *(_QWORD *)(v80 + 919);
      v14 = *(_QWORD *)(v80 + 1831);
      *(_QWORD *)(v80 + 1831) = v13;
      v15 = *(_QWORD *)(v80 + 927);
      v16 = *(_QWORD *)(v80 + 1839);
      *(_QWORD *)(v80 + 1839) = v15;
      v17 = *(_QWORD *)(v80 + 631);
      v18 = *(_QWORD *)(v80 + 1783);
      *(_QWORD *)(v80 + 1783) = v17;
      v19 = *(_QWORD *)(v80 + 1791);
      v66 = *(_QWORD *)(v80 + 639);
      *(_QWORD *)(v80 + 1791) = v66;
      v76 = *(_QWORD *)(v80 + 1799);
      v77 = *(_QWORD *)(v80 + 775);
      *(_QWORD *)(v80 + 1799) = v77;
      v74 = *(_QWORD *)(v80 + 1807);
      v75 = *(_QWORD *)(v80 + 783);
      *(_QWORD *)(v80 + 1807) = v75;
      v62 = v5 - v6;
      if (v5 != v6 || v7 != v8 || v9 != v10 || v13 != v14 || v11 != v12 || v15 != v16)
      {
        v60 = v8;
        v61 = v12;
        v63 = v18;
        v64 = v19;
        v59 = v10;
        v20 = v17;
        v21 = v16;
        v22 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v80 + 32), v80);
        IsLevelEnabled = _NRLogIsLevelEnabled(v22, 0);

        v24 = v21;
        v17 = v20;
        v18 = v63;
        v19 = v64;
        v3 = (_QWORD *)v80;
        if (IsLevelEnabled)
        {
          v25 = v15 - v24;
          v26 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v80 + 32), v80);
          _NRLogWithArgs(v26, 0, "LinkStats - BT(M): Tx [ be %3llu, bk %3llu, %7llu B, %7llu B/s ] Rx [ be %3llu, bk %3llu, %7llu B, %7llu B/s ]", v9 - v59, v13 - v14, v62, v62 / *(_QWORD *)(v79 + 40), v11 - v61, v25, v7 - v60, (unint64_t)(v7 - v60) / *(_QWORD *)(v79 + 40));

          v18 = v63;
          v19 = v64;
          v3 = (_QWORD *)v80;
        }
      }
      v65 = v17 - v18;
      v27 = v66 - v19;
      if (v69 != v68 || v67 != v78 || v77 != v76 || v17 != v18 || v75 != v74 || v66 != v19)
      {
        v28 = v19;
        v29 = (void *)_NRCopyLogObjectForNRUUID(v3[4], v3);
        v30 = _NRLogIsLevelEnabled(v29, 0);

        v19 = v28;
        v12 = v80;
        if (v30)
        {
          v31 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v80 + 32), v3);
          _NRLogWithArgs(v31, 0, "LinkStats - BT(U): Tx [ vo %3llu, vi %3llu, %7llu B, %7llu B/s ] Rx [ vo %3llu, vi %3llu, %7llu B, %7llu B/s ]", v65, v77 - v76, v69 - v68, (unint64_t)(v69 - v68) / *(_QWORD *)(v79 + 40), v27, v75 - v74, v67 - v78, (unint64_t)(v67 - v78) / *(_QWORD *)(v79 + 40));

          v19 = v28;
        }
      }
      if (v73 != v72 || v71 != v70 || v66 != v19)
      {
        v32 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v80 + 32), v3);
        v33 = _NRLogIsLevelEnabled(v32, 0);

        if (v33)
        {
          v35 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v80 + 32), v34);
          _NRLogWithArgs(v35, 0, "LinkStats - BT(D): Tx [ vo %3llu, %7llu B, %7llu B/s ] Rx [ vo %3llu, %7llu B, %7llu B/s ]", v65, v73 - v72, (unint64_t)(v73 - v72) / *(_QWORD *)(v79 + 40), v27, v71 - v70, (unint64_t)(v71 - v70) / *(_QWORD *)(v79 + 40));

        }
      }
      if (_NRIsAppleInternal(v12))
      {
        objc_opt_self(NRLinkDirector);
        if (qword_1001E4710 != -1)
          dispatch_once(&qword_1001E4710, &stru_1001B6E60);
        v36 = (unsigned __int8 *)(id)qword_1001E4708;
        if (v36)
        {
          v37 = v36[9];

          if (v37)
          {
            if (gNRPacketLoggingEnabled)
            {
              v56 = sub_100070AC8();
              v57 = _NRLogIsLevelEnabled(v56, 1);

              if (v57)
              {
                v58 = sub_100070AC8();
                _NRLogWithArgs(v58, 1, "%s%.30s:%-4d force sending wake packet to ESP", "", "-[NRLinkBluetooth armLinkStatsTimer]_block_invoke", 6272);

              }
            }
            *(_BYTE *)(v80 + 245) = 1;
          }
        }
      }
      v3 = (_QWORD *)v80;
      v38 = *(_QWORD *)(v80 + 1847);
      if ((unint64_t)(*(_QWORD *)(v79 + 40) * v38) < 0xF)
        goto LABEL_112;
      v39 = objc_alloc_init(NRAnalyticsDataStall);
      v41 = v80;
      v42 = v39;
      if (!*(_BYTE *)(v80 + 215) && (v47 = *(_QWORD *)(v80 + 591)) != 0 && v47 == *(_QWORD *)(v80 + 575))
      {
        v44 = sub_100097568((_QWORD *)v80, "NexusVO");
        if (v42)
          v42->_stalledNexusVOOutput = 1;
        v43 = 1;
        v41 = v80;
      }
      else
      {
        v43 = 0;
        v44 = 0;
      }
      *(_QWORD *)(v41 + 591) = *(_QWORD *)(v41 + 575);
      if (!*(_BYTE *)(v41 + 217))
      {
        v48 = *(_QWORD *)(v41 + 735);
        if (v48)
        {
          if (v48 == *(_QWORD *)(v41 + 719))
          {
            if (v44)
            {
              v44 = 1;
            }
            else
            {
              v44 = sub_100097568((_QWORD *)v41, "NexusVI");
              v41 = v80;
            }
            if (v42)
              v42->_stalledNexusVIOutput = 1;
            v43 = 1;
          }
        }
      }
      *(_QWORD *)(v41 + 735) = *(_QWORD *)(v41 + 719);
      if (!*(_BYTE *)(v41 + 213))
      {
        v49 = *(_QWORD *)(v41 + 439);
        if (v49)
        {
          if (v49 == *(_QWORD *)(v41 + 423))
          {
            if (v44)
            {
              v44 = 1;
            }
            else
            {
              v44 = sub_100097568((_QWORD *)v41, "Nexus");
              v41 = v80;
            }
            if (v42)
              v42->_stalledNexusOutput = 1;
            v43 = 1;
          }
        }
      }
      *(_QWORD *)(v41 + 439) = *(_QWORD *)(v41 + 423);
      if (!*(_BYTE *)(v41 + 219))
      {
        v50 = *(_QWORD *)(v41 + 879);
        if (v50)
        {
          if (v50 == *(_QWORD *)(v41 + 863))
          {
            if (v44)
            {
              v44 = 1;
            }
            else
            {
              v44 = sub_100097568((_QWORD *)v41, "NexusBK");
              v41 = v80;
            }
            if (v42)
              v42->_stalledNexusBKOutput = 1;
            v43 = 1;
          }
        }
      }
      *(_QWORD *)(v41 + 879) = *(_QWORD *)(v41 + 863);
      if (!*(_BYTE *)(v41 + 222))
      {
        v51 = *(_QWORD *)(v41 + 1023);
        if (v51)
        {
          if (v51 == *(_QWORD *)(v41 + 1007))
          {
            if (v44)
            {
              v44 = 1;
            }
            else
            {
              v44 = sub_100097568((_QWORD *)v41, "Link");
              v41 = v80;
            }
            if (v42)
              v42->_stalledLinkOutput = 1;
            v43 = 1;
          }
        }
      }
      *(_QWORD *)(v41 + 1023) = *(_QWORD *)(v41 + 1007);
      if (!*(_BYTE *)(v41 + 228))
      {
        v52 = *(_QWORD *)(v41 + 1183);
        if (v52)
        {
          if (v52 == *(_QWORD *)(v41 + 1167))
          {
            if (v44)
            {
              v44 = 1;
            }
            else
            {
              v44 = sub_100097568((_QWORD *)v41, "UrgentLink");
              v41 = v80;
            }
            if (v42)
              v42->_stalledUrgentLinkOutput = 1;
            v43 = 1;
          }
        }
      }
      *(_QWORD *)(v41 + 1183) = *(_QWORD *)(v41 + 1167);
      if (!*(_BYTE *)(v41 + 224) && (v53 = *(_QWORD *)(v41 + 1103)) != 0 && v53 == *(_QWORD *)(v41 + 1087))
      {
        v54 = v44 || sub_100097568((_QWORD *)v41, "DatagramLink");
        if (v42)
          v42->_stalledDatagramLinkOutput = 1;
        v41 = v80;
        *(_QWORD *)(v80 + 1103) = *(_QWORD *)(v80 + 1087);
        *(_QWORD *)(v80 + 1847) = 0;
        if (v54)
        {
          sub_100097808(v80, v40);
          v41 = v80;
          v45 = 1;
        }
        else
        {
          v45 = 0;
        }
      }
      else
      {
        *(_QWORD *)(v41 + 1103) = *(_QWORD *)(v41 + 1087);
        *(_QWORD *)(v41 + 1847) = 0;
        if (v44)
        {
          sub_100097808(v41, v40);
          v45 = 1;
          if ((v43 & 1) == 0)
            goto LABEL_104;
          v41 = v80;
        }
        else
        {
          v45 = 0;
          v46 = 0;
          if (!v43)
          {
LABEL_106:
            *(_QWORD *)(v41 + 1855) = 0;
            if ((v45 & 1) != 0)
              goto LABEL_110;
LABEL_109:
            if (!v46)
            {
LABEL_111:

              v3 = (_QWORD *)v80;
              v38 = *(_QWORD *)(v80 + 1847);
LABEL_112:
              *(_QWORD *)((char *)v3 + 1847) = v38 + 1;
              goto LABEL_113;
            }
LABEL_110:
            -[NRAnalyticsDataStall submit](v42, "submit");
            goto LABEL_111;
          }
        }
      }
      v55 = *(_QWORD *)(v41 + 1855) + 1;
      *(_QWORD *)(v41 + 1855) = v55;
      if ((unint64_t)(15 * v55) < 0xB4)
      {
        v46 = 0;
        if ((v45 & 1) != 0)
          goto LABEL_110;
        goto LABEL_109;
      }
      if (sub_100097C68(v41))
      {
        v46 = 1;
        if (v42)
          v42->_remediatedDataStall = 1;
        goto LABEL_105;
      }
LABEL_104:
      v46 = 0;
LABEL_105:
      v41 = v80;
      goto LABEL_106;
    }
  }
LABEL_113:

}

BOOL sub_100097568(_QWORD *a1, const char *a2)
{
  _QWORD *v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  BOOL v10;
  uint64_t v11;
  double v12;
  _BOOL8 v14;
  id v15;
  uint64_t v16;
  void *v17;
  int IsLevelEnabled;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  _QWORD *v24;
  NSObject *v25;
  id v26;
  int v27;
  const char *v29;
  id v30;

  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v4 = (id)qword_1001E4708;
  if (v4
    && ((v5 = sub_10014CFBC(),
         dispatch_assert_queue_V2(v5),
         v5,
         v6 = v4[31],
         v7 = mach_absolute_time(),
         v6)
      ? (v10 = v7 > v6)
      : (v10 = 0),
        v10))
  {
    v11 = v7;
    if (qword_1001E48A8 != -1)
      dispatch_once(&qword_1001E48A8, &stru_1001B7C30);
    LODWORD(v8) = dword_1001E48B0;
    LODWORD(v9) = *(_DWORD *)algn_1001E48B4;
    v12 = (double)(v11 - v6) * (0.000000001 * (double)v8) / (double)v9;

    if (v12 > 0.0 && v12 < 3600.0)
      return 0;
  }
  else
  {

  }
  v14 = a2 != 0;
  if (a2)
  {
    v29 = a2;
    v15 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%sOutput"));
    v17 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v16);
    IsLevelEnabled = _NRLogIsLevelEnabled(v17, 0);

    if (IsLevelEnabled)
    {
      v23 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v19);
      v30 = objc_msgSend(a1, "copyDescription");
      v29 = "";
      _NRLogWithArgs(v23, 0, "%s%.30s:%-4d %@: Data stall detected for %@");

    }
    sub_100109270(CFSTR("NRLinkBluetooth"), CFSTR("Data stall"), v15, 0, 0, v20, v21, v22, (uint64_t)v29);
    objc_opt_self(NRLinkDirector);
    if (qword_1001E4710 != -1)
      dispatch_once(&qword_1001E4710, &stru_1001B6E60);
    v24 = (id)qword_1001E4708;
    if (v24)
    {
      v25 = sub_10014CFBC();
      dispatch_assert_queue_V2(v25);

      v24[31] = mach_absolute_time();
    }

    goto LABEL_23;
  }
  v26 = sub_100070AC8();
  v27 = _NRLogIsLevelEnabled(v26, 17);

  if (!v27)
    return 0;
  v15 = sub_100070AC8();
  _NRLogWithArgs(v15, 17, "%s called with null srcName", "-[NRLinkBluetooth reportDataStallForOutputSource:]");
LABEL_23:

  return v14;
}

void sub_100097808(uint64_t a1, uint64_t a2)
{
  unint64_t v3;
  unint64_t v4;
  void *v5;
  int IsLevelEnabled;
  void *v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t *v10;
  unsigned int v11;
  unint64_t v12;
  unint64_t v13;
  void *v14;
  int v15;
  void *v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t *v19;
  unsigned int v20;
  unint64_t v21;
  unint64_t v22;
  void *v23;
  int v24;
  void *v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t *v28;
  unsigned int v29;
  unint64_t v30;
  unint64_t v31;
  void *v32;
  int v33;
  void *v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t *v37;
  unsigned int v38;
  unint64_t v39;
  unint64_t v40;
  void *v41;
  int v42;
  uint64_t v43;
  void *v44;
  unsigned int v45;
  uint64_t v46;
  uint64_t *v47;
  unsigned int v48;

  if (*(_QWORD *)(a1 + 1879))
  {
    v3 = *(unsigned __int8 *)(a1 + 251);
    v4 = *(unsigned __int8 *)(a1 + 250);
    v5 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0);

    if (IsLevelEnabled)
    {
      v7 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
      _NRLogWithArgs(v7, 0, "LinkStats: ------ %s datapath snapshot ------", "Rx(M)");

    }
    if (*(_BYTE *)(a1 + 250))
    {
      v8 = 0;
      v9 = v3 - (v3 / v4) * (unint64_t)v4;
      do
      {
        v10 = (uint64_t *)(*(_QWORD *)(a1 + 1879) + 8 * v9);
        if ((v10 & 7) != 0)
          break;
        sub_100097E1C(*v10, *(void **)(a1 + 32));
        *v10 = 0;
        v11 = *(unsigned __int8 *)(a1 + 250);
        v9 = (v9 + 1) % v11;
        ++v8;
      }
      while (v8 < v11);
    }
  }
  if (*(_QWORD *)(a1 + 1927))
  {
    v12 = *(unsigned __int8 *)(a1 + 257);
    v13 = *(unsigned __int8 *)(a1 + 256);
    v14 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
    v15 = _NRLogIsLevelEnabled(v14, 0);

    if (v15)
    {
      v16 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
      _NRLogWithArgs(v16, 0, "LinkStats: ------ %s datapath snapshot ------", "Tx(M)");

    }
    if (*(_BYTE *)(a1 + 256))
    {
      v17 = 0;
      v18 = v12 - (v12 / v13) * (unint64_t)v13;
      do
      {
        v19 = (uint64_t *)(*(_QWORD *)(a1 + 1927) + 8 * v18);
        if ((v19 & 7) != 0)
          break;
        sub_10009882C(*v19, *(void **)(a1 + 32));
        *v19 = 0;
        v20 = *(unsigned __int8 *)(a1 + 256);
        v18 = (v18 + 1) % v20;
        ++v17;
      }
      while (v17 < v20);
    }
  }
  if (*(_QWORD *)(a1 + 1895))
  {
    v21 = *(unsigned __int8 *)(a1 + 253);
    v22 = *(unsigned __int8 *)(a1 + 252);
    v23 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
    v24 = _NRLogIsLevelEnabled(v23, 0);

    if (v24)
    {
      v25 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
      _NRLogWithArgs(v25, 0, "LinkStats: ------ %s datapath snapshot ------", "Rx(U)");

    }
    if (*(_BYTE *)(a1 + 252))
    {
      v26 = 0;
      v27 = v21 - (v21 / v22) * (unint64_t)v22;
      do
      {
        v28 = (uint64_t *)(*(_QWORD *)(a1 + 1895) + 8 * v27);
        if ((v28 & 7) != 0)
          break;
        sub_100097E1C(*v28, *(void **)(a1 + 32));
        *v28 = 0;
        v29 = *(unsigned __int8 *)(a1 + 252);
        v27 = (v27 + 1) % v29;
        ++v26;
      }
      while (v26 < v29);
    }
  }
  if (*(_QWORD *)(a1 + 1943))
  {
    v30 = *(unsigned __int8 *)(a1 + 259);
    v31 = *(unsigned __int8 *)(a1 + 258);
    v32 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
    v33 = _NRLogIsLevelEnabled(v32, 0);

    if (v33)
    {
      v34 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
      _NRLogWithArgs(v34, 0, "LinkStats: ------ %s datapath snapshot ------", "Tx(U)");

    }
    if (*(_BYTE *)(a1 + 258))
    {
      v35 = 0;
      v36 = v30 - (v30 / v31) * (unint64_t)v31;
      do
      {
        v37 = (uint64_t *)(*(_QWORD *)(a1 + 1943) + 8 * v36);
        if ((v37 & 7) != 0)
          break;
        sub_10009882C(*v37, *(void **)(a1 + 32));
        *v37 = 0;
        v38 = *(unsigned __int8 *)(a1 + 258);
        v36 = (v36 + 1) % v38;
        ++v35;
      }
      while (v35 < v38);
    }
  }
  if (*(_QWORD *)(a1 + 1911))
  {
    v39 = *(unsigned __int8 *)(a1 + 255);
    v40 = *(unsigned __int8 *)(a1 + 254);
    v41 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), a2);
    v42 = _NRLogIsLevelEnabled(v41, 0);

    if (v42)
    {
      v44 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v43);
      _NRLogWithArgs(v44, 0, "LinkStats: ------ %s datapath snapshot ------", "Rx(D)");

    }
    if (*(_BYTE *)(a1 + 254))
    {
      v45 = 0;
      v46 = v39 - (v39 / v40) * (unint64_t)v40;
      do
      {
        v47 = (uint64_t *)(*(_QWORD *)(a1 + 1911) + 8 * v46);
        if ((v47 & 7) != 0)
          break;
        sub_100097E1C(*v47, *(void **)(a1 + 32));
        *v47 = 0;
        v48 = *(unsigned __int8 *)(a1 + 254);
        v46 = (v46 + 1) % v48;
        ++v45;
      }
      while (v45 < v48);
    }
  }
}

uint64_t sub_100097C68(uint64_t a1)
{
  _QWORD *v3;
  NSObject *v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  BOOL v9;
  double v10;
  _QWORD *v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  if (*(_QWORD *)(a1 + 1031))
    return 0;
  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v3 = (id)qword_1001E4708;
  if (v3
    && ((v4 = sub_10014CFBC(),
         dispatch_assert_queue_V2(v4),
         v4,
         v5 = v3[32],
         v6 = mach_absolute_time(),
         v5)
      ? (v9 = v6 > v5)
      : (v9 = 0),
        v9))
  {
    if (qword_1001E48A8 != -1)
    {
      v21 = v6;
      dispatch_once(&qword_1001E48A8, &stru_1001B7C30);
      v6 = v21;
    }
    LODWORD(v7) = dword_1001E48B0;
    LODWORD(v8) = *(_DWORD *)algn_1001E48B4;
    v10 = (double)(v6 - v5) * (0.000000001 * (double)v7) / (double)v8;

    if (v10 > 0.0 && v10 < 3600.0)
      return 0;
  }
  else
  {

  }
  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v12 = (id)qword_1001E4708;
  if (v12)
  {
    v13 = sub_10014CFBC();
    dispatch_assert_queue_V2(v13);

    v12[32] = mach_absolute_time();
  }

  sub_100074F70((void *)a1, CFSTR("LinkStats - Remediating data stall"), v14, v15, v16, v17, v18, v19, v20);
  return 1;
}

void sub_100097E1C(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  void *v5;
  int IsLevelEnabled;
  void *v7;
  void *v8;
  int v9;
  void *v10;
  void *v11;
  int v12;
  void *v13;
  void *v14;
  int v15;
  void *v16;
  void *v17;
  int v18;
  void *v19;
  void *v20;
  int v21;
  void *v22;
  void *v23;
  int v24;
  void *v25;
  void *v26;
  int v27;
  void *v28;
  void *v29;
  int v30;
  void *v31;
  void *v32;
  int v33;
  void *v34;
  void *v35;
  int v36;
  void *v37;
  void *v38;
  int v39;
  void *v40;
  void *v41;
  int v42;
  void *v43;
  void *v44;
  int v45;
  void *v46;
  void *v47;
  int v48;
  void *v49;
  void *v50;
  int v51;
  void *v52;
  void *v53;
  int v54;
  void *v55;
  void *v56;
  int v57;
  void *v58;
  void *v59;
  int v60;
  void *v61;
  void *v62;
  int v63;
  void *v64;
  void *v65;
  int v66;
  void *v67;
  void *v68;
  int v69;
  void *v70;
  void *v71;
  int v72;
  void *v73;
  void *v74;
  int v75;
  void *v76;
  void *v77;
  int v78;
  void *v79;
  void *v80;
  int v81;
  void *v82;
  void *v83;
  int v84;
  void *v85;
  void *v86;
  int v87;
  void *v88;
  void *v89;
  int v90;
  void *v91;
  void *v92;
  int v93;
  void *v94;
  void *v95;
  int v96;
  void *v97;
  void *v98;
  int v99;
  void *v100;
  void *v101;
  int v102;
  void *v103;
  void *v104;
  int v105;
  void *v106;
  void *v107;
  int v108;
  void *v109;
  void *v110;
  int v111;
  void *v112;
  void *v113;
  int v114;
  uint64_t v115;
  void *v116;
  id v117;

  v3 = a2;
  if (a1)
  {
    v117 = v3;
    if ((a1 & 2) != 0)
    {
      v5 = (void *)_NRCopyLogObjectForNRUUID(v3, v4);
      IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0);

      if (IsLevelEnabled)
      {
        v7 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v7, 0, "LinkStats: LTNStartOuterLoop");

      }
    }
    if ((a1 & 4) != 0)
    {
      v8 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v9 = _NRLogIsLevelEnabled(v8, 0);

      if (v9)
      {
        v10 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v10, 0, "LinkStats: LTNStartInnerLoop");

      }
    }
    if ((a1 & 8) != 0)
    {
      v11 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v12 = _NRLogIsLevelEnabled(v11, 0);

      if (v12)
      {
        v13 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v13, 0, "LinkStats: LTNReadAllCurLinkInputSlot");

      }
    }
    if ((a1 & 0x10) != 0)
    {
      v14 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v15 = _NRLogIsLevelEnabled(v14, 0);

      if (v15)
      {
        v16 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v16, 0, "LinkStats: LTNGotNewSlot");

      }
    }
    if ((a1 & 0x20) != 0)
    {
      v17 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v18 = _NRLogIsLevelEnabled(v17, 0);

      if (v18)
      {
        v19 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v19, 0, "LinkStats: LTNReuseExistingSlot");

      }
    }
    if ((a1 & 0x40) != 0)
    {
      v20 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v21 = _NRLogIsLevelEnabled(v20, 0);

      if (v21)
      {
        v22 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v22, 0, "LinkStats: LTNNoLinkInputSlot");

      }
    }
    if ((a1 & 0x80) != 0)
    {
      v23 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v24 = _NRLogIsLevelEnabled(v23, 0);

      if (v24)
      {
        v25 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v25, 0, "LinkStats: LTNIncomingTLV1");

      }
    }
    if ((a1 & 0x100) != 0)
    {
      v26 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v27 = _NRLogIsLevelEnabled(v26, 0);

      if (v27)
      {
        v28 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v28, 0, "LinkStats: LTNIncomingTLV2");

      }
    }
    if ((a1 & 0x200) != 0)
    {
      v29 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v30 = _NRLogIsLevelEnabled(v29, 0);

      if (v30)
      {
        v31 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v31, 0, "LinkStats: LTNIncomingTLV3");

      }
    }
    if ((a1 & 0x400) != 0)
    {
      v32 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v33 = _NRLogIsLevelEnabled(v32, 0);

      if (v33)
      {
        v34 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v34, 0, "LinkStats: LTNIncomingTLV4");

      }
    }
    if ((a1 & 0x800) != 0)
    {
      v35 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v36 = _NRLogIsLevelEnabled(v35, 0);

      if (v36)
      {
        v37 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v37, 0, "LinkStats: LTNIncomingTLV5");

      }
    }
    if ((a1 & 0x1000) != 0)
    {
      v38 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v39 = _NRLogIsLevelEnabled(v38, 0);

      if (v39)
      {
        v40 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v40, 0, "LinkStats: LTNPlacingLinkReadBuffer");

      }
    }
    if ((a1 & 0x2000) != 0)
    {
      v41 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v42 = _NRLogIsLevelEnabled(v41, 0);

      if (v42)
      {
        v43 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v43, 0, "LinkStats: LTNPlacingCurLinkInputSlot");

      }
    }
    if ((a1 & 0x4000) != 0)
    {
      v44 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v45 = _NRLogIsLevelEnabled(v44, 0);

      if (v45)
      {
        v46 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v46, 0, "LinkStats: LTNShrinkingIOVec");

      }
    }
    if ((a1 & 0x8000) != 0)
    {
      v47 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v48 = _NRLogIsLevelEnabled(v47, 0);

      if (v48)
      {
        v49 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v49, 0, "LinkStats: LTNNotShrinkingIOVec");

      }
    }
    if ((a1 & 0x10000) != 0)
    {
      v50 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v51 = _NRLogIsLevelEnabled(v50, 0);

      if (v51)
      {
        v52 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v52, 0, "LinkStats: LTNNoLookAheadSlots");

      }
    }
    if ((a1 & 0x20000) != 0)
    {
      v53 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v54 = _NRLogIsLevelEnabled(v53, 0);

      if (v54)
      {
        v55 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v55, 0, "LinkStats: LTNPlacingLookAheadSlots");

      }
    }
    if ((a1 & 0x40000) != 0)
    {
      v56 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v57 = _NRLogIsLevelEnabled(v56, 0);

      if (v57)
      {
        v58 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v58, 0, "LinkStats: LTNShrinkingLastIOVec");

      }
    }
    if ((a1 & 0x80000) != 0)
    {
      v59 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v60 = _NRLogIsLevelEnabled(v59, 0);

      if (v60)
      {
        v61 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v61, 0, "LinkStats: LTNNotShrinkingLastIOVec");

      }
    }
    if ((a1 & 0x100000) != 0)
    {
      v62 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v63 = _NRLogIsLevelEnabled(v62, 0);

      if (v63)
      {
        v64 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v64, 0, "LinkStats: LTNNotEnoughInputBytes");

      }
    }
    if ((a1 & 0x200000) != 0)
    {
      v65 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v66 = _NRLogIsLevelEnabled(v65, 0);

      if (v66)
      {
        v67 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v67, 0, "LinkStats: LTNCurInputSlotComplete");

      }
    }
    if ((a1 & 0x400000) != 0)
    {
      v68 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v69 = _NRLogIsLevelEnabled(v68, 0);

      if (v69)
      {
        v70 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v70, 0, "LinkStats: LTNCurInputSlotCompleteLRB");

      }
    }
    if ((a1 & 0x800000) != 0)
    {
      v71 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v72 = _NRLogIsLevelEnabled(v71, 0);

      if (v72)
      {
        v73 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v73, 0, "LinkStats: LTNNoNexusOutputSlot");

      }
    }
    if ((a1 & 0x1000000) != 0)
    {
      v74 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v75 = _NRLogIsLevelEnabled(v74, 0);

      if (v75)
      {
        v76 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v76, 0, "LinkStats: LTNNoNexusOutputSlotAndFullLRB");

      }
    }
    if ((a1 & 0x2000000) != 0)
    {
      v77 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v78 = _NRLogIsLevelEnabled(v77, 0);

      if (v78)
      {
        v79 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v79, 0, "LinkStats: LTNNoNexusOutputSlotWithAllInLRB");

      }
    }
    if ((a1 & 0x4000000) != 0)
    {
      v80 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v81 = _NRLogIsLevelEnabled(v80, 0);

      if (v81)
      {
        v82 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v82, 0, "LinkStats: LTNCurInputSlotCompleteWithNoNexusOutputSlot");

      }
    }
    if ((a1 & 0x8000000) != 0)
    {
      v83 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v84 = _NRLogIsLevelEnabled(v83, 0);

      if (v84)
      {
        v85 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v85, 0, "LinkStats: LTNReinjectingPacketToNexus");

      }
    }
    if ((a1 & 0x10000000) != 0)
    {
      v86 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v87 = _NRLogIsLevelEnabled(v86, 0);

      if (v87)
      {
        v88 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v88, 0, "LinkStats: LTNMarkedWakePacketFlag");

      }
    }
    if ((a1 & 0x20000000) != 0)
    {
      v89 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v90 = _NRLogIsLevelEnabled(v89, 0);

      if (v90)
      {
        v91 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v91, 0, "LinkStats: LTNReinjectingIKEv2Packet");

      }
    }
    if ((a1 & 0x40000000) != 0)
    {
      v92 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v93 = _NRLogIsLevelEnabled(v92, 0);

      if (v93)
      {
        v94 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v94, 0, "LinkStats: LTNEndInnerLoop");

      }
    }
    if ((a1 & 0x80000000) != 0)
    {
      v95 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v96 = _NRLogIsLevelEnabled(v95, 0);

      if (v96)
      {
        v97 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v97, 0, "LinkStats: LTNMemmovingLRB");

      }
    }
    if ((a1 & 0x100000000) != 0)
    {
      v98 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v99 = _NRLogIsLevelEnabled(v98, 0);

      if (v99)
      {
        v100 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v100, 0, "LinkStats: LTNNotMemmovingLRBWithHandled");

      }
    }
    if ((a1 & 0x200000000) != 0)
    {
      v101 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v102 = _NRLogIsLevelEnabled(v101, 0);

      if (v102)
      {
        v103 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v103, 0, "LinkStats: LTNNotMemmovingLRBWithNoHandled");

      }
    }
    if ((a1 & 0x400000000) != 0)
    {
      v104 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v105 = _NRLogIsLevelEnabled(v104, 0);

      if (v105)
      {
        v106 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v106, 0, "LinkStats: LTNResettingLRB");

      }
    }
    if ((a1 & 0x800000000) != 0)
    {
      v107 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v108 = _NRLogIsLevelEnabled(v107, 0);

      if (v108)
      {
        v109 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v109, 0, "LinkStats: LTNLinkChannelSync");

      }
    }
    if ((a1 & 0x1000000000) != 0)
    {
      v110 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      v111 = _NRLogIsLevelEnabled(v110, 0);

      if (v111)
      {
        v112 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v112, 0, "LinkStats: LTNNexusOutputSync");

      }
    }
    v113 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
    v114 = _NRLogIsLevelEnabled(v113, 0);

    v3 = v117;
    if (v114)
    {
      v116 = (void *)_NRCopyLogObjectForNRUUID(v117, v115);
      _NRLogWithArgs(v116, 0, "LinkStats: ------------------------------");

      v3 = v117;
    }
  }

}

void sub_10009882C(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  void *v5;
  int IsLevelEnabled;
  void *v7;
  void *v8;
  int v9;
  void *v10;
  void *v11;
  int v12;
  void *v13;
  void *v14;
  int v15;
  void *v16;
  void *v17;
  int v18;
  void *v19;
  void *v20;
  int v21;
  void *v22;
  void *v23;
  int v24;
  void *v25;
  void *v26;
  int v27;
  void *v28;
  void *v29;
  int v30;
  void *v31;
  void *v32;
  int v33;
  void *v34;
  void *v35;
  int v36;
  void *v37;
  void *v38;
  int v39;
  void *v40;
  void *v41;
  int v42;
  void *v43;
  void *v44;
  int v45;
  void *v46;
  void *v47;
  int v48;
  void *v49;
  void *v50;
  int v51;
  void *v52;
  void *v53;
  int v54;
  void *v55;
  void *v56;
  int v57;
  void *v58;
  void *v59;
  int v60;
  void *v61;
  void *v62;
  int v63;
  void *v64;
  void *v65;
  int v66;
  void *v67;
  void *v68;
  int v69;
  void *v70;
  void *v71;
  int v72;
  void *v73;
  void *v74;
  int v75;
  void *v76;
  void *v77;
  int v78;
  uint64_t v79;
  void *v80;
  id v81;

  v3 = a2;
  if (a1)
  {
    v81 = v3;
    if ((a1 & 2) != 0)
    {
      v5 = (void *)_NRCopyLogObjectForNRUUID(v3, v4);
      IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0);

      if (IsLevelEnabled)
      {
        v7 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v7, 0, "LinkStats: NTLStartInnerLoop");

      }
    }
    if ((a1 & 4) != 0)
    {
      v8 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      v9 = _NRLogIsLevelEnabled(v8, 0);

      if (v9)
      {
        v10 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v10, 0, "LinkStats: NTLNoDatagramLinkInputSlot");

      }
    }
    if ((a1 & 8) != 0)
    {
      v11 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      v12 = _NRLogIsLevelEnabled(v11, 0);

      if (v12)
      {
        v13 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v13, 0, "LinkStats: NTLNoNexusInputSlotForDatagramLink");

      }
    }
    if ((a1 & 0x10) != 0)
    {
      v14 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      v15 = _NRLogIsLevelEnabled(v14, 0);

      if (v15)
      {
        v16 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v16, 0, "LinkStats: NTLWroteToDatagramLink");

      }
    }
    if ((a1 & 0x20) != 0)
    {
      v17 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      v18 = _NRLogIsLevelEnabled(v17, 0);

      if (v18)
      {
        v19 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v19, 0, "LinkStats: NTLGotLinkOutputSlot");

      }
    }
    if ((a1 & 0x40) != 0)
    {
      v20 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      v21 = _NRLogIsLevelEnabled(v20, 0);

      if (v21)
      {
        v22 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v22, 0, "LinkStats: NTLReuseExistingSlot");

      }
    }
    if ((a1 & 0x80) != 0)
    {
      v23 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      v24 = _NRLogIsLevelEnabled(v23, 0);

      if (v24)
      {
        v25 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v25, 0, "LinkStats: NTLNoLinkOutputSlot");

      }
    }
    if ((a1 & 0x100) != 0)
    {
      v26 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      v27 = _NRLogIsLevelEnabled(v26, 0);

      if (v27)
      {
        v28 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v28, 0, "LinkStats: NTLWroteBytesFromLWB");

      }
    }
    if ((a1 & 0x200) != 0)
    {
      v29 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      v30 = _NRLogIsLevelEnabled(v29, 0);

      if (v30)
      {
        v31 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v31, 0, "LinkStats: NTLFilledLinkOutputWithLWB");

      }
    }
    if ((a1 & 0x400) != 0)
    {
      v32 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      v33 = _NRLogIsLevelEnabled(v32, 0);

      if (v33)
      {
        v34 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v34, 0, "LinkStats: NTLNilNexusInputRing");

      }
    }
    if ((a1 & 0x800) != 0)
    {
      v35 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      v36 = _NRLogIsLevelEnabled(v35, 0);

      if (v36)
      {
        v37 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v37, 0, "LinkStats: NTLNoNexusInput");

      }
    }
    if ((a1 & 0x1000) != 0)
    {
      v38 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      v39 = _NRLogIsLevelEnabled(v38, 0);

      if (v39)
      {
        v40 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v40, 0, "LinkStats: NTLGotLookaheadOutputSlot");

      }
    }
    if ((a1 & 0x2000) != 0)
    {
      v41 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      v42 = _NRLogIsLevelEnabled(v41, 0);

      if (v42)
      {
        v43 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v43, 0, "LinkStats: NTLNotEnoughRoomInLinkOutputSlot");

      }
    }
    if ((a1 & 0x4000) != 0)
    {
      v44 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      v45 = _NRLogIsLevelEnabled(v44, 0);

      if (v45)
      {
        v46 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v46, 0, "LinkStats: NTLWroteToLinkOutputSlot");

      }
    }
    if ((a1 & 0x8000) != 0)
    {
      v47 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      v48 = _NRLogIsLevelEnabled(v47, 0);

      if (v48)
      {
        v49 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v49, 0, "LinkStats: NTLWroteToLookaheadOutputSlot");

      }
    }
    if ((a1 & 0x10000) != 0)
    {
      v50 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      v51 = _NRLogIsLevelEnabled(v50, 0);

      if (v51)
      {
        v52 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v52, 0, "LinkStats: NTLWroteNexusPacket");

      }
    }
    if ((a1 & 0x20000) != 0)
    {
      v53 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      v54 = _NRLogIsLevelEnabled(v53, 0);

      if (v54)
      {
        v55 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v55, 0, "LinkStats: NTLWrotePartialBytesToLinkOutput");

      }
    }
    if ((a1 & 0x40000) != 0)
    {
      v56 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      v57 = _NRLogIsLevelEnabled(v56, 0);

      if (v57)
      {
        v58 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v58, 0, "LinkStats: NTLWroteAllBytesToLinkOutput");

      }
    }
    if ((a1 & 0x80000) != 0)
    {
      v59 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      v60 = _NRLogIsLevelEnabled(v59, 0);

      if (v60)
      {
        v61 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v61, 0, "LinkStats: NTLMemmovingLWB");

      }
    }
    if ((a1 & 0x100000) != 0)
    {
      v62 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      v63 = _NRLogIsLevelEnabled(v62, 0);

      if (v63)
      {
        v64 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v64, 0, "LinkStats: NTLResettingLWB");

      }
    }
    if ((a1 & 0x200000) != 0)
    {
      v65 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      v66 = _NRLogIsLevelEnabled(v65, 0);

      if (v66)
      {
        v67 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v67, 0, "LinkStats: NTLLinkOutputSync");

      }
    }
    if ((a1 & 0x400000) != 0)
    {
      v68 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      v69 = _NRLogIsLevelEnabled(v68, 0);

      if (v69)
      {
        v70 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v70, 0, "LinkStats: NTLLinkChannelSync");

      }
    }
    if ((a1 & 0x800000) != 0)
    {
      v71 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      v72 = _NRLogIsLevelEnabled(v71, 0);

      if (v72)
      {
        v73 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v73, 0, "LinkStats: NTLDatagramLinkChannelSync");

      }
    }
    if ((a1 & 0x1000000) != 0)
    {
      v74 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      v75 = _NRLogIsLevelEnabled(v74, 0);

      if (v75)
      {
        v76 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v76, 0, "LinkStats: NTLNexusInputSync");

      }
    }
    v77 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
    v78 = _NRLogIsLevelEnabled(v77, 0);

    v3 = v81;
    if (v78)
    {
      v80 = (void *)_NRCopyLogObjectForNRUUID(v81, v79);
      _NRLogWithArgs(v80, 0, "LinkStats: ------------------------------");

      v3 = v81;
    }
  }

}

void sub_100098F0C(uint64_t a1, unsigned int a2)
{
  void *v3;
  NSObject *v5;
  id v6;
  char *v7;
  uint64_t v8;
  char *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t next_slot;
  uint64_t v13;
  size_t v14;
  void *v15;
  int v16;
  uint64_t v17;
  void *v18;
  id v19;
  void *v20;
  int v21;
  void *v22;
  int v23;
  void *v24;
  id v25;
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  void *v30;
  void *v31;
  int IsLevelEnabled;
  void *v33;
  id v34;
  void *v35;
  int v36;
  void *v37;
  id v38;
  void *v39;
  int v40;
  uint64_t v41;
  void *v42;
  id v43;
  void *v44;
  int v45;
  uint64_t v46;
  void *v47;
  id v48;
  id v49;
  _QWORD block[5];
  __int128 v51;
  void *__dst[2];
  __int128 v53;
  __int128 v54;

  if (!a1)
    return;
  v3 = *(void **)(a1 + 1327);
  if (!v3 || *(unsigned __int8 *)(a1 + 16) == 255)
    return;
  if (a2 >= 0x41)
  {
    v5 = *(NSObject **)(a1 + 8);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100099580;
    block[3] = &unk_1001B8AE0;
    block[4] = a1;
    dispatch_async(v5, block);
    return;
  }
  v6 = objc_msgSend(v3, "length");
  v49 = *(id *)(a1 + 1327);
  v7 = (char *)objc_msgSend(v49, "bytes");
  if (*(_QWORD *)(a1 + 975))
  {
    if (*(_QWORD *)(a1 + 959))
    {
      if (v6)
      {
        v9 = v7;
        v10 = 0;
        v11 = 0;
        while (1)
        {
          v53 = 0u;
          v54 = 0u;
          v51 = 0u;
          *(_OWORD *)__dst = 0u;
          next_slot = os_channel_get_next_slot(*(_QWORD *)(a1 + 975), v11, &v51);
          if (!next_slot)
            break;
          v13 = next_slot;
          if ((unsigned __int16)((_WORD)v6 - v10) >= WORD1(v51))
            v14 = WORD1(v51);
          else
            v14 = (unsigned __int16)((_WORD)v6 - v10);
          memcpy(__dst[0], &v9[v10], v14);
          WORD1(v51) = v14;
          v10 += v14;
          os_channel_set_slot_properties(*(_QWORD *)(a1 + 975), v13, &v51);
          v11 = v13;
          if (v10 >= (unint64_t)v6)
            goto LABEL_26;
        }
        v13 = v11;
        if (!v11)
          goto LABEL_27;
LABEL_26:
        os_channel_advance_slot(*(_QWORD *)(a1 + 975), v13);
      }
      else
      {
        v10 = 0;
      }
LABEL_27:
      os_channel_sync(*(_QWORD *)(a1 + 959), 0);
      if ((id)v10 == v6)
      {
        if (!gNRPacketLoggingEnabled)
        {
          v10 = (unint64_t)v6;
          goto LABEL_36;
        }
        v31 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v17);
        IsLevelEnabled = _NRLogIsLevelEnabled(v31, 1);

        if (IsLevelEnabled)
        {
          v33 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v17);
          v34 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v33, 1, "%s%.30s:%-4d %@: Wrote %zu bytes to the channel", "", "-[NRLinkBluetooth writeBytesToChannel:length:]", 7022, v34, v6);

        }
        v10 = (unint64_t)v6;
        if (!gNRPacketLoggingEnabled)
          goto LABEL_36;
LABEL_59:
        v35 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v17);
        v36 = _NRLogIsLevelEnabled(v35, 1);

        if (v36)
        {
          v37 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v17);
          v38 = objc_msgSend((id)a1, "copyDescription");
          _NRLogWithArgs(v37, 1, "%s%.30s:%-4d %@: wrote %lld", "", "-[NRLinkBluetooth sendDataWithCount:]", 7099, v38, v10);

        }
        goto LABEL_36;
      }
      if (!gNRPacketLoggingEnabled)
        goto LABEL_36;
      v22 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v17);
      v23 = _NRLogIsLevelEnabled(v22, 1);

      if (v23)
      {
        v24 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v17);
        v25 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v24, 1, "%s%.30s:%-4d %@: Wrote %zu bytes (but asked for %zu) to the channel", "", "-[NRLinkBluetooth writeBytesToChannel:length:]", 7020, v25, v10, v6);

        if (!gNRPacketLoggingEnabled)
          goto LABEL_36;
        goto LABEL_59;
      }
LABEL_35:
      if (!gNRPacketLoggingEnabled)
        goto LABEL_36;
      goto LABEL_59;
    }
    v20 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v8);
    v21 = _NRLogIsLevelEnabled(v20, 17);

    if (!v21)
    {
      v10 = 0;
      goto LABEL_35;
    }
    v18 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v17);
    v19 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v18, 17, "%@: Tried to write but _linkChannel is NULL", v19);
  }
  else
  {
    v15 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v8);
    v16 = _NRLogIsLevelEnabled(v15, 17);

    if (!v16)
      goto LABEL_22;
    v18 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v17);
    v19 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v18, 17, "%@: Tried to write but _linkOutputRing is NULL", v19);
  }

LABEL_22:
  v10 = 0;
  if (gNRPacketLoggingEnabled)
    goto LABEL_59;
LABEL_36:
  if ((v10 & 0x8000000000000000) != 0)
  {
    objc_msgSend((id)a1, "cancelWithReason:", CFSTR("Write error"));
  }
  else
  {
    if (gNRPacketLoggingEnabled)
    {
      v29 = objc_claimAutoreleasedReturnValue(+[NSDate date](NSDate, "date"));
      v30 = *(void **)(a1 + 1687);
      *(_QWORD *)(a1 + 1687) = v29;

    }
    *(_QWORD *)(a1 + 1383) += v10;
    if ((id)v10 == v6)
    {
      v26 = *(void **)(a1 + 1327);
      *(_QWORD *)(a1 + 1327) = 0;

      sub_10009683C(a1, a2 + 1);
    }
    else
    {
      if (v10)
        objc_msgSend(*(id *)(a1 + 1327), "replaceBytesInRange:withBytes:length:", 0, v10, 0, 0);
      if (*(_BYTE *)(a1 + 222) && *(_QWORD *)(a1 + 991))
      {
        *(_BYTE *)(a1 + 222) = 0;
        ++*(_QWORD *)(a1 + 1007);
        if (gNRPacketLoggingEnabled)
        {
          v39 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v17);
          v40 = _NRLogIsLevelEnabled(v39, 1);

          if (v40)
          {
            v42 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v41);
            v43 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v42, 1, "%s%.30s:%-4d %@: source-resume: LinkOutput", "", "NRLinkResumeLinkOutputSource", 823, v43);

          }
        }
        dispatch_resume(*(dispatch_object_t *)(a1 + 991));
      }
      v27 = a2 + 1;
      if (!*(_BYTE *)(a1 + 212) && *(_QWORD *)(a1 + 391))
      {
        *(_BYTE *)(a1 + 212) = 1;
        ++*(_QWORD *)(a1 + 415);
        if (gNRPacketLoggingEnabled)
        {
          v44 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v17);
          v45 = _NRLogIsLevelEnabled(v44, 1);

          if (v45)
          {
            v47 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v46);
            v48 = objc_msgSend((id)a1, "copyDescription");
            _NRLogWithArgs(v47, 1, "%s%.30s:%-4d %@: source-suspend: NexusInput", "", "NRLinkSuspendNexusInputSource", 832, v48);

          }
        }
        dispatch_suspend(*(dispatch_object_t *)(a1 + 391));
      }
      v28 = *(void **)(a1 + 1351);
      if (v28)
        objc_msgSend(v28, "setReceiveWindowPacketCount:", 0);
      sub_100098F0C(a1, v27);
    }
  }

}

uint64_t sub_100099580(uint64_t a1)
{
  return sub_100098F0C(*(_QWORD *)(a1 + 32), 0);
}

void sub_10009958C(uint64_t a1)
{
  char *v2;
  uint64_t v3;
  char *v4;
  int v5;
  void *v6;
  int v7;
  uint64_t v8;
  void *v9;
  id v10;
  void *v11;
  id *v12;
  char *v13;
  void *v14;
  id v15;
  void *v16;
  char *v17;
  id v18;
  int IsLevelEnabled;
  id v20;
  uint64_t v21;
  char *v22;
  int *v23;
  uint64_t v24;
  id v25;
  _QWORD v27[5];
  char *v28;
  _QWORD v29[5];
  char *v30;

  if (!*(_BYTE *)(a1 + 242) && *(unsigned __int8 *)(a1 + 210) - 10 <= 9)
  {
    v2 = sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(a1 + 32));
    if (!v2)
    {
      v18 = sub_100070AC8();
      IsLevelEnabled = _NRLogIsLevelEnabled(v18, 16);

      if (IsLevelEnabled)
      {
        v20 = sub_100070AC8();
        _NRLogWithArgs(v20, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)", "", "-[NRLinkBluetooth setupIPsecForPairingInitiatorIfNecessary]", 8721);

      }
      v21 = _os_log_pack_size(12);
      v22 = (char *)&v27[-1] - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
      v23 = __error();
      v24 = _os_log_pack_fill(v22, v21, *v23, &_mh_execute_header, "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
      *(_DWORD *)v24 = 136446210;
      *(_QWORD *)(v24 + 4) = "-[NRLinkBluetooth setupIPsecForPairingInitiatorIfNecessary]";
      v25 = sub_100070AC8();
      _NRLogAbortWithPack(v25, v22);
    }
    v4 = v2;
    v5 = *(unsigned __int8 *)(a1 + 210);
    v6 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v3);
    v7 = _NRLogIsLevelEnabled(v6, 0);

    if (v5 == 11)
    {
      if (v7)
      {
        v9 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v8);
        v10 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v9, 0, "%s%.30s:%-4d %@: Initiator querying IDS keys for pairing", "", "-[NRLinkBluetooth setupIPsecForPairingInitiatorIfNecessary]", 8724, v10);

      }
      v11 = *(void **)(a1 + 32);
      v29[0] = _NSConcreteStackBlock;
      v29[1] = 3221225472;
      v29[2] = sub_100099A28;
      v29[3] = &unk_1001B6CD8;
      v12 = (id *)&v30;
      v29[4] = a1;
      v30 = v4;
      v13 = v4;
      sub_1001390B8((uint64_t)NRDLocalDevice, v11, 4, v29);
    }
    else
    {
      if (v7)
      {
        v14 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v8);
        v15 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v14, 0, "%s%.30s:%-4d %@: Querying for pairing keys for OOBK pairing", "", "-[NRLinkBluetooth setupIPsecForPairingInitiatorIfNecessary]", 8788, v15);

      }
      v16 = *(void **)(a1 + 32);
      v27[0] = _NSConcreteStackBlock;
      v27[1] = 3221225472;
      v27[2] = sub_100099FB0;
      v27[3] = &unk_1001B6D00;
      v12 = (id *)&v28;
      v27[4] = a1;
      v28 = v4;
      v17 = v4;
      sub_1001385D4((uint64_t)NRDLocalDevice, v16, 1, v27);
    }

  }
}

void sub_1000998A4(uint64_t a1)
{
  void **WeakRetained;
  void **v2;
  char *v3;
  char *v4;
  id v5;
  int IsLevelEnabled;
  id v7;
  uint64_t v8;
  char *v9;
  int *v10;
  uint64_t v11;
  id v12;
  void **v13;

  WeakRetained = (void **)objc_loadWeakRetained((id *)(a1 + 32));
  v2 = WeakRetained;
  if (WeakRetained)
  {
    v13 = WeakRetained;
    sub_10007762C((uint64_t)WeakRetained, 3);
    v2 = v13;
    if (!*((_BYTE *)v13 + 242))
    {
      v3 = sub_10012FFF4((uint64_t)NRDLocalDevice, v13[4]);
      if (!v3)
      {
        v5 = sub_100070AC8();
        IsLevelEnabled = _NRLogIsLevelEnabled(v5, 16);

        if (IsLevelEnabled)
        {
          v7 = sub_100070AC8();
          _NRLogWithArgs(v7, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)", "", "-[NRLinkBluetooth setupIPsec]_block_invoke", 9085);

        }
        v8 = _os_log_pack_size(12);
        v9 = (char *)&v13 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
        v10 = __error();
        v11 = _os_log_pack_fill(v9, v8, *v10, &_mh_execute_header, "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
        *(_DWORD *)v11 = 136446210;
        *(_QWORD *)(v11 + 4) = "-[NRLinkBluetooth setupIPsec]_block_invoke";
        v12 = sub_100070AC8();
        _NRLogAbortWithPack(v12, v9);
      }
      v4 = v3;
      if (!v3[14] && *((unsigned __int16 *)v3 + 14) <= 0x12u)
        sub_10007762C((uint64_t)v13, 1);

      v2 = v13;
    }
  }

}

void sub_100099A28(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6)
{
  id v12;
  id v13;
  uint64_t v14;
  void *v15;
  int IsLevelEnabled;
  uint64_t v17;
  void *v18;
  id v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  id v23;
  id v24;
  id v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  id v30;
  id v31;
  id v32;
  id v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  void *v40;
  int v41;
  uint64_t v42;
  void *v43;
  id v44;
  uint64_t v45;
  void *v46;
  int v47;
  uint64_t v48;
  void *v49;
  id v50;
  void *v51;
  int v52;
  uint64_t v53;
  id v54;
  id v55;
  int v56;
  id v57;
  int v58;
  id v59;
  int v60;
  int v61;
  uint64_t v62;
  void *v63;
  id v64;
  id v65;

  v65 = a4;
  v12 = a5;
  v13 = a6;
  if (objc_msgSend(*(id *)(a1 + 32), "state") != 255)
  {
    if (a2)
    {
      if (a3)
      {
        if (v65)
        {
          v15 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v14);
          IsLevelEnabled = _NRLogIsLevelEnabled(v15, 0);

          if (IsLevelEnabled)
          {
            v18 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v17);
            v19 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
            _NRLogWithArgs(v18, 0, "%s%.30s:%-4d %@: Initiator queried IDS keys for pairing", "", "-[NRLinkBluetooth setupIPsecForPairingInitiatorIfNecessary]_block_invoke", 8742, v19);

          }
          v20 = *(_QWORD *)(a1 + 32);
          if (v20)
            objc_storeStrong((id *)(v20 + 1287), a4);
          if (v12)
          {
            v21 = *(_QWORD *)(a1 + 32);
            if (v21)
              objc_storeStrong((id *)(v21 + 1295), a5);
          }
          if (v13)
          {
            v22 = *(_QWORD *)(a1 + 32);
            if (v22)
              objc_storeStrong((id *)(v22 + 1303), a6);
          }
          v23 = objc_msgSend(objc_alloc((Class)NEIKEv2AuthenticationProtocol), "initWithNonStandardDigitalSignature:", 2);
          if (qword_1001E4950 != -1)
            dispatch_once(&qword_1001E4950, &stru_1001B7DE8);
          v24 = (id)qword_1001E4948;
          v25 = sub_10011268C(1, v24, v23);

          objc_msgSend(v25, "setLocalPrivateKeyRef:", a3);
          objc_msgSend(v25, "setRemotePublicKeyRef:", a2);
          objc_msgSend(*(id *)(a1 + 32), "reportEvent:", 3011);
          v26 = mach_absolute_time();
          v27 = *(_QWORD *)(a1 + 32);
          if (v27
            && ((v28 = *(_QWORD *)(v27 + 1863)) == 0 || (*(_QWORD *)(v28 + 112) = v26, (v27 = *(_QWORD *)(a1 + 32)) != 0)))
          {
            v29 = *(id *)(v27 + 1863);
            if (v29)
              ++v29[13];
          }
          else
          {
            v29 = 0;
          }

          v30 = sub_100112198();
          objc_msgSend(v30, "setRequestChildlessSA:", 1);
          v31 = objc_alloc((Class)NEIKEv2Session);
          v32 = sub_100112420();
          objc_msgSend(v32, "setSequencePerTrafficClass:", 1);
          objc_msgSend(v32, "setReplayWindowSize:", 16);
          v33 = objc_msgSend(v31, "initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:kernelSASessionName:packetDelegate:", v30, v32, v25, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), 0, 0, CFSTR("terminusIKEForPairingWithIDS"), *(_QWORD *)(a1 + 32));
          v34 = *(_QWORD *)(a1 + 32);
          v35 = *(void **)(v34 + 1247);
          *(_QWORD *)(v34 + 1247) = v33;

          v36 = *(_QWORD *)(a1 + 32);
          v37 = *(_QWORD *)(v36 + 1247);
          v39 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(v36 + 32), v38);
          v40 = (void *)v39;
          if (v37)
          {
            v41 = _NRLogIsLevelEnabled(v39, 0);

            if (v41)
            {
              v43 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v42);
              v44 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
              _NRLogWithArgs(v43, 0, "%s%.30s:%-4d %@: Created initiator IDS pairing IKE session", "", "-[NRLinkBluetooth setupIPsecForPairingInitiatorIfNecessary]_block_invoke", 8780, v44);

            }
            sub_1000757B4(*(_QWORD *)(a1 + 32));
            v46 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v45);
            v47 = _NRLogIsLevelEnabled(v46, 0);

            if (v47)
            {
              v49 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v48);
              v50 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
              _NRLogWithArgs(v49, 0, "%s%.30s:%-4d %@: Connecting initiator IDS pairing session", "", "-[NRLinkBluetooth setupIPsecForPairingInitiatorIfNecessary]_block_invoke", 8784, v50);

            }
            objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 1247), "connect");
          }
          else
          {
            v61 = _NRLogIsLevelEnabled(v39, 17);

            if (v61)
            {
              v63 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v62);
              v64 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
              _NRLogWithArgs(v63, 17, "%@: Failed to create initiator IDS pairing IKE session", v64);

            }
          }

        }
        else
        {
          v59 = sub_100070AC8();
          v60 = _NRLogIsLevelEnabled(v59, 17);

          if (!v60)
            goto LABEL_32;
          v23 = sub_100070AC8();
          _NRLogWithArgs(v23, 17, "%s called with null localPublicClassDKeysEncryptedWithIDS");
        }
      }
      else
      {
        v57 = sub_100070AC8();
        v58 = _NRLogIsLevelEnabled(v57, 17);

        if (!v58)
          goto LABEL_32;
        v23 = sub_100070AC8();
        _NRLogWithArgs(v23, 17, "%s called with null localPrivateIDSClassDSigningKey");
      }
    }
    else
    {
      v55 = sub_100070AC8();
      v56 = _NRLogIsLevelEnabled(v55, 17);

      if (!v56)
        goto LABEL_32;
      v23 = sub_100070AC8();
      _NRLogWithArgs(v23, 17, "%s called with null remotePublicIDSClassDSigningKey");
    }
    goto LABEL_31;
  }
  v51 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v14);
  v52 = _NRLogIsLevelEnabled(v51, 0);

  if (v52)
  {
    v23 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v53);
    v54 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    _NRLogWithArgs(v23, 0, "%s%.30s:%-4d %@: Ignoring result as link is cancelled", "", "-[NRLinkBluetooth setupIPsecForPairingInitiatorIfNecessary]_block_invoke", 8735, v54);

LABEL_31:
  }
LABEL_32:

}

void sub_100099FB0(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v8;
  id v9;
  uint64_t v10;
  void *v11;
  int IsLevelEnabled;
  uint64_t v13;
  void *v14;
  id v15;
  void *LogString;
  id v17;
  void *v18;
  void *v19;
  void *v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  id v26;
  id v27;
  id v28;
  uint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  id v40;
  id v41;
  id v42;
  id v43;
  uint64_t v44;
  void *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  void *v50;
  int v51;
  uint64_t v52;
  void *v53;
  id v54;
  uint64_t v55;
  void *v56;
  int v57;
  uint64_t v58;
  void *v59;
  id v60;
  void *v61;
  int v62;
  uint64_t v63;
  id v64;
  int v65;
  int v66;
  uint64_t v67;
  void *v68;
  id v69;
  void *v70;
  id v71;

  v71 = a2;
  v8 = a3;
  v9 = a4;
  v11 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v10);
  IsLevelEnabled = _NRLogIsLevelEnabled(v11, 0);

  if (IsLevelEnabled)
  {
    v14 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v13);
    v15 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    LogString = (void *)_NRKeyCreateLogString(v71);
    v70 = a3;
    v17 = v8;
    v18 = (void *)_NRKeyCreateLogString(v8);
    v19 = a4;
    v20 = (void *)_NRKeyCreateLogString(v9);
    _NRLogWithArgs(v14, 0, "%s%.30s:%-4d %@: Queryied for pairing keys for OOBK pairing D %@ C %@ A %@", "", "-[NRLinkBluetooth setupIPsecForPairingInitiatorIfNecessary]_block_invoke_2", 8798, v15, LogString, v18, v20);

    a4 = v19;
    v8 = v17;
    a3 = v70;

  }
  v21 = objc_msgSend(*(id *)(a1 + 32), "state");
  v23 = *(_QWORD *)(a1 + 32);
  if (v21 != 255)
  {
    if (v23)
    {
      objc_storeStrong((id *)(v23 + 1263), a2);
      v24 = *(_QWORD *)(a1 + 32);
      if (v24)
      {
        objc_storeStrong((id *)(v24 + 1271), a3);
        v25 = *(_QWORD *)(a1 + 32);
        if (v25)
          objc_storeStrong((id *)(v25 + 1279), a4);
      }
    }
    v26 = objc_msgSend(objc_alloc((Class)NEIKEv2AuthenticationProtocol), "initWithMethod:", 2);
    if (qword_1001E4960 != -1)
      dispatch_once(&qword_1001E4960, &stru_1001B7E08);
    v27 = (id)qword_1001E4958;
    v28 = sub_10011268C(1, v27, v26);

    v29 = *(_QWORD *)(a1 + 40);
    if (v29)
    {
      v30 = *(_QWORD **)(v29 + 152);
      if (v30)
        v30 = (_QWORD *)v30[2];
      v31 = v30;
    }
    else
    {
      v31 = 0;
    }
    objc_msgSend(v28, "setSharedSecret:", v31);

    v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "sharedSecret"));
    if (v32)
    {
      v33 = *(void **)(a1 + 32);
      v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "sharedSecret"));
      v35 = (void *)_NRKeyCreateLogString(v34);
      objc_msgSend(v33, "reportEvent:details:", 3013, v35);

      v36 = mach_absolute_time();
      v37 = *(_QWORD *)(a1 + 32);
      if (v37
        && ((v38 = *(_QWORD *)(v37 + 1863)) == 0 || (*(_QWORD *)(v38 + 112) = v36, (v37 = *(_QWORD *)(a1 + 32)) != 0)))
      {
        v39 = *(id *)(v37 + 1863);
        if (v39)
          ++v39[13];
      }
      else
      {
        v39 = 0;
      }

      v40 = sub_100112198();
      objc_msgSend(v40, "setRequestChildlessSA:", 1);
      v41 = objc_alloc((Class)NEIKEv2Session);
      v42 = sub_100112420();
      objc_msgSend(v42, "setSequencePerTrafficClass:", 1);
      objc_msgSend(v42, "setReplayWindowSize:", 16);
      v43 = objc_msgSend(v41, "initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:kernelSASessionName:packetDelegate:", v40, v42, v28, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), 0, 0, CFSTR("terminusIKEForPairingWithOOBKey"), *(_QWORD *)(a1 + 32));
      v44 = *(_QWORD *)(a1 + 32);
      v45 = *(void **)(v44 + 1247);
      *(_QWORD *)(v44 + 1247) = v43;

      v46 = *(_QWORD *)(a1 + 32);
      v47 = *(_QWORD *)(v46 + 1247);
      v49 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(v46 + 32), v48);
      v50 = (void *)v49;
      if (v47)
      {
        v51 = _NRLogIsLevelEnabled(v49, 0);

        if (v51)
        {
          v53 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v52);
          v54 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
          _NRLogWithArgs(v53, 0, "%s%.30s:%-4d %@: Created initiator OOBK pairing IKE session", "", "-[NRLinkBluetooth setupIPsecForPairingInitiatorIfNecessary]_block_invoke_2", 8838, v54);

        }
        sub_1000757B4(*(_QWORD *)(a1 + 32));
        v56 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v55);
        v57 = _NRLogIsLevelEnabled(v56, 0);

        if (v57)
        {
          v59 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v58);
          v60 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
          _NRLogWithArgs(v59, 0, "%s%.30s:%-4d %@: Connecting initiator OOBK pairing session", "", "-[NRLinkBluetooth setupIPsecForPairingInitiatorIfNecessary]_block_invoke_2", 8842, v60);

        }
        objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 1247), "connect");
      }
      else
      {
        v66 = _NRLogIsLevelEnabled(v49, 17);

        if (v66)
        {
          v68 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v67);
          v69 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
          _NRLogWithArgs(v68, 17, "%@: Failed to create initiator OOBK pairing IKE session", v69);

        }
      }
    }
    else
    {
      v64 = sub_100070AC8();
      v65 = _NRLogIsLevelEnabled(v64, 17);

      if (!v65)
        goto LABEL_29;
      v40 = sub_100070AC8();
      _NRLogWithArgs(v40, 17, "Missing out of band key for %@, %@", *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32));
    }

LABEL_29:
    goto LABEL_30;
  }
  v61 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v23 + 32), v22);
  v62 = _NRLogIsLevelEnabled(v61, 0);

  if (v62)
  {
    v26 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v63);
    v28 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    _NRLogWithArgs(v26, 0, "%s%.30s:%-4d %@: Ignoring result as link is cancelled", "", "-[NRLinkBluetooth setupIPsecForPairingInitiatorIfNecessary]_block_invoke_2", 8801, v28);
    goto LABEL_29;
  }
LABEL_30:

}

uint64_t sub_10009A548(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t extended;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int fd;
  uint64_t v17;
  unsigned int v18;
  dispatch_group_t v19;
  NSObject *v20;
  dispatch_source_t v21;
  void *v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  dispatch_source_t v26;
  void *v27;
  NSObject *v28;
  NSObject *v29;
  NSObject *v30;
  uint64_t IsLevelEnabled;
  NSObject *v32;
  void *v33;
  NSObject *v34;
  void *v35;
  uint64_t v36;
  void *v37;
  id v38;
  void *v39;
  int v40;
  uint64_t v41;
  void *v42;
  id v43;
  int *v44;
  void *v46;
  uint64_t v47;
  void *v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  id v52;
  int v53;
  id v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  id v59;
  int v60;
  id v61;
  uint64_t v62;
  uint64_t v63;
  id v64;
  int v65;
  id v66;
  uint64_t v67;
  int *v68;
  uint64_t v69;
  id v70;
  _QWORD block[5];
  _QWORD v72[4];
  NSObject *v73;
  _QWORD v74[5];
  _QWORD v75[4];
  NSObject *v76;
  _QWORD handler[5];
  _QWORD v78[2];

  v3 = a2;
  v4 = os_channel_attr_create();
  if (!v4)
  {
    v35 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
    IsLevelEnabled = _NRLogIsLevelEnabled(v35, 17);

    if (!(_DWORD)IsLevelEnabled)
      goto LABEL_18;
    v37 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v36);
    v38 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v37, 17, "%@: os_channel_attr_create failed", v38);
    goto LABEL_13;
  }
  v6 = v4;
  os_channel_attr_set(v4, 7, 1);
  v78[0] = 0;
  v78[1] = 0;
  objc_msgSend(v3, "getUUIDBytes:", v78);
  extended = os_channel_create_extended(v78, 0, 0, 0xFFFFFFFFLL, v6);
  if (!extended)
  {
    v39 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v8);
    v40 = _NRLogIsLevelEnabled(v39, 16);

    if (v40)
    {
      v42 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v41);
      v43 = objc_msgSend((id)a1, "copyDescription");
      v44 = __error();
      _NRLogWithArgs(v42, 16, "%s%.30s:%-4d %@: os_channel_create_extended for %@ failed (errno %d)\n", "", "-[NRLinkBluetooth setupNexusChannelVoice:]", 2213, v43, v3, *v44);

    }
    NEVirtualInterfaceDisableChannel(objc_msgSend((id)a1, "virtualInterface"));
    os_channel_attr_destroy(v6);
    goto LABEL_17;
  }
  v9 = extended;
  *(_QWORD *)(a1 + 527) = extended;
  if (!sub_1000827B0((_QWORD *)a1, v6))
  {
LABEL_17:
    IsLevelEnabled = 0;
    goto LABEL_18;
  }
  os_channel_attr_destroy(v6);
  v10 = os_channel_ring_id(*(_QWORD *)(a1 + 527), 2);
  v11 = os_channel_rx_ring(*(_QWORD *)(a1 + 527), v10);
  *(_QWORD *)(a1 + 535) = v11;
  if (!v11)
  {
    v46 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v12);
    IsLevelEnabled = _NRLogIsLevelEnabled(v46, 17);

    if (!(_DWORD)IsLevelEnabled)
      goto LABEL_18;
    v37 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v47);
    v38 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v37, 17, "%@: _nexusVOInputRing is NULL", v38);
    goto LABEL_13;
  }
  v13 = os_channel_ring_id(*(_QWORD *)(a1 + 527), 0);
  v14 = os_channel_tx_ring(*(_QWORD *)(a1 + 527), v13);
  *(_QWORD *)(a1 + 543) = v14;
  if (!v14)
  {
    v48 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v15);
    IsLevelEnabled = _NRLogIsLevelEnabled(v48, 17);

    if (!(_DWORD)IsLevelEnabled)
      goto LABEL_18;
    v37 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v49);
    v38 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v37, 17, "%@: _nexusVOOutputRing is NULL", v38);
    goto LABEL_13;
  }
  fd = os_channel_get_fd(*(_QWORD *)(a1 + 527));
  if ((fd & 0x80000000) != 0)
  {
    v50 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v17);
    IsLevelEnabled = _NRLogIsLevelEnabled(v50, 17);

    if (!(_DWORD)IsLevelEnabled)
      goto LABEL_18;
    v37 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v51);
    v38 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v37, 17, "%@: os_channel_get_fd failed", v38);
LABEL_13:

    goto LABEL_17;
  }
  v18 = fd;
  v19 = dispatch_group_create();
  if (!v19)
  {
    v52 = sub_100070AC8();
    v53 = _NRLogIsLevelEnabled(v52, 16);

    if (v53)
    {
      v54 = sub_100070AC8();
      _NRLogWithArgs(v54, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (nexusGroup) != ((void *)0)", "", "-[NRLinkBluetooth setupNexusChannelVoice:]", 2249);

    }
    v55 = _os_log_pack_size(12);
    v56 = (char *)block - ((v55 + 15) & 0xFFFFFFFFFFFFFFF0);
    v57 = *__error();
    v58 = _os_log_pack_fill(v56, v55, v57, &_mh_execute_header, "%{public}s Assertion Failed: (nexusGroup) != ((void *)0)");
    goto LABEL_31;
  }
  v20 = v19;
  v21 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, v18, 0, *(dispatch_queue_t *)(a1 + 8));
  v22 = *(void **)(a1 + 551);
  *(_QWORD *)(a1 + 551) = v21;

  v23 = *(NSObject **)(a1 + 551);
  if (!v23)
  {
    v59 = sub_100070AC8();
    v60 = _NRLogIsLevelEnabled(v59, 16);

    if (v60)
    {
      v61 = sub_100070AC8();
      _NRLogWithArgs(v61, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (_dNexusVOInputSource) != ((void *)0)", "", "-[NRLinkBluetooth setupNexusChannelVoice:]", 2253);

    }
    v62 = _os_log_pack_size(12);
    v56 = (char *)block - ((v62 + 15) & 0xFFFFFFFFFFFFFFF0);
    v63 = *__error();
    v58 = _os_log_pack_fill(v56, v62, v63, &_mh_execute_header, "%{public}s Assertion Failed: (_dNexusVOInputSource) != ((void *)0)");
LABEL_31:
    *(_DWORD *)v58 = 136446210;
    *(_QWORD *)(v58 + 4) = "-[NRLinkBluetooth setupNexusChannelVoice:]";
    goto LABEL_35;
  }
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472;
  handler[2] = sub_10009CBAC;
  handler[3] = &unk_1001B8AE0;
  handler[4] = a1;
  dispatch_source_set_event_handler(v23, handler);
  dispatch_group_enter(v20);
  v24 = *(NSObject **)(a1 + 551);
  v75[0] = _NSConcreteStackBlock;
  v75[1] = 3221225472;
  v75[2] = sub_10009CD34;
  v75[3] = &unk_1001B8AE0;
  v25 = v20;
  v76 = v25;
  dispatch_source_set_cancel_handler(v24, v75);
  dispatch_activate(*(dispatch_object_t *)(a1 + 551));
  v26 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_write, v18, 0, *(dispatch_queue_t *)(a1 + 8));
  v27 = *(void **)(a1 + 559);
  *(_QWORD *)(a1 + 559) = v26;

  v28 = *(NSObject **)(a1 + 559);
  if (!v28)
  {
    v64 = sub_100070AC8();
    v65 = _NRLogIsLevelEnabled(v64, 16);

    if (v65)
    {
      v66 = sub_100070AC8();
      _NRLogWithArgs(v66, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (_dNexusVOOutputSource) != ((void *)0)", "", "-[NRLinkBluetooth setupNexusChannelVoice:]", 2271);

    }
    v67 = _os_log_pack_size(12);
    v56 = (char *)block - ((v67 + 15) & 0xFFFFFFFFFFFFFFF0);
    v68 = __error();
    v69 = _os_log_pack_fill(v56, v67, *v68, &_mh_execute_header, "%{public}s Assertion Failed: (_dNexusVOOutputSource) != ((void *)0)");
    *(_DWORD *)v69 = 136446210;
    *(_QWORD *)(v69 + 4) = "-[NRLinkBluetooth setupNexusChannelVoice:]";
LABEL_35:
    v70 = sub_100070AC8();
    _NRLogAbortWithPack(v70, v56);
  }
  v74[0] = _NSConcreteStackBlock;
  v74[1] = 3221225472;
  v74[2] = sub_10009CD3C;
  v74[3] = &unk_1001B8AE0;
  v74[4] = a1;
  dispatch_source_set_event_handler(v28, v74);
  dispatch_group_enter(v25);
  v29 = *(NSObject **)(a1 + 559);
  v72[0] = _NSConcreteStackBlock;
  v72[1] = 3221225472;
  v72[2] = sub_10009CEB8;
  v72[3] = &unk_1001B8AE0;
  v30 = v25;
  v73 = v30;
  dispatch_source_set_cancel_handler(v29, v72);
  IsLevelEnabled = 1;
  *(_BYTE *)(a1 + 215) = 1;
  v32 = *(NSObject **)(a1 + 8);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10009CEC0;
  block[3] = &unk_1001B85D0;
  block[4] = v9;
  dispatch_group_notify(v30, v32, block);
  v33 = *(void **)(a1 + 519);
  *(_QWORD *)(a1 + 519) = v30;
  v34 = v30;

LABEL_18:
  return IsLevelEnabled;
}

uint64_t sub_10009AC8C(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t extended;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int fd;
  uint64_t v17;
  unsigned int v18;
  dispatch_group_t v19;
  NSObject *v20;
  dispatch_source_t v21;
  void *v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  dispatch_source_t v26;
  void *v27;
  NSObject *v28;
  NSObject *v29;
  NSObject *v30;
  uint64_t IsLevelEnabled;
  NSObject *v32;
  void *v33;
  NSObject *v34;
  void *v35;
  uint64_t v36;
  void *v37;
  id v38;
  void *v39;
  int v40;
  uint64_t v41;
  void *v42;
  id v43;
  int *v44;
  void *v46;
  uint64_t v47;
  void *v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  id v52;
  int v53;
  id v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  id v59;
  int v60;
  id v61;
  uint64_t v62;
  uint64_t v63;
  id v64;
  int v65;
  id v66;
  uint64_t v67;
  int *v68;
  uint64_t v69;
  id v70;
  _QWORD block[5];
  _QWORD v72[4];
  NSObject *v73;
  _QWORD v74[5];
  _QWORD v75[4];
  NSObject *v76;
  _QWORD handler[5];
  _QWORD v78[2];

  v3 = a2;
  v4 = os_channel_attr_create();
  if (!v4)
  {
    v35 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
    IsLevelEnabled = _NRLogIsLevelEnabled(v35, 17);

    if (!(_DWORD)IsLevelEnabled)
      goto LABEL_18;
    v37 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v36);
    v38 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v37, 17, "%@: os_channel_attr_create failed", v38);
    goto LABEL_13;
  }
  v6 = v4;
  os_channel_attr_set(v4, 7, 1);
  v78[0] = 0;
  v78[1] = 0;
  objc_msgSend(v3, "getUUIDBytes:", v78);
  extended = os_channel_create_extended(v78, 0, 0, 0xFFFFFFFFLL, v6);
  if (!extended)
  {
    v39 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v8);
    v40 = _NRLogIsLevelEnabled(v39, 16);

    if (v40)
    {
      v42 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v41);
      v43 = objc_msgSend((id)a1, "copyDescription");
      v44 = __error();
      _NRLogWithArgs(v42, 16, "%s%.30s:%-4d %@: os_channel_create_extended for %@ failed (errno %d)\n", "", "-[NRLinkBluetooth setupNexusChannelVideo:]", 1923, v43, v3, *v44);

    }
    NEVirtualInterfaceDisableChannel(objc_msgSend((id)a1, "virtualInterface"));
    os_channel_attr_destroy(v6);
    goto LABEL_17;
  }
  v9 = extended;
  *(_QWORD *)(a1 + 671) = extended;
  if (!sub_1000827B0((_QWORD *)a1, v6))
  {
LABEL_17:
    IsLevelEnabled = 0;
    goto LABEL_18;
  }
  os_channel_attr_destroy(v6);
  v10 = os_channel_ring_id(*(_QWORD *)(a1 + 671), 2);
  v11 = os_channel_rx_ring(*(_QWORD *)(a1 + 671), v10);
  *(_QWORD *)(a1 + 679) = v11;
  if (!v11)
  {
    v46 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v12);
    IsLevelEnabled = _NRLogIsLevelEnabled(v46, 17);

    if (!(_DWORD)IsLevelEnabled)
      goto LABEL_18;
    v37 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v47);
    v38 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v37, 17, "%@: _nexusVIInputRing is NULL", v38);
    goto LABEL_13;
  }
  v13 = os_channel_ring_id(*(_QWORD *)(a1 + 671), 0);
  v14 = os_channel_tx_ring(*(_QWORD *)(a1 + 671), v13);
  *(_QWORD *)(a1 + 687) = v14;
  if (!v14)
  {
    v48 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v15);
    IsLevelEnabled = _NRLogIsLevelEnabled(v48, 17);

    if (!(_DWORD)IsLevelEnabled)
      goto LABEL_18;
    v37 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v49);
    v38 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v37, 17, "%@: _nexusVIOutputRing is NULL", v38);
    goto LABEL_13;
  }
  fd = os_channel_get_fd(*(_QWORD *)(a1 + 671));
  if ((fd & 0x80000000) != 0)
  {
    v50 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v17);
    IsLevelEnabled = _NRLogIsLevelEnabled(v50, 17);

    if (!(_DWORD)IsLevelEnabled)
      goto LABEL_18;
    v37 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v51);
    v38 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v37, 17, "%@: os_channel_get_fd failed", v38);
LABEL_13:

    goto LABEL_17;
  }
  v18 = fd;
  v19 = dispatch_group_create();
  if (!v19)
  {
    v52 = sub_100070AC8();
    v53 = _NRLogIsLevelEnabled(v52, 16);

    if (v53)
    {
      v54 = sub_100070AC8();
      _NRLogWithArgs(v54, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (nexusGroup) != ((void *)0)", "", "-[NRLinkBluetooth setupNexusChannelVideo:]", 1959);

    }
    v55 = _os_log_pack_size(12);
    v56 = (char *)block - ((v55 + 15) & 0xFFFFFFFFFFFFFFF0);
    v57 = *__error();
    v58 = _os_log_pack_fill(v56, v55, v57, &_mh_execute_header, "%{public}s Assertion Failed: (nexusGroup) != ((void *)0)");
    goto LABEL_31;
  }
  v20 = v19;
  v21 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, v18, 0, *(dispatch_queue_t *)(a1 + 8));
  v22 = *(void **)(a1 + 695);
  *(_QWORD *)(a1 + 695) = v21;

  v23 = *(NSObject **)(a1 + 695);
  if (!v23)
  {
    v59 = sub_100070AC8();
    v60 = _NRLogIsLevelEnabled(v59, 16);

    if (v60)
    {
      v61 = sub_100070AC8();
      _NRLogWithArgs(v61, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (_dNexusVIInputSource) != ((void *)0)", "", "-[NRLinkBluetooth setupNexusChannelVideo:]", 1963);

    }
    v62 = _os_log_pack_size(12);
    v56 = (char *)block - ((v62 + 15) & 0xFFFFFFFFFFFFFFF0);
    v63 = *__error();
    v58 = _os_log_pack_fill(v56, v62, v63, &_mh_execute_header, "%{public}s Assertion Failed: (_dNexusVIInputSource) != ((void *)0)");
LABEL_31:
    *(_DWORD *)v58 = 136446210;
    *(_QWORD *)(v58 + 4) = "-[NRLinkBluetooth setupNexusChannelVideo:]";
    goto LABEL_35;
  }
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472;
  handler[2] = sub_10009C890;
  handler[3] = &unk_1001B8AE0;
  handler[4] = a1;
  dispatch_source_set_event_handler(v23, handler);
  dispatch_group_enter(v20);
  v24 = *(NSObject **)(a1 + 695);
  v75[0] = _NSConcreteStackBlock;
  v75[1] = 3221225472;
  v75[2] = sub_10009CA18;
  v75[3] = &unk_1001B8AE0;
  v25 = v20;
  v76 = v25;
  dispatch_source_set_cancel_handler(v24, v75);
  dispatch_activate(*(dispatch_object_t *)(a1 + 695));
  v26 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_write, v18, 0, *(dispatch_queue_t *)(a1 + 8));
  v27 = *(void **)(a1 + 703);
  *(_QWORD *)(a1 + 703) = v26;

  v28 = *(NSObject **)(a1 + 703);
  if (!v28)
  {
    v64 = sub_100070AC8();
    v65 = _NRLogIsLevelEnabled(v64, 16);

    if (v65)
    {
      v66 = sub_100070AC8();
      _NRLogWithArgs(v66, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (_dNexusVIOutputSource) != ((void *)0)", "", "-[NRLinkBluetooth setupNexusChannelVideo:]", 1981);

    }
    v67 = _os_log_pack_size(12);
    v56 = (char *)block - ((v67 + 15) & 0xFFFFFFFFFFFFFFF0);
    v68 = __error();
    v69 = _os_log_pack_fill(v56, v67, *v68, &_mh_execute_header, "%{public}s Assertion Failed: (_dNexusVIOutputSource) != ((void *)0)");
    *(_DWORD *)v69 = 136446210;
    *(_QWORD *)(v69 + 4) = "-[NRLinkBluetooth setupNexusChannelVideo:]";
LABEL_35:
    v70 = sub_100070AC8();
    _NRLogAbortWithPack(v70, v56);
  }
  v74[0] = _NSConcreteStackBlock;
  v74[1] = 3221225472;
  v74[2] = sub_10009CA20;
  v74[3] = &unk_1001B8AE0;
  v74[4] = a1;
  dispatch_source_set_event_handler(v28, v74);
  dispatch_group_enter(v25);
  v29 = *(NSObject **)(a1 + 703);
  v72[0] = _NSConcreteStackBlock;
  v72[1] = 3221225472;
  v72[2] = sub_10009CB9C;
  v72[3] = &unk_1001B8AE0;
  v30 = v25;
  v73 = v30;
  dispatch_source_set_cancel_handler(v29, v72);
  IsLevelEnabled = 1;
  *(_BYTE *)(a1 + 217) = 1;
  v32 = *(NSObject **)(a1 + 8);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10009CBA4;
  block[3] = &unk_1001B85D0;
  block[4] = v9;
  dispatch_group_notify(v30, v32, block);
  v33 = *(void **)(a1 + 663);
  *(_QWORD *)(a1 + 663) = v30;
  v34 = v30;

LABEL_18:
  return IsLevelEnabled;
}

uint64_t sub_10009B3D0(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t extended;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int fd;
  uint64_t v17;
  unsigned int v18;
  dispatch_group_t v19;
  NSObject *v20;
  dispatch_source_t v21;
  void *v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  dispatch_source_t v26;
  void *v27;
  NSObject *v28;
  NSObject *v29;
  NSObject *v30;
  uint64_t IsLevelEnabled;
  NSObject *v32;
  void *v33;
  NSObject *v34;
  void *v35;
  uint64_t v36;
  void *v37;
  id v38;
  void *v39;
  int v40;
  uint64_t v41;
  void *v42;
  id v43;
  int *v44;
  void *v46;
  uint64_t v47;
  void *v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  id v52;
  int v53;
  id v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  id v59;
  int v60;
  id v61;
  uint64_t v62;
  uint64_t v63;
  id v64;
  int v65;
  id v66;
  uint64_t v67;
  int *v68;
  uint64_t v69;
  id v70;
  _QWORD block[5];
  _QWORD v72[4];
  NSObject *v73;
  _QWORD v74[5];
  _QWORD v75[4];
  NSObject *v76;
  _QWORD handler[5];
  _QWORD v78[2];

  v3 = a2;
  v4 = os_channel_attr_create();
  if (!v4)
  {
    v35 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
    IsLevelEnabled = _NRLogIsLevelEnabled(v35, 17);

    if (!(_DWORD)IsLevelEnabled)
      goto LABEL_18;
    v37 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v36);
    v38 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v37, 17, "%@: os_channel_attr_create failed", v38);
    goto LABEL_13;
  }
  v6 = v4;
  os_channel_attr_set(v4, 7, 1);
  v78[0] = 0;
  v78[1] = 0;
  objc_msgSend(v3, "getUUIDBytes:", v78);
  extended = os_channel_create_extended(v78, 0, 0, 0xFFFFFFFFLL, v6);
  if (!extended)
  {
    v39 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v8);
    v40 = _NRLogIsLevelEnabled(v39, 16);

    if (v40)
    {
      v42 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v41);
      v43 = objc_msgSend((id)a1, "copyDescription");
      v44 = __error();
      _NRLogWithArgs(v42, 16, "%s%.30s:%-4d %@: os_channel_create_extended for %@ failed (errno %d)\n", "", "-[NRLinkBluetooth setupNexusChannelBestEffort:]", 2117, v43, v3, *v44);

    }
    NEVirtualInterfaceDisableChannel(objc_msgSend((id)a1, "virtualInterface"));
    os_channel_attr_destroy(v6);
    goto LABEL_17;
  }
  v9 = extended;
  *(_QWORD *)(a1 + 367) = extended;
  if (!sub_1000827B0((_QWORD *)a1, v6))
  {
LABEL_17:
    IsLevelEnabled = 0;
    goto LABEL_18;
  }
  os_channel_attr_destroy(v6);
  v10 = os_channel_ring_id(*(_QWORD *)(a1 + 367), 2);
  v11 = os_channel_rx_ring(*(_QWORD *)(a1 + 367), v10);
  *(_QWORD *)(a1 + 375) = v11;
  if (!v11)
  {
    v46 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v12);
    IsLevelEnabled = _NRLogIsLevelEnabled(v46, 17);

    if (!(_DWORD)IsLevelEnabled)
      goto LABEL_18;
    v37 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v47);
    v38 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v37, 17, "%@: _nexusInputRing is NULL", v38);
    goto LABEL_13;
  }
  v13 = os_channel_ring_id(*(_QWORD *)(a1 + 367), 0);
  v14 = os_channel_tx_ring(*(_QWORD *)(a1 + 367), v13);
  *(_QWORD *)(a1 + 383) = v14;
  if (!v14)
  {
    v48 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v15);
    IsLevelEnabled = _NRLogIsLevelEnabled(v48, 17);

    if (!(_DWORD)IsLevelEnabled)
      goto LABEL_18;
    v37 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v49);
    v38 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v37, 17, "%@: _nexusOutputRing is NULL", v38);
    goto LABEL_13;
  }
  fd = os_channel_get_fd(*(_QWORD *)(a1 + 367));
  if ((fd & 0x80000000) != 0)
  {
    v50 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v17);
    IsLevelEnabled = _NRLogIsLevelEnabled(v50, 17);

    if (!(_DWORD)IsLevelEnabled)
      goto LABEL_18;
    v37 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v51);
    v38 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v37, 17, "%@: os_channel_get_fd failed", v38);
LABEL_13:

    goto LABEL_17;
  }
  v18 = fd;
  v19 = dispatch_group_create();
  if (!v19)
  {
    v52 = sub_100070AC8();
    v53 = _NRLogIsLevelEnabled(v52, 16);

    if (v53)
    {
      v54 = sub_100070AC8();
      _NRLogWithArgs(v54, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (nexusGroup) != ((void *)0)", "", "-[NRLinkBluetooth setupNexusChannelBestEffort:]", 2153);

    }
    v55 = _os_log_pack_size(12);
    v56 = (char *)block - ((v55 + 15) & 0xFFFFFFFFFFFFFFF0);
    v57 = *__error();
    v58 = _os_log_pack_fill(v56, v55, v57, &_mh_execute_header, "%{public}s Assertion Failed: (nexusGroup) != ((void *)0)");
    goto LABEL_31;
  }
  v20 = v19;
  v21 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, v18, 0, *(dispatch_queue_t *)(a1 + 8));
  v22 = *(void **)(a1 + 391);
  *(_QWORD *)(a1 + 391) = v21;

  v23 = *(NSObject **)(a1 + 391);
  if (!v23)
  {
    v59 = sub_100070AC8();
    v60 = _NRLogIsLevelEnabled(v59, 16);

    if (v60)
    {
      v61 = sub_100070AC8();
      _NRLogWithArgs(v61, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (_dNexusInputSource) != ((void *)0)", "", "-[NRLinkBluetooth setupNexusChannelBestEffort:]", 2156);

    }
    v62 = _os_log_pack_size(12);
    v56 = (char *)block - ((v62 + 15) & 0xFFFFFFFFFFFFFFF0);
    v63 = *__error();
    v58 = _os_log_pack_fill(v56, v62, v63, &_mh_execute_header, "%{public}s Assertion Failed: (_dNexusInputSource) != ((void *)0)");
LABEL_31:
    *(_DWORD *)v58 = 136446210;
    *(_QWORD *)(v58 + 4) = "-[NRLinkBluetooth setupNexusChannelBestEffort:]";
    goto LABEL_35;
  }
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472;
  handler[2] = sub_10009C574;
  handler[3] = &unk_1001B8AE0;
  handler[4] = a1;
  dispatch_source_set_event_handler(v23, handler);
  dispatch_group_enter(v20);
  v24 = *(NSObject **)(a1 + 391);
  v75[0] = _NSConcreteStackBlock;
  v75[1] = 3221225472;
  v75[2] = sub_10009C6FC;
  v75[3] = &unk_1001B8AE0;
  v25 = v20;
  v76 = v25;
  dispatch_source_set_cancel_handler(v24, v75);
  dispatch_activate(*(dispatch_object_t *)(a1 + 391));
  v26 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_write, v18, 0, *(dispatch_queue_t *)(a1 + 8));
  v27 = *(void **)(a1 + 399);
  *(_QWORD *)(a1 + 399) = v26;

  v28 = *(NSObject **)(a1 + 399);
  if (!v28)
  {
    v64 = sub_100070AC8();
    v65 = _NRLogIsLevelEnabled(v64, 16);

    if (v65)
    {
      v66 = sub_100070AC8();
      _NRLogWithArgs(v66, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (_dNexusOutputSource) != ((void *)0)", "", "-[NRLinkBluetooth setupNexusChannelBestEffort:]", 2174);

    }
    v67 = _os_log_pack_size(12);
    v56 = (char *)block - ((v67 + 15) & 0xFFFFFFFFFFFFFFF0);
    v68 = __error();
    v69 = _os_log_pack_fill(v56, v67, *v68, &_mh_execute_header, "%{public}s Assertion Failed: (_dNexusOutputSource) != ((void *)0)");
    *(_DWORD *)v69 = 136446210;
    *(_QWORD *)(v69 + 4) = "-[NRLinkBluetooth setupNexusChannelBestEffort:]";
LABEL_35:
    v70 = sub_100070AC8();
    _NRLogAbortWithPack(v70, v56);
  }
  v74[0] = _NSConcreteStackBlock;
  v74[1] = 3221225472;
  v74[2] = sub_10009C704;
  v74[3] = &unk_1001B8AE0;
  v74[4] = a1;
  dispatch_source_set_event_handler(v28, v74);
  dispatch_group_enter(v25);
  v29 = *(NSObject **)(a1 + 399);
  v72[0] = _NSConcreteStackBlock;
  v72[1] = 3221225472;
  v72[2] = sub_10009C880;
  v72[3] = &unk_1001B8AE0;
  v30 = v25;
  v73 = v30;
  dispatch_source_set_cancel_handler(v29, v72);
  IsLevelEnabled = 1;
  *(_BYTE *)(a1 + 213) = 1;
  v32 = *(NSObject **)(a1 + 8);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10009C888;
  block[3] = &unk_1001B85D0;
  block[4] = v9;
  dispatch_group_notify(v30, v32, block);
  v33 = *(void **)(a1 + 407);
  *(_QWORD *)(a1 + 407) = v30;
  v34 = v30;

LABEL_18:
  return IsLevelEnabled;
}

uint64_t sub_10009BB14(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t extended;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int fd;
  uint64_t v17;
  unsigned int v18;
  dispatch_group_t v19;
  NSObject *v20;
  dispatch_source_t v21;
  void *v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  dispatch_source_t v26;
  void *v27;
  NSObject *v28;
  NSObject *v29;
  NSObject *v30;
  uint64_t IsLevelEnabled;
  NSObject *v32;
  void *v33;
  NSObject *v34;
  void *v35;
  uint64_t v36;
  void *v37;
  id v38;
  void *v39;
  int v40;
  uint64_t v41;
  void *v42;
  id v43;
  int *v44;
  void *v46;
  uint64_t v47;
  void *v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  id v52;
  int v53;
  id v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  id v59;
  int v60;
  id v61;
  uint64_t v62;
  uint64_t v63;
  id v64;
  int v65;
  id v66;
  uint64_t v67;
  int *v68;
  uint64_t v69;
  id v70;
  _QWORD block[5];
  _QWORD v72[4];
  NSObject *v73;
  _QWORD v74[5];
  _QWORD v75[4];
  NSObject *v76;
  _QWORD handler[5];
  _QWORD v78[2];

  v3 = a2;
  v4 = os_channel_attr_create();
  if (!v4)
  {
    v35 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
    IsLevelEnabled = _NRLogIsLevelEnabled(v35, 17);

    if (!(_DWORD)IsLevelEnabled)
      goto LABEL_18;
    v37 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v36);
    v38 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v37, 17, "%@: os_channel_attr_create failed", v38);
    goto LABEL_13;
  }
  v6 = v4;
  os_channel_attr_set(v4, 7, 1);
  v78[0] = 0;
  v78[1] = 0;
  objc_msgSend(v3, "getUUIDBytes:", v78);
  extended = os_channel_create_extended(v78, 0, 0, 0xFFFFFFFFLL, v6);
  if (!extended)
  {
    v39 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v8);
    v40 = _NRLogIsLevelEnabled(v39, 16);

    if (v40)
    {
      v42 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v41);
      v43 = objc_msgSend((id)a1, "copyDescription");
      v44 = __error();
      _NRLogWithArgs(v42, 16, "%s%.30s:%-4d %@: os_channel_create_extended for %@ failed (errno %d)\n", "", "-[NRLinkBluetooth setupNexusChannelBackground:]", 2020, v43, v3, *v44);

    }
    NEVirtualInterfaceDisableChannel(objc_msgSend((id)a1, "virtualInterface"));
    os_channel_attr_destroy(v6);
    goto LABEL_17;
  }
  v9 = extended;
  *(_QWORD *)(a1 + 815) = extended;
  if (!sub_1000827B0((_QWORD *)a1, v6))
  {
LABEL_17:
    IsLevelEnabled = 0;
    goto LABEL_18;
  }
  os_channel_attr_destroy(v6);
  v10 = os_channel_ring_id(*(_QWORD *)(a1 + 815), 2);
  v11 = os_channel_rx_ring(*(_QWORD *)(a1 + 815), v10);
  *(_QWORD *)(a1 + 823) = v11;
  if (!v11)
  {
    v46 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v12);
    IsLevelEnabled = _NRLogIsLevelEnabled(v46, 17);

    if (!(_DWORD)IsLevelEnabled)
      goto LABEL_18;
    v37 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v47);
    v38 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v37, 17, "%@: _nexusBKInputRing is NULL", v38);
    goto LABEL_13;
  }
  v13 = os_channel_ring_id(*(_QWORD *)(a1 + 815), 0);
  v14 = os_channel_tx_ring(*(_QWORD *)(a1 + 815), v13);
  *(_QWORD *)(a1 + 831) = v14;
  if (!v14)
  {
    v48 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v15);
    IsLevelEnabled = _NRLogIsLevelEnabled(v48, 17);

    if (!(_DWORD)IsLevelEnabled)
      goto LABEL_18;
    v37 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v49);
    v38 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v37, 17, "%@: _nexusBKOutputRing is NULL", v38);
    goto LABEL_13;
  }
  fd = os_channel_get_fd(*(_QWORD *)(a1 + 815));
  if ((fd & 0x80000000) != 0)
  {
    v50 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v17);
    IsLevelEnabled = _NRLogIsLevelEnabled(v50, 17);

    if (!(_DWORD)IsLevelEnabled)
      goto LABEL_18;
    v37 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v51);
    v38 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v37, 17, "%@: os_channel_get_fd failed", v38);
LABEL_13:

    goto LABEL_17;
  }
  v18 = fd;
  v19 = dispatch_group_create();
  if (!v19)
  {
    v52 = sub_100070AC8();
    v53 = _NRLogIsLevelEnabled(v52, 16);

    if (v53)
    {
      v54 = sub_100070AC8();
      _NRLogWithArgs(v54, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (nexusGroup) != ((void *)0)", "", "-[NRLinkBluetooth setupNexusChannelBackground:]", 2056);

    }
    v55 = _os_log_pack_size(12);
    v56 = (char *)block - ((v55 + 15) & 0xFFFFFFFFFFFFFFF0);
    v57 = *__error();
    v58 = _os_log_pack_fill(v56, v55, v57, &_mh_execute_header, "%{public}s Assertion Failed: (nexusGroup) != ((void *)0)");
    goto LABEL_31;
  }
  v20 = v19;
  v21 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, v18, 0, *(dispatch_queue_t *)(a1 + 8));
  v22 = *(void **)(a1 + 839);
  *(_QWORD *)(a1 + 839) = v21;

  v23 = *(NSObject **)(a1 + 839);
  if (!v23)
  {
    v59 = sub_100070AC8();
    v60 = _NRLogIsLevelEnabled(v59, 16);

    if (v60)
    {
      v61 = sub_100070AC8();
      _NRLogWithArgs(v61, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (_dNexusBKInputSource) != ((void *)0)", "", "-[NRLinkBluetooth setupNexusChannelBackground:]", 2060);

    }
    v62 = _os_log_pack_size(12);
    v56 = (char *)block - ((v62 + 15) & 0xFFFFFFFFFFFFFFF0);
    v63 = *__error();
    v58 = _os_log_pack_fill(v56, v62, v63, &_mh_execute_header, "%{public}s Assertion Failed: (_dNexusBKInputSource) != ((void *)0)");
LABEL_31:
    *(_DWORD *)v58 = 136446210;
    *(_QWORD *)(v58 + 4) = "-[NRLinkBluetooth setupNexusChannelBackground:]";
    goto LABEL_35;
  }
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472;
  handler[2] = sub_10009C258;
  handler[3] = &unk_1001B8AE0;
  handler[4] = a1;
  dispatch_source_set_event_handler(v23, handler);
  dispatch_group_enter(v20);
  v24 = *(NSObject **)(a1 + 839);
  v75[0] = _NSConcreteStackBlock;
  v75[1] = 3221225472;
  v75[2] = sub_10009C3E0;
  v75[3] = &unk_1001B8AE0;
  v25 = v20;
  v76 = v25;
  dispatch_source_set_cancel_handler(v24, v75);
  dispatch_activate(*(dispatch_object_t *)(a1 + 839));
  v26 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_write, v18, 0, *(dispatch_queue_t *)(a1 + 8));
  v27 = *(void **)(a1 + 847);
  *(_QWORD *)(a1 + 847) = v26;

  v28 = *(NSObject **)(a1 + 847);
  if (!v28)
  {
    v64 = sub_100070AC8();
    v65 = _NRLogIsLevelEnabled(v64, 16);

    if (v65)
    {
      v66 = sub_100070AC8();
      _NRLogWithArgs(v66, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (_dNexusBKOutputSource) != ((void *)0)", "", "-[NRLinkBluetooth setupNexusChannelBackground:]", 2078);

    }
    v67 = _os_log_pack_size(12);
    v56 = (char *)block - ((v67 + 15) & 0xFFFFFFFFFFFFFFF0);
    v68 = __error();
    v69 = _os_log_pack_fill(v56, v67, *v68, &_mh_execute_header, "%{public}s Assertion Failed: (_dNexusBKOutputSource) != ((void *)0)");
    *(_DWORD *)v69 = 136446210;
    *(_QWORD *)(v69 + 4) = "-[NRLinkBluetooth setupNexusChannelBackground:]";
LABEL_35:
    v70 = sub_100070AC8();
    _NRLogAbortWithPack(v70, v56);
  }
  v74[0] = _NSConcreteStackBlock;
  v74[1] = 3221225472;
  v74[2] = sub_10009C3E8;
  v74[3] = &unk_1001B8AE0;
  v74[4] = a1;
  dispatch_source_set_event_handler(v28, v74);
  dispatch_group_enter(v25);
  v29 = *(NSObject **)(a1 + 847);
  v72[0] = _NSConcreteStackBlock;
  v72[1] = 3221225472;
  v72[2] = sub_10009C564;
  v72[3] = &unk_1001B8AE0;
  v30 = v25;
  v73 = v30;
  dispatch_source_set_cancel_handler(v29, v72);
  IsLevelEnabled = 1;
  *(_BYTE *)(a1 + 219) = 1;
  v32 = *(NSObject **)(a1 + 8);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10009C56C;
  block[3] = &unk_1001B85D0;
  block[4] = v9;
  dispatch_group_notify(v30, v32, block);
  v33 = *(void **)(a1 + 807);
  *(_QWORD *)(a1 + 807) = v30;
  v34 = v30;

LABEL_18:
  return IsLevelEnabled;
}

void sub_10009C258(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  int IsLevelEnabled;
  uint64_t v6;
  id v7;
  void *v8;
  int v9;
  uint64_t v10;
  void *v11;
  id v12;
  id v13;

  v3 = *(_QWORD *)(a1 + 32);
  if (*(unsigned __int8 *)(v3 + 16) == 255)
  {
    v4 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), a2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v4, 16);

    if (IsLevelEnabled)
    {
      v13 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v6);
      v7 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
      _NRLogWithArgs(v13, 16, "%s%.30s:%-4d %@: Nexus BK input available but cancelled", "", "-[NRLinkBluetooth setupNexusChannelBackground:]_block_invoke", 2063, v7);

    }
  }
  else
  {
    ++*(_QWORD *)(v3 + 887);
    if (gNRPacketLoggingEnabled)
    {
      v8 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), a2);
      v9 = _NRLogIsLevelEnabled(v8, 1);

      if (v9)
      {
        v11 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v10);
        v12 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
        _NRLogWithArgs(v11, 1, "%s%.30s:%-4d %@: Nexus BK input available", "", "-[NRLinkBluetooth setupNexusChannelBackground:]_block_invoke", 2067, v12);

      }
    }
    sub_100071380(*(void **)(a1 + 32), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 815));
  }
}

void sub_10009C3E0(uint64_t a1)
{
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_10009C3E8(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  int IsLevelEnabled;
  uint64_t v6;
  id v7;
  void *v8;
  int v9;
  uint64_t v10;
  void *v11;
  id v12;
  id v13;

  v3 = *(_QWORD *)(a1 + 32);
  if (*(unsigned __int8 *)(v3 + 16) == 255)
  {
    v4 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), a2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v4, 16);

    if (IsLevelEnabled)
    {
      v13 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v6);
      v7 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
      _NRLogWithArgs(v13, 16, "%s%.30s:%-4d %@: Nexus BK output available but cancelled", "", "-[NRLinkBluetooth setupNexusChannelBackground:]_block_invoke", 2081, v7);

    }
  }
  else
  {
    ++*(_QWORD *)(v3 + 895);
    if (gNRPacketLoggingEnabled)
    {
      v8 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), a2);
      v9 = _NRLogIsLevelEnabled(v8, 1);

      if (v9)
      {
        v11 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v10);
        v12 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
        _NRLogWithArgs(v11, 1, "%s%.30s:%-4d %@: Nexus BK output available", "", "-[NRLinkBluetooth setupNexusChannelBackground:]_block_invoke", 2085, v12);

      }
    }
    sub_100091008(*(void **)(a1 + 32));
  }
}

void sub_10009C564(uint64_t a1)
{
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

uint64_t sub_10009C56C(uint64_t a1)
{
  return os_channel_destroy(*(_QWORD *)(a1 + 32));
}

void sub_10009C574(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  int IsLevelEnabled;
  uint64_t v6;
  id v7;
  void *v8;
  int v9;
  uint64_t v10;
  void *v11;
  id v12;
  id v13;

  v3 = *(_QWORD *)(a1 + 32);
  if (*(unsigned __int8 *)(v3 + 16) == 255)
  {
    v4 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), a2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v4, 16);

    if (IsLevelEnabled)
    {
      v13 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v6);
      v7 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
      _NRLogWithArgs(v13, 16, "%s%.30s:%-4d %@: Nexus input available but cancelled", "", "-[NRLinkBluetooth setupNexusChannelBestEffort:]_block_invoke", 2159, v7);

    }
  }
  else
  {
    ++*(_QWORD *)(v3 + 455);
    if (gNRPacketLoggingEnabled)
    {
      v8 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), a2);
      v9 = _NRLogIsLevelEnabled(v8, 1);

      if (v9)
      {
        v11 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v10);
        v12 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
        _NRLogWithArgs(v11, 1, "%s%.30s:%-4d %@: Nexus input available", "", "-[NRLinkBluetooth setupNexusChannelBestEffort:]_block_invoke", 2163, v12);

      }
    }
    sub_100071380(*(void **)(a1 + 32), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 367));
  }
}

void sub_10009C6FC(uint64_t a1)
{
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_10009C704(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  int IsLevelEnabled;
  uint64_t v6;
  id v7;
  void *v8;
  int v9;
  uint64_t v10;
  void *v11;
  id v12;
  id v13;

  v3 = *(_QWORD *)(a1 + 32);
  if (*(unsigned __int8 *)(v3 + 16) == 255)
  {
    v4 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), a2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v4, 16);

    if (IsLevelEnabled)
    {
      v13 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v6);
      v7 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
      _NRLogWithArgs(v13, 16, "%s%.30s:%-4d %@: Nexus output available but cancelled", "", "-[NRLinkBluetooth setupNexusChannelBestEffort:]_block_invoke", 2177, v7);

    }
  }
  else
  {
    ++*(_QWORD *)(v3 + 463);
    if (gNRPacketLoggingEnabled)
    {
      v8 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), a2);
      v9 = _NRLogIsLevelEnabled(v8, 1);

      if (v9)
      {
        v11 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v10);
        v12 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
        _NRLogWithArgs(v11, 1, "%s%.30s:%-4d %@: Nexus output available", "", "-[NRLinkBluetooth setupNexusChannelBestEffort:]_block_invoke", 2181, v12);

      }
    }
    sub_100091008(*(void **)(a1 + 32));
  }
}

void sub_10009C880(uint64_t a1)
{
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

uint64_t sub_10009C888(uint64_t a1)
{
  return os_channel_destroy(*(_QWORD *)(a1 + 32));
}

void sub_10009C890(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  int IsLevelEnabled;
  uint64_t v6;
  id v7;
  void *v8;
  int v9;
  uint64_t v10;
  void *v11;
  id v12;
  id v13;

  v3 = *(_QWORD *)(a1 + 32);
  if (*(unsigned __int8 *)(v3 + 16) == 255)
  {
    v4 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), a2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v4, 16);

    if (IsLevelEnabled)
    {
      v13 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v6);
      v7 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
      _NRLogWithArgs(v13, 16, "%s%.30s:%-4d %@: Nexus VI input available but cancelled", "", "-[NRLinkBluetooth setupNexusChannelVideo:]_block_invoke", 1966, v7);

    }
  }
  else
  {
    ++*(_QWORD *)(v3 + 743);
    if (gNRPacketLoggingEnabled)
    {
      v8 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), a2);
      v9 = _NRLogIsLevelEnabled(v8, 1);

      if (v9)
      {
        v11 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v10);
        v12 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
        _NRLogWithArgs(v11, 1, "%s%.30s:%-4d %@: Nexus VI input available", "", "-[NRLinkBluetooth setupNexusChannelVideo:]_block_invoke", 1970, v12);

      }
    }
    sub_100083E50(*(void **)(a1 + 32), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 671));
  }
}

void sub_10009CA18(uint64_t a1)
{
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_10009CA20(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  int IsLevelEnabled;
  uint64_t v6;
  id v7;
  void *v8;
  int v9;
  uint64_t v10;
  void *v11;
  id v12;
  id v13;

  v3 = *(_QWORD *)(a1 + 32);
  if (*(unsigned __int8 *)(v3 + 16) == 255)
  {
    v4 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), a2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v4, 16);

    if (IsLevelEnabled)
    {
      v13 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v6);
      v7 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
      _NRLogWithArgs(v13, 16, "%s%.30s:%-4d %@: Nexus VI output available but cancelled", "", "-[NRLinkBluetooth setupNexusChannelVideo:]_block_invoke", 1984, v7);

    }
  }
  else
  {
    ++*(_QWORD *)(v3 + 751);
    if (gNRPacketLoggingEnabled)
    {
      v8 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), a2);
      v9 = _NRLogIsLevelEnabled(v8, 1);

      if (v9)
      {
        v11 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v10);
        v12 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
        _NRLogWithArgs(v11, 1, "%s%.30s:%-4d %@: Nexus VI output available", "", "-[NRLinkBluetooth setupNexusChannelVideo:]_block_invoke", 1988, v12);

      }
    }
    sub_100086FF4(*(void **)(a1 + 32));
  }
}

void sub_10009CB9C(uint64_t a1)
{
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

uint64_t sub_10009CBA4(uint64_t a1)
{
  return os_channel_destroy(*(_QWORD *)(a1 + 32));
}

void sub_10009CBAC(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  int IsLevelEnabled;
  uint64_t v6;
  id v7;
  void *v8;
  int v9;
  uint64_t v10;
  void *v11;
  id v12;
  id v13;

  v3 = *(_QWORD *)(a1 + 32);
  if (*(unsigned __int8 *)(v3 + 16) == 255)
  {
    v4 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), a2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v4, 16);

    if (IsLevelEnabled)
    {
      v13 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v6);
      v7 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
      _NRLogWithArgs(v13, 16, "%s%.30s:%-4d %@: Nexus VO input available but cancelled", "", "-[NRLinkBluetooth setupNexusChannelVoice:]_block_invoke", 2256, v7);

    }
  }
  else
  {
    ++*(_QWORD *)(v3 + 599);
    if (gNRPacketLoggingEnabled)
    {
      v8 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), a2);
      v9 = _NRLogIsLevelEnabled(v8, 1);

      if (v9)
      {
        v11 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v10);
        v12 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
        _NRLogWithArgs(v11, 1, "%s%.30s:%-4d %@: Nexus VO input available", "", "-[NRLinkBluetooth setupNexusChannelVoice:]_block_invoke", 2260, v12);

      }
    }
    sub_100083E50(*(void **)(a1 + 32), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 527));
  }
}

void sub_10009CD34(uint64_t a1)
{
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_10009CD3C(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  int IsLevelEnabled;
  uint64_t v6;
  id v7;
  void *v8;
  int v9;
  uint64_t v10;
  void *v11;
  id v12;
  id v13;

  v3 = *(_QWORD *)(a1 + 32);
  if (*(unsigned __int8 *)(v3 + 16) == 255)
  {
    v4 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), a2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v4, 16);

    if (IsLevelEnabled)
    {
      v13 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v6);
      v7 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
      _NRLogWithArgs(v13, 16, "%s%.30s:%-4d %@: Nexus VO output available but cancelled", "", "-[NRLinkBluetooth setupNexusChannelVoice:]_block_invoke", 2274, v7);

    }
  }
  else
  {
    ++*(_QWORD *)(v3 + 607);
    if (gNRPacketLoggingEnabled)
    {
      v8 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), a2);
      v9 = _NRLogIsLevelEnabled(v8, 1);

      if (v9)
      {
        v11 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v10);
        v12 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
        _NRLogWithArgs(v11, 1, "%s%.30s:%-4d %@: Nexus VO output available", "", "-[NRLinkBluetooth setupNexusChannelVoice:]_block_invoke", 2278, v12);

      }
    }
    sub_10009CEC8(*(void **)(a1 + 32));
  }
}

void sub_10009CEB8(uint64_t a1)
{
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

uint64_t sub_10009CEC0(uint64_t a1)
{
  return os_channel_destroy(*(_QWORD *)(a1 + 32));
}

void sub_10009CEC8(void *a1)
{
  _QWORD *v1;
  uint64_t v2;
  char *v3;
  int v4;
  void *v5;
  int IsLevelEnabled;
  uint64_t v7;
  void *v8;
  id v9;
  int *v10;
  void *v11;
  int v12;
  uint64_t v13;
  void *v14;
  int v15;
  uint64_t v16;
  int *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t next_slot;
  uint64_t v23;
  uint64_t v24;
  int *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t packet;
  uint64_t next_buflet;
  uint64_t object_address;
  unsigned int data_offset;
  uint64_t data_length;
  uint64_t v33;
  uint64_t v34;
  unsigned __int8 *v35;
  unsigned int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t ESPSequenceNumberFromPacket;
  uint64_t v43;
  void *v44;
  int v45;
  void *v46;
  id v47;
  uint64_t v48;
  void *StringFromNRTLVType;
  _QWORD *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  int ESPSPIFromPacket;
  NSObject *v56;
  uint64_t v57;
  _QWORD *v58;
  void *v59;
  int v60;
  uint64_t v61;
  void *v62;
  id v63;
  void *v64;
  int v65;
  void *v66;
  id v67;
  void *v68;
  uint64_t v69;
  void *v70;
  void *v71;
  int v72;
  uint64_t v73;
  int v74;
  void *v75;
  int v76;
  uint64_t v77;
  void *v78;
  id v79;
  void *v80;
  int v81;
  uint64_t v82;
  void *v83;
  id v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  _QWORD *v92;
  void *v93;
  int v94;
  uint64_t v95;
  void *v96;
  id v97;
  uint64_t v98;
  void *v99;
  int v100;
  uint64_t v101;
  void *v102;
  id v103;
  uint64_t v104;
  void *v105;
  void *v106;
  int v107;
  uint64_t v108;
  void *v109;
  id v110;
  void *v111;
  int v112;
  uint64_t v113;
  void *v114;
  id v115;
  void *v116;
  int v117;
  uint64_t v118;
  void *v119;
  id v120;
  void *v121;
  int v122;
  uint64_t v123;
  void *v124;
  id v125;
  void *v126;
  int v127;
  uint64_t v128;
  void *v129;
  id v130;
  id v131;
  uint64_t v132;
  char *v133;
  int *v134;
  uint64_t v135;
  id v136;
  id v137;
  id v138;
  _BYTE *v139;
  uint64_t v140;
  unsigned __int8 *v141;
  unsigned int v142;
  int v143;
  __int128 v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  _QWORD v148[2];
  _OWORD v149[4];
  _QWORD block[4];
  int v151;
  int v152;
  char v153;
  _BYTE v154[7];

  v1 = a1;
  v3 = (char *)v1;
  v4 = *((unsigned __int8 *)v1 + 16);
  if (v4 == 255)
  {
    v5 = (void *)_NRCopyLogObjectForNRUUID(v1[4], v2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v5, 16);

    if (IsLevelEnabled)
    {
      v8 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v7);
      v9 = objc_msgSend(v3, "copyDescription");
      _NRLogWithArgs(v8, 16, "%s%.30s:%-4d %@: LinkToNexusLoop but cancelled", "", "NRLinkDatagramLinkToNexusLoop", 4188, v9);
LABEL_11:

      goto LABEL_12;
    }
    goto LABEL_12;
  }
  v10 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
  if (!*(_QWORD *)((char *)v1 + 1047))
  {
    if (*((_BYTE *)v1 + 225))
    {
      v14 = (void *)_NRCopyLogObjectForNRUUID(v1[4], v2);
      v15 = _NRLogIsLevelEnabled(v14, 17);

      if (v15)
      {
        v8 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v16);
        v9 = objc_msgSend(v3, "copyDescription");
        _NRLogWithArgs(v8, 17, "%@: Tried to linkToNexusLoop but _datagramLinkInputRing is NULL", v9);
        goto LABEL_11;
      }
    }
    goto LABEL_12;
  }
  if ((v4 - 1) >= 2)
  {
    v139 = v154;
    v17 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
    while (1)
    {
      v18 = 0;
      v19 = 0;
      memset(v149, 0, sizeof(v149));
      v148[0] = 0;
      v148[1] = 0;
      while (1)
      {
        v20 = v17[340];
        *(_QWORD *)&v3[v20] = 4;
        v147 = 0u;
        v146 = 0u;
        v145 = 0u;
        v144 = 0u;
        v21 = v18;
        next_slot = os_channel_get_next_slot(*(_QWORD *)(v3 + 543), v18, &v144);
        if (!next_slot)
          break;
        v18 = next_slot;
        v24 = os_channel_get_next_slot(*(_QWORD *)&v3[v10[77]], v19, v149);
        if (!v24)
        {
          v85 = v21;
          if (v3[223] && *(_QWORD *)(v3 + 1063))
          {
            v89 = v19;
            v3[223] = 0;
            ++*(_QWORD *)(v3 + 1079);
            if (gNRPacketLoggingEnabled)
            {
              v116 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v23);
              v117 = _NRLogIsLevelEnabled(v116, 1);

              if (v117)
              {
                v119 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v118);
                v120 = objc_msgSend(v3, "copyDescription");
                _NRLogWithArgs(v119, 1, "%s%.30s:%-4d %@: source-resume: DatagramLinkInput", "", "NRLinkResumeDatagramLinkInputSource", 824, v120);

              }
            }
            dispatch_resume(*(dispatch_object_t *)(v3 + 1063));
            v19 = v89;
          }
          if (v3[215] || !*(_QWORD *)(v3 + 559))
          {
            v88 = 64;
            goto LABEL_94;
          }
          v87 = v19;
          v3[215] = 1;
          ++*(_QWORD *)(v3 + 575);
          if (gNRPacketLoggingEnabled)
          {
            v126 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v23);
            v127 = _NRLogIsLevelEnabled(v126, 1);

            if (v127)
            {
              v129 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v128);
              v130 = objc_msgSend(v3, "copyDescription");
              _NRLogWithArgs(v129, 1, "%s%.30s:%-4d %@: source-suspend: NexusVOOutput", "", "NRLinkSuspendNexusVOOutputSource", 835, v130);

            }
          }
          dispatch_suspend(*(dispatch_object_t *)(v3 + 559));
          v88 = 64;
          goto LABEL_93;
        }
        v25 = v17;
        v26 = v24;
        v27 = *(_QWORD *)&v3[v10[77]];
        v140 = v26;
        packet = os_channel_slot_get_packet(v27, v26);
        next_buflet = os_packet_get_next_buflet(packet, 0);
        object_address = os_buflet_get_object_address();
        data_offset = os_buflet_get_data_offset(next_buflet);
        data_length = os_buflet_get_data_length(next_buflet);
        if (data_length >= 0x10000)
        {
          if (qword_1001E46D8 != -1)
            goto LABEL_123;
          while (1)
          {
            if (_NRLogIsLevelEnabled(qword_1001E46D0, 16))
            {
              v131 = sub_100070AC8();
              _NRLogWithArgs(v131, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: inputBufferLength <= 65535", "", "NRLinkDatagramLinkToNexusLoop", 4257);

            }
            v132 = _os_log_pack_size(12);
            v133 = (char *)&v137 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
            v134 = __error();
            v135 = _os_log_pack_fill(v133, v132, *v134, &_mh_execute_header, "%{public}s Assertion Failed: inputBufferLength <= 65535");
            *(_DWORD *)v135 = 136446210;
            *(_QWORD *)(v135 + 4) = "NRLinkDatagramLinkToNexusLoop";
            v136 = sub_100070AC8();
            _NRLogAbortWithPack(v136, v133);
LABEL_123:
            dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
          }
        }
        v33 = data_length;
        os_packet_get_flow_uuid(packet, v148);
        if (!v3[223] && *(_QWORD *)(v3 + 1063))
        {
          v3[223] = 1;
          ++*(_QWORD *)(v3 + 1079);
          if (gNRPacketLoggingEnabled)
          {
            v68 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v34);
            LODWORD(v138) = _NRLogIsLevelEnabled(v68, 1);

            if ((_DWORD)v138)
            {
              v70 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v69);
              v138 = objc_msgSend(v3, "copyDescription");
              _NRLogWithArgs(v70, 1, "%s%.30s:%-4d %@: source-suspend: DatagramLinkInput", "", "NRLinkSuspendDatagramLinkInputSource", 816, v138);

            }
          }
          dispatch_suspend(*(dispatch_object_t *)(v3 + 1063));
        }
        if (v33 > WORD1(v144))
        {
          v17 = v25;
LABEL_30:
          v18 = v21;
          goto LABEL_54;
        }
        v35 = (unsigned __int8 *)(object_address + data_offset);
        v143 = 0;
        v141 = v35;
        v142 = v33;
        if (v33 < 3)
        {
          if (!gNRPacketLoggingEnabled)
          {
            v18 = v21;
            v17 = v25;
            goto LABEL_54;
          }
          v64 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v34);
          v65 = _NRLogIsLevelEnabled(v64, 1);

          v17 = v25;
          if (!v65)
            goto LABEL_30;
          v66 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v34);
          v67 = objc_msgSend(v3, "copyDescription");
          _NRLogWithArgs(v66, 1, "%s%.30s:%-4d %@: received unexpected packet length: %u", "", "NRLinkDatagramLinkToNexusLoop", 4327, v67, v142);
LABEL_67:

          goto LABEL_30;
        }
        v36 = bswap32(*(unsigned __int16 *)(v35 + 1));
        v37 = HIWORD(v36);
        v38 = v37 + 5;
        if (v37 + 5 != v33)
        {
          if (!gNRPacketLoggingEnabled)
            goto LABEL_45;
          v71 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v34);
          v72 = _NRLogIsLevelEnabled(v71, 1);

          v10 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
          v17 = v25;
          if (!v72)
            goto LABEL_30;
          v66 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v34);
          v67 = objc_msgSend(v3, "copyDescription");
          _NRLogWithArgs(v66, 1, "%s%.30s:%-4d %@: DatagramLink:Ignoring truncated packet (%zu + %zu + %u + %zu != %u)", "", "NRLinkDatagramLinkToNexusLoop", 4282, v67, 1, 2, v37, 2, v142);
          goto LABEL_67;
        }
        v39 = *v35;
        v41 = nrTLVToPacket(&v141, 1, v39, HIWORD(v36), v145, WORD1(v144), v3 + 1967, v3 + 1951);
        if (gNRPacketLoggingEnabled)
        {
          v138 = (id)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v40);
          LODWORD(v137) = _NRLogIsLevelEnabled(v138, 1);

          if ((_DWORD)v137)
          {
            v138 = (id)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v40);
            v137 = objc_msgSend(v3, "copyDescription");
            _NRLogWithArgs(v138, 1, "%s%.30s:%-4d %@: DatagramLink:read %u bytes from datagram link, uncompressedLen = %u", "", "NRLinkDatagramLinkToNexusLoop", 4290, v137, v33, v41);

          }
        }
        if (!(_DWORD)v41)
        {
          v44 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v40);
          v45 = _NRLogIsLevelEnabled(v44, 17);

          if (v45)
          {
            v46 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v34);
            v47 = objc_msgSend(v3, "copyDescription");
            StringFromNRTLVType = (void *)createStringFromNRTLVType(v39, v48);
            _NRLogWithArgs(v46, 17, "%@: failed to reinject %@ tlvLen=%u slotLen=%u", v47, StringFromNRTLVType, v37, WORD1(v144));

          }
LABEL_45:
          v18 = v21;
          v10 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
          v17 = v25;
          goto LABEL_54;
        }
        WORD1(v144) = v41;
        if (gNRPacketLoggingEnabled)
        {
          ESPSequenceNumberFromPacket = getESPSequenceNumberFromPacket(v145, v41);
          if (gNRPacketLoggingEnabled)
          {
            getESPSPIFromPacket(v145, WORD1(v144));
            v74 = gNRPacketLoggingEnabled;
            *(_QWORD *)&v3[v20] |= 0x8000000uLL;
            if (v74)
            {
              v75 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v73);
              v76 = _NRLogIsLevelEnabled(v75, 1);

              if (v76)
              {
                v78 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v77);
                v79 = objc_msgSend(v3, "copyDescription");
                _NRLogWithArgs(v78, 1, "%s%.30s:%-4d %@: DatagramLink:Received ESP sequence number: %u", "", "NRLinkDatagramLinkToNexusLoop", 4295, v79, ESPSequenceNumberFromPacket);

              }
            }
            v17 = v25;
            goto LABEL_38;
          }
        }
        else
        {
          ESPSequenceNumberFromPacket = 0;
        }
        v17 = v25;
        *(_QWORD *)&v3[v20] |= 0x8000000uLL;
LABEL_38:
        v43 = os_channel_slot_get_packet(*(_QWORD *)(v3 + 543), v18);
        if ((v148[0] & 0x10000) != 0 || v3[245])
        {
          v3[245] = 0;
          v50 = v139;
          *(_QWORD *)(v139 + 7) = 0;
          *v50 = 0;
          v153 = 1;
          if (v43)
          {
            os_packet_set_flow_uuid(v43, &v153);
            *(_QWORD *)&v3[v20] |= 0x10000000uLL;
            if (gNRPacketLoggingEnabled)
            {
              v80 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v51);
              v81 = _NRLogIsLevelEnabled(v80, 1);

              if (v81)
              {
                v83 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v82);
                v84 = objc_msgSend(v3, "copyDescription");
                _NRLogWithArgs(v83, 1, "%s%.30s:%-4d %@: DatagramLink:Set waking metadata for packet w/ ESP sequence number: %u", "", "NRLinkDatagramLinkToNexusLoop", 4307, v84, ESPSequenceNumberFromPacket);

              }
            }
          }
          v52 = v145;
          v53 = WORD1(v144);
          v54 = getESPSequenceNumberFromPacket(v145, WORD1(v144));
          ESPSPIFromPacket = getESPSPIFromPacket(v52, v53);
          if (qword_1001E48A0 != -1)
            dispatch_once(&qword_1001E48A0, &stru_1001B7C10);
          v56 = (id)qword_1001E4898;
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472;
          block[2] = sub_10008C1F8;
          block[3] = &unk_1001B85D0;
          v151 = ESPSPIFromPacket;
          v152 = v54;
          dispatch_async(v56, block);

          v17 = v25;
        }
        else if (v43)
        {
          os_packet_clear_flow_uuid();
        }
        os_channel_set_slot_properties(*(_QWORD *)(v3 + 543), v18, &v144);
        *(_QWORD *)(v3 + 1391) += v38;
        *(_QWORD *)(v3 + 655) += v41;
        ++*(_QWORD *)(v3 + 639);
        v10 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
LABEL_54:
        if (*(_QWORD *)&v3[v17[340]] && *(_QWORD *)(v3 + 1911))
        {
          v3[255] = v3[255] % v3[254];
          v57 = *(_QWORD *)(v3 + 1911);
          v58 = (_QWORD *)(v57 + 8 * v3[255]);
          if ((unint64_t)(v58 + 1) <= v57 + 8 * (unint64_t)v3[254])
          {
            if ((v58 & 7) == 0)
            {
              *v58 = *(_QWORD *)&v3[v17[340]];
              ++v3[255];
              *(_QWORD *)&v3[v17[340]] = 0;
            }
          }
          else
          {
            v59 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v34);
            v60 = _NRLogIsLevelEnabled(v59, 17);

            if (v60)
            {
              v62 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v61);
              v63 = objc_msgSend(v3, "copyDescription");
              _NRLogWithArgs(v62, 17, "%@: invalid index for link log list (curIdx: %u)", v63, v3[255]);

            }
          }
        }
        v19 = v140;
      }
      v85 = v18;
      if (!v3[223] && *(_QWORD *)(v3 + 1063))
      {
        v86 = v19;
        v3[223] = 1;
        ++*(_QWORD *)(v3 + 1079);
        if (gNRPacketLoggingEnabled)
        {
          v121 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v23);
          v122 = _NRLogIsLevelEnabled(v121, 1);

          if (v122)
          {
            v124 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v123);
            v125 = objc_msgSend(v3, "copyDescription");
            _NRLogWithArgs(v124, 1, "%s%.30s:%-4d %@: source-suspend: DatagramLinkInput", "", "NRLinkSuspendDatagramLinkInputSource", 816, v125);

          }
        }
        dispatch_suspend(*(dispatch_object_t *)(v3 + 1063));
        v19 = v86;
      }
      if (!v3[215] || !*(_QWORD *)(v3 + 559))
      {
        v88 = 0x800000;
        goto LABEL_94;
      }
      v87 = v19;
      v3[215] = 0;
      ++*(_QWORD *)(v3 + 575);
      if (gNRPacketLoggingEnabled)
      {
        v111 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v23);
        v112 = _NRLogIsLevelEnabled(v111, 1);

        if (v112)
        {
          v114 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v113);
          v115 = objc_msgSend(v3, "copyDescription");
          _NRLogWithArgs(v114, 1, "%s%.30s:%-4d %@: source-resume: NexusVOOutput", "", "NRLinkResumeNexusVOOutputSource", 845, v115);

        }
      }
      dispatch_resume(*(dispatch_object_t *)(v3 + 559));
      v88 = 0x800000;
LABEL_93:
      v19 = v87;
LABEL_94:
      *(_QWORD *)&v3[v20] |= v88;
      if (v19)
      {
        *(_QWORD *)&v3[v17[340]] |= 0x800000000uLL;
        if (gNRPacketLoggingEnabled)
        {
          v98 = v19;
          v99 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v23);
          v100 = _NRLogIsLevelEnabled(v99, 1);

          if (v100)
          {
            v102 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v101);
            v103 = objc_msgSend(v3, "copyDescription");
            _NRLogWithArgs(v102, 1, "%s%.30s:%-4d %@: DatagramLink:advancing past datagramLinkInputSlot=%p and syncing link input", "", "NRLinkDatagramLinkToNexusLoop", 4338, v103, v98);

          }
          v19 = v98;
          if (gNRPacketLoggingEnabled)
          {
            v104 = objc_claimAutoreleasedReturnValue(+[NSDate date](NSDate, "date"));
            v105 = *(void **)(v3 + 1695);
            *(_QWORD *)(v3 + 1695) = v104;

          }
        }
        os_channel_advance_slot(*(_QWORD *)&v3[v10[77]], v19);
        os_channel_sync(*(_QWORD *)(v3 + 1039), 1);
        ++*(_QWORD *)(v3 + 1439);
      }
      v90 = v19;
      if (v85)
      {
        *(_QWORD *)&v3[v17[340]] |= 0x1000000000uLL;
        if (gNRPacketLoggingEnabled)
        {
          v106 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v23);
          v107 = _NRLogIsLevelEnabled(v106, 1);

          if (v107)
          {
            v109 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v108);
            v110 = objc_msgSend(v3, "copyDescription");
            _NRLogWithArgs(v109, 1, "%s%.30s:%-4d %@: DatagramLink:advancing past nexusOutputSlot=%p and syncing nexus output", "", "NRLinkDatagramLinkToNexusLoop", 4347, v110, v85);

          }
        }
        os_channel_advance_slot(*(_QWORD *)(v3 + 543), v85);
        os_channel_sync(*(_QWORD *)(v3 + 527), 0);
        ++*(_QWORD *)(v3 + 623);
      }
      if (*(_QWORD *)&v3[v17[340]] && *(_QWORD *)(v3 + 1911))
      {
        v3[255] = v3[255] % v3[254];
        v91 = *(_QWORD *)(v3 + 1911);
        v92 = (_QWORD *)(v91 + 8 * v3[255]);
        if ((unint64_t)(v92 + 1) <= v91 + 8 * (unint64_t)v3[254])
        {
          if ((v92 & 7) == 0)
          {
            *v92 = *(_QWORD *)&v3[v17[340]];
            ++v3[255];
            *(_QWORD *)&v3[v17[340]] = 0;
          }
        }
        else
        {
          v93 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v23);
          v94 = _NRLogIsLevelEnabled(v93, 17);

          if (v94)
          {
            v96 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v95);
            v97 = objc_msgSend(v3, "copyDescription");
            _NRLogWithArgs(v96, 17, "%@: invalid index for link log list (curIdx: %u)", v97, v3[255]);

          }
        }
      }
      if (!(v85 | v90))
        goto LABEL_12;
    }
  }
  v11 = (void *)_NRCopyLogObjectForNRUUID(v1[4], v2);
  v12 = _NRLogIsLevelEnabled(v11, 17);

  if (v12)
  {
    v8 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v3 + 4), v13);
    v9 = objc_msgSend(v3, "copyDescription");
    _NRLogWithArgs(v8, 17, "%@: Tried to linkToNexusLoop but bad state", v9);
    goto LABEL_11;
  }
LABEL_12:

}

void sub_10009E144(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  void *v5;
  int v6;
  uint64_t v7;
  id v8;
  void *v9;
  int IsLevelEnabled;
  uint64_t v11;
  void *v12;
  int v13;
  uint64_t v14;
  void *v15;
  id v16;
  id v17;

  v3 = *(_QWORD *)(a1 + 32);
  if (*(unsigned __int8 *)(v3 + 16) == 255)
  {
    v9 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), a2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v9, 16);

    if (IsLevelEnabled)
    {
      v17 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v11);
      v8 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
      _NRLogWithArgs(v17, 16, "%s%.30s:%-4d %@: Datagram link input available but cancelled", "", "-[NRLinkBluetooth updateDatagramPipe:]_block_invoke", 2714, v8);
      goto LABEL_7;
    }
  }
  else
  {
    ++*(_QWORD *)(v3 + 1487);
    v4 = *(_QWORD *)(a1 + 32);
    if (*(unsigned __int8 *)(v4 + 16) - 1 > 1)
    {
      if (gNRPacketLoggingEnabled)
      {
        v12 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), a2);
        v13 = _NRLogIsLevelEnabled(v12, 1);

        v4 = *(_QWORD *)(a1 + 32);
        if (v13)
        {
          v15 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v14);
          v16 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
          _NRLogWithArgs(v15, 1, "%s%.30s:%-4d %@: Datagram link input available after prelude", "", "-[NRLinkBluetooth updateDatagramPipe:]_block_invoke", 2721, v16);

          v4 = *(_QWORD *)(a1 + 32);
        }
      }
      sub_10009CEC8((void *)v4);
    }
    else
    {
      v5 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), a2);
      v6 = _NRLogIsLevelEnabled(v5, 17);

      if (v6)
      {
        v17 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v7);
        v8 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
        _NRLogWithArgs(v17, 17, "%@: Datagram link input available before prelude", v8);
LABEL_7:

      }
    }
  }
}

void sub_10009E328(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  int IsLevelEnabled;
  uint64_t v6;
  id v7;
  void *v8;
  int v9;
  uint64_t v10;
  void *v11;
  id v12;
  id v13;

  v3 = *(_QWORD *)(a1 + 32);
  if (*(unsigned __int8 *)(v3 + 16) == 255)
  {
    v4 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), a2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v4, 16);

    if (IsLevelEnabled)
    {
      v13 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v6);
      v7 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
      _NRLogWithArgs(v13, 16, "%s%.30s:%-4d %@: Datagram link output available but cancelled", "", "-[NRLinkBluetooth updateDatagramPipe:]_block_invoke_3", 2740, v7);

    }
  }
  else
  {
    ++*(_QWORD *)(v3 + 1495);
    if (gNRPacketLoggingEnabled)
    {
      v8 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), a2);
      v9 = _NRLogIsLevelEnabled(v8, 1);

      if (v9)
      {
        v11 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v10);
        v12 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
        _NRLogWithArgs(v11, 1, "%s%.30s:%-4d %@: Datagram link output available", "", "-[NRLinkBluetooth updateDatagramPipe:]_block_invoke_3", 2744, v12);

      }
    }
    sub_100083E50(*(void **)(a1 + 32), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 527));
  }
}

void sub_10009E4B4(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  void *v5;
  int IsLevelEnabled;
  uint64_t v7;
  id v8;
  void *v9;
  int v10;
  uint64_t v11;
  void *v12;
  id v13;
  void *v14;
  int v15;
  uint64_t v16;
  void *v17;
  id v18;
  id v19;

  v3 = *(_QWORD *)(a1 + 32);
  if (*(unsigned __int8 *)(v3 + 16) == 255)
  {
    v5 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), a2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v5, 16);

    if (IsLevelEnabled)
    {
      v19 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v7);
      v8 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
      _NRLogWithArgs(v19, 16, "%s%.30s:%-4d %@: Link input available but cancelled", "", "-[NRLinkBluetooth start]_block_invoke", 1276, v8);

    }
  }
  else
  {
    ++*(_QWORD *)(v3 + 1471);
    v4 = *(_QWORD *)(a1 + 32);
    if (*(unsigned __int8 *)(v4 + 16) - 1 > 1)
    {
      if (gNRPacketLoggingEnabled)
      {
        v14 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), a2);
        v15 = _NRLogIsLevelEnabled(v14, 1);

        v4 = *(_QWORD *)(a1 + 32);
        if (v15)
        {
          v17 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v16);
          v18 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
          _NRLogWithArgs(v17, 1, "%s%.30s:%-4d %@: Link input available after prelude", "", "-[NRLinkBluetooth start]_block_invoke", 1284, v18);

          v4 = *(_QWORD *)(a1 + 32);
        }
      }
      sub_100091008((void *)v4);
    }
    else
    {
      if (gNRPacketLoggingEnabled)
      {
        v9 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), a2);
        v10 = _NRLogIsLevelEnabled(v9, 1);

        v4 = *(_QWORD *)(a1 + 32);
        if (v10)
        {
          v12 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v4 + 32), v11);
          v13 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
          _NRLogWithArgs(v12, 1, "%s%.30s:%-4d %@: Link input available before prelude", "", "-[NRLinkBluetooth start]_block_invoke", 1281, v13);

          v4 = *(_QWORD *)(a1 + 32);
        }
      }
      sub_100086D44(v4, 0);
    }
  }
}

void sub_10009E6DC(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  int *v12;
  BOOL v13;
  int *v14;
  uint64_t v15;
  void *v16;
  int IsLevelEnabled;
  uint64_t v18;
  id v19;
  void *v20;
  int v21;
  uint64_t v22;
  void *v23;
  id v24;
  id v25;

  v3 = *(_QWORD *)(a1 + 32);
  if (*(unsigned __int8 *)(v3 + 16) == 255)
  {
    v16 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v3 + 32), a2);
    IsLevelEnabled = _NRLogIsLevelEnabled(v16, 16);

    if (IsLevelEnabled)
    {
      v25 = (id)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v18);
      v19 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
      _NRLogWithArgs(v25, 16, "%s%.30s:%-4d %@: Link output available but cancelled", "", "-[NRLinkBluetooth start]_block_invoke_3", 1302, v19);

    }
  }
  else
  {
    ++*(_QWORD *)(v3 + 1479);
    if (gNRPacketLoggingEnabled)
    {
      v20 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), a2);
      v21 = _NRLogIsLevelEnabled(v20, 1);

      if (v21)
      {
        v23 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v22);
        v24 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
        _NRLogWithArgs(v23, 1, "%s%.30s:%-4d %@: Link output available", "", "-[NRLinkBluetooth start]_block_invoke_3", 1306, v24);

      }
    }
    v4 = *(_QWORD *)(a1 + 32);
    v5 = *(_QWORD *)(v4 + 1111);
    v6 = *(unsigned __int8 *)(v4 + 230);
    if (v5)
      v7 = 2;
    else
      v7 = 4;
    do
    {
      if ((v6 & 0xFC) != 0)
        v8 = 0;
      else
        v8 = v6;
      v9 = *(_QWORD *)(a1 + 32);
      v10 = *(_QWORD *)(v9 + 1111);
      if (v10)
        v11 = 0;
      else
        v11 = v8 == 1;
      if (v11)
        v12 = &OBJC_IVAR___NRLinkBluetooth__nexusVIChannel;
      else
        v12 = &OBJC_IVAR___NRLinkBluetooth__nexusBKChannel;
      if (v10)
        v13 = 0;
      else
        v13 = v8 == 0;
      if (v13)
        v14 = &OBJC_IVAR___NRLinkBluetooth__nexusVOChannel;
      else
        v14 = &OBJC_IVAR___NRLinkBluetooth__nexusChannel;
      if ((v8 & 1) != 0)
        v14 = v12;
      sub_100071380((void *)v9, *(_QWORD *)(v9 + *v14));
      v6 = v8 + 1;
      --v7;
    }
    while (v7);
    ++*(_BYTE *)(*(_QWORD *)(a1 + 32) + 230);
    v15 = *(_QWORD *)(a1 + 32);
    if (*(unsigned __int8 *)(v15 + 230) > 3u)
      *(_BYTE *)(v15 + 230) = 0;
  }
}

void sub_10009E928(uint64_t a1, uint64_t a2)
{
  void *v3;
  int IsLevelEnabled;
  uint64_t v5;
  void *v6;
  id v7;
  dispatch_time_t v8;
  NSObject *v9;
  _QWORD block[4];
  id v11;
  id location;

  v3 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), a2);
  IsLevelEnabled = _NRLogIsLevelEnabled(v3, 1);

  if (IsLevelEnabled)
  {
    v6 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), v5);
    v7 = objc_msgSend(*(id *)(a1 + 32), "copyDescription");
    _NRLogWithArgs(v6, 1, "%s%.30s:%-4d %@: NtL LOOP async start after async", "", "-[NRLinkBluetooth start]_block_invoke", 1393, v7);

  }
  sub_100071380(*(void **)(a1 + 32), 0);
  objc_initWeak(&location, *(id *)(a1 + 32));
  v8 = dispatch_time(0x8000000000000000, 10000000000);
  v9 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 8);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10009EA64;
  block[3] = &unk_1001B7F28;
  objc_copyWeak(&v11, &location);
  dispatch_after(v8, v9, block);
  objc_destroyWeak(&v11);
  objc_destroyWeak(&location);
}

void sub_10009EA64(uint64_t a1)
{
  char *WeakRetained;
  BOOL v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;

  WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v10 = WeakRetained;
    v2 = objc_msgSend(WeakRetained, "state") == 2;
    WeakRetained = v10;
    if (v2)
    {
      v9 = *(_QWORD *)(v10 + 1863);
      if (v9)
        *(_BYTE *)(v9 + 101) = 1;
      sub_100074F70(v10, CFSTR("Did not receive prelude after %ds"), v3, v4, v5, v6, v7, v8, 10);
      WeakRetained = v10;
    }
  }

}

char *sub_10009EAD8(char *a1, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  NSObject *v11;
  id v12;
  id v13;
  int *v14;
  char *v15;
  char *v16;
  void *v17;
  uint64_t v18;
  void *v19;
  NRAnalyticsCmpnLinkBluetooth *v20;
  void *v21;
  int *v22;
  id v23;
  unsigned __int8 *v24;
  char *v25;
  int v26;
  BOOL v27;
  char v28;
  id v29;
  void *v30;
  void *v31;
  char *v32;
  __objc2_prot *v34;
  id v35;
  int IsLevelEnabled;
  id v37;
  id v38;
  int v39;
  id v40;
  int v41;
  id v42;
  int v43;
  id v44;
  int v45;
  id v46;
  id v47;
  int v48;
  id v49;
  int *v50;
  uint64_t v51;
  id v52;
  char *v53;
  int *v54;
  NSObject *v55;
  objc_super v56;

  v11 = a2;
  v12 = a3;
  v13 = a4;
  v14 = a5;
  v15 = a6;
  if (!a1)
    goto LABEL_51;
  if (!v11)
  {
    v35 = sub_100070AC8();
    IsLevelEnabled = _NRLogIsLevelEnabled(v35, 17);

    if (!IsLevelEnabled)
      goto LABEL_51;
    v37 = sub_100070AC8();
    _NRLogWithArgs(v37, 17, "%s called with null queue");
LABEL_50:

    v32 = 0;
    goto LABEL_35;
  }
  dispatch_assert_queue_V2(v11);
  if (!v13)
  {
    v38 = sub_100070AC8();
    v39 = _NRLogIsLevelEnabled(v38, 17);

    if (!v39)
      goto LABEL_51;
    v37 = sub_100070AC8();
    _NRLogWithArgs(v37, 17, "%s called with null nrUUID");
    goto LABEL_50;
  }
  if ((_NRIsUUIDNonZero(v13) & 1) == 0)
  {
    v40 = sub_100070AC8();
    v41 = _NRLogIsLevelEnabled(v40, 17);

    if (!v41)
      goto LABEL_51;
    v37 = sub_100070AC8();
    _NRLogWithArgs(v37, 17, "called with all-zero nrUUID");
    goto LABEL_50;
  }
  if (!v15)
  {
    v42 = sub_100070AC8();
    v43 = _NRLogIsLevelEnabled(v42, 17);

    if (v43)
    {
      v37 = sub_100070AC8();
      _NRLogWithArgs(v37, 17, "%s called with null remoteDeviceName");
      goto LABEL_50;
    }
LABEL_51:
    v32 = 0;
    goto LABEL_35;
  }
  v56.receiver = a1;
  v56.super_class = (Class)NRLinkBluetooth;
  v16 = (char *)objc_msgSendSuper2(&v56, "initLinkWithQueue:linkDelegate:nrUUID:", v11, v12, v13);
  if (v16)
  {
    a1 = v16;
    v53 = v15;
    v55 = v11;
    objc_msgSend(v16, "setType:", 1);
    objc_storeStrong((id *)(a1 + 335), a5);
    v54 = v14;
    v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "peer"));
    v18 = objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "identifier"));
    v19 = *(void **)(a1 + 327);
    *(_QWORD *)(a1 + 327) = v18;

    objc_storeStrong((id *)(a1 + 343), a6);
    v20 = objc_alloc_init(NRAnalyticsCmpnLinkBluetooth);
    v21 = *(void **)(a1 + 1863);
    *(_QWORD *)(a1 + 1863) = v20;

    v22 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
    *(_DWORD *)(a1 + 263) = 0xFFFF;
    v14 = &OBJC_IVAR___NRLinkUpgradeReport__timeOfLinkUpgrade;
    *(_DWORD *)(a1 + 271) = (*(_DWORD *)(a1 + 263) + 1) >> 1;
    *(_DWORD *)(a1 + 267) = *(_DWORD *)(a1 + 263);
    *(_DWORD *)(a1 + 275) = (*(_DWORD *)(a1 + 267) + 1) >> 1;
    *(_DWORD *)(a1 + 279) = 0x4000;
    *(_DWORD *)(a1 + 283) = *(_DWORD *)(a1 + 279);
    objc_opt_self(NRLinkDirector);
    if (qword_1001E4710 != -1)
      dispatch_once(&qword_1001E4710, &stru_1001B6E60);
    v23 = v12;
    v24 = (unsigned __int8 *)(id)qword_1001E4708;
    if (v24)
    {
      v12 = (id)v24[10];

      if ((_DWORD)v12)
      {
        a1[246] = 1;
        *(_DWORD *)(a1 + 263) = 48;
        *(_DWORD *)(a1 + 271) = (*(_DWORD *)(a1 + 263) + 1) >> 1;
        *(_DWORD *)(a1 + 267) = *(_DWORD *)(a1 + 263);
        *(_DWORD *)(a1 + 275) = (*(_DWORD *)(a1 + 267) + 1) >> 1;
        *(_DWORD *)(a1 + 279) = 48;
        *(_DWORD *)(a1 + 283) = *(_DWORD *)(a1 + 279);
      }
    }
    v25 = sub_10012FFF4((uint64_t)NRDLocalDevice, v13);
    if (v25)
    {
      v22 = (int *)v25;
      if (v25[15])
      {
        v26 = 1;
      }
      else
      {
        if (v25[14])
          v27 = 1;
        else
          v27 = *((unsigned __int16 *)v25 + 14) > 0x12u;
        v26 = v27;
      }
      v12 = v23;
      v14 = v54;
      v11 = v55;
      v15 = v53;
      if (v25[12])
      {
        if (!v25[13])
          v26 = 0;
        if (v26 == 1)
        {
          a1[208] = 20;
LABEL_33:
          sub_10013453C(v25, a1 + 1951);
          sub_100133C94(v22, a1 + 1967);
          sub_10013CC28(v22, a1 + 1983);
          v29 = objc_msgSend(v13, "UUIDString", sub_10013CDB8(v22, a1 + 1999));
          v30 = (void *)objc_claimAutoreleasedReturnValue(v29);
          objc_msgSend(a1, "reportEvent:details:", 3000, v30);

          v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "linkDelegate"));
          objc_msgSend(v31, "linkIsAvailable:", a1);

          v32 = a1;
LABEL_34:

          goto LABEL_35;
        }
      }
      if (*((_QWORD *)v25 + 19))
      {
        if (v25[15])
          v28 = 12;
        else
          v28 = 10;
        a1[208] = v28;
        goto LABEL_33;
      }
      if (v25[15])
      {
        a1[208] = 11;
        goto LABEL_33;
      }
      objc_msgSend(a1, "reportEvent:detailsFormat:", 3017, CFSTR("Local device without pairing keys %@"), v25);
      v34 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
      if (qword_1001E46D8 == -1)
      {
LABEL_37:
        if (_NRLogIsLevelEnabled(qword_1001E46D0, 17))
        {
          if (v34[24].inst_meths != (__objc2_meth_list *)-1)
            dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
          _NRLogWithArgs(qword_1001E46D0, 17, "Local device without pairing keys %@", v22);
        }
        v32 = 0;
        goto LABEL_34;
      }
    }
    else
    {
      v47 = sub_100070AC8();
      v48 = _NRLogIsLevelEnabled(v47, 16);

      v15 = "-[NRLinkBluetooth initLinkWithQueue:linkDelegate:nrUUID:pipe:remoteDeviceName:]";
      if (v48)
      {
        v49 = sub_100070AC8();
        _NRLogWithArgs(v49, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)", "", "-[NRLinkBluetooth initLinkWithQueue:linkDelegate:nrUUID:pipe:remoteDeviceName:]", 1050);

      }
      v11 = _os_log_pack_size(12);
      v34 = (__objc2_prot *)((char *)&v53 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0));
      v50 = __error();
      v51 = _os_log_pack_fill(v34, v11, *v50, &_mh_execute_header, "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
      *(_DWORD *)v51 = 136446210;
      *(_QWORD *)(v51 + 4) = "-[NRLinkBluetooth initLinkWithQueue:linkDelegate:nrUUID:pipe:remoteDeviceName:]";
      v52 = sub_100070AC8();
      _NRLogAbortWithPack(v52, v34);
    }
    dispatch_once(&qword_1001E46D8, &stru_1001B6D98);
    goto LABEL_37;
  }
  v44 = sub_100070AC8();
  v45 = _NRLogIsLevelEnabled(v44, 17);

  if (v45)
  {
    v46 = sub_100070AC8();
    _NRLogWithArgs(v46, 17, "[NRLink initLinkWithQueue:] failed");

  }
  a1 = 0;
  v32 = 0;
LABEL_35:

  return v32;
}

void sub_10009F1D4(uint64_t a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  NRDLatencyContext *v6;
  const char *v7;
  NRDLatencyContext *v8;
  unint64_t v9;
  uint64_t v10;
  void *v11;
  int v12;
  uint64_t v13;
  void *v14;
  id v15;
  dispatch_time_t v16;
  NSObject *v17;
  id v18;
  int v19;
  id v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  id v25;
  int IsLevelEnabled;
  id v27;
  uint64_t v28;
  uint64_t v29;
  id v30;
  _QWORD block[6];
  char v33;
  unint64_t v34;

  v3 = a2;
  if (!*(_QWORD *)(a1 + 1207))
  {
    v4 = objc_alloc_init((Class)NSMutableArray);
    v5 = *(void **)(a1 + 1207);
    *(_QWORD *)(a1 + 1207) = v4;

    if (!*(_QWORD *)(a1 + 1207))
    {
      v25 = sub_100070AC8();
      IsLevelEnabled = _NRLogIsLevelEnabled(v25, 16);

      if (IsLevelEnabled)
      {
        v27 = sub_100070AC8();
        _NRLogWithArgs(v27, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (self.latencyContexts) != ((void *)0)", "", "-[NRLinkBluetooth measureLatencyWithCompletion:]", 2922);

      }
      v28 = _os_log_pack_size(12);
      v22 = (char *)&block[-1] - ((__chkstk_darwin(v28) + 15) & 0xFFFFFFFFFFFFFFF0);
      v29 = *__error();
      v24 = _os_log_pack_fill(v22, v28, v29, &_mh_execute_header, "%{public}s Assertion Failed: (self.latencyContexts) != ((void *)0)");
LABEL_13:
      *(_DWORD *)v24 = 136446210;
      *(_QWORD *)(v24 + 4) = "-[NRLinkBluetooth measureLatencyWithCompletion:]";
      v30 = sub_100070AC8();
      _NRLogAbortWithPack(v30, v22);
    }
  }
  v6 = objc_alloc_init(NRDLatencyContext);
  if (!v6)
  {
    v18 = sub_100070AC8();
    v19 = _NRLogIsLevelEnabled(v18, 16);

    if (v19)
    {
      v20 = sub_100070AC8();
      _NRLogWithArgs(v20, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (latencyContext) != ((void *)0)", "", "-[NRLinkBluetooth measureLatencyWithCompletion:]", 2926);

    }
    v21 = _os_log_pack_size(12);
    v22 = (char *)&block[-1] - ((__chkstk_darwin(v21) + 15) & 0xFFFFFFFFFFFFFFF0);
    v23 = *__error();
    v24 = _os_log_pack_fill(v22, v21, v23, &_mh_execute_header, "%{public}s Assertion Failed: (latencyContext) != ((void *)0)");
    goto LABEL_13;
  }
  v8 = v6;
  objc_setProperty_nonatomic_copy(v6, v7, v3, 8);
  v9 = ++qword_1001E46B8;
  v8->_sequenceNumber = qword_1001E46B8;
  v11 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v10);
  v12 = _NRLogIsLevelEnabled(v11, 1);

  if (v12)
  {
    v14 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v13);
    v15 = objc_msgSend((id)a1, "copyDescription");
    _NRLogWithArgs(v14, 1, "%s%.30s:%-4d %@: Sending ping seq %llu", "", "-[NRLinkBluetooth measureLatencyWithCompletion:]", 2933, v15, v8->_sequenceNumber);

  }
  v33 = 1;
  v34 = bswap64(v9);
  v8->_startTime = sub_10008C79C((void *)a1, &v33, 9u, 1);
  objc_msgSend(*(id *)(a1 + 1207), "addObject:", v8);
  v16 = dispatch_time(0x8000000000000000, 10000000000);
  v17 = objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "queue"));
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10009F558;
  block[3] = &unk_1001B74F8;
  block[4] = a1;
  block[5] = v9;
  dispatch_after(v16, v17, block);

}

void sub_10009F558(uint64_t a1)
{
  sub_10008CB98(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), 0);
}

void sub_10009F568(uint64_t a1, void *a2, int a3)
{
  id v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  size_t v9;
  void *v10;
  int IsLevelEnabled;
  uint64_t v12;
  void *v13;
  id v14;
  void *v15;
  void *v16;
  id v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  void *v22;
  int v23;
  uint64_t v24;
  void *v25;
  id v26;
  void *v27;
  void *v28;
  id v29;
  id v30;
  int v31;
  id v32;
  id v33;
  int v34;
  id v35;
  uint64_t v36;
  char *v37;
  int *v38;
  uint64_t v39;
  id v40;
  id v41;

  v5 = a2;
  v41 = v5;
  if (!a3)
  {
    if (*(unsigned __int8 *)(a1 + 16) - 1 > 1)
    {
      sub_10008C2A4(a1, v5);
      v6 = 311;
      goto LABEL_12;
    }
    v7 = *(_DWORD *)(a1 + 311);
    v9 = v7 + objc_msgSend(v5, "length");
    if (*(_DWORD *)(a1 + 263) < v9)
    {
      v10 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v8);
      IsLevelEnabled = _NRLogIsLevelEnabled(v10, 0);

      if (IsLevelEnabled)
      {
        v13 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v12);
        v14 = objc_msgSend((id)a1, "copyDescription");
        _NRLogWithArgs(v13, 0, "%s%.30s:%-4d %@: increasing size of _linkReadBuffer %u -> %u", "", "-[NRLinkBluetooth processXPCCommMessage:isUrgentLink:]", 6084, v14, *(unsigned int *)(a1 + 263), v9);

      }
      v15 = reallocf(*(void **)(a1 + 1311), v9);
      if (!v15)
      {
        v30 = sub_100070AC8();
        v31 = _NRLogIsLevelEnabled(v30, 16);

        if (v31)
        {
          v32 = sub_100070AC8();
          _NRLogWithArgs(v32, 16, "%s%.30s:%-4d ABORTING: _strict_reallocf(%zu) failed", "", "_strict_reallocf", 139, v9);

        }
        goto LABEL_26;
      }
      *(_QWORD *)(a1 + 1311) = 0;
      *(_QWORD *)(a1 + 1311) = v15;
      *(_DWORD *)(a1 + 263) = v9;
      *(_DWORD *)(a1 + 271) = (*(_DWORD *)(a1 + 263) + 1) >> 1;
    }
    v16 = (void *)(*(_QWORD *)(a1 + 1311) + *(unsigned int *)(a1 + 311));
    v17 = objc_msgSend(v41, "bytes", v41);
    memcpy(v16, v17, (size_t)objc_msgSend(v41, "length"));
    *(_DWORD *)(a1 + 311) += objc_msgSend(v41, "length");
    v18 = a1;
    v19 = 0;
LABEL_19:
    sub_10008D068(v18, v19);
    goto LABEL_20;
  }
  if (!*(_BYTE *)(a1 + 229))
  {
    v20 = *(_DWORD *)(a1 + 319);
    v9 = v20 + objc_msgSend(v5, "length");
    if (*(_DWORD *)(a1 + 267) >= v9)
    {
LABEL_18:
      v28 = (void *)(*(_QWORD *)(a1 + 1319) + *(unsigned int *)(a1 + 319));
      v29 = objc_msgSend(v41, "bytes", v41);
      memcpy(v28, v29, (size_t)objc_msgSend(v41, "length"));
      *(_DWORD *)(a1 + 319) += objc_msgSend(v41, "length");
      v18 = a1;
      v19 = 1;
      goto LABEL_19;
    }
    v22 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v21);
    v23 = _NRLogIsLevelEnabled(v22, 0);

    if (v23)
    {
      v25 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v24);
      v26 = objc_msgSend((id)a1, "copyDescription");
      _NRLogWithArgs(v25, 0, "%s%.30s:%-4d %@: increasing size of _urgentLinkReadBuffer %u -> %u", "", "-[NRLinkBluetooth processXPCCommMessage:isUrgentLink:]", 6068, v26, *(unsigned int *)(a1 + 267), v9);

    }
    v27 = reallocf(*(void **)(a1 + 1319), v9);
    if (v27)
    {
      *(_QWORD *)(a1 + 1319) = 0;
      *(_QWORD *)(a1 + 1319) = v27;
      *(_DWORD *)(a1 + 267) = v9;
      *(_DWORD *)(a1 + 275) = (*(_DWORD *)(a1 + 267) + 1) >> 1;
      goto LABEL_18;
    }
    v33 = sub_100070AC8();
    v34 = _NRLogIsLevelEnabled(v33, 16);

    if (v34)
    {
      v35 = sub_100070AC8();
      _NRLogWithArgs(v35, 16, "%s%.30s:%-4d ABORTING: _strict_reallocf(%zu) failed", "", "_strict_reallocf", 139, v9);

    }
LABEL_26:
    v36 = _os_log_pack_size(22);
    v37 = (char *)&v41 - ((__chkstk_darwin(v36) + 15) & 0xFFFFFFFFFFFFFFF0);
    v38 = __error();
    v39 = _os_log_pack_fill(v37, v36, *v38, &_mh_execute_header, "%{public}s _strict_reallocf(%zu) failed");
    *(_DWORD *)v39 = 136446466;
    *(_QWORD *)(v39 + 4) = "_strict_reallocf";
    *(_WORD *)(v39 + 12) = 2048;
    *(_QWORD *)(v39 + 14) = v9;
    v40 = sub_100070AC8();
    _NRLogAbortWithPack(v40, v37);
  }
  sub_10008C2A4(a1, v5);
  v6 = 319;
LABEL_12:
  *(_DWORD *)(a1 + v6) = 0;
LABEL_20:

}

uint64_t sub_10009FA90(uint64_t a1)
{
  uint64_t result;
  id v3;
  id v4;
  void *v5;
  void *v6;
  void *v7;
  _QWORD v8[4];
  id v9;
  id location;
  char v11;
  id v12;

  if (objc_msgSend((id)a1, "state") == 255)
    return 0;
  result = (uint64_t)objc_msgSend((id)a1, "ikeClassDEstablished");
  if ((_DWORD)result)
  {
    objc_opt_self(NRLinkManagerWiFi);
    v11 = 1;
    v3 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &v11, 1);
    v4 = objc_msgSend(objc_alloc((Class)NEIKEv2PrivateNotify), "initWithNotifyStatus:notifyData:", 51401, v3);
    objc_initWeak(&location, (id)a1);
    v5 = *(void **)(a1 + 1223);
    v12 = v4;
    v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v12, 1));
    v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "queue"));
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472;
    v8[2] = sub_10009FC50;
    v8[3] = &unk_1001B7978;
    objc_copyWeak(&v9, &location);
    objc_msgSend(v5, "sendPrivateNotifies:maxRetries:retryIntervalInMilliseconds:callbackQueue:callback:", v6, 10, 10000, v7, v8);

    objc_destroyWeak(&v9);
    objc_destroyWeak(&location);

    return 1;
  }
  return result;
}

void sub_10009FC24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  id *v15;

  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10009FC50(uint64_t a1, int a2)
{
  _QWORD *WeakRetained;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  int IsLevelEnabled;
  uint64_t v8;
  void *v9;
  id v10;
  int v11;
  uint64_t v12;
  _QWORD *v13;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v13 = WeakRetained;
    v5 = _NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    v6 = (void *)v5;
    if (a2)
    {
      IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0);

      WeakRetained = v13;
      if (IsLevelEnabled)
      {
        v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v8);
        v10 = objc_msgSend(v13, "copyDescription");
        _NRLogWithArgs(v9, 0, "%s%.30s:%-4d %@: Received response to notify payloads", "", "-[NRLinkBluetooth sendAlwaysOnWiFiUpdate]_block_invoke", 7490, v10);
LABEL_7:

        WeakRetained = v13;
      }
    }
    else
    {
      v11 = _NRLogIsLevelEnabled(v5, 16);

      WeakRetained = v13;
      if (v11)
      {
        v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v12);
        v10 = objc_msgSend(v13, "copyDescription");
        _NRLogWithArgs(v9, 16, "%s%.30s:%-4d %@: Did not receive response to notify payloads", "", "-[NRLinkBluetooth sendAlwaysOnWiFiUpdate]_block_invoke", 7492, v10);
        goto LABEL_7;
      }
    }
  }

}

void sub_10009FD60(id a1)
{
  sub_100107D4C(CFSTR("/var/mobile/Library/terminus/com.apple.terminus.plist"));
}

void sub_10009FD6C(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001E46F8;
  qword_1001E46F8 = (uint64_t)v1;

}

void sub_10009FD9C(id a1)
{
  id v1;
  uint64_t v2;
  id v3;
  id v4;
  const char *v5;
  int v6;
  const char *v7;
  id v8;
  void *v9;
  __CFString *v10;

  v10 = (__CFString *)objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("-%s"), "563.0.3");
  if ((-[__CFString isEqualToString:](v10, "isEqualToString:", CFSTR("-")) & 1) != 0
    || -[__CFString isEqualToString:](v10, "isEqualToString:", CFSTR("-$RC_ProjectSourceVersion")))
  {

    v10 = &stru_1001B95A0;
  }
  v1 = objc_alloc((Class)NSString);
  v2 = getpid();
  if (qword_1001E4850 != -1)
    dispatch_once(&qword_1001E4850, &stru_1001B7B70);
  v3 = (id)qword_1001E4848;
  if (qword_1001E4860 != -1)
    dispatch_once(&qword_1001E4860, &stru_1001B7B90);
  v4 = (id)qword_1001E4858;
  if (_NRIsAppleInternal(v4))
    v5 = " internal";
  else
    v5 = "";
  v6 = _NRShouldDebugAutoRelease();
  v7 = " (NR_DEBUG_AUTORELEASE)";
  if (!v6)
    v7 = "";
  v8 = objc_msgSend(v1, "initWithFormat:", CFSTR("terminusd%@ pid %d built on %s %s, iphoneOS %@ \"%@\"%s%s"), v10, v2, "Aug  3 2024", "08:51:44", v3, v4, v5, v7);
  v9 = (void *)qword_1001E46E8;
  qword_1001E46E8 = (uint64_t)v8;

}

uint64_t sub_10009FF34(uint64_t a1)
{
  id v1;
  void *v2;
  void *v3;
  uint64_t v4;
  unsigned __int8 v5;
  _BOOL8 v6;

  if (!_NRIsAppleInternal(a1))
    return 1;
  os_unfair_lock_lock((os_unfair_lock_t)&unk_1001E46E0);
  v1 = objc_msgSend(objc_alloc((Class)NSDictionary), "initWithContentsOfFile:", CFSTR("/var/mobile/Library/terminus/com.apple.terminus.plist"));
  v2 = v1;
  if (v1)
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "objectForKeyedSubscript:", CFSTR("companionLinkEnabled")));
    v4 = objc_opt_class(NSNumber);
    if ((objc_opt_isKindOfClass(v3, v4) & 1) != 0)
      v5 = objc_msgSend(v3, "intValue");
    else
      v5 = 0;

  }
  else
  {
    v5 = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1001E46E0);
  v6 = v5 != 2;

  return v6;
}

void sub_1000A0004(uint64_t a1)
{
  id v2;
  void *v3;
  uint64_t v4;
  unsigned int v5;
  void *v6;
  int v7;
  NSObject *v8;
  id *v9;
  NSObject *v10;
  uint64_t v11;
  id v12;
  void *v13;
  id v14;
  const char *v15;
  id v16;
  id v17;

  os_unfair_lock_lock((os_unfair_lock_t)&unk_1001E46E0);
  v2 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithContentsOfFile:", CFSTR("/var/mobile/Library/terminus/com.apple.terminus.plist"));
  if (!v2)
    v2 = objc_alloc_init((Class)NSMutableDictionary);
  v17 = v2;
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "objectForKeyedSubscript:", CFSTR("companionLinkEnabled")));
  v4 = objc_opt_class(NSNumber);
  if ((objc_opt_isKindOfClass(v3, v4) & 1) != 0)
    v5 = objc_msgSend(v3, "intValue");
  else
    v5 = 0;
  v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", a1));
  objc_msgSend(v17, "setObject:forKeyedSubscript:", v6, CFSTR("companionLinkEnabled"));

  v7 = sub_10010754C(CFSTR("/var/mobile/Library/terminus/com.apple.terminus.plist"), v17, 1);
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1001E46E0);
  v8 = sub_10014CFBC();
  dispatch_async(v8, &stru_1001B69F0);

  objc_opt_self(NRLinkDirector);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  v9 = (id *)(id)qword_1001E4708;
  if (v9)
  {
    v10 = sub_10014CFBC();
    dispatch_assert_queue_V2(v10);

    if (sub_10009FF34(v11))
      sub_1000A35A0(v9);
    else
      sub_1000A4A20((uint64_t)v9);
  }

  v12 = objc_alloc((Class)NSString);
  v13 = *(&off_1001B6E48 + a1);
  if (v5 >= 3)
    v14 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("Unknown[%lld]"), v5);
  else
    v14 = *(&off_1001B6E48 + v5);
  v15 = " (WRITE FAILED)";
  if (v7)
    v15 = "";
  v16 = objc_msgSend(v12, "initWithFormat:", CFSTR("Set companion link to %@ (previously was %@)%s"), v13, v14, v15);

  sub_100121E18(0, 9001, &stru_1001B95A0, v16);
}

void sub_1000A0244(void *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id v7;
  void *v8;
  void *v9;
  void *v10;
  id v11;
  void *v12;
  void *v13;
  int v14;
  id v15;

  v15 = a1;
  v5 = a2;
  v6 = a3;
  os_unfair_lock_lock((os_unfair_lock_t)&unk_1001E46E0);
  v7 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithContentsOfFile:", CFSTR("/var/mobile/Library/terminus/com.apple.terminus.plist"));
  if (!v7)
  {
    v7 = objc_alloc_init((Class)NSMutableDictionary);
    v8 = v15;
    if (v15)
      goto LABEL_3;
LABEL_6:
    objc_msgSend(v7, "setObject:forKeyedSubscript:", v6, v5);
    goto LABEL_9;
  }
  v8 = v15;
  if (!v15)
    goto LABEL_6;
LABEL_3:
  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "UUIDString"));
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", v9));

  if (v10)
    v11 = objc_msgSend(v10, "mutableCopy");
  else
    v11 = objc_alloc_init((Class)NSMutableDictionary);
  v12 = v11;
  objc_msgSend(v11, "setObject:forKeyedSubscript:", v6, v5);
  v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "UUIDString"));
  objc_msgSend(v7, "setObject:forKeyedSubscript:", v12, v13);

LABEL_9:
  v14 = sub_10010754C(CFSTR("/var/mobile/Library/terminus/com.apple.terminus.plist"), v7, 1);
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1001E46E0);
  if (v14)
  {
    if (qword_1001E4700 != -1)
      dispatch_once(&qword_1001E4700, &stru_1001B6E28);
    if (_NRLogIsLevelEnabled(qword_1001E46F8, 0))
    {
      if (qword_1001E4700 != -1)
        dispatch_once(&qword_1001E4700, &stru_1001B6E28);
      _NRLogWithArgs(qword_1001E46F8, 0, "%s%.30s:%-4d Successfully wrote '%@':%@", "", "terminusdSettingsSetValueForKey", 279, v5, v6);
    }
  }
  else
  {
    if (qword_1001E4700 != -1)
      dispatch_once(&qword_1001E4700, &stru_1001B6E28);
    if (_NRLogIsLevelEnabled(qword_1001E46F8, 17))
    {
      if (qword_1001E4700 != -1)
        dispatch_once(&qword_1001E4700, &stru_1001B6E28);
      _NRLogWithArgs(qword_1001E46F8, 17, "Failed to write '%@':%@", v5, v6);
    }
  }

}

void sub_1000A04A0(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  void *v6;
  id v7;
  id v8;
  void *v9;
  int v10;
  id v11;
  id v12;
  id v13;

  v13 = a1;
  v3 = a2;
  os_unfair_lock_lock((os_unfair_lock_t)&unk_1001E46E0);
  v4 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithContentsOfFile:", CFSTR("/var/mobile/Library/terminus/com.apple.terminus.plist"));
  if (v4)
  {
    if (v13)
    {
      v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "UUIDString"));
      v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "objectForKeyedSubscript:", v5));

      if (v6)
      {
        if (v3)
        {
          v7 = objc_msgSend(v6, "mutableCopy");
          objc_msgSend(v7, "removeObjectForKey:", v3);
        }
        else
        {
          v7 = 0;
        }
        v8 = objc_msgSend(v7, "count");
        v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "UUIDString"));
        if (v8)
          objc_msgSend(v4, "setObject:forKeyedSubscript:", v7, v9);
        else
          objc_msgSend(v4, "removeObjectForKey:", v9);

      }
    }
    else
    {
      objc_msgSend(v4, "removeObjectForKey:", v3);
    }
    v10 = sub_10010754C(CFSTR("/var/mobile/Library/terminus/com.apple.terminus.plist"), v4, 1);
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_1001E46E0);
    if (v10)
    {
      if (qword_1001E4700 != -1)
        dispatch_once(&qword_1001E4700, &stru_1001B6E28);
      if (_NRLogIsLevelEnabled(qword_1001E46F8, 0))
      {
        if (qword_1001E4700 != -1)
          dispatch_once(&qword_1001E4700, &stru_1001B6E28);
        if (v3)
          v11 = v3;
        else
          v11 = v13;
        _NRLogWithArgs(qword_1001E46F8, 0, "%s%.30s:%-4d Successfully removed value for '%@'", "", "terminusdSettingsRemoveValueForKey", 318, v11);
      }
    }
    else
    {
      if (qword_1001E4700 != -1)
        dispatch_once(&qword_1001E4700, &stru_1001B6E28);
      if (_NRLogIsLevelEnabled(qword_1001E46F8, 17))
      {
        if (qword_1001E4700 != -1)
          dispatch_once(&qword_1001E4700, &stru_1001B6E28);
        if (v3)
          v12 = v3;
        else
          v12 = v13;
        _NRLogWithArgs(qword_1001E46F8, 17, "Failed to write '%@'", v12);
      }
    }
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_1001E46E0);
  }

}

id sub_1000A0710(void *a1, void *a2)
{
  id v3;
  id v4;
  id v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;

  v3 = a1;
  v4 = a2;
  os_unfair_lock_lock((os_unfair_lock_t)&unk_1001E46E0);
  v5 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithContentsOfFile:", CFSTR("/var/mobile/Library/terminus/com.apple.terminus.plist"));
  v6 = v5;
  if (v3)
  {
    v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "UUIDString"));
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectForKeyedSubscript:", v7));

    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "objectForKeyedSubscript:", v4));
  }
  else
  {
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", v4));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1001E46E0);
  if (v9)
  {
    if (qword_1001E4700 != -1)
      dispatch_once(&qword_1001E4700, &stru_1001B6E28);
    if (_NRLogIsLevelEnabled(qword_1001E46F8, 0))
    {
      if (qword_1001E4700 != -1)
        dispatch_once(&qword_1001E4700, &stru_1001B6E28);
      _NRLogWithArgs(qword_1001E46F8, 0, "%s%.30s:%-4d Successfully fetched '%@':%@", "", "terminusdSettingsGetValueForKey", 339, v4, v9);
    }
  }
  else
  {
    if (qword_1001E4700 != -1)
      dispatch_once(&qword_1001E4700, &stru_1001B6E28);
    if (_NRLogIsLevelEnabled(qword_1001E46F8, 0))
    {
      if (qword_1001E4700 != -1)
        dispatch_once(&qword_1001E4700, &stru_1001B6E28);
      _NRLogWithArgs(qword_1001E46F8, 0, "%s%.30s:%-4d No value for '%@'", "", "terminusdSettingsGetValueForKey", 341, v4);
    }
  }

  return v9;
}

void sub_1000A25C4(uint64_t a1, int a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  id v10;
  id v11;

  if (a1)
  {
    v10 = a3;
    v11 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:arguments:", v10, &a9);

    sub_100121E18(0, a2, 0, v11);
  }
}

id sub_1000A2640()
{
  if (qword_1001E4738 != -1)
    dispatch_once(&qword_1001E4738, &stru_1001B7110);
  return (id)qword_1001E4730;
}

void sub_1000A2680(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001E4730;
  qword_1001E4730 = (uint64_t)v1;

}

void sub_1000A26B0(uint64_t a1)
{
  uint64_t v1;
  id v2;
  id v3;
  id v4;
  id v5;
  uint64_t v6;
  void *i;
  void *v8;
  void *v9;
  id v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  id v14;
  id v15;
  id v16;
  uint64_t v17;
  void *j;
  void *v19;
  void *v20;
  id v21;
  void *v22;
  void *v23;
  id v24;
  id v25;
  id v26;
  id v27;
  id v28;
  id v29;
  uint64_t v30;
  void *k;
  void *v32;
  void *v33;
  id v34;
  void *v35;
  void *v36;
  id v37;
  id v38;
  id v39;
  id v40;
  id *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  id v45;
  id v46;
  id v47;
  uint64_t v48;
  void *m;
  _BYTE *v50;
  uint64_t v51;
  id v52;
  id obj;
  uint64_t v54;
  uint64_t v55;
  id v56;
  id v57;
  void *v58;
  uint64_t v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  _BYTE v80[128];
  void *v81;
  uint64_t v82;
  _BYTE v83[128];
  _QWORD v84[2];
  _BYTE v85[128];
  _BYTE v86[128];
  _BYTE v87[128];

  if (a1)
  {
    v1 = a1;
    if (*(_QWORD *)(a1 + 296))
    {
      v2 = objc_alloc_init((Class)NSMutableSet);
      v76 = 0u;
      v77 = 0u;
      v78 = 0u;
      v79 = 0u;
      v3 = *(id *)(v1 + 200);
      v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v76, v87, 16);
      if (v4)
      {
        v5 = v4;
        v6 = *(_QWORD *)v77;
        do
        {
          for (i = 0; i != v5; i = (char *)i + 1)
          {
            if (*(_QWORD *)v77 != v6)
              objc_enumerationMutation(v3);
            v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v1 + 200), "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v76 + 1) + 8 * (_QWORD)i)));
            v9 = sub_1000E0118((uint64_t)v8);

            if (objc_msgSend(v9, "count"))
              objc_msgSend(v2, "addObjectsFromArray:", v9);

          }
          v5 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v76, v87, 16);
        }
        while (v5);
      }

      if (objc_msgSend(v2, "count"))
      {
        objc_opt_self(NRDPolicySessionManager);
        if (qword_1001E4A20 != -1)
          dispatch_once(&qword_1001E4A20, &stru_1001B8590);
        v10 = (id)qword_1001E4A18;
        sub_100127618((uint64_t)v10, CFSTR("NRLinkDirector-AppVPN"));

        v56 = objc_alloc_init((Class)NSMutableArray);
        v72 = 0u;
        v73 = 0u;
        v74 = 0u;
        v75 = 0u;
        v52 = v2;
        obj = v2;
        v57 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v72, v86, 16);
        v55 = v1;
        if (v57)
        {
          v54 = *(_QWORD *)v73;
          do
          {
            v11 = 0;
            do
            {
              if (*(_QWORD *)v73 != v54)
                objc_enumerationMutation(obj);
              v59 = v11;
              v12 = *(_QWORD *)(*((_QWORD *)&v72 + 1) + 8 * v11);
              v13 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyRouteRule routeRuleWithAction:forNetworkAgent:](NEPolicyRouteRule, "routeRuleWithAction:forNetworkAgent:", 6, *(_QWORD *)(v1 + 296)));
              objc_msgSend(v13, "setNetworkAgentUUID:", v12);
              v58 = v13;
              objc_msgSend(v56, "addObject:", v13);
              v70 = 0u;
              v71 = 0u;
              v68 = 0u;
              v69 = 0u;
              v14 = *(id *)(v1 + 304);
              v15 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v68, v85, 16);
              if (v15)
              {
                v16 = v15;
                v17 = *(_QWORD *)v69;
                do
                {
                  for (j = 0; j != v16; j = (char *)j + 1)
                  {
                    if (*(_QWORD *)v69 != v17)
                      objc_enumerationMutation(v14);
                    v19 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition effectiveApplication:](NEPolicyCondition, "effectiveApplication:", *(_QWORD *)(*((_QWORD *)&v68 + 1) + 8 * (_QWORD)j)));
                    v20 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult removeNetworkAgentUUID:](NEPolicyResult, "removeNetworkAgentUUID:", v12));
                    v21 = objc_alloc((Class)NEPolicy);
                    v22 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](NEPolicyCondition, "allInterfaces"));
                    v84[0] = v22;
                    v84[1] = v19;
                    v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v84, 2));
                    v24 = objc_msgSend(v21, "initWithOrder:result:conditions:", 5, v20, v23);

                    objc_opt_self(NRDPolicySessionManager);
                    if (qword_1001E4A20 != -1)
                      dispatch_once(&qword_1001E4A20, &stru_1001B8590);
                    v25 = (id)qword_1001E4A18;
                    v26 = sub_100127310((uint64_t)v25, CFSTR("NRLinkDirector-AppVPN"), v24);

                  }
                  v16 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v68, v85, 16);
                }
                while (v16);
              }

              v11 = v59 + 1;
              v1 = v55;
            }
            while ((id)(v59 + 1) != v57);
            v57 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v72, v86, 16);
          }
          while (v57);
        }

        if (objc_msgSend(v56, "count"))
        {
          if (qword_1001E4738 != -1)
            dispatch_once(&qword_1001E4738, &stru_1001B7110);
          if (_NRLogIsLevelEnabled(qword_1001E4730, 2))
          {
            if (qword_1001E4738 != -1)
              dispatch_once(&qword_1001E4738, &stru_1001B7110);
            _NRLogWithArgs(qword_1001E4730, 2, "%s%.30s:%-4d adding appVPN route-rule(s) %@", "", "-[NRLinkDirector setupAppVPNPolicies]", 2418, v56);
          }
          v66 = 0u;
          v67 = 0u;
          v64 = 0u;
          v65 = 0u;
          v27 = v56;
          v28 = objc_msgSend(v27, "countByEnumeratingWithState:objects:count:", &v64, v83, 16);
          if (v28)
          {
            v29 = v28;
            v30 = *(_QWORD *)v65;
            do
            {
              for (k = 0; k != v29; k = (char *)k + 1)
              {
                if (*(_QWORD *)v65 != v30)
                  objc_enumerationMutation(v27);
                v82 = *(_QWORD *)(*((_QWORD *)&v64 + 1) + 8 * (_QWORD)k);
                v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v82, 1));
                v33 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult routeRules:](NEPolicyResult, "routeRules:", v32));

                v34 = objc_alloc((Class)NEPolicy);
                v35 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](NEPolicyCondition, "allInterfaces"));
                v81 = v35;
                v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v81, 1));
                v37 = objc_msgSend(v34, "initWithOrder:result:conditions:", 5, v33, v36);

                objc_opt_self(NRDPolicySessionManager);
                if (qword_1001E4A20 != -1)
                  dispatch_once(&qword_1001E4A20, &stru_1001B8590);
                v38 = (id)qword_1001E4A18;
                v39 = sub_100127310((uint64_t)v38, CFSTR("NRLinkDirector-AppVPN"), v37);

              }
              v29 = objc_msgSend(v27, "countByEnumeratingWithState:objects:count:", &v64, v83, 16);
            }
            while (v29);
          }

          v1 = v55;
        }
        objc_opt_self(NRDPolicySessionManager);
        v2 = v52;
        if (qword_1001E4A20 != -1)
          dispatch_once(&qword_1001E4A20, &stru_1001B8590);
        v40 = (id)qword_1001E4A18;
        v41 = (id *)v40;
        if (v40)
        {
          dispatch_assert_queue_V2(*((dispatch_queue_t *)v40 + 1));
          if ((objc_msgSend(v41[2], "apply") & 1) == 0)
            sub_100109270(CFSTR("NRPolicySessionManager"), CFSTR("ApplyPolicy Failed"), 0, 1, CFSTR("Failed to apply policies"), v42, v43, v44, v51);
        }

        v62 = 0u;
        v63 = 0u;
        v60 = 0u;
        v61 = 0u;
        v45 = *(id *)(v1 + 200);
        v46 = objc_msgSend(v45, "countByEnumeratingWithState:objects:count:", &v60, v80, 16);
        if (v46)
        {
          v47 = v46;
          v48 = *(_QWORD *)v61;
          do
          {
            for (m = 0; m != v47; m = (char *)m + 1)
            {
              if (*(_QWORD *)v61 != v48)
                objc_enumerationMutation(v45);
              v50 = (_BYTE *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v1 + 200), "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v60 + 1) + 8 * (_QWORD)m)));
              sub_1000EFA44(v50, 1);

            }
            v47 = objc_msgSend(v45, "countByEnumeratingWithState:objects:count:", &v60, v80, 16);
          }
          while (v47);
        }

      }
      else
      {
        sub_1000A2E80(v1);
      }

    }
  }
}

void sub_1000A2E80(uint64_t a1)
{
  id v2;
  id v3;
  id v4;
  uint64_t v5;
  void *i;
  _BYTE *v7;
  id v8;
  id v9;
  id *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  _BYTE v19[128];

  v15 = 0u;
  v16 = 0u;
  v17 = 0u;
  v18 = 0u;
  v2 = *(id *)(a1 + 200);
  v3 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v15, v19, 16);
  if (v3)
  {
    v4 = v3;
    v5 = *(_QWORD *)v16;
    do
    {
      for (i = 0; i != v4; i = (char *)i + 1)
      {
        if (*(_QWORD *)v16 != v5)
          objc_enumerationMutation(v2);
        v7 = (_BYTE *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 200), "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v15 + 1) + 8 * (_QWORD)i), (_QWORD)v15));
        sub_1000EFA44(v7, 0);

      }
      v4 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v15, v19, 16);
    }
    while (v4);
  }

  objc_opt_self(NRDPolicySessionManager);
  if (qword_1001E4A20 != -1)
    dispatch_once(&qword_1001E4A20, &stru_1001B8590);
  v8 = (id)qword_1001E4A18;
  sub_100127618((uint64_t)v8, CFSTR("NRLinkDirector-AppVPN"));

  objc_opt_self(NRDPolicySessionManager);
  if (qword_1001E4A20 != -1)
    dispatch_once(&qword_1001E4A20, &stru_1001B8590);
  v9 = (id)qword_1001E4A18;
  v10 = (id *)v9;
  if (v9)
  {
    dispatch_assert_queue_V2(*((dispatch_queue_t *)v9 + 1));
    if ((objc_msgSend(v10[2], "apply") & 1) == 0)
      sub_100109270(CFSTR("NRPolicySessionManager"), CFSTR("ApplyPolicy Failed"), 0, 1, CFSTR("Failed to apply policies"), v11, v12, v13, v15);
  }

  v14 = *(void **)(a1 + 296);
  *(_QWORD *)(a1 + 296) = 0;

  *(_BYTE *)(a1 + 18) = 0;
}

id sub_1000A3074(uint64_t a1)
{
  id v1;
  const char *v2;

  switch((int)a1)
  {
    case 1001:
      v1 = objc_alloc((Class)NSString);
      v2 = "Initial";
      return objc_msgSend(v1, "initWithUTF8String:", v2);
    case 1002:
      v1 = objc_alloc((Class)NSString);
      v2 = "Start";
      return objc_msgSend(v1, "initWithUTF8String:", v2);
    case 1003:
      v1 = objc_alloc((Class)NSString);
      v2 = "Ready";
      return objc_msgSend(v1, "initWithUTF8String:", v2);
    case 1004:
      v1 = objc_alloc((Class)NSString);
      v2 = "Cancelled";
      return objc_msgSend(v1, "initWithUTF8String:", v2);
    default:
      if ((_DWORD)a1)
        return objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("Unknown(%u)"), a1);
      v1 = objc_alloc((Class)NSString);
      v2 = "Invalid";
      return objc_msgSend(v1, "initWithUTF8String:", v2);
  }
}

id sub_1000A315C(uint64_t a1)
{
  objc_opt_self(a1);
  if (qword_1001E4710 != -1)
    dispatch_once(&qword_1001E4710, &stru_1001B6E60);
  return (id)qword_1001E4708;
}

void sub_1000A31A0(id a1)
{
  _QWORD *v1;
  void *v2;

  v1 = sub_1000A31CC([NRLinkDirector alloc]);
  v2 = (void *)qword_1001E4708;
  qword_1001E4708 = (uint64_t)v1;

}

_QWORD *sub_1000A31CC(_QWORD *a1)
{
  _QWORD *v1;
  NSObject *v2;
  _QWORD *v3;
  _QWORD *v4;
  id v5;
  void *v6;
  id v7;
  void *v8;
  id v9;
  void *v10;
  id v11;
  void *v12;
  id v13;
  void *v14;
  void *v15;
  _QWORD *v16;
  id v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  uint64_t v21;
  void *v22;
  id v24;
  int IsLevelEnabled;
  id v26;
  uint64_t v27;
  char *v28;
  int *v29;
  uint64_t v30;
  id v31;
  _QWORD v32[4];
  id v33;
  objc_super v34;

  v1 = a1;
  if (a1)
  {
    v2 = sub_10014CFBC();
    dispatch_assert_queue_V2(v2);

    v34.receiver = v1;
    v34.super_class = (Class)NRLinkDirector;
    v3 = objc_msgSendSuper2(&v34, "init");
    if (!v3)
    {
      v24 = sub_1000A2640();
      IsLevelEnabled = _NRLogIsLevelEnabled(v24, 16);

      if (IsLevelEnabled)
      {
        v26 = sub_1000A2640();
        _NRLogWithArgs(v26, 16, "%s%.30s:%-4d ABORTING: [super init] failed", "", "-[NRLinkDirector initDirector]", 247);

      }
      v27 = _os_log_pack_size(12);
      v28 = (char *)v32 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
      v29 = __error();
      v30 = _os_log_pack_fill(v28, v27, *v29, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)v30 = 136446210;
      *(_QWORD *)(v30 + 4) = "-[NRLinkDirector initDirector]";
      v31 = sub_1000A2640();
      _NRLogAbortWithPack(v31, v28);
    }
    v4 = v3;
    v5 = objc_alloc_init((Class)NSMutableDictionary);
    v6 = (void *)v4[25];
    v4[25] = v5;

    v7 = objc_alloc_init((Class)NSMutableSet);
    v8 = (void *)v4[26];
    v4[26] = v7;

    v9 = objc_alloc_init((Class)NSMutableSet);
    v10 = (void *)v4[27];
    v4[27] = v9;

    v11 = objc_alloc_init((Class)NSMutableSet);
    v12 = (void *)v4[28];
    v4[28] = v11;

    sub_100121E18(0, 1000, 0, 0);
    v4[3] = -1;
    v13 = sub_10014CFBC();
    v14 = (void *)v4[15];
    v4[15] = v13;

    v15 = (void *)v4[15];
    v32[0] = _NSConcreteStackBlock;
    v32[1] = 3221225472;
    v32[2] = sub_1000A3434;
    v32[3] = &unk_1001B6E88;
    v16 = v4;
    v33 = v16;
    v17 = v15;
    *((_BYTE *)v16 + 16) = ne_session_is_always_on_vpn_enabled(v17, v32, v18, v19);

    v20 = sub_10014CFBC();
    dispatch_assert_queue_V2(v20);

    if (sub_10009FF34(v21))
      sub_1000A35A0((id *)v16);
    else
      sub_1000A4A20((uint64_t)v16);
    v22 = v33;
    v1 = v16;

  }
  return v1;
}

void sub_1000A3434(uint64_t a1, int a2)
{
  int v4;
  uint64_t v5;
  id *v6;
  NSObject *v7;
  NSObject *v8;
  uint64_t v9;

  if (*(_QWORD *)(a1 + 32))
  {
    v4 = a2 ? 1037 : 1038;
    sub_100121E18(0, v4, 0, 0);
    v5 = *(_QWORD *)(a1 + 32);
    if (v5)
    {
      if ((*(_BYTE *)(v5 + 16) != 0) != a2)
      {
        *(_BYTE *)(v5 + 16) = a2;
        v6 = *(id **)(a1 + 32);
        if (v6)
        {
          v7 = sub_10014CFBC();
          dispatch_assert_queue_V2(v7);

          if (qword_1001E4738 != -1)
            dispatch_once(&qword_1001E4738, &stru_1001B7110);
          if (_NRLogIsLevelEnabled(qword_1001E4730, 0))
          {
            if (qword_1001E4738 != -1)
              dispatch_once(&qword_1001E4738, &stru_1001B7110);
            _NRLogWithArgs(qword_1001E4730, 0, "%s%.30s:%-4d Restarting link director", "", "-[NRLinkDirector restartDirector]", 331);
          }
          sub_1000A4A20((uint64_t)v6);
          v8 = sub_10014CFBC();
          dispatch_assert_queue_V2(v8);

          if (sub_10009FF34(v9))
            sub_1000A35A0(v6);
          else
            sub_1000A4A20((uint64_t)v6);
        }
      }
    }
  }
}

void sub_1000A35A0(id *a1)
{
  NSObject *v2;
  NSObject *v3;
  uint64_t v4;
  NRDTestServer *v5;
  id v6;
  char *v7;
  id v8;
  uint64_t v9;
  id v10;
  void *v11;
  id v12;
  void *v13;
  id v14;
  void *v15;
  id v16;
  void *v17;
  id v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  id *v23;
  id v24;
  id v25;
  uint64_t IsLevelEnabled;
  NRLinkManagerBluetooth *v27;
  NSObject *v28;
  id *v29;
  _BYTE *v30;
  uint64_t v31;
  id v32;
  void *v33;
  id v34;
  void *v35;
  id v36;
  void *v37;
  id v38;
  void *v39;
  NRLinkManagerBluetooth *v40;
  id v41;
  id v42;
  NROnDemandLinkSetupManager *v43;
  id v44;
  id *v45;
  uint64_t *v46;
  id v47;
  uint64_t v48;
  _DWORD *v49;
  objc_super *v50;
  NSObject *v51;
  uint32_t v52;
  id v53;
  char v54;
  id v55;
  objc_super *v56;
  void *v57;
  uint64_t v58;
  id v59;
  void *v60;
  uint64_t v61;
  id v62;
  uint64_t v63;
  NSObject *v64;
  id v65;
  id v66;
  id v67;
  uint64_t v68;
  void *i;
  uint64_t v70;
  uint64_t v71;
  void *v72;
  id v73;
  id v74;
  id v75;
  uint64_t v76;
  void *j;
  char *v78;
  char *v79;
  void *v80;
  void *v81;
  void *v82;
  unsigned int v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  id v89;
  void *v90;
  __objc2_prot *v91;
  __objc2_class *v92;
  NSObject *v93;
  id v94;
  id v95;
  void *v96;
  char *v97;
  id v98;
  void *v99;
  char *v100;
  id v101;
  id v102;
  id v103;
  id *v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  void *v108;
  NSObject *v109;
  id v110;
  int v111;
  id v112;
  int *v113;
  uint64_t v114;
  id v115;
  id v116;
  int v117;
  id v118;
  int *v119;
  uint64_t v120;
  id v121;
  id v122;
  int v123;
  id v124;
  int v125;
  id v126;
  id v127;
  int v128;
  id v129;
  uint64_t v130;
  id *v131;
  int v132;
  id location;
  __int128 from;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  _QWORD v138[2];
  objc_super block;
  void *v140;
  void *v141;
  id v142[12];

  v2 = sub_10014CFBC();
  dispatch_assert_queue_V2(v2);

  if (*((_BYTE *)a1 + 12))
  {
    if (qword_1001E4738 != -1)
      dispatch_once(&qword_1001E4738, &stru_1001B7110);
    if (_NRLogIsLevelEnabled(qword_1001E4730, 1))
    {
      if (qword_1001E4738 != -1)
        dispatch_once(&qword_1001E4738, &stru_1001B7110);
      _NRLogWithArgs(qword_1001E4730, 1, "%s%.30s:%-4d Skipping start as director is already enabled", "", "-[NRLinkDirector startDirector]", 282);
    }
    return;
  }
  *((_BYTE *)a1 + 12) = 1;
  sub_100121E18(0, 1001, 0, 0);
  *((_BYTE *)a1 + 10) = 0;
  if (_os_feature_enabled_impl("terminus", "BluetoothPacketParser"))
  {
    *((_BYTE *)a1 + 10) = 1;
    dword_1001E40CC = 64;
  }
  if (*((_BYTE *)a1 + 16))
    sub_100121E18(0, 1032, 0, 0);
  v3 = sub_10014CFBC();
  dispatch_assert_queue_V2(v3);

  v131 = a1;
  if (!_NRIsAppleInternal(v4))
    goto LABEL_49;
  if (qword_1001E4738 != -1)
    dispatch_once(&qword_1001E4738, &stru_1001B7110);
  if (_NRLogIsLevelEnabled(qword_1001E4730, 0))
  {
    if (qword_1001E4738 != -1)
      dispatch_once(&qword_1001E4738, &stru_1001B7110);
    _NRLogWithArgs(qword_1001E4730, 0, "%s%.30s:%-4d starting test server", "", "-[NRLinkDirector setupManagers]", 440);
  }
  v5 = [NRDTestServer alloc];
  v6 = a1[15];
  v7 = sub_10005AF8C((id *)&v5->super.isa, v6);
  v8 = a1[23];
  a1[23] = v7;

  v9 = (uint64_t)a1[23];
  if (v9)
    goto LABEL_150;
  if (qword_1001E4738 != -1)
    dispatch_once(&qword_1001E4738, &stru_1001B7110);
  if (_NRLogIsLevelEnabled(qword_1001E4730, 17))
  {
    if (qword_1001E4738 != -1)
      dispatch_once(&qword_1001E4738, &stru_1001B7110);
    _NRLogWithArgs(qword_1001E4730, 17, "[[NRDTestServer alloc] initTestServerWithQueue:] failed");
  }
  v9 = (uint64_t)a1[23];
  if (v9)
  {
LABEL_150:
    if (*(_BYTE *)(v9 + 8))
    {
      if (qword_1001E4620 != -1)
        dispatch_once(&qword_1001E4620, &stru_1001B6910);
      if (_NRLogIsLevelEnabled(qword_1001E4618, 16))
      {
        if (qword_1001E4620 != -1)
          dispatch_once(&qword_1001E4620, &stru_1001B6910);
        _NRLogWithArgs(qword_1001E4618, 16, "%s%.30s:%-4d Already started. Ignoring", "", "-[NRDTestServer start]", 251);
      }
    }
    else
    {
      *(_BYTE *)(v9 + 8) = 1;
      sub_100121E18(0, 9002, 0, 0);
      if (!*(_QWORD *)(v9 + 24))
      {
        v10 = sub_10005C008(v9, 0);
        v11 = *(void **)(v9 + 24);
        *(_QWORD *)(v9 + 24) = v10;

      }
      if (!*(_QWORD *)(v9 + 32))
      {
        v12 = sub_10005C008(v9, 1);
        v13 = *(void **)(v9 + 32);
        *(_QWORD *)(v9 + 32) = v12;

      }
    }
  }
  v14 = sub_1000A0710(0, CFSTR("FixedInterfacePeerIDSDeviceID"));
  v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
  v16 = sub_1000A0710(0, CFSTR("FixedInterfaceName"));
  v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
  v18 = sub_1000A0710(0, CFSTR("FixedInterfacePeerAddress"));
  v19 = (void *)objc_claimAutoreleasedReturnValue(v18);
  if (!v15 || (v20 = objc_opt_class(NSString), (objc_opt_isKindOfClass(v15, v20) & 1) == 0))
  {
    if (!v17
      || !v19
      || (v21 = objc_opt_class(NSString), (objc_opt_isKindOfClass(v17, v21) & 1) == 0)
      || (v22 = objc_opt_class(NSString), (objc_opt_isKindOfClass(v19, v22) & 1) == 0))
    {

      a1 = v131;
LABEL_49:
      if (*((_BYTE *)a1 + 16))
      {
        if (qword_1001E4738 != -1)
          dispatch_once(&qword_1001E4738, &stru_1001B7110);
        IsLevelEnabled = _NRLogIsLevelEnabled(qword_1001E4730, 0);
        if ((_DWORD)IsLevelEnabled)
        {
          if (qword_1001E4738 != -1)
            dispatch_once(&qword_1001E4738, &stru_1001B7110);
          IsLevelEnabled = _NRLogWithArgs(qword_1001E4730, 0, "%s%.30s:%-4d Not initializing managers as AOVPN is configured", "", "-[NRLinkDirector setupManagers]", 488);
        }
        goto LABEL_85;
      }
      if (qword_1001E4870 != -1)
        dispatch_once(&qword_1001E4870, &stru_1001B7BB0);
      if (byte_1001E4868)
      {
        v122 = sub_1000A2640();
        v123 = _NRLogIsLevelEnabled(v122, 0);

        if (!v123)
          goto LABEL_65;
        v28 = sub_1000A2640();
        _NRLogWithArgs(v28, 0, "%s%.30s:%-4d Skipping initialization of NRLinkManagerBluetooth for unsupported device", "", "-[NRLinkDirector setupManagers]", 497);
LABEL_64:

        a1 = v131;
LABEL_65:
        objc_opt_self(NRDKeyManager);
        if (qword_1001E4AD8 != -1)
          dispatch_once(&qword_1001E4AD8, &stru_1001B8968);
        v42 = (id)qword_1001E4AD0;
        *(_QWORD *)&from = _NSConcreteStackBlock;
        *((_QWORD *)&from + 1) = 3221225472;
        *(_QWORD *)&v135 = sub_1000ADDD4;
        *((_QWORD *)&v135 + 1) = &unk_1001B8AE0;
        *(_QWORD *)&v136 = a1;
        sub_10014ACE0((uint64_t)v42, &from);

        sub_1000ADCD8((uint64_t)v131);
        if (!v131[22])
        {
          v43 = [NROnDemandLinkSetupManager alloc];
          v44 = v131[15];
          v45 = sub_100013BCC((id *)&v43->super.isa, v44);
          v47 = v131[22];
          v46 = (uint64_t *)(v131 + 22);
          v131[22] = v45;

          v48 = *v46;
          if (*v46)
          {
            if (!*(_BYTE *)(v48 + 8))
            {
              *(_BYTE *)(v48 + 8) = 1;
              v49 = (_DWORD *)(v48 + 20);
              if (*(_DWORD *)(v48 + 20) == -1)
              {
                objc_initWeak(&location, (id)v48);
                block.receiver = _NSConcreteStackBlock;
                block.super_class = (Class)3221225472;
                v140 = sub_1000153FC;
                v141 = &unk_1001B8990;
                objc_copyWeak(v142, &location);
                v50 = objc_retainBlock(&block);
                v51 = *(id *)(v48 + 32);
                v52 = notify_register_dispatch("com.apple.CoreTelephony.Slicing.LLPHS.State", (int *)(v48 + 20), v51, v50);

                if (v52)
                {
                  *v49 = -1;
                  if (qword_1001E4518 != -1)
                    dispatch_once(&qword_1001E4518, &stru_1001B6140);
                  v53 = (id)qword_1001E4510;
                  v54 = _NRLogIsLevelEnabled(v53, 17);

                  if ((v54 & 1) != 0)
                  {
                    if (qword_1001E4518 != -1)
                      dispatch_once(&qword_1001E4518, &stru_1001B6140);
                    v55 = (id)qword_1001E4510;
                    _NRLogWithArgs(v55, 17, "notify_register_check(%s) failed: %u", "com.apple.CoreTelephony.Slicing.LLPHS.State", v52);

                  }
                }
                else
                {
                  ((void (*)(objc_super *, _QWORD))v50[1].receiver)(v50, *v49);
                }

                objc_destroyWeak(v142);
                objc_destroyWeak(&location);
              }
              objc_initWeak(&location, (id)v48);
              v108 = *(void **)(v48 + 32);
              block.receiver = _NSConcreteStackBlock;
              block.super_class = (Class)3221225472;
              v140 = sub_100013D74;
              v141 = &unk_1001B7F28;
              v109 = v108;
              objc_copyWeak(v142, &location);
              dispatch_async(v109, &block);

              objc_destroyWeak(v142);
              objc_destroyWeak(&location);
            }
          }
        }
        goto LABEL_85;
      }
      v27 = [NRLinkManagerBluetooth alloc];
      v28 = a1[15];
      v29 = a1;
      if (!v27)
        goto LABEL_147;
      if (v28)
      {
        dispatch_assert_queue_V2(v28);
        block.receiver = v27;
        block.super_class = (Class)NRLinkManagerBluetooth;
        v30 = objc_msgSendSuper2(&block, "initManagerWithQueue:managerDelegate:", v28, v29);
        v31 = (uint64_t)v30;
        if (v30)
        {
          v30[36] = 1;
          *((_DWORD *)v30 + 3) = 1001;
          v30[8] = 1;
          v32 = objc_alloc_init((Class)NSMutableSet);
          v33 = *(void **)(v31 + 56);
          *(_QWORD *)(v31 + 56) = v32;

          objc_msgSend((id)v31, "reportEvent:", 2001);
          sub_10002E228(v31);
          objc_msgSend((id)v31, "reportEvent:", 2002);
          *(_DWORD *)(v31 + 12) = 1003;
          v34 = objc_alloc_init((Class)NSMutableSet);
          v35 = *(void **)(v31 + 104);
          *(_QWORD *)(v31 + 104) = v34;

          v36 = objc_alloc_init((Class)NSMutableDictionary);
          v37 = *(void **)(v31 + 112);
          *(_QWORD *)(v31 + 112) = v36;

          v38 = objc_alloc_init((Class)NSMutableDictionary);
          v39 = *(void **)(v31 + 120);
          *(_QWORD *)(v31 + 120) = v38;

          objc_storeWeak((id *)(v31 + 128), v29);
          v27 = (NRLinkManagerBluetooth *)(id)v31;
          v40 = v27;
        }
        else
        {
          v127 = sub_10002A890();
          v128 = _NRLogIsLevelEnabled(v127, 17);

          if (v128)
          {
            v129 = sub_10002A890();
            _NRLogWithArgs(v129, 17, "[NRLinkManager initManagerWithQueue:] failed");

          }
          v27 = 0;
          v40 = 0;
        }
        goto LABEL_63;
      }
      v124 = sub_10002A890();
      v125 = _NRLogIsLevelEnabled(v124, 17);

      if (v125)
      {
        v126 = sub_10002A890();
        _NRLogWithArgs(v126, 17, "%s called with null queue", "-[NRLinkManagerBluetooth initManagerWithQueue:managerDelegate:bluetoothManagerDelegate:]");

        v40 = 0;
      }
      else
      {
LABEL_147:
        v40 = 0;
      }
LABEL_63:

      v41 = v29[5];
      v29[5] = v40;

      goto LABEL_64;
    }
  }
  v23 = v131;
  *((_BYTE *)v131 + 8) = 1;
  objc_storeStrong(v23 + 10, v19);
  objc_storeStrong(v131 + 9, v17);
  objc_storeStrong(v131 + 11, v15);
  v24 = sub_1001379CC((uint64_t)NRDLocalDevice);
  if (objc_msgSend(v24, "count"))
  {
    objc_opt_self(NRDKeyManager);
    if (qword_1001E4AD8 != -1)
      dispatch_once(&qword_1001E4AD8, &stru_1001B8968);
    v25 = (id)qword_1001E4AD0;
    block.receiver = _NSConcreteStackBlock;
    block.super_class = (Class)3221225472;
    v140 = sub_1000ADC78;
    v141 = &unk_1001B8AE0;
    v142[0] = v131;
    sub_10014ACE0((uint64_t)v25, &block);

    sub_1000ADCD8((uint64_t)v131);
  }
  else
  {
    if (qword_1001E4738 != -1)
      dispatch_once(&qword_1001E4738, &stru_1001B7110);
    if (_NRLogIsLevelEnabled(qword_1001E4730, 16))
    {
      if (qword_1001E4738 != -1)
        dispatch_once(&qword_1001E4738, &stru_1001B7110);
      _NRLogWithArgs(qword_1001E4730, 16, "%s%.30s:%-4d Fixed interface mode cannot be started as there are no enabled devices", "", "-[NRLinkDirector setupManagers]", 466);
    }
  }

LABEL_85:
  if (_NRIsAppleInternal(IsLevelEnabled))
  {
    objc_initWeak((id *)&from, v131);
    block.receiver = _NSConcreteStackBlock;
    block.super_class = (Class)3221225472;
    v140 = sub_1000ADB38;
    v141 = &unk_1001B70D0;
    objc_copyWeak(v142, (id *)&from);
    v56 = objc_retainBlock(&block);
    v57 = (void *)objc_claimAutoreleasedReturnValue(+[NSDistributedNotificationCenter defaultCenter](NSDistributedNotificationCenter, "defaultCenter"));
    v58 = objc_claimAutoreleasedReturnValue(objc_msgSend(v57, "addObserverForName:object:queue:usingBlock:", CFSTR("NanoSettingsPerpetualMeadowStandaloneWifiPreferencesChangedNotification"), 0, 0, v56));
    v59 = v131[34];
    v131[34] = (id)v58;

    v60 = (void *)objc_claimAutoreleasedReturnValue(+[NSDistributedNotificationCenter defaultCenter](NSDistributedNotificationCenter, "defaultCenter"));
    v61 = objc_claimAutoreleasedReturnValue(objc_msgSend(v60, "addObserverForName:object:queue:usingBlock:", CFSTR("NanoSettingsPerpetualMeadowStandaloneCellularPreferencesChangedNotification"), 0, 0, v56));
    v62 = v131[35];
    v131[35] = (id)v61;

    objc_destroyWeak(v142);
    objc_destroyWeak((id *)&from);
  }
  objc_opt_self(NRDLocalDevice);
  v63 = objc_opt_self(NRDLocalDevice);
  v64 = sub_10014CFBC();
  dispatch_assert_queue_V2(v64);

  sub_10012DFA0(v63);
  v65 = objc_alloc_init((Class)NSMutableArray);
  from = 0u;
  v135 = 0u;
  v136 = 0u;
  v137 = 0u;
  v66 = (id)qword_1001E4A38;
  v67 = objc_msgSend(v66, "countByEnumeratingWithState:objects:count:", &from, &block, 16);
  if (v67)
  {
    v68 = *(_QWORD *)v135;
    do
    {
      for (i = 0; i != v67; i = (char *)i + 1)
      {
        if (*(_QWORD *)v135 != v68)
          objc_enumerationMutation(v66);
        v70 = *(_QWORD *)(*((_QWORD *)&from + 1) + 8 * (_QWORD)i);
        v71 = objc_claimAutoreleasedReturnValue(objc_msgSend((id)qword_1001E4A38, "objectForKeyedSubscript:", v70));
        v72 = (void *)v71;
        if (v71 && *(_BYTE *)(v71 + 8))
          objc_msgSend(v65, "addObject:", v70);

      }
      v67 = objc_msgSend(v66, "countByEnumeratingWithState:objects:count:", &from, &block, 16);
    }
    while (v67);
  }

  if (!objc_msgSend(v65, "count"))
    goto LABEL_119;
  v73 = +[NRDeviceOperationalProperties copyPropertiesForDefaultPairedPhone](NRDeviceOperationalProperties, "copyPropertiesForDefaultPairedPhone");
  sub_10010B4E0(v73);
  v137 = 0u;
  v136 = 0u;
  v135 = 0u;
  from = 0u;
  v74 = v65;
  v75 = objc_msgSend(v74, "countByEnumeratingWithState:objects:count:", &from, &block, 16);
  if (!v75)
  {

    goto LABEL_118;
  }
  v132 = 0;
  v76 = *(_QWORD *)v135;
  do
  {
    for (j = 0; j != v75; j = (char *)j + 1)
    {
      if (*(_QWORD *)v135 != v76)
        objc_enumerationMutation(v74);
      v78 = sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(*((_QWORD *)&from + 1) + 8 * (_QWORD)j));
      v79 = v78;
      if (v78 && v78[8] && *((_QWORD *)v78 + 5))
      {
        v80 = (void *)*((_QWORD *)v78 + 16);
        if (!v80)
        {
          if (!v73)
            goto LABEL_113;
          v89 = *((id *)v79 + 4);
          v90 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v79, "description"));
          sub_100121E18(v89, 5011, v90, 0);

          objc_msgSend(v79, "setOperationalProp:", v73);
          goto LABEL_112;
        }
        v81 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v80, "allowedLinkTypes"));
        v82 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v73, "allowedLinkTypes"));
        v83 = objc_msgSend(v81, "isEqualToArray:", v82);

        if (v83 && (objc_msgSend(*((id *)v79 + 16), "isEqual:", v73) & 1) == 0)
        {
          sub_100135268(v79, 5012, CFSTR("old: %@ new: %@"), v84, v85, v86, v87, v88, *((_QWORD *)v79 + 16));
          objc_msgSend(*((id *)v79 + 16), "mergeProperties:", v73);
LABEL_112:
          v132 = 1;
        }
      }
LABEL_113:

    }
    v75 = objc_msgSend(v74, "countByEnumeratingWithState:objects:count:", &from, &block, 16);
  }
  while (v75);

  if ((v132 & 1) != 0)
    sub_10012EDB0((uint64_t)NRDLocalDevice, 1);
LABEL_118:

LABEL_119:
  sub_1000A5428((uint64_t)v131);
  v91 = (__objc2_prot *)&APSConnectionOverrideNamedDelegatePort_ptr;
  v92 = (__objc2_class *)NEPolicyCondition;
  objc_opt_self(NRDLocalDevice);
  v93 = sub_10014CFBC();
  dispatch_assert_queue_V2(v93);

  block = (objc_super)xmmword_10015D090;
  v94 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &block, 16);
  v95 = sub_100133E24((uint64_t)NRDLocalDevice, v94, CFSTR("0"));
  v96 = (void *)objc_claimAutoreleasedReturnValue(v95);

  v97 = (char *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition remoteAddress:prefix:](NEPolicyCondition, "remoteAddress:prefix:", v96, 64));
  if (v97)
  {
    v98 = objc_alloc((Class)NEPolicy);
    v99 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult drop](NEPolicyResult, "drop"));
    v138[0] = v97;
    v92 = (__objc2_class *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](NEPolicyCondition, "allInterfaces"));
    v138[1] = v92;
    v91 = (__objc2_prot *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v138, 2));
    v100 = (char *)objc_msgSend(v98, "initWithOrder:result:conditions:", 5000, v99, v91);

    if (v100)
    {
      v92 = &OBJC_METACLASS___NRAnalyticsLocalDevice;
      objc_opt_self(NRDPolicySessionManager);
      v91 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
      if (qword_1001E4A20 == -1)
        goto LABEL_122;
      goto LABEL_139;
    }
    v116 = sub_1000A2640();
    v117 = _NRLogIsLevelEnabled(v116, 16);

    if (v117)
    {
      v118 = sub_1000A2640();
      _NRLogWithArgs(v118, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (policyDropPrefix) != ((void *)0)", "", "-[NRLinkDirector startDirector]", 319);

    }
    v100 = (char *)_os_log_pack_size(12);
    v97 = (char *)&v130 - ((__chkstk_darwin(v100) + 15) & 0xFFFFFFFFFFFFFFF0);
    v119 = __error();
    v120 = _os_log_pack_fill(v97, v100, *v119, &_mh_execute_header, "%{public}s Assertion Failed: (policyDropPrefix) != ((void *)0)");
    *(_DWORD *)v120 = 136446210;
    *(_QWORD *)(v120 + 4) = "-[NRLinkDirector startDirector]";
    v121 = sub_1000A2640();
    _NRLogAbortWithPack(v121, v97);
  }
  else
  {
    v110 = sub_1000A2640();
    v111 = _NRLogIsLevelEnabled(v110, 16);

    if (v111)
    {
      v112 = sub_1000A2640();
      _NRLogWithArgs(v112, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (conditionPrefix) != ((void *)0)", "", "-[NRLinkDirector startDirector]", 314);

    }
    v97 = (char *)_os_log_pack_size(12);
    v100 = (char *)&v130 - ((__chkstk_darwin(v97) + 15) & 0xFFFFFFFFFFFFFFF0);
    v113 = __error();
    v114 = _os_log_pack_fill(v100, v97, *v113, &_mh_execute_header, "%{public}s Assertion Failed: (conditionPrefix) != ((void *)0)");
    *(_DWORD *)v114 = 136446210;
    *(_QWORD *)(v114 + 4) = "-[NRLinkDirector startDirector]";
    v115 = sub_1000A2640();
    _NRLogAbortWithPack(v115, v100);
  }
  __break(1u);
LABEL_139:
  dispatch_once(&qword_1001E4A20, &stru_1001B8590);
LABEL_122:
  v101 = (id)qword_1001E4A18;
  v102 = sub_100127310((uint64_t)v101, CFSTR("NRLinkDirector-Drop"), v100);

  objc_opt_self(&v92[54]);
  if (v91[36].isa != (void *)-1)
    dispatch_once(&qword_1001E4A20, &stru_1001B8590);
  v103 = (id)qword_1001E4A18;
  v104 = (id *)v103;
  if (v103)
  {
    dispatch_assert_queue_V2(*((dispatch_queue_t *)v103 + 1));
    if ((objc_msgSend(v104[2], "apply") & 1) == 0)
      sub_100109270(CFSTR("NRPolicySessionManager"), CFSTR("ApplyPolicy Failed"), 0, 1, CFSTR("Failed to apply policies"), v105, v106, v107, v130);
  }

  sub_100121E18(0, 1002, 0, 0);
}

void sub_1000A49E4(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 328));
  _Unwind_Resume(a1);
}

void sub_1000A4A20(uint64_t a1)
{
  NSObject *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  uint64_t v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  void *v18;
  id v19;
  id v20;
  id v21;
  uint64_t v22;
  void *i;
  void *v24;
  NSObject *v25;
  void *v26;
  void *v27;
  void *v28;
  id v29;
  id v30;
  id *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  _BYTE v40[128];

  v2 = sub_10014CFBC();
  dispatch_assert_queue_V2(v2);

  if (*(_BYTE *)(a1 + 12))
  {
    *(_BYTE *)(a1 + 12) = 0;
    sub_100121E18(0, 1003, 0, 0);
    *(_BYTE *)(a1 + 10) = 0;
    objc_msgSend(*(id *)(a1 + 40), "cancel");
    v3 = *(void **)(a1 + 40);
    *(_QWORD *)(a1 + 40) = 0;

    v4 = *(void **)(a1 + 56);
    if (v4)
    {
      objc_msgSend(v4, "cancel");
      v5 = *(void **)(a1 + 56);
      *(_QWORD *)(a1 + 56) = 0;

    }
    v6 = *(void **)(a1 + 48);
    if (v6)
    {
      objc_msgSend(v6, "cancel");
      v7 = *(void **)(a1 + 48);
      *(_QWORD *)(a1 + 48) = 0;

    }
    v8 = *(void **)(a1 + 168);
    if (v8)
    {
      objc_msgSend(v8, "cancel");
      v9 = *(void **)(a1 + 168);
      *(_QWORD *)(a1 + 168) = 0;

    }
    v10 = *(_QWORD *)(a1 + 176);
    if (v10)
    {
      if (!*(_BYTE *)(v10 + 9))
      {
        *(_BYTE *)(v10 + 9) = 1;
        v11 = *(void **)(v10 + 48);
        if (v11)
        {
          objc_msgSend(v11, "invalidate");
          v12 = *(void **)(v10 + 48);
          *(_QWORD *)(v10 + 48) = 0;

        }
        sub_1000136C4(v10);
        v10 = *(_QWORD *)(a1 + 176);
      }
      *(_QWORD *)(a1 + 176) = 0;

    }
    v13 = *(void **)(a1 + 64);
    if (v13)
    {
      objc_msgSend(v13, "cancel");
      v14 = *(void **)(a1 + 64);
      *(_QWORD *)(a1 + 64) = 0;

    }
    sub_1000A4E44(a1);
    sub_1000A5020((_QWORD *)a1);
    v15 = *(_QWORD *)(a1 + 192);
    if (v15)
    {
      sub_10014E7AC(v15);
      v16 = *(void **)(a1 + 192);
      *(_QWORD *)(a1 + 192) = 0;

    }
    v17 = *(_QWORD *)(a1 + 96);
    if (v17)
    {
      sub_100061418(v17);
      v18 = *(void **)(a1 + 96);
      *(_QWORD *)(a1 + 96) = 0;

    }
    v38 = 0u;
    v39 = 0u;
    v36 = 0u;
    v37 = 0u;
    v19 = *(id *)(a1 + 200);
    v20 = objc_msgSend(v19, "countByEnumeratingWithState:objects:count:", &v36, v40, 16);
    if (v20)
    {
      v21 = v20;
      v22 = *(_QWORD *)v37;
      do
      {
        for (i = 0; i != v21; i = (char *)i + 1)
        {
          if (*(_QWORD *)v37 != v22)
            objc_enumerationMutation(v19);
          v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 200), "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v36 + 1) + 8 * (_QWORD)i)));
          sub_1000EE544((uint64_t)v24);

        }
        v21 = objc_msgSend(v19, "countByEnumeratingWithState:objects:count:", &v36, v40, 16);
      }
      while (v21);
    }

    objc_msgSend(*(id *)(a1 + 200), "removeAllObjects");
    sub_1000A5114(a1);
    sub_1000A5350(a1);
    v25 = *(NSObject **)(a1 + 264);
    if (v25)
    {
      dispatch_source_cancel(v25);
      v26 = *(void **)(a1 + 264);
      *(_QWORD *)(a1 + 264) = 0;

    }
    v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSDistributedNotificationCenter defaultCenter](NSDistributedNotificationCenter, "defaultCenter"));
    objc_msgSend(v27, "removeObserver:name:object:", *(_QWORD *)(a1 + 272), CFSTR("NanoSettingsPerpetualMeadowStandaloneWifiPreferencesChangedNotification"), 0);

    v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSDistributedNotificationCenter defaultCenter](NSDistributedNotificationCenter, "defaultCenter"));
    objc_msgSend(v28, "removeObserver:name:object:", *(_QWORD *)(a1 + 280), CFSTR("NanoSettingsPerpetualMeadowStandaloneCellularPreferencesChangedNotification"), 0);

    objc_opt_self(NRDPolicySessionManager);
    if (qword_1001E4A20 != -1)
      dispatch_once(&qword_1001E4A20, &stru_1001B8590);
    v29 = (id)qword_1001E4A18;
    sub_100127618((uint64_t)v29, CFSTR("NRLinkDirector-Drop"));

    objc_opt_self(NRDPolicySessionManager);
    if (qword_1001E4A20 != -1)
      dispatch_once(&qword_1001E4A20, &stru_1001B8590);
    v30 = (id)qword_1001E4A18;
    v31 = (id *)v30;
    if (v30)
    {
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v30 + 1));
      if ((objc_msgSend(v31[2], "apply") & 1) == 0)
        sub_100109270(CFSTR("NRPolicySessionManager"), CFSTR("ApplyPolicy Failed"), 0, 1, CFSTR("Failed to apply policies"), v32, v33, v34, v35);
    }

  }
  else
  {
    if (qword_1001E4738 != -1)
      dispatch_once(&qword_1001E4738, &stru_1001B7110);
    if (_NRLogIsLevelEnabled(qword_1001E4730, 1))
    {
      if (qword_1001E4738 != -1)
        dispatch_once(&qword_1001E4738, &stru_1001B7110);
      _NRLogWithArgs(qword_1001E4730, 1, "%s%.30s:%-4d Skipping cancel as director is already disabled", "", "-[NRLinkDirector cancelDirector]", 341);
    }
  }
}

void sub_1000A4E44(uint64_t a1)
{
  NSObject *v2;
  void *v3;
  void *v4;
  id v5;
  dispatch_queue_t *v6;
  void *v7;
  unsigned __int8 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  id *v13;

  if (a1)
  {
    v2 = *(NSObject **)(a1 + 152);
    if (v2)
    {
      dispatch_source_cancel(v2);
      v3 = *(void **)(a1 + 152);
      *(_QWORD *)(a1 + 152) = 0;

    }
    if (*(_QWORD *)(a1 + 128))
    {
      nw_shoes_server_cancel();
      v4 = *(void **)(a1 + 128);
      *(_QWORD *)(a1 + 128) = 0;

      if (qword_1001E4738 != -1)
        dispatch_once(&qword_1001E4738, &stru_1001B7110);
      if (_NRLogIsLevelEnabled(qword_1001E4730, 0))
      {
        if (qword_1001E4738 != -1)
          dispatch_once(&qword_1001E4738, &stru_1001B7110);
        _NRLogWithArgs(qword_1001E4730, 0, "%s%.30s:%-4d socksServer cancelled", "", "-[NRLinkDirector cancelSocksServer]", 1923);
      }
      objc_opt_self(NRDPolicySessionManager);
      if (qword_1001E4A20 != -1)
        dispatch_once(&qword_1001E4A20, &stru_1001B8590);
      v5 = (id)qword_1001E4A18;
      sub_100127618((uint64_t)v5, CFSTR("NRLinkDirector-skip-privacy-proxy"));

      objc_opt_self(NRDPolicySessionManager);
      if (qword_1001E4A20 != -1)
        dispatch_once(&qword_1001E4A20, &stru_1001B8590);
      v6 = (dispatch_queue_t *)(id)qword_1001E4A18;
      v7 = v6;
      if (v6)
      {
        v13 = (id *)v6;
        dispatch_assert_queue_V2(v6[1]);
        v8 = objc_msgSend(v13[2], "apply");
        v7 = v13;
        if ((v8 & 1) == 0)
        {
          sub_100109270(CFSTR("NRPolicySessionManager"), CFSTR("ApplyPolicy Failed"), 0, 1, CFSTR("Failed to apply policies"), v9, v10, v11, v12);
          v7 = v13;
        }
      }

    }
  }
}

void sub_1000A5020(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  if (a1[17])
  {
    nw_masque_server_cancel();
    v2 = (void *)a1[17];
    a1[17] = 0;

    if (qword_1001E4738 != -1)
      dispatch_once(&qword_1001E4738, &stru_1001B7110);
    if (_NRLogIsLevelEnabled(qword_1001E4730, 0))
    {
      if (qword_1001E4738 != -1)
        dispatch_once(&qword_1001E4738, &stru_1001B7110);
      _NRLogWithArgs(qword_1001E4730, 0, "%s%.30s:%-4d MASQUE server cancelled", "", "-[NRLinkDirector cancelMASQUEProxyServer]", 2240);
    }
  }
  v3 = (void *)a1[14];
  a1[14] = 0;

  v4 = (void *)a1[13];
  a1[13] = 0;

  v5 = (void *)a1[18];
  a1[18] = 0;

}

uint64_t sub_1000A5114(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  void *i;
  uint64_t v5;
  id *v6;
  id v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  id v14;
  id v15;
  id v16;
  uint64_t v17;
  void *j;
  id obj;
  uint64_t v21;
  id v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  _BYTE v31[128];
  _BYTE v32[128];

  if (!a1)
    return 0;
  v2 = sub_10014CFBC();
  dispatch_assert_queue_V2(v2);

  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  obj = *(id *)(a1 + 200);
  v22 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v23, v31, 16);
  v3 = 0;
  if (v22)
  {
    v21 = *(_QWORD *)v24;
    do
    {
      for (i = 0; i != v22; i = (char *)i + 1)
      {
        if (*(_QWORD *)v24 != v21)
          objc_enumerationMutation(obj);
        v5 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 200), "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v23 + 1) + 8 * (_QWORD)i)));
        v6 = (id *)v5;
        if (v5)
        {
          dispatch_assert_queue_V2(*(dispatch_queue_t *)(v5 + 104));
          v7 = objc_msgSend(v6[14], "count");
          v8 = (int)v7;
          sub_1000D5060((uint64_t)v6, 1013, CFSTR("%u available"), v9, v10, v11, v12, v13, (uint64_t)v7);
          v29 = 0u;
          v30 = 0u;
          v27 = 0u;
          v28 = 0u;
          v14 = v6[14];
          v15 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v27, v32, 16);
          if (v15)
          {
            v16 = v15;
            v17 = *(_QWORD *)v28;
            do
            {
              for (j = 0; j != v16; j = (char *)j + 1)
              {
                if (*(_QWORD *)v28 != v17)
                  objc_enumerationMutation(v14);
                objc_msgSend(*(id *)(*((_QWORD *)&v27 + 1) + 8 * (_QWORD)j), "cancelWithReason:", CFSTR("Cancelling all links"));
              }
              v16 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v27, v32, 16);
            }
            while (v16);
          }

          sub_1000E1B64((uint64_t)v6, 0);
          objc_msgSend(v6[14], "removeAllObjects");
        }
        else
        {
          v8 = 0;
        }
        v3 = (v8 + v3);

      }
      v22 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v23, v31, 16);
    }
    while (v22);
  }

  return v3;
}

uint64_t sub_1000A5350(uint64_t result)
{
  uint64_t v1;

  if (*(_DWORD *)(result + 24) != -1)
  {
    v1 = result;
    if (qword_1001E4738 != -1)
      dispatch_once(&qword_1001E4738, &stru_1001B7110);
    if (_NRLogIsLevelEnabled(qword_1001E4730, 0))
    {
      if (qword_1001E4738 != -1)
        dispatch_once(&qword_1001E4738, &stru_1001B7110);
      _NRLogWithArgs(qword_1001E4730, 0, "%s%.30s:%-4d unregistering thermal pressure level watcher", "", "-[NRLinkDirector removeThermalStateWatcher]", 2729);
    }
    result = notify_cancel(*(_DWORD *)(v1 + 24));
    *(_DWORD *)(v1 + 24) = -1;
  }
  return result;
}

void sub_1000A5428(uint64_t a1)
{
  _QWORD *v1;
  id v2;
  void *v3;
  NSObject *v4;
  id v5;
  uint64_t v6;
  id *v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  id v11;
  id v12;
  char *v13;
  uint64_t v14;
  char *i;
  void *v16;
  void *v17;
  char *v18;
  void *v19;
  id v20;
  id v21;
  uint64_t v22;
  void *j;
  void *v24;
  char *v25;
  char *v26;
  id v27;
  id v28;
  id v29;
  id v30;
  uint64_t v31;
  void *k;
  uint64_t v33;
  id v34;
  uint64_t v35;
  void *m;
  uint64_t v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  void *v42;
  _BOOL4 v43;
  char *v44;
  id v45;
  id v46;
  id v47;
  uint64_t v48;
  void *n;
  uint64_t v50;
  void *v51;
  void *v52;
  id v53;
  id v54;
  id v55;
  uint64_t v56;
  void *ii;
  _QWORD *v58;
  void *v59;
  void *v60;
  _xpc_connection_s *v61;
  uint64_t v62;
  void *v63;
  int IsLevelEnabled;
  uint64_t v65;
  void *v66;
  void *v67;
  NRDevicePreferencesManager *v68;
  void *v69;
  id v70;
  id v71;
  id *v72;
  void *v73;
  id v74;
  uint64_t v75;
  void *v76;
  void *v77;
  uint64_t v78;
  void *v79;
  int v80;
  id v81;
  uint64_t v82;
  void *v83;
  NSObject *v84;
  id v85;
  id v86;
  uint64_t v87;
  uint64_t isKindOfClass;
  NSObject *v89;
  id v90;
  void *v91;
  uint64_t v92;
  id v93;
  void *v94;
  uint64_t v95;
  NRQuickRelayAgent *v96;
  void *v97;
  id v98;
  id v99;
  id *v100;
  void *v101;
  uint64_t v102;
  id v103;
  void *v104;
  void *v105;
  uint64_t v106;
  void *v107;
  uint64_t v108;
  id v109;
  void *v110;
  void *v111;
  void *v112;
  id v113;
  void *v114;
  void *v115;
  id v116;
  id v117;
  id v118;
  id *v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  void *v123;
  void *v124;
  id v125;
  id v126;
  void *v127;
  void *v128;
  void *v129;
  void *v130;
  int v131;
  uint64_t v132;
  NRBTLinkPreferencesAgent *v133;
  void *v134;
  id v135;
  id v136;
  id *v137;
  void *v138;
  uint64_t v139;
  id v140;
  void *v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  void *v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  void *v149;
  void *v150;
  void *v151;
  void *v152;
  void *v153;
  id v154;
  void *v155;
  void *v156;
  id v157;
  id v158;
  id v159;
  id v160;
  id *v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  id v165;
  void *v166;
  void *v167;
  NSObject *v168;
  id v169;
  id v170;
  char v171;
  char v172;
  uint64_t v173;
  void *v174;
  uint64_t v175;
  _BYTE *v176;
  BOOL v177;
  _BYTE *v178;
  BOOL v179;
  id v180;
  _QWORD *v181;
  NRPhoneCallRelayAgent *v182;
  id v183;
  id *v184;
  void *v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  id v190;
  void *v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  void *v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  void *v199;
  void *v200;
  void *v201;
  id v202;
  void *v203;
  void *v204;
  id v205;
  id v206;
  id v207;
  id v208;
  void *v209;
  void *v210;
  id v211;
  id v212;
  id v213;
  NSObject *v214;
  id v215;
  id v216;
  void *v217;
  void *v218;
  void *v219;
  void *v220;
  id v221;
  void *v222;
  void *v223;
  id v224;
  id v225;
  id v226;
  id v227;
  id *v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  void *v232;
  void *v233;
  uint64_t v234;
  uint64_t v235;
  void *v236;
  uint64_t v237;
  void *v238;
  _QWORD *v239;
  uint64_t v240;
  id v241;
  void *v242;
  int v243;
  void *v244;
  NSObject *v245;
  void *v246;
  _QWORD *v247;
  uint64_t v248;
  void *v249;
  void *v250;
  id v251;
  id v252;
  id *v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  void *v257;
  void *v258;
  id v259;
  char *v260;
  uint64_t v261;
  char *v262;
  uint64_t v263;
  void *v264;
  uint64_t v265;
  char *v266;
  void *v267;
  uint64_t v268;
  void *v269;
  NRPreferWiFiAgent *v270;
  void *v271;
  void *v272;
  id *v273;
  id v274;
  void *v275;
  dispatch_time_t v276;
  id v277;
  NSObject *v278;
  uint64_t v279;
  int *v280;
  int v281;
  NSObject *v282;
  uint32_t v283;
  id v284;
  char v285;
  id v286;
  NSObject *v287;
  nw_parameters_t v288;
  void *evaluator_for_endpoint;
  id v290;
  id *v291;
  id v292;
  id v293;
  char v294;
  id v295;
  id v296;
  NSObject *v297;
  id *v298;
  id v299;
  NSObject *v300;
  NSObject *v301;
  void *v302;
  NSObject *v303;
  id v304;
  const char *v305;
  id v306;
  id v307;
  id v308;
  void *v309;
  void *v310;
  void *v311;
  void *v312;
  void *v313;
  void *v314;
  id v315;
  id v316;
  id v317;
  uint64_t v318;
  void *v319;
  id v320;
  void **v321;
  id obj;
  uint64_t v323;
  uint64_t v324;
  void *v325;
  _QWORD *val;
  __int128 v327;
  __int128 v328;
  __int128 v329;
  __int128 v330;
  __int128 v331;
  __int128 v332;
  __int128 v333;
  __int128 v334;
  __int128 v335;
  __int128 v336;
  __int128 v337;
  __int128 v338;
  __int128 v339;
  __int128 v340;
  __int128 v341;
  __int128 v342;
  __int128 v343;
  __int128 v344;
  __int128 v345;
  __int128 v346;
  __int128 v347;
  __int128 v348;
  __int128 v349;
  __int128 v350;
  _BYTE v351[128];
  _BYTE v352[128];
  _BYTE v353[128];
  _BYTE v354[128];
  _BYTE v355[128];
  _BYTE v356[128];
  id location[2];
  __int128 v358;
  _OWORD v359[6];
  __int128 v360;
  __int128 v361;
  __int128 v362;
  __int128 v363;
  id from[2];
  __int128 v365;
  __int128 v366;
  __int128 v367;
  void **block;
  uint64_t v369;
  void *v370;
  void *v371;
  id v372;
  id v373;
  id *v374;

  if (a1)
  {
    v1 = (_QWORD *)a1;
    if (*(_BYTE *)(a1 + 12))
    {
      v2 = sub_1001379CC((uint64_t)NRDLocalDevice);
      v3 = (void *)v1[22];
      val = v1;
      if (v3)
      {
        v306 = sub_1000137E8((uint64_t)v3);
        if (objc_msgSend(v306, "count"))
        {
          v4 = sub_10014CFBC();
          block = _NSConcreteStackBlock;
          v369 = 3221225472;
          v370 = sub_100015590;
          v371 = &unk_1001B8AE0;
          v372 = v3;
          dispatch_async(v4, &block);

          v1 = val;
        }
        if (objc_msgSend(v306, "count"))
        {
          v5 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithArray:", v2);
          objc_msgSend(v5, "removeObjectsInArray:", v306);

          v2 = v5;
        }
      }
      else
      {
        v306 = 0;
      }
      _NRUpdateNRUUIDsEligibleForLogObjects(v2);
      v6 = v1[5];
      if (v6)
        sub_10002F478(v6);
      v7 = (id *)v1[6];
      if (v7)
        sub_100149C5C(v7);
      v8 = v1[7];
      if (v8)
        sub_1000FA5F4(v8);
      v9 = v1[8];
      if (v9)
      {
        v10 = *(id *)(v9 + 24);
        dispatch_assert_queue_V2(v10);

        v323 = v9;
        v11 = objc_msgSend(*(id *)(v9 + 40), "copy");
        *(_OWORD *)from = 0u;
        v365 = 0u;
        v366 = 0u;
        v367 = 0u;
        v12 = v11;
        v13 = (char *)objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", from, &block, 16);
        if (v13)
        {
          v14 = *(_QWORD *)v365;
          do
          {
            for (i = 0; i != v13; ++i)
            {
              if (*(_QWORD *)v365 != v14)
                objc_enumerationMutation(v12);
              v16 = (void *)*((_QWORD *)from[1] + (_QWORD)i);
              v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "nrUUID"));
              v18 = sub_10012FFF4((uint64_t)NRDLocalDevice, v17);

              if (!v18 || !v18[9])
                objc_msgSend(v16, "cancelWithReason:", CFSTR("Device has been disabled %@"), v18);

            }
            v13 = (char *)objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", from, &block, 16);
          }
          while (v13);
        }

        v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v323 + 88), "allKeys"));
        v363 = 0u;
        v362 = 0u;
        v361 = 0u;
        v360 = 0u;
        v20 = v19;
        v21 = objc_msgSend(v20, "countByEnumeratingWithState:objects:count:", &v360, location, 16);
        if (v21)
        {
          v22 = *(_QWORD *)v361;
          do
          {
            for (j = 0; j != v21; j = (char *)j + 1)
            {
              if (*(_QWORD *)v361 != v22)
                objc_enumerationMutation(v20);
              v24 = *(void **)(*((_QWORD *)&v360 + 1) + 8 * (_QWORD)j);
              v25 = sub_10012FFF4((uint64_t)NRDLocalDevice, v24);
              v26 = v25;
              if (!v25 || !v25[9])
                objc_msgSend(*(id *)(v323 + 88), "setObject:forKeyedSubscript:", 0, v24);

            }
            v21 = objc_msgSend(v20, "countByEnumeratingWithState:objects:count:", &v360, location, 16);
          }
          while (v21);
        }

        if (qword_1001E4768 != -1)
          dispatch_once(&qword_1001E4768, &stru_1001B7398);
        if (_NRLogIsLevelEnabled(qword_1001E4760, 1))
        {
          if (qword_1001E4768 != -1)
            dispatch_once(&qword_1001E4768, &stru_1001B7398);
          _NRLogWithArgs(qword_1001E4760, 1, "%s%.30s:%-4d Forcing interface availability event to check for new enabled devices", "", "-[NRLinkManagerWired checkEnabledDevices]", 728);
        }
        sub_1000C9F88(v323);

        v1 = val;
      }
      if (*((_BYTE *)v1 + 16))
      {
        if (qword_1001E4738 != -1)
          dispatch_once(&qword_1001E4738, &stru_1001B7110);
        if (_NRLogIsLevelEnabled(qword_1001E4730, 0))
        {
          if (qword_1001E4738 != -1)
            dispatch_once(&qword_1001E4738, &stru_1001B7110);
          _NRLogWithArgs(qword_1001E4730, 0, "%s%.30s:%-4d Not starting conductors as AOVPN is configured %@", "", "-[NRLinkDirector checkEnabledDevices]", 817, v2, v306);
        }
        v27 = objc_alloc_init((Class)NSArray);

        v2 = v27;
      }
      v28 = objc_alloc_init((Class)NSMutableArray);
      v347 = 0u;
      v348 = 0u;
      v349 = 0u;
      v350 = 0u;
      v29 = (id)v1[25];
      v30 = objc_msgSend(v29, "countByEnumeratingWithState:objects:count:", &v347, v356, 16);
      if (v30)
      {
        v31 = *(_QWORD *)v348;
        do
        {
          for (k = 0; k != v30; k = (char *)k + 1)
          {
            if (*(_QWORD *)v348 != v31)
              objc_enumerationMutation(v29);
            v33 = *(_QWORD *)(*((_QWORD *)&v347 + 1) + 8 * (_QWORD)k);
            if ((objc_msgSend(v2, "containsObject:", v33) & 1) == 0)
              objc_msgSend(v28, "addObject:", v33);
          }
          v30 = objc_msgSend(v29, "countByEnumeratingWithState:objects:count:", &v347, v356, 16);
        }
        while (v30);
      }

      v345 = 0u;
      v346 = 0u;
      v343 = 0u;
      v344 = 0u;
      obj = v28;
      v34 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v343, v355, 16);
      if (v34)
      {
        v35 = *(_QWORD *)v344;
        do
        {
          for (m = 0; m != v34; m = (char *)m + 1)
          {
            if (*(_QWORD *)v344 != v35)
              objc_enumerationMutation(obj);
            v37 = *(_QWORD *)(*((_QWORD *)&v343 + 1) + 8 * (_QWORD)m);
            v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)val[25], "objectForKeyedSubscript:", v37));
            sub_1000EE544((uint64_t)v38);

            objc_msgSend((id)val[25], "setObject:forKeyedSubscript:", 0, v37);
          }
          v34 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v343, v355, 16);
        }
        while (v34);
      }

      if (objc_msgSend(v2, "count") && qword_1001E4718 != -1)
        dispatch_once(&qword_1001E4718, &stru_1001B6EF8);
      v341 = 0u;
      v342 = 0u;
      v339 = 0u;
      v340 = 0u;
      v317 = v2;
      v320 = objc_msgSend(v317, "countByEnumeratingWithState:objects:count:", &v339, v354, 16);
      if (v320)
      {
        v318 = *(_QWORD *)v340;
        do
        {
          v39 = 0;
          do
          {
            if (*(_QWORD *)v340 != v318)
            {
              v40 = v39;
              objc_enumerationMutation(v317);
              v39 = v40;
            }
            v324 = v39;
            v41 = *(void **)(*((_QWORD *)&v339 + 1) + 8 * v39);
            v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)val[25], "objectForKeyedSubscript:", v41));
            v43 = v42 == 0;

            if (!v43)
            {
              v44 = (char *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)val[25], "objectForKeyedSubscript:", v41));
              sub_1000DAD34((uint64_t)v44);
              goto LABEL_170;
            }
            v44 = sub_1000EC13C((char *)[NRDDeviceConductor alloc], v41, (void *)val[15]);
            v45 = objc_msgSend((id)val[26], "copy");
            v337 = 0u;
            v338 = 0u;
            v335 = 0u;
            v336 = 0u;
            v46 = v45;
            v47 = objc_msgSend(v46, "countByEnumeratingWithState:objects:count:", &v335, v353, 16);
            if (!v47)
              goto LABEL_96;
            v48 = *(_QWORD *)v336;
            do
            {
              for (n = 0; n != v47; n = (char *)n + 1)
              {
                if (*(_QWORD *)v336 != v48)
                  objc_enumerationMutation(v46);
                v50 = *(_QWORD *)(*((_QWORD *)&v335 + 1) + 8 * (_QWORD)n);
                if (v50)
                {
                  if (!objc_msgSend(*(id *)(v50 + 8), "isEqual:", v41))
                    continue;
                  v51 = *(void **)(v50 + 16);
                  goto LABEL_92;
                }
                if ((objc_msgSend(0, "isEqual:", v41) & 1) != 0)
                {
                  v51 = 0;
LABEL_92:
                  sub_1000EF0D0((uint64_t)v44, v51);
                  objc_msgSend((id)val[26], "removeObject:", v50);
                  v52 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v50, "description"));
                  sub_100121E18(0, 1016, 0, v52);

                  continue;
                }
              }
              v47 = objc_msgSend(v46, "countByEnumeratingWithState:objects:count:", &v335, v353, 16);
            }
            while (v47);
LABEL_96:

            v53 = objc_msgSend((id)val[27], "copy");
            v333 = 0u;
            v334 = 0u;
            v331 = 0u;
            v332 = 0u;
            v54 = v53;
            v55 = objc_msgSend(v54, "countByEnumeratingWithState:objects:count:", &v331, v352, 16);
            if (v55)
            {
              v56 = *(_QWORD *)v332;
              do
              {
                for (ii = 0; ii != v55; ii = (char *)ii + 1)
                {
                  if (*(_QWORD *)v332 != v56)
                    objc_enumerationMutation(v54);
                  v58 = *(_QWORD **)(*((_QWORD *)&v331 + 1) + 8 * (_QWORD)ii);
                  if (v58)
                    v59 = (void *)v58[1];
                  else
                    v59 = 0;
                  if (objc_msgSend(v59, "isEqual:", v41))
                  {
                    objc_msgSend((id)val[27], "removeObject:", v58);
                    v60 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v58, "description"));
                    sub_100121E18(0, 1023, 0, v60);

                    if (v58)
                      v61 = (_xpc_connection_s *)v58[2];
                    else
                      v61 = 0;
                    xpc_connection_cancel(v61);
                  }
                }
                v55 = objc_msgSend(v54, "countByEnumeratingWithState:objects:count:", &v331, v352, 16);
              }
              while (v55);
            }

            if (!v44)
              goto LABEL_169;
            dispatch_assert_queue_V2(*((dispatch_queue_t *)v44 + 13));
            if (v44[14])
            {
              v63 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v44 + 12), v62);
              IsLevelEnabled = _NRLogIsLevelEnabled(v63, 1);

              if (IsLevelEnabled)
              {
                v66 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v44 + 12), v65);
                _NRLogWithArgs(v66, 1, "%s%.30s:%-4d Skipping start as conductor is already enabled", "", "-[NRDDeviceConductor startConductor]", 529);
                goto LABEL_168;
              }
              goto LABEL_169;
            }
            v44[14] = 1;
            v67 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v44, "description"));
            sub_100121E18(*((void **)v44 + 12), 1501, 0, v67);

            sub_1000ECAAC((uint64_t)v44);
            sub_1000E3160((void **)v44);
            v68 = [NRDevicePreferencesManager alloc];
            v69 = (void *)*((_QWORD *)v44 + 13);
            v70 = *((id *)v44 + 12);
            v71 = v69;
            v72 = sub_100113EE0((id *)&v68->super.isa, v71, v70);
            v73 = (void *)*((_QWORD *)v44 + 23);
            *((_QWORD *)v44 + 23) = v72;

            sub_1000EBDB0(v44);
            v74 = sub_1000A0710(*((void **)v44 + 12), CFSTR("WiFiEndpointAddressData"));
            v66 = (void *)objc_claimAutoreleasedReturnValue(v74);
            v75 = objc_opt_class(NSData);
            if ((objc_opt_isKindOfClass(v66, v75) & 1) != 0)
            {
              v76 = (void *)objc_claimAutoreleasedReturnValue(+[NWAddressEndpoint endpointWithAddress:](NWAddressEndpoint, "endpointWithAddress:", objc_msgSend(v66, "bytes")));
              v77 = v76;
              if (v44[44])
              {
                objc_storeStrong((id *)v44 + 17, v76);
                v79 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v44 + 12), v78);
                v80 = _NRLogIsLevelEnabled(v79, 1);

                if (v80)
                {
                  v81 = *((id *)v44 + 12);
                  v83 = (void *)_NRCopyLogObjectForNRUUID(v81, v82);
                  v305 = "";
                  _NRLogWithArgs(v83, 1, "%s%.30s:%-4d Fetched last sent endpoint as %@");

                }
              }
              else
              {
                v84 = *((_QWORD *)v44 + 13);
                block = _NSConcreteStackBlock;
                v369 = 3221225472;
                v370 = sub_1000ED294;
                v371 = &unk_1001B8778;
                v372 = v44;
                v373 = v76;
                dispatch_async(v84, &block);

              }
            }
            v85 = *((id *)v44 + 12);
            v86 = sub_1000A0710(v85, CFSTR("WiFiSignature"));
            v315 = (id)objc_claimAutoreleasedReturnValue(v86);

            v87 = objc_opt_class(NSData);
            isKindOfClass = objc_opt_isKindOfClass(v315, v87);
            if ((isKindOfClass & 1) != 0)
            {
              if (v44[44])
              {
                objc_storeStrong((id *)v44 + 18, v315);
              }
              else
              {
                v89 = *((_QWORD *)v44 + 13);
                location[0] = _NSConcreteStackBlock;
                location[1] = (id)3221225472;
                *(_QWORD *)&v358 = sub_1000ED350;
                *((_QWORD *)&v358 + 1) = &unk_1001B8778;
                *(_QWORD *)&v359[0] = v44;
                *((_QWORD *)&v359[0] + 1) = v315;
                dispatch_async(v89, location);

              }
            }
            if (_NRIsAppleInternal(isKindOfClass))
            {
              v90 = sub_1000A0710(*((void **)v44 + 12), CFSTR("DisableRangeExtension"));
              v91 = (void *)objc_claimAutoreleasedReturnValue(v90);
              v92 = objc_opt_class(NSNumber);
              if ((objc_opt_isKindOfClass(v91, v92) & 1) != 0 && objc_msgSend(v91, "BOOLValue"))
                v44[23] = 1;
              v93 = sub_1000A0710(*((void **)v44 + 12), CFSTR("DisablePreferWiFi"));
              v94 = (void *)objc_claimAutoreleasedReturnValue(v93);
              v95 = objc_opt_class(NSNumber);
              if ((objc_opt_isKindOfClass(v94, v95) & 1) != 0 && objc_msgSend(v94, "BOOLValue"))
                v44[24] = 1;

            }
            sub_1000EA9A0((uint64_t)v44);
            if (v44[55])
            {
              v96 = [NRQuickRelayAgent alloc];
              v97 = (void *)*((_QWORD *)v44 + 12);
              v98 = *((id *)v44 + 13);
              v99 = v97;
              v100 = sub_1000300F0((id *)&v96->super.isa, v99, v98, v44);
              v101 = (void *)*((_QWORD *)v44 + 24);
              *((_QWORD *)v44 + 24) = v100;

              v102 = *((_QWORD *)v44 + 24);
              if (v102)
              {
                dispatch_assert_queue_V2(*(dispatch_queue_t *)(v102 + 48));
                if (!*(_BYTE *)(v102 + 14))
                {
                  v103 = objc_msgSend(objc_alloc((Class)NWNetworkAgentRegistration), "initWithNetworkAgentClass:", objc_opt_class(v102));
                  v104 = *(void **)(v102 + 56);
                  *(_QWORD *)(v102 + 56) = v103;

                  v105 = *(void **)(v102 + 56);
                  if (v105)
                  {
                    if ((objc_msgSend(v105, "registerNetworkAgent:", v102) & 1) != 0)
                    {
                      v107 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v102, "agentUUID"));
                      v108 = objc_claimAutoreleasedReturnValue(+[NEPolicyResult netAgentUUID:](NEPolicyResult, "netAgentUUID:", v107));

                      v109 = *(id *)(v102 + 40);
                      v110 = (void *)nrCopyAccountIdentifierForNRUUID();
                      v312 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition accountIdentifier:](NEPolicyCondition, "accountIdentifier:", v110));

                      v111 = (void *)objc_claimAutoreleasedReturnValue(+[NRQuickRelayAgent agentDomain](NRQuickRelayAgent, "agentDomain"));
                      v112 = (void *)objc_claimAutoreleasedReturnValue(+[NRQuickRelayAgent agentType](NRQuickRelayAgent, "agentType"));
                      v309 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition requiredAgentDomain:agentType:](NEPolicyCondition, "requiredAgentDomain:agentType:", v111, v112));

                      v113 = objc_alloc((Class)NEPolicy);
                      from[0] = v309;
                      from[1] = v312;
                      v114 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](NEPolicyCondition, "allInterfaces"));
                      *(_QWORD *)&v365 = v114;
                      v115 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", from, 3));
                      v308 = objc_msgSend(v113, "initWithOrder:result:conditions:", 10, v108, v115);

                      objc_opt_self(NRDPolicySessionManager);
                      if (qword_1001E4A20 != -1)
                        dispatch_once(&qword_1001E4A20, &stru_1001B8590);
                      v116 = (id)qword_1001E4A18;
                      v117 = sub_100127310((uint64_t)v116, *(void **)(v102 + 72), v308);

                      objc_opt_self(NRDPolicySessionManager);
                      if (qword_1001E4A20 != -1)
                        dispatch_once(&qword_1001E4A20, &stru_1001B8590);
                      v118 = (id)qword_1001E4A18;
                      v119 = (id *)v118;
                      if (v118)
                      {
                        dispatch_assert_queue_V2(*((dispatch_queue_t *)v118 + 1));
                        if ((objc_msgSend(v119[2], "apply") & 1) == 0)
                          sub_100109270(CFSTR("NRPolicySessionManager"), CFSTR("ApplyPolicy Failed"), 0, 1, CFSTR("Failed to apply policies"), v120, v121, v122, (uint64_t)v305);
                      }

                      *(_BYTE *)(v102 + 14) = 1;
                      v123 = (void *)v108;
                      v124 = *(void **)(v102 + 40);
                      v125 = *(id *)(v102 + 80);
                      v126 = v124;
                      v127 = v123;
                      v307 = v126;
                      v128 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v102, "agentUUID"));
                      v129 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v128, "UUIDString"));
                      sub_100121E18(v307, 17002, v125, v129);

                      sub_10003073C(v102);
LABEL_148:

                    }
                    else
                    {
                      v130 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v102 + 40), v106);
                      v131 = _NRLogIsLevelEnabled(v130, 17);

                      if (v131)
                      {
                        v127 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(v102 + 40), v132);
                        _NRLogWithArgs(v127, 17, "Failed to register QuickRelay network agent");
                        goto LABEL_148;
                      }
                    }
                  }
                }
              }
            }
            if (v44[54])
            {
              v133 = [NRBTLinkPreferencesAgent alloc];
              v134 = (void *)*((_QWORD *)v44 + 12);
              v135 = *((id *)v44 + 13);
              v136 = v134;
              v137 = sub_100065914((id *)&v133->super.isa, v136, v135, v44);
              v138 = (void *)*((_QWORD *)v44 + 25);
              *((_QWORD *)v44 + 25) = v137;

              v139 = *((_QWORD *)v44 + 25);
              if (v139)
              {
                if (!*(_BYTE *)(v139 + 14))
                {
                  v140 = objc_msgSend(objc_alloc((Class)NWNetworkAgentRegistration), "initWithNetworkAgentClass:", objc_opt_class(v139));
                  v141 = *(void **)(v139 + 56);
                  *(_QWORD *)(v139 + 56) = v140;

                  v145 = *(void **)(v139 + 56);
                  if (!v145)
                  {
                    sub_100109270(CFSTR("NRBTLinkPreferenceAgent"), CFSTR("RegisterAgent"), CFSTR("Create Failed"), 1, CFSTR("Failed to create BTLinkPreferences network agent"), v142, v143, v144, (uint64_t)v305);
                    v145 = *(void **)(v139 + 56);
                  }
                  if ((objc_msgSend(v145, "registerNetworkAgent:", v139) & 1) == 0)
                    sub_100109270(CFSTR("NRBTLinkPreferenceAgent"), CFSTR("RegisterAgent"), CFSTR("Register Failed"), 1, CFSTR("Failed to register BTLinkPreferences network agent"), v146, v147, v148, (uint64_t)v305);
                  objc_msgSend((id)v139, "setActive:", 1);
                  objc_msgSend(*(id *)(v139 + 56), "updateNetworkAgent:", v139);
                  v149 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyRouteRule routeRuleWithAction:forType:](NEPolicyRouteRule, "routeRuleWithAction:forType:", 5, 6));
                  v150 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v139, "agentUUID"));
                  objc_msgSend(v149, "setNetworkAgentUUID:", v150);

                  *(_QWORD *)&v360 = v149;
                  v151 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v360, 1));
                  v313 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult routeRules:](NEPolicyResult, "routeRules:", v151));

                  v152 = (void *)objc_claimAutoreleasedReturnValue(+[NRBTLinkPreferencesAgent agentDomain](NRBTLinkPreferencesAgent, "agentDomain"));
                  v153 = (void *)objc_claimAutoreleasedReturnValue(+[NRBTLinkPreferencesAgent agentType](NRBTLinkPreferencesAgent, "agentType"));
                  v310 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition requiredAgentDomain:agentType:](NEPolicyCondition, "requiredAgentDomain:agentType:", v152, v153));

                  v154 = objc_alloc((Class)NEPolicy);
                  from[0] = v310;
                  v155 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](NEPolicyCondition, "allInterfaces"));
                  from[1] = v155;
                  v156 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", from, 2));
                  v157 = objc_msgSend(v154, "initWithOrder:result:conditions:", 10, v313, v156);

                  objc_opt_self(NRDPolicySessionManager);
                  if (qword_1001E4A20 != -1)
                    dispatch_once(&qword_1001E4A20, &stru_1001B8590);
                  v158 = (id)qword_1001E4A18;
                  v159 = sub_100127310((uint64_t)v158, *(void **)(v139 + 72), v157);

                  objc_opt_self(NRDPolicySessionManager);
                  if (qword_1001E4A20 != -1)
                    dispatch_once(&qword_1001E4A20, &stru_1001B8590);
                  v160 = (id)qword_1001E4A18;
                  v161 = (id *)v160;
                  if (v160)
                  {
                    dispatch_assert_queue_V2(*((dispatch_queue_t *)v160 + 1));
                    if ((objc_msgSend(v161[2], "apply") & 1) == 0)
                      sub_100109270(CFSTR("NRPolicySessionManager"), CFSTR("ApplyPolicy Failed"), 0, 1, CFSTR("Failed to apply policies"), v162, v163, v164, (uint64_t)v305);
                  }

                  *(_BYTE *)(v139 + 14) = 1;
                  v165 = *(id *)(v139 + 40);
                  v166 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v139, "agentUUID"));
                  v167 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v166, "UUIDString"));
                  sub_100121E18(v165, 18002, 0, v167);

                }
              }
            }
            sub_1000E4040((void **)v44);
            if (v44[45] && sub_1001099A0())
              sub_100121E18(*((void **)v44 + 12), 1036, 0, 0);
            v168 = *((_QWORD *)v44 + 13);
            from[0] = _NSConcreteStackBlock;
            from[1] = (id)3221225472;
            *(_QWORD *)&v365 = sub_1000ED40C;
            *((_QWORD *)&v365 + 1) = &unk_1001B8AE0;
            *(_QWORD *)&v366 = v44;
            dispatch_async(v168, from);

LABEL_168:
LABEL_169:
            objc_msgSend((id)val[25], "setObject:forKeyedSubscript:", v44, v41);
            sub_1000A7BA4((uint64_t)val);

LABEL_170:
            v39 = v324 + 1;
          }
          while ((id)(v324 + 1) != v320);
          v320 = objc_msgSend(v317, "countByEnumeratingWithState:objects:count:", &v339, v354, 16);
        }
        while (v320);
      }

      if (!objc_msgSend(v317, "count"))
      {
        sub_1000AA324();
        v234 = (uint64_t)val;
        v235 = val[24];
        if (v235)
        {
          sub_10014E7AC(v235);
          v236 = (void *)val[24];
          val[24] = 0;

          v234 = (uint64_t)val;
        }
        v237 = *(_QWORD *)(v234 + 96);
        if (v237)
        {
          sub_100061418(v237);
          v238 = (void *)val[12];
          val[12] = 0;

          v234 = (uint64_t)val;
        }
        sub_1000A4E44(v234);
        sub_1000A5020(val);
        sub_1000A5350((uint64_t)val);
        v239 = val;
        if (val[36])
        {
          if (qword_1001E4738 != -1)
            dispatch_once(&qword_1001E4738, &stru_1001B7110);
          if (_NRLogIsLevelEnabled(qword_1001E4730, 0))
          {
            if (qword_1001E4738 != -1)
              dispatch_once(&qword_1001E4738, &stru_1001B7110);
            v241 = (id)qword_1001E4730;
            v305 = "";
            _NRLogWithArgs(v241, 0, "%s%.30s:%-4d removing path evaluator for appVPN %@");

          }
          nw_path_evaluator_cancel(val[36], v240);
          v242 = (void *)val[36];
          val[36] = 0;

          v239 = val;
        }
        v243 = *((_DWORD *)v239 + 7);
        if (v243 != -1)
        {
          notify_cancel(v243);
          v239 = val;
          *((_DWORD *)val + 7) = -1;
        }
        v244 = (void *)v239[38];
        v239[38] = 0;

        sub_1000A2E80((uint64_t)val);
        v245 = val[33];
        if (v245)
        {
          dispatch_source_cancel(v245);
          v246 = (void *)val[33];
          val[33] = 0;

        }
        objc_opt_self(NRIKEv2Listener);
        if (qword_1001E44D8 != -1)
          dispatch_once(&qword_1001E44D8, &stru_1001B5E70);
        v247 = (id)qword_1001E44D0;
        v248 = (uint64_t)v247;
        if (v247)
        {
          v249 = (void *)v247[2];
          if (v249)
          {
            objc_msgSend(v249, "cancel");
            v250 = *(void **)(v248 + 16);
            *(_QWORD *)(v248 + 16) = 0;

            objc_opt_self(NRDPolicySessionManager);
            if (qword_1001E4A20 != -1)
              dispatch_once(&qword_1001E4A20, &stru_1001B8590);
            v251 = (id)qword_1001E4A18;
            sub_100127618((uint64_t)v251, CFSTR("NRIKEv2Listener"));

            objc_opt_self(NRDPolicySessionManager);
            if (qword_1001E4A20 != -1)
              dispatch_once(&qword_1001E4A20, &stru_1001B8590);
            v252 = (id)qword_1001E4A18;
            v253 = (id *)v252;
            if (v252)
            {
              dispatch_assert_queue_V2(*((dispatch_queue_t *)v252 + 1));
              if ((objc_msgSend(v253[2], "apply") & 1) == 0)
                sub_100109270(CFSTR("NRPolicySessionManager"), CFSTR("ApplyPolicy Failed"), 0, 1, CFSTR("Failed to apply policies"), v254, v255, v256, (uint64_t)v305);
            }

          }
          v257 = *(void **)(v248 + 24);
          *(_QWORD *)(v248 + 24) = 0;

          v258 = *(void **)(v248 + 32);
          *(_QWORD *)(v248 + 32) = 0;

          memset(v359, 0, 32);
          v358 = 0u;
          *(_OWORD *)location = 0u;
          v259 = *(id *)(v248 + 48);
          v260 = (char *)objc_msgSend(v259, "countByEnumeratingWithState:objects:count:", location, &block, 16);
          if (v260)
          {
            v261 = *(_QWORD *)v358;
            do
            {
              v262 = 0;
              do
              {
                if (*(_QWORD *)v358 != v261)
                  objc_enumerationMutation(v259);
                v263 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v248 + 48), "objectForKeyedSubscript:", *((_QWORD *)location[1] + (_QWORD)v262)));
                v264 = (void *)v263;
                if (v263)
                  v265 = *(_QWORD *)(v263 + 40);
                else
                  v265 = 0;
                (*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD))(v265 + 16))(v265, 0, 0, 0);

                ++v262;
              }
              while (v260 != v262);
              v266 = (char *)objc_msgSend(v259, "countByEnumeratingWithState:objects:count:", location, &block, 16);
              v260 = v266;
            }
            while (v266);
          }

          v267 = *(void **)(v248 + 48);
          *(_QWORD *)(v248 + 48) = 0;

          sub_10000EF60(v248);
        }

        goto LABEL_289;
      }
      sub_1000A7EAC((char *)val);
      sub_1000A87B8(val);
      v329 = 0u;
      v330 = 0u;
      v327 = 0u;
      v328 = 0u;
      v169 = (id)val[25];
      v170 = objc_msgSend(v169, "countByEnumeratingWithState:objects:count:", &v327, v351, 16);
      if (v170)
      {
        v171 = 0;
        v172 = 0;
        v173 = *(_QWORD *)v328;
        do
        {
          v174 = 0;
          do
          {
            if (*(_QWORD *)v328 != v173)
              objc_enumerationMutation(v169);
            v175 = *(_QWORD *)(*((_QWORD *)&v327 + 1) + 8 * (_QWORD)v174);
            v176 = (_BYTE *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)val[25], "objectForKeyedSubscript:", v175));
            if (v176)
              v177 = v176[9] != 0;
            else
              v177 = 0;

            v178 = (_BYTE *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)val[25], "objectForKeyedSubscript:", v175));
            if (v178)
              v179 = v178[8] != 0;
            else
              v179 = 0;

            v171 |= v177;
            v172 |= v179;
            v174 = (char *)v174 + 1;
          }
          while (v170 != v174);
          v180 = objc_msgSend(v169, "countByEnumeratingWithState:objects:count:", &v327, v351, 16);
          v170 = v180;
        }
        while (v180);

        if ((v171 & 1) != 0)
        {
          v181 = val;
          if (!val[24])
          {
            v182 = [NRPhoneCallRelayAgent alloc];
            v183 = (id)val[15];
            v184 = sub_10014EA14((id *)&v182->super.isa, v183, val);
            v185 = (void *)val[24];
            val[24] = v184;

            v189 = val[24];
            if (v189)
            {
              if (!*(_BYTE *)(v189 + 14))
              {
                v190 = objc_msgSend(objc_alloc((Class)NWNetworkAgentRegistration), "initWithNetworkAgentClass:", objc_opt_class(v189));
                v191 = *(void **)(v189 + 48);
                *(_QWORD *)(v189 + 48) = v190;

                v195 = *(void **)(v189 + 48);
                if (!v195)
                {
                  sub_100109270(CFSTR("NRPhoneCallRelayAgent"), CFSTR("RegisterAgent"), CFSTR("Create Failed"), 1, CFSTR("Failed to create phone call relay network agent"), v192, v193, v194, (uint64_t)v305);
                  v195 = *(void **)(v189 + 48);
                }
                if ((objc_msgSend(v195, "registerNetworkAgent:", v189) & 1) == 0)
                  sub_100109270(CFSTR("NRPhoneCallRelayAgent"), CFSTR("RegisterAgent"), CFSTR("Register Failed"), 1, CFSTR("Failed to register phone call relay network agent"), v196, v197, v198, (uint64_t)v305);
                v199 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v189, "agentUUID"));
                v325 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult netAgentUUID:](NEPolicyResult, "netAgentUUID:", v199));

                v200 = (void *)objc_claimAutoreleasedReturnValue(+[NRPhoneCallRelayAgent agentDomain](NRPhoneCallRelayAgent, "agentDomain"));
                v201 = (void *)objc_claimAutoreleasedReturnValue(+[NRPhoneCallRelayAgent agentType](NRPhoneCallRelayAgent, "agentType"));
                v314 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition requiredAgentDomain:agentType:](NEPolicyCondition, "requiredAgentDomain:agentType:", v200, v201));

                v202 = objc_alloc((Class)NEPolicy);
                from[0] = v314;
                v203 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](NEPolicyCondition, "allInterfaces"));
                from[1] = v203;
                v204 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", from, 2));
                v205 = objc_msgSend(v202, "initWithOrder:result:conditions:", 10, v325, v204);

                objc_opt_self(NRDPolicySessionManager);
                if (qword_1001E4A20 != -1)
                  dispatch_once(&qword_1001E4A20, &stru_1001B8590);
                v206 = (id)qword_1001E4A18;
                v207 = sub_100127310((uint64_t)v206, *(void **)(v189 + 64), v205);

                v321 = (void **)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition trafficClassStart:end:](NEPolicyCondition, "trafficClassStart:end:", 800, 900));
                v319 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition ipProtocol:](NEPolicyCondition, "ipProtocol:", 17));
                v316 = (id)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition platformBinary](NEPolicyCondition, "platformBinary"));
                v311 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition accountIdentifier:](NEPolicyCondition, "accountIdentifier:", CFSTR("com.apple.networkrelay.companion_proxy")));
                v208 = objc_alloc((Class)NEPolicy);
                block = v321;
                v369 = (uint64_t)v319;
                v370 = v316;
                v371 = v311;
                v209 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](NEPolicyCondition, "allInterfaces"));
                v372 = v209;
                v210 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &block, 5));
                v211 = objc_msgSend(v208, "initWithOrder:result:conditions:", 10, v325, v210);

                objc_opt_self(NRDPolicySessionManager);
                if (qword_1001E4A20 != -1)
                  dispatch_once(&qword_1001E4A20, &stru_1001B8590);
                v212 = (id)qword_1001E4A18;
                v213 = sub_100127310((uint64_t)v212, *(void **)(v189 + 64), v211);

                objc_opt_self(NRDLocalDevice);
                v214 = sub_10014CFBC();
                dispatch_assert_queue_V2(v214);

                *(_OWORD *)location = xmmword_10015D090;
                v215 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", location, 16);
                v216 = sub_100133E24((uint64_t)NRDLocalDevice, v215, CFSTR("0"));
                v217 = (void *)objc_claimAutoreleasedReturnValue(v216);

                v218 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v217, "hostname"));
                v219 = (void *)objc_claimAutoreleasedReturnValue(+[NWAddressEndpoint endpointWithHostname:port:](NWAddressEndpoint, "endpointWithHostname:port:", v218, CFSTR("62742")));

                v220 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition flowRemoteAddress:prefix:](NEPolicyCondition, "flowRemoteAddress:prefix:", v219, 64));
                v221 = objc_alloc((Class)NEPolicy);
                location[0] = v321;
                location[1] = v319;
                *(_QWORD *)&v358 = v316;
                *((_QWORD *)&v358 + 1) = v220;
                v222 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](NEPolicyCondition, "allInterfaces"));
                *(_QWORD *)&v359[0] = v222;
                v223 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", location, 5));
                v224 = objc_msgSend(v221, "initWithOrder:result:conditions:", 10, v325, v223);

                objc_opt_self(NRDPolicySessionManager);
                if (qword_1001E4A20 != -1)
                  dispatch_once(&qword_1001E4A20, &stru_1001B8590);
                v225 = (id)qword_1001E4A18;
                v226 = sub_100127310((uint64_t)v225, *(void **)(v189 + 64), v224);

                objc_opt_self(NRDPolicySessionManager);
                if (qword_1001E4A20 != -1)
                  dispatch_once(&qword_1001E4A20, &stru_1001B8590);
                v227 = (id)qword_1001E4A18;
                v228 = (id *)v227;
                if (v227)
                {
                  dispatch_assert_queue_V2(*((dispatch_queue_t *)v227 + 1));
                  if ((objc_msgSend(v228[2], "apply") & 1) == 0)
                    sub_100109270(CFSTR("NRPolicySessionManager"), CFSTR("ApplyPolicy Failed"), 0, 1, CFSTR("Failed to apply policies"), v229, v230, v231, (uint64_t)v305);
                }

                *(_BYTE *)(v189 + 14) = 1;
                v232 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)v189, "agentUUID"));
                v233 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v232, "UUIDString"));
                sub_100121E18(0, 16002, 0, v233);

              }
            }
            else
            {
              sub_100109270(CFSTR("NRLinkDirector"), CFSTR("PhoneCallRelayAgent is Nil"), 0, 1, CFSTR("[[NRPhoneCallRelayAgent alloc] initWithQueue: delegate:]"), v186, v187, v188, (uint64_t)v305);
            }
LABEL_251:
            v181 = val;
            if ((v172 & 1) != 0)
              goto LABEL_252;
            goto LABEL_258;
          }
          goto LABEL_257;
        }
      }
      else
      {

        v172 = 0;
      }
      v181 = val;
      v268 = val[24];
      if (v268)
      {
        sub_10014E7AC(v268);
        v269 = (void *)val[24];
        val[24] = 0;

        goto LABEL_251;
      }
LABEL_257:
      if ((v172 & 1) != 0)
      {
LABEL_252:
        if (!v181[12])
        {
          v270 = objc_alloc_init(NRPreferWiFiAgent);
          v271 = (void *)val[12];
          val[12] = v270;

          v272 = (void *)val[15];
          v273 = (id *)(id)val[12];
          v274 = v272;
          v275 = v274;
          if (!v273)
          {

            if (qword_1001E4738 != -1)
              dispatch_once(&qword_1001E4738, &stru_1001B7110);
            if (_NRLogIsLevelEnabled(qword_1001E4730, 17))
            {
              v304 = sub_1000A2640();
              _NRLogWithArgs(v304, 17, "Failed to register prefer Wi-Fi agent");

            }
            goto LABEL_289;
          }
          if (!*((_BYTE *)v273 + 14))
          {
            objc_storeStrong(v273 + 5, v272);
            objc_initWeak(location, v273);
            v276 = dispatch_time(0x8000000000000000, 1000000000);
            v277 = v273[5];
            block = _NSConcreteStackBlock;
            v369 = 3221225472;
            v370 = sub_100060CBC;
            v371 = &unk_1001B7F28;
            v278 = v277;
            objc_copyWeak(&v372, location);
            dispatch_after(v276, v278, &block);

            objc_destroyWeak(&v372);
            objc_destroyWeak(location);
          }

          goto LABEL_260;
        }
        goto LABEL_261;
      }
LABEL_258:
      v279 = v181[12];
      if (v279)
      {
        sub_100061418(v279);
        v273 = (id *)val[12];
        val[12] = 0;
LABEL_260:

        v181 = val;
      }
LABEL_261:
      v281 = *((_DWORD *)v181 + 6);
      v280 = (int *)(v181 + 3);
      if (v281 == -1)
      {
        if (qword_1001E4738 != -1)
          dispatch_once(&qword_1001E4738, &stru_1001B7110);
        if (_NRLogIsLevelEnabled(qword_1001E4730, 0))
        {
          if (qword_1001E4738 != -1)
            dispatch_once(&qword_1001E4738, &stru_1001B7110);
          _NRLogWithArgs(qword_1001E4730, 0, "%s%.30s:%-4d registering thermal pressure level watcher", "", "-[NRLinkDirector setupThermalStateWatcher]", 2665);
        }
        objc_initWeak(from, val);
        v282 = (id)val[15];
        location[0] = _NSConcreteStackBlock;
        location[1] = (id)3221225472;
        *(_QWORD *)&v358 = sub_1000AC22C;
        *((_QWORD *)&v358 + 1) = &unk_1001B8990;
        objc_copyWeak((id *)v359, from);
        v283 = notify_register_dispatch(kOSThermalNotificationPressureLevelName, v280, v282, location);

        if (v283 || *v280 == -1)
        {
          if (qword_1001E4738 != -1)
            dispatch_once(&qword_1001E4738, &stru_1001B7110);
          v284 = (id)qword_1001E4730;
          v285 = _NRLogIsLevelEnabled(v284, 17);

          if ((v285 & 1) != 0)
          {
            if (qword_1001E4738 != -1)
              dispatch_once(&qword_1001E4738, &stru_1001B7110);
            v286 = (id)qword_1001E4730;
            _NRLogWithArgs(v286, 17, "notify_register_dispatch (status: %u, token: %d) failed", v283, *v280);

          }
        }
        else
        {
          v287 = val[15];
          block = _NSConcreteStackBlock;
          v369 = 3221225472;
          v370 = sub_1000AC2AC;
          v371 = &unk_1001B8AE0;
          v372 = val;
          dispatch_async(v287, &block);
        }
        objc_destroyWeak((id *)v359);
        objc_destroyWeak(from);
      }
      sub_1000A9ABC();
      if (val[36])
      {
        sub_1000A26B0((uint64_t)val);
      }
      else
      {
        v288 = nw_parameters_create();
        nw_parameters_set_account_id(v288, "com.apple.networkextension.app-vpn-agent");
        evaluator_for_endpoint = (void *)nw_path_create_evaluator_for_endpoint(0, v288);
        nw_path_evaluator_set_queue(evaluator_for_endpoint, val[15]);
        objc_initWeak(from, val);
        location[0] = _NSConcreteStackBlock;
        location[1] = (id)3221225472;
        *(_QWORD *)&v358 = sub_1000AB5E8;
        *((_QWORD *)&v358 + 1) = &unk_1001B7058;
        objc_copyWeak((id *)v359 + 1, from);
        v290 = evaluator_for_endpoint;
        *(_QWORD *)&v359[0] = v290;
        v291 = objc_retainBlock(location);
        v292 = (id)val[15];
        nw_path_evaluator_set_update_handler(v290, v292, v291);

        nw_path_evaluator_start(v290);
        objc_storeStrong((id *)val + 36, evaluator_for_endpoint);
        if (qword_1001E4738 != -1)
          dispatch_once(&qword_1001E4738, &stru_1001B7110);
        v293 = (id)qword_1001E4730;
        v294 = _NRLogIsLevelEnabled(v293, 0);

        if ((v294 & 1) != 0)
        {
          if (qword_1001E4738 != -1)
            dispatch_once(&qword_1001E4738, &stru_1001B7110);
          v295 = (id)qword_1001E4730;
          v296 = (id)val[36];
          _NRLogWithArgs(v295, 0, "%s%.30s:%-4d registering path evaluator for appVPN %@", "", "-[NRLinkDirector setupAppVPNWatcher]", 2362, v296);

        }
        v297 = val[15];
        block = _NSConcreteStackBlock;
        v369 = 3221225472;
        v370 = sub_1000ABB68;
        v371 = &unk_1001B7080;
        v372 = val;
        v373 = v290;
        v374 = v291;
        v298 = v291;
        v299 = v290;
        dispatch_async(v297, &block);

        objc_destroyWeak((id *)v359 + 1);
        objc_destroyWeak(from);

      }
      if (!val[33])
      {
        v300 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, (dispatch_queue_t)val[15]);
        dispatch_source_set_timer(v300, 0, 0x29E8D60800uLL, 0x2FAF080uLL);
        objc_initWeak(location, val);
        block = _NSConcreteStackBlock;
        v369 = 3221225472;
        v370 = sub_1000AABA0;
        v371 = &unk_1001B87F0;
        objc_copyWeak(&v373, location);
        v301 = v300;
        v372 = v301;
        dispatch_source_set_event_handler(v301, &block);
        dispatch_resume(v301);
        v302 = (void *)val[33];
        val[33] = v301;
        v303 = v301;

        objc_destroyWeak(&v373);
        objc_destroyWeak(location);
      }
LABEL_289:

      return;
    }
    if (qword_1001E4738 != -1)
      dispatch_once(&qword_1001E4738, &stru_1001B7110);
    if (_NRLogIsLevelEnabled(qword_1001E4730, 1))
    {
      if (qword_1001E4738 != -1)
        dispatch_once(&qword_1001E4738, &stru_1001B7110);
      _NRLogWithArgs(qword_1001E4730, 1, "%s%.30s:%-4d Ignoring enabled device check since director is not enabled", "", "-[NRLinkDirector checkEnabledDevices]", 780);
    }
  }
}

void sub_1000A7B64(_Unwind_Exception *a1)
{
  id *v1;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)&STACK[0x5C0]);
  _Unwind_Resume(a1);
}

void sub_1000A7BA4(uint64_t a1)
{
  NSObject *v2;
  dispatch_group_t v3;
  id v4;
  id v5;
  char v6;
  void *v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  char *v11;
  char *v12;
  void *v13;
  id v14;
  void *v15;
  id v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  id v20;
  id v21;
  NSObject *v22;
  id v23;
  void *v24;
  NSObject *v25;
  id v26;
  uint64_t v27;
  _QWORD v28[4];
  id v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  id block[4];
  id v35;
  uint64_t v36;
  id v37;
  _BYTE v38[128];

  v2 = sub_10014CFBC();
  dispatch_assert_queue_V2(v2);

  v3 = dispatch_group_create();
  v30 = 0u;
  v31 = 0u;
  v32 = 0u;
  v33 = 0u;
  v4 = *(id *)(a1 + 200);
  v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v30, v38, 16);
  if (v5)
  {
    v6 = 0;
    v27 = *(_QWORD *)v31;
    do
    {
      v7 = 0;
      v26 = v5;
      do
      {
        if (*(_QWORD *)v31 != v27)
          objc_enumerationMutation(v4);
        v8 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 200), "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v30 + 1) + 8 * (_QWORD)v7)));
        v9 = v3;
        v10 = v9;
        if (v8
          && _NRIsAppleInternal(v9)
          && objc_opt_class(NPSDomainAccessor)
          && objc_opt_class(NRPairedDeviceRegistry)
          && *(_BYTE *)(v8 + 48))
        {
          if (qword_1001E4788 != -1)
            dispatch_once(&qword_1001E4788, &stru_1001B7568);
          v11 = sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(v8 + 96));
          v12 = v11;
          if (v11)
            v13 = (void *)*((_QWORD *)v11 + 5);
          else
            v13 = 0;
          v14 = v13;
          v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "description"));
          v16 = v4;
          v17 = a1;
          v18 = v3;
          v19 = qword_1001E4780;
          block[0] = _NSConcreteStackBlock;
          block[1] = (id)3221225472;
          block[2] = sub_1000EFB50;
          block[3] = &unk_1001B87A0;
          v35 = v14;
          v36 = v8;
          v37 = v15;
          v20 = v15;
          v21 = v14;
          v22 = v19;
          v3 = v18;
          a1 = v17;
          v4 = v16;
          v5 = v26;
          dispatch_group_async(v10, v22, block);

          v6 = 1;
        }

        v7 = (char *)v7 + 1;
      }
      while (v5 != v7);
      v23 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v30, v38, 16);
      v5 = v23;
    }
    while (v23);

    if ((v6 & 1) != 0)
    {
      objc_initWeak(block, (id)a1);
      v24 = *(void **)(a1 + 120);
      v28[0] = _NSConcreteStackBlock;
      v28[1] = 3221225472;
      v28[2] = sub_1000ADA40;
      v28[3] = &unk_1001B7F28;
      v25 = v24;
      objc_copyWeak(&v29, block);
      dispatch_group_notify(v10, v25, v28);

      objc_destroyWeak(&v29);
      objc_destroyWeak(block);
    }
  }
  else
  {

  }
}

void sub_1000A7EAC(char *a1)
{
  id v1;
  __objc2_prot *v2;
  id v3;
  char v4;
  uint64_t v5;
  void *i;
  char *v7;
  __objc2_prot *v8;
  id v9;
  __objc2_prop_list *v10;
  nw_parameters_t v11;
  uint64_t v12;
  uint64_t *v13;
  void *v14;
  uint64_t v15;
  NSObject *v16;
  dispatch_time_t v17;
  NSObject *v18;
  void *v19;
  NSObject *v20;
  id v21;
  void *v22;
  void *v23;
  void *v24;
  id v25;
  void *v26;
  void *v27;
  __objc2_class *v28;
  id v29;
  id v30;
  id v31;
  id *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  id v36;
  int IsLevelEnabled;
  id v38;
  uint64_t v39;
  int *v40;
  uint64_t v41;
  id v42;
  id v43;
  int v44;
  id v45;
  uint64_t v46;
  int *v47;
  uint64_t v48;
  id v49;
  id v50;
  int v51;
  id v52;
  uint64_t v53;
  int *v54;
  uint64_t v55;
  id v56;
  id v57;
  int v58;
  id v59;
  uint64_t v60;
  int *v61;
  uint64_t v62;
  id v63;
  uint64_t v64;
  nw_endpoint_t host;
  char *v66;
  id v67;
  _QWORD v68[4];
  NSObject *v69;
  id v70;
  id v71;
  _QWORD v72[5];
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  _QWORD v77[3];
  _BYTE v78[128];

  v66 = a1;
  if (a1)
  {
    v73 = 0u;
    v74 = 0u;
    v75 = 0u;
    v76 = 0u;
    v67 = sub_1001379CC((uint64_t)NRDLocalDevice);
    v3 = objc_msgSend(v67, "countByEnumeratingWithState:objects:count:", &v73, v78, 16);
    if (v3)
    {
      v4 = 0;
      v5 = *(_QWORD *)v74;
      while (2)
      {
        for (i = 0; i != v3; i = (char *)i + 1)
        {
          if (*(_QWORD *)v74 != v5)
            objc_enumerationMutation(v67);
          v7 = sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(*((_QWORD *)&v73 + 1) + 8 * (_QWORD)i));
          v8 = (__objc2_prot *)v7;
          if (!v7)
          {
            v8 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
            if (qword_1001E4738 != -1)
              dispatch_once(&qword_1001E4738, &stru_1001B7110);
            v36 = (id)qword_1001E4730;
            IsLevelEnabled = _NRLogIsLevelEnabled(v36, 16);

            if (IsLevelEnabled)
            {
              if (qword_1001E4738 != -1)
                dispatch_once(&qword_1001E4738, &stru_1001B7110);
              v38 = (id)qword_1001E4730;
              _NRLogWithArgs(v38, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)", "", "-[NRLinkDirector startSocksServerIfNeeded]", 1798);

            }
            v39 = _os_log_pack_size(12);
            v28 = (__objc2_class *)((char *)&v64 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0));
            v40 = __error();
            v41 = _os_log_pack_fill(v28, v39, *v40, &_mh_execute_header, "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
            *(_DWORD *)v41 = 136446210;
            *(_QWORD *)(v41 + 4) = "-[NRLinkDirector startSocksServerIfNeeded]";
            v42 = sub_1000A2640();
            _NRLogAbortWithPack(v42, v28);
            goto LABEL_50;
          }
          v9 = *((id *)v7 + 16);
          v1 = (id)(v9 == 0);

          if ((v1 & 1) != 0)
          {
            v4 = 1;
          }
          else
          {
            v1 = v8[1].inst_props;
            if (objc_msgSend(v1, "proxyCapability") == (id)1)
            {
              v10 = v8[1].inst_props;
              v2 = (__objc2_prot *)-[__objc2_prop_list hasCompanionDatapath](v10, "hasCompanionDatapath");

            }
            else
            {
              v2 = 0;
            }

            v4 |= v2;
          }

        }
        v3 = objc_msgSend(v67, "countByEnumeratingWithState:objects:count:", &v73, v78, 16);
        if (v3)
          continue;
        break;
      }

      if ((v4 & 1) != 0)
      {
        if (*((_QWORD *)v66 + 16))
          goto LABEL_32;
        host = nw_endpoint_create_host("::", "62742");
        if (host)
        {
          v11 = nw_parameters_create();
          v8 = (__objc2_prot *)v11;
          if (v11)
          {
            nw_parameters_set_local_address(v11, host);
            nw_parameters_set_required_interface_subtype(v8, 5001);
            nw_parameters_set_always_open_listener_socket(v8, 1);
            v1 = *((id *)v66 + 15);
            v12 = nw_shoes_server_create(v8, v1);
            v14 = (void *)*((_QWORD *)v66 + 16);
            v13 = (uint64_t *)(v66 + 128);
            *((_QWORD *)v66 + 16) = v12;

            v15 = *v13;
            if (*v13)
            {
              v72[0] = _NSConcreteStackBlock;
              v72[1] = 3221225472;
              v72[2] = sub_1000AD6C0;
              v72[3] = &unk_1001B8550;
              v72[4] = v66;
              nw_socks5_server_set_state_changed_handler(v15, v72);
              nw_socks5_server_start(*((_QWORD *)v66 + 16));
              if (!*((_QWORD *)v66 + 19))
              {
                v16 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, *((dispatch_queue_t *)v66 + 15));
                v17 = dispatch_time(0x8000000000000000, 21600000000000);
                dispatch_source_set_timer(v16, v17, 0x13A52453C000uLL, 0xEE6B280uLL);
                objc_initWeak(&v71, v66);
                v68[0] = _NSConcreteStackBlock;
                v68[1] = 3221225472;
                v68[2] = sub_1000AD94C;
                v68[3] = &unk_1001B87F0;
                objc_copyWeak(&v70, &v71);
                v18 = v16;
                v69 = v18;
                dispatch_source_set_event_handler(v18, v68);
                dispatch_activate(v18);
                v19 = (void *)*((_QWORD *)v66 + 19);
                *((_QWORD *)v66 + 19) = v18;
                v20 = v18;

                objc_destroyWeak(&v70);
                objc_destroyWeak(&v71);
              }
              v66 = (char *)objc_msgSend(objc_alloc((Class)NSUUID), "initWithUUIDBytes:", &ne_privacy_proxy_netagent_id);
              v21 = objc_alloc((Class)NEPolicy);
              v22 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult removeNetworkAgentUUID:](NEPolicyResult, "removeNetworkAgentUUID:", v66));
              v23 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](NEPolicyCondition, "allInterfaces"));
              v77[0] = v23;
              v24 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition accountIdentifier:](NEPolicyCondition, "accountIdentifier:", CFSTR("com.apple.networkrelay.companion_proxy")));
              v77[1] = v24;
              v25 = +[NEPolicyCondition effectivePID:](NEPolicyCondition, "effectivePID:", getpid());
              v26 = (void *)objc_claimAutoreleasedReturnValue(v25);
              v77[2] = v26;
              v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v77, 3));
              v1 = objc_msgSend(v21, "initWithOrder:result:conditions:", 10, v22, v27);

              v28 = &OBJC_METACLASS___NRAnalyticsLocalDevice;
              objc_opt_self(NRDPolicySessionManager);
              v2 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
              if (qword_1001E4A20 == -1)
                goto LABEL_24;
              goto LABEL_51;
            }
            v57 = sub_1000A2640();
            v58 = _NRLogIsLevelEnabled(v57, 16);

            if (v58)
            {
              v59 = sub_1000A2640();
              _NRLogWithArgs(v59, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (self.socksServer) != ((void *)0)", "", "-[NRLinkDirector startSocksServerIfNeeded]", 1833);

            }
            v60 = _os_log_pack_size(12);
            v28 = (__objc2_class *)((char *)&v64 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0));
            v61 = __error();
            v62 = _os_log_pack_fill(v28, v60, *v61, &_mh_execute_header, "%{public}s Assertion Failed: (self.socksServer) != ((void *)0)");
            *(_DWORD *)v62 = 136446210;
            *(_QWORD *)(v62 + 4) = "-[NRLinkDirector startSocksServerIfNeeded]";
            v63 = sub_1000A2640();
            _NRLogAbortWithPack(v63, v28);
          }
          else
          {
            v50 = sub_1000A2640();
            v51 = _NRLogIsLevelEnabled(v50, 16);

            if (v51)
            {
              v52 = sub_1000A2640();
              _NRLogWithArgs(v52, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (socksParameters) != ((void *)0)", "", "-[NRLinkDirector startSocksServerIfNeeded]", 1822);

            }
            v53 = _os_log_pack_size(12);
            v28 = (__objc2_class *)((char *)&v64 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0));
            v54 = __error();
            v55 = _os_log_pack_fill(v28, v53, *v54, &_mh_execute_header, "%{public}s Assertion Failed: (socksParameters) != ((void *)0)");
            *(_DWORD *)v55 = 136446210;
            *(_QWORD *)(v55 + 4) = "-[NRLinkDirector startSocksServerIfNeeded]";
            v56 = sub_1000A2640();
            _NRLogAbortWithPack(v56, v28);
          }
        }
        else
        {
          v43 = sub_1000A2640();
          v44 = _NRLogIsLevelEnabled(v43, 16);

          if (v44)
          {
            v45 = sub_1000A2640();
            _NRLogWithArgs(v45, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (socksEndpoint) != ((void *)0)", "", "-[NRLinkDirector startSocksServerIfNeeded]", 1820);

          }
          v46 = _os_log_pack_size(12);
          v28 = (__objc2_class *)((char *)&v64 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0));
          v47 = __error();
          v48 = _os_log_pack_fill(v28, v46, *v47, &_mh_execute_header, "%{public}s Assertion Failed: (socksEndpoint) != ((void *)0)");
          *(_DWORD *)v48 = 136446210;
          *(_QWORD *)(v48 + 4) = "-[NRLinkDirector startSocksServerIfNeeded]";
          v49 = sub_1000A2640();
          _NRLogAbortWithPack(v49, v28);
        }
LABEL_50:
        __break(1u);
LABEL_51:
        dispatch_once(&qword_1001E4A20, &stru_1001B8590);
LABEL_24:
        v29 = (id)qword_1001E4A18;
        v30 = sub_100127310((uint64_t)v29, CFSTR("NRLinkDirector-skip-privacy-proxy"), v1);

        objc_opt_self(&v28[54]);
        if (v2[36].isa != (void *)-1)
          dispatch_once(&qword_1001E4A20, &stru_1001B8590);
        v31 = (id)qword_1001E4A18;
        v32 = (id *)v31;
        if (v31)
        {
          dispatch_assert_queue_V2(*((dispatch_queue_t *)v31 + 1));
          if ((objc_msgSend(v32[2], "apply") & 1) == 0)
            sub_100109270(CFSTR("NRPolicySessionManager"), CFSTR("ApplyPolicy Failed"), 0, 1, CFSTR("Failed to apply policies"), v33, v34, v35, v64);
        }

        goto LABEL_32;
      }
    }
    else
    {

    }
    sub_1000A4E44((uint64_t)v66);
LABEL_32:

  }
}

void sub_1000A87B8(_QWORD *a1)
{
  char v2;
  id v3;
  uint64_t v4;
  void *i;
  char *v6;
  id *v7;
  id v8;
  BOOL v9;
  id v10;
  id v11;
  unsigned __int8 v12;
  __objc2_prot *v13;
  const __CFString *v14;
  id v15;
  int IsLevelEnabled;
  id v17;
  _QWORD *v18;
  __objc2_prot *v19;
  int *v20;
  uint64_t v21;
  id v22;
  nw_parameters_t v23;
  id v24;
  _BOOL4 v25;
  _QWORD *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  const void *SelfSignedCertificate;
  __SecIdentity *v42;
  sec_identity_t v43;
  sec_identity_t *v44;
  void *v45;
  const __CFArray *v46;
  CFIndex Count;
  CFIndex v48;
  CFIndex v49;
  __SecCertificate *ValueAtIndex;
  SecKeyRef v51;
  uint64_t v52;
  void *v53;
  __objc2_prot *v55;
  __objc2_meth_list *opt_inst_meths;
  void *v57;
  id v58;
  __objc2_meth_list *v59;
  void *LogString;
  uint64_t v61;
  __objc2_meth_list *v62;
  _QWORD *v63;
  id v64;
  id v65;
  id v66;
  uint64_t v67;
  void **v68;
  void *v69;
  void *v70;
  id v71;
  id v72;
  id v73;
  id v74;
  id v75;
  id v76;
  int v77;
  id v78;
  int *v79;
  uint64_t v80;
  id v81;
  id v82;
  int v83;
  id v84;
  int *v85;
  uint64_t v86;
  id v87;
  id v88;
  int v89;
  id v90;
  int v91;
  id v92;
  int v93;
  id v94;
  int *v95;
  uint64_t v96;
  id v97;
  id v98;
  CFDictionaryRef v99;
  SecKeyRef v100;
  NSObject *options;
  __SecKey *RandomKey;
  nw_endpoint_t host;
  NSObject *v104;
  nw_parameters_t v105;
  _QWORD *v106;
  id v107;
  _QWORD v108[4];
  id v109;
  id v110;
  _QWORD v111[4];
  id v112;
  id v113;
  _QWORD v114[4];
  id v115;
  id v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  _BYTE v121[128];
  _QWORD v122[2];
  _QWORD v123[2];
  const __CFString *v124;
  void *v125;
  uint64_t v126;
  _UNKNOWN **v127;
  _QWORD v128[3];
  id v129[3];
  uint64_t v130;
  int v131;
  _QWORD v132[2];
  void *v133;
  _QWORD v134[2];
  void *v135;
  _QWORD v136[2];
  void *v137;
  _QWORD v138[2];
  void *v139;
  id location[4];

  if (a1)
  {
    if ((_os_feature_enabled_impl("terminus", "MASQUEProxyServer") & 1) != 0)
    {
      v106 = a1;
      v117 = 0u;
      v118 = 0u;
      v119 = 0u;
      v120 = 0u;
      v107 = sub_1001379CC((uint64_t)NRDLocalDevice);
      v2 = 0;
      v3 = objc_msgSend(v107, "countByEnumeratingWithState:objects:count:", &v117, v121, 16);
      if (v3)
      {
        v4 = *(_QWORD *)v118;
        do
        {
          for (i = 0; i != v3; i = (char *)i + 1)
          {
            if (*(_QWORD *)v118 != v4)
              objc_enumerationMutation(v107);
            v6 = sub_10012FFF4((uint64_t)NRDLocalDevice, *(void **)(*((_QWORD *)&v117 + 1) + 8 * (_QWORD)i));
            v7 = (id *)v6;
            if (!v6)
            {
              if (qword_1001E4738 != -1)
                dispatch_once(&qword_1001E4738, &stru_1001B7110);
              v15 = (id)qword_1001E4730;
              IsLevelEnabled = _NRLogIsLevelEnabled(v15, 16);

              if (IsLevelEnabled)
              {
                if (qword_1001E4738 != -1)
                  dispatch_once(&qword_1001E4738, &stru_1001B7110);
                v17 = (id)qword_1001E4730;
                _NRLogWithArgs(v17, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)", "", "-[NRLinkDirector startMASQUEProxyServerIfNeeded]", 2040);

              }
              v18 = (_QWORD *)_os_log_pack_size(12);
              v19 = (__objc2_prot *)((char *)&v98 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0));
              v20 = __error();
              v21 = _os_log_pack_fill(v19, v18, *v20, &_mh_execute_header, "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
              *(_DWORD *)v21 = 136446210;
              *(_QWORD *)(v21 + 4) = "-[NRLinkDirector startMASQUEProxyServerIfNeeded]";
              v22 = sub_1000A2640();
              _NRLogAbortWithPack(v22, v19);
              goto LABEL_122;
            }
            v8 = *((id *)v6 + 16);
            v9 = v8 == 0;

            if (v9)
            {
              v2 = 0;
            }
            else
            {
              v10 = v7[16];
              if (objc_msgSend(v10, "proxyCapability") == (id)1)
              {
                v11 = v7[16];
                v12 = objc_msgSend(v11, "usesTLS");

              }
              else
              {
                v12 = 0;
              }

              v2 |= v12;
            }

          }
          v3 = objc_msgSend(v107, "countByEnumeratingWithState:objects:count:", &v117, v121, 16);
        }
        while (v3);
      }

      if (qword_1001E4738 != -1)
        dispatch_once(&qword_1001E4738, &stru_1001B7110);
      v13 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
      if (_NRLogIsLevelEnabled(qword_1001E4730, 2))
      {
        if (qword_1001E4738 != -1)
          dispatch_once(&qword_1001E4738, &stru_1001B7110);
        v14 = CFSTR("NO");
        if ((v2 & 1) != 0)
          v14 = CFSTR("YES");
        _NRLogWithArgs(qword_1001E4730, 2, "%s%.30s:%-4d start MASQUE server : %@", "", "-[NRLinkDirector startMASQUEProxyServerIfNeeded]", 2052, v14);
      }
      if ((v2 & 1) == 0)
      {
        sub_1000A5020(v106);
LABEL_105:

        return;
      }
      if (v106[17])
      {
        if (qword_1001E4738 != -1)
          dispatch_once(&qword_1001E4738, &stru_1001B7110);
        if (_NRLogIsLevelEnabled(qword_1001E4730, 2))
        {
          if (qword_1001E4738 != -1)
            dispatch_once(&qword_1001E4738, &stru_1001B7110);
          _NRLogWithArgs(qword_1001E4730, 2, "%s%.30s:%-4d MASQUE server is already running", "", "-[NRLinkDirector startMASQUEProxyServerIfNeeded]", 2060);
        }
        goto LABEL_105;
      }
      host = nw_endpoint_create_host("::", "0");
      if (!host)
      {
        v76 = sub_1000A2640();
        v77 = _NRLogIsLevelEnabled(v76, 16);

        if (v77)
        {
          v78 = sub_1000A2640();
          _NRLogWithArgs(v78, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (masqueEndpoint) != ((void *)0)", "", "-[NRLinkDirector startMASQUEProxyServerIfNeeded]", 2065);

        }
        v18 = (_QWORD *)_os_log_pack_size(12);
        v19 = (__objc2_prot *)((char *)&v98 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0));
        v79 = __error();
        v80 = _os_log_pack_fill(v19, v18, *v79, &_mh_execute_header, "%{public}s Assertion Failed: (masqueEndpoint) != ((void *)0)");
        *(_DWORD *)v80 = 136446210;
        *(_QWORD *)(v80 + 4) = "-[NRLinkDirector startMASQUEProxyServerIfNeeded]";
        v81 = sub_1000A2640();
        _NRLogAbortWithPack(v81, v19);
        goto LABEL_122;
      }
      v23 = nw_parameters_create();
      v105 = v23;
      if (!v23)
      {
        v82 = sub_1000A2640();
        v83 = _NRLogIsLevelEnabled(v82, 16);

        if (v83)
        {
          v84 = sub_1000A2640();
          _NRLogWithArgs(v84, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (masqueParameters) != ((void *)0)", "", "-[NRLinkDirector startMASQUEProxyServerIfNeeded]", 2067);

        }
        v18 = (_QWORD *)_os_log_pack_size(12);
        v19 = (__objc2_prot *)((char *)&v98 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0));
        v85 = __error();
        v86 = _os_log_pack_fill(v19, v18, *v85, &_mh_execute_header, "%{public}s Assertion Failed: (masqueParameters) != ((void *)0)");
        *(_DWORD *)v86 = 136446210;
        *(_QWORD *)(v86 + 4) = "-[NRLinkDirector startMASQUEProxyServerIfNeeded]";
        v87 = sub_1000A2640();
        _NRLogAbortWithPack(v87, v19);
        goto LABEL_122;
      }
      nw_parameters_set_local_address(v23, host);
      nw_parameters_set_use_awdl(v105, 1);
      nw_parameters_set_no_proxy(v105, 1);
      options = nw_tls_create_options();
      v104 = nw_tls_copy_sec_protocol_options(options);
      v24 = (id)v106[13];
      if (v24)
      {
        v25 = v106[14] == 0;

        v26 = v106;
        if (!v25)
          goto LABEL_98;
      }
      v122[0] = kSecAttrKeyType;
      v122[1] = kSecAttrKeySizeInBits;
      v123[0] = kSecAttrKeyTypeECSECPrimeRandom;
      v123[1] = &off_1001C4750;
      v99 = (CFDictionaryRef)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v123, v122, 2));
      RandomKey = SecKeyCreateRandomKey(v99, 0);
      v100 = SecKeyCopyPublicKey(RandomKey);
      v27 = (void *)v106[13];
      v106[13] = 0;

      if (RandomKey)
      {
        if (v100)
        {
          v138[0] = kSecOidCountryName;
          v138[1] = CFSTR("US");
          v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v138, 2));
          v139 = v28;
          v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v139, 1));
          location[0] = v29;
          v136[0] = kSecOidOrganization;
          v136[1] = CFSTR("Apple Inc.");
          v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v136, 2));
          v137 = v30;
          v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v137, 1));
          location[1] = v31;
          v134[0] = kSecOidOrganizationalUnit;
          v134[1] = CFSTR("NetworkRelay.framework");
          v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v134, 2));
          v135 = v32;
          v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v135, 1));
          location[2] = v33;
          v132[0] = kSecOidCommonName;
          v132[1] = CFSTR("NetworkRelay");
          v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v132, 2));
          v133 = v34;
          v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v133, 1));
          location[3] = v35;
          v98 = (id)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", location, 4));

          v131 = 16975621;
          v130 = 0x501062B08060A30;
          v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &v130, 12));
          v128[0] = kSecCertificateKeyUsage;
          v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", 7));
          v129[0] = v37;
          v128[1] = kSecSubjectAltName;
          v126 = kSecSubjectAltNameDNSName;
          v127 = &off_1001C4AB0;
          v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v127, &v126, 1));
          v129[1] = v38;
          v128[2] = kSecCertificateExtensionsEncoded;
          v124 = CFSTR("2.5.29.37");
          v125 = v36;
          v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v125, &v124, 1));
          v129[2] = v39;
          v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v129, v128, 3));

          SelfSignedCertificate = (const void *)SecGenerateSelfSignedCertificate(v98, v40, v100, RandomKey);
          if (SelfSignedCertificate)
          {
            v42 = (__SecIdentity *)SecIdentityCreate(0, SelfSignedCertificate, RandomKey);
            if (v42)
            {
              v43 = sec_identity_create_with_certificates(v42, (CFArrayRef)+[NSArray arrayWithObject:](NSArray, "arrayWithObject:", SelfSignedCertificate));
              CFRelease(v42);
              CFRelease(SelfSignedCertificate);
LABEL_70:

LABEL_71:
LABEL_72:
              v45 = (void *)v106[14];
              v44 = (sec_identity_t *)(v106 + 14);
              v106[14] = v43;

              if (*v44)
              {
                v46 = sec_identity_copy_certificates_ref(*v44);
                Count = CFArrayGetCount(v46);
                v48 = Count - 1;
                if (Count >= 1)
                {
                  v49 = 0;
                  do
                  {
                    ValueAtIndex = (__SecCertificate *)CFArrayGetValueAtIndex(v46, v49);
                    v51 = SecCertificateCopyKey(ValueAtIndex);
                    v52 = SecKeyCopySubjectPublicKeyInfo();
                    v53 = (void *)v106[13];
                    v106[13] = v52;

                    if (v51)
                      CFRelease(v51);
                    if (v106[13])
                      break;
                  }
                  while (v48 != v49++);
                }
                if (v46)
                  CFRelease(v46);
              }
              if (v100)
                CFRelease(v100);
              if (RandomKey)
                CFRelease(RandomKey);
              if (qword_1001E4738 != -1)
                dispatch_once(&qword_1001E4738, &stru_1001B7110);
              if (!_NRLogIsLevelEnabled(qword_1001E4730, 2))
                goto LABEL_91;
              v19 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
              v18 = v106;
              if (qword_1001E4738 != -1)
                goto LABEL_123;
              while (1)
              {
                v55 = v19;
                opt_inst_meths = v19[25].opt_inst_meths;
                v57 = (void *)v18[13];
                v13 = v55;
                v58 = v57;
                v59 = opt_inst_meths;
                LogString = (void *)_NRKeyCreateLogString(v58);
                _NRLogWithArgs(v59, 2, "%s%.30s:%-4d Generated MASQUE spki: %@", "", "-[NRLinkDirector generateMASQUEProxyServerKeysIfNeeded]", 2014, LogString);

LABEL_91:
                if (qword_1001E4738 != -1)
                  dispatch_once(&qword_1001E4738, &stru_1001B7110);
                if (_NRLogIsLevelEnabled(v13[25].opt_inst_meths, 2))
                {
                  if (qword_1001E4738 != -1)
                    dispatch_once(&qword_1001E4738, &stru_1001B7110);
                  v61 = v106[14];
                  v62 = v13[25].opt_inst_meths;
                  _NRLogWithArgs(v62, 2, "%s%.30s:%-4d Generated MASQUE TLS identity: %@", "", "-[NRLinkDirector generateMASQUEProxyServerKeysIfNeeded]", 2015, v61);

                }
                v26 = v106;
LABEL_98:
                sec_protocol_options_set_local_identity(v104, (sec_identity_t)v26[14]);
                v63 = v106;
                RandomKey = (__SecKey *)(id)v106[13];
                v64 = -[__SecKey bytes](RandomKey, "bytes");
                v65 = objc_msgSend((id)v63[13], "length");
                sec_protocol_options_add_server_raw_public_key_certificate(v104, v64, v65);
                v66 = (id)v106[15];
                v67 = nw_masque_server_create(v105, v104, v66);
                v69 = (void *)v106[17];
                v68 = (void **)(v106 + 17);
                v106[17] = v67;

                v70 = *v68;
                if (*v68)
                  break;
                if (qword_1001E4738 != -1)
                  dispatch_once(&qword_1001E4738, &stru_1001B7110);
                if (_NRLogIsLevelEnabled(v13[25].opt_inst_meths, 16))
                {
                  v71 = sub_1000A2640();
                  _NRLogWithArgs(v71, 16, "%s%.30s:%-4d Failed to create MASQUE server", "", "-[NRLinkDirector startMASQUEProxyServerIfNeeded]", 2089);

                }
                v70 = (void *)v106[17];
                if (v70)
                  break;
                v92 = sub_1000A2640();
                v93 = _NRLogIsLevelEnabled(v92, 16);

                if (v93)
                {
                  v94 = sub_1000A2640();
                  _NRLogWithArgs(v94, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (self.masqueServer) != ((void *)0)", "", "-[NRLinkDirector startMASQUEProxyServerIfNeeded]", 2090);

                }
                v18 = (_QWORD *)_os_log_pack_size(12);
                v19 = (__objc2_prot *)((char *)&v98 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0));
                v95 = __error();
                v96 = _os_log_pack_fill(v19, v18, *v95, &_mh_execute_header, "%{public}s Assertion Failed: (self.masqueServer) != ((void *)0)");
                *(_DWORD *)v96 = 136446210;
                *(_QWORD *)(v96 + 4) = "-[NRLinkDirector startMASQUEProxyServerIfNeeded]";
                v97 = sub_1000A2640();
                _NRLogAbortWithPack(v97, v19);
LABEL_122:
                __break(1u);
LABEL_123:
                dispatch_once(&qword_1001E4738, &stru_1001B7110);
              }
              objc_initWeak(location, v70);
              objc_initWeak(v129, v106);
              v72 = (id)v106[17];
              v114[0] = _NSConcreteStackBlock;
              v114[1] = 3221225472;
              v114[2] = sub_1000AC5C4;
              v114[3] = &unk_1001B6F40;
              objc_copyWeak(&v115, v129);
              objc_copyWeak(&v116, location);
              nw_masque_server_set_state_changed_handler(v72, v114);

              v73 = (id)v106[17];
              v111[0] = _NSConcreteStackBlock;
              v111[1] = 3221225472;
              v111[2] = sub_1000AC8AC;
              v111[3] = &unk_1001B6FB8;
              objc_copyWeak(&v112, v129);
              objc_copyWeak(&v113, location);
              nw_masque_server_set_outer_connection_handler(v73, v111);

              v74 = (id)v106[17];
              v108[0] = _NSConcreteStackBlock;
              v108[1] = 3221225472;
              v108[2] = sub_1000AC9E0;
              v108[3] = &unk_1001B6FE0;
              objc_copyWeak(&v109, v129);
              objc_copyWeak(&v110, location);
              nw_masque_server_set_proxy_client_connection_event_handler(v74, v108);

              v75 = (id)v106[17];
              nw_masque_server_start();

              objc_destroyWeak(&v110);
              objc_destroyWeak(&v109);
              objc_destroyWeak(&v113);
              objc_destroyWeak(&v112);
              objc_destroyWeak(&v116);
              objc_destroyWeak(&v115);
              objc_destroyWeak(v129);
              objc_destroyWeak(location);

              goto LABEL_105;
            }
            if (qword_1001E4738 != -1)
              dispatch_once(&qword_1001E4738, &stru_1001B7110);
            if (_NRLogIsLevelEnabled(qword_1001E4730, 16))
            {
              if (qword_1001E4738 != -1)
                dispatch_once(&qword_1001E4738, &stru_1001B7110);
              _NRLogWithArgs(qword_1001E4730, 16, "%s%.30s:%-4d SecIdentityCreate() failed", "", "-[NRLinkDirector copyServerIdentity:publicKey:]", 1968);
            }
            CFRelease(SelfSignedCertificate);
          }
          else
          {
            if (qword_1001E4738 != -1)
              dispatch_once(&qword_1001E4738, &stru_1001B7110);
            if (_NRLogIsLevelEnabled(qword_1001E4730, 16))
            {
              if (qword_1001E4738 != -1)
                dispatch_once(&qword_1001E4738, &stru_1001B7110);
              _NRLogWithArgs(qword_1001E4730, 16, "%s%.30s:%-4d SecGenerateSelfSignedCertificate() failed", "", "-[NRLinkDirector copyServerIdentity:publicKey:]", 1962);
            }
          }
          v43 = 0;
          goto LABEL_70;
        }
        v90 = sub_1000A2640();
        v91 = _NRLogIsLevelEnabled(v90, 17);

        if (v91)
        {
          v98 = sub_1000A2640();
          _NRLogWithArgs(v98, 17, "%s called with null publicKey", "-[NRLinkDirector copyServerIdentity:publicKey:]");
          goto LABEL_117;
        }
      }
      else
      {
        v88 = sub_1000A2640();
        v89 = _NRLogIsLevelEnabled(v88, 17);

        if (v89)
        {
          v98 = sub_1000A2640();
          _NRLogWithArgs(v98, 17, "%s called with null privateKey", "-[NRLinkDirector copyServerIdentity:publicKey:]");
LABEL_117:
          v43 = 0;
          goto LABEL_71;
        }
      }
      v43 = 0;
      goto LABEL_72;
    }
    if (qword_1001E4738 != -1)
      dispatch_once(&qword_1001E4738, &stru_1001B7110);
    if (_NRLogIsLevelEnabled(qword_1001E4730, 1))
    {
      if (qword_1001E4738 != -1)
        dispatch_once(&qword_1001E4738, &stru_1001B7110);
      _NRLogWithArgs(qword_1001E4730, 1, "%s%.30s:%-4d MASQUEProxyServer feature disabled", "", "-[NRLinkDirector startMASQUEProxyServerIfNeeded]", 2032);
    }
  }
}

void sub_1000A9A54(_Unwind_Exception *a1)
{
  uint64_t v1;
  id *v2;
  id *v3;
  id *v4;
  id *v5;
  id *v6;
  id *v7;
  uint64_t v8;

  objc_destroyWeak(v3);
  objc_destroyWeak(v5);
  objc_destroyWeak(v7);
  objc_destroyWeak(v6);
  objc_destroyWeak(v2);
  objc_destroyWeak(v4);
  objc_destroyWeak((id *)(v1 + 504));
  objc_destroyWeak((id *)(v8 - 144));
  _Unwind_Resume(a1);
}

void sub_1000A9ABC()
{
  __CFString *v0;
  __CFString *v1;
  __objc2_prot *v2;
  __objc2_prot *v3;
  id v4;
  void *v5;
  NSObject *v6;
  id v7;
  id v8;
  char *v9;
  void *v10;
  __CFString *v11;
  uint64_t v12;
  __CFString *v13;
  __CFString *v14;
  void *v15;
  id v16;
  id v17;
  void *v18;
  id v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  id v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  id v27;
  int IsLevelEnabled;
  id v29;
  uint64_t v30;
  uint64_t v31;
  id v32;
  int v33;
  id v34;
  uint64_t v35;
  id v36;
  uint64_t v37;
  id v38;
  __int128 v39;

  v4 = objc_alloc_init((Class)NSMutableDictionary);
  if (!v4)
  {
    v27 = sub_1000A2640();
    IsLevelEnabled = _NRLogIsLevelEnabled(v27, 16);

    if (IsLevelEnabled)
    {
      v29 = sub_1000A2640();
      _NRLogWithArgs(v29, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (entryDict) != ((void *)0)", "", "-[NRLinkDirector addTerminusPrefixDropPolicy]", 1663);

    }
    v5 = (void *)_os_log_pack_size(12);
    v9 = (char *)&v37 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
    v30 = *__error();
    v31 = _os_log_pack_fill(v9, v5, v30, &_mh_execute_header, "%{public}s Assertion Failed: (entryDict) != ((void *)0)");
    goto LABEL_69;
  }
  v5 = v4;
  objc_opt_self(NRDLocalDevice);
  v6 = sub_10014CFBC();
  dispatch_assert_queue_V2(v6);

  v39 = xmmword_10015D090;
  v7 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &v39, 16);
  v8 = sub_100133E24((uint64_t)NRDLocalDevice, v7, CFSTR("0"));
  v9 = (char *)objc_claimAutoreleasedReturnValue(v8);

  objc_msgSend(v5, "setObject:forKeyedSubscript:", CFSTR("PrivilegedTunnel"), CFSTR("Level"));
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "hostname"));
  objc_msgSend(v5, "setObject:forKeyedSubscript:", v10, CFSTR("Address"));

  objc_msgSend(v5, "setObject:forKeyedSubscript:", &off_1001C4738, CFSTR("Prefix"));
  v1 = CFSTR("/var/mobile/Library/terminus/com.apple.necp_drop_dest.plist");
  v11 = (__CFString *)objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithContentsOfFile:", CFSTR("/var/mobile/Library/terminus/com.apple.necp_drop_dest.plist"));
  v3 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
  if (v11)
  {
    v0 = v11;
    v12 = objc_opt_class(NSMutableArray);
    if ((objc_opt_isKindOfClass(v0, v12) & 1) != 0)
      goto LABEL_12;
    if (qword_1001E4738 != -1)
      dispatch_once(&qword_1001E4738, &stru_1001B7110);
    v2 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
    if (_NRLogIsLevelEnabled(qword_1001E4730, 17))
    {
      if (qword_1001E4738 != -1)
        dispatch_once(&qword_1001E4738, &stru_1001B7110);
      _NRLogWithArgs(qword_1001E4730, 17, "bad file format: %@", CFSTR("/var/mobile/Library/terminus/com.apple.necp_drop_dest.plist"));
    }

  }
  v0 = (__CFString *)objc_alloc_init((Class)NSMutableArray);
  if (!v0)
  {
    v32 = sub_1000A2640();
    v33 = _NRLogIsLevelEnabled(v32, 16);

    if (v33)
    {
      v34 = sub_1000A2640();
      _NRLogWithArgs(v34, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (entryArray) != ((void *)0)", "", "-[NRLinkDirector addTerminusPrefixDropPolicy]", 1680);

    }
    v5 = (void *)_os_log_pack_size(12);
    v9 = (char *)&v37 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
    v35 = *__error();
    v31 = _os_log_pack_fill(v9, v5, v35, &_mh_execute_header, "%{public}s Assertion Failed: (entryArray) != ((void *)0)");
LABEL_69:
    *(_DWORD *)v31 = 136446210;
    *(_QWORD *)(v31 + 4) = "-[NRLinkDirector addTerminusPrefixDropPolicy]";
    v36 = sub_1000A2640();
    _NRLogAbortWithPack(v36, v9);
    goto LABEL_70;
  }
LABEL_12:
  v13 = (__CFString *)sub_1000AA8AC((uint64_t)NRLinkDirector, v0);
  v1 = v13;
  if (v13)
  {
    v14 = v13;

    v0 = v14;
    if ((-[__CFString containsObject:](v14, "containsObject:", v5) & 1) != 0)
      goto LABEL_17;
  }
  else if ((-[__CFString containsObject:](v0, "containsObject:", v5) & 1) != 0)
  {
    goto LABEL_32;
  }
  -[__CFString addObject:](v0, "addObject:", v5);
LABEL_17:
  v38 = 0;
  v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSPropertyListSerialization dataWithPropertyList:format:options:error:](NSPropertyListSerialization, "dataWithPropertyList:format:options:error:", v0, 200, 0, &v38));
  v16 = v38;
  if (v16)
  {
    if (qword_1001E4738 != -1)
      dispatch_once(&qword_1001E4738, &stru_1001B7110);
    if (_NRLogIsLevelEnabled(qword_1001E4730, 17))
    {
      if (qword_1001E4738 != -1)
        dispatch_once(&qword_1001E4738, &stru_1001B7110);
      v17 = (id)qword_1001E4730;
      v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "localizedDescription"));
      _NRLogWithArgs(v17, 17, "[NSPropertyListSerialization dataWithPropertyList: %@ format: options: error: %@]", v0, v18);

    }
  }
  else if ((sub_100107290(CFSTR("/var/mobile/Library/terminus/com.apple.necp_drop_dest.plist"), v15, 1) & 1) == 0)
  {
    if (qword_1001E4738 != -1)
      dispatch_once(&qword_1001E4738, &stru_1001B7110);
    if (_NRLogIsLevelEnabled(qword_1001E4730, 16))
    {
      if (qword_1001E4738 != -1)
        dispatch_once(&qword_1001E4738, &stru_1001B7110);
      _NRLogWithArgs(qword_1001E4730, 16, "%s%.30s:%-4d failed to write file %@\n", "", "-[NRLinkDirector addTerminusPrefixDropPolicy]", 1705, CFSTR("/var/mobile/Library/terminus/com.apple.necp_drop_dest.plist"));
    }
  }

LABEL_32:
  objc_opt_self(NRDKeyManager);
  if (qword_1001E4AD8 != -1)
    dispatch_once(&qword_1001E4AD8, &stru_1001B8968);
  v19 = (id)qword_1001E4AD0;
  sub_10014ACE0((uint64_t)v19, &stru_1001B6F18);

  v20 = ne_session_add_necp_drop_dest_from_path(objc_msgSend(CFSTR("/var/mobile/Library/terminus/com.apple.necp_drop_dest.plist"), "UTF8String"));
  if ((_DWORD)v20)
  {
    v2 = (__objc2_prot *)v20;
    if (qword_1001E4738 == -1)
    {
LABEL_36:
      if (_NRLogIsLevelEnabled(qword_1001E4730, 17))
      {
        if (v3[25].opt_class_meths != (__objc2_meth_list *)-1)
          dispatch_once(&qword_1001E4738, &stru_1001B7110);
        _NRLogWithArgs(qword_1001E4730, 17, "ne_session_add_necp_drop_dest_from_path failed %d\n", (_DWORD)v2);
      }
      v21 = _CFXPCCreateXPCObjectFromCFObject(v0);
      v22 = (void *)v21;
      if (!v21 || (v2 = (__objc2_prot *)ne_session_add_necp_drop_dest_from_dest_list(v21), (_DWORD)v2))
      {
        if (v3[25].opt_class_meths != (__objc2_meth_list *)-1)
          dispatch_once(&qword_1001E4738, &stru_1001B7110);
        if (_NRLogIsLevelEnabled(qword_1001E4730, 17))
        {
          if (v3[25].opt_class_meths != (__objc2_meth_list *)-1)
            dispatch_once(&qword_1001E4738, &stru_1001B7110);
          _NRLogWithArgs(qword_1001E4730, 17, "ne_session_add_necp_drop_dest_from_dest_list failed %d\n", (_DWORD)v2);
        }
        v23 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("ne_session_add_necp_drop_dest_* failed with error %d"), v2);
        sub_100109270(CFSTR("addTerminusPrefixDropPolicy"), v23, 0, 0, 0, v24, v25, v26, v37);

      }
      else
      {
        if (v3[25].opt_class_meths != (__objc2_meth_list *)-1)
          dispatch_once(&qword_1001E4738, &stru_1001B7110);
        if (_NRLogIsLevelEnabled(qword_1001E4730, 0))
        {
          if (v3[25].opt_class_meths != (__objc2_meth_list *)-1)
            dispatch_once(&qword_1001E4738, &stru_1001B7110);
          _NRLogWithArgs(qword_1001E4730, 0, "%s%.30s:%-4d ne_session_add_necp_drop_dest_from_dest_list: success", "", "-[NRLinkDirector addTerminusPrefixDropPolicy]", 1725);
        }
      }

      goto LABEL_62;
    }
LABEL_70:
    dispatch_once(&qword_1001E4738, &stru_1001B7110);
    goto LABEL_36;
  }
  if (qword_1001E4738 != -1)
    dispatch_once(&qword_1001E4738, &stru_1001B7110);
  if (_NRLogIsLevelEnabled(qword_1001E4730, 0))
  {
    if (qword_1001E4738 != -1)
      dispatch_once(&qword_1001E4738, &stru_1001B7110);
    _NRLogWithArgs(qword_1001E4730, 0, "%s%.30s:%-4d ne_session_add_necp_drop_dest_from_path: success", "", "-[NRLinkDirector addTerminusPrefixDropPolicy]", 1734);
  }
LABEL_62:

}

void sub_1000AA324()
{
  char *v0;
  __CFString *v1;
  _UNKNOWN **v2;
  __objc2_prot *v3;
  __objc2_prot *v4;
  id v5;
  void *v6;
  NSObject *v7;
  id v8;
  id v9;
  char *v10;
  void *v11;
  char *v12;
  uint64_t v13;
  __CFString *v14;
  char *v15;
  id v16;
  void *v17;
  id v18;
  int IsLevelEnabled;
  id v20;
  int *v21;
  uint64_t v22;
  id v23;
  int v24;
  id v25;
  int *v26;
  uint64_t v27;
  id v28;
  uint64_t v29;
  id v30;
  __int128 v31;

  v5 = objc_alloc_init((Class)NSMutableDictionary);
  if (!v5)
  {
    v18 = sub_1000A2640();
    IsLevelEnabled = _NRLogIsLevelEnabled(v18, 16);

    if (IsLevelEnabled)
    {
      v20 = sub_1000A2640();
      _NRLogWithArgs(v20, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (entryDict) != ((void *)0)", "", "-[NRLinkDirector removeTerminusPrefixDropPolicy]", 1741);

    }
    v6 = (void *)_os_log_pack_size(12);
    v10 = (char *)&v29 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
    v21 = __error();
    v22 = _os_log_pack_fill(v10, v6, *v21, &_mh_execute_header, "%{public}s Assertion Failed: (entryDict) != ((void *)0)");
    *(_DWORD *)v22 = 136446210;
    *(_QWORD *)(v22 + 4) = "-[NRLinkDirector removeTerminusPrefixDropPolicy]";
    goto LABEL_38;
  }
  v6 = v5;
  objc_opt_self(NRDLocalDevice);
  v7 = sub_10014CFBC();
  dispatch_assert_queue_V2(v7);

  v31 = xmmword_10015D090;
  v8 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", &v31, 16);
  v9 = sub_100133E24((uint64_t)NRDLocalDevice, v8, CFSTR("0"));
  v10 = (char *)objc_claimAutoreleasedReturnValue(v9);

  objc_msgSend(v6, "setObject:forKeyedSubscript:", CFSTR("PrivilegedTunnel"), CFSTR("Level"));
  v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "hostname"));
  objc_msgSend(v6, "setObject:forKeyedSubscript:", v11, CFSTR("Address"));

  objc_msgSend(v6, "setObject:forKeyedSubscript:", &off_1001C4738, CFSTR("Prefix"));
  v2 = &APSConnectionOverrideNamedDelegatePort_ptr;
  v1 = CFSTR("/var/mobile/Library/terminus/com.apple.necp_drop_dest.plist");
  v12 = (char *)objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithContentsOfFile:", CFSTR("/var/mobile/Library/terminus/com.apple.necp_drop_dest.plist"));
  if (v12)
  {
    v0 = v12;
    v13 = objc_opt_class(NSMutableArray);
    if ((objc_opt_isKindOfClass(v0, v13) & 1) != 0)
      goto LABEL_12;
    v3 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
    if (qword_1001E4738 != -1)
      dispatch_once(&qword_1001E4738, &stru_1001B7110);
    v4 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
    if (_NRLogIsLevelEnabled(qword_1001E4730, 17))
    {
      if (qword_1001E4738 != -1)
        dispatch_once(&qword_1001E4738, &stru_1001B7110);
      _NRLogWithArgs(qword_1001E4730, 17, "bad file format: %@", CFSTR("/var/mobile/Library/terminus/com.apple.necp_drop_dest.plist"));
    }

  }
  v0 = (char *)objc_alloc_init((Class)NSMutableArray);
  if (!v0)
  {
    v23 = sub_1000A2640();
    v24 = _NRLogIsLevelEnabled(v23, 16);

    v0 = "-[NRLinkDirector removeTerminusPrefixDropPolicy]";
    if (v24)
    {
      v25 = sub_1000A2640();
      _NRLogWithArgs(v25, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (entryArray) != ((void *)0)", "", "-[NRLinkDirector removeTerminusPrefixDropPolicy]", 1758);

    }
    v6 = (void *)_os_log_pack_size(12);
    v10 = (char *)&v29 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
    v26 = __error();
    v27 = _os_log_pack_fill(v10, v6, *v26, &_mh_execute_header, "%{public}s Assertion Failed: (entryArray) != ((void *)0)");
    *(_DWORD *)v27 = 136446210;
    *(_QWORD *)(v27 + 4) = "-[NRLinkDirector removeTerminusPrefixDropPolicy]";
LABEL_38:
    v28 = sub_1000A2640();
    _NRLogAbortWithPack(v28, v10);
    goto LABEL_39;
  }
LABEL_12:
  v14 = (__CFString *)sub_1000AA8AC((uint64_t)NRLinkDirector, v0);
  v1 = v14;
  if (v14)
  {
    v15 = v14;

    v0 = v15;
    if ((objc_msgSend(v15, "containsObject:", v6) & 1) == 0)
    {
LABEL_17:
      v30 = 0;
      v2 = (_UNKNOWN **)objc_claimAutoreleasedReturnValue(+[NSPropertyListSerialization dataWithPropertyList:format:options:error:](NSPropertyListSerialization, "dataWithPropertyList:format:options:error:", v0, 200, 0, &v30));
      v3 = (__objc2_prot *)v30;
      if (!v3)
      {
        if ((sub_100107290(CFSTR("/var/mobile/Library/terminus/com.apple.necp_drop_dest.plist"), v2, 1) & 1) == 0)
        {
          if (qword_1001E4738 != -1)
            dispatch_once(&qword_1001E4738, &stru_1001B7110);
          if (_NRLogIsLevelEnabled(qword_1001E4730, 17))
          {
            if (qword_1001E4738 != -1)
              dispatch_once(&qword_1001E4738, &stru_1001B7110);
            _NRLogWithArgs(qword_1001E4730, 17, "failed to write file %@\n", CFSTR("/var/mobile/Library/terminus/com.apple.necp_drop_dest.plist"));
          }
        }
        goto LABEL_30;
      }
      v4 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
      if (qword_1001E4738 == -1)
      {
LABEL_19:
        if (_NRLogIsLevelEnabled(qword_1001E4730, 17))
        {
          if (v4[25].opt_class_meths != (__objc2_meth_list *)-1)
            dispatch_once(&qword_1001E4738, &stru_1001B7110);
          v16 = (id)qword_1001E4730;
          v17 = (void *)objc_claimAutoreleasedReturnValue(-[__objc2_prot localizedDescription](v3, "localizedDescription"));
          _NRLogWithArgs(v16, 17, "[NSPropertyListSerialization dataWithPropertyList: %@ format: options: error: %@] failed", v0, v17);

        }
LABEL_30:

        goto LABEL_31;
      }
LABEL_39:
      dispatch_once(&qword_1001E4738, &stru_1001B7110);
      goto LABEL_19;
    }
LABEL_16:
    objc_msgSend(v0, "removeObject:", v6);
    goto LABEL_17;
  }
  if (objc_msgSend(v0, "containsObject:", v6))
    goto LABEL_16;
LABEL_31:

}

id sub_1000AA8AC(uint64_t a1, void *a2)
{
  id v3;
  id v4;
  id v5;
  id v6;
  id v7;
  char v8;
  _UNKNOWN **v9;
  const __CFString *v10;
  uint64_t v11;
  void *v12;
  uint64_t StringForLegacyNECPLevel;
  uint64_t v14;
  _UNKNOWN **v15;
  id v16;
  void *v17;
  const __CFString *v18;
  void *v19;
  id v20;
  void *v21;
  uint64_t v22;
  id v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  id v28;
  id v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  _BYTE v35[128];

  v3 = a2;
  objc_opt_self(a1);
  v4 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", objc_msgSend(v3, "count"));
  v31 = 0u;
  v32 = 0u;
  v33 = 0u;
  v34 = 0u;
  v5 = v3;
  v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v31, v35, 16);
  if (!v6)
  {

    v27 = 0;
    goto LABEL_24;
  }
  v7 = v6;
  v8 = 0;
  v9 = &APSConnectionOverrideNamedDelegatePort_ptr;
  v10 = CFSTR("Level");
  v11 = *(_QWORD *)v32;
  while (2)
  {
    v12 = 0;
    v30 = v7;
    do
    {
      if (*(_QWORD *)v32 != v11)
        objc_enumerationMutation(v5);
      v21 = *(void **)(*((_QWORD *)&v31 + 1) + 8 * (_QWORD)v12);
      v22 = objc_opt_class(v9[141]);
      if ((objc_opt_isKindOfClass(v21, v22) & 1) != 0)
      {
        v23 = v21;
        v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v23, "objectForKeyedSubscript:", v10));
        v25 = objc_opt_class(NSNumber);
        if ((objc_opt_isKindOfClass(v24, v25) & 1) != 0)
        {
          StringForLegacyNECPLevel = NEPolicyGetStringForLegacyNECPLevel(objc_msgSend(v24, "unsignedIntValue"));
          v14 = v11;
          v15 = v9;
          v16 = v5;
          v17 = v4;
          v18 = v10;
          v19 = (void *)objc_claimAutoreleasedReturnValue(StringForLegacyNECPLevel);
          v20 = objc_msgSend(v23, "mutableCopy");
          objc_msgSend(v20, "setObject:forKeyedSubscript:", v19, v18);
          objc_msgSend(v17, "addObject:", v20);

          v10 = v18;
          v4 = v17;
          v5 = v16;
          v9 = v15;
          v11 = v14;
          v7 = v30;
          v8 = 1;
        }
        else
        {
          objc_msgSend(v4, "addObject:", v23);
        }

LABEL_7:
        goto LABEL_8;
      }
      if (qword_1001E4738 != -1)
        dispatch_once(&qword_1001E4738, &stru_1001B7110);
      if (_NRLogIsLevelEnabled(qword_1001E4730, 16))
      {
        if (qword_1001E4738 != -1)
          dispatch_once(&qword_1001E4738, &stru_1001B7110);
        v23 = (id)qword_1001E4730;
        v26 = objc_opt_class(v21);
        _NRLogWithArgs(v23, 16, "%s%.30s:%-4d Array entry is %@, not NSDictionary", "", "+[NRLinkDirector convertDropDestArray:]", 1653, v26);
        goto LABEL_7;
      }
LABEL_8:
      v12 = (char *)v12 + 1;
    }
    while (v7 != v12);
    v7 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v31, v35, 16);
    if (v7)
      continue;
    break;
  }

  if ((v8 & 1) != 0)
    v27 = v4;
  else
    v27 = 0;
LABEL_24:
  v28 = v27;

  return v28;
}

void sub_1000AABA0(uint64_t a1)
{
  id WeakRetained;
  id v3;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained && *((_BYTE *)WeakRetained + 12) && *((_QWORD *)WeakRetained + 33) == *(_QWORD *)(a1 + 32))
  {
    v3 = WeakRetained;
    sub_1000AABF8(0);
    WeakRetained = v3;
  }

}

void sub_1000AABF8(void *a1)
{
  id v1;
  id v2;
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  __objc2_prot *v8;
  uint64_t v9;
  unsigned int *v10;
  unsigned int *v11;
  int v12;
  unsigned int v13;
  id v14;
  id v15;
  id v16;
  uint64_t v17;
  uint64_t v18;
  void *i;
  uint64_t v20;
  id v21;
  void *v22;
  id v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  unsigned int *v29;
  id v30;
  void *v31;
  id v32;
  id v33;
  id v34;
  id v35;
  uint64_t v36;
  void *j;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  id v41;
  int IsLevelEnabled;
  id v43;
  uint64_t v44;
  int *v45;
  uint64_t v46;
  id v47;
  uint64_t v48;
  id v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  _BYTE v58[128];
  _BYTE v59[128];
  char v60[128];
  _OWORD buffer[6];
  __int128 v62;
  __int128 v63;
  uint64_t v64;

  v1 = a1;
  if (qword_1001E4720 != -1)
    dispatch_once(&qword_1001E4720, &stru_1001B70F0);
  v64 = 0;
  v62 = 0u;
  v63 = 0u;
  memset(buffer, 0, sizeof(buffer));
  if (proc_pidinfo(dword_1001E3B60, 3, 0, buffer, 136) != 136)
  {
    v7 = *__error();
    if (strerror_r(v7, v60, 0x80uLL))
      v60[0] = 0;
    if (qword_1001E4738 != -1)
      dispatch_once(&qword_1001E4738, &stru_1001B7110);
    if (_NRLogIsLevelEnabled(qword_1001E4730, 16))
    {
      if (qword_1001E4738 != -1)
        dispatch_once(&qword_1001E4738, &stru_1001B7110);
      _NRLogWithArgs(qword_1001E4730, 16, "%s%.30s:%-4d failed to fetch bsd info: [%d] %s", "", "-[NRLinkDirector checkFDUsageAndFillInStatusDictionary:]", 2901, v7, v60);
    }
    goto LABEL_83;
  }
  if (!(_DWORD)v62)
  {
    if (qword_1001E4738 != -1)
      dispatch_once(&qword_1001E4738, &stru_1001B7110);
    v8 = &OBJC_PROTOCOL___CBScalablePipeManagerDelegate;
    if (!_NRLogIsLevelEnabled(qword_1001E4730, 2))
      goto LABEL_83;
    if (qword_1001E4738 == -1)
    {
LABEL_24:
      _NRLogWithArgs(v8[25].opt_inst_meths, 2, "%s%.30s:%-4d no open files", "", "-[NRLinkDirector checkFDUsageAndFillInStatusDictionary:]", 2906);
      goto LABEL_83;
    }
LABEL_87:
    dispatch_once(&qword_1001E4738, &stru_1001B7110);
    goto LABEL_24;
  }
  if (v62 >= 0x401)
  {
    v2 = objc_alloc((Class)NSString);
    v3 = objc_msgSend(v2, "initWithFormat:", CFSTR("unexpected number of open files %u"), v62);
    sub_100109270(CFSTR("fdUsageMonitor"), v3, 0, 0, 0, v4, v5, v6, v48);
    if (qword_1001E4738 != -1)
      dispatch_once(&qword_1001E4738, &stru_1001B7110);
    if (_NRLogIsLevelEnabled(qword_1001E4730, 17))
    {
      if (qword_1001E4738 != -1)
        dispatch_once(&qword_1001E4738, &stru_1001B7110);
      _NRLogWithArgs(qword_1001E4730, 17, "%@", v3);
    }
LABEL_82:

    goto LABEL_83;
  }
  v9 = 8 * v62;
  v10 = (unsigned int *)malloc_type_malloc(v9, 0xA172743EuLL);
  if (!v10)
  {
    v41 = sub_1000A2640();
    IsLevelEnabled = _NRLogIsLevelEnabled(v41, 16);

    if (IsLevelEnabled)
    {
      v43 = sub_1000A2640();
      _NRLogWithArgs(v43, 16, "%s%.30s:%-4d ABORTING: strict_malloc(%zu) failed", "", "strict_malloc", 79, v9);

    }
    v44 = _os_log_pack_size(22);
    v8 = (__objc2_prot *)((char *)&v48 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0));
    v45 = __error();
    v46 = _os_log_pack_fill(v8, v44, *v45, &_mh_execute_header, "%{public}s strict_malloc(%zu) failed");
    *(_DWORD *)v46 = 136446466;
    *(_QWORD *)(v46 + 4) = "strict_malloc";
    *(_WORD *)(v46 + 12) = 2048;
    *(_QWORD *)(v46 + 14) = v9;
    v47 = sub_1000A2640();
    _NRLogAbortWithPack(v47, v8);
    goto LABEL_87;
  }
  v11 = v10;
  v12 = proc_pidinfo(dword_1001E3B60, 1, 0, v10, v9);
  if (v12 >= 1)
  {
    v13 = v12;
    if ((v12 & 7) == 0)
    {
      v49 = v1;
      v14 = objc_alloc_init((Class)NSCountedSet);
      if (v13 >= 8)
      {
        v28 = v13 >> 3;
        v29 = v11 + 1;
        do
        {
          switch(*v29)
          {
            case 0u:
              objc_msgSend(v14, "addObject:", CFSTR("ATALK"));
              break;
            case 1u:
              objc_msgSend(v14, "addObject:", CFSTR("VNODE"));
              break;
            case 2u:
              objc_msgSend(v14, "addObject:", CFSTR("SOCKET"));
              break;
            case 3u:
              objc_msgSend(v14, "addObject:", CFSTR("PSHM"));
              break;
            case 4u:
              objc_msgSend(v14, "addObject:", CFSTR("PSEM"));
              break;
            case 5u:
              objc_msgSend(v14, "addObject:", CFSTR("KQUEUE"));
              break;
            case 6u:
              objc_msgSend(v14, "addObject:", CFSTR("PIPE"));
              break;
            case 7u:
              objc_msgSend(v14, "addObject:", CFSTR("FSEVENTS"));
              break;
            case 9u:
              objc_msgSend(v14, "addObject:", CFSTR("NETPOLICY"));
              break;
            case 0xAu:
              objc_msgSend(v14, "addObject:", CFSTR("CHANNEL"));
              break;
            case 0xBu:
              objc_msgSend(v14, "addObject:", CFSTR("NEXUS"));
              break;
            default:
              v30 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%u"), *v29);
              objc_msgSend(v14, "addObject:", v30);

              break;
          }
          v29 += 2;
          --v28;
        }
        while (v28);
      }
      free(v11);
      v56 = 0u;
      v57 = 0u;
      v54 = 0u;
      v55 = 0u;
      v3 = v14;
      v15 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v54, v59, 16);
      if (v15)
      {
        v16 = v15;
        LODWORD(v17) = 0;
        v18 = *(_QWORD *)v55;
        do
        {
          for (i = 0; i != v16; i = (char *)i + 1)
          {
            if (*(_QWORD *)v55 != v18)
              objc_enumerationMutation(v3);
            v20 = *(_QWORD *)(*((_QWORD *)&v54 + 1) + 8 * (_QWORD)i);
            v21 = objc_msgSend(v3, "countForObject:", v20);
            if (qword_1001E4738 != -1)
              dispatch_once(&qword_1001E4738, &stru_1001B7110);
            if (_NRLogIsLevelEnabled(qword_1001E4730, 2))
            {
              if (qword_1001E4738 != -1)
                dispatch_once(&qword_1001E4738, &stru_1001B7110);
              _NRLogWithArgs(qword_1001E4730, 2, "%s%.30s:%-4d fd usage summary - %@ : %u", "", "-[NRLinkDirector checkFDUsageAndFillInStatusDictionary:]", 2961, v20, v21);
            }
            if (v49)
            {
              v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v21));
              objc_msgSend(v49, "setObject:forKeyedSubscript:", v22, v20);

            }
            if (v21 >= 0x101)
            {
              v23 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("FD usage for type %@ exceeded threshold(%u)"), v20, 256);
              sub_100109270(CFSTR("fdUsageMonitor"), v23, 0, 0, 0, v24, v25, v26, v48);

            }
            v17 = (v17 + (_DWORD)v21);
          }
          v16 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v54, v59, 16);
        }
        while (v16);
      }
      else
      {
        v17 = 0;
      }

      v1 = v49;
      if (v49)
      {
        v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v17));
        objc_msgSend(v49, "setObject:forKeyedSubscript:", v31, CFSTR("Total"));

      }
      if (v17 >= 0x201)
      {
        v32 = objc_msgSend(objc_alloc((Class)NSMutableString), "initWithFormat:", CFSTR("Total FD usage exceeded threshold(%u)"), 512);
        v50 = 0u;
        v51 = 0u;
        v52 = 0u;
        v53 = 0u;
        v33 = v3;
        v34 = objc_msgSend(v33, "countByEnumeratingWithState:objects:count:", &v50, v58, 16);
        if (v34)
        {
          v35 = v34;
          v36 = *(_QWORD *)v51;
          do
          {
            for (j = 0; j != v35; j = (char *)j + 1)
            {
              if (*(_QWORD *)v51 != v36)
                objc_enumerationMutation(v33);
              objc_msgSend(v32, "appendFormat:", CFSTR(" %@:%u"), *(_QWORD *)(*((_QWORD *)&v50 + 1) + 8 * (_QWORD)j), objc_msgSend(v33, "countForObject:", *(_QWORD *)(*((_QWORD *)&v50 + 1) + 8 * (_QWORD)j)));
            }
            v35 = objc_msgSend(v33, "countByEnumeratingWithState:objects:count:", &v50, v58, 16);
          }
          while (v35);
        }

        sub_100109270(CFSTR("fdUsageMonitor"), v32, 0, 0, 0, v38, v39, v40, v48);
      }
      goto LABEL_82;
    }
  }
  v27 = *__error();
  if (strerror_r(v27, v60, 0x80uLL))
    v60[0] = 0;
  if (qword_1001E4738 != -1)
    dispatch_once(&qword_1001E4738, &stru_1001B7110);
  if (_NRLogIsLevelEnabled(qword_1001E4730, 16))
  {
    if (qword_1001E4738 != -1)
      dispatch_once(&qword_1001E4738, &stru_1001B7110);
    _NRLogWithArgs(qword_1001E4730, 16, "%s%.30s:%-4d failed to fetch fd info: [%d] %s", "", "-[NRLinkDirector checkFDUsageAndFillInStatusDictionary:]", 2922, v27, v60);
  }
  free(v11);
LABEL_83:

}

void sub_1000AB5CC(id a1)
{
  dword_1001E3B60 = getpid();
}

void sub_1000AB5E8(uint64_t a1, void *a2)
{
  id v3;
  _BYTE *WeakRetained;
  uint64_t v5;
  void *v6;
  void *v7;
  id v8;
  uint64_t *v9;
  id *v10;
  id v11;
  unsigned __int8 v12;
  id v13;
  int IsLevelEnabled;
  id v15;
  id v16;
  NSObject *v17;
  uint32_t v18;
  id v19;
  int v20;
  id v21;
  id v22;
  int v23;
  id v24;
  int v25;
  void *v26;
  int v27;
  int v28;
  id v29;
  int v30;
  id v31;
  _QWORD applier[6];
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  char v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t (*v40)(uint64_t, uint64_t);
  void (*v41)(uint64_t);
  id v42;
  _QWORD handler[4];
  id v44;
  id location;
  int out_token[3];

  v3 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v5 = (uint64_t)WeakRetained;
  if (WeakRetained && WeakRetained[12] && *((_QWORD *)WeakRetained + 36) == *(_QWORD *)(a1 + 32))
  {
    v37 = 0;
    v38 = &v37;
    v39 = 0x3032000000;
    v40 = sub_1000ABBD8;
    v41 = sub_1000ABBE8;
    v42 = 0;
    v33 = 0;
    v34 = &v33;
    v35 = 0x2020000000;
    v36 = 0;
    v6 = (void *)nw_path_copy_netagent_dictionary(v3);
    v7 = v6;
    if (v6)
    {
      applier[0] = _NSConcreteStackBlock;
      applier[1] = 3221225472;
      applier[2] = sub_1000ABBF0;
      applier[3] = &unk_1001B7030;
      applier[4] = &v37;
      applier[5] = &v33;
      xpc_dictionary_apply(v6, applier);
    }
    v8 = *(id *)(v5 + 296);
    v9 = v38;
    if (v8 || v38[5])
    {
      v10 = (id *)(v5 + 296);
      v11 = *(id *)(v5 + 296);
      v12 = objc_msgSend(v11, "isEqual:", v9[5]);

      if ((v12 & 1) == 0)
      {
        objc_storeStrong((id *)(v5 + 296), (id)v38[5]);
        if (*v10)
        {
          if (qword_1001E4738 != -1)
            dispatch_once(&qword_1001E4738, &stru_1001B7110);
          v13 = (id)qword_1001E4730;
          IsLevelEnabled = _NRLogIsLevelEnabled(v13, 1);

          if (IsLevelEnabled)
          {
            if (qword_1001E4738 != -1)
              dispatch_once(&qword_1001E4738, &stru_1001B7110);
            v15 = (id)qword_1001E4730;
            v16 = *v10;
            _NRLogWithArgs(v15, 1, "%s%.30s:%-4d detected AppVPN agent %@", "", "-[NRLinkDirector setupAppVPNWatcher]_block_invoke", 2344, v16);

          }
          if (*v10 && *(_DWORD *)(v5 + 28) == -1)
          {
            out_token[0] = -1;
            objc_initWeak(&location, (id)v5);
            v17 = *(id *)(v5 + 120);
            handler[0] = _NSConcreteStackBlock;
            handler[1] = 3221225472;
            handler[2] = sub_1000ABCC8;
            handler[3] = &unk_1001B8990;
            objc_copyWeak(&v44, &location);
            v18 = notify_register_dispatch("com.apple.neconfigurationchanged", out_token, v17, handler);

            if (v18)
            {
              if (qword_1001E4738 != -1)
                dispatch_once(&qword_1001E4738, &stru_1001B7110);
              v19 = (id)qword_1001E4730;
              v20 = _NRLogIsLevelEnabled(v19, 17);

              if (v20)
              {
                if (qword_1001E4738 != -1)
                  dispatch_once(&qword_1001E4738, &stru_1001B7110);
                v21 = (id)qword_1001E4730;
                _NRLogWithArgs(v21, 17, "notify_register_dispatch(%s, %d) failed: %u", "com.apple.neconfigurationchanged", out_token[0], v18);

              }
            }
            else
            {
              v27 = out_token[0];
              *(_DWORD *)(v5 + 28) = out_token[0];
              sub_1000ABD1C((id)v5, v27);
            }
            objc_destroyWeak(&v44);
            objc_destroyWeak(&location);
          }
          sub_1000A26B0(v5);
        }
        else
        {
          if (qword_1001E4738 != -1)
            dispatch_once(&qword_1001E4738, &stru_1001B7110);
          v22 = (id)qword_1001E4730;
          v23 = _NRLogIsLevelEnabled(v22, 1);

          if (v23)
          {
            if (qword_1001E4738 != -1)
              dispatch_once(&qword_1001E4738, &stru_1001B7110);
            v24 = (id)qword_1001E4730;
            _NRLogWithArgs(v24, 1, "%s%.30s:%-4d no AppVPN agent found", "", "-[NRLinkDirector setupAppVPNWatcher]_block_invoke", 2348);

          }
          v25 = *(_DWORD *)(v5 + 28);
          if (v25 != -1)
          {
            notify_cancel(v25);
            *(_DWORD *)(v5 + 28) = -1;
          }
          v26 = *(void **)(v5 + 304);
          *(_QWORD *)(v5 + 304) = 0;

          sub_1000A2E80(v5);
        }
      }
    }
    v28 = *((unsigned __int8 *)v34 + 24);
    if (v28 != *(unsigned __int8 *)(v5 + 18))
    {
      *(_BYTE *)(v5 + 18) = v28;
      if (qword_1001E4738 != -1)
        dispatch_once(&qword_1001E4738, &stru_1001B7110);
      v29 = (id)qword_1001E4730;
      v30 = _NRLogIsLevelEnabled(v29, 1);

      if (v30)
      {
        if (qword_1001E4738 != -1)
          dispatch_once(&qword_1001E4738, &stru_1001B7110);
        v31 = (id)qword_1001E4730;
        _NRLogWithArgs(v31, 1, "%s%.30s:%-4d detected AppVPN active %d", "", "-[NRLinkDirector setupAppVPNWatcher]_block_invoke", 2356, *(unsigned __int8 *)(v5 + 18));

      }
    }

    _Block_object_dispose(&v33, 8);
    _Block_object_dispose(&v37, 8);

  }
}

void sub_1000ABB28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  id *v23;
  uint64_t v24;

  objc_destroyWeak(v23);
  objc_destroyWeak((id *)(v24 - 104));
  _Block_object_dispose(&a19, 8);
  _Block_object_dispose(&a23, 8);
  _Unwind_Resume(a1);
}

void sub_1000ABB68(_QWORD *a1)
{
  uint64_t v1;
  id v3;

  v1 = a1[4];
  if (v1 && *(_BYTE *)(v1 + 12) && *(_QWORD *)(v1 + 288) == a1[5])
  {
    v3 = (id)nw_path_evaluator_copy_path();
    (*(void (**)(void))(a1[6] + 16))();

  }
}

uint64_t sub_1000ABBD8(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_1000ABBE8(uint64_t a1)
{

}

uint64_t sub_1000ABBF0(uint64_t a1, int a2, xpc_object_t xdict)
{
  const char *data;
  uint64_t result;
  id v6;
  uint64_t v7;
  void *v8;
  size_t length;

  length = 0;
  data = (const char *)xpc_dictionary_get_data(xdict, "data", &length);
  result = 1;
  if (data && length >= 0xD8 && length == *((unsigned int *)data + 53) + 216)
  {
    if (!strcmp(data + 16, "NetworkExtension") && !strcmp(data + 48, "AppVPN"))
    {
      v6 = objc_msgSend(objc_alloc((Class)NSUUID), "initWithUUIDBytes:", data);
      v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v8 = *(void **)(v7 + 40);
      *(_QWORD *)(v7 + 40) = v6;

      result = 0;
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = (data[208] & 2) != 0;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

void sub_1000ABCC8(uint64_t a1, int a2)
{
  id WeakRetained;
  id v4;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained && *((_BYTE *)WeakRetained + 12) && *((_DWORD *)WeakRetained + 7) == a2)
  {
    v4 = WeakRetained;
    sub_1000ABD1C(WeakRetained, a2);
    WeakRetained = v4;
  }

}

void sub_1000ABD1C(id val, int a2)
{
  int v4;
  void *v5;
  id v6;
  _QWORD v7[4];
  id v8;
  int v9;
  int v10;
  id location;

  v4 = *((_DWORD *)val + 8) + 1;
  *((_DWORD *)val + 8) = v4;
  objc_initWeak(&location, val);
  v5 = (void *)objc_claimAutoreleasedReturnValue(+[NEConfigurationManager sharedManagerForAllUsers](NEConfigurationManager, "sharedManagerForAllUsers"));
  v6 = *((id *)val + 15);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_1000ABE1C;
  v7[3] = &unk_1001B70A8;
  objc_copyWeak(&v8, &location);
  v9 = a2;
  v10 = v4;
  objc_msgSend(v5, "loadConfigurationsWithCompletionQueue:handler:", v6, v7);

  objc_destroyWeak(&v8);
  objc_destroyWeak(&location);
}

void sub_1000ABDF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000ABE1C(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id *WeakRetained;
  id *v8;
  id v9;
  id v10;
  id v11;
  id v12;
  id v13;
  uint64_t v14;
  void *i;
  void *v16;
  uint64_t v17;
  void *v18;
  void *v19;
  unsigned int v20;
  void *v21;
  id v22;
  id *v23;
  id v24;
  id v25;
  id v26;
  uint64_t v27;
  void *j;
  id v29;
  id v30;
  int IsLevelEnabled;
  id v32;
  unsigned __int8 v33;
  id v34;
  id v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  _BYTE v44[128];
  _BYTE v45[128];

  v5 = a2;
  v6 = a3;
  WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  v8 = WeakRetained;
  if (WeakRetained
    && *((_BYTE *)WeakRetained + 12)
    && *((_DWORD *)WeakRetained + 7) == *(_DWORD *)(a1 + 40)
    && *(_DWORD *)(a1 + 44) == *((_DWORD *)WeakRetained + 8))
  {
    if (v6)
    {
      if (qword_1001E4738 != -1)
        dispatch_once(&qword_1001E4738, &stru_1001B7110);
      if (_NRLogIsLevelEnabled(qword_1001E4730, 17))
      {
        if (qword_1001E4738 != -1)
          dispatch_once(&qword_1001E4738, &stru_1001B7110);
        _NRLogWithArgs(qword_1001E4730, 17, "error loading NE configuration: %@", v6);
      }
    }
    else
    {
      v34 = WeakRetained[38];
      v9 = v8[38];
      v8[38] = 0;

      v10 = objc_alloc_init((Class)NSMutableArray);
      v40 = 0u;
      v41 = 0u;
      v42 = 0u;
      v43 = 0u;
      v35 = v5;
      v11 = v5;
      v12 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v40, v45, 16);
      if (v12)
      {
        v13 = v12;
        v14 = *(_QWORD *)v41;
        do
        {
          for (i = 0; i != v13; i = (char *)i + 1)
          {
            if (*(_QWORD *)v41 != v14)
              objc_enumerationMutation(v11);
            v16 = *(void **)(*((_QWORD *)&v40 + 1) + 8 * (_QWORD)i);
            v17 = objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "appVPN"));
            if (v17)
            {
              v18 = (void *)v17;
              v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "appVPN"));
              v20 = objc_msgSend(v19, "isEnabled");

              if (v20)
              {
                v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "appVPN"));
                v22 = objc_msgSend(v21, "copyAppRuleIDs");

                if (objc_msgSend(v22, "count"))
                  objc_msgSend(v10, "addObjectsFromArray:", v22);

              }
            }
          }
          v13 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v40, v45, 16);
        }
        while (v13);
      }
      v23 = v8 + 38;

      if (objc_msgSend(v10, "count"))
      {
        v11 = objc_alloc_init((Class)NSMutableSet);
        v36 = 0u;
        v37 = 0u;
        v38 = 0u;
        v39 = 0u;
        v24 = v10;
        v25 = objc_msgSend(v24, "countByEnumeratingWithState:objects:count:", &v36, v44, 16);
        if (v25)
        {
          v26 = v25;
          v27 = *(_QWORD *)v37;
          do
          {
            for (j = 0; j != v26; j = (char *)j + 1)
            {
              if (*(_QWORD *)v37 != v27)
                objc_enumerationMutation(v24);
              v29 = sub_1001078CC(*(void **)(*((_QWORD *)&v36 + 1) + 8 * (_QWORD)j));
              if (objc_msgSend(v29, "count"))
                objc_msgSend(v11, "addObjectsFromArray:", v29);

            }
            v26 = objc_msgSend(v24, "countByEnumeratingWithState:objects:count:", &v36, v44, 16);
          }
          while (v26);
        }

        if (objc_msgSend(v11, "count"))
        {
          objc_storeStrong(v8 + 38, v11);
          v30 = sub_1000A2640();
          IsLevelEnabled = _NRLogIsLevelEnabled(v30, 1);

          if (IsLevelEnabled)
          {
            v32 = sub_1000A2640();
            _NRLogWithArgs(v32, 1, "%s%.30s:%-4d fetched app vpn UUIDs %@", "", "-[NRLinkDirector processNEConfigurationChangeForNotifyToken:]_block_invoke", 2478, *v23);

          }
        }

      }
      if (v34 || (v11 = *v23) != 0)
      {
        v33 = objc_msgSend(*v23, "isEqualToSet:", v34);
        if (!v34)

        if ((v33 & 1) == 0)
          sub_1000A26B0((uint64_t)v8);
      }

      v6 = 0;
      v5 = v35;
    }
  }

}

void sub_1000AC220(id a1)
{
  sub_100107D4C(CFSTR("/var/mobile/Library/terminus/com.apple.necp_drop_dest.plist"));
}

void sub_1000AC22C(uint64_t a1, int a2)
{
  NSObject **WeakRetained;
  NSObject **v4;
  NSObject *v5;
  _QWORD block[5];

  WeakRetained = (NSObject **)objc_loadWeakRetained((id *)(a1 + 32));
  v4 = WeakRetained;
  if (WeakRetained && *((_DWORD *)WeakRetained + 6) == a2)
  {
    v5 = WeakRetained[15];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000AC2AC;
    block[3] = &unk_1001B8AE0;
    block[4] = v4;
    dispatch_async(v5, block);
  }

}

void sub_1000AC2AC(uint64_t a1)
{
  uint64_t v1;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *StringFromThermalPressureLevel;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  id v14;
  void *v15;
  uint64_t v16;
  void *v17;
  id v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  void *v28;
  _QWORD *v29;
  _QWORD *v30;
  id v31;
  id v32;
  uint64_t v33;
  void *i;
  unsigned int v35;
  uint64_t v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  _DWORD *v40;
  _DWORD *v41;
  _DWORD *v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  uint64_t state64;
  _BYTE v48[128];

  v1 = *(_QWORD *)(a1 + 32);
  if (v1)
  {
    if (*(_BYTE *)(v1 + 12))
    {
      v3 = *(_DWORD *)(v1 + 24);
      if (v3 != -1)
      {
        state64 = 0;
        notify_get_state(v3, &state64);
        v4 = *(_QWORD *)(a1 + 32);
        if (v4)
        {
          *(_DWORD *)(v4 + 20) = state64;
          v5 = *(_QWORD *)(a1 + 32);
          v6 = v5 ? *(unsigned int *)(v5 + 20) : 0;
        }
        else
        {
          v5 = 0;
          v6 = 0;
        }
        StringFromThermalPressureLevel = (void *)createStringFromThermalPressureLevel(v6);
        sub_1000A25C4(v5, 1049, CFSTR("%@"), v8, v9, v10, v11, v12, (uint64_t)StringFromThermalPressureLevel);

        v13 = *(_QWORD *)(a1 + 32);
        if (v13)
        {
          v14 = *(id *)(v13 + 200);
          if (v14)
          {
            v15 = v14;
            v16 = *(_QWORD *)(a1 + 32);
            v17 = v16 ? *(void **)(v16 + 200) : 0;
            v18 = objc_msgSend(v17, "count");

            if (v18)
            {
              v19 = *(_QWORD *)(a1 + 32);
              if (v19)
                v20 = *(void **)(v19 + 40);
              else
                v20 = 0;
              objc_msgSend(v20, "handleThermalStateUpdate");
              v21 = *(_QWORD *)(a1 + 32);
              if (v21)
                v22 = *(void **)(v21 + 48);
              else
                v22 = 0;
              objc_msgSend(v22, "handleThermalStateUpdate");
              v23 = *(_QWORD *)(a1 + 32);
              if (v23)
                v24 = *(void **)(v23 + 56);
              else
                v24 = 0;
              objc_msgSend(v24, "handleThermalStateUpdate");
              v25 = *(_QWORD *)(a1 + 32);
              if (v25)
                v26 = *(void **)(v25 + 64);
              else
                v26 = 0;
              if (_NRIsAppleInternal(objc_msgSend(v26, "handleThermalStateUpdate")))
              {
                v27 = *(_QWORD *)(a1 + 32);
                if (v27)
                  v28 = *(void **)(v27 + 168);
                else
                  v28 = 0;
                objc_msgSend(v28, "handleThermalStateUpdate");
              }
              v45 = 0u;
              v46 = 0u;
              v43 = 0u;
              v44 = 0u;
              v29 = *(_QWORD **)(a1 + 32);
              if (v29)
                v29 = (_QWORD *)v29[25];
              v30 = v29;
              v31 = objc_msgSend(v30, "countByEnumeratingWithState:objects:count:", &v43, v48, 16);
              if (v31)
              {
                v32 = v31;
                v33 = *(_QWORD *)v44;
                do
                {
                  for (i = 0; i != v32; i = (char *)i + 1)
                  {
                    if (*(_QWORD *)v44 != v33)
                      objc_enumerationMutation(v30);
                    v36 = *(_QWORD *)(a1 + 32);
                    if (v36)
                      v37 = *(void **)(v36 + 200);
                    else
                      v37 = 0;
                    v38 = objc_claimAutoreleasedReturnValue(objc_msgSend(v37, "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v43 + 1) + 8 * (_QWORD)i)));
                    v39 = v38;
                    if (v38 && *(_BYTE *)(v38 + 14))
                    {
                      objc_opt_self(NRLinkDirector);
                      if (qword_1001E4710 != -1)
                        dispatch_once(&qword_1001E4710, &stru_1001B6E60);
                      v40 = (id)qword_1001E4708;
                      if (v40)
                      {
                        v35 = v40[5];

                        if (v35 > *(_DWORD *)(v39 + 84))
                        {
                          v41 = *(id *)(v39 + 624);
                          if (v41)
                            v41[4] |= 0x400u;

                          v42 = *(id *)(v39 + 616);
                          if (v42)
                            v42[4] |= 0x400u;

                        }
                      }
                      else
                      {
                        v35 = 0;
                      }
                      *(_DWORD *)(v39 + 84) = v35;
                      sub_1000DB7A8(v39, *(void **)(v39 + 128));
                    }

                  }
                  v32 = objc_msgSend(v30, "countByEnumeratingWithState:objects:count:", &v43, v48, 16);
                }
                while (v32);
              }

            }
          }
        }
      }
    }
  }
}

void sub_1000AC5C4(uint64_t a1, int a2, void *a3)
{
  NSObject *v5;
  unsigned __int8 *WeakRetained;
  id v7;
  void *v8;
  unsigned int v9;
  id v10;
  int v11;
  id v12;
  dispatch_time_t v13;
  NSObject *v14;
  id v15;
  int IsLevelEnabled;
  id v17;
  _QWORD block[4];
  unsigned __int8 *v19;

  v5 = a3;
  WeakRetained = (unsigned __int8 *)objc_loadWeakRetained((id *)(a1 + 32));
  v7 = objc_loadWeakRetained((id *)(a1 + 40));
  v8 = v7;
  if (WeakRetained && WeakRetained[12] && *((id *)WeakRetained + 17) == v7)
  {
    if ((a2 - 1) <= 1)
    {
      if (qword_1001E4738 != -1)
        dispatch_once(&qword_1001E4738, &stru_1001B7110);
      if (_NRLogIsLevelEnabled(qword_1001E4730, 0))
      {
        if (qword_1001E4738 != -1)
          dispatch_once(&qword_1001E4738, &stru_1001B7110);
        _NRLogWithArgs(qword_1001E4730, 0, "%s%.30s:%-4d MASQUE server started %u");
      }
LABEL_25:
      WeakRetained[13] = 0;
      goto LABEL_26;
    }
    if (a2 == 3)
    {
      sub_1000A5020(WeakRetained);
      if (!v5 || nw_error_get_error_domain(v5) != nw_error_domain_posix || nw_error_get_error_code(v5) != 48)
      {
        if (qword_1001E4738 != -1)
          dispatch_once(&qword_1001E4738, &stru_1001B7110);
        if (_NRLogIsLevelEnabled(qword_1001E4730, 17))
        {
          if (qword_1001E4738 != -1)
            dispatch_once(&qword_1001E4738, &stru_1001B7110);
          _NRLogWithArgs(qword_1001E4730, 17, "failed to start proxy server with error %@", v5);
        }
        goto LABEL_25;
      }
      v9 = WeakRetained[13];
      if (v9 > 4)
      {
        v15 = sub_1000A2640();
        IsLevelEnabled = _NRLogIsLevelEnabled(v15, 17);

        if (IsLevelEnabled)
        {
          v17 = sub_1000A2640();
          _NRLogWithArgs(v17, 17, "failed to start proxy server after %u address in use retries", WeakRetained[13]);

        }
        goto LABEL_25;
      }
      WeakRetained[13] = v9 + 1;
      v10 = sub_1000A2640();
      v11 = _NRLogIsLevelEnabled(v10, 16);

      if (v11)
      {
        v12 = sub_1000A2640();
        _NRLogWithArgs(v12, 16, "%s%.30s:%-4d scheduling address in use retry %u", "", "-[NRLinkDirector startMASQUEProxyServerIfNeeded]_block_invoke", 2115, WeakRetained[13]);

      }
      v13 = dispatch_time(0x8000000000000000, 200000000 * WeakRetained[13]);
      v14 = *((_QWORD *)WeakRetained + 15);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_1000AD6B8;
      block[3] = &unk_1001B8AE0;
      v19 = WeakRetained;
      dispatch_after(v13, v14, block);

    }
  }
LABEL_26:

}

void sub_1000AC8AC(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6)
{
  id v11;
  id v12;
  id v13;
  id WeakRetained;
  id v15;
  void *v16;
  id v17;
  _QWORD v18[4];
  id v19;
  id v20;
  id v21;
  id v22;
  uint64_t v23;

  v17 = a3;
  v11 = a4;
  v12 = a5;
  v13 = a6;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v15 = objc_loadWeakRetained((id *)(a1 + 40));
  v16 = v15;
  if (WeakRetained && *((_BYTE *)WeakRetained + 12) && *((id *)WeakRetained + 17) == v15)
  {
    v18[0] = _NSConcreteStackBlock;
    v18[1] = 3221225472;
    v18[2] = sub_1000ACCD0;
    v18[3] = &unk_1001B6F90;
    v19 = v12;
    v20 = v17;
    v23 = a2;
    v21 = WeakRetained;
    v22 = v11;
    nw_http_fields_access_value_by_name(v13, "Proxy-Usage-Token", v18);

  }
}

void sub_1000AC9E0(uint64_t a1, uint64_t a2, int a3)
{
  id v6;
  void *v7;
  id v8;
  id v9;
  id v10;
  void *v11;
  void *v12;
  id v13;
  id *WeakRetained;

  WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  v6 = objc_loadWeakRetained((id *)(a1 + 40));
  v7 = v6;
  if (WeakRetained && *((_BYTE *)WeakRetained + 12) && WeakRetained[17] == v6)
  {
    if (a3 == 2)
    {
      if (qword_1001E4738 != -1)
        dispatch_once(&qword_1001E4738, &stru_1001B7110);
      if (_NRLogIsLevelEnabled(qword_1001E4730, 2))
      {
        if (qword_1001E4738 != -1)
          dispatch_once(&qword_1001E4738, &stru_1001B7110);
        _NRLogWithArgs(qword_1001E4730, 2, "%s%.30s:%-4d proxy client connection cancelled (id: %llu)", "", "-[NRLinkDirector startMASQUEProxyServerIfNeeded]_block_invoke_3", 2223, a2);
      }
      v10 = WeakRetained[18];
      v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a2));
      v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "objectForKeyedSubscript:", v11));

      if (v12)
      {
        if (qword_1001E4738 != -1)
          dispatch_once(&qword_1001E4738, &stru_1001B7110);
        if (_NRLogIsLevelEnabled(qword_1001E4730, 2))
        {
          if (qword_1001E4738 != -1)
            dispatch_once(&qword_1001E4738, &stru_1001B7110);
          _NRLogWithArgs(qword_1001E4730, 2, "%s%.30s:%-4d removing cached token (id: %llu)", "", "-[NRLinkDirector startMASQUEProxyServerIfNeeded]_block_invoke_3", 2225, a2);
        }
      }
      v13 = WeakRetained[18];
      v9 = (id)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a2));
      objc_msgSend(v13, "setObject:forKeyedSubscript:", 0, v9);

      goto LABEL_28;
    }
    if (a3 == 1)
    {
      if (qword_1001E4738 != -1)
        dispatch_once(&qword_1001E4738, &stru_1001B7110);
      if (_NRLogIsLevelEnabled(qword_1001E4730, 2))
      {
        if (qword_1001E4738 != -1)
          dispatch_once(&qword_1001E4738, &stru_1001B7110);
        _NRLogWithArgs(qword_1001E4730, 2, "%s%.30s:%-4d proxy client connection started (id: %llu)", "", "-[NRLinkDirector startMASQUEProxyServerIfNeeded]_block_invoke_3", 2218, a2);
      }
      if (!WeakRetained[18])
      {
        v8 = objc_alloc_init((Class)NSMutableDictionary);
        v9 = WeakRetained[18];
        WeakRetained[18] = v8;
LABEL_28:

      }
    }
  }

}

void sub_1000ACCD0(uint64_t a1, char *__s)
{
  size_t v4;
  dispatch_data_t v5;
  void *v6;
  id v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  void *v12;
  id v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  void *v17;
  void *v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  void *v22;
  id v23;
  uint64_t v24;
  void *i;
  uint64_t v26;
  int v27;
  id v28;
  BOOL v29;
  id v30;
  id v31;
  id v32;
  id v33;
  BOOL v34;
  id v35;
  id v36;
  uint64_t v37;
  void *v38;
  id v39;
  uint64_t v40;
  void *v41;
  id v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  id v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  _QWORD v51[4];
  id v52;
  id v53;
  uint64_t *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t *v57;
  uint64_t v58;
  uint64_t (*v59)(uint64_t, uint64_t);
  void (*v60)(uint64_t);
  id v61;
  _BYTE v62[128];

  if (__s)
  {
    v4 = strlen(__s);
    v5 = dispatch_data_create(__s, v4, 0, 0);
    v6 = (void *)dispatch_data_create_with_transform(v5, &_dispatch_data_format_type_base64, &_dispatch_data_format_type_none);
    v56 = 0;
    v57 = &v56;
    v58 = 0x3032000000;
    v59 = sub_1000ABBD8;
    v60 = sub_1000ABBE8;
    v61 = objc_alloc_init((Class)NSMutableArray);
    v51[0] = _NSConcreteStackBlock;
    v51[1] = 3221225472;
    v51[2] = sub_1000AD3EC;
    v51[3] = &unk_1001B6F68;
    v52 = *(id *)(a1 + 32);
    v7 = *(id *)(a1 + 40);
    v8 = *(_QWORD *)(a1 + 64);
    v54 = &v56;
    v55 = v8;
    v53 = v7;
    NRTLVParse(v6, v51);
    if (objc_msgSend((id)v57[5], "count"))
    {
      v9 = *(_QWORD **)(a1 + 48);
      if (v9)
        v9 = (_QWORD *)v9[18];
      v10 = v57[5];
      v11 = v9;
      v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(a1 + 64)));
      objc_msgSend(v11, "setObject:forKeyedSubscript:", v10, v12);

      v13 = (id)v57[5];
    }
    else
    {
      v13 = 0;
    }

    _Block_object_dispose(&v56, 8);
  }
  else
  {
    v14 = *(_QWORD **)(a1 + 48);
    if (v14)
      v14 = (_QWORD *)v14[18];
    v15 = *(_QWORD *)(a1 + 64);
    v16 = v14;
    v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v15));
    v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "objectForKeyedSubscript:", v17));

    if (!v18)
    {
      v13 = 0;
LABEL_58:
      if (qword_1001E4738 != -1)
        dispatch_once(&qword_1001E4738, &stru_1001B7110);
      if (_NRLogIsLevelEnabled(qword_1001E4730, 1))
      {
        if (qword_1001E4738 != -1)
          dispatch_once(&qword_1001E4738, &stru_1001B7110);
        _NRLogWithArgs(qword_1001E4730, 1, "%s%.30s:%-4d no token from %@ for %@ (id: %llu)", "", "-[NRLinkDirector startMASQUEProxyServerIfNeeded]_block_invoke_2", 2174, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 64));
      }
      goto LABEL_64;
    }
    v19 = *(_QWORD **)(a1 + 48);
    if (v19)
      v19 = (_QWORD *)v19[18];
    v20 = *(_QWORD *)(a1 + 64);
    v21 = v19;
    v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v20));
    v13 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "objectForKeyedSubscript:", v22));

    if (qword_1001E4738 != -1)
      dispatch_once(&qword_1001E4738, &stru_1001B7110);
    if (_NRLogIsLevelEnabled(qword_1001E4730, 1))
    {
      if (qword_1001E4738 != -1)
        dispatch_once(&qword_1001E4738, &stru_1001B7110);
      _NRLogWithArgs(qword_1001E4730, 1, "%s%.30s:%-4d using cached tokensfrom %@ for %@ (id: %llu)", "", "-[NRLinkDirector startMASQUEProxyServerIfNeeded]_block_invoke_2", 2170, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 64));
    }
  }
  if (!v13 || !objc_msgSend(v13, "count"))
    goto LABEL_58;
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v13 = v13;
  v23 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v47, v62, 16);
  if (v23)
  {
    v24 = *(_QWORD *)v48;
    do
    {
      for (i = 0; i != v23; i = (char *)i + 1)
      {
        if (*(_QWORD *)v48 != v24)
          objc_enumerationMutation(v13);
        v26 = *(_QWORD *)(*((_QWORD *)&v47 + 1) + 8 * (_QWORD)i);
        if (v26 && *(_BYTE *)(v26 + 8) == 1)
        {
          v27 = *(unsigned __int8 *)(v26 + 9);
          if (v27 == 52)
          {
            v33 = *(id *)(v26 + 16);
            v34 = v33 == 0;

            if (!v34)
            {
              v35 = objc_alloc((Class)NSString);
              v36 = *(id *)(v26 + 16);
              v32 = objc_msgSend(v35, "initWithData:encoding:", v36, 4);

              if (v32)
              {
                if (qword_1001E4738 != -1)
                  dispatch_once(&qword_1001E4738, &stru_1001B7110);
                if (_NRLogIsLevelEnabled(qword_1001E4730, 1))
                {
                  if (qword_1001E4738 != -1)
                    dispatch_once(&qword_1001E4738, &stru_1001B7110);
                  _NRLogWithArgs(qword_1001E4730, 1, "%s%.30s:%-4d setting bundle id %@", "", "-[NRLinkDirector startMASQUEProxyServerIfNeeded]_block_invoke_2", 2192, v32);
                }
                nw_parameters_set_source_application_by_external_bundle_id(*(_QWORD *)(a1 + 56), objc_msgSend(v32, "UTF8String"));
              }
              goto LABEL_24;
            }
          }
          else if (v27 == 51)
          {
            v28 = *(id *)(v26 + 16);
            v29 = v28 == 0;

            if (!v29)
            {
              v30 = objc_alloc((Class)NSString);
              v31 = *(id *)(v26 + 16);
              v32 = objc_msgSend(v30, "initWithData:encoding:", v31, 4);

              if (v32)
              {
                if (qword_1001E4738 != -1)
                  dispatch_once(&qword_1001E4738, &stru_1001B7110);
                if (_NRLogIsLevelEnabled(qword_1001E4730, 1))
                {
                  if (qword_1001E4738 != -1)
                    dispatch_once(&qword_1001E4738, &stru_1001B7110);
                  _NRLogWithArgs(qword_1001E4730, 1, "%s%.30s:%-4d setting account id %@", "", "-[NRLinkDirector startMASQUEProxyServerIfNeeded]_block_invoke_2", 2184, v32);
                }
                nw_parameters_set_account_id(*(_QWORD *)(a1 + 56), objc_msgSend(v32, "UTF8String"));
              }
LABEL_24:

              continue;
            }
          }
        }
      }
      v23 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v47, v62, 16);
    }
    while (v23);
  }

  v37 = *(_QWORD *)(a1 + 48);
  if (v37)
    v38 = *(void **)(v37 + 144);
  else
    v38 = 0;
  if ((unint64_t)objc_msgSend(v38, "count") >= 0x21)
  {
    v39 = objc_alloc((Class)NSString);
    v40 = *(_QWORD *)(a1 + 48);
    if (v40)
      v41 = *(void **)(v40 + 144);
    else
      v41 = 0;
    v46 = objc_msgSend(v41, "count");
    v42 = objc_msgSend(v39, "initWithFormat:", CFSTR("unexpected number of cached tokens %u"));
    sub_100109270(CFSTR("MASQUEProxyTokens"), v42, 0, 0, 0, v43, v44, v45, (uint64_t)v46);

  }
LABEL_64:

}

void sub_1000AD3D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  _Block_object_dispose(&a31, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000AD3EC(_QWORD *a1, uint64_t a2)
{
  id v4;
  void *v5;
  id v6;
  id *v7;
  NRToken *v8;
  _QWORD v10[8];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t, uint64_t);
  void (*v19)(uint64_t);
  id v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  char v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  char v28;

  v4 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", a2 + 3, bswap32(*(unsigned __int16 *)(a2 + 1)) >> 16);
  v5 = v4;
  if (*(_BYTE *)a2 == 8)
  {
    v6 = v4;
    objc_opt_self(NRToken);
    if (objc_msgSend(v6, "length"))
    {
      v25 = 0;
      v26 = &v25;
      v27 = 0x2020000000;
      v28 = 0;
      v21 = 0;
      v22 = &v21;
      v23 = 0x2020000000;
      v24 = 0;
      v15 = 0;
      v16 = &v15;
      v17 = 0x3032000000;
      v18 = sub_1000033AC;
      v19 = sub_1000033BC;
      v20 = 0;
      v11 = 0;
      v12 = &v11;
      v13 = 0x2020000000;
      v14 = 50;
      v10[0] = _NSConcreteStackBlock;
      v10[1] = 3221225472;
      v10[2] = sub_1000033C4;
      v10[3] = &unk_1001B5CE0;
      v10[4] = &v25;
      v10[5] = &v21;
      v10[6] = &v15;
      v10[7] = &v11;
      NRTLVParse(v6, v10);
      if (*((_BYTE *)v26 + 24))
      {
        v7 = 0;
      }
      else
      {
        v8 = [NRToken alloc];
        v7 = sub_100003144((id *)&v8->super.isa, *((_BYTE *)v22 + 24), *((_BYTE *)v12 + 24), (void *)v16[5]);
      }
      _Block_object_dispose(&v11, 8);
      _Block_object_dispose(&v15, 8);

      _Block_object_dispose(&v21, 8);
      _Block_object_dispose(&v25, 8);

      if (v7 && *((_BYTE *)v7 + 8))
      {
        if (qword_1001E4738 != -1)
          dispatch_once(&qword_1001E4738, &stru_1001B7110);
        if (_NRLogIsLevelEnabled(qword_1001E4730, 1))
        {
          if (qword_1001E4738 != -1)
            dispatch_once(&qword_1001E4738, &stru_1001B7110);
          _NRLogWithArgs(qword_1001E4730, 1, "%s%.30s:%-4d received token %@ from %@ for %@ (id: %llu)", "", "-[NRLinkDirector startMASQUEProxyServerIfNeeded]_block_invoke", 2158, v7, a1[4], a1[5], a1[7]);
        }
        objc_msgSend(*(id *)(*(_QWORD *)(a1[6] + 8) + 40), "addObject:", v7);
      }
    }
    else
    {

      v7 = 0;
    }

  }
  return 1;
}

void sub_1000AD678(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  uint64_t v29;

  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a29, 8);
  _Block_object_dispose((const void *)(v29 - 112), 8);
  _Block_object_dispose((const void *)(v29 - 80), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000AD6B8(uint64_t a1)
{
  return sub_1000A87B8(*(_QWORD *)(a1 + 32));
}

void sub_1000AD6C0(uint64_t a1, int a2, void *a3)
{
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  id v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  int64_t v13;
  dispatch_time_t v14;
  uint64_t v15;
  NSObject *v16;
  id v17;
  void *v18;
  uint64_t v19;
  _QWORD block[5];

  v5 = a3;
  if ((a2 - 1) <= 1)
  {
LABEL_2:
    v6 = *(_QWORD *)(a1 + 32);
    if (v6)
      *(_BYTE *)(v6 + 13) = 0;
    goto LABEL_22;
  }
  if (a2 != 3)
    goto LABEL_22;
  sub_1000A4E44(*(_QWORD *)(a1 + 32));
  if (!v5 || nw_error_get_error_domain(v5) != nw_error_domain_posix || nw_error_get_error_code(v5) != 48)
  {
    if (qword_1001E4738 != -1)
      dispatch_once(&qword_1001E4738, &stru_1001B7110);
    if (_NRLogIsLevelEnabled(qword_1001E4730, 17))
    {
      if (qword_1001E4738 != -1)
        dispatch_once(&qword_1001E4738, &stru_1001B7110);
      _NRLogWithArgs(qword_1001E4730, 17, "failed to start proxy server with error %@", v5);
    }
    goto LABEL_2;
  }
  v7 = *(_QWORD *)(a1 + 32);
  if (v7)
  {
    v8 = *(unsigned __int8 *)(v7 + 13);
    if (v8 > 4)
    {
      if (qword_1001E4738 != -1)
        dispatch_once(&qword_1001E4738, &stru_1001B7110);
      if (_NRLogIsLevelEnabled(qword_1001E4730, 17))
      {
        v17 = sub_1000A2640();
        v18 = v17;
        v19 = *(_QWORD *)(a1 + 32);
        if (v19)
          LODWORD(v19) = *(unsigned __int8 *)(v19 + 13);
        _NRLogWithArgs(v17, 17, "failed to start proxy server after %u address in use retries", v19);

      }
      goto LABEL_2;
    }
    *(_BYTE *)(v7 + 13) = v8 + 1;
  }
  if (qword_1001E4738 != -1)
    dispatch_once(&qword_1001E4738, &stru_1001B7110);
  if (_NRLogIsLevelEnabled(qword_1001E4730, 16))
  {
    v9 = sub_1000A2640();
    v10 = v9;
    v11 = *(_QWORD *)(a1 + 32);
    if (v11)
      LODWORD(v11) = *(unsigned __int8 *)(v11 + 13);
    _NRLogWithArgs(v9, 16, "%s%.30s:%-4d scheduling address in use retry %u", "", "-[NRLinkDirector startSocksServerIfNeeded]_block_invoke", 1848, v11);

  }
  v12 = *(_QWORD *)(a1 + 32);
  if (v12)
    v13 = 200000000 * *(unsigned __int8 *)(v12 + 13);
  else
    v13 = 0;
  v14 = dispatch_time(0x8000000000000000, v13);
  v15 = *(_QWORD *)(a1 + 32);
  if (v15)
    v16 = *(NSObject **)(v15 + 120);
  else
    v16 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000ADA38;
  block[3] = &unk_1001B8AE0;
  block[4] = v15;
  dispatch_after(v14, v16, block);
LABEL_22:

}

void sub_1000AD94C(uint64_t a1)
{
  id WeakRetained;
  _QWORD *v3;
  id v4;
  void *v5;
  int v6;
  NRAnalyticsSHOESProxy *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void *v12;
  uint64_t v13;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v3 = WeakRetained;
  if (WeakRetained)
  {
    if (*((_QWORD *)WeakRetained + 19) == *(_QWORD *)(a1 + 32))
    {
      v13 = 0;
      v4 = *((id *)WeakRetained + 16);
      if (v4)
      {
        v5 = v4;
        v6 = nw_shoes_server_fillout_statistics(v3[16], &v13, 8, 1);

        if (v6)
        {
          v7 = objc_alloc_init(NRAnalyticsSHOESProxy);
          v8 = (void *)v3[20];
          v3[20] = v7;

          v9 = v3[20];
          if (v9 && (*(_QWORD *)(v9 + 24) = v13, (v10 = v3[20]) != 0))
          {
            *(_QWORD *)(v10 + 16) = HIDWORD(v13);
            v11 = (void *)v3[20];
          }
          else
          {
            v11 = 0;
          }
          objc_msgSend(v11, "submit");
          v12 = (void *)v3[20];
          v3[20] = 0;

        }
      }
    }
  }

}

uint64_t sub_1000ADA38(uint64_t a1)
{
  return sub_1000A7EAC(*(_QWORD *)(a1 + 32));
}

void sub_1000ADA40(uint64_t a1)
{
  uint64_t *WeakRetained;
  id **v2;

  WeakRetained = (uint64_t *)objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained && *((_BYTE *)WeakRetained + 12))
  {
    v2 = (id **)WeakRetained;
    sub_10002F478(WeakRetained[5]);
    sub_100149C5C(v2[6]);
    WeakRetained = (uint64_t *)v2;
  }

}

void sub_1000ADA88(id a1)
{
  uint64_t IsLevelEnabled;

  if (qword_1001E4738 != -1)
    dispatch_once(&qword_1001E4738, &stru_1001B7110);
  IsLevelEnabled = _NRLogIsLevelEnabled(qword_1001E4730, 0);
  if ((_DWORD)IsLevelEnabled)
  {
    if (qword_1001E4738 != -1)
      dispatch_once(&qword_1001E4738, &stru_1001B7110);
    IsLevelEnabled = _NRLogWithArgs(qword_1001E4730, 0, "%s%.30s:%-4d Force clearing nehelper uuid cache", "", "-[NRLinkDirector checkEnabledDevices]_block_invoke", 837);
  }
  NEHelperCacheClearUUIDs(IsLevelEnabled);
}

void sub_1000ADB38(uint64_t a1, void *a2)
{
  id v3;
  _QWORD *WeakRetained;
  void *v5;
  NSObject *v6;
  _QWORD block[4];
  _QWORD *v8;

  v3 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v5 = WeakRetained;
  if (WeakRetained)
  {
    v6 = WeakRetained[15];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000ADC60;
    block[3] = &unk_1001B8AE0;
    v8 = WeakRetained;
    dispatch_async(v6, block);
    if (qword_1001E4738 != -1)
      dispatch_once(&qword_1001E4738, &stru_1001B7110);
    if (_NRLogIsLevelEnabled(qword_1001E4730, 0))
    {
      if (qword_1001E4738 != -1)
        dispatch_once(&qword_1001E4738, &stru_1001B7110);
      _NRLogWithArgs(qword_1001E4730, 0, "%s%.30s:%-4d Got perpetual standalone notification %@", "", "-[NRLinkDirector setupPerpetualStandaloneMeadow]_block_invoke", 2564, v3);
    }

  }
}

void sub_1000ADC60(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  if (v1)
  {
    if (*(_BYTE *)(v1 + 12))
      sub_1000A7BA4(v1);
  }
}

void sub_1000ADC78(uint64_t a1)
{
  uint64_t v1;
  id v3;
  uint64_t v4;
  uint64_t v5;

  v1 = *(_QWORD *)(a1 + 32);
  if (v1 && *(_BYTE *)(v1 + 12))
  {
    v3 = *(id *)(v1 + 72);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 32);
      if (v4)
      {
        v5 = *(_QWORD *)(v4 + 80);

        if (v5)
          return;
      }
      else
      {

      }
    }
    sub_1000AE110(*(_QWORD *)(a1 + 32));
  }
}

void sub_1000ADCD8(uint64_t a1)
{
  _QWORD *v1;
  id v2;
  _QWORD v3[5];

  if (!*(_QWORD *)(a1 + 64))
  {
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_1000AEBD4;
    v3[3] = &unk_1001B8AE0;
    v3[4] = a1;
    v1 = objc_retainBlock(v3);
    if (qword_1001E4870 != -1)
      dispatch_once(&qword_1001E4870, &stru_1001B7BB0);
    if (byte_1001E4868)
    {
      ((void (*)(_QWORD *))v1[2])(v1);
    }
    else
    {
      objc_opt_self(NRDKeyManager);
      if (qword_1001E4AD8 != -1)
        dispatch_once(&qword_1001E4AD8, &stru_1001B8968);
      v2 = (id)qword_1001E4AD0;
      sub_10014ACE0((uint64_t)v2, v1);

    }
  }
}

void sub_1000ADDD4(uint64_t a1)
{
  uint64_t v2;
  NRLinkManagerQuickRelay *v3;
  _QWORD *v4;
  _QWORD *v5;
  void *v6;
  id v7;
  __objc2_prot *v8;
  __objc2_prot *v9;
  __objc2_meth_list *v10;
  __objc2_meth_list *opt_inst_meths;
  NRLinkManagerQuickRelay *v12;
  uint64_t v13;
  id v14;
  int IsLevelEnabled;
  NSObject *v16;
  const char *v17;
  id v18;
  int v19;
  id v20;
  int v21;
  id v22;
  id v23;
  int v24;
  id v25;
  int v26;
  id v27;
  uint64_t v28;
  dispatch_queue_t queue;
  objc_super v30;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2 && *(_BYTE *)(v2 + 12))
  {
    sub_1000AE110(v2);
    if (qword_1001E4870 != -1)
      dispatch_once(&qword_1001E4870, &stru_1001B7BB0);
    if (byte_1001E4868)
    {
      v14 = sub_1000A2640();
      IsLevelEnabled = _NRLogIsLevelEnabled(v14, 0);

      if (IsLevelEnabled)
      {
        v16 = sub_1000A2640();
        v28 = 522;
        v17 = "%s%.30s:%-4d Skipping initialization of NRLinkManagerQuickRelay for unsupported device";
LABEL_23:
        queue = v16;
        _NRLogWithArgs(v16, 0, v17, "", "-[NRLinkDirector setupManagers]_block_invoke_2", v28);
LABEL_18:

      }
    }
    else
    {
      objc_opt_self(NRLinkManagerQuickRelay);
      if (objc_opt_class(IDSService) && objc_opt_class(APSConnection))
      {
        v3 = [NRLinkManagerQuickRelay alloc];
        v4 = *(_QWORD **)(a1 + 32);
        if (v4)
          v4 = (_QWORD *)v4[15];
        v5 = v4;
        v6 = *(void **)(a1 + 32);
        queue = v5;
        v7 = v6;
        if (!v3)
          goto LABEL_33;
        if (queue)
        {
          dispatch_assert_queue_V2(queue);
          if (v7)
          {
            v30.receiver = v3;
            v30.super_class = (Class)NRLinkManagerQuickRelay;
            v8 = (__objc2_prot *)objc_msgSendSuper2(&v30, "initManagerWithQueue:managerDelegate:", queue, v7);
            if (v8)
            {
              v9 = v8;
              LOBYTE(v8->name) = 4;
              v10 = (__objc2_meth_list *)objc_alloc_init((Class)NSMutableSet);
              opt_inst_meths = v9->opt_inst_meths;
              v9->opt_inst_meths = v10;

              objc_storeWeak(&v9[1].isa, v7);
              -[__objc2_prot reportEvent:](v9, "reportEvent:", 2001);
              sub_1000FA078(v9);
              HIDWORD(v9->name) = 1003;
              -[__objc2_prot reportEvent:](v9, "reportEvent:", 2002);
              v3 = v9;
              v12 = v3;
LABEL_15:

              v13 = *(_QWORD *)(a1 + 32);
              if (v13)
                objc_storeStrong((id *)(v13 + 56), v12);

              goto LABEL_18;
            }
            v25 = sub_1000F9858();
            v26 = _NRLogIsLevelEnabled(v25, 17);

            if (v26)
            {
              v27 = sub_1000F9858();
              _NRLogWithArgs(v27, 17, "[NRLinkManager initManagerWithQueue:] failed");

            }
            v3 = 0;
LABEL_33:
            v12 = 0;
            goto LABEL_15;
          }
          v23 = sub_1000F9858();
          v24 = _NRLogIsLevelEnabled(v23, 17);

          if (!v24)
            goto LABEL_33;
          v22 = sub_1000F9858();
          _NRLogWithArgs(v22, 17, "%s called with null managerDelegate");
        }
        else
        {
          v20 = sub_1000F9858();
          v21 = _NRLogIsLevelEnabled(v20, 17);

          if (!v21)
            goto LABEL_33;
          v22 = sub_1000F9858();
          _NRLogWithArgs(v22, 17, "%s called with null queue");
        }

        v12 = 0;
        goto LABEL_15;
      }
      v18 = sub_1000A2640();
      v19 = _NRLogIsLevelEnabled(v18, 0);

      if (v19)
      {
        v16 = sub_1000A2640();
        v28 = 519;
        v17 = "%s%.30s:%-4d Skipping initialization of NRLinkManagerQuickRelay, IDS and/or APS not available";
        goto LABEL_23;
      }
    }
  }
}

void sub_1000AE110(uint64_t a1)
{
  id v2;
  int IsLevelEnabled;
  id v4;

  if (a1)
  {
    objc_opt_self(NRLinkManagerWiFi);
    if (qword_1001E4870 != -1)
      dispatch_once(&qword_1001E4870, &stru_1001B7BB0);
    if (!byte_1001E4868 && qword_1001E4AA8 != -1)
      dispatch_once(&qword_1001E4AA8, &stru_1001B8750);
    if (byte_1001E4AA0 == 1)
    {
      if (!*(_BYTE *)(a1 + 17))
      {
        *(_BYTE *)(a1 + 17) = 1;
        sub_1000AE238((id *)a1, 1);
      }
    }
    else
    {
      v2 = sub_1000A2640();
      IsLevelEnabled = _NRLogIsLevelEnabled(v2, 0);

      if (IsLevelEnabled)
      {
        v4 = sub_1000A2640();
        _NRLogWithArgs(v4, 0, "%s%.30s:%-4d Skipping initialization of NRLinkManagerWiFi for unsupported device", "", "-[NRLinkDirector setupWiFiManager]", 564);

      }
    }
  }
}

void sub_1000AE238(id *a1, int a2)
{
  NRLinkManagerWiFi *v4;
  NSObject *v5;
  id *v6;
  NRLinkManagerWiFi *v7;
  NSMutableSet *v8;
  NSMutableSet *links;
  NSMutableSet *v10;
  NSMutableSet *wifiAutojoinClients;
  NSObject *v12;
  CWFInterface *v13;
  CWFInterface *coreWiFiHandle;
  CWFInterface *v15;
  CWFInterface *v16;
  CWFInterface *v17;
  NRSCDInterfaceConfig *v18;
  id *v19;
  NRSCDInterfaceConfig *wifiInterfaceConfig;
  NRSCDInterfaceConfig *v21;
  unsigned int interfaceIndex;
  SCDynamicStoreRef v23;
  NSString *scdKeyMIS;
  const __SCDynamicStore *scdynamicStoreRef;
  NSObject *v26;
  NSObject *v27;
  char v28;
  id v29;
  int v30;
  id v31;
  id v32;
  int v33;
  NRLinkManagerWiFi *v34;
  id v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  id *v41;
  NSObject *v42;
  id v43;
  int IsLevelEnabled;
  id v45;
  uint64_t v46;
  dispatch_time_t v47;
  NSObject *v48;
  id v49;
  int v50;
  id v51;
  id v52;
  int v53;
  id v54;
  id v55;
  char v56;
  id v57;
  int v58;
  CFErrorRef Error;
  id v60;
  int v61;
  id v62;
  int v63;
  _QWORD v64[5];
  int v65;
  _QWORD v66[5];
  objc_super v67;
  _QWORD v68[4];
  CWFInterface *v69;
  uint64_t *v70;
  uint64_t v71;
  uint64_t *v72;
  uint64_t v73;
  uint64_t (*v74)(uint64_t, uint64_t);
  void (*v75)(uint64_t);
  id v76;
  _QWORD v77[4];
  CWFInterface *v78;
  _QWORD block[5];
  SCDynamicStoreContext context;

  v4 = [NRLinkManagerWiFi alloc];
  v5 = a1[15];
  v6 = a1;
  if (!v4)
  {
LABEL_43:
    v34 = 0;
    goto LABEL_30;
  }
  if (!v5)
  {
    v43 = sub_100140BFC();
    IsLevelEnabled = _NRLogIsLevelEnabled(v43, 17);

    if (IsLevelEnabled)
    {
      v45 = sub_100140BFC();
      _NRLogWithArgs(v45, 17, "%s called with null queue", "-[NRLinkManagerWiFi initManagerWithQueue:managerDelegate:wifiManagerDelegate:]");

      v34 = 0;
      goto LABEL_30;
    }
    goto LABEL_43;
  }
  dispatch_assert_queue_V2(v5);
  v67.receiver = v4;
  v67.super_class = (Class)NRLinkManagerWiFi;
  v7 = (NRLinkManagerWiFi *)objc_msgSendSuper2(&v67, "initManagerWithQueue:managerDelegate:", v5, v6);
  if (!v7)
  {
    v49 = sub_100140BFC();
    v50 = _NRLogIsLevelEnabled(v49, 17);

    if (v50)
    {
      v51 = sub_100140BFC();
      _NRLogWithArgs(v51, 17, "[NRLinkManager initManagerWithQueue:] failed");

    }
    v4 = 0;
    goto LABEL_43;
  }
  v4 = v7;
  objc_storeWeak((id *)&v7->_wifiManagerDelegate, v6);
  v4->super._type = 2;
  v8 = (NSMutableSet *)objc_alloc_init((Class)NSMutableSet);
  links = v4->_links;
  v4->_links = v8;

  v10 = (NSMutableSet *)objc_alloc_init((Class)NSMutableSet);
  wifiAutojoinClients = v4->_wifiAutojoinClients;
  v4->_wifiAutojoinClients = v10;

  v4->_avoidCompanionNotifyToken = -1;
  v12 = v4->super._queue;
  dispatch_assert_queue_V2(v12);

  if (v4->super._state == 1003)
  {
LABEL_29:
    v4 = v4;
    v34 = v4;
    goto LABEL_30;
  }
  -[NRLinkManager reportEvent:](v4, "reportEvent:", 2001);
  v13 = (CWFInterface *)objc_alloc_init((Class)CWFInterface);
  coreWiFiHandle = v4->_coreWiFiHandle;
  v4->_coreWiFiHandle = v13;

  v15 = v4->_coreWiFiHandle;
  v77[0] = _NSConcreteStackBlock;
  v77[1] = 3221225472;
  v77[2] = sub_1001437A4;
  v77[3] = &unk_1001B8AE0;
  v16 = v15;
  v78 = v16;
  if (!sub_1001437AC((uint64_t)NRLinkManagerWiFi, v77))
  {
    v71 = 0;
    v72 = &v71;
    v73 = 0x3032000000;
    v74 = sub_10014387C;
    v75 = sub_10014388C;
    v76 = 0;
    v68[0] = _NSConcreteStackBlock;
    v68[1] = 3221225472;
    v68[2] = sub_100143894;
    v68[3] = &unk_1001B8840;
    v70 = &v71;
    v17 = v16;
    v69 = v17;
    if (sub_1001437AC((uint64_t)NRLinkManagerWiFi, v68))
    {
      v55 = sub_100140BFC();
      v56 = _NRLogIsLevelEnabled(v55, 16);

      if ((v56 & 1) == 0)
        goto LABEL_27;
      v31 = sub_100140BFC();
      _NRLogWithArgs(v31, 16, "%s%.30s:%-4d Timed out getting WiFi interface name", "", "-[NRLinkManagerWiFi setupWiFiManager]", 2156);
    }
    else if (v72[5])
    {
      v18 = [NRSCDInterfaceConfig alloc];
      v19 = sub_10001E9E8((id *)&v18->super.isa, (void *)v72[5], 0);
      wifiInterfaceConfig = v4->_wifiInterfaceConfig;
      v4->_wifiInterfaceConfig = (NRSCDInterfaceConfig *)v19;

      v21 = v4->_wifiInterfaceConfig;
      if (v21 && (interfaceIndex = v21->_interfaceIndex, v21, interfaceIndex))
      {
        context.version = 0;
        memset(&context.retain, 0, 24);
        context.info = v4;
        v23 = SCDynamicStoreCreate(kCFAllocatorDefault, CFSTR("NRLinkManagerWiFi"), (SCDynamicStoreCallBack)sub_1001438CC, &context);
        v4->_scdynamicStoreRef = v23;
        if (v23)
        {
          if (SCDynamicStoreSetDisconnectCallBack(v23, sub_100143918))
          {
            scdKeyMIS = v4->_scdKeyMIS;
            v4->_scdKeyMIS = (NSString *)CFSTR("com.apple.MobileInternetSharing");

            scdynamicStoreRef = v4->_scdynamicStoreRef;
            v26 = v4->super._queue;
            LODWORD(scdynamicStoreRef) = SCDynamicStoreSetDispatchQueue(scdynamicStoreRef, v26);

            if ((_DWORD)scdynamicStoreRef)
            {
              v27 = v4->super._queue;
              block[0] = _NSConcreteStackBlock;
              block[1] = 3221225472;
              block[2] = sub_1001439D8;
              block[3] = &unk_1001B8AE0;
              block[4] = v4;
              dispatch_async(v27, block);

              v4->super._state = 1003;
              -[NRLinkManager reportEvent:](v4, "reportEvent:", 2002);
              v28 = 1;
              goto LABEL_28;
            }
            v62 = sub_100140BFC();
            v63 = _NRLogIsLevelEnabled(v62, 17);

            if (!v63)
            {
LABEL_27:
              v28 = 0;
LABEL_28:

              _Block_object_dispose(&v71, 8);
              if ((v28 & 1) != 0)
                goto LABEL_29;
              goto LABEL_47;
            }
            v31 = sub_100140BFC();
            Error = SCCopyLastError();
            _NRLogWithArgs(v31, 17, "SCDynamicStoreSetDispatchQueue failed: %@", Error);
          }
          else
          {
            v60 = sub_100140BFC();
            v61 = _NRLogIsLevelEnabled(v60, 17);

            if (!v61)
              goto LABEL_27;
            v31 = sub_100140BFC();
            Error = SCCopyLastError();
            _NRLogWithArgs(v31, 17, "SCDynamicStoreSetDisconnectCallBack failed: %@", Error);
          }
        }
        else
        {
          v57 = sub_100140BFC();
          v58 = _NRLogIsLevelEnabled(v57, 17);

          if (!v58)
            goto LABEL_27;
          v31 = sub_100140BFC();
          Error = SCCopyLastError();
          _NRLogWithArgs(v31, 17, "SCDynamicStoreCreate failed: %@", Error);
        }

      }
      else
      {
        if (qword_1001E4AB8 != -1)
          dispatch_once(&qword_1001E4AB8, &stru_1001B8928);
        v32 = (id)qword_1001E4AB0;
        v33 = _NRLogIsLevelEnabled(v32, 17);

        if (!v33)
          goto LABEL_27;
        if (qword_1001E4AB8 != -1)
          dispatch_once(&qword_1001E4AB8, &stru_1001B8928);
        v31 = (id)qword_1001E4AB0;
        _NRLogWithArgs(v31, 17, "failed to find interface index for %@", v72[5]);
      }
    }
    else
    {
      if (qword_1001E4AB8 != -1)
        dispatch_once(&qword_1001E4AB8, &stru_1001B8928);
      v29 = (id)qword_1001E4AB0;
      v30 = _NRLogIsLevelEnabled(v29, 16);

      if (!v30)
        goto LABEL_27;
      if (qword_1001E4AB8 != -1)
        dispatch_once(&qword_1001E4AB8, &stru_1001B8928);
      v31 = (id)qword_1001E4AB0;
      _NRLogWithArgs(v31, 16, "%s%.30s:%-4d [CWFInterface interfaceName] failed", "", "-[NRLinkManagerWiFi setupWiFiManager]", 2161);
    }

    goto LABEL_27;
  }
  v52 = sub_100140BFC();
  v53 = _NRLogIsLevelEnabled(v52, 16);

  if (v53)
  {
    v54 = sub_100140BFC();
    _NRLogWithArgs(v54, 16, "%s%.30s:%-4d Timed out activating CoreWiFi handle", "", "-[NRLinkManagerWiFi setupWiFiManager]", 2147);

  }
LABEL_47:
  -[NRLinkManagerWiFi invalidateManager](v4, "invalidateManager");
  v34 = 0;
LABEL_30:

  v35 = v6[6];
  v6[6] = v34;

  v41 = (id *)v6[6];
  if (v41)
  {
    sub_100149C5C(v41);
    if (v6[29])
    {
      v42 = a1[15];
      v66[0] = _NSConcreteStackBlock;
      v66[1] = 3221225472;
      v66[2] = sub_1000AEA80;
      v66[3] = &unk_1001B8AE0;
      v66[4] = v6;
      dispatch_async(v42, v66);
    }
  }
  else
  {
    if ((2 * a2) >= 0x12C)
      v46 = 300;
    else
      v46 = (2 * a2);
    sub_1000A25C4((uint64_t)v6, 1047, CFSTR("WiFi - Retry in %us (attempt: %u)"), v36, v37, v38, v39, v40, v46);
    v47 = dispatch_time(0, 1000000000 * v46);
    v48 = a1[15];
    v64[0] = _NSConcreteStackBlock;
    v64[1] = 3221225472;
    v64[2] = sub_1000AEBB0;
    v64[3] = &unk_1001B6EB0;
    v64[4] = v6;
    v65 = a2;
    dispatch_after(v47, v48, v64);
  }
}

void sub_1000AEA68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  _Block_object_dispose(&a31, 8);
  _Unwind_Resume(a1);
}

void sub_1000AEA80(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  id v4;
  id v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  void *v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _BYTE v16[128];

  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v2 = *(_QWORD **)(a1 + 32);
  if (v2)
    v2 = (_QWORD *)v2[29];
  v3 = v2;
  v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
  if (v4)
  {
    v5 = v4;
    v6 = *(_QWORD *)v13;
    do
    {
      v7 = 0;
      do
      {
        if (*(_QWORD *)v13 != v6)
          objc_enumerationMutation(v3);
        (*(void (**)(_QWORD))(*(_QWORD *)(*((_QWORD *)&v12 + 1) + 8 * (_QWORD)v7) + 16))(*(_QWORD *)(*((_QWORD *)&v12 + 1) + 8 * (_QWORD)v7));
        v7 = (char *)v7 + 1;
      }
      while (v5 != v7);
      v5 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
    }
    while (v5);
  }

  v8 = *(_QWORD *)(a1 + 32);
  if (v8)
    v9 = *(void **)(v8 + 232);
  else
    v9 = 0;
  objc_msgSend(v9, "removeAllObjects", (_QWORD)v12);
  v10 = *(_QWORD *)(a1 + 32);
  if (v10)
  {
    v11 = *(void **)(v10 + 232);
    *(_QWORD *)(v10 + 232) = 0;

  }
}

uint64_t sub_1000AEBB0(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 32);
  if (result)
  {
    if (*(_BYTE *)(result + 12))
      return sub_1000AE238();
  }
  return result;
}

void sub_1000AEBD4(uint64_t a1)
{
  uint64_t v1;
  NRLinkManagerWired *v3;
  _QWORD *v4;
  id v5;
  uint64_t v6;
  _QWORD *v7;

  v1 = *(_QWORD *)(a1 + 32);
  if (v1 && *(_BYTE *)(v1 + 12))
  {
    v3 = [NRLinkManagerWired alloc];
    v4 = *(_QWORD **)(a1 + 32);
    if (v4)
      v4 = (_QWORD *)v4[15];
    v7 = v4;
    v5 = -[NRLinkManagerWired initManagerWithQueue:managerDelegate:](v3, "initManagerWithQueue:managerDelegate:");
    v6 = *(_QWORD *)(a1 + 32);
    if (v6)
      objc_storeStrong((id *)(v6 + 64), v5);

  }
}

void sub_1000AEC6C(uint64_t a1, void *a2)
{
  NSObject *v3;
  id v4;
  void (**v5)(void);
  void *v6;
  id v7;
  void *v8;
  id v9;
  void (**v10)(void);
  id v11;
  int v12;
  id v13;
  id v14;
  int IsLevelEnabled;
  id v16;
  uint64_t v17;
  char *v18;
  int *v19;
  uint64_t v20;
  id v21;
  void (**v22)(void);

  v22 = a2;
  if (a1)
  {
    v3 = sub_10014CFBC();
    dispatch_assert_queue_V2(v3);

    if (v22)
    {
      v4 = *(id *)(a1 + 48);
      if (v4)
      {

        v5 = v22;
LABEL_14:
        v5[2]();
        goto LABEL_15;
      }
      objc_opt_self(NRLinkManagerWiFi);
      if (qword_1001E4870 != -1)
        dispatch_once(&qword_1001E4870, &stru_1001B7BB0);
      v5 = v22;
      if (!byte_1001E4868 && qword_1001E4AA8 != -1)
      {
        dispatch_once(&qword_1001E4AA8, &stru_1001B8750);
        v5 = v22;
      }
      if ((byte_1001E4AA0 & 1) == 0)
        goto LABEL_14;
      v6 = *(void **)(a1 + 232);
      if (!v6)
      {
        v7 = objc_alloc_init((Class)NSMutableArray);
        v8 = *(void **)(a1 + 232);
        *(_QWORD *)(a1 + 232) = v7;

        v6 = *(void **)(a1 + 232);
        if (!v6)
        {
          v14 = sub_1000A2640();
          IsLevelEnabled = _NRLogIsLevelEnabled(v14, 16);

          if (IsLevelEnabled)
          {
            v16 = sub_1000A2640();
            _NRLogWithArgs(v16, 16, "%s%.30s:%-4d ABORTING: Assertion Failed: (self.wifiManagerAvailableBlocks) != ((void *)0)", "", "-[NRLinkDirector runAfterWiFiManagerAvailable:]", 614);

          }
          v17 = _os_log_pack_size(12);
          v18 = (char *)&v22 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
          v19 = __error();
          v20 = _os_log_pack_fill(v18, v17, *v19, &_mh_execute_header, "%{public}s Assertion Failed: (self.wifiManagerAvailableBlocks) != ((void *)0)");
          *(_DWORD *)v20 = 136446210;
          *(_QWORD *)(v20 + 4) = "-[NRLinkDirector runAfterWiFiManagerAvailable:]";
          v21 = sub_1000A2640();
          _NRLogAbortWithPack(v21, v18);
        }
      }
      v9 = v6;
      v10 = objc_retainBlock(v22);
      objc_msgSend(v9, "addObject:", v10);

    }
    else
    {
      v11 = sub_1000A2640();
      v12 = _NRLogIsLevelEnabled(v11, 17);

      if (v12)
      {
        v13 = sub_1000A2640();
        _NRLogWithArgs(v13, 17, "%s called with null wifiManagerAvailableBlock", "-[NRLinkDirector runAfterWiFiManagerAvailable:]");

      }
    }
  }
LABEL_15:

}

void sub_1000AEEF4(uint64_t a1, int a2, void *a3)
{
  uint64_t v5;
  uint64_t v6;
  void *v7;
  int IsLevelEnabled;
  uint64_t v9;
  void *v10;
  void (*v11)(void);
  int v12;
  uint64_t v13;
  void *v14;
  id v15;

  v15 = a3;
  v6 = _NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v5);
  v7 = (void *)v6;
  if (a2)
  {
    IsLevelEnabled = _NRLogIsLevelEnabled(v6, 1);

    if (IsLevelEnabled)
    {
      v10 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v9);
      _NRLogWithArgs(v10, 1, "%s%.30s:%-4d unpaired BT device %@", "", "-[NRLinkDirector unpairBluetoothDeviceWithNRUUID:completionBlock:]_block_invoke", 764, v15);

    }
    sub_10013E73C((uint64_t)NRDLocalDevice, 0, *(void **)(a1 + 32));
    v11 = *(void (**)(void))(*(_QWORD *)(a1 + 40) + 16);
  }
  else
  {
    v12 = _NRLogIsLevelEnabled(v6, 16);

    if (v12)
    {
      v14 = (void *)_NRCopyLogObjectForNRUUID(*(_QWORD *)(a1 + 32), v13);
      _NRLogWithArgs(v14, 16, "%s%.30s:%-4d failed to unpair BT device", "", "-[NRLinkDirector unpairBluetoothDeviceWithNRUUID:completionBlock:]_block_invoke", 768);

    }
    v11 = *(void (**)(void))(*(_QWORD *)(a1 + 40) + 16);
  }
  v11();

}

void sub_1000AF028(uint64_t a1, int a2)
{
  char v2;
  int v4;
  id v5;
  id v6;
  id v7;
  uint64_t v8;
  void *i;
  uint64_t v10;
  void *v11;
  id v12;
  void *j;
  uint64_t v14;
  void *v15;
  id v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  _BYTE v21[128];

  if (a1)
  {
    v2 = a2;
    if (a2)
      v4 = 10015;
    else
      v4 = 10016;
    sub_100121E18(0, v4, 0, 0);
    v19 = 0u;
    v20 = 0u;
    v17 = 0u;
    v18 = 0u;
    v5 = *(id *)(a1 + 200);
    v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v17, v21, 16);
    if (v6)
    {
      v7 = v6;
      v8 = *(_QWORD *)v18;
      if ((v2 & 1) != 0)
      {
        do
        {
          for (i = 0; i != v7; i = (char *)i + 1)
          {
            if (*(_QWORD *)v18 != v8)
              objc_enumerationMutation(v5);
            v10 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 200), "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v17 + 1) + 8 * (_QWORD)i), (_QWORD)v17));
            v11 = (void *)v10;
            if (v10)
            {
              dispatch_assert_queue_V2(*(dispatch_queue_t *)(v10 + 104));
              v12 = sub_1000D8AA8((uint64_t)v11, 4, 0);
            }
            else
            {
              v12 = 0;
            }

            if (objc_msgSend(v12, "state") == 1)
              objc_msgSend(v12, "start");

          }
          v7 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v17, v21, 16);
        }
        while (v7);
      }
      else
      {
        do
        {
          for (j = 0; j != v7; j = (char *)j + 1)
          {
            if (*(_QWORD *)v18 != v8)
              objc_enumerationMutation(v5);
            v14 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 200), "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v17 + 1) + 8 * (_QWORD)j), (_QWORD)v17));
            v15 = (void *)v14;
            if (v14)
            {
              dispatch_assert_queue_V2(*(dispatch_queue_t *)(v14 + 104));
              v16 = sub_1000D8AA8((uint64_t)v15, 4, 0);
            }
            else
            {
              v16 = 0;
            }

            if (objc_msgSend(v16, "state") != 8)
              objc_msgSend(v16, "cancelWithReason:", CFSTR("Disabled cloud link (via test command)"));

          }
          v7 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v17, v21, 16);
        }
        while (v7);
      }
    }

  }
}

void sub_1000AF264(uint64_t a1, int a2, void *a3, void *a4, void *a5)
{
  id v9;
  id v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  id v16;

  v16 = a3;
  v9 = a4;
  v10 = a5;
  if (a1)
  {
    if (a2)
    {
      if (v16 || v9 || v10)
      {
        sub_1000A0244(0, CFSTR("FixedInterfaceName"), v16);
        sub_1000A0244(0, CFSTR("FixedInterfacePeerAddress"), v9);
        sub_1000A0244(0, CFSTR("FixedInterfacePeerIDSDeviceID"), v10);
        sub_1000A25C4(a1, 1027, CFSTR("interface: %@, peer address: %@, peer IDSDeviceID: %@"), v11, v12, v13, v14, v15, (uint64_t)v16);
      }
      else
      {
        if (qword_1001E4738 != -1)
          dispatch_once(&qword_1001E4738, &stru_1001B7110);
        if (_NRLogIsLevelEnabled(qword_1001E4730, 16))
        {
          if (qword_1001E4738 != -1)
            dispatch_once(&qword_1001E4738, &stru_1001B7110);
          _NRLogWithArgs(qword_1001E4730, 16, "%s%.30s:%-4d Cannot enable fixed-interface mode (interface: %@, peerAddress = %@)", "", "-[NRLinkDirector setFixedInterfaceModeWithEnabled:interfaceName:peerAddress:idsDeviceID:]", 1067, 0, 0);
        }
      }
    }
    else
    {
      sub_1000A04A0(0, CFSTR("FixedInterfaceName"));
      sub_1000A04A0(0, CFSTR("FixedInterfacePeerAddress"));
      sub_1000A04A0(0, CFSTR("FixedInterfacePeerIDSDeviceID"));
      sub_100121E18(0, 1028, 0, 0);
    }
  }

}

void sub_1000AF414(uint64_t a1, void *a2, void *a3)
{
  id v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  id v10;
  NRDOrphanedConnection *v11;
  id *p_isa;
  void *v13;
  id v14;
  int IsLevelEnabled;
  id v16;

  v16 = a2;
  v6 = a3;
  if (a1)
  {
    v7 = sub_10014CFBC();
    dispatch_assert_queue_V2(v7);

    if (v16)
    {
      v8 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 200), "objectForKeyedSubscript:", v6));
      if (v8)
      {
        v9 = v8;
        v10 = v16;
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(v9 + 104));
        objc_msgSend(*(id *)(v9 + 168), "addObject:", v10);

      }
      else
      {
        v11 = objc_alloc_init(NRDOrphanedConnection);
        p_isa = (id *)&v11->super.isa;
        if (v11)
        {
          objc_storeStrong((id *)&v11->_nrUUID, a3);
          objc_storeStrong(p_isa + 2, a2);
        }
        objc_msgSend(*(id *)(a1 + 208), "addObject:", p_isa);
        v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(p_isa, "description"));
        sub_100121E18(0, 1015, 0, v13);

        v9 = 0;
      }
    }
    else
    {
      v14 = sub_1000A2640();
      IsLevelEnabled = _NRLogIsLevelEnabled(v14, 17);

      if (!IsLevelEnabled)
        goto LABEL_9;
      v9 = (uint64_t)sub_1000A2640();
      _NRLogWithArgs(v9, 17, "%s called with null connection", "-[NRLinkDirector addDeviceMonitorConnection:nrUUID:]");
    }

  }
LABEL_9:

}

void sub_1000AF574(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  id v5;
  id v6;
  id v7;
  uint64_t v8;
  void *i;
  uint64_t v10;
  id v11;
  id v12;
  id v13;
  id v14;
  id v15;
  uint64_t v16;
  void *j;
  _QWORD *v18;
  void *v19;
  id v20;
  int IsLevelEnabled;
  id v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  _BYTE v31[128];
  _BYTE v32[128];

  v3 = a2;
  if (a1)
  {
    v4 = sub_10014CFBC();
    dispatch_assert_queue_V2(v4);

    if (v3)
    {
      v29 = 0u;
      v30 = 0u;
      v27 = 0u;
      v28 = 0u;
      v5 = *(id *)(a1 + 200);
      v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v27, v32, 16);
      if (v6)
      {
        v7 = v6;
        v8 = *(_QWORD *)v28;
        do
        {
          for (i = 0; i != v7; i = (char *)i + 1)
          {
            if (*(_QWORD *)v28 != v8)
              objc_enumerationMutation(v5);
            v10 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 200), "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v27 + 1) + 8 * (_QWORD)i)));
            v11 = v3;
            if (v10)
            {
              dispatch_assert_queue_V2(*(dispatch_queue_t *)(v10 + 104));
              objc_msgSend(*(id *)(v10 + 176), "removeObject:", v11);
              if (!objc_msgSend(*(id *)(v10 + 176), "count"))
                sub_1000EEF1C(v10, 0);
            }

          }
          v7 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v27, v32, 16);
        }
        while (v7);
      }

      v12 = objc_msgSend(*(id *)(a1 + 216), "copy");
      v23 = 0u;
      v24 = 0u;
      v25 = 0u;
      v26 = 0u;
      v13 = v12;
      v14 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v23, v31, 16);
      if (v14)
      {
        v15 = v14;
        v16 = *(_QWORD *)v24;
        do
        {
          for (j = 0; j != v15; j = (char *)j + 1)
          {
            if (*(_QWORD *)v24 != v16)
              objc_enumerationMutation(v13);
            v18 = *(_QWORD **)(*((_QWORD *)&v23 + 1) + 8 * (_QWORD)j);
            if (v18 && (id)v18[2] == v3)
            {
              objc_msgSend(*(id *)(a1 + 216), "removeObject:", *(_QWORD *)(*((_QWORD *)&v23 + 1) + 8 * (_QWORD)j));
              v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "description"));
              sub_100121E18(0, 1024, 0, v19);

            }
          }
          v15 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v23, v31, 16);
        }
        while (v15);
      }

    }
    else
    {
      v20 = sub_1000A2640();
      IsLevelEnabled = _NRLogIsLevelEnabled(v20, 17);

      if (IsLevelEnabled)
      {
        v22 = sub_1000A2640();
        _NRLogWithArgs(v22, 17, "%s called with null connection", "-[NRLinkDirector removeDeviceSetupInProgressConnection:]");

      }
    }
  }

}

void sub_1000AF824(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  id v12;
  id v13;
  uint64_t v14;
  id v15;
  id v16;
  NSObject *v17;
  id v18;
  void *v19;
  uint64_t pid;
  id v21;
  NRDOrphanedConnection *v22;
  id *p_isa;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  id v27;
  int IsLevelEnabled;
  id v29;
  int v30;
  id v31;
  _QWORD v32[5];
  char v33;

  v31 = a2;
  v7 = a3;
  v8 = a4;
  if (a1)
  {
    v9 = sub_10014CFBC();
    dispatch_assert_queue_V2(v9);

    if (!v7)
    {
      v27 = sub_1000A2640();
      IsLevelEnabled = _NRLogIsLevelEnabled(v27, 17);

      if (!IsLevelEnabled)
        goto LABEL_25;
      v11 = (uint64_t)sub_1000A2640();
      _NRLogWithArgs(v11, 17, "%s called with null connection");
      goto LABEL_24;
    }
    if (!v8)
    {
      v29 = sub_1000A2640();
      v30 = _NRLogIsLevelEnabled(v29, 17);

      if (!v30)
        goto LABEL_25;
      v11 = (uint64_t)sub_1000A2640();
      _NRLogWithArgs(v11, 17, "%s called with null nrUUID");
      goto LABEL_24;
    }
    v10 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 200), "objectForKeyedSubscript:", v8));
    if (!v10)
    {
      v22 = objc_alloc_init(NRDOrphanedConnection);
      p_isa = (id *)&v22->super.isa;
      if (v22)
      {
        objc_storeStrong((id *)&v22->_nrUUID, a4);
        objc_storeStrong(p_isa + 2, a3);
      }
      objc_msgSend(*(id *)(a1 + 216), "addObject:", p_isa);
      v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(p_isa, "description"));
      sub_100121E18(0, 1022, 0, v24);

      v11 = 0;
      goto LABEL_24;
    }
    v11 = v10;
    v12 = v31;
    v13 = v7;
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v11 + 104));
    v14 = *(_QWORD *)(v11 + 184);
    v15 = v12;
    v16 = v13;
    if (!v14)
    {
LABEL_19:

      if (objc_msgSend(v15, "linkType") == 1)
      {
        if (objc_msgSend(v15, "isNotEmpty"))
        {
          v26 = (*(_QWORD *)(v11 + 592) >> 1) & 1;
          v32[0] = _NSConcreteStackBlock;
          v32[1] = 3221225472;
          v32[2] = sub_1000DA9AC;
          v32[3] = &unk_1001B74A8;
          v33 = v26;
          v32[4] = v11;
          sub_1000D8878(v11, 1, v26, v32);
        }
        else
        {
          sub_1000D8FF0(v11, *(void **)(v11 + 616));
        }
      }

LABEL_24:
      goto LABEL_25;
    }
    v17 = *(NSObject **)(v14 + 24);
    if (v17)
      dispatch_assert_queue_V2(v17);
    v18 = sub_100114EE0(v16);
    v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v14 + 32), "objectForKeyedSubscript:", v18));

    sub_100114D50(v14, v15, v18);
    if (objc_msgSend(v15, "isNotEmpty"))
    {
      pid = xpc_connection_get_pid((xpc_connection_t)v16);
      if ((int)pid < 1)
      {
LABEL_18:

        goto LABEL_19;
      }
      v21 = sub_100109ADC(pid, 0);
      sub_100114B48(v14, v21);
    }
    else
    {
      if (!v19)
        goto LABEL_18;
      v25 = xpc_connection_get_pid((xpc_connection_t)v16);
      if ((int)v25 < 1)
        goto LABEL_18;
      v21 = sub_100109ADC(v25, 0);
      sub_100114C4C(v14, v21);
    }

    goto LABEL_18;
  }
LABEL_25:

}

void sub_1000AFB18(uint64_t a1, void *a2, void *a3)
{
  id *v5;
  id v6;
  NRDEphemeralDevice *v7;
  NSUUID *connection;
  NSUUID *nrUUID;
  OS_xpc_object *v10;
  void *v11;
  id v12;
  id v13;
  id v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  void *v19;
  _QWORD v20[5];
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  _BYTE v25[128];

  v5 = a2;
  v6 = a3;
  if (a1)
  {
    if (v5)
    {
      v7 = objc_alloc_init(NRDEphemeralDevice);
      connection = (NSUUID *)v5[4];
      if (v7)
      {
        nrUUID = v7->super._nrUUID;
        v7->super._nrUUID = connection;

        v10 = (OS_xpc_object *)v6;
        connection = (NSUUID *)v7->super._connection;
        v7->super._connection = v10;
      }

      objc_msgSend(*(id *)(a1 + 224), "addObject:", v7);
      v11 = (void *)objc_claimAutoreleasedReturnValue(-[NRDEphemeralDevice description](v7, "description"));
      sub_100121E18(0, 1041, 0, v11);

      goto LABEL_23;
    }
    if (objc_msgSend(*(id *)(a1 + 224), "count"))
    {
      v12 = objc_msgSend(*(id *)(a1 + 224), "copy");
      v21 = 0u;
      v22 = 0u;
      v23 = 0u;
      v24 = 0u;
      v7 = (NRDEphemeralDevice *)v12;
      v13 = -[NRDEphemeralDevice countByEnumeratingWithState:objects:count:](v7, "countByEnumeratingWithState:objects:count:", &v21, v25, 16);
      if (!v13)
      {
LABEL_22:

LABEL_23:
        goto LABEL_24;
      }
      v14 = v13;
      v15 = *(_QWORD *)v22;
LABEL_10:
      v16 = 0;
      while (1)
      {
        if (*(_QWORD *)v22 != v15)
          objc_enumerationMutation(v7);
        v18 = *(_QWORD **)(*((_QWORD *)&v21 + 1) + 8 * v16);
        if (v18)
        {
          if ((id)v18[2] == v6)
            goto LABEL_18;
        }
        else if (!v6)
        {
LABEL_18:
          objc_msgSend(*(id *)(a1 + 224), "removeObject:", *(_QWORD *)(*((_QWORD *)&v21 + 1) + 8 * v16));
          v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "description"));
          sub_100121E18(0, 1042, 0, v19);

          if (v18)
            v17 = (void *)v18[1];
          else
            v17 = 0;
          v20[0] = _NSConcreteStackBlock;
          v20[1] = 3221225472;
          v20[2] = sub_1000AFD78;
          v20[3] = &unk_1001B7008;
          v20[4] = v18;
          sub_1001370D8((uint64_t)NRDLocalDevice, v17, v20);
        }
        if (v14 == (id)++v16)
        {
          v14 = -[NRDEphemeralDevice countByEnumeratingWithState:objects:count:](v7, "countByEnumeratingWithState:objects:count:", &v21, v25, 16);
          if (!v14)
            goto LABEL_22;
          goto LABEL_10;
        }
      }
    }
  }
LABEL_24:

}

void sub_1000AFD78(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5;
  uint64_t v6;
  id v7;
  id v8;

  v8 = a3;
  if (qword_1001E4738 != -1)
    dispatch_once(&qword_1001E4738, &stru_1001B7110);
  if (_NRLogIsLevelEnabled(qword_1001E4730, 0))
  {
    if (qword_1001E4738 != -1)
      dispatch_once(&qword_1001E4738, &stru_1001B7110);
    v5 = *(_QWORD *)(a1 + 32);
    if (v5)
      v6 = *(_QWORD *)(v5 + 8);
    else
      v6 = 0;
    v7 = (id)qword_1001E4730;
    _NRLogWithArgs(v7, 0, "%s%.30s:%-4d Removed ephemeral device with NRUUID %@ result %lld error %@", "", "-[NRLinkDirector updateEphemeralDevice:forConnection:]_block_invoke", 2293, v6, a2, v8);

  }
}

_QWORD *sub_1000AFE70(_QWORD *a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  void *v6;
  id v7;
  void *v8;
  id v9;
  id v10;
  NSObject *v11;
  _QWORD block[5];

  v3 = a2;
  v4 = v3;
  if (a1)
  {
    v5 = (void *)qword_1001E4728;
    if (qword_1001E4728)
    {
      if (v3)
      {
        (*((void (**)(id))v3 + 2))(v3);
        v5 = (void *)qword_1001E4728;
      }
      a1 = v5;
    }
    else
    {
      if (v3)
      {
        v6 = (void *)a1[39];
        if (!v6)
        {
          v7 = objc_alloc_init((Class)NSMutableArray);
          v8 = (void *)a1[39];
          a1[39] = v7;

          v6 = (void *)a1[39];
        }
        v9 = v6;
        v10 = objc_retainBlock(v4);
        objc_msgSend(v9, "addObject:", v10);

      }
      if (!*((_BYTE *)a1 + 19))
      {
        *((_BYTE *)a1 + 19) = 1;
        if (qword_1001E48F8 != -1)
          dispatch_once(&qword_1001E48F8, &stru_1001B7D20);
        v11 = (id)qword_1001E4900;
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_1000AFFB4;
        block[3] = &unk_1001B8AE0;
        block[4] = a1;
        dispatch_async(v11, block);

      }
      a1 = 0;
    }
  }

  return a1;
}

void sub_1000AFFB4(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  NSObject *v4;
  id v5;
  _QWORD v6[5];
  id v7;

  v2 = (void *)IDSCopyLocalDeviceUniqueID();
  v3 = *(_QWORD *)(a1 + 32);
  if (v3)
    v4 = *(NSObject **)(v3 + 120);
  else
    v4 = 0;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_1000B0040;
  v6[3] = &unk_1001B8778;
  v6[4] = v3;
  v7 = v2;
  v5 = v2;
  dispatch_async(v4, v6);

}

void sub_1000B0040(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  id v5;
  id v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  void *v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  _BYTE v15[128];

  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
    *(_BYTE *)(v2 + 19) = 0;
  objc_storeStrong((id *)&qword_1001E4728, *(id *)(a1 + 40));
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  v3 = *(_QWORD **)(a1 + 32);
  if (v3)
    v3 = (_QWORD *)v3[39];
  v4 = v3;
  v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
  if (v5)
  {
    v6 = v5;
    v7 = *(_QWORD *)v12;
    do
    {
      v8 = 0;
      do
      {
        if (*(_QWORD *)v12 != v7)
          objc_enumerationMutation(v4);
        (*(void (**)(_QWORD))(*(_QWORD *)(*((_QWORD *)&v11 + 1) + 8 * (_QWORD)v8) + 16))(*(_QWORD *)(*((_QWORD *)&v11 + 1) + 8 * (_QWORD)v8));
        v8 = (char *)v8 + 1;
      }
      while (v6 != v8);
      v6 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
    }
    while (v6);
  }

  v9 = *(_QWORD *)(a1 + 32);
  if (v9)
  {
    v10 = *(void **)(v9 + 312);
    *(_QWORD *)(v9 + 312) = 0;

  }
}

void sub_1000B090C(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001E4740;
  qword_1001E4740 = (uint64_t)v1;

}

id sub_1000B093C()
{
  if (qword_1001E4748 != -1)
    dispatch_once(&qword_1001E4748, &stru_1001B7158);
  return (id)qword_1001E4740;
}

void sub_1000B0E2C(uint64_t a1)
{
  _WORD *WeakRetained;
  int v2;
  void *v3;
  unsigned int v4;
  int v5;
  _DWORD v6[2];
  __int16 v7;
  __int16 v8;
  char __strerrbuf[8];
  uint64_t v10;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v5 = 1;
    if (sysctlbyname("net.inet6.ip6.forwarding", 0, 0, &v5, 4uLL))
    {
      v2 = *__error();
      if (strerror_r(v2, __strerrbuf, 0x80uLL))
        __strerrbuf[0] = 0;
      if (qword_1001E4748 != -1)
        dispatch_once(&qword_1001E4748, &stru_1001B7158);
      if (_NRLogIsLevelEnabled(qword_1001E4740, 17))
      {
        if (qword_1001E4748 != -1)
          dispatch_once(&qword_1001E4748, &stru_1001B7158);
        _NRLogWithArgs(qword_1001E4740, 17, "failed to set sysctl net.inet6.ip6.forwarding to 1: [%d] %s", v2, __strerrbuf);
      }
    }
    ++WeakRetained[5];
    v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "instance"));
    if (qword_1001E4748 != -1)
      dispatch_once(&qword_1001E4748, &stru_1001B7158);
    if (_NRLogIsLevelEnabled(qword_1001E4740, 2))
    {
      if (qword_1001E4748 != -1)
        dispatch_once(&qword_1001E4748, &stru_1001B7158);
      _NRLogWithArgs(qword_1001E4740, 2, "%s%.30s:%-4d %@Sending public hello on %@ with seqno %u", "", "-[NRBabelInterface initWithInstance:]_block_invoke", 716, v3, WeakRetained, (unsigned __int16)WeakRetained[5]);
    }
    v4 = bswap32((unsigned __int16)WeakRetained[5]);
    v6[0] = 134218282;
    v6[1] = 1540;
    v7 = HIWORD(v4);
    v8 = 28695;
    *(_QWORD *)__strerrbuf = v6;
    v10 = 12;
    objc_msgSend(WeakRetained, "sendPacket:iovLen:toAddr:", __strerrbuf, 1, &xmmword_10015D020);

  }
}

void sub_1000B3124(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id *location)
{
  id *v15;
  id *v16;
  uint64_t v17;

  objc_destroyWeak(v16);
  objc_destroyWeak(v15);
  objc_destroyWeak(location);
  objc_destroyWeak((id *)(v17 - 248));
  _Unwind_Resume(a1);
}

void sub_1000B3958(uint64_t a1)
{
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  objc_msgSend(WeakRetained, "readPackets");

}

void sub_1000B3984(uint64_t a1)
{
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  objc_msgSend(WeakRetained, "readPackets");

}

void sub_1000B39B0(uint64_t a1, void *a2)
{
  id *v2;
  id v3;
  id WeakRetained;

  v2 = (id *)(a1 + 32);
  v3 = a2;
  WeakRetained = objc_loadWeakRetained(v2);
  objc_msgSend(WeakRetained, "handlePathUpdate:", v3);

}

void sub_1000B6740(uint64_t a1)
{
  id WeakRetained;
  id v2;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v2 = WeakRetained;
    objc_msgSend(WeakRetained, "processPendingOutgoingPackets");
    WeakRetained = v2;
  }

}

void sub_1000B6770(uint64_t a1)
{
  id WeakRetained;
  id v2;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v2 = WeakRetained;
    objc_msgSend(WeakRetained, "updateRXCostCheckTime:personal:", 1, 0);
    WeakRetained = v2;
  }

}

void sub_1000B67A8(uint64_t a1)
{
  id WeakRetained;
  id v2;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v2 = WeakRetained;
    objc_msgSend(WeakRetained, "updateRXCostCheckTime:personal:", 1, 1);
    WeakRetained = v2;
  }

}

void sub_1000B67E0(uint64_t a1)
{
  id WeakRetained;
  void *v2;
  unsigned int v3;
  int IsLevelEnabled;
  id v5;
  void *v6;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v2 = WeakRetained;
  if (WeakRetained)
  {
    v6 = WeakRetained;
    v3 = objc_msgSend(WeakRetained, "txcost");
    v2 = v6;
    if (v3 != 0xFFFF)
    {
      if (qword_1001E4748 != -1)
        dispatch_once(&qword_1001E4748, &stru_1001B7158);
      IsLevelEnabled = _NRLogIsLevelEnabled(qword_1001E4740, 1);
      v2 = v6;
      if (IsLevelEnabled)
      {
        if (qword_1001E4748 != -1)
          dispatch_once(&qword_1001E4748, &stru_1001B7158);
        v5 = (id)qword_1001E4740;
        _NRLogWithArgs(v5, 1, "%s%.30s:%-4d incomingIHUTimer fired for %@, previous txcost was %u", "", "-[NRBabelNeighbor initWithAddress:babelInterface:]_block_invoke_4", 1709, v6, objc_msgSend(v6, "txcost"));

        v2 = v6;
      }
    }
  }

}

void sub_1000B7040(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000B715C(uint64_t a1)
{
  id WeakRetained;
  void *v2;
  void *v3;
  void *v4;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v4 = WeakRetained;
    if (qword_1001E4748 != -1)
      dispatch_once(&qword_1001E4748, &stru_1001B7158);
    if (_NRLogIsLevelEnabled(qword_1001E4740, 1))
    {
      if (qword_1001E4748 != -1)
        dispatch_once(&qword_1001E4748, &stru_1001B7158);
      _NRLogWithArgs(qword_1001E4740, 1, "%s%.30s:%-4d removing old source %@", "", "-[NRBabelSource setupGCTimer]_block_invoke", 1977, v4);
    }
    v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "instance"));
    v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "sources"));
    objc_msgSend(v3, "removeObject:", v4);

    WeakRetained = v4;
  }

}

void sub_1000B764C(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 112));
  _Unwind_Resume(a1);
}

uint64_t sub_1000B7ED0(uint64_t a1)
{
  uint64_t result;

  if (qword_1001E4748 != -1)
    dispatch_once(&qword_1001E4748, &stru_1001B7158);
  if (_NRLogIsLevelEnabled(qword_1001E4740, 1))
  {
    if (qword_1001E4748 != -1)
      dispatch_once(&qword_1001E4748, &stru_1001B7158);
    _NRLogWithArgs(qword_1001E4740, 1, "%s%.30s:%-4d %@ running <<%@>>", "", "-[NRBabelRoute applyUsingSystem]_block_invoke", 2198, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
  }
  system((const char *)objc_msgSend(*(id *)(a1 + 40), "UTF8String"));
  if (qword_1001E4748 != -1)
    dispatch_once(&qword_1001E4748, &stru_1001B7158);
  result = _NRLogIsLevelEnabled(qword_1001E4740, 1);
  if ((_DWORD)result)
  {
    if (qword_1001E4748 != -1)
      dispatch_once(&qword_1001E4748, &stru_1001B7158);
    return _NRLogWithArgs(qword_1001E4740, 1, "%s%.30s:%-4d %@ done running cmd", "", "-[NRBabelRoute applyUsingSystem]_block_invoke", 2200, *(_QWORD *)(a1 + 32));
  }
  return result;
}

void sub_1000B8024(uint64_t a1)
{
  id WeakRetained;
  void *v2;
  void *v3;
  void *v4;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v4 = WeakRetained;
    if (objc_msgSend(WeakRetained, "metric") == 0xFFFF)
    {
      if (qword_1001E4748 != -1)
        dispatch_once(&qword_1001E4748, &stru_1001B7158);
      if (_NRLogIsLevelEnabled(qword_1001E4740, 1))
      {
        if (qword_1001E4748 != -1)
          dispatch_once(&qword_1001E4748, &stru_1001B7158);
        _NRLogWithArgs(qword_1001E4740, 1, "%s%.30s:%-4d removing old route %@", "", "-[NRBabelRoute initWithPrefix:neighbor:routerID:seqno:interval:receivedMetric:nextHop:instance:]_block_invoke", 2085, v4);
      }
      v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "instance"));
      v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "routes"));
      objc_msgSend(v3, "removeObject:", v4);

    }
    else
    {
      if (qword_1001E4748 != -1)
        dispatch_once(&qword_1001E4748, &stru_1001B7158);
      if (_NRLogIsLevelEnabled(qword_1001E4740, 1))
      {
        if (qword_1001E4748 != -1)
          dispatch_once(&qword_1001E4748, &stru_1001B7158);
        _NRLogWithArgs(qword_1001E4740, 1, "%s%.30s:%-4d making old route unfeasible %@", "", "-[NRBabelRoute initWithPrefix:neighbor:routerID:seqno:interval:receivedMetric:nextHop:instance:]_block_invoke", 2081, v4);
      }
      objc_msgSend(v4, "setNumExpiryTimerFires:", (unsigned __int16)((unsigned __int16)objc_msgSend(v4, "numExpiryTimerFires") + 1));
      objc_msgSend(v4, "resetExpiryTimer");
    }
    WeakRetained = v4;
  }

}

void sub_1000B8F98(uint64_t a1)
{
  __int16 *WeakRetained;
  unsigned __int8 v3;
  int v4;
  __int16 *v5;

  WeakRetained = (__int16 *)objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    v5 = WeakRetained;
    v3 = objc_msgSend(*(id *)(a1 + 32), "cancelIfRouteUnselected");
    WeakRetained = v5;
    if ((v3 & 1) == 0)
    {
      v4 = v5[6];
      if (v4 < 1)
      {
        objc_msgSend(v5, "cancelWithDelay:", v4 == 0);
        WeakRetained = v5;
      }
      else
      {
        objc_msgSend(v5, "sendSeqnoReq");
        WeakRetained = v5;
        --v5[6];
      }
    }
  }

}

void sub_1000B99D8(_Unwind_Exception *a1)
{
  uint64_t v1;
  id *v2;

  objc_destroyWeak(v2);
  objc_destroyWeak((id *)(v1 + 56));
  _Unwind_Resume(a1);
}

uint64_t sub_1000BF404(unsigned __int8 *a1, int a2)
{
  unsigned __int8 *v2;
  unint64_t v3;
  int v4;
  uint64_t v5;
  id v6;
  int IsLevelEnabled;
  id v8;

  if (!a1)
  {
    v6 = sub_1000B093C();
    IsLevelEnabled = _NRLogIsLevelEnabled(v6, 17);

    if (IsLevelEnabled)
    {
      v8 = sub_1000B093C();
      _NRLogWithArgs(v8, 17, "%s called with null tlvTrailer", "nrBabelTLVHasUnknownMandatoryTLV");

    }
    return 0;
  }
  if (!a2)
    return 0;
  v2 = a1;
  v3 = (unint64_t)&a1[a2];
  while (1)
  {
    v4 = *v2;
    if (!*v2)
    {
      ++v2;
      goto LABEL_5;
    }
    if ((v4 & 0x80) != 0)
      break;
    if ((unint64_t)(v2 + 1) >= v3)
    {
      if (qword_1001E4748 != -1)
        dispatch_once(&qword_1001E4748, &stru_1001B7158);
      if (_NRLogIsLevelEnabled(qword_1001E4740, 16))
      {
        if (qword_1001E4748 != -1)
          dispatch_once(&qword_1001E4748, &stru_1001B7158);
        _NRLogWithArgs(qword_1001E4740, 16, "%s%.30s:%-4d Sub-TLV length hanging off edge of TLV trailer");
      }
      return 1;
    }
    v2 += v2[1] + 2;
    if ((unint64_t)v2 > v3)
    {
      if (qword_1001E4748 != -1)
        dispatch_once(&qword_1001E4748, &stru_1001B7158);
      if (_NRLogIsLevelEnabled(qword_1001E4740, 16))
      {
        if (qword_1001E4748 != -1)
          dispatch_once(&qword_1001E4748, &stru_1001B7158);
        _NRLogWithArgs(qword_1001E4740, 16, "%s%.30s:%-4d Sub-TLV body hanging off edge of TLV trailer");
      }
      return 1;
    }
    if (qword_1001E4748 != -1)
      dispatch_once(&qword_1001E4748, &stru_1001B7158);
    if (_NRLogIsLevelEnabled(qword_1001E4740, 1))
    {
      if (qword_1001E4748 != -1)
        dispatch_once(&qword_1001E4748, &stru_1001B7158);
      _NRLogWithArgs(qword_1001E4740, 1, "%s%.30s:%-4d Found unknown non-mandatory Sub-TLV %u", "", "nrBabelTLVHasUnknownMandatoryTLV", 2380, v4);
    }
LABEL_5:
    if ((unint64_t)v2 >= v3)
      return 0;
  }
  if (qword_1001E4748 != -1)
    dispatch_once(&qword_1001E4748, &stru_1001B7158);
  v5 = 1;
  if (_NRLogIsLevelEnabled(qword_1001E4740, 1))
  {
    if (qword_1001E4748 != -1)
      dispatch_once(&qword_1001E4748, &stru_1001B7158);
    _NRLogWithArgs(qword_1001E4740, 1, "%s%.30s:%-4d Found unknown mandatory Sub-TLV %u", "", "nrBabelTLVHasUnknownMandatoryTLV", 2363, v4);
  }
  return v5;
}

uint64_t sub_1000BF6E4(_QWORD *a1, int a2, void *__src, unsigned int a4, size_t __n, char *a6, unsigned __int8 *a7)
{
  unsigned int v9;
  uint64_t result;
  id v14;
  char *v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  unsigned __int8 v19;
  id v20;
  int v21;
  id v22;
  char *v23;
  unsigned int v24;
  id v25;
  int IsLevelEnabled;
  __int128 v27;

  if (!a2)
  {
    result = 0;
    *a1 = 0;
    a1[1] = 0;
    return result;
  }
  v9 = __n;
  if (a7 && *a7 >= 0x81u)
  {
    if (qword_1001E4748 != -1)
      dispatch_once(&qword_1001E4748, &stru_1001B7158);
    if (_NRLogIsLevelEnabled(qword_1001E4740, 16))
    {
      if (qword_1001E4748 != -1)
        dispatch_once(&qword_1001E4748, &stru_1001B7158);
      _NRLogWithArgs(qword_1001E4740, 16, "%s%.30s:%-4d got plen too high %u");
    }
    return 0xFFFFFFFFLL;
  }
  if ((_DWORD)__n && !a6)
  {
    if (qword_1001E4748 != -1)
      dispatch_once(&qword_1001E4748, &stru_1001B7158);
    if (_NRLogIsLevelEnabled(qword_1001E4740, 16))
    {
      if (qword_1001E4748 != -1)
        dispatch_once(&qword_1001E4748, &stru_1001B7158);
      _NRLogWithArgs(qword_1001E4740, 16, "%s%.30s:%-4d prevAddr is NULL");
    }
    return 0xFFFFFFFFLL;
  }
  v27 = 0uLL;
  switch(a2)
  {
    case 1:
      if (a7 && *a7 >= 0x21u)
      {
        if (qword_1001E4748 != -1)
          dispatch_once(&qword_1001E4748, &stru_1001B7158);
        if (_NRLogIsLevelEnabled(qword_1001E4740, 16))
        {
          v14 = sub_1000B093C();
          _NRLogWithArgs(v14, 16, "%s%.30s:%-4d got IPv4 plen too high %u", "", "nrBabelDecompressAddress", 2275, *a7);

        }
        return 0xFFFFFFFFLL;
      }
      WORD5(v27) = -1;
      v15 = (char *)&v27 + 12;
      a6 += 12;
      v16 = 32;
      if (a7)
        goto LABEL_31;
      break;
    case 2:
      v15 = (char *)&v27;
      v16 = 128;
      if (a7)
LABEL_31:
        v16 = *a7;
      break;
    case 3:
      LOWORD(v27) = -32514;
      v15 = (char *)&v27 + 8;
      a6 += 8;
      v16 = 64;
      if (a7)
        goto LABEL_31;
      break;
    default:
      if (qword_1001E4748 != -1)
        dispatch_once(&qword_1001E4748, &stru_1001B7158);
      if (!_NRLogIsLevelEnabled(qword_1001E4740, 16))
        return 0xFFFFFFFFLL;
      v22 = sub_1000B093C();
      _NRLogWithArgs(v22, 16, "%s%.30s:%-4d invalid AE %u");
      goto LABEL_69;
  }
  v17 = v16 >> 3;
  if (v16 >> 3 < __n)
  {
    if (qword_1001E4748 != -1)
      dispatch_once(&qword_1001E4748, &stru_1001B7158);
    if (_NRLogIsLevelEnabled(qword_1001E4740, 16))
    {
      if (qword_1001E4748 != -1)
        dispatch_once(&qword_1001E4748, &stru_1001B7158);
      _NRLogWithArgs(qword_1001E4740, 16, "%s%.30s:%-4d AE %u omitted %u > plenBytes %u", "");
    }
    return 0xFFFFFFFFLL;
  }
  v18 = v16 & 7;
  if (v17 > __n)
  {
    if (!__src)
    {
      v25 = sub_1000B093C();
      IsLevelEnabled = _NRLogIsLevelEnabled(v25, 16);

      if (IsLevelEnabled)
      {
        v22 = sub_1000B093C();
        _NRLogWithArgs(v22, 16, "%s%.30s:%-4d currentAddr is NULL");
        goto LABEL_69;
      }
      return 0xFFFFFFFFLL;
    }
    if ((v16 & 7) != 0)
      v19 = (v16 >> 3) - __n + 1;
    else
      v19 = (v16 >> 3) - __n;
    if (a4 < v19)
    {
      v20 = sub_1000B093C();
      v21 = _NRLogIsLevelEnabled(v20, 16);

      if (v21)
      {
        v22 = sub_1000B093C();
        _NRLogWithArgs(v22, 16, "%s%.30s:%-4d currentAddr is not long enough");
LABEL_69:

        return 0xFFFFFFFFLL;
      }
      return 0xFFFFFFFFLL;
    }
  }
  if ((_DWORD)__n)
    memcpy(v15, a6, __n);
  v23 = &v15[v9];
  if (v17 <= v9)
  {
    v24 = 0;
  }
  else
  {
    v24 = v17 - v9;
    memcpy(v23, __src, (int)(v17 - v9));
  }
  if (v18)
  {
    v23[v17] = *((_BYTE *)__src + (int)(v17 - v9)) & (-1 << (8 - v18));
    ++v24;
  }
  if (a2 == 1 && a7)
    *a7 += 96;
  *(_OWORD *)a1 = v27;
  if (v24 > a4)
    return 0xFFFFFFFFLL;
  else
    return v24;
}

void sub_1000BFBD8(uint64_t a1)
{
  uint64_t v2;
  NRBabelPrefix *v3;
  NRBabelSourceLocal *v4;
  uint64_t v5;
  uint64_t v6;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24);
  v5 = 65021;
  v6 = v2;
  v3 = -[NRBabelPrefix initWithPrefix:plen:]([NRBabelPrefix alloc], "initWithPrefix:plen:", &v5, 128);
  v4 = [NRBabelSourceLocal alloc];

  objc_msgSend(*(id *)(a1 + 32), "setupAddress:", &v5);
  objc_msgSend(*(id *)(a1 + 32), "setupInterfaces");

}

void sub_1000BFC78(uint64_t a1, void *a2)
{
  id *v2;
  id v3;
  id WeakRetained;

  v2 = (id *)(a1 + 32);
  v3 = a2;
  WeakRetained = objc_loadWeakRetained(v2);
  objc_msgSend(WeakRetained, "handleIfBringupPathUpdate:", v3);

}

void sub_1000C072C(uint64_t a1)
{
  void *v2;
  void *v3;
  id v4;
  void *v5;
  id v6;

  v2 = *(void **)(a1 + 32);
  v3 = *(void **)(a1 + 48);
  v4 = *(id *)(a1 + 40);
  v6 = v2;
  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "instance"));
  objc_msgSend(v5, "handlePacket:length:remoteAddr:localAddr:babelInterface:dtls:", objc_msgSend(v6, "bytes"), *(unsigned int *)(a1 + 64), objc_msgSend(v4, "localAddress"), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 48), 0);

}

void sub_1000C07C8(uint64_t a1)
{
  void *v2;
  id v3;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "interfaces"));
  objc_msgSend(v2, "addObject:", *(_QWORD *)(a1 + 40));

  v3 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "fakeInterfaces"));
  objc_msgSend(v3, "addObject:", *(_QWORD *)(a1 + 40));

}

void sub_1000C17B8(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_destroyWeak((id *)(v1 - 72));
  _Unwind_Resume(a1);
}

void sub_1000C1B78(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 56));
  _Unwind_Resume(a1);
}

void sub_1000C244C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id *location, id *a17)
{
  id *v17;
  id *v18;
  id *v19;
  id *v20;
  id *v21;
  uint64_t v22;

  objc_destroyWeak(v21);
  objc_destroyWeak(v20);
  objc_destroyWeak(v19);
  objc_destroyWeak(v18);
  objc_destroyWeak(v17);
  objc_destroyWeak(location);
  objc_destroyWeak(a17);
  objc_destroyWeak((id *)(v22 - 112));
  _Unwind_Resume(a1);
}

void sub_1000C2BD0(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_destroyWeak((id *)(v1 - 40));
  _Unwind_Resume(a1);
}

void sub_1000C38AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000C39E8(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 24));
  _Unwind_Resume(a1);
}

void sub_1000C3DE8(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 64));
  _Unwind_Resume(a1);
}

void sub_1000C43B8(uint64_t a1)
{
  _BYTE *WeakRetained;
  _BYTE *v2;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v2 = WeakRetained;
    if (WeakRetained[208])
      objc_msgSend(WeakRetained, "upgradeSessionsIfNeeded");
    else
      objc_msgSend(WeakRetained, "setupIPsecIfNecessary:", 3);
    WeakRetained = v2;
  }

}

void sub_1000C440C(uint64_t a1)
{
  unsigned __int8 *WeakRetained;
  char *v2;
  void *v3;
  id v4;
  void *v5;
  void *v6;
  _QWORD v7[4];
  id v8;
  id location;
  id v10;

  WeakRetained = (unsigned __int8 *)objc_loadWeakRetained((id *)(a1 + 32));
  v2 = (char *)WeakRetained;
  if (WeakRetained && WeakRetained[16] != 255 && *(_QWORD *)(WeakRetained + 239))
  {
    objc_initWeak(&location, WeakRetained);
    v3 = *(void **)(v2 + 239);
    v4 = sub_100112E3C();
    v10 = v4;
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v10, 1));
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "queue"));
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    v7[2] = sub_1000C4584;
    v7[3] = &unk_1001B7978;
    objc_copyWeak(&v8, &location);
    objc_msgSend(v3, "sendPrivateNotifies:maxRetries:retryIntervalInMilliseconds:callbackQueue:callback:", v5, 10, 1000, v6, v7);

    objc_destroyWeak(&v8);
    objc_destroyWeak(&location);
  }

}

void sub_1000C4558(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000C4584(uint64_t a1, int a2)
{
  _QWORD *WeakRetained;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  int IsLevelEnabled;
  uint64_t v8;
  void *v9;
  id v10;
  int v11;
  uint64_t v12;
  void *v13;
  id v14;
  _QWORD *v15;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v15 = WeakRetained;
    v5 = _NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    v6 = (void *)v5;
    if (a2)
    {
      IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0);

      if (IsLevelEnabled)
      {
        v9 = (void *)_NRCopyLogObjectForNRUUID(v15[4], v8);
        v10 = objc_msgSend(v15, "copyDescription");
        _NRLogWithArgs(v9, 0, "%s%.30s:%-4d %@: Received response to classC unlock", "", "-[NRLinkWired sendClassCUnlockedNotify]_block_invoke_2", 915, v10);

      }
      objc_msgSend(v15, "setSentLocalClassCUnlockNotify:", 1);
      objc_msgSend(v15, "upgradeSessionsIfNeeded");
      goto LABEL_8;
    }
    v11 = _NRLogIsLevelEnabled(v5, 16);

    WeakRetained = v15;
    if (v11)
    {
      v13 = (void *)_NRCopyLogObjectForNRUUID(v15[4], v12);
      v14 = objc_msgSend(v15, "copyDescription");
      _NRLogWithArgs(v13, 16, "%s%.30s:%-4d %@: Did not receive response to classC unlock", "", "-[NRLinkWired sendClassCUnlockedNotify]_block_invoke_2", 919, v14);

LABEL_8:
      WeakRetained = v15;
    }
  }

}

id sub_1000C46B8()
{
  if (qword_1001E4758 != -1)
    dispatch_once(&qword_1001E4758, &stru_1001B7378);
  return (id)qword_1001E4750;
}

void sub_1000C46F8(uint64_t a1, int a2)
{
  _QWORD *WeakRetained;
  BOOL v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  int IsLevelEnabled;
  uint64_t v9;
  void *v10;
  id v11;
  int v12;
  uint64_t v13;
  _QWORD *v14;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v14 = WeakRetained;
    v4 = objc_msgSend(WeakRetained, "state") == 255;
    WeakRetained = v14;
    if (!v4)
    {
      v6 = _NRCopyLogObjectForNRUUID(v14[4], v5);
      v7 = (void *)v6;
      if (a2)
      {
        IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0);

        WeakRetained = v14;
        if (IsLevelEnabled)
        {
          v10 = (void *)_NRCopyLogObjectForNRUUID(v14[4], v9);
          v11 = objc_msgSend(v14, "copyDescription");
          _NRLogWithArgs(v10, 0, "%s%.30s:%-4d %@: Received response to control notify", "", "-[NRLinkWired sendControlData:]_block_invoke", 866, v11);
LABEL_8:

          WeakRetained = v14;
        }
      }
      else
      {
        v12 = _NRLogIsLevelEnabled(v6, 16);

        WeakRetained = v14;
        if (v12)
        {
          v10 = (void *)_NRCopyLogObjectForNRUUID(v14[4], v13);
          v11 = objc_msgSend(v14, "copyDescription");
          _NRLogWithArgs(v10, 16, "%s%.30s:%-4d %@: Did not receive response to control notify", "", "-[NRLinkWired sendControlData:]_block_invoke", 868, v11);
          goto LABEL_8;
        }
      }
    }
  }

}

void sub_1000C4818(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001E4750;
  qword_1001E4750 = (uint64_t)v1;

}

void sub_1000C4848(uint64_t a1)
{
  id WeakRetained;
  BOOL v3;
  id v4;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v4 = WeakRetained;
    v3 = objc_msgSend(WeakRetained, "state") == 255;
    WeakRetained = v4;
    if (!v3)
    {
      objc_msgSend(v4, "setupIPsecIfNecessary:", *(unsigned __int8 *)(a1 + 40));
      WeakRetained = v4;
    }
  }

}

void sub_1000C489C(uint64_t a1, uint64_t a2, void *a3)
{
  _QWORD *WeakRetained;
  _QWORD *v6;
  void *v7;
  id v8;
  int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  void *SessionStateString;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  int IsLevelEnabled;
  uint64_t v21;
  void *v22;
  id v23;
  void *v24;
  int v25;
  uint64_t v26;
  void *v27;
  id v28;
  int v29;
  uint64_t v30;
  void *v31;
  int v32;
  uint64_t v33;
  void *v34;
  id v35;
  int v36;
  uint64_t v37;
  void *v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;
  int v43;
  uint64_t v44;
  void *v45;
  id v46;
  uint64_t v47;
  void *v48;
  int v49;
  uint64_t v50;
  void *v51;
  id v52;
  void *v53;
  void *v54;
  void *v55;
  char *v56;
  char *v57;
  void *v58;
  id v59;
  NRCompanionProxyAgent *v60;
  void *v61;
  void *v62;
  id *v63;
  void *v64;
  void *v65;
  uint64_t v66;
  char v67;
  uint64_t v68;
  int v69;
  uint64_t v70;
  void *v71;
  int v72;
  uint64_t v73;
  void *v74;
  id v75;
  id v76;

  v76 = a3;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  v6 = WeakRetained;
  if (WeakRetained)
  {
    v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "linkDelegate"));
    v8 = v76;
    if (v76)
    {
      v9 = *(unsigned __int8 *)(a1 + 56);
      if (v9 == 4
        || v9 == 3
        && (objc_msgSend(v6, "setIkeClassCEstablished:", 0),
            v10 = objc_msgSend(v6, "onlyAllowClassC"),
            v8 = v76,
            v10))
      {
        objc_msgSend(v6, "setIkeClassDEstablished:", 0, v8);
        v8 = v76;
      }
      objc_msgSend(v6, "processIKEDisconnection:error:", *(unsigned __int8 *)(a1 + 56), v8);
      if (objc_msgSend(v6, "state") != 255)
      {
        v11 = *(_QWORD *)(a1 + 32);
        v12 = *(_QWORD *)(a1 + 40);
        SessionStateString = (void *)NEIKEv2CreateSessionStateString(a2);
        objc_msgSend(v6, "reportEvent:detailsFormat:", 3018, CFSTR("%@ session %@ got IKE error %@ with state %@"), v11, v12, v76, SessionStateString);

LABEL_9:
        objc_msgSend(v6, "restartIKESessionForDataProtectionClass:", *(unsigned __int8 *)(a1 + 56));
      }
    }
    else
    {
      v14 = *(_QWORD *)(a1 + 32);
      v15 = *(_QWORD *)(a1 + 40);
      v16 = (void *)NEIKEv2CreateSessionStateString(a2);
      objc_msgSend(v6, "reportEvent:detailsFormat:", 3009, CFSTR("%@ session %@ changed state to %@"), v14, v15, v16);

      switch(a2)
      {
        case 1:
          if (objc_msgSend(v6, "state") == 1)
          {
            v19 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v18);
            IsLevelEnabled = _NRLogIsLevelEnabled(v19, 0);

            if (IsLevelEnabled)
            {
              v22 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v21);
              v23 = objc_msgSend(v6, "copyDescription");
              _NRLogWithArgs(v22, 0, "%s%.30s:%-4d %@: %@ IKE %@ now connecting", "", "-[NRLinkWired setupIKECallbacks:]_block_invoke", 413, v23, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));

            }
            objc_msgSend(v6, "changeStateTo:", 5);
          }
          else
          {
            v39 = objc_msgSend(v6, "state");
            v41 = _NRCopyLogObjectForNRUUID(v6[4], v40);
            v42 = (void *)v41;
            if (v39 == 5)
            {
              v43 = _NRLogIsLevelEnabled(v41, 0);

              if (!v43)
                break;
              v45 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v44);
              v46 = objc_msgSend(v6, "copyDescription");
              _NRLogWithArgs(v45, 0, "%s%.30s:%-4d %@: %@ IKE %@ already connecting", "", "-[NRLinkWired setupIKECallbacks:]_block_invoke", 416, v46, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
            }
            else
            {
              v69 = _NRLogIsLevelEnabled(v41, 16);

              if (!v69)
                break;
              v45 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v70);
              v46 = objc_msgSend(v6, "copyDescription");
              _NRLogWithArgs(v45, 16, "%s%.30s:%-4d %@: %@ IKE %@ connecting but weird state", "", "-[NRLinkWired setupIKECallbacks:]_block_invoke", 418, v46, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
            }

          }
          break;
        case 2:
          v24 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v17);
          v25 = _NRLogIsLevelEnabled(v24, 0);

          if (v25)
          {
            v27 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v26);
            v28 = objc_msgSend(v6, "copyDescription");
            _NRLogWithArgs(v27, 0, "%s%.30s:%-4d %@: %@ IKE %@ now connected from started", "", "-[NRLinkWired setupIKECallbacks:]_block_invoke", 421, v28, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));

          }
          v29 = *(unsigned __int8 *)(a1 + 56);
          if (v29 == 4
            || v29 == 3
            && (objc_msgSend(v6, "setIkeClassCEstablished:", 1), objc_msgSend(v6, "onlyAllowClassC")))
          {
            objc_msgSend(v6, "setIkeClassDEstablished:", 1);
          }
          if (objc_msgSend(v6, "state") == 8)
          {
            v31 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v30);
            v32 = _NRLogIsLevelEnabled(v31, 0);

            if (v32)
            {
              v34 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v33);
              v35 = objc_msgSend(v6, "copyDescription");
              _NRLogWithArgs(v34, 0, "%s%.30s:%-4d %@: %@ IKE %@ already ready", "", "-[NRLinkWired setupIKECallbacks:]_block_invoke", 432, v35, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));

            }
            objc_msgSend(v7, "linkIsReady:", v6);
          }
          else
          {
            if (objc_msgSend(v6, "state") != 5)
            {
              v48 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v47);
              v49 = _NRLogIsLevelEnabled(v48, 0);

              if (v49)
              {
                v51 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v50);
                v52 = objc_msgSend(v6, "copyDescription");
                _NRLogWithArgs(v51, 0, "%s%.30s:%-4d %@: %@ IKE %@ ready but weird state", "", "-[NRLinkWired setupIKECallbacks:]_block_invoke", 436, v52, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));

              }
            }
            objc_msgSend(v6, "changeStateTo:", 8);
            objc_msgSend(v7, "linkIsReady:", v6);
            if (objc_msgSend(v6, "shouldCreateCompanionProxyAgent"))
            {
              v53 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "companionProxyAgent"));

              if (!v53)
              {
                v54 = (void *)NEVirtualInterfaceCopyName(objc_msgSend(v6, "virtualInterface"));
                v55 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "nrUUID"));
                v56 = sub_10012FFF4((uint64_t)NRDLocalDevice, v55);
                v57 = v56;
                if (v56)
                  v58 = (void *)*((_QWORD *)v56 + 14);
                else
                  v58 = 0;
                v59 = v58;

                if (v54 && v59)
                {
                  v60 = [NRCompanionProxyAgent alloc];
                  v61 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "queue"));
                  v62 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "nrUUID"));
                  v63 = sub_10005E2AC((id *)&v60->super.isa, v61, v54, v59, v62);
                  v64 = (void *)v6[11];
                  v6[11] = v63;

                  objc_msgSend(v6, "reportEvent:", 12001);
                }

              }
              v65 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "companionProxyAgent"));
              v67 = sub_10005E5B8((uint64_t)v65, v66);

              if ((v67 & 1) != 0)
              {
                objc_msgSend(v6, "reportEvent:", 12002);
              }
              else
              {
                v71 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v68);
                v72 = _NRLogIsLevelEnabled(v71, 16);

                if (v72)
                {
                  v74 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v73);
                  v75 = objc_msgSend(v6, "copyDescription");
                  _NRLogWithArgs(v74, 16, "%s%.30s:%-4d %@: failed to register companion agent", "", "-[NRLinkWired setupIKECallbacks:]_block_invoke", 453, v75);

                }
              }
            }
          }
          objc_msgSend(v6, "sendClassCUnlockedNotify");
          break;
        case 3:
          v36 = *(unsigned __int8 *)(a1 + 56);
          if (v36 == 4
            || v36 == 3
            && (objc_msgSend(v6, "setIkeClassCEstablished:", 0), objc_msgSend(v6, "onlyAllowClassC")))
          {
            objc_msgSend(v6, "setIkeClassDEstablished:", 0);
          }
          objc_msgSend(v6, "reportEvent:detailsFormat:", 3018, CFSTR("%@ session %@ cancelled by peer"), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
          goto LABEL_9;
        case 4:
          objc_msgSend(v6, "cancelWithReason:", CFSTR("%@ session %@ got unexpected MOBIKE state"), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
          break;
        default:
          v37 = *(_QWORD *)(a1 + 32);
          v38 = (void *)NEIKEv2CreateSessionStateString(a2);
          objc_msgSend(v6, "cancelWithReason:", CFSTR("%@ session %@ got bad IKE state %@"), v37, v38);

          break;
      }
    }

  }
}

void sub_1000C4FC0(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id WeakRetained;
  uint64_t v8;
  uint64_t v9;
  void *SessionStateString;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  id v14;

  v14 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    if (v14)
    {
      v8 = *(_QWORD *)(a1 + 32);
      v9 = *(_QWORD *)(a1 + 40);
      SessionStateString = (void *)NEIKEv2CreateSessionStateString(a3);
      objc_msgSend(WeakRetained, "reportEvent:detailsFormat:", 3018, CFSTR("%@ session %@ got child %u state update %@ error %@"), v8, v9, a2, SessionStateString, v14);

      objc_msgSend(WeakRetained, "processIKEDisconnection:error:", *(unsigned __int8 *)(a1 + 56), v14);
      if (objc_msgSend(WeakRetained, "state") == 255)
        goto LABEL_9;
    }
    else
    {
      v11 = *(_QWORD *)(a1 + 32);
      v12 = *(_QWORD *)(a1 + 40);
      if (a3 != 3)
      {
        v13 = (void *)NEIKEv2CreateSessionStateString(a3);
        objc_msgSend(WeakRetained, "reportEvent:detailsFormat:", 3009, CFSTR("%@ session %@ child %u state update %@"), v11, v12, a2, v13);

        goto LABEL_9;
      }
      objc_msgSend(WeakRetained, "reportEvent:detailsFormat:", 3018, CFSTR("%@ session %@ got child %u Disconnected state with no error"), v11, *(_QWORD *)(a1 + 40), a2);
    }
    objc_msgSend(WeakRetained, "restartIKESessionForDataProtectionClass:", *(unsigned __int8 *)(a1 + 56));
  }
LABEL_9:

}

void sub_1000C50E4(uint64_t a1, void *a2)
{
  _QWORD *WeakRetained;
  uint64_t v4;
  _QWORD *v5;
  void *v6;
  int IsLevelEnabled;
  uint64_t v8;
  void *v9;
  id v10;
  id v11;

  v11 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  v5 = WeakRetained;
  if (WeakRetained)
  {
    v6 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0);

    if (IsLevelEnabled)
    {
      v9 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v8);
      v10 = objc_msgSend(v5, "copyDescription");
      _NRLogWithArgs(v9, 0, "%s%.30s:%-4d %@: %@ session %@ got config update %@", "", "-[NRLinkWired setupIKECallbacks:]_block_invoke_3", 518, v10, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), v11);

    }
  }

}

void sub_1000C51B0(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v7;
  _QWORD *WeakRetained;
  uint64_t v9;
  _QWORD *v10;
  void *v11;
  int IsLevelEnabled;
  uint64_t v13;
  void *v14;
  id v15;
  id v16;

  v16 = a3;
  v7 = a4;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  v10 = WeakRetained;
  if (WeakRetained)
  {
    v11 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v9);
    IsLevelEnabled = _NRLogIsLevelEnabled(v11, 0);

    if (IsLevelEnabled)
    {
      v14 = (void *)_NRCopyLogObjectForNRUUID(v10[4], v13);
      v15 = objc_msgSend(v10, "copyDescription");
      _NRLogWithArgs(v14, 0, "%s%.30s:%-4d %@: %@ session %@ got child %u traffic selector update local %@ remote %@", "", "-[NRLinkWired setupIKECallbacks:]_block_invoke_4", 529, v15, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), a2, v16, v7);

    }
  }

}

void sub_1000C529C(uint64_t a1, void *a2)
{
  _QWORD *WeakRetained;
  uint64_t v4;
  _QWORD *v5;
  void *v6;
  int IsLevelEnabled;
  uint64_t v8;
  void *v9;
  id v10;
  id v11;

  v11 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  v5 = WeakRetained;
  if (WeakRetained)
  {
    v6 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0);

    if (IsLevelEnabled)
    {
      v9 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v8);
      v10 = objc_msgSend(v5, "copyDescription");
      _NRLogWithArgs(v9, 0, "%s%.30s:%-4d %@: %@ session %@ got additional addresses %@", "", "-[NRLinkWired setupIKECallbacks:]_block_invoke_5", 538, v10, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), v11);

    }
  }

}

void sub_1000C5368(uint64_t a1)
{
  _QWORD *WeakRetained;
  uint64_t v3;
  void *v4;
  int IsLevelEnabled;
  uint64_t v6;
  void *v7;
  id v8;
  _QWORD *v9;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    v9 = WeakRetained;
    v4 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v3);
    IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0);

    WeakRetained = v9;
    if (IsLevelEnabled)
    {
      v7 = (void *)_NRCopyLogObjectForNRUUID(v9[4], v6);
      v8 = objc_msgSend(v9, "copyDescription");
      _NRLogWithArgs(v7, 0, "%s%.30s:%-4d %@: %@ session %@ got short DPD", "", "-[NRLinkWired setupIKECallbacks:]_block_invoke_6", 546, v8, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));

      WeakRetained = v9;
    }
  }

}

void sub_1000C5428(uint64_t a1, void *a2)
{
  id v3;
  _QWORD *WeakRetained;
  id v5;
  void *v6;
  void *v7;
  uint64_t v8;
  void *v9;
  int IsLevelEnabled;
  uint64_t v11;
  void *v12;
  id v13;
  id v14;
  id v15;
  id v16;
  uint64_t v17;
  void *i;
  void *v19;
  id v20;
  void *v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  _BYTE v26[128];
  id v27;

  v3 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    v5 = objc_msgSend(objc_alloc((Class)NSSortDescriptor), "initWithKey:ascending:", CFSTR("notifyStatus"), 1);
    v27 = v5;
    v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v27, 1));
    v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "sortedArrayUsingDescriptors:", v6));

    v9 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v8);
    IsLevelEnabled = _NRLogIsLevelEnabled(v9, 0);

    if (IsLevelEnabled)
    {
      v12 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v11);
      v13 = objc_msgSend(WeakRetained, "copyDescription");
      _NRLogWithArgs(v12, 0, "%s%.30s:%-4d %@: %@ session %@ got private notifies %@", "", "-[NRLinkWired setupIKECallbacks:]_block_invoke_7", 558, v13, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), v7);

    }
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    v14 = v7;
    v15 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v22, v26, 16);
    if (v15)
    {
      v16 = v15;
      v17 = *(_QWORD *)v23;
      do
      {
        for (i = 0; i != v16; i = (char *)i + 1)
        {
          if (*(_QWORD *)v23 != v17)
            objc_enumerationMutation(v14);
          v19 = *(void **)(*((_QWORD *)&v22 + 1) + 8 * (_QWORD)i);
          v20 = objc_msgSend(v19, "notifyStatus");
          v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "notifyData"));
          objc_msgSend(WeakRetained, "handleNotifyCode:payload:", v20, v21);

        }
        v16 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v22, v26, 16);
      }
      while (v16);
    }

  }
}

void sub_1000C5654(uint64_t a1, int a2)
{
  id WeakRetained;
  BOOL v4;
  uint64_t v5;
  void *v6;
  int IsLevelEnabled;
  uint64_t v8;
  void *v9;
  id v10;
  void *v11;
  id v12;
  id v13;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v13 = WeakRetained;
    v4 = objc_msgSend(WeakRetained, "state") == 255;
    WeakRetained = v13;
    if (!v4)
    {
      *((_BYTE *)v13 + 83) = 0;
      v6 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v13 + 4), v5);
      IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0);

      if (!a2)
      {
        if (IsLevelEnabled)
        {
          v11 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v13 + 4), v8);
          v12 = objc_msgSend(v13, "copyDescription");
          _NRLogWithArgs(v11, 0, "%s%.30s:%-4d %@: peer is NOT available", "", "-[NRLinkWired checkPeerAvailabilityWithForceAggressive:]_block_invoke", 304, v12);

        }
        objc_msgSend(v13, "cancelWithReason:", CFSTR("Dead Peer Detection"));
        goto LABEL_9;
      }
      WeakRetained = v13;
      if (IsLevelEnabled)
      {
        v9 = (void *)_NRCopyLogObjectForNRUUID(*((_QWORD *)v13 + 4), v8);
        v10 = objc_msgSend(v13, "copyDescription");
        _NRLogWithArgs(v9, 0, "%s%.30s:%-4d %@: peer is available", "", "-[NRLinkWired checkPeerAvailabilityWithForceAggressive:]_block_invoke", 302, v10);

LABEL_9:
        WeakRetained = v13;
      }
    }
  }

}

id sub_1000C5790(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "setupIPsecIfNecessary:", 3);
}

void sub_1000C579C(uint64_t a1, int a2, unsigned int a3)
{
  id WeakRetained;
  void *v7;
  unsigned int v8;
  id v9;
  id v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  id v14;
  void *v15;
  uint64_t v16;
  __CFString *v17;
  void *v18;
  int IsLevelEnabled;
  uint64_t v20;
  void *v21;
  id v22;
  _QWORD *v23;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v7 = WeakRetained;
  if (WeakRetained)
  {
    v23 = WeakRetained;
    v8 = objc_msgSend(WeakRetained, "state");
    v7 = v23;
    if (v8 != 255)
    {
      v9 = objc_loadWeakRetained((id *)(a1 + 40));
      if (!v9)
        goto LABEL_30;
      v10 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v23, "pairingClient"));

      if (v10 != v9)
        goto LABEL_30;
      v11 = objc_claimAutoreleasedReturnValue(objc_msgSend(v23, "pairingClient"));
      v12 = (void *)v11;
      if (v11)
        v13 = *(_QWORD *)(v11 + 48);
      else
        LOBYTE(v13) = 0;
      v14 = objc_alloc_init((Class)NSMutableString);
      v15 = v14;
      if ((v13 & 1) != 0)
      {
        objc_msgSend(v14, "appendFormat:", CFSTR("PairingSessionConnected | "));
        if ((v13 & 2) == 0)
        {
LABEL_9:
          if ((v13 & 4) == 0)
            goto LABEL_10;
          goto LABEL_17;
        }
      }
      else if ((v13 & 2) == 0)
      {
        goto LABEL_9;
      }
      objc_msgSend(v15, "appendFormat:", CFSTR("ClassDVerified | "));
      if ((v13 & 4) == 0)
      {
LABEL_10:
        if ((v13 & 8) == 0)
          goto LABEL_11;
        goto LABEL_18;
      }
LABEL_17:
      objc_msgSend(v15, "appendFormat:", CFSTR("ClassCVerified | "));
      if ((v13 & 8) == 0)
      {
LABEL_11:
        if ((v13 & 0x10) == 0)
          goto LABEL_12;
        goto LABEL_19;
      }
LABEL_18:
      objc_msgSend(v15, "appendFormat:", CFSTR("ClassAVerified | "));
      if ((v13 & 0x10) == 0)
      {
LABEL_12:

        if (a3)
        {
LABEL_13:
          if (a3 > 8)
            v17 = CFSTR("None");
          else
            v17 = *(&off_1001B5DF8 + (a3 - 1));
          objc_msgSend(v23, "cancelWithReason:", CFSTR("pairing client error: %@ mask: %@"), v17, v15);
LABEL_29:

LABEL_30:
          v7 = v23;
          goto LABEL_31;
        }
LABEL_20:
        if ((a2 - 1) > 6)
          v17 = CFSTR("Invalid");
        else
          v17 = *(&off_1001B5E38 + (a2 - 1));
        v18 = (void *)_NRCopyLogObjectForNRUUID(v23[4], v16);
        IsLevelEnabled = _NRLogIsLevelEnabled(v18, 0);

        if (IsLevelEnabled)
        {
          v21 = (void *)_NRCopyLogObjectForNRUUID(v23[4], v20);
          v22 = objc_msgSend(v23, "copyDescription");
          _NRLogWithArgs(v21, 0, "%s%.30s:%-4d %@: pairing client state: %@ mask: %@", "", "-[NRLinkWired initiatePairing]_block_invoke", 236, v22, v17, v15);

        }
        if (a2 == 5)
          objc_msgSend(v23, "initiateConnection");
        goto LABEL_29;
      }
LABEL_19:
      objc_msgSend(v15, "appendFormat:", CFSTR("PairingCompleted | "));

      if (a3)
        goto LABEL_13;
      goto LABEL_20;
    }
  }
LABEL_31:

}

